   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"base64.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.base64_encode_block,"ax",%progbits
  19              		.align	1
  20              		.global	base64_encode_block
  21              		.thumb
  22              		.thumb_func
  24              	base64_encode_block:
  25              	.LFB0:
  26              		.file 1 "base64/base64.c"
   1:base64/base64.c **** /*  Copyright (c) 2006-2008, Philip Busch <philip@0xe3.com>
   2:base64/base64.c ****  *  All rights reserved.
   3:base64/base64.c ****  *
   4:base64/base64.c ****  *  Redistribution and use in source and binary forms, with or without
   5:base64/base64.c ****  *  modification, are permitted provided that the following conditions are met:
   6:base64/base64.c ****  *
   7:base64/base64.c ****  *   - Redistributions of source code must retain the above copyright notice,
   8:base64/base64.c ****  *     this list of conditions and the following disclaimer.
   9:base64/base64.c ****  *   - Redistributions in binary form must reproduce the above copyright
  10:base64/base64.c ****  *     notice, this list of conditions and the following disclaimer in the
  11:base64/base64.c ****  *     documentation and/or other materials provided with the distribution.
  12:base64/base64.c ****  *
  13:base64/base64.c ****  *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  14:base64/base64.c ****  *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  15:base64/base64.c ****  *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  16:base64/base64.c ****  *  ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  17:base64/base64.c ****  *  LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  18:base64/base64.c ****  *  CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  19:base64/base64.c ****  *  SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  20:base64/base64.c ****  *  INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  21:base64/base64.c ****  *  CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  22:base64/base64.c ****  *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  23:base64/base64.c ****  *  POSSIBILITY OF SUCH DAMAGE.
  24:base64/base64.c ****  */
  25:base64/base64.c **** 
  26:base64/base64.c **** /**
  27:base64/base64.c ****  * @file
  28:base64/base64.c ****  * Base64 implementation.
  29:base64/base64.c ****  * @ingroup base64
  30:base64/base64.c ****  */
  31:base64/base64.c **** 
  32:base64/base64.c **** #include <math.h>
  33:base64/base64.c **** #include <stdio.h>
  34:base64/base64.c **** #include <stdlib.h>
  35:base64/base64.c **** #include <string.h>
  36:base64/base64.c **** #include "base64.h"
  37:base64/base64.c **** 
  38:base64/base64.c **** #define XX 100
  39:base64/base64.c **** 
  40:base64/base64.c **** /** @var base64_list
  41:base64/base64.c ****  *   A 64 character alphabet.
  42:base64/base64.c ****  *
  43:base64/base64.c ****  *   A 64-character subset of International Alphabet IA5, enabling
  44:base64/base64.c ****  *   6 bits to be represented per printable character.  (The proposed
  45:base64/base64.c ****  *   subset of characters is represented identically in IA5 and ASCII.)
  46:base64/base64.c ****  *   The character "=" signifies a special processing function used for
  47:base64/base64.c ****  *   padding within the printable encoding procedure.
  48:base64/base64.c ****  *
  49:base64/base64.c ****  *   VERIZON_SPECIFIC_NOTE:   This verison has been modified to perform the
  50:base64/base64.c ****  *                            first part of url-safe encoding as per RFC4648
  51:base64/base64.c ****  *                            We do not include padding in our output.
  52:base64/base64.c ****  *
  53:base64/base64.c ****  *                            The second characer value in the following table
  54:base64/base64.c ****  *                            represents the url safe character that is used.
  55:base64/base64.c ****  *
  56:base64/base64.c ****  *   \verbatim
  57:base64/base64.c ****     Value Encoding  Value Encoding  Value Encoding  Value Encoding
  58:base64/base64.c ****        0 A            17 R            34 i            51 z
  59:base64/base64.c ****        1 B            18 S            35 j            52 0
  60:base64/base64.c ****        2 C            19 T            36 k            53 1
  61:base64/base64.c ****        3 D            20 U            37 l            54 2
  62:base64/base64.c ****        4 E            21 V            38 m            55 3
  63:base64/base64.c ****        5 F            22 W            39 n            56 4
  64:base64/base64.c ****        6 G            23 X            40 o            57 5
  65:base64/base64.c ****        7 H            24 Y            41 p            58 6
  66:base64/base64.c ****        8 I            25 Z            42 q            59 7
  67:base64/base64.c ****        9 J            26 a            43 r            60 8
  68:base64/base64.c ****       10 K            27 b            44 s            61 9
  69:base64/base64.c ****       11 L            28 c            45 t            62 + -
  70:base64/base64.c ****       12 M            29 d            46 u            63 / _
  71:base64/base64.c ****       13 N            30 e            47 v
  72:base64/base64.c ****       14 O            31 f            48 w         (pad) =
  73:base64/base64.c ****       15 P            32 g            49 x
  74:base64/base64.c ****       16 Q            33 h            50 y
  75:base64/base64.c ****     \endverbatim
  76:base64/base64.c ****  */
  77:base64/base64.c **** static const char base64_list[] = \
  78:base64/base64.c ****         "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  79:base64/base64.c **** static const char url_safe_base64_list[] = \
  80:base64/base64.c ****         "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
  81:base64/base64.c **** 
  82:base64/base64.c **** static const int base64_index[256] = {
  83:base64/base64.c ****     XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
  84:base64/base64.c ****     XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
  85:base64/base64.c ****     XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,62, XX,62,XX,63,
  86:base64/base64.c ****     52,53,54,55, 56,57,58,59, 60,61,XX,XX, XX,XX,XX,XX,
  87:base64/base64.c ****     XX, 0, 1, 2,  3, 4, 5, 6,  7, 8, 9,10, 11,12,13,14,
  88:base64/base64.c ****     15,16,17,18, 19,20,21,22, 23,24,25,XX, XX,XX,XX,63,
  89:base64/base64.c ****     XX,26,27,28, 29,30,31,32, 33,34,35,36, 37,38,39,40,
  90:base64/base64.c ****     41,42,43,44, 45,46,47,48, 49,50,51,XX, XX,XX,XX,XX,
  91:base64/base64.c ****     XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
  92:base64/base64.c ****     XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
  93:base64/base64.c ****     XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
  94:base64/base64.c ****     XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
  95:base64/base64.c ****     XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
  96:base64/base64.c ****     XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
  97:base64/base64.c ****     XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
  98:base64/base64.c ****     XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX, XX,XX,XX,XX,
  99:base64/base64.c **** };
 100:base64/base64.c **** 
 101:base64/base64.c **** /** Encode a minimal memory block. This function encodes a minimal memory area
 102:base64/base64.c ****  *  of three bytes into a printable base64-format sequence of four bytes.
 103:base64/base64.c ****  *  It is mainly used in more convenient functions, see below.
 104:base64/base64.c ****  *
 105:base64/base64.c ****  * @attention This function can't check if there's enough space at the memory
 106:base64/base64.c ****  *            memory location pointed to by \c out, so be careful.
 107:base64/base64.c ****  *
 108:base64/base64.c ****  * @param out pointer to destination
 109:base64/base64.c ****  * @param in pointer to source
 110:base64/base64.c ****  * @param len input size in bytes (between 0 and 3)
 111:base64/base64.c ****  * @param charset the base64 character set to use (e.g. urlsafe, regular)
 112:base64/base64.c ****  * @returns nothing
 113:base64/base64.c ****  *
 114:base64/base64.c ****  * @ingroup base64
 115:base64/base64.c ****  */
 116:base64/base64.c **** void base64_encode_block(unsigned char out[4], const unsigned char in[3], const size_t len, const c
 117:base64/base64.c **** {
  27              		.loc 1 117 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 30B5     		push	{r4, r5, lr}
  33              		.cfi_def_cfa_offset 12
  34              		.cfi_offset 4, -12
  35              		.cfi_offset 5, -8
  36              		.cfi_offset 14, -4
 118:base64/base64.c ****         out[0] = charset[ in[0] >> 2 ];
  37              		.loc 1 118 0
  38 0002 0C78     		ldrb	r4, [r1]	@ zero_extendqisi2
 119:base64/base64.c ****         out[1] = charset[ ((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
 120:base64/base64.c **** 
 121:base64/base64.c ****         if (len > 1)
  39              		.loc 1 121 0
  40 0004 012A     		cmp	r2, #1
 118:base64/base64.c ****         out[0] = charset[ in[0] >> 2 ];
  41              		.loc 1 118 0
  42 0006 4FEA9404 		lsr	r4, r4, #2
  43 000a 1C5D     		ldrb	r4, [r3, r4]	@ zero_extendqisi2
  44 000c 0470     		strb	r4, [r0]
 119:base64/base64.c ****         out[1] = charset[ ((in[0] & 0x03) << 4) | ((in[1] & 0xf0) >> 4) ];
  45              		.loc 1 119 0
  46 000e 0D78     		ldrb	r5, [r1]	@ zero_extendqisi2
  47 0010 4C78     		ldrb	r4, [r1, #1]	@ zero_extendqisi2
  48 0012 05F00305 		and	r5, r5, #3
  49 0016 4FEA1414 		lsr	r4, r4, #4
  50 001a 44EA0514 		orr	r4, r4, r5, lsl #4
  51 001e 1C5D     		ldrb	r4, [r3, r4]	@ zero_extendqisi2
  52 0020 4470     		strb	r4, [r0, #1]
  53              		.loc 1 121 0
  54 0022 10D9     		bls	.L1
  55              	.LVL1:
  56              	.LBB2:
 122:base64/base64.c ****         {
 123:base64/base64.c ****                 unsigned char in_2 = 0;
 124:base64/base64.c ****                 if (len > 2)
  57              		.loc 1 124 0
  58 0024 022A     		cmp	r2, #2
  59 0026 05D0     		beq	.L4
 125:base64/base64.c ****                 {
 126:base64/base64.c ****                         in_2 = in[2];
  60              		.loc 1 126 0
  61 0028 8A78     		ldrb	r2, [r1, #2]	@ zero_extendqisi2
  62              	.LVL2:
 127:base64/base64.c ****                         out[3] = charset[in_2 & 0x3f];
  63              		.loc 1 127 0
  64 002a 02F03F04 		and	r4, r2, #63
  65 002e 1C5D     		ldrb	r4, [r3, r4]	@ zero_extendqisi2
  66 0030 C470     		strb	r4, [r0, #3]
  67              	.LVL3:
  68 0032 00E0     		b	.L3
  69              	.LVL4:
  70              	.L4:
 123:base64/base64.c ****                 unsigned char in_2 = 0;
  71              		.loc 1 123 0
  72 0034 0022     		movs	r2, #0
  73              	.LVL5:
  74              	.L3:
 128:base64/base64.c ****                 }
 129:base64/base64.c ****                 out[2] = charset[ ((in[1] & 0x0f) << 2) | ((in_2 & 0xc0) >> 6) ];
  75              		.loc 1 129 0
  76 0036 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
  77              	.LVL6:
  78 0038 01F00F01 		and	r1, r1, #15
  79 003c 8900     		lsls	r1, r1, #2
  80 003e 41EA9212 		orr	r2, r1, r2, lsr #6
  81              	.LVL7:
  82 0042 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
  83              	.LVL8:
  84 0044 8370     		strb	r3, [r0, #2]
  85              	.L1:
  86 0046 30BD     		pop	{r4, r5, pc}
  87              	.LBE2:
  88              		.cfi_endproc
  89              	.LFE0:
  91              		.section	.text.base64_decode_block,"ax",%progbits
  92              		.align	1
  93              		.global	base64_decode_block
  94              		.thumb
  95              		.thumb_func
  97              	base64_decode_block:
  98              	.LFB1:
 130:base64/base64.c ****         }
 131:base64/base64.c **** }
 132:base64/base64.c **** 
 133:base64/base64.c **** /** Decode a minimal memory block. This function decodes a minimal memory area
 134:base64/base64.c ****  *  of four bytes into its decoded equivalent. It is mainly used in more
 135:base64/base64.c ****  *  convenient functions, see below.
 136:base64/base64.c ****  *
 137:base64/base64.c ****  * @attention This function can't check if there's enough space at the memory
 138:base64/base64.c ****  *            memory location pointed to by \c out, so be careful.
 139:base64/base64.c ****  *
 140:base64/base64.c ****  * @param out pointer to destination
 141:base64/base64.c ****  * @param in pointer to source
 142:base64/base64.c ****  * @param len input size in bytes (between 1 and 4)
 143:base64/base64.c ****  * @returns -1 on error (illegal character) or the number of bytes decoded
 144:base64/base64.c ****  *
 145:base64/base64.c ****  * @ingroup base64
 146:base64/base64.c ****  */
 147:base64/base64.c **** int base64_decode_block(unsigned char out[3], const unsigned char in[4], const size_t len)
 148:base64/base64.c **** {
  99              		.loc 1 148 0
 100              		.cfi_startproc
 101              		@ args = 0, pretend = 0, frame = 8
 102              		@ frame_needed = 0, uses_anonymous_args = 0
 103              	.LVL9:
 149:base64/base64.c ****         int i, numbytes = len-1;
 104              		.loc 1 149 0
 105 0000 531E     		subs	r3, r2, #1
 106              	.LVL10:
 148:base64/base64.c **** {
 107              		.loc 1 148 0
 108 0002 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 109              		.cfi_def_cfa_offset 32
 110              		.cfi_offset 0, -32
 111              		.cfi_offset 1, -28
 112              		.cfi_offset 2, -24
 113              		.cfi_offset 4, -20
 114              		.cfi_offset 5, -16
 115              		.cfi_offset 6, -12
 116              		.cfi_offset 7, -8
 117              		.cfi_offset 14, -4
 118              		.loc 1 149 0
 119 0004 1C46     		mov	r4, r3
 120              	.LVL11:
 121              	.L7:
 150:base64/base64.c ****         char tmp[4];
 151:base64/base64.c **** 
 152:base64/base64.c ****         for(i = len-1; i >= 0; i--) {
 122              		.loc 1 152 0 discriminator 1
 123 0006 002B     		cmp	r3, #0
 124 0008 10DB     		blt	.L14
 153:base64/base64.c ****                 if(in[i] == '=') {
 125              		.loc 1 153 0
 126 000a CE5C     		ldrb	r6, [r1, r3]	@ zero_extendqisi2
 127 000c 01AD     		add	r5, sp, #4
 128 000e 3D2E     		cmp	r6, #61
 129 0010 03D1     		bne	.L8
 154:base64/base64.c ****                         tmp[i] = 0;
 130              		.loc 1 154 0
 131 0012 0024     		movs	r4, #0
 132 0014 EC54     		strb	r4, [r5, r3]
 133 0016 5C1E     		subs	r4, r3, #1
 134              	.LVL12:
 135 0018 03E0     		b	.L9
 136              	.LVL13:
 137              	.L8:
 155:base64/base64.c ****                         numbytes = i - 1;
 156:base64/base64.c ****                 } else {
 157:base64/base64.c ****                         tmp[i] = base64_index[ in[i] ];
 138              		.loc 1 157 0
 139 001a 134F     		ldr	r7, .L15
 140 001c 57F82660 		ldr	r6, [r7, r6, lsl #2]
 141 0020 EE54     		strb	r6, [r5, r3]
 142              	.L9:
 158:base64/base64.c ****                 }
 159:base64/base64.c **** 
 160:base64/base64.c ****                 if(tmp[i] == XX)
 143              		.loc 1 160 0
 144 0022 ED5C     		ldrb	r5, [r5, r3]	@ zero_extendqisi2
 145 0024 642D     		cmp	r5, #100
 146 0026 18D0     		beq	.L12
 152:base64/base64.c ****         for(i = len-1; i >= 0; i--) {
 147              		.loc 1 152 0
 148 0028 013B     		subs	r3, r3, #1
 149              	.LVL14:
 150 002a ECE7     		b	.L7
 151              	.L14:
 161:base64/base64.c ****                         return(-1);
 162:base64/base64.c ****         }
 163:base64/base64.c **** 
 164:base64/base64.c ****         out[0] = (unsigned char) (  tmp[0] << 2 | tmp[1] >> 4);
 152              		.loc 1 164 0
 153 002c 9DF80510 		ldrb	r1, [sp, #5]	@ zero_extendqisi2
 154              	.LVL15:
 155 0030 9DF80450 		ldrb	r5, [sp, #4]	@ zero_extendqisi2
 156 0034 0B09     		lsrs	r3, r1, #4
 157              	.LVL16:
 158 0036 43EA8503 		orr	r3, r3, r5, lsl #2
 159 003a 0370     		strb	r3, [r0]
 165:base64/base64.c ****         out[1] = (unsigned char) (  tmp[1] << 4 | tmp[2] >> 2);
 160              		.loc 1 165 0
 161 003c 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 166:base64/base64.c ****         if (len > 3)
 162              		.loc 1 166 0
 163 0040 032A     		cmp	r2, #3
 165:base64/base64.c ****         out[1] = (unsigned char) (  tmp[1] << 4 | tmp[2] >> 2);
 164              		.loc 1 165 0
 165 0042 4FEA9305 		lsr	r5, r3, #2
 166 0046 45EA0111 		orr	r1, r5, r1, lsl #4
 167 004a 4170     		strb	r1, [r0, #1]
 168              		.loc 1 166 0
 169 004c 08D9     		bls	.L13
 167:base64/base64.c ****                 out[2] = (unsigned char) (((tmp[2] << 6) & 0xc0) | tmp[3]);
 170              		.loc 1 167 0
 171 004e 9DF80720 		ldrb	r2, [sp, #7]	@ zero_extendqisi2
 172              	.LVL17:
 173 0052 42EA8313 		orr	r3, r2, r3, lsl #6
 174 0056 8370     		strb	r3, [r0, #2]
 175 0058 02E0     		b	.L13
 176              	.LVL18:
 177              	.L12:
 161:base64/base64.c ****                         return(-1);
 178              		.loc 1 161 0
 179 005a 4FF0FF30 		mov	r0, #-1
 180              	.LVL19:
 181 005e 00E0     		b	.L10
 182              	.LVL20:
 183              	.L13:
 184 0060 2046     		mov	r0, r4
 185              	.LVL21:
 186              	.L10:
 168:base64/base64.c **** 
 169:base64/base64.c ****         return(numbytes);
 170:base64/base64.c **** }
 187              		.loc 1 170 0
 188 0062 03B0     		add	sp, sp, #12
 189              		@ sp needed
 190 0064 F0BD     		pop	{r4, r5, r6, r7, pc}
 191              	.L16:
 192 0066 00BF     		.align	2
 193              	.L15:
 194 0068 00000000 		.word	.LANCHOR0
 195              		.cfi_endproc
 196              	.LFE1:
 198              		.global	__aeabi_ui2d
 199              		.global	__aeabi_dmul
 200              		.global	__aeabi_ddiv
 201              		.global	__aeabi_d2uiz
 202              		.section	.text.base64_encoded_size,"ax",%progbits
 203              		.align	1
 204              		.global	base64_encoded_size
 205              		.thumb
 206              		.thumb_func
 208              	base64_encoded_size:
 209              	.LFB2:
 171:base64/base64.c **** 
 172:base64/base64.c **** /** Compute size of needed storage for encoding. This function computes the
 173:base64/base64.c ****  *  \e exact size of a memory area needed to hold the result of an encoding
 174:base64/base64.c ****  *  operation, not including the terminating null character.
 175:base64/base64.c ****  *
 176:base64/base64.c ****  * @param len input size
 177:base64/base64.c ****  * @returns output size
 178:base64/base64.c ****  *
 179:base64/base64.c ****  * @ingroup base64
 180:base64/base64.c ****  */
 181:base64/base64.c **** size_t base64_encoded_size(const size_t len)
 182:base64/base64.c **** {
 210              		.loc 1 182 0
 211              		.cfi_startproc
 212              		@ args = 0, pretend = 0, frame = 0
 213              		@ frame_needed = 0, uses_anonymous_args = 0
 214              	.LVL22:
 215 0000 08B5     		push	{r3, lr}
 216              		.cfi_def_cfa_offset 8
 217              		.cfi_offset 3, -8
 218              		.cfi_offset 14, -4
 183:base64/base64.c ****         /* Base 64 represents 6 bits with each character (log_2(64)).
 184:base64/base64.c ****          *
 185:base64/base64.c ****          * Thus, the size calculation is:
 186:base64/base64.c ****          *
 187:base64/base64.c ****          *      encoded
 188:base64/base64.c ****          *
 189:base64/base64.c ****          *      len * 8
 190:base64/base64.c ****          *      -------
 191:base64/base64.c ****          *         6
 192:base64/base64.c ****          *
 193:base64/base64.c ****          * However, since we can only operate in whole bytes:
 194:base64/base64.c ****          *    __       __
 195:base64/base64.c ****          *    | len * 8 |
 196:base64/base64.c ****          *    | ------- |  or  ceil((len*8)/6)
 197:base64/base64.c ****          *    |    6    |
 198:base64/base64.c ****          *
 199:base64/base64.c ****          */
 200:base64/base64.c ****         return (size_t)ceil(((double)len * 8) / 6);
 219              		.loc 1 200 0
 220 0002 FFF7FEFF 		bl	__aeabi_ui2d
 221              	.LVL23:
 222 0006 0022     		movs	r2, #0
 223 0008 054B     		ldr	r3, .L18
 224 000a FFF7FEFF 		bl	__aeabi_dmul
 225              	.LVL24:
 226 000e 0022     		movs	r2, #0
 227 0010 044B     		ldr	r3, .L18+4
 228 0012 FFF7FEFF 		bl	__aeabi_ddiv
 229              	.LVL25:
 230 0016 FFF7FEFF 		bl	ceil
 231              	.LVL26:
 232 001a FFF7FEFF 		bl	__aeabi_d2uiz
 233              	.LVL27:
 201:base64/base64.c **** }
 234              		.loc 1 201 0
 235 001e 08BD     		pop	{r3, pc}
 236              	.L19:
 237              		.align	2
 238              	.L18:
 239 0020 00002040 		.word	1075838976
 240 0024 00001840 		.word	1075314688
 241              		.cfi_endproc
 242              	.LFE2:
 244              		.section	.text.base64_decoded_size,"ax",%progbits
 245              		.align	1
 246              		.global	base64_decoded_size
 247              		.thumb
 248              		.thumb_func
 250              	base64_decoded_size:
 251              	.LFB3:
 202:base64/base64.c **** 
 203:base64/base64.c **** /** Compute size of needed storage for decoding. This function computes the
 204:base64/base64.c ****  *  \e estimated size of a memory area needed to hold the result of a decoding
 205:base64/base64.c ****  *  operation, not including the terminating null character. Note that this
 206:base64/base64.c ****  *  function may return up to two bytes more due to the nature of Base64.
 207:base64/base64.c ****  *
 208:base64/base64.c ****  * @param len input size
 209:base64/base64.c ****  * @returns output size
 210:base64/base64.c ****  *
 211:base64/base64.c ****  * @ingroup base64
 212:base64/base64.c ****  */
 213:base64/base64.c **** size_t base64_decoded_size(const size_t len)
 214:base64/base64.c **** {
 252              		.loc 1 214 0
 253              		.cfi_startproc
 254              		@ args = 0, pretend = 0, frame = 0
 255              		@ frame_needed = 0, uses_anonymous_args = 0
 256              	.LVL28:
 257 0000 08B5     		push	{r3, lr}
 258              		.cfi_def_cfa_offset 8
 259              		.cfi_offset 3, -8
 260              		.cfi_offset 14, -4
 215:base64/base64.c ****         return (size_t)ceil(((double)len / 8) * 6);
 261              		.loc 1 215 0
 262 0002 FFF7FEFF 		bl	__aeabi_ui2d
 263              	.LVL29:
 264 0006 0022     		movs	r2, #0
 265 0008 4FF07F53 		mov	r3, #1069547520
 266 000c FFF7FEFF 		bl	__aeabi_dmul
 267              	.LVL30:
 268 0010 0022     		movs	r2, #0
 269 0012 044B     		ldr	r3, .L21
 270 0014 FFF7FEFF 		bl	__aeabi_dmul
 271              	.LVL31:
 272 0018 FFF7FEFF 		bl	ceil
 273              	.LVL32:
 274 001c FFF7FEFF 		bl	__aeabi_d2uiz
 275              	.LVL33:
 216:base64/base64.c **** }
 276              		.loc 1 216 0
 277 0020 08BD     		pop	{r3, pc}
 278              	.L22:
 279 0022 00BF     		.align	2
 280              	.L21:
 281 0024 00001840 		.word	1075314688
 282              		.cfi_endproc
 283              	.LFE3:
 285              		.section	.text.base64_encode_binary,"ax",%progbits
 286              		.align	1
 287              		.global	base64_encode_binary
 288              		.thumb
 289              		.thumb_func
 291              	base64_encode_binary:
 292              	.LFB4:
 217:base64/base64.c **** 
 218:base64/base64.c **** /** Encode an arbitrary size memory area. This function encodes the first
 219:base64/base64.c ****  *  \c len bytes of the contents of the memory area pointed to by \c in and
 220:base64/base64.c ****  *  stores the result in the memory area pointed to by \c out. The result will
 221:base64/base64.c ****  *  be null-terminated.
 222:base64/base64.c ****  *
 223:base64/base64.c ****  * @attention This function can't check if there's enough space at the memory
 224:base64/base64.c ****  *            memory location pointed to by \c out, so be careful.
 225:base64/base64.c ****  *
 226:base64/base64.c ****  * @param out pointer to destination
 227:base64/base64.c ****  * @param in pointer to source
 228:base64/base64.c ****  * @param len input size in bytes
 229:base64/base64.c ****  * @param charset the base64 character set to use (e.g. urlsafe, regular)
 230:base64/base64.c ****  * @returns nothing
 231:base64/base64.c ****  *
 232:base64/base64.c ****  * @ingroup base64
 233:base64/base64.c ****  */
 234:base64/base64.c **** size_t base64_encode_binary(char *out, const unsigned char *in, const size_t len, const char charse
 235:base64/base64.c **** {
 293              		.loc 1 235 0
 294              		.cfi_startproc
 295              		@ args = 0, pretend = 0, frame = 0
 296              		@ frame_needed = 0, uses_anonymous_args = 0
 297              	.LVL34:
 298 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 299              		.cfi_def_cfa_offset 32
 300              		.cfi_offset 3, -32
 301              		.cfi_offset 4, -28
 302              		.cfi_offset 5, -24
 303              		.cfi_offset 6, -20
 304              		.cfi_offset 7, -16
 305              		.cfi_offset 8, -12
 306              		.cfi_offset 9, -8
 307              		.cfi_offset 14, -4
 308              		.loc 1 235 0
 309 0004 0646     		mov	r6, r0
 310 0006 8946     		mov	r9, r1
 311 0008 9046     		mov	r8, r2
 312 000a 1F46     		mov	r7, r3
 236:base64/base64.c ****         char* out_start = out;
 237:base64/base64.c ****         int size = 4;
 238:base64/base64.c ****         size_t i = 0;
 239:base64/base64.c **** 
 240:base64/base64.c ****         while (len-i >= 4)
 313              		.loc 1 240 0
 314 000c 1546     		mov	r5, r2
 315 000e 0446     		mov	r4, r0
 316              	.LVL35:
 317              	.L24:
 318 0010 09EB0801 		add	r1, r9, r8
 319              		.loc 1 240 0 is_stmt 0 discriminator 1
 320 0014 032D     		cmp	r5, #3
 321 0016 C5EB0101 		rsb	r1, r5, r1
 322              	.LVL36:
 323 001a 07D9     		bls	.L30
 241:base64/base64.c ****         {
 242:base64/base64.c ****                 base64_encode_block((unsigned char *)out, in, size, charset);
 324              		.loc 1 242 0 is_stmt 1
 325 001c 2046     		mov	r0, r4
 326 001e 0422     		movs	r2, #4
 327 0020 3B46     		mov	r3, r7
 328 0022 FFF7FEFF 		bl	base64_encode_block
 329              	.LVL37:
 243:base64/base64.c ****                 out += 4;
 330              		.loc 1 243 0
 331 0026 0434     		adds	r4, r4, #4
 332              	.LVL38:
 333 0028 033D     		subs	r5, r5, #3
 334              	.LVL39:
 335 002a F1E7     		b	.L24
 336              	.LVL40:
 337              	.L30:
 244:base64/base64.c ****                 in  += 3;
 245:base64/base64.c ****                 i   += 3;
 246:base64/base64.c ****         }
 247:base64/base64.c **** 
 248:base64/base64.c ****         size = len-i;
 249:base64/base64.c ****         if (size)
 338              		.loc 1 249 0
 339 002c 2DB1     		cbz	r5, .L26
 250:base64/base64.c ****         {
 251:base64/base64.c ****                 base64_encode_block((unsigned char *)out, in, size, charset);
 340              		.loc 1 251 0
 341 002e 2046     		mov	r0, r4
 342 0030 2A46     		mov	r2, r5
 343 0032 3B46     		mov	r3, r7
 344 0034 FFF7FEFF 		bl	base64_encode_block
 345              	.LVL41:
 252:base64/base64.c ****                 out += size;
 346              		.loc 1 252 0
 347 0038 2C44     		add	r4, r4, r5
 348              	.LVL42:
 349              	.L26:
 253:base64/base64.c ****         }
 254:base64/base64.c **** 
 255:base64/base64.c ****         out++;
 350              		.loc 1 255 0
 351 003a 601C     		adds	r0, r4, #1
 352              	.LVL43:
 256:base64/base64.c ****         return out-out_start;
 257:base64/base64.c **** }
 353              		.loc 1 257 0
 354 003c 801B     		subs	r0, r0, r6
 355              	.LVL44:
 356 003e BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 357              		.cfi_endproc
 358              	.LFE4:
 360              		.section	.text.base64_decode_binary,"ax",%progbits
 361              		.align	1
 362              		.global	base64_decode_binary
 363              		.thumb
 364              		.thumb_func
 366              	base64_decode_binary:
 367              	.LFB5:
 258:base64/base64.c **** 
 259:base64/base64.c **** /** Decode an arbitrary size memory area. This function decodes the
 260:base64/base64.c ****  *  base64-string pointed to by \c in and stores the result in the memory area
 261:base64/base64.c ****  *  pointed to by \c out. The result will \e not be null-terminated.
 262:base64/base64.c ****  *
 263:base64/base64.c ****  * @attention This function can't check if there's enough space at the memory
 264:base64/base64.c ****  *            memory location pointed to by \c out, so be careful.
 265:base64/base64.c ****  *
 266:base64/base64.c ****  * @param out pointer to destination
 267:base64/base64.c ****  * @param in pointer to source
 268:base64/base64.c ****  * @param len size in bytes of in
 269:base64/base64.c ****  * @returns -1 on error (illegal character) or the number of bytes decoded
 270:base64/base64.c ****  *
 271:base64/base64.c ****  * @ingroup base64
 272:base64/base64.c ****  */
 273:base64/base64.c **** int base64_decode_binary(unsigned char *out, const char *in, const size_t len)
 274:base64/base64.c **** {
 368              		.loc 1 274 0
 369              		.cfi_startproc
 370              		@ args = 0, pretend = 0, frame = 0
 371              		@ frame_needed = 0, uses_anonymous_args = 0
 372              	.LVL45:
 373 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 374              		.cfi_def_cfa_offset 24
 375              		.cfi_offset 4, -24
 376              		.cfi_offset 5, -20
 377              		.cfi_offset 6, -16
 378              		.cfi_offset 7, -12
 379              		.cfi_offset 8, -8
 380              		.cfi_offset 14, -4
 381              		.loc 1 274 0
 382 0004 0646     		mov	r6, r0
 383 0006 8846     		mov	r8, r1
 384 0008 1746     		mov	r7, r2
 275:base64/base64.c ****         size_t i = 0;
 276:base64/base64.c ****         size_t size = 4;
 277:base64/base64.c ****         int numbytes = 0;
 278:base64/base64.c ****         int ret;
 279:base64/base64.c **** 
 280:base64/base64.c ****         while (len-i >= 4)
 385              		.loc 1 280 0
 386 000a 1446     		mov	r4, r2
 277:base64/base64.c ****         int numbytes = 0;
 387              		.loc 1 277 0
 388 000c 0025     		movs	r5, #0
 389              	.LVL46:
 390              	.L32:
 391 000e 08EB0701 		add	r1, r8, r7
 392              		.loc 1 280 0 discriminator 1
 393 0012 032C     		cmp	r4, #3
 394 0014 C4EB0101 		rsb	r1, r4, r1
 395              	.LVL47:
 396 0018 0ED9     		bls	.L41
 281:base64/base64.c ****         {
 282:base64/base64.c ****                 ret = base64_decode_block(out, (unsigned char *)in, size);
 397              		.loc 1 282 0
 398 001a 0422     		movs	r2, #4
 399 001c 3046     		mov	r0, r6
 400 001e FFF7FEFF 		bl	base64_decode_block
 401              	.LVL48:
 283:base64/base64.c ****                 if(ret == -1)
 402              		.loc 1 283 0
 403 0022 421C     		adds	r2, r0, #1
 404 0024 A4F10404 		sub	r4, r4, #4
 405              	.LVL49:
 406 0028 03D1     		bne	.L33
 407              	.LVL50:
 408              	.L36:
 284:base64/base64.c ****                         return(-1);
 409              		.loc 1 284 0
 410 002a 4FF0FF30 		mov	r0, #-1
 411              	.LVL51:
 412 002e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 413              	.LVL52:
 414              	.L33:
 285:base64/base64.c ****                 numbytes += ret;
 415              		.loc 1 285 0
 416 0032 0544     		add	r5, r5, r0
 417              	.LVL53:
 286:base64/base64.c **** 
 287:base64/base64.c ****                 out += 3;
 418              		.loc 1 287 0
 419 0034 0336     		adds	r6, r6, #3
 420              	.LVL54:
 421 0036 EAE7     		b	.L32
 422              	.LVL55:
 423              	.L41:
 288:base64/base64.c ****                 in  += 4;
 289:base64/base64.c ****                 i   += 4;
 290:base64/base64.c ****         }
 291:base64/base64.c **** 
 292:base64/base64.c ****         size = len-i;
 293:base64/base64.c ****         if (size)
 424              		.loc 1 293 0
 425 0038 44B1     		cbz	r4, .L37
 294:base64/base64.c ****         {
 295:base64/base64.c ****                 ret = base64_decode_block(out, (unsigned char *)in, size);
 426              		.loc 1 295 0
 427 003a 3046     		mov	r0, r6
 428 003c 2246     		mov	r2, r4
 429 003e FFF7FEFF 		bl	base64_decode_block
 430              	.LVL56:
 296:base64/base64.c ****                 if(ret == -1)
 431              		.loc 1 296 0
 432 0042 431C     		adds	r3, r0, #1
 433 0044 F1D0     		beq	.L36
 297:base64/base64.c ****                         return(-1);
 298:base64/base64.c ****                 numbytes += ret;
 434              		.loc 1 298 0
 435 0046 2844     		add	r0, r0, r5
 436              	.LVL57:
 437 0048 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 438              	.LVL58:
 439              	.L37:
 440 004c 2846     		mov	r0, r5
 299:base64/base64.c ****         }
 300:base64/base64.c **** 
 301:base64/base64.c ****         return(numbytes);
 302:base64/base64.c **** }
 441              		.loc 1 302 0
 442 004e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 443              		.cfi_endproc
 444              	.LFE5:
 446              		.section	.text.base64_encode,"ax",%progbits
 447              		.align	1
 448              		.global	base64_encode
 449              		.thumb
 450              		.thumb_func
 452              	base64_encode:
 453              	.LFB6:
 303:base64/base64.c **** 
 304:base64/base64.c **** /** Encode a string. This is a convenience function. It encodes the first
 305:base64/base64.c ****  *  \c size bytes of the string pointed to by \c in, stores the result
 306:base64/base64.c ****  *  into \c out.
 307:base64/base64.c ****  *
 308:base64/base64.c ****  * @attention This function can't check if there's enough space at the memory
 309:base64/base64.c ****  *            memory location pointed to by \c out, so be careful.
 310:base64/base64.c ****  *
 311:base64/base64.c ****  * @param out pointer to string to write encoded chars to
 312:base64/base64.c ****  * @param in pointer to string
 313:base64/base64.c ****  * @param len size in bytes of in
 314:base64/base64.c ****  * @returns length of out, not including terminating null character
 315:base64/base64.c ****  *
 316:base64/base64.c ****  * @ingroup base64
 317:base64/base64.c ****  */
 318:base64/base64.c **** int base64_encode(char* out, const char *in, const size_t len)
 319:base64/base64.c **** {
 454              		.loc 1 319 0
 455              		.cfi_startproc
 456              		@ args = 0, pretend = 0, frame = 0
 457              		@ frame_needed = 0, uses_anonymous_args = 0
 458              		@ link register save eliminated.
 459              	.LVL59:
 320:base64/base64.c ****         size_t outlen;
 321:base64/base64.c **** 
 322:base64/base64.c ****         if(in == NULL)
 460              		.loc 1 322 0
 461 0000 19B1     		cbz	r1, .L43
 323:base64/base64.c ****                 return(-1);
 324:base64/base64.c **** 
 325:base64/base64.c ****         if(len == 0)
 462              		.loc 1 325 0
 463 0002 12B1     		cbz	r2, .L43
 326:base64/base64.c ****                 return(-1);
 327:base64/base64.c **** 
 328:base64/base64.c ****         outlen = base64_encode_binary(out, (unsigned char *)in, len, base64_list);
 464              		.loc 1 328 0
 465 0004 024B     		ldr	r3, .L48
 466 0006 FFF7FEBF 		b	base64_encode_binary
 467              	.LVL60:
 468              	.L43:
 329:base64/base64.c **** 
 330:base64/base64.c ****         return(outlen);
 331:base64/base64.c **** }
 469              		.loc 1 331 0
 470 000a 4FF0FF30 		mov	r0, #-1
 471              	.LVL61:
 472 000e 7047     		bx	lr
 473              	.L49:
 474              		.align	2
 475              	.L48:
 476 0010 00000000 		.word	.LANCHOR1
 477              		.cfi_endproc
 478              	.LFE6:
 480              		.section	.text.url_safe_base64_encode,"ax",%progbits
 481              		.align	1
 482              		.global	url_safe_base64_encode
 483              		.thumb
 484              		.thumb_func
 486              	url_safe_base64_encode:
 487              	.LFB7:
 332:base64/base64.c **** 
 333:base64/base64.c **** /** Encode a string. This is a convenience function. It encodes the first
 334:base64/base64.c ****  *  \c size bytes of the string pointed to by \c in, stores the result
 335:base64/base64.c ****  *  into \c out.
 336:base64/base64.c ****  *
 337:base64/base64.c ****  *  This is the url safe variant which replaces the +/ with -_, respectively.
 338:base64/base64.c ****  *
 339:base64/base64.c ****  * @attention This function can't check if there's enough space at the memory
 340:base64/base64.c ****  *            memory location pointed to by \c out, so be careful.
 341:base64/base64.c ****  *
 342:base64/base64.c ****  * @param out pointer to string to write the encoded chars to
 343:base64/base64.c ****  * @param in pointer to string
 344:base64/base64.c ****  * @param len size in bytes of len
 345:base64/base64.c ****  * @returns NULL on error (not enough memory) or a pointer to the encoded result
 346:base64/base64.c ****  *
 347:base64/base64.c ****  * @ingroup base64
 348:base64/base64.c ****  */
 349:base64/base64.c **** int url_safe_base64_encode(char* out, const char *in, const size_t len)
 350:base64/base64.c **** {
 488              		.loc 1 350 0
 489              		.cfi_startproc
 490              		@ args = 0, pretend = 0, frame = 0
 491              		@ frame_needed = 0, uses_anonymous_args = 0
 492              		@ link register save eliminated.
 493              	.LVL62:
 351:base64/base64.c ****         size_t outlen;
 352:base64/base64.c **** 
 353:base64/base64.c ****         if(in == NULL)
 494              		.loc 1 353 0
 495 0000 19B1     		cbz	r1, .L51
 354:base64/base64.c ****                 return(-1);
 355:base64/base64.c **** 
 356:base64/base64.c ****         if(len == 0)
 496              		.loc 1 356 0
 497 0002 12B1     		cbz	r2, .L51
 357:base64/base64.c ****                 return(-1);
 358:base64/base64.c **** 
 359:base64/base64.c ****         outlen = base64_encode_binary(out, (unsigned char *)in, len, url_safe_base64_list);
 498              		.loc 1 359 0
 499 0004 024B     		ldr	r3, .L56
 500 0006 FFF7FEBF 		b	base64_encode_binary
 501              	.LVL63:
 502              	.L51:
 360:base64/base64.c **** 
 361:base64/base64.c ****         return(outlen);
 362:base64/base64.c **** }
 503              		.loc 1 362 0
 504 000a 4FF0FF30 		mov	r0, #-1
 505              	.LVL64:
 506 000e 7047     		bx	lr
 507              	.L57:
 508              		.align	2
 509              	.L56:
 510 0010 00000000 		.word	.LANCHOR2
 511              		.cfi_endproc
 512              	.LFE7:
 514              		.section	.rodata.base64_list,"a",%progbits
 515              		.set	.LANCHOR1,. + 0
 518              	base64_list:
 519 0000 41424344 		.ascii	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxy"
 519      45464748 
 519      494A4B4C 
 519      4D4E4F50 
 519      51525354 
 520 0033 7A303132 		.ascii	"z0123456789+/\000"
 520      33343536 
 520      3738392B 
 520      2F00
 521              		.section	.rodata.url_safe_base64_list,"a",%progbits
 522              		.set	.LANCHOR2,. + 0
 525              	url_safe_base64_list:
 526 0000 41424344 		.ascii	"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxy"
 526      45464748 
 526      494A4B4C 
 526      4D4E4F50 
 526      51525354 
 527 0033 7A303132 		.ascii	"z0123456789-_\000"
 527      33343536 
 527      3738392D 
 527      5F00
 528              		.section	.rodata.base64_index,"a",%progbits
 529              		.align	2
 530              		.set	.LANCHOR0,. + 0
 533              	base64_index:
 534 0000 64000000 		.word	100
 535 0004 64000000 		.word	100
 536 0008 64000000 		.word	100
 537 000c 64000000 		.word	100
 538 0010 64000000 		.word	100
 539 0014 64000000 		.word	100
 540 0018 64000000 		.word	100
 541 001c 64000000 		.word	100
 542 0020 64000000 		.word	100
 543 0024 64000000 		.word	100
 544 0028 64000000 		.word	100
 545 002c 64000000 		.word	100
 546 0030 64000000 		.word	100
 547 0034 64000000 		.word	100
 548 0038 64000000 		.word	100
 549 003c 64000000 		.word	100
 550 0040 64000000 		.word	100
 551 0044 64000000 		.word	100
 552 0048 64000000 		.word	100
 553 004c 64000000 		.word	100
 554 0050 64000000 		.word	100
 555 0054 64000000 		.word	100
 556 0058 64000000 		.word	100
 557 005c 64000000 		.word	100
 558 0060 64000000 		.word	100
 559 0064 64000000 		.word	100
 560 0068 64000000 		.word	100
 561 006c 64000000 		.word	100
 562 0070 64000000 		.word	100
 563 0074 64000000 		.word	100
 564 0078 64000000 		.word	100
 565 007c 64000000 		.word	100
 566 0080 64000000 		.word	100
 567 0084 64000000 		.word	100
 568 0088 64000000 		.word	100
 569 008c 64000000 		.word	100
 570 0090 64000000 		.word	100
 571 0094 64000000 		.word	100
 572 0098 64000000 		.word	100
 573 009c 64000000 		.word	100
 574 00a0 64000000 		.word	100
 575 00a4 64000000 		.word	100
 576 00a8 64000000 		.word	100
 577 00ac 3E000000 		.word	62
 578 00b0 64000000 		.word	100
 579 00b4 3E000000 		.word	62
 580 00b8 64000000 		.word	100
 581 00bc 3F000000 		.word	63
 582 00c0 34000000 		.word	52
 583 00c4 35000000 		.word	53
 584 00c8 36000000 		.word	54
 585 00cc 37000000 		.word	55
 586 00d0 38000000 		.word	56
 587 00d4 39000000 		.word	57
 588 00d8 3A000000 		.word	58
 589 00dc 3B000000 		.word	59
 590 00e0 3C000000 		.word	60
 591 00e4 3D000000 		.word	61
 592 00e8 64000000 		.word	100
 593 00ec 64000000 		.word	100
 594 00f0 64000000 		.word	100
 595 00f4 64000000 		.word	100
 596 00f8 64000000 		.word	100
 597 00fc 64000000 		.word	100
 598 0100 64000000 		.word	100
 599 0104 00000000 		.word	0
 600 0108 01000000 		.word	1
 601 010c 02000000 		.word	2
 602 0110 03000000 		.word	3
 603 0114 04000000 		.word	4
 604 0118 05000000 		.word	5
 605 011c 06000000 		.word	6
 606 0120 07000000 		.word	7
 607 0124 08000000 		.word	8
 608 0128 09000000 		.word	9
 609 012c 0A000000 		.word	10
 610 0130 0B000000 		.word	11
 611 0134 0C000000 		.word	12
 612 0138 0D000000 		.word	13
 613 013c 0E000000 		.word	14
 614 0140 0F000000 		.word	15
 615 0144 10000000 		.word	16
 616 0148 11000000 		.word	17
 617 014c 12000000 		.word	18
 618 0150 13000000 		.word	19
 619 0154 14000000 		.word	20
 620 0158 15000000 		.word	21
 621 015c 16000000 		.word	22
 622 0160 17000000 		.word	23
 623 0164 18000000 		.word	24
 624 0168 19000000 		.word	25
 625 016c 64000000 		.word	100
 626 0170 64000000 		.word	100
 627 0174 64000000 		.word	100
 628 0178 64000000 		.word	100
 629 017c 3F000000 		.word	63
 630 0180 64000000 		.word	100
 631 0184 1A000000 		.word	26
 632 0188 1B000000 		.word	27
 633 018c 1C000000 		.word	28
 634 0190 1D000000 		.word	29
 635 0194 1E000000 		.word	30
 636 0198 1F000000 		.word	31
 637 019c 20000000 		.word	32
 638 01a0 21000000 		.word	33
 639 01a4 22000000 		.word	34
 640 01a8 23000000 		.word	35
 641 01ac 24000000 		.word	36
 642 01b0 25000000 		.word	37
 643 01b4 26000000 		.word	38
 644 01b8 27000000 		.word	39
 645 01bc 28000000 		.word	40
 646 01c0 29000000 		.word	41
 647 01c4 2A000000 		.word	42
 648 01c8 2B000000 		.word	43
 649 01cc 2C000000 		.word	44
 650 01d0 2D000000 		.word	45
 651 01d4 2E000000 		.word	46
 652 01d8 2F000000 		.word	47
 653 01dc 30000000 		.word	48
 654 01e0 31000000 		.word	49
 655 01e4 32000000 		.word	50
 656 01e8 33000000 		.word	51
 657 01ec 64000000 		.word	100
 658 01f0 64000000 		.word	100
 659 01f4 64000000 		.word	100
 660 01f8 64000000 		.word	100
 661 01fc 64000000 		.word	100
 662 0200 64000000 		.word	100
 663 0204 64000000 		.word	100
 664 0208 64000000 		.word	100
 665 020c 64000000 		.word	100
 666 0210 64000000 		.word	100
 667 0214 64000000 		.word	100
 668 0218 64000000 		.word	100
 669 021c 64000000 		.word	100
 670 0220 64000000 		.word	100
 671 0224 64000000 		.word	100
 672 0228 64000000 		.word	100
 673 022c 64000000 		.word	100
 674 0230 64000000 		.word	100
 675 0234 64000000 		.word	100
 676 0238 64000000 		.word	100
 677 023c 64000000 		.word	100
 678 0240 64000000 		.word	100
 679 0244 64000000 		.word	100
 680 0248 64000000 		.word	100
 681 024c 64000000 		.word	100
 682 0250 64000000 		.word	100
 683 0254 64000000 		.word	100
 684 0258 64000000 		.word	100
 685 025c 64000000 		.word	100
 686 0260 64000000 		.word	100
 687 0264 64000000 		.word	100
 688 0268 64000000 		.word	100
 689 026c 64000000 		.word	100
 690 0270 64000000 		.word	100
 691 0274 64000000 		.word	100
 692 0278 64000000 		.word	100
 693 027c 64000000 		.word	100
 694 0280 64000000 		.word	100
 695 0284 64000000 		.word	100
 696 0288 64000000 		.word	100
 697 028c 64000000 		.word	100
 698 0290 64000000 		.word	100
 699 0294 64000000 		.word	100
 700 0298 64000000 		.word	100
 701 029c 64000000 		.word	100
 702 02a0 64000000 		.word	100
 703 02a4 64000000 		.word	100
 704 02a8 64000000 		.word	100
 705 02ac 64000000 		.word	100
 706 02b0 64000000 		.word	100
 707 02b4 64000000 		.word	100
 708 02b8 64000000 		.word	100
 709 02bc 64000000 		.word	100
 710 02c0 64000000 		.word	100
 711 02c4 64000000 		.word	100
 712 02c8 64000000 		.word	100
 713 02cc 64000000 		.word	100
 714 02d0 64000000 		.word	100
 715 02d4 64000000 		.word	100
 716 02d8 64000000 		.word	100
 717 02dc 64000000 		.word	100
 718 02e0 64000000 		.word	100
 719 02e4 64000000 		.word	100
 720 02e8 64000000 		.word	100
 721 02ec 64000000 		.word	100
 722 02f0 64000000 		.word	100
 723 02f4 64000000 		.word	100
 724 02f8 64000000 		.word	100
 725 02fc 64000000 		.word	100
 726 0300 64000000 		.word	100
 727 0304 64000000 		.word	100
 728 0308 64000000 		.word	100
 729 030c 64000000 		.word	100
 730 0310 64000000 		.word	100
 731 0314 64000000 		.word	100
 732 0318 64000000 		.word	100
 733 031c 64000000 		.word	100
 734 0320 64000000 		.word	100
 735 0324 64000000 		.word	100
 736 0328 64000000 		.word	100
 737 032c 64000000 		.word	100
 738 0330 64000000 		.word	100
 739 0334 64000000 		.word	100
 740 0338 64000000 		.word	100
 741 033c 64000000 		.word	100
 742 0340 64000000 		.word	100
 743 0344 64000000 		.word	100
 744 0348 64000000 		.word	100
 745 034c 64000000 		.word	100
 746 0350 64000000 		.word	100
 747 0354 64000000 		.word	100
 748 0358 64000000 		.word	100
 749 035c 64000000 		.word	100
 750 0360 64000000 		.word	100
 751 0364 64000000 		.word	100
 752 0368 64000000 		.word	100
 753 036c 64000000 		.word	100
 754 0370 64000000 		.word	100
 755 0374 64000000 		.word	100
 756 0378 64000000 		.word	100
 757 037c 64000000 		.word	100
 758 0380 64000000 		.word	100
 759 0384 64000000 		.word	100
 760 0388 64000000 		.word	100
 761 038c 64000000 		.word	100
 762 0390 64000000 		.word	100
 763 0394 64000000 		.word	100
 764 0398 64000000 		.word	100
 765 039c 64000000 		.word	100
 766 03a0 64000000 		.word	100
 767 03a4 64000000 		.word	100
 768 03a8 64000000 		.word	100
 769 03ac 64000000 		.word	100
 770 03b0 64000000 		.word	100
 771 03b4 64000000 		.word	100
 772 03b8 64000000 		.word	100
 773 03bc 64000000 		.word	100
 774 03c0 64000000 		.word	100
 775 03c4 64000000 		.word	100
 776 03c8 64000000 		.word	100
 777 03cc 64000000 		.word	100
 778 03d0 64000000 		.word	100
 779 03d4 64000000 		.word	100
 780 03d8 64000000 		.word	100
 781 03dc 64000000 		.word	100
 782 03e0 64000000 		.word	100
 783 03e4 64000000 		.word	100
 784 03e8 64000000 		.word	100
 785 03ec 64000000 		.word	100
 786 03f0 64000000 		.word	100
 787 03f4 64000000 		.word	100
 788 03f8 64000000 		.word	100
 789 03fc 64000000 		.word	100
 790              		.text
 791              	.Letext0:
 792              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 793              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\math
DEFINED SYMBOLS
                            *ABS*:00000000 base64.c
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:19     .text.base64_encode_block:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:24     .text.base64_encode_block:00000000 base64_encode_block
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:92     .text.base64_decode_block:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:97     .text.base64_decode_block:00000000 base64_decode_block
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:194    .text.base64_decode_block:00000068 $d
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:203    .text.base64_encoded_size:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:208    .text.base64_encoded_size:00000000 base64_encoded_size
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:239    .text.base64_encoded_size:00000020 $d
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:245    .text.base64_decoded_size:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:250    .text.base64_decoded_size:00000000 base64_decoded_size
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:281    .text.base64_decoded_size:00000024 $d
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:286    .text.base64_encode_binary:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:291    .text.base64_encode_binary:00000000 base64_encode_binary
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:361    .text.base64_decode_binary:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:366    .text.base64_decode_binary:00000000 base64_decode_binary
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:447    .text.base64_encode:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:452    .text.base64_encode:00000000 base64_encode
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:476    .text.base64_encode:00000010 $d
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:481    .text.url_safe_base64_encode:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:486    .text.url_safe_base64_encode:00000000 url_safe_base64_encode
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:510    .text.url_safe_base64_encode:00000010 $d
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:518    .rodata.base64_list:00000000 base64_list
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:525    .rodata.url_safe_base64_list:00000000 url_safe_base64_list
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:529    .rodata.base64_index:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccJNhbj4.s:533    .rodata.base64_index:00000000 base64_index
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
__aeabi_ui2d
__aeabi_dmul
__aeabi_ddiv
__aeabi_d2uiz
ceil
