   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"base58.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.my_dblsha256,"ax",%progbits
  19              		.align	1
  20              		.thumb
  21              		.thumb_func
  23              	my_dblsha256:
  24              	.LFB1:
  25              		.file 1 "base64/base58.c"
   1:base64/base58.c **** /*
   2:base64/base58.c ****  * Copyright 2012-2014 Luke Dashjr
   3:base64/base58.c ****  *
   4:base64/base58.c ****  * This program is free software; you can redistribute it and/or modify it
   5:base64/base58.c ****  * under the terms of the standard MIT license.  See COPYING for more details.
   6:base64/base58.c ****  */
   7:base64/base58.c **** 
   8:base64/base58.c **** #include <stdbool.h>
   9:base64/base58.c **** #include <stddef.h>
  10:base64/base58.c **** #include <stdint.h>
  11:base64/base58.c **** #include <string.h>
  12:base64/base58.c **** #include <sys/types.h>
  13:base64/base58.c **** 
  14:base64/base58.c **** #include "libbase58.h"
  15:base64/base58.c **** 
  16:base64/base58.c **** bool (*b58_sha256_impl)(void *, const void *, size_t) = NULL;
  17:base64/base58.c **** 
  18:base64/base58.c **** static const int8_t b58digits_map[] = {
  19:base64/base58.c **** 	-1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  20:base64/base58.c **** 	-1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  21:base64/base58.c **** 	-1,-1,-1,-1,-1,-1,-1,-1, -1,-1,-1,-1,-1,-1,-1,-1,
  22:base64/base58.c **** 	-1, 0, 1, 2, 3, 4, 5, 6,  7, 8,-1,-1,-1,-1,-1,-1,
  23:base64/base58.c **** 	-1, 9,10,11,12,13,14,15, 16,-1,17,18,19,20,21,-1,
  24:base64/base58.c **** 	22,23,24,25,26,27,28,29, 30,31,32,-1,-1,-1,-1,-1,
  25:base64/base58.c **** 	-1,33,34,35,36,37,38,39, 40,41,42,43,-1,44,45,46,
  26:base64/base58.c **** 	47,48,49,50,51,52,53,54, 55,56,57,-1,-1,-1,-1,-1,
  27:base64/base58.c **** };
  28:base64/base58.c **** 
  29:base64/base58.c **** bool b58tobin(void *bin, size_t *binszp, const char *b58, size_t b58sz)
  30:base64/base58.c **** {
  31:base64/base58.c **** 	size_t binsz = *binszp;
  32:base64/base58.c **** 	const unsigned char *b58u = (void*)b58;
  33:base64/base58.c **** 	unsigned char *binu = bin;
  34:base64/base58.c **** 	size_t outisz = (binsz + 3) / 4;
  35:base64/base58.c **** 	uint32_t outi[outisz];
  36:base64/base58.c **** 	uint64_t t;
  37:base64/base58.c **** 	uint32_t c;
  38:base64/base58.c **** 	size_t i, j;
  39:base64/base58.c **** 	uint8_t bytesleft = binsz % 4;
  40:base64/base58.c **** 	uint32_t zeromask = bytesleft ? (0xffffffff << (bytesleft * 8)) : 0;
  41:base64/base58.c **** 	unsigned zerocount = 0;
  42:base64/base58.c **** 	
  43:base64/base58.c **** 	if (!b58sz)
  44:base64/base58.c **** 		b58sz = strlen(b58);
  45:base64/base58.c **** 	
  46:base64/base58.c **** 	memset(outi, 0, outisz * sizeof(*outi));
  47:base64/base58.c **** 	
  48:base64/base58.c **** 	// Leading zeros, just count
  49:base64/base58.c **** 	for (i = 0; i < b58sz && b58u[i] == '1'; ++i)
  50:base64/base58.c **** 		++zerocount;
  51:base64/base58.c **** 	
  52:base64/base58.c **** 	for ( ; i < b58sz; ++i)
  53:base64/base58.c **** 	{
  54:base64/base58.c **** 		if (b58u[i] & 0x80)
  55:base64/base58.c **** 			// High-bit set on invalid digit
  56:base64/base58.c **** 			return false;
  57:base64/base58.c **** 		if (b58digits_map[b58u[i]] == -1)
  58:base64/base58.c **** 			// Invalid base58 digit
  59:base64/base58.c **** 			return false;
  60:base64/base58.c **** 		c = (unsigned)b58digits_map[b58u[i]];
  61:base64/base58.c **** 		for (j = outisz; j--; )
  62:base64/base58.c **** 		{
  63:base64/base58.c **** 			t = ((uint64_t)outi[j]) * 58 + c;
  64:base64/base58.c **** 			c = (t & 0x3f00000000) >> 32;
  65:base64/base58.c **** 			outi[j] = t & 0xffffffff;
  66:base64/base58.c **** 		}
  67:base64/base58.c **** 		if (c)
  68:base64/base58.c **** 			// Output number too big (carry to the next int32)
  69:base64/base58.c **** 			return false;
  70:base64/base58.c **** 		if (outi[0] & zeromask)
  71:base64/base58.c **** 			// Output number too big (last int32 filled too far)
  72:base64/base58.c **** 			return false;
  73:base64/base58.c **** 	}
  74:base64/base58.c **** 	
  75:base64/base58.c **** 	j = 0;
  76:base64/base58.c **** 	switch (bytesleft) {
  77:base64/base58.c **** 		case 3:
  78:base64/base58.c **** 			*(binu++) = (outi[0] &   0xff0000) >> 16;
  79:base64/base58.c **** 		case 2:
  80:base64/base58.c **** 			*(binu++) = (outi[0] &     0xff00) >>  8;
  81:base64/base58.c **** 		case 1:
  82:base64/base58.c **** 			*(binu++) = (outi[0] &       0xff);
  83:base64/base58.c **** 			++j;
  84:base64/base58.c **** 		default:
  85:base64/base58.c **** 			break;
  86:base64/base58.c **** 	}
  87:base64/base58.c **** 	
  88:base64/base58.c **** 	for (; j < outisz; ++j)
  89:base64/base58.c **** 	{
  90:base64/base58.c **** 		*(binu++) = (outi[j] >> 0x18) & 0xff;
  91:base64/base58.c **** 		*(binu++) = (outi[j] >> 0x10) & 0xff;
  92:base64/base58.c **** 		*(binu++) = (outi[j] >>    8) & 0xff;
  93:base64/base58.c **** 		*(binu++) = (outi[j] >>    0) & 0xff;
  94:base64/base58.c **** 	}
  95:base64/base58.c **** 	
  96:base64/base58.c **** 	// Count canonical base58 byte count
  97:base64/base58.c **** 	binu = bin;
  98:base64/base58.c **** 	for (i = 0; i < binsz; ++i)
  99:base64/base58.c **** 	{
 100:base64/base58.c **** 		if (binu[i])
 101:base64/base58.c **** 			break;
 102:base64/base58.c **** 		--*binszp;
 103:base64/base58.c **** 	}
 104:base64/base58.c **** 	*binszp += zerocount;
 105:base64/base58.c **** 	
 106:base64/base58.c **** 	return true;
 107:base64/base58.c **** }
 108:base64/base58.c **** 
 109:base64/base58.c **** static
 110:base64/base58.c **** bool my_dblsha256(void *hash, const void *data, size_t datasz)
 111:base64/base58.c **** {
  26              		.loc 1 111 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 32
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 30B5     		push	{r4, r5, lr}
  32              		.cfi_def_cfa_offset 12
  33              		.cfi_offset 4, -12
  34              		.cfi_offset 5, -8
  35              		.cfi_offset 14, -4
 112:base64/base58.c **** 	uint8_t buf[0x20];
 113:base64/base58.c **** 	return b58_sha256_impl(buf, data, datasz) && b58_sha256_impl(hash, buf, sizeof(buf));
  36              		.loc 1 113 0
  37 0002 084C     		ldr	r4, .L5
 111:base64/base58.c **** {
  38              		.loc 1 111 0
  39 0004 89B0     		sub	sp, sp, #36
  40              		.cfi_def_cfa_offset 48
 111:base64/base58.c **** {
  41              		.loc 1 111 0
  42 0006 0546     		mov	r5, r0
  43              		.loc 1 113 0
  44 0008 2368     		ldr	r3, [r4]
  45 000a 6846     		mov	r0, sp
  46              	.LVL1:
  47 000c 9847     		blx	r3
  48              	.LVL2:
  49 000e 20B1     		cbz	r0, .L2
  50              		.loc 1 113 0 is_stmt 0 discriminator 1
  51 0010 2368     		ldr	r3, [r4]
  52 0012 2846     		mov	r0, r5
  53 0014 6946     		mov	r1, sp
  54 0016 2022     		movs	r2, #32
  55 0018 9847     		blx	r3
  56              	.LVL3:
  57              	.L2:
 114:base64/base58.c **** }
  58              		.loc 1 114 0 is_stmt 1 discriminator 4
  59 001a 00F00100 		and	r0, r0, #1
  60 001e 09B0     		add	sp, sp, #36
  61              		@ sp needed
  62 0020 30BD     		pop	{r4, r5, pc}
  63              	.LVL4:
  64              	.L6:
  65 0022 00BF     		.align	2
  66              	.L5:
  67 0024 00000000 		.word	.LANCHOR0
  68              		.cfi_endproc
  69              	.LFE1:
  71              		.section	.text.b58tobin,"ax",%progbits
  72              		.align	1
  73              		.global	b58tobin
  74              		.thumb
  75              		.thumb_func
  77              	b58tobin:
  78              	.LFB0:
  30:base64/base58.c **** {
  79              		.loc 1 30 0
  80              		.cfi_startproc
  81              		@ args = 0, pretend = 0, frame = 56
  82              		@ frame_needed = 1, uses_anonymous_args = 0
  83              	.LVL5:
  84 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
  85              		.cfi_def_cfa_offset 36
  86              		.cfi_offset 4, -36
  87              		.cfi_offset 5, -32
  88              		.cfi_offset 6, -28
  89              		.cfi_offset 7, -24
  90              		.cfi_offset 8, -20
  91              		.cfi_offset 9, -16
  92              		.cfi_offset 10, -12
  93              		.cfi_offset 11, -8
  94              		.cfi_offset 14, -4
  95 0004 8FB0     		sub	sp, sp, #60
  96              		.cfi_def_cfa_offset 96
  97 0006 9846     		mov	r8, r3
  31:base64/base58.c **** 	size_t binsz = *binszp;
  98              		.loc 1 31 0
  99 0008 0B68     		ldr	r3, [r1]
 100              	.LVL6:
  30:base64/base58.c **** {
 101              		.loc 1 30 0
 102 000a 00AF     		add	r7, sp, #0
 103              		.cfi_def_cfa_register 7
  34:base64/base58.c **** 	size_t outisz = (binsz + 3) / 4;
 104              		.loc 1 34 0
 105 000c 03F1030A 		add	r10, r3, #3
 106 0010 4FEA9A0A 		lsr	r10, r10, #2
  30:base64/base58.c **** {
 107              		.loc 1 30 0
 108 0014 3A60     		str	r2, [r7]
  35:base64/base58.c **** 	uint32_t outi[outisz];
 109              		.loc 1 35 0
 110 0016 4FEA8A02 		lsl	r2, r10, #2
 111              	.LVL7:
  31:base64/base58.c **** 	size_t binsz = *binszp;
 112              		.loc 1 31 0
 113 001a 7B63     		str	r3, [r7, #52]
 114              	.LVL8:
  35:base64/base58.c **** 	uint32_t outi[outisz];
 115              		.loc 1 35 0
 116 001c 02F10A03 		add	r3, r2, #10
 117              	.LVL9:
 118 0020 23F00703 		bic	r3, r3, #7
 119 0024 ADEB030D 		sub	sp, sp, r3
 120              	.LVL10:
  40:base64/base58.c **** 	uint32_t zeromask = bytesleft ? (0xffffffff << (bytesleft * 8)) : 0;
 121              		.loc 1 40 0
 122 0028 7B6B     		ldr	r3, [r7, #52]
  30:base64/base58.c **** {
 123              		.loc 1 30 0
 124 002a 0546     		mov	r5, r0
 125              	.LVL11:
  40:base64/base58.c **** 	uint32_t zeromask = bytesleft ? (0xffffffff << (bytesleft * 8)) : 0;
 126              		.loc 1 40 0
 127 002c 13F00306 		ands	r6, r3, #3
  30:base64/base58.c **** {
 128              		.loc 1 30 0
 129 0030 8946     		mov	r9, r1
  34:base64/base58.c **** 	size_t outisz = (binsz + 3) / 4;
 130              		.loc 1 34 0
 131 0032 C7F804A0 		str	r10, [r7, #4]
 132              	.LVL12:
  35:base64/base58.c **** 	uint32_t outi[outisz];
 133              		.loc 1 35 0
 134 0036 6C46     		mov	r4, sp
 135              	.LVL13:
  40:base64/base58.c **** 	uint32_t zeromask = bytesleft ? (0xffffffff << (bytesleft * 8)) : 0;
 136              		.loc 1 40 0
 137 0038 05D0     		beq	.L30
  40:base64/base58.c **** 	uint32_t zeromask = bytesleft ? (0xffffffff << (bytesleft * 8)) : 0;
 138              		.loc 1 40 0 is_stmt 0 discriminator 1
 139 003a F300     		lsls	r3, r6, #3
 140 003c 4FF0FF31 		mov	r1, #-1
 141              	.LVL14:
 142 0040 9940     		lsls	r1, r1, r3
 143 0042 3963     		str	r1, [r7, #48]
 144 0044 00E0     		b	.L8
 145              	.LVL15:
 146              	.L30:
  40:base64/base58.c **** 	uint32_t zeromask = bytesleft ? (0xffffffff << (bytesleft * 8)) : 0;
 147              		.loc 1 40 0
 148 0046 3E63     		str	r6, [r7, #48]
 149              	.LVL16:
 150              	.L8:
  43:base64/base58.c **** 	if (!b58sz)
 151              		.loc 1 43 0 is_stmt 1 discriminator 3
 152 0048 B8F1000F 		cmp	r8, #0
 153 004c 05D1     		bne	.L9
  44:base64/base58.c **** 		b58sz = strlen(b58);
 154              		.loc 1 44 0
 155 004e 3868     		ldr	r0, [r7]
 156              	.LVL17:
 157 0050 BA61     		str	r2, [r7, #24]
 158 0052 FFF7FEFF 		bl	strlen
 159              	.LVL18:
 160 0056 BA69     		ldr	r2, [r7, #24]
 161 0058 8046     		mov	r8, r0
 162              	.LVL19:
 163              	.L9:
  46:base64/base58.c **** 	memset(outi, 0, outisz * sizeof(*outi));
 164              		.loc 1 46 0
 165 005a 0021     		movs	r1, #0
 166 005c 2046     		mov	r0, r4
 167 005e FFF7FEFF 		bl	memset
 168              	.LVL20:
  49:base64/base58.c **** 	for (i = 0; i < b58sz && b58u[i] == '1'; ++i)
 169              		.loc 1 49 0
 170 0062 0021     		movs	r1, #0
 171              	.LVL21:
 172              	.L10:
  49:base64/base58.c **** 	for (i = 0; i < b58sz && b58u[i] == '1'; ++i)
 173              		.loc 1 49 0 is_stmt 0 discriminator 1
 174 0064 4145     		cmp	r1, r8
 175 0066 F961     		str	r1, [r7, #28]
 176              	.LVL22:
 177 0068 0FD0     		beq	.L12
  49:base64/base58.c **** 	for (i = 0; i < b58sz && b58u[i] == '1'; ++i)
 178              		.loc 1 49 0 discriminator 2
 179 006a D7F800A0 		ldr	r10, [r7]
 180 006e 1AF80130 		ldrb	r3, [r10, r1]	@ zero_extendqisi2
 181 0072 312B     		cmp	r3, #49
 182 0074 09D1     		bne	.L12
 183              	.LVL23:
  49:base64/base58.c **** 	for (i = 0; i < b58sz && b58u[i] == '1'; ++i)
 184              		.loc 1 49 0 discriminator 1
 185 0076 0131     		adds	r1, r1, #1
 186              	.LVL24:
 187 0078 F4E7     		b	.L10
 188              	.LVL25:
 189              	.L39:
  67:base64/base58.c **** 		if (c)
 190              		.loc 1 67 0 is_stmt 1
 191 007a 70B9     		cbnz	r0, .L17
  70:base64/base58.c **** 		if (outi[0] & zeromask)
 192              		.loc 1 70 0
 193 007c 2368     		ldr	r3, [r4]
 194 007e D7F830B0 		ldr	fp, [r7, #48]
 195 0082 1BEA030F 		tst	fp, r3
 196 0086 08D1     		bne	.L17
  52:base64/base58.c **** 	for ( ; i < b58sz; ++i)
 197              		.loc 1 52 0
 198 0088 0131     		adds	r1, r1, #1
 199              	.LVL26:
 200              	.L12:
  52:base64/base58.c **** 	for ( ; i < b58sz; ++i)
 201              		.loc 1 52 0 is_stmt 0 discriminator 1
 202 008a 4145     		cmp	r1, r8
 203 008c 3BD2     		bcs	.L38
  54:base64/base58.c **** 		if (b58u[i] & 0x80)
 204              		.loc 1 54 0 is_stmt 1
 205 008e D7F800B0 		ldr	fp, [r7]
 206 0092 1BF80130 		ldrb	r3, [fp, r1]	@ zero_extendqisi2
 207 0096 1A06     		lsls	r2, r3, #24
 208 0098 01D5     		bpl	.L15
 209              	.L17:
  56:base64/base58.c **** 			return false;
 210              		.loc 1 56 0
 211 009a 0020     		movs	r0, #0
 212 009c 73E0     		b	.L16
 213              	.L15:
  57:base64/base58.c **** 		if (b58digits_map[b58u[i]] == -1)
 214              		.loc 1 57 0
 215 009e 3C4A     		ldr	r2, .L41
 216 00a0 D256     		ldrsb	r2, [r2, r3]
 217 00a2 531C     		adds	r3, r2, #1
 218 00a4 F9D0     		beq	.L17
 219 00a6 7B68     		ldr	r3, [r7, #4]
  60:base64/base58.c **** 		c = (unsigned)b58digits_map[b58u[i]];
 220              		.loc 1 60 0
 221 00a8 1046     		mov	r0, r2
 222              	.LVL27:
 223 00aa 04EB830C 		add	ip, r4, r3, lsl #2
  61:base64/base58.c **** 		for (j = outisz; j--; )
 224              		.loc 1 61 0
 225 00ae 3B61     		str	r3, [r7, #16]
 226              	.LVL28:
 227              	.L18:
  61:base64/base58.c **** 		for (j = outisz; j--; )
 228              		.loc 1 61 0 is_stmt 0 discriminator 1
 229 00b0 D7F810A0 		ldr	r10, [r7, #16]
 230 00b4 0AF1FF3A 		add	r10, r10, #-1
 231 00b8 BAF1FF3F 		cmp	r10, #-1
 232 00bc C7F810A0 		str	r10, [r7, #16]
 233              	.LVL29:
 234 00c0 DBD0     		beq	.L39
  63:base64/base58.c **** 			t = ((uint64_t)outi[j]) * 58 + c;
 235              		.loc 1 63 0 is_stmt 1
 236 00c2 8246     		mov	r10, r0
 237              	.LVL30:
 238 00c4 4FF0000B 		mov	fp, #0
 239 00c8 5CF8040C 		ldr	r0, [ip, #-4]
 240              	.LVL31:
 241 00cc C7E90AAB 		strd	r10, [r7, #40]
 242 00d0 D7E90A23 		ldrd	r2, [r7, #40]
 243 00d4 4FF03A0A 		mov	r10, #58
 244              	.LVL32:
 245 00d8 EAFB0023 		umlal	r2, r3, r10, r0
  64:base64/base58.c **** 			c = (t & 0x3f00000000) >> 32;
 246              		.loc 1 64 0
 247 00dc 4FF03F0B 		mov	fp, #63
  63:base64/base58.c **** 			t = ((uint64_t)outi[j]) * 58 + c;
 248              		.loc 1 63 0
 249 00e0 C7E90A23 		strd	r2, [r7, #40]
 250              	.LVL33:
  64:base64/base58.c **** 			c = (t & 0x3f00000000) >> 32;
 251              		.loc 1 64 0
 252 00e4 0BEA030B 		and	fp, fp, r3
 253 00e8 4FF0000A 		mov	r10, #0
  65:base64/base58.c **** 			outi[j] = t & 0xffffffff;
 254              		.loc 1 65 0
 255 00ec BB6A     		ldr	r3, [r7, #40]
  64:base64/base58.c **** 			c = (t & 0x3f00000000) >> 32;
 256              		.loc 1 64 0
 257 00ee 0AEA020A 		and	r10, r10, r2
 258 00f2 0022     		movs	r2, #0
 259              	.LVL34:
 260 00f4 C7E902AB 		strd	r10, [r7, #8]
 261 00f8 5846     		mov	r0, fp
 262 00fa C7F820B0 		str	fp, [r7, #32]
 263 00fe 7A62     		str	r2, [r7, #36]
 264              	.LVL35:
  65:base64/base58.c **** 			outi[j] = t & 0xffffffff;
 265              		.loc 1 65 0
 266 0100 4CF8043D 		str	r3, [ip, #-4]!
 267 0104 D4E7     		b	.L18
 268              	.LVL36:
 269              	.L38:
  76:base64/base58.c **** 	switch (bytesleft) {
 270              		.loc 1 76 0
 271 0106 022E     		cmp	r6, #2
 272 0108 09D0     		beq	.L33
 273 010a 032E     		cmp	r6, #3
 274 010c 03D0     		beq	.L23
 275 010e 012E     		cmp	r6, #1
 276 0110 0ED1     		bne	.L37
 277 0112 2A46     		mov	r2, r5
 278 0114 07E0     		b	.L24
 279              	.L23:
  78:base64/base58.c **** 			*(binu++) = (outi[0] &   0xff0000) >> 16;
 280              		.loc 1 78 0
 281 0116 A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 282 0118 6B1C     		adds	r3, r5, #1
 283              	.LVL37:
 284 011a 2A70     		strb	r2, [r5]
 285 011c 00E0     		b	.L22
 286              	.LVL38:
 287              	.L33:
  76:base64/base58.c **** 	switch (bytesleft) {
 288              		.loc 1 76 0
 289 011e 2B46     		mov	r3, r5
 290              	.LVL39:
 291              	.L22:
  80:base64/base58.c **** 			*(binu++) = (outi[0] &     0xff00) >>  8;
 292              		.loc 1 80 0
 293 0120 6178     		ldrb	r1, [r4, #1]	@ zero_extendqisi2
 294              	.LVL40:
 295 0122 5A1C     		adds	r2, r3, #1
 296              	.LVL41:
 297 0124 1970     		strb	r1, [r3]
 298              	.L24:
  82:base64/base58.c **** 			*(binu++) = (outi[0] &       0xff);
 299              		.loc 1 82 0
 300 0126 2368     		ldr	r3, [r4]
 301 0128 501C     		adds	r0, r2, #1
 302              	.LVL42:
 303 012a 1370     		strb	r3, [r2]
 304              	.LVL43:
  83:base64/base58.c **** 			++j;
 305              		.loc 1 83 0
 306 012c 0123     		movs	r3, #1
 307 012e 01E0     		b	.L21
 308              	.LVL44:
 309              	.L37:
  76:base64/base58.c **** 	switch (bytesleft) {
 310              		.loc 1 76 0
 311 0130 2846     		mov	r0, r5
  75:base64/base58.c **** 	j = 0;
 312              		.loc 1 75 0
 313 0132 0023     		movs	r3, #0
 314              	.LVL45:
 315              	.L21:
 316 0134 04EB8304 		add	r4, r4, r3, lsl #2
 317              	.LVL46:
  75:base64/base58.c **** 	j = 0;
 318              		.loc 1 75 0 is_stmt 0 discriminator 1
 319 0138 0022     		movs	r2, #0
 320              	.LVL47:
 321              	.L25:
  88:base64/base58.c **** 	for (; j < outisz; ++j)
 322              		.loc 1 88 0 is_stmt 1 discriminator 1
 323 013a D7F804A0 		ldr	r10, [r7, #4]
 324 013e 5345     		cmp	r3, r10
 325 0140 0FD2     		bcs	.L40
  90:base64/base58.c **** 		*(binu++) = (outi[j] >> 0x18) & 0xff;
 326              		.loc 1 90 0 discriminator 2
 327 0142 A158     		ldr	r1, [r4, r2]
  88:base64/base58.c **** 	for (; j < outisz; ++j)
 328              		.loc 1 88 0 discriminator 2
 329 0144 0133     		adds	r3, r3, #1
 330              	.LVL48:
  90:base64/base58.c **** 		*(binu++) = (outi[j] >> 0x18) & 0xff;
 331              		.loc 1 90 0 discriminator 2
 332 0146 0E0E     		lsrs	r6, r1, #24
 333 0148 8654     		strb	r6, [r0, r2]
  91:base64/base58.c **** 		*(binu++) = (outi[j] >> 0x10) & 0xff;
 334              		.loc 1 91 0 discriminator 2
 335 014a 4FEA114C 		lsr	ip, r1, #16
 336 014e 8618     		adds	r6, r0, r2
 337 0150 86F801C0 		strb	ip, [r6, #1]
  92:base64/base58.c **** 		*(binu++) = (outi[j] >>    8) & 0xff;
 338              		.loc 1 92 0 discriminator 2
 339 0154 4FEA112C 		lsr	ip, r1, #8
 340 0158 86F802C0 		strb	ip, [r6, #2]
 341              	.LVL49:
  93:base64/base58.c **** 		*(binu++) = (outi[j] >>    0) & 0xff;
 342              		.loc 1 93 0 discriminator 2
 343 015c F170     		strb	r1, [r6, #3]
 344 015e 0432     		adds	r2, r2, #4
 345              	.LVL50:
 346 0160 EBE7     		b	.L25
 347              	.LVL51:
 348              	.L40:
  88:base64/base58.c **** 	for (; j < outisz; ++j)
 349              		.loc 1 88 0
 350 0162 0023     		movs	r3, #0
 351              	.LVL52:
 352              	.L27:
  98:base64/base58.c **** 	for (i = 0; i < binsz; ++i)
 353              		.loc 1 98 0 discriminator 1
 354 0164 786B     		ldr	r0, [r7, #52]
 355 0166 D9F80020 		ldr	r2, [r9]
 356 016a 8342     		cmp	r3, r0
 357 016c 06D0     		beq	.L28
 100:base64/base58.c **** 		if (binu[i])
 358              		.loc 1 100 0
 359 016e E95C     		ldrb	r1, [r5, r3]	@ zero_extendqisi2
 360 0170 21B9     		cbnz	r1, .L28
 102:base64/base58.c **** 		--*binszp;
 361              		.loc 1 102 0
 362 0172 013A     		subs	r2, r2, #1
 363 0174 C9F80020 		str	r2, [r9]
  98:base64/base58.c **** 	for (i = 0; i < binsz; ++i)
 364              		.loc 1 98 0
 365 0178 0133     		adds	r3, r3, #1
 366              	.LVL53:
 367 017a F3E7     		b	.L27
 368              	.L28:
 104:base64/base58.c **** 	*binszp += zerocount;
 369              		.loc 1 104 0
 370 017c F969     		ldr	r1, [r7, #28]
 106:base64/base58.c **** 	return true;
 371              		.loc 1 106 0
 372 017e 0120     		movs	r0, #1
 104:base64/base58.c **** 	*binszp += zerocount;
 373              		.loc 1 104 0
 374 0180 0A44     		add	r2, r2, r1
 375 0182 C9F80020 		str	r2, [r9]
 376              	.LVL54:
 377              	.L16:
 107:base64/base58.c **** }
 378              		.loc 1 107 0
 379 0186 3C37     		adds	r7, r7, #60
 380              	.LVL55:
 381 0188 BD46     		mov	sp, r7
 382              	.LVL56:
 383              		@ sp needed
 384 018a BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 385              	.LVL57:
 386              	.L42:
 387 018e 00BF     		.align	2
 388              	.L41:
 389 0190 00000000 		.word	.LANCHOR1
 390              		.cfi_endproc
 391              	.LFE0:
 393              		.section	.text.b58check,"ax",%progbits
 394              		.align	1
 395              		.global	b58check
 396              		.thumb
 397              		.thumb_func
 399              	b58check:
 400              	.LFB2:
 115:base64/base58.c **** 
 116:base64/base58.c **** int b58check(const void *bin, size_t binsz, const char *base58str, size_t b58sz)
 117:base64/base58.c **** {
 401              		.loc 1 117 0
 402              		.cfi_startproc
 403              		@ args = 0, pretend = 0, frame = 32
 404              		@ frame_needed = 0, uses_anonymous_args = 0
 405              	.LVL58:
 406 0000 70B5     		push	{r4, r5, r6, lr}
 407              		.cfi_def_cfa_offset 16
 408              		.cfi_offset 4, -16
 409              		.cfi_offset 5, -12
 410              		.cfi_offset 6, -8
 411              		.cfi_offset 14, -4
 118:base64/base58.c **** 	unsigned char buf[32];
 119:base64/base58.c **** 	const uint8_t *binc = bin;
 120:base64/base58.c **** 	unsigned i;
 121:base64/base58.c **** 	if (binsz < 4)
 412              		.loc 1 121 0
 413 0002 0329     		cmp	r1, #3
 117:base64/base58.c **** {
 414              		.loc 1 117 0
 415 0004 88B0     		sub	sp, sp, #32
 416              		.cfi_def_cfa_offset 48
 117:base64/base58.c **** {
 417              		.loc 1 117 0
 418 0006 0446     		mov	r4, r0
 419              	.LVL59:
 420 0008 1546     		mov	r5, r2
 421              		.loc 1 121 0
 422 000a 14D9     		bls	.L49
 122:base64/base58.c **** 		return -4;
 123:base64/base58.c **** 	if (!my_dblsha256(buf, bin, binsz - 4))
 423              		.loc 1 123 0
 424 000c 0E1F     		subs	r6, r1, #4
 425 000e 6846     		mov	r0, sp
 426              	.LVL60:
 427 0010 2146     		mov	r1, r4
 428              	.LVL61:
 429 0012 3246     		mov	r2, r6
 430              	.LVL62:
 431 0014 FFF7FEFF 		bl	my_dblsha256
 432              	.LVL63:
 433 0018 80B1     		cbz	r0, .L50
 124:base64/base58.c **** 		return -2;
 125:base64/base58.c **** 	if (memcmp(&binc[binsz - 4], buf, 4))
 434              		.loc 1 125 0
 435 001a A019     		adds	r0, r4, r6
 436 001c 6946     		mov	r1, sp
 437 001e 0422     		movs	r2, #4
 438 0020 FFF7FEFF 		bl	memcmp
 439              	.LVL64:
 440 0024 68B9     		cbnz	r0, .L51
 441 0026 0346     		mov	r3, r0
 442              	.L45:
 443              	.LVL65:
 126:base64/base58.c **** 		return -1;
 127:base64/base58.c **** 	
 128:base64/base58.c **** 	// Check number of zeros is correct AFTER verifying checksum (to avoid possibility of accessing ba
 129:base64/base58.c **** 	for (i = 0; binc[i] == '\0' && base58str[i] == '1'; ++i)
 444              		.loc 1 129 0 discriminator 1
 445 0028 E25C     		ldrb	r2, [r4, r3]	@ zero_extendqisi2
 446 002a 6AB9     		cbnz	r2, .L46
 447              		.loc 1 129 0 is_stmt 0 discriminator 2
 448 002c EA5C     		ldrb	r2, [r5, r3]	@ zero_extendqisi2
 449 002e 312A     		cmp	r2, #49
 450 0030 0FD1     		bne	.L52
 451              		.loc 1 129 0 discriminator 1
 452 0032 0133     		adds	r3, r3, #1
 453              	.LVL66:
 454 0034 F8E7     		b	.L45
 455              	.LVL67:
 456              	.L49:
 122:base64/base58.c **** 		return -4;
 457              		.loc 1 122 0 is_stmt 1
 458 0036 6FF00300 		mvn	r0, #3
 459              	.LVL68:
 460 003a 0CE0     		b	.L53
 461              	.LVL69:
 462              	.L50:
 124:base64/base58.c **** 		return -2;
 463              		.loc 1 124 0
 464 003c 6FF00100 		mvn	r0, #1
 465 0040 09E0     		b	.L53
 466              	.L51:
 126:base64/base58.c **** 		return -1;
 467              		.loc 1 126 0
 468 0042 4FF0FF30 		mov	r0, #-1
 469 0046 06E0     		b	.L53
 470              	.LVL70:
 471              	.L46:
 130:base64/base58.c **** 	{}  // Just finding the end of zeros, nothing to do in loop
 131:base64/base58.c **** 	if (binc[i] == '\0' || base58str[i] == '1')
 472              		.loc 1 131 0
 473 0048 EB5C     		ldrb	r3, [r5, r3]	@ zero_extendqisi2
 474              	.LVL71:
 475 004a 312B     		cmp	r3, #49
 132:base64/base58.c **** 		return -3;
 133:base64/base58.c **** 	
 134:base64/base58.c **** 	return binc[0];
 476              		.loc 1 134 0
 477 004c 18BF     		it	ne
 478 004e 2078     		ldrbne	r0, [r4]	@ zero_extendqisi2
 131:base64/base58.c **** 	if (binc[i] == '\0' || base58str[i] == '1')
 479              		.loc 1 131 0
 480 0050 01D1     		bne	.L53
 481              	.L52:
 132:base64/base58.c **** 		return -3;
 482              		.loc 1 132 0
 483 0052 6FF00200 		mvn	r0, #2
 484              	.LVL72:
 485              	.L53:
 135:base64/base58.c **** }
 486              		.loc 1 135 0
 487 0056 08B0     		add	sp, sp, #32
 488              		@ sp needed
 489 0058 70BD     		pop	{r4, r5, r6, pc}
 490              		.cfi_endproc
 491              	.LFE2:
 493              		.section	.text.b58enc,"ax",%progbits
 494              		.align	1
 495              		.global	b58enc
 496              		.thumb
 497              		.thumb_func
 499              	b58enc:
 500              	.LFB3:
 136:base64/base58.c **** 
 137:base64/base58.c **** static const char b58digits_ordered[] = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz
 138:base64/base58.c **** 
 139:base64/base58.c **** bool b58enc(char *b58, size_t *b58sz, const void *data, size_t binsz)
 140:base64/base58.c **** {
 501              		.loc 1 140 0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 16
 504              		@ frame_needed = 1, uses_anonymous_args = 0
 505              	.LVL73:
 506 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 507              		.cfi_def_cfa_offset 36
 508              		.cfi_offset 4, -36
 509              		.cfi_offset 5, -32
 510              		.cfi_offset 6, -28
 511              		.cfi_offset 7, -24
 512              		.cfi_offset 8, -20
 513              		.cfi_offset 9, -16
 514              		.cfi_offset 10, -12
 515              		.cfi_offset 11, -8
 516              		.cfi_offset 14, -4
 517 0004 85B0     		sub	sp, sp, #20
 518              		.cfi_def_cfa_offset 56
 519 0006 00AF     		add	r7, sp, #0
 520              		.cfi_def_cfa_register 7
 521              	.LVL74:
 522              		.loc 1 140 0
 523 0008 8346     		mov	fp, r0
 524 000a 8A46     		mov	r10, r1
 525 000c 7A60     		str	r2, [r7, #4]
 526              	.LVL75:
 141:base64/base58.c **** 	const uint8_t *bin = data;
 142:base64/base58.c **** 	int carry;
 143:base64/base58.c **** 	ssize_t i, j, high, zcount = 0;
 527              		.loc 1 143 0
 528 000e 0024     		movs	r4, #0
 529              	.LVL76:
 530              	.L56:
 144:base64/base58.c **** 	size_t size;
 145:base64/base58.c **** 	
 146:base64/base58.c **** 	while (zcount < binsz && !bin[zcount])
 531              		.loc 1 146 0 discriminator 1
 532 0010 9C42     		cmp	r4, r3
 533 0012 BC60     		str	r4, [r7, #8]
 534 0014 1AD1     		bne	.L57
 535              	.L78:
 147:base64/base58.c **** 		++zcount;
 148:base64/base58.c **** 	
 149:base64/base58.c **** 	size = (binsz - zcount) * 138 / 100 + 1;
 536              		.loc 1 149 0
 537 0016 1A1B     		subs	r2, r3, r4
 538 0018 4FF08A09 		mov	r9, #138
 539 001c 09FB02F9 		mul	r9, r9, r2
 540 0020 6422     		movs	r2, #100
 541 0022 B9FBF2F9 		udiv	r9, r9, r2
 150:base64/base58.c **** 	uint8_t buf[size];
 542              		.loc 1 150 0
 543 0026 09F10802 		add	r2, r9, #8
 544 002a 22F00702 		bic	r2, r2, #7
 545 002e ADEB020D 		sub	sp, sp, r2
 546              	.LVL77:
 149:base64/base58.c **** 	size = (binsz - zcount) * 138 / 100 + 1;
 547              		.loc 1 149 0
 548 0032 09F10106 		add	r6, r9, #1
 549              	.LVL78:
 151:base64/base58.c **** 	memset(buf, 0, size);
 550              		.loc 1 151 0
 551 0036 6846     		mov	r0, sp
 552              	.LVL79:
 553 0038 0021     		movs	r1, #0
 554 003a 3246     		mov	r2, r6
 555 003c 3B60     		str	r3, [r7]
 556 003e FC60     		str	r4, [r7, #12]
 150:base64/base58.c **** 	uint8_t buf[size];
 557              		.loc 1 150 0
 558 0040 E846     		mov	r8, sp
 559              	.LVL80:
 560              		.loc 1 151 0
 561 0042 FFF7FEFF 		bl	memset
 562              	.LVL81:
 152:base64/base58.c **** 	
 153:base64/base58.c **** 	for (i = zcount, high = size - 1; i < binsz; ++i, high = j)
 563              		.loc 1 153 0
 564 0046 CC46     		mov	ip, r9
 565 0048 3B68     		ldr	r3, [r7]
 566 004a 17E0     		b	.L58
 567              	.LVL82:
 568              	.L57:
 146:base64/base58.c **** 	while (zcount < binsz && !bin[zcount])
 569              		.loc 1 146 0 discriminator 2
 570 004c 7968     		ldr	r1, [r7, #4]
 571 004e 0A5D     		ldrb	r2, [r1, r4]	@ zero_extendqisi2
 572 0050 002A     		cmp	r2, #0
 573 0052 E0D1     		bne	.L78
 147:base64/base58.c **** 		++zcount;
 574              		.loc 1 147 0
 575 0054 0134     		adds	r4, r4, #1
 576              	.LVL83:
 577 0056 DBE7     		b	.L56
 578              	.LVL84:
 579              	.L62:
 154:base64/base58.c **** 	{
 155:base64/base58.c **** 		for (carry = bin[i], j = size - 1; (j > high) || carry; --j)
 156:base64/base58.c **** 		{
 157:base64/base58.c **** 			carry += 256 * buf[j];
 580              		.loc 1 157 0 discriminator 2
 581 0058 18F80500 		ldrb	r0, [r8, r5]	@ zero_extendqisi2
 158:base64/base58.c **** 			buf[j] = carry % 58;
 582              		.loc 1 158 0 discriminator 2
 583 005c 3A21     		movs	r1, #58
 157:base64/base58.c **** 			carry += 256 * buf[j];
 584              		.loc 1 157 0 discriminator 2
 585 005e 02EB0020 		add	r0, r2, r0, lsl #8
 586              	.LVL85:
 587              		.loc 1 158 0 discriminator 2
 588 0062 90FBF1F2 		sdiv	r2, r0, r1
 589 0066 01FB1201 		mls	r1, r1, r2, r0
 590 006a 08F80510 		strb	r1, [r8, r5]
 591              	.LVL86:
 155:base64/base58.c **** 		for (carry = bin[i], j = size - 1; (j > high) || carry; --j)
 592              		.loc 1 155 0 discriminator 2
 593 006e 013D     		subs	r5, r5, #1
 594              	.LVL87:
 595              	.L61:
 155:base64/base58.c **** 		for (carry = bin[i], j = size - 1; (j > high) || carry; --j)
 596              		.loc 1 155 0 is_stmt 0 discriminator 1
 597 0070 6545     		cmp	r5, ip
 598 0072 F1DC     		bgt	.L62
 155:base64/base58.c **** 		for (carry = bin[i], j = size - 1; (j > high) || carry; --j)
 599              		.loc 1 155 0 discriminator 3
 600 0074 002A     		cmp	r2, #0
 601 0076 EFD1     		bne	.L62
 153:base64/base58.c **** 	for (i = zcount, high = size - 1; i < binsz; ++i, high = j)
 602              		.loc 1 153 0 is_stmt 1
 603 0078 0134     		adds	r4, r4, #1
 604              	.LVL88:
 605 007a AC46     		mov	ip, r5
 606              	.LVL89:
 607              	.L58:
 153:base64/base58.c **** 	for (i = zcount, high = size - 1; i < binsz; ++i, high = j)
 608              		.loc 1 153 0 is_stmt 0 discriminator 1
 609 007c 9C42     		cmp	r4, r3
 610 007e 03D2     		bcs	.L80
 155:base64/base58.c **** 		for (carry = bin[i], j = size - 1; (j > high) || carry; --j)
 611              		.loc 1 155 0 is_stmt 1
 612 0080 7968     		ldr	r1, [r7, #4]
 613 0082 4D46     		mov	r5, r9
 614 0084 0A5D     		ldrb	r2, [r1, r4]	@ zero_extendqisi2
 615              	.LVL90:
 616 0086 F3E7     		b	.L61
 617              	.LVL91:
 618              	.L80:
 153:base64/base58.c **** 	for (i = zcount, high = size - 1; i < binsz; ++i, high = j)
 619              		.loc 1 153 0
 620 0088 0024     		movs	r4, #0
 621              	.LVL92:
 622              	.L64:
 159:base64/base58.c **** 			carry /= 58;
 160:base64/base58.c **** 		}
 161:base64/base58.c **** 	}
 162:base64/base58.c **** 	
 163:base64/base58.c **** 	for (j = 0; j < size && !buf[j]; ++j);
 623              		.loc 1 163 0 discriminator 1
 624 008a B442     		cmp	r4, r6
 625 008c 0CD3     		bcc	.L65
 626              	.L79:
 164:base64/base58.c **** 	
 165:base64/base58.c **** 	if (*b58sz <= zcount + size - j)
 627              		.loc 1 165 0
 628 008e BB68     		ldr	r3, [r7, #8]
 629 0090 DAF80020 		ldr	r2, [r10]
 630 0094 3344     		add	r3, r3, r6
 631 0096 1B1B     		subs	r3, r3, r4
 632 0098 9A42     		cmp	r2, r3
 633 009a 2546     		mov	r5, r4
 634 009c 0AD8     		bhi	.L77
 166:base64/base58.c **** 	{
 167:base64/base58.c **** 		*b58sz = zcount + size - j + 1;
 635              		.loc 1 167 0
 636 009e 0133     		adds	r3, r3, #1
 637 00a0 CAF80030 		str	r3, [r10]
 168:base64/base58.c **** 		return false;
 638              		.loc 1 168 0
 639 00a4 0020     		movs	r0, #0
 640 00a6 22E0     		b	.L70
 641              	.L65:
 163:base64/base58.c **** 	for (j = 0; j < size && !buf[j]; ++j);
 642              		.loc 1 163 0 discriminator 2
 643 00a8 18F80430 		ldrb	r3, [r8, r4]	@ zero_extendqisi2
 644 00ac 002B     		cmp	r3, #0
 645 00ae EED1     		bne	.L79
 163:base64/base58.c **** 	for (j = 0; j < size && !buf[j]; ++j);
 646              		.loc 1 163 0 is_stmt 0 discriminator 1
 647 00b0 0134     		adds	r4, r4, #1
 648              	.LVL93:
 649 00b2 EAE7     		b	.L64
 650              	.L77:
 169:base64/base58.c **** 	}
 170:base64/base58.c **** 	
 171:base64/base58.c **** 	if (zcount)
 651              		.loc 1 171 0 is_stmt 1
 652 00b4 FB68     		ldr	r3, [r7, #12]
 653 00b6 23B1     		cbz	r3, .L72
 172:base64/base58.c **** 		memset(b58, '1', zcount);
 654              		.loc 1 172 0
 655 00b8 5846     		mov	r0, fp
 656 00ba 3121     		movs	r1, #49
 657 00bc BA68     		ldr	r2, [r7, #8]
 658 00be FFF7FEFF 		bl	memset
 659              	.LVL94:
 660              	.L72:
 661 00c2 FB68     		ldr	r3, [r7, #12]
 173:base64/base58.c **** 	for (i = zcount; j < size; ++i, ++j)
 662              		.loc 1 173 0 discriminator 1
 663 00c4 B442     		cmp	r4, r6
 664 00c6 C5EB0302 		rsb	r2, r5, r3
 665 00ca 02EB0403 		add	r3, r2, r4
 666              	.LVL95:
 667 00ce 07D2     		bcs	.L81
 174:base64/base58.c **** 		b58[i] = b58digits_ordered[buf[j]];
 668              		.loc 1 174 0 discriminator 2
 669 00d0 18F80430 		ldrb	r3, [r8, r4]	@ zero_extendqisi2
 670              	.LVL96:
 671 00d4 0849     		ldr	r1, .L82
 672 00d6 5A44     		add	r2, r2, fp
 673              	.LVL97:
 674 00d8 CB5C     		ldrb	r3, [r1, r3]	@ zero_extendqisi2
 675 00da 1355     		strb	r3, [r2, r4]
 676              	.LVL98:
 173:base64/base58.c **** 	for (i = zcount; j < size; ++i, ++j)
 677              		.loc 1 173 0 discriminator 2
 678 00dc 0134     		adds	r4, r4, #1
 679              	.LVL99:
 680 00de F0E7     		b	.L72
 681              	.LVL100:
 682              	.L81:
 175:base64/base58.c **** 	b58[i] = '\0';
 683              		.loc 1 175 0
 684 00e0 0022     		movs	r2, #0
 685 00e2 0BF80320 		strb	r2, [fp, r3]
 176:base64/base58.c **** 	*b58sz = i + 1;
 686              		.loc 1 176 0
 687 00e6 0133     		adds	r3, r3, #1
 688              	.LVL101:
 689 00e8 CAF80030 		str	r3, [r10]
 177:base64/base58.c **** 	
 178:base64/base58.c **** 	return true;
 690              		.loc 1 178 0
 691 00ec 0120     		movs	r0, #1
 692              	.LVL102:
 693              	.L70:
 179:base64/base58.c **** }
 694              		.loc 1 179 0
 695 00ee 1437     		adds	r7, r7, #20
 696              	.LVL103:
 697 00f0 BD46     		mov	sp, r7
 698              		@ sp needed
 699 00f2 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 700              	.LVL104:
 701              	.L83:
 702 00f6 00BF     		.align	2
 703              	.L82:
 704 00f8 00000000 		.word	.LANCHOR2
 705              		.cfi_endproc
 706              	.LFE3:
 708              		.section	.text.b58check_enc,"ax",%progbits
 709              		.align	1
 710              		.global	b58check_enc
 711              		.thumb
 712              		.thumb_func
 714              	b58check_enc:
 715              	.LFB4:
 180:base64/base58.c **** 
 181:base64/base58.c **** bool b58check_enc(char *b58c, size_t *b58c_sz, uint8_t ver, const void *data, size_t datasz)
 182:base64/base58.c **** {
 716              		.loc 1 182 0
 717              		.cfi_startproc
 718              		@ args = 4, pretend = 0, frame = 0
 719              		@ frame_needed = 1, uses_anonymous_args = 0
 720              	.LVL105:
 721 0000 2DE9D043 		push	{r4, r6, r7, r8, r9, lr}
 722              		.cfi_def_cfa_offset 24
 723              		.cfi_offset 4, -24
 724              		.cfi_offset 6, -20
 725              		.cfi_offset 7, -16
 726              		.cfi_offset 8, -12
 727              		.cfi_offset 9, -8
 728              		.cfi_offset 14, -4
 729 0004 00AF     		add	r7, sp, #0
 730              		.cfi_def_cfa_register 7
 731              		.loc 1 182 0
 732 0006 BC69     		ldr	r4, [r7, #24]
 733              	.LVL106:
 734 0008 0E46     		mov	r6, r1
 183:base64/base58.c **** 	uint8_t buf[1 + datasz + 0x20];
 735              		.loc 1 183 0
 736 000a 04F12801 		add	r1, r4, #40
 737              	.LVL107:
 738 000e 21F00701 		bic	r1, r1, #7
 739 0012 ADEB010D 		sub	sp, sp, r1
 740              	.LVL108:
 182:base64/base58.c **** {
 741              		.loc 1 182 0
 742 0016 8146     		mov	r9, r0
 184:base64/base58.c **** 	uint8_t *hash = &buf[1 + datasz];
 185:base64/base58.c **** 	
 186:base64/base58.c **** 	buf[0] = ver;
 743              		.loc 1 186 0
 744 0018 6846     		mov	r0, sp
 745              	.LVL109:
 184:base64/base58.c **** 	uint8_t *hash = &buf[1 + datasz];
 746              		.loc 1 184 0
 747 001a 04F10108 		add	r8, r4, #1
 748              	.LVL110:
 749              		.loc 1 186 0
 750 001e 00F8012B 		strb	r2, [r0], #1
 187:base64/base58.c **** 	memcpy(&buf[1], data, datasz);
 751              		.loc 1 187 0
 752 0022 1946     		mov	r1, r3
 753 0024 2246     		mov	r2, r4
 754              	.LVL111:
 755 0026 FFF7FEFF 		bl	memcpy
 756              	.LVL112:
 188:base64/base58.c **** 	if (!my_dblsha256(hash, buf, datasz + 1))
 757              		.loc 1 188 0
 758 002a 0DEB0800 		add	r0, sp, r8
 759 002e 6946     		mov	r1, sp
 760 0030 4246     		mov	r2, r8
 761 0032 FFF7FEFF 		bl	my_dblsha256
 762              	.LVL113:
 763 0036 08B9     		cbnz	r0, .L85
 189:base64/base58.c **** 	{
 190:base64/base58.c **** 		*b58c_sz = 0;
 764              		.loc 1 190 0
 765 0038 3060     		str	r0, [r6]
 191:base64/base58.c **** 		return false;
 766              		.loc 1 191 0
 767 003a 05E0     		b	.L86
 768              	.L85:
 192:base64/base58.c **** 	}
 193:base64/base58.c **** 	
 194:base64/base58.c **** 	return b58enc(b58c, b58c_sz, buf, 1 + datasz + 4);
 769              		.loc 1 194 0
 770 003c 4846     		mov	r0, r9
 771 003e 3146     		mov	r1, r6
 772 0040 6A46     		mov	r2, sp
 773 0042 631D     		adds	r3, r4, #5
 774 0044 FFF7FEFF 		bl	b58enc
 775              	.LVL114:
 776              	.L86:
 195:base64/base58.c **** }
 777              		.loc 1 195 0
 778 0048 BD46     		mov	sp, r7
 779              	.LVL115:
 780              		@ sp needed
 781 004a BDE8D083 		pop	{r4, r6, r7, r8, r9, pc}
 782              		.cfi_endproc
 783              	.LFE4:
 785              		.global	b58_sha256_impl
 786              		.section	.rodata.b58digits_map,"a",%progbits
 787              		.set	.LANCHOR1,. + 0
 790              	b58digits_map:
 791 0000 FF       		.byte	-1
 792 0001 FF       		.byte	-1
 793 0002 FF       		.byte	-1
 794 0003 FF       		.byte	-1
 795 0004 FF       		.byte	-1
 796 0005 FF       		.byte	-1
 797 0006 FF       		.byte	-1
 798 0007 FF       		.byte	-1
 799 0008 FF       		.byte	-1
 800 0009 FF       		.byte	-1
 801 000a FF       		.byte	-1
 802 000b FF       		.byte	-1
 803 000c FF       		.byte	-1
 804 000d FF       		.byte	-1
 805 000e FF       		.byte	-1
 806 000f FF       		.byte	-1
 807 0010 FF       		.byte	-1
 808 0011 FF       		.byte	-1
 809 0012 FF       		.byte	-1
 810 0013 FF       		.byte	-1
 811 0014 FF       		.byte	-1
 812 0015 FF       		.byte	-1
 813 0016 FF       		.byte	-1
 814 0017 FF       		.byte	-1
 815 0018 FF       		.byte	-1
 816 0019 FF       		.byte	-1
 817 001a FF       		.byte	-1
 818 001b FF       		.byte	-1
 819 001c FF       		.byte	-1
 820 001d FF       		.byte	-1
 821 001e FF       		.byte	-1
 822 001f FF       		.byte	-1
 823 0020 FF       		.byte	-1
 824 0021 FF       		.byte	-1
 825 0022 FF       		.byte	-1
 826 0023 FF       		.byte	-1
 827 0024 FF       		.byte	-1
 828 0025 FF       		.byte	-1
 829 0026 FF       		.byte	-1
 830 0027 FF       		.byte	-1
 831 0028 FF       		.byte	-1
 832 0029 FF       		.byte	-1
 833 002a FF       		.byte	-1
 834 002b FF       		.byte	-1
 835 002c FF       		.byte	-1
 836 002d FF       		.byte	-1
 837 002e FF       		.byte	-1
 838 002f FF       		.byte	-1
 839 0030 FF       		.byte	-1
 840 0031 00       		.byte	0
 841 0032 01       		.byte	1
 842 0033 02       		.byte	2
 843 0034 03       		.byte	3
 844 0035 04       		.byte	4
 845 0036 05       		.byte	5
 846 0037 06       		.byte	6
 847 0038 07       		.byte	7
 848 0039 08       		.byte	8
 849 003a FF       		.byte	-1
 850 003b FF       		.byte	-1
 851 003c FF       		.byte	-1
 852 003d FF       		.byte	-1
 853 003e FF       		.byte	-1
 854 003f FF       		.byte	-1
 855 0040 FF       		.byte	-1
 856 0041 09       		.byte	9
 857 0042 0A       		.byte	10
 858 0043 0B       		.byte	11
 859 0044 0C       		.byte	12
 860 0045 0D       		.byte	13
 861 0046 0E       		.byte	14
 862 0047 0F       		.byte	15
 863 0048 10       		.byte	16
 864 0049 FF       		.byte	-1
 865 004a 11       		.byte	17
 866 004b 12       		.byte	18
 867 004c 13       		.byte	19
 868 004d 14       		.byte	20
 869 004e 15       		.byte	21
 870 004f FF       		.byte	-1
 871 0050 16       		.byte	22
 872 0051 17       		.byte	23
 873 0052 18       		.byte	24
 874 0053 19       		.byte	25
 875 0054 1A       		.byte	26
 876 0055 1B       		.byte	27
 877 0056 1C       		.byte	28
 878 0057 1D       		.byte	29
 879 0058 1E       		.byte	30
 880 0059 1F       		.byte	31
 881 005a 20       		.byte	32
 882 005b FF       		.byte	-1
 883 005c FF       		.byte	-1
 884 005d FF       		.byte	-1
 885 005e FF       		.byte	-1
 886 005f FF       		.byte	-1
 887 0060 FF       		.byte	-1
 888 0061 21       		.byte	33
 889 0062 22       		.byte	34
 890 0063 23       		.byte	35
 891 0064 24       		.byte	36
 892 0065 25       		.byte	37
 893 0066 26       		.byte	38
 894 0067 27       		.byte	39
 895 0068 28       		.byte	40
 896 0069 29       		.byte	41
 897 006a 2A       		.byte	42
 898 006b 2B       		.byte	43
 899 006c FF       		.byte	-1
 900 006d 2C       		.byte	44
 901 006e 2D       		.byte	45
 902 006f 2E       		.byte	46
 903 0070 2F       		.byte	47
 904 0071 30       		.byte	48
 905 0072 31       		.byte	49
 906 0073 32       		.byte	50
 907 0074 33       		.byte	51
 908 0075 34       		.byte	52
 909 0076 35       		.byte	53
 910 0077 36       		.byte	54
 911 0078 37       		.byte	55
 912 0079 38       		.byte	56
 913 007a 39       		.byte	57
 914 007b FF       		.byte	-1
 915 007c FF       		.byte	-1
 916 007d FF       		.byte	-1
 917 007e FF       		.byte	-1
 918 007f FF       		.byte	-1
 919              		.section	.rodata.b58digits_ordered,"a",%progbits
 920              		.set	.LANCHOR2,. + 0
 923              	b58digits_ordered:
 924 0000 31323334 		.ascii	"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrs"
 924      35363738 
 924      39414243 
 924      44454647 
 924      484A4B4C 
 925 0033 74757677 		.ascii	"tuvwxyz\000"
 925      78797A00 
 926              		.section	.bss.b58_sha256_impl,"aw",%nobits
 927              		.align	2
 928              		.set	.LANCHOR0,. + 0
 931              	b58_sha256_impl:
 932 0000 00000000 		.space	4
 933              		.text
 934              	.Letext0:
 935              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 936              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\mach
 937              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdi
 938              		.file 5 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\sys\
 939              		.file 6 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\sys\
 940              		.file 7 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stri
DEFINED SYMBOLS
                            *ABS*:00000000 base58.c
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:19     .text.my_dblsha256:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:23     .text.my_dblsha256:00000000 my_dblsha256
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:67     .text.my_dblsha256:00000024 $d
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:72     .text.b58tobin:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:77     .text.b58tobin:00000000 b58tobin
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:389    .text.b58tobin:00000190 $d
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:394    .text.b58check:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:399    .text.b58check:00000000 b58check
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:494    .text.b58enc:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:499    .text.b58enc:00000000 b58enc
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:704    .text.b58enc:000000f8 $d
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:709    .text.b58check_enc:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:714    .text.b58check_enc:00000000 b58check_enc
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:931    .bss.b58_sha256_impl:00000000 b58_sha256_impl
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:790    .rodata.b58digits_map:00000000 b58digits_map
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:923    .rodata.b58digits_ordered:00000000 b58digits_ordered
C:\Users\haifisch\AppData\Local\Temp\ccgbVmIE.s:927    .bss.b58_sha256_impl:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
strlen
memset
memcmp
memcpy
