   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"usb_core.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.Standard_GetConfiguration,"ax",%progbits
  16              		.align	1
  17              		.global	Standard_GetConfiguration
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	Standard_GetConfiguration:
  24              	.LFB0:
  25              		.file 1 "usb_lib/usb_core.c"
   1:usb_lib/usb_core.c **** /******************** (C) COPYRIGHT 2008 STMicroelectronics ********************
   2:usb_lib/usb_core.c **** * File Name          : usb_core.c
   3:usb_lib/usb_core.c **** * Author             : MCD Application Team
   4:usb_lib/usb_core.c **** * Version            : V2.2.1
   5:usb_lib/usb_core.c **** * Date               : 09/22/2008
   6:usb_lib/usb_core.c **** * Description        : Standard protocol processing (USB v2.0)
   7:usb_lib/usb_core.c **** ********************************************************************************
   8:usb_lib/usb_core.c **** * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
   9:usb_lib/usb_core.c **** * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
  10:usb_lib/usb_core.c **** * AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
  11:usb_lib/usb_core.c **** * INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
  12:usb_lib/usb_core.c **** * CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
  13:usb_lib/usb_core.c **** * INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  14:usb_lib/usb_core.c **** *******************************************************************************/
  15:usb_lib/usb_core.c **** 
  16:usb_lib/usb_core.c **** /* Includes ------------------------------------------------------------------*/
  17:usb_lib/usb_core.c **** #include "usb_lib.h"
  18:usb_lib/usb_core.c **** /* Private typedef -----------------------------------------------------------*/
  19:usb_lib/usb_core.c **** /* Private define ------------------------------------------------------------*/
  20:usb_lib/usb_core.c **** #define ValBit(VAR,Place)    (VAR & (1 << Place))
  21:usb_lib/usb_core.c **** #define SetBit(VAR,Place)    (VAR |= (1 << Place))
  22:usb_lib/usb_core.c **** #define ClrBit(VAR,Place)    (VAR &= ((1 << Place) ^ 255))
  23:usb_lib/usb_core.c **** 
  24:usb_lib/usb_core.c **** #define Send0LengthData() { _SetEPTxCount(ENDP0, 0); \
  25:usb_lib/usb_core.c ****     vSetEPTxStatus(EP_TX_VALID); \
  26:usb_lib/usb_core.c ****   }
  27:usb_lib/usb_core.c **** 
  28:usb_lib/usb_core.c **** #define vSetEPRxStatus(st) (SaveRState = st)
  29:usb_lib/usb_core.c **** #define vSetEPTxStatus(st) (SaveTState = st)
  30:usb_lib/usb_core.c **** 
  31:usb_lib/usb_core.c **** #define USB_StatusIn() Send0LengthData()
  32:usb_lib/usb_core.c **** #define USB_StatusOut() vSetEPRxStatus(EP_RX_VALID)
  33:usb_lib/usb_core.c **** 
  34:usb_lib/usb_core.c **** /* Private macro -------------------------------------------------------------*/
  35:usb_lib/usb_core.c **** /* Private variables ---------------------------------------------------------*/
  36:usb_lib/usb_core.c **** u16_u8 StatusInfo;
  37:usb_lib/usb_core.c **** bool Data_Mul_MaxPacketSize = FALSE;
  38:usb_lib/usb_core.c **** /* Private function prototypes -----------------------------------------------*/
  39:usb_lib/usb_core.c **** static void DataStageOut(void);
  40:usb_lib/usb_core.c **** static void DataStageIn(void);
  41:usb_lib/usb_core.c **** static void NoData_Setup0(void);
  42:usb_lib/usb_core.c **** static void Data_Setup0(void);
  43:usb_lib/usb_core.c **** /* Private functions ---------------------------------------------------------*/
  44:usb_lib/usb_core.c **** 
  45:usb_lib/usb_core.c **** /*******************************************************************************
  46:usb_lib/usb_core.c **** * Function Name  : Standard_GetConfiguration.
  47:usb_lib/usb_core.c **** * Description    : Return the current configuration variable address.
  48:usb_lib/usb_core.c **** * Input          : Length - How many bytes are needed.
  49:usb_lib/usb_core.c **** * Output         : None.
  50:usb_lib/usb_core.c **** * Return         : Return 1 , if the request is invalid when "Length" is 0.
  51:usb_lib/usb_core.c **** *                  Return "Buffer" if the "Length" is not 0.
  52:usb_lib/usb_core.c **** *******************************************************************************/
  53:usb_lib/usb_core.c **** u8 *Standard_GetConfiguration(u16 Length)
  54:usb_lib/usb_core.c **** {
  26              		.loc 1 54 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              	.LVL0:
  31 0000 10B5     		push	{r4, lr}
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 4, -8
  34              		.cfi_offset 14, -4
  35 0002 064C     		ldr	r4, .L4
  55:usb_lib/usb_core.c ****   if (Length == 0)
  36              		.loc 1 55 0
  37 0004 18B9     		cbnz	r0, .L2
  56:usb_lib/usb_core.c ****   {
  57:usb_lib/usb_core.c ****     pInformation->Ctrl_Info.Usb_wLength =
  38              		.loc 1 57 0
  39 0006 0122     		movs	r2, #1
  40 0008 2368     		ldr	r3, [r4]
  41 000a 1A82     		strh	r2, [r3, #16]	@ movhi
  42              	.LVL1:
  43              	.L1:
  58:usb_lib/usb_core.c ****       sizeof(pInformation->Current_Configuration);
  59:usb_lib/usb_core.c ****     return 0;
  60:usb_lib/usb_core.c ****   }
  61:usb_lib/usb_core.c ****   pUser_Standard_Requests->User_GetConfiguration();
  62:usb_lib/usb_core.c ****   return (u8 *)&pInformation->Current_Configuration;
  63:usb_lib/usb_core.c **** }
  44              		.loc 1 63 0
  45 000c 10BD     		pop	{r4, pc}
  46              	.LVL2:
  47              	.L2:
  61:usb_lib/usb_core.c ****   return (u8 *)&pInformation->Current_Configuration;
  48              		.loc 1 61 0
  49 000e 044B     		ldr	r3, .L4+4
  50 0010 1B68     		ldr	r3, [r3]
  51 0012 1B68     		ldr	r3, [r3]
  52 0014 9847     		blx	r3
  53              	.LVL3:
  62:usb_lib/usb_core.c **** }
  54              		.loc 1 62 0
  55 0016 2068     		ldr	r0, [r4]
  56 0018 0A30     		adds	r0, r0, #10
  57 001a F7E7     		b	.L1
  58              	.L5:
  59              		.align	2
  60              	.L4:
  61 001c 00000000 		.word	pInformation
  62 0020 00000000 		.word	pUser_Standard_Requests
  63              		.cfi_endproc
  64              	.LFE0:
  66              		.section	.text.Standard_GetInterface,"ax",%progbits
  67              		.align	1
  68              		.global	Standard_GetInterface
  69              		.syntax unified
  70              		.thumb
  71              		.thumb_func
  72              		.fpu softvfp
  74              	Standard_GetInterface:
  75              	.LFB2:
  64:usb_lib/usb_core.c **** 
  65:usb_lib/usb_core.c **** /*******************************************************************************
  66:usb_lib/usb_core.c **** * Function Name  : Standard_SetConfiguration.
  67:usb_lib/usb_core.c **** * Description    : This routine is called to set the configuration value
  68:usb_lib/usb_core.c **** *                  Then each class should configure device themself.
  69:usb_lib/usb_core.c **** * Input          : None.
  70:usb_lib/usb_core.c **** * Output         : None.
  71:usb_lib/usb_core.c **** * Return         : Return USB_SUCCESS, if the request is performed.
  72:usb_lib/usb_core.c **** *                  Return USB_UNSUPPORT, if the request is invalid.
  73:usb_lib/usb_core.c **** *******************************************************************************/
  74:usb_lib/usb_core.c **** RESULT Standard_SetConfiguration(void)
  75:usb_lib/usb_core.c **** {
  76:usb_lib/usb_core.c **** 
  77:usb_lib/usb_core.c ****   if ((pInformation->USBwValue0 <=
  78:usb_lib/usb_core.c ****       Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
  79:usb_lib/usb_core.c ****       && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
  80:usb_lib/usb_core.c ****   {
  81:usb_lib/usb_core.c ****     pInformation->Current_Configuration = pInformation->USBwValue0;
  82:usb_lib/usb_core.c ****     pUser_Standard_Requests->User_SetConfiguration();
  83:usb_lib/usb_core.c ****     return USB_SUCCESS;
  84:usb_lib/usb_core.c ****   }
  85:usb_lib/usb_core.c ****   else
  86:usb_lib/usb_core.c ****   {
  87:usb_lib/usb_core.c ****     return USB_UNSUPPORT;
  88:usb_lib/usb_core.c ****   }
  89:usb_lib/usb_core.c **** }
  90:usb_lib/usb_core.c **** 
  91:usb_lib/usb_core.c **** /*******************************************************************************
  92:usb_lib/usb_core.c **** * Function Name  : Standard_GetInterface.
  93:usb_lib/usb_core.c **** * Description    : Return the Alternate Setting of the current interface.
  94:usb_lib/usb_core.c **** * Input          : Length - How many bytes are needed.
  95:usb_lib/usb_core.c **** * Output         : None.
  96:usb_lib/usb_core.c **** * Return         : Return 0, if the request is invalid when "Length" is 0.
  97:usb_lib/usb_core.c **** *                  Return "Buffer" if the "Length" is not 0.
  98:usb_lib/usb_core.c **** *******************************************************************************/
  99:usb_lib/usb_core.c **** u8 *Standard_GetInterface(u16 Length)
 100:usb_lib/usb_core.c **** {
  76              		.loc 1 100 0
  77              		.cfi_startproc
  78              		@ args = 0, pretend = 0, frame = 0
  79              		@ frame_needed = 0, uses_anonymous_args = 0
  80              	.LVL4:
  81 0000 10B5     		push	{r4, lr}
  82              		.cfi_def_cfa_offset 8
  83              		.cfi_offset 4, -8
  84              		.cfi_offset 14, -4
  85 0002 064C     		ldr	r4, .L9
 101:usb_lib/usb_core.c ****   if (Length == 0)
  86              		.loc 1 101 0
  87 0004 18B9     		cbnz	r0, .L7
 102:usb_lib/usb_core.c ****   {
 103:usb_lib/usb_core.c ****     pInformation->Ctrl_Info.Usb_wLength =
  88              		.loc 1 103 0
  89 0006 0122     		movs	r2, #1
  90 0008 2368     		ldr	r3, [r4]
  91 000a 1A82     		strh	r2, [r3, #16]	@ movhi
  92              	.LVL5:
  93              	.L6:
 104:usb_lib/usb_core.c ****       sizeof(pInformation->Current_AlternateSetting);
 105:usb_lib/usb_core.c ****     return 0;
 106:usb_lib/usb_core.c ****   }
 107:usb_lib/usb_core.c ****   pUser_Standard_Requests->User_GetInterface();
 108:usb_lib/usb_core.c ****   return (u8 *)&pInformation->Current_AlternateSetting;
 109:usb_lib/usb_core.c **** }
  94              		.loc 1 109 0
  95 000c 10BD     		pop	{r4, pc}
  96              	.LVL6:
  97              	.L7:
 107:usb_lib/usb_core.c ****   return (u8 *)&pInformation->Current_AlternateSetting;
  98              		.loc 1 107 0
  99 000e 044B     		ldr	r3, .L9+4
 100 0010 1B68     		ldr	r3, [r3]
 101 0012 9B68     		ldr	r3, [r3, #8]
 102 0014 9847     		blx	r3
 103              	.LVL7:
 108:usb_lib/usb_core.c **** }
 104              		.loc 1 108 0
 105 0016 2068     		ldr	r0, [r4]
 106 0018 0C30     		adds	r0, r0, #12
 107 001a F7E7     		b	.L6
 108              	.L10:
 109              		.align	2
 110              	.L9:
 111 001c 00000000 		.word	pInformation
 112 0020 00000000 		.word	pUser_Standard_Requests
 113              		.cfi_endproc
 114              	.LFE2:
 116              		.section	.text.Standard_GetStatus,"ax",%progbits
 117              		.align	1
 118              		.global	Standard_GetStatus
 119              		.syntax unified
 120              		.thumb
 121              		.thumb_func
 122              		.fpu softvfp
 124              	Standard_GetStatus:
 125              	.LFB4:
 110:usb_lib/usb_core.c **** 
 111:usb_lib/usb_core.c **** /*******************************************************************************
 112:usb_lib/usb_core.c **** * Function Name  : Standard_SetInterface.
 113:usb_lib/usb_core.c **** * Description    : This routine is called to set the interface.
 114:usb_lib/usb_core.c **** *                  Then each class should configure the interface them self.
 115:usb_lib/usb_core.c **** * Input          : None.
 116:usb_lib/usb_core.c **** * Output         : None.
 117:usb_lib/usb_core.c **** * Return         : - Return USB_SUCCESS, if the request is performed.
 118:usb_lib/usb_core.c **** *                  - Return USB_UNSUPPORT, if the request is invalid.
 119:usb_lib/usb_core.c **** *******************************************************************************/
 120:usb_lib/usb_core.c **** RESULT Standard_SetInterface(void)
 121:usb_lib/usb_core.c **** {
 122:usb_lib/usb_core.c ****   RESULT Re;
 123:usb_lib/usb_core.c ****   /*Test if the specified Interface and Alternate Setting are supported by
 124:usb_lib/usb_core.c ****     the application Firmware*/
 125:usb_lib/usb_core.c ****   Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0
 126:usb_lib/usb_core.c **** 
 127:usb_lib/usb_core.c ****   if (pInformation->Current_Configuration != 0)
 128:usb_lib/usb_core.c ****   {
 129:usb_lib/usb_core.c ****     if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
 130:usb_lib/usb_core.c ****         || (pInformation->USBwValue1 != 0))
 131:usb_lib/usb_core.c ****     {
 132:usb_lib/usb_core.c ****       return  USB_UNSUPPORT;
 133:usb_lib/usb_core.c ****     }
 134:usb_lib/usb_core.c ****     else if (Re == USB_SUCCESS)
 135:usb_lib/usb_core.c ****     {
 136:usb_lib/usb_core.c ****       pUser_Standard_Requests->User_SetInterface();
 137:usb_lib/usb_core.c ****       pInformation->Current_Interface = pInformation->USBwIndex0;
 138:usb_lib/usb_core.c ****       pInformation->Current_AlternateSetting = pInformation->USBwValue0;
 139:usb_lib/usb_core.c ****       return USB_SUCCESS;
 140:usb_lib/usb_core.c ****     }
 141:usb_lib/usb_core.c **** 
 142:usb_lib/usb_core.c ****   }
 143:usb_lib/usb_core.c **** 
 144:usb_lib/usb_core.c ****   return USB_UNSUPPORT;
 145:usb_lib/usb_core.c **** }
 146:usb_lib/usb_core.c **** 
 147:usb_lib/usb_core.c **** /*******************************************************************************
 148:usb_lib/usb_core.c **** * Function Name  : Standard_GetStatus.
 149:usb_lib/usb_core.c **** * Description    : Copy the device request data to "StatusInfo buffer".
 150:usb_lib/usb_core.c **** * Input          : - Length - How many bytes are needed.
 151:usb_lib/usb_core.c **** * Output         : None.
 152:usb_lib/usb_core.c **** * Return         : Return 0, if the request is at end of data block,
 153:usb_lib/usb_core.c **** *                  or is invalid when "Length" is 0.
 154:usb_lib/usb_core.c **** *******************************************************************************/
 155:usb_lib/usb_core.c **** u8 *Standard_GetStatus(u16 Length)
 156:usb_lib/usb_core.c **** {
 126              		.loc 1 156 0
 127              		.cfi_startproc
 128              		@ args = 0, pretend = 0, frame = 0
 129              		@ frame_needed = 0, uses_anonymous_args = 0
 130              	.LVL8:
 131 0000 1E4B     		ldr	r3, .L30
 132 0002 10B5     		push	{r4, lr}
 133              		.cfi_def_cfa_offset 8
 134              		.cfi_offset 4, -8
 135              		.cfi_offset 14, -4
 136 0004 1C68     		ldr	r4, [r3]
 137 0006 0023     		movs	r3, #0
 157:usb_lib/usb_core.c ****   if (Length == 0)
 138              		.loc 1 157 0
 139 0008 10B9     		cbnz	r0, .L12
 158:usb_lib/usb_core.c ****   {
 159:usb_lib/usb_core.c ****     pInformation->Ctrl_Info.Usb_wLength = 2;
 140              		.loc 1 159 0
 141 000a 0223     		movs	r3, #2
 142 000c 2382     		strh	r3, [r4, #16]	@ movhi
 143              	.LVL9:
 144              	.L11:
 160:usb_lib/usb_core.c ****     return 0;
 161:usb_lib/usb_core.c ****   }
 162:usb_lib/usb_core.c **** 
 163:usb_lib/usb_core.c ****   StatusInfo.w = 0;
 164:usb_lib/usb_core.c ****   /* Reset Status Information */
 165:usb_lib/usb_core.c **** 
 166:usb_lib/usb_core.c ****   if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 167:usb_lib/usb_core.c ****   {
 168:usb_lib/usb_core.c ****     /*Get Device Status */
 169:usb_lib/usb_core.c ****     u8 Feature = pInformation->Current_Feature;
 170:usb_lib/usb_core.c **** 
 171:usb_lib/usb_core.c ****     /* Remote Wakeup enabled */
 172:usb_lib/usb_core.c ****     if (ValBit(Feature, 5))
 173:usb_lib/usb_core.c ****     {
 174:usb_lib/usb_core.c ****       SetBit(StatusInfo0, 1);
 175:usb_lib/usb_core.c ****     }
 176:usb_lib/usb_core.c **** 
 177:usb_lib/usb_core.c ****     /* Bus-powered */
 178:usb_lib/usb_core.c ****     if (ValBit(Feature, 6))
 179:usb_lib/usb_core.c ****     {
 180:usb_lib/usb_core.c ****       ClrBit(StatusInfo0, 0);
 181:usb_lib/usb_core.c ****     }
 182:usb_lib/usb_core.c ****     else /* Self-powered */
 183:usb_lib/usb_core.c ****     {
 184:usb_lib/usb_core.c ****       SetBit(StatusInfo0, 0);
 185:usb_lib/usb_core.c ****     }
 186:usb_lib/usb_core.c ****   }
 187:usb_lib/usb_core.c ****   /*Interface Status*/
 188:usb_lib/usb_core.c ****   else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 189:usb_lib/usb_core.c ****   {
 190:usb_lib/usb_core.c ****     return (u8 *)&StatusInfo;
 191:usb_lib/usb_core.c ****   }
 192:usb_lib/usb_core.c ****   /*Get EndPoint Status*/
 193:usb_lib/usb_core.c ****   else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 194:usb_lib/usb_core.c ****   {
 195:usb_lib/usb_core.c ****     u8 Related_Endpoint;
 196:usb_lib/usb_core.c ****     u8 wIndex0 = pInformation->USBwIndex0;
 197:usb_lib/usb_core.c **** 
 198:usb_lib/usb_core.c ****     Related_Endpoint = (wIndex0 & 0x0f);
 199:usb_lib/usb_core.c ****     if (ValBit(wIndex0, 7))
 200:usb_lib/usb_core.c ****     {
 201:usb_lib/usb_core.c ****       /* IN endpoint */
 202:usb_lib/usb_core.c ****       if (_GetTxStallStatus(Related_Endpoint))
 203:usb_lib/usb_core.c ****       {
 204:usb_lib/usb_core.c ****         SetBit(StatusInfo0, 0); /* IN Endpoint stalled */
 205:usb_lib/usb_core.c ****       }
 206:usb_lib/usb_core.c ****     }
 207:usb_lib/usb_core.c ****     else
 208:usb_lib/usb_core.c ****     {
 209:usb_lib/usb_core.c ****       /* OUT endpoint */
 210:usb_lib/usb_core.c ****       if (_GetRxStallStatus(Related_Endpoint))
 211:usb_lib/usb_core.c ****       {
 212:usb_lib/usb_core.c ****         SetBit(StatusInfo0, 0); /* OUT Endpoint stalled */
 213:usb_lib/usb_core.c ****       }
 214:usb_lib/usb_core.c ****     }
 215:usb_lib/usb_core.c **** 
 216:usb_lib/usb_core.c ****   }
 217:usb_lib/usb_core.c ****   else
 218:usb_lib/usb_core.c ****   {
 219:usb_lib/usb_core.c ****     return NULL;
 220:usb_lib/usb_core.c ****   }
 221:usb_lib/usb_core.c ****   pUser_Standard_Requests->User_GetStatus();
 222:usb_lib/usb_core.c ****   return (u8 *)&StatusInfo;
 223:usb_lib/usb_core.c **** }
 145              		.loc 1 223 0
 146 000e 10BD     		pop	{r4, pc}
 147              	.LVL10:
 148              	.L12:
 163:usb_lib/usb_core.c ****   /* Reset Status Information */
 149              		.loc 1 163 0
 150 0010 1B48     		ldr	r0, .L30+4
 151              	.LVL11:
 152 0012 0380     		strh	r3, [r0]	@ movhi
 153 0014 2178     		ldrb	r1, [r4]	@ zero_extendqisi2
 154 0016 0246     		mov	r2, r0
 166:usb_lib/usb_core.c ****   {
 155              		.loc 1 166 0
 156 0018 11F07F01 		ands	r1, r1, #127
 157 001c 12D1     		bne	.L14
 158              	.LBB2:
 169:usb_lib/usb_core.c **** 
 159              		.loc 1 169 0
 160 001e 617A     		ldrb	r1, [r4, #9]	@ zero_extendqisi2
 161              	.LVL12:
 172:usb_lib/usb_core.c ****     {
 162              		.loc 1 172 0
 163 0020 8C06     		lsls	r4, r1, #26
 174:usb_lib/usb_core.c ****     }
 164              		.loc 1 174 0
 165 0022 44BF     		itt	mi
 166 0024 0223     		movmi	r3, #2
 167 0026 0370     		strbmi	r3, [r0]
 168 0028 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 178:usb_lib/usb_core.c ****     {
 169              		.loc 1 178 0
 170 002a 4806     		lsls	r0, r1, #25
 180:usb_lib/usb_core.c ****     }
 171              		.loc 1 180 0
 172 002c 4CBF     		ite	mi
 173 002e 23F00103 		bicmi	r3, r3, #1
 184:usb_lib/usb_core.c ****     }
 174              		.loc 1 184 0
 175 0032 43F00103 		orrpl	r3, r3, #1
 176              	.LVL13:
 177              	.L29:
 178              	.LBE2:
 179              	.LBB3:
 204:usb_lib/usb_core.c ****       }
 180              		.loc 1 204 0
 181 0036 1370     		strb	r3, [r2]
 182              	.L17:
 183              	.LBE3:
 221:usb_lib/usb_core.c ****   return (u8 *)&StatusInfo;
 184              		.loc 1 221 0
 185 0038 124B     		ldr	r3, .L30+8
 186 003a 1B68     		ldr	r3, [r3]
 187 003c 1B69     		ldr	r3, [r3, #16]
 188 003e 9847     		blx	r3
 189              	.LVL14:
 222:usb_lib/usb_core.c **** }
 190              		.loc 1 222 0
 191 0040 0F48     		ldr	r0, .L30+4
 192 0042 E4E7     		b	.L11
 193              	.L14:
 188:usb_lib/usb_core.c ****   {
 194              		.loc 1 188 0
 195 0044 0129     		cmp	r1, #1
 196 0046 E2D0     		beq	.L11
 193:usb_lib/usb_core.c ****   {
 197              		.loc 1 193 0
 198 0048 0229     		cmp	r1, #2
 199 004a 15D1     		bne	.L21
 200              	.LBB4:
 196:usb_lib/usb_core.c **** 
 201              		.loc 1 196 0
 202 004c 2179     		ldrb	r1, [r4, #4]	@ zero_extendqisi2
 203              	.LVL15:
 204 004e 01F00F03 		and	r3, r1, #15
 205 0052 9B00     		lsls	r3, r3, #2
 206 0054 03F18043 		add	r3, r3, #1073741824
 207 0058 03F5B843 		add	r3, r3, #23552
 199:usb_lib/usb_core.c ****     {
 208              		.loc 1 199 0
 209 005c 0906     		lsls	r1, r1, #24
 210              	.LVL16:
 202:usb_lib/usb_core.c ****       {
 211              		.loc 1 202 0
 212 005e 1B68     		ldr	r3, [r3]
 199:usb_lib/usb_core.c ****     {
 213              		.loc 1 199 0
 214 0060 05D5     		bpl	.L18
 202:usb_lib/usb_core.c ****       {
 215              		.loc 1 202 0
 216 0062 03F03003 		and	r3, r3, #48
 217 0066 102B     		cmp	r3, #16
 218              	.L28:
 219 0068 E6D1     		bne	.L17
 204:usb_lib/usb_core.c ****       }
 220              		.loc 1 204 0
 221 006a 0123     		movs	r3, #1
 222 006c E3E7     		b	.L29
 223              	.L18:
 210:usb_lib/usb_core.c ****       {
 224              		.loc 1 210 0
 225 006e 03F44053 		and	r3, r3, #12288
 226 0072 B3F5805F 		cmp	r3, #4096
 227 0076 F7E7     		b	.L28
 228              	.LVL17:
 229              	.L21:
 230              	.LBE4:
 219:usb_lib/usb_core.c ****   }
 231              		.loc 1 219 0
 232 0078 1846     		mov	r0, r3
 233 007a C8E7     		b	.L11
 234              	.L31:
 235              		.align	2
 236              	.L30:
 237 007c 00000000 		.word	pInformation
 238 0080 00000000 		.word	StatusInfo
 239 0084 00000000 		.word	pUser_Standard_Requests
 240              		.cfi_endproc
 241              	.LFE4:
 243              		.section	.text.DataStageIn,"ax",%progbits
 244              		.align	1
 245              		.syntax unified
 246              		.thumb
 247              		.thumb_func
 248              		.fpu softvfp
 250              	DataStageIn:
 251              	.LFB10:
 224:usb_lib/usb_core.c **** 
 225:usb_lib/usb_core.c **** /*******************************************************************************
 226:usb_lib/usb_core.c **** * Function Name  : Standard_ClearFeature.
 227:usb_lib/usb_core.c **** * Description    : Clear or disable a specific feature.
 228:usb_lib/usb_core.c **** * Input          : None.
 229:usb_lib/usb_core.c **** * Output         : None.
 230:usb_lib/usb_core.c **** * Return         : - Return USB_SUCCESS, if the request is performed.
 231:usb_lib/usb_core.c **** *                  - Return USB_UNSUPPORT, if the request is invalid.
 232:usb_lib/usb_core.c **** *******************************************************************************/
 233:usb_lib/usb_core.c **** RESULT Standard_ClearFeature(void)
 234:usb_lib/usb_core.c **** {
 235:usb_lib/usb_core.c ****   u32     Type_Rec = Type_Recipient;
 236:usb_lib/usb_core.c ****   u32     Status;
 237:usb_lib/usb_core.c **** 
 238:usb_lib/usb_core.c **** 
 239:usb_lib/usb_core.c ****   if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 240:usb_lib/usb_core.c ****   {/*Device Clear Feature*/
 241:usb_lib/usb_core.c ****     ClrBit(pInformation->Current_Feature, 5);
 242:usb_lib/usb_core.c ****     return USB_SUCCESS;
 243:usb_lib/usb_core.c ****   }
 244:usb_lib/usb_core.c ****   else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 245:usb_lib/usb_core.c ****   {/*EndPoint Clear Feature*/
 246:usb_lib/usb_core.c ****     DEVICE* pDev;
 247:usb_lib/usb_core.c ****     u32 Related_Endpoint;
 248:usb_lib/usb_core.c ****     u32 wIndex0;
 249:usb_lib/usb_core.c ****     u32 rEP;
 250:usb_lib/usb_core.c **** 
 251:usb_lib/usb_core.c ****     if ((pInformation->USBwValue != ENDPOINT_STALL)
 252:usb_lib/usb_core.c ****         || (pInformation->USBwIndex1 != 0))
 253:usb_lib/usb_core.c ****     {
 254:usb_lib/usb_core.c ****       return USB_UNSUPPORT;
 255:usb_lib/usb_core.c ****     }
 256:usb_lib/usb_core.c **** 
 257:usb_lib/usb_core.c ****     pDev = &Device_Table;
 258:usb_lib/usb_core.c ****     wIndex0 = pInformation->USBwIndex0;
 259:usb_lib/usb_core.c ****     rEP = wIndex0 & ~0x80;
 260:usb_lib/usb_core.c ****     Related_Endpoint = ENDP0 + rEP;
 261:usb_lib/usb_core.c **** 
 262:usb_lib/usb_core.c ****     if (ValBit(pInformation->USBwIndex0, 7))
 263:usb_lib/usb_core.c ****     {
 264:usb_lib/usb_core.c ****       /*Get Status of endpoint & stall the request if the related_ENdpoint
 265:usb_lib/usb_core.c ****       is Disabled*/
 266:usb_lib/usb_core.c ****       Status = _GetEPTxStatus(Related_Endpoint);
 267:usb_lib/usb_core.c ****     }
 268:usb_lib/usb_core.c ****     else
 269:usb_lib/usb_core.c ****     {
 270:usb_lib/usb_core.c ****       Status = _GetEPRxStatus(Related_Endpoint);
 271:usb_lib/usb_core.c ****     }
 272:usb_lib/usb_core.c **** 
 273:usb_lib/usb_core.c ****     if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
 274:usb_lib/usb_core.c ****         || (pInformation->Current_Configuration == 0))
 275:usb_lib/usb_core.c ****     {
 276:usb_lib/usb_core.c ****       return USB_UNSUPPORT;
 277:usb_lib/usb_core.c ****     }
 278:usb_lib/usb_core.c **** 
 279:usb_lib/usb_core.c **** 
 280:usb_lib/usb_core.c ****     if (wIndex0 & 0x80)
 281:usb_lib/usb_core.c ****     {
 282:usb_lib/usb_core.c ****       /* IN endpoint */
 283:usb_lib/usb_core.c ****       if (_GetTxStallStatus(Related_Endpoint ))
 284:usb_lib/usb_core.c ****       {
 285:usb_lib/usb_core.c ****         ClearDTOG_TX(Related_Endpoint);
 286:usb_lib/usb_core.c ****         SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
 287:usb_lib/usb_core.c ****       }
 288:usb_lib/usb_core.c ****     }
 289:usb_lib/usb_core.c ****     else
 290:usb_lib/usb_core.c ****     {
 291:usb_lib/usb_core.c ****       /* OUT endpoint */
 292:usb_lib/usb_core.c ****       if (_GetRxStallStatus(Related_Endpoint))
 293:usb_lib/usb_core.c ****       {
 294:usb_lib/usb_core.c ****         if (Related_Endpoint == ENDP0)
 295:usb_lib/usb_core.c ****         {
 296:usb_lib/usb_core.c ****           /* After clear the STALL, enable the default endpoint receiver */
 297:usb_lib/usb_core.c ****           SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
 298:usb_lib/usb_core.c ****           _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
 299:usb_lib/usb_core.c ****         }
 300:usb_lib/usb_core.c ****         else
 301:usb_lib/usb_core.c ****         {
 302:usb_lib/usb_core.c ****           ClearDTOG_RX(Related_Endpoint);
 303:usb_lib/usb_core.c ****           _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
 304:usb_lib/usb_core.c ****         }
 305:usb_lib/usb_core.c ****       }
 306:usb_lib/usb_core.c ****     }
 307:usb_lib/usb_core.c ****     pUser_Standard_Requests->User_ClearFeature();
 308:usb_lib/usb_core.c ****     return USB_SUCCESS;
 309:usb_lib/usb_core.c ****   }
 310:usb_lib/usb_core.c **** 
 311:usb_lib/usb_core.c ****   return USB_UNSUPPORT;
 312:usb_lib/usb_core.c **** }
 313:usb_lib/usb_core.c **** 
 314:usb_lib/usb_core.c **** /*******************************************************************************
 315:usb_lib/usb_core.c **** * Function Name  : Standard_SetEndPointFeature
 316:usb_lib/usb_core.c **** * Description    : Set or enable a specific feature of EndPoint
 317:usb_lib/usb_core.c **** * Input          : None.
 318:usb_lib/usb_core.c **** * Output         : None.
 319:usb_lib/usb_core.c **** * Return         : - Return USB_SUCCESS, if the request is performed.
 320:usb_lib/usb_core.c **** *                  - Return USB_UNSUPPORT, if the request is invalid.
 321:usb_lib/usb_core.c **** *******************************************************************************/
 322:usb_lib/usb_core.c **** RESULT Standard_SetEndPointFeature(void)
 323:usb_lib/usb_core.c **** {
 324:usb_lib/usb_core.c ****   u32    wIndex0;
 325:usb_lib/usb_core.c ****   u32    Related_Endpoint;
 326:usb_lib/usb_core.c ****   u32    rEP;
 327:usb_lib/usb_core.c ****   u32   Status;
 328:usb_lib/usb_core.c **** 
 329:usb_lib/usb_core.c ****   wIndex0 = pInformation->USBwIndex0;
 330:usb_lib/usb_core.c ****   rEP = wIndex0 & ~0x80;
 331:usb_lib/usb_core.c ****   Related_Endpoint = ENDP0 + rEP;
 332:usb_lib/usb_core.c **** 
 333:usb_lib/usb_core.c ****   if (ValBit(pInformation->USBwIndex0, 7))
 334:usb_lib/usb_core.c ****   {
 335:usb_lib/usb_core.c ****     /* get Status of endpoint & stall the request if the related_ENdpoint
 336:usb_lib/usb_core.c ****     is Disabled*/
 337:usb_lib/usb_core.c ****     Status = _GetEPTxStatus(Related_Endpoint);
 338:usb_lib/usb_core.c ****   }
 339:usb_lib/usb_core.c ****   else
 340:usb_lib/usb_core.c ****   {
 341:usb_lib/usb_core.c ****     Status = _GetEPRxStatus(Related_Endpoint);
 342:usb_lib/usb_core.c ****   }
 343:usb_lib/usb_core.c **** 
 344:usb_lib/usb_core.c ****   if (Related_Endpoint >= Device_Table.Total_Endpoint
 345:usb_lib/usb_core.c ****       || pInformation->USBwValue != 0 || Status == 0
 346:usb_lib/usb_core.c ****       || pInformation->Current_Configuration == 0)
 347:usb_lib/usb_core.c ****   {
 348:usb_lib/usb_core.c ****     return USB_UNSUPPORT;
 349:usb_lib/usb_core.c ****   }
 350:usb_lib/usb_core.c ****   else
 351:usb_lib/usb_core.c ****   {
 352:usb_lib/usb_core.c ****     if (wIndex0 & 0x80)
 353:usb_lib/usb_core.c ****     {
 354:usb_lib/usb_core.c ****       /* IN endpoint */
 355:usb_lib/usb_core.c ****       _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
 356:usb_lib/usb_core.c ****     }
 357:usb_lib/usb_core.c **** 
 358:usb_lib/usb_core.c ****     else
 359:usb_lib/usb_core.c ****     {
 360:usb_lib/usb_core.c ****       /* OUT endpoint */
 361:usb_lib/usb_core.c ****       _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
 362:usb_lib/usb_core.c ****     }
 363:usb_lib/usb_core.c ****   }
 364:usb_lib/usb_core.c ****   pUser_Standard_Requests->User_SetEndPointFeature();
 365:usb_lib/usb_core.c ****   return USB_SUCCESS;
 366:usb_lib/usb_core.c **** }
 367:usb_lib/usb_core.c **** 
 368:usb_lib/usb_core.c **** /*******************************************************************************
 369:usb_lib/usb_core.c **** * Function Name  : Standard_SetDeviceFeature.
 370:usb_lib/usb_core.c **** * Description    : Set or enable a specific feature of Device.
 371:usb_lib/usb_core.c **** * Input          : None.
 372:usb_lib/usb_core.c **** * Output         : None.
 373:usb_lib/usb_core.c **** * Return         : - Return USB_SUCCESS, if the request is performed.
 374:usb_lib/usb_core.c **** *                  - Return USB_UNSUPPORT, if the request is invalid.
 375:usb_lib/usb_core.c **** *******************************************************************************/
 376:usb_lib/usb_core.c **** RESULT Standard_SetDeviceFeature(void)
 377:usb_lib/usb_core.c **** {
 378:usb_lib/usb_core.c ****   SetBit(pInformation->Current_Feature, 5);
 379:usb_lib/usb_core.c ****   pUser_Standard_Requests->User_SetDeviceFeature();
 380:usb_lib/usb_core.c ****   return USB_SUCCESS;
 381:usb_lib/usb_core.c **** }
 382:usb_lib/usb_core.c **** 
 383:usb_lib/usb_core.c **** /*******************************************************************************
 384:usb_lib/usb_core.c **** * Function Name  : Standard_GetDescriptorData.
 385:usb_lib/usb_core.c **** * Description    : Standard_GetDescriptorData is used for descriptors transfer.
 386:usb_lib/usb_core.c **** *                : This routine is used for the descriptors resident in Flash
 387:usb_lib/usb_core.c **** *                  or RAM
 388:usb_lib/usb_core.c **** *                  pDesc can be in either Flash or RAM
 389:usb_lib/usb_core.c **** *                  The purpose of this routine is to have a versatile way to
 390:usb_lib/usb_core.c **** *                  response descriptors request. It allows user to generate
 391:usb_lib/usb_core.c **** *                  certain descriptors with software or read descriptors from
 392:usb_lib/usb_core.c **** *                  external storage part by part.
 393:usb_lib/usb_core.c **** * Input          : - Length - Length of the data in this transfer.
 394:usb_lib/usb_core.c **** *                  - pDesc - A pointer points to descriptor struct.
 395:usb_lib/usb_core.c **** *                  The structure gives the initial address of the descriptor and
 396:usb_lib/usb_core.c **** *                  its original size.
 397:usb_lib/usb_core.c **** * Output         : None.
 398:usb_lib/usb_core.c **** * Return         : Address of a part of the descriptor pointed by the Usb_
 399:usb_lib/usb_core.c **** *                  wOffset The buffer pointed by this address contains at least
 400:usb_lib/usb_core.c **** *                  Length bytes.
 401:usb_lib/usb_core.c **** *******************************************************************************/
 402:usb_lib/usb_core.c **** u8 *Standard_GetDescriptorData(u16 Length, ONE_DESCRIPTOR *pDesc)
 403:usb_lib/usb_core.c **** {
 404:usb_lib/usb_core.c ****   u32  wOffset;
 405:usb_lib/usb_core.c **** 
 406:usb_lib/usb_core.c ****   wOffset = pInformation->Ctrl_Info.Usb_wOffset;
 407:usb_lib/usb_core.c ****   if (Length == 0)
 408:usb_lib/usb_core.c ****   {
 409:usb_lib/usb_core.c ****     pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
 410:usb_lib/usb_core.c ****     return 0;
 411:usb_lib/usb_core.c ****   }
 412:usb_lib/usb_core.c **** 
 413:usb_lib/usb_core.c ****   return pDesc->Descriptor + wOffset;
 414:usb_lib/usb_core.c **** }
 415:usb_lib/usb_core.c **** 
 416:usb_lib/usb_core.c **** /*******************************************************************************
 417:usb_lib/usb_core.c **** * Function Name  : DataStageOut.
 418:usb_lib/usb_core.c **** * Description    : Data stage of a Control Write Transfer.
 419:usb_lib/usb_core.c **** * Input          : None.
 420:usb_lib/usb_core.c **** * Output         : None.
 421:usb_lib/usb_core.c **** * Return         : None.
 422:usb_lib/usb_core.c **** *******************************************************************************/
 423:usb_lib/usb_core.c **** void DataStageOut(void)
 424:usb_lib/usb_core.c **** {
 425:usb_lib/usb_core.c ****   ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
 426:usb_lib/usb_core.c ****   u32 save_rLength;
 427:usb_lib/usb_core.c **** 
 428:usb_lib/usb_core.c ****   save_rLength = pEPinfo->Usb_rLength;
 429:usb_lib/usb_core.c **** 
 430:usb_lib/usb_core.c ****   if (pEPinfo->CopyData && save_rLength)
 431:usb_lib/usb_core.c ****   {
 432:usb_lib/usb_core.c ****     u8 *Buffer;
 433:usb_lib/usb_core.c ****     u32 Length;
 434:usb_lib/usb_core.c **** 
 435:usb_lib/usb_core.c ****     Length = pEPinfo->PacketSize;
 436:usb_lib/usb_core.c ****     if (Length > save_rLength)
 437:usb_lib/usb_core.c ****     {
 438:usb_lib/usb_core.c ****       Length = save_rLength;
 439:usb_lib/usb_core.c ****     }
 440:usb_lib/usb_core.c **** 
 441:usb_lib/usb_core.c ****     Buffer = (*pEPinfo->CopyData)(Length);
 442:usb_lib/usb_core.c ****     pEPinfo->Usb_rLength -= Length;
 443:usb_lib/usb_core.c ****     pEPinfo->Usb_rOffset += Length;
 444:usb_lib/usb_core.c **** 
 445:usb_lib/usb_core.c ****     PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
 446:usb_lib/usb_core.c ****   }
 447:usb_lib/usb_core.c **** 
 448:usb_lib/usb_core.c ****   if (pEPinfo->Usb_rLength != 0)
 449:usb_lib/usb_core.c ****   {
 450:usb_lib/usb_core.c ****     vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
 451:usb_lib/usb_core.c ****     SetEPTxCount(ENDP0, 0);
 452:usb_lib/usb_core.c ****     vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
 453:usb_lib/usb_core.c ****   }
 454:usb_lib/usb_core.c ****   /* Set the next State*/
 455:usb_lib/usb_core.c ****   if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
 456:usb_lib/usb_core.c ****   {
 457:usb_lib/usb_core.c ****     pInformation->ControlState = OUT_DATA;
 458:usb_lib/usb_core.c ****   }
 459:usb_lib/usb_core.c ****   else
 460:usb_lib/usb_core.c ****   {
 461:usb_lib/usb_core.c ****     if (pEPinfo->Usb_rLength > 0)
 462:usb_lib/usb_core.c ****     {
 463:usb_lib/usb_core.c ****       pInformation->ControlState = LAST_OUT_DATA;
 464:usb_lib/usb_core.c ****     }
 465:usb_lib/usb_core.c ****     else if (pEPinfo->Usb_rLength == 0)
 466:usb_lib/usb_core.c ****     {
 467:usb_lib/usb_core.c ****       pInformation->ControlState = WAIT_STATUS_IN;
 468:usb_lib/usb_core.c ****       USB_StatusIn();
 469:usb_lib/usb_core.c ****     }
 470:usb_lib/usb_core.c ****   }
 471:usb_lib/usb_core.c **** }
 472:usb_lib/usb_core.c **** 
 473:usb_lib/usb_core.c **** /*******************************************************************************
 474:usb_lib/usb_core.c **** * Function Name  : DataStageIn.
 475:usb_lib/usb_core.c **** * Description    : Data stage of a Control Read Transfer.
 476:usb_lib/usb_core.c **** * Input          : None.
 477:usb_lib/usb_core.c **** * Output         : None.
 478:usb_lib/usb_core.c **** * Return         : None.
 479:usb_lib/usb_core.c **** *******************************************************************************/
 480:usb_lib/usb_core.c **** void DataStageIn(void)
 481:usb_lib/usb_core.c **** {
 252              		.loc 1 481 0
 253              		.cfi_startproc
 254              		@ args = 0, pretend = 0, frame = 0
 255              		@ frame_needed = 0, uses_anonymous_args = 0
 256 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 257              		.cfi_def_cfa_offset 32
 258              		.cfi_offset 3, -32
 259              		.cfi_offset 4, -28
 260              		.cfi_offset 5, -24
 261              		.cfi_offset 6, -20
 262              		.cfi_offset 7, -16
 263              		.cfi_offset 8, -12
 264              		.cfi_offset 9, -8
 265              		.cfi_offset 14, -4
 482:usb_lib/usb_core.c ****   ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
 266              		.loc 1 482 0
 267 0004 234F     		ldr	r7, .L38
 268 0006 DFF8A080 		ldr	r8, .L38+20
 269 000a 3D68     		ldr	r5, [r7]
 270              	.LVL18:
 483:usb_lib/usb_core.c ****   u32 save_wLength = pEPinfo->Usb_wLength;
 271              		.loc 1 483 0
 272 000c 2C8A     		ldrh	r4, [r5, #16]
 273              	.LVL19:
 484:usb_lib/usb_core.c ****   u32 ControlState = pInformation->ControlState;
 485:usb_lib/usb_core.c **** 
 486:usb_lib/usb_core.c ****   u8 *DataBuffer;
 487:usb_lib/usb_core.c ****   u32 Length;
 488:usb_lib/usb_core.c **** 
 489:usb_lib/usb_core.c ****   if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
 274              		.loc 1 489 0
 275 000e D4B9     		cbnz	r4, .L33
 276              		.loc 1 489 0 is_stmt 0 discriminator 1
 277 0010 2E7A     		ldrb	r6, [r5, #8]	@ zero_extendqisi2
 278 0012 042E     		cmp	r6, #4
 279 0014 17D1     		bne	.L33
 490:usb_lib/usb_core.c ****   {
 491:usb_lib/usb_core.c ****     if(Data_Mul_MaxPacketSize == TRUE)
 280              		.loc 1 491 0 is_stmt 1
 281 0016 2049     		ldr	r1, .L38+4
 282 0018 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 283 001a 012B     		cmp	r3, #1
 284 001c 0ED1     		bne	.L34
 492:usb_lib/usb_core.c ****     {
 493:usb_lib/usb_core.c ****       /* No more data to send and empty packet */
 494:usb_lib/usb_core.c ****       Send0LengthData();
 285              		.loc 1 494 0
 286 001e 1F4B     		ldr	r3, .L38+8
 287 0020 1A68     		ldr	r2, [r3]
 288 0022 1F4B     		ldr	r3, .L38+12
 289 0024 92B2     		uxth	r2, r2
 290 0026 1344     		add	r3, r3, r2
 291 0028 5B00     		lsls	r3, r3, #1
 292 002a 1C60     		str	r4, [r3]
 293              	.LVL20:
 294 002c 3023     		movs	r3, #48
 495:usb_lib/usb_core.c ****       ControlState = LAST_IN_DATA;
 496:usb_lib/usb_core.c ****       Data_Mul_MaxPacketSize = FALSE;
 295              		.loc 1 496 0
 296 002e 0C70     		strb	r4, [r1]
 494:usb_lib/usb_core.c ****       ControlState = LAST_IN_DATA;
 297              		.loc 1 494 0
 298 0030 A8F80030 		strh	r3, [r8]	@ movhi
 299              	.LVL21:
 300              	.L35:
 497:usb_lib/usb_core.c ****     }
 498:usb_lib/usb_core.c ****     else
 499:usb_lib/usb_core.c ****     {
 500:usb_lib/usb_core.c ****       /* No more data to send so STALL the TX Status*/
 501:usb_lib/usb_core.c ****       ControlState = WAIT_STATUS_OUT;
 502:usb_lib/usb_core.c ****       vSetEPTxStatus(EP_TX_STALL);
 503:usb_lib/usb_core.c ****     }
 504:usb_lib/usb_core.c **** 
 505:usb_lib/usb_core.c ****     goto Expect_Status_Out;
 506:usb_lib/usb_core.c ****   }
 507:usb_lib/usb_core.c **** 
 508:usb_lib/usb_core.c ****   Length = pEPinfo->PacketSize;
 509:usb_lib/usb_core.c ****   ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
 510:usb_lib/usb_core.c **** 
 511:usb_lib/usb_core.c ****   if (Length > save_wLength)
 512:usb_lib/usb_core.c ****   {
 513:usb_lib/usb_core.c ****     Length = save_wLength;
 514:usb_lib/usb_core.c ****   }
 515:usb_lib/usb_core.c **** 
 516:usb_lib/usb_core.c ****   DataBuffer = (*pEPinfo->CopyData)(Length);
 517:usb_lib/usb_core.c **** 
 518:usb_lib/usb_core.c ****   UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
 519:usb_lib/usb_core.c **** 
 520:usb_lib/usb_core.c ****   SetEPTxCount(ENDP0, Length);
 521:usb_lib/usb_core.c **** 
 522:usb_lib/usb_core.c ****   pEPinfo->Usb_wLength -= Length;
 523:usb_lib/usb_core.c ****   pEPinfo->Usb_wOffset += Length;
 524:usb_lib/usb_core.c ****   vSetEPTxStatus(EP_TX_VALID);
 525:usb_lib/usb_core.c **** 
 526:usb_lib/usb_core.c ****   USB_StatusOut();/* Expect the host to abort the data IN stage */
 527:usb_lib/usb_core.c **** 
 528:usb_lib/usb_core.c **** Expect_Status_Out:
 529:usb_lib/usb_core.c ****   pInformation->ControlState = ControlState;
 301              		.loc 1 529 0
 302 0034 3B68     		ldr	r3, [r7]
 303 0036 1E72     		strb	r6, [r3, #8]
 530:usb_lib/usb_core.c **** }
 304              		.loc 1 530 0
 305 0038 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 306              	.LVL22:
 307              	.L34:
 502:usb_lib/usb_core.c ****     }
 308              		.loc 1 502 0
 309 003c 1023     		movs	r3, #16
 501:usb_lib/usb_core.c ****       vSetEPTxStatus(EP_TX_STALL);
 310              		.loc 1 501 0
 311 003e 0726     		movs	r6, #7
 502:usb_lib/usb_core.c ****     }
 312              		.loc 1 502 0
 313 0040 A8F80030 		strh	r3, [r8]	@ movhi
 314 0044 F6E7     		b	.L35
 315              	.LVL23:
 316              	.L33:
 508:usb_lib/usb_core.c ****   ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
 317              		.loc 1 508 0
 318 0046 AB8A     		ldrh	r3, [r5, #20]
 319              	.LVL24:
 509:usb_lib/usb_core.c **** 
 320              		.loc 1 509 0
 321 0048 9C42     		cmp	r4, r3
 322 004a 94BF     		ite	ls
 323 004c 0426     		movls	r6, #4
 324 004e 0226     		movhi	r6, #2
 325              	.LVL25:
 516:usb_lib/usb_core.c **** 
 326              		.loc 1 516 0
 327 0050 9C42     		cmp	r4, r3
 328 0052 28BF     		it	cs
 329 0054 1C46     		movcs	r4, r3
 330              	.LVL26:
 331 0056 AB69     		ldr	r3, [r5, #24]
 332              	.LVL27:
 333 0058 2046     		mov	r0, r4
 334 005a 9847     		blx	r3
 335              	.LVL28:
 336 005c 8146     		mov	r9, r0
 337              	.LVL29:
 518:usb_lib/usb_core.c **** 
 338              		.loc 1 518 0
 339 005e 0020     		movs	r0, #0
 340              	.LVL30:
 341 0060 FFF7FEFF 		bl	GetEPTxAddr
 342              	.LVL31:
 343 0064 2246     		mov	r2, r4
 344 0066 0146     		mov	r1, r0
 345 0068 4846     		mov	r0, r9
 346 006a FFF7FEFF 		bl	UserToPMABufferCopy
 347              	.LVL32:
 520:usb_lib/usb_core.c **** 
 348              		.loc 1 520 0
 349 006e 2146     		mov	r1, r4
 350 0070 0020     		movs	r0, #0
 351 0072 FFF7FEFF 		bl	SetEPTxCount
 352              	.LVL33:
 522:usb_lib/usb_core.c ****   pEPinfo->Usb_wOffset += Length;
 353              		.loc 1 522 0
 354 0076 2B8A     		ldrh	r3, [r5, #16]
 526:usb_lib/usb_core.c **** 
 355              		.loc 1 526 0
 356 0078 4FF44052 		mov	r2, #12288
 522:usb_lib/usb_core.c ****   pEPinfo->Usb_wOffset += Length;
 357              		.loc 1 522 0
 358 007c 1B1B     		subs	r3, r3, r4
 359 007e 2B82     		strh	r3, [r5, #16]	@ movhi
 523:usb_lib/usb_core.c ****   vSetEPTxStatus(EP_TX_VALID);
 360              		.loc 1 523 0
 361 0080 6B8A     		ldrh	r3, [r5, #18]
 362 0082 1C44     		add	r4, r4, r3
 524:usb_lib/usb_core.c **** 
 363              		.loc 1 524 0
 364 0084 3023     		movs	r3, #48
 365 0086 A8F80030 		strh	r3, [r8]	@ movhi
 526:usb_lib/usb_core.c **** 
 366              		.loc 1 526 0
 367 008a 064B     		ldr	r3, .L38+16
 523:usb_lib/usb_core.c ****   vSetEPTxStatus(EP_TX_VALID);
 368              		.loc 1 523 0
 369 008c 6C82     		strh	r4, [r5, #18]	@ movhi
 526:usb_lib/usb_core.c **** 
 370              		.loc 1 526 0
 371 008e 1A80     		strh	r2, [r3]	@ movhi
 372 0090 D0E7     		b	.L35
 373              	.L39:
 374 0092 00BF     		.align	2
 375              	.L38:
 376 0094 00000000 		.word	pInformation
 377 0098 00000000 		.word	.LANCHOR0
 378 009c 505C0040 		.word	1073765456
 379 00a0 02300020 		.word	536883202
 380 00a4 00000000 		.word	SaveRState
 381 00a8 00000000 		.word	SaveTState
 382              		.cfi_endproc
 383              	.LFE10:
 385              		.section	.text.Standard_SetConfiguration,"ax",%progbits
 386              		.align	1
 387              		.global	Standard_SetConfiguration
 388              		.syntax unified
 389              		.thumb
 390              		.thumb_func
 391              		.fpu softvfp
 393              	Standard_SetConfiguration:
 394              	.LFB1:
  75:usb_lib/usb_core.c **** 
 395              		.loc 1 75 0
 396              		.cfi_startproc
 397              		@ args = 0, pretend = 0, frame = 0
 398              		@ frame_needed = 0, uses_anonymous_args = 0
 399 0000 10B5     		push	{r4, lr}
 400              		.cfi_def_cfa_offset 8
 401              		.cfi_offset 4, -8
 402              		.cfi_offset 14, -4
  77:usb_lib/usb_core.c ****       Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
 403              		.loc 1 77 0
 404 0002 0A4B     		ldr	r3, .L45
  78:usb_lib/usb_core.c ****       && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
 405              		.loc 1 78 0
 406 0004 0A49     		ldr	r1, .L45+4
  77:usb_lib/usb_core.c ****       Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
 407              		.loc 1 77 0
 408 0006 1B68     		ldr	r3, [r3]
 409 0008 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 410 000a 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 411 000c 9142     		cmp	r1, r2
 412 000e 0AD3     		bcc	.L44
  78:usb_lib/usb_core.c ****       && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
 413              		.loc 1 78 0
 414 0010 D978     		ldrb	r1, [r3, #3]	@ zero_extendqisi2
 415 0012 41B9     		cbnz	r1, .L44
  79:usb_lib/usb_core.c ****   {
 416              		.loc 1 79 0
 417 0014 9C88     		ldrh	r4, [r3, #4]
 418 0016 34B9     		cbnz	r4, .L44
  81:usb_lib/usb_core.c ****     pUser_Standard_Requests->User_SetConfiguration();
 419              		.loc 1 81 0
 420 0018 9A72     		strb	r2, [r3, #10]
  82:usb_lib/usb_core.c ****     return USB_SUCCESS;
 421              		.loc 1 82 0
 422 001a 064B     		ldr	r3, .L45+8
 423 001c 1B68     		ldr	r3, [r3]
 424 001e 5B68     		ldr	r3, [r3, #4]
 425 0020 9847     		blx	r3
 426              	.LVL34:
  83:usb_lib/usb_core.c ****   }
 427              		.loc 1 83 0
 428 0022 2046     		mov	r0, r4
 429              	.L41:
  89:usb_lib/usb_core.c **** 
 430              		.loc 1 89 0
 431 0024 10BD     		pop	{r4, pc}
 432              	.L44:
  87:usb_lib/usb_core.c ****   }
 433              		.loc 1 87 0
 434 0026 0220     		movs	r0, #2
 435 0028 FCE7     		b	.L41
 436              	.L46:
 437 002a 00BF     		.align	2
 438              	.L45:
 439 002c 00000000 		.word	pInformation
 440 0030 00000000 		.word	Device_Table
 441 0034 00000000 		.word	pUser_Standard_Requests
 442              		.cfi_endproc
 443              	.LFE1:
 445              		.section	.text.Standard_SetInterface,"ax",%progbits
 446              		.align	1
 447              		.global	Standard_SetInterface
 448              		.syntax unified
 449              		.thumb
 450              		.thumb_func
 451              		.fpu softvfp
 453              	Standard_SetInterface:
 454              	.LFB3:
 121:usb_lib/usb_core.c ****   RESULT Re;
 455              		.loc 1 121 0
 456              		.cfi_startproc
 457              		@ args = 0, pretend = 0, frame = 0
 458              		@ frame_needed = 0, uses_anonymous_args = 0
 459 0000 38B5     		push	{r3, r4, r5, lr}
 460              		.cfi_def_cfa_offset 16
 461              		.cfi_offset 3, -16
 462              		.cfi_offset 4, -12
 463              		.cfi_offset 5, -8
 464              		.cfi_offset 14, -4
 125:usb_lib/usb_core.c **** 
 465              		.loc 1 125 0
 466 0002 0F4A     		ldr	r2, .L53
 467 0004 0F4D     		ldr	r5, .L53+4
 468 0006 1268     		ldr	r2, [r2]
 469 0008 2B68     		ldr	r3, [r5]
 470 000a 9269     		ldr	r2, [r2, #24]
 471 000c 9978     		ldrb	r1, [r3, #2]	@ zero_extendqisi2
 472 000e 1879     		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 473 0010 9047     		blx	r2
 474              	.LVL35:
 127:usb_lib/usb_core.c ****   {
 475              		.loc 1 127 0
 476 0012 2B68     		ldr	r3, [r5]
 125:usb_lib/usb_core.c **** 
 477              		.loc 1 125 0
 478 0014 0446     		mov	r4, r0
 479              	.LVL36:
 127:usb_lib/usb_core.c ****   {
 480              		.loc 1 127 0
 481 0016 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 482 0018 7AB1     		cbz	r2, .L52
 129:usb_lib/usb_core.c ****         || (pInformation->USBwValue1 != 0))
 483              		.loc 1 129 0
 484 001a 70B9     		cbnz	r0, .L52
 129:usb_lib/usb_core.c ****         || (pInformation->USBwValue1 != 0))
 485              		.loc 1 129 0 is_stmt 0 discriminator 1
 486 001c 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 487 001e 62B9     		cbnz	r2, .L52
 130:usb_lib/usb_core.c ****     {
 488              		.loc 1 130 0 is_stmt 1
 489 0020 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 490 0022 53B9     		cbnz	r3, .L52
 491              	.LBB7:
 492              	.LBB8:
 136:usb_lib/usb_core.c ****       pInformation->Current_Interface = pInformation->USBwIndex0;
 493              		.loc 1 136 0
 494 0024 084B     		ldr	r3, .L53+8
 495 0026 1B68     		ldr	r3, [r3]
 496 0028 DB68     		ldr	r3, [r3, #12]
 497 002a 9847     		blx	r3
 498              	.LVL37:
 137:usb_lib/usb_core.c ****       pInformation->Current_AlternateSetting = pInformation->USBwValue0;
 499              		.loc 1 137 0
 500 002c 2B68     		ldr	r3, [r5]
 501 002e 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 502 0030 DA72     		strb	r2, [r3, #11]
 138:usb_lib/usb_core.c ****       return USB_SUCCESS;
 503              		.loc 1 138 0
 504 0032 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 505 0034 1A73     		strb	r2, [r3, #12]
 506              	.L48:
 507              	.LBE8:
 508              	.LBE7:
 145:usb_lib/usb_core.c **** 
 509              		.loc 1 145 0
 510 0036 2046     		mov	r0, r4
 511 0038 38BD     		pop	{r3, r4, r5, pc}
 512              	.LVL38:
 513              	.L52:
 144:usb_lib/usb_core.c **** }
 514              		.loc 1 144 0
 515 003a 0224     		movs	r4, #2
 516 003c FBE7     		b	.L48
 517              	.L54:
 518 003e 00BF     		.align	2
 519              	.L53:
 520 0040 00000000 		.word	pProperty
 521 0044 00000000 		.word	pInformation
 522 0048 00000000 		.word	pUser_Standard_Requests
 523              		.cfi_endproc
 524              	.LFE3:
 526              		.section	.text.Standard_ClearFeature,"ax",%progbits
 527              		.align	1
 528              		.global	Standard_ClearFeature
 529              		.syntax unified
 530              		.thumb
 531              		.thumb_func
 532              		.fpu softvfp
 534              	Standard_ClearFeature:
 535              	.LFB5:
 234:usb_lib/usb_core.c ****   u32     Type_Rec = Type_Recipient;
 536              		.loc 1 234 0
 537              		.cfi_startproc
 538              		@ args = 0, pretend = 0, frame = 0
 539              		@ frame_needed = 0, uses_anonymous_args = 0
 540 0000 38B5     		push	{r3, r4, r5, lr}
 541              		.cfi_def_cfa_offset 16
 542              		.cfi_offset 3, -16
 543              		.cfi_offset 4, -12
 544              		.cfi_offset 5, -8
 545              		.cfi_offset 14, -4
 235:usb_lib/usb_core.c ****   u32     Status;
 546              		.loc 1 235 0
 547 0002 2B4B     		ldr	r3, .L70
 548 0004 1B68     		ldr	r3, [r3]
 549 0006 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 550              	.LVL39:
 239:usb_lib/usb_core.c ****   {/*Device Clear Feature*/
 551              		.loc 1 239 0
 552 0008 10F07F00 		ands	r0, r0, #127
 553              	.LVL40:
 554 000c 04D1     		bne	.L56
 241:usb_lib/usb_core.c ****     return USB_SUCCESS;
 555              		.loc 1 241 0
 556 000e 5A7A     		ldrb	r2, [r3, #9]	@ zero_extendqisi2
 557 0010 22F02002 		bic	r2, r2, #32
 558 0014 5A72     		strb	r2, [r3, #9]
 559              	.LVL41:
 560              	.L57:
 312:usb_lib/usb_core.c **** 
 561              		.loc 1 312 0
 562 0016 38BD     		pop	{r3, r4, r5, pc}
 563              	.LVL42:
 564              	.L56:
 244:usb_lib/usb_core.c ****   {/*EndPoint Clear Feature*/
 565              		.loc 1 244 0
 566 0018 0228     		cmp	r0, #2
 567 001a 47D1     		bne	.L68
 568              	.LBB9:
 251:usb_lib/usb_core.c ****         || (pInformation->USBwIndex1 != 0))
 569              		.loc 1 251 0
 570 001c 5A88     		ldrh	r2, [r3, #2]
 571 001e 002A     		cmp	r2, #0
 572 0020 F9D1     		bne	.L57
 252:usb_lib/usb_core.c ****     {
 573              		.loc 1 252 0
 574 0022 5A79     		ldrb	r2, [r3, #5]	@ zero_extendqisi2
 575 0024 002A     		cmp	r2, #0
 576 0026 F6D1     		bne	.L57
 577              	.LVL43:
 258:usb_lib/usb_core.c ****     rEP = wIndex0 & ~0x80;
 578              		.loc 1 258 0
 579 0028 1979     		ldrb	r1, [r3, #4]	@ zero_extendqisi2
 580              	.LVL44:
 273:usb_lib/usb_core.c ****         || (pInformation->Current_Configuration == 0))
 581              		.loc 1 273 0
 582 002a 224D     		ldr	r5, .L70+4
 259:usb_lib/usb_core.c ****     Related_Endpoint = ENDP0 + rEP;
 583              		.loc 1 259 0
 584 002c 21F08000 		bic	r0, r1, #128
 585              	.LVL45:
 586 0030 8400     		lsls	r4, r0, #2
 587 0032 04F18044 		add	r4, r4, #1073741824
 588 0036 04F5B844 		add	r4, r4, #23552
 266:usb_lib/usb_core.c ****     }
 589              		.loc 1 266 0
 590 003a 2268     		ldr	r2, [r4]
 262:usb_lib/usb_core.c ****     {
 591              		.loc 1 262 0
 592 003c 49B2     		sxtb	r1, r1
 273:usb_lib/usb_core.c ****         || (pInformation->Current_Configuration == 0))
 593              		.loc 1 273 0
 594 003e 2D78     		ldrb	r5, [r5]	@ zero_extendqisi2
 262:usb_lib/usb_core.c ****     {
 595              		.loc 1 262 0
 596 0040 0029     		cmp	r1, #0
 266:usb_lib/usb_core.c ****     }
 597              		.loc 1 266 0
 598 0042 B4BF     		ite	lt
 599 0044 02F03002 		andlt	r2, r2, #48
 600              	.LVL46:
 270:usb_lib/usb_core.c ****     }
 601              		.loc 1 270 0
 602 0048 02F44052 		andge	r2, r2, #12288
 603              	.LVL47:
 273:usb_lib/usb_core.c ****         || (pInformation->Current_Configuration == 0))
 604              		.loc 1 273 0
 605 004c 8542     		cmp	r5, r0
 606 004e 2DD9     		bls	.L68
 273:usb_lib/usb_core.c ****         || (pInformation->Current_Configuration == 0))
 607              		.loc 1 273 0 is_stmt 0 discriminator 1
 608 0050 62B3     		cbz	r2, .L68
 274:usb_lib/usb_core.c ****     {
 609              		.loc 1 274 0 is_stmt 1
 610 0052 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 611              	.LVL48:
 612 0054 53B3     		cbz	r3, .L68
 280:usb_lib/usb_core.c ****     {
 613              		.loc 1 280 0
 614 0056 0029     		cmp	r1, #0
 283:usb_lib/usb_core.c ****       {
 615              		.loc 1 283 0
 616 0058 2368     		ldr	r3, [r4]
 280:usb_lib/usb_core.c ****     {
 617              		.loc 1 280 0
 618 005a 11DA     		bge	.L60
 283:usb_lib/usb_core.c ****       {
 619              		.loc 1 283 0
 620 005c 03F03003 		and	r3, r3, #48
 621 0060 102B     		cmp	r3, #16
 622 0062 07D1     		bne	.L61
 285:usb_lib/usb_core.c ****         SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
 623              		.loc 1 285 0
 624 0064 C4B2     		uxtb	r4, r0
 625 0066 2046     		mov	r0, r4
 626              	.LVL49:
 627 0068 FFF7FEFF 		bl	ClearDTOG_TX
 628              	.LVL50:
 286:usb_lib/usb_core.c ****       }
 629              		.loc 1 286 0
 630 006c 3021     		movs	r1, #48
 631 006e 2046     		mov	r0, r4
 632 0070 FFF7FEFF 		bl	SetEPTxStatus
 633              	.LVL51:
 634              	.L61:
 307:usb_lib/usb_core.c ****     return USB_SUCCESS;
 635              		.loc 1 307 0
 636 0074 104B     		ldr	r3, .L70+8
 637 0076 1B68     		ldr	r3, [r3]
 638 0078 5B69     		ldr	r3, [r3, #20]
 639 007a 9847     		blx	r3
 640              	.LVL52:
 308:usb_lib/usb_core.c ****   }
 641              		.loc 1 308 0
 642 007c 0020     		movs	r0, #0
 643 007e CAE7     		b	.L57
 644              	.LVL53:
 645              	.L60:
 292:usb_lib/usb_core.c ****       {
 646              		.loc 1 292 0
 647 0080 03F44053 		and	r3, r3, #12288
 648 0084 B3F5805F 		cmp	r3, #4096
 649 0088 F4D1     		bne	.L61
 650 008a 0C4D     		ldr	r5, .L70+12
 294:usb_lib/usb_core.c ****         {
 651              		.loc 1 294 0
 652 008c 58B9     		cbnz	r0, .L62
 297:usb_lib/usb_core.c ****           _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
 653              		.loc 1 297 0
 654 008e 0C4B     		ldr	r3, .L70+16
 655 0090 93F83010 		ldrb	r1, [r3, #48]	@ zero_extendqisi2
 656              	.LVL54:
 657 0094 FFF7FEFF 		bl	SetEPRxCount
 658              	.LVL55:
 659              	.L69:
 660              	.LBB10:
 303:usb_lib/usb_core.c ****         }
 661              		.loc 1 303 0
 662 0098 2368     		ldr	r3, [r4]
 663 009a 2B40     		ands	r3, r3, r5
 664 009c 9BB2     		uxth	r3, r3
 665              	.LVL56:
 666 009e 83F44053 		eor	r3, r3, #12288
 667              	.LVL57:
 668 00a2 2360     		str	r3, [r4]
 669 00a4 E6E7     		b	.L61
 670              	.LVL58:
 671              	.L62:
 672              	.LBE10:
 302:usb_lib/usb_core.c ****           _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
 673              		.loc 1 302 0
 674 00a6 FFF7FEFF 		bl	ClearDTOG_RX
 675              	.LVL59:
 676 00aa F5E7     		b	.L69
 677              	.LVL60:
 678              	.L68:
 679              	.LBE9:
 311:usb_lib/usb_core.c **** }
 680              		.loc 1 311 0
 681 00ac 0220     		movs	r0, #2
 682 00ae B2E7     		b	.L57
 683              	.L71:
 684              		.align	2
 685              	.L70:
 686 00b0 00000000 		.word	pInformation
 687 00b4 00000000 		.word	Device_Table
 688 00b8 00000000 		.word	pUser_Standard_Requests
 689 00bc 8FBFFFFF 		.word	-16497
 690 00c0 00000000 		.word	Device_Property
 691              		.cfi_endproc
 692              	.LFE5:
 694              		.section	.text.Standard_SetEndPointFeature,"ax",%progbits
 695              		.align	1
 696              		.global	Standard_SetEndPointFeature
 697              		.syntax unified
 698              		.thumb
 699              		.thumb_func
 700              		.fpu softvfp
 702              	Standard_SetEndPointFeature:
 703              	.LFB6:
 323:usb_lib/usb_core.c ****   u32    wIndex0;
 704              		.loc 1 323 0
 705              		.cfi_startproc
 706              		@ args = 0, pretend = 0, frame = 0
 707              		@ frame_needed = 0, uses_anonymous_args = 0
 708 0000 38B5     		push	{r3, r4, r5, lr}
 709              		.cfi_def_cfa_offset 16
 710              		.cfi_offset 3, -16
 711              		.cfi_offset 4, -12
 712              		.cfi_offset 5, -8
 713              		.cfi_offset 14, -4
 329:usb_lib/usb_core.c ****   rEP = wIndex0 & ~0x80;
 714              		.loc 1 329 0
 715 0002 1B4B     		ldr	r3, .L83
 344:usb_lib/usb_core.c ****       || pInformation->USBwValue != 0 || Status == 0
 716              		.loc 1 344 0
 717 0004 1B4D     		ldr	r5, .L83+4
 329:usb_lib/usb_core.c ****   rEP = wIndex0 & ~0x80;
 718              		.loc 1 329 0
 719 0006 1868     		ldr	r0, [r3]
 344:usb_lib/usb_core.c ****       || pInformation->USBwValue != 0 || Status == 0
 720              		.loc 1 344 0
 721 0008 2D78     		ldrb	r5, [r5]	@ zero_extendqisi2
 329:usb_lib/usb_core.c ****   rEP = wIndex0 & ~0x80;
 722              		.loc 1 329 0
 723 000a 0179     		ldrb	r1, [r0, #4]	@ zero_extendqisi2
 724              	.LVL61:
 330:usb_lib/usb_core.c ****   Related_Endpoint = ENDP0 + rEP;
 725              		.loc 1 330 0
 726 000c 21F08004 		bic	r4, r1, #128
 727              	.LVL62:
 728 0010 A300     		lsls	r3, r4, #2
 729 0012 03F18043 		add	r3, r3, #1073741824
 730 0016 03F5B843 		add	r3, r3, #23552
 337:usb_lib/usb_core.c ****   }
 731              		.loc 1 337 0
 732 001a 1A68     		ldr	r2, [r3]
 333:usb_lib/usb_core.c ****   {
 733              		.loc 1 333 0
 734 001c 49B2     		sxtb	r1, r1
 735 001e 0029     		cmp	r1, #0
 337:usb_lib/usb_core.c ****   }
 736              		.loc 1 337 0
 737 0020 B4BF     		ite	lt
 738 0022 02F03002 		andlt	r2, r2, #48
 739              	.LVL63:
 341:usb_lib/usb_core.c ****   }
 740              		.loc 1 341 0
 741 0026 02F44052 		andge	r2, r2, #12288
 742              	.LVL64:
 344:usb_lib/usb_core.c ****       || pInformation->USBwValue != 0 || Status == 0
 743              		.loc 1 344 0
 744 002a A542     		cmp	r5, r4
 745 002c 1DD9     		bls	.L81
 345:usb_lib/usb_core.c ****       || pInformation->Current_Configuration == 0)
 746              		.loc 1 345 0
 747 002e 4488     		ldrh	r4, [r0, #2]
 748              	.LVL65:
 749 0030 DCB9     		cbnz	r4, .L81
 345:usb_lib/usb_core.c ****       || pInformation->Current_Configuration == 0)
 750              		.loc 1 345 0 is_stmt 0 discriminator 1
 751 0032 D2B1     		cbz	r2, .L81
 346:usb_lib/usb_core.c ****   {
 752              		.loc 1 346 0 is_stmt 1
 753 0034 827A     		ldrb	r2, [r0, #10]	@ zero_extendqisi2
 754              	.LVL66:
 755 0036 C2B1     		cbz	r2, .L81
 756              	.LBB11:
 355:usb_lib/usb_core.c ****     }
 757              		.loc 1 355 0
 758 0038 1A68     		ldr	r2, [r3]
 759              	.LBE11:
 352:usb_lib/usb_core.c ****     {
 760              		.loc 1 352 0
 761 003a 0029     		cmp	r1, #0
 762              	.LBB12:
 355:usb_lib/usb_core.c ****     }
 763              		.loc 1 355 0
 764 003c B5BF     		itete	lt
 765 003e 22F4E042 		biclt	r2, r2, #28672
 766              	.LBE12:
 767              	.LBB13:
 361:usb_lib/usb_core.c ****     }
 768              		.loc 1 361 0
 769 0042 22F48042 		bicge	r2, r2, #16384
 770              	.LBE13:
 771              	.LBB14:
 355:usb_lib/usb_core.c ****     }
 772              		.loc 1 355 0
 773 0046 22F04002 		biclt	r2, r2, #64
 774              	.LBE14:
 775              	.LBB15:
 361:usb_lib/usb_core.c ****     }
 776              		.loc 1 361 0
 777 004a 22F07002 		bicge	r2, r2, #112
 778              	.LBE15:
 779              	.LBB16:
 355:usb_lib/usb_core.c ****     }
 780              		.loc 1 355 0
 781 004e B5BF     		itete	lt
 782 0050 92B2     		uxthlt	r2, r2
 783              	.LBE16:
 784              	.LBB17:
 361:usb_lib/usb_core.c ****     }
 785              		.loc 1 361 0
 786 0052 92B2     		uxthge	r2, r2
 787              	.LBE17:
 788              	.LBB18:
 355:usb_lib/usb_core.c ****     }
 789              		.loc 1 355 0
 790 0054 82F01002 		eorlt	r2, r2, #16
 791              	.LVL67:
 792              	.LBE18:
 793              	.LBB19:
 361:usb_lib/usb_core.c ****     }
 794              		.loc 1 361 0
 795 0058 82F48052 		eorge	r2, r2, #4096
 796              	.LVL68:
 797 005c 1A60     		str	r2, [r3]
 798              	.LBE19:
 364:usb_lib/usb_core.c ****   return USB_SUCCESS;
 799              		.loc 1 364 0
 800 005e 064B     		ldr	r3, .L83+8
 801 0060 1B68     		ldr	r3, [r3]
 802 0062 9B69     		ldr	r3, [r3, #24]
 803 0064 9847     		blx	r3
 804              	.LVL69:
 365:usb_lib/usb_core.c **** }
 805              		.loc 1 365 0
 806 0066 0020     		movs	r0, #0
 807              	.L75:
 366:usb_lib/usb_core.c **** 
 808              		.loc 1 366 0
 809 0068 38BD     		pop	{r3, r4, r5, pc}
 810              	.LVL70:
 811              	.L81:
 348:usb_lib/usb_core.c ****   }
 812              		.loc 1 348 0
 813 006a 0220     		movs	r0, #2
 814              	.LVL71:
 815 006c FCE7     		b	.L75
 816              	.L84:
 817 006e 00BF     		.align	2
 818              	.L83:
 819 0070 00000000 		.word	pInformation
 820 0074 00000000 		.word	Device_Table
 821 0078 00000000 		.word	pUser_Standard_Requests
 822              		.cfi_endproc
 823              	.LFE6:
 825              		.section	.text.Standard_SetDeviceFeature,"ax",%progbits
 826              		.align	1
 827              		.global	Standard_SetDeviceFeature
 828              		.syntax unified
 829              		.thumb
 830              		.thumb_func
 831              		.fpu softvfp
 833              	Standard_SetDeviceFeature:
 834              	.LFB7:
 377:usb_lib/usb_core.c ****   SetBit(pInformation->Current_Feature, 5);
 835              		.loc 1 377 0
 836              		.cfi_startproc
 837              		@ args = 0, pretend = 0, frame = 0
 838              		@ frame_needed = 0, uses_anonymous_args = 0
 839 0000 08B5     		push	{r3, lr}
 840              		.cfi_def_cfa_offset 8
 841              		.cfi_offset 3, -8
 842              		.cfi_offset 14, -4
 378:usb_lib/usb_core.c ****   pUser_Standard_Requests->User_SetDeviceFeature();
 843              		.loc 1 378 0
 844 0002 064B     		ldr	r3, .L86
 845 0004 1A68     		ldr	r2, [r3]
 846 0006 537A     		ldrb	r3, [r2, #9]	@ zero_extendqisi2
 847 0008 43F02003 		orr	r3, r3, #32
 848 000c 5372     		strb	r3, [r2, #9]
 379:usb_lib/usb_core.c ****   return USB_SUCCESS;
 849              		.loc 1 379 0
 850 000e 044B     		ldr	r3, .L86+4
 851 0010 1B68     		ldr	r3, [r3]
 852 0012 DB69     		ldr	r3, [r3, #28]
 853 0014 9847     		blx	r3
 854              	.LVL72:
 381:usb_lib/usb_core.c **** 
 855              		.loc 1 381 0
 856 0016 0020     		movs	r0, #0
 857 0018 08BD     		pop	{r3, pc}
 858              	.L87:
 859 001a 00BF     		.align	2
 860              	.L86:
 861 001c 00000000 		.word	pInformation
 862 0020 00000000 		.word	pUser_Standard_Requests
 863              		.cfi_endproc
 864              	.LFE7:
 866              		.section	.text.Standard_GetDescriptorData,"ax",%progbits
 867              		.align	1
 868              		.global	Standard_GetDescriptorData
 869              		.syntax unified
 870              		.thumb
 871              		.thumb_func
 872              		.fpu softvfp
 874              	Standard_GetDescriptorData:
 875              	.LFB8:
 403:usb_lib/usb_core.c ****   u32  wOffset;
 876              		.loc 1 403 0
 877              		.cfi_startproc
 878              		@ args = 0, pretend = 0, frame = 0
 879              		@ frame_needed = 0, uses_anonymous_args = 0
 880              	.LVL73:
 406:usb_lib/usb_core.c ****   if (Length == 0)
 881              		.loc 1 406 0
 882 0000 054B     		ldr	r3, .L91
 403:usb_lib/usb_core.c ****   u32  wOffset;
 883              		.loc 1 403 0
 884 0002 10B5     		push	{r4, lr}
 885              		.cfi_def_cfa_offset 8
 886              		.cfi_offset 4, -8
 887              		.cfi_offset 14, -4
 406:usb_lib/usb_core.c ****   if (Length == 0)
 888              		.loc 1 406 0
 889 0004 1C68     		ldr	r4, [r3]
 890 0006 628A     		ldrh	r2, [r4, #18]
 891              	.LVL74:
 407:usb_lib/usb_core.c ****   {
 892              		.loc 1 407 0
 893 0008 18B9     		cbnz	r0, .L89
 409:usb_lib/usb_core.c ****     return 0;
 894              		.loc 1 409 0
 895 000a 8B88     		ldrh	r3, [r1, #4]
 896 000c 9B1A     		subs	r3, r3, r2
 897 000e 2382     		strh	r3, [r4, #16]	@ movhi
 898              	.LVL75:
 899              	.L88:
 414:usb_lib/usb_core.c **** 
 900              		.loc 1 414 0
 901 0010 10BD     		pop	{r4, pc}
 902              	.LVL76:
 903              	.L89:
 413:usb_lib/usb_core.c **** }
 904              		.loc 1 413 0
 905 0012 0868     		ldr	r0, [r1]
 906              	.LVL77:
 907 0014 1044     		add	r0, r0, r2
 908 0016 FBE7     		b	.L88
 909              	.L92:
 910              		.align	2
 911              	.L91:
 912 0018 00000000 		.word	pInformation
 913              		.cfi_endproc
 914              	.LFE8:
 916              		.section	.text.Post0_Process,"ax",%progbits
 917              		.align	1
 918              		.global	Post0_Process
 919              		.syntax unified
 920              		.thumb
 921              		.thumb_func
 922              		.fpu softvfp
 924              	Post0_Process:
 925              	.LFB16:
 531:usb_lib/usb_core.c **** 
 532:usb_lib/usb_core.c **** /*******************************************************************************
 533:usb_lib/usb_core.c **** * Function Name  : NoData_Setup0.
 534:usb_lib/usb_core.c **** * Description    : Proceed the processing of setup request without data stage.
 535:usb_lib/usb_core.c **** * Input          : None.
 536:usb_lib/usb_core.c **** * Output         : None.
 537:usb_lib/usb_core.c **** * Return         : None.
 538:usb_lib/usb_core.c **** *******************************************************************************/
 539:usb_lib/usb_core.c **** void NoData_Setup0(void)
 540:usb_lib/usb_core.c **** {
 541:usb_lib/usb_core.c ****   RESULT Result = USB_UNSUPPORT;
 542:usb_lib/usb_core.c ****   u32 RequestNo = pInformation->USBbRequest;
 543:usb_lib/usb_core.c ****   u32 ControlState;
 544:usb_lib/usb_core.c **** 
 545:usb_lib/usb_core.c ****   if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 546:usb_lib/usb_core.c ****   {
 547:usb_lib/usb_core.c ****     /* Device Request*/
 548:usb_lib/usb_core.c ****     /* SET_CONFIGURATION*/
 549:usb_lib/usb_core.c ****     if (RequestNo == SET_CONFIGURATION)
 550:usb_lib/usb_core.c ****     {
 551:usb_lib/usb_core.c ****       Result = Standard_SetConfiguration();
 552:usb_lib/usb_core.c ****     }
 553:usb_lib/usb_core.c **** 
 554:usb_lib/usb_core.c ****     /*SET ADDRESS*/
 555:usb_lib/usb_core.c ****     else if (RequestNo == SET_ADDRESS)
 556:usb_lib/usb_core.c ****     {
 557:usb_lib/usb_core.c ****       if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
 558:usb_lib/usb_core.c ****           || (pInformation->USBwIndex != 0)
 559:usb_lib/usb_core.c ****           || (pInformation->Current_Configuration != 0))
 560:usb_lib/usb_core.c ****         /* Device Address should be 127 or less*/
 561:usb_lib/usb_core.c ****       {
 562:usb_lib/usb_core.c ****         ControlState = STALLED;
 563:usb_lib/usb_core.c ****         goto exit_NoData_Setup0;
 564:usb_lib/usb_core.c ****       }
 565:usb_lib/usb_core.c ****       else
 566:usb_lib/usb_core.c ****       {
 567:usb_lib/usb_core.c ****         Result = USB_SUCCESS;
 568:usb_lib/usb_core.c ****       }
 569:usb_lib/usb_core.c ****     }
 570:usb_lib/usb_core.c ****     /*SET FEATURE for Device*/
 571:usb_lib/usb_core.c ****     else if (RequestNo == SET_FEATURE)
 572:usb_lib/usb_core.c ****     {
 573:usb_lib/usb_core.c ****       if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
 574:usb_lib/usb_core.c ****           && (pInformation->USBwIndex == 0)
 575:usb_lib/usb_core.c ****           && (ValBit(pInformation->Current_Feature, 5)))
 576:usb_lib/usb_core.c ****       {
 577:usb_lib/usb_core.c ****         Result = Standard_SetDeviceFeature();
 578:usb_lib/usb_core.c ****       }
 579:usb_lib/usb_core.c ****       else
 580:usb_lib/usb_core.c ****       {
 581:usb_lib/usb_core.c ****         Result = USB_UNSUPPORT;
 582:usb_lib/usb_core.c ****       }
 583:usb_lib/usb_core.c ****     }
 584:usb_lib/usb_core.c ****     /*Clear FEATURE for Device */
 585:usb_lib/usb_core.c ****     else if (RequestNo == CLEAR_FEATURE)
 586:usb_lib/usb_core.c ****     {
 587:usb_lib/usb_core.c ****       if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
 588:usb_lib/usb_core.c ****           && pInformation->USBwIndex == 0
 589:usb_lib/usb_core.c ****           && ValBit(pInformation->Current_Feature, 5))
 590:usb_lib/usb_core.c ****       {
 591:usb_lib/usb_core.c ****         Result = Standard_ClearFeature();
 592:usb_lib/usb_core.c ****       }
 593:usb_lib/usb_core.c ****       else
 594:usb_lib/usb_core.c ****       {
 595:usb_lib/usb_core.c ****         Result = USB_UNSUPPORT;
 596:usb_lib/usb_core.c ****       }
 597:usb_lib/usb_core.c ****     }
 598:usb_lib/usb_core.c **** 
 599:usb_lib/usb_core.c ****   }
 600:usb_lib/usb_core.c **** 
 601:usb_lib/usb_core.c ****   /* Interface Request*/
 602:usb_lib/usb_core.c ****   else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 603:usb_lib/usb_core.c ****   {
 604:usb_lib/usb_core.c ****     /*SET INTERFACE*/
 605:usb_lib/usb_core.c ****     if (RequestNo == SET_INTERFACE)
 606:usb_lib/usb_core.c ****     {
 607:usb_lib/usb_core.c ****       Result = Standard_SetInterface();
 608:usb_lib/usb_core.c ****     }
 609:usb_lib/usb_core.c ****   }
 610:usb_lib/usb_core.c **** 
 611:usb_lib/usb_core.c ****   /* EndPoint Request*/
 612:usb_lib/usb_core.c ****   else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 613:usb_lib/usb_core.c ****   {
 614:usb_lib/usb_core.c ****     /*CLEAR FEATURE for EndPoint*/
 615:usb_lib/usb_core.c ****     if (RequestNo == CLEAR_FEATURE)
 616:usb_lib/usb_core.c ****     {
 617:usb_lib/usb_core.c ****       Result = Standard_ClearFeature();
 618:usb_lib/usb_core.c ****     }
 619:usb_lib/usb_core.c ****     /* SET FEATURE for EndPoint*/
 620:usb_lib/usb_core.c ****     else if (RequestNo == SET_FEATURE)
 621:usb_lib/usb_core.c ****     {
 622:usb_lib/usb_core.c ****       Result = Standard_SetEndPointFeature();
 623:usb_lib/usb_core.c ****     }
 624:usb_lib/usb_core.c ****   }
 625:usb_lib/usb_core.c ****   else
 626:usb_lib/usb_core.c ****   {
 627:usb_lib/usb_core.c ****     Result = USB_UNSUPPORT;
 628:usb_lib/usb_core.c ****   }
 629:usb_lib/usb_core.c **** 
 630:usb_lib/usb_core.c **** 
 631:usb_lib/usb_core.c ****   if (Result != USB_SUCCESS)
 632:usb_lib/usb_core.c ****   {
 633:usb_lib/usb_core.c ****     Result = (*pProperty->Class_NoData_Setup)(RequestNo);
 634:usb_lib/usb_core.c ****     if (Result == USB_NOT_READY)
 635:usb_lib/usb_core.c ****     {
 636:usb_lib/usb_core.c ****       ControlState = PAUSE;
 637:usb_lib/usb_core.c ****       goto exit_NoData_Setup0;
 638:usb_lib/usb_core.c ****     }
 639:usb_lib/usb_core.c ****   }
 640:usb_lib/usb_core.c **** 
 641:usb_lib/usb_core.c ****   if (Result != USB_SUCCESS)
 642:usb_lib/usb_core.c ****   {
 643:usb_lib/usb_core.c ****     ControlState = STALLED;
 644:usb_lib/usb_core.c ****     goto exit_NoData_Setup0;
 645:usb_lib/usb_core.c ****   }
 646:usb_lib/usb_core.c **** 
 647:usb_lib/usb_core.c ****   ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
 648:usb_lib/usb_core.c **** 
 649:usb_lib/usb_core.c ****   USB_StatusIn();
 650:usb_lib/usb_core.c **** 
 651:usb_lib/usb_core.c **** exit_NoData_Setup0:
 652:usb_lib/usb_core.c ****   pInformation->ControlState = ControlState;
 653:usb_lib/usb_core.c ****   return;
 654:usb_lib/usb_core.c **** }
 655:usb_lib/usb_core.c **** 
 656:usb_lib/usb_core.c **** /*******************************************************************************
 657:usb_lib/usb_core.c **** * Function Name  : Data_Setup0.
 658:usb_lib/usb_core.c **** * Description    : Proceed the processing of setup request with data stage.
 659:usb_lib/usb_core.c **** * Input          : None.
 660:usb_lib/usb_core.c **** * Output         : None.
 661:usb_lib/usb_core.c **** * Return         : None.
 662:usb_lib/usb_core.c **** *******************************************************************************/
 663:usb_lib/usb_core.c **** void Data_Setup0(void)
 664:usb_lib/usb_core.c **** {
 665:usb_lib/usb_core.c ****   u8 *(*CopyRoutine)(u16);
 666:usb_lib/usb_core.c ****   RESULT Result;
 667:usb_lib/usb_core.c ****   u32 Request_No = pInformation->USBbRequest;
 668:usb_lib/usb_core.c **** 
 669:usb_lib/usb_core.c ****   u32 Related_Endpoint, Reserved;
 670:usb_lib/usb_core.c ****   u32 wOffset, Status;
 671:usb_lib/usb_core.c **** 
 672:usb_lib/usb_core.c **** 
 673:usb_lib/usb_core.c **** 
 674:usb_lib/usb_core.c ****   CopyRoutine = NULL;
 675:usb_lib/usb_core.c ****   wOffset = 0;
 676:usb_lib/usb_core.c **** 
 677:usb_lib/usb_core.c ****   if (Request_No == GET_DESCRIPTOR)
 678:usb_lib/usb_core.c ****   {
 679:usb_lib/usb_core.c ****     if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 680:usb_lib/usb_core.c ****     {
 681:usb_lib/usb_core.c ****       u8 wValue1 = pInformation->USBwValue1;
 682:usb_lib/usb_core.c ****       if (wValue1 == DEVICE_DESCRIPTOR)
 683:usb_lib/usb_core.c ****       {
 684:usb_lib/usb_core.c ****         CopyRoutine = pProperty->GetDeviceDescriptor;
 685:usb_lib/usb_core.c ****       }
 686:usb_lib/usb_core.c ****       else if (wValue1 == CONFIG_DESCRIPTOR)
 687:usb_lib/usb_core.c ****       {
 688:usb_lib/usb_core.c ****         CopyRoutine = pProperty->GetConfigDescriptor;
 689:usb_lib/usb_core.c ****       }
 690:usb_lib/usb_core.c ****       else if (wValue1 == STRING_DESCRIPTOR)
 691:usb_lib/usb_core.c ****       {
 692:usb_lib/usb_core.c ****         CopyRoutine = pProperty->GetStringDescriptor;
 693:usb_lib/usb_core.c ****       } else if (wValue1 == 0x21) /* added to support functional descriptors */
 694:usb_lib/usb_core.c ****       {
 695:usb_lib/usb_core.c **** 	CopyRoutine = pProperty->GetFunctionalDescriptor;
 696:usb_lib/usb_core.c ****       } /* End of GET_DESCRIPTOR */
 697:usb_lib/usb_core.c ****     }
 698:usb_lib/usb_core.c ****   }
 699:usb_lib/usb_core.c **** 
 700:usb_lib/usb_core.c ****   /*GET STATUS*/
 701:usb_lib/usb_core.c ****   else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
 702:usb_lib/usb_core.c ****            && (pInformation->USBwLength == 0x0002)
 703:usb_lib/usb_core.c ****            && (pInformation->USBwIndex1 == 0))
 704:usb_lib/usb_core.c ****   {
 705:usb_lib/usb_core.c ****     /* GET STATUS for Device*/
 706:usb_lib/usb_core.c ****     if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 707:usb_lib/usb_core.c ****         && (pInformation->USBwIndex == 0))
 708:usb_lib/usb_core.c ****     {
 709:usb_lib/usb_core.c ****       CopyRoutine = Standard_GetStatus;
 710:usb_lib/usb_core.c ****     }
 711:usb_lib/usb_core.c **** 
 712:usb_lib/usb_core.c ****     /* GET STATUS for Interface*/
 713:usb_lib/usb_core.c ****     else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 714:usb_lib/usb_core.c ****     {
 715:usb_lib/usb_core.c ****       if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
 716:usb_lib/usb_core.c ****           && (pInformation->Current_Configuration != 0))
 717:usb_lib/usb_core.c ****       {
 718:usb_lib/usb_core.c ****         CopyRoutine = Standard_GetStatus;
 719:usb_lib/usb_core.c ****       }
 720:usb_lib/usb_core.c ****     }
 721:usb_lib/usb_core.c **** 
 722:usb_lib/usb_core.c ****     /* GET STATUS for EndPoint*/
 723:usb_lib/usb_core.c ****     else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
 724:usb_lib/usb_core.c ****     {
 725:usb_lib/usb_core.c ****       Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
 726:usb_lib/usb_core.c ****       Reserved = pInformation->USBwIndex0 & 0x70;
 727:usb_lib/usb_core.c **** 
 728:usb_lib/usb_core.c ****       if (ValBit(pInformation->USBwIndex0, 7))
 729:usb_lib/usb_core.c ****       {
 730:usb_lib/usb_core.c ****         /*Get Status of endpoint & stall the request if the related_ENdpoint
 731:usb_lib/usb_core.c ****         is Disabled*/
 732:usb_lib/usb_core.c ****         Status = _GetEPTxStatus(Related_Endpoint);
 733:usb_lib/usb_core.c ****       }
 734:usb_lib/usb_core.c ****       else
 735:usb_lib/usb_core.c ****       {
 736:usb_lib/usb_core.c ****         Status = _GetEPRxStatus(Related_Endpoint);
 737:usb_lib/usb_core.c ****       }
 738:usb_lib/usb_core.c **** 
 739:usb_lib/usb_core.c ****       if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
 740:usb_lib/usb_core.c ****           && (Status != 0))
 741:usb_lib/usb_core.c ****       {
 742:usb_lib/usb_core.c ****         CopyRoutine = Standard_GetStatus;
 743:usb_lib/usb_core.c ****       }
 744:usb_lib/usb_core.c ****     }
 745:usb_lib/usb_core.c **** 
 746:usb_lib/usb_core.c ****   }
 747:usb_lib/usb_core.c **** 
 748:usb_lib/usb_core.c ****   /*GET CONFIGURATION*/
 749:usb_lib/usb_core.c ****   else if (Request_No == GET_CONFIGURATION)
 750:usb_lib/usb_core.c ****   {
 751:usb_lib/usb_core.c ****     if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
 752:usb_lib/usb_core.c ****     {
 753:usb_lib/usb_core.c ****       CopyRoutine = Standard_GetConfiguration;
 754:usb_lib/usb_core.c ****     }
 755:usb_lib/usb_core.c ****   }
 756:usb_lib/usb_core.c ****   /*GET INTERFACE*/
 757:usb_lib/usb_core.c ****   else if (Request_No == GET_INTERFACE)
 758:usb_lib/usb_core.c ****   {
 759:usb_lib/usb_core.c ****     if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
 760:usb_lib/usb_core.c ****         && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
 761:usb_lib/usb_core.c ****         && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
 762:usb_lib/usb_core.c ****         && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
 763:usb_lib/usb_core.c ****     {
 764:usb_lib/usb_core.c ****       CopyRoutine = Standard_GetInterface;
 765:usb_lib/usb_core.c ****     }
 766:usb_lib/usb_core.c **** 
 767:usb_lib/usb_core.c ****   }
 768:usb_lib/usb_core.c **** 
 769:usb_lib/usb_core.c ****   if (CopyRoutine)
 770:usb_lib/usb_core.c ****   {
 771:usb_lib/usb_core.c ****     pInformation->Ctrl_Info.Usb_wOffset = wOffset;
 772:usb_lib/usb_core.c ****     pInformation->Ctrl_Info.CopyData = CopyRoutine;
 773:usb_lib/usb_core.c ****     /* sb in the original the cast to word was directly */
 774:usb_lib/usb_core.c ****     /* now the cast is made step by step */
 775:usb_lib/usb_core.c ****     (*CopyRoutine)(0);
 776:usb_lib/usb_core.c ****     Result = USB_SUCCESS;
 777:usb_lib/usb_core.c ****   }
 778:usb_lib/usb_core.c ****   else
 779:usb_lib/usb_core.c ****   {
 780:usb_lib/usb_core.c ****     Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
 781:usb_lib/usb_core.c ****     if (Result == USB_NOT_READY)
 782:usb_lib/usb_core.c ****     {
 783:usb_lib/usb_core.c ****       pInformation->ControlState = PAUSE;
 784:usb_lib/usb_core.c ****       return;
 785:usb_lib/usb_core.c ****     }
 786:usb_lib/usb_core.c ****   }
 787:usb_lib/usb_core.c **** 
 788:usb_lib/usb_core.c ****   if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
 789:usb_lib/usb_core.c ****   {
 790:usb_lib/usb_core.c ****     /* Data is not ready, wait it */
 791:usb_lib/usb_core.c ****     pInformation->ControlState = PAUSE;
 792:usb_lib/usb_core.c ****     return;
 793:usb_lib/usb_core.c ****   }
 794:usb_lib/usb_core.c ****   if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
 795:usb_lib/usb_core.c ****   {
 796:usb_lib/usb_core.c ****     /* Unsupported request */
 797:usb_lib/usb_core.c ****     pInformation->ControlState = STALLED;
 798:usb_lib/usb_core.c ****     return;
 799:usb_lib/usb_core.c ****   }
 800:usb_lib/usb_core.c **** 
 801:usb_lib/usb_core.c **** 
 802:usb_lib/usb_core.c ****   if (ValBit(pInformation->USBbmRequestType, 7))
 803:usb_lib/usb_core.c ****   {
 804:usb_lib/usb_core.c ****     /* Device ==> Host */
 805:usb_lib/usb_core.c ****     vu32 wLength = pInformation->USBwLength;
 806:usb_lib/usb_core.c **** 
 807:usb_lib/usb_core.c ****     /* Restrict the data length to be the one host asks */
 808:usb_lib/usb_core.c ****     if (pInformation->Ctrl_Info.Usb_wLength > wLength)
 809:usb_lib/usb_core.c ****     {
 810:usb_lib/usb_core.c ****       pInformation->Ctrl_Info.Usb_wLength = wLength;
 811:usb_lib/usb_core.c ****     }
 812:usb_lib/usb_core.c **** 
 813:usb_lib/usb_core.c ****     else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
 814:usb_lib/usb_core.c ****     {
 815:usb_lib/usb_core.c ****       if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
 816:usb_lib/usb_core.c ****       {
 817:usb_lib/usb_core.c ****         Data_Mul_MaxPacketSize = FALSE;
 818:usb_lib/usb_core.c ****       }
 819:usb_lib/usb_core.c ****       else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
 820:usb_lib/usb_core.c ****       {
 821:usb_lib/usb_core.c ****         Data_Mul_MaxPacketSize = TRUE;
 822:usb_lib/usb_core.c ****       }
 823:usb_lib/usb_core.c ****     }
 824:usb_lib/usb_core.c **** 
 825:usb_lib/usb_core.c ****     pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
 826:usb_lib/usb_core.c ****     DataStageIn();
 827:usb_lib/usb_core.c ****   }
 828:usb_lib/usb_core.c ****   else
 829:usb_lib/usb_core.c ****   {
 830:usb_lib/usb_core.c ****     pInformation->ControlState = OUT_DATA;
 831:usb_lib/usb_core.c ****     vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
 832:usb_lib/usb_core.c ****   }
 833:usb_lib/usb_core.c **** 
 834:usb_lib/usb_core.c ****   return;
 835:usb_lib/usb_core.c **** }
 836:usb_lib/usb_core.c **** 
 837:usb_lib/usb_core.c **** /*******************************************************************************
 838:usb_lib/usb_core.c **** * Function Name  : Setup0_Process
 839:usb_lib/usb_core.c **** * Description    : Get the device request data and dispatch to individual process.
 840:usb_lib/usb_core.c **** * Input          : None.
 841:usb_lib/usb_core.c **** * Output         : None.
 842:usb_lib/usb_core.c **** * Return         : Post0_Process.
 843:usb_lib/usb_core.c **** *******************************************************************************/
 844:usb_lib/usb_core.c **** u8 Setup0_Process(void)
 845:usb_lib/usb_core.c **** {
 846:usb_lib/usb_core.c **** 
 847:usb_lib/usb_core.c ****   union
 848:usb_lib/usb_core.c ****   {
 849:usb_lib/usb_core.c ****     u8* b;
 850:usb_lib/usb_core.c ****     u16* w;
 851:usb_lib/usb_core.c ****   } pBuf;
 852:usb_lib/usb_core.c **** 
 853:usb_lib/usb_core.c ****   pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
 854:usb_lib/usb_core.c **** 
 855:usb_lib/usb_core.c ****   if (pInformation->ControlState != PAUSE)
 856:usb_lib/usb_core.c ****   {
 857:usb_lib/usb_core.c ****     pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
 858:usb_lib/usb_core.c ****     pInformation->USBbRequest = *pBuf.b++; /* bRequest */
 859:usb_lib/usb_core.c ****     pBuf.w++;  /* word not accessed because of 32 bits addressing */
 860:usb_lib/usb_core.c ****     pInformation->USBwValue = *pBuf.w++; /* wValue in Little Endian */
 861:usb_lib/usb_core.c ****     pBuf.w++;  /* word not accessed because of 32 bits addressing */
 862:usb_lib/usb_core.c ****     pInformation->USBwIndex  = *pBuf.w++; /* wIndex in Little Endian */
 863:usb_lib/usb_core.c ****     pBuf.w++;  /* word not accessed because of 32 bits addressing */
 864:usb_lib/usb_core.c ****     pInformation->USBwLength = *pBuf.w; /* wLength in Little Endian */
 865:usb_lib/usb_core.c ****   }
 866:usb_lib/usb_core.c **** 
 867:usb_lib/usb_core.c ****   pInformation->ControlState = SETTING_UP;
 868:usb_lib/usb_core.c ****   if (pInformation->USBwLength == 0)
 869:usb_lib/usb_core.c ****   {
 870:usb_lib/usb_core.c ****     /* Setup with no data stage */
 871:usb_lib/usb_core.c ****     NoData_Setup0();
 872:usb_lib/usb_core.c ****   }
 873:usb_lib/usb_core.c ****   else
 874:usb_lib/usb_core.c ****   {
 875:usb_lib/usb_core.c ****     /* Setup with data stage */
 876:usb_lib/usb_core.c ****     Data_Setup0();
 877:usb_lib/usb_core.c ****   }
 878:usb_lib/usb_core.c ****   return Post0_Process();
 879:usb_lib/usb_core.c **** }
 880:usb_lib/usb_core.c **** 
 881:usb_lib/usb_core.c **** /*******************************************************************************
 882:usb_lib/usb_core.c **** * Function Name  : In0_Process
 883:usb_lib/usb_core.c **** * Description    : Process the IN token on all default endpoint.
 884:usb_lib/usb_core.c **** * Input          : None.
 885:usb_lib/usb_core.c **** * Output         : None.
 886:usb_lib/usb_core.c **** * Return         : Post0_Process.
 887:usb_lib/usb_core.c **** *******************************************************************************/
 888:usb_lib/usb_core.c **** u8 In0_Process(void)
 889:usb_lib/usb_core.c **** {
 890:usb_lib/usb_core.c ****   u32 ControlState = pInformation->ControlState;
 891:usb_lib/usb_core.c **** 
 892:usb_lib/usb_core.c ****   if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
 893:usb_lib/usb_core.c ****   {
 894:usb_lib/usb_core.c ****     DataStageIn();
 895:usb_lib/usb_core.c ****     /* ControlState may be changed outside the function */
 896:usb_lib/usb_core.c ****     ControlState = pInformation->ControlState;
 897:usb_lib/usb_core.c ****   }
 898:usb_lib/usb_core.c **** 
 899:usb_lib/usb_core.c ****   else if (ControlState == WAIT_STATUS_IN)
 900:usb_lib/usb_core.c ****   {
 901:usb_lib/usb_core.c ****     if ((pInformation->USBbRequest == SET_ADDRESS) &&
 902:usb_lib/usb_core.c ****         (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
 903:usb_lib/usb_core.c ****     {
 904:usb_lib/usb_core.c ****       SetDeviceAddress(pInformation->USBwValue0);
 905:usb_lib/usb_core.c ****       pUser_Standard_Requests->User_SetDeviceAddress();
 906:usb_lib/usb_core.c ****     }
 907:usb_lib/usb_core.c ****     (*pProperty->Process_Status_IN)();
 908:usb_lib/usb_core.c ****     ControlState = STALLED;
 909:usb_lib/usb_core.c ****   }
 910:usb_lib/usb_core.c **** 
 911:usb_lib/usb_core.c ****   else
 912:usb_lib/usb_core.c ****   {
 913:usb_lib/usb_core.c ****     ControlState = STALLED;
 914:usb_lib/usb_core.c ****   }
 915:usb_lib/usb_core.c **** 
 916:usb_lib/usb_core.c ****   pInformation->ControlState = ControlState;
 917:usb_lib/usb_core.c **** 
 918:usb_lib/usb_core.c ****   return Post0_Process();
 919:usb_lib/usb_core.c **** }
 920:usb_lib/usb_core.c **** 
 921:usb_lib/usb_core.c **** /*******************************************************************************
 922:usb_lib/usb_core.c **** * Function Name  : Out0_Process
 923:usb_lib/usb_core.c **** * Description    : Process the OUT token on all default endpoint.
 924:usb_lib/usb_core.c **** * Input          : None.
 925:usb_lib/usb_core.c **** * Output         : None.
 926:usb_lib/usb_core.c **** * Return         : Post0_Process.
 927:usb_lib/usb_core.c **** *******************************************************************************/
 928:usb_lib/usb_core.c **** u8 Out0_Process(void)
 929:usb_lib/usb_core.c **** {
 930:usb_lib/usb_core.c ****   u32 ControlState = pInformation->ControlState;
 931:usb_lib/usb_core.c **** 
 932:usb_lib/usb_core.c ****   if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
 933:usb_lib/usb_core.c ****   {
 934:usb_lib/usb_core.c ****     DataStageOut();
 935:usb_lib/usb_core.c ****     ControlState = pInformation->ControlState; /* may be changed outside the function */
 936:usb_lib/usb_core.c ****   }
 937:usb_lib/usb_core.c **** 
 938:usb_lib/usb_core.c ****   else if (ControlState == WAIT_STATUS_OUT)
 939:usb_lib/usb_core.c ****   {
 940:usb_lib/usb_core.c ****     (*pProperty->Process_Status_OUT)();
 941:usb_lib/usb_core.c ****     ControlState = STALLED;
 942:usb_lib/usb_core.c ****   }
 943:usb_lib/usb_core.c **** 
 944:usb_lib/usb_core.c ****   else if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
 945:usb_lib/usb_core.c ****   {
 946:usb_lib/usb_core.c ****     /* host aborts the transfer before finish */
 947:usb_lib/usb_core.c ****     ControlState = STALLED;
 948:usb_lib/usb_core.c ****   }
 949:usb_lib/usb_core.c **** 
 950:usb_lib/usb_core.c ****   /* Unexpect state, STALL the endpoint */
 951:usb_lib/usb_core.c ****   else
 952:usb_lib/usb_core.c ****   {
 953:usb_lib/usb_core.c ****     ControlState = STALLED;
 954:usb_lib/usb_core.c ****   }
 955:usb_lib/usb_core.c **** 
 956:usb_lib/usb_core.c ****   pInformation->ControlState = ControlState;
 957:usb_lib/usb_core.c **** 
 958:usb_lib/usb_core.c ****   return Post0_Process();
 959:usb_lib/usb_core.c **** }
 960:usb_lib/usb_core.c **** 
 961:usb_lib/usb_core.c **** /*******************************************************************************
 962:usb_lib/usb_core.c **** * Function Name  : Post0_Process
 963:usb_lib/usb_core.c **** * Description    : Stall the Endpoint 0 in case of error.
 964:usb_lib/usb_core.c **** * Input          : None.
 965:usb_lib/usb_core.c **** * Output         : None.
 966:usb_lib/usb_core.c **** * Return         : - 0 if the control State is in PAUSE
 967:usb_lib/usb_core.c **** *                  - 1 if not.
 968:usb_lib/usb_core.c **** *******************************************************************************/
 969:usb_lib/usb_core.c **** u8 Post0_Process(void)
 970:usb_lib/usb_core.c **** {
 926              		.loc 1 970 0
 927              		.cfi_startproc
 928              		@ args = 0, pretend = 0, frame = 0
 929              		@ frame_needed = 0, uses_anonymous_args = 0
 930 0000 08B5     		push	{r3, lr}
 931              		.cfi_def_cfa_offset 8
 932              		.cfi_offset 3, -8
 933              		.cfi_offset 14, -4
 971:usb_lib/usb_core.c ****   SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
 934              		.loc 1 971 0
 935 0002 0B4B     		ldr	r3, .L95
 936 0004 0020     		movs	r0, #0
 937 0006 93F83010 		ldrb	r1, [r3, #48]	@ zero_extendqisi2
 938 000a FFF7FEFF 		bl	SetEPRxCount
 939              	.LVL78:
 972:usb_lib/usb_core.c **** 
 973:usb_lib/usb_core.c ****   if (pInformation->ControlState == STALLED)
 940              		.loc 1 973 0
 941 000e 094B     		ldr	r3, .L95+4
 942 0010 1B68     		ldr	r3, [r3]
 943 0012 187A     		ldrb	r0, [r3, #8]	@ zero_extendqisi2
 944 0014 0828     		cmp	r0, #8
 945 0016 06D1     		bne	.L94
 974:usb_lib/usb_core.c ****   {
 975:usb_lib/usb_core.c ****     vSetEPRxStatus(EP_RX_STALL);
 946              		.loc 1 975 0
 947 0018 4FF48052 		mov	r2, #4096
 948 001c 064B     		ldr	r3, .L95+8
 949 001e 1A80     		strh	r2, [r3]	@ movhi
 976:usb_lib/usb_core.c ****     vSetEPTxStatus(EP_TX_STALL);
 950              		.loc 1 976 0
 951 0020 1022     		movs	r2, #16
 952 0022 064B     		ldr	r3, .L95+12
 953 0024 1A80     		strh	r2, [r3]	@ movhi
 954              	.L94:
 977:usb_lib/usb_core.c ****   }
 978:usb_lib/usb_core.c **** 
 979:usb_lib/usb_core.c ****   return (pInformation->ControlState == PAUSE);
 980:usb_lib/usb_core.c **** }
 955              		.loc 1 980 0
 956 0026 A0F10903 		sub	r3, r0, #9
 957 002a 5842     		rsbs	r0, r3, #0
 958 002c 5841     		adcs	r0, r0, r3
 959 002e 08BD     		pop	{r3, pc}
 960              	.L96:
 961              		.align	2
 962              	.L95:
 963 0030 00000000 		.word	Device_Property
 964 0034 00000000 		.word	pInformation
 965 0038 00000000 		.word	SaveRState
 966 003c 00000000 		.word	SaveTState
 967              		.cfi_endproc
 968              	.LFE16:
 970              		.section	.text.Setup0_Process,"ax",%progbits
 971              		.align	1
 972              		.global	Setup0_Process
 973              		.syntax unified
 974              		.thumb
 975              		.thumb_func
 976              		.fpu softvfp
 978              	Setup0_Process:
 979              	.LFB13:
 845:usb_lib/usb_core.c **** 
 980              		.loc 1 845 0
 981              		.cfi_startproc
 982              		@ args = 0, pretend = 0, frame = 8
 983              		@ frame_needed = 0, uses_anonymous_args = 0
 984 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 985              		.cfi_def_cfa_offset 24
 986              		.cfi_offset 4, -16
 987              		.cfi_offset 5, -12
 988              		.cfi_offset 6, -8
 989              		.cfi_offset 14, -4
 855:usb_lib/usb_core.c ****   {
 990              		.loc 1 855 0
 991 0002 964D     		ldr	r5, .L166
 853:usb_lib/usb_core.c **** 
 992              		.loc 1 853 0
 993 0004 964E     		ldr	r6, .L166+4
 855:usb_lib/usb_core.c ****   {
 994              		.loc 1 855 0
 995 0006 2B68     		ldr	r3, [r5]
 853:usb_lib/usb_core.c **** 
 996              		.loc 1 853 0
 997 0008 3168     		ldr	r1, [r6]
 998              	.LVL79:
 855:usb_lib/usb_core.c ****   {
 999              		.loc 1 855 0
 1000 000a 1A7A     		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 1001 000c 092A     		cmp	r2, #9
 1002 000e 13D0     		beq	.L98
 853:usb_lib/usb_core.c **** 
 1003              		.loc 1 853 0
 1004 0010 944A     		ldr	r2, .L166+8
 1005 0012 89B2     		uxth	r1, r1
 1006              	.LVL80:
 1007 0014 0A44     		add	r2, r2, r1
 1008 0016 5200     		lsls	r2, r2, #1
 1009 0018 1288     		ldrh	r2, [r2]
 1010 001a 5200     		lsls	r2, r2, #1
 1011 001c 02F18042 		add	r2, r2, #1073741824
 1012 0020 02F5C042 		add	r2, r2, #24576
 857:usb_lib/usb_core.c ****     pInformation->USBbRequest = *pBuf.b++; /* bRequest */
 1013              		.loc 1 857 0
 1014 0024 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 1015 0026 1970     		strb	r1, [r3]
 858:usb_lib/usb_core.c ****     pBuf.w++;  /* word not accessed because of 32 bits addressing */
 1016              		.loc 1 858 0
 1017 0028 5178     		ldrb	r1, [r2, #1]	@ zero_extendqisi2
 1018 002a 5970     		strb	r1, [r3, #1]
 860:usb_lib/usb_core.c ****     pBuf.w++;  /* word not accessed because of 32 bits addressing */
 1019              		.loc 1 860 0
 1020 002c 9188     		ldrh	r1, [r2, #4]
 1021 002e 5980     		strh	r1, [r3, #2]	@ movhi
 862:usb_lib/usb_core.c ****     pBuf.w++;  /* word not accessed because of 32 bits addressing */
 1022              		.loc 1 862 0
 1023 0030 1189     		ldrh	r1, [r2, #8]
 1024 0032 9980     		strh	r1, [r3, #4]	@ movhi
 864:usb_lib/usb_core.c ****   }
 1025              		.loc 1 864 0
 1026 0034 9289     		ldrh	r2, [r2, #12]
 1027 0036 DA80     		strh	r2, [r3, #6]	@ movhi
 1028              	.L98:
 867:usb_lib/usb_core.c ****   if (pInformation->USBwLength == 0)
 1029              		.loc 1 867 0
 1030 0038 0122     		movs	r2, #1
 1031 003a 1A72     		strb	r2, [r3, #8]
 868:usb_lib/usb_core.c ****   {
 1032              		.loc 1 868 0
 1033 003c DA88     		ldrh	r2, [r3, #6]
 1034 003e 5C78     		ldrb	r4, [r3, #1]	@ zero_extendqisi2
 1035 0040 002A     		cmp	r2, #0
 1036 0042 64D1     		bne	.L99
 1037              	.LVL81:
 1038 0044 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1039              	.LBB26:
 1040              	.LBB27:
 545:usb_lib/usb_core.c ****   {
 1041              		.loc 1 545 0
 1042 0046 12F07F02 		ands	r2, r2, #127
 1043 004a 4DD1     		bne	.L100
 549:usb_lib/usb_core.c ****     {
 1044              		.loc 1 549 0
 1045 004c 092C     		cmp	r4, #9
 1046 004e 03D1     		bne	.L101
 551:usb_lib/usb_core.c ****     }
 1047              		.loc 1 551 0
 1048 0050 FFF7FEFF 		bl	Standard_SetConfiguration
 1049              	.LVL82:
 1050              	.L102:
 631:usb_lib/usb_core.c ****   {
 1051              		.loc 1 631 0
 1052 0054 40BB     		cbnz	r0, .L110
 1053 0056 16E0     		b	.L113
 1054              	.LVL83:
 1055              	.L101:
 555:usb_lib/usb_core.c ****     {
 1056              		.loc 1 555 0
 1057 0058 052C     		cmp	r4, #5
 1058 005a 20D1     		bne	.L103
 557:usb_lib/usb_core.c ****           || (pInformation->USBwIndex != 0)
 1059              		.loc 1 557 0
 1060 005c 93F90220 		ldrsb	r2, [r3, #2]
 1061 0060 002A     		cmp	r2, #0
 1062 0062 07DA     		bge	.L104
 1063              	.LVL84:
 1064              	.L106:
 562:usb_lib/usb_core.c ****         goto exit_NoData_Setup0;
 1065              		.loc 1 562 0
 1066 0064 0823     		movs	r3, #8
 1067              	.L105:
 1068              	.LVL85:
 652:usb_lib/usb_core.c ****   return;
 1069              		.loc 1 652 0
 1070 0066 2A68     		ldr	r2, [r5]
 1071 0068 1372     		strb	r3, [r2, #8]
 1072              	.LVL86:
 1073              	.L114:
 1074              	.LBE27:
 1075              	.LBE26:
 879:usb_lib/usb_core.c **** 
 1076              		.loc 1 879 0
 1077 006a 02B0     		add	sp, sp, #8
 1078              		.cfi_remember_state
 1079              		.cfi_def_cfa_offset 16
 1080              		@ sp needed
 1081 006c BDE87040 		pop	{r4, r5, r6, lr}
 1082              		.cfi_restore 14
 1083              		.cfi_restore 6
 1084              		.cfi_restore 5
 1085              		.cfi_restore 4
 1086              		.cfi_def_cfa_offset 0
 878:usb_lib/usb_core.c **** }
 1087              		.loc 1 878 0
 1088 0070 FFF7FEBF 		b	Post0_Process
 1089              	.LVL87:
 1090              	.L104:
 1091              		.cfi_restore_state
 1092              	.LBB29:
 1093              	.LBB28:
 557:usb_lib/usb_core.c ****           || (pInformation->USBwIndex != 0)
 1094              		.loc 1 557 0
 1095 0074 DA78     		ldrb	r2, [r3, #3]	@ zero_extendqisi2
 1096 0076 002A     		cmp	r2, #0
 1097 0078 F4D1     		bne	.L106
 558:usb_lib/usb_core.c ****           || (pInformation->Current_Configuration != 0))
 1098              		.loc 1 558 0
 1099 007a 9A88     		ldrh	r2, [r3, #4]
 1100 007c 002A     		cmp	r2, #0
 1101 007e F1D1     		bne	.L106
 559:usb_lib/usb_core.c ****         /* Device Address should be 127 or less*/
 1102              		.loc 1 559 0
 1103 0080 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 1104              	.LVL88:
 1105 0082 002B     		cmp	r3, #0
 1106 0084 EED1     		bne	.L106
 1107              	.LVL89:
 1108              	.L113:
 649:usb_lib/usb_core.c **** 
 1109              		.loc 1 649 0
 1110 0086 3268     		ldr	r2, [r6]
 1111 0088 774B     		ldr	r3, .L166+12
 1112 008a 92B2     		uxth	r2, r2
 1113 008c 1344     		add	r3, r3, r2
 1114 008e 0022     		movs	r2, #0
 1115 0090 5B00     		lsls	r3, r3, #1
 1116 0092 1A60     		str	r2, [r3]
 1117 0094 3022     		movs	r2, #48
 1118 0096 754B     		ldr	r3, .L166+16
 1119 0098 1A80     		strh	r2, [r3]	@ movhi
 647:usb_lib/usb_core.c **** 
 1120              		.loc 1 647 0
 1121 009a 0623     		movs	r3, #6
 1122 009c E3E7     		b	.L105
 1123              	.LVL90:
 1124              	.L103:
 571:usb_lib/usb_core.c ****     {
 1125              		.loc 1 571 0
 1126 009e 032C     		cmp	r4, #3
 1127 00a0 14D1     		bne	.L107
 573:usb_lib/usb_core.c ****           && (pInformation->USBwIndex == 0)
 1128              		.loc 1 573 0
 1129 00a2 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 1130 00a4 012A     		cmp	r2, #1
 1131 00a6 08D0     		beq	.L108
 1132              	.LVL91:
 1133              	.L110:
 633:usb_lib/usb_core.c ****     if (Result == USB_NOT_READY)
 1134              		.loc 1 633 0
 1135 00a8 714B     		ldr	r3, .L166+20
 1136 00aa 2046     		mov	r0, r4
 1137 00ac 1B68     		ldr	r3, [r3]
 1138 00ae 5B69     		ldr	r3, [r3, #20]
 1139 00b0 9847     		blx	r3
 1140              	.LVL92:
 634:usb_lib/usb_core.c ****     {
 1141              		.loc 1 634 0
 1142 00b2 0328     		cmp	r0, #3
 1143 00b4 28D1     		bne	.L161
 636:usb_lib/usb_core.c ****       goto exit_NoData_Setup0;
 1144              		.loc 1 636 0
 1145 00b6 0923     		movs	r3, #9
 1146 00b8 D5E7     		b	.L105
 1147              	.LVL93:
 1148              	.L108:
 574:usb_lib/usb_core.c ****           && (ValBit(pInformation->Current_Feature, 5)))
 1149              		.loc 1 574 0
 1150 00ba 9A88     		ldrh	r2, [r3, #4]
 1151 00bc 002A     		cmp	r2, #0
 1152 00be F3D1     		bne	.L110
 575:usb_lib/usb_core.c ****       {
 1153              		.loc 1 575 0
 1154 00c0 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 1155              	.LVL94:
 1156 00c2 9A06     		lsls	r2, r3, #26
 1157 00c4 F0D5     		bpl	.L110
 577:usb_lib/usb_core.c ****       }
 1158              		.loc 1 577 0
 1159 00c6 FFF7FEFF 		bl	Standard_SetDeviceFeature
 1160              	.LVL95:
 1161 00ca C3E7     		b	.L102
 1162              	.LVL96:
 1163              	.L107:
 585:usb_lib/usb_core.c ****     {
 1164              		.loc 1 585 0
 1165 00cc 012C     		cmp	r4, #1
 1166 00ce EBD1     		bne	.L110
 587:usb_lib/usb_core.c ****           && pInformation->USBwIndex == 0
 1167              		.loc 1 587 0
 1168 00d0 9A78     		ldrb	r2, [r3, #2]	@ zero_extendqisi2
 1169 00d2 012A     		cmp	r2, #1
 1170 00d4 E8D1     		bne	.L110
 588:usb_lib/usb_core.c ****           && ValBit(pInformation->Current_Feature, 5))
 1171              		.loc 1 588 0
 1172 00d6 9A88     		ldrh	r2, [r3, #4]
 1173 00d8 002A     		cmp	r2, #0
 1174 00da E5D1     		bne	.L110
 589:usb_lib/usb_core.c ****       {
 1175              		.loc 1 589 0
 1176 00dc 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 1177              	.LVL97:
 1178 00de 9B06     		lsls	r3, r3, #26
 1179 00e0 E2D5     		bpl	.L110
 1180              	.L112:
 591:usb_lib/usb_core.c ****       }
 1181              		.loc 1 591 0
 1182 00e2 FFF7FEFF 		bl	Standard_ClearFeature
 1183              	.LVL98:
 1184 00e6 B5E7     		b	.L102
 1185              	.LVL99:
 1186              	.L100:
 602:usb_lib/usb_core.c ****   {
 1187              		.loc 1 602 0
 1188 00e8 012A     		cmp	r2, #1
 1189 00ea 04D1     		bne	.L111
 605:usb_lib/usb_core.c ****     {
 1190              		.loc 1 605 0
 1191 00ec 0B2C     		cmp	r4, #11
 1192 00ee DBD1     		bne	.L110
 607:usb_lib/usb_core.c ****     }
 1193              		.loc 1 607 0
 1194 00f0 FFF7FEFF 		bl	Standard_SetInterface
 1195              	.LVL100:
 1196 00f4 AEE7     		b	.L102
 1197              	.LVL101:
 1198              	.L111:
 612:usb_lib/usb_core.c ****   {
 1199              		.loc 1 612 0
 1200 00f6 022A     		cmp	r2, #2
 1201 00f8 D6D1     		bne	.L110
 615:usb_lib/usb_core.c ****     {
 1202              		.loc 1 615 0
 1203 00fa 012C     		cmp	r4, #1
 1204 00fc F1D0     		beq	.L112
 620:usb_lib/usb_core.c ****     {
 1205              		.loc 1 620 0
 1206 00fe 032C     		cmp	r4, #3
 1207 0100 D2D1     		bne	.L110
 622:usb_lib/usb_core.c ****     }
 1208              		.loc 1 622 0
 1209 0102 FFF7FEFF 		bl	Standard_SetEndPointFeature
 1210              	.LVL102:
 1211 0106 A5E7     		b	.L102
 1212              	.L161:
 641:usb_lib/usb_core.c ****   {
 1213              		.loc 1 641 0
 1214 0108 0028     		cmp	r0, #0
 1215 010a ABD1     		bne	.L106
 1216 010c BBE7     		b	.L113
 1217              	.LVL103:
 1218              	.L99:
 1219              	.LBE28:
 1220              	.LBE29:
 1221              	.LBB30:
 1222              	.LBB31:
 677:usb_lib/usb_core.c ****   {
 1223              		.loc 1 677 0
 1224 010e 062C     		cmp	r4, #6
 1225 0110 16D1     		bne	.L115
 679:usb_lib/usb_core.c ****     {
 1226              		.loc 1 679 0
 1227 0112 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1228 0114 5406     		lsls	r4, r2, #25
 1229 0116 5ED1     		bne	.L116
 1230              	.LBB32:
 681:usb_lib/usb_core.c ****       if (wValue1 == DEVICE_DESCRIPTOR)
 1231              		.loc 1 681 0
 1232 0118 DB78     		ldrb	r3, [r3, #3]	@ zero_extendqisi2
 1233              	.LVL104:
 1234 011a 554A     		ldr	r2, .L166+20
 682:usb_lib/usb_core.c ****       {
 1235              		.loc 1 682 0
 1236 011c 012B     		cmp	r3, #1
 1237 011e 1268     		ldr	r2, [r2]
 1238 0120 02D1     		bne	.L117
 684:usb_lib/usb_core.c ****       }
 1239              		.loc 1 684 0
 1240 0122 D369     		ldr	r3, [r2, #28]
 1241              	.LVL105:
 1242              	.L118:
 1243              	.LBE32:
 769:usb_lib/usb_core.c ****   {
 1244              		.loc 1 769 0
 1245 0124 FBB9     		cbnz	r3, .L123
 1246 0126 56E0     		b	.L116
 1247              	.LVL106:
 1248              	.L117:
 1249              	.LBB33:
 686:usb_lib/usb_core.c ****       {
 1250              		.loc 1 686 0
 1251 0128 022B     		cmp	r3, #2
 1252 012a 01D1     		bne	.L119
 688:usb_lib/usb_core.c ****       }
 1253              		.loc 1 688 0
 1254 012c 136A     		ldr	r3, [r2, #32]
 1255              	.LVL107:
 1256 012e F9E7     		b	.L118
 1257              	.LVL108:
 1258              	.L119:
 690:usb_lib/usb_core.c ****       {
 1259              		.loc 1 690 0
 1260 0130 032B     		cmp	r3, #3
 1261 0132 01D1     		bne	.L120
 692:usb_lib/usb_core.c ****       } else if (wValue1 == 0x21) /* added to support functional descriptors */
 1262              		.loc 1 692 0
 1263 0134 536A     		ldr	r3, [r2, #36]
 1264              	.LVL109:
 1265 0136 F5E7     		b	.L118
 1266              	.LVL110:
 1267              	.L120:
 693:usb_lib/usb_core.c ****       {
 1268              		.loc 1 693 0
 1269 0138 212B     		cmp	r3, #33
 1270 013a 4CD1     		bne	.L116
 695:usb_lib/usb_core.c ****       } /* End of GET_DESCRIPTOR */
 1271              		.loc 1 695 0
 1272 013c 936A     		ldr	r3, [r2, #40]
 1273              	.LVL111:
 1274 013e F1E7     		b	.L118
 1275              	.LVL112:
 1276              	.L115:
 1277              	.LBE33:
 701:usb_lib/usb_core.c ****            && (pInformation->USBwLength == 0x0002)
 1278              		.loc 1 701 0
 1279 0140 002C     		cmp	r4, #0
 1280 0142 54D1     		bne	.L121
 1281 0144 5988     		ldrh	r1, [r3, #2]
 1282 0146 0029     		cmp	r1, #0
 1283 0148 45D1     		bne	.L116
 703:usb_lib/usb_core.c ****   {
 1284              		.loc 1 703 0
 1285 014a 5A68     		ldr	r2, [r3, #4]
 1286 014c 22F0FF02 		bic	r2, r2, #255
 1287 0150 B2F5003F 		cmp	r2, #131072
 1288 0154 3FD1     		bne	.L116
 1289 0156 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 706:usb_lib/usb_core.c ****         && (pInformation->USBwIndex == 0))
 1290              		.loc 1 706 0
 1291 0158 12F07F02 		ands	r2, r2, #127
 1292 015c 16D1     		bne	.L122
 707:usb_lib/usb_core.c ****     {
 1293              		.loc 1 707 0
 1294 015e 9B88     		ldrh	r3, [r3, #4]
 1295              	.LVL113:
 1296 0160 002B     		cmp	r3, #0
 1297 0162 38D1     		bne	.L116
 1298              	.L125:
 709:usb_lib/usb_core.c ****     }
 1299              		.loc 1 709 0
 1300 0164 434B     		ldr	r3, .L166+24
 1301              	.LVL114:
 1302              	.L123:
 771:usb_lib/usb_core.c ****     pInformation->Ctrl_Info.CopyData = CopyRoutine;
 1303              		.loc 1 771 0
 1304 0166 0024     		movs	r4, #0
 1305 0168 2A68     		ldr	r2, [r5]
 775:usb_lib/usb_core.c ****     Result = USB_SUCCESS;
 1306              		.loc 1 775 0
 1307 016a 2046     		mov	r0, r4
 771:usb_lib/usb_core.c ****     pInformation->Ctrl_Info.CopyData = CopyRoutine;
 1308              		.loc 1 771 0
 1309 016c 5482     		strh	r4, [r2, #18]	@ movhi
 772:usb_lib/usb_core.c ****     /* sb in the original the cast to word was directly */
 1310              		.loc 1 772 0
 1311 016e 9361     		str	r3, [r2, #24]
 775:usb_lib/usb_core.c ****     Result = USB_SUCCESS;
 1312              		.loc 1 775 0
 1313 0170 9847     		blx	r3
 1314              	.LVL115:
 776:usb_lib/usb_core.c ****   }
 1315              		.loc 1 776 0
 1316 0172 2046     		mov	r0, r4
 1317              	.LVL116:
 1318              	.L129:
 788:usb_lib/usb_core.c ****   {
 1319              		.loc 1 788 0
 1320 0174 4FF6FF71 		movw	r1, #65535
 1321 0178 2B68     		ldr	r3, [r5]
 1322 017a 1A8A     		ldrh	r2, [r3, #16]
 1323 017c 8A42     		cmp	r2, r1
 1324 017e 33D0     		beq	.L165
 794:usb_lib/usb_core.c ****   {
 1325              		.loc 1 794 0
 1326 0180 0228     		cmp	r0, #2
 1327 0182 01D0     		beq	.L131
 1328 0184 002A     		cmp	r2, #0
 1329 0186 55D1     		bne	.L132
 1330              	.L131:
 797:usb_lib/usb_core.c ****     return;
 1331              		.loc 1 797 0
 1332 0188 0822     		movs	r2, #8
 1333 018a 2EE0     		b	.L164
 1334              	.LVL117:
 1335              	.L122:
 713:usb_lib/usb_core.c ****     {
 1336              		.loc 1 713 0
 1337 018c 012A     		cmp	r2, #1
 1338 018e 0AD1     		bne	.L124
 715:usb_lib/usb_core.c ****           && (pInformation->Current_Configuration != 0))
 1339              		.loc 1 715 0
 1340 0190 374A     		ldr	r2, .L166+20
 1341 0192 1879     		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 1342 0194 1268     		ldr	r2, [r2]
 1343 0196 9269     		ldr	r2, [r2, #24]
 1344 0198 9047     		blx	r2
 1345              	.LVL118:
 1346 019a E0B9     		cbnz	r0, .L116
 716:usb_lib/usb_core.c ****       {
 1347              		.loc 1 716 0
 1348 019c 2B68     		ldr	r3, [r5]
 1349 019e 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 1350              	.L162:
 740:usb_lib/usb_core.c ****       {
 1351              		.loc 1 740 0
 1352 01a0 002B     		cmp	r3, #0
 1353 01a2 DFD1     		bne	.L125
 1354 01a4 17E0     		b	.L116
 1355              	.LVL119:
 1356              	.L124:
 723:usb_lib/usb_core.c ****     {
 1357              		.loc 1 723 0
 1358 01a6 022A     		cmp	r2, #2
 1359 01a8 15D1     		bne	.L116
 725:usb_lib/usb_core.c ****       Reserved = pInformation->USBwIndex0 & 0x70;
 1360              		.loc 1 725 0
 1361 01aa 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 1362 01ac 02F00F01 		and	r1, r2, #15
 1363              	.LVL120:
 1364 01b0 8B00     		lsls	r3, r1, #2
 1365              	.LVL121:
 728:usb_lib/usb_core.c ****       {
 1366              		.loc 1 728 0
 1367 01b2 1006     		lsls	r0, r2, #24
 1368 01b4 03F18043 		add	r3, r3, #1073741824
 739:usb_lib/usb_core.c ****           && (Status != 0))
 1369              		.loc 1 739 0
 1370 01b8 2F48     		ldr	r0, .L166+28
 1371 01ba 03F5B843 		add	r3, r3, #23552
 732:usb_lib/usb_core.c ****       }
 1372              		.loc 1 732 0
 1373 01be 1B68     		ldr	r3, [r3]
 739:usb_lib/usb_core.c ****           && (Status != 0))
 1374              		.loc 1 739 0
 1375 01c0 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 732:usb_lib/usb_core.c ****       }
 1376              		.loc 1 732 0
 1377 01c2 4CBF     		ite	mi
 1378 01c4 03F03003 		andmi	r3, r3, #48
 1379              	.LVL122:
 736:usb_lib/usb_core.c ****       }
 1380              		.loc 1 736 0
 1381 01c8 03F44053 		andpl	r3, r3, #12288
 1382              	.LVL123:
 739:usb_lib/usb_core.c ****           && (Status != 0))
 1383              		.loc 1 739 0
 1384 01cc 8842     		cmp	r0, r1
 1385 01ce 02D9     		bls	.L116
 1386 01d0 12F0700F 		tst	r2, #112
 1387 01d4 E4D0     		beq	.L162
 1388              	.LVL124:
 1389              	.L116:
 780:usb_lib/usb_core.c ****     if (Result == USB_NOT_READY)
 1390              		.loc 1 780 0
 1391 01d6 264B     		ldr	r3, .L166+20
 1392 01d8 2A68     		ldr	r2, [r5]
 1393 01da 1B68     		ldr	r3, [r3]
 1394 01dc 5078     		ldrb	r0, [r2, #1]	@ zero_extendqisi2
 1395 01de 1B69     		ldr	r3, [r3, #16]
 1396 01e0 9847     		blx	r3
 1397              	.LVL125:
 781:usb_lib/usb_core.c ****     {
 1398              		.loc 1 781 0
 1399 01e2 0328     		cmp	r0, #3
 1400 01e4 C6D1     		bne	.L129
 783:usb_lib/usb_core.c ****       return;
 1401              		.loc 1 783 0
 1402 01e6 2B68     		ldr	r3, [r5]
 1403              	.L165:
 791:usb_lib/usb_core.c ****     return;
 1404              		.loc 1 791 0
 1405 01e8 0922     		movs	r2, #9
 1406              	.L164:
 797:usb_lib/usb_core.c ****     return;
 1407              		.loc 1 797 0
 1408 01ea 1A72     		strb	r2, [r3, #8]
 1409 01ec 3DE7     		b	.L114
 1410              	.LVL126:
 1411              	.L121:
 749:usb_lib/usb_core.c ****   {
 1412              		.loc 1 749 0
 1413 01ee 082C     		cmp	r4, #8
 1414 01f0 04D1     		bne	.L128
 751:usb_lib/usb_core.c ****     {
 1415              		.loc 1 751 0
 1416 01f2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1417              	.LVL127:
 1418 01f4 5B06     		lsls	r3, r3, #25
 1419 01f6 EED1     		bne	.L116
 753:usb_lib/usb_core.c ****     }
 1420              		.loc 1 753 0
 1421 01f8 204B     		ldr	r3, .L166+32
 1422 01fa B4E7     		b	.L123
 1423              	.LVL128:
 1424              	.L128:
 757:usb_lib/usb_core.c ****   {
 1425              		.loc 1 757 0
 1426 01fc 0A2C     		cmp	r4, #10
 1427 01fe EAD1     		bne	.L116
 759:usb_lib/usb_core.c ****         && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
 1428              		.loc 1 759 0
 1429 0200 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1430 0202 02F07F02 		and	r2, r2, #127
 1431 0206 012A     		cmp	r2, #1
 1432 0208 E5D1     		bne	.L116
 760:usb_lib/usb_core.c ****         && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
 1433              		.loc 1 760 0
 1434 020a 9A7A     		ldrb	r2, [r3, #10]	@ zero_extendqisi2
 1435 020c 002A     		cmp	r2, #0
 1436 020e E2D0     		beq	.L116
 1437 0210 5988     		ldrh	r1, [r3, #2]
 1438 0212 0029     		cmp	r1, #0
 1439 0214 DFD1     		bne	.L116
 761:usb_lib/usb_core.c ****         && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
 1440              		.loc 1 761 0
 1441 0216 5A68     		ldr	r2, [r3, #4]
 1442 0218 22F0FF02 		bic	r2, r2, #255
 1443 021c B2F5803F 		cmp	r2, #65536
 1444 0220 D9D1     		bne	.L116
 762:usb_lib/usb_core.c ****     {
 1445              		.loc 1 762 0
 1446 0222 134A     		ldr	r2, .L166+20
 1447 0224 1879     		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 1448 0226 1268     		ldr	r2, [r2]
 1449 0228 9269     		ldr	r2, [r2, #24]
 1450 022a 9047     		blx	r2
 1451              	.LVL129:
 1452 022c 0028     		cmp	r0, #0
 1453 022e D2D1     		bne	.L116
 764:usb_lib/usb_core.c ****     }
 1454              		.loc 1 764 0
 1455 0230 134B     		ldr	r3, .L166+36
 1456 0232 98E7     		b	.L123
 1457              	.LVL130:
 1458              	.L132:
 802:usb_lib/usb_core.c ****   {
 1459              		.loc 1 802 0
 1460 0234 93F90010 		ldrsb	r1, [r3]
 1461 0238 0029     		cmp	r1, #0
 1462 023a 34DA     		bge	.L133
 1463              	.LBB34:
 805:usb_lib/usb_core.c **** 
 1464              		.loc 1 805 0
 1465 023c D988     		ldrh	r1, [r3, #6]
 1466 023e 0C48     		ldr	r0, .L166+20
 1467              	.LVL131:
 1468 0240 0191     		str	r1, [sp, #4]
 1469 0242 0068     		ldr	r0, [r0]
 808:usb_lib/usb_core.c ****     {
 1470              		.loc 1 808 0
 1471 0244 019D     		ldr	r5, [sp, #4]
 1472 0246 90F83000 		ldrb	r0, [r0, #48]	@ zero_extendqisi2
 1473 024a AA42     		cmp	r2, r5
 1474 024c 84B2     		uxth	r4, r0
 1475 024e 19D9     		bls	.L134
 810:usb_lib/usb_core.c ****     }
 1476              		.loc 1 810 0
 1477 0250 019A     		ldr	r2, [sp, #4]
 1478 0252 1A82     		strh	r2, [r3, #16]	@ movhi
 1479              	.L135:
 825:usb_lib/usb_core.c ****     DataStageIn();
 1480              		.loc 1 825 0
 1481 0254 9C82     		strh	r4, [r3, #20]	@ movhi
 826:usb_lib/usb_core.c ****   }
 1482              		.loc 1 826 0
 1483 0256 FFF7FEFF 		bl	DataStageIn
 1484              	.LVL132:
 1485 025a 06E7     		b	.L114
 1486              	.L167:
 1487              		.align	2
 1488              	.L166:
 1489 025c 00000000 		.word	pInformation
 1490 0260 505C0040 		.word	1073765456
 1491 0264 04300020 		.word	536883204
 1492 0268 02300020 		.word	536883202
 1493 026c 00000000 		.word	SaveTState
 1494 0270 00000000 		.word	pProperty
 1495 0274 00000000 		.word	Standard_GetStatus
 1496 0278 00000000 		.word	Device_Table
 1497 027c 00000000 		.word	Standard_GetConfiguration
 1498 0280 00000000 		.word	Standard_GetInterface
 1499              	.L134:
 813:usb_lib/usb_core.c ****     {
 1500              		.loc 1 813 0
 1501 0284 8A42     		cmp	r2, r1
 1502 0286 E5D2     		bcs	.L135
 815:usb_lib/usb_core.c ****       {
 1503              		.loc 1 815 0
 1504 0288 A242     		cmp	r2, r4
 1505 028a 03D2     		bcs	.L136
 817:usb_lib/usb_core.c ****       }
 1506              		.loc 1 817 0
 1507 028c 0021     		movs	r1, #0
 1508 028e 094A     		ldr	r2, .L168
 1509              	.L163:
 821:usb_lib/usb_core.c ****       }
 1510              		.loc 1 821 0
 1511 0290 1170     		strb	r1, [r2]
 1512 0292 DFE7     		b	.L135
 1513              	.L136:
 819:usb_lib/usb_core.c ****       {
 1514              		.loc 1 819 0
 1515 0294 92FBF0F1 		sdiv	r1, r2, r0
 1516 0298 00FB1122 		mls	r2, r0, r1, r2
 1517 029c 002A     		cmp	r2, #0
 1518 029e D9D1     		bne	.L135
 821:usb_lib/usb_core.c ****       }
 1519              		.loc 1 821 0
 1520 02a0 044A     		ldr	r2, .L168
 1521 02a2 0121     		movs	r1, #1
 1522 02a4 F4E7     		b	.L163
 1523              	.LVL133:
 1524              	.L133:
 1525              	.LBE34:
 830:usb_lib/usb_core.c ****     vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
 1526              		.loc 1 830 0
 1527 02a6 0322     		movs	r2, #3
 1528 02a8 1A72     		strb	r2, [r3, #8]
 831:usb_lib/usb_core.c ****   }
 1529              		.loc 1 831 0
 1530 02aa 4FF44052 		mov	r2, #12288
 1531 02ae 024B     		ldr	r3, .L168+4
 1532 02b0 1A80     		strh	r2, [r3]	@ movhi
 1533 02b2 DAE6     		b	.L114
 1534              	.L169:
 1535              		.align	2
 1536              	.L168:
 1537 02b4 00000000 		.word	.LANCHOR0
 1538 02b8 00000000 		.word	SaveRState
 1539              	.LBE31:
 1540              	.LBE30:
 1541              		.cfi_endproc
 1542              	.LFE13:
 1544              		.section	.text.Out0_Process,"ax",%progbits
 1545              		.align	1
 1546              		.global	Out0_Process
 1547              		.syntax unified
 1548              		.thumb
 1549              		.thumb_func
 1550              		.fpu softvfp
 1552              	Out0_Process:
 1553              	.LFB15:
 929:usb_lib/usb_core.c ****   u32 ControlState = pInformation->ControlState;
 1554              		.loc 1 929 0
 1555              		.cfi_startproc
 1556              		@ args = 0, pretend = 0, frame = 0
 1557              		@ frame_needed = 0, uses_anonymous_args = 0
 1558 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1559              		.cfi_def_cfa_offset 24
 1560              		.cfi_offset 3, -24
 1561              		.cfi_offset 4, -20
 1562              		.cfi_offset 5, -16
 1563              		.cfi_offset 6, -12
 1564              		.cfi_offset 7, -8
 1565              		.cfi_offset 14, -4
 930:usb_lib/usb_core.c **** 
 1566              		.loc 1 930 0
 1567 0002 294E     		ldr	r6, .L193
 1568 0004 3468     		ldr	r4, [r6]
 1569 0006 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 1570              	.LVL134:
 932:usb_lib/usb_core.c ****   {
 1571              		.loc 1 932 0
 1572 0008 032B     		cmp	r3, #3
 1573 000a 01D0     		beq	.L171
 932:usb_lib/usb_core.c ****   {
 1574              		.loc 1 932 0 is_stmt 0 discriminator 1
 1575 000c 052B     		cmp	r3, #5
 1576 000e 43D1     		bne	.L172
 1577              	.L171:
 1578              	.LVL135:
 1579              	.LBB38:
 1580              	.LBB39:
 430:usb_lib/usb_core.c ****   {
 1581              		.loc 1 430 0 is_stmt 1
 1582 0010 A369     		ldr	r3, [r4, #24]
 1583              	.LVL136:
 1584 0012 B3B1     		cbz	r3, .L173
 428:usb_lib/usb_core.c **** 
 1585              		.loc 1 428 0
 1586 0014 258A     		ldrh	r5, [r4, #16]
 430:usb_lib/usb_core.c ****   {
 1587              		.loc 1 430 0
 1588 0016 A5B1     		cbz	r5, .L173
 1589              	.LBB40:
 435:usb_lib/usb_core.c ****     if (Length > save_rLength)
 1590              		.loc 1 435 0
 1591 0018 A28A     		ldrh	r2, [r4, #20]
 1592              	.LVL137:
 441:usb_lib/usb_core.c ****     pEPinfo->Usb_rLength -= Length;
 1593              		.loc 1 441 0
 1594 001a 9542     		cmp	r5, r2
 1595 001c 28BF     		it	cs
 1596 001e 1546     		movcs	r5, r2
 1597              	.LVL138:
 1598 0020 2846     		mov	r0, r5
 1599 0022 9847     		blx	r3
 1600              	.LVL139:
 442:usb_lib/usb_core.c ****     pEPinfo->Usb_rOffset += Length;
 1601              		.loc 1 442 0
 1602 0024 238A     		ldrh	r3, [r4, #16]
 441:usb_lib/usb_core.c ****     pEPinfo->Usb_rLength -= Length;
 1603              		.loc 1 441 0
 1604 0026 0746     		mov	r7, r0
 1605              	.LVL140:
 442:usb_lib/usb_core.c ****     pEPinfo->Usb_rOffset += Length;
 1606              		.loc 1 442 0
 1607 0028 5B1B     		subs	r3, r3, r5
 1608 002a 2382     		strh	r3, [r4, #16]	@ movhi
 443:usb_lib/usb_core.c **** 
 1609              		.loc 1 443 0
 1610 002c 638A     		ldrh	r3, [r4, #18]
 445:usb_lib/usb_core.c ****   }
 1611              		.loc 1 445 0
 1612 002e 0020     		movs	r0, #0
 1613              	.LVL141:
 443:usb_lib/usb_core.c **** 
 1614              		.loc 1 443 0
 1615 0030 2B44     		add	r3, r3, r5
 1616 0032 6382     		strh	r3, [r4, #18]	@ movhi
 445:usb_lib/usb_core.c ****   }
 1617              		.loc 1 445 0
 1618 0034 FFF7FEFF 		bl	GetEPRxAddr
 1619              	.LVL142:
 1620 0038 2A46     		mov	r2, r5
 1621 003a 0146     		mov	r1, r0
 1622 003c 3846     		mov	r0, r7
 1623 003e FFF7FEFF 		bl	PMAToUserBufferCopy
 1624              	.LVL143:
 1625              	.L173:
 1626              	.LBE40:
 448:usb_lib/usb_core.c ****   {
 1627              		.loc 1 448 0
 1628 0042 238A     		ldrh	r3, [r4, #16]
 1629 0044 53B1     		cbz	r3, .L174
 451:usb_lib/usb_core.c ****     vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
 1630              		.loc 1 451 0
 1631 0046 0021     		movs	r1, #0
 450:usb_lib/usb_core.c ****     SetEPTxCount(ENDP0, 0);
 1632              		.loc 1 450 0
 1633 0048 4FF44052 		mov	r2, #12288
 1634 004c 174B     		ldr	r3, .L193+4
 451:usb_lib/usb_core.c ****     vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
 1635              		.loc 1 451 0
 1636 004e 0846     		mov	r0, r1
 450:usb_lib/usb_core.c ****     SetEPTxCount(ENDP0, 0);
 1637              		.loc 1 450 0
 1638 0050 1A80     		strh	r2, [r3]	@ movhi
 451:usb_lib/usb_core.c ****     vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
 1639              		.loc 1 451 0
 1640 0052 FFF7FEFF 		bl	SetEPTxCount
 1641              	.LVL144:
 452:usb_lib/usb_core.c ****   }
 1642              		.loc 1 452 0
 1643 0056 3022     		movs	r2, #48
 1644 0058 154B     		ldr	r3, .L193+8
 1645 005a 1A80     		strh	r2, [r3]	@ movhi
 1646              	.L174:
 455:usb_lib/usb_core.c ****   {
 1647              		.loc 1 455 0
 1648 005c 218A     		ldrh	r1, [r4, #16]
 1649 005e A38A     		ldrh	r3, [r4, #20]
 1650 0060 3268     		ldr	r2, [r6]
 1651 0062 8B42     		cmp	r3, r1
 1652 0064 08D8     		bhi	.L175
 457:usb_lib/usb_core.c ****   }
 1653              		.loc 1 457 0
 1654 0066 0323     		movs	r3, #3
 1655              	.L192:
 463:usb_lib/usb_core.c ****     }
 1656              		.loc 1 463 0
 1657 0068 1372     		strb	r3, [r2, #8]
 1658              	.L176:
 1659              	.LBE39:
 1660              	.LBE38:
 935:usb_lib/usb_core.c ****   }
 1661              		.loc 1 935 0
 1662 006a 137A     		ldrb	r3, [r2, #8]	@ zero_extendqisi2
 1663              	.LVL145:
 1664              	.L178:
 956:usb_lib/usb_core.c **** 
 1665              		.loc 1 956 0
 1666 006c 3268     		ldr	r2, [r6]
 1667 006e 1372     		strb	r3, [r2, #8]
 959:usb_lib/usb_core.c **** 
 1668              		.loc 1 959 0
 1669 0070 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 1670              		.cfi_remember_state
 1671              		.cfi_restore 14
 1672              		.cfi_restore 7
 1673              		.cfi_restore 6
 1674              		.cfi_restore 5
 1675              		.cfi_restore 4
 1676              		.cfi_restore 3
 1677              		.cfi_def_cfa_offset 0
 1678              	.LVL146:
 958:usb_lib/usb_core.c **** }
 1679              		.loc 1 958 0
 1680 0074 FFF7FEBF 		b	Post0_Process
 1681              	.LVL147:
 1682              	.L175:
 1683              		.cfi_restore_state
 1684              	.LBB42:
 1685              	.LBB41:
 461:usb_lib/usb_core.c ****     {
 1686              		.loc 1 461 0
 1687 0078 09B1     		cbz	r1, .L177
 463:usb_lib/usb_core.c ****     }
 1688              		.loc 1 463 0
 1689 007a 0523     		movs	r3, #5
 1690 007c F4E7     		b	.L192
 1691              	.L177:
 467:usb_lib/usb_core.c ****       USB_StatusIn();
 1692              		.loc 1 467 0
 1693 007e 0623     		movs	r3, #6
 1694 0080 1372     		strb	r3, [r2, #8]
 468:usb_lib/usb_core.c ****     }
 1695              		.loc 1 468 0
 1696 0082 0C4B     		ldr	r3, .L193+12
 1697 0084 1868     		ldr	r0, [r3]
 1698 0086 0C4B     		ldr	r3, .L193+16
 1699 0088 80B2     		uxth	r0, r0
 1700 008a 0344     		add	r3, r3, r0
 1701 008c 5B00     		lsls	r3, r3, #1
 1702 008e 1960     		str	r1, [r3]
 1703 0090 3021     		movs	r1, #48
 1704 0092 074B     		ldr	r3, .L193+8
 1705 0094 1980     		strh	r1, [r3]	@ movhi
 1706 0096 E8E7     		b	.L176
 1707              	.LVL148:
 1708              	.L172:
 1709              	.LBE41:
 1710              	.LBE42:
 938:usb_lib/usb_core.c ****   {
 1711              		.loc 1 938 0
 1712 0098 072B     		cmp	r3, #7
 1713 009a 03D1     		bne	.L179
 940:usb_lib/usb_core.c ****     ControlState = STALLED;
 1714              		.loc 1 940 0
 1715 009c 074B     		ldr	r3, .L193+20
 1716              	.LVL149:
 1717 009e 1B68     		ldr	r3, [r3]
 1718 00a0 DB68     		ldr	r3, [r3, #12]
 1719 00a2 9847     		blx	r3
 1720              	.LVL150:
 1721              	.L179:
 947:usb_lib/usb_core.c ****   }
 1722              		.loc 1 947 0
 1723 00a4 0823     		movs	r3, #8
 1724 00a6 E1E7     		b	.L178
 1725              	.L194:
 1726              		.align	2
 1727              	.L193:
 1728 00a8 00000000 		.word	pInformation
 1729 00ac 00000000 		.word	SaveRState
 1730 00b0 00000000 		.word	SaveTState
 1731 00b4 505C0040 		.word	1073765456
 1732 00b8 02300020 		.word	536883202
 1733 00bc 00000000 		.word	pProperty
 1734              		.cfi_endproc
 1735              	.LFE15:
 1737              		.section	.text.SetDeviceAddress,"ax",%progbits
 1738              		.align	1
 1739              		.global	SetDeviceAddress
 1740              		.syntax unified
 1741              		.thumb
 1742              		.thumb_func
 1743              		.fpu softvfp
 1745              	SetDeviceAddress:
 1746              	.LFB17:
 981:usb_lib/usb_core.c **** 
 982:usb_lib/usb_core.c **** /*******************************************************************************
 983:usb_lib/usb_core.c **** * Function Name  : SetDeviceAddress.
 984:usb_lib/usb_core.c **** * Description    : Set the device and all the used Endpoints addresses.
 985:usb_lib/usb_core.c **** * Input          : - Val: device adress.
 986:usb_lib/usb_core.c **** * Output         : None.
 987:usb_lib/usb_core.c **** * Return         : None.
 988:usb_lib/usb_core.c **** *******************************************************************************/
 989:usb_lib/usb_core.c **** void SetDeviceAddress(u8 Val)
 990:usb_lib/usb_core.c **** {
 1747              		.loc 1 990 0
 1748              		.cfi_startproc
 1749              		@ args = 0, pretend = 0, frame = 0
 1750              		@ frame_needed = 0, uses_anonymous_args = 0
 1751              	.LVL151:
 1752 0000 30B5     		push	{r4, r5, lr}
 1753              		.cfi_def_cfa_offset 12
 1754              		.cfi_offset 4, -12
 1755              		.cfi_offset 5, -8
 1756              		.cfi_offset 14, -4
 991:usb_lib/usb_core.c ****   u32 i;
 992:usb_lib/usb_core.c ****   u32 nEP = Device_Table.Total_Endpoint;
 993:usb_lib/usb_core.c **** 
 994:usb_lib/usb_core.c ****   /* set address in every used endpoint */
 995:usb_lib/usb_core.c ****   for (i = 0; i < nEP; i++)
 1757              		.loc 1 995 0
 1758 0002 0022     		movs	r2, #0
 996:usb_lib/usb_core.c ****   {
 997:usb_lib/usb_core.c ****     _SetEPAddress((u8)i, (u8)i);
 1759              		.loc 1 997 0
 1760 0004 48F68F75 		movw	r5, #36751
 992:usb_lib/usb_core.c **** 
 1761              		.loc 1 992 0
 1762 0008 094B     		ldr	r3, .L198
 1763 000a 1C78     		ldrb	r4, [r3]	@ zero_extendqisi2
 1764              	.LVL152:
 1765              	.L196:
 995:usb_lib/usb_core.c ****   {
 1766              		.loc 1 995 0 discriminator 1
 1767 000c A242     		cmp	r2, r4
 1768 000e 04D3     		bcc	.L197
 998:usb_lib/usb_core.c ****   } /* for */
 999:usb_lib/usb_core.c ****   _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
 1769              		.loc 1 999 0
 1770 0010 084B     		ldr	r3, .L198+4
 1771 0012 40F08000 		orr	r0, r0, #128
 1772              	.LVL153:
 1773 0016 1860     		str	r0, [r3]
1000:usb_lib/usb_core.c **** }
 1774              		.loc 1 1000 0
 1775 0018 30BD     		pop	{r4, r5, pc}
 1776              	.LVL154:
 1777              	.L197:
 1778 001a 02F18053 		add	r3, r2, #268435456
 1779 001e 03F5B853 		add	r3, r3, #5888
 1780 0022 9B00     		lsls	r3, r3, #2
 997:usb_lib/usb_core.c ****   } /* for */
 1781              		.loc 1 997 0 discriminator 3
 1782 0024 1968     		ldr	r1, [r3]
 1783 0026 2940     		ands	r1, r1, r5
 1784 0028 1143     		orrs	r1, r1, r2
 1785 002a 1960     		str	r1, [r3]
 995:usb_lib/usb_core.c ****   {
 1786              		.loc 1 995 0 discriminator 3
 1787 002c 0132     		adds	r2, r2, #1
 1788              	.LVL155:
 1789 002e EDE7     		b	.L196
 1790              	.L199:
 1791              		.align	2
 1792              	.L198:
 1793 0030 00000000 		.word	Device_Table
 1794 0034 4C5C0040 		.word	1073765452
 1795              		.cfi_endproc
 1796              	.LFE17:
 1798              		.section	.text.In0_Process,"ax",%progbits
 1799              		.align	1
 1800              		.global	In0_Process
 1801              		.syntax unified
 1802              		.thumb
 1803              		.thumb_func
 1804              		.fpu softvfp
 1806              	In0_Process:
 1807              	.LFB14:
 889:usb_lib/usb_core.c ****   u32 ControlState = pInformation->ControlState;
 1808              		.loc 1 889 0
 1809              		.cfi_startproc
 1810              		@ args = 0, pretend = 0, frame = 0
 1811              		@ frame_needed = 0, uses_anonymous_args = 0
 1812 0000 10B5     		push	{r4, lr}
 1813              		.cfi_def_cfa_offset 8
 1814              		.cfi_offset 4, -8
 1815              		.cfi_offset 14, -4
 890:usb_lib/usb_core.c **** 
 1816              		.loc 1 890 0
 1817 0002 134C     		ldr	r4, .L209
 1818 0004 2368     		ldr	r3, [r4]
 1819 0006 1A7A     		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 1820              	.LVL156:
 892:usb_lib/usb_core.c ****   {
 1821              		.loc 1 892 0
 1822 0008 022A     		cmp	r2, #2
 1823 000a 01D0     		beq	.L201
 892:usb_lib/usb_core.c ****   {
 1824              		.loc 1 892 0 is_stmt 0 discriminator 1
 1825 000c 042A     		cmp	r2, #4
 1826 000e 09D1     		bne	.L202
 1827              	.L201:
 894:usb_lib/usb_core.c ****     /* ControlState may be changed outside the function */
 1828              		.loc 1 894 0 is_stmt 1
 1829 0010 FFF7FEFF 		bl	DataStageIn
 1830              	.LVL157:
 896:usb_lib/usb_core.c ****   }
 1831              		.loc 1 896 0
 1832 0014 2368     		ldr	r3, [r4]
 1833 0016 1B7A     		ldrb	r3, [r3, #8]	@ zero_extendqisi2
 1834              	.LVL158:
 1835              	.L203:
 916:usb_lib/usb_core.c **** 
 1836              		.loc 1 916 0
 1837 0018 2268     		ldr	r2, [r4]
 1838 001a 1372     		strb	r3, [r2, #8]
 919:usb_lib/usb_core.c **** 
 1839              		.loc 1 919 0
 1840 001c BDE81040 		pop	{r4, lr}
 1841              		.cfi_remember_state
 1842              		.cfi_restore 14
 1843              		.cfi_restore 4
 1844              		.cfi_def_cfa_offset 0
 918:usb_lib/usb_core.c **** }
 1845              		.loc 1 918 0
 1846 0020 FFF7FEBF 		b	Post0_Process
 1847              	.LVL159:
 1848              	.L202:
 1849              		.cfi_restore_state
 899:usb_lib/usb_core.c ****   {
 1850              		.loc 1 899 0
 1851 0024 062A     		cmp	r2, #6
 1852 0026 10D1     		bne	.L205
 901:usb_lib/usb_core.c ****         (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
 1853              		.loc 1 901 0
 1854 0028 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 1855              	.LVL160:
 1856 002a 052A     		cmp	r2, #5
 1857 002c 09D1     		bne	.L204
 901:usb_lib/usb_core.c ****         (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
 1858              		.loc 1 901 0 is_stmt 0 discriminator 1
 1859 002e 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1860 0030 5206     		lsls	r2, r2, #25
 1861 0032 06D1     		bne	.L204
 904:usb_lib/usb_core.c ****       pUser_Standard_Requests->User_SetDeviceAddress();
 1862              		.loc 1 904 0 is_stmt 1
 1863 0034 9878     		ldrb	r0, [r3, #2]	@ zero_extendqisi2
 1864 0036 FFF7FEFF 		bl	SetDeviceAddress
 1865              	.LVL161:
 905:usb_lib/usb_core.c ****     }
 1866              		.loc 1 905 0
 1867 003a 064B     		ldr	r3, .L209+4
 1868 003c 1B68     		ldr	r3, [r3]
 1869 003e 1B6A     		ldr	r3, [r3, #32]
 1870 0040 9847     		blx	r3
 1871              	.LVL162:
 1872              	.L204:
 907:usb_lib/usb_core.c ****     ControlState = STALLED;
 1873              		.loc 1 907 0
 1874 0042 054B     		ldr	r3, .L209+8
 1875 0044 1B68     		ldr	r3, [r3]
 1876 0046 9B68     		ldr	r3, [r3, #8]
 1877 0048 9847     		blx	r3
 1878              	.LVL163:
 1879              	.L205:
 913:usb_lib/usb_core.c ****   }
 1880              		.loc 1 913 0
 1881 004a 0823     		movs	r3, #8
 1882 004c E4E7     		b	.L203
 1883              	.L210:
 1884 004e 00BF     		.align	2
 1885              	.L209:
 1886 0050 00000000 		.word	pInformation
 1887 0054 00000000 		.word	pUser_Standard_Requests
 1888 0058 00000000 		.word	pProperty
 1889              		.cfi_endproc
 1890              	.LFE14:
 1892              		.section	.text.NOP_Process,"ax",%progbits
 1893              		.align	1
 1894              		.global	NOP_Process
 1895              		.syntax unified
 1896              		.thumb
 1897              		.thumb_func
 1898              		.fpu softvfp
 1900              	NOP_Process:
 1901              	.LFB18:
1001:usb_lib/usb_core.c **** 
1002:usb_lib/usb_core.c **** /*******************************************************************************
1003:usb_lib/usb_core.c **** * Function Name  : NOP_Process
1004:usb_lib/usb_core.c **** * Description    : No operation function.
1005:usb_lib/usb_core.c **** * Input          : None.
1006:usb_lib/usb_core.c **** * Output         : None.
1007:usb_lib/usb_core.c **** * Return         : None.
1008:usb_lib/usb_core.c **** *******************************************************************************/
1009:usb_lib/usb_core.c **** void NOP_Process(void)
1010:usb_lib/usb_core.c **** {
 1902              		.loc 1 1010 0
 1903              		.cfi_startproc
 1904              		@ args = 0, pretend = 0, frame = 0
 1905              		@ frame_needed = 0, uses_anonymous_args = 0
 1906              		@ link register save eliminated.
1011:usb_lib/usb_core.c **** }
 1907              		.loc 1 1011 0
 1908 0000 7047     		bx	lr
 1909              		.cfi_endproc
 1910              	.LFE18:
 1912              		.global	Data_Mul_MaxPacketSize
 1913              		.comm	StatusInfo,2,2
 1914              		.section	.bss.Data_Mul_MaxPacketSize,"aw",%nobits
 1915              		.set	.LANCHOR0,. + 0
 1918              	Data_Mul_MaxPacketSize:
 1919 0000 00       		.space	1
 1920              		.text
 1921              	.Letext0:
 1922              		.file 2 "usb_lib/usb_type.h"
 1923              		.file 3 "usb_lib/usb_def.h"
 1924              		.file 4 "usb_lib/usb_core.h"
 1925              		.file 5 "usb_lib/usb_regs.h"
 1926              		.file 6 "usb_lib/usb_init.h"
 1927              		.file 7 "usb_lib/usb_mem.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usb_core.c
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:16     .text.Standard_GetConfiguration:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:23     .text.Standard_GetConfiguration:0000000000000000 Standard_GetConfiguration
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:61     .text.Standard_GetConfiguration:000000000000001c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:67     .text.Standard_GetInterface:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:74     .text.Standard_GetInterface:0000000000000000 Standard_GetInterface
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:111    .text.Standard_GetInterface:000000000000001c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:117    .text.Standard_GetStatus:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:124    .text.Standard_GetStatus:0000000000000000 Standard_GetStatus
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:237    .text.Standard_GetStatus:000000000000007c $d
                            *COM*:0000000000000002 StatusInfo
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:244    .text.DataStageIn:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:250    .text.DataStageIn:0000000000000000 DataStageIn
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:376    .text.DataStageIn:0000000000000094 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:386    .text.Standard_SetConfiguration:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:393    .text.Standard_SetConfiguration:0000000000000000 Standard_SetConfiguration
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:439    .text.Standard_SetConfiguration:000000000000002c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:446    .text.Standard_SetInterface:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:453    .text.Standard_SetInterface:0000000000000000 Standard_SetInterface
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:520    .text.Standard_SetInterface:0000000000000040 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:527    .text.Standard_ClearFeature:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:534    .text.Standard_ClearFeature:0000000000000000 Standard_ClearFeature
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:686    .text.Standard_ClearFeature:00000000000000b0 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:695    .text.Standard_SetEndPointFeature:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:702    .text.Standard_SetEndPointFeature:0000000000000000 Standard_SetEndPointFeature
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:819    .text.Standard_SetEndPointFeature:0000000000000070 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:826    .text.Standard_SetDeviceFeature:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:833    .text.Standard_SetDeviceFeature:0000000000000000 Standard_SetDeviceFeature
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:861    .text.Standard_SetDeviceFeature:000000000000001c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:867    .text.Standard_GetDescriptorData:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:874    .text.Standard_GetDescriptorData:0000000000000000 Standard_GetDescriptorData
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:912    .text.Standard_GetDescriptorData:0000000000000018 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:917    .text.Post0_Process:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:924    .text.Post0_Process:0000000000000000 Post0_Process
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:963    .text.Post0_Process:0000000000000030 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:971    .text.Setup0_Process:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:978    .text.Setup0_Process:0000000000000000 Setup0_Process
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1489   .text.Setup0_Process:000000000000025c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1501   .text.Setup0_Process:0000000000000284 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1537   .text.Setup0_Process:00000000000002b4 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1545   .text.Out0_Process:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1552   .text.Out0_Process:0000000000000000 Out0_Process
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1728   .text.Out0_Process:00000000000000a8 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1738   .text.SetDeviceAddress:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1745   .text.SetDeviceAddress:0000000000000000 SetDeviceAddress
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1793   .text.SetDeviceAddress:0000000000000030 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1799   .text.In0_Process:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1806   .text.In0_Process:0000000000000000 In0_Process
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1886   .text.In0_Process:0000000000000050 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1893   .text.NOP_Process:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1900   .text.NOP_Process:0000000000000000 NOP_Process
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1918   .bss.Data_Mul_MaxPacketSize:0000000000000000 Data_Mul_MaxPacketSize
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc6Uarmg.s:1919   .bss.Data_Mul_MaxPacketSize:0000000000000000 $d

UNDEFINED SYMBOLS
pInformation
pUser_Standard_Requests
GetEPTxAddr
UserToPMABufferCopy
SetEPTxCount
SaveRState
SaveTState
Device_Table
pProperty
ClearDTOG_TX
SetEPTxStatus
SetEPRxCount
ClearDTOG_RX
Device_Property
GetEPRxAddr
PMAToUserBufferCopy
