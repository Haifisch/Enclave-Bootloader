   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"dfu.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.dfuInit,"ax",%progbits
  16              		.align	1
  17              		.global	dfuInit
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	dfuInit:
  24              	.LFB3:
  25              		.file 1 "dfu.c"
   1:dfu.c         **** /* *****************************************************************************
   2:dfu.c         ****  * The MIT License
   3:dfu.c         ****  *
   4:dfu.c         ****  * Copyright (c) 2010 LeafLabs LLC.
   5:dfu.c         ****  *
   6:dfu.c         ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:dfu.c         ****  * of this software and associated documentation files (the "Software"), to deal
   8:dfu.c         ****  * in the Software without restriction, including without limitation the rights
   9:dfu.c         ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:dfu.c         ****  * copies of the Software, and to permit persons to whom the Software is
  11:dfu.c         ****  * furnished to do so, subject to the following conditions:
  12:dfu.c         ****  *
  13:dfu.c         ****  * The above copyright notice and this permission notice shall be included in
  14:dfu.c         ****  * all copies or substantial portions of the Software.
  15:dfu.c         ****  *
  16:dfu.c         ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:dfu.c         ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:dfu.c         ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:dfu.c         ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:dfu.c         ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:dfu.c         ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:dfu.c         ****  * THE SOFTWARE.
  23:dfu.c         ****  * ****************************************************************************/
  24:dfu.c         **** 
  25:dfu.c         **** /**
  26:dfu.c         ****  *  @file dfu.c
  27:dfu.c         ****  *
  28:dfu.c         ****  *  @brief The principle dfu state machine as well as the data
  29:dfu.c         ****  *  transfer callbacks accessed by the usb library
  30:dfu.c         ****  *
  31:dfu.c         ****  *
  32:dfu.c         ****  */
  33:dfu.c         **** #include "hardware.h"
  34:dfu.c         **** #include "dfu.h"
  35:dfu.c         **** #include "usb.h"
  36:dfu.c         **** #include "sha256.h"
  37:dfu.c         **** #include "image.h"
  38:dfu.c         **** 
  39:dfu.c         **** /* DFU globals */
  40:dfu.c         **** static volatile u32 userAppAddr = USER_CODE_RAM; /* default RAM user code location */
  41:dfu.c         **** static volatile u32 userAppEnd = RAM_END;
  42:dfu.c         **** static volatile DFUStatus dfuAppStatus;       /* includes state */
  43:dfu.c         **** volatile dfuUploadTypes_t userUploadType = DFU_UPLOAD_NONE;
  44:dfu.c         **** volatile bool dfuBusy = FALSE;
  45:dfu.c         **** 
  46:dfu.c         **** unsigned char sha256sum[32];
  47:dfu.c         **** uint8_t input[0x5C];    
  48:dfu.c         **** sha256_context ctx;
  49:dfu.c         **** 
  50:dfu.c         **** //static volatile u8 recvBuffer[wTransferSize] __attribute__((aligned(4)));
  51:dfu.c         **** static volatile u8 recvBuffer[LARGEST_FLASH_PAGE_SIZE] __attribute__((aligned(4)));
  52:dfu.c         **** 
  53:dfu.c         **** static volatile u32 userFirmwareLen = 0;
  54:dfu.c         **** static volatile u16 thisBlockLen = 0;
  55:dfu.c         **** static volatile u16 uploadBlockLen = 0;
  56:dfu.c         **** 
  57:dfu.c         **** 
  58:dfu.c         **** volatile PLOT code_copy_lock;
  59:dfu.c         **** 
  60:dfu.c         **** /* todo: force dfu globals to be singleton to avoid re-inits? */
  61:dfu.c         **** void dfuInit(void) {
  26              		.loc 1 61 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30 0000 08B5     		push	{r3, lr}
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 3, -8
  33              		.cfi_offset 14, -4
  62:dfu.c         ****     dfuAppStatus.bStatus = OK;
  63:dfu.c         ****     dfuAppStatus.bwPollTimeout0 = 0x00;
  64:dfu.c         ****     dfuAppStatus.bwPollTimeout1 = 0x00;
  65:dfu.c         ****     dfuAppStatus.bwPollTimeout2 = 0x00;
  66:dfu.c         ****     dfuAppStatus.bState = dfuIDLE;
  34              		.loc 1 66 0
  35 0002 0221     		movs	r1, #2
  62:dfu.c         ****     dfuAppStatus.bStatus = OK;
  36              		.loc 1 62 0
  37 0004 0023     		movs	r3, #0
  38 0006 144A     		ldr	r2, .L2
  67:dfu.c         ****     dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
  68:dfu.c         ****     userFirmwareLen = 0;
  69:dfu.c         ****     thisBlockLen = 0;;
  70:dfu.c         ****     userAppAddr = USER_CODE_RAM; /* default RAM user code location */
  71:dfu.c         ****     userAppEnd = RAM_END;
  72:dfu.c         ****     userUploadType=DFU_UPLOAD_NONE;
  73:dfu.c         ****     code_copy_lock = WAIT;
  74:dfu.c         ****     dfuBusy = FALSE;
  75:dfu.c         ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
  39              		.loc 1 75 0
  40 0008 1448     		ldr	r0, .L2+4
  62:dfu.c         ****     dfuAppStatus.bStatus = OK;
  41              		.loc 1 62 0
  42 000a 1370     		strb	r3, [r2]
  63:dfu.c         ****     dfuAppStatus.bwPollTimeout1 = 0x00;
  43              		.loc 1 63 0
  44 000c 5370     		strb	r3, [r2, #1]
  64:dfu.c         ****     dfuAppStatus.bwPollTimeout2 = 0x00;
  45              		.loc 1 64 0
  46 000e 9370     		strb	r3, [r2, #2]
  65:dfu.c         ****     dfuAppStatus.bState = dfuIDLE;
  47              		.loc 1 65 0
  48 0010 D370     		strb	r3, [r2, #3]
  66:dfu.c         ****     dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
  49              		.loc 1 66 0
  50 0012 1171     		strb	r1, [r2, #4]
  67:dfu.c         ****     userFirmwareLen = 0;
  51              		.loc 1 67 0
  52 0014 5371     		strb	r3, [r2, #5]
  68:dfu.c         ****     thisBlockLen = 0;;
  53              		.loc 1 68 0
  54 0016 124A     		ldr	r2, .L2+8
  70:dfu.c         ****     userAppEnd = RAM_END;
  55              		.loc 1 70 0
  56 0018 1249     		ldr	r1, .L2+12
  68:dfu.c         ****     thisBlockLen = 0;;
  57              		.loc 1 68 0
  58 001a 1360     		str	r3, [r2]
  69:dfu.c         ****     userAppAddr = USER_CODE_RAM; /* default RAM user code location */
  59              		.loc 1 69 0
  60 001c 124A     		ldr	r2, .L2+16
  61 001e 1380     		strh	r3, [r2]	@ movhi
  70:dfu.c         ****     userAppEnd = RAM_END;
  62              		.loc 1 70 0
  63 0020 124A     		ldr	r2, .L2+20
  64 0022 1160     		str	r1, [r2]
  71:dfu.c         ****     userUploadType=DFU_UPLOAD_NONE;
  65              		.loc 1 71 0
  66 0024 124A     		ldr	r2, .L2+24
  67 0026 01F58841 		add	r1, r1, #17408
  68 002a 1160     		str	r1, [r2]
  73:dfu.c         ****     dfuBusy = FALSE;
  69              		.loc 1 73 0
  70 002c 0321     		movs	r1, #3
  72:dfu.c         ****     code_copy_lock = WAIT;
  71              		.loc 1 72 0
  72 002e 114A     		ldr	r2, .L2+28
  73 0030 1370     		strb	r3, [r2]
  73:dfu.c         ****     dfuBusy = FALSE;
  74              		.loc 1 73 0
  75 0032 114A     		ldr	r2, .L2+32
  76 0034 1170     		strb	r1, [r2]
  74:dfu.c         ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
  77              		.loc 1 74 0
  78 0036 114A     		ldr	r2, .L2+36
  79              		.loc 1 75 0
  80 0038 FF21     		movs	r1, #255
  74:dfu.c         ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
  81              		.loc 1 74 0
  82 003a 1370     		strb	r3, [r2]
  83              		.loc 1 75 0
  84 003c 2022     		movs	r2, #32
  85 003e FFF7FEFF 		bl	memset
  86              	.LVL0:
  76:dfu.c         ****     memset(input, 0xFF, sizeof(input));
  87              		.loc 1 76 0
  88 0042 5C22     		movs	r2, #92
  89 0044 FF21     		movs	r1, #255
  90 0046 0E48     		ldr	r0, .L2+40
  91 0048 FFF7FEFF 		bl	memset
  92              	.LVL1:
  77:dfu.c         **** 
  78:dfu.c         ****     sha256_starts(&ctx);
  79:dfu.c         **** }
  93              		.loc 1 79 0
  94 004c BDE80840 		pop	{r3, lr}
  95              		.cfi_restore 14
  96              		.cfi_restore 3
  97              		.cfi_def_cfa_offset 0
  78:dfu.c         **** }
  98              		.loc 1 78 0
  99 0050 0C48     		ldr	r0, .L2+44
 100 0052 FFF7FEBF 		b	sha256_starts
 101              	.LVL2:
 102              	.L3:
 103 0056 00BF     		.align	2
 104              	.L2:
 105 0058 00000000 		.word	.LANCHOR0
 106 005c 00000000 		.word	sha256sum
 107 0060 00000000 		.word	.LANCHOR1
 108 0064 000C0020 		.word	536873984
 109 0068 00000000 		.word	.LANCHOR2
 110 006c 00000000 		.word	.LANCHOR3
 111 0070 00000000 		.word	.LANCHOR4
 112 0074 00000000 		.word	.LANCHOR5
 113 0078 00000000 		.word	code_copy_lock
 114 007c 00000000 		.word	.LANCHOR6
 115 0080 00000000 		.word	input
 116 0084 00000000 		.word	ctx
 117              		.cfi_endproc
 118              	.LFE3:
 120              		.section	.text.dfuUpdateByReset,"ax",%progbits
 121              		.align	1
 122              		.global	dfuUpdateByReset
 123              		.syntax unified
 124              		.thumb
 125              		.thumb_func
 126              		.fpu softvfp
 128              	dfuUpdateByReset:
 129              	.LFB5:
  80:dfu.c         **** 
  81:dfu.c         **** bool dfuUpdateByRequest(void) {
  82:dfu.c         ****     /* were using the global pInformation struct from usb_lib here,
  83:dfu.c         ****        see comment in maple_dfu.h around DFUEvent struct */
  84:dfu.c         ****     dfuBusy = TRUE;
  85:dfu.c         **** 
  86:dfu.c         ****     u8 startState = dfuAppStatus.bState;
  87:dfu.c         ****     dfuAppStatus.bStatus = OK;
  88:dfu.c         ****     
  89:dfu.c         ****     /* often leaner to nest if's then embed a switch/case */
  90:dfu.c         ****     /* but who the fuck cares? use a better compiler. we have space */
  91:dfu.c         ****     if (startState == dfuIDLE)  {
  92:dfu.c         ****         /*  device running inside DFU mode */
  93:dfu.c         ****         dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
  94:dfu.c         **** 
  95:dfu.c         ****         if (pInformation->USBbRequest == DFU_DNLOAD) {
  96:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
  97:dfu.c         ****                 userFirmwareLen = 0;
  98:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
  99:dfu.c         **** 				switch(pInformation->Current_AlternateSetting) {
 100:dfu.c         **** 					/*
 101:dfu.c         **** 					Roger Clark. removed upload to RAM option
 102:dfu.c         **** 					case 0:
 103:dfu.c         **** 					    userAppAddr = USER_CODE_RAM;
 104:dfu.c         **** 						userUploadType = DFU_UPLOAD_RAM;
 105:dfu.c         **** 						break;
 106:dfu.c         **** 						*/
 107:dfu.c         **** 
 108:dfu.c         **** 					case 1:
 109:dfu.c         **** 					    userAppAddr = USER_CODE_FLASH0X8008000;
 110:dfu.c         **** 						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
 111:dfu.c         **** 						
 112:dfu.c         **** 						/* make sure the flash is setup properly, unlock it */
 113:dfu.c         **** 						setupFLASH();
 114:dfu.c         **** 						flashUnlock();
 115:dfu.c         **** 						
 116:dfu.c         ****                         /* Clear lower memory so that we can check on cold boot, whether
 117:dfu.c         ****                            the last upload was to 0x8002000 or 0x8005000 */
 118:dfu.c         **** 						//flashErasePage((u32)USER_CODE_FLASH0X8002000);
 119:dfu.c         **** 
 120:dfu.c         **** 						break;
 121:dfu.c         **** 
 122:dfu.c         **** 					case 2:
 123:dfu.c         **** 						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
 124:dfu.c         **** 						userAppAddr = USER_CODE_FLASH0X8002000;
 125:dfu.c         **** 						
 126:dfu.c         ****                         /* make sure the flash is setup properly, unlock it */
 127:dfu.c         ****                         setupFLASH();
 128:dfu.c         **** 						flashUnlock();
 129:dfu.c         **** 
 130:dfu.c         **** 						break;
 131:dfu.c         **** 
 132:dfu.c         **** 					default:
 133:dfu.c         **** 					    // Roger Clark. Report error 
 134:dfu.c         **** 						dfuAppStatus.bState  = dfuERROR;
 135:dfu.c         **** 						dfuAppStatus.bStatus = errWRITE;
 136:dfu.c         **** 
 137:dfu.c         **** 						break;
 138:dfu.c         **** 				}
 139:dfu.c         ****             } else {
 140:dfu.c         ****                 dfuAppStatus.bState  = dfuERROR;
 141:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 142:dfu.c         ****             }
 143:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_UPLOAD) {
 144:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 145:dfu.c         ****             
 146:dfu.c         ****             /* record length of first block for calculating target
 147:dfu.c         ****                address from wValue in consecutive blocks */
 148:dfu.c         ****             uploadBlockLen = pInformation->USBwLengths.w;
 149:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 150:dfu.c         ****             
 151:dfu.c         ****             /* calculate where the data should be copied from */
 152:dfu.c         ****             userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 153:dfu.c         **** 			
 154:dfu.c         ****             switch(pInformation->Current_AlternateSetting) {
 155:dfu.c         **** 			/*
 156:dfu.c         **** 				case 0:
 157:dfu.c         **** 					userAppAddr = USER_CODE_RAM;
 158:dfu.c         **** 					userAppEnd = RAM_END;
 159:dfu.c         **** 					*/
 160:dfu.c         **** 
 161:dfu.c         **** 				case 1:
 162:dfu.c         **** 				    userAppAddr = USER_CODE_FLASH0X8008000;
 163:dfu.c         **** 					userAppEnd = getFlashEnd();
 164:dfu.c         **** 					break;
 165:dfu.c         **** 
 166:dfu.c         **** 				case 2: 
 167:dfu.c         **** 				    userAppAddr = USER_CODE_FLASH0X8002000;
 168:dfu.c         **** 					userAppEnd = getFlashEnd();
 169:dfu.c         **** 					break;
 170:dfu.c         **** 
 171:dfu.c         **** 				default:
 172:dfu.c         **** 				// Roger Clark. 
 173:dfu.c         **** 				// Changed this to report error that its unable to write to this memory
 174:dfu.c         **** 				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see abo
 175:dfu.c         **** 					dfuAppStatus.bState  = dfuERROR;
 176:dfu.c         **** 					dfuAppStatus.bStatus = errWRITE;
 177:dfu.c         **** 					break;					
 178:dfu.c         **** 			}
 179:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 180:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 181:dfu.c         ****             dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
 182:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 183:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 184:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 185:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 186:dfu.c         ****         } else {
 187:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 188:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 189:dfu.c         ****         }
 190:dfu.c         **** 
 191:dfu.c         ****     } else if (startState == dfuDNLOAD_SYNC)         {
 192:dfu.c         ****         /* device received block, waiting for DFU_GETSTATUS request */
 193:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 194:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 195:dfu.c         **** 			
 196:dfu.c         **** 			/* Roger Clark. Commented out code associated with RAM upload
 197:dfu.c         **** 			
 198:dfu.c         ****             if (userUploadType == DFU_UPLOAD_RAM) 
 199:dfu.c         **** 			{
 200:dfu.c         ****                 if (code_copy_lock == WAIT) {
 201:dfu.c         ****                     code_copy_lock = BEGINNING;
 202:dfu.c         ****                     dfuAppStatus.bwPollTimeout0 = 0x20; // 32 ms 
 203:dfu.c         ****                     dfuAppStatus.bwPollTimeout1 = 0x00;
 204:dfu.c         ****                     dfuAppStatus.bState = dfuDNBUSY;
 205:dfu.c         **** 
 206:dfu.c         ****                 } else if (code_copy_lock == BEGINNING) {
 207:dfu.c         ****                     dfuAppStatus.bState = dfuDNLOAD_SYNC;
 208:dfu.c         **** 
 209:dfu.c         ****                 } else if (code_copy_lock == MIDDLE) {
 210:dfu.c         ****                     dfuAppStatus.bState = dfuDNLOAD_SYNC;
 211:dfu.c         **** 
 212:dfu.c         ****                 } else if (code_copy_lock == END) {
 213:dfu.c         ****                     dfuAppStatus.bwPollTimeout0 = 0x00;
 214:dfu.c         ****                     code_copy_lock = WAIT;
 215:dfu.c         ****                     dfuAppStatus.bState = dfuDNLOAD_IDLE;
 216:dfu.c         ****                 }
 217:dfu.c         **** 
 218:dfu.c         ****             } 
 219:dfu.c         **** 			else 
 220:dfu.c         **** 			*/
 221:dfu.c         **** 			{
 222:dfu.c         ****                 dfuAppStatus.bState = dfuDNLOAD_IDLE;
 223:dfu.c         ****                 dfuCopyBufferToExec();
 224:dfu.c         ****             }
 225:dfu.c         **** 
 226:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 227:dfu.c         ****             dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 228:dfu.c         ****         } else {
 229:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 230:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 231:dfu.c         ****         }
 232:dfu.c         ****     } else if (startState == dfuDNBUSY)              {
 233:dfu.c         ****         /* if were actually done writing, goto sync, else stay busy */
 234:dfu.c         ****         if (code_copy_lock == END) {
 235:dfu.c         **** 
 236:dfu.c         ****             dfuAppStatus.bwPollTimeout0 = 0x00;
 237:dfu.c         ****             code_copy_lock = WAIT;
 238:dfu.c         ****             dfuAppStatus.bState = dfuDNLOAD_IDLE;
 239:dfu.c         ****         } else {
 240:dfu.c         ****             dfuAppStatus.bState = dfuDNBUSY;
 241:dfu.c         ****         }
 242:dfu.c         ****     } else if (startState == dfuDNLOAD_IDLE)         {
 243:dfu.c         ****         /* device is expecting dfu_dnload requests */
 244:dfu.c         ****         if (pInformation->USBbRequest == DFU_DNLOAD) {
 245:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 246:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 247:dfu.c         ****             } else {
 248:dfu.c         ****                 /* todo, support "disagreement" if device expects more data than this */
 249:dfu.c         ****                 dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 250:dfu.c         ****                 ImageObjectHandle imageHandle;
 251:dfu.c         ****                 int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
 252:dfu.c         ****                 debug_print("image check ret: %X\n", ret);
 253:dfu.c         ****                 switch (ret)
 254:dfu.c         ****                 {
 255:dfu.c         ****                     case kImageImageIsTrusted:
 256:dfu.c         ****                         uart_printf("Uploaded signature verified!\n");
 257:dfu.c         ****                         break;
 258:dfu.c         **** 
 259:dfu.c         ****                     case kImageImageMissingMagic:
 260:dfu.c         ****                     case kImageImageRejectSignature:
 261:dfu.c         ****                     case kImageImageHashCalcFailed:
 262:dfu.c         ****                         uart_printf("Image unverified...\n");
 263:dfu.c         ****                         break;
 264:dfu.c         **** 
 265:dfu.c         ****                     default:
 266:dfu.c         ****                         break;
 267:dfu.c         ****                 }
 268:dfu.c         ****                 flashLock();
 269:dfu.c         ****             }
 270:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 271:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 272:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 273:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 274:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 275:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 276:dfu.c         ****         } else {
 277:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 278:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 279:dfu.c         ****         }
 280:dfu.c         **** 
 281:dfu.c         ****     } else if (startState == dfuMANIFEST_SYNC) {
 282:dfu.c         ****         /* device has received last block, waiting DFU_GETSTATUS request */
 283:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 284:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 285:dfu.c         ****             dfuAppStatus.bStatus = OK;
 286:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 287:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 288:dfu.c         ****         } else {
 289:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 290:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 291:dfu.c         ****         }
 292:dfu.c         ****     } else if (startState == dfuMANIFEST) {
 293:dfu.c         ****         /* device is in manifestation phase */
 294:dfu.c         **** 
 295:dfu.c         ****         /* should never receive request while in manifest! */
 296:dfu.c         ****         dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 297:dfu.c         ****         dfuAppStatus.bStatus = OK;
 298:dfu.c         ****     } else if (startState == dfuMANIFEST_WAIT_RESET) {
 299:dfu.c         ****         /* device has programmed new firmware but needs external
 300:dfu.c         ****            usb reset or power on reset to run the new code */
 301:dfu.c         **** 
 302:dfu.c         ****         /* consider timing out and self-resetting */
 303:dfu.c         ****         dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 304:dfu.c         ****     } else if (startState == dfuUPLOAD_IDLE) {
 305:dfu.c         ****         /* device expecting further dfu_upload requests */
 306:dfu.c         ****         if (pInformation->USBbRequest == DFU_UPLOAD) {
 307:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 308:dfu.c         ****                 /* check that this is not the last possible block */
 309:dfu.c         ****                 userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
 310:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 311:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 312:dfu.c         ****                     dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 313:dfu.c         ****                 } else {
 314:dfu.c         ****                     /* if above comparison was just equal, thisBlockLen becomes zero
 315:dfu.c         ****                     next time when USBWValue has been increased by one */
 316:dfu.c         ****                     thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
 317:dfu.c         ****                     
 318:dfu.c         ****                     /* check for overflow due to USBwValue out of range */
 319:dfu.c         ****                     if (thisBlockLen >= pInformation->USBwLengths.w) {
 320:dfu.c         ****                         thisBlockLen = 0;
 321:dfu.c         ****                     }
 322:dfu.c         ****                     
 323:dfu.c         ****                     dfuAppStatus.bState  = dfuIDLE;
 324:dfu.c         ****                 }
 325:dfu.c         ****             } else {
 326:dfu.c         ****                 dfuAppStatus.bState  = dfuERROR;
 327:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 328:dfu.c         ****             }
 329:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_ABORT) {
 330:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 331:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 332:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 333:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 334:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 335:dfu.c         ****         } else {
 336:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 337:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 338:dfu.c         ****         }
 339:dfu.c         ****     } else if (startState == dfuERROR)               {
 340:dfu.c         ****         /* status is in error, awaiting DFU_CLRSTATUS request */
 341:dfu.c         ****         if (pInformation->USBbRequest == DFU_GETSTATUS) {
 342:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 343:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 344:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 345:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 346:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
 347:dfu.c         ****             /* todo handle any cleanup we need here */
 348:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 349:dfu.c         ****             dfuAppStatus.bStatus = OK;
 350:dfu.c         ****         } else {
 351:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 352:dfu.c         ****             dfuAppStatus.bStatus = errSTALLEDPKT;
 353:dfu.c         ****         }
 354:dfu.c         ****     } else {
 355:dfu.c         ****         /* some kind of error... */
 356:dfu.c         ****         dfuAppStatus.bState  = dfuERROR;
 357:dfu.c         ****         dfuAppStatus.bStatus = errSTALLEDPKT;
 358:dfu.c         ****     }
 359:dfu.c         **** 
 360:dfu.c         ****     return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
 361:dfu.c         **** }
 362:dfu.c         **** 
 363:dfu.c         **** void dfuUpdateByReset(void) {
 130              		.loc 1 363 0
 131              		.cfi_startproc
 132              		@ args = 0, pretend = 0, frame = 0
 133              		@ frame_needed = 0, uses_anonymous_args = 0
 364:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 365:dfu.c         ****     userFirmwareLen = 0;
 134              		.loc 1 365 0
 135 0000 0021     		movs	r1, #0
 363:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 136              		.loc 1 363 0
 137 0002 08B5     		push	{r3, lr}
 138              		.cfi_def_cfa_offset 8
 139              		.cfi_offset 3, -8
 140              		.cfi_offset 14, -4
 364:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 141              		.loc 1 364 0
 142 0004 0D4B     		ldr	r3, .L7
 143              		.loc 1 365 0
 144 0006 0E48     		ldr	r0, .L7+4
 364:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 145              		.loc 1 364 0
 146 0008 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 147              		.loc 1 365 0
 148 000a 0160     		str	r1, [r0]
 364:dfu.c         ****     u8 startState = dfuAppStatus.bState;
 149              		.loc 1 364 0
 150 000c D2B2     		uxtb	r2, r2
 151              	.LVL3:
 366:dfu.c         **** 
 367:dfu.c         ****     if (startState == appDETACH) {
 152              		.loc 1 367 0
 153 000e 012A     		cmp	r2, #1
 154 0010 08D1     		bne	.L5
 368:dfu.c         ****         dfuAppStatus.bState = dfuIDLE;
 155              		.loc 1 368 0
 156 0012 0222     		movs	r2, #2
 157              	.LVL4:
 158 0014 1A71     		strb	r2, [r3, #4]
 369:dfu.c         ****         dfuAppStatus.bStatus = OK;
 159              		.loc 1 369 0
 160 0016 1970     		strb	r1, [r3]
 370:dfu.c         **** 
 371:dfu.c         ****         nvicDisableInterrupts();
 161              		.loc 1 371 0
 162 0018 FFF7FEFF 		bl	nvicDisableInterrupts
 163              	.LVL5:
 372:dfu.c         ****         usbEnbISR();
 373:dfu.c         ****     } else if (startState == appIDLE || startState == dfuIDLE) {
 374:dfu.c         ****         /* do nothing...might be normal usb bus activity */
 375:dfu.c         ****     } else {
 376:dfu.c         ****         /* we reset from the dfu, reset everything and startover,
 377:dfu.c         ****            which is the correct operation if this is an erroneous
 378:dfu.c         ****            event or properly following a MANIFEST */
 379:dfu.c         ****         dfuAppStatus.bState = dfuIDLE;
 380:dfu.c         ****         dfuAppStatus.bStatus = OK;
 381:dfu.c         **** 
 382:dfu.c         ****         systemHardReset();
 383:dfu.c         ****     }
 384:dfu.c         **** }
 164              		.loc 1 384 0
 165 001c BDE80840 		pop	{r3, lr}
 166              		.cfi_remember_state
 167              		.cfi_restore 14
 168              		.cfi_restore 3
 169              		.cfi_def_cfa_offset 0
 372:dfu.c         ****         usbEnbISR();
 170              		.loc 1 372 0
 171 0020 FFF7FEBF 		b	usbEnbISR
 172              	.LVL6:
 173              	.L5:
 174              		.cfi_restore_state
 373:dfu.c         ****         /* do nothing...might be normal usb bus activity */
 175              		.loc 1 373 0
 176 0024 12F0FD0F 		tst	r2, #253
 177 0028 06D0     		beq	.L4
 379:dfu.c         ****         dfuAppStatus.bStatus = OK;
 178              		.loc 1 379 0
 179 002a 0222     		movs	r2, #2
 180              	.LVL7:
 181 002c 1A71     		strb	r2, [r3, #4]
 380:dfu.c         **** 
 182              		.loc 1 380 0
 183 002e 1970     		strb	r1, [r3]
 184              		.loc 1 384 0
 185 0030 BDE80840 		pop	{r3, lr}
 186              		.cfi_remember_state
 187              		.cfi_restore 14
 188              		.cfi_restore 3
 189              		.cfi_def_cfa_offset 0
 382:dfu.c         ****     }
 190              		.loc 1 382 0
 191 0034 FFF7FEBF 		b	systemHardReset
 192              	.LVL8:
 193              	.L4:
 194              		.cfi_restore_state
 195              		.loc 1 384 0
 196 0038 08BD     		pop	{r3, pc}
 197              	.L8:
 198 003a 00BF     		.align	2
 199              	.L7:
 200 003c 00000000 		.word	.LANCHOR0
 201 0040 00000000 		.word	.LANCHOR1
 202              		.cfi_endproc
 203              	.LFE5:
 205              		.section	.text.dfuUpdateByTimeout,"ax",%progbits
 206              		.align	1
 207              		.global	dfuUpdateByTimeout
 208              		.syntax unified
 209              		.thumb
 210              		.thumb_func
 211              		.fpu softvfp
 213              	dfuUpdateByTimeout:
 214              	.LFB6:
 385:dfu.c         **** 
 386:dfu.c         **** void dfuUpdateByTimeout(void) {
 215              		.loc 1 386 0
 216              		.cfi_startproc
 217              		@ args = 0, pretend = 0, frame = 0
 218              		@ frame_needed = 0, uses_anonymous_args = 0
 219              		@ link register save eliminated.
 387:dfu.c         **** }
 220              		.loc 1 387 0
 221 0000 7047     		bx	lr
 222              		.cfi_endproc
 223              	.LFE6:
 225              		.section	.text.dfuCopyState,"ax",%progbits
 226              		.align	1
 227              		.global	dfuCopyState
 228              		.syntax unified
 229              		.thumb
 230              		.thumb_func
 231              		.fpu softvfp
 233              	dfuCopyState:
 234              	.LFB7:
 388:dfu.c         **** 
 389:dfu.c         **** u8 *dfuCopyState(u16 length) {
 235              		.loc 1 389 0
 236              		.cfi_startproc
 237              		@ args = 0, pretend = 0, frame = 0
 238              		@ frame_needed = 0, uses_anonymous_args = 0
 239              		@ link register save eliminated.
 240              	.LVL9:
 390:dfu.c         ****     if (length == 0) {
 241              		.loc 1 390 0
 242 0000 20B9     		cbnz	r0, .L12
 391:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = 1;
 243              		.loc 1 391 0
 244 0002 0122     		movs	r2, #1
 245 0004 024B     		ldr	r3, .L13
 246 0006 1B68     		ldr	r3, [r3]
 247 0008 1A82     		strh	r2, [r3, #16]	@ movhi
 392:dfu.c         ****         return NULL;
 248              		.loc 1 392 0
 249 000a 7047     		bx	lr
 250              	.L12:
 393:dfu.c         ****     } else {
 394:dfu.c         ****         return (u8 *)(&(dfuAppStatus.bState));
 251              		.loc 1 394 0
 252 000c 0148     		ldr	r0, .L13+4
 253              	.LVL10:
 395:dfu.c         ****     }
 396:dfu.c         **** }
 254              		.loc 1 396 0
 255 000e 7047     		bx	lr
 256              	.L14:
 257              		.align	2
 258              	.L13:
 259 0010 00000000 		.word	pInformation
 260 0014 04000000 		.word	.LANCHOR0+4
 261              		.cfi_endproc
 262              	.LFE7:
 264              		.section	.text.dfuCopyStatus,"ax",%progbits
 265              		.align	1
 266              		.global	dfuCopyStatus
 267              		.syntax unified
 268              		.thumb
 269              		.thumb_func
 270              		.fpu softvfp
 272              	dfuCopyStatus:
 273              	.LFB8:
 397:dfu.c         **** 
 398:dfu.c         **** u8 *dfuCopyStatus(u16 length) {
 274              		.loc 1 398 0
 275              		.cfi_startproc
 276              		@ args = 0, pretend = 0, frame = 0
 277              		@ frame_needed = 0, uses_anonymous_args = 0
 278              		@ link register save eliminated.
 279              	.LVL11:
 399:dfu.c         ****     if (length == 0) {
 280              		.loc 1 399 0
 281 0000 20B9     		cbnz	r0, .L17
 400:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = 6;
 282              		.loc 1 400 0
 283 0002 0622     		movs	r2, #6
 284 0004 024B     		ldr	r3, .L18
 285 0006 1B68     		ldr	r3, [r3]
 286 0008 1A82     		strh	r2, [r3, #16]	@ movhi
 401:dfu.c         ****         return NULL;
 287              		.loc 1 401 0
 288 000a 7047     		bx	lr
 289              	.L17:
 402:dfu.c         ****     } else {
 403:dfu.c         ****         return (u8*)(&dfuAppStatus);
 290              		.loc 1 403 0
 291 000c 0148     		ldr	r0, .L18+4
 292              	.LVL12:
 404:dfu.c         ****     }
 405:dfu.c         **** }
 293              		.loc 1 405 0
 294 000e 7047     		bx	lr
 295              	.L19:
 296              		.align	2
 297              	.L18:
 298 0010 00000000 		.word	pInformation
 299 0014 00000000 		.word	.LANCHOR0
 300              		.cfi_endproc
 301              	.LFE8:
 303              		.section	.text.dfuCopyDNLOAD,"ax",%progbits
 304              		.align	1
 305              		.global	dfuCopyDNLOAD
 306              		.syntax unified
 307              		.thumb
 308              		.thumb_func
 309              		.fpu softvfp
 311              	dfuCopyDNLOAD:
 312              	.LFB9:
 406:dfu.c         **** 
 407:dfu.c         **** 
 408:dfu.c         **** u8 *dfuCopyDNLOAD(u16 length) {
 313              		.loc 1 408 0
 314              		.cfi_startproc
 315              		@ args = 0, pretend = 0, frame = 0
 316              		@ frame_needed = 0, uses_anonymous_args = 0
 317              		@ link register save eliminated.
 318              	.LVL13:
 319 0000 064B     		ldr	r3, .L23
 320 0002 1A68     		ldr	r2, [r3]
 321 0004 538A     		ldrh	r3, [r2, #18]
 409:dfu.c         ****     if (length == 0) {
 322              		.loc 1 409 0
 323 0006 28B9     		cbnz	r0, .L21
 410:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info
 324              		.loc 1 410 0
 325 0008 D188     		ldrh	r1, [r2, #6]
 326 000a CB1A     		subs	r3, r1, r3
 327 000c 1382     		strh	r3, [r2, #16]	@ movhi
 411:dfu.c         ****         thisBlockLen = pInformation->USBwLengths.w;
 328              		.loc 1 411 0
 329 000e 044B     		ldr	r3, .L23+4
 330 0010 1980     		strh	r1, [r3]	@ movhi
 412:dfu.c         ****         return NULL;
 331              		.loc 1 412 0
 332 0012 7047     		bx	lr
 333              	.L21:
 413:dfu.c         ****     } else {
 414:dfu.c         ****         return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
 334              		.loc 1 414 0
 335 0014 0348     		ldr	r0, .L23+8
 336              	.LVL14:
 337 0016 1844     		add	r0, r0, r3
 415:dfu.c         ****     }
 416:dfu.c         **** }
 338              		.loc 1 416 0
 339 0018 7047     		bx	lr
 340              	.L24:
 341 001a 00BF     		.align	2
 342              	.L23:
 343 001c 00000000 		.word	pInformation
 344 0020 00000000 		.word	.LANCHOR2
 345 0024 00000000 		.word	.LANCHOR7
 346              		.cfi_endproc
 347              	.LFE9:
 349              		.section	.text.dfuCopyUPLOAD,"ax",%progbits
 350              		.align	1
 351              		.global	dfuCopyUPLOAD
 352              		.syntax unified
 353              		.thumb
 354              		.thumb_func
 355              		.fpu softvfp
 357              	dfuCopyUPLOAD:
 358              	.LFB10:
 417:dfu.c         **** 
 418:dfu.c         **** u8 *dfuCopyUPLOAD(u16 length) {
 359              		.loc 1 418 0
 360              		.cfi_startproc
 361              		@ args = 0, pretend = 0, frame = 0
 362              		@ frame_needed = 0, uses_anonymous_args = 0
 363              		@ link register save eliminated.
 364              	.LVL15:
 365 0000 074B     		ldr	r3, .L28
 366 0002 1968     		ldr	r1, [r3]
 367 0004 4A8A     		ldrh	r2, [r1, #18]
 419:dfu.c         ****     if (length == 0) {
 368              		.loc 1 419 0
 369 0006 20B9     		cbnz	r0, .L26
 420:dfu.c         ****         pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
 370              		.loc 1 420 0
 371 0008 064B     		ldr	r3, .L28+4
 372 000a 1B88     		ldrh	r3, [r3]
 373 000c 9B1A     		subs	r3, r3, r2
 374 000e 0B82     		strh	r3, [r1, #16]	@ movhi
 421:dfu.c         ****         return NULL;
 375              		.loc 1 421 0
 376 0010 7047     		bx	lr
 377              	.L26:
 422:dfu.c         ****     } else {
 423:dfu.c         ****         return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
 378              		.loc 1 423 0
 379 0012 054B     		ldr	r3, .L28+8
 380 0014 1868     		ldr	r0, [r3]
 381              	.LVL16:
 382 0016 054B     		ldr	r3, .L28+12
 383 0018 1B68     		ldr	r3, [r3]
 384 001a 1844     		add	r0, r0, r3
 385 001c 1044     		add	r0, r0, r2
 424:dfu.c         ****     }
 425:dfu.c         **** }
 386              		.loc 1 425 0
 387 001e 7047     		bx	lr
 388              	.L29:
 389              		.align	2
 390              	.L28:
 391 0020 00000000 		.word	pInformation
 392 0024 00000000 		.word	.LANCHOR2
 393 0028 00000000 		.word	.LANCHOR1
 394 002c 00000000 		.word	.LANCHOR3
 395              		.cfi_endproc
 396              	.LFE10:
 398              		.section	.text.dfuCopyBufferToExec,"ax",%progbits
 399              		.align	1
 400              		.global	dfuCopyBufferToExec
 401              		.syntax unified
 402              		.thumb
 403              		.thumb_func
 404              		.fpu softvfp
 406              	dfuCopyBufferToExec:
 407              	.LFB11:
 426:dfu.c         **** 
 427:dfu.c         **** void dfuCopyBufferToExec() {
 408              		.loc 1 427 0
 409              		.cfi_startproc
 410              		@ args = 0, pretend = 0, frame = 0
 411              		@ frame_needed = 0, uses_anonymous_args = 0
 412 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 413              		.cfi_def_cfa_offset 24
 414              		.cfi_offset 3, -24
 415              		.cfi_offset 4, -20
 416              		.cfi_offset 5, -16
 417              		.cfi_offset 6, -12
 418              		.cfi_offset 7, -8
 419              		.cfi_offset 14, -4
 428:dfu.c         ****     int i;
 429:dfu.c         ****     u32 *userSpace;
 430:dfu.c         **** 	
 431:dfu.c         **** /* Roger Clark. 
 432:dfu.c         **** 	Commented out code associated with upload to RAM
 433:dfu.c         **** 
 434:dfu.c         ****     if (userUploadType == DFU_UPLOAD_RAM) 
 435:dfu.c         **** 	{
 436:dfu.c         ****         userSpace = (u32 *)(USER_CODE_RAM + userFirmwareLen);
 437:dfu.c         ****         // we dont need to handle when thisBlock len is not divisible by 4,
 438:dfu.c         ****         //   since the linker will align everything to 4B anyway 
 439:dfu.c         ****         for (i = 0; i < thisBlockLen; i = i + 4) {
 440:dfu.c         ****             *userSpace++ = *(u32 *)(recvBuffer + i);
 441:dfu.c         ****         }
 442:dfu.c         ****     } 
 443:dfu.c         **** 	else 
 444:dfu.c         **** */
 445:dfu.c         **** 	
 446:dfu.c         **** 	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
 420              		.loc 1 446 0
 421 0002 114B     		ldr	r3, .L34
 447:dfu.c         **** 		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
 448:dfu.c         **** 	}
 449:dfu.c         **** 
 450:dfu.c         ****     flashErasePage((u32)(userSpace));
 451:dfu.c         **** 
 452:dfu.c         ****     for (i = 0; i < thisBlockLen; i = i + 4) {
 422              		.loc 1 452 0
 423 0004 0025     		movs	r5, #0
 446:dfu.c         **** 		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
 424              		.loc 1 446 0
 425 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 426              		.loc 1 452 0
 427 0008 104E     		ldr	r6, .L34+4
 446:dfu.c         **** 		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
 428              		.loc 1 446 0
 429 000a 042B     		cmp	r3, #4
 447:dfu.c         **** 		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
 430              		.loc 1 447 0
 431 000c 08BF     		it	eq
 432 000e 104B     		ldreq	r3, .L34+8
 453:dfu.c         ****         /*if ((u32)(userSpace) >= 0x8008074)
 454:dfu.c         ****         {
 455:dfu.c         ****             sha256_update(&ctx, recvBuffer +i, sizeof(u32));
 456:dfu.c         ****         }*/
 457:dfu.c         ****         flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
 433              		.loc 1 457 0
 434 0010 104F     		ldr	r7, .L34+12
 447:dfu.c         **** 	}
 435              		.loc 1 447 0
 436 0012 02BF     		ittt	eq
 437 0014 1C68     		ldreq	r4, [r3]
 438 0016 04F10064 		addeq	r4, r4, #134217728
 439 001a 04F51044 		addeq	r4, r4, #36864
 440              	.LVL17:
 450:dfu.c         **** 
 441              		.loc 1 450 0
 442 001e 2046     		mov	r0, r4
 443 0020 FFF7FEFF 		bl	flashErasePage
 444              	.LVL18:
 445              	.L32:
 452:dfu.c         ****         /*if ((u32)(userSpace) >= 0x8008074)
 446              		.loc 1 452 0 discriminator 1
 447 0024 3388     		ldrh	r3, [r6]
 448 0026 9D42     		cmp	r5, r3
 449 0028 07DB     		blt	.L33
 458:dfu.c         ****     }
 459:dfu.c         ****     
 460:dfu.c         ****     userFirmwareLen += thisBlockLen;
 450              		.loc 1 460 0
 451 002a 094A     		ldr	r2, .L34+8
 452 002c 3188     		ldrh	r1, [r6]
 453 002e 1368     		ldr	r3, [r2]
 454 0030 0B44     		add	r3, r3, r1
 455 0032 1360     		str	r3, [r2]
 461:dfu.c         ****     thisBlockLen = 0;
 456              		.loc 1 461 0
 457 0034 0023     		movs	r3, #0
 458 0036 3380     		strh	r3, [r6]	@ movhi
 462:dfu.c         **** }
 459              		.loc 1 462 0
 460 0038 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 461              	.LVL19:
 462              	.L33:
 457:dfu.c         ****     }
 463              		.loc 1 457 0 discriminator 3
 464 003a E959     		ldr	r1, [r5, r7]
 465 003c 6019     		adds	r0, r4, r5
 466 003e FFF7FEFF 		bl	flashWriteWord
 467              	.LVL20:
 452:dfu.c         ****         /*if ((u32)(userSpace) >= 0x8008074)
 468              		.loc 1 452 0 discriminator 3
 469 0042 0435     		adds	r5, r5, #4
 470              	.LVL21:
 471 0044 EEE7     		b	.L32
 472              	.L35:
 473 0046 00BF     		.align	2
 474              	.L34:
 475 0048 00000000 		.word	.LANCHOR5
 476 004c 00000000 		.word	.LANCHOR2
 477 0050 00000000 		.word	.LANCHOR1
 478 0054 00000000 		.word	.LANCHOR7
 479              		.cfi_endproc
 480              	.LFE11:
 482              		.section	.text.dfuUpdateByRequest,"ax",%progbits
 483              		.align	1
 484              		.global	dfuUpdateByRequest
 485              		.syntax unified
 486              		.thumb
 487              		.thumb_func
 488              		.fpu softvfp
 490              	dfuUpdateByRequest:
 491              	.LFB4:
  81:dfu.c         ****     /* were using the global pInformation struct from usb_lib here,
 492              		.loc 1 81 0
 493              		.cfi_startproc
 494              		@ args = 0, pretend = 0, frame = 8
 495              		@ frame_needed = 0, uses_anonymous_args = 0
 496 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 497              		.cfi_def_cfa_offset 32
 498              		.cfi_offset 4, -20
 499              		.cfi_offset 5, -16
 500              		.cfi_offset 6, -12
 501              		.cfi_offset 7, -8
 502              		.cfi_offset 14, -4
  84:dfu.c         **** 
 503              		.loc 1 84 0
 504 0002 0120     		movs	r0, #1
  87:dfu.c         ****     
 505              		.loc 1 87 0
 506 0004 0022     		movs	r2, #0
  84:dfu.c         **** 
 507              		.loc 1 84 0
 508 0006 8449     		ldr	r1, .L101
  86:dfu.c         ****     dfuAppStatus.bStatus = OK;
 509              		.loc 1 86 0
 510 0008 844C     		ldr	r4, .L101+4
  84:dfu.c         **** 
 511              		.loc 1 84 0
 512 000a 0870     		strb	r0, [r1]
  86:dfu.c         ****     dfuAppStatus.bStatus = OK;
 513              		.loc 1 86 0
 514 000c 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
  87:dfu.c         ****     
 515              		.loc 1 87 0
 516 000e 2270     		strb	r2, [r4]
  86:dfu.c         ****     dfuAppStatus.bStatus = OK;
 517              		.loc 1 86 0
 518 0010 DBB2     		uxtb	r3, r3
 519              	.LVL22:
  91:dfu.c         ****         /*  device running inside DFU mode */
 520              		.loc 1 91 0
 521 0012 022B     		cmp	r3, #2
 522 0014 5DD1     		bne	.L37
  93:dfu.c         **** 
 523              		.loc 1 93 0
 524 0016 0870     		strb	r0, [r1]
  95:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 525              		.loc 1 95 0
 526 0018 8149     		ldr	r1, .L101+8
 527 001a 0968     		ldr	r1, [r1]
 528 001c 4878     		ldrb	r0, [r1, #1]	@ zero_extendqisi2
 529 001e 0128     		cmp	r0, #1
 530 0020 27D1     		bne	.L38
  96:dfu.c         ****                 userFirmwareLen = 0;
 531              		.loc 1 96 0
 532 0022 CB88     		ldrh	r3, [r1, #6]
 533              	.LVL23:
 534 0024 002B     		cmp	r3, #0
 535 0026 00F0DB80 		beq	.L73
  97:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 536              		.loc 1 97 0
 537 002a 7E4B     		ldr	r3, .L101+12
 538 002c 1A60     		str	r2, [r3]
  98:dfu.c         **** 				switch(pInformation->Current_AlternateSetting) {
 539              		.loc 1 98 0
 540 002e 0323     		movs	r3, #3
  99:dfu.c         **** 					/*
 541              		.loc 1 99 0
 542 0030 0A7B     		ldrb	r2, [r1, #12]	@ zero_extendqisi2
  98:dfu.c         **** 				switch(pInformation->Current_AlternateSetting) {
 543              		.loc 1 98 0
 544 0032 2371     		strb	r3, [r4, #4]
  99:dfu.c         **** 					/*
 545              		.loc 1 99 0
 546 0034 012A     		cmp	r2, #1
 547 0036 05D0     		beq	.L41
 548 0038 022A     		cmp	r2, #2
 549 003a 13D0     		beq	.L42
 134:dfu.c         **** 						dfuAppStatus.bStatus = errWRITE;
 550              		.loc 1 134 0
 551 003c 0A22     		movs	r2, #10
 552 003e 2271     		strb	r2, [r4, #4]
 553              	.L87:
 357:dfu.c         ****     }
 554              		.loc 1 357 0
 555 0040 2370     		strb	r3, [r4]
 556 0042 09E0     		b	.L43
 557              	.L41:
 109:dfu.c         **** 						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
 558              		.loc 1 109 0
 559 0044 784B     		ldr	r3, .L101+16
 560 0046 794A     		ldr	r2, .L101+20
 561 0048 1A60     		str	r2, [r3]
 110:dfu.c         **** 						
 562              		.loc 1 110 0
 563 004a 0422     		movs	r2, #4
 564 004c 784B     		ldr	r3, .L101+24
 565 004e 1A70     		strb	r2, [r3]
 566              	.L91:
 127:dfu.c         **** 						flashUnlock();
 567              		.loc 1 127 0
 568 0050 FFF7FEFF 		bl	setupFLASH
 569              	.LVL24:
 128:dfu.c         **** 
 570              		.loc 1 128 0
 571 0054 FFF7FEFF 		bl	flashUnlock
 572              	.LVL25:
 573              	.L43:
 360:dfu.c         **** }
 574              		.loc 1 360 0
 575 0058 2078     		ldrb	r0, [r4]	@ zero_extendqisi2
 361:dfu.c         **** 
 576              		.loc 1 361 0
 577 005a B0FA80F0 		clz	r0, r0
 578 005e 4009     		lsrs	r0, r0, #5
 579 0060 03B0     		add	sp, sp, #12
 580              		.cfi_remember_state
 581              		.cfi_def_cfa_offset 20
 582              		@ sp needed
 583 0062 F0BD     		pop	{r4, r5, r6, r7, pc}
 584              	.L42:
 585              		.cfi_restore_state
 123:dfu.c         **** 						userAppAddr = USER_CODE_FLASH0X8002000;
 586              		.loc 1 123 0
 587 0064 0622     		movs	r2, #6
 588 0066 724B     		ldr	r3, .L101+24
 589 0068 1A70     		strb	r2, [r3]
 124:dfu.c         **** 						
 590              		.loc 1 124 0
 591 006a 6F4B     		ldr	r3, .L101+16
 592 006c 714A     		ldr	r2, .L101+28
 593 006e 1A60     		str	r2, [r3]
 594 0070 EEE7     		b	.L91
 595              	.LVL26:
 596              	.L38:
 143:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 597              		.loc 1 143 0
 598 0072 0228     		cmp	r0, #2
 599 0074 21D1     		bne	.L44
 144:dfu.c         ****             
 600              		.loc 1 144 0
 601 0076 0923     		movs	r3, #9
 602              	.LVL27:
 148:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 603              		.loc 1 148 0
 604 0078 CA88     		ldrh	r2, [r1, #6]
 144:dfu.c         ****             
 605              		.loc 1 144 0
 606 007a 2371     		strb	r3, [r4, #4]
 148:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 607              		.loc 1 148 0
 608 007c 6E4B     		ldr	r3, .L101+32
 149:dfu.c         ****             
 609              		.loc 1 149 0
 610 007e 6F48     		ldr	r0, .L101+36
 148:dfu.c         ****             thisBlockLen = uploadBlockLen; /* for this first block as well */
 611              		.loc 1 148 0
 612 0080 1A80     		strh	r2, [r3]	@ movhi
 149:dfu.c         ****             
 613              		.loc 1 149 0
 614 0082 1A88     		ldrh	r2, [r3]
 615 0084 92B2     		uxth	r2, r2
 616 0086 0280     		strh	r2, [r0]	@ movhi
 152:dfu.c         **** 			
 617              		.loc 1 152 0
 618 0088 1A88     		ldrh	r2, [r3]
 619 008a 4B88     		ldrh	r3, [r1, #2]
 620 008c 5343     		muls	r3, r2, r3
 621 008e 654A     		ldr	r2, .L101+12
 622 0090 1360     		str	r3, [r2]
 154:dfu.c         **** 			/*
 623              		.loc 1 154 0
 624 0092 0B7B     		ldrb	r3, [r1, #12]	@ zero_extendqisi2
 625 0094 012B     		cmp	r3, #1
 626 0096 05D0     		beq	.L46
 627 0098 022B     		cmp	r3, #2
 628 009a 0BD0     		beq	.L47
 175:dfu.c         **** 					dfuAppStatus.bStatus = errWRITE;
 629              		.loc 1 175 0
 630 009c 0A23     		movs	r3, #10
 631 009e 2371     		strb	r3, [r4, #4]
 176:dfu.c         **** 					break;					
 632              		.loc 1 176 0
 633 00a0 0323     		movs	r3, #3
 634 00a2 CDE7     		b	.L87
 635              	.L46:
 162:dfu.c         **** 					userAppEnd = getFlashEnd();
 636              		.loc 1 162 0
 637 00a4 604B     		ldr	r3, .L101+16
 638 00a6 614A     		ldr	r2, .L101+20
 639              	.L86:
 167:dfu.c         **** 					userAppEnd = getFlashEnd();
 640              		.loc 1 167 0
 641 00a8 1A60     		str	r2, [r3]
 168:dfu.c         **** 					break;
 642              		.loc 1 168 0
 643 00aa FFF7FEFF 		bl	getFlashEnd
 644              	.LVL28:
 645 00ae 644B     		ldr	r3, .L101+40
 646 00b0 1860     		str	r0, [r3]
 169:dfu.c         **** 
 647              		.loc 1 169 0
 648 00b2 D1E7     		b	.L43
 649              	.L47:
 167:dfu.c         **** 					userAppEnd = getFlashEnd();
 650              		.loc 1 167 0
 651 00b4 5C4B     		ldr	r3, .L101+16
 652 00b6 5F4A     		ldr	r2, .L101+28
 653 00b8 F6E7     		b	.L86
 654              	.LVL29:
 655              	.L44:
 179:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 656              		.loc 1 179 0
 657 00ba 0628     		cmp	r0, #6
 658 00bc 02D1     		bne	.L48
 659              	.LVL30:
 660              	.L90:
 284:dfu.c         ****             dfuAppStatus.bStatus = OK;
 661              		.loc 1 284 0
 662 00be 2371     		strb	r3, [r4, #4]
 285:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 663              		.loc 1 285 0
 664 00c0 2270     		strb	r2, [r4]
 665 00c2 C9E7     		b	.L43
 666              	.LVL31:
 667              	.L48:
 182:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 668              		.loc 1 182 0
 669 00c4 0328     		cmp	r0, #3
 670 00c6 01D1     		bne	.L49
 671              	.LVL32:
 672              	.L89:
 238:dfu.c         ****         } else {
 673              		.loc 1 238 0
 674 00c8 2371     		strb	r3, [r4, #4]
 675 00ca C5E7     		b	.L43
 676              	.LVL33:
 677              	.L49:
 184:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 678              		.loc 1 184 0
 679 00cc 0528     		cmp	r0, #5
 680              	.L97:
 286:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 681              		.loc 1 286 0
 682 00ce 46D1     		bne	.L79
 683 00d0 FAE7     		b	.L89
 684              	.L37:
 191:dfu.c         ****         /* device received block, waiting for DFU_GETSTATUS request */
 685              		.loc 1 191 0
 686 00d2 032B     		cmp	r3, #3
 687 00d4 0BD1     		bne	.L51
 193:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 688              		.loc 1 193 0
 689 00d6 524A     		ldr	r2, .L101+8
 690 00d8 1268     		ldr	r2, [r2]
 691 00da 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 692 00dc 032A     		cmp	r2, #3
 693 00de 04D1     		bne	.L52
 222:dfu.c         ****                 dfuCopyBufferToExec();
 694              		.loc 1 222 0
 695 00e0 0523     		movs	r3, #5
 696              	.LVL34:
 697 00e2 2371     		strb	r3, [r4, #4]
 223:dfu.c         ****             }
 698              		.loc 1 223 0
 699 00e4 FFF7FEFF 		bl	dfuCopyBufferToExec
 700              	.LVL35:
 701 00e8 B6E7     		b	.L43
 702              	.LVL36:
 703              	.L52:
 226:dfu.c         ****             dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 704              		.loc 1 226 0
 705 00ea 052A     		cmp	r2, #5
 706 00ec EFE7     		b	.L97
 707              	.L51:
 232:dfu.c         ****         /* if were actually done writing, goto sync, else stay busy */
 708              		.loc 1 232 0
 709 00ee 042B     		cmp	r3, #4
 710 00f0 08D1     		bne	.L54
 234:dfu.c         **** 
 711              		.loc 1 234 0
 712 00f2 5449     		ldr	r1, .L101+44
 713 00f4 0878     		ldrb	r0, [r1]	@ zero_extendqisi2
 714 00f6 0228     		cmp	r0, #2
 237:dfu.c         ****             dfuAppStatus.bState = dfuDNLOAD_IDLE;
 715              		.loc 1 237 0
 716 00f8 01BF     		itttt	eq
 717 00fa 0323     		moveq	r3, #3
 718              	.LVL37:
 236:dfu.c         ****             code_copy_lock = WAIT;
 719              		.loc 1 236 0
 720 00fc 6270     		strbeq	r2, [r4, #1]
 237:dfu.c         ****             dfuAppStatus.bState = dfuDNLOAD_IDLE;
 721              		.loc 1 237 0
 722 00fe 0B70     		strbeq	r3, [r1]
 238:dfu.c         ****         } else {
 723              		.loc 1 238 0
 724 0100 0523     		moveq	r3, #5
 725 0102 E1E7     		b	.L89
 726              	.LVL38:
 727              	.L54:
 242:dfu.c         ****         /* device is expecting dfu_dnload requests */
 728              		.loc 1 242 0
 729 0104 052B     		cmp	r3, #5
 730 0106 2ED1     		bne	.L56
 244:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 731              		.loc 1 244 0
 732 0108 454B     		ldr	r3, .L101+8
 733              	.LVL39:
 734 010a 1A68     		ldr	r2, [r3]
 735 010c 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 736 010e 012B     		cmp	r3, #1
 737 0110 1DD1     		bne	.L57
 245:dfu.c         ****                 dfuAppStatus.bState  = dfuDNLOAD_SYNC;
 738              		.loc 1 245 0
 739 0112 D288     		ldrh	r2, [r2, #6]
 740 0114 0AB1     		cbz	r2, .L58
 246:dfu.c         ****             } else {
 741              		.loc 1 246 0
 742 0116 0323     		movs	r3, #3
 743 0118 D6E7     		b	.L89
 744              	.L58:
 745              	.LBB2:
 249:dfu.c         ****                 ImageObjectHandle imageHandle;
 746              		.loc 1 249 0
 747 011a 0623     		movs	r3, #6
 251:dfu.c         ****                 debug_print("image check ret: %X\n", ret);
 748              		.loc 1 251 0
 749 011c 4349     		ldr	r1, .L101+20
 750 011e 01A8     		add	r0, sp, #4
 249:dfu.c         ****                 ImageObjectHandle imageHandle;
 751              		.loc 1 249 0
 752 0120 2371     		strb	r3, [r4, #4]
 251:dfu.c         ****                 debug_print("image check ret: %X\n", ret);
 753              		.loc 1 251 0
 754 0122 FFF7FEFF 		bl	imageCheckFromAddress
 755              	.LVL40:
 756 0126 0546     		mov	r5, r0
 757              	.LVL41:
 252:dfu.c         ****                 switch (ret)
 758              		.loc 1 252 0
 759 0128 0146     		mov	r1, r0
 253:dfu.c         ****                 {
 760              		.loc 1 253 0
 761 012a 023D     		subs	r5, r5, #2
 252:dfu.c         ****                 switch (ret)
 762              		.loc 1 252 0
 763 012c 4648     		ldr	r0, .L101+48
 764              	.LVL42:
 765 012e FFF7FEFF 		bl	uart_printf
 766              	.LVL43:
 253:dfu.c         ****                 {
 767              		.loc 1 253 0
 768 0132 032D     		cmp	r5, #3
 769 0134 06D8     		bhi	.L59
 770 0136 DFE805F0 		tbb	[pc, r5]
 771              	.L61:
 772 013a 08       		.byte	(.L60-.L61)/2
 773 013b 02       		.byte	(.L62-.L61)/2
 774 013c 08       		.byte	(.L60-.L61)/2
 775 013d 08       		.byte	(.L60-.L61)/2
 776              		.p2align 1
 777              	.L62:
 256:dfu.c         ****                         break;
 778              		.loc 1 256 0
 779 013e 4348     		ldr	r0, .L101+52
 780              	.L85:
 262:dfu.c         ****                         break;
 781              		.loc 1 262 0
 782 0140 FFF7FEFF 		bl	uart_printf
 783              	.LVL44:
 784              	.L59:
 268:dfu.c         ****             }
 785              		.loc 1 268 0
 786 0144 FFF7FEFF 		bl	flashLock
 787              	.LVL45:
 788 0148 86E7     		b	.L43
 789              	.L60:
 262:dfu.c         ****                         break;
 790              		.loc 1 262 0
 791 014a 4148     		ldr	r0, .L101+56
 792 014c F8E7     		b	.L85
 793              	.LVL46:
 794              	.L57:
 795              	.LBE2:
 270:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 796              		.loc 1 270 0
 797 014e 062B     		cmp	r3, #6
 798 0150 01D1     		bne	.L63
 799              	.L100:
 330:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
 800              		.loc 1 330 0
 801 0152 0223     		movs	r3, #2
 802 0154 B8E7     		b	.L89
 803              	.L63:
 272:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 804              		.loc 1 272 0
 805 0156 032B     		cmp	r3, #3
 806 0158 FBD0     		beq	.L100
 274:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 807              		.loc 1 274 0
 808 015a 052B     		cmp	r3, #5
 809 015c F9D0     		beq	.L100
 810              	.L79:
 356:dfu.c         ****         dfuAppStatus.bStatus = errSTALLEDPKT;
 811              		.loc 1 356 0
 812 015e 0A23     		movs	r3, #10
 813 0160 2371     		strb	r3, [r4, #4]
 357:dfu.c         ****     }
 814              		.loc 1 357 0
 815 0162 0F23     		movs	r3, #15
 816 0164 6CE7     		b	.L87
 817              	.LVL47:
 818              	.L56:
 281:dfu.c         ****         /* device has received last block, waiting DFU_GETSTATUS request */
 819              		.loc 1 281 0
 820 0166 062B     		cmp	r3, #6
 821 0168 08D1     		bne	.L66
 283:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
 822              		.loc 1 283 0
 823 016a 2D49     		ldr	r1, .L101+8
 824 016c 0968     		ldr	r1, [r1]
 825 016e 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 826 0170 0329     		cmp	r1, #3
 827 0172 01D1     		bne	.L67
 828              	.L92:
 284:dfu.c         ****             dfuAppStatus.bStatus = OK;
 829              		.loc 1 284 0
 830 0174 0823     		movs	r3, #8
 831              	.LVL48:
 832 0176 A2E7     		b	.L90
 833              	.LVL49:
 834              	.L67:
 286:dfu.c         ****             dfuAppStatus.bState  = dfuMANIFEST_SYNC;
 835              		.loc 1 286 0
 836 0178 0529     		cmp	r1, #5
 837 017a A8E7     		b	.L97
 838              	.L66:
 292:dfu.c         ****         /* device is in manifestation phase */
 839              		.loc 1 292 0
 840 017c 072B     		cmp	r3, #7
 841 017e F9D0     		beq	.L92
 298:dfu.c         ****         /* device has programmed new firmware but needs external
 842              		.loc 1 298 0
 843 0180 082B     		cmp	r3, #8
 844 0182 A1D0     		beq	.L89
 304:dfu.c         ****         /* device expecting further dfu_upload requests */
 845              		.loc 1 304 0
 846 0184 092B     		cmp	r3, #9
 847 0186 36D1     		bne	.L71
 306:dfu.c         ****             if (pInformation->USBwLengths.w > 0) {
 848              		.loc 1 306 0
 849 0188 254B     		ldr	r3, .L101+8
 850              	.LVL50:
 851 018a 1A68     		ldr	r2, [r3]
 852 018c 5378     		ldrb	r3, [r2, #1]	@ zero_extendqisi2
 853 018e 022B     		cmp	r3, #2
 854 0190 2AD1     		bne	.L72
 307:dfu.c         ****                 /* check that this is not the last possible block */
 855              		.loc 1 307 0
 856 0192 D588     		ldrh	r5, [r2, #6]
 857 0194 25B3     		cbz	r5, .L73
 309:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 858              		.loc 1 309 0
 859 0196 2848     		ldr	r0, .L101+32
 860 0198 5388     		ldrh	r3, [r2, #2]
 861 019a 0188     		ldrh	r1, [r0]
 310:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 862              		.loc 1 310 0
 863 019c 224E     		ldr	r6, .L101+16
 309:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 864              		.loc 1 309 0
 865 019e 4B43     		muls	r3, r1, r3
 866 01a0 2049     		ldr	r1, .L101+12
 310:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 867              		.loc 1 310 0
 868 01a2 274F     		ldr	r7, .L101+40
 309:dfu.c         ****                 if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
 869              		.loc 1 309 0
 870 01a4 0B60     		str	r3, [r1]
 310:dfu.c         ****                     thisBlockLen = uploadBlockLen;
 871              		.loc 1 310 0
 872 01a6 3368     		ldr	r3, [r6]
 873 01a8 D1F800E0 		ldr	lr, [r1]
 874 01ac B0F800C0 		ldrh	ip, [r0]
 875 01b0 7344     		add	r3, r3, lr
 876 01b2 3A68     		ldr	r2, [r7]
 877 01b4 6344     		add	r3, r3, ip
 878 01b6 9342     		cmp	r3, r2
 879 01b8 204A     		ldr	r2, .L101+36
 880 01ba 04D8     		bhi	.L74
 311:dfu.c         ****                     dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 881              		.loc 1 311 0
 882 01bc 0388     		ldrh	r3, [r0]
 883 01be 9BB2     		uxth	r3, r3
 884 01c0 1380     		strh	r3, [r2]	@ movhi
 885              	.L99:
 334:dfu.c         ****         } else {
 886              		.loc 1 334 0
 887 01c2 0923     		movs	r3, #9
 888 01c4 80E7     		b	.L89
 889              	.L74:
 316:dfu.c         ****                     
 890              		.loc 1 316 0
 891 01c6 3B68     		ldr	r3, [r7]
 892 01c8 3068     		ldr	r0, [r6]
 893 01ca 0968     		ldr	r1, [r1]
 894 01cc 1B1A     		subs	r3, r3, r0
 895 01ce 5B1A     		subs	r3, r3, r1
 896 01d0 9BB2     		uxth	r3, r3
 897 01d2 1380     		strh	r3, [r2]	@ movhi
 319:dfu.c         ****                         thisBlockLen = 0;
 898              		.loc 1 319 0
 899 01d4 1388     		ldrh	r3, [r2]
 900 01d6 9D42     		cmp	r5, r3
 901 01d8 BBD8     		bhi	.L100
 320:dfu.c         ****                     }
 902              		.loc 1 320 0
 903 01da 0023     		movs	r3, #0
 904 01dc 1380     		strh	r3, [r2]	@ movhi
 905 01de B8E7     		b	.L100
 906              	.L73:
 326:dfu.c         ****                 dfuAppStatus.bStatus = errNOTDONE;
 907              		.loc 1 326 0
 908 01e0 0A23     		movs	r3, #10
 909 01e2 2371     		strb	r3, [r4, #4]
 327:dfu.c         ****             }
 910              		.loc 1 327 0
 911 01e4 0923     		movs	r3, #9
 912 01e6 2BE7     		b	.L87
 913              	.L72:
 329:dfu.c         ****             dfuAppStatus.bState  = dfuIDLE;
 914              		.loc 1 329 0
 915 01e8 062B     		cmp	r3, #6
 916 01ea B2D0     		beq	.L100
 331:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 917              		.loc 1 331 0
 918 01ec 032B     		cmp	r3, #3
 919 01ee E8D0     		beq	.L99
 333:dfu.c         ****             dfuAppStatus.bState  = dfuUPLOAD_IDLE;
 920              		.loc 1 333 0
 921 01f0 052B     		cmp	r3, #5
 922 01f2 B4D1     		bne	.L79
 923 01f4 E5E7     		b	.L99
 924              	.LVL51:
 925              	.L71:
 339:dfu.c         ****         /* status is in error, awaiting DFU_CLRSTATUS request */
 926              		.loc 1 339 0
 927 01f6 0A2B     		cmp	r3, #10
 928 01f8 B1D1     		bne	.L79
 341:dfu.c         ****             /* todo, add routine to wait for last block write to finish */
 929              		.loc 1 341 0
 930 01fa 094B     		ldr	r3, .L101+8
 931              	.LVL52:
 932 01fc 1B68     		ldr	r3, [r3]
 933 01fe 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 934 0200 032B     		cmp	r3, #3
 935 0202 01D1     		bne	.L80
 936              	.L95:
 343:dfu.c         ****         } else if (pInformation->USBbRequest == DFU_GETSTATE) {
 937              		.loc 1 343 0
 938 0204 0A23     		movs	r3, #10
 939 0206 5FE7     		b	.L89
 940              	.L80:
 344:dfu.c         ****             dfuAppStatus.bState  = dfuERROR;
 941              		.loc 1 344 0
 942 0208 052B     		cmp	r3, #5
 943 020a FBD0     		beq	.L95
 346:dfu.c         ****             /* todo handle any cleanup we need here */
 944              		.loc 1 346 0
 945 020c 042B     		cmp	r3, #4
 946 020e A6D1     		bne	.L79
 348:dfu.c         ****             dfuAppStatus.bStatus = OK;
 947              		.loc 1 348 0
 948 0210 0223     		movs	r3, #2
 949 0212 2371     		strb	r3, [r4, #4]
 349:dfu.c         ****         } else {
 950              		.loc 1 349 0
 951 0214 0023     		movs	r3, #0
 952 0216 13E7     		b	.L87
 953              	.L102:
 954              		.align	2
 955              	.L101:
 956 0218 00000000 		.word	.LANCHOR6
 957 021c 00000000 		.word	.LANCHOR0
 958 0220 00000000 		.word	pInformation
 959 0224 00000000 		.word	.LANCHOR1
 960 0228 00000000 		.word	.LANCHOR3
 961 022c 00900008 		.word	134254592
 962 0230 00000000 		.word	.LANCHOR5
 963 0234 00200008 		.word	134225920
 964 0238 00000000 		.word	.LANCHOR8
 965 023c 00000000 		.word	.LANCHOR2
 966 0240 00000000 		.word	.LANCHOR4
 967 0244 00000000 		.word	code_copy_lock
 968 0248 00000000 		.word	.LC0
 969 024c 15000000 		.word	.LC1
 970 0250 33000000 		.word	.LC2
 971              		.cfi_endproc
 972              	.LFE4:
 974              		.section	.text.dfuGetState,"ax",%progbits
 975              		.align	1
 976              		.global	dfuGetState
 977              		.syntax unified
 978              		.thumb
 979              		.thumb_func
 980              		.fpu softvfp
 982              	dfuGetState:
 983              	.LFB12:
 463:dfu.c         **** 
 464:dfu.c         **** u8 dfuGetState(void)
 465:dfu.c         **** {
 984              		.loc 1 465 0
 985              		.cfi_startproc
 986              		@ args = 0, pretend = 0, frame = 0
 987              		@ frame_needed = 0, uses_anonymous_args = 0
 988              		@ link register save eliminated.
 466:dfu.c         ****     return dfuAppStatus.bState;
 989              		.loc 1 466 0
 990 0000 014B     		ldr	r3, .L104
 991 0002 1879     		ldrb	r0, [r3, #4]	@ zero_extendqisi2
 467:dfu.c         **** }
 992              		.loc 1 467 0
 993 0004 7047     		bx	lr
 994              	.L105:
 995 0006 00BF     		.align	2
 996              	.L104:
 997 0008 00000000 		.word	.LANCHOR0
 998              		.cfi_endproc
 999              	.LFE12:
 1001              		.section	.text.dfuSetState,"ax",%progbits
 1002              		.align	1
 1003              		.global	dfuSetState
 1004              		.syntax unified
 1005              		.thumb
 1006              		.thumb_func
 1007              		.fpu softvfp
 1009              	dfuSetState:
 1010              	.LFB13:
 468:dfu.c         **** 
 469:dfu.c         **** void dfuSetState(u8 newState)
 470:dfu.c         **** {
 1011              		.loc 1 470 0
 1012              		.cfi_startproc
 1013              		@ args = 0, pretend = 0, frame = 0
 1014              		@ frame_needed = 0, uses_anonymous_args = 0
 1015              		@ link register save eliminated.
 1016              	.LVL53:
 471:dfu.c         ****     dfuAppStatus.bState = newState;
 1017              		.loc 1 471 0
 1018 0000 014B     		ldr	r3, .L107
 1019 0002 1871     		strb	r0, [r3, #4]
 472:dfu.c         **** }
 1020              		.loc 1 472 0
 1021 0004 7047     		bx	lr
 1022              	.L108:
 1023 0006 00BF     		.align	2
 1024              	.L107:
 1025 0008 00000000 		.word	.LANCHOR0
 1026              		.cfi_endproc
 1027              	.LFE13:
 1029              		.section	.text.dfuUploadStarted,"ax",%progbits
 1030              		.align	1
 1031              		.global	dfuUploadStarted
 1032              		.syntax unified
 1033              		.thumb
 1034              		.thumb_func
 1035              		.fpu softvfp
 1037              	dfuUploadStarted:
 1038              	.LFB14:
 473:dfu.c         **** 
 474:dfu.c         **** bool dfuUploadStarted()
 475:dfu.c         **** {
 1039              		.loc 1 475 0
 1040              		.cfi_startproc
 1041              		@ args = 0, pretend = 0, frame = 0
 1042              		@ frame_needed = 0, uses_anonymous_args = 0
 1043              		@ link register save eliminated.
 476:dfu.c         ****     return dfuBusy;
 1044              		.loc 1 476 0
 1045 0000 014B     		ldr	r3, .L110
 1046 0002 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 477:dfu.c         **** }
 1047              		.loc 1 477 0
 1048 0004 7047     		bx	lr
 1049              	.L111:
 1050 0006 00BF     		.align	2
 1051              	.L110:
 1052 0008 00000000 		.word	.LANCHOR6
 1053              		.cfi_endproc
 1054              	.LFE14:
 1056              		.section	.text.dfuUploadDone,"ax",%progbits
 1057              		.align	1
 1058              		.global	dfuUploadDone
 1059              		.syntax unified
 1060              		.thumb
 1061              		.thumb_func
 1062              		.fpu softvfp
 1064              	dfuUploadDone:
 1065              	.LFB15:
 478:dfu.c         **** 
 479:dfu.c         **** bool dfuUploadDone()
 480:dfu.c         **** {
 1066              		.loc 1 480 0
 1067              		.cfi_startproc
 1068              		@ args = 0, pretend = 0, frame = 0
 1069              		@ frame_needed = 0, uses_anonymous_args = 0
 1070              		@ link register save eliminated.
 481:dfu.c         ****     return (dfuAppStatus.bState == dfuMANIFEST_WAIT_RESET
 1071              		.loc 1 481 0
 1072 0000 044B     		ldr	r3, .L115
 1073 0002 1A79     		ldrb	r2, [r3, #4]	@ zero_extendqisi2
 482:dfu.c         ****         &&  dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
 1074              		.loc 1 482 0
 1075 0004 082A     		cmp	r2, #8
 1076 0006 03BF     		ittte	eq
 1077 0008 1878     		ldrbeq	r0, [r3]	@ zero_extendqisi2
 1078 000a B0FA80F0 		clzeq	r0, r0
 1079 000e 4009     		lsreq	r0, r0, #5
 1080 0010 0020     		movne	r0, #0
 483:dfu.c         **** }
 1081              		.loc 1 483 0
 1082 0012 7047     		bx	lr
 1083              	.L116:
 1084              		.align	2
 1085              	.L115:
 1086 0014 00000000 		.word	.LANCHOR0
 1087              		.cfi_endproc
 1088              	.LFE15:
 1090              		.section	.text.dfuFinishUpload,"ax",%progbits
 1091              		.align	1
 1092              		.global	dfuFinishUpload
 1093              		.syntax unified
 1094              		.thumb
 1095              		.thumb_func
 1096              		.fpu softvfp
 1098              	dfuFinishUpload:
 1099              	.LFB16:
 484:dfu.c         **** 
 485:dfu.c         **** void dfuFinishUpload() {
 1100              		.loc 1 485 0
 1101              		.cfi_startproc
 1102              		@ Volatile: function does not return.
 1103              		@ args = 0, pretend = 0, frame = 0
 1104              		@ frame_needed = 0, uses_anonymous_args = 0
 1105              		@ link register save eliminated.
 1106              	.L118:
 486:dfu.c         **** 
 487:dfu.c         ****     while (1)
 488:dfu.c         **** 	{
 489:dfu.c         **** 		__asm__ __volatile__ ("");
 1107              		.loc 1 489 0 discriminator 1
 1108 0000 FEE7     		b	.L118
 1109              		.cfi_endproc
 1110              	.LFE16:
 1112              		.comm	code_copy_lock,1,1
 1113              		.comm	ctx,104,4
 1114              		.comm	input,92,1
 1115              		.comm	sha256sum,32,1
 1116              		.global	dfuBusy
 1117              		.global	userUploadType
 1118              		.comm	rootCA,32,1
 1119              		.comm	wTransferSize,4,4
 1120              		.section	.bss.dfuAppStatus,"aw",%nobits
 1121              		.set	.LANCHOR0,. + 0
 1124              	dfuAppStatus:
 1125 0000 00000000 		.space	6
 1125      0000
 1126              		.section	.bss.dfuBusy,"aw",%nobits
 1127              		.set	.LANCHOR6,. + 0
 1130              	dfuBusy:
 1131 0000 00       		.space	1
 1132              		.section	.bss.recvBuffer,"aw",%nobits
 1133              		.align	2
 1134              		.set	.LANCHOR7,. + 0
 1137              	recvBuffer:
 1138 0000 00000000 		.space	2048
 1138      00000000 
 1138      00000000 
 1138      00000000 
 1138      00000000 
 1139              		.section	.bss.thisBlockLen,"aw",%nobits
 1140              		.align	1
 1141              		.set	.LANCHOR2,. + 0
 1144              	thisBlockLen:
 1145 0000 0000     		.space	2
 1146              		.section	.bss.uploadBlockLen,"aw",%nobits
 1147              		.align	1
 1148              		.set	.LANCHOR8,. + 0
 1151              	uploadBlockLen:
 1152 0000 0000     		.space	2
 1153              		.section	.bss.userFirmwareLen,"aw",%nobits
 1154              		.align	2
 1155              		.set	.LANCHOR1,. + 0
 1158              	userFirmwareLen:
 1159 0000 00000000 		.space	4
 1160              		.section	.bss.userUploadType,"aw",%nobits
 1161              		.set	.LANCHOR5,. + 0
 1164              	userUploadType:
 1165 0000 00       		.space	1
 1166              		.section	.data.userAppAddr,"aw",%progbits
 1167              		.align	2
 1168              		.set	.LANCHOR3,. + 0
 1171              	userAppAddr:
 1172 0000 000C0020 		.word	536873984
 1173              		.section	.data.userAppEnd,"aw",%progbits
 1174              		.align	2
 1175              		.set	.LANCHOR4,. + 0
 1178              	userAppEnd:
 1179 0000 00500020 		.word	536891392
 1180              		.section	.rodata.dfuUpdateByRequest.str1.1,"aMS",%progbits,1
 1181              	.LC0:
 1182 0000 696D6167 		.ascii	"image check ret: %X\012\000"
 1182      65206368 
 1182      65636B20 
 1182      7265743A 
 1182      2025580A 
 1183              	.LC1:
 1184 0015 55706C6F 		.ascii	"Uploaded signature verified!\012\000"
 1184      61646564 
 1184      20736967 
 1184      6E617475 
 1184      72652076 
 1185              	.LC2:
 1186 0033 496D6167 		.ascii	"Image unverified...\012\000"
 1186      6520756E 
 1186      76657269 
 1186      66696564 
 1186      2E2E2E0A 
 1187              		.text
 1188              	.Letext0:
 1189              		.file 2 "/usr/arm-none-eabi/include/machine/_default_types.h"
 1190              		.file 3 "/usr/arm-none-eabi/include/sys/_stdint.h"
 1191              		.file 4 "./stm32_lib/stm32f10x_type.h"
 1192              		.file 5 "/usr/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h"
 1193              		.file 6 "/usr/arm-none-eabi/include/sys/lock.h"
 1194              		.file 7 "/usr/arm-none-eabi/include/sys/_types.h"
 1195              		.file 8 "/usr/arm-none-eabi/include/sys/reent.h"
 1196              		.file 9 "/usr/arm-none-eabi/include/sys/unistd.h"
 1197              		.file 10 "/usr/arm-none-eabi/include/sys/errno.h"
 1198              		.file 11 "./usb_lib/usb_regs.h"
 1199              		.file 12 "./usb_lib/usb_core.h"
 1200              		.file 13 "./usb_lib/usb_init.h"
 1201              		.file 14 "usb_descriptor.h"
 1202              		.file 15 "usb.h"
 1203              		.file 16 "dfu.h"
 1204              		.file 17 "./25519/sha256.h"
 1205              		.file 18 "image.h"
 1206              		.file 19 "hardware.h"
 1207              		.file 20 "/usr/arm-none-eabi/include/string.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 dfu.c
     /tmp/ccVjP7uf.s:16     .text.dfuInit:0000000000000000 $t
     /tmp/ccVjP7uf.s:23     .text.dfuInit:0000000000000000 dfuInit
     /tmp/ccVjP7uf.s:105    .text.dfuInit:0000000000000058 $d
                            *COM*:0000000000000020 sha256sum
                            *COM*:0000000000000001 code_copy_lock
                            *COM*:000000000000005c input
                            *COM*:0000000000000068 ctx
     /tmp/ccVjP7uf.s:121    .text.dfuUpdateByReset:0000000000000000 $t
     /tmp/ccVjP7uf.s:128    .text.dfuUpdateByReset:0000000000000000 dfuUpdateByReset
     /tmp/ccVjP7uf.s:200    .text.dfuUpdateByReset:000000000000003c $d
     /tmp/ccVjP7uf.s:206    .text.dfuUpdateByTimeout:0000000000000000 $t
     /tmp/ccVjP7uf.s:213    .text.dfuUpdateByTimeout:0000000000000000 dfuUpdateByTimeout
     /tmp/ccVjP7uf.s:226    .text.dfuCopyState:0000000000000000 $t
     /tmp/ccVjP7uf.s:233    .text.dfuCopyState:0000000000000000 dfuCopyState
     /tmp/ccVjP7uf.s:259    .text.dfuCopyState:0000000000000010 $d
     /tmp/ccVjP7uf.s:265    .text.dfuCopyStatus:0000000000000000 $t
     /tmp/ccVjP7uf.s:272    .text.dfuCopyStatus:0000000000000000 dfuCopyStatus
     /tmp/ccVjP7uf.s:298    .text.dfuCopyStatus:0000000000000010 $d
     /tmp/ccVjP7uf.s:304    .text.dfuCopyDNLOAD:0000000000000000 $t
     /tmp/ccVjP7uf.s:311    .text.dfuCopyDNLOAD:0000000000000000 dfuCopyDNLOAD
     /tmp/ccVjP7uf.s:343    .text.dfuCopyDNLOAD:000000000000001c $d
     /tmp/ccVjP7uf.s:350    .text.dfuCopyUPLOAD:0000000000000000 $t
     /tmp/ccVjP7uf.s:357    .text.dfuCopyUPLOAD:0000000000000000 dfuCopyUPLOAD
     /tmp/ccVjP7uf.s:391    .text.dfuCopyUPLOAD:0000000000000020 $d
     /tmp/ccVjP7uf.s:399    .text.dfuCopyBufferToExec:0000000000000000 $t
     /tmp/ccVjP7uf.s:406    .text.dfuCopyBufferToExec:0000000000000000 dfuCopyBufferToExec
     /tmp/ccVjP7uf.s:475    .text.dfuCopyBufferToExec:0000000000000048 $d
     /tmp/ccVjP7uf.s:483    .text.dfuUpdateByRequest:0000000000000000 $t
     /tmp/ccVjP7uf.s:490    .text.dfuUpdateByRequest:0000000000000000 dfuUpdateByRequest
     /tmp/ccVjP7uf.s:772    .text.dfuUpdateByRequest:000000000000013a $d
     /tmp/ccVjP7uf.s:776    .text.dfuUpdateByRequest:000000000000013e $t
     /tmp/ccVjP7uf.s:956    .text.dfuUpdateByRequest:0000000000000218 $d
     /tmp/ccVjP7uf.s:975    .text.dfuGetState:0000000000000000 $t
     /tmp/ccVjP7uf.s:982    .text.dfuGetState:0000000000000000 dfuGetState
     /tmp/ccVjP7uf.s:997    .text.dfuGetState:0000000000000008 $d
     /tmp/ccVjP7uf.s:1002   .text.dfuSetState:0000000000000000 $t
     /tmp/ccVjP7uf.s:1009   .text.dfuSetState:0000000000000000 dfuSetState
     /tmp/ccVjP7uf.s:1025   .text.dfuSetState:0000000000000008 $d
     /tmp/ccVjP7uf.s:1030   .text.dfuUploadStarted:0000000000000000 $t
     /tmp/ccVjP7uf.s:1037   .text.dfuUploadStarted:0000000000000000 dfuUploadStarted
     /tmp/ccVjP7uf.s:1052   .text.dfuUploadStarted:0000000000000008 $d
     /tmp/ccVjP7uf.s:1057   .text.dfuUploadDone:0000000000000000 $t
     /tmp/ccVjP7uf.s:1064   .text.dfuUploadDone:0000000000000000 dfuUploadDone
     /tmp/ccVjP7uf.s:1086   .text.dfuUploadDone:0000000000000014 $d
     /tmp/ccVjP7uf.s:1091   .text.dfuFinishUpload:0000000000000000 $t
     /tmp/ccVjP7uf.s:1098   .text.dfuFinishUpload:0000000000000000 dfuFinishUpload
     /tmp/ccVjP7uf.s:1130   .bss.dfuBusy:0000000000000000 dfuBusy
     /tmp/ccVjP7uf.s:1164   .bss.userUploadType:0000000000000000 userUploadType
                            *COM*:0000000000000020 rootCA
                            *COM*:0000000000000004 wTransferSize
     /tmp/ccVjP7uf.s:1124   .bss.dfuAppStatus:0000000000000000 dfuAppStatus
     /tmp/ccVjP7uf.s:1125   .bss.dfuAppStatus:0000000000000000 $d
     /tmp/ccVjP7uf.s:1131   .bss.dfuBusy:0000000000000000 $d
     /tmp/ccVjP7uf.s:1133   .bss.recvBuffer:0000000000000000 $d
     /tmp/ccVjP7uf.s:1137   .bss.recvBuffer:0000000000000000 recvBuffer
     /tmp/ccVjP7uf.s:1140   .bss.thisBlockLen:0000000000000000 $d
     /tmp/ccVjP7uf.s:1144   .bss.thisBlockLen:0000000000000000 thisBlockLen
     /tmp/ccVjP7uf.s:1147   .bss.uploadBlockLen:0000000000000000 $d
     /tmp/ccVjP7uf.s:1151   .bss.uploadBlockLen:0000000000000000 uploadBlockLen
     /tmp/ccVjP7uf.s:1154   .bss.userFirmwareLen:0000000000000000 $d
     /tmp/ccVjP7uf.s:1158   .bss.userFirmwareLen:0000000000000000 userFirmwareLen
     /tmp/ccVjP7uf.s:1165   .bss.userUploadType:0000000000000000 $d
     /tmp/ccVjP7uf.s:1167   .data.userAppAddr:0000000000000000 $d
     /tmp/ccVjP7uf.s:1171   .data.userAppAddr:0000000000000000 userAppAddr
     /tmp/ccVjP7uf.s:1174   .data.userAppEnd:0000000000000000 $d
     /tmp/ccVjP7uf.s:1178   .data.userAppEnd:0000000000000000 userAppEnd

UNDEFINED SYMBOLS
memset
sha256_starts
nvicDisableInterrupts
usbEnbISR
systemHardReset
pInformation
flashErasePage
flashWriteWord
setupFLASH
flashUnlock
getFlashEnd
imageCheckFromAddress
uart_printf
flashLock
