   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"edsign.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.hash_with_prefix,"ax",%progbits
  16              		.align	1
  17              		.syntax unified
  18              		.thumb
  19              		.thumb_func
  20              		.fpu softvfp
  22              	hash_with_prefix:
  23              	.LFB10:
  24              		.file 1 "25519/edsign.c"
   1:25519/edsign.c **** /* Edwards curve signature system
   2:25519/edsign.c ****  * Daniel Beer <dlbeer@gmail.com>, 22 Apr 2014
   3:25519/edsign.c ****  *
   4:25519/edsign.c ****  * This file is in the public domain.
   5:25519/edsign.c ****  */
   6:25519/edsign.c **** 
   7:25519/edsign.c **** #include "ed25519.h"
   8:25519/edsign.c **** #include "sha512.h"
   9:25519/edsign.c **** #include "fprime.h"
  10:25519/edsign.c **** #include "edsign.h"
  11:25519/edsign.c **** 
  12:25519/edsign.c **** #define EXPANDED_SIZE		64
  13:25519/edsign.c **** 
  14:25519/edsign.c **** static const uint8_t ed25519_order[FPRIME_SIZE] = {
  15:25519/edsign.c **** 	0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58,
  16:25519/edsign.c **** 	0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14,
  17:25519/edsign.c **** 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  18:25519/edsign.c **** 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10
  19:25519/edsign.c **** };
  20:25519/edsign.c **** 
  21:25519/edsign.c **** static void expand_key(uint8_t *expanded, const uint8_t *secret)
  22:25519/edsign.c **** {
  23:25519/edsign.c **** 	struct sha512_state s;
  24:25519/edsign.c **** 
  25:25519/edsign.c **** 	sha512_init(&s);
  26:25519/edsign.c **** 	sha512_final(&s, secret, EDSIGN_SECRET_KEY_SIZE);
  27:25519/edsign.c **** 	sha512_get(&s, expanded, 0, EXPANDED_SIZE);
  28:25519/edsign.c **** 	ed25519_prepare(expanded);
  29:25519/edsign.c **** }
  30:25519/edsign.c **** 
  31:25519/edsign.c **** static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
  32:25519/edsign.c **** {
  33:25519/edsign.c **** 	uint8_t x[F25519_SIZE];
  34:25519/edsign.c **** 	uint8_t y[F25519_SIZE];
  35:25519/edsign.c **** 	uint8_t ok = ed25519_try_unpack(x, y, packed);
  36:25519/edsign.c **** 
  37:25519/edsign.c **** 	ed25519_project(p, x, y);
  38:25519/edsign.c **** 	return ok;
  39:25519/edsign.c **** }
  40:25519/edsign.c **** 
  41:25519/edsign.c **** static void pp(uint8_t *packed, const struct ed25519_pt *p)
  42:25519/edsign.c **** {
  43:25519/edsign.c **** 	uint8_t x[F25519_SIZE];
  44:25519/edsign.c **** 	uint8_t y[F25519_SIZE];
  45:25519/edsign.c **** 
  46:25519/edsign.c **** 	ed25519_unproject(x, y, p);
  47:25519/edsign.c **** 	ed25519_pack(packed, x, y);
  48:25519/edsign.c **** }
  49:25519/edsign.c **** 
  50:25519/edsign.c **** static void sm_pack(uint8_t *r, const uint8_t *k)
  51:25519/edsign.c **** {
  52:25519/edsign.c **** 	struct ed25519_pt p;
  53:25519/edsign.c **** 
  54:25519/edsign.c **** 	ed25519_smult(&p, &ed25519_base, k);
  55:25519/edsign.c **** 	pp(r, &p);
  56:25519/edsign.c **** }
  57:25519/edsign.c **** 
  58:25519/edsign.c **** void edsign_sec_to_pub(uint8_t *pub, const uint8_t *secret)
  59:25519/edsign.c **** {
  60:25519/edsign.c **** 	uint8_t expanded[EXPANDED_SIZE];
  61:25519/edsign.c **** 
  62:25519/edsign.c **** 	expand_key(expanded, secret);
  63:25519/edsign.c **** 	sm_pack(pub, expanded);
  64:25519/edsign.c **** }
  65:25519/edsign.c **** 
  66:25519/edsign.c **** static void hash_with_prefix(uint8_t *out_fp,
  67:25519/edsign.c **** 			     uint8_t *init_block, int prefix_size,
  68:25519/edsign.c **** 			     const uint8_t *message, size_t len)
  69:25519/edsign.c **** {
  25              		.loc 1 69 0
  26              		.cfi_startproc
  27              		@ args = 4, pretend = 0, frame = 64
  28              		@ frame_needed = 0, uses_anonymous_args = 0
  29              	.LVL0:
  30 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
  31              		.cfi_def_cfa_offset 32
  32              		.cfi_offset 4, -32
  33              		.cfi_offset 5, -28
  34              		.cfi_offset 6, -24
  35              		.cfi_offset 7, -20
  36              		.cfi_offset 8, -16
  37              		.cfi_offset 9, -12
  38              		.cfi_offset 10, -8
  39              		.cfi_offset 14, -4
  40 0004 90B0     		sub	sp, sp, #64
  41              		.cfi_def_cfa_offset 96
  42              	.LVL1:
  43              	.LBB5:
  44              	.LBB6:
  45              		.file 2 "25519/sha512.h"
   1:25519/sha512.h **** /* SHA512
   2:25519/sha512.h ****  * Daniel Beer <dlbeer@gmail.com>, 22 Apr 2014
   3:25519/sha512.h ****  *
   4:25519/sha512.h ****  * This file is in the public domain.
   5:25519/sha512.h ****  */
   6:25519/sha512.h **** 
   7:25519/sha512.h **** #ifndef SHA512_H_
   8:25519/sha512.h **** #define SHA512_H_
   9:25519/sha512.h **** 
  10:25519/sha512.h **** #include <stdint.h>
  11:25519/sha512.h **** #include <stddef.h>
  12:25519/sha512.h **** #include <string.h>
  13:25519/sha512.h **** 
  14:25519/sha512.h **** /* SHA512 state. State is updated as data is fed in, and then the final
  15:25519/sha512.h ****  * hash can be read out in slices.
  16:25519/sha512.h ****  *
  17:25519/sha512.h ****  * Data is fed in as a sequence of full blocks terminated by a single
  18:25519/sha512.h ****  * partial block.
  19:25519/sha512.h ****  */
  20:25519/sha512.h **** struct sha512_state {
  21:25519/sha512.h **** 	uint64_t	h[8];
  22:25519/sha512.h **** };
  23:25519/sha512.h **** 
  24:25519/sha512.h **** /* Initial state */
  25:25519/sha512.h **** extern const struct sha512_state sha512_initial_state;
  26:25519/sha512.h **** 
  27:25519/sha512.h **** /* Set up a new context */
  28:25519/sha512.h **** static inline void sha512_init(struct sha512_state *s)
  29:25519/sha512.h **** {
  30:25519/sha512.h **** 	memcpy(s, &sha512_initial_state, sizeof(*s));
  46              		.loc 2 30 0
  47 0006 6C46     		mov	r4, sp
  48              	.LBE6:
  49              	.LBE5:
  50              		.loc 1 69 0
  51 0008 1646     		mov	r6, r2
  52 000a 0F46     		mov	r7, r1
  53              	.LBB10:
  54              	.LBB7:
  55              		.loc 2 30 0
  56 000c 1E4D     		ldr	r5, .L7
  57              	.LBE7:
  58              	.LBE10:
  59              		.loc 1 69 0
  60 000e 8246     		mov	r10, r0
  61 0010 9946     		mov	r9, r3
  62              	.LBB11:
  63              	.LBB8:
  64              		.loc 2 30 0
  65 0012 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
  66              	.LVL2:
  67 0014 0FC4     		stmia	r4!, {r0, r1, r2, r3}
  68 0016 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
  69 0018 0FC4     		stmia	r4!, {r0, r1, r2, r3}
  70 001a 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
  71 001c 0FC4     		stmia	r4!, {r0, r1, r2, r3}
  72 001e 95E80F00 		ldm	r5, {r0, r1, r2, r3}
  73              	.LBE8:
  74              	.LBE11:
  75              		.loc 1 69 0
  76 0022 DDF86080 		ldr	r8, [sp, #96]
  77              	.LBB12:
  78              	.LBB9:
  79              		.loc 2 30 0
  80 0026 84E80F00 		stm	r4, {r0, r1, r2, r3}
  81              	.LVL3:
  82              	.LBE9:
  83              	.LBE12:
  70:25519/edsign.c **** 	struct sha512_state s;
  71:25519/edsign.c **** 
  72:25519/edsign.c **** 	sha512_init(&s);
  73:25519/edsign.c **** 
  74:25519/edsign.c **** 	if (len < SHA512_BLOCK_SIZE - prefix_size) {
  84              		.loc 1 74 0
  85 002a C6F18004 		rsb	r4, r6, #128
  86 002e 4445     		cmp	r4, r8
  87 0030 07EB0600 		add	r0, r7, r6
  88 0034 4644     		add	r6, r6, r8
  89              	.LVL4:
  90 0036 17D9     		bls	.L2
  75:25519/edsign.c **** 		memcpy(init_block + prefix_size, message, len);
  91              		.loc 1 75 0
  92 0038 4246     		mov	r2, r8
  93 003a 4946     		mov	r1, r9
  94 003c FFF7FEFF 		bl	memcpy
  95              	.LVL5:
  76:25519/edsign.c **** 		sha512_final(&s, init_block, len + prefix_size);
  96              		.loc 1 76 0
  97 0040 3246     		mov	r2, r6
  98 0042 3946     		mov	r1, r7
  99              	.L6:
 100              	.LBB13:
  77:25519/edsign.c **** 	} else {
  78:25519/edsign.c **** 		size_t i;
  79:25519/edsign.c **** 
  80:25519/edsign.c **** 		memcpy(init_block + prefix_size, message,
  81:25519/edsign.c **** 		       SHA512_BLOCK_SIZE - prefix_size);
  82:25519/edsign.c **** 		sha512_block(&s, init_block);
  83:25519/edsign.c **** 
  84:25519/edsign.c **** 		for (i = SHA512_BLOCK_SIZE - prefix_size;
  85:25519/edsign.c **** 		     i + SHA512_BLOCK_SIZE <= len;
  86:25519/edsign.c **** 		     i += SHA512_BLOCK_SIZE)
  87:25519/edsign.c **** 			sha512_block(&s, message + i);
  88:25519/edsign.c **** 
  89:25519/edsign.c **** 		sha512_final(&s, message + i, len + prefix_size);
 101              		.loc 1 89 0
 102 0044 6846     		mov	r0, sp
 103 0046 FFF7FEFF 		bl	sha512_final
 104              	.LVL6:
 105              	.LBE13:
  90:25519/edsign.c **** 	}
  91:25519/edsign.c **** 
  92:25519/edsign.c **** 	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
 106              		.loc 1 92 0
 107 004a 3946     		mov	r1, r7
 108 004c 6846     		mov	r0, sp
 109 004e 4023     		movs	r3, #64
 110 0050 0022     		movs	r2, #0
 111 0052 FFF7FEFF 		bl	sha512_get
 112              	.LVL7:
  93:25519/edsign.c **** 	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
 113              		.loc 1 93 0
 114 0056 0D4B     		ldr	r3, .L7+4
 115 0058 4022     		movs	r2, #64
 116 005a 3946     		mov	r1, r7
 117 005c 5046     		mov	r0, r10
 118 005e FFF7FEFF 		bl	fprime_from_bytes
 119              	.LVL8:
  94:25519/edsign.c **** }
 120              		.loc 1 94 0
 121 0062 10B0     		add	sp, sp, #64
 122              		.cfi_remember_state
 123              		.cfi_def_cfa_offset 32
 124              		@ sp needed
 125 0064 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 126              	.LVL9:
 127              	.L2:
 128              		.cfi_restore_state
 129              	.LBB14:
  80:25519/edsign.c **** 		       SHA512_BLOCK_SIZE - prefix_size);
 130              		.loc 1 80 0
 131 0068 4946     		mov	r1, r9
 132 006a 2246     		mov	r2, r4
 133 006c FFF7FEFF 		bl	memcpy
 134              	.LVL10:
  82:25519/edsign.c **** 
 135              		.loc 1 82 0
 136 0070 3946     		mov	r1, r7
 137              	.L5:
  87:25519/edsign.c **** 
 138              		.loc 1 87 0
 139 0072 6846     		mov	r0, sp
 140 0074 FFF7FEFF 		bl	sha512_block
 141              	.LVL11:
 142 0078 09EB0401 		add	r1, r9, r4
 143 007c 8034     		adds	r4, r4, #128
 144              	.LVL12:
  84:25519/edsign.c **** 		     i + SHA512_BLOCK_SIZE <= len;
 145              		.loc 1 84 0
 146 007e 4445     		cmp	r4, r8
 147 0080 F7D9     		bls	.L5
  89:25519/edsign.c **** 	}
 148              		.loc 1 89 0
 149 0082 3246     		mov	r2, r6
 150 0084 DEE7     		b	.L6
 151              	.L8:
 152 0086 00BF     		.align	2
 153              	.L7:
 154 0088 00000000 		.word	sha512_initial_state
 155 008c 00000000 		.word	.LANCHOR0
 156              	.LBE14:
 157              		.cfi_endproc
 158              	.LFE10:
 160              		.section	.text.expand_key,"ax",%progbits
 161              		.align	1
 162              		.syntax unified
 163              		.thumb
 164              		.thumb_func
 165              		.fpu softvfp
 167              	expand_key:
 168              	.LFB5:
  22:25519/edsign.c **** 	struct sha512_state s;
 169              		.loc 1 22 0
 170              		.cfi_startproc
 171              		@ args = 0, pretend = 0, frame = 64
 172              		@ frame_needed = 0, uses_anonymous_args = 0
 173              	.LVL13:
 174 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 175              		.cfi_def_cfa_offset 20
 176              		.cfi_offset 4, -20
 177              		.cfi_offset 5, -16
 178              		.cfi_offset 6, -12
 179              		.cfi_offset 7, -8
 180              		.cfi_offset 14, -4
 181 0002 91B0     		sub	sp, sp, #68
 182              		.cfi_def_cfa_offset 88
 183              	.LVL14:
 184              	.LBB19:
 185              	.LBB20:
 186              		.loc 2 30 0
 187 0004 6C46     		mov	r4, sp
 188              	.LBE20:
 189              	.LBE19:
  22:25519/edsign.c **** 	struct sha512_state s;
 190              		.loc 1 22 0
 191 0006 0F46     		mov	r7, r1
 192 0008 0646     		mov	r6, r0
 193              	.LBB22:
 194              	.LBB21:
 195              		.loc 2 30 0
 196 000a 114D     		ldr	r5, .L10
 197 000c 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 198              	.LVL15:
 199 000e 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 200 0010 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 201 0012 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 202 0014 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 203 0016 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 204 0018 95E80F00 		ldm	r5, {r0, r1, r2, r3}
 205 001c 84E80F00 		stm	r4, {r0, r1, r2, r3}
 206              	.LVL16:
 207              	.LBE21:
 208              	.LBE22:
  26:25519/edsign.c **** 	sha512_get(&s, expanded, 0, EXPANDED_SIZE);
 209              		.loc 1 26 0
 210 0020 3946     		mov	r1, r7
 211 0022 6846     		mov	r0, sp
 212 0024 2022     		movs	r2, #32
 213 0026 FFF7FEFF 		bl	sha512_final
 214              	.LVL17:
  27:25519/edsign.c **** 	ed25519_prepare(expanded);
 215              		.loc 1 27 0
 216 002a 4023     		movs	r3, #64
 217 002c 0022     		movs	r2, #0
 218 002e 3146     		mov	r1, r6
 219 0030 6846     		mov	r0, sp
 220 0032 FFF7FEFF 		bl	sha512_get
 221              	.LVL18:
 222              	.LBB23:
 223              	.LBB24:
 224              		.file 3 "25519/ed25519.h"
   1:25519/ed25519.h **** /* Edwards curve operations
   2:25519/ed25519.h ****  * Daniel Beer <dlbeer@gmail.com>, 9 Jan 2014
   3:25519/ed25519.h ****  *
   4:25519/ed25519.h ****  * This file is in the public domain.
   5:25519/ed25519.h ****  */
   6:25519/ed25519.h **** 
   7:25519/ed25519.h **** #ifndef ED25519_H_
   8:25519/ed25519.h **** #define ED25519_H_
   9:25519/ed25519.h **** 
  10:25519/ed25519.h **** #include "f25519.h"
  11:25519/ed25519.h **** 
  12:25519/ed25519.h **** /* This is not the Ed25519 signature system. Rather, we're implementing
  13:25519/ed25519.h ****  * basic operations on the twisted Edwards curve over (Z mod 2^255-19):
  14:25519/ed25519.h ****  *
  15:25519/ed25519.h ****  *     -x^2 + y^2 = 1 - (121665/121666)x^2y^2
  16:25519/ed25519.h ****  *
  17:25519/ed25519.h ****  * With the positive-x base point y = 4/5.
  18:25519/ed25519.h ****  *
  19:25519/ed25519.h ****  * These functions will not leak secret data through timing.
  20:25519/ed25519.h ****  *
  21:25519/ed25519.h ****  * For more information, see:
  22:25519/ed25519.h ****  *
  23:25519/ed25519.h ****  *     Bernstein, D.J. & Lange, T. (2007) "Faster addition and doubling on
  24:25519/ed25519.h ****  *     elliptic curves". Document ID: 95616567a6ba20f575c5f25e7cebaf83.
  25:25519/ed25519.h ****  *
  26:25519/ed25519.h ****  *     Hisil, H. & Wong, K K. & Carter, G. & Dawson, E. (2008) "Twisted
  27:25519/ed25519.h ****  *     Edwards curves revisited". Advances in Cryptology, ASIACRYPT 2008,
  28:25519/ed25519.h ****  *     Vol. 5350, pp. 326-343.
  29:25519/ed25519.h ****  */
  30:25519/ed25519.h **** 
  31:25519/ed25519.h **** /* Projective coordinates */
  32:25519/ed25519.h **** struct ed25519_pt {
  33:25519/ed25519.h **** 	uint8_t		x[F25519_SIZE];
  34:25519/ed25519.h **** 	uint8_t		y[F25519_SIZE];
  35:25519/ed25519.h **** 	uint8_t		t[F25519_SIZE];
  36:25519/ed25519.h **** 	uint8_t		z[F25519_SIZE];
  37:25519/ed25519.h **** };
  38:25519/ed25519.h **** 
  39:25519/ed25519.h **** extern const struct ed25519_pt ed25519_base;
  40:25519/ed25519.h **** extern const struct ed25519_pt ed25519_neutral;
  41:25519/ed25519.h **** 
  42:25519/ed25519.h **** /* Convert between projective and affine coordinates (x/y in F25519) */
  43:25519/ed25519.h **** void ed25519_project(struct ed25519_pt *p,
  44:25519/ed25519.h **** 		     const uint8_t *x, const uint8_t *y);
  45:25519/ed25519.h **** 
  46:25519/ed25519.h **** void ed25519_unproject(uint8_t *x, uint8_t *y,
  47:25519/ed25519.h **** 		       const struct ed25519_pt *p);
  48:25519/ed25519.h **** 
  49:25519/ed25519.h **** /* Compress/uncompress points. try_unpack() will check that the
  50:25519/ed25519.h ****  * compressed point is on the curve, returning 1 if the unpacked point
  51:25519/ed25519.h ****  * is valid, and 0 otherwise.
  52:25519/ed25519.h ****  */
  53:25519/ed25519.h **** #define ED25519_PACK_SIZE	F25519_SIZE
  54:25519/ed25519.h **** 
  55:25519/ed25519.h **** void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y);
  56:25519/ed25519.h **** uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *c);
  57:25519/ed25519.h **** 
  58:25519/ed25519.h **** /* Add, double and scalar multiply */
  59:25519/ed25519.h **** #define ED25519_EXPONENT_SIZE	32
  60:25519/ed25519.h **** 
  61:25519/ed25519.h **** /* Prepare an exponent by clamping appropriate bits */
  62:25519/ed25519.h **** static inline void ed25519_prepare(uint8_t *e)
  63:25519/ed25519.h **** {
  64:25519/ed25519.h **** 	e[0] &= 0xf8;
 225              		.loc 3 64 0
 226 0036 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 227 0038 23F00703 		bic	r3, r3, #7
 228 003c 3370     		strb	r3, [r6]
  65:25519/ed25519.h **** 	e[31] &= 0x7f;
 229              		.loc 3 65 0
 230 003e F37F     		ldrb	r3, [r6, #31]	@ zero_extendqisi2
 231 0040 03F07F03 		and	r3, r3, #127
  66:25519/ed25519.h **** 	e[31] |= 0x40;
 232              		.loc 3 66 0
 233 0044 43F04003 		orr	r3, r3, #64
 234 0048 F377     		strb	r3, [r6, #31]
 235              	.LVL19:
 236              	.LBE24:
 237              	.LBE23:
  29:25519/edsign.c **** 
 238              		.loc 1 29 0
 239 004a 11B0     		add	sp, sp, #68
 240              		.cfi_def_cfa_offset 20
 241              		@ sp needed
 242 004c F0BD     		pop	{r4, r5, r6, r7, pc}
 243              	.LVL20:
 244              	.L11:
 245 004e 00BF     		.align	2
 246              	.L10:
 247 0050 00000000 		.word	sha512_initial_state
 248              		.cfi_endproc
 249              	.LFE5:
 251              		.section	.text.sm_pack,"ax",%progbits
 252              		.align	1
 253              		.syntax unified
 254              		.thumb
 255              		.thumb_func
 256              		.fpu softvfp
 258              	sm_pack:
 259              	.LFB8:
  51:25519/edsign.c **** 	struct ed25519_pt p;
 260              		.loc 1 51 0
 261              		.cfi_startproc
 262              		@ args = 0, pretend = 0, frame = 192
 263              		@ frame_needed = 0, uses_anonymous_args = 0
 264              	.LVL21:
 265 0000 10B5     		push	{r4, lr}
 266              		.cfi_def_cfa_offset 8
 267              		.cfi_offset 4, -8
 268              		.cfi_offset 14, -4
 269 0002 0446     		mov	r4, r0
 270 0004 B0B0     		sub	sp, sp, #192
 271              		.cfi_def_cfa_offset 200
  54:25519/edsign.c **** 	pp(r, &p);
 272              		.loc 1 54 0
 273 0006 0A46     		mov	r2, r1
 274 0008 10A8     		add	r0, sp, #64
 275              	.LVL22:
 276 000a 0749     		ldr	r1, .L13
 277              	.LVL23:
 278 000c FFF7FEFF 		bl	ed25519_smult
 279              	.LVL24:
 280              	.LBB27:
 281              	.LBB28:
  46:25519/edsign.c **** 	ed25519_pack(packed, x, y);
 282              		.loc 1 46 0
 283 0010 10AA     		add	r2, sp, #64
 284              	.LVL25:
 285 0012 08A9     		add	r1, sp, #32
 286 0014 6846     		mov	r0, sp
 287 0016 FFF7FEFF 		bl	ed25519_unproject
 288              	.LVL26:
  47:25519/edsign.c **** }
 289              		.loc 1 47 0
 290 001a 08AA     		add	r2, sp, #32
 291 001c 6946     		mov	r1, sp
 292 001e 2046     		mov	r0, r4
 293 0020 FFF7FEFF 		bl	ed25519_pack
 294              	.LVL27:
 295              	.LBE28:
 296              	.LBE27:
  56:25519/edsign.c **** 
 297              		.loc 1 56 0
 298 0024 30B0     		add	sp, sp, #192
 299              		.cfi_def_cfa_offset 8
 300              		@ sp needed
 301 0026 10BD     		pop	{r4, pc}
 302              	.LVL28:
 303              	.L14:
 304              		.align	2
 305              	.L13:
 306 0028 00000000 		.word	ed25519_base
 307              		.cfi_endproc
 308              	.LFE8:
 310              		.section	.text.edsign_sec_to_pub,"ax",%progbits
 311              		.align	1
 312              		.global	edsign_sec_to_pub
 313              		.syntax unified
 314              		.thumb
 315              		.thumb_func
 316              		.fpu softvfp
 318              	edsign_sec_to_pub:
 319              	.LFB9:
  59:25519/edsign.c **** 	uint8_t expanded[EXPANDED_SIZE];
 320              		.loc 1 59 0
 321              		.cfi_startproc
 322              		@ args = 0, pretend = 0, frame = 64
 323              		@ frame_needed = 0, uses_anonymous_args = 0
 324              	.LVL29:
 325 0000 10B5     		push	{r4, lr}
 326              		.cfi_def_cfa_offset 8
 327              		.cfi_offset 4, -8
 328              		.cfi_offset 14, -4
 329 0002 0446     		mov	r4, r0
 330 0004 90B0     		sub	sp, sp, #64
 331              		.cfi_def_cfa_offset 72
  62:25519/edsign.c **** 	sm_pack(pub, expanded);
 332              		.loc 1 62 0
 333 0006 6846     		mov	r0, sp
 334              	.LVL30:
 335 0008 FFF7FEFF 		bl	expand_key
 336              	.LVL31:
  63:25519/edsign.c **** }
 337              		.loc 1 63 0
 338 000c 6946     		mov	r1, sp
 339 000e 2046     		mov	r0, r4
 340 0010 FFF7FEFF 		bl	sm_pack
 341              	.LVL32:
  64:25519/edsign.c **** 
 342              		.loc 1 64 0
 343 0014 10B0     		add	sp, sp, #64
 344              		.cfi_def_cfa_offset 8
 345              		@ sp needed
 346 0016 10BD     		pop	{r4, pc}
 347              		.cfi_endproc
 348              	.LFE9:
 350              		.section	.text.edsign_sign,"ax",%progbits
 351              		.align	1
 352              		.global	edsign_sign
 353              		.syntax unified
 354              		.thumb
 355              		.thumb_func
 356              		.fpu softvfp
 358              	edsign_sign:
 359              	.LFB13:
  95:25519/edsign.c **** 
  96:25519/edsign.c **** static void generate_k(uint8_t *k, const uint8_t *kgen_key,
  97:25519/edsign.c **** 		       const uint8_t *message, size_t len)
  98:25519/edsign.c **** {
  99:25519/edsign.c **** 	uint8_t block[SHA512_BLOCK_SIZE];
 100:25519/edsign.c **** 
 101:25519/edsign.c **** 	memcpy(block, kgen_key, 32);
 102:25519/edsign.c **** 	hash_with_prefix(k, block, 32, message, len);
 103:25519/edsign.c **** }
 104:25519/edsign.c **** 
 105:25519/edsign.c **** static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
 106:25519/edsign.c **** 			 const uint8_t *m, size_t len)
 107:25519/edsign.c **** {
 108:25519/edsign.c **** 	uint8_t block[SHA512_BLOCK_SIZE];
 109:25519/edsign.c **** 
 110:25519/edsign.c **** 	memcpy(block, r, 32);
 111:25519/edsign.c **** 	memcpy(block + 32, a, 32);
 112:25519/edsign.c **** 	hash_with_prefix(z, block, 64, m, len);
 113:25519/edsign.c **** }
 114:25519/edsign.c **** 
 115:25519/edsign.c **** void edsign_sign(uint8_t *signature, const uint8_t *pub,
 116:25519/edsign.c **** 		 const uint8_t *secret,
 117:25519/edsign.c **** 		 const uint8_t *message, size_t len)
 118:25519/edsign.c **** {
 360              		.loc 1 118 0
 361              		.cfi_startproc
 362              		@ args = 4, pretend = 0, frame = 288
 363              		@ frame_needed = 0, uses_anonymous_args = 0
 364              	.LVL33:
 365 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 366              		.cfi_def_cfa_offset 28
 367              		.cfi_offset 4, -28
 368              		.cfi_offset 5, -24
 369              		.cfi_offset 6, -20
 370              		.cfi_offset 7, -16
 371              		.cfi_offset 8, -12
 372              		.cfi_offset 9, -8
 373              		.cfi_offset 14, -4
 374 0004 9846     		mov	r8, r3
 375 0006 0646     		mov	r6, r0
 376 0008 CBB0     		sub	sp, sp, #300
 377              		.cfi_def_cfa_offset 328
 119:25519/edsign.c **** 	uint8_t expanded[EXPANDED_SIZE];
 120:25519/edsign.c **** 	uint8_t e[FPRIME_SIZE];
 121:25519/edsign.c **** 	uint8_t s[FPRIME_SIZE];
 122:25519/edsign.c **** 	uint8_t k[FPRIME_SIZE];
 123:25519/edsign.c **** 	uint8_t z[FPRIME_SIZE];
 124:25519/edsign.c **** 
 125:25519/edsign.c **** 	expand_key(expanded, secret);
 378              		.loc 1 125 0
 379 000a 1AA8     		add	r0, sp, #104
 380              	.LVL34:
 118:25519/edsign.c **** 	uint8_t expanded[EXPANDED_SIZE];
 381              		.loc 1 118 0
 382 000c 0F46     		mov	r7, r1
 383              	.LBB33:
 384              	.LBB34:
 101:25519/edsign.c **** 	hash_with_prefix(k, block, 32, message, len);
 385              		.loc 1 101 0
 386 000e 2AAC     		add	r4, sp, #168
 387              	.LBE34:
 388              	.LBE33:
 389              		.loc 1 125 0
 390 0010 1146     		mov	r1, r2
 391              	.LVL35:
 392              	.LBB37:
 393              	.LBB35:
 101:25519/edsign.c **** 	hash_with_prefix(k, block, 32, message, len);
 394              		.loc 1 101 0
 395 0012 22AD     		add	r5, sp, #136
 396              	.LBE35:
 397              	.LBE37:
 118:25519/edsign.c **** 	uint8_t expanded[EXPANDED_SIZE];
 398              		.loc 1 118 0
 399 0014 DDF84891 		ldr	r9, [sp, #328]
 400              		.loc 1 125 0
 401 0018 FFF7FEFF 		bl	expand_key
 402              	.LVL36:
 403              	.LBB38:
 404              	.LBB36:
 101:25519/edsign.c **** 	hash_with_prefix(k, block, 32, message, len);
 405              		.loc 1 101 0
 406 001c 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 407              	.LVL37:
 408 001e 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 409 0020 95E80F00 		ldm	r5, {r0, r1, r2, r3}
 410 0024 84E80F00 		stm	r4, {r0, r1, r2, r3}
 102:25519/edsign.c **** }
 411              		.loc 1 102 0
 412 0028 4346     		mov	r3, r8
 413 002a 2022     		movs	r2, #32
 414 002c 2AA9     		add	r1, sp, #168
 415 002e 0AA8     		add	r0, sp, #40
 416              	.LVL38:
 417 0030 CDF80090 		str	r9, [sp]
 418 0034 FFF7FEFF 		bl	hash_with_prefix
 419              	.LVL39:
 420              	.LBE36:
 421              	.LBE38:
 126:25519/edsign.c **** 
 127:25519/edsign.c **** 	generate_k(k, expanded + 32, message, len);
 128:25519/edsign.c **** 	sm_pack(signature, k);
 422              		.loc 1 128 0
 423 0038 0AA9     		add	r1, sp, #40
 424 003a 3046     		mov	r0, r6
 425 003c FFF7FEFF 		bl	sm_pack
 426              	.LVL40:
 427              	.LBB39:
 428              	.LBB40:
 110:25519/edsign.c **** 	memcpy(block + 32, a, 32);
 429              		.loc 1 110 0
 430 0040 3346     		mov	r3, r6
 431 0042 2AAD     		add	r5, sp, #168
 432 0044 06F12004 		add	r4, r6, #32
 433              	.LVL41:
 434              	.L17:
 435 0048 2A46     		mov	r2, r5
 436 004a 1868     		ldr	r0, [r3]	@ unaligned
 437 004c 5968     		ldr	r1, [r3, #4]	@ unaligned
 438 004e 0833     		adds	r3, r3, #8
 439 0050 03C2     		stmia	r2!, {r0, r1}
 440 0052 A342     		cmp	r3, r4
 441 0054 1546     		mov	r5, r2
 442 0056 F7D1     		bne	.L17
 111:25519/edsign.c **** 	hash_with_prefix(z, block, 64, m, len);
 443              		.loc 1 111 0
 444 0058 32AD     		add	r5, sp, #200
 445 005a 2E46     		mov	r6, r5
 446              	.LVL42:
 447 005c 3B46     		mov	r3, r7
 448 005e 2037     		adds	r7, r7, #32
 449              	.LVL43:
 450              	.L18:
 451 0060 3246     		mov	r2, r6
 452 0062 1868     		ldr	r0, [r3]	@ unaligned
 453 0064 5968     		ldr	r1, [r3, #4]	@ unaligned
 454 0066 0833     		adds	r3, r3, #8
 455 0068 03C2     		stmia	r2!, {r0, r1}
 456 006a BB42     		cmp	r3, r7
 457 006c 1646     		mov	r6, r2
 458 006e F7D1     		bne	.L18
 112:25519/edsign.c **** }
 459              		.loc 1 112 0
 460 0070 4346     		mov	r3, r8
 461 0072 4022     		movs	r2, #64
 462 0074 2AA9     		add	r1, sp, #168
 463 0076 12A8     		add	r0, sp, #72
 464              	.LVL44:
 465 0078 CDF80090 		str	r9, [sp]
 466 007c FFF7FEFF 		bl	hash_with_prefix
 467              	.LVL45:
 468              	.LBE40:
 469              	.LBE39:
 129:25519/edsign.c **** 
 130:25519/edsign.c **** 	hash_message(z, signature, pub, message, len);
 131:25519/edsign.c **** 
 132:25519/edsign.c **** 	fprime_from_bytes(e, expanded, 32, ed25519_order);
 470              		.loc 1 132 0
 471 0080 0F4B     		ldr	r3, .L23
 472 0082 2022     		movs	r2, #32
 473 0084 1AA9     		add	r1, sp, #104
 474 0086 02A8     		add	r0, sp, #8
 475 0088 FFF7FEFF 		bl	fprime_from_bytes
 476              	.LVL46:
 133:25519/edsign.c **** 
 134:25519/edsign.c **** 	fprime_mul(s, z, e, ed25519_order);
 477              		.loc 1 134 0
 478 008c 0C4B     		ldr	r3, .L23
 479 008e 02AA     		add	r2, sp, #8
 480 0090 12A9     		add	r1, sp, #72
 481 0092 2AA8     		add	r0, sp, #168
 482 0094 FFF7FEFF 		bl	fprime_mul
 483              	.LVL47:
 135:25519/edsign.c **** 	fprime_add(s, k, ed25519_order);
 484              		.loc 1 135 0
 485 0098 094A     		ldr	r2, .L23
 486 009a 0AA9     		add	r1, sp, #40
 487 009c 2AA8     		add	r0, sp, #168
 488 009e FFF7FEFF 		bl	fprime_add
 489              	.LVL48:
 136:25519/edsign.c **** 	memcpy(signature + 32, s, 32);
 490              		.loc 1 136 0
 491 00a2 2246     		mov	r2, r4
 492 00a4 2AAB     		add	r3, sp, #168
 493              	.LVL49:
 494              	.L19:
 495 00a6 1C46     		mov	r4, r3
 496 00a8 03CC     		ldmia	r4!, {r0, r1}
 497 00aa AC42     		cmp	r4, r5
 498 00ac 1060     		str	r0, [r2]	@ unaligned
 499 00ae 5160     		str	r1, [r2, #4]	@ unaligned
 500 00b0 2346     		mov	r3, r4
 501 00b2 02F10802 		add	r2, r2, #8
 502 00b6 F6D1     		bne	.L19
 137:25519/edsign.c **** }
 503              		.loc 1 137 0
 504 00b8 4BB0     		add	sp, sp, #300
 505              		.cfi_def_cfa_offset 28
 506              		@ sp needed
 507 00ba BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 508              	.LVL50:
 509              	.L24:
 510 00be 00BF     		.align	2
 511              	.L23:
 512 00c0 00000000 		.word	.LANCHOR0
 513              		.cfi_endproc
 514              	.LFE13:
 516              		.section	.text.edsign_verify,"ax",%progbits
 517              		.align	1
 518              		.global	edsign_verify
 519              		.syntax unified
 520              		.thumb
 521              		.thumb_func
 522              		.fpu softvfp
 524              	edsign_verify:
 525              	.LFB14:
 138:25519/edsign.c **** uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
 139:25519/edsign.c **** 		      const uint8_t *message, size_t len)
 140:25519/edsign.c **** {
 526              		.loc 1 140 0
 527              		.cfi_startproc
 528              		@ args = 0, pretend = 0, frame = 416
 529              		@ frame_needed = 0, uses_anonymous_args = 0
 530              	.LVL51:
 531 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 532              		.cfi_def_cfa_offset 24
 533              		.cfi_offset 4, -24
 534              		.cfi_offset 5, -20
 535              		.cfi_offset 6, -16
 536              		.cfi_offset 7, -12
 537              		.cfi_offset 8, -8
 538              		.cfi_offset 14, -4
 539 0004 0646     		mov	r6, r0
 540 0006 0F46     		mov	r7, r1
 541              	.LBB49:
 542              	.LBB50:
 110:25519/edsign.c **** 	memcpy(block + 32, a, 32);
 543              		.loc 1 110 0
 544 0008 0446     		mov	r4, r0
 545              	.LBE50:
 546              	.LBE49:
 547              		.loc 1 140 0
 548 000a EAB0     		sub	sp, sp, #424
 549              		.cfi_def_cfa_offset 448
 550              	.LVL52:
 551              	.LBB52:
 552              	.LBB51:
 110:25519/edsign.c **** 	memcpy(block + 32, a, 32);
 553              		.loc 1 110 0
 554 000c 0DF5947C 		add	ip, sp, #296
 555 0010 00F12008 		add	r8, r0, #32
 556              	.LVL53:
 557              	.L26:
 558 0014 6546     		mov	r5, ip
 559 0016 2068     		ldr	r0, [r4]	@ unaligned
 560 0018 6168     		ldr	r1, [r4, #4]	@ unaligned
 561 001a 0834     		adds	r4, r4, #8
 562 001c 03C5     		stmia	r5!, {r0, r1}
 563 001e 4445     		cmp	r4, r8
 564 0020 AC46     		mov	ip, r5
 565 0022 F7D1     		bne	.L26
 111:25519/edsign.c **** 	hash_with_prefix(z, block, 64, m, len);
 566              		.loc 1 111 0
 567 0024 3C46     		mov	r4, r7
 568 0026 0DF5A47C 		add	ip, sp, #328
 569 002a 07F1200E 		add	lr, r7, #32
 570              	.L27:
 571 002e 6546     		mov	r5, ip
 572 0030 2068     		ldr	r0, [r4]	@ unaligned
 573 0032 6168     		ldr	r1, [r4, #4]	@ unaligned
 574 0034 0834     		adds	r4, r4, #8
 575 0036 03C5     		stmia	r5!, {r0, r1}
 576 0038 7445     		cmp	r4, lr
 577 003a AC46     		mov	ip, r5
 578 003c F7D1     		bne	.L27
 112:25519/edsign.c **** }
 579              		.loc 1 112 0
 580 003e 0093     		str	r3, [sp]
 581 0040 4AA9     		add	r1, sp, #296
 582 0042 1346     		mov	r3, r2
 583              	.LVL54:
 584 0044 12A8     		add	r0, sp, #72
 585              	.LVL55:
 586 0046 4022     		movs	r2, #64
 587              	.LVL56:
 588 0048 FFF7FEFF 		bl	hash_with_prefix
 589              	.LVL57:
 590              	.LBE51:
 591              	.LBE52:
 141:25519/edsign.c **** 	struct ed25519_pt p;
 142:25519/edsign.c **** 	struct ed25519_pt q;
 143:25519/edsign.c **** 	uint8_t lhs[F25519_SIZE];
 144:25519/edsign.c **** 	uint8_t rhs[F25519_SIZE];
 145:25519/edsign.c **** 	uint8_t z[FPRIME_SIZE];
 146:25519/edsign.c **** 	uint8_t ok = 1;
 147:25519/edsign.c **** 
 148:25519/edsign.c **** 	/* Compute z = H(R, A, M) */
 149:25519/edsign.c **** 	hash_message(z, signature, pub, message, len);
 150:25519/edsign.c **** 
 151:25519/edsign.c **** 	/* sB = (ze + k)B = ... */
 152:25519/edsign.c **** 	sm_pack(lhs, signature + 32);
 592              		.loc 1 152 0
 593 004c 4146     		mov	r1, r8
 594 004e 02A8     		add	r0, sp, #8
 595 0050 FFF7FEFF 		bl	sm_pack
 596              	.LVL58:
 597              	.LBB53:
 598              	.LBB54:
  35:25519/edsign.c **** 
 599              		.loc 1 35 0
 600 0054 3A46     		mov	r2, r7
 601 0056 4AA9     		add	r1, sp, #296
 602 0058 22A8     		add	r0, sp, #136
 603 005a FFF7FEFF 		bl	ed25519_try_unpack
 604              	.LVL59:
  37:25519/edsign.c **** 	return ok;
 605              		.loc 1 37 0
 606 005e 4AAA     		add	r2, sp, #296
 607 0060 22A9     		add	r1, sp, #136
  35:25519/edsign.c **** 
 608              		.loc 1 35 0
 609 0062 0446     		mov	r4, r0
 610              	.LVL60:
  37:25519/edsign.c **** 	return ok;
 611              		.loc 1 37 0
 612 0064 2AA8     		add	r0, sp, #168
 613              	.LVL61:
 614 0066 FFF7FEFF 		bl	ed25519_project
 615              	.LVL62:
 616              	.LBE54:
 617              	.LBE53:
 153:25519/edsign.c **** 
 154:25519/edsign.c **** 	/* ... = zA + R */
 155:25519/edsign.c **** 	ok &= upp(&p, pub);
 156:25519/edsign.c **** 	ed25519_smult(&p, &p, z);
 618              		.loc 1 156 0
 619 006a 2AA9     		add	r1, sp, #168
 620 006c 12AA     		add	r2, sp, #72
 621 006e 0846     		mov	r0, r1
 622 0070 FFF7FEFF 		bl	ed25519_smult
 623              	.LVL63:
 624              	.LBB55:
 625              	.LBB56:
  35:25519/edsign.c **** 
 626              		.loc 1 35 0
 627 0074 3246     		mov	r2, r6
 628 0076 22A9     		add	r1, sp, #136
 629 0078 1AA8     		add	r0, sp, #104
 630 007a FFF7FEFF 		bl	ed25519_try_unpack
 631              	.LVL64:
  37:25519/edsign.c **** 	return ok;
 632              		.loc 1 37 0
 633 007e 22AA     		add	r2, sp, #136
 634 0080 1AA9     		add	r1, sp, #104
 635 0082 0440     		ands	r4, r4, r0
 636              	.LVL65:
 637 0084 4AA8     		add	r0, sp, #296
 638              	.LVL66:
 639 0086 FFF7FEFF 		bl	ed25519_project
 640              	.LVL67:
 641              	.LBE56:
 642              	.LBE55:
 157:25519/edsign.c **** 	ok &= upp(&q, signature);
 158:25519/edsign.c **** 	ed25519_add(&p, &p, &q);
 643              		.loc 1 158 0
 644 008a 2AA9     		add	r1, sp, #168
 645 008c 4AAA     		add	r2, sp, #296
 646              	.LVL68:
 647 008e 0846     		mov	r0, r1
 648 0090 FFF7FEFF 		bl	ed25519_add
 649              	.LVL69:
 650              	.LBB57:
 651              	.LBB58:
  46:25519/edsign.c **** 	ed25519_pack(packed, x, y);
 652              		.loc 1 46 0
 653 0094 2AAA     		add	r2, sp, #168
 654 0096 22A9     		add	r1, sp, #136
 655 0098 1AA8     		add	r0, sp, #104
 656 009a FFF7FEFF 		bl	ed25519_unproject
 657              	.LVL70:
  47:25519/edsign.c **** }
 658              		.loc 1 47 0
 659 009e 22AA     		add	r2, sp, #136
 660 00a0 1AA9     		add	r1, sp, #104
 661 00a2 0AA8     		add	r0, sp, #40
 662 00a4 FFF7FEFF 		bl	ed25519_pack
 663              	.LVL71:
 664              	.LBE58:
 665              	.LBE57:
 159:25519/edsign.c **** 	pp(rhs, &p);
 160:25519/edsign.c **** 
 161:25519/edsign.c **** 	/* Equal? */
 162:25519/edsign.c **** 	return ok & f25519_eq(lhs, rhs);
 666              		.loc 1 162 0
 667 00a8 0AA9     		add	r1, sp, #40
 668 00aa 02A8     		add	r0, sp, #8
 669 00ac FFF7FEFF 		bl	f25519_eq
 670              	.LVL72:
 671 00b0 E4B2     		uxtb	r4, r4
 672              	.LVL73:
 157:25519/edsign.c **** 	ed25519_add(&p, &p, &q);
 673              		.loc 1 157 0
 674 00b2 04F00104 		and	r4, r4, #1
 675              	.LVL74:
 163:25519/edsign.c **** }
 676              		.loc 1 163 0
 677 00b6 2040     		ands	r0, r0, r4
 678 00b8 6AB0     		add	sp, sp, #424
 679              		.cfi_def_cfa_offset 24
 680              		@ sp needed
 681 00ba BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 682              		.cfi_endproc
 683              	.LFE14:
 685              		.section	.rodata.ed25519_order,"a",%progbits
 686              		.set	.LANCHOR0,. + 0
 689              	ed25519_order:
 690 0000 ED       		.byte	-19
 691 0001 D3       		.byte	-45
 692 0002 F5       		.byte	-11
 693 0003 5C       		.byte	92
 694 0004 1A       		.byte	26
 695 0005 63       		.byte	99
 696 0006 12       		.byte	18
 697 0007 58       		.byte	88
 698 0008 D6       		.byte	-42
 699 0009 9C       		.byte	-100
 700 000a F7       		.byte	-9
 701 000b A2       		.byte	-94
 702 000c DE       		.byte	-34
 703 000d F9       		.byte	-7
 704 000e DE       		.byte	-34
 705 000f 14       		.byte	20
 706 0010 00       		.byte	0
 707 0011 00       		.byte	0
 708 0012 00       		.byte	0
 709 0013 00       		.byte	0
 710 0014 00       		.byte	0
 711 0015 00       		.byte	0
 712 0016 00       		.byte	0
 713 0017 00       		.byte	0
 714 0018 00       		.byte	0
 715 0019 00       		.byte	0
 716 001a 00       		.byte	0
 717 001b 00       		.byte	0
 718 001c 00       		.byte	0
 719 001d 00       		.byte	0
 720 001e 00       		.byte	0
 721 001f 10       		.byte	16
 722              		.text
 723              	.Letext0:
 724              		.file 4 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_d
 725              		.file 5 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_stdin
 726              		.file 6 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/incl
 727              		.file 7 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/lock.h
 728              		.file 8 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types
 729              		.file 9 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/reent.
 730              		.file 10 "25519/f25519.h"
 731              		.file 11 "25519/fprime.h"
 732              		.file 12 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 edsign.c
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:16     .text.hash_with_prefix:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:22     .text.hash_with_prefix:0000000000000000 hash_with_prefix
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:154    .text.hash_with_prefix:0000000000000088 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:161    .text.expand_key:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:167    .text.expand_key:0000000000000000 expand_key
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:247    .text.expand_key:0000000000000050 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:252    .text.sm_pack:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:258    .text.sm_pack:0000000000000000 sm_pack
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:306    .text.sm_pack:0000000000000028 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:311    .text.edsign_sec_to_pub:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:318    .text.edsign_sec_to_pub:0000000000000000 edsign_sec_to_pub
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:351    .text.edsign_sign:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:358    .text.edsign_sign:0000000000000000 edsign_sign
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:512    .text.edsign_sign:00000000000000c0 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:517    .text.edsign_verify:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:524    .text.edsign_verify:0000000000000000 edsign_verify
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccH5URBh.s:689    .rodata.ed25519_order:0000000000000000 ed25519_order

UNDEFINED SYMBOLS
memcpy
sha512_final
sha512_get
fprime_from_bytes
sha512_block
sha512_initial_state
ed25519_smult
ed25519_unproject
ed25519_pack
ed25519_base
fprime_mul
fprime_add
ed25519_try_unpack
ed25519_project
ed25519_add
f25519_eq
