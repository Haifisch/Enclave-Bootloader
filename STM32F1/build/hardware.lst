   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"hardware.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.uart_printf.constprop.0,"ax",%progbits
  19              		.align	2
  20              		.thumb
  21              		.thumb_func
  23              	uart_printf.constprop.0:
  24              	.LFB31:
  25              		.file 1 "hardware.c"
   1:hardware.c    **** /* *****************************************************************************
   2:hardware.c    ****  * The MIT License
   3:hardware.c    ****  *
   4:hardware.c    ****  * Copyright (c) 2010 LeafLabs LLC.
   5:hardware.c    ****  *
   6:hardware.c    ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:hardware.c    ****  * of this software and associated documentation files (the "Software"), to deal
   8:hardware.c    ****  * in the Software without restriction, including without limitation the rights
   9:hardware.c    ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:hardware.c    ****  * copies of the Software, and to permit persons to whom the Software is
  11:hardware.c    ****  * furnished to do so, subject to the following conditions:
  12:hardware.c    ****  *
  13:hardware.c    ****  * The above copyright notice and this permission notice shall be included in
  14:hardware.c    ****  * all copies or substantial portions of the Software.
  15:hardware.c    ****  *
  16:hardware.c    ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:hardware.c    ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:hardware.c    ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:hardware.c    ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:hardware.c    ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:hardware.c    ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:hardware.c    ****  * THE SOFTWARE.
  23:hardware.c    ****  * ****************************************************************************/
  24:hardware.c    **** 
  25:hardware.c    **** /**
  26:hardware.c    ****  *  @file hardware.c
  27:hardware.c    ****  *
  28:hardware.c    ****  *  @brief init routines to setup clocks, interrupts, also destructor functions.
  29:hardware.c    ****  *  does not include USB stuff. EEPROM read/write functions.
  30:hardware.c    ****  *
  31:hardware.c    ****  */
  32:hardware.c    **** #include <stdio.h>
  33:hardware.c    **** #include <stdint.h>
  34:hardware.c    **** #include <string.h>
  35:hardware.c    **** #include <limits.h>
  36:hardware.c    **** #include <unistd.h>
  37:hardware.c    **** #include <errno.h>
  38:hardware.c    **** #include <stdarg.h>
  39:hardware.c    **** 
  40:hardware.c    **** 
  41:hardware.c    **** #include "common.h"
  42:hardware.c    **** #include "hardware.h"
  43:hardware.c    **** #include "sha256.h"
  44:hardware.c    **** #include "edsign.h"
  45:hardware.c    **** #include "image.h"
  46:hardware.c    **** 
  47:hardware.c    **** /*
  48:hardware.c    **** void setPin(u32 bank, u8 pin) {
  49:hardware.c    ****     u32 pinMask = 0x1 << (pin);
  50:hardware.c    ****     SET_REG(GPIO_BSRR(bank), pinMask);
  51:hardware.c    **** }
  52:hardware.c    **** 
  53:hardware.c    **** void resetPin(u32 bank, u8 pin) {
  54:hardware.c    ****     u32 pinMask = 0x1 << (16 + pin);
  55:hardware.c    ****     SET_REG(GPIO_BSRR(bank), pinMask);
  56:hardware.c    **** }
  57:hardware.c    **** */
  58:hardware.c    **** void gpio_write_bit(u32 bank, u8 pin, u8 val) {
  59:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
  61:hardware.c    **** }
  62:hardware.c    **** 
  63:hardware.c    **** bool readPin(u32 bank, u8 pin) {
  64:hardware.c    ****     // todo, implement read
  65:hardware.c    ****     if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
  66:hardware.c    ****         return TRUE;
  67:hardware.c    ****     } else {
  68:hardware.c    ****         return FALSE;
  69:hardware.c    ****     }
  70:hardware.c    **** }
  71:hardware.c    **** 
  72:hardware.c    **** void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
  73:hardware.c    **** {
  74:hardware.c    ****     gpio_write_bit( bank,pin,1-onState);
  75:hardware.c    **** 
  76:hardware.c    ****     u32 c;
  77:hardware.c    ****     while (count-- > 0) 
  78:hardware.c    **** 	{
  79:hardware.c    ****         for (c = rate; c > 0; c--)
  80:hardware.c    **** 		{
  81:hardware.c    ****             asm volatile("nop");
  82:hardware.c    ****         }
  83:hardware.c    **** 		
  84:hardware.c    ****         gpio_write_bit( bank,pin,onState);
  85:hardware.c    **** 		
  86:hardware.c    ****         for (c = rate; c > 0; c--)
  87:hardware.c    **** 		{
  88:hardware.c    ****             asm volatile("nop");
  89:hardware.c    ****         }
  90:hardware.c    ****         gpio_write_bit( bank,pin,1-onState);
  91:hardware.c    ****     }
  92:hardware.c    **** }
  93:hardware.c    **** 
  94:hardware.c    **** 
  95:hardware.c    **** typedef struct
  96:hardware.c    **** {
  97:hardware.c    ****   uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate
  98:hardware.c    ****                                            The baud rate is computed using the following formula:
  99:hardware.c    ****                                             - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->
 100:hardware.c    ****                                             - FractionalDivider = ((IntegerDivider - ((u32) Integer
 101:hardware.c    **** 
 102:hardware.c    ****   uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or receive
 103:hardware.c    ****                                            This parameter can be a value of @ref USART_Word_Length 
 104:hardware.c    **** 
 105:hardware.c    ****   uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
 106:hardware.c    ****                                            This parameter can be a value of @ref USART_Stop_Bits */
 107:hardware.c    **** 
 108:hardware.c    ****   uint16_t USART_Parity;              /*!< Specifies the parity mode.
 109:hardware.c    ****                                            This parameter can be a value of @ref USART_Parity
 110:hardware.c    ****                                            @note When parity is enabled, the computed parity is ins
 111:hardware.c    ****                                                  at the MSB position of the transmitted data (9th b
 112:hardware.c    ****                                                  the word length is set to 9 data bits; 8th bit whe
 113:hardware.c    ****                                                  word length is set to 8 data bits). */
 114:hardware.c    ****  
 115:hardware.c    ****   uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled
 116:hardware.c    ****                                            This parameter can be a value of @ref USART_Mode */
 117:hardware.c    **** 
 118:hardware.c    ****   uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabl
 119:hardware.c    ****                                            or disabled.
 120:hardware.c    ****                                            This parameter can be a value of @ref USART_Hardware_Flo
 121:hardware.c    **** } USART_InitTypeDef;
 122:hardware.c    **** 
 123:hardware.c    **** /** 
 124:hardware.c    ****   * @brief  USART Clock Init Structure definition  
 125:hardware.c    ****   */ 
 126:hardware.c    ****   
 127:hardware.c    **** typedef struct
 128:hardware.c    **** {
 129:hardware.c    **** 
 130:hardware.c    ****   uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.
 131:hardware.c    ****                                This parameter can be a value of @ref USART_Clock */
 132:hardware.c    **** 
 133:hardware.c    ****   uint16_t USART_CPOL;    /*!< Specifies the steady state value of the serial clock.
 134:hardware.c    ****                                This parameter can be a value of @ref USART_Clock_Polarity */
 135:hardware.c    **** 
 136:hardware.c    ****   uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.
 137:hardware.c    ****                                This parameter can be a value of @ref USART_Clock_Phase */
 138:hardware.c    **** 
 139:hardware.c    ****   uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmit
 140:hardware.c    ****                                data bit (MSB) has to be output on the SCLK pin in synchronous mode.
 141:hardware.c    ****                                This parameter can be a value of @ref USART_Last_Bit */
 142:hardware.c    **** } USART_ClockInitTypeDef;
 143:hardware.c    **** 
 144:hardware.c    **** 
 145:hardware.c    **** typedef enum
 146:hardware.c    **** { 
 147:hardware.c    ****   GPIO_Speed_10MHz = 1,
 148:hardware.c    ****   GPIO_Speed_2MHz, 
 149:hardware.c    ****   GPIO_Speed_50MHz
 150:hardware.c    **** }GPIOSpeed_TypeDef;
 151:hardware.c    **** 
 152:hardware.c    **** typedef enum
 153:hardware.c    **** { GPIO_Mode_AIN = 0x0,
 154:hardware.c    ****   GPIO_Mode_IN_FLOATING = 0x04,
 155:hardware.c    ****   GPIO_Mode_IPD = 0x28,
 156:hardware.c    ****   GPIO_Mode_IPU = 0x48,
 157:hardware.c    ****   GPIO_Mode_Out_OD = 0x14,
 158:hardware.c    ****   GPIO_Mode_Out_PP = 0x10,
 159:hardware.c    ****   GPIO_Mode_AF_OD = 0x1C,
 160:hardware.c    ****   GPIO_Mode_AF_PP = 0x18
 161:hardware.c    **** }GPIOMode_TypeDef;
 162:hardware.c    **** 
 163:hardware.c    **** typedef struct
 164:hardware.c    **** {
 165:hardware.c    ****   uint16_t GPIO_Pin;             /*!< Specifies the GPIO pins to be configured.
 166:hardware.c    ****                                       This parameter can be any value of @ref GPIO_pins_define */
 167:hardware.c    **** 
 168:hardware.c    ****   GPIOSpeed_TypeDef GPIO_Speed;  /*!< Specifies the speed for the selected pins.
 169:hardware.c    ****                                       This parameter can be a value of @ref GPIOSpeed_TypeDef */
 170:hardware.c    **** 
 171:hardware.c    ****   GPIOMode_TypeDef GPIO_Mode;    /*!< Specifies the operating mode for the selected pins.
 172:hardware.c    ****                                       This parameter can be a value of @ref GPIOMode_TypeDef */
 173:hardware.c    **** }GPIO_InitTypeDef;
 174:hardware.c    **** 
 175:hardware.c    **** typedef struct
 176:hardware.c    **** {
 177:hardware.c    ****   __IO uint32_t CRL;
 178:hardware.c    ****   __IO uint32_t CRH;
 179:hardware.c    ****   __IO uint32_t IDR;
 180:hardware.c    ****   __IO uint32_t ODR;
 181:hardware.c    ****   __IO uint32_t BSRR;
 182:hardware.c    ****   __IO uint32_t BRR;
 183:hardware.c    ****   __IO uint32_t LCKR;
 184:hardware.c    **** } GPIO_TypeDef;
 185:hardware.c    **** #define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias regi
 186:hardware.c    **** 
 187:hardware.c    **** #define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band r
 188:hardware.c    **** 
 189:hardware.c    **** #define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address */
 190:hardware.c    **** 
 191:hardware.c    **** /*!< Peripheral memory map */
 192:hardware.c    **** #define APB1PERIPH_BASE       PERIPH_BASE
 193:hardware.c    **** #define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
 194:hardware.c    **** 
 195:hardware.c    **** #define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
 196:hardware.c    **** #define USART1              ((USART_TypeDef *) USART1_BASE)
 197:hardware.c    **** 
 198:hardware.c    **** #define USART_WordLength_8b                  ((uint16_t)0x0000)
 199:hardware.c    **** #define USART_WordLength_9b                  ((uint16_t)0x1000)
 200:hardware.c    ****                                     
 201:hardware.c    **** #define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
 202:hardware.c    ****                                       ((LENGTH) == USART_WordLength_9b))
 203:hardware.c    **** /**
 204:hardware.c    ****   * @}
 205:hardware.c    ****   */ 
 206:hardware.c    **** 
 207:hardware.c    **** /** @defgroup USART_Stop_Bits 
 208:hardware.c    ****   * @{
 209:hardware.c    ****   */ 
 210:hardware.c    ****   
 211:hardware.c    **** #define USART_StopBits_1                     ((uint16_t)0x0000)
 212:hardware.c    **** #define USART_StopBits_0_5                   ((uint16_t)0x1000)
 213:hardware.c    **** #define USART_StopBits_2                     ((uint16_t)0x2000)
 214:hardware.c    **** #define USART_StopBits_1_5                   ((uint16_t)0x3000)
 215:hardware.c    **** #define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
 216:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_0_5) || \
 217:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_2) || \
 218:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_1_5))
 219:hardware.c    **** /**
 220:hardware.c    ****   * @}
 221:hardware.c    ****   */ 
 222:hardware.c    **** 
 223:hardware.c    **** /** @defgroup USART_Parity 
 224:hardware.c    ****   * @{
 225:hardware.c    ****   */ 
 226:hardware.c    ****   
 227:hardware.c    **** #define USART_Parity_No                      ((uint16_t)0x0000)
 228:hardware.c    **** #define USART_Parity_Even                    ((uint16_t)0x0400)
 229:hardware.c    **** #define USART_Parity_Odd                     ((uint16_t)0x0600) 
 230:hardware.c    **** #define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
 231:hardware.c    ****                                  ((PARITY) == USART_Parity_Even) || \
 232:hardware.c    ****                                  ((PARITY) == USART_Parity_Odd))
 233:hardware.c    **** /**
 234:hardware.c    ****   * @}
 235:hardware.c    ****   */ 
 236:hardware.c    **** 
 237:hardware.c    **** /** @defgroup USART_Mode 
 238:hardware.c    ****   * @{
 239:hardware.c    ****   */ 
 240:hardware.c    ****   
 241:hardware.c    **** #define USART_Mode_Rx                        ((uint16_t)0x0004)
 242:hardware.c    **** #define USART_Mode_Tx                        ((uint16_t)0x0008)
 243:hardware.c    **** #define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))
 244:hardware.c    **** /**
 245:hardware.c    ****   * @}
 246:hardware.c    ****   */ 
 247:hardware.c    **** 
 248:hardware.c    **** /** @defgroup USART_Hardware_Flow_Control 
 249:hardware.c    ****   * @{
 250:hardware.c    ****   */ 
 251:hardware.c    **** #define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
 252:hardware.c    **** #define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
 253:hardware.c    **** #define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
 254:hardware.c    **** #define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
 255:hardware.c    **** #define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
 256:hardware.c    ****                               (((CONTROL) == USART_HardwareFlowControl_None) || \
 257:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_RTS) || \
 258:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_CTS) || \
 259:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
 260:hardware.c    **** /**
 261:hardware.c    ****   * @}
 262:hardware.c    ****   */ 
 263:hardware.c    **** 
 264:hardware.c    **** /** @defgroup USART_Clock 
 265:hardware.c    ****   * @{
 266:hardware.c    ****   */ 
 267:hardware.c    **** #define USART_Clock_Disable                  ((uint16_t)0x0000)
 268:hardware.c    **** #define USART_Clock_Enable                   ((uint16_t)0x0800)
 269:hardware.c    **** #define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
 270:hardware.c    ****                                ((CLOCK) == USART_Clock_Enable))
 271:hardware.c    **** /**
 272:hardware.c    ****   * @}
 273:hardware.c    ****   */ 
 274:hardware.c    **** 
 275:hardware.c    **** extern void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
 276:hardware.c    **** extern void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
 277:hardware.c    **** #define RCC_APB2Periph_USART1            ((uint32_t)0x00004000)
 278:hardware.c    **** #define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)
 279:hardware.c    **** #define RCC_APB2Periph_AFIO              ((uint32_t)0x00000001)
 280:hardware.c    **** #define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected */
 281:hardware.c    **** #define GPIO_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected */
 282:hardware.c    **** 
 283:hardware.c    **** #define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!< Transmit Data Regis
 284:hardware.c    **** 
 285:hardware.c    **** //DebugLog
 286:hardware.c    **** #ifdef DEBUG
 287:hardware.c    **** void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
 288:hardware.c    **** {
 289:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 290:hardware.c    ****   USARTx->DR = ch;  
 291:hardware.c    **** }
 292:hardware.c    **** 
 293:hardware.c    **** void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
 294:hardware.c    **** {
 295:hardware.c    ****   while(*str != 0)
 296:hardware.c    ****   {
 297:hardware.c    ****     UU_PutChar(USARTx, *str);
 298:hardware.c    ****     str++;
 299:hardware.c    ****   }
 300:hardware.c    **** }
 301:hardware.c    **** 
 302:hardware.c    **** void vprint(const char *fmt, va_list argp)
 303:hardware.c    **** {
 304:hardware.c    ****     char string[200];
 305:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
 306:hardware.c    ****     {
 307:hardware.c    ****         UU_PutString(USART1, (uint8_t*)string); // send message via UART
 308:hardware.c    **** 
 309:hardware.c    ****     }
 310:hardware.c    **** }
 311:hardware.c    **** 
 312:hardware.c    **** void uart_printf(const char *fmt, ...) // custom printf() function
  26              		.loc 1 312 0
  27              		.cfi_startproc
  28              		@ args = 4, pretend = 16, frame = 208
  29              		@ frame_needed = 0, uses_anonymous_args = 1
  30              	.LVL0:
  31 0000 0FB4     		push	{r0, r1, r2, r3}
  32              		.cfi_def_cfa_offset 16
  33              		.cfi_offset 0, -16
  34              		.cfi_offset 1, -12
  35              		.cfi_offset 2, -8
  36              		.cfi_offset 3, -4
  37 0002 10B5     		push	{r4, lr}
  38              		.cfi_def_cfa_offset 24
  39              		.cfi_offset 4, -24
  40              		.cfi_offset 14, -20
  41 0004 B4B0     		sub	sp, sp, #208
  42              		.cfi_def_cfa_offset 232
 313:hardware.c    **** {
 314:hardware.c    ****     va_list argp;
 315:hardware.c    ****     va_start(argp, fmt);
  43              		.loc 1 315 0
  44 0006 37AB     		add	r3, sp, #220
  45              	.LBB32:
  46              	.LBB33:
 305:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
  47              		.loc 1 305 0
  48 0008 1A46     		mov	r2, r3
  49 000a 02A8     		add	r0, sp, #8
  50 000c 0C49     		ldr	r1, .L14
  51              	.LBE33:
  52              	.LBE32:
  53              		.loc 1 315 0
  54 000e 0193     		str	r3, [sp, #4]
  55              	.LVL1:
  56              	.LBB39:
  57              	.LBB38:
 305:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
  58              		.loc 1 305 0
  59 0010 FFF7FEFF 		bl	vsprintf
  60              	.LVL2:
  61 0014 0028     		cmp	r0, #0
  62 0016 0DDD     		ble	.L1
  63              	.LVL3:
  64              	.LBB34:
  65              	.LBB35:
 295:hardware.c    ****   while(*str != 0)
  66              		.loc 1 295 0
  67 0018 9DF80810 		ldrb	r1, [sp, #8]	@ zero_extendqisi2
  68 001c 51B1     		cbz	r1, .L1
  69              	.LBB36:
  70              	.LBB37:
 289:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
  71              		.loc 1 289 0
  72 001e 094A     		ldr	r2, .L14+4
  73 0020 02A8     		add	r0, sp, #8
  74              	.LVL4:
  75 0022 1446     		mov	r4, r2
  76              	.LVL5:
  77              	.L5:
  78 0024 1388     		ldrh	r3, [r2]
  79 0026 1B06     		lsls	r3, r3, #24
  80 0028 FCD5     		bpl	.L5
 290:hardware.c    ****   USARTx->DR = ch;  
  81              		.loc 1 290 0
  82 002a A180     		strh	r1, [r4, #4]	@ movhi
  83              	.LVL6:
  84              	.LBE37:
  85              	.LBE36:
 295:hardware.c    ****   while(*str != 0)
  86              		.loc 1 295 0
  87 002c 10F8011F 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
  88              	.LVL7:
  89 0030 0029     		cmp	r1, #0
  90 0032 F7D1     		bne	.L5
  91              	.LVL8:
  92              	.L1:
  93              	.LBE35:
  94              	.LBE34:
  95              	.LBE38:
  96              	.LBE39:
 316:hardware.c    ****     vprint(fmt, argp);
 317:hardware.c    ****     va_end(argp);
 318:hardware.c    **** }
  97              		.loc 1 318 0
  98 0034 34B0     		add	sp, sp, #208
  99              		@ sp needed
 100 0036 BDE81040 		pop	{r4, lr}
 101 003a 04B0     		add	sp, sp, #16
 102 003c 7047     		bx	lr
 103              	.L15:
 104 003e 00BF     		.align	2
 105              	.L14:
 106 0040 00000000 		.word	.LC0
 107 0044 00380140 		.word	1073821696
 108              		.cfi_endproc
 109              	.LFE31:
 111              		.section	.text.uart_printf.constprop.1,"ax",%progbits
 112              		.align	2
 113              		.thumb
 114              		.thumb_func
 116              	uart_printf.constprop.1:
 117              	.LFB30:
 312:hardware.c    **** void uart_printf(const char *fmt, ...) // custom printf() function
 118              		.loc 1 312 0
 119              		.cfi_startproc
 120              		@ args = 4, pretend = 16, frame = 208
 121              		@ frame_needed = 0, uses_anonymous_args = 1
 122              	.LVL9:
 123 0000 0FB4     		push	{r0, r1, r2, r3}
 124              		.cfi_def_cfa_offset 16
 125              		.cfi_offset 0, -16
 126              		.cfi_offset 1, -12
 127              		.cfi_offset 2, -8
 128              		.cfi_offset 3, -4
 129 0002 10B5     		push	{r4, lr}
 130              		.cfi_def_cfa_offset 24
 131              		.cfi_offset 4, -24
 132              		.cfi_offset 14, -20
 133 0004 B4B0     		sub	sp, sp, #208
 134              		.cfi_def_cfa_offset 232
 315:hardware.c    ****     va_start(argp, fmt);
 135              		.loc 1 315 0
 136 0006 37AB     		add	r3, sp, #220
 137              	.LBB46:
 138              	.LBB47:
 305:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
 139              		.loc 1 305 0
 140 0008 1A46     		mov	r2, r3
 141 000a 02A8     		add	r0, sp, #8
 142 000c 0C49     		ldr	r1, .L28
 143              	.LBE47:
 144              	.LBE46:
 315:hardware.c    ****     va_start(argp, fmt);
 145              		.loc 1 315 0
 146 000e 0193     		str	r3, [sp, #4]
 147              	.LVL10:
 148              	.LBB53:
 149              	.LBB52:
 305:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
 150              		.loc 1 305 0
 151 0010 FFF7FEFF 		bl	vsprintf
 152              	.LVL11:
 153 0014 0028     		cmp	r0, #0
 154 0016 0DDD     		ble	.L16
 155              	.LVL12:
 156              	.LBB48:
 157              	.LBB49:
 295:hardware.c    ****   while(*str != 0)
 158              		.loc 1 295 0
 159 0018 9DF80810 		ldrb	r1, [sp, #8]	@ zero_extendqisi2
 160 001c 51B1     		cbz	r1, .L16
 161              	.LBB50:
 162              	.LBB51:
 289:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 163              		.loc 1 289 0
 164 001e 094A     		ldr	r2, .L28+4
 165 0020 02A8     		add	r0, sp, #8
 166              	.LVL13:
 167 0022 1446     		mov	r4, r2
 168              	.LVL14:
 169              	.L20:
 170 0024 1388     		ldrh	r3, [r2]
 171 0026 1B06     		lsls	r3, r3, #24
 172 0028 FCD5     		bpl	.L20
 290:hardware.c    ****   USARTx->DR = ch;  
 173              		.loc 1 290 0
 174 002a A180     		strh	r1, [r4, #4]	@ movhi
 175              	.LVL15:
 176              	.LBE51:
 177              	.LBE50:
 295:hardware.c    ****   while(*str != 0)
 178              		.loc 1 295 0
 179 002c 10F8011F 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 180              	.LVL16:
 181 0030 0029     		cmp	r1, #0
 182 0032 F7D1     		bne	.L20
 183              	.LVL17:
 184              	.L16:
 185              	.LBE49:
 186              	.LBE48:
 187              	.LBE52:
 188              	.LBE53:
 189              		.loc 1 318 0
 190 0034 34B0     		add	sp, sp, #208
 191              		@ sp needed
 192 0036 BDE81040 		pop	{r4, lr}
 193 003a 04B0     		add	sp, sp, #16
 194 003c 7047     		bx	lr
 195              	.L29:
 196 003e 00BF     		.align	2
 197              	.L28:
 198 0040 08000000 		.word	.LC1
 199 0044 00380140 		.word	1073821696
 200              		.cfi_endproc
 201              	.LFE30:
 203              		.section	.text.gpio_write_bit,"ax",%progbits
 204              		.align	2
 205              		.global	gpio_write_bit
 206              		.thumb
 207              		.thumb_func
 209              	gpio_write_bit:
 210              	.LFB0:
  58:hardware.c    **** void gpio_write_bit(u32 bank, u8 pin, u8 val) {
 211              		.loc 1 58 0
 212              		.cfi_startproc
 213              		@ args = 0, pretend = 0, frame = 0
 214              		@ frame_needed = 0, uses_anonymous_args = 0
 215              		@ link register save eliminated.
 216              	.LVL18:
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
 217              		.loc 1 60 0
 218 0000 0123     		movs	r3, #1
 219 0002 03FA01F1 		lsl	r1, r3, r1
 220              	.LVL19:
  59:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
 221              		.loc 1 59 0
 222 0006 D2F10102 		rsbs	r2, r2, #1
 223              	.LVL20:
 224 000a 38BF     		it	cc
 225 000c 0022     		movcc	r2, #0
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
 226              		.loc 1 60 0
 227 000e 1301     		lsls	r3, r2, #4
 228 0010 9940     		lsls	r1, r1, r3
 229 0012 0161     		str	r1, [r0, #16]
 230 0014 7047     		bx	lr
 231              		.cfi_endproc
 232              	.LFE0:
 234 0016 00BF     		.section	.text.readPin,"ax",%progbits
 235              		.align	2
 236              		.global	readPin
 237              		.thumb
 238              		.thumb_func
 240              	readPin:
 241              	.LFB1:
  63:hardware.c    **** bool readPin(u32 bank, u8 pin) {
 242              		.loc 1 63 0
 243              		.cfi_startproc
 244              		@ args = 0, pretend = 0, frame = 0
 245              		@ frame_needed = 0, uses_anonymous_args = 0
 246              		@ link register save eliminated.
 247              	.LVL21:
  65:hardware.c    ****     if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
 248              		.loc 1 65 0
 249 0000 0123     		movs	r3, #1
 250 0002 03FA01F1 		lsl	r1, r3, r1
 251              	.LVL22:
 252 0006 8268     		ldr	r2, [r0, #8]
 253 0008 0A42     		tst	r2, r1
  70:hardware.c    **** }
 254              		.loc 1 70 0
 255 000a 0CBF     		ite	eq
 256 000c 0020     		moveq	r0, #0
 257 000e 0120     		movne	r0, #1
 258              	.LVL23:
 259 0010 7047     		bx	lr
 260              		.cfi_endproc
 261              	.LFE1:
 263 0012 00BF     		.section	.text.strobePin,"ax",%progbits
 264              		.align	2
 265              		.global	strobePin
 266              		.thumb
 267              		.thumb_func
 269              	strobePin:
 270              	.LFB2:
  73:hardware.c    **** {
 271              		.loc 1 73 0
 272              		.cfi_startproc
 273              		@ args = 4, pretend = 0, frame = 0
 274              		@ frame_needed = 0, uses_anonymous_args = 0
 275              		@ link register save eliminated.
 276              	.LVL24:
 277 0000 F0B4     		push	{r4, r5, r6, r7}
 278              		.cfi_def_cfa_offset 16
 279              		.cfi_offset 4, -16
 280              		.cfi_offset 5, -12
 281              		.cfi_offset 6, -8
 282              		.cfi_offset 7, -4
 283              	.LBB54:
 284              	.LBB55:
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
 285              		.loc 1 60 0
 286 0002 0124     		movs	r4, #1
 287 0004 04FA01F1 		lsl	r1, r4, r1
 288              	.LVL25:
 289              	.LBE55:
 290              	.LBE54:
  73:hardware.c    **** {
 291              		.loc 1 73 0
 292 0008 9DF81060 		ldrb	r6, [sp, #16]	@ zero_extendqisi2
  77:hardware.c    ****     while (count-- > 0) 
 293              		.loc 1 77 0
 294 000c 571E     		subs	r7, r2, #1
 295              	.LBB57:
 296              	.LBB56:
  59:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
 297              		.loc 1 59 0
 298 000e 341B     		subs	r4, r6, r4
 299 0010 6542     		rsbs	r5, r4, #0
 300 0012 6541     		adcs	r5, r5, r4
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
 301              		.loc 1 60 0
 302 0014 2D01     		lsls	r5, r5, #4
 303 0016 01FA05F5 		lsl	r5, r1, r5
 304              	.LVL26:
 305 001a 00F11004 		add	r4, r0, #16
 306 001e 0561     		str	r5, [r0, #16]
 307              	.LBE56:
 308              	.LBE57:
  77:hardware.c    ****     while (count-- > 0) 
 309              		.loc 1 77 0
 310 0020 F8B2     		uxtb	r0, r7
 311              	.LVL27:
 312 0022 A2B1     		cbz	r2, .L32
 313 0024 D6F10102 		rsbs	r2, r6, #1
 314 0028 38BF     		it	cc
 315 002a 0022     		movcc	r2, #0
 316 002c 1201     		lsls	r2, r2, #4
 317 002e 9140     		lsls	r1, r1, r2
 318              	.LVL28:
 319              	.L34:
  79:hardware.c    ****         for (c = rate; c > 0; c--)
 320              		.loc 1 79 0 discriminator 1
 321 0030 7BB1     		cbz	r3, .L38
  79:hardware.c    ****         for (c = rate; c > 0; c--)
 322              		.loc 1 79 0 is_stmt 0
 323 0032 1A46     		mov	r2, r3
 324              	.LVL29:
 325              	.L39:
  81:hardware.c    ****             asm volatile("nop");
 326              		.loc 1 81 0 is_stmt 1 discriminator 2
 327              	@ 81 "hardware.c" 1
 328 0034 00BF     		nop
 329              	@ 0 "" 2
 330              	.LVL30:
  79:hardware.c    ****         for (c = rate; c > 0; c--)
 331              		.loc 1 79 0 discriminator 2
 332              		.thumb
 333 0036 013A     		subs	r2, r2, #1
 334              	.LVL31:
 335 0038 FCD1     		bne	.L39
 336              	.LVL32:
 337              	.LBB58:
 338              	.LBB59:
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
 339              		.loc 1 60 0
 340 003a 2160     		str	r1, [r4]
 341              	.LVL33:
 342 003c 1A46     		mov	r2, r3
 343              	.L40:
 344              	.LVL34:
 345              	.LBE59:
 346              	.LBE58:
  88:hardware.c    ****             asm volatile("nop");
 347              		.loc 1 88 0 discriminator 2
 348              	@ 88 "hardware.c" 1
 349 003e 00BF     		nop
 350              	@ 0 "" 2
 351              	.LVL35:
  86:hardware.c    ****         for (c = rate; c > 0; c--)
 352              		.loc 1 86 0 discriminator 2
 353              		.thumb
 354 0040 013A     		subs	r2, r2, #1
 355              	.LVL36:
 356 0042 FCD1     		bne	.L40
 357              	.LVL37:
  77:hardware.c    ****     while (count-- > 0) 
 358              		.loc 1 77 0
 359 0044 0138     		subs	r0, r0, #1
 360              	.LVL38:
 361 0046 C0B2     		uxtb	r0, r0
 362              	.LVL39:
 363 0048 FF28     		cmp	r0, #255
 364              	.LBB61:
 365              	.LBB62:
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
 366              		.loc 1 60 0
 367 004a 2560     		str	r5, [r4]
 368              	.LVL40:
 369              	.LBE62:
 370              	.LBE61:
  77:hardware.c    ****     while (count-- > 0) 
 371              		.loc 1 77 0
 372 004c F0D1     		bne	.L34
 373              	.LVL41:
 374              	.L32:
  92:hardware.c    **** }
 375              		.loc 1 92 0
 376 004e F0BC     		pop	{r4, r5, r6, r7}
 377              	.LVL42:
 378 0050 7047     		bx	lr
 379              	.LVL43:
 380              	.L38:
  77:hardware.c    ****     while (count-- > 0) 
 381              		.loc 1 77 0
 382 0052 0138     		subs	r0, r0, #1
 383              	.LVL44:
 384 0054 C0B2     		uxtb	r0, r0
 385              	.LVL45:
 386 0056 FF28     		cmp	r0, #255
 387              	.LBB64:
 388              	.LBB60:
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
 389              		.loc 1 60 0
 390 0058 2160     		str	r1, [r4]
 391              	.LVL46:
 392              	.LBE60:
 393              	.LBE64:
 394              	.LBB65:
 395              	.LBB63:
 396 005a 2560     		str	r5, [r4]
 397              	.LVL47:
 398              	.LBE63:
 399              	.LBE65:
  77:hardware.c    ****     while (count-- > 0) 
 400              		.loc 1 77 0
 401 005c E8D1     		bne	.L34
 402 005e F6E7     		b	.L32
 403              		.cfi_endproc
 404              	.LFE2:
 406              		.section	.text.UU_PutChar,"ax",%progbits
 407              		.align	2
 408              		.global	UU_PutChar
 409              		.thumb
 410              		.thumb_func
 412              	UU_PutChar:
 413              	.LFB3:
 288:hardware.c    **** {
 414              		.loc 1 288 0
 415              		.cfi_startproc
 416              		@ args = 0, pretend = 0, frame = 0
 417              		@ frame_needed = 0, uses_anonymous_args = 0
 418              		@ link register save eliminated.
 419              	.LVL48:
 420              	.L52:
 289:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 421              		.loc 1 289 0 discriminator 1
 422 0000 0388     		ldrh	r3, [r0]
 423 0002 1B06     		lsls	r3, r3, #24
 424 0004 FCD5     		bpl	.L52
 290:hardware.c    ****   USARTx->DR = ch;  
 425              		.loc 1 290 0
 426 0006 8180     		strh	r1, [r0, #4]	@ movhi
 427 0008 7047     		bx	lr
 428              		.cfi_endproc
 429              	.LFE3:
 431 000a 00BF     		.section	.text.UU_PutString,"ax",%progbits
 432              		.align	2
 433              		.global	UU_PutString
 434              		.thumb
 435              		.thumb_func
 437              	UU_PutString:
 438              	.LFB4:
 294:hardware.c    **** {
 439              		.loc 1 294 0
 440              		.cfi_startproc
 441              		@ args = 0, pretend = 0, frame = 0
 442              		@ frame_needed = 0, uses_anonymous_args = 0
 443              		@ link register save eliminated.
 444              	.LVL49:
 295:hardware.c    ****   while(*str != 0)
 445              		.loc 1 295 0
 446 0000 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 447 0002 3AB1     		cbz	r2, .L53
 448              	.LVL50:
 449              	.L56:
 450              	.LBB66:
 451              	.LBB67:
 289:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 452              		.loc 1 289 0
 453 0004 0388     		ldrh	r3, [r0]
 454 0006 1B06     		lsls	r3, r3, #24
 455 0008 FCD5     		bpl	.L56
 290:hardware.c    ****   USARTx->DR = ch;  
 456              		.loc 1 290 0
 457 000a 8280     		strh	r2, [r0, #4]	@ movhi
 458              	.LVL51:
 459              	.LBE67:
 460              	.LBE66:
 295:hardware.c    ****   while(*str != 0)
 461              		.loc 1 295 0
 462 000c 11F8012F 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 463              	.LVL52:
 464 0010 002A     		cmp	r2, #0
 465 0012 F7D1     		bne	.L56
 466              	.LVL53:
 467              	.L53:
 468 0014 7047     		bx	lr
 469              		.cfi_endproc
 470              	.LFE4:
 472 0016 00BF     		.section	.text.vprint,"ax",%progbits
 473              		.align	2
 474              		.global	vprint
 475              		.thumb
 476              		.thumb_func
 478              	vprint:
 479              	.LFB5:
 303:hardware.c    **** {
 480              		.loc 1 303 0
 481              		.cfi_startproc
 482              		@ args = 0, pretend = 0, frame = 200
 483              		@ frame_needed = 0, uses_anonymous_args = 0
 484              	.LVL54:
 485 0000 10B5     		push	{r4, lr}
 486              		.cfi_def_cfa_offset 8
 487              		.cfi_offset 4, -8
 488              		.cfi_offset 14, -4
 489 0002 B2B0     		sub	sp, sp, #200
 490              		.cfi_def_cfa_offset 208
 303:hardware.c    **** {
 491              		.loc 1 303 0
 492 0004 0A46     		mov	r2, r1
 305:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
 493              		.loc 1 305 0
 494 0006 0146     		mov	r1, r0
 495              	.LVL55:
 496 0008 6846     		mov	r0, sp
 497              	.LVL56:
 498 000a FFF7FEFF 		bl	vsprintf
 499              	.LVL57:
 500 000e 0028     		cmp	r0, #0
 501 0010 0DDD     		ble	.L62
 502              	.LVL58:
 503              	.LBB72:
 504              	.LBB73:
 295:hardware.c    ****   while(*str != 0)
 505              		.loc 1 295 0
 506 0012 9DF80010 		ldrb	r1, [sp]	@ zero_extendqisi2
 507 0016 51B1     		cbz	r1, .L62
 508              	.LBB74:
 509              	.LBB75:
 289:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 510              		.loc 1 289 0
 511 0018 064A     		ldr	r2, .L74
 512 001a 6846     		mov	r0, sp
 513 001c 1446     		mov	r4, r2
 514              	.LVL59:
 515              	.L66:
 516 001e 1388     		ldrh	r3, [r2]
 517 0020 1B06     		lsls	r3, r3, #24
 518 0022 FCD5     		bpl	.L66
 290:hardware.c    ****   USARTx->DR = ch;  
 519              		.loc 1 290 0
 520 0024 A180     		strh	r1, [r4, #4]	@ movhi
 521              	.LVL60:
 522              	.LBE75:
 523              	.LBE74:
 295:hardware.c    ****   while(*str != 0)
 524              		.loc 1 295 0
 525 0026 10F8011F 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 526              	.LVL61:
 527 002a 0029     		cmp	r1, #0
 528 002c F7D1     		bne	.L66
 529              	.LVL62:
 530              	.L62:
 531              	.LBE73:
 532              	.LBE72:
 310:hardware.c    **** }
 533              		.loc 1 310 0
 534 002e 32B0     		add	sp, sp, #200
 535              		@ sp needed
 536 0030 10BD     		pop	{r4, pc}
 537              	.L75:
 538 0032 00BF     		.align	2
 539              	.L74:
 540 0034 00380140 		.word	1073821696
 541              		.cfi_endproc
 542              	.LFE5:
 544              		.section	.text.uart_printf,"ax",%progbits
 545              		.align	2
 546              		.global	uart_printf
 547              		.thumb
 548              		.thumb_func
 550              	uart_printf:
 551              	.LFB6:
 313:hardware.c    **** {
 552              		.loc 1 313 0
 553              		.cfi_startproc
 554              		@ args = 4, pretend = 16, frame = 208
 555              		@ frame_needed = 0, uses_anonymous_args = 1
 556              	.LVL63:
 557 0000 0FB4     		push	{r0, r1, r2, r3}
 558              		.cfi_def_cfa_offset 16
 559              		.cfi_offset 0, -16
 560              		.cfi_offset 1, -12
 561              		.cfi_offset 2, -8
 562              		.cfi_offset 3, -4
 563 0002 10B5     		push	{r4, lr}
 564              		.cfi_def_cfa_offset 24
 565              		.cfi_offset 4, -24
 566              		.cfi_offset 14, -20
 567 0004 B4B0     		sub	sp, sp, #208
 568              		.cfi_def_cfa_offset 232
 313:hardware.c    **** {
 569              		.loc 1 313 0
 570 0006 36AB     		add	r3, sp, #216
 571 0008 53F8041B 		ldr	r1, [r3], #4
 572              	.LBB82:
 573              	.LBB83:
 305:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
 574              		.loc 1 305 0
 575 000c 02A8     		add	r0, sp, #8
 576 000e 1A46     		mov	r2, r3
 577              	.LBE83:
 578              	.LBE82:
 315:hardware.c    ****     va_start(argp, fmt);
 579              		.loc 1 315 0
 580 0010 0193     		str	r3, [sp, #4]
 581              	.LVL64:
 582              	.LBB89:
 583              	.LBB88:
 305:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
 584              		.loc 1 305 0
 585 0012 FFF7FEFF 		bl	vsprintf
 586              	.LVL65:
 587 0016 0028     		cmp	r0, #0
 588 0018 0DDD     		ble	.L76
 589              	.LVL66:
 590              	.LBB84:
 591              	.LBB85:
 295:hardware.c    ****   while(*str != 0)
 592              		.loc 1 295 0
 593 001a 9DF80810 		ldrb	r1, [sp, #8]	@ zero_extendqisi2
 594 001e 51B1     		cbz	r1, .L76
 595              	.LBB86:
 596              	.LBB87:
 289:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 597              		.loc 1 289 0
 598 0020 074A     		ldr	r2, .L88
 599 0022 02A8     		add	r0, sp, #8
 600              	.LVL67:
 601 0024 1446     		mov	r4, r2
 602              	.LVL68:
 603              	.L80:
 604 0026 1388     		ldrh	r3, [r2]
 605 0028 1B06     		lsls	r3, r3, #24
 606 002a FCD5     		bpl	.L80
 290:hardware.c    ****   USARTx->DR = ch;  
 607              		.loc 1 290 0
 608 002c A180     		strh	r1, [r4, #4]	@ movhi
 609              	.LVL69:
 610              	.LBE87:
 611              	.LBE86:
 295:hardware.c    ****   while(*str != 0)
 612              		.loc 1 295 0
 613 002e 10F8011F 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 614              	.LVL70:
 615 0032 0029     		cmp	r1, #0
 616 0034 F7D1     		bne	.L80
 617              	.LVL71:
 618              	.L76:
 619              	.LBE85:
 620              	.LBE84:
 621              	.LBE88:
 622              	.LBE89:
 623              		.loc 1 318 0
 624 0036 34B0     		add	sp, sp, #208
 625              		@ sp needed
 626 0038 BDE81040 		pop	{r4, lr}
 627              	.LVL72:
 628 003c 04B0     		add	sp, sp, #16
 629              	.LVL73:
 630 003e 7047     		bx	lr
 631              	.L89:
 632              		.align	2
 633              	.L88:
 634 0040 00380140 		.word	1073821696
 635              		.cfi_endproc
 636              	.LFE6:
 638              		.section	.text.hexdump,"ax",%progbits
 639              		.align	2
 640              		.global	hexdump
 641              		.thumb
 642              		.thumb_func
 644              	hexdump:
 645              	.LFB7:
 319:hardware.c    **** 
 320:hardware.c    **** void hexdump(unsigned char *data, size_t size)
 321:hardware.c    **** {
 646              		.loc 1 321 0
 647              		.cfi_startproc
 648              		@ args = 0, pretend = 0, frame = 24
 649              		@ frame_needed = 0, uses_anonymous_args = 0
 650              	.LVL74:
 651 0000 2DE9F043 		push	{r4, r5, r6, r7, r8, r9, lr}
 652              		.cfi_def_cfa_offset 28
 653              		.cfi_offset 4, -28
 654              		.cfi_offset 5, -24
 655              		.cfi_offset 6, -20
 656              		.cfi_offset 7, -16
 657              		.cfi_offset 8, -12
 658              		.cfi_offset 9, -8
 659              		.cfi_offset 14, -4
 322:hardware.c    ****     int i;
 323:hardware.c    ****     char cs[17];
 324:hardware.c    ****     memset(cs, 0, 17);
 660              		.loc 1 324 0
 661 0004 0024     		movs	r4, #0
 321:hardware.c    **** {
 662              		.loc 1 321 0
 663 0006 87B0     		sub	sp, sp, #28
 664              		.cfi_def_cfa_offset 56
 325:hardware.c    **** 
 326:hardware.c    ****     for(i = 0; i < size; i++)
 665              		.loc 1 326 0
 666 0008 8846     		mov	r8, r1
 321:hardware.c    **** {
 667              		.loc 1 321 0
 668 000a 0746     		mov	r7, r0
 324:hardware.c    ****     memset(cs, 0, 17);
 669              		.loc 1 324 0
 670 000c 0194     		str	r4, [sp, #4]
 671 000e 0294     		str	r4, [sp, #8]
 672 0010 0394     		str	r4, [sp, #12]
 673 0012 0494     		str	r4, [sp, #16]
 674 0014 8DF81440 		strb	r4, [sp, #20]
 675              	.LVL75:
 676              		.loc 1 326 0
 677 0018 0029     		cmp	r1, #0
 678 001a 42D0     		beq	.L111
 679 001c 2646     		mov	r6, r4
 680 001e 2546     		mov	r5, r4
 681 0020 0DF10409 		add	r9, sp, #4
 682              	.LVL76:
 683              	.L92:
 327:hardware.c    ****     {
 328:hardware.c    ****         if(i != 0 && i % 0x10 == 0)
 329:hardware.c    ****         {
 330:hardware.c    ****             uart_printf(" |%s|\n", cs);
 331:hardware.c    ****             memset(cs, 0, 17);
 332:hardware.c    ****         }
 333:hardware.c    ****         else if(i != 0 && i % 0x8 == 0)
 334:hardware.c    ****         {
 335:hardware.c    ****             uart_printf(" ");
 336:hardware.c    ****         }
 337:hardware.c    ****         uart_printf("%02X ", data[i]);
 684              		.loc 1 337 0
 685 0024 B95D     		ldrb	r1, [r7, r6]	@ zero_extendqisi2
 686 0026 2148     		ldr	r0, .L116
 687 0028 FFF7FEFF 		bl	uart_printf.constprop.0
 688              	.LVL77:
 338:hardware.c    ****         cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
 689              		.loc 1 338 0
 690 002c BB5D     		ldrb	r3, [r7, r6]	@ zero_extendqisi2
 326:hardware.c    ****     for(i = 0; i < size; i++)
 691              		.loc 1 326 0
 692 002e 0134     		adds	r4, r4, #1
 693              	.LVL78:
 694              		.loc 1 338 0
 695 0030 A3F12002 		sub	r2, r3, #32
 696 0034 5E2A     		cmp	r2, #94
 697 0036 06AA     		add	r2, sp, #24
 698 0038 88BF     		it	hi
 699 003a 2E23     		movhi	r3, #46
 700 003c 1544     		add	r5, r5, r2
 326:hardware.c    ****     for(i = 0; i < size; i++)
 701              		.loc 1 326 0
 702 003e 4445     		cmp	r4, r8
 703              		.loc 1 338 0
 704 0040 05F8143C 		strb	r3, [r5, #-20]
 326:hardware.c    ****     for(i = 0; i < size; i++)
 705              		.loc 1 326 0
 706 0044 2646     		mov	r6, r4
 707 0046 15D0     		beq	.L112
 328:hardware.c    ****         if(i != 0 && i % 0x10 == 0)
 708              		.loc 1 328 0
 709 0048 74B3     		cbz	r4, .L113
 328:hardware.c    ****         if(i != 0 && i % 0x10 == 0)
 710              		.loc 1 328 0 is_stmt 0 discriminator 1
 711 004a 14F00F05 		ands	r5, r4, #15
 712 004e 05D0     		beq	.L114
 333:hardware.c    ****         else if(i != 0 && i % 0x8 == 0)
 713              		.loc 1 333 0 is_stmt 1 discriminator 1
 714 0050 6307     		lsls	r3, r4, #29
 715 0052 E7D1     		bne	.L92
 335:hardware.c    ****             uart_printf(" ");
 716              		.loc 1 335 0
 717 0054 1648     		ldr	r0, .L116+4
 718 0056 FFF7FEFF 		bl	uart_printf
 719              	.LVL79:
 720 005a E3E7     		b	.L92
 721              	.L114:
 330:hardware.c    ****             uart_printf(" |%s|\n", cs);
 722              		.loc 1 330 0
 723 005c 1548     		ldr	r0, .L116+8
 724 005e 4946     		mov	r1, r9
 725 0060 FFF7FEFF 		bl	uart_printf
 726              	.LVL80:
 331:hardware.c    ****             memset(cs, 0, 17);
 727              		.loc 1 331 0
 728 0064 C9F80050 		str	r5, [r9]
 729 0068 0295     		str	r5, [sp, #8]
 730 006a 0395     		str	r5, [sp, #12]
 731 006c 0495     		str	r5, [sp, #16]
 732 006e 8DF81450 		strb	r5, [sp, #20]
 733 0072 D7E7     		b	.L92
 734              	.L112:
 735              	.LVL81:
 339:hardware.c    ****     }
 340:hardware.c    **** 
 341:hardware.c    ****     i = i % 0x10;
 342:hardware.c    ****     if(i != 0)
 736              		.loc 1 342 0
 737 0074 14F00F04 		ands	r4, r4, #15
 738              	.LVL82:
 739 0078 08D0     		beq	.L97
 343:hardware.c    ****     {
 344:hardware.c    ****         if(i <= 0x8)
 740              		.loc 1 344 0
 741 007a 082C     		cmp	r4, #8
 742 007c 0DDD     		ble	.L115
 743              	.L98:
 345:hardware.c    ****         {
 346:hardware.c    ****             uart_printf(" ");
 347:hardware.c    ****         }
 348:hardware.c    ****         while(i++ < 0x10)
 744              		.loc 1 348 0 discriminator 1
 745 007e 0134     		adds	r4, r4, #1
 746              	.LVL83:
 747              	.L99:
 748              		.loc 1 348 0 is_stmt 0
 749 0080 0134     		adds	r4, r4, #1
 750              	.LVL84:
 349:hardware.c    ****         {
 350:hardware.c    ****             uart_printf("   ");
 751              		.loc 1 350 0 is_stmt 1
 752 0082 0D48     		ldr	r0, .L116+12
 753 0084 FFF7FEFF 		bl	uart_printf.constprop.1
 754              	.LVL85:
 348:hardware.c    ****         while(i++ < 0x10)
 755              		.loc 1 348 0
 756 0088 112C     		cmp	r4, #17
 757 008a F9D1     		bne	.L99
 758              	.LVL86:
 759              	.L97:
 351:hardware.c    ****         }
 352:hardware.c    ****     }
 353:hardware.c    ****     uart_printf(" |%s|\n", cs);
 760              		.loc 1 353 0
 761 008c 4946     		mov	r1, r9
 762 008e 0948     		ldr	r0, .L116+8
 763 0090 FFF7FEFF 		bl	uart_printf
 764              	.LVL87:
 354:hardware.c    **** }
 765              		.loc 1 354 0
 766 0094 07B0     		add	sp, sp, #28
 767              		@ sp needed
 768 0096 BDE8F083 		pop	{r4, r5, r6, r7, r8, r9, pc}
 769              	.LVL88:
 770              	.L115:
 346:hardware.c    ****             uart_printf(" ");
 771              		.loc 1 346 0
 772 009a 0548     		ldr	r0, .L116+4
 773 009c FFF7FEFF 		bl	uart_printf
 774              	.LVL89:
 775 00a0 EDE7     		b	.L98
 776              	.LVL90:
 777              	.L111:
 778 00a2 0DF10409 		add	r9, sp, #4
 779 00a6 F1E7     		b	.L97
 780              	.LVL91:
 781              	.L113:
 782 00a8 2546     		mov	r5, r4
 783 00aa BBE7     		b	.L92
 784              	.L117:
 785              		.align	2
 786              	.L116:
 787 00ac 00000000 		.word	.LC0
 788 00b0 14000000 		.word	.LC3
 789 00b4 0C000000 		.word	.LC2
 790 00b8 08000000 		.word	.LC1
 791              		.cfi_endproc
 792              	.LFE7:
 794              		.section	.text.uartInit,"ax",%progbits
 795              		.align	2
 796              		.global	uartInit
 797              		.thumb
 798              		.thumb_func
 800              	uartInit:
 801              	.LFB8:
 355:hardware.c    **** 
 356:hardware.c    **** 
 357:hardware.c    **** #endif
 358:hardware.c    **** void uartInit(void) {
 802              		.loc 1 358 0
 803              		.cfi_startproc
 804              		@ args = 0, pretend = 0, frame = 24
 805              		@ frame_needed = 0, uses_anonymous_args = 0
 806 0000 70B5     		push	{r4, r5, r6, lr}
 807              		.cfi_def_cfa_offset 16
 808              		.cfi_offset 4, -16
 809              		.cfi_offset 5, -12
 810              		.cfi_offset 6, -8
 811              		.cfi_offset 14, -4
 359:hardware.c    ****     GPIO_InitTypeDef GPIO_InitStructure;
 360:hardware.c    ****     USART_InitTypeDef USART_InitStructure;
 361:hardware.c    ****     
 362:hardware.c    ****     /* Enable peripheral clocks for USART1 on GPIOA */
 363:hardware.c    ****     //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
 364:hardware.c    ****     RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 365:hardware.c    ****         RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
 812              		.loc 1 365 0
 813 0002 1F4C     		ldr	r4, .L119
 358:hardware.c    **** void uartInit(void) {
 814              		.loc 1 358 0
 815 0004 86B0     		sub	sp, sp, #24
 816              		.cfi_def_cfa_offset 40
 364:hardware.c    ****     RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 817              		.loc 1 364 0
 818 0006 4FF48040 		mov	r0, #16384
 819 000a 0121     		movs	r1, #1
 820 000c FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 821              	.LVL92:
 822              		.loc 1 365 0
 823 0010 2046     		mov	r0, r4
 824 0012 0121     		movs	r1, #1
 825 0014 FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 826              	.LVL93:
 366:hardware.c    ****     /* Configure PA9 and PA10 as USART1 TX/RX */
 367:hardware.c    ****     
 368:hardware.c    ****     /* PA9 = alternate function push/pull output */
 369:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 370:hardware.c    ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 371:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 372:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 373:hardware.c    ****     
 374:hardware.c    ****     /* PA10 = floating input */
 375:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 376:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 377:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 378:hardware.c    ****     
 379:hardware.c    ****     /* Configure and initialize usart... */
 380:hardware.c    ****     USART_InitStructure.USART_BaudRate = 115200;
 381:hardware.c    ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 382:hardware.c    ****     USART_InitStructure.USART_StopBits = USART_StopBits_1;
 383:hardware.c    ****     USART_InitStructure.USART_Parity = USART_Parity_No;
 384:hardware.c    ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 385:hardware.c    ****     USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 386:hardware.c    ****         
 387:hardware.c    ****     USART_Init(USART1, &USART_InitStructure);
 827              		.loc 1 387 0
 828 0018 1A4D     		ldr	r5, .L119+4
 372:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 829              		.loc 1 372 0
 830 001a 2046     		mov	r0, r4
 831 001c 01A9     		add	r1, sp, #4
 370:hardware.c    ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 832              		.loc 1 370 0
 833 001e 0322     		movs	r2, #3
 371:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 834              		.loc 1 371 0
 835 0020 1823     		movs	r3, #24
 369:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 836              		.loc 1 369 0
 837 0022 4FF40076 		mov	r6, #512
 370:hardware.c    ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 838              		.loc 1 370 0
 839 0026 8DF80620 		strb	r2, [sp, #6]
 371:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 840              		.loc 1 371 0
 841 002a 8DF80730 		strb	r3, [sp, #7]
 369:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 842              		.loc 1 369 0
 843 002e ADF80460 		strh	r6, [sp, #4]	@ movhi
 372:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 844              		.loc 1 372 0
 845 0032 FFF7FEFF 		bl	GPIO_Init
 846              	.LVL94:
 377:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 847              		.loc 1 377 0
 848 0036 2046     		mov	r0, r4
 849 0038 01A9     		add	r1, sp, #4
 375:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 850              		.loc 1 375 0
 851 003a 4FF48062 		mov	r2, #1024
 376:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 852              		.loc 1 376 0
 853 003e 0423     		movs	r3, #4
 375:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 854              		.loc 1 375 0
 855 0040 ADF80420 		strh	r2, [sp, #4]	@ movhi
 376:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 856              		.loc 1 376 0
 857 0044 8DF80730 		strb	r3, [sp, #7]
 380:hardware.c    ****     USART_InitStructure.USART_BaudRate = 115200;
 858              		.loc 1 380 0
 859 0048 4FF4E134 		mov	r4, #115200
 377:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 860              		.loc 1 377 0
 861 004c FFF7FEFF 		bl	GPIO_Init
 862              	.LVL95:
 381:hardware.c    ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 863              		.loc 1 381 0
 864 0050 0023     		movs	r3, #0
 385:hardware.c    ****     USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 865              		.loc 1 385 0
 866 0052 0C22     		movs	r2, #12
 867              		.loc 1 387 0
 868 0054 02A9     		add	r1, sp, #8
 869 0056 2846     		mov	r0, r5
 381:hardware.c    ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 870              		.loc 1 381 0
 871 0058 ADF80C30 		strh	r3, [sp, #12]	@ movhi
 382:hardware.c    ****     USART_InitStructure.USART_StopBits = USART_StopBits_1;
 872              		.loc 1 382 0
 873 005c ADF80E30 		strh	r3, [sp, #14]	@ movhi
 383:hardware.c    ****     USART_InitStructure.USART_Parity = USART_Parity_No;
 874              		.loc 1 383 0
 875 0060 ADF81030 		strh	r3, [sp, #16]	@ movhi
 384:hardware.c    ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 876              		.loc 1 384 0
 877 0064 ADF81430 		strh	r3, [sp, #20]	@ movhi
 385:hardware.c    ****     USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 878              		.loc 1 385 0
 879 0068 ADF81220 		strh	r2, [sp, #18]	@ movhi
 380:hardware.c    ****     USART_InitStructure.USART_BaudRate = 115200;
 880              		.loc 1 380 0
 881 006c 0294     		str	r4, [sp, #8]
 882              		.loc 1 387 0
 883 006e FFF7FEFF 		bl	USART_Init
 884              	.LVL96:
 388:hardware.c    ****     
 389:hardware.c    ****     /* Enable USART1 */
 390:hardware.c    ****     USART_Cmd(USART1, ENABLE);   
 885              		.loc 1 390 0
 886 0072 2846     		mov	r0, r5
 887 0074 0121     		movs	r1, #1
 888 0076 FFF7FEFF 		bl	USART_Cmd
 889              	.LVL97:
 391:hardware.c    **** }
 890              		.loc 1 391 0
 891 007a 06B0     		add	sp, sp, #24
 892              		@ sp needed
 893 007c 70BD     		pop	{r4, r5, r6, pc}
 894              	.L120:
 895 007e 00BF     		.align	2
 896              	.L119:
 897 0080 00080140 		.word	1073809408
 898 0084 00380140 		.word	1073821696
 899              		.cfi_endproc
 900              	.LFE8:
 902              		.section	.text.systemReset,"ax",%progbits
 903              		.align	2
 904              		.global	systemReset
 905              		.thumb
 906              		.thumb_func
 908              	systemReset:
 909              	.LFB9:
 392:hardware.c    **** 
 393:hardware.c    **** void systemReset(void) {
 910              		.loc 1 393 0
 911              		.cfi_startproc
 912              		@ args = 0, pretend = 0, frame = 0
 913              		@ frame_needed = 0, uses_anonymous_args = 0
 914              		@ link register save eliminated.
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 915              		.loc 1 394 0
 916 0000 0F4B     		ldr	r3, .L122
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 917              		.loc 1 395 0
 918 0002 104A     		ldr	r2, .L122+4
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 919              		.loc 1 394 0
 920 0004 1868     		ldr	r0, [r3]
 393:hardware.c    **** void systemReset(void) {
 921              		.loc 1 393 0
 922 0006 10B4     		push	{r4}
 923              		.cfi_def_cfa_offset 4
 924              		.cfi_offset 4, -4
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 925              		.loc 1 394 0
 926 0008 40F00100 		orr	r0, r0, #1
 927 000c 1860     		str	r0, [r3]
 928              		.loc 1 395 0
 929 000e 1468     		ldr	r4, [r2]
 930 0010 0D49     		ldr	r1, .L122+8
 396:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 397:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
 398:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 399:hardware.c    **** 
 400:hardware.c    ****     SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
 931              		.loc 1 400 0
 932 0012 0E48     		ldr	r0, .L122+12
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 933              		.loc 1 395 0
 934 0014 2140     		ands	r1, r1, r4
 935 0016 1160     		str	r1, [r2]
 396:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 936              		.loc 1 396 0
 937 0018 1968     		ldr	r1, [r3]
 938              		.loc 1 400 0
 939 001a 0024     		movs	r4, #0
 396:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 940              		.loc 1 396 0
 941 001c 21F08471 		bic	r1, r1, #17301504
 942 0020 21F48031 		bic	r1, r1, #65536
 943 0024 1960     		str	r1, [r3]
 397:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
 944              		.loc 1 397 0
 945 0026 1968     		ldr	r1, [r3]
 946 0028 21F48021 		bic	r1, r1, #262144
 947 002c 1960     		str	r1, [r3]
 398:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 948              		.loc 1 398 0
 949 002e 1368     		ldr	r3, [r2]
 950 0030 23F4FE03 		bic	r3, r3, #8323072
 951 0034 1360     		str	r3, [r2]
 952              		.loc 1 400 0
 953 0036 0460     		str	r4, [r0]
 401:hardware.c    **** }
 954              		.loc 1 401 0
 955 0038 5DF8044B 		ldr	r4, [sp], #4
 956 003c 7047     		bx	lr
 957              	.L123:
 958 003e 00BF     		.align	2
 959              	.L122:
 960 0040 00100240 		.word	1073876992
 961 0044 04100240 		.word	1073876996
 962 0048 0000FFF8 		.word	-117506048
 963 004c 08100240 		.word	1073877000
 964              		.cfi_endproc
 965              	.LFE9:
 967              		.section	.text.setupCLK,"ax",%progbits
 968              		.align	2
 969              		.global	setupCLK
 970              		.thumb
 971              		.thumb_func
 973              	setupCLK:
 974              	.LFB10:
 402:hardware.c    **** 
 403:hardware.c    **** void setupCLK(void) {
 975              		.loc 1 403 0
 976              		.cfi_startproc
 977              		@ args = 0, pretend = 0, frame = 0
 978              		@ frame_needed = 0, uses_anonymous_args = 0
 979              		@ link register save eliminated.
 980              	.LVL98:
 404:hardware.c    **** 	unsigned int StartUpCounter=0;
 405:hardware.c    ****     /* enable HSE */
 406:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
 981              		.loc 1 406 0
 982 0000 174B     		ldr	r3, .L131
 983 0002 1A68     		ldr	r2, [r3]
 407:hardware.c    ****     while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
 984              		.loc 1 407 0
 985 0004 1946     		mov	r1, r3
 406:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
 986              		.loc 1 406 0
 987 0006 42F00112 		orr	r2, r2, #65537
 988 000a 1A60     		str	r2, [r3]
 989              	.L126:
 990              		.loc 1 407 0 discriminator 1
 991 000c 0B68     		ldr	r3, [r1]
 992 000e 144A     		ldr	r2, .L131
 993 0010 9803     		lsls	r0, r3, #14
 994 0012 FBD5     		bpl	.L126
 408:hardware.c    **** 
 409:hardware.c    ****     /* enable flash prefetch buffer */
 410:hardware.c    ****     SET_REG(FLASH_ACR, 0x00000012);
 995              		.loc 1 410 0
 996 0014 134B     		ldr	r3, .L131+4
 997 0016 1221     		movs	r1, #18
 411:hardware.c    **** 	
 412:hardware.c    ****      /* Configure PLL */
 413:hardware.c    **** #ifdef XTAL12M
 414:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
 415:hardware.c    **** #else
 416:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
 998              		.loc 1 416 0
 999 0018 1348     		ldr	r0, .L131+8
 410:hardware.c    ****     SET_REG(FLASH_ACR, 0x00000012);
 1000              		.loc 1 410 0
 1001 001a 1960     		str	r1, [r3]
 1002              		.loc 1 416 0
 1003 001c 0368     		ldr	r3, [r0]
 417:hardware.c    **** #endif	
 418:hardware.c    **** 
 419:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
 420:hardware.c    **** 	
 421:hardware.c    **** 
 422:hardware.c    **** #if !defined  (HSE_STARTUP_TIMEOUT) 
 423:hardware.c    ****   #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
 424:hardware.c    **** #endif /* HSE_STARTUP_TIMEOUT */   
 425:hardware.c    **** 
 426:hardware.c    ****     while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
 1004              		.loc 1 426 0
 1005 001e 1146     		mov	r1, r2
 416:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
 1006              		.loc 1 416 0
 1007 0020 43F4E813 		orr	r3, r3, #1900544
 1008 0024 43F48063 		orr	r3, r3, #1024
 1009 0028 0360     		str	r3, [r0]
 419:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
 1010              		.loc 1 419 0
 1011 002a 1368     		ldr	r3, [r2]
 1012 002c 43F08073 		orr	r3, r3, #16777216
 1013 0030 1360     		str	r3, [r2]
 1014              	.L128:
 1015              		.loc 1 426 0 discriminator 1
 1016 0032 0B68     		ldr	r3, [r1]
 1017 0034 13F0407F 		tst	r3, #50331648
 1018 0038 FBD0     		beq	.L128
 427:hardware.c    **** 	{
 428:hardware.c    **** //		StartUpCounter++; // This is commented out, so other changes can be committed. It will be uncom
 429:hardware.c    **** 	}	/* wait for it to come on */
 430:hardware.c    **** 
 431:hardware.c    **** 	if (StartUpCounter>=HSE_STARTUP_TIMEOUT)
 432:hardware.c    **** 	{
 433:hardware.c    **** 		// HSE has not started. Try restarting the processor
 434:hardware.c    **** 		systemHardReset(); 
 435:hardware.c    **** 	}
 436:hardware.c    ****     /* Set SYSCLK as PLL */
 437:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
 1019              		.loc 1 437 0
 1020 003a 0B4B     		ldr	r3, .L131+8
 1021 003c 1968     		ldr	r1, [r3]
 438:hardware.c    ****     while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
 1022              		.loc 1 438 0
 1023 003e 1A46     		mov	r2, r3
 437:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
 1024              		.loc 1 437 0
 1025 0040 41F00201 		orr	r1, r1, #2
 1026 0044 1960     		str	r1, [r3]
 1027              	.L130:
 1028              		.loc 1 438 0 discriminator 1
 1029 0046 1368     		ldr	r3, [r2]
 1030 0048 1B07     		lsls	r3, r3, #28
 1031 004a FCD5     		bpl	.L130
 439:hardware.c    **** 	
 440:hardware.c    ****     pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
 1032              		.loc 1 440 0
 1033 004c 044B     		ldr	r3, .L131
 1034 004e 9A69     		ldr	r2, [r3, #24]
 1035 0050 42F4FE72 		orr	r2, r2, #508
 1036 0054 9A61     		str	r2, [r3, #24]
 441:hardware.c    **** 	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
 1037              		.loc 1 441 0
 1038 0056 DA69     		ldr	r2, [r3, #28]
 1039 0058 42F40002 		orr	r2, r2, #8388608
 1040 005c DA61     		str	r2, [r3, #28]
 1041 005e 7047     		bx	lr
 1042              	.L132:
 1043              		.align	2
 1044              	.L131:
 1045 0060 00100240 		.word	1073876992
 1046 0064 00200240 		.word	1073881088
 1047 0068 04100240 		.word	1073876996
 1048              		.cfi_endproc
 1049              	.LFE10:
 1051              		.section	.text.setupLEDAndButton,"ax",%progbits
 1052              		.align	2
 1053              		.global	setupLEDAndButton
 1054              		.thumb
 1055              		.thumb_func
 1057              	setupLEDAndButton:
 1058              	.LFB11:
 442:hardware.c    **** 
 443:hardware.c    **** }
 444:hardware.c    **** 
 445:hardware.c    **** void setupLEDAndButton (void) { 
 1059              		.loc 1 445 0
 1060              		.cfi_startproc
 1061              		@ args = 0, pretend = 0, frame = 0
 1062              		@ frame_needed = 0, uses_anonymous_args = 0
 1063              		@ link register save eliminated.
 446:hardware.c    ****   SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUT
 1064              		.loc 1 446 0
 1065 0000 034B     		ldr	r3, .L134
 1066 0002 1A68     		ldr	r2, [r3]
 1067              	.LVL99:
 1068 0004 22F47002 		bic	r2, r2, #15728640
 1069 0008 42F48012 		orr	r2, r2, #1048576
 1070 000c 1A60     		str	r2, [r3]
 1071 000e 7047     		bx	lr
 1072              	.L135:
 1073              		.align	2
 1074              	.L134:
 1075 0010 04100140 		.word	1073811460
 1076              		.cfi_endproc
 1077              	.LFE11:
 1079              		.section	.text.setupFLASH,"ax",%progbits
 1080              		.align	2
 1081              		.global	setupFLASH
 1082              		.thumb
 1083              		.thumb_func
 1085              	setupFLASH:
 1086              	.LFB12:
 447:hardware.c    **** }
 448:hardware.c    **** 
 449:hardware.c    **** void setupFLASH() {
 1087              		.loc 1 449 0
 1088              		.cfi_startproc
 1089              		@ args = 0, pretend = 0, frame = 0
 1090              		@ frame_needed = 0, uses_anonymous_args = 0
 1091              		@ link register save eliminated.
 450:hardware.c    ****     /* configure the HSI oscillator */
 451:hardware.c    ****     if ((pRCC->CR & 0x01) == 0x00) {
 1092              		.loc 1 451 0
 1093 0000 064B     		ldr	r3, .L140
 1094 0002 1A68     		ldr	r2, [r3]
 1095 0004 D207     		lsls	r2, r2, #31
 1096 0006 03D4     		bmi	.L137
 1097              	.LBB90:
 452:hardware.c    ****         u32 rwmVal = pRCC->CR;
 1098              		.loc 1 452 0
 1099 0008 1A68     		ldr	r2, [r3]
 1100              	.LVL100:
 453:hardware.c    ****         rwmVal |= 0x01;
 1101              		.loc 1 453 0
 1102 000a 42F00102 		orr	r2, r2, #1
 1103              	.LVL101:
 454:hardware.c    ****         pRCC->CR = rwmVal;
 1104              		.loc 1 454 0
 1105 000e 1A60     		str	r2, [r3]
 1106              	.LVL102:
 1107              	.L137:
 1108              	.LBE90:
 455:hardware.c    ****     }
 456:hardware.c    **** 
 457:hardware.c    ****     /* wait for it to come on */
 458:hardware.c    ****     while ((pRCC->CR & 0x02) == 0x00) {}
 1109              		.loc 1 458 0 discriminator 1
 1110 0010 024A     		ldr	r2, .L140
 1111              	.L139:
 1112 0012 1368     		ldr	r3, [r2]
 1113 0014 9B07     		lsls	r3, r3, #30
 1114 0016 FCD5     		bpl	.L139
 459:hardware.c    **** }   
 1115              		.loc 1 459 0
 1116 0018 7047     		bx	lr
 1117              	.L141:
 1118 001a 00BF     		.align	2
 1119              	.L140:
 1120 001c 00100240 		.word	1073876992
 1121              		.cfi_endproc
 1122              	.LFE12:
 1124              		.section	.text.uid_read,"ax",%progbits
 1125              		.align	2
 1126              		.global	uid_read
 1127              		.thumb
 1128              		.thumb_func
 1130              	uid_read:
 1131              	.LFB13:
 460:hardware.c    **** 
 461:hardware.c    **** /* Read U_ID register */
 462:hardware.c    **** void uid_read(struct u_id *id)
 463:hardware.c    **** {
 1132              		.loc 1 463 0
 1133              		.cfi_startproc
 1134              		@ args = 0, pretend = 0, frame = 0
 1135              		@ frame_needed = 0, uses_anonymous_args = 0
 1136              		@ link register save eliminated.
 1137              	.LVL103:
 464:hardware.c    ****     id->off0 = MMIO16(U_ID + 0x0);
 1138              		.loc 1 464 0
 1139 0000 064B     		ldr	r3, .L143
 465:hardware.c    ****     id->off2 = MMIO16(U_ID + 0x2);
 1140              		.loc 1 465 0
 1141 0002 074A     		ldr	r2, .L143+4
 464:hardware.c    ****     id->off0 = MMIO16(U_ID + 0x0);
 1142              		.loc 1 464 0
 1143 0004 1988     		ldrh	r1, [r3]
 466:hardware.c    ****     id->off4 = MMIO32(U_ID + 0x4);
 1144              		.loc 1 466 0
 1145 0006 0433     		adds	r3, r3, #4
 464:hardware.c    ****     id->off0 = MMIO16(U_ID + 0x0);
 1146              		.loc 1 464 0
 1147 0008 0180     		strh	r1, [r0]	@ movhi
 465:hardware.c    ****     id->off2 = MMIO16(U_ID + 0x2);
 1148              		.loc 1 465 0
 1149 000a 1288     		ldrh	r2, [r2]
 1150              		.loc 1 466 0
 1151 000c 1B68     		ldr	r3, [r3]
 467:hardware.c    ****     id->off8 = MMIO32(U_ID + 0x8);
 1152              		.loc 1 467 0
 1153 000e 0549     		ldr	r1, .L143+8
 466:hardware.c    ****     id->off4 = MMIO32(U_ID + 0x4);
 1154              		.loc 1 466 0
 1155 0010 4360     		str	r3, [r0, #4]
 1156              		.loc 1 467 0
 1157 0012 0B68     		ldr	r3, [r1]
 465:hardware.c    ****     id->off2 = MMIO16(U_ID + 0x2);
 1158              		.loc 1 465 0
 1159 0014 4280     		strh	r2, [r0, #2]	@ movhi
 1160              		.loc 1 467 0
 1161 0016 8360     		str	r3, [r0, #8]
 1162 0018 7047     		bx	lr
 1163              	.L144:
 1164 001a 00BF     		.align	2
 1165              	.L143:
 1166 001c E8F7FF1F 		.word	536868840
 1167 0020 EAF7FF1F 		.word	536868842
 1168 0024 F0F7FF1F 		.word	536868848
 1169              		.cfi_endproc
 1170              	.LFE13:
 1172              		.section	.text.checkUserCode,"ax",%progbits
 1173              		.align	2
 1174              		.global	checkUserCode
 1175              		.thumb
 1176              		.thumb_func
 1178              	checkUserCode:
 1179              	.LFB14:
 468:hardware.c    **** }
 469:hardware.c    **** 
 470:hardware.c    **** int checkUserCode(u32 usrAddr) {
 1180              		.loc 1 470 0
 1181              		.cfi_startproc
 1182              		@ args = 0, pretend = 0, frame = 0
 1183              		@ frame_needed = 0, uses_anonymous_args = 0
 1184              		@ link register save eliminated.
 1185              	.LVL104:
 471:hardware.c    ****     /* deprecated 
 472:hardware.c    ****     int imageCheckFromAddress(
 473:hardware.c    ****         ImageObjectHandle *newHandle,
 474:hardware.c    ****         uint32_t flashAddress);*/
 475:hardware.c    ****     // get hash written to top of stage 2
 476:hardware.c    ****     /*unsigned char writtenHash[32];
 477:hardware.c    ****     memset(writtenHash, 0xFF, sizeof(writtenHash));
 478:hardware.c    ****     memcpy(writtenHash, (vu32 *)usrAddr, 0x20);
 479:hardware.c    **** 
 480:hardware.c    ****     // hax to see if our firmware is where it should be
 481:hardware.c    ****     if (!memcmp(writtenHash, 0xFF, 32))
 482:hardware.c    ****     {
 483:hardware.c    ****       return 0x0;
 484:hardware.c    ****     }
 485:hardware.c    **** 
 486:hardware.c    ****     // get signature from stage 2 image
 487:hardware.c    ****     uint8_t signature[EDSIGN_SIGNATURE_SIZE];
 488:hardware.c    ****     memset(signature, 0xFF, sizeof(signature));
 489:hardware.c    ****     memcpy(signature,  (vu32 *)(usrAddr+0x20), 0x40);
 490:hardware.c    **** 
 491:hardware.c    ****     // prepare hash
 492:hardware.c    ****     unsigned char sha256sum[32];
 493:hardware.c    ****     uint8_t input[0x5C];
 494:hardware.c    **** 
 495:hardware.c    ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
 496:hardware.c    ****     memset(input, 0xFF, sizeof(input));
 497:hardware.c    **** 
 498:hardware.c    ****     sha256_context ctx;
 499:hardware.c    ****     sha256_starts(&ctx);
 500:hardware.c    **** 
 501:hardware.c    ****     // get expected size
 502:hardware.c    ****     int offset = Swap2Bytes(*(int*)((vu32 *)(usrAddr+0x60))) + 0x140;
 503:hardware.c    ****     int i = 0x74;
 504:hardware.c    ****     //feedface is our eof, hi mach ily
 505:hardware.c    ****     char cmpEnd[4] = {0xFE, 0xED, 0xFA, 0xCE};
 506:hardware.c    ****     char buff[0x4];
 507:hardware.c    ****     // read through memory, hash buff, and stop on feedface
 508:hardware.c    ****     while ((usrAddr+i) <= (usrAddr+offset))
 509:hardware.c    ****     {
 510:hardware.c    ****       memset(buff, 0xFF, 0x4);
 511:hardware.c    ****       memcpy(buff, (char *)(usrAddr+i), 0x4);
 512:hardware.c    ****       if (memmem(&buff, 0x4, &cmpEnd, 4) != 0)
 513:hardware.c    ****       {
 514:hardware.c    ****         sha256_update(&ctx, (vu32 *)(usrAddr+i), 0x4);
 515:hardware.c    ****         break;
 516:hardware.c    ****       }
 517:hardware.c    ****       sha256_update(&ctx, (vu32 *)(usrAddr+i), 0x4);
 518:hardware.c    ****       i += 0x4;
 519:hardware.c    ****     }
 520:hardware.c    **** 
 521:hardware.c    ****     // hash in our unique ID
 522:hardware.c    ****     struct u_id id;
 523:hardware.c    ****     uid_read(&id);
 524:hardware.c    ****     unsigned char uniqueID[23];
 525:hardware.c    ****     sprintf(uniqueID,"%X", id.off0, id.off2, id.off4, id.off8);
 526:hardware.c    ****     uart_printf("%X%X%X%X\n", id.off0, id.off2, id.off4, id.off8);
 527:hardware.c    ****     sha256_update(&ctx, uniqueID, 23);
 528:hardware.c    ****     sha256_finish(&ctx, sha256sum);
 529:hardware.c    **** 
 530:hardware.c    ****     print_hash(sha256sum);
 531:hardware.c    **** 
 532:hardware.c    ****   uint8_t rootCA[32] = {
 533:hardware.c    ****        0xf3,0x47,0xb9,0x5e,0x5f,0x03,0x62,0x13,
 534:hardware.c    ****        0xf3,0x88,0x72,0x73,0xea,0xcf,0x91,0x73,
 535:hardware.c    ****        0x35,0xda,0x72,0x68,0xae,0xf6,0x98,0x90,
 536:hardware.c    ****        0x51,0x87,0xff,0xea,0xd6,0xb5,0x5b,0x32
 537:hardware.c    ****     };
 538:hardware.c    ****     // verify signature against recalc hash
 539:hardware.c    ****     if (!edsign_verify(signature, rootCA, sha256sum, 0x20) > 0) {
 540:hardware.c    ****         return 0x1;
 541:hardware.c    ****     }
 542:hardware.c    ****     // verify written hash against recalc hash
 543:hardware.c    ****     if (memcmp(sha256sum, writtenHash, 32)){
 544:hardware.c    ****         return 0x2;
 545:hardware.c    ****     }*/
 546:hardware.c    **** 
 547:hardware.c    ****     return 0x3;
 548:hardware.c    **** }
 1186              		.loc 1 548 0
 1187 0000 0320     		movs	r0, #3
 1188              	.LVL105:
 1189 0002 7047     		bx	lr
 1190              		.cfi_endproc
 1191              	.LFE14:
 1193              		.section	.text.setMspAndJump,"ax",%progbits
 1194              		.align	2
 1195              		.global	setMspAndJump
 1196              		.thumb
 1197              		.thumb_func
 1199              	setMspAndJump:
 1200              	.LFB15:
 549:hardware.c    **** 
 550:hardware.c    **** void setMspAndJump(u32 usrAddr) {
 1201              		.loc 1 550 0
 1202              		.cfi_startproc
 1203              		@ args = 0, pretend = 0, frame = 0
 1204              		@ frame_needed = 0, uses_anonymous_args = 0
 1205              	.LVL106:
 551:hardware.c    ****   // Dedicated function with no call to any function (appart the last call)
 552:hardware.c    ****   // This way, there is no manipulation of the stack here, ensuring that GGC
 553:hardware.c    ****   // didn't insert any pop from the SP after having set the MSP.
 554:hardware.c    ****   typedef void (*funcPtr)(void);
 555:hardware.c    ****   u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
 556:hardware.c    **** 
 557:hardware.c    ****   funcPtr usrMain = (funcPtr) jumpAddr;
 558:hardware.c    **** 
 559:hardware.c    ****   SET_REG(SCB_VTOR, (vu32) (usrAddr));
 1206              		.loc 1 559 0
 1207 0000 044A     		ldr	r2, .L147
 550:hardware.c    **** void setMspAndJump(u32 usrAddr) {
 1208              		.loc 1 550 0
 1209 0002 08B5     		push	{r3, lr}
 1210              		.cfi_def_cfa_offset 8
 1211              		.cfi_offset 3, -8
 1212              		.cfi_offset 14, -4
 555:hardware.c    ****   u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
 1213              		.loc 1 555 0
 1214 0004 4368     		ldr	r3, [r0, #4]
 1215              	.LVL107:
 1216              		.loc 1 559 0
 1217 0006 1060     		str	r0, [r2]
 560:hardware.c    **** 
 561:hardware.c    ****   asm volatile("msr msp, %0"::"g"
 562:hardware.c    ****                (*(volatile u32 *)usrAddr));
 1218              		.loc 1 562 0
 1219 0008 0268     		ldr	r2, [r0]
 561:hardware.c    ****   asm volatile("msr msp, %0"::"g"
 1220              		.loc 1 561 0
 1221              	@ 561 "hardware.c" 1
 1222 000a 82F30888 		msr msp, r2
 1223              	@ 0 "" 2
 563:hardware.c    **** 
 564:hardware.c    ****   usrMain();                                /* go! */
 1224              		.loc 1 564 0
 1225              		.thumb
 1226 000e 9847     		blx	r3
 1227              	.LVL108:
 1228 0010 08BD     		pop	{r3, pc}
 1229              	.L148:
 1230 0012 00BF     		.align	2
 1231              	.L147:
 1232 0014 08ED00E0 		.word	-536810232
 1233              		.cfi_endproc
 1234              	.LFE15:
 1236              		.section	.text.jumpToUser,"ax",%progbits
 1237              		.align	2
 1238              		.global	jumpToUser
 1239              		.thumb
 1240              		.thumb_func
 1242              	jumpToUser:
 1243              	.LFB16:
 565:hardware.c    **** }
 566:hardware.c    **** 
 567:hardware.c    **** 
 568:hardware.c    **** void jumpToUser(u32 usrAddr) {
 1244              		.loc 1 568 0
 1245              		.cfi_startproc
 1246              		@ args = 0, pretend = 0, frame = 0
 1247              		@ frame_needed = 0, uses_anonymous_args = 0
 1248              	.LVL109:
 1249              	.LBB99:
 1250              	.LBB100:
 569:hardware.c    **** 
 570:hardware.c    ****     /* tear down all the dfu related setup */
 571:hardware.c    ****     // disable usb interrupts, clear them, turn off usb, set the disc pin
 572:hardware.c    ****     // todo pick exactly what we want to do here, now its just a conservative
 573:hardware.c    **** 
 574:hardware.c    ****     flashLock();
 575:hardware.c    ****     usbDsbISR();
 576:hardware.c    ****     nvicDisableInterrupts();
 577:hardware.c    **** 	
 578:hardware.c    **** #ifndef HAS_MAPLE_HARDWARE	
 579:hardware.c    **** 	usbDsbBus();
 580:hardware.c    **** #endif
 581:hardware.c    **** 	
 582:hardware.c    **** // Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(
 583:hardware.c    ****     systemReset(); // resets clocks and periphs, not core regs
 584:hardware.c    ****     SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);
 585:hardware.c    ****     setMspAndJump(usrAddr);
 586:hardware.c    **** }
 587:hardware.c    **** 
 588:hardware.c    **** void bkp10Write(u16 value)
 589:hardware.c    **** {
 590:hardware.c    **** 		// Enable clocks for the backup domain registers
 591:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 592:hardware.c    **** 		
 593:hardware.c    ****         // Disable backup register write protection
 594:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 595:hardware.c    **** 
 596:hardware.c    ****         // store value in pBK DR10
 597:hardware.c    ****         pBKP->DR10 = value;
 598:hardware.c    **** 
 599:hardware.c    ****         // Re-enable backup register write protection
 600:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 601:hardware.c    **** }
 602:hardware.c    **** 
 603:hardware.c    **** int checkAndClearBootloaderFlag()
 604:hardware.c    **** {
 605:hardware.c    ****     bool flagSet = 0x00;// Flag not used
 606:hardware.c    **** 
 607:hardware.c    ****     // Enable clocks for the backup domain registers
 608:hardware.c    ****     pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 609:hardware.c    **** 
 610:hardware.c    ****     switch (pBKP->DR10)
 611:hardware.c    **** 	{
 612:hardware.c    **** 		case RTC_BOOTLOADER_FLAG:
 613:hardware.c    **** 			flagSet = 0x01;
 614:hardware.c    **** 			break;
 615:hardware.c    **** 		case RTC_BOOTLOADER_JUST_UPLOADED:
 616:hardware.c    **** 			flagSet = 0x02;
 617:hardware.c    **** 			break;		
 618:hardware.c    ****     }
 619:hardware.c    **** 
 620:hardware.c    **** 	if (flagSet!=0x00)
 621:hardware.c    **** 	{
 622:hardware.c    **** 		bkp10Write(0x0000);// Clear the flag
 623:hardware.c    **** 		// Disable clocks
 624:hardware.c    **** 		pRCC->APB1ENR &= ~(RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 625:hardware.c    **** 	}
 626:hardware.c    ****     return flagSet;
 627:hardware.c    **** }
 628:hardware.c    **** 
 629:hardware.c    **** void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
 630:hardware.c    ****     u32 tmppriority = 0x00;
 631:hardware.c    ****     u32 tmpreg      = 0x00;
 632:hardware.c    ****     u32 tmpmask     = 0x00;
 633:hardware.c    ****     u32 tmppre      = 0;
 634:hardware.c    ****     u32 tmpsub      = 0x0F;
 635:hardware.c    **** 
 636:hardware.c    ****     SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
 637:hardware.c    ****     NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
 638:hardware.c    **** 
 639:hardware.c    **** 
 640:hardware.c    ****     /* Compute the Corresponding IRQ Priority --------------------------------*/
 641:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 642:hardware.c    ****     tmppre = (0x4 - tmppriority);
 643:hardware.c    ****     tmpsub = tmpsub >> tmppriority;
 644:hardware.c    **** 
 645:hardware.c    ****     tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 646:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 647:hardware.c    **** 
 648:hardware.c    ****     tmppriority = tmppriority << 0x04;
 649:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 650:hardware.c    **** 
 651:hardware.c    ****     tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 652:hardware.c    ****     tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 653:hardware.c    ****     tmpreg &= ~tmpmask;
 654:hardware.c    ****     tmppriority &= tmpmask;
 655:hardware.c    ****     tmpreg |= tmppriority;
 656:hardware.c    **** 
 657:hardware.c    ****     rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
 658:hardware.c    **** 
 659:hardware.c    ****     /* Enable the Selected IRQ Channels --------------------------------------*/
 660:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 661:hardware.c    ****         (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 662:hardware.c    **** }
 663:hardware.c    **** 
 664:hardware.c    **** void nvicDisableInterrupts() {
 665:hardware.c    ****     NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
 666:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 667:hardware.c    ****     rNVIC->ICER[1] = 0xFFFFFFFF;
 668:hardware.c    ****     rNVIC->ICPR[0] = 0xFFFFFFFF;
 669:hardware.c    ****     rNVIC->ICPR[1] = 0xFFFFFFFF;
 670:hardware.c    **** 
 671:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 672:hardware.c    **** }
 673:hardware.c    **** 
 674:hardware.c    **** void systemHardReset(void) {
 675:hardware.c    ****     SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
 676:hardware.c    **** 
 677:hardware.c    ****     /* Reset  */
 678:hardware.c    ****     rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
 679:hardware.c    **** 
 680:hardware.c    ****     /*  should never get here */
 681:hardware.c    ****     while (1) {
 682:hardware.c    ****         asm volatile("nop");
 683:hardware.c    ****     }
 684:hardware.c    **** }
 685:hardware.c    **** 
 686:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 687:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 688:hardware.c    ****     rwmVal = FLASH_CR_PER;
 689:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 690:hardware.c    **** 
 691:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 692:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 693:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 694:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 695:hardware.c    **** 
 696:hardware.c    ****     /* todo: verify the page was erased */
 697:hardware.c    **** 
 698:hardware.c    ****     rwmVal = 0x00;
 699:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 700:hardware.c    **** 
 701:hardware.c    ****     return TRUE;
 702:hardware.c    **** }
 703:hardware.c    **** bool flashErasePages(u32 pageAddr, u16 n) {
 704:hardware.c    ****     while (n-- > 0) {
 705:hardware.c    ****         if (!flashErasePage(pageAddr + wTransferSize * n)) {
 706:hardware.c    ****             return FALSE;
 707:hardware.c    ****         }
 708:hardware.c    ****     }
 709:hardware.c    **** 
 710:hardware.c    ****     return TRUE;
 711:hardware.c    **** }
 712:hardware.c    **** 
 713:hardware.c    **** bool flashWriteWord(u32 addr, u32 word) {
 714:hardware.c    ****     vu16 *flashAddr = (vu16 *)addr;
 715:hardware.c    ****     vu32 lhWord = (vu32)word & 0x0000FFFF;
 716:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 717:hardware.c    **** 
 718:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 719:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 720:hardware.c    **** 
 721:hardware.c    ****     /* apparently we need not write to FLASH_AR and can
 722:hardware.c    ****        simply do a native write of a half word */
 723:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 724:hardware.c    ****     *(flashAddr + 0x01) = (vu16)hhWord;
 725:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 726:hardware.c    ****     *(flashAddr) = (vu16)lhWord;
 727:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 728:hardware.c    **** 
 729:hardware.c    ****     rwmVal &= 0xFFFFFFFE;
 730:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 731:hardware.c    **** 
 732:hardware.c    ****     /* verify the write */
 733:hardware.c    ****     if (*(vu32 *)addr != word) {
 734:hardware.c    ****         return FALSE;
 735:hardware.c    ****     }
 736:hardware.c    **** 
 737:hardware.c    ****     return TRUE;
 738:hardware.c    **** }
 739:hardware.c    **** 
 740:hardware.c    **** void flashLock() {
 741:hardware.c    ****     /* take down the HSI oscillator? it may be in use elsewhere */
 742:hardware.c    **** 
 743:hardware.c    ****     /* ensure all FPEC functions disabled and lock the FPEC */
 744:hardware.c    ****     SET_REG(FLASH_CR, 0x00000080);
 1251              		.loc 1 744 0
 1252 0000 204B     		ldr	r3, .L150
 1253 0002 8022     		movs	r2, #128
 1254              	.LBE100:
 1255              	.LBE99:
 568:hardware.c    **** void jumpToUser(u32 usrAddr) {
 1256              		.loc 1 568 0
 1257 0004 70B5     		push	{r4, r5, r6, lr}
 1258              		.cfi_def_cfa_offset 16
 1259              		.cfi_offset 4, -16
 1260              		.cfi_offset 5, -12
 1261              		.cfi_offset 6, -8
 1262              		.cfi_offset 14, -4
 1263              	.LBB102:
 1264              	.LBB101:
 1265              		.loc 1 744 0
 1266 0006 1A60     		str	r2, [r3]
 1267              	.LBE101:
 1268              	.LBE102:
 568:hardware.c    **** void jumpToUser(u32 usrAddr) {
 1269              		.loc 1 568 0
 1270 0008 0446     		mov	r4, r0
 575:hardware.c    ****     usbDsbISR();
 1271              		.loc 1 575 0
 1272 000a FFF7FEFF 		bl	usbDsbISR
 1273              	.LVL110:
 1274              	.LBB103:
 1275              	.LBB104:
 666:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1276              		.loc 1 666 0
 1277 000e 1E4B     		ldr	r3, .L150+4
 671:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1278              		.loc 1 671 0
 1279 0010 1E49     		ldr	r1, .L150+8
 666:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1280              		.loc 1 666 0
 1281 0012 4FF0FF32 		mov	r2, #-1
 671:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1282              		.loc 1 671 0
 1283 0016 0420     		movs	r0, #4
 666:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1284              		.loc 1 666 0
 1285 0018 C3F88020 		str	r2, [r3, #128]
 667:hardware.c    ****     rNVIC->ICER[1] = 0xFFFFFFFF;
 1286              		.loc 1 667 0
 1287 001c C3F88420 		str	r2, [r3, #132]
 668:hardware.c    ****     rNVIC->ICPR[0] = 0xFFFFFFFF;
 1288              		.loc 1 668 0
 1289 0020 C3F88021 		str	r2, [r3, #384]
 669:hardware.c    ****     rNVIC->ICPR[1] = 0xFFFFFFFF;
 1290              		.loc 1 669 0
 1291 0024 C3F88421 		str	r2, [r3, #388]
 671:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1292              		.loc 1 671 0
 1293 0028 0860     		str	r0, [r1]
 1294              	.LBE104:
 1295              	.LBE103:
 579:hardware.c    **** 	usbDsbBus();
 1296              		.loc 1 579 0
 1297 002a FFF7FEFF 		bl	usbDsbBus
 1298              	.LVL111:
 1299              	.LBB105:
 1300              	.LBB106:
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 1301              		.loc 1 394 0
 1302 002e 184B     		ldr	r3, .L150+12
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 1303              		.loc 1 395 0
 1304 0030 184A     		ldr	r2, .L150+16
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 1305              		.loc 1 394 0
 1306 0032 1868     		ldr	r0, [r3]
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 1307              		.loc 1 395 0
 1308 0034 1849     		ldr	r1, .L150+20
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 1309              		.loc 1 394 0
 1310 0036 40F00100 		orr	r0, r0, #1
 1311 003a 1860     		str	r0, [r3]
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 1312              		.loc 1 395 0
 1313 003c 1068     		ldr	r0, [r2]
 400:hardware.c    ****     SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
 1314              		.loc 1 400 0
 1315 003e 174D     		ldr	r5, .L150+24
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 1316              		.loc 1 395 0
 1317 0040 0140     		ands	r1, r1, r0
 1318 0042 1160     		str	r1, [r2]
 396:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 1319              		.loc 1 396 0
 1320 0044 1968     		ldr	r1, [r3]
 400:hardware.c    ****     SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
 1321              		.loc 1 400 0
 1322 0046 0026     		movs	r6, #0
 396:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 1323              		.loc 1 396 0
 1324 0048 21F08471 		bic	r1, r1, #17301504
 1325 004c 21F48031 		bic	r1, r1, #65536
 1326 0050 1960     		str	r1, [r3]
 397:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
 1327              		.loc 1 397 0
 1328 0052 1868     		ldr	r0, [r3]
 1329              	.LBE106:
 1330              	.LBE105:
 584:hardware.c    ****     SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);
 1331              		.loc 1 584 0
 1332 0054 1249     		ldr	r1, .L150+28
 1333              	.LBB109:
 1334              	.LBB107:
 397:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
 1335              		.loc 1 397 0
 1336 0056 20F48020 		bic	r0, r0, #262144
 1337 005a 1860     		str	r0, [r3]
 398:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 1338              		.loc 1 398 0
 1339 005c 1368     		ldr	r3, [r2]
 1340              	.LBE107:
 1341              	.LBE109:
 1342              	.LBB110:
 1343              	.LBB111:
 559:hardware.c    ****   SET_REG(SCB_VTOR, (vu32) (usrAddr));
 1344              		.loc 1 559 0
 1345 005e 1148     		ldr	r0, .L150+32
 1346              	.LBE111:
 1347              	.LBE110:
 1348              	.LBB113:
 1349              	.LBB108:
 398:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 1350              		.loc 1 398 0
 1351 0060 23F4FE03 		bic	r3, r3, #8323072
 1352 0064 1360     		str	r3, [r2]
 400:hardware.c    ****     SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
 1353              		.loc 1 400 0
 1354 0066 2E60     		str	r6, [r5]
 1355              	.LBE108:
 1356              	.LBE113:
 584:hardware.c    ****     SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);
 1357              		.loc 1 584 0
 1358 0068 0B68     		ldr	r3, [r1]
 1359 006a 23F0E063 		bic	r3, r3, #117440512
 1360 006e 43F08063 		orr	r3, r3, #67108864
 1361 0072 0B60     		str	r3, [r1]
 1362              	.LVL112:
 1363              	.LBB114:
 1364              	.LBB112:
 555:hardware.c    ****   u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
 1365              		.loc 1 555 0
 1366 0074 6368     		ldr	r3, [r4, #4]
 1367              	.LVL113:
 559:hardware.c    ****   SET_REG(SCB_VTOR, (vu32) (usrAddr));
 1368              		.loc 1 559 0
 1369 0076 0460     		str	r4, [r0]
 562:hardware.c    ****                (*(volatile u32 *)usrAddr));
 1370              		.loc 1 562 0
 1371 0078 2268     		ldr	r2, [r4]
 561:hardware.c    ****   asm volatile("msr msp, %0"::"g"
 1372              		.loc 1 561 0
 1373              	@ 561 "hardware.c" 1
 1374 007a 82F30888 		msr msp, r2
 1375              	@ 0 "" 2
 564:hardware.c    ****   usrMain();                                /* go! */
 1376              		.loc 1 564 0
 1377              		.thumb
 1378 007e 9847     		blx	r3
 1379              	.LVL114:
 1380 0080 70BD     		pop	{r4, r5, r6, pc}
 1381              	.LVL115:
 1382              	.L151:
 1383 0082 00BF     		.align	2
 1384              	.L150:
 1385 0084 10200240 		.word	1073881104
 1386 0088 00E100E0 		.word	-536813312
 1387 008c 10E000E0 		.word	-536813552
 1388 0090 00100240 		.word	1073876992
 1389 0094 04100240 		.word	1073876996
 1390 0098 0000FFF8 		.word	-117506048
 1391 009c 08100240 		.word	1073877000
 1392 00a0 04000140 		.word	1073807364
 1393 00a4 08ED00E0 		.word	-536810232
 1394              	.LBE112:
 1395              	.LBE114:
 1396              		.cfi_endproc
 1397              	.LFE16:
 1399              		.section	.text.bkp10Write,"ax",%progbits
 1400              		.align	2
 1401              		.global	bkp10Write
 1402              		.thumb
 1403              		.thumb_func
 1405              	bkp10Write:
 1406              	.LFB17:
 589:hardware.c    **** {
 1407              		.loc 1 589 0
 1408              		.cfi_startproc
 1409              		@ args = 0, pretend = 0, frame = 0
 1410              		@ frame_needed = 0, uses_anonymous_args = 0
 1411              		@ link register save eliminated.
 1412              	.LVL116:
 591:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1413              		.loc 1 591 0
 1414 0000 094A     		ldr	r2, .L153
 589:hardware.c    **** {
 1415              		.loc 1 589 0
 1416 0002 10B4     		push	{r4}
 1417              		.cfi_def_cfa_offset 4
 1418              		.cfi_offset 4, -4
 591:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1419              		.loc 1 591 0
 1420 0004 D469     		ldr	r4, [r2, #28]
 594:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1421              		.loc 1 594 0
 1422 0006 094B     		ldr	r3, .L153+4
 591:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1423              		.loc 1 591 0
 1424 0008 44F0C054 		orr	r4, r4, #402653184
 1425 000c D461     		str	r4, [r2, #28]
 594:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1426              		.loc 1 594 0
 1427 000e 1A68     		ldr	r2, [r3]
 597:hardware.c    ****         pBKP->DR10 = value;
 1428              		.loc 1 597 0
 1429 0010 0749     		ldr	r1, .L153+8
 594:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1430              		.loc 1 594 0
 1431 0012 42F48072 		orr	r2, r2, #256
 1432 0016 1A60     		str	r2, [r3]
 597:hardware.c    ****         pBKP->DR10 = value;
 1433              		.loc 1 597 0
 1434 0018 0885     		strh	r0, [r1, #40]	@ movhi
 600:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 1435              		.loc 1 600 0
 1436 001a 1A68     		ldr	r2, [r3]
 601:hardware.c    **** }
 1437              		.loc 1 601 0
 1438 001c 5DF8044B 		ldr	r4, [sp], #4
 600:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 1439              		.loc 1 600 0
 1440 0020 22F48072 		bic	r2, r2, #256
 1441 0024 1A60     		str	r2, [r3]
 601:hardware.c    **** }
 1442              		.loc 1 601 0
 1443 0026 7047     		bx	lr
 1444              	.L154:
 1445              		.align	2
 1446              	.L153:
 1447 0028 00100240 		.word	1073876992
 1448 002c 00700040 		.word	1073770496
 1449 0030 006C0040 		.word	1073769472
 1450              		.cfi_endproc
 1451              	.LFE17:
 1453              		.section	.text.checkAndClearBootloaderFlag,"ax",%progbits
 1454              		.align	2
 1455              		.global	checkAndClearBootloaderFlag
 1456              		.thumb
 1457              		.thumb_func
 1459              	checkAndClearBootloaderFlag:
 1460              	.LFB18:
 604:hardware.c    **** {
 1461              		.loc 1 604 0
 1462              		.cfi_startproc
 1463              		@ args = 0, pretend = 0, frame = 0
 1464              		@ frame_needed = 0, uses_anonymous_args = 0
 1465              		@ link register save eliminated.
 1466              	.LVL117:
 608:hardware.c    ****     pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1467              		.loc 1 608 0
 1468 0000 164B     		ldr	r3, .L163
 610:hardware.c    ****     switch (pBKP->DR10)
 1469              		.loc 1 610 0
 1470 0002 1749     		ldr	r1, .L163+4
 608:hardware.c    ****     pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1471              		.loc 1 608 0
 1472 0004 D869     		ldr	r0, [r3, #28]
 604:hardware.c    **** {
 1473              		.loc 1 604 0
 1474 0006 30B4     		push	{r4, r5}
 1475              		.cfi_def_cfa_offset 8
 1476              		.cfi_offset 4, -8
 1477              		.cfi_offset 5, -4
 608:hardware.c    ****     pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1478              		.loc 1 608 0
 1479 0008 40F0C050 		orr	r0, r0, #402653184
 1480 000c D861     		str	r0, [r3, #28]
 610:hardware.c    ****     switch (pBKP->DR10)
 1481              		.loc 1 610 0
 1482 000e 0B8D     		ldrh	r3, [r1, #40]
 1483 0010 44F24C22 		movw	r2, #16972
 1484 0014 9BB2     		uxth	r3, r3
 1485 0016 9342     		cmp	r3, r2
 1486 0018 1ED0     		beq	.L157
 1487 001a 44F24D22 		movw	r2, #16973
 1488 001e 9342     		cmp	r3, r2
 1489 0020 17D1     		bne	.L162
 1490 0022 0220     		movs	r0, #2
 1491              	.L158:
 1492              	.LVL118:
 1493              	.LBB115:
 1494              	.LBB116:
 591:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1495              		.loc 1 591 0
 1496 0024 0D4B     		ldr	r3, .L163
 594:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1497              		.loc 1 594 0
 1498 0026 0F4A     		ldr	r2, .L163+8
 591:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1499              		.loc 1 591 0
 1500 0028 DC69     		ldr	r4, [r3, #28]
 597:hardware.c    ****         pBKP->DR10 = value;
 1501              		.loc 1 597 0
 1502 002a 0D49     		ldr	r1, .L163+4
 591:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1503              		.loc 1 591 0
 1504 002c 44F0C054 		orr	r4, r4, #402653184
 1505 0030 DC61     		str	r4, [r3, #28]
 594:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1506              		.loc 1 594 0
 1507 0032 1568     		ldr	r5, [r2]
 597:hardware.c    ****         pBKP->DR10 = value;
 1508              		.loc 1 597 0
 1509 0034 0024     		movs	r4, #0
 594:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1510              		.loc 1 594 0
 1511 0036 45F48075 		orr	r5, r5, #256
 1512 003a 1560     		str	r5, [r2]
 597:hardware.c    ****         pBKP->DR10 = value;
 1513              		.loc 1 597 0
 1514 003c 0C85     		strh	r4, [r1, #40]	@ movhi
 600:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 1515              		.loc 1 600 0
 1516 003e 1168     		ldr	r1, [r2]
 1517              	.LBE116:
 1518              	.LBE115:
 627:hardware.c    **** }
 1519              		.loc 1 627 0
 1520 0040 30BC     		pop	{r4, r5}
 1521              	.LBB118:
 1522              	.LBB117:
 600:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 1523              		.loc 1 600 0
 1524 0042 21F48071 		bic	r1, r1, #256
 1525 0046 1160     		str	r1, [r2]
 1526              	.LBE117:
 1527              	.LBE118:
 624:hardware.c    **** 		pRCC->APB1ENR &= ~(RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1528              		.loc 1 624 0
 1529 0048 DA69     		ldr	r2, [r3, #28]
 1530 004a 22F0C052 		bic	r2, r2, #402653184
 1531 004e DA61     		str	r2, [r3, #28]
 627:hardware.c    **** }
 1532              		.loc 1 627 0
 1533 0050 7047     		bx	lr
 1534              	.LVL119:
 1535              	.L162:
 610:hardware.c    ****     switch (pBKP->DR10)
 1536              		.loc 1 610 0
 1537 0052 0020     		movs	r0, #0
 627:hardware.c    **** }
 1538              		.loc 1 627 0
 1539 0054 30BC     		pop	{r4, r5}
 1540 0056 7047     		bx	lr
 1541              	.L157:
 610:hardware.c    ****     switch (pBKP->DR10)
 1542              		.loc 1 610 0
 1543 0058 0120     		movs	r0, #1
 1544 005a E3E7     		b	.L158
 1545              	.L164:
 1546              		.align	2
 1547              	.L163:
 1548 005c 00100240 		.word	1073876992
 1549 0060 006C0040 		.word	1073769472
 1550 0064 00700040 		.word	1073770496
 1551              		.cfi_endproc
 1552              	.LFE18:
 1554              		.section	.text.nvicInit,"ax",%progbits
 1555              		.align	2
 1556              		.global	nvicInit
 1557              		.thumb
 1558              		.thumb_func
 1560              	nvicInit:
 1561              	.LFB19:
 629:hardware.c    **** void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
 1562              		.loc 1 629 0
 1563              		.cfi_startproc
 1564              		@ args = 0, pretend = 0, frame = 0
 1565              		@ frame_needed = 0, uses_anonymous_args = 0
 1566              		@ link register save eliminated.
 1567              	.LVL120:
 641:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 1568              		.loc 1 641 0
 1569 0000 194B     		ldr	r3, .L166
 629:hardware.c    **** void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
 1570              		.loc 1 629 0
 1571 0002 10B4     		push	{r4}
 1572              		.cfi_def_cfa_offset 4
 1573              		.cfi_offset 4, -4
 641:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 1574              		.loc 1 641 0
 1575 0004 DB68     		ldr	r3, [r3, #12]
 645:hardware.c    ****     tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 1576              		.loc 1 645 0
 1577 0006 4478     		ldrb	r4, [r0, #1]	@ zero_extendqisi2
 641:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 1578              		.loc 1 641 0
 1579 0008 DB43     		mvns	r3, r3
 1580 000a C3F30223 		ubfx	r3, r3, #8, #3
 1581              	.LVL121:
 643:hardware.c    ****     tmpsub = tmpsub >> tmppriority;
 1582              		.loc 1 643 0
 1583 000e 0F21     		movs	r1, #15
 642:hardware.c    ****     tmppre = (0x4 - tmppriority);
 1584              		.loc 1 642 0
 1585 0010 C3F10402 		rsb	r2, r3, #4
 1586              	.LVL122:
 643:hardware.c    ****     tmpsub = tmpsub >> tmppriority;
 1587              		.loc 1 643 0
 1588 0014 D940     		lsrs	r1, r1, r3
 1589              	.LVL123:
 645:hardware.c    ****     tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 1590              		.loc 1 645 0
 1591 0016 04FA02F2 		lsl	r2, r4, r2
 1592              	.LVL124:
 646:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 1593              		.loc 1 646 0
 1594 001a 8478     		ldrb	r4, [r0, #2]	@ zero_extendqisi2
 649:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1595              		.loc 1 649 0
 1596 001c 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 1597              	.LVL125:
 646:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 1598              		.loc 1 646 0
 1599 001e 2140     		ands	r1, r1, r4
 1600              	.LVL126:
 1601 0020 1143     		orrs	r1, r1, r2
 1602              	.LVL127:
 649:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1603              		.loc 1 649 0
 1604 0022 03F00302 		and	r2, r3, #3
 1605 0026 D200     		lsls	r2, r2, #3
 652:hardware.c    ****     tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1606              		.loc 1 652 0
 1607 0028 FF24     		movs	r4, #255
 648:hardware.c    ****     tmppriority = tmppriority << 0x04;
 1608              		.loc 1 648 0
 1609 002a 0901     		lsls	r1, r1, #4
 1610              	.LVL128:
 649:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1611              		.loc 1 649 0
 1612 002c 9140     		lsls	r1, r1, r2
 1613              	.LVL129:
 652:hardware.c    ****     tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1614              		.loc 1 652 0
 1615 002e 04FA02F2 		lsl	r2, r4, r2
 1616 0032 03F0FC03 		and	r3, r3, #252
 1617 0036 03F16043 		add	r3, r3, #-536870912
 1618 003a 03F56143 		add	r3, r3, #57600
 651:hardware.c    ****     tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 1619              		.loc 1 651 0
 1620 003e D3F80043 		ldr	r4, [r3, #768]
 1621              	.LVL130:
 654:hardware.c    ****     tmppriority &= tmpmask;
 1622              		.loc 1 654 0
 1623 0042 1140     		ands	r1, r1, r2
 1624              	.LVL131:
 653:hardware.c    ****     tmpreg &= ~tmpmask;
 1625              		.loc 1 653 0
 1626 0044 24EA0202 		bic	r2, r4, r2
 1627              	.LVL132:
 655:hardware.c    ****     tmpreg |= tmppriority;
 1628              		.loc 1 655 0
 1629 0048 0A43     		orrs	r2, r2, r1
 1630              	.LVL133:
 657:hardware.c    ****     rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
 1631              		.loc 1 657 0
 1632 004a C3F80023 		str	r2, [r3, #768]
 1633              	.LVL134:
 660:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 1634              		.loc 1 660 0
 1635 004e 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 661:hardware.c    ****         (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 1636              		.loc 1 661 0
 1637 0050 0121     		movs	r1, #1
 1638 0052 03F01F02 		and	r2, r3, #31
 1639              	.LVL135:
 1640 0056 9140     		lsls	r1, r1, r2
 660:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 1641              		.loc 1 660 0
 1642 0058 044A     		ldr	r2, .L166+4
 1643 005a 5B09     		lsrs	r3, r3, #5
 1644 005c 42F82310 		str	r1, [r2, r3, lsl #2]
 662:hardware.c    **** }
 1645              		.loc 1 662 0
 1646 0060 5DF8044B 		ldr	r4, [sp], #4
 1647 0064 7047     		bx	lr
 1648              	.L167:
 1649 0066 00BF     		.align	2
 1650              	.L166:
 1651 0068 00ED00E0 		.word	-536810240
 1652 006c 00E100E0 		.word	-536813312
 1653              		.cfi_endproc
 1654              	.LFE19:
 1656              		.section	.text.nvicDisableInterrupts,"ax",%progbits
 1657              		.align	2
 1658              		.global	nvicDisableInterrupts
 1659              		.thumb
 1660              		.thumb_func
 1662              	nvicDisableInterrupts:
 1663              	.LFB20:
 664:hardware.c    **** void nvicDisableInterrupts() {
 1664              		.loc 1 664 0
 1665              		.cfi_startproc
 1666              		@ args = 0, pretend = 0, frame = 0
 1667              		@ frame_needed = 0, uses_anonymous_args = 0
 1668              		@ link register save eliminated.
 1669              	.LVL136:
 666:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1670              		.loc 1 666 0
 1671 0000 074B     		ldr	r3, .L169
 671:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1672              		.loc 1 671 0
 1673 0002 0849     		ldr	r1, .L169+4
 666:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1674              		.loc 1 666 0
 1675 0004 4FF0FF32 		mov	r2, #-1
 671:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1676              		.loc 1 671 0
 1677 0008 0420     		movs	r0, #4
 666:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1678              		.loc 1 666 0
 1679 000a C3F88020 		str	r2, [r3, #128]
 667:hardware.c    ****     rNVIC->ICER[1] = 0xFFFFFFFF;
 1680              		.loc 1 667 0
 1681 000e C3F88420 		str	r2, [r3, #132]
 668:hardware.c    ****     rNVIC->ICPR[0] = 0xFFFFFFFF;
 1682              		.loc 1 668 0
 1683 0012 C3F88021 		str	r2, [r3, #384]
 669:hardware.c    ****     rNVIC->ICPR[1] = 0xFFFFFFFF;
 1684              		.loc 1 669 0
 1685 0016 C3F88421 		str	r2, [r3, #388]
 671:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1686              		.loc 1 671 0
 1687 001a 0860     		str	r0, [r1]
 1688 001c 7047     		bx	lr
 1689              	.L170:
 1690 001e 00BF     		.align	2
 1691              	.L169:
 1692 0020 00E100E0 		.word	-536813312
 1693 0024 10E000E0 		.word	-536813552
 1694              		.cfi_endproc
 1695              	.LFE20:
 1697              		.section	.text.systemHardReset,"ax",%progbits
 1698              		.align	2
 1699              		.global	systemHardReset
 1700              		.thumb
 1701              		.thumb_func
 1703              	systemHardReset:
 1704              	.LFB21:
 674:hardware.c    **** void systemHardReset(void) {
 1705              		.loc 1 674 0
 1706              		.cfi_startproc
 1707              		@ args = 0, pretend = 0, frame = 0
 1708              		@ frame_needed = 0, uses_anonymous_args = 0
 1709              		@ link register save eliminated.
 1710              	.LVL137:
 678:hardware.c    ****     rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
 1711              		.loc 1 678 0
 1712 0000 024B     		ldr	r3, .L173
 1713 0002 034A     		ldr	r2, .L173+4
 1714 0004 DA60     		str	r2, [r3, #12]
 1715              	.L172:
 682:hardware.c    ****         asm volatile("nop");
 1716              		.loc 1 682 0 discriminator 1
 1717              	@ 682 "hardware.c" 1
 1718 0006 00BF     		nop
 1719              	@ 0 "" 2
 1720              		.thumb
 1721 0008 FDE7     		b	.L172
 1722              	.L174:
 1723 000a 00BF     		.align	2
 1724              	.L173:
 1725 000c 00ED00E0 		.word	-536810240
 1726 0010 0400FA05 		.word	100270084
 1727              		.cfi_endproc
 1728              	.LFE21:
 1730              		.section	.text.flashErasePage,"ax",%progbits
 1731              		.align	2
 1732              		.global	flashErasePage
 1733              		.thumb
 1734              		.thumb_func
 1736              	flashErasePage:
 1737              	.LFB22:
 686:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 1738              		.loc 1 686 0
 1739              		.cfi_startproc
 1740              		@ args = 0, pretend = 0, frame = 0
 1741              		@ frame_needed = 0, uses_anonymous_args = 0
 1742              		@ link register save eliminated.
 1743              	.LVL138:
 687:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1744              		.loc 1 687 0
 1745 0000 0C4B     		ldr	r3, .L180
 689:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1746              		.loc 1 689 0
 1747 0002 0221     		movs	r1, #2
 691:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1748              		.loc 1 691 0
 1749 0004 0C4A     		ldr	r2, .L180+4
 686:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 1750              		.loc 1 686 0
 1751 0006 10B4     		push	{r4}
 1752              		.cfi_def_cfa_offset 4
 1753              		.cfi_offset 4, -4
 687:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1754              		.loc 1 687 0
 1755 0008 1C68     		ldr	r4, [r3]
 1756              	.LVL139:
 689:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1757              		.loc 1 689 0
 1758 000a 1960     		str	r1, [r3]
 1759              	.L177:
 691:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1760              		.loc 1 691 0 discriminator 1
 1761 000c 1368     		ldr	r3, [r2]
 1762 000e DB07     		lsls	r3, r3, #31
 1763 0010 FCD4     		bmi	.L177
 692:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 1764              		.loc 1 692 0
 1765 0012 0A4C     		ldr	r4, .L180+8
 693:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 1766              		.loc 1 693 0
 1767 0014 074B     		ldr	r3, .L180
 1768 0016 4221     		movs	r1, #66
 694:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1769              		.loc 1 694 0
 1770 0018 074A     		ldr	r2, .L180+4
 692:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 1771              		.loc 1 692 0
 1772 001a 2060     		str	r0, [r4]
 693:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 1773              		.loc 1 693 0
 1774 001c 1960     		str	r1, [r3]
 1775              	.L179:
 694:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1776              		.loc 1 694 0 discriminator 1
 1777 001e 1368     		ldr	r3, [r2]
 1778 0020 13F00103 		ands	r3, r3, #1
 1779 0024 FBD1     		bne	.L179
 1780              	.LVL140:
 699:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1781              		.loc 1 699 0
 1782 0026 034A     		ldr	r2, .L180
 702:hardware.c    **** }
 1783              		.loc 1 702 0
 1784 0028 0120     		movs	r0, #1
 1785              	.LVL141:
 699:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1786              		.loc 1 699 0
 1787 002a 1360     		str	r3, [r2]
 702:hardware.c    **** }
 1788              		.loc 1 702 0
 1789 002c 5DF8044B 		ldr	r4, [sp], #4
 1790 0030 7047     		bx	lr
 1791              	.L181:
 1792 0032 00BF     		.align	2
 1793              	.L180:
 1794 0034 10200240 		.word	1073881104
 1795 0038 0C200240 		.word	1073881100
 1796 003c 14200240 		.word	1073881108
 1797              		.cfi_endproc
 1798              	.LFE22:
 1800              		.section	.text.flashErasePages,"ax",%progbits
 1801              		.align	2
 1802              		.global	flashErasePages
 1803              		.thumb
 1804              		.thumb_func
 1806              	flashErasePages:
 1807              	.LFB23:
 703:hardware.c    **** bool flashErasePages(u32 pageAddr, u16 n) {
 1808              		.loc 1 703 0
 1809              		.cfi_startproc
 1810              		@ args = 0, pretend = 0, frame = 0
 1811              		@ frame_needed = 0, uses_anonymous_args = 0
 1812              		@ link register save eliminated.
 1813              	.LVL142:
 1814 0000 2DE9F003 		push	{r4, r5, r6, r7, r8, r9}
 1815              		.cfi_def_cfa_offset 24
 1816              		.cfi_offset 4, -24
 1817              		.cfi_offset 5, -20
 1818              		.cfi_offset 6, -16
 1819              		.cfi_offset 7, -12
 1820              		.cfi_offset 8, -8
 1821              		.cfi_offset 9, -4
 704:hardware.c    ****     while (n-- > 0) {
 1822              		.loc 1 704 0
 1823 0004 4C1E     		subs	r4, r1, #1
 1824 0006 A4B2     		uxth	r4, r4
 1825              	.LVL143:
 1826 0008 E9B1     		cbz	r1, .L190
 1827 000a 114B     		ldr	r3, .L192
 1828              	.LBB119:
 1829              	.LBB120:
 687:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1830              		.loc 1 687 0
 1831 000c 1149     		ldr	r1, .L192+4
 1832 000e D3F80080 		ldr	r8, [r3]
 691:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1833              		.loc 1 691 0
 1834 0012 114A     		ldr	r2, .L192+8
 692:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 1835              		.loc 1 692 0
 1836 0014 DFF844C0 		ldr	ip, .L192+12
 689:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1837              		.loc 1 689 0
 1838 0018 0227     		movs	r7, #2
 693:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 1839              		.loc 1 693 0
 1840 001a 4226     		movs	r6, #66
 1841              	.LBE120:
 1842              	.LBE119:
 704:hardware.c    ****     while (n-- > 0) {
 1843              		.loc 1 704 0
 1844 001c 4FF6FF75 		movw	r5, #65535
 1845              	.LVL144:
 1846              	.L189:
 705:hardware.c    ****         if (!flashErasePage(pageAddr + wTransferSize * n)) {
 1847              		.loc 1 705 0
 1848 0020 08FB0409 		mla	r9, r8, r4, r0
 1849              	.LVL145:
 1850              	.LBB123:
 1851              	.LBB121:
 687:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1852              		.loc 1 687 0
 1853 0024 0B68     		ldr	r3, [r1]
 1854              	.LVL146:
 689:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1855              		.loc 1 689 0
 1856 0026 0F60     		str	r7, [r1]
 1857              	.L185:
 691:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1858              		.loc 1 691 0
 1859 0028 1368     		ldr	r3, [r2]
 1860 002a DB07     		lsls	r3, r3, #31
 1861 002c FCD4     		bmi	.L185
 692:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 1862              		.loc 1 692 0
 1863 002e CCF80090 		str	r9, [ip]
 693:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 1864              		.loc 1 693 0
 1865 0032 0E60     		str	r6, [r1]
 1866              	.L187:
 694:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1867              		.loc 1 694 0
 1868 0034 1368     		ldr	r3, [r2]
 1869 0036 13F00103 		ands	r3, r3, #1
 1870 003a FBD1     		bne	.L187
 1871              	.LVL147:
 1872              	.LBE121:
 1873              	.LBE123:
 704:hardware.c    ****     while (n-- > 0) {
 1874              		.loc 1 704 0
 1875 003c 013C     		subs	r4, r4, #1
 1876              	.LVL148:
 1877 003e A4B2     		uxth	r4, r4
 1878              	.LVL149:
 1879 0040 AC42     		cmp	r4, r5
 1880              	.LBB124:
 1881              	.LBB122:
 699:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1882              		.loc 1 699 0
 1883 0042 0B60     		str	r3, [r1]
 1884              	.LVL150:
 1885              	.LBE122:
 1886              	.LBE124:
 704:hardware.c    ****     while (n-- > 0) {
 1887              		.loc 1 704 0
 1888 0044 ECD1     		bne	.L189
 1889              	.LVL151:
 1890              	.L190:
 711:hardware.c    **** }
 1891              		.loc 1 711 0
 1892 0046 0120     		movs	r0, #1
 1893              	.LVL152:
 1894 0048 BDE8F003 		pop	{r4, r5, r6, r7, r8, r9}
 1895 004c 7047     		bx	lr
 1896              	.L193:
 1897 004e 00BF     		.align	2
 1898              	.L192:
 1899 0050 00000000 		.word	wTransferSize
 1900 0054 10200240 		.word	1073881104
 1901 0058 0C200240 		.word	1073881100
 1902 005c 14200240 		.word	1073881108
 1903              		.cfi_endproc
 1904              	.LFE23:
 1906              		.section	.text.flashWriteWord,"ax",%progbits
 1907              		.align	2
 1908              		.global	flashWriteWord
 1909              		.thumb
 1910              		.thumb_func
 1912              	flashWriteWord:
 1913              	.LFB24:
 713:hardware.c    **** bool flashWriteWord(u32 addr, u32 word) {
 1914              		.loc 1 713 0
 1915              		.cfi_startproc
 1916              		@ args = 0, pretend = 0, frame = 8
 1917              		@ frame_needed = 0, uses_anonymous_args = 0
 1918              		@ link register save eliminated.
 1919              	.LVL153:
 1920 0000 30B4     		push	{r4, r5}
 1921              		.cfi_def_cfa_offset 8
 1922              		.cfi_offset 4, -8
 1923              		.cfi_offset 5, -4
 716:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 1924              		.loc 1 716 0
 1925 0002 0A0C     		lsrs	r2, r1, #16
 713:hardware.c    **** bool flashWriteWord(u32 addr, u32 word) {
 1926              		.loc 1 713 0
 1927 0004 82B0     		sub	sp, sp, #8
 1928              		.cfi_def_cfa_offset 16
 715:hardware.c    ****     vu32 lhWord = (vu32)word & 0x0000FFFF;
 1929              		.loc 1 715 0
 1930 0006 8CB2     		uxth	r4, r1
 718:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1931              		.loc 1 718 0
 1932 0008 114B     		ldr	r3, .L201
 715:hardware.c    ****     vu32 lhWord = (vu32)word & 0x0000FFFF;
 1933              		.loc 1 715 0
 1934 000a 0094     		str	r4, [sp]
 716:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 1935              		.loc 1 716 0
 1936 000c 0192     		str	r2, [sp, #4]
 719:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 1937              		.loc 1 719 0
 1938 000e 0124     		movs	r4, #1
 723:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1939              		.loc 1 723 0
 1940 0010 104A     		ldr	r2, .L201+4
 1941              	.LVL154:
 718:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1942              		.loc 1 718 0
 1943 0012 1D68     		ldr	r5, [r3]
 1944              	.LVL155:
 719:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 1945              		.loc 1 719 0
 1946 0014 1C60     		str	r4, [r3]
 1947              	.L196:
 723:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1948              		.loc 1 723 0 discriminator 1
 1949 0016 1368     		ldr	r3, [r2]
 1950 0018 DC07     		lsls	r4, r3, #31
 1951 001a FCD4     		bmi	.L196
 724:hardware.c    ****     *(flashAddr + 0x01) = (vu16)hhWord;
 1952              		.loc 1 724 0
 1953 001c 019B     		ldr	r3, [sp, #4]
 725:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1954              		.loc 1 725 0
 1955 001e 0D4A     		ldr	r2, .L201+4
 724:hardware.c    ****     *(flashAddr + 0x01) = (vu16)hhWord;
 1956              		.loc 1 724 0
 1957 0020 9BB2     		uxth	r3, r3
 1958 0022 4380     		strh	r3, [r0, #2]	@ movhi
 1959              	.L198:
 725:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1960              		.loc 1 725 0 discriminator 1
 1961 0024 1368     		ldr	r3, [r2]
 1962 0026 DB07     		lsls	r3, r3, #31
 1963 0028 FCD4     		bmi	.L198
 726:hardware.c    ****     *(flashAddr) = (vu16)lhWord;
 1964              		.loc 1 726 0
 1965 002a 009B     		ldr	r3, [sp]
 727:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1966              		.loc 1 727 0
 1967 002c 094A     		ldr	r2, .L201+4
 726:hardware.c    ****     *(flashAddr) = (vu16)lhWord;
 1968              		.loc 1 726 0
 1969 002e 9BB2     		uxth	r3, r3
 1970 0030 0380     		strh	r3, [r0]	@ movhi
 1971              	.L200:
 727:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1972              		.loc 1 727 0 discriminator 1
 1973 0032 1368     		ldr	r3, [r2]
 1974 0034 DC07     		lsls	r4, r3, #31
 1975 0036 FCD4     		bmi	.L200
 730:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1976              		.loc 1 730 0
 1977 0038 054B     		ldr	r3, .L201
 729:hardware.c    ****     rwmVal &= 0xFFFFFFFE;
 1978              		.loc 1 729 0
 1979 003a 25F00102 		bic	r2, r5, #1
 1980              	.LVL156:
 730:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1981              		.loc 1 730 0
 1982 003e 1A60     		str	r2, [r3]
 733:hardware.c    ****     if (*(vu32 *)addr != word) {
 1983              		.loc 1 733 0
 1984 0040 0068     		ldr	r0, [r0]
 1985              	.LVL157:
 738:hardware.c    **** }
 1986              		.loc 1 738 0
 1987 0042 0B1A     		subs	r3, r1, r0
 1988 0044 5842     		rsbs	r0, r3, #0
 1989 0046 5841     		adcs	r0, r0, r3
 1990 0048 02B0     		add	sp, sp, #8
 1991              		@ sp needed
 1992 004a 30BC     		pop	{r4, r5}
 1993 004c 7047     		bx	lr
 1994              	.L202:
 1995 004e 00BF     		.align	2
 1996              	.L201:
 1997 0050 10200240 		.word	1073881104
 1998 0054 0C200240 		.word	1073881100
 1999              		.cfi_endproc
 2000              	.LFE24:
 2002              		.section	.text.flashLock,"ax",%progbits
 2003              		.align	2
 2004              		.global	flashLock
 2005              		.thumb
 2006              		.thumb_func
 2008              	flashLock:
 2009              	.LFB25:
 740:hardware.c    **** void flashLock() {
 2010              		.loc 1 740 0
 2011              		.cfi_startproc
 2012              		@ args = 0, pretend = 0, frame = 0
 2013              		@ frame_needed = 0, uses_anonymous_args = 0
 2014              		@ link register save eliminated.
 2015              		.loc 1 744 0
 2016 0000 014B     		ldr	r3, .L204
 2017 0002 8022     		movs	r2, #128
 2018 0004 1A60     		str	r2, [r3]
 2019 0006 7047     		bx	lr
 2020              	.L205:
 2021              		.align	2
 2022              	.L204:
 2023 0008 10200240 		.word	1073881104
 2024              		.cfi_endproc
 2025              	.LFE25:
 2027              		.section	.text.flashUnlock,"ax",%progbits
 2028              		.align	2
 2029              		.global	flashUnlock
 2030              		.thumb
 2031              		.thumb_func
 2033              	flashUnlock:
 2034              	.LFB26:
 745:hardware.c    **** }
 746:hardware.c    **** 
 747:hardware.c    **** void flashUnlock() {
 2035              		.loc 1 747 0
 2036              		.cfi_startproc
 2037              		@ args = 0, pretend = 0, frame = 0
 2038              		@ frame_needed = 0, uses_anonymous_args = 0
 2039              		@ link register save eliminated.
 748:hardware.c    ****     /* unlock the flash */
 749:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY1);
 2040              		.loc 1 749 0
 2041 0000 024B     		ldr	r3, .L207
 2042 0002 0349     		ldr	r1, .L207+4
 750:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY2);
 2043              		.loc 1 750 0
 2044 0004 034A     		ldr	r2, .L207+8
 749:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY1);
 2045              		.loc 1 749 0
 2046 0006 1960     		str	r1, [r3]
 2047              		.loc 1 750 0
 2048 0008 1A60     		str	r2, [r3]
 2049 000a 7047     		bx	lr
 2050              	.L208:
 2051              		.align	2
 2052              	.L207:
 2053 000c 04200240 		.word	1073881092
 2054 0010 23016745 		.word	1164378403
 2055 0014 AB89EFCD 		.word	-839939669
 2056              		.cfi_endproc
 2057              	.LFE26:
 2059              		.section	.text.crMask,"ax",%progbits
 2060              		.align	2
 2061              		.global	crMask
 2062              		.thumb
 2063              		.thumb_func
 2065              	crMask:
 2066              	.LFB27:
 751:hardware.c    **** }
 752:hardware.c    **** 
 753:hardware.c    **** 
 754:hardware.c    **** // Used to create the control register masking pattern, when setting control register mode.
 755:hardware.c    **** unsigned int crMask(int pin)
 756:hardware.c    **** {
 2067              		.loc 1 756 0
 2068              		.cfi_startproc
 2069              		@ args = 0, pretend = 0, frame = 0
 2070              		@ frame_needed = 0, uses_anonymous_args = 0
 2071              		@ link register save eliminated.
 2072              	.LVL158:
 757:hardware.c    **** 	unsigned int mask;
 758:hardware.c    **** 	if (pin>=8)
 2073              		.loc 1 758 0
 2074 0000 0728     		cmp	r0, #7
 759:hardware.c    **** 	{
 760:hardware.c    **** 		pin-=8;
 2075              		.loc 1 760 0
 2076 0002 C8BF     		it	gt
 2077 0004 0838     		subgt	r0, r0, #8
 2078              	.LVL159:
 761:hardware.c    **** 	}
 762:hardware.c    **** 	mask = 0x0F << (pin<<2);
 2079              		.loc 1 762 0
 2080 0006 0F23     		movs	r3, #15
 2081 0008 8000     		lsls	r0, r0, #2
 2082              	.LVL160:
 2083 000a 03FA00F0 		lsl	r0, r3, r0
 2084              	.LVL161:
 763:hardware.c    **** 	return ~mask;
 764:hardware.c    **** }	
 2085              		.loc 1 764 0
 2086 000e C043     		mvns	r0, r0
 2087              	.LVL162:
 2088 0010 7047     		bx	lr
 2089              		.cfi_endproc
 2090              	.LFE27:
 2092 0012 00BF     		.section	.text.getFlashEnd,"ax",%progbits
 2093              		.align	2
 2094              		.global	getFlashEnd
 2095              		.thumb
 2096              		.thumb_func
 2098              	getFlashEnd:
 2099              	.LFB28:
 765:hardware.c    **** 
 766:hardware.c    **** #define FLASH_SIZE_REG 0x1FFFF7E0
 767:hardware.c    **** int getFlashEnd(void)
 768:hardware.c    **** {
 2100              		.loc 1 768 0
 2101              		.cfi_startproc
 2102              		@ args = 0, pretend = 0, frame = 0
 2103              		@ frame_needed = 0, uses_anonymous_args = 0
 2104              		@ link register save eliminated.
 2105              	.LVL163:
 769:hardware.c    **** 	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
 770:hardware.c    **** 	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
 2106              		.loc 1 770 0
 2107 0000 024B     		ldr	r3, .L212
 2108 0002 1888     		ldrh	r0, [r3]
 2109 0004 00F50030 		add	r0, r0, #131072
 771:hardware.c    **** }
 2110              		.loc 1 771 0
 2111 0008 8002     		lsls	r0, r0, #10
 2112 000a 7047     		bx	lr
 2113              	.L213:
 2114              		.align	2
 2115              	.L212:
 2116 000c E0F7FF1F 		.word	536868832
 2117              		.cfi_endproc
 2118              	.LFE28:
 2120              		.section	.text.getFlashPageSize,"ax",%progbits
 2121              		.align	2
 2122              		.global	getFlashPageSize
 2123              		.thumb
 2124              		.thumb_func
 2126              	getFlashPageSize:
 2127              	.LFB29:
 772:hardware.c    **** 
 773:hardware.c    **** int getFlashPageSize(void)
 774:hardware.c    **** {
 2128              		.loc 1 774 0
 2129              		.cfi_startproc
 2130              		@ args = 0, pretend = 0, frame = 0
 2131              		@ frame_needed = 0, uses_anonymous_args = 0
 2132              		@ link register save eliminated.
 2133              	.LVL164:
 775:hardware.c    **** 
 776:hardware.c    **** 	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
 777:hardware.c    **** 	if ((*flashSize & 0xffff) > 128)
 2134              		.loc 1 777 0
 2135 0000 044B     		ldr	r3, .L217
 2136 0002 1B88     		ldrh	r3, [r3]
 778:hardware.c    **** 	{
 779:hardware.c    **** 		return 0x800;
 2137              		.loc 1 779 0
 2138 0004 812B     		cmp	r3, #129
 780:hardware.c    **** 	}
 781:hardware.c    **** 	else
 782:hardware.c    **** 	{
 783:hardware.c    **** 		return 0x400;
 784:hardware.c    **** 	}
 785:hardware.c    **** }
 2139              		.loc 1 785 0
 2140 0006 34BF     		ite	cc
 2141 0008 4FF48060 		movcc	r0, #1024
 2142 000c 4FF40060 		movcs	r0, #2048
 2143 0010 7047     		bx	lr
 2144              	.L218:
 2145 0012 00BF     		.align	2
 2146              	.L217:
 2147 0014 E0F7FF1F 		.word	536868832
 2148              		.cfi_endproc
 2149              	.LFE29:
 2151              		.comm	wTransferSize,4,4
 2152              		.section	.rodata.str1.4,"aMS",%progbits,1
 2153              		.align	2
 2154              	.LC0:
 2155 0000 25303258 		.ascii	"%02X \000"
 2155      2000
 2156 0006 0000     		.space	2
 2157              	.LC1:
 2158 0008 20202000 		.ascii	"   \000"
 2159              	.LC2:
 2160 000c 207C2573 		.ascii	" |%s|\012\000"
 2160      7C0A00
 2161 0013 00       		.space	1
 2162              	.LC3:
 2163 0014 2000     		.ascii	" \000"
 2164 0016 0000     		.text
 2165              	.Letext0:
 2166              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 2167              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 2168              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\mach
 2169              		.file 5 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdi
 2170              		.file 6 "./stm32_lib/stm32f10x_type.h"
 2171              		.file 7 "hardware.h"
 2172              		.file 8 "<built-in>"
 2173              		.file 9 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdi
 2174              		.file 10 "usb.h"
DEFINED SYMBOLS
                            *ABS*:00000000 hardware.c
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:19     .text.uart_printf.constprop.0:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:23     .text.uart_printf.constprop.0:00000000 uart_printf.constprop.0
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:106    .text.uart_printf.constprop.0:00000040 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:112    .text.uart_printf.constprop.1:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:116    .text.uart_printf.constprop.1:00000000 uart_printf.constprop.1
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:198    .text.uart_printf.constprop.1:00000040 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:204    .text.gpio_write_bit:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:209    .text.gpio_write_bit:00000000 gpio_write_bit
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:235    .text.readPin:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:240    .text.readPin:00000000 readPin
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:264    .text.strobePin:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:269    .text.strobePin:00000000 strobePin
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:407    .text.UU_PutChar:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:412    .text.UU_PutChar:00000000 UU_PutChar
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:432    .text.UU_PutString:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:437    .text.UU_PutString:00000000 UU_PutString
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:473    .text.vprint:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:478    .text.vprint:00000000 vprint
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:540    .text.vprint:00000034 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:545    .text.uart_printf:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:550    .text.uart_printf:00000000 uart_printf
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:634    .text.uart_printf:00000040 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:639    .text.hexdump:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:644    .text.hexdump:00000000 hexdump
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:787    .text.hexdump:000000ac $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:795    .text.uartInit:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:800    .text.uartInit:00000000 uartInit
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:897    .text.uartInit:00000080 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:903    .text.systemReset:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:908    .text.systemReset:00000000 systemReset
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:960    .text.systemReset:00000040 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:968    .text.setupCLK:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:973    .text.setupCLK:00000000 setupCLK
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1045   .text.setupCLK:00000060 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1052   .text.setupLEDAndButton:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1057   .text.setupLEDAndButton:00000000 setupLEDAndButton
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1075   .text.setupLEDAndButton:00000010 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1080   .text.setupFLASH:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1085   .text.setupFLASH:00000000 setupFLASH
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1120   .text.setupFLASH:0000001c $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1125   .text.uid_read:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1130   .text.uid_read:00000000 uid_read
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1166   .text.uid_read:0000001c $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1173   .text.checkUserCode:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1178   .text.checkUserCode:00000000 checkUserCode
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1194   .text.setMspAndJump:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1199   .text.setMspAndJump:00000000 setMspAndJump
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1232   .text.setMspAndJump:00000014 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1237   .text.jumpToUser:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1242   .text.jumpToUser:00000000 jumpToUser
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1385   .text.jumpToUser:00000084 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1400   .text.bkp10Write:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1405   .text.bkp10Write:00000000 bkp10Write
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1447   .text.bkp10Write:00000028 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1454   .text.checkAndClearBootloaderFlag:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1459   .text.checkAndClearBootloaderFlag:00000000 checkAndClearBootloaderFlag
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1548   .text.checkAndClearBootloaderFlag:0000005c $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1555   .text.nvicInit:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1560   .text.nvicInit:00000000 nvicInit
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1651   .text.nvicInit:00000068 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1657   .text.nvicDisableInterrupts:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1662   .text.nvicDisableInterrupts:00000000 nvicDisableInterrupts
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1692   .text.nvicDisableInterrupts:00000020 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1698   .text.systemHardReset:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1703   .text.systemHardReset:00000000 systemHardReset
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1725   .text.systemHardReset:0000000c $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1731   .text.flashErasePage:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1736   .text.flashErasePage:00000000 flashErasePage
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1794   .text.flashErasePage:00000034 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1801   .text.flashErasePages:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1806   .text.flashErasePages:00000000 flashErasePages
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1899   .text.flashErasePages:00000050 $d
                            *COM*:00000004 wTransferSize
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1907   .text.flashWriteWord:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1912   .text.flashWriteWord:00000000 flashWriteWord
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:1997   .text.flashWriteWord:00000050 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2003   .text.flashLock:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2008   .text.flashLock:00000000 flashLock
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2023   .text.flashLock:00000008 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2028   .text.flashUnlock:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2033   .text.flashUnlock:00000000 flashUnlock
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2053   .text.flashUnlock:0000000c $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2060   .text.crMask:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2065   .text.crMask:00000000 crMask
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2093   .text.getFlashEnd:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2098   .text.getFlashEnd:00000000 getFlashEnd
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2116   .text.getFlashEnd:0000000c $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2121   .text.getFlashPageSize:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2126   .text.getFlashPageSize:00000000 getFlashPageSize
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2147   .text.getFlashPageSize:00000014 $d
C:\Users\haifisch\AppData\Local\Temp\ccBNnHsv.s:2153   .rodata.str1.4:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vsprintf
RCC_APB2PeriphClockCmd
GPIO_Init
USART_Init
USART_Cmd
usbDsbISR
usbDsbBus
