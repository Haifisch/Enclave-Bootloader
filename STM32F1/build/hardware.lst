   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"hardware.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.gpio_write_bit,"ax",%progbits
  19              		.align	2
  20              		.global	gpio_write_bit
  21              		.thumb
  22              		.thumb_func
  24              	gpio_write_bit:
  25              	.LFB0:
  26              		.file 1 "hardware.c"
   1:hardware.c    **** /* *****************************************************************************
   2:hardware.c    ****  * The MIT License
   3:hardware.c    ****  *
   4:hardware.c    ****  * Copyright (c) 2010 LeafLabs LLC.
   5:hardware.c    ****  *
   6:hardware.c    ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:hardware.c    ****  * of this software and associated documentation files (the "Software"), to deal
   8:hardware.c    ****  * in the Software without restriction, including without limitation the rights
   9:hardware.c    ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:hardware.c    ****  * copies of the Software, and to permit persons to whom the Software is
  11:hardware.c    ****  * furnished to do so, subject to the following conditions:
  12:hardware.c    ****  *
  13:hardware.c    ****  * The above copyright notice and this permission notice shall be included in
  14:hardware.c    ****  * all copies or substantial portions of the Software.
  15:hardware.c    ****  *
  16:hardware.c    ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:hardware.c    ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:hardware.c    ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:hardware.c    ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:hardware.c    ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:hardware.c    ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:hardware.c    ****  * THE SOFTWARE.
  23:hardware.c    ****  * ****************************************************************************/
  24:hardware.c    **** 
  25:hardware.c    **** /**
  26:hardware.c    ****  *  @file hardware.c
  27:hardware.c    ****  *
  28:hardware.c    ****  *  @brief init routines to setup clocks, interrupts, also destructor functions.
  29:hardware.c    ****  *  does not include USB stuff. EEPROM read/write functions.
  30:hardware.c    ****  *
  31:hardware.c    ****  */
  32:hardware.c    **** #include <stdio.h>
  33:hardware.c    **** #include <stdint.h>
  34:hardware.c    **** #include <string.h>
  35:hardware.c    **** #include <limits.h>
  36:hardware.c    **** #include <unistd.h>
  37:hardware.c    **** #include <errno.h>
  38:hardware.c    **** #include <stdarg.h>
  39:hardware.c    **** 
  40:hardware.c    **** 
  41:hardware.c    **** #include "common.h"
  42:hardware.c    **** #include "hardware.h"
  43:hardware.c    **** #include "sha256.h"
  44:hardware.c    **** #include "edsign.h"
  45:hardware.c    **** 
  46:hardware.c    **** 
  47:hardware.c    **** /*
  48:hardware.c    **** void setPin(u32 bank, u8 pin) {
  49:hardware.c    ****     u32 pinMask = 0x1 << (pin);
  50:hardware.c    ****     SET_REG(GPIO_BSRR(bank), pinMask);
  51:hardware.c    **** }
  52:hardware.c    **** 
  53:hardware.c    **** void resetPin(u32 bank, u8 pin) {
  54:hardware.c    ****     u32 pinMask = 0x1 << (16 + pin);
  55:hardware.c    ****     SET_REG(GPIO_BSRR(bank), pinMask);
  56:hardware.c    **** }
  57:hardware.c    **** */
  58:hardware.c    **** void gpio_write_bit(u32 bank, u8 pin, u8 val) {
  27              		.loc 1 58 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32              	.LVL0:
  59:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
  33              		.loc 1 60 0
  34 0000 0123     		movs	r3, #1
  35 0002 03FA01F1 		lsl	r1, r3, r1
  36              	.LVL1:
  59:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
  37              		.loc 1 59 0
  38 0006 D2F10102 		rsbs	r2, r2, #1
  39              	.LVL2:
  40 000a 38BF     		it	cc
  41 000c 0022     		movcc	r2, #0
  42              		.loc 1 60 0
  43 000e 1301     		lsls	r3, r2, #4
  44 0010 9940     		lsls	r1, r1, r3
  45 0012 0161     		str	r1, [r0, #16]
  46 0014 7047     		bx	lr
  47              		.cfi_endproc
  48              	.LFE0:
  50 0016 00BF     		.section	.text.readPin,"ax",%progbits
  51              		.align	2
  52              		.global	readPin
  53              		.thumb
  54              		.thumb_func
  56              	readPin:
  57              	.LFB1:
  61:hardware.c    **** }
  62:hardware.c    **** 
  63:hardware.c    **** bool readPin(u32 bank, u8 pin) {
  58              		.loc 1 63 0
  59              		.cfi_startproc
  60              		@ args = 0, pretend = 0, frame = 0
  61              		@ frame_needed = 0, uses_anonymous_args = 0
  62              		@ link register save eliminated.
  63              	.LVL3:
  64:hardware.c    ****     // todo, implement read
  65:hardware.c    ****     if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
  64              		.loc 1 65 0
  65 0000 0123     		movs	r3, #1
  66 0002 03FA01F1 		lsl	r1, r3, r1
  67              	.LVL4:
  68 0006 8268     		ldr	r2, [r0, #8]
  69 0008 0A42     		tst	r2, r1
  66:hardware.c    ****         return TRUE;
  67:hardware.c    ****     } else {
  68:hardware.c    ****         return FALSE;
  69:hardware.c    ****     }
  70:hardware.c    **** }
  70              		.loc 1 70 0
  71 000a 0CBF     		ite	eq
  72 000c 0020     		moveq	r0, #0
  73 000e 0120     		movne	r0, #1
  74              	.LVL5:
  75 0010 7047     		bx	lr
  76              		.cfi_endproc
  77              	.LFE1:
  79 0012 00BF     		.section	.text.strobePin,"ax",%progbits
  80              		.align	2
  81              		.global	strobePin
  82              		.thumb
  83              		.thumb_func
  85              	strobePin:
  86              	.LFB2:
  71:hardware.c    **** 
  72:hardware.c    **** void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
  73:hardware.c    **** {
  87              		.loc 1 73 0
  88              		.cfi_startproc
  89              		@ args = 4, pretend = 0, frame = 0
  90              		@ frame_needed = 0, uses_anonymous_args = 0
  91              		@ link register save eliminated.
  92              	.LVL6:
  93 0000 F0B4     		push	{r4, r5, r6, r7}
  94              		.cfi_def_cfa_offset 16
  95              		.cfi_offset 4, -16
  96              		.cfi_offset 5, -12
  97              		.cfi_offset 6, -8
  98              		.cfi_offset 7, -4
  99              	.LBB28:
 100              	.LBB29:
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
 101              		.loc 1 60 0
 102 0002 0124     		movs	r4, #1
 103 0004 04FA01F1 		lsl	r1, r4, r1
 104              	.LVL7:
 105              	.LBE29:
 106              	.LBE28:
 107              		.loc 1 73 0
 108 0008 9DF81060 		ldrb	r6, [sp, #16]	@ zero_extendqisi2
  74:hardware.c    ****     gpio_write_bit( bank,pin,1-onState);
  75:hardware.c    **** 
  76:hardware.c    ****     u32 c;
  77:hardware.c    ****     while (count-- > 0) 
 109              		.loc 1 77 0
 110 000c 571E     		subs	r7, r2, #1
 111              	.LBB31:
 112              	.LBB30:
  59:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
 113              		.loc 1 59 0
 114 000e 341B     		subs	r4, r6, r4
 115 0010 6542     		rsbs	r5, r4, #0
 116 0012 6541     		adcs	r5, r5, r4
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
 117              		.loc 1 60 0
 118 0014 2D01     		lsls	r5, r5, #4
 119 0016 01FA05F5 		lsl	r5, r1, r5
 120              	.LVL8:
 121 001a 00F11004 		add	r4, r0, #16
 122 001e 0561     		str	r5, [r0, #16]
 123              	.LBE30:
 124              	.LBE31:
 125              		.loc 1 77 0
 126 0020 F8B2     		uxtb	r0, r7
 127              	.LVL9:
 128 0022 A2B1     		cbz	r2, .L3
 129 0024 D6F10102 		rsbs	r2, r6, #1
 130 0028 38BF     		it	cc
 131 002a 0022     		movcc	r2, #0
 132 002c 1201     		lsls	r2, r2, #4
 133 002e 9140     		lsls	r1, r1, r2
 134              	.LVL10:
 135              	.L5:
  78:hardware.c    **** 	{
  79:hardware.c    ****         for (c = rate; c > 0; c--)
 136              		.loc 1 79 0 discriminator 1
 137 0030 7BB1     		cbz	r3, .L9
 138              		.loc 1 79 0 is_stmt 0
 139 0032 1A46     		mov	r2, r3
 140              	.LVL11:
 141              	.L10:
  80:hardware.c    **** 		{
  81:hardware.c    ****             asm volatile("nop");
 142              		.loc 1 81 0 is_stmt 1 discriminator 2
 143              	@ 81 "hardware.c" 1
 144 0034 00BF     		nop
 145              	@ 0 "" 2
 146              	.LVL12:
  79:hardware.c    ****         for (c = rate; c > 0; c--)
 147              		.loc 1 79 0 discriminator 2
 148              		.thumb
 149 0036 013A     		subs	r2, r2, #1
 150              	.LVL13:
 151 0038 FCD1     		bne	.L10
 152              	.LVL14:
 153              	.LBB32:
 154              	.LBB33:
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
 155              		.loc 1 60 0
 156 003a 2160     		str	r1, [r4]
 157              	.LVL15:
 158 003c 1A46     		mov	r2, r3
 159              	.L11:
 160              	.LVL16:
 161              	.LBE33:
 162              	.LBE32:
  82:hardware.c    ****         }
  83:hardware.c    **** 		
  84:hardware.c    ****         gpio_write_bit( bank,pin,onState);
  85:hardware.c    **** 		
  86:hardware.c    ****         for (c = rate; c > 0; c--)
  87:hardware.c    **** 		{
  88:hardware.c    ****             asm volatile("nop");
 163              		.loc 1 88 0 discriminator 2
 164              	@ 88 "hardware.c" 1
 165 003e 00BF     		nop
 166              	@ 0 "" 2
 167              	.LVL17:
  86:hardware.c    ****         for (c = rate; c > 0; c--)
 168              		.loc 1 86 0 discriminator 2
 169              		.thumb
 170 0040 013A     		subs	r2, r2, #1
 171              	.LVL18:
 172 0042 FCD1     		bne	.L11
 173              	.LVL19:
  77:hardware.c    ****     while (count-- > 0) 
 174              		.loc 1 77 0
 175 0044 0138     		subs	r0, r0, #1
 176              	.LVL20:
 177 0046 C0B2     		uxtb	r0, r0
 178              	.LVL21:
 179 0048 FF28     		cmp	r0, #255
 180              	.LBB35:
 181              	.LBB36:
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
 182              		.loc 1 60 0
 183 004a 2560     		str	r5, [r4]
 184              	.LVL22:
 185              	.LBE36:
 186              	.LBE35:
  77:hardware.c    ****     while (count-- > 0) 
 187              		.loc 1 77 0
 188 004c F0D1     		bne	.L5
 189              	.LVL23:
 190              	.L3:
  89:hardware.c    ****         }
  90:hardware.c    ****         gpio_write_bit( bank,pin,1-onState);
  91:hardware.c    ****     }
  92:hardware.c    **** }
 191              		.loc 1 92 0
 192 004e F0BC     		pop	{r4, r5, r6, r7}
 193              	.LVL24:
 194 0050 7047     		bx	lr
 195              	.LVL25:
 196              	.L9:
  77:hardware.c    ****     while (count-- > 0) 
 197              		.loc 1 77 0
 198 0052 0138     		subs	r0, r0, #1
 199              	.LVL26:
 200 0054 C0B2     		uxtb	r0, r0
 201              	.LVL27:
 202 0056 FF28     		cmp	r0, #255
 203              	.LBB38:
 204              	.LBB34:
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
 205              		.loc 1 60 0
 206 0058 2160     		str	r1, [r4]
 207              	.LVL28:
 208              	.LBE34:
 209              	.LBE38:
 210              	.LBB39:
 211              	.LBB37:
 212 005a 2560     		str	r5, [r4]
 213              	.LVL29:
 214              	.LBE37:
 215              	.LBE39:
  77:hardware.c    ****     while (count-- > 0) 
 216              		.loc 1 77 0
 217 005c E8D1     		bne	.L5
 218 005e F6E7     		b	.L3
 219              		.cfi_endproc
 220              	.LFE2:
 222              		.section	.text.UU_PutChar,"ax",%progbits
 223              		.align	2
 224              		.global	UU_PutChar
 225              		.thumb
 226              		.thumb_func
 228              	UU_PutChar:
 229              	.LFB3:
  93:hardware.c    **** 
  94:hardware.c    **** 
  95:hardware.c    **** typedef struct
  96:hardware.c    **** {
  97:hardware.c    ****   uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate
  98:hardware.c    ****                                            The baud rate is computed using the following formula:
  99:hardware.c    ****                                             - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->
 100:hardware.c    ****                                             - FractionalDivider = ((IntegerDivider - ((u32) Integer
 101:hardware.c    **** 
 102:hardware.c    ****   uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or receive
 103:hardware.c    ****                                            This parameter can be a value of @ref USART_Word_Length 
 104:hardware.c    **** 
 105:hardware.c    ****   uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
 106:hardware.c    ****                                            This parameter can be a value of @ref USART_Stop_Bits */
 107:hardware.c    **** 
 108:hardware.c    ****   uint16_t USART_Parity;              /*!< Specifies the parity mode.
 109:hardware.c    ****                                            This parameter can be a value of @ref USART_Parity
 110:hardware.c    ****                                            @note When parity is enabled, the computed parity is ins
 111:hardware.c    ****                                                  at the MSB position of the transmitted data (9th b
 112:hardware.c    ****                                                  the word length is set to 9 data bits; 8th bit whe
 113:hardware.c    ****                                                  word length is set to 8 data bits). */
 114:hardware.c    ****  
 115:hardware.c    ****   uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled
 116:hardware.c    ****                                            This parameter can be a value of @ref USART_Mode */
 117:hardware.c    **** 
 118:hardware.c    ****   uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabl
 119:hardware.c    ****                                            or disabled.
 120:hardware.c    ****                                            This parameter can be a value of @ref USART_Hardware_Flo
 121:hardware.c    **** } USART_InitTypeDef;
 122:hardware.c    **** 
 123:hardware.c    **** /** 
 124:hardware.c    ****   * @brief  USART Clock Init Structure definition  
 125:hardware.c    ****   */ 
 126:hardware.c    ****   
 127:hardware.c    **** typedef struct
 128:hardware.c    **** {
 129:hardware.c    **** 
 130:hardware.c    ****   uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.
 131:hardware.c    ****                                This parameter can be a value of @ref USART_Clock */
 132:hardware.c    **** 
 133:hardware.c    ****   uint16_t USART_CPOL;    /*!< Specifies the steady state value of the serial clock.
 134:hardware.c    ****                                This parameter can be a value of @ref USART_Clock_Polarity */
 135:hardware.c    **** 
 136:hardware.c    ****   uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.
 137:hardware.c    ****                                This parameter can be a value of @ref USART_Clock_Phase */
 138:hardware.c    **** 
 139:hardware.c    ****   uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmit
 140:hardware.c    ****                                data bit (MSB) has to be output on the SCLK pin in synchronous mode.
 141:hardware.c    ****                                This parameter can be a value of @ref USART_Last_Bit */
 142:hardware.c    **** } USART_ClockInitTypeDef;
 143:hardware.c    **** 
 144:hardware.c    **** 
 145:hardware.c    **** typedef enum
 146:hardware.c    **** { 
 147:hardware.c    ****   GPIO_Speed_10MHz = 1,
 148:hardware.c    ****   GPIO_Speed_2MHz, 
 149:hardware.c    ****   GPIO_Speed_50MHz
 150:hardware.c    **** }GPIOSpeed_TypeDef;
 151:hardware.c    **** 
 152:hardware.c    **** typedef enum
 153:hardware.c    **** { GPIO_Mode_AIN = 0x0,
 154:hardware.c    ****   GPIO_Mode_IN_FLOATING = 0x04,
 155:hardware.c    ****   GPIO_Mode_IPD = 0x28,
 156:hardware.c    ****   GPIO_Mode_IPU = 0x48,
 157:hardware.c    ****   GPIO_Mode_Out_OD = 0x14,
 158:hardware.c    ****   GPIO_Mode_Out_PP = 0x10,
 159:hardware.c    ****   GPIO_Mode_AF_OD = 0x1C,
 160:hardware.c    ****   GPIO_Mode_AF_PP = 0x18
 161:hardware.c    **** }GPIOMode_TypeDef;
 162:hardware.c    **** 
 163:hardware.c    **** typedef struct
 164:hardware.c    **** {
 165:hardware.c    ****   uint16_t GPIO_Pin;             /*!< Specifies the GPIO pins to be configured.
 166:hardware.c    ****                                       This parameter can be any value of @ref GPIO_pins_define */
 167:hardware.c    **** 
 168:hardware.c    ****   GPIOSpeed_TypeDef GPIO_Speed;  /*!< Specifies the speed for the selected pins.
 169:hardware.c    ****                                       This parameter can be a value of @ref GPIOSpeed_TypeDef */
 170:hardware.c    **** 
 171:hardware.c    ****   GPIOMode_TypeDef GPIO_Mode;    /*!< Specifies the operating mode for the selected pins.
 172:hardware.c    ****                                       This parameter can be a value of @ref GPIOMode_TypeDef */
 173:hardware.c    **** }GPIO_InitTypeDef;
 174:hardware.c    **** 
 175:hardware.c    **** typedef struct
 176:hardware.c    **** {
 177:hardware.c    ****   __IO uint32_t CRL;
 178:hardware.c    ****   __IO uint32_t CRH;
 179:hardware.c    ****   __IO uint32_t IDR;
 180:hardware.c    ****   __IO uint32_t ODR;
 181:hardware.c    ****   __IO uint32_t BSRR;
 182:hardware.c    ****   __IO uint32_t BRR;
 183:hardware.c    ****   __IO uint32_t LCKR;
 184:hardware.c    **** } GPIO_TypeDef;
 185:hardware.c    **** #define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias regi
 186:hardware.c    **** 
 187:hardware.c    **** #define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band r
 188:hardware.c    **** 
 189:hardware.c    **** #define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address */
 190:hardware.c    **** 
 191:hardware.c    **** /*!< Peripheral memory map */
 192:hardware.c    **** #define APB1PERIPH_BASE       PERIPH_BASE
 193:hardware.c    **** #define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
 194:hardware.c    **** 
 195:hardware.c    **** #define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
 196:hardware.c    **** #define USART1              ((USART_TypeDef *) USART1_BASE)
 197:hardware.c    **** 
 198:hardware.c    **** #define USART_WordLength_8b                  ((uint16_t)0x0000)
 199:hardware.c    **** #define USART_WordLength_9b                  ((uint16_t)0x1000)
 200:hardware.c    ****                                     
 201:hardware.c    **** #define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
 202:hardware.c    ****                                       ((LENGTH) == USART_WordLength_9b))
 203:hardware.c    **** /**
 204:hardware.c    ****   * @}
 205:hardware.c    ****   */ 
 206:hardware.c    **** 
 207:hardware.c    **** /** @defgroup USART_Stop_Bits 
 208:hardware.c    ****   * @{
 209:hardware.c    ****   */ 
 210:hardware.c    ****   
 211:hardware.c    **** #define USART_StopBits_1                     ((uint16_t)0x0000)
 212:hardware.c    **** #define USART_StopBits_0_5                   ((uint16_t)0x1000)
 213:hardware.c    **** #define USART_StopBits_2                     ((uint16_t)0x2000)
 214:hardware.c    **** #define USART_StopBits_1_5                   ((uint16_t)0x3000)
 215:hardware.c    **** #define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
 216:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_0_5) || \
 217:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_2) || \
 218:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_1_5))
 219:hardware.c    **** /**
 220:hardware.c    ****   * @}
 221:hardware.c    ****   */ 
 222:hardware.c    **** 
 223:hardware.c    **** /** @defgroup USART_Parity 
 224:hardware.c    ****   * @{
 225:hardware.c    ****   */ 
 226:hardware.c    ****   
 227:hardware.c    **** #define USART_Parity_No                      ((uint16_t)0x0000)
 228:hardware.c    **** #define USART_Parity_Even                    ((uint16_t)0x0400)
 229:hardware.c    **** #define USART_Parity_Odd                     ((uint16_t)0x0600) 
 230:hardware.c    **** #define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
 231:hardware.c    ****                                  ((PARITY) == USART_Parity_Even) || \
 232:hardware.c    ****                                  ((PARITY) == USART_Parity_Odd))
 233:hardware.c    **** /**
 234:hardware.c    ****   * @}
 235:hardware.c    ****   */ 
 236:hardware.c    **** 
 237:hardware.c    **** /** @defgroup USART_Mode 
 238:hardware.c    ****   * @{
 239:hardware.c    ****   */ 
 240:hardware.c    ****   
 241:hardware.c    **** #define USART_Mode_Rx                        ((uint16_t)0x0004)
 242:hardware.c    **** #define USART_Mode_Tx                        ((uint16_t)0x0008)
 243:hardware.c    **** #define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))
 244:hardware.c    **** /**
 245:hardware.c    ****   * @}
 246:hardware.c    ****   */ 
 247:hardware.c    **** 
 248:hardware.c    **** /** @defgroup USART_Hardware_Flow_Control 
 249:hardware.c    ****   * @{
 250:hardware.c    ****   */ 
 251:hardware.c    **** #define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
 252:hardware.c    **** #define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
 253:hardware.c    **** #define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
 254:hardware.c    **** #define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
 255:hardware.c    **** #define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
 256:hardware.c    ****                               (((CONTROL) == USART_HardwareFlowControl_None) || \
 257:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_RTS) || \
 258:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_CTS) || \
 259:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
 260:hardware.c    **** /**
 261:hardware.c    ****   * @}
 262:hardware.c    ****   */ 
 263:hardware.c    **** 
 264:hardware.c    **** /** @defgroup USART_Clock 
 265:hardware.c    ****   * @{
 266:hardware.c    ****   */ 
 267:hardware.c    **** #define USART_Clock_Disable                  ((uint16_t)0x0000)
 268:hardware.c    **** #define USART_Clock_Enable                   ((uint16_t)0x0800)
 269:hardware.c    **** #define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
 270:hardware.c    ****                                ((CLOCK) == USART_Clock_Enable))
 271:hardware.c    **** /**
 272:hardware.c    ****   * @}
 273:hardware.c    ****   */ 
 274:hardware.c    **** 
 275:hardware.c    **** extern void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
 276:hardware.c    **** extern void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
 277:hardware.c    **** #define RCC_APB2Periph_USART1            ((uint32_t)0x00004000)
 278:hardware.c    **** #define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)
 279:hardware.c    **** #define RCC_APB2Periph_AFIO              ((uint32_t)0x00000001)
 280:hardware.c    **** #define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected */
 281:hardware.c    **** #define GPIO_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected */
 282:hardware.c    **** 
 283:hardware.c    **** #define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!< Transmit Data Regis
 284:hardware.c    **** 
 285:hardware.c    **** //DebugLog
 286:hardware.c    **** #ifdef DEBUG
 287:hardware.c    **** void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
 288:hardware.c    **** {
 230              		.loc 1 288 0
 231              		.cfi_startproc
 232              		@ args = 0, pretend = 0, frame = 0
 233              		@ frame_needed = 0, uses_anonymous_args = 0
 234              		@ link register save eliminated.
 235              	.LVL30:
 236              	.L24:
 289:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 237              		.loc 1 289 0 discriminator 1
 238 0000 0388     		ldrh	r3, [r0]
 239 0002 1B06     		lsls	r3, r3, #24
 240 0004 FCD5     		bpl	.L24
 290:hardware.c    ****   USARTx->DR = ch;  
 241              		.loc 1 290 0
 242 0006 8180     		strh	r1, [r0, #4]	@ movhi
 243 0008 7047     		bx	lr
 244              		.cfi_endproc
 245              	.LFE3:
 247 000a 00BF     		.section	.text.UU_PutString,"ax",%progbits
 248              		.align	2
 249              		.global	UU_PutString
 250              		.thumb
 251              		.thumb_func
 253              	UU_PutString:
 254              	.LFB4:
 291:hardware.c    **** }
 292:hardware.c    **** 
 293:hardware.c    **** void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
 294:hardware.c    **** {
 255              		.loc 1 294 0
 256              		.cfi_startproc
 257              		@ args = 0, pretend = 0, frame = 0
 258              		@ frame_needed = 0, uses_anonymous_args = 0
 259              		@ link register save eliminated.
 260              	.LVL31:
 295:hardware.c    ****   while(*str != 0)
 261              		.loc 1 295 0
 262 0000 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 263 0002 3AB1     		cbz	r2, .L25
 264              	.LVL32:
 265              	.L28:
 266              	.LBB40:
 267              	.LBB41:
 289:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 268              		.loc 1 289 0
 269 0004 0388     		ldrh	r3, [r0]
 270 0006 1B06     		lsls	r3, r3, #24
 271 0008 FCD5     		bpl	.L28
 290:hardware.c    ****   USARTx->DR = ch;  
 272              		.loc 1 290 0
 273 000a 8280     		strh	r2, [r0, #4]	@ movhi
 274              	.LVL33:
 275              	.LBE41:
 276              	.LBE40:
 277              		.loc 1 295 0
 278 000c 11F8012F 		ldrb	r2, [r1, #1]!	@ zero_extendqisi2
 279              	.LVL34:
 280 0010 002A     		cmp	r2, #0
 281 0012 F7D1     		bne	.L28
 282              	.LVL35:
 283              	.L25:
 284 0014 7047     		bx	lr
 285              		.cfi_endproc
 286              	.LFE4:
 288 0016 00BF     		.section	.text.vprint,"ax",%progbits
 289              		.align	2
 290              		.global	vprint
 291              		.thumb
 292              		.thumb_func
 294              	vprint:
 295              	.LFB5:
 296:hardware.c    ****   {
 297:hardware.c    ****     UU_PutChar(USARTx, *str);
 298:hardware.c    ****     str++;
 299:hardware.c    ****   }
 300:hardware.c    **** }
 301:hardware.c    **** 
 302:hardware.c    **** void vprint(const char *fmt, va_list argp)
 303:hardware.c    **** {
 296              		.loc 1 303 0
 297              		.cfi_startproc
 298              		@ args = 0, pretend = 0, frame = 200
 299              		@ frame_needed = 0, uses_anonymous_args = 0
 300              	.LVL36:
 301 0000 10B5     		push	{r4, lr}
 302              		.cfi_def_cfa_offset 8
 303              		.cfi_offset 4, -8
 304              		.cfi_offset 14, -4
 305 0002 B2B0     		sub	sp, sp, #200
 306              		.cfi_def_cfa_offset 208
 307              		.loc 1 303 0
 308 0004 0A46     		mov	r2, r1
 304:hardware.c    ****     char string[200];
 305:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
 309              		.loc 1 305 0
 310 0006 0146     		mov	r1, r0
 311              	.LVL37:
 312 0008 6846     		mov	r0, sp
 313              	.LVL38:
 314 000a FFF7FEFF 		bl	vsprintf
 315              	.LVL39:
 316 000e 0028     		cmp	r0, #0
 317 0010 0DDD     		ble	.L34
 318              	.LVL40:
 319              	.LBB46:
 320              	.LBB47:
 295:hardware.c    ****   while(*str != 0)
 321              		.loc 1 295 0
 322 0012 9DF80010 		ldrb	r1, [sp]	@ zero_extendqisi2
 323 0016 51B1     		cbz	r1, .L34
 324              	.LBB48:
 325              	.LBB49:
 289:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 326              		.loc 1 289 0
 327 0018 064A     		ldr	r2, .L46
 328 001a 6846     		mov	r0, sp
 329 001c 1446     		mov	r4, r2
 330              	.LVL41:
 331              	.L38:
 332 001e 1388     		ldrh	r3, [r2]
 333 0020 1B06     		lsls	r3, r3, #24
 334 0022 FCD5     		bpl	.L38
 290:hardware.c    ****   USARTx->DR = ch;  
 335              		.loc 1 290 0
 336 0024 A180     		strh	r1, [r4, #4]	@ movhi
 337              	.LVL42:
 338              	.LBE49:
 339              	.LBE48:
 295:hardware.c    ****   while(*str != 0)
 340              		.loc 1 295 0
 341 0026 10F8011F 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 342              	.LVL43:
 343 002a 0029     		cmp	r1, #0
 344 002c F7D1     		bne	.L38
 345              	.LVL44:
 346              	.L34:
 347              	.LBE47:
 348              	.LBE46:
 306:hardware.c    ****     {
 307:hardware.c    ****         UU_PutString(USART1, (uint8_t*)string); // send message via UART
 308:hardware.c    **** 
 309:hardware.c    ****     }
 310:hardware.c    **** }
 349              		.loc 1 310 0
 350 002e 32B0     		add	sp, sp, #200
 351              		@ sp needed
 352 0030 10BD     		pop	{r4, pc}
 353              	.L47:
 354 0032 00BF     		.align	2
 355              	.L46:
 356 0034 00380140 		.word	1073821696
 357              		.cfi_endproc
 358              	.LFE5:
 360              		.section	.text.uart_printf,"ax",%progbits
 361              		.align	2
 362              		.global	uart_printf
 363              		.thumb
 364              		.thumb_func
 366              	uart_printf:
 367              	.LFB6:
 311:hardware.c    **** 
 312:hardware.c    **** void uart_printf(const char *fmt, ...) // custom printf() function
 313:hardware.c    **** {
 368              		.loc 1 313 0
 369              		.cfi_startproc
 370              		@ args = 4, pretend = 16, frame = 208
 371              		@ frame_needed = 0, uses_anonymous_args = 1
 372              	.LVL45:
 373 0000 0FB4     		push	{r0, r1, r2, r3}
 374              		.cfi_def_cfa_offset 16
 375              		.cfi_offset 0, -16
 376              		.cfi_offset 1, -12
 377              		.cfi_offset 2, -8
 378              		.cfi_offset 3, -4
 379 0002 10B5     		push	{r4, lr}
 380              		.cfi_def_cfa_offset 24
 381              		.cfi_offset 4, -24
 382              		.cfi_offset 14, -20
 383 0004 B4B0     		sub	sp, sp, #208
 384              		.cfi_def_cfa_offset 232
 385              		.loc 1 313 0
 386 0006 36AB     		add	r3, sp, #216
 387 0008 53F8041B 		ldr	r1, [r3], #4
 388              	.LBB56:
 389              	.LBB57:
 305:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
 390              		.loc 1 305 0
 391 000c 02A8     		add	r0, sp, #8
 392 000e 1A46     		mov	r2, r3
 393              	.LBE57:
 394              	.LBE56:
 314:hardware.c    ****     va_list argp;
 315:hardware.c    ****     va_start(argp, fmt);
 395              		.loc 1 315 0
 396 0010 0193     		str	r3, [sp, #4]
 397              	.LVL46:
 398              	.LBB63:
 399              	.LBB62:
 305:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
 400              		.loc 1 305 0
 401 0012 FFF7FEFF 		bl	vsprintf
 402              	.LVL47:
 403 0016 0028     		cmp	r0, #0
 404 0018 0DDD     		ble	.L48
 405              	.LVL48:
 406              	.LBB58:
 407              	.LBB59:
 295:hardware.c    ****   while(*str != 0)
 408              		.loc 1 295 0
 409 001a 9DF80810 		ldrb	r1, [sp, #8]	@ zero_extendqisi2
 410 001e 51B1     		cbz	r1, .L48
 411              	.LBB60:
 412              	.LBB61:
 289:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 413              		.loc 1 289 0
 414 0020 074A     		ldr	r2, .L60
 415 0022 02A8     		add	r0, sp, #8
 416              	.LVL49:
 417 0024 1446     		mov	r4, r2
 418              	.LVL50:
 419              	.L52:
 420 0026 1388     		ldrh	r3, [r2]
 421 0028 1B06     		lsls	r3, r3, #24
 422 002a FCD5     		bpl	.L52
 290:hardware.c    ****   USARTx->DR = ch;  
 423              		.loc 1 290 0
 424 002c A180     		strh	r1, [r4, #4]	@ movhi
 425              	.LVL51:
 426              	.LBE61:
 427              	.LBE60:
 295:hardware.c    ****   while(*str != 0)
 428              		.loc 1 295 0
 429 002e 10F8011F 		ldrb	r1, [r0, #1]!	@ zero_extendqisi2
 430              	.LVL52:
 431 0032 0029     		cmp	r1, #0
 432 0034 F7D1     		bne	.L52
 433              	.LVL53:
 434              	.L48:
 435              	.LBE59:
 436              	.LBE58:
 437              	.LBE62:
 438              	.LBE63:
 316:hardware.c    ****     vprint(fmt, argp);
 317:hardware.c    ****     va_end(argp);
 318:hardware.c    **** }
 439              		.loc 1 318 0
 440 0036 34B0     		add	sp, sp, #208
 441              		@ sp needed
 442 0038 BDE81040 		pop	{r4, lr}
 443              	.LVL54:
 444 003c 04B0     		add	sp, sp, #16
 445              	.LVL55:
 446 003e 7047     		bx	lr
 447              	.L61:
 448              		.align	2
 449              	.L60:
 450 0040 00380140 		.word	1073821696
 451              		.cfi_endproc
 452              	.LFE6:
 454              		.section	.text.uartInit,"ax",%progbits
 455              		.align	2
 456              		.global	uartInit
 457              		.thumb
 458              		.thumb_func
 460              	uartInit:
 461              	.LFB8:
 319:hardware.c    **** 
 320:hardware.c    **** static void hexdump(unsigned char *data, size_t size)
 321:hardware.c    **** {
 322:hardware.c    ****     int i;
 323:hardware.c    ****     char cs[17];
 324:hardware.c    ****     memset(cs, 0, 17);
 325:hardware.c    **** 
 326:hardware.c    ****     for(i = 0; i < size; i++)
 327:hardware.c    ****     {
 328:hardware.c    ****         if(i != 0 && i % 0x10 == 0)
 329:hardware.c    ****         {
 330:hardware.c    ****             uart_printf(" |%s|\n", cs);
 331:hardware.c    ****             memset(cs, 0, 17);
 332:hardware.c    ****         }
 333:hardware.c    ****         else if(i != 0 && i % 0x8 == 0)
 334:hardware.c    ****         {
 335:hardware.c    ****             uart_printf(" ");
 336:hardware.c    ****         }
 337:hardware.c    ****         uart_printf("%02X ", data[i]);
 338:hardware.c    ****         cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
 339:hardware.c    ****     }
 340:hardware.c    **** 
 341:hardware.c    ****     i = i % 0x10;
 342:hardware.c    ****     if(i != 0)
 343:hardware.c    ****     {
 344:hardware.c    ****         if(i <= 0x8)
 345:hardware.c    ****         {
 346:hardware.c    ****             uart_printf(" ");
 347:hardware.c    ****         }
 348:hardware.c    ****         while(i++ < 0x10)
 349:hardware.c    ****         {
 350:hardware.c    ****             uart_printf("   ");
 351:hardware.c    ****         }
 352:hardware.c    ****     }
 353:hardware.c    ****     uart_printf(" |%s|\n", cs);
 354:hardware.c    **** }
 355:hardware.c    **** 
 356:hardware.c    **** 
 357:hardware.c    **** #endif
 358:hardware.c    **** void uartInit(void) {
 462              		.loc 1 358 0
 463              		.cfi_startproc
 464              		@ args = 0, pretend = 0, frame = 24
 465              		@ frame_needed = 0, uses_anonymous_args = 0
 466 0000 70B5     		push	{r4, r5, r6, lr}
 467              		.cfi_def_cfa_offset 16
 468              		.cfi_offset 4, -16
 469              		.cfi_offset 5, -12
 470              		.cfi_offset 6, -8
 471              		.cfi_offset 14, -4
 359:hardware.c    ****     GPIO_InitTypeDef GPIO_InitStructure;
 360:hardware.c    ****     USART_InitTypeDef USART_InitStructure;
 361:hardware.c    ****     
 362:hardware.c    ****     /* Enable peripheral clocks for USART1 on GPIOA */
 363:hardware.c    ****     //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
 364:hardware.c    ****     RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 365:hardware.c    ****         RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
 472              		.loc 1 365 0
 473 0002 1F4C     		ldr	r4, .L63
 358:hardware.c    **** void uartInit(void) {
 474              		.loc 1 358 0
 475 0004 86B0     		sub	sp, sp, #24
 476              		.cfi_def_cfa_offset 40
 364:hardware.c    ****     RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 477              		.loc 1 364 0
 478 0006 4FF48040 		mov	r0, #16384
 479 000a 0121     		movs	r1, #1
 480 000c FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 481              	.LVL56:
 482              		.loc 1 365 0
 483 0010 2046     		mov	r0, r4
 484 0012 0121     		movs	r1, #1
 485 0014 FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 486              	.LVL57:
 366:hardware.c    ****     /* Configure PA9 and PA10 as USART1 TX/RX */
 367:hardware.c    ****     
 368:hardware.c    ****     /* PA9 = alternate function push/pull output */
 369:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 370:hardware.c    ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 371:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 372:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 373:hardware.c    ****     
 374:hardware.c    ****     /* PA10 = floating input */
 375:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 376:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 377:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 378:hardware.c    ****     
 379:hardware.c    ****     /* Configure and initialize usart... */
 380:hardware.c    ****     USART_InitStructure.USART_BaudRate = 115200;
 381:hardware.c    ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 382:hardware.c    ****     USART_InitStructure.USART_StopBits = USART_StopBits_1;
 383:hardware.c    ****     USART_InitStructure.USART_Parity = USART_Parity_No;
 384:hardware.c    ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 385:hardware.c    ****     USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 386:hardware.c    ****         
 387:hardware.c    ****     USART_Init(USART1, &USART_InitStructure);
 487              		.loc 1 387 0
 488 0018 1A4D     		ldr	r5, .L63+4
 372:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 489              		.loc 1 372 0
 490 001a 2046     		mov	r0, r4
 491 001c 01A9     		add	r1, sp, #4
 370:hardware.c    ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 492              		.loc 1 370 0
 493 001e 0322     		movs	r2, #3
 371:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 494              		.loc 1 371 0
 495 0020 1823     		movs	r3, #24
 369:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 496              		.loc 1 369 0
 497 0022 4FF40076 		mov	r6, #512
 370:hardware.c    ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 498              		.loc 1 370 0
 499 0026 8DF80620 		strb	r2, [sp, #6]
 371:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 500              		.loc 1 371 0
 501 002a 8DF80730 		strb	r3, [sp, #7]
 369:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 502              		.loc 1 369 0
 503 002e ADF80460 		strh	r6, [sp, #4]	@ movhi
 372:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 504              		.loc 1 372 0
 505 0032 FFF7FEFF 		bl	GPIO_Init
 506              	.LVL58:
 377:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 507              		.loc 1 377 0
 508 0036 2046     		mov	r0, r4
 509 0038 01A9     		add	r1, sp, #4
 375:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 510              		.loc 1 375 0
 511 003a 4FF48062 		mov	r2, #1024
 376:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 512              		.loc 1 376 0
 513 003e 0423     		movs	r3, #4
 375:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 514              		.loc 1 375 0
 515 0040 ADF80420 		strh	r2, [sp, #4]	@ movhi
 376:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 516              		.loc 1 376 0
 517 0044 8DF80730 		strb	r3, [sp, #7]
 380:hardware.c    ****     USART_InitStructure.USART_BaudRate = 115200;
 518              		.loc 1 380 0
 519 0048 4FF4E134 		mov	r4, #115200
 377:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 520              		.loc 1 377 0
 521 004c FFF7FEFF 		bl	GPIO_Init
 522              	.LVL59:
 381:hardware.c    ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 523              		.loc 1 381 0
 524 0050 0023     		movs	r3, #0
 385:hardware.c    ****     USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 525              		.loc 1 385 0
 526 0052 0C22     		movs	r2, #12
 527              		.loc 1 387 0
 528 0054 02A9     		add	r1, sp, #8
 529 0056 2846     		mov	r0, r5
 381:hardware.c    ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 530              		.loc 1 381 0
 531 0058 ADF80C30 		strh	r3, [sp, #12]	@ movhi
 382:hardware.c    ****     USART_InitStructure.USART_StopBits = USART_StopBits_1;
 532              		.loc 1 382 0
 533 005c ADF80E30 		strh	r3, [sp, #14]	@ movhi
 383:hardware.c    ****     USART_InitStructure.USART_Parity = USART_Parity_No;
 534              		.loc 1 383 0
 535 0060 ADF81030 		strh	r3, [sp, #16]	@ movhi
 384:hardware.c    ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 536              		.loc 1 384 0
 537 0064 ADF81430 		strh	r3, [sp, #20]	@ movhi
 385:hardware.c    ****     USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 538              		.loc 1 385 0
 539 0068 ADF81220 		strh	r2, [sp, #18]	@ movhi
 380:hardware.c    ****     USART_InitStructure.USART_BaudRate = 115200;
 540              		.loc 1 380 0
 541 006c 0294     		str	r4, [sp, #8]
 542              		.loc 1 387 0
 543 006e FFF7FEFF 		bl	USART_Init
 544              	.LVL60:
 388:hardware.c    ****     
 389:hardware.c    ****     /* Enable USART1 */
 390:hardware.c    ****     USART_Cmd(USART1, ENABLE);   
 545              		.loc 1 390 0
 546 0072 2846     		mov	r0, r5
 547 0074 0121     		movs	r1, #1
 548 0076 FFF7FEFF 		bl	USART_Cmd
 549              	.LVL61:
 391:hardware.c    **** }
 550              		.loc 1 391 0
 551 007a 06B0     		add	sp, sp, #24
 552              		@ sp needed
 553 007c 70BD     		pop	{r4, r5, r6, pc}
 554              	.L64:
 555 007e 00BF     		.align	2
 556              	.L63:
 557 0080 00080140 		.word	1073809408
 558 0084 00380140 		.word	1073821696
 559              		.cfi_endproc
 560              	.LFE8:
 562              		.section	.text.systemReset,"ax",%progbits
 563              		.align	2
 564              		.global	systemReset
 565              		.thumb
 566              		.thumb_func
 568              	systemReset:
 569              	.LFB9:
 392:hardware.c    **** 
 393:hardware.c    **** void systemReset(void) {
 570              		.loc 1 393 0
 571              		.cfi_startproc
 572              		@ args = 0, pretend = 0, frame = 0
 573              		@ frame_needed = 0, uses_anonymous_args = 0
 574              		@ link register save eliminated.
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 575              		.loc 1 394 0
 576 0000 0F4B     		ldr	r3, .L66
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 577              		.loc 1 395 0
 578 0002 104A     		ldr	r2, .L66+4
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 579              		.loc 1 394 0
 580 0004 1868     		ldr	r0, [r3]
 393:hardware.c    **** void systemReset(void) {
 581              		.loc 1 393 0
 582 0006 10B4     		push	{r4}
 583              		.cfi_def_cfa_offset 4
 584              		.cfi_offset 4, -4
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 585              		.loc 1 394 0
 586 0008 40F00100 		orr	r0, r0, #1
 587 000c 1860     		str	r0, [r3]
 588              		.loc 1 395 0
 589 000e 1468     		ldr	r4, [r2]
 590 0010 0D49     		ldr	r1, .L66+8
 396:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 397:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
 398:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 399:hardware.c    **** 
 400:hardware.c    ****     SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
 591              		.loc 1 400 0
 592 0012 0E48     		ldr	r0, .L66+12
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 593              		.loc 1 395 0
 594 0014 2140     		ands	r1, r1, r4
 595 0016 1160     		str	r1, [r2]
 396:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 596              		.loc 1 396 0
 597 0018 1968     		ldr	r1, [r3]
 598              		.loc 1 400 0
 599 001a 0024     		movs	r4, #0
 396:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 600              		.loc 1 396 0
 601 001c 21F08471 		bic	r1, r1, #17301504
 602 0020 21F48031 		bic	r1, r1, #65536
 603 0024 1960     		str	r1, [r3]
 397:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
 604              		.loc 1 397 0
 605 0026 1968     		ldr	r1, [r3]
 606 0028 21F48021 		bic	r1, r1, #262144
 607 002c 1960     		str	r1, [r3]
 398:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 608              		.loc 1 398 0
 609 002e 1368     		ldr	r3, [r2]
 610 0030 23F4FE03 		bic	r3, r3, #8323072
 611 0034 1360     		str	r3, [r2]
 612              		.loc 1 400 0
 613 0036 0460     		str	r4, [r0]
 401:hardware.c    **** }
 614              		.loc 1 401 0
 615 0038 5DF8044B 		ldr	r4, [sp], #4
 616 003c 7047     		bx	lr
 617              	.L67:
 618 003e 00BF     		.align	2
 619              	.L66:
 620 0040 00100240 		.word	1073876992
 621 0044 04100240 		.word	1073876996
 622 0048 0000FFF8 		.word	-117506048
 623 004c 08100240 		.word	1073877000
 624              		.cfi_endproc
 625              	.LFE9:
 627              		.section	.text.setupCLK,"ax",%progbits
 628              		.align	2
 629              		.global	setupCLK
 630              		.thumb
 631              		.thumb_func
 633              	setupCLK:
 634              	.LFB10:
 402:hardware.c    **** 
 403:hardware.c    **** void setupCLK(void) {
 635              		.loc 1 403 0
 636              		.cfi_startproc
 637              		@ args = 0, pretend = 0, frame = 0
 638              		@ frame_needed = 0, uses_anonymous_args = 0
 639              		@ link register save eliminated.
 640              	.LVL62:
 404:hardware.c    **** 	unsigned int StartUpCounter=0;
 405:hardware.c    ****     /* enable HSE */
 406:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
 641              		.loc 1 406 0
 642 0000 174B     		ldr	r3, .L75
 643 0002 1A68     		ldr	r2, [r3]
 407:hardware.c    ****     while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
 644              		.loc 1 407 0
 645 0004 1946     		mov	r1, r3
 406:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
 646              		.loc 1 406 0
 647 0006 42F00112 		orr	r2, r2, #65537
 648 000a 1A60     		str	r2, [r3]
 649              	.L70:
 650              		.loc 1 407 0 discriminator 1
 651 000c 0B68     		ldr	r3, [r1]
 652 000e 144A     		ldr	r2, .L75
 653 0010 9803     		lsls	r0, r3, #14
 654 0012 FBD5     		bpl	.L70
 408:hardware.c    **** 
 409:hardware.c    ****     /* enable flash prefetch buffer */
 410:hardware.c    ****     SET_REG(FLASH_ACR, 0x00000012);
 655              		.loc 1 410 0
 656 0014 134B     		ldr	r3, .L75+4
 657 0016 1221     		movs	r1, #18
 411:hardware.c    **** 	
 412:hardware.c    ****      /* Configure PLL */
 413:hardware.c    **** #ifdef XTAL12M
 414:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
 415:hardware.c    **** #else
 416:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
 658              		.loc 1 416 0
 659 0018 1348     		ldr	r0, .L75+8
 410:hardware.c    ****     SET_REG(FLASH_ACR, 0x00000012);
 660              		.loc 1 410 0
 661 001a 1960     		str	r1, [r3]
 662              		.loc 1 416 0
 663 001c 0368     		ldr	r3, [r0]
 417:hardware.c    **** #endif	
 418:hardware.c    **** 
 419:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
 420:hardware.c    **** 	
 421:hardware.c    **** 
 422:hardware.c    **** #if !defined  (HSE_STARTUP_TIMEOUT) 
 423:hardware.c    ****   #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
 424:hardware.c    **** #endif /* HSE_STARTUP_TIMEOUT */   
 425:hardware.c    **** 
 426:hardware.c    ****     while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
 664              		.loc 1 426 0
 665 001e 1146     		mov	r1, r2
 416:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
 666              		.loc 1 416 0
 667 0020 43F4E813 		orr	r3, r3, #1900544
 668 0024 43F48063 		orr	r3, r3, #1024
 669 0028 0360     		str	r3, [r0]
 419:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
 670              		.loc 1 419 0
 671 002a 1368     		ldr	r3, [r2]
 672 002c 43F08073 		orr	r3, r3, #16777216
 673 0030 1360     		str	r3, [r2]
 674              	.L72:
 675              		.loc 1 426 0 discriminator 1
 676 0032 0B68     		ldr	r3, [r1]
 677 0034 13F0407F 		tst	r3, #50331648
 678 0038 FBD0     		beq	.L72
 427:hardware.c    **** 	{
 428:hardware.c    **** //		StartUpCounter++; // This is commented out, so other changes can be committed. It will be uncom
 429:hardware.c    **** 	}	/* wait for it to come on */
 430:hardware.c    **** 
 431:hardware.c    **** 	if (StartUpCounter>=HSE_STARTUP_TIMEOUT)
 432:hardware.c    **** 	{
 433:hardware.c    **** 		// HSE has not started. Try restarting the processor
 434:hardware.c    **** 		systemHardReset(); 
 435:hardware.c    **** 	}
 436:hardware.c    ****     /* Set SYSCLK as PLL */
 437:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
 679              		.loc 1 437 0
 680 003a 0B4B     		ldr	r3, .L75+8
 681 003c 1968     		ldr	r1, [r3]
 438:hardware.c    ****     while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
 682              		.loc 1 438 0
 683 003e 1A46     		mov	r2, r3
 437:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
 684              		.loc 1 437 0
 685 0040 41F00201 		orr	r1, r1, #2
 686 0044 1960     		str	r1, [r3]
 687              	.L74:
 688              		.loc 1 438 0 discriminator 1
 689 0046 1368     		ldr	r3, [r2]
 690 0048 1B07     		lsls	r3, r3, #28
 691 004a FCD5     		bpl	.L74
 439:hardware.c    **** 	
 440:hardware.c    ****     pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
 692              		.loc 1 440 0
 693 004c 044B     		ldr	r3, .L75
 694 004e 9A69     		ldr	r2, [r3, #24]
 695 0050 42F4FE72 		orr	r2, r2, #508
 696 0054 9A61     		str	r2, [r3, #24]
 441:hardware.c    **** 	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
 697              		.loc 1 441 0
 698 0056 DA69     		ldr	r2, [r3, #28]
 699 0058 42F40002 		orr	r2, r2, #8388608
 700 005c DA61     		str	r2, [r3, #28]
 701 005e 7047     		bx	lr
 702              	.L76:
 703              		.align	2
 704              	.L75:
 705 0060 00100240 		.word	1073876992
 706 0064 00200240 		.word	1073881088
 707 0068 04100240 		.word	1073876996
 708              		.cfi_endproc
 709              	.LFE10:
 711              		.section	.text.setupLEDAndButton,"ax",%progbits
 712              		.align	2
 713              		.global	setupLEDAndButton
 714              		.thumb
 715              		.thumb_func
 717              	setupLEDAndButton:
 718              	.LFB11:
 442:hardware.c    **** 
 443:hardware.c    **** }
 444:hardware.c    **** 
 445:hardware.c    **** void setupLEDAndButton (void) { 
 719              		.loc 1 445 0
 720              		.cfi_startproc
 721              		@ args = 0, pretend = 0, frame = 0
 722              		@ frame_needed = 0, uses_anonymous_args = 0
 723              		@ link register save eliminated.
 446:hardware.c    ****   SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUT
 724              		.loc 1 446 0
 725 0000 034B     		ldr	r3, .L78
 726 0002 1A68     		ldr	r2, [r3]
 727              	.LVL63:
 728 0004 22F47002 		bic	r2, r2, #15728640
 729 0008 42F48012 		orr	r2, r2, #1048576
 730 000c 1A60     		str	r2, [r3]
 731 000e 7047     		bx	lr
 732              	.L79:
 733              		.align	2
 734              	.L78:
 735 0010 04100140 		.word	1073811460
 736              		.cfi_endproc
 737              	.LFE11:
 739              		.section	.text.setupFLASH,"ax",%progbits
 740              		.align	2
 741              		.global	setupFLASH
 742              		.thumb
 743              		.thumb_func
 745              	setupFLASH:
 746              	.LFB12:
 447:hardware.c    **** }
 448:hardware.c    **** 
 449:hardware.c    **** void setupFLASH() {
 747              		.loc 1 449 0
 748              		.cfi_startproc
 749              		@ args = 0, pretend = 0, frame = 0
 750              		@ frame_needed = 0, uses_anonymous_args = 0
 751              		@ link register save eliminated.
 450:hardware.c    ****     /* configure the HSI oscillator */
 451:hardware.c    ****     if ((pRCC->CR & 0x01) == 0x00) {
 752              		.loc 1 451 0
 753 0000 064B     		ldr	r3, .L84
 754 0002 1A68     		ldr	r2, [r3]
 755 0004 D207     		lsls	r2, r2, #31
 756 0006 03D4     		bmi	.L81
 757              	.LBB64:
 452:hardware.c    ****         u32 rwmVal = pRCC->CR;
 758              		.loc 1 452 0
 759 0008 1A68     		ldr	r2, [r3]
 760              	.LVL64:
 453:hardware.c    ****         rwmVal |= 0x01;
 761              		.loc 1 453 0
 762 000a 42F00102 		orr	r2, r2, #1
 763              	.LVL65:
 454:hardware.c    ****         pRCC->CR = rwmVal;
 764              		.loc 1 454 0
 765 000e 1A60     		str	r2, [r3]
 766              	.LVL66:
 767              	.L81:
 768              	.LBE64:
 455:hardware.c    ****     }
 456:hardware.c    **** 
 457:hardware.c    ****     /* wait for it to come on */
 458:hardware.c    ****     while ((pRCC->CR & 0x02) == 0x00) {}
 769              		.loc 1 458 0 discriminator 1
 770 0010 024A     		ldr	r2, .L84
 771              	.L83:
 772 0012 1368     		ldr	r3, [r2]
 773 0014 9B07     		lsls	r3, r3, #30
 774 0016 FCD5     		bpl	.L83
 459:hardware.c    **** }   
 775              		.loc 1 459 0
 776 0018 7047     		bx	lr
 777              	.L85:
 778 001a 00BF     		.align	2
 779              	.L84:
 780 001c 00100240 		.word	1073876992
 781              		.cfi_endproc
 782              	.LFE12:
 784              		.section	.text.uid_read,"ax",%progbits
 785              		.align	2
 786              		.global	uid_read
 787              		.thumb
 788              		.thumb_func
 790              	uid_read:
 791              	.LFB13:
 460:hardware.c    **** 
 461:hardware.c    **** /* Read U_ID register */
 462:hardware.c    **** void uid_read(struct u_id *id)
 463:hardware.c    **** {
 792              		.loc 1 463 0
 793              		.cfi_startproc
 794              		@ args = 0, pretend = 0, frame = 0
 795              		@ frame_needed = 0, uses_anonymous_args = 0
 796              		@ link register save eliminated.
 797              	.LVL67:
 464:hardware.c    ****     id->off0 = MMIO16(U_ID + 0x0);
 798              		.loc 1 464 0
 799 0000 064B     		ldr	r3, .L87
 465:hardware.c    ****     id->off2 = MMIO16(U_ID + 0x2);
 800              		.loc 1 465 0
 801 0002 074A     		ldr	r2, .L87+4
 464:hardware.c    ****     id->off0 = MMIO16(U_ID + 0x0);
 802              		.loc 1 464 0
 803 0004 1988     		ldrh	r1, [r3]
 466:hardware.c    ****     id->off4 = MMIO32(U_ID + 0x4);
 804              		.loc 1 466 0
 805 0006 0433     		adds	r3, r3, #4
 464:hardware.c    ****     id->off0 = MMIO16(U_ID + 0x0);
 806              		.loc 1 464 0
 807 0008 0180     		strh	r1, [r0]	@ movhi
 465:hardware.c    ****     id->off2 = MMIO16(U_ID + 0x2);
 808              		.loc 1 465 0
 809 000a 1288     		ldrh	r2, [r2]
 810              		.loc 1 466 0
 811 000c 1B68     		ldr	r3, [r3]
 467:hardware.c    ****     id->off8 = MMIO32(U_ID + 0x8);
 812              		.loc 1 467 0
 813 000e 0549     		ldr	r1, .L87+8
 466:hardware.c    ****     id->off4 = MMIO32(U_ID + 0x4);
 814              		.loc 1 466 0
 815 0010 4360     		str	r3, [r0, #4]
 816              		.loc 1 467 0
 817 0012 0B68     		ldr	r3, [r1]
 465:hardware.c    ****     id->off2 = MMIO16(U_ID + 0x2);
 818              		.loc 1 465 0
 819 0014 4280     		strh	r2, [r0, #2]	@ movhi
 820              		.loc 1 467 0
 821 0016 8360     		str	r3, [r0, #8]
 822 0018 7047     		bx	lr
 823              	.L88:
 824 001a 00BF     		.align	2
 825              	.L87:
 826 001c E8F7FF1F 		.word	536868840
 827 0020 EAF7FF1F 		.word	536868842
 828 0024 F0F7FF1F 		.word	536868848
 829              		.cfi_endproc
 830              	.LFE13:
 832              		.section	.text.checkUserCode,"ax",%progbits
 833              		.align	2
 834              		.global	checkUserCode
 835              		.thumb
 836              		.thumb_func
 838              	checkUserCode:
 839              	.LFB14:
 468:hardware.c    **** }
 469:hardware.c    **** 
 470:hardware.c    **** int checkUserCode(u32 usrAddr) {
 840              		.loc 1 470 0
 841              		.cfi_startproc
 842              		@ args = 0, pretend = 0, frame = 392
 843              		@ frame_needed = 0, uses_anonymous_args = 0
 844              	.LVL68:
 845 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 846              		.cfi_def_cfa_offset 20
 847              		.cfi_offset 4, -20
 848              		.cfi_offset 5, -16
 849              		.cfi_offset 6, -12
 850              		.cfi_offset 7, -8
 851              		.cfi_offset 14, -4
 852 0002 E5B0     		sub	sp, sp, #404
 853              		.cfi_def_cfa_offset 424
 854              		.loc 1 470 0
 855 0004 0446     		mov	r4, r0
 471:hardware.c    ****     // get hash written to top of stage 2
 472:hardware.c    ****     unsigned char writtenHash[32];
 473:hardware.c    ****     memset(writtenHash, 0xFF, sizeof(writtenHash));
 856              		.loc 1 473 0
 857 0006 FF21     		movs	r1, #255
 858 0008 2022     		movs	r2, #32
 859 000a 0BA8     		add	r0, sp, #44
 860              	.LVL69:
 861 000c FFF7FEFF 		bl	memset
 862              	.LVL70:
 474:hardware.c    ****     memcpy(writtenHash, (vu32 *)usrAddr, 0x20);
 863              		.loc 1 474 0
 864 0010 2068     		ldr	r0, [r4]	@ unaligned
 865 0012 6168     		ldr	r1, [r4, #4]	@ unaligned
 866 0014 A268     		ldr	r2, [r4, #8]	@ unaligned
 867 0016 E368     		ldr	r3, [r4, #12]	@ unaligned
 868 0018 0BAD     		add	r5, sp, #44
 869 001a 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 870 001c 2069     		ldr	r0, [r4, #16]	@ unaligned
 871 001e 6169     		ldr	r1, [r4, #20]	@ unaligned
 872 0020 A269     		ldr	r2, [r4, #24]	@ unaligned
 873 0022 E369     		ldr	r3, [r4, #28]	@ unaligned
 874 0024 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 475:hardware.c    **** 
 476:hardware.c    ****     // hax to see if our firmware is where it should be
 477:hardware.c    ****     if (!memcmp(writtenHash, 0xFF, 32))
 875              		.loc 1 477 0
 876 0026 0BA8     		add	r0, sp, #44
 877 0028 FF21     		movs	r1, #255
 878 002a 2022     		movs	r2, #32
 879 002c FFF7FEFF 		bl	memcmp
 880              	.LVL71:
 881 0030 08B9     		cbnz	r0, .L103
 478:hardware.c    ****     {
 479:hardware.c    ****       return 0x0;
 480:hardware.c    ****     }
 481:hardware.c    **** 
 482:hardware.c    ****     // get signature from stage 2 image
 483:hardware.c    ****     uint8_t signature[EDSIGN_SIGNATURE_SIZE];
 484:hardware.c    ****     memset(signature, 0xFF, sizeof(signature));
 485:hardware.c    ****     memcpy(signature,  (vu32 *)(usrAddr+0x20), 0x40);
 486:hardware.c    **** 
 487:hardware.c    ****     // prepare hash
 488:hardware.c    ****     unsigned char sha256sum[32];
 489:hardware.c    ****     uint8_t input[0x5C];
 490:hardware.c    **** 
 491:hardware.c    ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
 492:hardware.c    ****     memset(input, 0xFF, sizeof(input));
 493:hardware.c    **** 
 494:hardware.c    ****     sha256_context ctx;
 495:hardware.c    ****     sha256_starts(&ctx);
 496:hardware.c    **** 
 497:hardware.c    ****     // get expected size
 498:hardware.c    ****     int offset = Swap2Bytes(*(int*)((vu32 *)(usrAddr+0x60))) + 0x140;
 499:hardware.c    ****     int i = 0x74;
 500:hardware.c    ****     //feedface is our eof, hi mach ily
 501:hardware.c    ****     char cmpEnd[4] = {0xFE, 0xED, 0xFA, 0xCE};
 502:hardware.c    ****     char buff[0x4];
 503:hardware.c    ****     // read through memory, hash buff, and stop on feedface
 504:hardware.c    ****     while ((usrAddr+i) <= (usrAddr+offset))
 505:hardware.c    ****     {
 506:hardware.c    ****       memset(buff, 0xFF, 0x4);
 507:hardware.c    ****       memcpy(buff, (char *)(usrAddr+i), 0x4);
 508:hardware.c    ****       if (memmem(&buff, 0x4, &cmpEnd, 4) != 0)
 509:hardware.c    ****       {
 510:hardware.c    ****         sha256_update(&ctx, (vu32 *)(usrAddr+i), 0x4);
 511:hardware.c    ****         break;
 512:hardware.c    ****       }
 513:hardware.c    ****       sha256_update(&ctx, (vu32 *)(usrAddr+i), 0x4);
 514:hardware.c    ****       i += 0x4;
 515:hardware.c    ****     }
 516:hardware.c    **** 
 517:hardware.c    ****     // hash in our unique ID
 518:hardware.c    ****     struct u_id id;
 519:hardware.c    ****     uid_read(&id);
 520:hardware.c    ****     unsigned char uniqueID[23];
 521:hardware.c    ****     sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
 522:hardware.c    ****     uart_printf("%X%X%X%X\n", id.off0, id.off2, id.off4, id.off8);
 523:hardware.c    ****     sha256_update(&ctx, uniqueID, 23);
 524:hardware.c    ****     sha256_finish(&ctx, sha256sum);
 525:hardware.c    **** 
 526:hardware.c    ****     print_hash(sha256sum);
 527:hardware.c    **** 
 528:hardware.c    ****   uint8_t rootCA[32] = {
 529:hardware.c    ****        0xf3,0x47,0xb9,0x5e,0x5f,0x03,0x62,0x13,
 530:hardware.c    ****        0xf3,0x88,0x72,0x73,0xea,0xcf,0x91,0x73,
 531:hardware.c    ****        0x35,0xda,0x72,0x68,0xae,0xf6,0x98,0x90,
 532:hardware.c    ****        0x51,0x87,0xff,0xea,0xd6,0xb5,0x5b,0x32
 533:hardware.c    ****     };
 534:hardware.c    ****     // verify signature against recalc hash
 535:hardware.c    ****     if (!edsign_verify(signature, rootCA, sha256sum, 0x20) > 0) {
 536:hardware.c    ****         return 0x1;
 537:hardware.c    ****     }
 538:hardware.c    ****     // verify written hash against recalc hash
 539:hardware.c    ****     if (memcmp(sha256sum, writtenHash, 32)){
 540:hardware.c    ****         return 0x2;
 541:hardware.c    ****     }
 542:hardware.c    ****     return 0x3;
 543:hardware.c    **** }
 882              		.loc 1 543 0
 883 0032 65B0     		add	sp, sp, #404
 884              		@ sp needed
 885 0034 F0BD     		pop	{r4, r5, r6, r7, pc}
 886              	.LVL72:
 887              	.L103:
 484:hardware.c    ****     memset(signature, 0xFF, sizeof(signature));
 888              		.loc 1 484 0
 889 0036 23A8     		add	r0, sp, #140
 890 0038 FF21     		movs	r1, #255
 891 003a 4022     		movs	r2, #64
 892 003c FFF7FEFF 		bl	memset
 893              	.LVL73:
 485:hardware.c    ****     memcpy(signature,  (vu32 *)(usrAddr+0x20), 0x40);
 894              		.loc 1 485 0
 895 0040 23AF     		add	r7, sp, #140
 896 0042 04F12005 		add	r5, r4, #32
 897 0046 04F1600E 		add	lr, r4, #96
 898              	.L91:
 899 004a 2868     		ldr	r0, [r5]	@ unaligned
 900 004c 6968     		ldr	r1, [r5, #4]	@ unaligned
 901 004e AA68     		ldr	r2, [r5, #8]	@ unaligned
 902 0050 EB68     		ldr	r3, [r5, #12]	@ unaligned
 903 0052 3E46     		mov	r6, r7
 904 0054 0FC6     		stmia	r6!, {r0, r1, r2, r3}
 905 0056 1035     		adds	r5, r5, #16
 906 0058 7545     		cmp	r5, lr
 907 005a 3746     		mov	r7, r6
 908 005c F5D1     		bne	.L91
 491:hardware.c    ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
 909              		.loc 1 491 0
 910 005e FF21     		movs	r1, #255
 911 0060 2022     		movs	r2, #32
 912 0062 13A8     		add	r0, sp, #76
 913 0064 FFF7FEFF 		bl	memset
 914              	.LVL74:
 492:hardware.c    ****     memset(input, 0xFF, sizeof(input));
 915              		.loc 1 492 0
 916 0068 5C22     		movs	r2, #92
 917 006a FF21     		movs	r1, #255
 918 006c 33A8     		add	r0, sp, #204
 919 006e FFF7FEFF 		bl	memset
 920              	.LVL75:
 495:hardware.c    ****     sha256_starts(&ctx);
 921              		.loc 1 495 0
 922 0072 4AA8     		add	r0, sp, #296
 923 0074 FFF7FEFF 		bl	sha256_starts
 924              	.LVL76:
 498:hardware.c    ****     int offset = Swap2Bytes(*(int*)((vu32 *)(usrAddr+0x60))) + 0x140;
 925              		.loc 1 498 0
 926 0078 236E     		ldr	r3, [r4, #96]
 927              	.LVL77:
 501:hardware.c    ****     char cmpEnd[4] = {0xFE, 0xED, 0xFA, 0xCE};
 928              		.loc 1 501 0
 929 007a 374A     		ldr	r2, .L104
 498:hardware.c    ****     int offset = Swap2Bytes(*(int*)((vu32 *)(usrAddr+0x60))) + 0x140;
 930              		.loc 1 498 0
 931 007c 1E02     		lsls	r6, r3, #8
 932 007e B6B2     		uxth	r6, r6
 933 0080 C3F30723 		ubfx	r3, r3, #8, #8
 934              	.LVL78:
 935 0084 1E43     		orrs	r6, r6, r3
 936 0086 06F5A076 		add	r6, r6, #320
 501:hardware.c    ****     char cmpEnd[4] = {0xFE, 0xED, 0xFA, 0xCE};
 937              		.loc 1 501 0
 938 008a 1068     		ldr	r0, [r2]	@ unaligned
 504:hardware.c    ****     while ((usrAddr+i) <= (usrAddr+offset))
 939              		.loc 1 504 0
 940 008c 2644     		add	r6, r6, r4
 941 008e 04F17405 		add	r5, r4, #116
 942 0092 B542     		cmp	r5, r6
 501:hardware.c    ****     char cmpEnd[4] = {0xFE, 0xED, 0xFA, 0xCE};
 943              		.loc 1 501 0
 944 0094 0390     		str	r0, [sp, #12]	@ unaligned
 504:hardware.c    ****     while ((usrAddr+i) <= (usrAddr+offset))
 945              		.loc 1 504 0
 946 0096 19D8     		bhi	.L93
 947 0098 7834     		adds	r4, r4, #120
 948              	.LVL79:
 949 009a 08E0     		b	.L96
 950              	.LVL80:
 951              	.L94:
 513:hardware.c    ****       sha256_update(&ctx, (vu32 *)(usrAddr+i), 0x4);
 952              		.loc 1 513 0
 953 009c 4AA8     		add	r0, sp, #296
 954 009e FFF7FEFF 		bl	sha256_update
 955              	.LVL81:
 504:hardware.c    ****     while ((usrAddr+i) <= (usrAddr+offset))
 956              		.loc 1 504 0
 957 00a2 B442     		cmp	r4, r6
 958 00a4 04F10403 		add	r3, r4, #4
 959 00a8 10D8     		bhi	.L93
 960 00aa 2546     		mov	r5, r4
 961 00ac 1C46     		mov	r4, r3
 962              	.LVL82:
 963              	.L96:
 507:hardware.c    ****       memcpy(buff, (char *)(usrAddr+i), 0x4);
 964              		.loc 1 507 0
 965 00ae 2868     		ldr	r0, [r5]	@ unaligned
 508:hardware.c    ****       if (memmem(&buff, 0x4, &cmpEnd, 4) != 0)
 966              		.loc 1 508 0
 967 00b0 0421     		movs	r1, #4
 507:hardware.c    ****       memcpy(buff, (char *)(usrAddr+i), 0x4);
 968              		.loc 1 507 0
 969 00b2 0490     		str	r0, [sp, #16]	@ unaligned
 508:hardware.c    ****       if (memmem(&buff, 0x4, &cmpEnd, 4) != 0)
 970              		.loc 1 508 0
 971 00b4 0B46     		mov	r3, r1
 972 00b6 03AA     		add	r2, sp, #12
 973 00b8 04A8     		add	r0, sp, #16
 974 00ba FFF7FEFF 		bl	memmem
 975              	.LVL83:
 513:hardware.c    ****       sha256_update(&ctx, (vu32 *)(usrAddr+i), 0x4);
 976              		.loc 1 513 0
 977 00be 2946     		mov	r1, r5
 978 00c0 0422     		movs	r2, #4
 508:hardware.c    ****       if (memmem(&buff, 0x4, &cmpEnd, 4) != 0)
 979              		.loc 1 508 0
 980 00c2 0028     		cmp	r0, #0
 981 00c4 EAD0     		beq	.L94
 510:hardware.c    ****         sha256_update(&ctx, (vu32 *)(usrAddr+i), 0x4);
 982              		.loc 1 510 0
 983 00c6 4AA8     		add	r0, sp, #296
 984 00c8 FFF7FEFF 		bl	sha256_update
 985              	.LVL84:
 986              	.L93:
 987              	.LBB65:
 988              	.LBB66:
 464:hardware.c    ****     id->off0 = MMIO16(U_ID + 0x0);
 989              		.loc 1 464 0
 990 00cc 2348     		ldr	r0, .L104+4
 465:hardware.c    ****     id->off2 = MMIO16(U_ID + 0x2);
 991              		.loc 1 465 0
 992 00ce 2449     		ldr	r1, .L104+8
 466:hardware.c    ****     id->off4 = MMIO32(U_ID + 0x4);
 993              		.loc 1 466 0
 994 00d0 244A     		ldr	r2, .L104+12
 467:hardware.c    ****     id->off8 = MMIO32(U_ID + 0x8);
 995              		.loc 1 467 0
 996 00d2 254B     		ldr	r3, .L104+16
 464:hardware.c    ****     id->off0 = MMIO16(U_ID + 0x0);
 997              		.loc 1 464 0
 998 00d4 0788     		ldrh	r7, [r0]
 465:hardware.c    ****     id->off2 = MMIO16(U_ID + 0x2);
 999              		.loc 1 465 0
 1000 00d6 0E88     		ldrh	r6, [r1]
 466:hardware.c    ****     id->off4 = MMIO32(U_ID + 0x4);
 1001              		.loc 1 466 0
 1002 00d8 1468     		ldr	r4, [r2]
 467:hardware.c    ****     id->off8 = MMIO32(U_ID + 0x8);
 1003              		.loc 1 467 0
 1004 00da 1D68     		ldr	r5, [r3]
 464:hardware.c    ****     id->off0 = MMIO16(U_ID + 0x0);
 1005              		.loc 1 464 0
 1006 00dc BFB2     		uxth	r7, r7
 1007              	.LVL85:
 465:hardware.c    ****     id->off2 = MMIO16(U_ID + 0x2);
 1008              		.loc 1 465 0
 1009 00de B6B2     		uxth	r6, r6
 1010              	.LVL86:
 1011              	.LBE66:
 1012              	.LBE65:
 521:hardware.c    ****     sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
 1013              		.loc 1 521 0
 1014 00e0 8DE83000 		stmia	sp, {r4, r5}
 1015 00e4 3A46     		mov	r2, r7
 1016 00e6 3346     		mov	r3, r6
 1017 00e8 2049     		ldr	r1, .L104+20
 1018 00ea 05A8     		add	r0, sp, #20
 1019 00ec FFF7FEFF 		bl	sprintf
 1020              	.LVL87:
 522:hardware.c    ****     uart_printf("%X%X%X%X\n", id.off0, id.off2, id.off4, id.off8);
 1021              		.loc 1 522 0
 1022 00f0 2346     		mov	r3, r4
 1023 00f2 3946     		mov	r1, r7
 1024 00f4 3246     		mov	r2, r6
 1025 00f6 0095     		str	r5, [sp]
 1026 00f8 1D48     		ldr	r0, .L104+24
 1027 00fa FFF7FEFF 		bl	uart_printf
 1028              	.LVL88:
 523:hardware.c    ****     sha256_update(&ctx, uniqueID, 23);
 1029              		.loc 1 523 0
 1030 00fe 1722     		movs	r2, #23
 1031 0100 4AA8     		add	r0, sp, #296
 1032 0102 05A9     		add	r1, sp, #20
 528:hardware.c    ****   uint8_t rootCA[32] = {
 1033              		.loc 1 528 0
 1034 0104 1B4D     		ldr	r5, .L104+28
 1035              	.LVL89:
 523:hardware.c    ****     sha256_update(&ctx, uniqueID, 23);
 1036              		.loc 1 523 0
 1037 0106 FFF7FEFF 		bl	sha256_update
 1038              	.LVL90:
 524:hardware.c    ****     sha256_finish(&ctx, sha256sum);
 1039              		.loc 1 524 0
 1040 010a 13A9     		add	r1, sp, #76
 1041 010c 4AA8     		add	r0, sp, #296
 1042 010e FFF7FEFF 		bl	sha256_finish
 1043              	.LVL91:
 526:hardware.c    ****     print_hash(sha256sum);
 1044              		.loc 1 526 0
 1045 0112 13A8     		add	r0, sp, #76
 1046 0114 FFF7FEFF 		bl	print_hash
 1047              	.LVL92:
 528:hardware.c    ****   uint8_t rootCA[32] = {
 1048              		.loc 1 528 0
 1049 0118 2868     		ldr	r0, [r5]	@ unaligned
 1050 011a 6968     		ldr	r1, [r5, #4]	@ unaligned
 1051 011c AA68     		ldr	r2, [r5, #8]	@ unaligned
 1052 011e EB68     		ldr	r3, [r5, #12]	@ unaligned
 1053 0120 1BAC     		add	r4, sp, #108
 1054              	.LVL93:
 1055 0122 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 1056 0124 2869     		ldr	r0, [r5, #16]	@ unaligned
 1057 0126 6969     		ldr	r1, [r5, #20]	@ unaligned
 1058 0128 AA69     		ldr	r2, [r5, #24]	@ unaligned
 1059 012a EB69     		ldr	r3, [r5, #28]	@ unaligned
 1060 012c 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 535:hardware.c    ****     if (!edsign_verify(signature, rootCA, sha256sum, 0x20) > 0) {
 1061              		.loc 1 535 0
 1062 012e 1BA9     		add	r1, sp, #108
 1063 0130 23A8     		add	r0, sp, #140
 1064 0132 13AA     		add	r2, sp, #76
 1065 0134 2023     		movs	r3, #32
 1066 0136 FFF7FEFF 		bl	edsign_verify
 1067              	.LVL94:
 1068 013a 50B1     		cbz	r0, .L97
 539:hardware.c    ****     if (memcmp(sha256sum, writtenHash, 32)){
 1069              		.loc 1 539 0
 1070 013c 13A8     		add	r0, sp, #76
 1071 013e 0BA9     		add	r1, sp, #44
 1072 0140 2022     		movs	r2, #32
 1073 0142 FFF7FEFF 		bl	memcmp
 1074              	.LVL95:
 540:hardware.c    ****         return 0x2;
 1075              		.loc 1 540 0
 1076 0146 0028     		cmp	r0, #0
 1077 0148 0CBF     		ite	eq
 1078 014a 0320     		moveq	r0, #3
 1079 014c 0220     		movne	r0, #2
 1080              		.loc 1 543 0
 1081 014e 65B0     		add	sp, sp, #404
 1082              		@ sp needed
 1083 0150 F0BD     		pop	{r4, r5, r6, r7, pc}
 1084              	.LVL96:
 1085              	.L97:
 536:hardware.c    ****         return 0x1;
 1086              		.loc 1 536 0
 1087 0152 0120     		movs	r0, #1
 1088              		.loc 1 543 0
 1089 0154 65B0     		add	sp, sp, #404
 1090              		@ sp needed
 1091 0156 F0BD     		pop	{r4, r5, r6, r7, pc}
 1092              	.LVL97:
 1093              	.L105:
 1094              		.align	2
 1095              	.L104:
 1096 0158 00000000 		.word	.LANCHOR0
 1097 015c E8F7FF1F 		.word	536868840
 1098 0160 EAF7FF1F 		.word	536868842
 1099 0164 ECF7FF1F 		.word	536868844
 1100 0168 F0F7FF1F 		.word	536868848
 1101 016c 00000000 		.word	.LC2
 1102 0170 0C000000 		.word	.LC3
 1103 0174 04000000 		.word	.LANCHOR0+4
 1104              		.cfi_endproc
 1105              	.LFE14:
 1107              		.section	.text.setMspAndJump,"ax",%progbits
 1108              		.align	2
 1109              		.global	setMspAndJump
 1110              		.thumb
 1111              		.thumb_func
 1113              	setMspAndJump:
 1114              	.LFB15:
 544:hardware.c    **** 
 545:hardware.c    **** void setMspAndJump(u32 usrAddr) {
 1115              		.loc 1 545 0
 1116              		.cfi_startproc
 1117              		@ args = 0, pretend = 0, frame = 0
 1118              		@ frame_needed = 0, uses_anonymous_args = 0
 1119              	.LVL98:
 546:hardware.c    ****   // Dedicated function with no call to any function (appart the last call)
 547:hardware.c    ****   // This way, there is no manipulation of the stack here, ensuring that GGC
 548:hardware.c    ****   // didn't insert any pop from the SP after having set the MSP.
 549:hardware.c    ****   typedef void (*funcPtr)(void);
 550:hardware.c    ****   u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
 551:hardware.c    **** 
 552:hardware.c    ****   funcPtr usrMain = (funcPtr) jumpAddr;
 553:hardware.c    **** 
 554:hardware.c    ****   SET_REG(SCB_VTOR, (vu32) (usrAddr));
 1120              		.loc 1 554 0
 1121 0000 044A     		ldr	r2, .L107
 545:hardware.c    **** void setMspAndJump(u32 usrAddr) {
 1122              		.loc 1 545 0
 1123 0002 08B5     		push	{r3, lr}
 1124              		.cfi_def_cfa_offset 8
 1125              		.cfi_offset 3, -8
 1126              		.cfi_offset 14, -4
 550:hardware.c    ****   u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
 1127              		.loc 1 550 0
 1128 0004 4368     		ldr	r3, [r0, #4]
 1129              	.LVL99:
 1130              		.loc 1 554 0
 1131 0006 1060     		str	r0, [r2]
 555:hardware.c    **** 
 556:hardware.c    ****   asm volatile("msr msp, %0"::"g"
 557:hardware.c    ****                (*(volatile u32 *)usrAddr));
 1132              		.loc 1 557 0
 1133 0008 0268     		ldr	r2, [r0]
 556:hardware.c    ****   asm volatile("msr msp, %0"::"g"
 1134              		.loc 1 556 0
 1135              	@ 556 "hardware.c" 1
 1136 000a 82F30888 		msr msp, r2
 1137              	@ 0 "" 2
 558:hardware.c    **** 
 559:hardware.c    ****   usrMain();                                /* go! */
 1138              		.loc 1 559 0
 1139              		.thumb
 1140 000e 9847     		blx	r3
 1141              	.LVL100:
 1142 0010 08BD     		pop	{r3, pc}
 1143              	.L108:
 1144 0012 00BF     		.align	2
 1145              	.L107:
 1146 0014 08ED00E0 		.word	-536810232
 1147              		.cfi_endproc
 1148              	.LFE15:
 1150              		.section	.text.jumpToUser,"ax",%progbits
 1151              		.align	2
 1152              		.global	jumpToUser
 1153              		.thumb
 1154              		.thumb_func
 1156              	jumpToUser:
 1157              	.LFB16:
 560:hardware.c    **** }
 561:hardware.c    **** 
 562:hardware.c    **** 
 563:hardware.c    **** void jumpToUser(u32 usrAddr) {
 1158              		.loc 1 563 0
 1159              		.cfi_startproc
 1160              		@ args = 0, pretend = 0, frame = 0
 1161              		@ frame_needed = 0, uses_anonymous_args = 0
 1162              	.LVL101:
 1163              	.LBB75:
 1164              	.LBB76:
 564:hardware.c    **** 
 565:hardware.c    ****     /* tear down all the dfu related setup */
 566:hardware.c    ****     // disable usb interrupts, clear them, turn off usb, set the disc pin
 567:hardware.c    ****     // todo pick exactly what we want to do here, now its just a conservative
 568:hardware.c    **** 
 569:hardware.c    ****     flashLock();
 570:hardware.c    ****     usbDsbISR();
 571:hardware.c    ****     nvicDisableInterrupts();
 572:hardware.c    **** 	
 573:hardware.c    **** #ifndef HAS_MAPLE_HARDWARE	
 574:hardware.c    **** 	usbDsbBus();
 575:hardware.c    **** #endif
 576:hardware.c    **** 	
 577:hardware.c    **** // Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(
 578:hardware.c    ****     systemReset(); // resets clocks and periphs, not core regs
 579:hardware.c    ****     SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);
 580:hardware.c    ****     setMspAndJump(usrAddr);
 581:hardware.c    **** }
 582:hardware.c    **** 
 583:hardware.c    **** void bkp10Write(u16 value)
 584:hardware.c    **** {
 585:hardware.c    **** 		// Enable clocks for the backup domain registers
 586:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 587:hardware.c    **** 		
 588:hardware.c    ****         // Disable backup register write protection
 589:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 590:hardware.c    **** 
 591:hardware.c    ****         // store value in pBK DR10
 592:hardware.c    ****         pBKP->DR10 = value;
 593:hardware.c    **** 
 594:hardware.c    ****         // Re-enable backup register write protection
 595:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 596:hardware.c    **** }
 597:hardware.c    **** 
 598:hardware.c    **** int checkAndClearBootloaderFlag()
 599:hardware.c    **** {
 600:hardware.c    ****     bool flagSet = 0x00;// Flag not used
 601:hardware.c    **** 
 602:hardware.c    ****     // Enable clocks for the backup domain registers
 603:hardware.c    ****     pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 604:hardware.c    **** 
 605:hardware.c    ****     switch (pBKP->DR10)
 606:hardware.c    **** 	{
 607:hardware.c    **** 		case RTC_BOOTLOADER_FLAG:
 608:hardware.c    **** 			flagSet = 0x01;
 609:hardware.c    **** 			break;
 610:hardware.c    **** 		case RTC_BOOTLOADER_JUST_UPLOADED:
 611:hardware.c    **** 			flagSet = 0x02;
 612:hardware.c    **** 			break;		
 613:hardware.c    ****     }
 614:hardware.c    **** 
 615:hardware.c    **** 	if (flagSet!=0x00)
 616:hardware.c    **** 	{
 617:hardware.c    **** 		bkp10Write(0x0000);// Clear the flag
 618:hardware.c    **** 		// Disable clocks
 619:hardware.c    **** 		pRCC->APB1ENR &= ~(RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 620:hardware.c    **** 	}
 621:hardware.c    ****     return flagSet;
 622:hardware.c    **** }
 623:hardware.c    **** 
 624:hardware.c    **** 
 625:hardware.c    **** 
 626:hardware.c    **** void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
 627:hardware.c    ****     u32 tmppriority = 0x00;
 628:hardware.c    ****     u32 tmpreg      = 0x00;
 629:hardware.c    ****     u32 tmpmask     = 0x00;
 630:hardware.c    ****     u32 tmppre      = 0;
 631:hardware.c    ****     u32 tmpsub      = 0x0F;
 632:hardware.c    **** 
 633:hardware.c    ****     SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
 634:hardware.c    ****     NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
 635:hardware.c    **** 
 636:hardware.c    **** 
 637:hardware.c    ****     /* Compute the Corresponding IRQ Priority --------------------------------*/
 638:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 639:hardware.c    ****     tmppre = (0x4 - tmppriority);
 640:hardware.c    ****     tmpsub = tmpsub >> tmppriority;
 641:hardware.c    **** 
 642:hardware.c    ****     tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 643:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 644:hardware.c    **** 
 645:hardware.c    ****     tmppriority = tmppriority << 0x04;
 646:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 647:hardware.c    **** 
 648:hardware.c    ****     tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 649:hardware.c    ****     tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 650:hardware.c    ****     tmpreg &= ~tmpmask;
 651:hardware.c    ****     tmppriority &= tmpmask;
 652:hardware.c    ****     tmpreg |= tmppriority;
 653:hardware.c    **** 
 654:hardware.c    ****     rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
 655:hardware.c    **** 
 656:hardware.c    ****     /* Enable the Selected IRQ Channels --------------------------------------*/
 657:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 658:hardware.c    ****         (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 659:hardware.c    **** }
 660:hardware.c    **** 
 661:hardware.c    **** void nvicDisableInterrupts() {
 662:hardware.c    ****     NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
 663:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 664:hardware.c    ****     rNVIC->ICER[1] = 0xFFFFFFFF;
 665:hardware.c    ****     rNVIC->ICPR[0] = 0xFFFFFFFF;
 666:hardware.c    ****     rNVIC->ICPR[1] = 0xFFFFFFFF;
 667:hardware.c    **** 
 668:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 669:hardware.c    **** }
 670:hardware.c    **** 
 671:hardware.c    **** void systemHardReset(void) {
 672:hardware.c    ****     SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
 673:hardware.c    **** 
 674:hardware.c    ****     /* Reset  */
 675:hardware.c    ****     rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
 676:hardware.c    **** 
 677:hardware.c    ****     /*  should never get here */
 678:hardware.c    ****     while (1) {
 679:hardware.c    ****         asm volatile("nop");
 680:hardware.c    ****     }
 681:hardware.c    **** }
 682:hardware.c    **** 
 683:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 684:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 685:hardware.c    ****     rwmVal = FLASH_CR_PER;
 686:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 687:hardware.c    **** 
 688:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 689:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 690:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 691:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 692:hardware.c    **** 
 693:hardware.c    ****     /* todo: verify the page was erased */
 694:hardware.c    **** 
 695:hardware.c    ****     rwmVal = 0x00;
 696:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 697:hardware.c    **** 
 698:hardware.c    ****     return TRUE;
 699:hardware.c    **** }
 700:hardware.c    **** bool flashErasePages(u32 pageAddr, u16 n) {
 701:hardware.c    ****     while (n-- > 0) {
 702:hardware.c    ****         if (!flashErasePage(pageAddr + wTransferSize * n)) {
 703:hardware.c    ****             return FALSE;
 704:hardware.c    ****         }
 705:hardware.c    ****     }
 706:hardware.c    **** 
 707:hardware.c    ****     return TRUE;
 708:hardware.c    **** }
 709:hardware.c    **** 
 710:hardware.c    **** bool flashWriteWord(u32 addr, u32 word) {
 711:hardware.c    ****     vu16 *flashAddr = (vu16 *)addr;
 712:hardware.c    ****     vu32 lhWord = (vu32)word & 0x0000FFFF;
 713:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 714:hardware.c    **** 
 715:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 716:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 717:hardware.c    **** 
 718:hardware.c    ****     /* apparently we need not write to FLASH_AR and can
 719:hardware.c    ****        simply do a native write of a half word */
 720:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 721:hardware.c    ****     *(flashAddr + 0x01) = (vu16)hhWord;
 722:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 723:hardware.c    ****     *(flashAddr) = (vu16)lhWord;
 724:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 725:hardware.c    **** 
 726:hardware.c    ****     rwmVal &= 0xFFFFFFFE;
 727:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 728:hardware.c    **** 
 729:hardware.c    ****     /* verify the write */
 730:hardware.c    ****     if (*(vu32 *)addr != word) {
 731:hardware.c    ****         return FALSE;
 732:hardware.c    ****     }
 733:hardware.c    **** 
 734:hardware.c    ****     return TRUE;
 735:hardware.c    **** }
 736:hardware.c    **** 
 737:hardware.c    **** void flashLock() {
 738:hardware.c    ****     /* take down the HSI oscillator? it may be in use elsewhere */
 739:hardware.c    **** 
 740:hardware.c    ****     /* ensure all FPEC functions disabled and lock the FPEC */
 741:hardware.c    ****     SET_REG(FLASH_CR, 0x00000080);
 1165              		.loc 1 741 0
 1166 0000 204B     		ldr	r3, .L110
 1167 0002 8022     		movs	r2, #128
 1168              	.LBE76:
 1169              	.LBE75:
 563:hardware.c    **** void jumpToUser(u32 usrAddr) {
 1170              		.loc 1 563 0
 1171 0004 70B5     		push	{r4, r5, r6, lr}
 1172              		.cfi_def_cfa_offset 16
 1173              		.cfi_offset 4, -16
 1174              		.cfi_offset 5, -12
 1175              		.cfi_offset 6, -8
 1176              		.cfi_offset 14, -4
 1177              	.LBB78:
 1178              	.LBB77:
 1179              		.loc 1 741 0
 1180 0006 1A60     		str	r2, [r3]
 1181              	.LBE77:
 1182              	.LBE78:
 563:hardware.c    **** void jumpToUser(u32 usrAddr) {
 1183              		.loc 1 563 0
 1184 0008 0446     		mov	r4, r0
 570:hardware.c    ****     usbDsbISR();
 1185              		.loc 1 570 0
 1186 000a FFF7FEFF 		bl	usbDsbISR
 1187              	.LVL102:
 1188              	.LBB79:
 1189              	.LBB80:
 663:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1190              		.loc 1 663 0
 1191 000e 1E4B     		ldr	r3, .L110+4
 668:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1192              		.loc 1 668 0
 1193 0010 1E49     		ldr	r1, .L110+8
 663:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1194              		.loc 1 663 0
 1195 0012 4FF0FF32 		mov	r2, #-1
 668:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1196              		.loc 1 668 0
 1197 0016 0420     		movs	r0, #4
 663:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1198              		.loc 1 663 0
 1199 0018 C3F88020 		str	r2, [r3, #128]
 664:hardware.c    ****     rNVIC->ICER[1] = 0xFFFFFFFF;
 1200              		.loc 1 664 0
 1201 001c C3F88420 		str	r2, [r3, #132]
 665:hardware.c    ****     rNVIC->ICPR[0] = 0xFFFFFFFF;
 1202              		.loc 1 665 0
 1203 0020 C3F88021 		str	r2, [r3, #384]
 666:hardware.c    ****     rNVIC->ICPR[1] = 0xFFFFFFFF;
 1204              		.loc 1 666 0
 1205 0024 C3F88421 		str	r2, [r3, #388]
 668:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1206              		.loc 1 668 0
 1207 0028 0860     		str	r0, [r1]
 1208              	.LBE80:
 1209              	.LBE79:
 574:hardware.c    **** 	usbDsbBus();
 1210              		.loc 1 574 0
 1211 002a FFF7FEFF 		bl	usbDsbBus
 1212              	.LVL103:
 1213              	.LBB81:
 1214              	.LBB82:
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 1215              		.loc 1 394 0
 1216 002e 184B     		ldr	r3, .L110+12
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 1217              		.loc 1 395 0
 1218 0030 184A     		ldr	r2, .L110+16
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 1219              		.loc 1 394 0
 1220 0032 1868     		ldr	r0, [r3]
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 1221              		.loc 1 395 0
 1222 0034 1849     		ldr	r1, .L110+20
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 1223              		.loc 1 394 0
 1224 0036 40F00100 		orr	r0, r0, #1
 1225 003a 1860     		str	r0, [r3]
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 1226              		.loc 1 395 0
 1227 003c 1068     		ldr	r0, [r2]
 400:hardware.c    ****     SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
 1228              		.loc 1 400 0
 1229 003e 174D     		ldr	r5, .L110+24
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 1230              		.loc 1 395 0
 1231 0040 0140     		ands	r1, r1, r0
 1232 0042 1160     		str	r1, [r2]
 396:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 1233              		.loc 1 396 0
 1234 0044 1968     		ldr	r1, [r3]
 400:hardware.c    ****     SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
 1235              		.loc 1 400 0
 1236 0046 0026     		movs	r6, #0
 396:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 1237              		.loc 1 396 0
 1238 0048 21F08471 		bic	r1, r1, #17301504
 1239 004c 21F48031 		bic	r1, r1, #65536
 1240 0050 1960     		str	r1, [r3]
 397:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
 1241              		.loc 1 397 0
 1242 0052 1868     		ldr	r0, [r3]
 1243              	.LBE82:
 1244              	.LBE81:
 579:hardware.c    ****     SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);
 1245              		.loc 1 579 0
 1246 0054 1249     		ldr	r1, .L110+28
 1247              	.LBB85:
 1248              	.LBB83:
 397:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
 1249              		.loc 1 397 0
 1250 0056 20F48020 		bic	r0, r0, #262144
 1251 005a 1860     		str	r0, [r3]
 398:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 1252              		.loc 1 398 0
 1253 005c 1368     		ldr	r3, [r2]
 1254              	.LBE83:
 1255              	.LBE85:
 1256              	.LBB86:
 1257              	.LBB87:
 554:hardware.c    ****   SET_REG(SCB_VTOR, (vu32) (usrAddr));
 1258              		.loc 1 554 0
 1259 005e 1148     		ldr	r0, .L110+32
 1260              	.LBE87:
 1261              	.LBE86:
 1262              	.LBB89:
 1263              	.LBB84:
 398:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 1264              		.loc 1 398 0
 1265 0060 23F4FE03 		bic	r3, r3, #8323072
 1266 0064 1360     		str	r3, [r2]
 400:hardware.c    ****     SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
 1267              		.loc 1 400 0
 1268 0066 2E60     		str	r6, [r5]
 1269              	.LBE84:
 1270              	.LBE89:
 579:hardware.c    ****     SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);
 1271              		.loc 1 579 0
 1272 0068 0B68     		ldr	r3, [r1]
 1273 006a 23F0E063 		bic	r3, r3, #117440512
 1274 006e 43F08063 		orr	r3, r3, #67108864
 1275 0072 0B60     		str	r3, [r1]
 1276              	.LVL104:
 1277              	.LBB90:
 1278              	.LBB88:
 550:hardware.c    ****   u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
 1279              		.loc 1 550 0
 1280 0074 6368     		ldr	r3, [r4, #4]
 1281              	.LVL105:
 554:hardware.c    ****   SET_REG(SCB_VTOR, (vu32) (usrAddr));
 1282              		.loc 1 554 0
 1283 0076 0460     		str	r4, [r0]
 557:hardware.c    ****                (*(volatile u32 *)usrAddr));
 1284              		.loc 1 557 0
 1285 0078 2268     		ldr	r2, [r4]
 556:hardware.c    ****   asm volatile("msr msp, %0"::"g"
 1286              		.loc 1 556 0
 1287              	@ 556 "hardware.c" 1
 1288 007a 82F30888 		msr msp, r2
 1289              	@ 0 "" 2
 559:hardware.c    ****   usrMain();                                /* go! */
 1290              		.loc 1 559 0
 1291              		.thumb
 1292 007e 9847     		blx	r3
 1293              	.LVL106:
 1294 0080 70BD     		pop	{r4, r5, r6, pc}
 1295              	.LVL107:
 1296              	.L111:
 1297 0082 00BF     		.align	2
 1298              	.L110:
 1299 0084 10200240 		.word	1073881104
 1300 0088 00E100E0 		.word	-536813312
 1301 008c 10E000E0 		.word	-536813552
 1302 0090 00100240 		.word	1073876992
 1303 0094 04100240 		.word	1073876996
 1304 0098 0000FFF8 		.word	-117506048
 1305 009c 08100240 		.word	1073877000
 1306 00a0 04000140 		.word	1073807364
 1307 00a4 08ED00E0 		.word	-536810232
 1308              	.LBE88:
 1309              	.LBE90:
 1310              		.cfi_endproc
 1311              	.LFE16:
 1313              		.section	.text.bkp10Write,"ax",%progbits
 1314              		.align	2
 1315              		.global	bkp10Write
 1316              		.thumb
 1317              		.thumb_func
 1319              	bkp10Write:
 1320              	.LFB17:
 584:hardware.c    **** {
 1321              		.loc 1 584 0
 1322              		.cfi_startproc
 1323              		@ args = 0, pretend = 0, frame = 0
 1324              		@ frame_needed = 0, uses_anonymous_args = 0
 1325              		@ link register save eliminated.
 1326              	.LVL108:
 586:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1327              		.loc 1 586 0
 1328 0000 094A     		ldr	r2, .L113
 584:hardware.c    **** {
 1329              		.loc 1 584 0
 1330 0002 10B4     		push	{r4}
 1331              		.cfi_def_cfa_offset 4
 1332              		.cfi_offset 4, -4
 586:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1333              		.loc 1 586 0
 1334 0004 D469     		ldr	r4, [r2, #28]
 589:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1335              		.loc 1 589 0
 1336 0006 094B     		ldr	r3, .L113+4
 586:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1337              		.loc 1 586 0
 1338 0008 44F0C054 		orr	r4, r4, #402653184
 1339 000c D461     		str	r4, [r2, #28]
 589:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1340              		.loc 1 589 0
 1341 000e 1A68     		ldr	r2, [r3]
 592:hardware.c    ****         pBKP->DR10 = value;
 1342              		.loc 1 592 0
 1343 0010 0749     		ldr	r1, .L113+8
 589:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1344              		.loc 1 589 0
 1345 0012 42F48072 		orr	r2, r2, #256
 1346 0016 1A60     		str	r2, [r3]
 592:hardware.c    ****         pBKP->DR10 = value;
 1347              		.loc 1 592 0
 1348 0018 0885     		strh	r0, [r1, #40]	@ movhi
 595:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 1349              		.loc 1 595 0
 1350 001a 1A68     		ldr	r2, [r3]
 596:hardware.c    **** }
 1351              		.loc 1 596 0
 1352 001c 5DF8044B 		ldr	r4, [sp], #4
 595:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 1353              		.loc 1 595 0
 1354 0020 22F48072 		bic	r2, r2, #256
 1355 0024 1A60     		str	r2, [r3]
 596:hardware.c    **** }
 1356              		.loc 1 596 0
 1357 0026 7047     		bx	lr
 1358              	.L114:
 1359              		.align	2
 1360              	.L113:
 1361 0028 00100240 		.word	1073876992
 1362 002c 00700040 		.word	1073770496
 1363 0030 006C0040 		.word	1073769472
 1364              		.cfi_endproc
 1365              	.LFE17:
 1367              		.section	.text.checkAndClearBootloaderFlag,"ax",%progbits
 1368              		.align	2
 1369              		.global	checkAndClearBootloaderFlag
 1370              		.thumb
 1371              		.thumb_func
 1373              	checkAndClearBootloaderFlag:
 1374              	.LFB18:
 599:hardware.c    **** {
 1375              		.loc 1 599 0
 1376              		.cfi_startproc
 1377              		@ args = 0, pretend = 0, frame = 0
 1378              		@ frame_needed = 0, uses_anonymous_args = 0
 1379              		@ link register save eliminated.
 1380              	.LVL109:
 603:hardware.c    ****     pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1381              		.loc 1 603 0
 1382 0000 164B     		ldr	r3, .L123
 605:hardware.c    ****     switch (pBKP->DR10)
 1383              		.loc 1 605 0
 1384 0002 1749     		ldr	r1, .L123+4
 603:hardware.c    ****     pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1385              		.loc 1 603 0
 1386 0004 D869     		ldr	r0, [r3, #28]
 599:hardware.c    **** {
 1387              		.loc 1 599 0
 1388 0006 30B4     		push	{r4, r5}
 1389              		.cfi_def_cfa_offset 8
 1390              		.cfi_offset 4, -8
 1391              		.cfi_offset 5, -4
 603:hardware.c    ****     pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1392              		.loc 1 603 0
 1393 0008 40F0C050 		orr	r0, r0, #402653184
 1394 000c D861     		str	r0, [r3, #28]
 605:hardware.c    ****     switch (pBKP->DR10)
 1395              		.loc 1 605 0
 1396 000e 0B8D     		ldrh	r3, [r1, #40]
 1397 0010 44F24C22 		movw	r2, #16972
 1398 0014 9BB2     		uxth	r3, r3
 1399 0016 9342     		cmp	r3, r2
 1400 0018 1ED0     		beq	.L117
 1401 001a 44F24D22 		movw	r2, #16973
 1402 001e 9342     		cmp	r3, r2
 1403 0020 17D1     		bne	.L122
 1404 0022 0220     		movs	r0, #2
 1405              	.L118:
 1406              	.LVL110:
 1407              	.LBB91:
 1408              	.LBB92:
 586:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1409              		.loc 1 586 0
 1410 0024 0D4B     		ldr	r3, .L123
 589:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1411              		.loc 1 589 0
 1412 0026 0F4A     		ldr	r2, .L123+8
 586:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1413              		.loc 1 586 0
 1414 0028 DC69     		ldr	r4, [r3, #28]
 592:hardware.c    ****         pBKP->DR10 = value;
 1415              		.loc 1 592 0
 1416 002a 0D49     		ldr	r1, .L123+4
 586:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1417              		.loc 1 586 0
 1418 002c 44F0C054 		orr	r4, r4, #402653184
 1419 0030 DC61     		str	r4, [r3, #28]
 589:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1420              		.loc 1 589 0
 1421 0032 1568     		ldr	r5, [r2]
 592:hardware.c    ****         pBKP->DR10 = value;
 1422              		.loc 1 592 0
 1423 0034 0024     		movs	r4, #0
 589:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1424              		.loc 1 589 0
 1425 0036 45F48075 		orr	r5, r5, #256
 1426 003a 1560     		str	r5, [r2]
 592:hardware.c    ****         pBKP->DR10 = value;
 1427              		.loc 1 592 0
 1428 003c 0C85     		strh	r4, [r1, #40]	@ movhi
 595:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 1429              		.loc 1 595 0
 1430 003e 1168     		ldr	r1, [r2]
 1431              	.LBE92:
 1432              	.LBE91:
 622:hardware.c    **** }
 1433              		.loc 1 622 0
 1434 0040 30BC     		pop	{r4, r5}
 1435              	.LBB94:
 1436              	.LBB93:
 595:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 1437              		.loc 1 595 0
 1438 0042 21F48071 		bic	r1, r1, #256
 1439 0046 1160     		str	r1, [r2]
 1440              	.LBE93:
 1441              	.LBE94:
 619:hardware.c    **** 		pRCC->APB1ENR &= ~(RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1442              		.loc 1 619 0
 1443 0048 DA69     		ldr	r2, [r3, #28]
 1444 004a 22F0C052 		bic	r2, r2, #402653184
 1445 004e DA61     		str	r2, [r3, #28]
 622:hardware.c    **** }
 1446              		.loc 1 622 0
 1447 0050 7047     		bx	lr
 1448              	.LVL111:
 1449              	.L122:
 605:hardware.c    ****     switch (pBKP->DR10)
 1450              		.loc 1 605 0
 1451 0052 0020     		movs	r0, #0
 622:hardware.c    **** }
 1452              		.loc 1 622 0
 1453 0054 30BC     		pop	{r4, r5}
 1454 0056 7047     		bx	lr
 1455              	.L117:
 605:hardware.c    ****     switch (pBKP->DR10)
 1456              		.loc 1 605 0
 1457 0058 0120     		movs	r0, #1
 1458 005a E3E7     		b	.L118
 1459              	.L124:
 1460              		.align	2
 1461              	.L123:
 1462 005c 00100240 		.word	1073876992
 1463 0060 006C0040 		.word	1073769472
 1464 0064 00700040 		.word	1073770496
 1465              		.cfi_endproc
 1466              	.LFE18:
 1468              		.section	.text.nvicInit,"ax",%progbits
 1469              		.align	2
 1470              		.global	nvicInit
 1471              		.thumb
 1472              		.thumb_func
 1474              	nvicInit:
 1475              	.LFB19:
 626:hardware.c    **** void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
 1476              		.loc 1 626 0
 1477              		.cfi_startproc
 1478              		@ args = 0, pretend = 0, frame = 0
 1479              		@ frame_needed = 0, uses_anonymous_args = 0
 1480              		@ link register save eliminated.
 1481              	.LVL112:
 638:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 1482              		.loc 1 638 0
 1483 0000 194B     		ldr	r3, .L126
 626:hardware.c    **** void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
 1484              		.loc 1 626 0
 1485 0002 10B4     		push	{r4}
 1486              		.cfi_def_cfa_offset 4
 1487              		.cfi_offset 4, -4
 638:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 1488              		.loc 1 638 0
 1489 0004 DB68     		ldr	r3, [r3, #12]
 642:hardware.c    ****     tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 1490              		.loc 1 642 0
 1491 0006 4478     		ldrb	r4, [r0, #1]	@ zero_extendqisi2
 638:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 1492              		.loc 1 638 0
 1493 0008 DB43     		mvns	r3, r3
 1494 000a C3F30223 		ubfx	r3, r3, #8, #3
 1495              	.LVL113:
 640:hardware.c    ****     tmpsub = tmpsub >> tmppriority;
 1496              		.loc 1 640 0
 1497 000e 0F21     		movs	r1, #15
 639:hardware.c    ****     tmppre = (0x4 - tmppriority);
 1498              		.loc 1 639 0
 1499 0010 C3F10402 		rsb	r2, r3, #4
 1500              	.LVL114:
 640:hardware.c    ****     tmpsub = tmpsub >> tmppriority;
 1501              		.loc 1 640 0
 1502 0014 D940     		lsrs	r1, r1, r3
 1503              	.LVL115:
 642:hardware.c    ****     tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 1504              		.loc 1 642 0
 1505 0016 04FA02F2 		lsl	r2, r4, r2
 1506              	.LVL116:
 643:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 1507              		.loc 1 643 0
 1508 001a 8478     		ldrb	r4, [r0, #2]	@ zero_extendqisi2
 646:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1509              		.loc 1 646 0
 1510 001c 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 1511              	.LVL117:
 643:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 1512              		.loc 1 643 0
 1513 001e 2140     		ands	r1, r1, r4
 1514              	.LVL118:
 1515 0020 1143     		orrs	r1, r1, r2
 1516              	.LVL119:
 646:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1517              		.loc 1 646 0
 1518 0022 03F00302 		and	r2, r3, #3
 1519 0026 D200     		lsls	r2, r2, #3
 649:hardware.c    ****     tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1520              		.loc 1 649 0
 1521 0028 FF24     		movs	r4, #255
 645:hardware.c    ****     tmppriority = tmppriority << 0x04;
 1522              		.loc 1 645 0
 1523 002a 0901     		lsls	r1, r1, #4
 1524              	.LVL120:
 646:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1525              		.loc 1 646 0
 1526 002c 9140     		lsls	r1, r1, r2
 1527              	.LVL121:
 649:hardware.c    ****     tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1528              		.loc 1 649 0
 1529 002e 04FA02F2 		lsl	r2, r4, r2
 1530 0032 03F0FC03 		and	r3, r3, #252
 1531 0036 03F16043 		add	r3, r3, #-536870912
 1532 003a 03F56143 		add	r3, r3, #57600
 648:hardware.c    ****     tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 1533              		.loc 1 648 0
 1534 003e D3F80043 		ldr	r4, [r3, #768]
 1535              	.LVL122:
 651:hardware.c    ****     tmppriority &= tmpmask;
 1536              		.loc 1 651 0
 1537 0042 1140     		ands	r1, r1, r2
 1538              	.LVL123:
 650:hardware.c    ****     tmpreg &= ~tmpmask;
 1539              		.loc 1 650 0
 1540 0044 24EA0202 		bic	r2, r4, r2
 1541              	.LVL124:
 652:hardware.c    ****     tmpreg |= tmppriority;
 1542              		.loc 1 652 0
 1543 0048 0A43     		orrs	r2, r2, r1
 1544              	.LVL125:
 654:hardware.c    ****     rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
 1545              		.loc 1 654 0
 1546 004a C3F80023 		str	r2, [r3, #768]
 1547              	.LVL126:
 657:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 1548              		.loc 1 657 0
 1549 004e 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 658:hardware.c    ****         (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 1550              		.loc 1 658 0
 1551 0050 0121     		movs	r1, #1
 1552 0052 03F01F02 		and	r2, r3, #31
 1553              	.LVL127:
 1554 0056 9140     		lsls	r1, r1, r2
 657:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 1555              		.loc 1 657 0
 1556 0058 044A     		ldr	r2, .L126+4
 1557 005a 5B09     		lsrs	r3, r3, #5
 1558 005c 42F82310 		str	r1, [r2, r3, lsl #2]
 659:hardware.c    **** }
 1559              		.loc 1 659 0
 1560 0060 5DF8044B 		ldr	r4, [sp], #4
 1561 0064 7047     		bx	lr
 1562              	.L127:
 1563 0066 00BF     		.align	2
 1564              	.L126:
 1565 0068 00ED00E0 		.word	-536810240
 1566 006c 00E100E0 		.word	-536813312
 1567              		.cfi_endproc
 1568              	.LFE19:
 1570              		.section	.text.nvicDisableInterrupts,"ax",%progbits
 1571              		.align	2
 1572              		.global	nvicDisableInterrupts
 1573              		.thumb
 1574              		.thumb_func
 1576              	nvicDisableInterrupts:
 1577              	.LFB20:
 661:hardware.c    **** void nvicDisableInterrupts() {
 1578              		.loc 1 661 0
 1579              		.cfi_startproc
 1580              		@ args = 0, pretend = 0, frame = 0
 1581              		@ frame_needed = 0, uses_anonymous_args = 0
 1582              		@ link register save eliminated.
 1583              	.LVL128:
 663:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1584              		.loc 1 663 0
 1585 0000 074B     		ldr	r3, .L129
 668:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1586              		.loc 1 668 0
 1587 0002 0849     		ldr	r1, .L129+4
 663:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1588              		.loc 1 663 0
 1589 0004 4FF0FF32 		mov	r2, #-1
 668:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1590              		.loc 1 668 0
 1591 0008 0420     		movs	r0, #4
 663:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1592              		.loc 1 663 0
 1593 000a C3F88020 		str	r2, [r3, #128]
 664:hardware.c    ****     rNVIC->ICER[1] = 0xFFFFFFFF;
 1594              		.loc 1 664 0
 1595 000e C3F88420 		str	r2, [r3, #132]
 665:hardware.c    ****     rNVIC->ICPR[0] = 0xFFFFFFFF;
 1596              		.loc 1 665 0
 1597 0012 C3F88021 		str	r2, [r3, #384]
 666:hardware.c    ****     rNVIC->ICPR[1] = 0xFFFFFFFF;
 1598              		.loc 1 666 0
 1599 0016 C3F88421 		str	r2, [r3, #388]
 668:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1600              		.loc 1 668 0
 1601 001a 0860     		str	r0, [r1]
 1602 001c 7047     		bx	lr
 1603              	.L130:
 1604 001e 00BF     		.align	2
 1605              	.L129:
 1606 0020 00E100E0 		.word	-536813312
 1607 0024 10E000E0 		.word	-536813552
 1608              		.cfi_endproc
 1609              	.LFE20:
 1611              		.section	.text.systemHardReset,"ax",%progbits
 1612              		.align	2
 1613              		.global	systemHardReset
 1614              		.thumb
 1615              		.thumb_func
 1617              	systemHardReset:
 1618              	.LFB21:
 671:hardware.c    **** void systemHardReset(void) {
 1619              		.loc 1 671 0
 1620              		.cfi_startproc
 1621              		@ args = 0, pretend = 0, frame = 0
 1622              		@ frame_needed = 0, uses_anonymous_args = 0
 1623              		@ link register save eliminated.
 1624              	.LVL129:
 675:hardware.c    ****     rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
 1625              		.loc 1 675 0
 1626 0000 024B     		ldr	r3, .L133
 1627 0002 034A     		ldr	r2, .L133+4
 1628 0004 DA60     		str	r2, [r3, #12]
 1629              	.L132:
 679:hardware.c    ****         asm volatile("nop");
 1630              		.loc 1 679 0 discriminator 1
 1631              	@ 679 "hardware.c" 1
 1632 0006 00BF     		nop
 1633              	@ 0 "" 2
 1634              		.thumb
 1635 0008 FDE7     		b	.L132
 1636              	.L134:
 1637 000a 00BF     		.align	2
 1638              	.L133:
 1639 000c 00ED00E0 		.word	-536810240
 1640 0010 0400FA05 		.word	100270084
 1641              		.cfi_endproc
 1642              	.LFE21:
 1644              		.section	.text.flashErasePage,"ax",%progbits
 1645              		.align	2
 1646              		.global	flashErasePage
 1647              		.thumb
 1648              		.thumb_func
 1650              	flashErasePage:
 1651              	.LFB22:
 683:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 1652              		.loc 1 683 0
 1653              		.cfi_startproc
 1654              		@ args = 0, pretend = 0, frame = 0
 1655              		@ frame_needed = 0, uses_anonymous_args = 0
 1656              		@ link register save eliminated.
 1657              	.LVL130:
 684:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1658              		.loc 1 684 0
 1659 0000 0C4B     		ldr	r3, .L140
 686:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1660              		.loc 1 686 0
 1661 0002 0221     		movs	r1, #2
 688:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1662              		.loc 1 688 0
 1663 0004 0C4A     		ldr	r2, .L140+4
 683:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 1664              		.loc 1 683 0
 1665 0006 10B4     		push	{r4}
 1666              		.cfi_def_cfa_offset 4
 1667              		.cfi_offset 4, -4
 684:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1668              		.loc 1 684 0
 1669 0008 1C68     		ldr	r4, [r3]
 1670              	.LVL131:
 686:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1671              		.loc 1 686 0
 1672 000a 1960     		str	r1, [r3]
 1673              	.L137:
 688:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1674              		.loc 1 688 0 discriminator 1
 1675 000c 1368     		ldr	r3, [r2]
 1676 000e DB07     		lsls	r3, r3, #31
 1677 0010 FCD4     		bmi	.L137
 689:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 1678              		.loc 1 689 0
 1679 0012 0A4C     		ldr	r4, .L140+8
 690:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 1680              		.loc 1 690 0
 1681 0014 074B     		ldr	r3, .L140
 1682 0016 4221     		movs	r1, #66
 691:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1683              		.loc 1 691 0
 1684 0018 074A     		ldr	r2, .L140+4
 689:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 1685              		.loc 1 689 0
 1686 001a 2060     		str	r0, [r4]
 690:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 1687              		.loc 1 690 0
 1688 001c 1960     		str	r1, [r3]
 1689              	.L139:
 691:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1690              		.loc 1 691 0 discriminator 1
 1691 001e 1368     		ldr	r3, [r2]
 1692 0020 13F00103 		ands	r3, r3, #1
 1693 0024 FBD1     		bne	.L139
 1694              	.LVL132:
 696:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1695              		.loc 1 696 0
 1696 0026 034A     		ldr	r2, .L140
 699:hardware.c    **** }
 1697              		.loc 1 699 0
 1698 0028 0120     		movs	r0, #1
 1699              	.LVL133:
 696:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1700              		.loc 1 696 0
 1701 002a 1360     		str	r3, [r2]
 699:hardware.c    **** }
 1702              		.loc 1 699 0
 1703 002c 5DF8044B 		ldr	r4, [sp], #4
 1704 0030 7047     		bx	lr
 1705              	.L141:
 1706 0032 00BF     		.align	2
 1707              	.L140:
 1708 0034 10200240 		.word	1073881104
 1709 0038 0C200240 		.word	1073881100
 1710 003c 14200240 		.word	1073881108
 1711              		.cfi_endproc
 1712              	.LFE22:
 1714              		.section	.text.flashErasePages,"ax",%progbits
 1715              		.align	2
 1716              		.global	flashErasePages
 1717              		.thumb
 1718              		.thumb_func
 1720              	flashErasePages:
 1721              	.LFB23:
 700:hardware.c    **** bool flashErasePages(u32 pageAddr, u16 n) {
 1722              		.loc 1 700 0
 1723              		.cfi_startproc
 1724              		@ args = 0, pretend = 0, frame = 0
 1725              		@ frame_needed = 0, uses_anonymous_args = 0
 1726              		@ link register save eliminated.
 1727              	.LVL134:
 1728 0000 2DE9F003 		push	{r4, r5, r6, r7, r8, r9}
 1729              		.cfi_def_cfa_offset 24
 1730              		.cfi_offset 4, -24
 1731              		.cfi_offset 5, -20
 1732              		.cfi_offset 6, -16
 1733              		.cfi_offset 7, -12
 1734              		.cfi_offset 8, -8
 1735              		.cfi_offset 9, -4
 701:hardware.c    ****     while (n-- > 0) {
 1736              		.loc 1 701 0
 1737 0004 4C1E     		subs	r4, r1, #1
 1738 0006 A4B2     		uxth	r4, r4
 1739              	.LVL135:
 1740 0008 E9B1     		cbz	r1, .L150
 1741 000a 114B     		ldr	r3, .L152
 1742              	.LBB95:
 1743              	.LBB96:
 684:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1744              		.loc 1 684 0
 1745 000c 1149     		ldr	r1, .L152+4
 1746 000e D3F80080 		ldr	r8, [r3]
 688:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1747              		.loc 1 688 0
 1748 0012 114A     		ldr	r2, .L152+8
 689:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 1749              		.loc 1 689 0
 1750 0014 DFF844C0 		ldr	ip, .L152+12
 686:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1751              		.loc 1 686 0
 1752 0018 0227     		movs	r7, #2
 690:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 1753              		.loc 1 690 0
 1754 001a 4226     		movs	r6, #66
 1755              	.LBE96:
 1756              	.LBE95:
 701:hardware.c    ****     while (n-- > 0) {
 1757              		.loc 1 701 0
 1758 001c 4FF6FF75 		movw	r5, #65535
 1759              	.LVL136:
 1760              	.L149:
 702:hardware.c    ****         if (!flashErasePage(pageAddr + wTransferSize * n)) {
 1761              		.loc 1 702 0
 1762 0020 08FB0409 		mla	r9, r8, r4, r0
 1763              	.LVL137:
 1764              	.LBB99:
 1765              	.LBB97:
 684:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1766              		.loc 1 684 0
 1767 0024 0B68     		ldr	r3, [r1]
 1768              	.LVL138:
 686:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1769              		.loc 1 686 0
 1770 0026 0F60     		str	r7, [r1]
 1771              	.L145:
 688:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1772              		.loc 1 688 0
 1773 0028 1368     		ldr	r3, [r2]
 1774 002a DB07     		lsls	r3, r3, #31
 1775 002c FCD4     		bmi	.L145
 689:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 1776              		.loc 1 689 0
 1777 002e CCF80090 		str	r9, [ip]
 690:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 1778              		.loc 1 690 0
 1779 0032 0E60     		str	r6, [r1]
 1780              	.L147:
 691:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1781              		.loc 1 691 0
 1782 0034 1368     		ldr	r3, [r2]
 1783 0036 13F00103 		ands	r3, r3, #1
 1784 003a FBD1     		bne	.L147
 1785              	.LVL139:
 1786              	.LBE97:
 1787              	.LBE99:
 701:hardware.c    ****     while (n-- > 0) {
 1788              		.loc 1 701 0
 1789 003c 013C     		subs	r4, r4, #1
 1790              	.LVL140:
 1791 003e A4B2     		uxth	r4, r4
 1792              	.LVL141:
 1793 0040 AC42     		cmp	r4, r5
 1794              	.LBB100:
 1795              	.LBB98:
 696:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1796              		.loc 1 696 0
 1797 0042 0B60     		str	r3, [r1]
 1798              	.LVL142:
 1799              	.LBE98:
 1800              	.LBE100:
 701:hardware.c    ****     while (n-- > 0) {
 1801              		.loc 1 701 0
 1802 0044 ECD1     		bne	.L149
 1803              	.LVL143:
 1804              	.L150:
 708:hardware.c    **** }
 1805              		.loc 1 708 0
 1806 0046 0120     		movs	r0, #1
 1807              	.LVL144:
 1808 0048 BDE8F003 		pop	{r4, r5, r6, r7, r8, r9}
 1809 004c 7047     		bx	lr
 1810              	.L153:
 1811 004e 00BF     		.align	2
 1812              	.L152:
 1813 0050 00000000 		.word	wTransferSize
 1814 0054 10200240 		.word	1073881104
 1815 0058 0C200240 		.word	1073881100
 1816 005c 14200240 		.word	1073881108
 1817              		.cfi_endproc
 1818              	.LFE23:
 1820              		.section	.text.flashWriteWord,"ax",%progbits
 1821              		.align	2
 1822              		.global	flashWriteWord
 1823              		.thumb
 1824              		.thumb_func
 1826              	flashWriteWord:
 1827              	.LFB24:
 710:hardware.c    **** bool flashWriteWord(u32 addr, u32 word) {
 1828              		.loc 1 710 0
 1829              		.cfi_startproc
 1830              		@ args = 0, pretend = 0, frame = 8
 1831              		@ frame_needed = 0, uses_anonymous_args = 0
 1832              		@ link register save eliminated.
 1833              	.LVL145:
 1834 0000 30B4     		push	{r4, r5}
 1835              		.cfi_def_cfa_offset 8
 1836              		.cfi_offset 4, -8
 1837              		.cfi_offset 5, -4
 713:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 1838              		.loc 1 713 0
 1839 0002 0A0C     		lsrs	r2, r1, #16
 710:hardware.c    **** bool flashWriteWord(u32 addr, u32 word) {
 1840              		.loc 1 710 0
 1841 0004 82B0     		sub	sp, sp, #8
 1842              		.cfi_def_cfa_offset 16
 712:hardware.c    ****     vu32 lhWord = (vu32)word & 0x0000FFFF;
 1843              		.loc 1 712 0
 1844 0006 8CB2     		uxth	r4, r1
 715:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1845              		.loc 1 715 0
 1846 0008 114B     		ldr	r3, .L161
 712:hardware.c    ****     vu32 lhWord = (vu32)word & 0x0000FFFF;
 1847              		.loc 1 712 0
 1848 000a 0094     		str	r4, [sp]
 713:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 1849              		.loc 1 713 0
 1850 000c 0192     		str	r2, [sp, #4]
 716:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 1851              		.loc 1 716 0
 1852 000e 0124     		movs	r4, #1
 720:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1853              		.loc 1 720 0
 1854 0010 104A     		ldr	r2, .L161+4
 1855              	.LVL146:
 715:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1856              		.loc 1 715 0
 1857 0012 1D68     		ldr	r5, [r3]
 1858              	.LVL147:
 716:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 1859              		.loc 1 716 0
 1860 0014 1C60     		str	r4, [r3]
 1861              	.L156:
 720:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1862              		.loc 1 720 0 discriminator 1
 1863 0016 1368     		ldr	r3, [r2]
 1864 0018 DC07     		lsls	r4, r3, #31
 1865 001a FCD4     		bmi	.L156
 721:hardware.c    ****     *(flashAddr + 0x01) = (vu16)hhWord;
 1866              		.loc 1 721 0
 1867 001c 019B     		ldr	r3, [sp, #4]
 722:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1868              		.loc 1 722 0
 1869 001e 0D4A     		ldr	r2, .L161+4
 721:hardware.c    ****     *(flashAddr + 0x01) = (vu16)hhWord;
 1870              		.loc 1 721 0
 1871 0020 9BB2     		uxth	r3, r3
 1872 0022 4380     		strh	r3, [r0, #2]	@ movhi
 1873              	.L158:
 722:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1874              		.loc 1 722 0 discriminator 1
 1875 0024 1368     		ldr	r3, [r2]
 1876 0026 DB07     		lsls	r3, r3, #31
 1877 0028 FCD4     		bmi	.L158
 723:hardware.c    ****     *(flashAddr) = (vu16)lhWord;
 1878              		.loc 1 723 0
 1879 002a 009B     		ldr	r3, [sp]
 724:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1880              		.loc 1 724 0
 1881 002c 094A     		ldr	r2, .L161+4
 723:hardware.c    ****     *(flashAddr) = (vu16)lhWord;
 1882              		.loc 1 723 0
 1883 002e 9BB2     		uxth	r3, r3
 1884 0030 0380     		strh	r3, [r0]	@ movhi
 1885              	.L160:
 724:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1886              		.loc 1 724 0 discriminator 1
 1887 0032 1368     		ldr	r3, [r2]
 1888 0034 DC07     		lsls	r4, r3, #31
 1889 0036 FCD4     		bmi	.L160
 727:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1890              		.loc 1 727 0
 1891 0038 054B     		ldr	r3, .L161
 726:hardware.c    ****     rwmVal &= 0xFFFFFFFE;
 1892              		.loc 1 726 0
 1893 003a 25F00102 		bic	r2, r5, #1
 1894              	.LVL148:
 727:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1895              		.loc 1 727 0
 1896 003e 1A60     		str	r2, [r3]
 730:hardware.c    ****     if (*(vu32 *)addr != word) {
 1897              		.loc 1 730 0
 1898 0040 0068     		ldr	r0, [r0]
 1899              	.LVL149:
 735:hardware.c    **** }
 1900              		.loc 1 735 0
 1901 0042 0B1A     		subs	r3, r1, r0
 1902 0044 5842     		rsbs	r0, r3, #0
 1903 0046 5841     		adcs	r0, r0, r3
 1904 0048 02B0     		add	sp, sp, #8
 1905              		@ sp needed
 1906 004a 30BC     		pop	{r4, r5}
 1907 004c 7047     		bx	lr
 1908              	.L162:
 1909 004e 00BF     		.align	2
 1910              	.L161:
 1911 0050 10200240 		.word	1073881104
 1912 0054 0C200240 		.word	1073881100
 1913              		.cfi_endproc
 1914              	.LFE24:
 1916              		.section	.text.flashLock,"ax",%progbits
 1917              		.align	2
 1918              		.global	flashLock
 1919              		.thumb
 1920              		.thumb_func
 1922              	flashLock:
 1923              	.LFB25:
 737:hardware.c    **** void flashLock() {
 1924              		.loc 1 737 0
 1925              		.cfi_startproc
 1926              		@ args = 0, pretend = 0, frame = 0
 1927              		@ frame_needed = 0, uses_anonymous_args = 0
 1928              		@ link register save eliminated.
 1929              		.loc 1 741 0
 1930 0000 014B     		ldr	r3, .L164
 1931 0002 8022     		movs	r2, #128
 1932 0004 1A60     		str	r2, [r3]
 1933 0006 7047     		bx	lr
 1934              	.L165:
 1935              		.align	2
 1936              	.L164:
 1937 0008 10200240 		.word	1073881104
 1938              		.cfi_endproc
 1939              	.LFE25:
 1941              		.section	.text.flashUnlock,"ax",%progbits
 1942              		.align	2
 1943              		.global	flashUnlock
 1944              		.thumb
 1945              		.thumb_func
 1947              	flashUnlock:
 1948              	.LFB26:
 742:hardware.c    **** }
 743:hardware.c    **** 
 744:hardware.c    **** void flashUnlock() {
 1949              		.loc 1 744 0
 1950              		.cfi_startproc
 1951              		@ args = 0, pretend = 0, frame = 0
 1952              		@ frame_needed = 0, uses_anonymous_args = 0
 1953              		@ link register save eliminated.
 745:hardware.c    ****     /* unlock the flash */
 746:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY1);
 1954              		.loc 1 746 0
 1955 0000 024B     		ldr	r3, .L167
 1956 0002 0349     		ldr	r1, .L167+4
 747:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY2);
 1957              		.loc 1 747 0
 1958 0004 034A     		ldr	r2, .L167+8
 746:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY1);
 1959              		.loc 1 746 0
 1960 0006 1960     		str	r1, [r3]
 1961              		.loc 1 747 0
 1962 0008 1A60     		str	r2, [r3]
 1963 000a 7047     		bx	lr
 1964              	.L168:
 1965              		.align	2
 1966              	.L167:
 1967 000c 04200240 		.word	1073881092
 1968 0010 23016745 		.word	1164378403
 1969 0014 AB89EFCD 		.word	-839939669
 1970              		.cfi_endproc
 1971              	.LFE26:
 1973              		.section	.text.crMask,"ax",%progbits
 1974              		.align	2
 1975              		.global	crMask
 1976              		.thumb
 1977              		.thumb_func
 1979              	crMask:
 1980              	.LFB27:
 748:hardware.c    **** }
 749:hardware.c    **** 
 750:hardware.c    **** 
 751:hardware.c    **** // Used to create the control register masking pattern, when setting control register mode.
 752:hardware.c    **** unsigned int crMask(int pin)
 753:hardware.c    **** {
 1981              		.loc 1 753 0
 1982              		.cfi_startproc
 1983              		@ args = 0, pretend = 0, frame = 0
 1984              		@ frame_needed = 0, uses_anonymous_args = 0
 1985              		@ link register save eliminated.
 1986              	.LVL150:
 754:hardware.c    **** 	unsigned int mask;
 755:hardware.c    **** 	if (pin>=8)
 1987              		.loc 1 755 0
 1988 0000 0728     		cmp	r0, #7
 756:hardware.c    **** 	{
 757:hardware.c    **** 		pin-=8;
 1989              		.loc 1 757 0
 1990 0002 C8BF     		it	gt
 1991 0004 0838     		subgt	r0, r0, #8
 1992              	.LVL151:
 758:hardware.c    **** 	}
 759:hardware.c    **** 	mask = 0x0F << (pin<<2);
 1993              		.loc 1 759 0
 1994 0006 0F23     		movs	r3, #15
 1995 0008 8000     		lsls	r0, r0, #2
 1996              	.LVL152:
 1997 000a 03FA00F0 		lsl	r0, r3, r0
 1998              	.LVL153:
 760:hardware.c    **** 	return ~mask;
 761:hardware.c    **** }	
 1999              		.loc 1 761 0
 2000 000e C043     		mvns	r0, r0
 2001              	.LVL154:
 2002 0010 7047     		bx	lr
 2003              		.cfi_endproc
 2004              	.LFE27:
 2006 0012 00BF     		.section	.text.getFlashEnd,"ax",%progbits
 2007              		.align	2
 2008              		.global	getFlashEnd
 2009              		.thumb
 2010              		.thumb_func
 2012              	getFlashEnd:
 2013              	.LFB28:
 762:hardware.c    **** 
 763:hardware.c    **** #define FLASH_SIZE_REG 0x1FFFF7E0
 764:hardware.c    **** int getFlashEnd(void)
 765:hardware.c    **** {
 2014              		.loc 1 765 0
 2015              		.cfi_startproc
 2016              		@ args = 0, pretend = 0, frame = 0
 2017              		@ frame_needed = 0, uses_anonymous_args = 0
 2018              		@ link register save eliminated.
 2019              	.LVL155:
 766:hardware.c    **** 	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
 767:hardware.c    **** 	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
 2020              		.loc 1 767 0
 2021 0000 024B     		ldr	r3, .L172
 2022 0002 1888     		ldrh	r0, [r3]
 2023 0004 00F50030 		add	r0, r0, #131072
 768:hardware.c    **** }
 2024              		.loc 1 768 0
 2025 0008 8002     		lsls	r0, r0, #10
 2026 000a 7047     		bx	lr
 2027              	.L173:
 2028              		.align	2
 2029              	.L172:
 2030 000c E0F7FF1F 		.word	536868832
 2031              		.cfi_endproc
 2032              	.LFE28:
 2034              		.section	.text.getFlashPageSize,"ax",%progbits
 2035              		.align	2
 2036              		.global	getFlashPageSize
 2037              		.thumb
 2038              		.thumb_func
 2040              	getFlashPageSize:
 2041              	.LFB29:
 769:hardware.c    **** 
 770:hardware.c    **** int getFlashPageSize(void)
 771:hardware.c    **** {
 2042              		.loc 1 771 0
 2043              		.cfi_startproc
 2044              		@ args = 0, pretend = 0, frame = 0
 2045              		@ frame_needed = 0, uses_anonymous_args = 0
 2046              		@ link register save eliminated.
 2047              	.LVL156:
 772:hardware.c    **** 
 773:hardware.c    **** 	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
 774:hardware.c    **** 	if ((*flashSize & 0xffff) > 128)
 2048              		.loc 1 774 0
 2049 0000 044B     		ldr	r3, .L177
 2050 0002 1B88     		ldrh	r3, [r3]
 775:hardware.c    **** 	{
 776:hardware.c    **** 		return 0x800;
 2051              		.loc 1 776 0
 2052 0004 812B     		cmp	r3, #129
 777:hardware.c    **** 	}
 778:hardware.c    **** 	else
 779:hardware.c    **** 	{
 780:hardware.c    **** 		return 0x400;
 781:hardware.c    **** 	}
 782:hardware.c    **** }
 2053              		.loc 1 782 0
 2054 0006 34BF     		ite	cc
 2055 0008 4FF48060 		movcc	r0, #1024
 2056 000c 4FF40060 		movcs	r0, #2048
 2057 0010 7047     		bx	lr
 2058              	.L178:
 2059 0012 00BF     		.align	2
 2060              	.L177:
 2061 0014 E0F7FF1F 		.word	536868832
 2062              		.cfi_endproc
 2063              	.LFE29:
 2065              		.comm	wTransferSize,4,4
 2066              		.section	.rodata
 2067              		.align	2
 2068              		.set	.LANCHOR0,. + 0
 2069              	.LC0:
 2070 0000 FE       		.byte	-2
 2071 0001 ED       		.byte	-19
 2072 0002 FA       		.byte	-6
 2073 0003 CE       		.byte	-50
 2074              	.LC1:
 2075 0004 F3       		.byte	-13
 2076 0005 47       		.byte	71
 2077 0006 B9       		.byte	-71
 2078 0007 5E       		.byte	94
 2079 0008 5F       		.byte	95
 2080 0009 03       		.byte	3
 2081 000a 62       		.byte	98
 2082 000b 13       		.byte	19
 2083 000c F3       		.byte	-13
 2084 000d 88       		.byte	-120
 2085 000e 72       		.byte	114
 2086 000f 73       		.byte	115
 2087 0010 EA       		.byte	-22
 2088 0011 CF       		.byte	-49
 2089 0012 91       		.byte	-111
 2090 0013 73       		.byte	115
 2091 0014 35       		.byte	53
 2092 0015 DA       		.byte	-38
 2093 0016 72       		.byte	114
 2094 0017 68       		.byte	104
 2095 0018 AE       		.byte	-82
 2096 0019 F6       		.byte	-10
 2097 001a 98       		.byte	-104
 2098 001b 90       		.byte	-112
 2099 001c 51       		.byte	81
 2100 001d 87       		.byte	-121
 2101 001e FF       		.byte	-1
 2102 001f EA       		.byte	-22
 2103 0020 D6       		.byte	-42
 2104 0021 B5       		.byte	-75
 2105 0022 5B       		.byte	91
 2106 0023 32       		.byte	50
 2107              		.section	.rodata.str1.4,"aMS",%progbits,1
 2108              		.align	2
 2109              	.LC2:
 2110 0000 25582558 		.ascii	"%X%X%X%X\000"
 2110      25582558 
 2110      00
 2111 0009 000000   		.space	3
 2112              	.LC3:
 2113 000c 25582558 		.ascii	"%X%X%X%X\012\000"
 2113      25582558 
 2113      0A00
 2114 0016 0000     		.text
 2115              	.Letext0:
 2116              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 2117              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 2118              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\mach
 2119              		.file 5 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdi
 2120              		.file 6 "./stm32_lib/stm32f10x_type.h"
 2121              		.file 7 "hardware.h"
 2122              		.file 8 "<built-in>"
 2123              		.file 9 "./25519/sha256.h"
 2124              		.file 10 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\std
 2125              		.file 11 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\str
 2126              		.file 12 "./25519/edsign.h"
 2127              		.file 13 "usb.h"
DEFINED SYMBOLS
                            *ABS*:00000000 hardware.c
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:19     .text.gpio_write_bit:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:24     .text.gpio_write_bit:00000000 gpio_write_bit
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:51     .text.readPin:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:56     .text.readPin:00000000 readPin
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:80     .text.strobePin:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:85     .text.strobePin:00000000 strobePin
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:223    .text.UU_PutChar:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:228    .text.UU_PutChar:00000000 UU_PutChar
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:248    .text.UU_PutString:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:253    .text.UU_PutString:00000000 UU_PutString
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:289    .text.vprint:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:294    .text.vprint:00000000 vprint
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:356    .text.vprint:00000034 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:361    .text.uart_printf:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:366    .text.uart_printf:00000000 uart_printf
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:450    .text.uart_printf:00000040 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:455    .text.uartInit:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:460    .text.uartInit:00000000 uartInit
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:557    .text.uartInit:00000080 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:563    .text.systemReset:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:568    .text.systemReset:00000000 systemReset
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:620    .text.systemReset:00000040 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:628    .text.setupCLK:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:633    .text.setupCLK:00000000 setupCLK
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:705    .text.setupCLK:00000060 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:712    .text.setupLEDAndButton:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:717    .text.setupLEDAndButton:00000000 setupLEDAndButton
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:735    .text.setupLEDAndButton:00000010 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:740    .text.setupFLASH:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:745    .text.setupFLASH:00000000 setupFLASH
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:780    .text.setupFLASH:0000001c $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:785    .text.uid_read:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:790    .text.uid_read:00000000 uid_read
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:826    .text.uid_read:0000001c $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:833    .text.checkUserCode:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:838    .text.checkUserCode:00000000 checkUserCode
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1096   .text.checkUserCode:00000158 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1108   .text.setMspAndJump:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1113   .text.setMspAndJump:00000000 setMspAndJump
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1146   .text.setMspAndJump:00000014 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1151   .text.jumpToUser:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1156   .text.jumpToUser:00000000 jumpToUser
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1299   .text.jumpToUser:00000084 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1314   .text.bkp10Write:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1319   .text.bkp10Write:00000000 bkp10Write
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1361   .text.bkp10Write:00000028 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1368   .text.checkAndClearBootloaderFlag:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1373   .text.checkAndClearBootloaderFlag:00000000 checkAndClearBootloaderFlag
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1462   .text.checkAndClearBootloaderFlag:0000005c $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1469   .text.nvicInit:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1474   .text.nvicInit:00000000 nvicInit
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1565   .text.nvicInit:00000068 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1571   .text.nvicDisableInterrupts:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1576   .text.nvicDisableInterrupts:00000000 nvicDisableInterrupts
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1606   .text.nvicDisableInterrupts:00000020 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1612   .text.systemHardReset:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1617   .text.systemHardReset:00000000 systemHardReset
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1639   .text.systemHardReset:0000000c $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1645   .text.flashErasePage:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1650   .text.flashErasePage:00000000 flashErasePage
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1708   .text.flashErasePage:00000034 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1715   .text.flashErasePages:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1720   .text.flashErasePages:00000000 flashErasePages
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1813   .text.flashErasePages:00000050 $d
                            *COM*:00000004 wTransferSize
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1821   .text.flashWriteWord:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1826   .text.flashWriteWord:00000000 flashWriteWord
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1911   .text.flashWriteWord:00000050 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1917   .text.flashLock:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1922   .text.flashLock:00000000 flashLock
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1937   .text.flashLock:00000008 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1942   .text.flashUnlock:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1947   .text.flashUnlock:00000000 flashUnlock
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1967   .text.flashUnlock:0000000c $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1974   .text.crMask:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:1979   .text.crMask:00000000 crMask
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:2007   .text.getFlashEnd:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:2012   .text.getFlashEnd:00000000 getFlashEnd
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:2030   .text.getFlashEnd:0000000c $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:2035   .text.getFlashPageSize:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:2040   .text.getFlashPageSize:00000000 getFlashPageSize
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:2061   .text.getFlashPageSize:00000014 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:2067   .rodata:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccMmG83j.s:2108   .rodata.str1.4:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vsprintf
RCC_APB2PeriphClockCmd
GPIO_Init
USART_Init
USART_Cmd
memset
memcmp
sha256_starts
sha256_update
memmem
sprintf
sha256_finish
print_hash
edsign_verify
usbDsbISR
usbDsbBus
