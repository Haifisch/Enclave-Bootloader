   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"hardware.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.gpio_write_bit,"ax",%progbits
  16              		.align	1
  17              		.global	gpio_write_bit
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	gpio_write_bit:
  24              	.LFB5:
  25              		.file 1 "hardware.c"
   1:hardware.c    **** /* *****************************************************************************
   2:hardware.c    ****  * The MIT License
   3:hardware.c    ****  *
   4:hardware.c    ****  * Copyright (c) 2010 LeafLabs LLC.
   5:hardware.c    ****  *
   6:hardware.c    ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:hardware.c    ****  * of this software and associated documentation files (the "Software"), to deal
   8:hardware.c    ****  * in the Software without restriction, including without limitation the rights
   9:hardware.c    ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:hardware.c    ****  * copies of the Software, and to permit persons to whom the Software is
  11:hardware.c    ****  * furnished to do so, subject to the following conditions:
  12:hardware.c    ****  *
  13:hardware.c    ****  * The above copyright notice and this permission notice shall be included in
  14:hardware.c    ****  * all copies or substantial portions of the Software.
  15:hardware.c    ****  *
  16:hardware.c    ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:hardware.c    ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:hardware.c    ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:hardware.c    ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:hardware.c    ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:hardware.c    ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:hardware.c    ****  * THE SOFTWARE.
  23:hardware.c    ****  * ****************************************************************************/
  24:hardware.c    **** 
  25:hardware.c    **** /**
  26:hardware.c    ****  *  @file hardware.c
  27:hardware.c    ****  *
  28:hardware.c    ****  *  @brief init routines to setup clocks, interrupts, also destructor functions.
  29:hardware.c    ****  *  does not include USB stuff. EEPROM read/write functions.
  30:hardware.c    ****  *
  31:hardware.c    ****  */
  32:hardware.c    **** #include <stdio.h>
  33:hardware.c    **** #include <stdint.h>
  34:hardware.c    **** #include <string.h>
  35:hardware.c    **** #include <limits.h>
  36:hardware.c    **** #include <unistd.h>
  37:hardware.c    **** #include <errno.h>
  38:hardware.c    **** #include <stdarg.h>
  39:hardware.c    **** 
  40:hardware.c    **** 
  41:hardware.c    **** #include "common.h"
  42:hardware.c    **** #include "hardware.h"
  43:hardware.c    **** #include "sha256.h"
  44:hardware.c    **** #include "edsign.h"
  45:hardware.c    **** #include "c25519.h"
  46:hardware.c    **** #include "image.h"
  47:hardware.c    **** 
  48:hardware.c    **** /*
  49:hardware.c    **** void setPin(u32 bank, u8 pin) {
  50:hardware.c    ****     u32 pinMask = 0x1 << (pin);
  51:hardware.c    ****     SET_REG(GPIO_BSRR(bank), pinMask);
  52:hardware.c    **** }
  53:hardware.c    **** 
  54:hardware.c    **** void resetPin(u32 bank, u8 pin) {
  55:hardware.c    ****     u32 pinMask = 0x1 << (16 + pin);
  56:hardware.c    ****     SET_REG(GPIO_BSRR(bank), pinMask);
  57:hardware.c    **** }
  58:hardware.c    **** */
  59:hardware.c    **** void gpio_write_bit(u32 bank, u8 pin, u8 val) {
  26              		.loc 1 59 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31              	.LVL0:
  60:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
  32              		.loc 1 60 0
  33 0000 B2FA82F2 		clz	r2, r2
  34              	.LVL1:
  61:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
  35              		.loc 1 61 0
  36 0004 0123     		movs	r3, #1
  60:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
  37              		.loc 1 60 0
  38 0006 5209     		lsrs	r2, r2, #5
  39              		.loc 1 61 0
  40 0008 03FA01F1 		lsl	r1, r3, r1
  41              	.LVL2:
  42 000c 1201     		lsls	r2, r2, #4
  43 000e 9140     		lsls	r1, r1, r2
  44 0010 0161     		str	r1, [r0, #16]
  62:hardware.c    **** }
  45              		.loc 1 62 0
  46 0012 7047     		bx	lr
  47              		.cfi_endproc
  48              	.LFE5:
  50              		.section	.text.readPin,"ax",%progbits
  51              		.align	1
  52              		.global	readPin
  53              		.syntax unified
  54              		.thumb
  55              		.thumb_func
  56              		.fpu softvfp
  58              	readPin:
  59              	.LFB6:
  63:hardware.c    **** 
  64:hardware.c    **** bool readPin(u32 bank, u8 pin) {
  60              		.loc 1 64 0
  61              		.cfi_startproc
  62              		@ args = 0, pretend = 0, frame = 0
  63              		@ frame_needed = 0, uses_anonymous_args = 0
  64              		@ link register save eliminated.
  65              	.LVL3:
  65:hardware.c    ****     // todo, implement read
  66:hardware.c    ****     if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
  66              		.loc 1 66 0
  67 0000 0123     		movs	r3, #1
  68 0002 8268     		ldr	r2, [r0, #8]
  69 0004 03FA01F1 		lsl	r1, r3, r1
  70              	.LVL4:
  71 0008 1142     		tst	r1, r2
  67:hardware.c    ****         return TRUE;
  68:hardware.c    ****     } else {
  69:hardware.c    ****         return FALSE;
  70:hardware.c    ****     }
  71:hardware.c    **** }
  72              		.loc 1 71 0
  73 000a 14BF     		ite	ne
  74 000c 1846     		movne	r0, r3
  75              	.LVL5:
  76 000e 0020     		moveq	r0, #0
  77 0010 7047     		bx	lr
  78              		.cfi_endproc
  79              	.LFE6:
  81              		.section	.text.strobePin,"ax",%progbits
  82              		.align	1
  83              		.global	strobePin
  84              		.syntax unified
  85              		.thumb
  86              		.thumb_func
  87              		.fpu softvfp
  89              	strobePin:
  90              	.LFB7:
  72:hardware.c    **** 
  73:hardware.c    **** void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
  74:hardware.c    **** {
  91              		.loc 1 74 0
  92              		.cfi_startproc
  93              		@ args = 4, pretend = 0, frame = 0
  94              		@ frame_needed = 0, uses_anonymous_args = 0
  95              	.LVL6:
  96 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
  97              		.cfi_def_cfa_offset 32
  98              		.cfi_offset 3, -32
  99              		.cfi_offset 4, -28
 100              		.cfi_offset 5, -24
 101              		.cfi_offset 6, -20
 102              		.cfi_offset 7, -16
 103              		.cfi_offset 8, -12
 104              		.cfi_offset 9, -8
 105              		.cfi_offset 14, -4
 106              		.loc 1 74 0
 107 0004 9DF82090 		ldrb	r9, [sp, #32]	@ zero_extendqisi2
 108 0008 1446     		mov	r4, r2
  75:hardware.c    ****   gpio_write_bit( bank,pin,1-onState);
 109              		.loc 1 75 0
 110 000a C9F10105 		rsb	r5, r9, #1
 111 000e EDB2     		uxtb	r5, r5
  74:hardware.c    ****   gpio_write_bit( bank,pin,1-onState);
 112              		.loc 1 74 0
 113 0010 0646     		mov	r6, r0
 114 0012 0F46     		mov	r7, r1
 115 0014 9846     		mov	r8, r3
 116              		.loc 1 75 0
 117 0016 2A46     		mov	r2, r5
 118              	.LVL7:
 119              	.L10:
  76:hardware.c    ****   u32 c;
  77:hardware.c    ****   while (count-- > 0) {
 120              		.loc 1 77 0
 121 0018 013C     		subs	r4, r4, #1
 122 001a E4B2     		uxtb	r4, r4
  78:hardware.c    ****     for (c = rate; c > 0; c--){
  79:hardware.c    ****       asm volatile("nop");
  80:hardware.c    ****     }
  81:hardware.c    ****     gpio_write_bit( bank,pin,onState);
  82:hardware.c    ****     for (c = rate; c > 0; c--) {
  83:hardware.c    ****       asm volatile("nop");
  84:hardware.c    ****     }
  85:hardware.c    ****     gpio_write_bit( bank,pin,1-onState);
 123              		.loc 1 85 0
 124 001c FFF7FEFF 		bl	gpio_write_bit
 125              	.LVL8:
  77:hardware.c    ****     for (c = rate; c > 0; c--){
 126              		.loc 1 77 0
 127 0020 FF2C     		cmp	r4, #255
 128 0022 10D1     		bne	.L9
  86:hardware.c    ****   }
  87:hardware.c    **** }
 129              		.loc 1 87 0
 130 0024 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 131              	.LVL9:
 132              	.L5:
  79:hardware.c    ****     }
 133              		.loc 1 79 0 discriminator 3
 134              		.syntax unified
 135              	@ 79 "hardware.c" 1
 136 0028 00BF     		nop
 137              	@ 0 "" 2
  78:hardware.c    ****       asm volatile("nop");
 138              		.loc 1 78 0 discriminator 3
 139              		.thumb
 140              		.syntax unified
 141 002a 013B     		subs	r3, r3, #1
 142              	.LVL10:
 143              	.L8:
  78:hardware.c    ****       asm volatile("nop");
 144              		.loc 1 78 0 is_stmt 0 discriminator 1
 145 002c 002B     		cmp	r3, #0
 146 002e FBD1     		bne	.L5
  81:hardware.c    ****     for (c = rate; c > 0; c--) {
 147              		.loc 1 81 0 is_stmt 1
 148 0030 4A46     		mov	r2, r9
 149 0032 3946     		mov	r1, r7
 150 0034 3046     		mov	r0, r6
 151              	.LVL11:
 152 0036 FFF7FEFF 		bl	gpio_write_bit
 153              	.LVL12:
  82:hardware.c    ****       asm volatile("nop");
 154              		.loc 1 82 0
 155 003a 4346     		mov	r3, r8
 156              	.LVL13:
 157              	.L6:
  82:hardware.c    ****       asm volatile("nop");
 158              		.loc 1 82 0 is_stmt 0 discriminator 1
 159 003c 2BB9     		cbnz	r3, .L7
  85:hardware.c    ****   }
 160              		.loc 1 85 0 is_stmt 1
 161 003e 2A46     		mov	r2, r5
 162 0040 3946     		mov	r1, r7
 163 0042 3046     		mov	r0, r6
 164              	.LVL14:
 165 0044 E8E7     		b	.L10
 166              	.LVL15:
 167              	.L9:
  78:hardware.c    ****       asm volatile("nop");
 168              		.loc 1 78 0
 169 0046 4346     		mov	r3, r8
 170 0048 F0E7     		b	.L8
 171              	.LVL16:
 172              	.L7:
  83:hardware.c    ****     }
 173              		.loc 1 83 0 discriminator 3
 174              		.syntax unified
 175              	@ 83 "hardware.c" 1
 176 004a 00BF     		nop
 177              	@ 0 "" 2
  82:hardware.c    ****       asm volatile("nop");
 178              		.loc 1 82 0 discriminator 3
 179              		.thumb
 180              		.syntax unified
 181 004c 013B     		subs	r3, r3, #1
 182              	.LVL17:
 183 004e F5E7     		b	.L6
 184              		.cfi_endproc
 185              	.LFE7:
 187              		.section	.text.UU_PutChar,"ax",%progbits
 188              		.align	1
 189              		.global	UU_PutChar
 190              		.syntax unified
 191              		.thumb
 192              		.thumb_func
 193              		.fpu softvfp
 195              	UU_PutChar:
 196              	.LFB8:
  88:hardware.c    **** 
  89:hardware.c    **** 
  90:hardware.c    **** typedef struct
  91:hardware.c    **** {
  92:hardware.c    ****   uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate
  93:hardware.c    ****                                            The baud rate is computed using the following formula:
  94:hardware.c    ****                                             - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->
  95:hardware.c    ****                                             - FractionalDivider = ((IntegerDivider - ((u32) Integer
  96:hardware.c    **** 
  97:hardware.c    ****   uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or receive
  98:hardware.c    ****                                            This parameter can be a value of @ref USART_Word_Length 
  99:hardware.c    **** 
 100:hardware.c    ****   uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
 101:hardware.c    ****                                            This parameter can be a value of @ref USART_Stop_Bits */
 102:hardware.c    **** 
 103:hardware.c    ****   uint16_t USART_Parity;              /*!< Specifies the parity mode.
 104:hardware.c    ****                                            This parameter can be a value of @ref USART_Parity
 105:hardware.c    ****                                            @note When parity is enabled, the computed parity is ins
 106:hardware.c    ****                                                  at the MSB position of the transmitted data (9th b
 107:hardware.c    ****                                                  the word length is set to 9 data bits; 8th bit whe
 108:hardware.c    ****                                                  word length is set to 8 data bits). */
 109:hardware.c    ****  
 110:hardware.c    ****   uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled
 111:hardware.c    ****                                            This parameter can be a value of @ref USART_Mode */
 112:hardware.c    **** 
 113:hardware.c    ****   uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabl
 114:hardware.c    ****                                            or disabled.
 115:hardware.c    ****                                            This parameter can be a value of @ref USART_Hardware_Flo
 116:hardware.c    **** } USART_InitTypeDef;
 117:hardware.c    **** 
 118:hardware.c    **** /** 
 119:hardware.c    ****   * @brief  USART Clock Init Structure definition  
 120:hardware.c    ****   */ 
 121:hardware.c    ****   
 122:hardware.c    **** typedef struct
 123:hardware.c    **** {
 124:hardware.c    **** 
 125:hardware.c    ****   uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.
 126:hardware.c    ****                                This parameter can be a value of @ref USART_Clock */
 127:hardware.c    **** 
 128:hardware.c    ****   uint16_t USART_CPOL;    /*!< Specifies the steady state value of the serial clock.
 129:hardware.c    ****                                This parameter can be a value of @ref USART_Clock_Polarity */
 130:hardware.c    **** 
 131:hardware.c    ****   uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.
 132:hardware.c    ****                                This parameter can be a value of @ref USART_Clock_Phase */
 133:hardware.c    **** 
 134:hardware.c    ****   uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmit
 135:hardware.c    ****                                data bit (MSB) has to be output on the SCLK pin in synchronous mode.
 136:hardware.c    ****                                This parameter can be a value of @ref USART_Last_Bit */
 137:hardware.c    **** } USART_ClockInitTypeDef;
 138:hardware.c    **** 
 139:hardware.c    **** 
 140:hardware.c    **** typedef enum
 141:hardware.c    **** { 
 142:hardware.c    ****   GPIO_Speed_10MHz = 1,
 143:hardware.c    ****   GPIO_Speed_2MHz, 
 144:hardware.c    ****   GPIO_Speed_50MHz
 145:hardware.c    **** }GPIOSpeed_TypeDef;
 146:hardware.c    **** 
 147:hardware.c    **** typedef enum
 148:hardware.c    **** { GPIO_Mode_AIN = 0x0,
 149:hardware.c    ****   GPIO_Mode_IN_FLOATING = 0x04,
 150:hardware.c    ****   GPIO_Mode_IPD = 0x28,
 151:hardware.c    ****   GPIO_Mode_IPU = 0x48,
 152:hardware.c    ****   GPIO_Mode_Out_OD = 0x14,
 153:hardware.c    ****   GPIO_Mode_Out_PP = 0x10,
 154:hardware.c    ****   GPIO_Mode_AF_OD = 0x1C,
 155:hardware.c    ****   GPIO_Mode_AF_PP = 0x18
 156:hardware.c    **** }GPIOMode_TypeDef;
 157:hardware.c    **** 
 158:hardware.c    **** typedef struct
 159:hardware.c    **** {
 160:hardware.c    ****   uint16_t GPIO_Pin;             /*!< Specifies the GPIO pins to be configured.
 161:hardware.c    ****                                       This parameter can be any value of @ref GPIO_pins_define */
 162:hardware.c    **** 
 163:hardware.c    ****   GPIOSpeed_TypeDef GPIO_Speed;  /*!< Specifies the speed for the selected pins.
 164:hardware.c    ****                                       This parameter can be a value of @ref GPIOSpeed_TypeDef */
 165:hardware.c    **** 
 166:hardware.c    ****   GPIOMode_TypeDef GPIO_Mode;    /*!< Specifies the operating mode for the selected pins.
 167:hardware.c    ****                                       This parameter can be a value of @ref GPIOMode_TypeDef */
 168:hardware.c    **** }GPIO_InitTypeDef;
 169:hardware.c    **** 
 170:hardware.c    **** typedef struct
 171:hardware.c    **** {
 172:hardware.c    ****   __IO uint32_t CRL;
 173:hardware.c    ****   __IO uint32_t CRH;
 174:hardware.c    ****   __IO uint32_t IDR;
 175:hardware.c    ****   __IO uint32_t ODR;
 176:hardware.c    ****   __IO uint32_t BSRR;
 177:hardware.c    ****   __IO uint32_t BRR;
 178:hardware.c    ****   __IO uint32_t LCKR;
 179:hardware.c    **** } GPIO_TypeDef;
 180:hardware.c    **** #define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias regi
 181:hardware.c    **** 
 182:hardware.c    **** #define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band r
 183:hardware.c    **** 
 184:hardware.c    **** #define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address */
 185:hardware.c    **** 
 186:hardware.c    **** /*!< Peripheral memory map */
 187:hardware.c    **** #define APB1PERIPH_BASE       PERIPH_BASE
 188:hardware.c    **** #define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
 189:hardware.c    **** 
 190:hardware.c    **** #define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
 191:hardware.c    **** #define USART1              ((USART_TypeDef *) USART1_BASE)
 192:hardware.c    **** 
 193:hardware.c    **** #define USART_WordLength_8b                  ((uint16_t)0x0000)
 194:hardware.c    **** #define USART_WordLength_9b                  ((uint16_t)0x1000)
 195:hardware.c    ****                                     
 196:hardware.c    **** #define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
 197:hardware.c    ****                                       ((LENGTH) == USART_WordLength_9b))
 198:hardware.c    **** /**
 199:hardware.c    ****   * @}
 200:hardware.c    ****   */ 
 201:hardware.c    **** 
 202:hardware.c    **** /** @defgroup USART_Stop_Bits 
 203:hardware.c    ****   * @{
 204:hardware.c    ****   */ 
 205:hardware.c    ****   
 206:hardware.c    **** #define USART_StopBits_1                     ((uint16_t)0x0000)
 207:hardware.c    **** #define USART_StopBits_0_5                   ((uint16_t)0x1000)
 208:hardware.c    **** #define USART_StopBits_2                     ((uint16_t)0x2000)
 209:hardware.c    **** #define USART_StopBits_1_5                   ((uint16_t)0x3000)
 210:hardware.c    **** #define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
 211:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_0_5) || \
 212:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_2) || \
 213:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_1_5))
 214:hardware.c    **** /**
 215:hardware.c    ****   * @}
 216:hardware.c    ****   */ 
 217:hardware.c    **** 
 218:hardware.c    **** /** @defgroup USART_Parity 
 219:hardware.c    ****   * @{
 220:hardware.c    ****   */ 
 221:hardware.c    ****   
 222:hardware.c    **** #define USART_Parity_No                      ((uint16_t)0x0000)
 223:hardware.c    **** #define USART_Parity_Even                    ((uint16_t)0x0400)
 224:hardware.c    **** #define USART_Parity_Odd                     ((uint16_t)0x0600) 
 225:hardware.c    **** #define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
 226:hardware.c    ****                                  ((PARITY) == USART_Parity_Even) || \
 227:hardware.c    ****                                  ((PARITY) == USART_Parity_Odd))
 228:hardware.c    **** /**
 229:hardware.c    ****   * @}
 230:hardware.c    ****   */ 
 231:hardware.c    **** 
 232:hardware.c    **** /** @defgroup USART_Mode 
 233:hardware.c    ****   * @{
 234:hardware.c    ****   */ 
 235:hardware.c    ****   
 236:hardware.c    **** #define USART_Mode_Rx                        ((uint16_t)0x0004)
 237:hardware.c    **** #define USART_Mode_Tx                        ((uint16_t)0x0008)
 238:hardware.c    **** #define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))
 239:hardware.c    **** /**
 240:hardware.c    ****   * @}
 241:hardware.c    ****   */ 
 242:hardware.c    **** 
 243:hardware.c    **** /** @defgroup USART_Hardware_Flow_Control 
 244:hardware.c    ****   * @{
 245:hardware.c    ****   */ 
 246:hardware.c    **** #define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
 247:hardware.c    **** #define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
 248:hardware.c    **** #define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
 249:hardware.c    **** #define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
 250:hardware.c    **** #define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
 251:hardware.c    ****                               (((CONTROL) == USART_HardwareFlowControl_None) || \
 252:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_RTS) || \
 253:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_CTS) || \
 254:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
 255:hardware.c    **** /**
 256:hardware.c    ****   * @}
 257:hardware.c    ****   */ 
 258:hardware.c    **** 
 259:hardware.c    **** /** @defgroup USART_Clock 
 260:hardware.c    ****   * @{
 261:hardware.c    ****   */ 
 262:hardware.c    **** #define USART_Clock_Disable                  ((uint16_t)0x0000)
 263:hardware.c    **** #define USART_Clock_Enable                   ((uint16_t)0x0800)
 264:hardware.c    **** #define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
 265:hardware.c    ****                                ((CLOCK) == USART_Clock_Enable))
 266:hardware.c    **** /**
 267:hardware.c    ****   * @}
 268:hardware.c    ****   */ 
 269:hardware.c    **** 
 270:hardware.c    **** extern void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
 271:hardware.c    **** extern void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
 272:hardware.c    **** #define RCC_APB2Periph_USART1            ((uint32_t)0x00004000)
 273:hardware.c    **** #define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)
 274:hardware.c    **** #define RCC_APB2Periph_AFIO              ((uint32_t)0x00000001)
 275:hardware.c    **** #define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected */
 276:hardware.c    **** #define GPIO_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected */
 277:hardware.c    **** 
 278:hardware.c    **** #define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!< Transmit Data Regis
 279:hardware.c    **** 
 280:hardware.c    **** //DebugLog
 281:hardware.c    **** #ifdef DEBUG
 282:hardware.c    **** void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
 283:hardware.c    **** {
 197              		.loc 1 283 0
 198              		.cfi_startproc
 199              		@ args = 0, pretend = 0, frame = 0
 200              		@ frame_needed = 0, uses_anonymous_args = 0
 201              		@ link register save eliminated.
 202              	.LVL18:
 203              	.L12:
 284:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 204              		.loc 1 284 0 discriminator 1
 205 0000 0388     		ldrh	r3, [r0]
 206 0002 1B06     		lsls	r3, r3, #24
 207 0004 FCD5     		bpl	.L12
 285:hardware.c    ****   USARTx->DR = ch;  
 208              		.loc 1 285 0
 209 0006 89B2     		uxth	r1, r1
 210              	.LVL19:
 211 0008 8180     		strh	r1, [r0, #4]	@ movhi
 286:hardware.c    **** }
 212              		.loc 1 286 0
 213 000a 7047     		bx	lr
 214              		.cfi_endproc
 215              	.LFE8:
 217              		.section	.text.UU_PutString,"ax",%progbits
 218              		.align	1
 219              		.global	UU_PutString
 220              		.syntax unified
 221              		.thumb
 222              		.thumb_func
 223              		.fpu softvfp
 225              	UU_PutString:
 226              	.LFB9:
 287:hardware.c    **** 
 288:hardware.c    **** void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
 289:hardware.c    **** {
 227              		.loc 1 289 0
 228              		.cfi_startproc
 229              		@ args = 0, pretend = 0, frame = 0
 230              		@ frame_needed = 0, uses_anonymous_args = 0
 231              	.LVL20:
 232 0000 10B5     		push	{r4, lr}
 233              		.cfi_def_cfa_offset 8
 234              		.cfi_offset 4, -8
 235              		.cfi_offset 14, -4
 236              		.loc 1 289 0
 237 0002 0446     		mov	r4, r0
 238 0004 4A1E     		subs	r2, r1, #1
 239              	.LVL21:
 240              	.L16:
 290:hardware.c    ****   while(*str != 0)
 241              		.loc 1 290 0
 242 0006 12F8011F 		ldrb	r1, [r2, #1]!	@ zero_extendqisi2
 243              	.LVL22:
 244 000a 01B9     		cbnz	r1, .L17
 291:hardware.c    ****   {
 292:hardware.c    ****     UU_PutChar(USARTx, *str);
 293:hardware.c    ****     str++;
 294:hardware.c    ****   }
 295:hardware.c    **** }
 245              		.loc 1 295 0
 246 000c 10BD     		pop	{r4, pc}
 247              	.L17:
 292:hardware.c    ****     str++;
 248              		.loc 1 292 0
 249 000e 2046     		mov	r0, r4
 250              	.LVL23:
 251 0010 FFF7FEFF 		bl	UU_PutChar
 252              	.LVL24:
 253 0014 F7E7     		b	.L16
 254              		.cfi_endproc
 255              	.LFE9:
 257              		.section	.text.vprint,"ax",%progbits
 258              		.align	1
 259              		.global	vprint
 260              		.syntax unified
 261              		.thumb
 262              		.thumb_func
 263              		.fpu softvfp
 265              	vprint:
 266              	.LFB10:
 296:hardware.c    **** 
 297:hardware.c    **** void vprint(const char *fmt, va_list argp)
 298:hardware.c    **** {
 267              		.loc 1 298 0
 268              		.cfi_startproc
 269              		@ args = 0, pretend = 0, frame = 200
 270              		@ frame_needed = 0, uses_anonymous_args = 0
 271              	.LVL25:
 272 0000 00B5     		push	{lr}
 273              		.cfi_def_cfa_offset 4
 274              		.cfi_offset 14, -4
 275 0002 B3B0     		sub	sp, sp, #204
 276              		.cfi_def_cfa_offset 208
 299:hardware.c    ****     char string[200];
 300:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
 277              		.loc 1 300 0
 278 0004 0A46     		mov	r2, r1
 279 0006 0146     		mov	r1, r0
 280              	.LVL26:
 281 0008 6846     		mov	r0, sp
 282              	.LVL27:
 283 000a FFF7FEFF 		bl	vsprintf
 284              	.LVL28:
 285 000e 0028     		cmp	r0, #0
 286 0010 03DD     		ble	.L18
 301:hardware.c    ****     {
 302:hardware.c    ****         UU_PutString(USART1, (uint8_t*)string); // send message via UART
 287              		.loc 1 302 0
 288 0012 6946     		mov	r1, sp
 289 0014 0248     		ldr	r0, .L20
 290 0016 FFF7FEFF 		bl	UU_PutString
 291              	.LVL29:
 292              	.L18:
 303:hardware.c    ****     }
 304:hardware.c    **** }
 293              		.loc 1 304 0
 294 001a 33B0     		add	sp, sp, #204
 295              		.cfi_def_cfa_offset 4
 296              		@ sp needed
 297 001c 5DF804FB 		ldr	pc, [sp], #4
 298              	.L21:
 299              		.align	2
 300              	.L20:
 301 0020 00380140 		.word	1073821696
 302              		.cfi_endproc
 303              	.LFE10:
 305              		.section	.text.uart_printf,"ax",%progbits
 306              		.align	1
 307              		.global	uart_printf
 308              		.syntax unified
 309              		.thumb
 310              		.thumb_func
 311              		.fpu softvfp
 313              	uart_printf:
 314              	.LFB11:
 305:hardware.c    **** 
 306:hardware.c    **** void uart_printf(const char *fmt, ...) // custom printf() function
 307:hardware.c    **** {
 315              		.loc 1 307 0
 316              		.cfi_startproc
 317              		@ args = 4, pretend = 16, frame = 8
 318              		@ frame_needed = 0, uses_anonymous_args = 1
 319              	.LVL30:
 320 0000 0FB4     		push	{r0, r1, r2, r3}
 321              		.cfi_def_cfa_offset 16
 322              		.cfi_offset 0, -16
 323              		.cfi_offset 1, -12
 324              		.cfi_offset 2, -8
 325              		.cfi_offset 3, -4
 326 0002 07B5     		push	{r0, r1, r2, lr}
 327              		.cfi_def_cfa_offset 32
 328              		.cfi_offset 14, -20
 329              		.loc 1 307 0
 330 0004 04A9     		add	r1, sp, #16
 331 0006 51F8040B 		ldr	r0, [r1], #4
 308:hardware.c    ****     va_list argp;
 309:hardware.c    ****     va_start(argp, fmt);
 332              		.loc 1 309 0
 333 000a 0191     		str	r1, [sp, #4]
 310:hardware.c    ****     vprint(fmt, argp);
 334              		.loc 1 310 0
 335 000c FFF7FEFF 		bl	vprint
 336              	.LVL31:
 311:hardware.c    ****     va_end(argp);
 312:hardware.c    **** }
 337              		.loc 1 312 0
 338 0010 03B0     		add	sp, sp, #12
 339              		.cfi_def_cfa_offset 20
 340              		@ sp needed
 341 0012 5DF804EB 		ldr	lr, [sp], #4
 342              		.cfi_restore 14
 343              		.cfi_def_cfa_offset 16
 344 0016 04B0     		add	sp, sp, #16
 345              		.cfi_restore 3
 346              		.cfi_restore 2
 347              		.cfi_restore 1
 348              		.cfi_restore 0
 349              		.cfi_def_cfa_offset 0
 350 0018 7047     		bx	lr
 351              		.cfi_endproc
 352              	.LFE11:
 354              		.section	.text.hexdump,"ax",%progbits
 355              		.align	1
 356              		.global	hexdump
 357              		.syntax unified
 358              		.thumb
 359              		.thumb_func
 360              		.fpu softvfp
 362              	hexdump:
 363              	.LFB12:
 313:hardware.c    **** 
 314:hardware.c    **** void hexdump(unsigned char *data, size_t size)
 315:hardware.c    **** {
 364              		.loc 1 315 0
 365              		.cfi_startproc
 366              		@ args = 0, pretend = 0, frame = 24
 367              		@ frame_needed = 0, uses_anonymous_args = 0
 368              	.LVL32:
 369 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 370              		.cfi_def_cfa_offset 32
 371              		.cfi_offset 4, -32
 372              		.cfi_offset 5, -28
 373              		.cfi_offset 6, -24
 374              		.cfi_offset 7, -20
 375              		.cfi_offset 8, -16
 376              		.cfi_offset 9, -12
 377              		.cfi_offset 10, -8
 378              		.cfi_offset 14, -4
 379 0004 86B0     		sub	sp, sp, #24
 380              		.cfi_def_cfa_offset 56
 381              		.loc 1 315 0
 382 0006 0546     		mov	r5, r0
 383 0008 0E46     		mov	r6, r1
 316:hardware.c    ****     int i;
 317:hardware.c    ****     char cs[17];
 318:hardware.c    ****     memset(cs, 0, 17);
 384              		.loc 1 318 0
 385 000a 1122     		movs	r2, #17
 386 000c 0021     		movs	r1, #0
 387              	.LVL33:
 388 000e 01A8     		add	r0, sp, #4
 389              	.LVL34:
 390 0010 FFF7FEFF 		bl	memset
 391              	.LVL35:
 319:hardware.c    **** 
 320:hardware.c    ****     for(i = 0; i < size; i++)
 392              		.loc 1 320 0
 393 0014 4FF0000A 		mov	r10, #0
 321:hardware.c    ****     {
 322:hardware.c    ****         if(i != 0 && i % 0x10 == 0)
 323:hardware.c    ****         {
 324:hardware.c    ****             debug_print(" |%s|\n", cs);
 325:hardware.c    ****             memset(cs, 0, 17);
 326:hardware.c    ****         }
 327:hardware.c    ****         else if(i != 0 && i % 0x8 == 0)
 328:hardware.c    ****         {
 329:hardware.c    ****             debug_print(" ",0);
 394              		.loc 1 329 0
 395 0018 234F     		ldr	r7, .L39
 324:hardware.c    ****             memset(cs, 0, 17);
 396              		.loc 1 324 0
 397 001a DFF89080 		ldr	r8, .L39+4
 330:hardware.c    ****         }
 331:hardware.c    ****         debug_print("%02X ", data[i]);
 398              		.loc 1 331 0
 399 001e DFF89490 		ldr	r9, .L39+12
 400 0022 013D     		subs	r5, r5, #1
 401              	.LVL36:
 402              	.L24:
 320:hardware.c    ****     {
 403              		.loc 1 320 0 discriminator 2
 404 0024 B245     		cmp	r10, r6
 405 0026 0AF00F04 		and	r4, r10, #15
 406 002a 07D1     		bne	.L28
 407              	.LVL37:
 332:hardware.c    ****         cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
 333:hardware.c    ****     }
 334:hardware.c    **** 
 335:hardware.c    ****     i = i % 0x10;
 336:hardware.c    ****     if(i != 0)
 408              		.loc 1 336 0
 409 002c 64BB     		cbnz	r4, .L29
 410              	.L33:
 337:hardware.c    ****     {
 338:hardware.c    ****         if(i <= 0x8)
 339:hardware.c    ****         {
 340:hardware.c    ****             debug_print(" ",0);
 341:hardware.c    ****         }
 342:hardware.c    ****         while(i++ < 0x10)
 343:hardware.c    ****         {
 344:hardware.c    ****             debug_print("   ",0);
 345:hardware.c    ****         }
 346:hardware.c    ****     }
 347:hardware.c    ****     debug_print(" |%s|\n", cs);
 411              		.loc 1 347 0
 412 002e 01A9     		add	r1, sp, #4
 413 0030 1E48     		ldr	r0, .L39+4
 414 0032 FFF7FEFF 		bl	uart_printf
 415              	.LVL38:
 348:hardware.c    **** }
 416              		.loc 1 348 0
 417 0036 06B0     		add	sp, sp, #24
 418              		.cfi_remember_state
 419              		.cfi_def_cfa_offset 32
 420              		@ sp needed
 421 0038 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 422              	.LVL39:
 423              	.L28:
 424              		.cfi_restore_state
 322:hardware.c    ****         {
 425              		.loc 1 322 0
 426 003c BAF1000F 		cmp	r10, #0
 427 0040 09D0     		beq	.L25
 322:hardware.c    ****         {
 428              		.loc 1 322 0 is_stmt 0 discriminator 1
 429 0042 D4B9     		cbnz	r4, .L26
 324:hardware.c    ****             memset(cs, 0, 17);
 430              		.loc 1 324 0 is_stmt 1 discriminator 1
 431 0044 01A9     		add	r1, sp, #4
 432 0046 4046     		mov	r0, r8
 433 0048 FFF7FEFF 		bl	uart_printf
 434              	.LVL40:
 325:hardware.c    ****         }
 435              		.loc 1 325 0 discriminator 1
 436 004c 1122     		movs	r2, #17
 437 004e 2146     		mov	r1, r4
 438 0050 01A8     		add	r0, sp, #4
 439 0052 FFF7FEFF 		bl	memset
 440              	.LVL41:
 441              	.L25:
 331:hardware.c    ****         cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
 442              		.loc 1 331 0 discriminator 1
 443 0056 15F8011F 		ldrb	r1, [r5, #1]!	@ zero_extendqisi2
 444 005a 4846     		mov	r0, r9
 445 005c FFF7FEFF 		bl	uart_printf
 446              	.LVL42:
 332:hardware.c    ****     }
 447              		.loc 1 332 0 discriminator 1
 448 0060 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 320:hardware.c    ****     {
 449              		.loc 1 320 0 discriminator 1
 450 0062 0AF1010A 		add	r10, r10, #1
 451              	.LVL43:
 332:hardware.c    ****     }
 452              		.loc 1 332 0 discriminator 1
 453 0066 A3F12002 		sub	r2, r3, #32
 454 006a 5E2A     		cmp	r2, #94
 455 006c 88BF     		it	hi
 456 006e 2E23     		movhi	r3, #46
 457 0070 06AA     		add	r2, sp, #24
 458 0072 1444     		add	r4, r4, r2
 459 0074 04F8143C 		strb	r3, [r4, #-20]
 460 0078 D4E7     		b	.L24
 461              	.L26:
 327:hardware.c    ****         {
 462              		.loc 1 327 0 discriminator 1
 463 007a 1AF00701 		ands	r1, r10, #7
 464 007e EAD1     		bne	.L25
 329:hardware.c    ****         }
 465              		.loc 1 329 0 discriminator 1
 466 0080 3846     		mov	r0, r7
 467 0082 FFF7FEFF 		bl	uart_printf
 468              	.LVL44:
 469 0086 E6E7     		b	.L25
 470              	.LVL45:
 471              	.L29:
 338:hardware.c    ****         {
 472              		.loc 1 338 0
 473 0088 082C     		cmp	r4, #8
 474 008a 03DC     		bgt	.L30
 340:hardware.c    ****         }
 475              		.loc 1 340 0 discriminator 1
 476 008c 0021     		movs	r1, #0
 477 008e 0648     		ldr	r0, .L39
 478 0090 FFF7FEFF 		bl	uart_printf
 479              	.LVL46:
 480              	.L30:
 344:hardware.c    ****         }
 481              		.loc 1 344 0
 482 0094 064D     		ldr	r5, .L39+8
 483              	.L31:
 342:hardware.c    ****         {
 484              		.loc 1 342 0
 485 0096 0134     		adds	r4, r4, #1
 486              	.LVL47:
 487 0098 112C     		cmp	r4, #17
 488 009a C8D0     		beq	.L33
 344:hardware.c    ****         }
 489              		.loc 1 344 0 discriminator 1
 490 009c 0021     		movs	r1, #0
 491 009e 2846     		mov	r0, r5
 492 00a0 FFF7FEFF 		bl	uart_printf
 493              	.LVL48:
 494 00a4 F7E7     		b	.L31
 495              	.L40:
 496 00a6 00BF     		.align	2
 497              	.L39:
 498 00a8 07000000 		.word	.LC1
 499 00ac 00000000 		.word	.LC0
 500 00b0 0F000000 		.word	.LC3
 501 00b4 09000000 		.word	.LC2
 502              		.cfi_endproc
 503              	.LFE12:
 505              		.section	.text.print_hash,"ax",%progbits
 506              		.align	1
 507              		.global	print_hash
 508              		.syntax unified
 509              		.thumb
 510              		.thumb_func
 511              		.fpu softvfp
 513              	print_hash:
 514              	.LFB13:
 349:hardware.c    **** 
 350:hardware.c    **** void print_hash(unsigned char hash[])
 351:hardware.c    **** {
 515              		.loc 1 351 0
 516              		.cfi_startproc
 517              		@ args = 0, pretend = 0, frame = 0
 518              		@ frame_needed = 0, uses_anonymous_args = 0
 519              	.LVL49:
 520 0000 70B5     		push	{r4, r5, r6, lr}
 521              		.cfi_def_cfa_offset 16
 522              		.cfi_offset 4, -16
 523              		.cfi_offset 5, -12
 524              		.cfi_offset 6, -8
 525              		.cfi_offset 14, -4
 352:hardware.c    ****    int idx;
 353:hardware.c    ****    for (idx=0; idx < 32; idx++)
 354:hardware.c    ****       debug_print("%02x",hash[idx]);
 526              		.loc 1 354 0
 527 0002 084E     		ldr	r6, .L44
 528 0004 451E     		subs	r5, r0, #1
 529 0006 00F11F04 		add	r4, r0, #31
 530              	.LVL50:
 531              	.L42:
 532              		.loc 1 354 0 is_stmt 0 discriminator 1
 533 000a 15F8011F 		ldrb	r1, [r5, #1]!	@ zero_extendqisi2
 534              	.LVL51:
 535 000e 3046     		mov	r0, r6
 536 0010 FFF7FEFF 		bl	uart_printf
 537              	.LVL52:
 353:hardware.c    ****       debug_print("%02x",hash[idx]);
 538              		.loc 1 353 0 is_stmt 1 discriminator 1
 539 0014 A542     		cmp	r5, r4
 540 0016 F8D1     		bne	.L42
 355:hardware.c    ****    debug_print("\n", 0);
 541              		.loc 1 355 0 discriminator 1
 542 0018 0021     		movs	r1, #0
 356:hardware.c    **** }
 543              		.loc 1 356 0 discriminator 1
 544 001a BDE87040 		pop	{r4, r5, r6, lr}
 545              		.cfi_restore 14
 546              		.cfi_restore 6
 547              		.cfi_restore 5
 548              		.cfi_restore 4
 549              		.cfi_def_cfa_offset 0
 550              	.LVL53:
 355:hardware.c    ****    debug_print("\n", 0);
 551              		.loc 1 355 0 discriminator 1
 552 001e 0248     		ldr	r0, .L44+4
 553 0020 FFF7FEBF 		b	uart_printf
 554              	.LVL54:
 555              	.L45:
 556              		.align	2
 557              	.L44:
 558 0024 00000000 		.word	.LC4
 559 0028 05000000 		.word	.LC5
 560              		.cfi_endproc
 561              	.LFE13:
 563              		.section	.text.uartInit,"ax",%progbits
 564              		.align	1
 565              		.global	uartInit
 566              		.syntax unified
 567              		.thumb
 568              		.thumb_func
 569              		.fpu softvfp
 571              	uartInit:
 572              	.LFB14:
 357:hardware.c    **** 
 358:hardware.c    **** #endif
 359:hardware.c    **** void uartInit(void) {
 573              		.loc 1 359 0
 574              		.cfi_startproc
 575              		@ args = 0, pretend = 0, frame = 32
 576              		@ frame_needed = 0, uses_anonymous_args = 0
 577 0000 10B5     		push	{r4, lr}
 578              		.cfi_def_cfa_offset 8
 579              		.cfi_offset 4, -8
 580              		.cfi_offset 14, -4
 360:hardware.c    ****     GPIO_InitTypeDef GPIO_InitStructure;
 361:hardware.c    ****     USART_InitTypeDef USART_InitStructure; 
 362:hardware.c    ****     USART_ClockInitTypeDef USART_ClockInitStructure;
 363:hardware.c    ****      
 364:hardware.c    ****     //enable bus clocks
 365:hardware.c    ****     RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENAB
 581              		.loc 1 365 0
 582 0002 0121     		movs	r1, #1
 359:hardware.c    ****     GPIO_InitTypeDef GPIO_InitStructure;
 583              		.loc 1 359 0
 584 0004 88B0     		sub	sp, sp, #32
 585              		.cfi_def_cfa_offset 40
 586              		.loc 1 365 0
 587 0006 44F20500 		movw	r0, #16389
 588 000a FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 589              	.LVL55:
 366:hardware.c    ****      
 367:hardware.c    ****     //Set USART1 Tx (PA.09) as AF push-pull
 368:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;  
 590              		.loc 1 368 0
 591 000e 4FF40073 		mov	r3, #512
 592 0012 ADF80430 		strh	r3, [sp, #4]	@ movhi
 369:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;   
 593              		.loc 1 369 0
 594 0016 1823     		movs	r3, #24
 595 0018 8DF80730 		strb	r3, [sp, #7]
 370:hardware.c    ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 596              		.loc 1 370 0
 597 001c 0323     		movs	r3, #3
 371:hardware.c    ****      
 372:hardware.c    ****     GPIO_Init(GPIOA, &GPIO_InitStructure);
 598              		.loc 1 372 0
 599 001e 184C     		ldr	r4, .L47
 600 0020 01A9     		add	r1, sp, #4
 601 0022 2046     		mov	r0, r4
 370:hardware.c    ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 602              		.loc 1 370 0
 603 0024 8DF80630 		strb	r3, [sp, #6]
 604              		.loc 1 372 0
 605 0028 FFF7FEFF 		bl	GPIO_Init
 606              	.LVL56:
 373:hardware.c    ****      
 374:hardware.c    ****     //Set USART1 Rx (PA.10) as input floating
 375:hardware.c    ****      
 376:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 607              		.loc 1 376 0
 608 002c 4FF48063 		mov	r3, #1024
 609 0030 ADF80430 		strh	r3, [sp, #4]	@ movhi
 377:hardware.c    ****      
 378:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 610              		.loc 1 378 0
 611 0034 0423     		movs	r3, #4
 379:hardware.c    ****      
 380:hardware.c    ****     GPIO_Init(GPIOA, &GPIO_InitStructure);
 612              		.loc 1 380 0
 613 0036 2046     		mov	r0, r4
 614 0038 0DEB0301 		add	r1, sp, r3
 378:hardware.c    ****      
 615              		.loc 1 378 0
 616 003c 8DF80730 		strb	r3, [sp, #7]
 381:hardware.c    ****      
 382:hardware.c    ****     USART_ClockStructInit(&USART_ClockInitStructure);
 383:hardware.c    ****      
 384:hardware.c    ****     USART_ClockInit(USART1, &USART_ClockInitStructure);
 617              		.loc 1 384 0
 618 0040 04F54054 		add	r4, r4, #12288
 380:hardware.c    ****      
 619              		.loc 1 380 0
 620 0044 FFF7FEFF 		bl	GPIO_Init
 621              	.LVL57:
 382:hardware.c    ****      
 622              		.loc 1 382 0
 623 0048 02A8     		add	r0, sp, #8
 624 004a FFF7FEFF 		bl	USART_ClockStructInit
 625              	.LVL58:
 626              		.loc 1 384 0
 627 004e 02A9     		add	r1, sp, #8
 628 0050 2046     		mov	r0, r4
 629 0052 FFF7FEFF 		bl	USART_ClockInit
 630              	.LVL59:
 385:hardware.c    ****      
 386:hardware.c    ****     USART_InitStructure.USART_BaudRate = 115200;     
 631              		.loc 1 386 0
 632 0056 0023     		movs	r3, #0
 633 0058 4FF4E132 		mov	r2, #115200
 634 005c CDE90423 		strd	r2, r3, [sp, #16]
 387:hardware.c    ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;     
 388:hardware.c    ****     USART_InitStructure.USART_StopBits = USART_StopBits_1;     
 635              		.loc 1 388 0
 636 0060 4FF44022 		mov	r2, #786432
 389:hardware.c    ****     USART_InitStructure.USART_Parity = USART_Parity_No ;    
 390:hardware.c    ****     USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;    
 391:hardware.c    ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 392:hardware.c    ****      
 393:hardware.c    ****     //Write USART1 parameters     
 394:hardware.c    ****     USART_Init(USART1, &USART_InitStructure);
 637              		.loc 1 394 0
 638 0064 04A9     		add	r1, sp, #16
 639 0066 2046     		mov	r0, r4
 388:hardware.c    ****     USART_InitStructure.USART_Parity = USART_Parity_No ;    
 640              		.loc 1 388 0
 641 0068 0692     		str	r2, [sp, #24]
 390:hardware.c    ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 642              		.loc 1 390 0
 643 006a ADF81C30 		strh	r3, [sp, #28]	@ movhi
 644              		.loc 1 394 0
 645 006e FFF7FEFF 		bl	USART_Init
 646              	.LVL60:
 395:hardware.c    ****      
 396:hardware.c    ****     //Enable USART1
 397:hardware.c    ****     USART_Cmd(USART1, ENABLE);  
 647              		.loc 1 397 0
 648 0072 0121     		movs	r1, #1
 649 0074 2046     		mov	r0, r4
 650 0076 FFF7FEFF 		bl	USART_Cmd
 651              	.LVL61:
 398:hardware.c    **** }
 652              		.loc 1 398 0
 653 007a 08B0     		add	sp, sp, #32
 654              		.cfi_def_cfa_offset 8
 655              		@ sp needed
 656 007c 10BD     		pop	{r4, pc}
 657              	.L48:
 658 007e 00BF     		.align	2
 659              	.L47:
 660 0080 00080140 		.word	1073809408
 661              		.cfi_endproc
 662              	.LFE14:
 664              		.section	.text.systemReset,"ax",%progbits
 665              		.align	1
 666              		.global	systemReset
 667              		.syntax unified
 668              		.thumb
 669              		.thumb_func
 670              		.fpu softvfp
 672              	systemReset:
 673              	.LFB15:
 399:hardware.c    **** 
 400:hardware.c    **** void systemReset(void) {
 674              		.loc 1 400 0
 675              		.cfi_startproc
 676              		@ args = 0, pretend = 0, frame = 0
 677              		@ frame_needed = 0, uses_anonymous_args = 0
 678              		@ link register save eliminated.
 401:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 679              		.loc 1 401 0
 680 0000 0D4B     		ldr	r3, .L50
 402:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 681              		.loc 1 402 0
 682 0002 0E49     		ldr	r1, .L50+4
 401:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 683              		.loc 1 401 0
 684 0004 1A68     		ldr	r2, [r3]
 685 0006 42F00102 		orr	r2, r2, #1
 686 000a 1A60     		str	r2, [r3]
 687              		.loc 1 402 0
 688 000c 0868     		ldr	r0, [r1]
 689 000e 0C4A     		ldr	r2, .L50+8
 690 0010 0240     		ands	r2, r2, r0
 691 0012 0A60     		str	r2, [r1]
 403:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 692              		.loc 1 403 0
 693 0014 1A68     		ldr	r2, [r3]
 694 0016 22F08472 		bic	r2, r2, #17301504
 695 001a 22F48032 		bic	r2, r2, #65536
 696 001e 1A60     		str	r2, [r3]
 404:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
 697              		.loc 1 404 0
 698 0020 1A68     		ldr	r2, [r3]
 699 0022 22F48022 		bic	r2, r2, #262144
 700 0026 1A60     		str	r2, [r3]
 405:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 406:hardware.c    **** 
 407:hardware.c    ****     SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
 701              		.loc 1 407 0
 702 0028 0022     		movs	r2, #0
 405:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 703              		.loc 1 405 0
 704 002a 0B68     		ldr	r3, [r1]
 705 002c 23F4FE03 		bic	r3, r3, #8323072
 706 0030 0B60     		str	r3, [r1]
 707              		.loc 1 407 0
 708 0032 044B     		ldr	r3, .L50+12
 709 0034 1A60     		str	r2, [r3]
 408:hardware.c    **** }
 710              		.loc 1 408 0
 711 0036 7047     		bx	lr
 712              	.L51:
 713              		.align	2
 714              	.L50:
 715 0038 00100240 		.word	1073876992
 716 003c 04100240 		.word	1073876996
 717 0040 0000FFF8 		.word	-117506048
 718 0044 08100240 		.word	1073877000
 719              		.cfi_endproc
 720              	.LFE15:
 722              		.section	.text.setupCLK,"ax",%progbits
 723              		.align	1
 724              		.global	setupCLK
 725              		.syntax unified
 726              		.thumb
 727              		.thumb_func
 728              		.fpu softvfp
 730              	setupCLK:
 731              	.LFB16:
 409:hardware.c    **** 
 410:hardware.c    **** void setupCLK(void) {
 732              		.loc 1 410 0
 733              		.cfi_startproc
 734              		@ args = 0, pretend = 0, frame = 0
 735              		@ frame_needed = 0, uses_anonymous_args = 0
 736              		@ link register save eliminated.
 737              	.LVL62:
 411:hardware.c    **** 	unsigned int StartUpCounter=0;
 412:hardware.c    ****     /* enable HSE */
 413:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
 738              		.loc 1 413 0
 739 0000 154B     		ldr	r3, .L62
 740 0002 1A68     		ldr	r2, [r3]
 741 0004 42F00112 		orr	r2, r2, #65537
 742 0008 1A60     		str	r2, [r3]
 743              	.L53:
 414:hardware.c    ****     while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
 744              		.loc 1 414 0 discriminator 1
 745 000a 1A68     		ldr	r2, [r3]
 746 000c 9003     		lsls	r0, r2, #14
 747 000e FCD5     		bpl	.L53
 415:hardware.c    **** 
 416:hardware.c    ****     /* enable flash prefetch buffer */
 417:hardware.c    ****     SET_REG(FLASH_ACR, 0x00000012);
 748              		.loc 1 417 0
 749 0010 1221     		movs	r1, #18
 750 0012 124A     		ldr	r2, .L62+4
 751 0014 1160     		str	r1, [r2]
 418:hardware.c    **** 	
 419:hardware.c    ****      /* Configure PLL */
 420:hardware.c    **** #ifdef XTAL12M
 421:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
 422:hardware.c    **** #else
 423:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
 752              		.loc 1 423 0
 753 0016 A2F6FC72 		subw	r2, r2, #4092
 754 001a 1168     		ldr	r1, [r2]
 755 001c 41F4E811 		orr	r1, r1, #1900544
 756 0020 41F48061 		orr	r1, r1, #1024
 757 0024 1160     		str	r1, [r2]
 424:hardware.c    **** #endif	
 425:hardware.c    **** 
 426:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
 758              		.loc 1 426 0
 759 0026 1968     		ldr	r1, [r3]
 760 0028 41F08071 		orr	r1, r1, #16777216
 761 002c 1960     		str	r1, [r3]
 762              	.L54:
 427:hardware.c    **** 	
 428:hardware.c    **** 
 429:hardware.c    **** #if !defined  (HSE_STARTUP_TIMEOUT) 
 430:hardware.c    ****   #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
 431:hardware.c    **** #endif /* HSE_STARTUP_TIMEOUT */   
 432:hardware.c    **** 
 433:hardware.c    ****     while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
 763              		.loc 1 433 0 discriminator 2
 764 002e 1968     		ldr	r1, [r3]
 765 0030 11F0407F 		tst	r1, #50331648
 766 0034 FBD0     		beq	.L54
 434:hardware.c    **** 	{
 435:hardware.c    **** //		StartUpCounter++; // This is commented out, so other changes can be committed. It will be uncom
 436:hardware.c    **** 	}	/* wait for it to come on */
 437:hardware.c    **** 
 438:hardware.c    **** 	if (StartUpCounter>=HSE_STARTUP_TIMEOUT)
 439:hardware.c    **** 	{
 440:hardware.c    **** 		// HSE has not started. Try restarting the processor
 441:hardware.c    **** 		systemHardReset(); 
 442:hardware.c    **** 	}
 443:hardware.c    ****     /* Set SYSCLK as PLL */
 444:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
 767              		.loc 1 444 0
 768 0036 1168     		ldr	r1, [r2]
 769 0038 41F00201 		orr	r1, r1, #2
 770 003c 1160     		str	r1, [r2]
 771              	.L55:
 445:hardware.c    ****     while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
 772              		.loc 1 445 0 discriminator 1
 773 003e 1168     		ldr	r1, [r2]
 774 0040 0907     		lsls	r1, r1, #28
 775 0042 FCD5     		bpl	.L55
 446:hardware.c    **** 	
 447:hardware.c    ****     pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
 776              		.loc 1 447 0
 777 0044 9A69     		ldr	r2, [r3, #24]
 778 0046 42F4FE72 		orr	r2, r2, #508
 779 004a 9A61     		str	r2, [r3, #24]
 448:hardware.c    **** 	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
 780              		.loc 1 448 0
 781 004c DA69     		ldr	r2, [r3, #28]
 782 004e 42F40002 		orr	r2, r2, #8388608
 783 0052 DA61     		str	r2, [r3, #28]
 449:hardware.c    **** 
 450:hardware.c    **** }
 784              		.loc 1 450 0
 785 0054 7047     		bx	lr
 786              	.L63:
 787 0056 00BF     		.align	2
 788              	.L62:
 789 0058 00100240 		.word	1073876992
 790 005c 00200240 		.word	1073881088
 791              		.cfi_endproc
 792              	.LFE16:
 794              		.section	.text.setupLEDAndButton,"ax",%progbits
 795              		.align	1
 796              		.global	setupLEDAndButton
 797              		.syntax unified
 798              		.thumb
 799              		.thumb_func
 800              		.fpu softvfp
 802              	setupLEDAndButton:
 803              	.LFB17:
 451:hardware.c    **** 
 452:hardware.c    **** void setupLEDAndButton (void) { 
 804              		.loc 1 452 0
 805              		.cfi_startproc
 806              		@ args = 0, pretend = 0, frame = 0
 807              		@ frame_needed = 0, uses_anonymous_args = 0
 808              		@ link register save eliminated.
 453:hardware.c    ****   SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUT
 809              		.loc 1 453 0
 810 0000 034A     		ldr	r2, .L65
 811 0002 1368     		ldr	r3, [r2]
 812 0004 23F47003 		bic	r3, r3, #15728640
 813 0008 43F48013 		orr	r3, r3, #1048576
 814 000c 1360     		str	r3, [r2]
 454:hardware.c    **** }
 815              		.loc 1 454 0
 816 000e 7047     		bx	lr
 817              	.L66:
 818              		.align	2
 819              	.L65:
 820 0010 04100140 		.word	1073811460
 821              		.cfi_endproc
 822              	.LFE17:
 824              		.section	.text.setupFLASH,"ax",%progbits
 825              		.align	1
 826              		.global	setupFLASH
 827              		.syntax unified
 828              		.thumb
 829              		.thumb_func
 830              		.fpu softvfp
 832              	setupFLASH:
 833              	.LFB18:
 455:hardware.c    **** 
 456:hardware.c    **** void setupFLASH() {
 834              		.loc 1 456 0
 835              		.cfi_startproc
 836              		@ args = 0, pretend = 0, frame = 0
 837              		@ frame_needed = 0, uses_anonymous_args = 0
 838              		@ link register save eliminated.
 457:hardware.c    ****     /* configure the HSI oscillator */
 458:hardware.c    ****     if ((pRCC->CR & 0x01) == 0x00) {
 839              		.loc 1 458 0
 840 0000 054B     		ldr	r3, .L72
 841 0002 1A68     		ldr	r2, [r3]
 842 0004 D107     		lsls	r1, r2, #31
 843              	.LBB4:
 459:hardware.c    ****         u32 rwmVal = pRCC->CR;
 844              		.loc 1 459 0
 845 0006 5EBF     		ittt	pl
 846 0008 1A68     		ldrpl	r2, [r3]
 847              	.LVL63:
 460:hardware.c    ****         rwmVal |= 0x01;
 848              		.loc 1 460 0
 849 000a 42F00102 		orrpl	r2, r2, #1
 850              	.LVL64:
 461:hardware.c    ****         pRCC->CR = rwmVal;
 851              		.loc 1 461 0
 852 000e 1A60     		strpl	r2, [r3]
 853              	.LVL65:
 854              	.L69:
 855              	.LBE4:
 462:hardware.c    ****     }
 463:hardware.c    **** 
 464:hardware.c    ****     /* wait for it to come on */
 465:hardware.c    ****     while ((pRCC->CR & 0x02) == 0x00) {}
 856              		.loc 1 465 0 discriminator 1
 857 0010 1A68     		ldr	r2, [r3]
 858 0012 9207     		lsls	r2, r2, #30
 859 0014 FCD5     		bpl	.L69
 466:hardware.c    **** }   
 860              		.loc 1 466 0
 861 0016 7047     		bx	lr
 862              	.L73:
 863              		.align	2
 864              	.L72:
 865 0018 00100240 		.word	1073876992
 866              		.cfi_endproc
 867              	.LFE18:
 869              		.section	.text.uid_read,"ax",%progbits
 870              		.align	1
 871              		.global	uid_read
 872              		.syntax unified
 873              		.thumb
 874              		.thumb_func
 875              		.fpu softvfp
 877              	uid_read:
 878              	.LFB19:
 467:hardware.c    **** 
 468:hardware.c    **** /* Read U_ID register */
 469:hardware.c    **** void uid_read(struct u_id *id)
 470:hardware.c    **** {
 879              		.loc 1 470 0
 880              		.cfi_startproc
 881              		@ args = 0, pretend = 0, frame = 0
 882              		@ frame_needed = 0, uses_anonymous_args = 0
 883              		@ link register save eliminated.
 884              	.LVL66:
 471:hardware.c    ****   if (QEMU_BUILD) // put an arbitrary ECID in qemu
 472:hardware.c    ****   {
 473:hardware.c    ****     memcpy(&id, (unsigned char*)0xFF, 23);
 474:hardware.c    ****   } else {
 475:hardware.c    ****     id->off0 = MMIO16(U_ID + 0x0);
 476:hardware.c    ****     id->off2 = MMIO16(U_ID + 0x2);
 477:hardware.c    ****     id->off4 = MMIO32(U_ID + 0x4);
 478:hardware.c    ****     id->off8 = MMIO32(U_ID + 0x8);
 479:hardware.c    ****   }
 480:hardware.c    **** }
 885              		.loc 1 480 0
 886 0000 7047     		bx	lr
 887              		.cfi_endproc
 888              	.LFE19:
 890              		.section	.text.setMspAndJump,"ax",%progbits
 891              		.align	1
 892              		.global	setMspAndJump
 893              		.syntax unified
 894              		.thumb
 895              		.thumb_func
 896              		.fpu softvfp
 898              	setMspAndJump:
 899              	.LFB20:
 481:hardware.c    **** 
 482:hardware.c    **** void setMspAndJump(u32 usrAddr) {
 900              		.loc 1 482 0
 901              		.cfi_startproc
 902              		@ args = 0, pretend = 0, frame = 0
 903              		@ frame_needed = 0, uses_anonymous_args = 0
 904              		@ link register save eliminated.
 905              	.LVL67:
 483:hardware.c    ****   // Dedicated function with no call to any function (appart the last call)
 484:hardware.c    ****   // This way, there is no manipulation of the stack here, ensuring that GGC
 485:hardware.c    ****   // didn't insert any pop from the SP after having set the MSP.
 486:hardware.c    ****   typedef void (*funcPtr)(void);
 487:hardware.c    ****   u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
 488:hardware.c    **** 
 489:hardware.c    ****   funcPtr usrMain = (funcPtr) jumpAddr;
 490:hardware.c    **** 
 491:hardware.c    ****   SET_REG(SCB_VTOR, (vu32) (usrAddr));
 906              		.loc 1 491 0
 907 0000 034A     		ldr	r2, .L76
 487:hardware.c    **** 
 908              		.loc 1 487 0
 909 0002 4368     		ldr	r3, [r0, #4]
 910              	.LVL68:
 911              		.loc 1 491 0
 912 0004 1060     		str	r0, [r2]
 492:hardware.c    **** 
 493:hardware.c    ****   asm volatile("msr msp, %0"::"g"
 494:hardware.c    ****                (*(volatile u32 *)usrAddr));
 913              		.loc 1 494 0
 914 0006 0268     		ldr	r2, [r0]
 493:hardware.c    ****                (*(volatile u32 *)usrAddr));
 915              		.loc 1 493 0
 916              		.syntax unified
 917              	@ 493 "hardware.c" 1
 918 0008 82F30888 		msr msp, r2
 919              	@ 0 "" 2
 495:hardware.c    **** 
 496:hardware.c    ****   usrMain();                                /* go! */
 920              		.loc 1 496 0
 921              		.thumb
 922              		.syntax unified
 923 000c 1847     		bx	r3	@ indirect register sibling call
 924              	.LVL69:
 925              	.L77:
 926 000e 00BF     		.align	2
 927              	.L76:
 928 0010 08ED00E0 		.word	-536810232
 929              		.cfi_endproc
 930              	.LFE20:
 932              		.section	.text.bkp10Write,"ax",%progbits
 933              		.align	1
 934              		.global	bkp10Write
 935              		.syntax unified
 936              		.thumb
 937              		.thumb_func
 938              		.fpu softvfp
 940              	bkp10Write:
 941              	.LFB22:
 497:hardware.c    **** }
 498:hardware.c    **** 
 499:hardware.c    **** 
 500:hardware.c    **** void jumpToUser(u32 usrAddr) {
 501:hardware.c    **** 
 502:hardware.c    ****     /* tear down all the dfu related setup */
 503:hardware.c    ****     // disable usb interrupts, clear them, turn off usb, set the disc pin
 504:hardware.c    ****     // todo pick exactly what we want to do here, now its just a conservative
 505:hardware.c    **** 
 506:hardware.c    ****     //flashLock();
 507:hardware.c    ****     usbDsbISR();
 508:hardware.c    ****     nvicDisableInterrupts();
 509:hardware.c    **** 	
 510:hardware.c    **** #ifndef HAS_MAPLE_HARDWARE	
 511:hardware.c    **** 	usbDsbBus();
 512:hardware.c    **** #endif
 513:hardware.c    **** 	
 514:hardware.c    **** // Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(
 515:hardware.c    ****     systemReset(); // resets clocks and periphs, not core regs
 516:hardware.c    ****     //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW
 517:hardware.c    ****     setMspAndJump(usrAddr);
 518:hardware.c    **** }
 519:hardware.c    **** 
 520:hardware.c    **** void bkp10Write(u16 value)
 521:hardware.c    **** {
 942              		.loc 1 521 0
 943              		.cfi_startproc
 944              		@ args = 0, pretend = 0, frame = 0
 945              		@ frame_needed = 0, uses_anonymous_args = 0
 946              		@ link register save eliminated.
 947              	.LVL70:
 522:hardware.c    **** 		// Enable clocks for the backup domain registers
 523:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 948              		.loc 1 523 0
 949 0000 084A     		ldr	r2, .L79
 950 0002 D369     		ldr	r3, [r2, #28]
 951 0004 43F0C053 		orr	r3, r3, #402653184
 952 0008 D361     		str	r3, [r2, #28]
 524:hardware.c    **** 		
 525:hardware.c    ****         // Disable backup register write protection
 526:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 953              		.loc 1 526 0
 954 000a 074B     		ldr	r3, .L79+4
 955 000c 1A68     		ldr	r2, [r3]
 956 000e 42F48072 		orr	r2, r2, #256
 957 0012 1A60     		str	r2, [r3]
 527:hardware.c    **** 
 528:hardware.c    ****         // store value in pBK DR10
 529:hardware.c    ****         pBKP->DR10 = value;
 958              		.loc 1 529 0
 959 0014 054A     		ldr	r2, .L79+8
 960 0016 1085     		strh	r0, [r2, #40]	@ movhi
 530:hardware.c    **** 
 531:hardware.c    ****         // Re-enable backup register write protection
 532:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 961              		.loc 1 532 0
 962 0018 1A68     		ldr	r2, [r3]
 963 001a 22F48072 		bic	r2, r2, #256
 964 001e 1A60     		str	r2, [r3]
 533:hardware.c    **** }
 965              		.loc 1 533 0
 966 0020 7047     		bx	lr
 967              	.L80:
 968 0022 00BF     		.align	2
 969              	.L79:
 970 0024 00100240 		.word	1073876992
 971 0028 00700040 		.word	1073770496
 972 002c 006C0040 		.word	1073769472
 973              		.cfi_endproc
 974              	.LFE22:
 976              		.section	.text.checkAndClearBootloaderFlag,"ax",%progbits
 977              		.align	1
 978              		.global	checkAndClearBootloaderFlag
 979              		.syntax unified
 980              		.thumb
 981              		.thumb_func
 982              		.fpu softvfp
 984              	checkAndClearBootloaderFlag:
 985              	.LFB23:
 534:hardware.c    **** 
 535:hardware.c    **** int checkAndClearBootloaderFlag()
 536:hardware.c    **** {
 986              		.loc 1 536 0
 987              		.cfi_startproc
 988              		@ args = 0, pretend = 0, frame = 0
 989              		@ frame_needed = 0, uses_anonymous_args = 0
 990              	.LVL71:
 537:hardware.c    ****     bool flagSet = 0x00;// Flag not used
 538:hardware.c    **** 
 539:hardware.c    ****     // Enable clocks for the backup domain registers
 540:hardware.c    ****     pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 541:hardware.c    **** 
 542:hardware.c    ****     switch (pBKP->DR10)
 991              		.loc 1 542 0
 992 0000 44F24C21 		movw	r1, #16972
 540:hardware.c    **** 
 993              		.loc 1 540 0
 994 0004 0E4B     		ldr	r3, .L88
 536:hardware.c    ****     bool flagSet = 0x00;// Flag not used
 995              		.loc 1 536 0
 996 0006 10B5     		push	{r4, lr}
 997              		.cfi_def_cfa_offset 8
 998              		.cfi_offset 4, -8
 999              		.cfi_offset 14, -4
 540:hardware.c    **** 
 1000              		.loc 1 540 0
 1001 0008 DA69     		ldr	r2, [r3, #28]
 1002 000a 42F0C052 		orr	r2, r2, #402653184
 1003 000e DA61     		str	r2, [r3, #28]
 1004              		.loc 1 542 0
 1005 0010 0C4A     		ldr	r2, .L88+4
 1006 0012 128D     		ldrh	r2, [r2, #40]
 1007 0014 92B2     		uxth	r2, r2
 1008 0016 8A42     		cmp	r2, r1
 1009 0018 1946     		mov	r1, r3
 1010 001a 05D0     		beq	.L83
 1011 001c 44F24D23 		movw	r3, #16973
 1012 0020 9A42     		cmp	r2, r3
 1013 0022 0BD0     		beq	.L86
 537:hardware.c    ****     bool flagSet = 0x00;// Flag not used
 1014              		.loc 1 537 0
 1015 0024 0024     		movs	r4, #0
 1016 0026 07E0     		b	.L82
 1017              	.L83:
 543:hardware.c    **** 	{
 544:hardware.c    **** 		case RTC_BOOTLOADER_FLAG:
 545:hardware.c    **** 			flagSet = 0x01;
 1018              		.loc 1 545 0
 1019 0028 0124     		movs	r4, #1
 1020              	.L84:
 546:hardware.c    **** 			break;
 547:hardware.c    **** 		case RTC_BOOTLOADER_JUST_UPLOADED:
 548:hardware.c    **** 			flagSet = 0x02;
 549:hardware.c    **** 			break;		
 550:hardware.c    ****     }
 551:hardware.c    **** 
 552:hardware.c    **** 	if (flagSet!=0x00)
 553:hardware.c    **** 	{
 554:hardware.c    **** 		bkp10Write(0x0000);// Clear the flag
 1021              		.loc 1 554 0
 1022 002a 0020     		movs	r0, #0
 1023 002c FFF7FEFF 		bl	bkp10Write
 1024              	.LVL72:
 555:hardware.c    **** 		// Disable clocks
 556:hardware.c    **** 		pRCC->APB1ENR &= ~(RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1025              		.loc 1 556 0
 1026 0030 CB69     		ldr	r3, [r1, #28]
 1027 0032 23F0C053 		bic	r3, r3, #402653184
 1028 0036 CB61     		str	r3, [r1, #28]
 1029              	.L82:
 557:hardware.c    **** 	}
 558:hardware.c    ****     return flagSet;
 559:hardware.c    **** }
 1030              		.loc 1 559 0
 1031 0038 2046     		mov	r0, r4
 1032 003a 10BD     		pop	{r4, pc}
 1033              	.L86:
 548:hardware.c    **** 			break;		
 1034              		.loc 1 548 0
 1035 003c 0224     		movs	r4, #2
 1036 003e F4E7     		b	.L84
 1037              	.L89:
 1038              		.align	2
 1039              	.L88:
 1040 0040 00100240 		.word	1073876992
 1041 0044 006C0040 		.word	1073769472
 1042              		.cfi_endproc
 1043              	.LFE23:
 1045              		.section	.text.nvicInit,"ax",%progbits
 1046              		.align	1
 1047              		.global	nvicInit
 1048              		.syntax unified
 1049              		.thumb
 1050              		.thumb_func
 1051              		.fpu softvfp
 1053              	nvicInit:
 1054              	.LFB24:
 560:hardware.c    **** 
 561:hardware.c    **** void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
 1055              		.loc 1 561 0
 1056              		.cfi_startproc
 1057              		@ args = 0, pretend = 0, frame = 0
 1058              		@ frame_needed = 0, uses_anonymous_args = 0
 1059              	.LVL73:
 562:hardware.c    ****     u32 tmppriority = 0x00;
 563:hardware.c    ****     u32 tmpreg      = 0x00;
 564:hardware.c    ****     u32 tmpmask     = 0x00;
 565:hardware.c    ****     u32 tmppre      = 0;
 566:hardware.c    ****     u32 tmpsub      = 0x0F;
 567:hardware.c    **** 
 568:hardware.c    ****     SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
 569:hardware.c    ****     NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
 570:hardware.c    **** 
 571:hardware.c    **** 
 572:hardware.c    ****     /* Compute the Corresponding IRQ Priority --------------------------------*/
 573:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 1060              		.loc 1 573 0
 1061 0000 184B     		ldr	r3, .L91
 561:hardware.c    ****     u32 tmppriority = 0x00;
 1062              		.loc 1 561 0
 1063 0002 30B5     		push	{r4, r5, lr}
 1064              		.cfi_def_cfa_offset 12
 1065              		.cfi_offset 4, -12
 1066              		.cfi_offset 5, -8
 1067              		.cfi_offset 14, -4
 1068              		.loc 1 573 0
 1069 0004 DA68     		ldr	r2, [r3, #12]
 574:hardware.c    ****     tmppre = (0x4 - tmppriority);
 575:hardware.c    ****     tmpsub = tmpsub >> tmppriority;
 1070              		.loc 1 575 0
 1071 0006 0F24     		movs	r4, #15
 573:hardware.c    ****     tmppre = (0x4 - tmppriority);
 1072              		.loc 1 573 0
 1073 0008 D243     		mvns	r2, r2
 1074 000a C2F30222 		ubfx	r2, r2, #8, #3
 1075              	.LVL74:
 574:hardware.c    ****     tmppre = (0x4 - tmppriority);
 1076              		.loc 1 574 0
 1077 000e C2F10401 		rsb	r1, r2, #4
 1078              	.LVL75:
 1079              		.loc 1 575 0
 1080 0012 24FA02F2 		lsr	r2, r4, r2
 1081              	.LVL76:
 576:hardware.c    **** 
 577:hardware.c    ****     tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 578:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 579:hardware.c    **** 
 580:hardware.c    ****     tmppriority = tmppriority << 0x04;
 581:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 582:hardware.c    **** 
 583:hardware.c    ****     tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 584:hardware.c    ****     tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1082              		.loc 1 584 0
 1083 0016 FF24     		movs	r4, #255
 577:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 1084              		.loc 1 577 0
 1085 0018 4378     		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 1086 001a 03FA01F1 		lsl	r1, r3, r1
 1087              	.LVL77:
 578:hardware.c    **** 
 1088              		.loc 1 578 0
 1089 001e 8378     		ldrb	r3, [r0, #2]	@ zero_extendqisi2
 1090 0020 1340     		ands	r3, r3, r2
 581:hardware.c    **** 
 1091              		.loc 1 581 0
 1092 0022 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
 1093              	.LVL78:
 578:hardware.c    **** 
 1094              		.loc 1 578 0
 1095 0024 0B43     		orrs	r3, r3, r1
 1096              	.LVL79:
 1097 0026 02F0FC01 		and	r1, r2, #252
 1098 002a 01F16041 		add	r1, r1, #-536870912
 1099 002e 01F56141 		add	r1, r1, #57600
 581:hardware.c    **** 
 1100              		.loc 1 581 0
 1101 0032 02F00300 		and	r0, r2, #3
 1102              	.LVL80:
 583:hardware.c    ****     tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1103              		.loc 1 583 0
 1104 0036 D1F80053 		ldr	r5, [r1, #768]
 1105              	.LVL81:
 581:hardware.c    **** 
 1106              		.loc 1 581 0
 1107 003a C000     		lsls	r0, r0, #3
 580:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1108              		.loc 1 580 0
 1109 003c 1B01     		lsls	r3, r3, #4
 1110              	.LVL82:
 581:hardware.c    **** 
 1111              		.loc 1 581 0
 1112 003e 8340     		lsls	r3, r3, r0
 1113              	.LVL83:
 1114 0040 6B40     		eors	r3, r3, r5
 1115              		.loc 1 584 0
 1116 0042 04FA00F0 		lsl	r0, r4, r0
 1117              	.LVL84:
 1118 0046 0340     		ands	r3, r3, r0
 585:hardware.c    ****     tmpreg &= ~tmpmask;
 586:hardware.c    ****     tmppriority &= tmpmask;
 587:hardware.c    ****     tmpreg |= tmppriority;
 1119              		.loc 1 587 0
 1120 0048 6B40     		eors	r3, r3, r5
 1121              	.LVL85:
 588:hardware.c    **** 
 589:hardware.c    ****     rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
 1122              		.loc 1 589 0
 1123 004a C1F80033 		str	r3, [r1, #768]
 590:hardware.c    **** 
 591:hardware.c    ****     /* Enable the Selected IRQ Channels --------------------------------------*/
 592:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 593:hardware.c    ****         (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 1124              		.loc 1 593 0
 1125 004e 0123     		movs	r3, #1
 1126              	.LVL86:
 592:hardware.c    ****         (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 1127              		.loc 1 592 0
 1128 0050 5109     		lsrs	r1, r2, #5
 1129              	.LVL87:
 1130              		.loc 1 593 0
 1131 0052 02F01F02 		and	r2, r2, #31
 1132              	.LVL88:
 1133 0056 03FA02F2 		lsl	r2, r3, r2
 592:hardware.c    ****         (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 1134              		.loc 1 592 0
 1135 005a 034B     		ldr	r3, .L91+4
 1136 005c 43F82120 		str	r2, [r3, r1, lsl #2]
 594:hardware.c    **** }
 1137              		.loc 1 594 0
 1138 0060 30BD     		pop	{r4, r5, pc}
 1139              	.L92:
 1140 0062 00BF     		.align	2
 1141              	.L91:
 1142 0064 00ED00E0 		.word	-536810240
 1143 0068 00E100E0 		.word	-536813312
 1144              		.cfi_endproc
 1145              	.LFE24:
 1147              		.section	.text.nvicDisableInterrupts,"ax",%progbits
 1148              		.align	1
 1149              		.global	nvicDisableInterrupts
 1150              		.syntax unified
 1151              		.thumb
 1152              		.thumb_func
 1153              		.fpu softvfp
 1155              	nvicDisableInterrupts:
 1156              	.LFB25:
 595:hardware.c    **** 
 596:hardware.c    **** void nvicDisableInterrupts() {
 1157              		.loc 1 596 0
 1158              		.cfi_startproc
 1159              		@ args = 0, pretend = 0, frame = 0
 1160              		@ frame_needed = 0, uses_anonymous_args = 0
 1161              		@ link register save eliminated.
 1162              	.LVL89:
 597:hardware.c    ****     NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
 598:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1163              		.loc 1 598 0
 1164 0000 4FF0FF32 		mov	r2, #-1
 1165 0004 064B     		ldr	r3, .L94
 1166 0006 C3F88020 		str	r2, [r3, #128]
 599:hardware.c    ****     rNVIC->ICER[1] = 0xFFFFFFFF;
 1167              		.loc 1 599 0
 1168 000a C3F88420 		str	r2, [r3, #132]
 600:hardware.c    ****     rNVIC->ICPR[0] = 0xFFFFFFFF;
 1169              		.loc 1 600 0
 1170 000e C3F88021 		str	r2, [r3, #384]
 601:hardware.c    ****     rNVIC->ICPR[1] = 0xFFFFFFFF;
 1171              		.loc 1 601 0
 1172 0012 C3F88421 		str	r2, [r3, #388]
 602:hardware.c    **** 
 603:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1173              		.loc 1 603 0
 1174 0016 0422     		movs	r2, #4
 1175 0018 43F8F02C 		str	r2, [r3, #-240]
 604:hardware.c    **** }
 1176              		.loc 1 604 0
 1177 001c 7047     		bx	lr
 1178              	.L95:
 1179 001e 00BF     		.align	2
 1180              	.L94:
 1181 0020 00E100E0 		.word	-536813312
 1182              		.cfi_endproc
 1183              	.LFE25:
 1185              		.section	.text.jumpToUser,"ax",%progbits
 1186              		.align	1
 1187              		.global	jumpToUser
 1188              		.syntax unified
 1189              		.thumb
 1190              		.thumb_func
 1191              		.fpu softvfp
 1193              	jumpToUser:
 1194              	.LFB21:
 500:hardware.c    **** 
 1195              		.loc 1 500 0
 1196              		.cfi_startproc
 1197              		@ args = 0, pretend = 0, frame = 0
 1198              		@ frame_needed = 0, uses_anonymous_args = 0
 1199              	.LVL90:
 1200 0000 10B5     		push	{r4, lr}
 1201              		.cfi_def_cfa_offset 8
 1202              		.cfi_offset 4, -8
 1203              		.cfi_offset 14, -4
 500:hardware.c    **** 
 1204              		.loc 1 500 0
 1205 0002 0446     		mov	r4, r0
 507:hardware.c    ****     nvicDisableInterrupts();
 1206              		.loc 1 507 0
 1207 0004 FFF7FEFF 		bl	usbDsbISR
 1208              	.LVL91:
 508:hardware.c    **** 	
 1209              		.loc 1 508 0
 1210 0008 FFF7FEFF 		bl	nvicDisableInterrupts
 1211              	.LVL92:
 511:hardware.c    **** #endif
 1212              		.loc 1 511 0
 1213 000c FFF7FEFF 		bl	usbDsbBus
 1214              	.LVL93:
 515:hardware.c    ****     //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW
 1215              		.loc 1 515 0
 1216 0010 FFF7FEFF 		bl	systemReset
 1217              	.LVL94:
 517:hardware.c    **** }
 1218              		.loc 1 517 0
 1219 0014 2046     		mov	r0, r4
 518:hardware.c    **** 
 1220              		.loc 1 518 0
 1221 0016 BDE81040 		pop	{r4, lr}
 1222              		.cfi_restore 14
 1223              		.cfi_restore 4
 1224              		.cfi_def_cfa_offset 0
 1225              	.LVL95:
 517:hardware.c    **** }
 1226              		.loc 1 517 0
 1227 001a FFF7FEBF 		b	setMspAndJump
 1228              	.LVL96:
 1229              		.cfi_endproc
 1230              	.LFE21:
 1232              		.section	.text.systemHardReset,"ax",%progbits
 1233              		.align	1
 1234              		.global	systemHardReset
 1235              		.syntax unified
 1236              		.thumb
 1237              		.thumb_func
 1238              		.fpu softvfp
 1240              	systemHardReset:
 1241              	.LFB26:
 605:hardware.c    **** 
 606:hardware.c    **** void systemHardReset(void) {
 1242              		.loc 1 606 0
 1243              		.cfi_startproc
 1244              		@ args = 0, pretend = 0, frame = 0
 1245              		@ frame_needed = 0, uses_anonymous_args = 0
 1246              		@ link register save eliminated.
 1247              	.LVL97:
 607:hardware.c    ****     SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
 608:hardware.c    **** 
 609:hardware.c    ****     /* Reset  */
 610:hardware.c    ****     rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
 1248              		.loc 1 610 0
 1249 0000 024B     		ldr	r3, .L99
 1250 0002 034A     		ldr	r2, .L99+4
 1251 0004 DA60     		str	r2, [r3, #12]
 1252              	.L98:
 611:hardware.c    **** 
 612:hardware.c    ****     /*  should never get here */
 613:hardware.c    ****     while (1) {
 614:hardware.c    ****         asm volatile("nop");
 1253              		.loc 1 614 0 discriminator 1
 1254              		.syntax unified
 1255              	@ 614 "hardware.c" 1
 1256 0006 00BF     		nop
 1257              	@ 0 "" 2
 1258              		.thumb
 1259              		.syntax unified
 1260 0008 FDE7     		b	.L98
 1261              	.L100:
 1262 000a 00BF     		.align	2
 1263              	.L99:
 1264 000c 00ED00E0 		.word	-536810240
 1265 0010 0400FA05 		.word	100270084
 1266              		.cfi_endproc
 1267              	.LFE26:
 1269              		.section	.text.flashErasePage,"ax",%progbits
 1270              		.align	1
 1271              		.global	flashErasePage
 1272              		.syntax unified
 1273              		.thumb
 1274              		.thumb_func
 1275              		.fpu softvfp
 1277              	flashErasePage:
 1278              	.LFB27:
 615:hardware.c    ****     }
 616:hardware.c    **** }
 617:hardware.c    **** 
 618:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 1279              		.loc 1 618 0
 1280              		.cfi_startproc
 1281              		@ args = 0, pretend = 0, frame = 0
 1282              		@ frame_needed = 0, uses_anonymous_args = 0
 1283              	.LVL98:
 619:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1284              		.loc 1 619 0
 1285 0000 0A4B     		ldr	r3, .L106
 618:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1286              		.loc 1 618 0
 1287 0002 10B5     		push	{r4, lr}
 1288              		.cfi_def_cfa_offset 8
 1289              		.cfi_offset 4, -8
 1290              		.cfi_offset 14, -4
 1291              		.loc 1 619 0
 1292 0004 1A68     		ldr	r2, [r3]
 1293              	.LVL99:
 620:hardware.c    ****     rwmVal = FLASH_CR_PER;
 621:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1294              		.loc 1 621 0
 1295 0006 0222     		movs	r2, #2
 1296 0008 1A60     		str	r2, [r3]
 622:hardware.c    **** 
 623:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1297              		.loc 1 623 0
 1298 000a 094A     		ldr	r2, .L106+4
 1299 000c 1146     		mov	r1, r2
 1300              	.L102:
 1301              		.loc 1 623 0 is_stmt 0 discriminator 1
 1302 000e 1468     		ldr	r4, [r2]
 1303 0010 E407     		lsls	r4, r4, #31
 1304 0012 FCD4     		bmi	.L102
 624:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 1305              		.loc 1 624 0 is_stmt 1
 1306 0014 074A     		ldr	r2, .L106+8
 1307 0016 1060     		str	r0, [r2]
 625:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 1308              		.loc 1 625 0
 1309 0018 4222     		movs	r2, #66
 1310 001a 1A60     		str	r2, [r3]
 1311              	.L103:
 626:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1312              		.loc 1 626 0 discriminator 1
 1313 001c 0A68     		ldr	r2, [r1]
 1314 001e 12F00102 		ands	r2, r2, #1
 1315 0022 FBD1     		bne	.L103
 1316              	.LVL100:
 627:hardware.c    **** 
 628:hardware.c    ****     /* todo: verify the page was erased */
 629:hardware.c    **** 
 630:hardware.c    ****     rwmVal = 0x00;
 631:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1317              		.loc 1 631 0
 1318 0024 1A60     		str	r2, [r3]
 632:hardware.c    **** 
 633:hardware.c    ****     return TRUE;
 634:hardware.c    **** }
 1319              		.loc 1 634 0
 1320 0026 0120     		movs	r0, #1
 1321              	.LVL101:
 1322 0028 10BD     		pop	{r4, pc}
 1323              	.L107:
 1324 002a 00BF     		.align	2
 1325              	.L106:
 1326 002c 10200240 		.word	1073881104
 1327 0030 0C200240 		.word	1073881100
 1328 0034 14200240 		.word	1073881108
 1329              		.cfi_endproc
 1330              	.LFE27:
 1332              		.section	.text.flashErasePages,"ax",%progbits
 1333              		.align	1
 1334              		.global	flashErasePages
 1335              		.syntax unified
 1336              		.thumb
 1337              		.thumb_func
 1338              		.fpu softvfp
 1340              	flashErasePages:
 1341              	.LFB28:
 635:hardware.c    **** bool flashErasePages(u32 pageAddr, u16 n) {
 1342              		.loc 1 635 0
 1343              		.cfi_startproc
 1344              		@ args = 0, pretend = 0, frame = 0
 1345              		@ frame_needed = 0, uses_anonymous_args = 0
 1346              	.LVL102:
 1347 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1348              		.cfi_def_cfa_offset 24
 1349              		.cfi_offset 3, -24
 1350              		.cfi_offset 4, -20
 1351              		.cfi_offset 5, -16
 1352              		.cfi_offset 6, -12
 1353              		.cfi_offset 7, -8
 1354              		.cfi_offset 14, -4
 1355              		.loc 1 635 0
 1356 0002 0646     		mov	r6, r0
 636:hardware.c    ****     while (n-- > 0) {
 1357              		.loc 1 636 0
 1358 0004 4FF6FF75 		movw	r5, #65535
 1359 0008 0139     		subs	r1, r1, #1
 1360              	.LVL103:
 637:hardware.c    ****         if (!flashErasePage(pageAddr + wTransferSize * n)) {
 1361              		.loc 1 637 0
 1362 000a 084F     		ldr	r7, .L115
 1363 000c 8CB2     		uxth	r4, r1
 1364              	.LVL104:
 1365              	.L109:
 636:hardware.c    ****     while (n-- > 0) {
 1366              		.loc 1 636 0
 1367 000e AC42     		cmp	r4, r5
 1368 0010 01D1     		bne	.L111
 638:hardware.c    ****             return FALSE;
 639:hardware.c    ****         }
 640:hardware.c    ****     }
 641:hardware.c    **** 
 642:hardware.c    ****     return TRUE;
 1369              		.loc 1 642 0
 1370 0012 0120     		movs	r0, #1
 1371 0014 08E0     		b	.L110
 1372              	.L111:
 637:hardware.c    ****         if (!flashErasePage(pageAddr + wTransferSize * n)) {
 1373              		.loc 1 637 0
 1374 0016 3868     		ldr	r0, [r7]
 1375 0018 00FB0460 		mla	r0, r0, r4, r6
 1376 001c FFF7FEFF 		bl	flashErasePage
 1377              	.LVL105:
 1378 0020 013C     		subs	r4, r4, #1
 1379              	.LVL106:
 1380 0022 A4B2     		uxth	r4, r4
 1381 0024 0028     		cmp	r0, #0
 1382 0026 F2D1     		bne	.L109
 1383              	.L110:
 643:hardware.c    **** }
 1384              		.loc 1 643 0
 1385 0028 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1386              	.LVL107:
 1387              	.L116:
 1388 002a 00BF     		.align	2
 1389              	.L115:
 1390 002c 00000000 		.word	wTransferSize
 1391              		.cfi_endproc
 1392              	.LFE28:
 1394              		.section	.text.flashWriteWord,"ax",%progbits
 1395              		.align	1
 1396              		.global	flashWriteWord
 1397              		.syntax unified
 1398              		.thumb
 1399              		.thumb_func
 1400              		.fpu softvfp
 1402              	flashWriteWord:
 1403              	.LFB29:
 644:hardware.c    **** 
 645:hardware.c    **** bool flashWriteWord(u32 addr, u32 word) {
 1404              		.loc 1 645 0
 1405              		.cfi_startproc
 1406              		@ args = 0, pretend = 0, frame = 8
 1407              		@ frame_needed = 0, uses_anonymous_args = 0
 1408              	.LVL108:
 1409 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 1410              		.cfi_def_cfa_offset 24
 1411              		.cfi_offset 4, -16
 1412              		.cfi_offset 5, -12
 1413              		.cfi_offset 6, -8
 1414              		.cfi_offset 14, -4
 646:hardware.c    ****     vu16 *flashAddr = (vu16 *)addr;
 647:hardware.c    ****     vu32 lhWord = (vu32)word & 0x0000FFFF;
 648:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 649:hardware.c    **** 
 650:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 651:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 1415              		.loc 1 651 0
 1416 0002 0124     		movs	r4, #1
 647:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 1417              		.loc 1 647 0
 1418 0004 8BB2     		uxth	r3, r1
 1419 0006 0093     		str	r3, [sp]
 648:hardware.c    **** 
 1420              		.loc 1 648 0
 1421 0008 0B0C     		lsrs	r3, r1, #16
 1422 000a 0193     		str	r3, [sp, #4]
 650:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 1423              		.loc 1 650 0
 1424 000c 0E4B     		ldr	r3, .L124
 1425 000e 1A68     		ldr	r2, [r3]
 1426              	.LVL109:
 1427              		.loc 1 651 0
 1428 0010 1C60     		str	r4, [r3]
 652:hardware.c    **** 
 653:hardware.c    ****     /* apparently we need not write to FLASH_AR and can
 654:hardware.c    ****        simply do a native write of a half word */
 655:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1429              		.loc 1 655 0
 1430 0012 0E4C     		ldr	r4, .L124+4
 1431 0014 2546     		mov	r5, r4
 1432              	.L118:
 1433              		.loc 1 655 0 is_stmt 0 discriminator 1
 1434 0016 2668     		ldr	r6, [r4]
 1435 0018 F607     		lsls	r6, r6, #31
 1436 001a FCD4     		bmi	.L118
 656:hardware.c    ****     *(flashAddr + 0x01) = (vu16)hhWord;
 1437              		.loc 1 656 0 is_stmt 1
 1438 001c 019C     		ldr	r4, [sp, #4]
 1439 001e A4B2     		uxth	r4, r4
 1440 0020 4480     		strh	r4, [r0, #2]	@ movhi
 1441              	.L119:
 657:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1442              		.loc 1 657 0 discriminator 1
 1443 0022 2C68     		ldr	r4, [r5]
 1444 0024 E607     		lsls	r6, r4, #31
 1445 0026 FCD4     		bmi	.L119
 658:hardware.c    ****     *(flashAddr) = (vu16)lhWord;
 1446              		.loc 1 658 0
 1447 0028 009C     		ldr	r4, [sp]
 1448 002a A4B2     		uxth	r4, r4
 1449 002c 0480     		strh	r4, [r0]	@ movhi
 1450              	.L120:
 659:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1451              		.loc 1 659 0 discriminator 1
 1452 002e 2C68     		ldr	r4, [r5]
 1453 0030 E407     		lsls	r4, r4, #31
 1454 0032 FCD4     		bmi	.L120
 660:hardware.c    **** 
 661:hardware.c    ****     rwmVal &= 0xFFFFFFFE;
 1455              		.loc 1 661 0
 1456 0034 22F00102 		bic	r2, r2, #1
 1457              	.LVL110:
 662:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1458              		.loc 1 662 0
 1459 0038 1A60     		str	r2, [r3]
 663:hardware.c    **** 
 664:hardware.c    ****     /* verify the write */
 665:hardware.c    ****     if (*(vu32 *)addr != word) {
 1460              		.loc 1 665 0
 1461 003a 0068     		ldr	r0, [r0]
 1462              	.LVL111:
 666:hardware.c    ****         return FALSE;
 667:hardware.c    ****     }
 668:hardware.c    **** 
 669:hardware.c    ****     return TRUE;
 670:hardware.c    **** }
 1463              		.loc 1 670 0
 1464 003c 431A     		subs	r3, r0, r1
 1465 003e 5842     		rsbs	r0, r3, #0
 1466 0040 5841     		adcs	r0, r0, r3
 1467 0042 02B0     		add	sp, sp, #8
 1468              		.cfi_def_cfa_offset 16
 1469              		@ sp needed
 1470 0044 70BD     		pop	{r4, r5, r6, pc}
 1471              	.L125:
 1472 0046 00BF     		.align	2
 1473              	.L124:
 1474 0048 10200240 		.word	1073881104
 1475 004c 0C200240 		.word	1073881100
 1476              		.cfi_endproc
 1477              	.LFE29:
 1479              		.section	.text.flashLock,"ax",%progbits
 1480              		.align	1
 1481              		.global	flashLock
 1482              		.syntax unified
 1483              		.thumb
 1484              		.thumb_func
 1485              		.fpu softvfp
 1487              	flashLock:
 1488              	.LFB30:
 671:hardware.c    **** 
 672:hardware.c    **** void flashLock() {
 1489              		.loc 1 672 0
 1490              		.cfi_startproc
 1491              		@ args = 0, pretend = 0, frame = 0
 1492              		@ frame_needed = 0, uses_anonymous_args = 0
 1493              		@ link register save eliminated.
 673:hardware.c    ****     /* take down the HSI oscillator? it may be in use elsewhere */
 674:hardware.c    **** 
 675:hardware.c    ****     /* ensure all FPEC functions disabled and lock the FPEC */
 676:hardware.c    ****     SET_REG(FLASH_CR, 0x00000080);
 1494              		.loc 1 676 0
 1495 0000 8022     		movs	r2, #128
 1496 0002 014B     		ldr	r3, .L127
 1497 0004 1A60     		str	r2, [r3]
 677:hardware.c    **** }
 1498              		.loc 1 677 0
 1499 0006 7047     		bx	lr
 1500              	.L128:
 1501              		.align	2
 1502              	.L127:
 1503 0008 10200240 		.word	1073881104
 1504              		.cfi_endproc
 1505              	.LFE30:
 1507              		.section	.text.flashUnlock,"ax",%progbits
 1508              		.align	1
 1509              		.global	flashUnlock
 1510              		.syntax unified
 1511              		.thumb
 1512              		.thumb_func
 1513              		.fpu softvfp
 1515              	flashUnlock:
 1516              	.LFB31:
 678:hardware.c    **** 
 679:hardware.c    **** void flashUnlock() {
 1517              		.loc 1 679 0
 1518              		.cfi_startproc
 1519              		@ args = 0, pretend = 0, frame = 0
 1520              		@ frame_needed = 0, uses_anonymous_args = 0
 1521              		@ link register save eliminated.
 680:hardware.c    ****     /* unlock the flash */
 681:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY1);
 1522              		.loc 1 681 0
 1523 0000 034B     		ldr	r3, .L130
 1524 0002 044A     		ldr	r2, .L130+4
 1525 0004 1A60     		str	r2, [r3]
 682:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY2);
 1526              		.loc 1 682 0
 1527 0006 02F18832 		add	r2, r2, #-2004318072
 1528 000a 1A60     		str	r2, [r3]
 683:hardware.c    **** }
 1529              		.loc 1 683 0
 1530 000c 7047     		bx	lr
 1531              	.L131:
 1532 000e 00BF     		.align	2
 1533              	.L130:
 1534 0010 04200240 		.word	1073881092
 1535 0014 23016745 		.word	1164378403
 1536              		.cfi_endproc
 1537              	.LFE31:
 1539              		.section	.text.crMask,"ax",%progbits
 1540              		.align	1
 1541              		.global	crMask
 1542              		.syntax unified
 1543              		.thumb
 1544              		.thumb_func
 1545              		.fpu softvfp
 1547              	crMask:
 1548              	.LFB32:
 684:hardware.c    **** 
 685:hardware.c    **** 
 686:hardware.c    **** // Used to create the control register masking pattern, when setting control register mode.
 687:hardware.c    **** unsigned int crMask(int pin)
 688:hardware.c    **** {
 1549              		.loc 1 688 0
 1550              		.cfi_startproc
 1551              		@ args = 0, pretend = 0, frame = 0
 1552              		@ frame_needed = 0, uses_anonymous_args = 0
 1553              		@ link register save eliminated.
 1554              	.LVL112:
 689:hardware.c    **** 	unsigned int mask;
 690:hardware.c    **** 	if (pin>=8)
 691:hardware.c    **** 	{
 692:hardware.c    **** 		pin-=8;
 693:hardware.c    **** 	}
 694:hardware.c    **** 	mask = 0x0F << (pin<<2);
 1555              		.loc 1 694 0
 1556 0000 0F23     		movs	r3, #15
 690:hardware.c    **** 	{
 1557              		.loc 1 690 0
 1558 0002 0728     		cmp	r0, #7
 692:hardware.c    **** 	}
 1559              		.loc 1 692 0
 1560 0004 C8BF     		it	gt
 1561 0006 0838     		subgt	r0, r0, #8
 1562              	.LVL113:
 1563              		.loc 1 694 0
 1564 0008 8000     		lsls	r0, r0, #2
 1565              	.LVL114:
 1566 000a 03FA00F0 		lsl	r0, r3, r0
 1567              	.LVL115:
 695:hardware.c    **** 	return ~mask;
 696:hardware.c    **** }	
 1568              		.loc 1 696 0
 1569 000e C043     		mvns	r0, r0
 1570              	.LVL116:
 1571 0010 7047     		bx	lr
 1572              		.cfi_endproc
 1573              	.LFE32:
 1575              		.section	.text.getFlashEnd,"ax",%progbits
 1576              		.align	1
 1577              		.global	getFlashEnd
 1578              		.syntax unified
 1579              		.thumb
 1580              		.thumb_func
 1581              		.fpu softvfp
 1583              	getFlashEnd:
 1584              	.LFB33:
 697:hardware.c    **** 
 698:hardware.c    **** #define FLASH_SIZE_REG 0x1FFFF7E0
 699:hardware.c    **** int getFlashEnd(void)
 700:hardware.c    **** {
 1585              		.loc 1 700 0
 1586              		.cfi_startproc
 1587              		@ args = 0, pretend = 0, frame = 0
 1588              		@ frame_needed = 0, uses_anonymous_args = 0
 1589              		@ link register save eliminated.
 1590              	.LVL117:
 701:hardware.c    **** 	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
 702:hardware.c    **** 	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
 1591              		.loc 1 702 0
 1592 0000 024B     		ldr	r3, .L135
 1593 0002 1888     		ldrh	r0, [r3]
 1594 0004 00F50030 		add	r0, r0, #131072
 703:hardware.c    **** }
 1595              		.loc 1 703 0
 1596 0008 8002     		lsls	r0, r0, #10
 1597 000a 7047     		bx	lr
 1598              	.L136:
 1599              		.align	2
 1600              	.L135:
 1601 000c E0F7FF1F 		.word	536868832
 1602              		.cfi_endproc
 1603              	.LFE33:
 1605              		.section	.text.getFlashPageSize,"ax",%progbits
 1606              		.align	1
 1607              		.global	getFlashPageSize
 1608              		.syntax unified
 1609              		.thumb
 1610              		.thumb_func
 1611              		.fpu softvfp
 1613              	getFlashPageSize:
 1614              	.LFB34:
 704:hardware.c    **** 
 705:hardware.c    **** int getFlashPageSize(void)
 706:hardware.c    **** {
 1615              		.loc 1 706 0
 1616              		.cfi_startproc
 1617              		@ args = 0, pretend = 0, frame = 0
 1618              		@ frame_needed = 0, uses_anonymous_args = 0
 1619              		@ link register save eliminated.
 1620              	.LVL118:
 707:hardware.c    **** 	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
 708:hardware.c    **** 	if ((*flashSize & 0xffff) > 128)
 1621              		.loc 1 708 0
 1622 0000 044B     		ldr	r3, .L140
 1623 0002 1B88     		ldrh	r3, [r3]
 1624 0004 802B     		cmp	r3, #128
 709:hardware.c    **** 	{
 710:hardware.c    **** 		return 0x800;
 711:hardware.c    **** 	}
 712:hardware.c    **** 	else
 713:hardware.c    **** 	{
 714:hardware.c    **** 		return 0x400;
 715:hardware.c    **** 	}
 716:hardware.c    **** }
 1625              		.loc 1 716 0
 1626 0006 8CBF     		ite	hi
 1627 0008 4FF40060 		movhi	r0, #2048
 1628 000c 4FF48060 		movls	r0, #1024
 1629 0010 7047     		bx	lr
 1630              	.L141:
 1631 0012 00BF     		.align	2
 1632              	.L140:
 1633 0014 E0F7FF1F 		.word	536868832
 1634              		.cfi_endproc
 1635              	.LFE34:
 1637              		.comm	rootCA,32,1
 1638              		.comm	wTransferSize,4,4
 1639              		.section	.rodata.hexdump.str1.1,"aMS",%progbits,1
 1640              	.LC0:
 1641 0000 207C2573 		.ascii	" |%s|\012\000"
 1641      7C0A00
 1642              	.LC1:
 1643 0007 2000     		.ascii	" \000"
 1644              	.LC2:
 1645 0009 25303258 		.ascii	"%02X \000"
 1645      2000
 1646              	.LC3:
 1647 000f 20202000 		.ascii	"   \000"
 1648              		.section	.rodata.print_hash.str1.1,"aMS",%progbits,1
 1649              	.LC4:
 1650 0000 25303278 		.ascii	"%02x\000"
 1650      00
 1651              	.LC5:
 1652 0005 0A00     		.ascii	"\012\000"
 1653              		.text
 1654              	.Letext0:
 1655              		.file 2 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_d
 1656              		.file 3 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/incl
 1657              		.file 4 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/incl
 1658              		.file 5 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/stdio.h"
 1659              		.file 6 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/lock.h
 1660              		.file 7 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types
 1661              		.file 8 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/reent.
 1662              		.file 9 "<built-in>"
 1663              		.file 10 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_stdi
 1664              		.file 11 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/unist
 1665              		.file 12 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/errno
 1666              		.file 13 "./stm32_lib/stm32f10x_type.h"
 1667              		.file 14 "hardware.h"
 1668              		.file 15 "./usb_lib/usb_regs.h"
 1669              		.file 16 "./usb_lib/usb_core.h"
 1670              		.file 17 "./usb_lib/usb_init.h"
 1671              		.file 18 "usb_descriptor.h"
 1672              		.file 19 "usb.h"
 1673              		.file 20 "./25519/f25519.h"
 1674              		.file 21 "./25519/c25519.h"
 1675              		.file 22 "image.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 hardware.c
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:16     .text.gpio_write_bit:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:23     .text.gpio_write_bit:0000000000000000 gpio_write_bit
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:51     .text.readPin:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:58     .text.readPin:0000000000000000 readPin
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:82     .text.strobePin:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:89     .text.strobePin:0000000000000000 strobePin
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:188    .text.UU_PutChar:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:195    .text.UU_PutChar:0000000000000000 UU_PutChar
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:218    .text.UU_PutString:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:225    .text.UU_PutString:0000000000000000 UU_PutString
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:258    .text.vprint:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:265    .text.vprint:0000000000000000 vprint
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:301    .text.vprint:0000000000000020 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:306    .text.uart_printf:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:313    .text.uart_printf:0000000000000000 uart_printf
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:355    .text.hexdump:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:362    .text.hexdump:0000000000000000 hexdump
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:498    .text.hexdump:00000000000000a8 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:506    .text.print_hash:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:513    .text.print_hash:0000000000000000 print_hash
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:558    .text.print_hash:0000000000000024 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:564    .text.uartInit:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:571    .text.uartInit:0000000000000000 uartInit
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:660    .text.uartInit:0000000000000080 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:665    .text.systemReset:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:672    .text.systemReset:0000000000000000 systemReset
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:715    .text.systemReset:0000000000000038 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:723    .text.setupCLK:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:730    .text.setupCLK:0000000000000000 setupCLK
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:789    .text.setupCLK:0000000000000058 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:795    .text.setupLEDAndButton:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:802    .text.setupLEDAndButton:0000000000000000 setupLEDAndButton
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:820    .text.setupLEDAndButton:0000000000000010 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:825    .text.setupFLASH:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:832    .text.setupFLASH:0000000000000000 setupFLASH
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:865    .text.setupFLASH:0000000000000018 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:870    .text.uid_read:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:877    .text.uid_read:0000000000000000 uid_read
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:891    .text.setMspAndJump:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:898    .text.setMspAndJump:0000000000000000 setMspAndJump
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:928    .text.setMspAndJump:0000000000000010 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:933    .text.bkp10Write:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:940    .text.bkp10Write:0000000000000000 bkp10Write
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:970    .text.bkp10Write:0000000000000024 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:977    .text.checkAndClearBootloaderFlag:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:984    .text.checkAndClearBootloaderFlag:0000000000000000 checkAndClearBootloaderFlag
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1040   .text.checkAndClearBootloaderFlag:0000000000000040 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1046   .text.nvicInit:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1053   .text.nvicInit:0000000000000000 nvicInit
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1142   .text.nvicInit:0000000000000064 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1148   .text.nvicDisableInterrupts:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1155   .text.nvicDisableInterrupts:0000000000000000 nvicDisableInterrupts
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1181   .text.nvicDisableInterrupts:0000000000000020 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1186   .text.jumpToUser:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1193   .text.jumpToUser:0000000000000000 jumpToUser
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1233   .text.systemHardReset:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1240   .text.systemHardReset:0000000000000000 systemHardReset
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1264   .text.systemHardReset:000000000000000c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1270   .text.flashErasePage:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1277   .text.flashErasePage:0000000000000000 flashErasePage
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1326   .text.flashErasePage:000000000000002c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1333   .text.flashErasePages:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1340   .text.flashErasePages:0000000000000000 flashErasePages
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1390   .text.flashErasePages:000000000000002c $d
                            *COM*:0000000000000004 wTransferSize
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1395   .text.flashWriteWord:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1402   .text.flashWriteWord:0000000000000000 flashWriteWord
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1474   .text.flashWriteWord:0000000000000048 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1480   .text.flashLock:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1487   .text.flashLock:0000000000000000 flashLock
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1503   .text.flashLock:0000000000000008 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1508   .text.flashUnlock:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1515   .text.flashUnlock:0000000000000000 flashUnlock
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1534   .text.flashUnlock:0000000000000010 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1540   .text.crMask:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1547   .text.crMask:0000000000000000 crMask
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1576   .text.getFlashEnd:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1583   .text.getFlashEnd:0000000000000000 getFlashEnd
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1601   .text.getFlashEnd:000000000000000c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1606   .text.getFlashPageSize:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1613   .text.getFlashPageSize:0000000000000000 getFlashPageSize
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccv0lhsu.s:1633   .text.getFlashPageSize:0000000000000014 $d
                            *COM*:0000000000000020 rootCA

UNDEFINED SYMBOLS
vsprintf
memset
RCC_APB2PeriphClockCmd
GPIO_Init
USART_ClockStructInit
USART_ClockInit
USART_Init
USART_Cmd
usbDsbISR
usbDsbBus
