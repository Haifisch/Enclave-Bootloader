   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"hardware.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.gpio_write_bit,"ax",%progbits
  19              		.align	1
  20              		.global	gpio_write_bit
  21              		.thumb
  22              		.thumb_func
  24              	gpio_write_bit:
  25              	.LFB0:
  26              		.file 1 "hardware.c"
   1:hardware.c    **** /* *****************************************************************************
   2:hardware.c    ****  * The MIT License
   3:hardware.c    ****  *
   4:hardware.c    ****  * Copyright (c) 2010 LeafLabs LLC.
   5:hardware.c    ****  *
   6:hardware.c    ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:hardware.c    ****  * of this software and associated documentation files (the "Software"), to deal
   8:hardware.c    ****  * in the Software without restriction, including without limitation the rights
   9:hardware.c    ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:hardware.c    ****  * copies of the Software, and to permit persons to whom the Software is
  11:hardware.c    ****  * furnished to do so, subject to the following conditions:
  12:hardware.c    ****  *
  13:hardware.c    ****  * The above copyright notice and this permission notice shall be included in
  14:hardware.c    ****  * all copies or substantial portions of the Software.
  15:hardware.c    ****  *
  16:hardware.c    ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:hardware.c    ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:hardware.c    ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:hardware.c    ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:hardware.c    ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:hardware.c    ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:hardware.c    ****  * THE SOFTWARE.
  23:hardware.c    ****  * ****************************************************************************/
  24:hardware.c    **** 
  25:hardware.c    **** /**
  26:hardware.c    ****  *  @file hardware.c
  27:hardware.c    ****  *
  28:hardware.c    ****  *  @brief init routines to setup clocks, interrupts, also destructor functions.
  29:hardware.c    ****  *  does not include USB stuff. EEPROM read/write functions.
  30:hardware.c    ****  *
  31:hardware.c    ****  */
  32:hardware.c    **** #include <stdio.h>
  33:hardware.c    **** #include <stdint.h>
  34:hardware.c    **** #include <string.h>
  35:hardware.c    **** #include <limits.h>
  36:hardware.c    **** #include <unistd.h>
  37:hardware.c    **** #include <errno.h>
  38:hardware.c    **** #include <stdarg.h>
  39:hardware.c    **** 
  40:hardware.c    **** 
  41:hardware.c    **** #include "common.h"
  42:hardware.c    **** #include "hardware.h"
  43:hardware.c    **** #include "sha256.h"
  44:hardware.c    **** #include "edsign.h"
  45:hardware.c    **** #include "image.h"
  46:hardware.c    **** 
  47:hardware.c    **** /*
  48:hardware.c    **** void setPin(u32 bank, u8 pin) {
  49:hardware.c    ****     u32 pinMask = 0x1 << (pin);
  50:hardware.c    ****     SET_REG(GPIO_BSRR(bank), pinMask);
  51:hardware.c    **** }
  52:hardware.c    **** 
  53:hardware.c    **** void resetPin(u32 bank, u8 pin) {
  54:hardware.c    ****     u32 pinMask = 0x1 << (16 + pin);
  55:hardware.c    ****     SET_REG(GPIO_BSRR(bank), pinMask);
  56:hardware.c    **** }
  57:hardware.c    **** */
  58:hardware.c    **** void gpio_write_bit(u32 bank, u8 pin, u8 val) {
  27              		.loc 1 58 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32              	.LVL0:
  59:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
  60:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
  33              		.loc 1 60 0
  34 0000 0123     		movs	r3, #1
  35 0002 03FA01F1 		lsl	r1, r3, r1
  36              	.LVL1:
  59:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
  37              		.loc 1 59 0
  38 0006 D2F10102 		rsbs	r2, r2, #1
  39              	.LVL2:
  40 000a 38BF     		it	cc
  41 000c 0022     		movcc	r2, #0
  42              		.loc 1 60 0
  43 000e 1301     		lsls	r3, r2, #4
  44 0010 9940     		lsls	r1, r1, r3
  45 0012 0161     		str	r1, [r0, #16]
  46 0014 7047     		bx	lr
  47              		.cfi_endproc
  48              	.LFE0:
  50              		.section	.text.readPin,"ax",%progbits
  51              		.align	1
  52              		.global	readPin
  53              		.thumb
  54              		.thumb_func
  56              	readPin:
  57              	.LFB1:
  61:hardware.c    **** }
  62:hardware.c    **** 
  63:hardware.c    **** bool readPin(u32 bank, u8 pin) {
  58              		.loc 1 63 0
  59              		.cfi_startproc
  60              		@ args = 0, pretend = 0, frame = 0
  61              		@ frame_needed = 0, uses_anonymous_args = 0
  62              		@ link register save eliminated.
  63              	.LVL3:
  64:hardware.c    ****     // todo, implement read
  65:hardware.c    ****     if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
  64              		.loc 1 65 0
  65 0000 0122     		movs	r2, #1
  66 0002 02FA01F1 		lsl	r1, r2, r1
  67              	.LVL4:
  68 0006 8368     		ldr	r3, [r0, #8]
  69 0008 0B42     		tst	r3, r1
  66:hardware.c    ****         return TRUE;
  67:hardware.c    ****     } else {
  68:hardware.c    ****         return FALSE;
  69:hardware.c    ****     }
  70:hardware.c    **** }
  70              		.loc 1 70 0
  71 000a 0CBF     		ite	eq
  72 000c 0020     		moveq	r0, #0
  73 000e 0120     		movne	r0, #1
  74              	.LVL5:
  75 0010 7047     		bx	lr
  76              		.cfi_endproc
  77              	.LFE1:
  79              		.section	.text.strobePin,"ax",%progbits
  80              		.align	1
  81              		.global	strobePin
  82              		.thumb
  83              		.thumb_func
  85              	strobePin:
  86              	.LFB2:
  71:hardware.c    **** 
  72:hardware.c    **** void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
  73:hardware.c    **** {
  87              		.loc 1 73 0
  88              		.cfi_startproc
  89              		@ args = 4, pretend = 0, frame = 0
  90              		@ frame_needed = 0, uses_anonymous_args = 0
  91              	.LVL6:
  92 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
  93              		.cfi_def_cfa_offset 32
  94              		.cfi_offset 4, -32
  95              		.cfi_offset 5, -28
  96              		.cfi_offset 6, -24
  97              		.cfi_offset 7, -20
  98              		.cfi_offset 8, -16
  99              		.cfi_offset 9, -12
 100              		.cfi_offset 10, -8
 101              		.cfi_offset 14, -4
 102              		.loc 1 73 0
 103 0004 9DF820A0 		ldrb	r10, [sp, #32]	@ zero_extendqisi2
 104 0008 1446     		mov	r4, r2
  74:hardware.c    ****     gpio_write_bit( bank,pin,1-onState);
 105              		.loc 1 74 0
 106 000a CAF10107 		rsb	r7, r10, #1
 107 000e FFB2     		uxtb	r7, r7
 108 0010 3A46     		mov	r2, r7
 109              	.LVL7:
  73:hardware.c    **** {
 110              		.loc 1 73 0
 111 0012 8046     		mov	r8, r0
 112 0014 8946     		mov	r9, r1
 113 0016 1E46     		mov	r6, r3
 114              		.loc 1 74 0
 115 0018 FFF7FEFF 		bl	gpio_write_bit
 116              	.LVL8:
 117              	.L4:
  75:hardware.c    **** 
  76:hardware.c    ****     u32 c;
  77:hardware.c    ****     while (count-- > 0) 
 118              		.loc 1 77 0 discriminator 1
 119 001c B4B1     		cbz	r4, .L3
 120              		.loc 1 77 0 is_stmt 0
 121 001e 3546     		mov	r5, r6
 122              	.L9:
 123              	.LVL9:
  78:hardware.c    **** 	{
  79:hardware.c    ****         for (c = rate; c > 0; c--)
 124              		.loc 1 79 0 is_stmt 1 discriminator 1
 125 0020 15B1     		cbz	r5, .L11
  80:hardware.c    **** 		{
  81:hardware.c    ****             asm volatile("nop");
 126              		.loc 1 81 0 discriminator 2
 127              	@ 81 "hardware.c" 1
 128 0022 00BF     		nop
 129              	@ 0 "" 2
  79:hardware.c    ****         for (c = rate; c > 0; c--)
 130              		.loc 1 79 0 discriminator 2
 131              		.thumb
 132 0024 013D     		subs	r5, r5, #1
 133              	.LVL10:
 134 0026 FBE7     		b	.L9
 135              	.L11:
  82:hardware.c    ****         }
  83:hardware.c    **** 		
  84:hardware.c    ****         gpio_write_bit( bank,pin,onState);
 136              		.loc 1 84 0
 137 0028 4046     		mov	r0, r8
 138 002a 4946     		mov	r1, r9
 139 002c 5246     		mov	r2, r10
 140 002e FFF7FEFF 		bl	gpio_write_bit
 141              	.LVL11:
  85:hardware.c    **** 		
  86:hardware.c    ****         for (c = rate; c > 0; c--)
 142              		.loc 1 86 0
 143 0032 3546     		mov	r5, r6
 144              	.LVL12:
 145              	.L6:
 146              		.loc 1 86 0 is_stmt 0 discriminator 1
 147 0034 15B1     		cbz	r5, .L12
  87:hardware.c    **** 		{
  88:hardware.c    ****             asm volatile("nop");
 148              		.loc 1 88 0 is_stmt 1 discriminator 2
 149              	@ 88 "hardware.c" 1
 150 0036 00BF     		nop
 151              	@ 0 "" 2
  86:hardware.c    ****         for (c = rate; c > 0; c--)
 152              		.loc 1 86 0 discriminator 2
 153              		.thumb
 154 0038 013D     		subs	r5, r5, #1
 155              	.LVL13:
 156 003a FBE7     		b	.L6
 157              	.L12:
  89:hardware.c    ****         }
  90:hardware.c    ****         gpio_write_bit( bank,pin,1-onState);
 158              		.loc 1 90 0
 159 003c 4046     		mov	r0, r8
 160 003e 4946     		mov	r1, r9
 161 0040 3A46     		mov	r2, r7
 162 0042 013C     		subs	r4, r4, #1
 163              	.LVL14:
 164 0044 FFF7FEFF 		bl	gpio_write_bit
 165              	.LVL15:
 166 0048 E4B2     		uxtb	r4, r4
 167              	.LVL16:
 168 004a E7E7     		b	.L4
 169              	.LVL17:
 170              	.L3:
 171 004c BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 172              		.cfi_endproc
 173              	.LFE2:
 175              		.section	.text.UU_PutChar,"ax",%progbits
 176              		.align	1
 177              		.global	UU_PutChar
 178              		.thumb
 179              		.thumb_func
 181              	UU_PutChar:
 182              	.LFB3:
  91:hardware.c    ****     }
  92:hardware.c    **** }
  93:hardware.c    **** 
  94:hardware.c    **** 
  95:hardware.c    **** typedef struct
  96:hardware.c    **** {
  97:hardware.c    ****   uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate
  98:hardware.c    ****                                            The baud rate is computed using the following formula:
  99:hardware.c    ****                                             - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->
 100:hardware.c    ****                                             - FractionalDivider = ((IntegerDivider - ((u32) Integer
 101:hardware.c    **** 
 102:hardware.c    ****   uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or receive
 103:hardware.c    ****                                            This parameter can be a value of @ref USART_Word_Length 
 104:hardware.c    **** 
 105:hardware.c    ****   uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
 106:hardware.c    ****                                            This parameter can be a value of @ref USART_Stop_Bits */
 107:hardware.c    **** 
 108:hardware.c    ****   uint16_t USART_Parity;              /*!< Specifies the parity mode.
 109:hardware.c    ****                                            This parameter can be a value of @ref USART_Parity
 110:hardware.c    ****                                            @note When parity is enabled, the computed parity is ins
 111:hardware.c    ****                                                  at the MSB position of the transmitted data (9th b
 112:hardware.c    ****                                                  the word length is set to 9 data bits; 8th bit whe
 113:hardware.c    ****                                                  word length is set to 8 data bits). */
 114:hardware.c    ****  
 115:hardware.c    ****   uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled
 116:hardware.c    ****                                            This parameter can be a value of @ref USART_Mode */
 117:hardware.c    **** 
 118:hardware.c    ****   uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabl
 119:hardware.c    ****                                            or disabled.
 120:hardware.c    ****                                            This parameter can be a value of @ref USART_Hardware_Flo
 121:hardware.c    **** } USART_InitTypeDef;
 122:hardware.c    **** 
 123:hardware.c    **** /** 
 124:hardware.c    ****   * @brief  USART Clock Init Structure definition  
 125:hardware.c    ****   */ 
 126:hardware.c    ****   
 127:hardware.c    **** typedef struct
 128:hardware.c    **** {
 129:hardware.c    **** 
 130:hardware.c    ****   uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.
 131:hardware.c    ****                                This parameter can be a value of @ref USART_Clock */
 132:hardware.c    **** 
 133:hardware.c    ****   uint16_t USART_CPOL;    /*!< Specifies the steady state value of the serial clock.
 134:hardware.c    ****                                This parameter can be a value of @ref USART_Clock_Polarity */
 135:hardware.c    **** 
 136:hardware.c    ****   uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.
 137:hardware.c    ****                                This parameter can be a value of @ref USART_Clock_Phase */
 138:hardware.c    **** 
 139:hardware.c    ****   uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmit
 140:hardware.c    ****                                data bit (MSB) has to be output on the SCLK pin in synchronous mode.
 141:hardware.c    ****                                This parameter can be a value of @ref USART_Last_Bit */
 142:hardware.c    **** } USART_ClockInitTypeDef;
 143:hardware.c    **** 
 144:hardware.c    **** 
 145:hardware.c    **** typedef enum
 146:hardware.c    **** { 
 147:hardware.c    ****   GPIO_Speed_10MHz = 1,
 148:hardware.c    ****   GPIO_Speed_2MHz, 
 149:hardware.c    ****   GPIO_Speed_50MHz
 150:hardware.c    **** }GPIOSpeed_TypeDef;
 151:hardware.c    **** 
 152:hardware.c    **** typedef enum
 153:hardware.c    **** { GPIO_Mode_AIN = 0x0,
 154:hardware.c    ****   GPIO_Mode_IN_FLOATING = 0x04,
 155:hardware.c    ****   GPIO_Mode_IPD = 0x28,
 156:hardware.c    ****   GPIO_Mode_IPU = 0x48,
 157:hardware.c    ****   GPIO_Mode_Out_OD = 0x14,
 158:hardware.c    ****   GPIO_Mode_Out_PP = 0x10,
 159:hardware.c    ****   GPIO_Mode_AF_OD = 0x1C,
 160:hardware.c    ****   GPIO_Mode_AF_PP = 0x18
 161:hardware.c    **** }GPIOMode_TypeDef;
 162:hardware.c    **** 
 163:hardware.c    **** typedef struct
 164:hardware.c    **** {
 165:hardware.c    ****   uint16_t GPIO_Pin;             /*!< Specifies the GPIO pins to be configured.
 166:hardware.c    ****                                       This parameter can be any value of @ref GPIO_pins_define */
 167:hardware.c    **** 
 168:hardware.c    ****   GPIOSpeed_TypeDef GPIO_Speed;  /*!< Specifies the speed for the selected pins.
 169:hardware.c    ****                                       This parameter can be a value of @ref GPIOSpeed_TypeDef */
 170:hardware.c    **** 
 171:hardware.c    ****   GPIOMode_TypeDef GPIO_Mode;    /*!< Specifies the operating mode for the selected pins.
 172:hardware.c    ****                                       This parameter can be a value of @ref GPIOMode_TypeDef */
 173:hardware.c    **** }GPIO_InitTypeDef;
 174:hardware.c    **** 
 175:hardware.c    **** typedef struct
 176:hardware.c    **** {
 177:hardware.c    ****   __IO uint32_t CRL;
 178:hardware.c    ****   __IO uint32_t CRH;
 179:hardware.c    ****   __IO uint32_t IDR;
 180:hardware.c    ****   __IO uint32_t ODR;
 181:hardware.c    ****   __IO uint32_t BSRR;
 182:hardware.c    ****   __IO uint32_t BRR;
 183:hardware.c    ****   __IO uint32_t LCKR;
 184:hardware.c    **** } GPIO_TypeDef;
 185:hardware.c    **** #define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias regi
 186:hardware.c    **** 
 187:hardware.c    **** #define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band r
 188:hardware.c    **** 
 189:hardware.c    **** #define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address */
 190:hardware.c    **** 
 191:hardware.c    **** /*!< Peripheral memory map */
 192:hardware.c    **** #define APB1PERIPH_BASE       PERIPH_BASE
 193:hardware.c    **** #define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
 194:hardware.c    **** 
 195:hardware.c    **** #define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
 196:hardware.c    **** #define USART1              ((USART_TypeDef *) USART1_BASE)
 197:hardware.c    **** 
 198:hardware.c    **** #define USART_WordLength_8b                  ((uint16_t)0x0000)
 199:hardware.c    **** #define USART_WordLength_9b                  ((uint16_t)0x1000)
 200:hardware.c    ****                                     
 201:hardware.c    **** #define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
 202:hardware.c    ****                                       ((LENGTH) == USART_WordLength_9b))
 203:hardware.c    **** /**
 204:hardware.c    ****   * @}
 205:hardware.c    ****   */ 
 206:hardware.c    **** 
 207:hardware.c    **** /** @defgroup USART_Stop_Bits 
 208:hardware.c    ****   * @{
 209:hardware.c    ****   */ 
 210:hardware.c    ****   
 211:hardware.c    **** #define USART_StopBits_1                     ((uint16_t)0x0000)
 212:hardware.c    **** #define USART_StopBits_0_5                   ((uint16_t)0x1000)
 213:hardware.c    **** #define USART_StopBits_2                     ((uint16_t)0x2000)
 214:hardware.c    **** #define USART_StopBits_1_5                   ((uint16_t)0x3000)
 215:hardware.c    **** #define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
 216:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_0_5) || \
 217:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_2) || \
 218:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_1_5))
 219:hardware.c    **** /**
 220:hardware.c    ****   * @}
 221:hardware.c    ****   */ 
 222:hardware.c    **** 
 223:hardware.c    **** /** @defgroup USART_Parity 
 224:hardware.c    ****   * @{
 225:hardware.c    ****   */ 
 226:hardware.c    ****   
 227:hardware.c    **** #define USART_Parity_No                      ((uint16_t)0x0000)
 228:hardware.c    **** #define USART_Parity_Even                    ((uint16_t)0x0400)
 229:hardware.c    **** #define USART_Parity_Odd                     ((uint16_t)0x0600) 
 230:hardware.c    **** #define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
 231:hardware.c    ****                                  ((PARITY) == USART_Parity_Even) || \
 232:hardware.c    ****                                  ((PARITY) == USART_Parity_Odd))
 233:hardware.c    **** /**
 234:hardware.c    ****   * @}
 235:hardware.c    ****   */ 
 236:hardware.c    **** 
 237:hardware.c    **** /** @defgroup USART_Mode 
 238:hardware.c    ****   * @{
 239:hardware.c    ****   */ 
 240:hardware.c    ****   
 241:hardware.c    **** #define USART_Mode_Rx                        ((uint16_t)0x0004)
 242:hardware.c    **** #define USART_Mode_Tx                        ((uint16_t)0x0008)
 243:hardware.c    **** #define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))
 244:hardware.c    **** /**
 245:hardware.c    ****   * @}
 246:hardware.c    ****   */ 
 247:hardware.c    **** 
 248:hardware.c    **** /** @defgroup USART_Hardware_Flow_Control 
 249:hardware.c    ****   * @{
 250:hardware.c    ****   */ 
 251:hardware.c    **** #define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
 252:hardware.c    **** #define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
 253:hardware.c    **** #define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
 254:hardware.c    **** #define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
 255:hardware.c    **** #define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
 256:hardware.c    ****                               (((CONTROL) == USART_HardwareFlowControl_None) || \
 257:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_RTS) || \
 258:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_CTS) || \
 259:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
 260:hardware.c    **** /**
 261:hardware.c    ****   * @}
 262:hardware.c    ****   */ 
 263:hardware.c    **** 
 264:hardware.c    **** /** @defgroup USART_Clock 
 265:hardware.c    ****   * @{
 266:hardware.c    ****   */ 
 267:hardware.c    **** #define USART_Clock_Disable                  ((uint16_t)0x0000)
 268:hardware.c    **** #define USART_Clock_Enable                   ((uint16_t)0x0800)
 269:hardware.c    **** #define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
 270:hardware.c    ****                                ((CLOCK) == USART_Clock_Enable))
 271:hardware.c    **** /**
 272:hardware.c    ****   * @}
 273:hardware.c    ****   */ 
 274:hardware.c    **** 
 275:hardware.c    **** extern void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
 276:hardware.c    **** extern void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
 277:hardware.c    **** #define RCC_APB2Periph_USART1            ((uint32_t)0x00004000)
 278:hardware.c    **** #define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)
 279:hardware.c    **** #define RCC_APB2Periph_AFIO              ((uint32_t)0x00000001)
 280:hardware.c    **** #define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected */
 281:hardware.c    **** #define GPIO_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected */
 282:hardware.c    **** 
 283:hardware.c    **** #define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!< Transmit Data Regis
 284:hardware.c    **** 
 285:hardware.c    **** //DebugLog
 286:hardware.c    **** #ifdef DEBUG
 287:hardware.c    **** void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
 288:hardware.c    **** {
 183              		.loc 1 288 0
 184              		.cfi_startproc
 185              		@ args = 0, pretend = 0, frame = 0
 186              		@ frame_needed = 0, uses_anonymous_args = 0
 187              		@ link register save eliminated.
 188              	.LVL18:
 189              	.L15:
 289:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 190              		.loc 1 289 0 discriminator 1
 191 0000 0388     		ldrh	r3, [r0]
 192 0002 1B06     		lsls	r3, r3, #24
 193 0004 FCD5     		bpl	.L15
 290:hardware.c    ****   USARTx->DR = ch;  
 194              		.loc 1 290 0
 195 0006 8180     		strh	r1, [r0, #4]	@ movhi
 196 0008 7047     		bx	lr
 197              		.cfi_endproc
 198              	.LFE3:
 200              		.section	.text.UU_PutString,"ax",%progbits
 201              		.align	1
 202              		.global	UU_PutString
 203              		.thumb
 204              		.thumb_func
 206              	UU_PutString:
 207              	.LFB4:
 291:hardware.c    **** }
 292:hardware.c    **** 
 293:hardware.c    **** void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
 294:hardware.c    **** {
 208              		.loc 1 294 0
 209              		.cfi_startproc
 210              		@ args = 0, pretend = 0, frame = 0
 211              		@ frame_needed = 0, uses_anonymous_args = 0
 212              	.LVL19:
 213 0000 38B5     		push	{r3, r4, r5, lr}
 214              		.cfi_def_cfa_offset 16
 215              		.cfi_offset 3, -16
 216              		.cfi_offset 4, -12
 217              		.cfi_offset 5, -8
 218              		.cfi_offset 14, -4
 219              		.loc 1 294 0
 220 0002 0546     		mov	r5, r0
 221 0004 4C1E     		subs	r4, r1, #1
 222              	.LVL20:
 223              	.L17:
 295:hardware.c    ****   while(*str != 0)
 224              		.loc 1 295 0 discriminator 1
 225 0006 14F8011F 		ldrb	r1, [r4, #1]!	@ zero_extendqisi2
 226              	.LVL21:
 227 000a 19B1     		cbz	r1, .L19
 296:hardware.c    ****   {
 297:hardware.c    ****     UU_PutChar(USARTx, *str);
 228              		.loc 1 297 0
 229 000c 2846     		mov	r0, r5
 230 000e FFF7FEFF 		bl	UU_PutChar
 231              	.LVL22:
 232 0012 F8E7     		b	.L17
 233              	.LVL23:
 234              	.L19:
 298:hardware.c    ****     str++;
 299:hardware.c    ****   }
 300:hardware.c    **** }
 235              		.loc 1 300 0
 236 0014 38BD     		pop	{r3, r4, r5, pc}
 237              		.cfi_endproc
 238              	.LFE4:
 240              		.section	.text.vprint,"ax",%progbits
 241              		.align	1
 242              		.global	vprint
 243              		.thumb
 244              		.thumb_func
 246              	vprint:
 247              	.LFB5:
 301:hardware.c    **** 
 302:hardware.c    **** void vprint(const char *fmt, va_list argp)
 303:hardware.c    **** {
 248              		.loc 1 303 0
 249              		.cfi_startproc
 250              		@ args = 0, pretend = 0, frame = 200
 251              		@ frame_needed = 0, uses_anonymous_args = 0
 252              	.LVL24:
 253 0000 00B5     		push	{lr}
 254              		.cfi_def_cfa_offset 4
 255              		.cfi_offset 14, -4
 256 0002 0346     		mov	r3, r0
 257 0004 B3B0     		sub	sp, sp, #204
 258              		.cfi_def_cfa_offset 208
 259              		.loc 1 303 0
 260 0006 0A46     		mov	r2, r1
 304:hardware.c    ****     char string[200];
 305:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
 261              		.loc 1 305 0
 262 0008 6846     		mov	r0, sp
 263              	.LVL25:
 264 000a 1946     		mov	r1, r3
 265              	.LVL26:
 266 000c FFF7FEFF 		bl	vsprintf
 267              	.LVL27:
 268 0010 0028     		cmp	r0, #0
 269 0012 03DD     		ble	.L20
 306:hardware.c    ****     {
 307:hardware.c    ****         UU_PutString(USART1, (uint8_t*)string); // send message via UART
 270              		.loc 1 307 0
 271 0014 0348     		ldr	r0, .L22
 272 0016 6946     		mov	r1, sp
 273 0018 FFF7FEFF 		bl	UU_PutString
 274              	.LVL28:
 275              	.L20:
 308:hardware.c    **** 
 309:hardware.c    ****     }
 310:hardware.c    **** }
 276              		.loc 1 310 0
 277 001c 33B0     		add	sp, sp, #204
 278              		@ sp needed
 279 001e 5DF804FB 		ldr	pc, [sp], #4
 280              	.L23:
 281 0022 00BF     		.align	2
 282              	.L22:
 283 0024 00380140 		.word	1073821696
 284              		.cfi_endproc
 285              	.LFE5:
 287              		.section	.text.uart_printf,"ax",%progbits
 288              		.align	1
 289              		.global	uart_printf
 290              		.thumb
 291              		.thumb_func
 293              	uart_printf:
 294              	.LFB6:
 311:hardware.c    **** 
 312:hardware.c    **** void uart_printf(const char *fmt, ...) // custom printf() function
 313:hardware.c    **** {
 295              		.loc 1 313 0
 296              		.cfi_startproc
 297              		@ args = 4, pretend = 16, frame = 8
 298              		@ frame_needed = 0, uses_anonymous_args = 1
 299              	.LVL29:
 300 0000 0FB4     		push	{r0, r1, r2, r3}
 301              		.cfi_def_cfa_offset 16
 302              		.cfi_offset 0, -16
 303              		.cfi_offset 1, -12
 304              		.cfi_offset 2, -8
 305              		.cfi_offset 3, -4
 306 0002 07B5     		push	{r0, r1, r2, lr}
 307              		.cfi_def_cfa_offset 32
 308              		.cfi_offset 0, -32
 309              		.cfi_offset 1, -28
 310              		.cfi_offset 2, -24
 311              		.cfi_offset 14, -20
 312              		.loc 1 313 0
 313 0004 04A9     		add	r1, sp, #16
 314 0006 51F8040B 		ldr	r0, [r1], #4
 314:hardware.c    ****     va_list argp;
 315:hardware.c    ****     va_start(argp, fmt);
 315              		.loc 1 315 0
 316 000a 0191     		str	r1, [sp, #4]
 316:hardware.c    ****     vprint(fmt, argp);
 317              		.loc 1 316 0
 318 000c FFF7FEFF 		bl	vprint
 319              	.LVL30:
 317:hardware.c    ****     va_end(argp);
 318:hardware.c    **** }
 320              		.loc 1 318 0
 321 0010 03B0     		add	sp, sp, #12
 322              		@ sp needed
 323 0012 5DF804EB 		ldr	lr, [sp], #4
 324 0016 04B0     		add	sp, sp, #16
 325 0018 7047     		bx	lr
 326              		.cfi_endproc
 327              	.LFE6:
 329              		.section	.text.hexdump,"ax",%progbits
 330              		.align	1
 331              		.global	hexdump
 332              		.thumb
 333              		.thumb_func
 335              	hexdump:
 336              	.LFB7:
 319:hardware.c    **** 
 320:hardware.c    **** void hexdump(unsigned char *data, size_t size)
 321:hardware.c    **** {
 337              		.loc 1 321 0
 338              		.cfi_startproc
 339              		@ args = 0, pretend = 0, frame = 24
 340              		@ frame_needed = 0, uses_anonymous_args = 0
 341              	.LVL31:
 342 0000 30B5     		push	{r4, r5, lr}
 343              		.cfi_def_cfa_offset 12
 344              		.cfi_offset 4, -12
 345              		.cfi_offset 5, -8
 346              		.cfi_offset 14, -4
 347 0002 87B0     		sub	sp, sp, #28
 348              		.cfi_def_cfa_offset 40
 349              		.loc 1 321 0
 350 0004 0D46     		mov	r5, r1
 322:hardware.c    ****     int i;
 323:hardware.c    ****     char cs[17];
 324:hardware.c    ****     memset(cs, 0, 17);
 351              		.loc 1 324 0
 352 0006 01A8     		add	r0, sp, #4
 353              	.LVL32:
 354 0008 0021     		movs	r1, #0
 355              	.LVL33:
 356 000a 1122     		movs	r2, #17
 357 000c FFF7FEFF 		bl	memset
 358              	.LVL34:
 325:hardware.c    **** 
 326:hardware.c    ****     for(i = 0; i < size; i++)
 359              		.loc 1 326 0
 360 0010 0024     		movs	r4, #0
 361              	.LVL35:
 362              	.L26:
 363              		.loc 1 326 0 is_stmt 0 discriminator 1
 364 0012 AC42     		cmp	r4, r5
 365 0014 09D0     		beq	.L32
 327:hardware.c    ****     {
 328:hardware.c    ****         if(i != 0 && i % 0x10 == 0)
 366              		.loc 1 328 0 is_stmt 1
 367 0016 34B1     		cbz	r4, .L27
 368              		.loc 1 328 0 is_stmt 0 discriminator 1
 369 0018 14F00F01 		ands	r1, r4, #15
 370 001c 03D1     		bne	.L27
 329:hardware.c    ****         {
 330:hardware.c    ****             debug_print(" |%s|\n", cs);
 331:hardware.c    ****             memset(cs, 0, 17);
 371              		.loc 1 331 0 is_stmt 1
 372 001e 01A8     		add	r0, sp, #4
 373 0020 1122     		movs	r2, #17
 374 0022 FFF7FEFF 		bl	memset
 375              	.LVL36:
 376              	.L27:
 326:hardware.c    ****     for(i = 0; i < size; i++)
 377              		.loc 1 326 0
 378 0026 0134     		adds	r4, r4, #1
 379              	.LVL37:
 380 0028 F3E7     		b	.L26
 381              	.L32:
 332:hardware.c    ****         }
 333:hardware.c    ****         else if(i != 0 && i % 0x8 == 0)
 334:hardware.c    ****         {
 335:hardware.c    ****             debug_print(" ",0);
 336:hardware.c    ****         }
 337:hardware.c    ****         debug_print("%02X ", data[i]);
 338:hardware.c    ****         cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
 339:hardware.c    ****     }
 340:hardware.c    **** 
 341:hardware.c    ****     i = i % 0x10;
 342:hardware.c    ****     if(i != 0)
 343:hardware.c    ****     {
 344:hardware.c    ****         if(i <= 0x8)
 345:hardware.c    ****         {
 346:hardware.c    ****             debug_print(" ",0);
 347:hardware.c    ****         }
 348:hardware.c    ****         while(i++ < 0x10)
 349:hardware.c    ****         {
 350:hardware.c    ****             debug_print("   ",0);
 351:hardware.c    ****         }
 352:hardware.c    ****     }
 353:hardware.c    ****     debug_print(" |%s|\n", cs);
 354:hardware.c    **** }
 382              		.loc 1 354 0
 383 002a 07B0     		add	sp, sp, #28
 384              		@ sp needed
 385 002c 30BD     		pop	{r4, r5, pc}
 386              		.cfi_endproc
 387              	.LFE7:
 389              		.section	.text.uartInit,"ax",%progbits
 390              		.align	1
 391              		.global	uartInit
 392              		.thumb
 393              		.thumb_func
 395              	uartInit:
 396              	.LFB8:
 355:hardware.c    **** 
 356:hardware.c    **** 
 357:hardware.c    **** #endif
 358:hardware.c    **** void uartInit(void) {
 397              		.loc 1 358 0
 398              		.cfi_startproc
 399              		@ args = 0, pretend = 0, frame = 24
 400              		@ frame_needed = 0, uses_anonymous_args = 0
 401 0000 10B5     		push	{r4, lr}
 402              		.cfi_def_cfa_offset 8
 403              		.cfi_offset 4, -8
 404              		.cfi_offset 14, -4
 359:hardware.c    ****     GPIO_InitTypeDef GPIO_InitStructure;
 360:hardware.c    ****     USART_InitTypeDef USART_InitStructure;
 361:hardware.c    ****     
 362:hardware.c    ****     /* Enable peripheral clocks for USART1 on GPIOA */
 363:hardware.c    ****     //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
 364:hardware.c    ****     RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 365:hardware.c    ****         RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
 405              		.loc 1 365 0
 406 0002 204C     		ldr	r4, .L34
 358:hardware.c    **** void uartInit(void) {
 407              		.loc 1 358 0
 408 0004 86B0     		sub	sp, sp, #24
 409              		.cfi_def_cfa_offset 32
 364:hardware.c    ****     RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
 410              		.loc 1 364 0
 411 0006 4FF48040 		mov	r0, #16384
 412 000a 0121     		movs	r1, #1
 413 000c FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 414              	.LVL38:
 415              		.loc 1 365 0
 416 0010 2046     		mov	r0, r4
 417 0012 0121     		movs	r1, #1
 418 0014 FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 419              	.LVL39:
 366:hardware.c    ****     /* Configure PA9 and PA10 as USART1 TX/RX */
 367:hardware.c    ****     
 368:hardware.c    ****     /* PA9 = alternate function push/pull output */
 369:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
 420              		.loc 1 369 0
 421 0018 4FF40073 		mov	r3, #512
 422 001c ADF80430 		strh	r3, [sp, #4]	@ movhi
 370:hardware.c    ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 423              		.loc 1 370 0
 424 0020 0323     		movs	r3, #3
 425 0022 8DF80630 		strb	r3, [sp, #6]
 371:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 372:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 426              		.loc 1 372 0
 427 0026 2046     		mov	r0, r4
 371:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 428              		.loc 1 371 0
 429 0028 1823     		movs	r3, #24
 430              		.loc 1 372 0
 431 002a 01A9     		add	r1, sp, #4
 371:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
 432              		.loc 1 371 0
 433 002c 8DF80730 		strb	r3, [sp, #7]
 434              		.loc 1 372 0
 435 0030 FFF7FEFF 		bl	GPIO_Init
 436              	.LVL40:
 373:hardware.c    ****     
 374:hardware.c    ****     /* PA10 = floating input */
 375:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 437              		.loc 1 375 0
 438 0034 4FF48063 		mov	r3, #1024
 439 0038 ADF80430 		strh	r3, [sp, #4]	@ movhi
 376:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 440              		.loc 1 376 0
 441 003c 0423     		movs	r3, #4
 377:hardware.c    ****     GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
 442              		.loc 1 377 0
 443 003e 0DEB0301 		add	r1, sp, r3
 444 0042 2046     		mov	r0, r4
 376:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 445              		.loc 1 376 0
 446 0044 8DF80730 		strb	r3, [sp, #7]
 447              		.loc 1 377 0
 448 0048 FFF7FEFF 		bl	GPIO_Init
 449              	.LVL41:
 378:hardware.c    ****     
 379:hardware.c    ****     /* Configure and initialize usart... */
 380:hardware.c    ****     USART_InitStructure.USART_BaudRate = 115200;
 450              		.loc 1 380 0
 451 004c 4FF4E133 		mov	r3, #115200
 452 0050 0293     		str	r3, [sp, #8]
 381:hardware.c    ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 382:hardware.c    ****     USART_InitStructure.USART_StopBits = USART_StopBits_1;
 383:hardware.c    ****     USART_InitStructure.USART_Parity = USART_Parity_No;
 384:hardware.c    ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 385:hardware.c    ****     USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 386:hardware.c    ****         
 387:hardware.c    ****     USART_Init(USART1, &USART_InitStructure);
 453              		.loc 1 387 0
 454 0052 04F54054 		add	r4, r4, #12288
 381:hardware.c    ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;
 455              		.loc 1 381 0
 456 0056 0023     		movs	r3, #0
 457 0058 ADF80C30 		strh	r3, [sp, #12]	@ movhi
 382:hardware.c    ****     USART_InitStructure.USART_StopBits = USART_StopBits_1;
 458              		.loc 1 382 0
 459 005c ADF80E30 		strh	r3, [sp, #14]	@ movhi
 383:hardware.c    ****     USART_InitStructure.USART_Parity = USART_Parity_No;
 460              		.loc 1 383 0
 461 0060 ADF81030 		strh	r3, [sp, #16]	@ movhi
 384:hardware.c    ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 462              		.loc 1 384 0
 463 0064 ADF81430 		strh	r3, [sp, #20]	@ movhi
 464              		.loc 1 387 0
 465 0068 02A9     		add	r1, sp, #8
 385:hardware.c    ****     USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 466              		.loc 1 385 0
 467 006a 0C23     		movs	r3, #12
 468              		.loc 1 387 0
 469 006c 2046     		mov	r0, r4
 385:hardware.c    ****     USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
 470              		.loc 1 385 0
 471 006e ADF81230 		strh	r3, [sp, #18]	@ movhi
 472              		.loc 1 387 0
 473 0072 FFF7FEFF 		bl	USART_Init
 474              	.LVL42:
 388:hardware.c    ****     
 389:hardware.c    ****     /* Enable USART1 */
 390:hardware.c    ****     USART_Cmd(USART1, ENABLE);   
 475              		.loc 1 390 0
 476 0076 2046     		mov	r0, r4
 477 0078 0121     		movs	r1, #1
 478 007a FFF7FEFF 		bl	USART_Cmd
 479              	.LVL43:
 391:hardware.c    **** }
 480              		.loc 1 391 0
 481 007e 06B0     		add	sp, sp, #24
 482              		@ sp needed
 483 0080 10BD     		pop	{r4, pc}
 484              	.L35:
 485 0082 00BF     		.align	2
 486              	.L34:
 487 0084 00080140 		.word	1073809408
 488              		.cfi_endproc
 489              	.LFE8:
 491              		.section	.text.systemReset,"ax",%progbits
 492              		.align	1
 493              		.global	systemReset
 494              		.thumb
 495              		.thumb_func
 497              	systemReset:
 498              	.LFB9:
 392:hardware.c    **** 
 393:hardware.c    **** void systemReset(void) {
 499              		.loc 1 393 0
 500              		.cfi_startproc
 501              		@ args = 0, pretend = 0, frame = 0
 502              		@ frame_needed = 0, uses_anonymous_args = 0
 503              		@ link register save eliminated.
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 504              		.loc 1 394 0
 505 0000 0D4B     		ldr	r3, .L37
 395:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 506              		.loc 1 395 0
 507 0002 0E49     		ldr	r1, .L37+4
 394:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 508              		.loc 1 394 0
 509 0004 1A68     		ldr	r2, [r3]
 510 0006 42F00102 		orr	r2, r2, #1
 511 000a 1A60     		str	r2, [r3]
 512              		.loc 1 395 0
 513 000c 0C4A     		ldr	r2, .L37+8
 514 000e 1068     		ldr	r0, [r2]
 515 0010 0140     		ands	r1, r1, r0
 516 0012 1160     		str	r1, [r2]
 396:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 517              		.loc 1 396 0
 518 0014 1968     		ldr	r1, [r3]
 519 0016 21F08471 		bic	r1, r1, #17301504
 520 001a 21F48031 		bic	r1, r1, #65536
 521 001e 1960     		str	r1, [r3]
 397:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
 522              		.loc 1 397 0
 523 0020 1968     		ldr	r1, [r3]
 524 0022 21F48021 		bic	r1, r1, #262144
 525 0026 1960     		str	r1, [r3]
 398:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 526              		.loc 1 398 0
 527 0028 1368     		ldr	r3, [r2]
 528 002a 23F4FE03 		bic	r3, r3, #8323072
 529 002e 1360     		str	r3, [r2]
 399:hardware.c    **** 
 400:hardware.c    ****     SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
 530              		.loc 1 400 0
 531 0030 044B     		ldr	r3, .L37+12
 532 0032 0022     		movs	r2, #0
 533 0034 1A60     		str	r2, [r3]
 534 0036 7047     		bx	lr
 535              	.L38:
 536              		.align	2
 537              	.L37:
 538 0038 00100240 		.word	1073876992
 539 003c 0000FFF8 		.word	-117506048
 540 0040 04100240 		.word	1073876996
 541 0044 08100240 		.word	1073877000
 542              		.cfi_endproc
 543              	.LFE9:
 545              		.section	.text.setupCLK,"ax",%progbits
 546              		.align	1
 547              		.global	setupCLK
 548              		.thumb
 549              		.thumb_func
 551              	setupCLK:
 552              	.LFB10:
 401:hardware.c    **** }
 402:hardware.c    **** 
 403:hardware.c    **** void setupCLK(void) {
 553              		.loc 1 403 0
 554              		.cfi_startproc
 555              		@ args = 0, pretend = 0, frame = 0
 556              		@ frame_needed = 0, uses_anonymous_args = 0
 557              		@ link register save eliminated.
 558              	.LVL44:
 404:hardware.c    **** 	unsigned int StartUpCounter=0;
 405:hardware.c    ****     /* enable HSE */
 406:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
 559              		.loc 1 406 0
 560 0000 154B     		ldr	r3, .L46
 561 0002 1A68     		ldr	r2, [r3]
 562 0004 42F00112 		orr	r2, r2, #65537
 563 0008 1A60     		str	r2, [r3]
 564              	.L41:
 407:hardware.c    ****     while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
 565              		.loc 1 407 0 discriminator 1
 566 000a 1A68     		ldr	r2, [r3]
 567 000c 1248     		ldr	r0, .L46
 568 000e 9203     		lsls	r2, r2, #14
 569 0010 FBD5     		bpl	.L41
 408:hardware.c    **** 
 409:hardware.c    ****     /* enable flash prefetch buffer */
 410:hardware.c    ****     SET_REG(FLASH_ACR, 0x00000012);
 570              		.loc 1 410 0
 571 0012 124A     		ldr	r2, .L46+4
 572 0014 1221     		movs	r1, #18
 573 0016 1160     		str	r1, [r2]
 411:hardware.c    **** 	
 412:hardware.c    ****      /* Configure PLL */
 413:hardware.c    **** #ifdef XTAL12M
 414:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
 415:hardware.c    **** #else
 416:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
 574              		.loc 1 416 0
 575 0018 A2F6FC72 		subw	r2, r2, #4092
 576 001c 1168     		ldr	r1, [r2]
 577 001e 41F4E811 		orr	r1, r1, #1900544
 578 0022 41F48061 		orr	r1, r1, #1024
 579 0026 1160     		str	r1, [r2]
 417:hardware.c    **** #endif	
 418:hardware.c    **** 
 419:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
 580              		.loc 1 419 0
 581 0028 0168     		ldr	r1, [r0]
 582 002a 41F08071 		orr	r1, r1, #16777216
 583 002e 0160     		str	r1, [r0]
 584              	.L43:
 420:hardware.c    **** 	
 421:hardware.c    **** 
 422:hardware.c    **** #if !defined  (HSE_STARTUP_TIMEOUT) 
 423:hardware.c    ****   #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
 424:hardware.c    **** #endif /* HSE_STARTUP_TIMEOUT */   
 425:hardware.c    **** 
 426:hardware.c    ****     while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
 585              		.loc 1 426 0 discriminator 1
 586 0030 1968     		ldr	r1, [r3]
 587 0032 11F0407F 		tst	r1, #50331648
 588 0036 FBD0     		beq	.L43
 427:hardware.c    **** 	{
 428:hardware.c    **** //		StartUpCounter++; // This is commented out, so other changes can be committed. It will be uncom
 429:hardware.c    **** 	}	/* wait for it to come on */
 430:hardware.c    **** 
 431:hardware.c    **** 	if (StartUpCounter>=HSE_STARTUP_TIMEOUT)
 432:hardware.c    **** 	{
 433:hardware.c    **** 		// HSE has not started. Try restarting the processor
 434:hardware.c    **** 		systemHardReset(); 
 435:hardware.c    **** 	}
 436:hardware.c    ****     /* Set SYSCLK as PLL */
 437:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
 589              		.loc 1 437 0
 590 0038 1168     		ldr	r1, [r2]
 591 003a 41F00201 		orr	r1, r1, #2
 592 003e 1160     		str	r1, [r2]
 593              	.L45:
 438:hardware.c    ****     while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
 594              		.loc 1 438 0 discriminator 1
 595 0040 1168     		ldr	r1, [r2]
 596 0042 0907     		lsls	r1, r1, #28
 597 0044 FCD5     		bpl	.L45
 439:hardware.c    **** 	
 440:hardware.c    ****     pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
 598              		.loc 1 440 0
 599 0046 9A69     		ldr	r2, [r3, #24]
 600 0048 42F4FE72 		orr	r2, r2, #508
 601 004c 9A61     		str	r2, [r3, #24]
 441:hardware.c    **** 	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
 602              		.loc 1 441 0
 603 004e DA69     		ldr	r2, [r3, #28]
 604 0050 42F40002 		orr	r2, r2, #8388608
 605 0054 DA61     		str	r2, [r3, #28]
 606 0056 7047     		bx	lr
 607              	.L47:
 608              		.align	2
 609              	.L46:
 610 0058 00100240 		.word	1073876992
 611 005c 00200240 		.word	1073881088
 612              		.cfi_endproc
 613              	.LFE10:
 615              		.section	.text.setupLEDAndButton,"ax",%progbits
 616              		.align	1
 617              		.global	setupLEDAndButton
 618              		.thumb
 619              		.thumb_func
 621              	setupLEDAndButton:
 622              	.LFB11:
 442:hardware.c    **** 
 443:hardware.c    **** }
 444:hardware.c    **** 
 445:hardware.c    **** void setupLEDAndButton (void) { 
 623              		.loc 1 445 0
 624              		.cfi_startproc
 625              		@ args = 0, pretend = 0, frame = 0
 626              		@ frame_needed = 0, uses_anonymous_args = 0
 627              		@ link register save eliminated.
 446:hardware.c    ****   SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUT
 628              		.loc 1 446 0
 629 0000 034B     		ldr	r3, .L49
 630 0002 1A68     		ldr	r2, [r3]
 631              	.LVL45:
 632 0004 22F47002 		bic	r2, r2, #15728640
 633 0008 42F48012 		orr	r2, r2, #1048576
 634 000c 1A60     		str	r2, [r3]
 635 000e 7047     		bx	lr
 636              	.L50:
 637              		.align	2
 638              	.L49:
 639 0010 04100140 		.word	1073811460
 640              		.cfi_endproc
 641              	.LFE11:
 643              		.section	.text.setupFLASH,"ax",%progbits
 644              		.align	1
 645              		.global	setupFLASH
 646              		.thumb
 647              		.thumb_func
 649              	setupFLASH:
 650              	.LFB12:
 447:hardware.c    **** }
 448:hardware.c    **** 
 449:hardware.c    **** void setupFLASH() {
 651              		.loc 1 449 0
 652              		.cfi_startproc
 653              		@ args = 0, pretend = 0, frame = 0
 654              		@ frame_needed = 0, uses_anonymous_args = 0
 655              		@ link register save eliminated.
 450:hardware.c    ****     /* configure the HSI oscillator */
 451:hardware.c    ****     if ((pRCC->CR & 0x01) == 0x00) {
 656              		.loc 1 451 0
 657 0000 054B     		ldr	r3, .L55
 658 0002 1A68     		ldr	r2, [r3]
 659 0004 D107     		lsls	r1, r2, #31
 660 0006 03D4     		bmi	.L54
 661              	.LBB4:
 452:hardware.c    ****         u32 rwmVal = pRCC->CR;
 662              		.loc 1 452 0
 663 0008 1A68     		ldr	r2, [r3]
 664              	.LVL46:
 453:hardware.c    ****         rwmVal |= 0x01;
 665              		.loc 1 453 0
 666 000a 42F00102 		orr	r2, r2, #1
 667              	.LVL47:
 454:hardware.c    ****         pRCC->CR = rwmVal;
 668              		.loc 1 454 0
 669 000e 1A60     		str	r2, [r3]
 670              	.LVL48:
 671              	.L54:
 672              	.LBE4:
 455:hardware.c    ****     }
 456:hardware.c    **** 
 457:hardware.c    ****     /* wait for it to come on */
 458:hardware.c    ****     while ((pRCC->CR & 0x02) == 0x00) {}
 673              		.loc 1 458 0 discriminator 1
 674 0010 1A68     		ldr	r2, [r3]
 675 0012 9207     		lsls	r2, r2, #30
 676 0014 FCD5     		bpl	.L54
 459:hardware.c    **** }   
 677              		.loc 1 459 0
 678 0016 7047     		bx	lr
 679              	.L56:
 680              		.align	2
 681              	.L55:
 682 0018 00100240 		.word	1073876992
 683              		.cfi_endproc
 684              	.LFE12:
 686              		.section	.text.uid_read,"ax",%progbits
 687              		.align	1
 688              		.global	uid_read
 689              		.thumb
 690              		.thumb_func
 692              	uid_read:
 693              	.LFB13:
 460:hardware.c    **** 
 461:hardware.c    **** /* Read U_ID register */
 462:hardware.c    **** void uid_read(struct u_id *id)
 463:hardware.c    **** {
 694              		.loc 1 463 0
 695              		.cfi_startproc
 696              		@ args = 0, pretend = 0, frame = 8
 697              		@ frame_needed = 0, uses_anonymous_args = 0
 698              	.LVL49:
 699 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 700              		.cfi_def_cfa_offset 24
 701              		.cfi_offset 0, -24
 702              		.cfi_offset 1, -20
 703              		.cfi_offset 2, -16
 704              		.cfi_offset 4, -12
 705              		.cfi_offset 5, -8
 706              		.cfi_offset 14, -4
 707              		.loc 1 463 0
 708 0002 02AA     		add	r2, sp, #8
 709 0004 42F8040D 		str	r0, [r2, #-4]!
 464:hardware.c    ****   if (QEMU_BUILD) // put an arbitrary ECID in qemu
 465:hardware.c    ****   {
 466:hardware.c    ****     memcpy(&id, (unsigned char*)0xFF, 23);
 710              		.loc 1 466 0
 711 0008 FF23     		movs	r3, #255
 712 000a 40F20F15 		movw	r5, #271
 713              	.LVL50:
 714              	.L58:
 715 000e 1868     		ldr	r0, [r3]	@ unaligned
 716 0010 5968     		ldr	r1, [r3, #4]	@ unaligned
 717 0012 1446     		mov	r4, r2
 718 0014 03C4     		stmia	r4!, {r0, r1}
 719 0016 0833     		adds	r3, r3, #8
 720 0018 AB42     		cmp	r3, r5
 721 001a 2246     		mov	r2, r4
 722 001c F7D1     		bne	.L58
 723 001e 1868     		ldr	r0, [r3]	@ unaligned
 724 0020 2060     		str	r0, [r4]	@ unaligned
 725 0022 9988     		ldrh	r1, [r3, #4]	@ unaligned
 726 0024 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 727 0026 A180     		strh	r1, [r4, #4]	@ unaligned
 728 0028 A371     		strb	r3, [r4, #6]
 467:hardware.c    ****   } else {
 468:hardware.c    ****     id->off0 = MMIO16(U_ID + 0x0);
 469:hardware.c    ****     id->off2 = MMIO16(U_ID + 0x2);
 470:hardware.c    ****     id->off4 = MMIO32(U_ID + 0x4);
 471:hardware.c    ****     id->off8 = MMIO32(U_ID + 0x8);
 472:hardware.c    ****   }
 473:hardware.c    **** }
 729              		.loc 1 473 0
 730 002a 03B0     		add	sp, sp, #12
 731              		@ sp needed
 732 002c 30BD     		pop	{r4, r5, pc}
 733              		.cfi_endproc
 734              	.LFE13:
 736              		.section	.text.checkUserCode,"ax",%progbits
 737              		.align	1
 738              		.global	checkUserCode
 739              		.thumb
 740              		.thumb_func
 742              	checkUserCode:
 743              	.LFB14:
 474:hardware.c    **** 
 475:hardware.c    **** int checkUserCode(u32 usrAddr) {
 744              		.loc 1 475 0
 745              		.cfi_startproc
 746              		@ args = 0, pretend = 0, frame = 0
 747              		@ frame_needed = 0, uses_anonymous_args = 0
 748              		@ link register save eliminated.
 749              	.LVL51:
 476:hardware.c    ****     /* deprecated 
 477:hardware.c    ****     int imageCheckFromAddress(
 478:hardware.c    ****         ImageObjectHandle *newHandle,
 479:hardware.c    ****         uint32_t flashAddress);*/
 480:hardware.c    ****     // get hash written to top of stage 2
 481:hardware.c    ****     /*unsigned char writtenHash[32];
 482:hardware.c    ****     memset(writtenHash, 0xFF, sizeof(writtenHash));
 483:hardware.c    ****     memcpy(writtenHash, (vu32 *)usrAddr, 0x20);
 484:hardware.c    **** 
 485:hardware.c    ****     // hax to see if our firmware is where it should be
 486:hardware.c    ****     if (!memcmp(writtenHash, 0xFF, 32))
 487:hardware.c    ****     {
 488:hardware.c    ****       return 0x0;
 489:hardware.c    ****     }
 490:hardware.c    **** 
 491:hardware.c    ****     // get signature from stage 2 image
 492:hardware.c    ****     uint8_t signature[EDSIGN_SIGNATURE_SIZE];
 493:hardware.c    ****     memset(signature, 0xFF, sizeof(signature));
 494:hardware.c    ****     memcpy(signature,  (vu32 *)(usrAddr+0x20), 0x40);
 495:hardware.c    **** 
 496:hardware.c    ****     // prepare hash
 497:hardware.c    ****     unsigned char sha256sum[32];
 498:hardware.c    ****     uint8_t input[0x5C];
 499:hardware.c    **** 
 500:hardware.c    ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
 501:hardware.c    ****     memset(input, 0xFF, sizeof(input));
 502:hardware.c    **** 
 503:hardware.c    ****     sha256_context ctx;
 504:hardware.c    ****     sha256_starts(&ctx);
 505:hardware.c    **** 
 506:hardware.c    ****     // get expected size
 507:hardware.c    ****     int offset = Swap2Bytes(*(int*)((vu32 *)(usrAddr+0x60))) + 0x140;
 508:hardware.c    ****     int i = 0x74;
 509:hardware.c    ****     //feedface is our eof, hi mach ily
 510:hardware.c    ****     {0x50, 0xF5, 0x00, 0x68, 0x01}
 511:hardware.c    ****     char cmpEnd[4] = {0xFE, 0xED, 0xFA, 0xCE};
 512:hardware.c    ****     char buff[0x4];
 513:hardware.c    ****     // read through memory, hash buff, and stop on feedface
 514:hardware.c    ****     while ((usrAddr+i) <= (usrAddr+offset))
 515:hardware.c    ****     {
 516:hardware.c    ****       memset(buff, 0xFF, 0x4);
 517:hardware.c    ****       memcpy(buff, (char *)(usrAddr+i), 0x4);
 518:hardware.c    ****       if (memmem(&buff, 0x4, &cmpEnd, 4) != 0)
 519:hardware.c    ****       {
 520:hardware.c    ****         sha256_update(&ctx, (vu32 *)(usrAddr+i), 0x4);
 521:hardware.c    ****         break;
 522:hardware.c    ****       }
 523:hardware.c    ****       sha256_update(&ctx, (vu32 *)(usrAddr+i), 0x4);
 524:hardware.c    ****       i += 0x4;
 525:hardware.c    ****     }
 526:hardware.c    **** 
 527:hardware.c    ****     // hash in our unique ID
 528:hardware.c    ****     struct u_id id;
 529:hardware.c    ****     uid_read(&id);
 530:hardware.c    ****     unsigned char uniqueID[23];
 531:hardware.c    ****     sprintf(uniqueID,"%X", id.off0, id.off2, id.off4, id.off8);
 532:hardware.c    ****     uart_printf("%X%X%X%X\n", id.off0, id.off2, id.off4, id.off8);
 533:hardware.c    ****     sha256_update(&ctx, uniqueID, 23);
 534:hardware.c    ****     sha256_finish(&ctx, sha256sum);
 535:hardware.c    **** 
 536:hardware.c    ****     print_hash(sha256sum);
 537:hardware.c    **** 
 538:hardware.c    ****   uint8_t rootCA[32] = {
 539:hardware.c    ****        0xf3,0x47,0xb9,0x5e,0x5f,0x03,0x62,0x13,
 540:hardware.c    ****        0xf3,0x88,0x72,0x73,0xea,0xcf,0x91,0x73,
 541:hardware.c    ****        0x35,0xda,0x72,0x68,0xae,0xf6,0x98,0x90,
 542:hardware.c    ****        0x51,0x87,0xff,0xea,0xd6,0xb5,0x5b,0x32
 543:hardware.c    ****     };
 544:hardware.c    ****     // verify signature against recalc hash
 545:hardware.c    ****     if (!edsign_verify(signature, rootCA, sha256sum, 0x20) > 0) {
 546:hardware.c    ****         return 0x1;
 547:hardware.c    ****     }
 548:hardware.c    ****     // verify written hash against recalc hash
 549:hardware.c    ****     if (memcmp(sha256sum, writtenHash, 32)){
 550:hardware.c    ****         return 0x2;
 551:hardware.c    ****     }*/
 552:hardware.c    **** 
 553:hardware.c    ****     return 0x3;
 554:hardware.c    **** }
 750              		.loc 1 554 0
 751 0000 0320     		movs	r0, #3
 752              	.LVL52:
 753 0002 7047     		bx	lr
 754              		.cfi_endproc
 755              	.LFE14:
 757              		.section	.text.setMspAndJump,"ax",%progbits
 758              		.align	1
 759              		.global	setMspAndJump
 760              		.thumb
 761              		.thumb_func
 763              	setMspAndJump:
 764              	.LFB15:
 555:hardware.c    **** 
 556:hardware.c    **** void setMspAndJump(u32 usrAddr) {
 765              		.loc 1 556 0
 766              		.cfi_startproc
 767              		@ args = 0, pretend = 0, frame = 0
 768              		@ frame_needed = 0, uses_anonymous_args = 0
 769              	.LVL53:
 557:hardware.c    ****   // Dedicated function with no call to any function (appart the last call)
 558:hardware.c    ****   // This way, there is no manipulation of the stack here, ensuring that GGC
 559:hardware.c    ****   // didn't insert any pop from the SP after having set the MSP.
 560:hardware.c    ****   typedef void (*funcPtr)(void);
 561:hardware.c    ****   u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
 562:hardware.c    **** 
 563:hardware.c    ****   funcPtr usrMain = (funcPtr) jumpAddr;
 564:hardware.c    **** 
 565:hardware.c    ****   SET_REG(SCB_VTOR, (vu32) (usrAddr));
 770              		.loc 1 565 0
 771 0000 044A     		ldr	r2, .L62
 556:hardware.c    **** void setMspAndJump(u32 usrAddr) {
 772              		.loc 1 556 0
 773 0002 08B5     		push	{r3, lr}
 774              		.cfi_def_cfa_offset 8
 775              		.cfi_offset 3, -8
 776              		.cfi_offset 14, -4
 561:hardware.c    ****   u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
 777              		.loc 1 561 0
 778 0004 4368     		ldr	r3, [r0, #4]
 779              	.LVL54:
 780              		.loc 1 565 0
 781 0006 1060     		str	r0, [r2]
 566:hardware.c    **** 
 567:hardware.c    ****   asm volatile("msr msp, %0"::"g"
 568:hardware.c    ****                (*(volatile u32 *)usrAddr));
 782              		.loc 1 568 0
 783 0008 0268     		ldr	r2, [r0]
 567:hardware.c    ****   asm volatile("msr msp, %0"::"g"
 784              		.loc 1 567 0
 785              	@ 567 "hardware.c" 1
 786 000a 82F30888 		msr msp, r2
 787              	@ 0 "" 2
 569:hardware.c    **** 
 570:hardware.c    ****   usrMain();                                /* go! */
 788              		.loc 1 570 0
 789              		.thumb
 790 000e 9847     		blx	r3
 791              	.LVL55:
 792 0010 08BD     		pop	{r3, pc}
 793              	.L63:
 794 0012 00BF     		.align	2
 795              	.L62:
 796 0014 08ED00E0 		.word	-536810232
 797              		.cfi_endproc
 798              	.LFE15:
 800              		.section	.text.bkp10Write,"ax",%progbits
 801              		.align	1
 802              		.global	bkp10Write
 803              		.thumb
 804              		.thumb_func
 806              	bkp10Write:
 807              	.LFB17:
 571:hardware.c    **** }
 572:hardware.c    **** 
 573:hardware.c    **** 
 574:hardware.c    **** void jumpToUser(u32 usrAddr) {
 575:hardware.c    **** 
 576:hardware.c    ****     /* tear down all the dfu related setup */
 577:hardware.c    ****     // disable usb interrupts, clear them, turn off usb, set the disc pin
 578:hardware.c    ****     // todo pick exactly what we want to do here, now its just a conservative
 579:hardware.c    **** 
 580:hardware.c    ****     //flashLock();
 581:hardware.c    ****     usbDsbISR();
 582:hardware.c    ****     nvicDisableInterrupts();
 583:hardware.c    **** 	
 584:hardware.c    **** #ifndef HAS_MAPLE_HARDWARE	
 585:hardware.c    **** 	usbDsbBus();
 586:hardware.c    **** #endif
 587:hardware.c    **** 	
 588:hardware.c    **** // Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(
 589:hardware.c    ****     systemReset(); // resets clocks and periphs, not core regs
 590:hardware.c    ****     //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW
 591:hardware.c    ****     setMspAndJump(usrAddr);
 592:hardware.c    **** }
 593:hardware.c    **** 
 594:hardware.c    **** void bkp10Write(u16 value)
 595:hardware.c    **** {
 808              		.loc 1 595 0
 809              		.cfi_startproc
 810              		@ args = 0, pretend = 0, frame = 0
 811              		@ frame_needed = 0, uses_anonymous_args = 0
 812              		@ link register save eliminated.
 813              	.LVL56:
 596:hardware.c    **** 		// Enable clocks for the backup domain registers
 597:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 814              		.loc 1 597 0
 815 0000 084B     		ldr	r3, .L65
 816 0002 DA69     		ldr	r2, [r3, #28]
 817 0004 42F0C052 		orr	r2, r2, #402653184
 818 0008 DA61     		str	r2, [r3, #28]
 598:hardware.c    **** 		
 599:hardware.c    ****         // Disable backup register write protection
 600:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 819              		.loc 1 600 0
 820 000a A3F5D033 		sub	r3, r3, #106496
 821 000e 1A68     		ldr	r2, [r3]
 822 0010 42F48072 		orr	r2, r2, #256
 823 0014 1A60     		str	r2, [r3]
 601:hardware.c    **** 
 602:hardware.c    ****         // store value in pBK DR10
 603:hardware.c    ****         pBKP->DR10 = value;
 824              		.loc 1 603 0
 825 0016 044A     		ldr	r2, .L65+4
 826 0018 1085     		strh	r0, [r2, #40]	@ movhi
 604:hardware.c    **** 
 605:hardware.c    ****         // Re-enable backup register write protection
 606:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 827              		.loc 1 606 0
 828 001a 1A68     		ldr	r2, [r3]
 829 001c 22F48072 		bic	r2, r2, #256
 830 0020 1A60     		str	r2, [r3]
 831 0022 7047     		bx	lr
 832              	.L66:
 833              		.align	2
 834              	.L65:
 835 0024 00100240 		.word	1073876992
 836 0028 006C0040 		.word	1073769472
 837              		.cfi_endproc
 838              	.LFE17:
 840              		.section	.text.checkAndClearBootloaderFlag,"ax",%progbits
 841              		.align	1
 842              		.global	checkAndClearBootloaderFlag
 843              		.thumb
 844              		.thumb_func
 846              	checkAndClearBootloaderFlag:
 847              	.LFB18:
 607:hardware.c    **** }
 608:hardware.c    **** 
 609:hardware.c    **** int checkAndClearBootloaderFlag()
 610:hardware.c    **** {
 848              		.loc 1 610 0
 849              		.cfi_startproc
 850              		@ args = 0, pretend = 0, frame = 0
 851              		@ frame_needed = 0, uses_anonymous_args = 0
 852              	.LVL57:
 853 0000 38B5     		push	{r3, r4, r5, lr}
 854              		.cfi_def_cfa_offset 16
 855              		.cfi_offset 3, -16
 856              		.cfi_offset 4, -12
 857              		.cfi_offset 5, -8
 858              		.cfi_offset 14, -4
 611:hardware.c    ****     bool flagSet = 0x00;// Flag not used
 612:hardware.c    **** 
 613:hardware.c    ****     // Enable clocks for the backup domain registers
 614:hardware.c    ****     pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 859              		.loc 1 614 0
 860 0002 0F4B     		ldr	r3, .L74
 615:hardware.c    **** 
 616:hardware.c    ****     switch (pBKP->DR10)
 861              		.loc 1 616 0
 862 0004 44F24C21 		movw	r1, #16972
 614:hardware.c    ****     pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 863              		.loc 1 614 0
 864 0008 DA69     		ldr	r2, [r3, #28]
 865 000a 1D46     		mov	r5, r3
 866 000c 42F0C052 		orr	r2, r2, #402653184
 867 0010 DA61     		str	r2, [r3, #28]
 868              		.loc 1 616 0
 869 0012 0C4A     		ldr	r2, .L74+4
 870 0014 128D     		ldrh	r2, [r2, #40]
 871 0016 92B2     		uxth	r2, r2
 872 0018 8A42     		cmp	r2, r1
 873 001a 05D0     		beq	.L69
 874 001c 44F24D23 		movw	r3, #16973
 875 0020 9A42     		cmp	r2, r3
 876 0022 03D0     		beq	.L72
 611:hardware.c    ****     bool flagSet = 0x00;// Flag not used
 877              		.loc 1 611 0
 878 0024 0024     		movs	r4, #0
 879 0026 09E0     		b	.L73
 880              	.L69:
 617:hardware.c    **** 	{
 618:hardware.c    **** 		case RTC_BOOTLOADER_FLAG:
 619:hardware.c    **** 			flagSet = 0x01;
 881              		.loc 1 619 0
 882 0028 0124     		movs	r4, #1
 883 002a 00E0     		b	.L70
 884              	.L72:
 620:hardware.c    **** 			break;
 621:hardware.c    **** 		case RTC_BOOTLOADER_JUST_UPLOADED:
 622:hardware.c    **** 			flagSet = 0x02;
 885              		.loc 1 622 0
 886 002c 0224     		movs	r4, #2
 887              	.L70:
 888              	.LVL58:
 623:hardware.c    **** 			break;		
 624:hardware.c    ****     }
 625:hardware.c    **** 
 626:hardware.c    **** 	if (flagSet!=0x00)
 627:hardware.c    **** 	{
 628:hardware.c    **** 		bkp10Write(0x0000);// Clear the flag
 889              		.loc 1 628 0
 890 002e 0020     		movs	r0, #0
 891 0030 FFF7FEFF 		bl	bkp10Write
 892              	.LVL59:
 629:hardware.c    **** 		// Disable clocks
 630:hardware.c    **** 		pRCC->APB1ENR &= ~(RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 893              		.loc 1 630 0
 894 0034 EB69     		ldr	r3, [r5, #28]
 895 0036 23F0C053 		bic	r3, r3, #402653184
 896 003a EB61     		str	r3, [r5, #28]
 897              	.LVL60:
 898              	.L73:
 631:hardware.c    **** 	}
 632:hardware.c    ****     return flagSet;
 633:hardware.c    **** }
 899              		.loc 1 633 0
 900 003c 2046     		mov	r0, r4
 901 003e 38BD     		pop	{r3, r4, r5, pc}
 902              	.L75:
 903              		.align	2
 904              	.L74:
 905 0040 00100240 		.word	1073876992
 906 0044 006C0040 		.word	1073769472
 907              		.cfi_endproc
 908              	.LFE18:
 910              		.section	.text.nvicInit,"ax",%progbits
 911              		.align	1
 912              		.global	nvicInit
 913              		.thumb
 914              		.thumb_func
 916              	nvicInit:
 917              	.LFB19:
 634:hardware.c    **** 
 635:hardware.c    **** void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
 918              		.loc 1 635 0
 919              		.cfi_startproc
 920              		@ args = 0, pretend = 0, frame = 0
 921              		@ frame_needed = 0, uses_anonymous_args = 0
 922              	.LVL61:
 636:hardware.c    ****     u32 tmppriority = 0x00;
 637:hardware.c    ****     u32 tmpreg      = 0x00;
 638:hardware.c    ****     u32 tmpmask     = 0x00;
 639:hardware.c    ****     u32 tmppre      = 0;
 640:hardware.c    ****     u32 tmpsub      = 0x0F;
 641:hardware.c    **** 
 642:hardware.c    ****     SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
 643:hardware.c    ****     NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
 644:hardware.c    **** 
 645:hardware.c    **** 
 646:hardware.c    ****     /* Compute the Corresponding IRQ Priority --------------------------------*/
 647:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 923              		.loc 1 647 0
 924 0000 184B     		ldr	r3, .L77
 635:hardware.c    **** void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
 925              		.loc 1 635 0
 926 0002 30B5     		push	{r4, r5, lr}
 927              		.cfi_def_cfa_offset 12
 928              		.cfi_offset 4, -12
 929              		.cfi_offset 5, -8
 930              		.cfi_offset 14, -4
 931              		.loc 1 647 0
 932 0004 DB68     		ldr	r3, [r3, #12]
 648:hardware.c    ****     tmppre = (0x4 - tmppriority);
 649:hardware.c    ****     tmpsub = tmpsub >> tmppriority;
 650:hardware.c    **** 
 651:hardware.c    ****     tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 933              		.loc 1 651 0
 934 0006 4478     		ldrb	r4, [r0, #1]	@ zero_extendqisi2
 647:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 935              		.loc 1 647 0
 936 0008 DB43     		mvns	r3, r3
 937 000a C3F30223 		ubfx	r3, r3, #8, #3
 938              	.LVL62:
 648:hardware.c    ****     tmppre = (0x4 - tmppriority);
 939              		.loc 1 648 0
 940 000e C3F10402 		rsb	r2, r3, #4
 941              	.LVL63:
 942              		.loc 1 651 0
 943 0012 04FA02F2 		lsl	r2, r4, r2
 944              	.LVL64:
 649:hardware.c    ****     tmpsub = tmpsub >> tmppriority;
 945              		.loc 1 649 0
 946 0016 0F24     		movs	r4, #15
 947 0018 DC40     		lsrs	r4, r4, r3
 948              	.LVL65:
 652:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 949              		.loc 1 652 0
 950 001a 8178     		ldrb	r1, [r0, #2]	@ zero_extendqisi2
 653:hardware.c    **** 
 654:hardware.c    ****     tmppriority = tmppriority << 0x04;
 655:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 951              		.loc 1 655 0
 952 001c 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 953              	.LVL66:
 652:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 954              		.loc 1 652 0
 955 001e 0C40     		ands	r4, r4, r1
 956              	.LVL67:
 957 0020 1443     		orrs	r4, r4, r2
 958              	.LVL68:
 959              		.loc 1 655 0
 960 0022 03F00301 		and	r1, r3, #3
 961 0026 C900     		lsls	r1, r1, #3
 654:hardware.c    ****     tmppriority = tmppriority << 0x04;
 962              		.loc 1 654 0
 963 0028 2401     		lsls	r4, r4, #4
 964              	.LVL69:
 656:hardware.c    **** 
 657:hardware.c    ****     tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 658:hardware.c    ****     tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 965              		.loc 1 658 0
 966 002a FF22     		movs	r2, #255
 655:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 967              		.loc 1 655 0
 968 002c 8C40     		lsls	r4, r4, r1
 969              	.LVL70:
 970              		.loc 1 658 0
 971 002e 8A40     		lsls	r2, r2, r1
 972 0030 03F0FC03 		and	r3, r3, #252
 973 0034 03F16043 		add	r3, r3, #-536870912
 974 0038 03F56143 		add	r3, r3, #57600
 657:hardware.c    ****     tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 975              		.loc 1 657 0
 976 003c D3F80053 		ldr	r5, [r3, #768]
 977              	.LVL71:
 659:hardware.c    ****     tmpreg &= ~tmpmask;
 978              		.loc 1 659 0
 979 0040 25EA0201 		bic	r1, r5, r2
 980              	.LVL72:
 660:hardware.c    ****     tmppriority &= tmpmask;
 981              		.loc 1 660 0
 982 0044 2240     		ands	r2, r2, r4
 983              	.LVL73:
 661:hardware.c    ****     tmpreg |= tmppriority;
 984              		.loc 1 661 0
 985 0046 0A43     		orrs	r2, r2, r1
 986              	.LVL74:
 662:hardware.c    **** 
 663:hardware.c    ****     rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
 987              		.loc 1 663 0
 988 0048 C3F80023 		str	r2, [r3, #768]
 989              	.LVL75:
 664:hardware.c    **** 
 665:hardware.c    ****     /* Enable the Selected IRQ Channels --------------------------------------*/
 666:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 990              		.loc 1 666 0
 991 004c 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 667:hardware.c    ****         (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 992              		.loc 1 667 0
 993 004e 0122     		movs	r2, #1
 994              	.LVL76:
 666:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 995              		.loc 1 666 0
 996 0050 5909     		lsrs	r1, r3, #5
 997              		.loc 1 667 0
 998 0052 03F01F03 		and	r3, r3, #31
 999 0056 02FA03F3 		lsl	r3, r2, r3
 666:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 1000              		.loc 1 666 0
 1001 005a 034A     		ldr	r2, .L77+4
 1002 005c 42F82130 		str	r3, [r2, r1, lsl #2]
 1003 0060 30BD     		pop	{r4, r5, pc}
 1004              	.L78:
 1005 0062 00BF     		.align	2
 1006              	.L77:
 1007 0064 00ED00E0 		.word	-536810240
 1008 0068 00E100E0 		.word	-536813312
 1009              		.cfi_endproc
 1010              	.LFE19:
 1012              		.section	.text.nvicDisableInterrupts,"ax",%progbits
 1013              		.align	1
 1014              		.global	nvicDisableInterrupts
 1015              		.thumb
 1016              		.thumb_func
 1018              	nvicDisableInterrupts:
 1019              	.LFB20:
 668:hardware.c    **** }
 669:hardware.c    **** 
 670:hardware.c    **** void nvicDisableInterrupts() {
 1020              		.loc 1 670 0
 1021              		.cfi_startproc
 1022              		@ args = 0, pretend = 0, frame = 0
 1023              		@ frame_needed = 0, uses_anonymous_args = 0
 1024              		@ link register save eliminated.
 1025              	.LVL77:
 671:hardware.c    ****     NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
 672:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1026              		.loc 1 672 0
 1027 0000 074B     		ldr	r3, .L80
 1028 0002 4FF0FF32 		mov	r2, #-1
 1029 0006 C3F88020 		str	r2, [r3, #128]
 673:hardware.c    ****     rNVIC->ICER[1] = 0xFFFFFFFF;
 1030              		.loc 1 673 0
 1031 000a C3F88420 		str	r2, [r3, #132]
 674:hardware.c    ****     rNVIC->ICPR[0] = 0xFFFFFFFF;
 1032              		.loc 1 674 0
 1033 000e C3F88021 		str	r2, [r3, #384]
 675:hardware.c    ****     rNVIC->ICPR[1] = 0xFFFFFFFF;
 1034              		.loc 1 675 0
 1035 0012 C3F88421 		str	r2, [r3, #388]
 676:hardware.c    **** 
 677:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1036              		.loc 1 677 0
 1037 0016 0422     		movs	r2, #4
 1038 0018 43F8F02C 		str	r2, [r3, #-240]
 1039 001c 7047     		bx	lr
 1040              	.L81:
 1041 001e 00BF     		.align	2
 1042              	.L80:
 1043 0020 00E100E0 		.word	-536813312
 1044              		.cfi_endproc
 1045              	.LFE20:
 1047              		.section	.text.jumpToUser,"ax",%progbits
 1048              		.align	1
 1049              		.global	jumpToUser
 1050              		.thumb
 1051              		.thumb_func
 1053              	jumpToUser:
 1054              	.LFB16:
 574:hardware.c    **** void jumpToUser(u32 usrAddr) {
 1055              		.loc 1 574 0
 1056              		.cfi_startproc
 1057              		@ args = 0, pretend = 0, frame = 0
 1058              		@ frame_needed = 0, uses_anonymous_args = 0
 1059              	.LVL78:
 1060 0000 10B5     		push	{r4, lr}
 1061              		.cfi_def_cfa_offset 8
 1062              		.cfi_offset 4, -8
 1063              		.cfi_offset 14, -4
 574:hardware.c    **** void jumpToUser(u32 usrAddr) {
 1064              		.loc 1 574 0
 1065 0002 0446     		mov	r4, r0
 581:hardware.c    ****     usbDsbISR();
 1066              		.loc 1 581 0
 1067 0004 FFF7FEFF 		bl	usbDsbISR
 1068              	.LVL79:
 582:hardware.c    ****     nvicDisableInterrupts();
 1069              		.loc 1 582 0
 1070 0008 FFF7FEFF 		bl	nvicDisableInterrupts
 1071              	.LVL80:
 585:hardware.c    **** 	usbDsbBus();
 1072              		.loc 1 585 0
 1073 000c FFF7FEFF 		bl	usbDsbBus
 1074              	.LVL81:
 589:hardware.c    ****     systemReset(); // resets clocks and periphs, not core regs
 1075              		.loc 1 589 0
 1076 0010 FFF7FEFF 		bl	systemReset
 1077              	.LVL82:
 591:hardware.c    ****     setMspAndJump(usrAddr);
 1078              		.loc 1 591 0
 1079 0014 2046     		mov	r0, r4
 592:hardware.c    **** }
 1080              		.loc 1 592 0
 1081 0016 BDE81040 		pop	{r4, lr}
 1082              	.LVL83:
 591:hardware.c    ****     setMspAndJump(usrAddr);
 1083              		.loc 1 591 0
 1084 001a FFF7FEBF 		b	setMspAndJump
 1085              	.LVL84:
 1086              		.cfi_endproc
 1087              	.LFE16:
 1089              		.section	.text.systemHardReset,"ax",%progbits
 1090              		.align	1
 1091              		.global	systemHardReset
 1092              		.thumb
 1093              		.thumb_func
 1095              	systemHardReset:
 1096              	.LFB21:
 678:hardware.c    **** }
 679:hardware.c    **** 
 680:hardware.c    **** void systemHardReset(void) {
 1097              		.loc 1 680 0
 1098              		.cfi_startproc
 1099              		@ args = 0, pretend = 0, frame = 0
 1100              		@ frame_needed = 0, uses_anonymous_args = 0
 1101              		@ link register save eliminated.
 1102              	.LVL85:
 681:hardware.c    ****     SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
 682:hardware.c    **** 
 683:hardware.c    ****     /* Reset  */
 684:hardware.c    ****     rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
 1103              		.loc 1 684 0
 1104 0000 024A     		ldr	r2, .L85
 1105 0002 034B     		ldr	r3, .L85+4
 1106 0004 DA60     		str	r2, [r3, #12]
 1107              	.L84:
 685:hardware.c    **** 
 686:hardware.c    ****     /*  should never get here */
 687:hardware.c    ****     while (1) {
 688:hardware.c    ****         asm volatile("nop");
 1108              		.loc 1 688 0 discriminator 1
 1109              	@ 688 "hardware.c" 1
 1110 0006 00BF     		nop
 1111              	@ 0 "" 2
 1112              		.thumb
 1113 0008 FDE7     		b	.L84
 1114              	.L86:
 1115 000a 00BF     		.align	2
 1116              	.L85:
 1117 000c 0400FA05 		.word	100270084
 1118 0010 00ED00E0 		.word	-536810240
 1119              		.cfi_endproc
 1120              	.LFE21:
 1122              		.section	.text.flashErasePage,"ax",%progbits
 1123              		.align	1
 1124              		.global	flashErasePage
 1125              		.thumb
 1126              		.thumb_func
 1128              	flashErasePage:
 1129              	.LFB22:
 689:hardware.c    ****     }
 690:hardware.c    **** }
 691:hardware.c    **** 
 692:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 1130              		.loc 1 692 0
 1131              		.cfi_startproc
 1132              		@ args = 0, pretend = 0, frame = 0
 1133              		@ frame_needed = 0, uses_anonymous_args = 0
 1134              	.LVL86:
 693:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1135              		.loc 1 693 0
 1136 0000 0A4B     		ldr	r3, .L92
 692:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 1137              		.loc 1 692 0
 1138 0002 10B5     		push	{r4, lr}
 1139              		.cfi_def_cfa_offset 8
 1140              		.cfi_offset 4, -8
 1141              		.cfi_offset 14, -4
 1142              		.loc 1 693 0
 1143 0004 1A68     		ldr	r2, [r3]
 1144              	.LVL87:
 694:hardware.c    ****     rwmVal = FLASH_CR_PER;
 695:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1145              		.loc 1 695 0
 1146 0006 0222     		movs	r2, #2
 1147 0008 1A60     		str	r2, [r3]
 1148              	.L89:
 696:hardware.c    **** 
 697:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1149              		.loc 1 697 0 discriminator 1
 1150 000a 094A     		ldr	r2, .L92+4
 1151 000c 1168     		ldr	r1, [r2]
 1152 000e 1446     		mov	r4, r2
 1153 0010 11F0010F 		tst	r1, #1
 1154 0014 F9D1     		bne	.L89
 698:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 1155              		.loc 1 698 0
 1156 0016 9060     		str	r0, [r2, #8]
 699:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 1157              		.loc 1 699 0
 1158 0018 4222     		movs	r2, #66
 1159 001a 1A60     		str	r2, [r3]
 1160              	.L91:
 700:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1161              		.loc 1 700 0 discriminator 1
 1162 001c 2268     		ldr	r2, [r4]
 1163 001e 12F00101 		ands	r1, r2, #1
 1164 0022 FBD1     		bne	.L91
 1165              	.LVL88:
 701:hardware.c    **** 
 702:hardware.c    ****     /* todo: verify the page was erased */
 703:hardware.c    **** 
 704:hardware.c    ****     rwmVal = 0x00;
 705:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1166              		.loc 1 705 0
 1167 0024 1960     		str	r1, [r3]
 706:hardware.c    **** 
 707:hardware.c    ****     return TRUE;
 708:hardware.c    **** }
 1168              		.loc 1 708 0
 1169 0026 0120     		movs	r0, #1
 1170              	.LVL89:
 1171 0028 10BD     		pop	{r4, pc}
 1172              	.L93:
 1173 002a 00BF     		.align	2
 1174              	.L92:
 1175 002c 10200240 		.word	1073881104
 1176 0030 0C200240 		.word	1073881100
 1177              		.cfi_endproc
 1178              	.LFE22:
 1180              		.section	.text.flashErasePages,"ax",%progbits
 1181              		.align	1
 1182              		.global	flashErasePages
 1183              		.thumb
 1184              		.thumb_func
 1186              	flashErasePages:
 1187              	.LFB23:
 709:hardware.c    **** bool flashErasePages(u32 pageAddr, u16 n) {
 1188              		.loc 1 709 0
 1189              		.cfi_startproc
 1190              		@ args = 0, pretend = 0, frame = 0
 1191              		@ frame_needed = 0, uses_anonymous_args = 0
 1192              	.LVL90:
 1193 0000 0139     		subs	r1, r1, #1
 1194              	.LVL91:
 1195 0002 38B5     		push	{r3, r4, r5, lr}
 1196              		.cfi_def_cfa_offset 16
 1197              		.cfi_offset 3, -16
 1198              		.cfi_offset 4, -12
 1199              		.cfi_offset 5, -8
 1200              		.cfi_offset 14, -4
 1201              		.loc 1 709 0
 1202 0004 0546     		mov	r5, r0
 1203 0006 8CB2     		uxth	r4, r1
 1204              	.LVL92:
 1205              	.L95:
 710:hardware.c    ****     while (n-- > 0) {
 1206              		.loc 1 710 0 discriminator 1
 1207 0008 4FF6FF73 		movw	r3, #65535
 1208 000c 9C42     		cmp	r4, r3
 1209 000e 0AD0     		beq	.L101
 711:hardware.c    ****         if (!flashErasePage(pageAddr + wTransferSize * n)) {
 1210              		.loc 1 711 0
 1211 0010 064B     		ldr	r3, .L102
 1212 0012 1868     		ldr	r0, [r3]
 1213 0014 00FB0450 		mla	r0, r0, r4, r5
 1214 0018 FFF7FEFF 		bl	flashErasePage
 1215              	.LVL93:
 1216 001c 013C     		subs	r4, r4, #1
 1217              	.LVL94:
 1218 001e A4B2     		uxth	r4, r4
 1219              	.LVL95:
 1220 0020 0028     		cmp	r0, #0
 1221 0022 F1D1     		bne	.L95
 1222 0024 00E0     		b	.L96
 1223              	.LVL96:
 1224              	.L101:
 712:hardware.c    ****             return FALSE;
 713:hardware.c    ****         }
 714:hardware.c    ****     }
 715:hardware.c    **** 
 716:hardware.c    ****     return TRUE;
 1225              		.loc 1 716 0
 1226 0026 0120     		movs	r0, #1
 1227              	.LVL97:
 1228              	.L96:
 717:hardware.c    **** }
 1229              		.loc 1 717 0
 1230 0028 38BD     		pop	{r3, r4, r5, pc}
 1231              	.LVL98:
 1232              	.L103:
 1233 002a 00BF     		.align	2
 1234              	.L102:
 1235 002c 00000000 		.word	wTransferSize
 1236              		.cfi_endproc
 1237              	.LFE23:
 1239              		.section	.text.flashWriteWord,"ax",%progbits
 1240              		.align	1
 1241              		.global	flashWriteWord
 1242              		.thumb
 1243              		.thumb_func
 1245              	flashWriteWord:
 1246              	.LFB24:
 718:hardware.c    **** 
 719:hardware.c    **** bool flashWriteWord(u32 addr, u32 word) {
 1247              		.loc 1 719 0
 1248              		.cfi_startproc
 1249              		@ args = 0, pretend = 0, frame = 8
 1250              		@ frame_needed = 0, uses_anonymous_args = 0
 1251              	.LVL99:
 1252 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 1253              		.cfi_def_cfa_offset 24
 1254              		.cfi_offset 0, -24
 1255              		.cfi_offset 1, -20
 1256              		.cfi_offset 2, -16
 1257              		.cfi_offset 4, -12
 1258              		.cfi_offset 5, -8
 1259              		.cfi_offset 14, -4
 720:hardware.c    ****     vu16 *flashAddr = (vu16 *)addr;
 721:hardware.c    ****     vu32 lhWord = (vu32)word & 0x0000FFFF;
 1260              		.loc 1 721 0
 1261 0002 8BB2     		uxth	r3, r1
 1262 0004 0093     		str	r3, [sp]
 722:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 1263              		.loc 1 722 0
 1264 0006 0B0C     		lsrs	r3, r1, #16
 1265 0008 0193     		str	r3, [sp, #4]
 723:hardware.c    **** 
 724:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1266              		.loc 1 724 0
 1267 000a 0E4B     		ldr	r3, .L111
 725:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 1268              		.loc 1 725 0
 1269 000c 0122     		movs	r2, #1
 724:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1270              		.loc 1 724 0
 1271 000e 1C68     		ldr	r4, [r3]
 1272              	.LVL100:
 1273              		.loc 1 725 0
 1274 0010 1A60     		str	r2, [r3]
 1275              	.L106:
 726:hardware.c    **** 
 727:hardware.c    ****     /* apparently we need not write to FLASH_AR and can
 728:hardware.c    ****        simply do a native write of a half word */
 729:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1276              		.loc 1 729 0 discriminator 1
 1277 0012 0D4A     		ldr	r2, .L111+4
 1278 0014 1568     		ldr	r5, [r2]
 1279 0016 ED07     		lsls	r5, r5, #31
 1280 0018 FBD4     		bmi	.L106
 730:hardware.c    ****     *(flashAddr + 0x01) = (vu16)hhWord;
 1281              		.loc 1 730 0
 1282 001a 019D     		ldr	r5, [sp, #4]
 1283 001c ADB2     		uxth	r5, r5
 1284 001e 4580     		strh	r5, [r0, #2]	@ movhi
 1285              	.L108:
 731:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1286              		.loc 1 731 0 discriminator 1
 1287 0020 1568     		ldr	r5, [r2]
 1288 0022 ED07     		lsls	r5, r5, #31
 1289 0024 FCD4     		bmi	.L108
 732:hardware.c    ****     *(flashAddr) = (vu16)lhWord;
 1290              		.loc 1 732 0
 1291 0026 009D     		ldr	r5, [sp]
 1292 0028 ADB2     		uxth	r5, r5
 1293 002a 0580     		strh	r5, [r0]	@ movhi
 1294              	.L110:
 733:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1295              		.loc 1 733 0 discriminator 1
 1296 002c 1568     		ldr	r5, [r2]
 1297 002e ED07     		lsls	r5, r5, #31
 1298 0030 FCD4     		bmi	.L110
 734:hardware.c    **** 
 735:hardware.c    ****     rwmVal &= 0xFFFFFFFE;
 1299              		.loc 1 735 0
 1300 0032 24F00102 		bic	r2, r4, #1
 1301              	.LVL101:
 736:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1302              		.loc 1 736 0
 1303 0036 1A60     		str	r2, [r3]
 737:hardware.c    **** 
 738:hardware.c    ****     /* verify the write */
 739:hardware.c    ****     if (*(vu32 *)addr != word) {
 1304              		.loc 1 739 0
 1305 0038 0068     		ldr	r0, [r0]
 1306              	.LVL102:
 740:hardware.c    ****         return FALSE;
 741:hardware.c    ****     }
 742:hardware.c    **** 
 743:hardware.c    ****     return TRUE;
 744:hardware.c    **** }
 1307              		.loc 1 744 0
 1308 003a 431A     		subs	r3, r0, r1
 1309 003c 5842     		rsbs	r0, r3, #0
 1310 003e 5841     		adcs	r0, r0, r3
 1311 0040 03B0     		add	sp, sp, #12
 1312              		@ sp needed
 1313 0042 30BD     		pop	{r4, r5, pc}
 1314              	.L112:
 1315              		.align	2
 1316              	.L111:
 1317 0044 10200240 		.word	1073881104
 1318 0048 0C200240 		.word	1073881100
 1319              		.cfi_endproc
 1320              	.LFE24:
 1322              		.section	.text.flashLock,"ax",%progbits
 1323              		.align	1
 1324              		.global	flashLock
 1325              		.thumb
 1326              		.thumb_func
 1328              	flashLock:
 1329              	.LFB25:
 745:hardware.c    **** 
 746:hardware.c    **** void flashLock() {
 1330              		.loc 1 746 0
 1331              		.cfi_startproc
 1332              		@ args = 0, pretend = 0, frame = 0
 1333              		@ frame_needed = 0, uses_anonymous_args = 0
 1334              		@ link register save eliminated.
 747:hardware.c    ****     /* take down the HSI oscillator? it may be in use elsewhere */
 748:hardware.c    **** 
 749:hardware.c    ****     /* ensure all FPEC functions disabled and lock the FPEC */
 750:hardware.c    ****     SET_REG(FLASH_CR, 0x00000080);
 1335              		.loc 1 750 0
 1336 0000 014B     		ldr	r3, .L114
 1337 0002 8022     		movs	r2, #128
 1338 0004 1A60     		str	r2, [r3]
 1339 0006 7047     		bx	lr
 1340              	.L115:
 1341              		.align	2
 1342              	.L114:
 1343 0008 10200240 		.word	1073881104
 1344              		.cfi_endproc
 1345              	.LFE25:
 1347              		.section	.text.flashUnlock,"ax",%progbits
 1348              		.align	1
 1349              		.global	flashUnlock
 1350              		.thumb
 1351              		.thumb_func
 1353              	flashUnlock:
 1354              	.LFB26:
 751:hardware.c    **** }
 752:hardware.c    **** 
 753:hardware.c    **** void flashUnlock() {
 1355              		.loc 1 753 0
 1356              		.cfi_startproc
 1357              		@ args = 0, pretend = 0, frame = 0
 1358              		@ frame_needed = 0, uses_anonymous_args = 0
 1359              		@ link register save eliminated.
 754:hardware.c    ****     /* unlock the flash */
 755:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY1);
 1360              		.loc 1 755 0
 1361 0000 034B     		ldr	r3, .L117
 1362 0002 044A     		ldr	r2, .L117+4
 1363 0004 1A60     		str	r2, [r3]
 756:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY2);
 1364              		.loc 1 756 0
 1365 0006 02F18832 		add	r2, r2, #-2004318072
 1366 000a 1A60     		str	r2, [r3]
 1367 000c 7047     		bx	lr
 1368              	.L118:
 1369 000e 00BF     		.align	2
 1370              	.L117:
 1371 0010 04200240 		.word	1073881092
 1372 0014 23016745 		.word	1164378403
 1373              		.cfi_endproc
 1374              	.LFE26:
 1376              		.section	.text.crMask,"ax",%progbits
 1377              		.align	1
 1378              		.global	crMask
 1379              		.thumb
 1380              		.thumb_func
 1382              	crMask:
 1383              	.LFB27:
 757:hardware.c    **** }
 758:hardware.c    **** 
 759:hardware.c    **** 
 760:hardware.c    **** // Used to create the control register masking pattern, when setting control register mode.
 761:hardware.c    **** unsigned int crMask(int pin)
 762:hardware.c    **** {
 1384              		.loc 1 762 0
 1385              		.cfi_startproc
 1386              		@ args = 0, pretend = 0, frame = 0
 1387              		@ frame_needed = 0, uses_anonymous_args = 0
 1388              		@ link register save eliminated.
 1389              	.LVL103:
 763:hardware.c    **** 	unsigned int mask;
 764:hardware.c    **** 	if (pin>=8)
 1390              		.loc 1 764 0
 1391 0000 0728     		cmp	r0, #7
 765:hardware.c    **** 	{
 766:hardware.c    **** 		pin-=8;
 1392              		.loc 1 766 0
 1393 0002 C8BF     		it	gt
 1394 0004 0838     		subgt	r0, r0, #8
 1395              	.LVL104:
 767:hardware.c    **** 	}
 768:hardware.c    **** 	mask = 0x0F << (pin<<2);
 1396              		.loc 1 768 0
 1397 0006 0F23     		movs	r3, #15
 1398 0008 8000     		lsls	r0, r0, #2
 1399              	.LVL105:
 1400 000a 03FA00F0 		lsl	r0, r3, r0
 1401              	.LVL106:
 769:hardware.c    **** 	return ~mask;
 770:hardware.c    **** }	
 1402              		.loc 1 770 0
 1403 000e C043     		mvns	r0, r0
 1404              	.LVL107:
 1405 0010 7047     		bx	lr
 1406              		.cfi_endproc
 1407              	.LFE27:
 1409              		.section	.text.getFlashEnd,"ax",%progbits
 1410              		.align	1
 1411              		.global	getFlashEnd
 1412              		.thumb
 1413              		.thumb_func
 1415              	getFlashEnd:
 1416              	.LFB28:
 771:hardware.c    **** 
 772:hardware.c    **** #define FLASH_SIZE_REG 0x1FFFF7E0
 773:hardware.c    **** int getFlashEnd(void)
 774:hardware.c    **** {
 1417              		.loc 1 774 0
 1418              		.cfi_startproc
 1419              		@ args = 0, pretend = 0, frame = 0
 1420              		@ frame_needed = 0, uses_anonymous_args = 0
 1421              		@ link register save eliminated.
 1422              	.LVL108:
 775:hardware.c    **** 	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
 776:hardware.c    **** 	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
 1423              		.loc 1 776 0
 1424 0000 024B     		ldr	r3, .L122
 1425 0002 1888     		ldrh	r0, [r3]
 1426 0004 00F50030 		add	r0, r0, #131072
 777:hardware.c    **** }
 1427              		.loc 1 777 0
 1428 0008 8002     		lsls	r0, r0, #10
 1429 000a 7047     		bx	lr
 1430              	.L123:
 1431              		.align	2
 1432              	.L122:
 1433 000c E0F7FF1F 		.word	536868832
 1434              		.cfi_endproc
 1435              	.LFE28:
 1437              		.section	.text.getFlashPageSize,"ax",%progbits
 1438              		.align	1
 1439              		.global	getFlashPageSize
 1440              		.thumb
 1441              		.thumb_func
 1443              	getFlashPageSize:
 1444              	.LFB29:
 778:hardware.c    **** 
 779:hardware.c    **** int getFlashPageSize(void)
 780:hardware.c    **** {
 1445              		.loc 1 780 0
 1446              		.cfi_startproc
 1447              		@ args = 0, pretend = 0, frame = 0
 1448              		@ frame_needed = 0, uses_anonymous_args = 0
 1449              		@ link register save eliminated.
 1450              	.LVL109:
 781:hardware.c    **** 
 782:hardware.c    **** 	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
 783:hardware.c    **** 	if ((*flashSize & 0xffff) > 128)
 1451              		.loc 1 783 0
 1452 0000 044B     		ldr	r3, .L127
 1453 0002 1B88     		ldrh	r3, [r3]
 784:hardware.c    **** 	{
 785:hardware.c    **** 		return 0x800;
 1454              		.loc 1 785 0
 1455 0004 812B     		cmp	r3, #129
 786:hardware.c    **** 	}
 787:hardware.c    **** 	else
 788:hardware.c    **** 	{
 789:hardware.c    **** 		return 0x400;
 790:hardware.c    **** 	}
 791:hardware.c    **** }
 1456              		.loc 1 791 0
 1457 0006 34BF     		ite	cc
 1458 0008 4FF48060 		movcc	r0, #1024
 1459 000c 4FF40060 		movcs	r0, #2048
 1460 0010 7047     		bx	lr
 1461              	.L128:
 1462 0012 00BF     		.align	2
 1463              	.L127:
 1464 0014 E0F7FF1F 		.word	536868832
 1465              		.cfi_endproc
 1466              	.LFE29:
 1468              		.comm	wTransferSize,4,4
 1469              		.text
 1470              	.Letext0:
 1471              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 1472              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 1473              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\mach
 1474              		.file 5 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdi
 1475              		.file 6 "./stm32_lib/stm32f10x_type.h"
 1476              		.file 7 "hardware.h"
 1477              		.file 8 "<built-in>"
 1478              		.file 9 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdi
 1479              		.file 10 "usb.h"
DEFINED SYMBOLS
                            *ABS*:00000000 hardware.c
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:19     .text.gpio_write_bit:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:24     .text.gpio_write_bit:00000000 gpio_write_bit
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:51     .text.readPin:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:56     .text.readPin:00000000 readPin
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:80     .text.strobePin:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:85     .text.strobePin:00000000 strobePin
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:176    .text.UU_PutChar:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:181    .text.UU_PutChar:00000000 UU_PutChar
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:201    .text.UU_PutString:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:206    .text.UU_PutString:00000000 UU_PutString
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:241    .text.vprint:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:246    .text.vprint:00000000 vprint
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:283    .text.vprint:00000024 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:288    .text.uart_printf:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:293    .text.uart_printf:00000000 uart_printf
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:330    .text.hexdump:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:335    .text.hexdump:00000000 hexdump
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:390    .text.uartInit:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:395    .text.uartInit:00000000 uartInit
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:487    .text.uartInit:00000084 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:492    .text.systemReset:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:497    .text.systemReset:00000000 systemReset
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:538    .text.systemReset:00000038 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:546    .text.setupCLK:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:551    .text.setupCLK:00000000 setupCLK
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:610    .text.setupCLK:00000058 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:616    .text.setupLEDAndButton:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:621    .text.setupLEDAndButton:00000000 setupLEDAndButton
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:639    .text.setupLEDAndButton:00000010 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:644    .text.setupFLASH:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:649    .text.setupFLASH:00000000 setupFLASH
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:682    .text.setupFLASH:00000018 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:687    .text.uid_read:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:692    .text.uid_read:00000000 uid_read
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:737    .text.checkUserCode:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:742    .text.checkUserCode:00000000 checkUserCode
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:758    .text.setMspAndJump:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:763    .text.setMspAndJump:00000000 setMspAndJump
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:796    .text.setMspAndJump:00000014 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:801    .text.bkp10Write:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:806    .text.bkp10Write:00000000 bkp10Write
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:835    .text.bkp10Write:00000024 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:841    .text.checkAndClearBootloaderFlag:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:846    .text.checkAndClearBootloaderFlag:00000000 checkAndClearBootloaderFlag
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:905    .text.checkAndClearBootloaderFlag:00000040 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:911    .text.nvicInit:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:916    .text.nvicInit:00000000 nvicInit
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1007   .text.nvicInit:00000064 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1013   .text.nvicDisableInterrupts:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1018   .text.nvicDisableInterrupts:00000000 nvicDisableInterrupts
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1043   .text.nvicDisableInterrupts:00000020 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1048   .text.jumpToUser:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1053   .text.jumpToUser:00000000 jumpToUser
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1090   .text.systemHardReset:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1095   .text.systemHardReset:00000000 systemHardReset
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1117   .text.systemHardReset:0000000c $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1123   .text.flashErasePage:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1128   .text.flashErasePage:00000000 flashErasePage
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1175   .text.flashErasePage:0000002c $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1181   .text.flashErasePages:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1186   .text.flashErasePages:00000000 flashErasePages
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1235   .text.flashErasePages:0000002c $d
                            *COM*:00000004 wTransferSize
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1240   .text.flashWriteWord:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1245   .text.flashWriteWord:00000000 flashWriteWord
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1317   .text.flashWriteWord:00000044 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1323   .text.flashLock:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1328   .text.flashLock:00000000 flashLock
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1343   .text.flashLock:00000008 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1348   .text.flashUnlock:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1353   .text.flashUnlock:00000000 flashUnlock
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1371   .text.flashUnlock:00000010 $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1377   .text.crMask:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1382   .text.crMask:00000000 crMask
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1410   .text.getFlashEnd:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1415   .text.getFlashEnd:00000000 getFlashEnd
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1433   .text.getFlashEnd:0000000c $d
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1438   .text.getFlashPageSize:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1443   .text.getFlashPageSize:00000000 getFlashPageSize
C:\Users\haifisch\AppData\Local\Temp\ccp0I6FJ.s:1464   .text.getFlashPageSize:00000014 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
vsprintf
memset
RCC_APB2PeriphClockCmd
GPIO_Init
USART_Init
USART_Cmd
usbDsbISR
usbDsbBus
