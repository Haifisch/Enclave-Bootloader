   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"hardware.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.gpio_write_bit,"ax",%progbits
  16              		.align	1
  17              		.global	gpio_write_bit
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	gpio_write_bit:
  24              	.LFB5:
  25              		.file 1 "hardware.c"
   1:hardware.c    **** /* *****************************************************************************
   2:hardware.c    ****  * The MIT License
   3:hardware.c    ****  *
   4:hardware.c    ****  * Copyright (c) 2010 LeafLabs LLC.
   5:hardware.c    ****  *
   6:hardware.c    ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:hardware.c    ****  * of this software and associated documentation files (the "Software"), to deal
   8:hardware.c    ****  * in the Software without restriction, including without limitation the rights
   9:hardware.c    ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:hardware.c    ****  * copies of the Software, and to permit persons to whom the Software is
  11:hardware.c    ****  * furnished to do so, subject to the following conditions:
  12:hardware.c    ****  *
  13:hardware.c    ****  * The above copyright notice and this permission notice shall be included in
  14:hardware.c    ****  * all copies or substantial portions of the Software.
  15:hardware.c    ****  *
  16:hardware.c    ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:hardware.c    ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:hardware.c    ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:hardware.c    ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:hardware.c    ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:hardware.c    ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:hardware.c    ****  * THE SOFTWARE.
  23:hardware.c    ****  * ****************************************************************************/
  24:hardware.c    **** 
  25:hardware.c    **** /**
  26:hardware.c    ****  *  @file hardware.c
  27:hardware.c    ****  *
  28:hardware.c    ****  *  @brief init routines to setup clocks, interrupts, also destructor functions.
  29:hardware.c    ****  *  does not include USB stuff. EEPROM read/write functions.
  30:hardware.c    ****  *
  31:hardware.c    ****  */
  32:hardware.c    **** #include <stdio.h>
  33:hardware.c    **** #include <stdint.h>
  34:hardware.c    **** #include <string.h>
  35:hardware.c    **** #include <limits.h>
  36:hardware.c    **** #include <unistd.h>
  37:hardware.c    **** #include <errno.h>
  38:hardware.c    **** #include <stdarg.h>
  39:hardware.c    **** 
  40:hardware.c    **** 
  41:hardware.c    **** #include "common.h"
  42:hardware.c    **** #include "hardware.h"
  43:hardware.c    **** #include "sha256.h"
  44:hardware.c    **** #include "edsign.h"
  45:hardware.c    **** #include "c25519.h"
  46:hardware.c    **** #include "image.h"
  47:hardware.c    **** #include "cencode.h"
  48:hardware.c    **** #include "cdecode.h"
  49:hardware.c    **** 
  50:hardware.c    **** /*
  51:hardware.c    **** void setPin(u32 bank, u8 pin) {
  52:hardware.c    ****     u32 pinMask = 0x1 << (pin);
  53:hardware.c    ****     SET_REG(GPIO_BSRR(bank), pinMask);
  54:hardware.c    **** }
  55:hardware.c    **** 
  56:hardware.c    **** void resetPin(u32 bank, u8 pin) {
  57:hardware.c    ****     u32 pinMask = 0x1 << (16 + pin);
  58:hardware.c    ****     SET_REG(GPIO_BSRR(bank), pinMask);
  59:hardware.c    **** }
  60:hardware.c    **** */
  61:hardware.c    **** void gpio_write_bit(u32 bank, u8 pin, u8 val) {
  26              		.loc 1 61 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31              	.LVL0:
  62:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
  32              		.loc 1 62 0
  33 0000 B2FA82F2 		clz	r2, r2
  34              	.LVL1:
  63:hardware.c    ****     SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
  35              		.loc 1 63 0
  36 0004 0123     		movs	r3, #1
  62:hardware.c    ****     val = !val;          // "set" bits are lower than "reset" bits  
  37              		.loc 1 62 0
  38 0006 5209     		lsrs	r2, r2, #5
  39              		.loc 1 63 0
  40 0008 03FA01F1 		lsl	r1, r3, r1
  41              	.LVL2:
  42 000c 1201     		lsls	r2, r2, #4
  43 000e 9140     		lsls	r1, r1, r2
  44 0010 0161     		str	r1, [r0, #16]
  64:hardware.c    **** }
  45              		.loc 1 64 0
  46 0012 7047     		bx	lr
  47              		.cfi_endproc
  48              	.LFE5:
  50              		.section	.text.readPin,"ax",%progbits
  51              		.align	1
  52              		.global	readPin
  53              		.syntax unified
  54              		.thumb
  55              		.thumb_func
  56              		.fpu softvfp
  58              	readPin:
  59              	.LFB6:
  65:hardware.c    **** 
  66:hardware.c    **** bool readPin(u32 bank, u8 pin) {
  60              		.loc 1 66 0
  61              		.cfi_startproc
  62              		@ args = 0, pretend = 0, frame = 0
  63              		@ frame_needed = 0, uses_anonymous_args = 0
  64              		@ link register save eliminated.
  65              	.LVL3:
  67:hardware.c    ****     // todo, implement read
  68:hardware.c    ****     if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
  66              		.loc 1 68 0
  67 0000 0123     		movs	r3, #1
  68 0002 8268     		ldr	r2, [r0, #8]
  69 0004 03FA01F1 		lsl	r1, r3, r1
  70              	.LVL4:
  71 0008 1142     		tst	r1, r2
  69:hardware.c    ****         return TRUE;
  70:hardware.c    ****     } else {
  71:hardware.c    ****         return FALSE;
  72:hardware.c    ****     }
  73:hardware.c    **** }
  72              		.loc 1 73 0
  73 000a 14BF     		ite	ne
  74 000c 1846     		movne	r0, r3
  75              	.LVL5:
  76 000e 0020     		moveq	r0, #0
  77 0010 7047     		bx	lr
  78              		.cfi_endproc
  79              	.LFE6:
  81              		.section	.text.strobePin,"ax",%progbits
  82              		.align	1
  83              		.global	strobePin
  84              		.syntax unified
  85              		.thumb
  86              		.thumb_func
  87              		.fpu softvfp
  89              	strobePin:
  90              	.LFB7:
  74:hardware.c    **** 
  75:hardware.c    **** void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
  76:hardware.c    **** {
  91              		.loc 1 76 0
  92              		.cfi_startproc
  93              		@ args = 4, pretend = 0, frame = 0
  94              		@ frame_needed = 0, uses_anonymous_args = 0
  95              	.LVL6:
  96 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
  97              		.cfi_def_cfa_offset 32
  98              		.cfi_offset 3, -32
  99              		.cfi_offset 4, -28
 100              		.cfi_offset 5, -24
 101              		.cfi_offset 6, -20
 102              		.cfi_offset 7, -16
 103              		.cfi_offset 8, -12
 104              		.cfi_offset 9, -8
 105              		.cfi_offset 14, -4
 106              		.loc 1 76 0
 107 0004 9DF82090 		ldrb	r9, [sp, #32]	@ zero_extendqisi2
 108 0008 1446     		mov	r4, r2
  77:hardware.c    ****   gpio_write_bit( bank,pin,1-onState);
 109              		.loc 1 77 0
 110 000a C9F10105 		rsb	r5, r9, #1
 111 000e EDB2     		uxtb	r5, r5
  76:hardware.c    ****   gpio_write_bit( bank,pin,1-onState);
 112              		.loc 1 76 0
 113 0010 0646     		mov	r6, r0
 114 0012 0F46     		mov	r7, r1
 115 0014 9846     		mov	r8, r3
 116              		.loc 1 77 0
 117 0016 2A46     		mov	r2, r5
 118              	.LVL7:
 119              	.L10:
  78:hardware.c    ****   u32 c;
  79:hardware.c    ****   while (count-- > 0) {
 120              		.loc 1 79 0
 121 0018 013C     		subs	r4, r4, #1
 122 001a E4B2     		uxtb	r4, r4
  80:hardware.c    ****     for (c = rate; c > 0; c--){
  81:hardware.c    ****       asm volatile("nop");
  82:hardware.c    ****     }
  83:hardware.c    ****     gpio_write_bit( bank,pin,onState);
  84:hardware.c    ****     for (c = rate; c > 0; c--) {
  85:hardware.c    ****       asm volatile("nop");
  86:hardware.c    ****     }
  87:hardware.c    ****     gpio_write_bit( bank,pin,1-onState);
 123              		.loc 1 87 0
 124 001c FFF7FEFF 		bl	gpio_write_bit
 125              	.LVL8:
  79:hardware.c    ****     for (c = rate; c > 0; c--){
 126              		.loc 1 79 0
 127 0020 FF2C     		cmp	r4, #255
 128 0022 10D1     		bne	.L9
  88:hardware.c    ****   }
  89:hardware.c    **** }
 129              		.loc 1 89 0
 130 0024 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 131              	.LVL9:
 132              	.L5:
  81:hardware.c    ****     }
 133              		.loc 1 81 0 discriminator 3
 134              		.syntax unified
 135              	@ 81 "hardware.c" 1
 136 0028 00BF     		nop
 137              	@ 0 "" 2
  80:hardware.c    ****       asm volatile("nop");
 138              		.loc 1 80 0 discriminator 3
 139              		.thumb
 140              		.syntax unified
 141 002a 013B     		subs	r3, r3, #1
 142              	.LVL10:
 143              	.L8:
  80:hardware.c    ****       asm volatile("nop");
 144              		.loc 1 80 0 is_stmt 0 discriminator 1
 145 002c 002B     		cmp	r3, #0
 146 002e FBD1     		bne	.L5
  83:hardware.c    ****     for (c = rate; c > 0; c--) {
 147              		.loc 1 83 0 is_stmt 1
 148 0030 4A46     		mov	r2, r9
 149 0032 3946     		mov	r1, r7
 150 0034 3046     		mov	r0, r6
 151              	.LVL11:
 152 0036 FFF7FEFF 		bl	gpio_write_bit
 153              	.LVL12:
  84:hardware.c    ****       asm volatile("nop");
 154              		.loc 1 84 0
 155 003a 4346     		mov	r3, r8
 156              	.LVL13:
 157              	.L6:
  84:hardware.c    ****       asm volatile("nop");
 158              		.loc 1 84 0 is_stmt 0 discriminator 1
 159 003c 2BB9     		cbnz	r3, .L7
  87:hardware.c    ****   }
 160              		.loc 1 87 0 is_stmt 1
 161 003e 2A46     		mov	r2, r5
 162 0040 3946     		mov	r1, r7
 163 0042 3046     		mov	r0, r6
 164              	.LVL14:
 165 0044 E8E7     		b	.L10
 166              	.LVL15:
 167              	.L9:
  80:hardware.c    ****       asm volatile("nop");
 168              		.loc 1 80 0
 169 0046 4346     		mov	r3, r8
 170 0048 F0E7     		b	.L8
 171              	.LVL16:
 172              	.L7:
  85:hardware.c    ****     }
 173              		.loc 1 85 0 discriminator 3
 174              		.syntax unified
 175              	@ 85 "hardware.c" 1
 176 004a 00BF     		nop
 177              	@ 0 "" 2
  84:hardware.c    ****       asm volatile("nop");
 178              		.loc 1 84 0 discriminator 3
 179              		.thumb
 180              		.syntax unified
 181 004c 013B     		subs	r3, r3, #1
 182              	.LVL17:
 183 004e F5E7     		b	.L6
 184              		.cfi_endproc
 185              	.LFE7:
 187              		.section	.text.UU_PutChar,"ax",%progbits
 188              		.align	1
 189              		.global	UU_PutChar
 190              		.syntax unified
 191              		.thumb
 192              		.thumb_func
 193              		.fpu softvfp
 195              	UU_PutChar:
 196              	.LFB8:
  90:hardware.c    **** 
  91:hardware.c    **** 
  92:hardware.c    **** typedef struct
  93:hardware.c    **** {
  94:hardware.c    ****   uint32_t USART_BaudRate;            /*!< This member configures the USART communication baud rate
  95:hardware.c    ****                                            The baud rate is computed using the following formula:
  96:hardware.c    ****                                             - IntegerDivider = ((PCLKx) / (16 * (USART_InitStruct->
  97:hardware.c    ****                                             - FractionalDivider = ((IntegerDivider - ((u32) Integer
  98:hardware.c    **** 
  99:hardware.c    ****   uint16_t USART_WordLength;          /*!< Specifies the number of data bits transmitted or receive
 100:hardware.c    ****                                            This parameter can be a value of @ref USART_Word_Length 
 101:hardware.c    **** 
 102:hardware.c    ****   uint16_t USART_StopBits;            /*!< Specifies the number of stop bits transmitted.
 103:hardware.c    ****                                            This parameter can be a value of @ref USART_Stop_Bits */
 104:hardware.c    **** 
 105:hardware.c    ****   uint16_t USART_Parity;              /*!< Specifies the parity mode.
 106:hardware.c    ****                                            This parameter can be a value of @ref USART_Parity
 107:hardware.c    ****                                            @note When parity is enabled, the computed parity is ins
 108:hardware.c    ****                                                  at the MSB position of the transmitted data (9th b
 109:hardware.c    ****                                                  the word length is set to 9 data bits; 8th bit whe
 110:hardware.c    ****                                                  word length is set to 8 data bits). */
 111:hardware.c    ****  
 112:hardware.c    ****   uint16_t USART_Mode;                /*!< Specifies wether the Receive or Transmit mode is enabled
 113:hardware.c    ****                                            This parameter can be a value of @ref USART_Mode */
 114:hardware.c    **** 
 115:hardware.c    ****   uint16_t USART_HardwareFlowControl; /*!< Specifies wether the hardware flow control mode is enabl
 116:hardware.c    ****                                            or disabled.
 117:hardware.c    ****                                            This parameter can be a value of @ref USART_Hardware_Flo
 118:hardware.c    **** } USART_InitTypeDef;
 119:hardware.c    **** 
 120:hardware.c    **** /** 
 121:hardware.c    ****   * @brief  USART Clock Init Structure definition  
 122:hardware.c    ****   */ 
 123:hardware.c    ****   
 124:hardware.c    **** typedef struct
 125:hardware.c    **** {
 126:hardware.c    **** 
 127:hardware.c    ****   uint16_t USART_Clock;   /*!< Specifies whether the USART clock is enabled or disabled.
 128:hardware.c    ****                                This parameter can be a value of @ref USART_Clock */
 129:hardware.c    **** 
 130:hardware.c    ****   uint16_t USART_CPOL;    /*!< Specifies the steady state value of the serial clock.
 131:hardware.c    ****                                This parameter can be a value of @ref USART_Clock_Polarity */
 132:hardware.c    **** 
 133:hardware.c    ****   uint16_t USART_CPHA;    /*!< Specifies the clock transition on which the bit capture is made.
 134:hardware.c    ****                                This parameter can be a value of @ref USART_Clock_Phase */
 135:hardware.c    **** 
 136:hardware.c    ****   uint16_t USART_LastBit; /*!< Specifies whether the clock pulse corresponding to the last transmit
 137:hardware.c    ****                                data bit (MSB) has to be output on the SCLK pin in synchronous mode.
 138:hardware.c    ****                                This parameter can be a value of @ref USART_Last_Bit */
 139:hardware.c    **** } USART_ClockInitTypeDef;
 140:hardware.c    **** 
 141:hardware.c    **** 
 142:hardware.c    **** typedef enum
 143:hardware.c    **** { 
 144:hardware.c    ****   GPIO_Speed_10MHz = 1,
 145:hardware.c    ****   GPIO_Speed_2MHz, 
 146:hardware.c    ****   GPIO_Speed_50MHz
 147:hardware.c    **** }GPIOSpeed_TypeDef;
 148:hardware.c    **** 
 149:hardware.c    **** typedef enum
 150:hardware.c    **** { GPIO_Mode_AIN = 0x0,
 151:hardware.c    ****   GPIO_Mode_IN_FLOATING = 0x04,
 152:hardware.c    ****   GPIO_Mode_IPD = 0x28,
 153:hardware.c    ****   GPIO_Mode_IPU = 0x48,
 154:hardware.c    ****   GPIO_Mode_Out_OD = 0x14,
 155:hardware.c    ****   GPIO_Mode_Out_PP = 0x10,
 156:hardware.c    ****   GPIO_Mode_AF_OD = 0x1C,
 157:hardware.c    ****   GPIO_Mode_AF_PP = 0x18
 158:hardware.c    **** }GPIOMode_TypeDef;
 159:hardware.c    **** 
 160:hardware.c    **** typedef struct
 161:hardware.c    **** {
 162:hardware.c    ****   uint16_t GPIO_Pin;             /*!< Specifies the GPIO pins to be configured.
 163:hardware.c    ****                                       This parameter can be any value of @ref GPIO_pins_define */
 164:hardware.c    **** 
 165:hardware.c    ****   GPIOSpeed_TypeDef GPIO_Speed;  /*!< Specifies the speed for the selected pins.
 166:hardware.c    ****                                       This parameter can be a value of @ref GPIOSpeed_TypeDef */
 167:hardware.c    **** 
 168:hardware.c    ****   GPIOMode_TypeDef GPIO_Mode;    /*!< Specifies the operating mode for the selected pins.
 169:hardware.c    ****                                       This parameter can be a value of @ref GPIOMode_TypeDef */
 170:hardware.c    **** }GPIO_InitTypeDef;
 171:hardware.c    **** 
 172:hardware.c    **** typedef struct
 173:hardware.c    **** {
 174:hardware.c    ****   __IO uint32_t CRL;
 175:hardware.c    ****   __IO uint32_t CRH;
 176:hardware.c    ****   __IO uint32_t IDR;
 177:hardware.c    ****   __IO uint32_t ODR;
 178:hardware.c    ****   __IO uint32_t BSRR;
 179:hardware.c    ****   __IO uint32_t BRR;
 180:hardware.c    ****   __IO uint32_t LCKR;
 181:hardware.c    **** } GPIO_TypeDef;
 182:hardware.c    **** #define PERIPH_BASE           ((uint32_t)0x40000000) /*!< Peripheral base address in the alias regi
 183:hardware.c    **** 
 184:hardware.c    **** #define PERIPH_BB_BASE        ((uint32_t)0x42000000) /*!< Peripheral base address in the bit-band r
 185:hardware.c    **** 
 186:hardware.c    **** #define FSMC_R_BASE           ((uint32_t)0xA0000000) /*!< FSMC registers base address */
 187:hardware.c    **** 
 188:hardware.c    **** /*!< Peripheral memory map */
 189:hardware.c    **** #define APB1PERIPH_BASE       PERIPH_BASE
 190:hardware.c    **** #define APB2PERIPH_BASE       (PERIPH_BASE + 0x10000)
 191:hardware.c    **** 
 192:hardware.c    **** #define USART1_BASE           (APB2PERIPH_BASE + 0x3800)
 193:hardware.c    **** #define USART1              ((USART_TypeDef *) USART1_BASE)
 194:hardware.c    **** 
 195:hardware.c    **** #define USART_WordLength_8b                  ((uint16_t)0x0000)
 196:hardware.c    **** #define USART_WordLength_9b                  ((uint16_t)0x1000)
 197:hardware.c    ****                                     
 198:hardware.c    **** #define IS_USART_WORD_LENGTH(LENGTH) (((LENGTH) == USART_WordLength_8b) || \
 199:hardware.c    ****                                       ((LENGTH) == USART_WordLength_9b))
 200:hardware.c    **** /**
 201:hardware.c    ****   * @}
 202:hardware.c    ****   */ 
 203:hardware.c    **** 
 204:hardware.c    **** /** @defgroup USART_Stop_Bits 
 205:hardware.c    ****   * @{
 206:hardware.c    ****   */ 
 207:hardware.c    ****   
 208:hardware.c    **** #define USART_StopBits_1                     ((uint16_t)0x0000)
 209:hardware.c    **** #define USART_StopBits_0_5                   ((uint16_t)0x1000)
 210:hardware.c    **** #define USART_StopBits_2                     ((uint16_t)0x2000)
 211:hardware.c    **** #define USART_StopBits_1_5                   ((uint16_t)0x3000)
 212:hardware.c    **** #define IS_USART_STOPBITS(STOPBITS) (((STOPBITS) == USART_StopBits_1) || \
 213:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_0_5) || \
 214:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_2) || \
 215:hardware.c    ****                                      ((STOPBITS) == USART_StopBits_1_5))
 216:hardware.c    **** /**
 217:hardware.c    ****   * @}
 218:hardware.c    ****   */ 
 219:hardware.c    **** 
 220:hardware.c    **** /** @defgroup USART_Parity 
 221:hardware.c    ****   * @{
 222:hardware.c    ****   */ 
 223:hardware.c    ****   
 224:hardware.c    **** #define USART_Parity_No                      ((uint16_t)0x0000)
 225:hardware.c    **** #define USART_Parity_Even                    ((uint16_t)0x0400)
 226:hardware.c    **** #define USART_Parity_Odd                     ((uint16_t)0x0600) 
 227:hardware.c    **** #define IS_USART_PARITY(PARITY) (((PARITY) == USART_Parity_No) || \
 228:hardware.c    ****                                  ((PARITY) == USART_Parity_Even) || \
 229:hardware.c    ****                                  ((PARITY) == USART_Parity_Odd))
 230:hardware.c    **** /**
 231:hardware.c    ****   * @}
 232:hardware.c    ****   */ 
 233:hardware.c    **** 
 234:hardware.c    **** /** @defgroup USART_Mode 
 235:hardware.c    ****   * @{
 236:hardware.c    ****   */ 
 237:hardware.c    ****   
 238:hardware.c    **** #define USART_Mode_Rx                        ((uint16_t)0x0004)
 239:hardware.c    **** #define USART_Mode_Tx                        ((uint16_t)0x0008)
 240:hardware.c    **** #define IS_USART_MODE(MODE) ((((MODE) & (uint16_t)0xFFF3) == 0x00) && ((MODE) != (uint16_t)0x00))
 241:hardware.c    **** /**
 242:hardware.c    ****   * @}
 243:hardware.c    ****   */ 
 244:hardware.c    **** 
 245:hardware.c    **** /** @defgroup USART_Hardware_Flow_Control 
 246:hardware.c    ****   * @{
 247:hardware.c    ****   */ 
 248:hardware.c    **** #define USART_HardwareFlowControl_None       ((uint16_t)0x0000)
 249:hardware.c    **** #define USART_HardwareFlowControl_RTS        ((uint16_t)0x0100)
 250:hardware.c    **** #define USART_HardwareFlowControl_CTS        ((uint16_t)0x0200)
 251:hardware.c    **** #define USART_HardwareFlowControl_RTS_CTS    ((uint16_t)0x0300)
 252:hardware.c    **** #define IS_USART_HARDWARE_FLOW_CONTROL(CONTROL)\
 253:hardware.c    ****                               (((CONTROL) == USART_HardwareFlowControl_None) || \
 254:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_RTS) || \
 255:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_CTS) || \
 256:hardware.c    ****                                ((CONTROL) == USART_HardwareFlowControl_RTS_CTS))
 257:hardware.c    **** /**
 258:hardware.c    ****   * @}
 259:hardware.c    ****   */ 
 260:hardware.c    **** 
 261:hardware.c    **** /** @defgroup USART_Clock 
 262:hardware.c    ****   * @{
 263:hardware.c    ****   */ 
 264:hardware.c    **** #define USART_Clock_Disable                  ((uint16_t)0x0000)
 265:hardware.c    **** #define USART_Clock_Enable                   ((uint16_t)0x0800)
 266:hardware.c    **** #define IS_USART_CLOCK(CLOCK) (((CLOCK) == USART_Clock_Disable) || \
 267:hardware.c    ****                                ((CLOCK) == USART_Clock_Enable))
 268:hardware.c    **** /**
 269:hardware.c    ****   * @}
 270:hardware.c    ****   */ 
 271:hardware.c    **** 
 272:hardware.c    **** extern void RCC_APB2PeriphClockCmd(uint32_t RCC_APB2Periph, FunctionalState NewState);
 273:hardware.c    **** extern void GPIO_Init(GPIO_TypeDef* GPIOx, GPIO_InitTypeDef* GPIO_InitStruct);
 274:hardware.c    **** #define RCC_APB2Periph_USART1            ((uint32_t)0x00004000)
 275:hardware.c    **** #define RCC_APB2Periph_GPIOA             ((uint32_t)0x00000004)
 276:hardware.c    **** #define RCC_APB2Periph_AFIO              ((uint32_t)0x00000001)
 277:hardware.c    **** #define GPIO_Pin_9                 ((uint16_t)0x0200)  /*!< Pin 9 selected */
 278:hardware.c    **** #define GPIO_Pin_10                ((uint16_t)0x0400)  /*!< Pin 10 selected */
 279:hardware.c    **** 
 280:hardware.c    **** #define  USART_SR_TXE                        ((uint16_t)0x0080)            /*!< Transmit Data Regis
 281:hardware.c    **** 
 282:hardware.c    **** //DebugLog
 283:hardware.c    **** #ifdef DEBUG
 284:hardware.c    **** void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
 285:hardware.c    **** {
 197              		.loc 1 285 0
 198              		.cfi_startproc
 199              		@ args = 0, pretend = 0, frame = 0
 200              		@ frame_needed = 0, uses_anonymous_args = 0
 201              		@ link register save eliminated.
 202              	.LVL18:
 203              	.L12:
 286:hardware.c    ****   while(!(USARTx->SR & USART_SR_TXE));
 204              		.loc 1 286 0 discriminator 1
 205 0000 0388     		ldrh	r3, [r0]
 206 0002 1B06     		lsls	r3, r3, #24
 207 0004 FCD5     		bpl	.L12
 287:hardware.c    ****   USARTx->DR = ch;  
 208              		.loc 1 287 0
 209 0006 89B2     		uxth	r1, r1
 210              	.LVL19:
 211 0008 8180     		strh	r1, [r0, #4]	@ movhi
 288:hardware.c    **** }
 212              		.loc 1 288 0
 213 000a 7047     		bx	lr
 214              		.cfi_endproc
 215              	.LFE8:
 217              		.section	.text.UU_PutString,"ax",%progbits
 218              		.align	1
 219              		.global	UU_PutString
 220              		.syntax unified
 221              		.thumb
 222              		.thumb_func
 223              		.fpu softvfp
 225              	UU_PutString:
 226              	.LFB9:
 289:hardware.c    **** 
 290:hardware.c    **** void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
 291:hardware.c    **** {
 227              		.loc 1 291 0
 228              		.cfi_startproc
 229              		@ args = 0, pretend = 0, frame = 0
 230              		@ frame_needed = 0, uses_anonymous_args = 0
 231              	.LVL20:
 232 0000 10B5     		push	{r4, lr}
 233              		.cfi_def_cfa_offset 8
 234              		.cfi_offset 4, -8
 235              		.cfi_offset 14, -4
 236              		.loc 1 291 0
 237 0002 0446     		mov	r4, r0
 238 0004 4A1E     		subs	r2, r1, #1
 239              	.LVL21:
 240              	.L16:
 292:hardware.c    ****   while(*str != 0)
 241              		.loc 1 292 0
 242 0006 12F8011F 		ldrb	r1, [r2, #1]!	@ zero_extendqisi2
 243              	.LVL22:
 244 000a 01B9     		cbnz	r1, .L17
 293:hardware.c    ****   {
 294:hardware.c    ****     UU_PutChar(USARTx, *str);
 295:hardware.c    ****     str++;
 296:hardware.c    ****   }
 297:hardware.c    **** }
 245              		.loc 1 297 0
 246 000c 10BD     		pop	{r4, pc}
 247              	.L17:
 294:hardware.c    ****     str++;
 248              		.loc 1 294 0
 249 000e 2046     		mov	r0, r4
 250              	.LVL23:
 251 0010 FFF7FEFF 		bl	UU_PutChar
 252              	.LVL24:
 253 0014 F7E7     		b	.L16
 254              		.cfi_endproc
 255              	.LFE9:
 257              		.section	.text.vprint,"ax",%progbits
 258              		.align	1
 259              		.global	vprint
 260              		.syntax unified
 261              		.thumb
 262              		.thumb_func
 263              		.fpu softvfp
 265              	vprint:
 266              	.LFB10:
 298:hardware.c    **** 
 299:hardware.c    **** void vprint(const char *fmt, va_list argp)
 300:hardware.c    **** {
 267              		.loc 1 300 0
 268              		.cfi_startproc
 269              		@ args = 0, pretend = 0, frame = 200
 270              		@ frame_needed = 0, uses_anonymous_args = 0
 271              	.LVL25:
 272 0000 00B5     		push	{lr}
 273              		.cfi_def_cfa_offset 4
 274              		.cfi_offset 14, -4
 275 0002 B3B0     		sub	sp, sp, #204
 276              		.cfi_def_cfa_offset 208
 301:hardware.c    ****     char string[200];
 302:hardware.c    ****     if(0 < vsprintf(string,fmt,argp)) // build string
 277              		.loc 1 302 0
 278 0004 0A46     		mov	r2, r1
 279 0006 0146     		mov	r1, r0
 280              	.LVL26:
 281 0008 6846     		mov	r0, sp
 282              	.LVL27:
 283 000a FFF7FEFF 		bl	vsprintf
 284              	.LVL28:
 285 000e 0028     		cmp	r0, #0
 286 0010 03DD     		ble	.L18
 303:hardware.c    ****     {
 304:hardware.c    ****         UU_PutString(USART1, (uint8_t*)string); // send message via UART
 287              		.loc 1 304 0
 288 0012 6946     		mov	r1, sp
 289 0014 0248     		ldr	r0, .L20
 290 0016 FFF7FEFF 		bl	UU_PutString
 291              	.LVL29:
 292              	.L18:
 305:hardware.c    ****     }
 306:hardware.c    **** }
 293              		.loc 1 306 0
 294 001a 33B0     		add	sp, sp, #204
 295              		.cfi_def_cfa_offset 4
 296              		@ sp needed
 297 001c 5DF804FB 		ldr	pc, [sp], #4
 298              	.L21:
 299              		.align	2
 300              	.L20:
 301 0020 00380140 		.word	1073821696
 302              		.cfi_endproc
 303              	.LFE10:
 305              		.section	.text.uart_printf,"ax",%progbits
 306              		.align	1
 307              		.global	uart_printf
 308              		.syntax unified
 309              		.thumb
 310              		.thumb_func
 311              		.fpu softvfp
 313              	uart_printf:
 314              	.LFB11:
 307:hardware.c    **** 
 308:hardware.c    **** void uart_printf(const char *fmt, ...) // custom printf() function
 309:hardware.c    **** {
 315              		.loc 1 309 0
 316              		.cfi_startproc
 317              		@ args = 4, pretend = 16, frame = 8
 318              		@ frame_needed = 0, uses_anonymous_args = 1
 319              	.LVL30:
 320 0000 0FB4     		push	{r0, r1, r2, r3}
 321              		.cfi_def_cfa_offset 16
 322              		.cfi_offset 0, -16
 323              		.cfi_offset 1, -12
 324              		.cfi_offset 2, -8
 325              		.cfi_offset 3, -4
 326 0002 07B5     		push	{r0, r1, r2, lr}
 327              		.cfi_def_cfa_offset 32
 328              		.cfi_offset 14, -20
 329              		.loc 1 309 0
 330 0004 04A9     		add	r1, sp, #16
 331 0006 51F8040B 		ldr	r0, [r1], #4
 310:hardware.c    ****     va_list argp;
 311:hardware.c    ****     va_start(argp, fmt);
 332              		.loc 1 311 0
 333 000a 0191     		str	r1, [sp, #4]
 312:hardware.c    ****     vprint(fmt, argp);
 334              		.loc 1 312 0
 335 000c FFF7FEFF 		bl	vprint
 336              	.LVL31:
 313:hardware.c    ****     va_end(argp);
 314:hardware.c    **** }
 337              		.loc 1 314 0
 338 0010 03B0     		add	sp, sp, #12
 339              		.cfi_def_cfa_offset 20
 340              		@ sp needed
 341 0012 5DF804EB 		ldr	lr, [sp], #4
 342              		.cfi_restore 14
 343              		.cfi_def_cfa_offset 16
 344 0016 04B0     		add	sp, sp, #16
 345              		.cfi_restore 3
 346              		.cfi_restore 2
 347              		.cfi_restore 1
 348              		.cfi_restore 0
 349              		.cfi_def_cfa_offset 0
 350 0018 7047     		bx	lr
 351              		.cfi_endproc
 352              	.LFE11:
 354              		.section	.text.print_hex,"ax",%progbits
 355              		.align	1
 356              		.global	print_hex
 357              		.syntax unified
 358              		.thumb
 359              		.thumb_func
 360              		.fpu softvfp
 362              	print_hex:
 363              	.LFB12:
 315:hardware.c    **** 
 316:hardware.c    **** void print_hex(const char *label, const uint8_t *data, int len)
 317:hardware.c    **** {
 364              		.loc 1 317 0
 365              		.cfi_startproc
 366              		@ args = 0, pretend = 0, frame = 0
 367              		@ frame_needed = 0, uses_anonymous_args = 0
 368              	.LVL32:
 369 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 370              		.cfi_def_cfa_offset 24
 371              		.cfi_offset 3, -24
 372              		.cfi_offset 4, -20
 373              		.cfi_offset 5, -16
 374              		.cfi_offset 6, -12
 375              		.cfi_offset 7, -8
 376              		.cfi_offset 14, -4
 377              		.loc 1 317 0
 378 0002 0D46     		mov	r5, r1
 318:hardware.c    ****     int i;
 319:hardware.c    **** 
 320:hardware.c    ****     uart_printf("%s: ", label);
 379              		.loc 1 320 0
 380 0004 0146     		mov	r1, r0
 381              	.LVL33:
 382 0006 0A48     		ldr	r0, .L26
 383              	.LVL34:
 317:hardware.c    ****     int i;
 384              		.loc 1 317 0
 385 0008 1646     		mov	r6, r2
 321:hardware.c    ****     for (i = 0; i < len; i++)
 386              		.loc 1 321 0
 387 000a 2C46     		mov	r4, r5
 320:hardware.c    ****     for (i = 0; i < len; i++)
 388              		.loc 1 320 0
 389 000c FFF7FEFF 		bl	uart_printf
 390              	.LVL35:
 322:hardware.c    ****         uart_printf("%02x", data[i]);
 391              		.loc 1 322 0
 392 0010 084F     		ldr	r7, .L26+4
 393              	.LVL36:
 394              	.L24:
 321:hardware.c    ****     for (i = 0; i < len; i++)
 395              		.loc 1 321 0 discriminator 1
 396 0012 631B     		subs	r3, r4, r5
 397 0014 9E42     		cmp	r6, r3
 398 0016 04DC     		bgt	.L25
 323:hardware.c    ****     uart_printf("\n");
 324:hardware.c    **** }
 399              		.loc 1 324 0
 400 0018 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 401              		.cfi_remember_state
 402              		.cfi_restore 14
 403              		.cfi_restore 7
 404              		.cfi_restore 6
 405              		.cfi_restore 5
 406              		.cfi_restore 4
 407              		.cfi_restore 3
 408              		.cfi_def_cfa_offset 0
 409              	.LVL37:
 323:hardware.c    ****     uart_printf("\n");
 410              		.loc 1 323 0
 411 001c 0648     		ldr	r0, .L26+8
 412 001e FFF7FEBF 		b	uart_printf
 413              	.LVL38:
 414              	.L25:
 415              		.cfi_restore_state
 322:hardware.c    ****         uart_printf("%02x", data[i]);
 416              		.loc 1 322 0 discriminator 3
 417 0022 14F8011B 		ldrb	r1, [r4], #1	@ zero_extendqisi2
 418              	.LVL39:
 419 0026 3846     		mov	r0, r7
 420 0028 FFF7FEFF 		bl	uart_printf
 421              	.LVL40:
 422 002c F1E7     		b	.L24
 423              	.L27:
 424 002e 00BF     		.align	2
 425              	.L26:
 426 0030 00000000 		.word	.LC0
 427 0034 05000000 		.word	.LC1
 428 0038 0A000000 		.word	.LC2
 429              		.cfi_endproc
 430              	.LFE12:
 432              		.section	.text.hexdump,"ax",%progbits
 433              		.align	1
 434              		.global	hexdump
 435              		.syntax unified
 436              		.thumb
 437              		.thumb_func
 438              		.fpu softvfp
 440              	hexdump:
 441              	.LFB13:
 325:hardware.c    **** 
 326:hardware.c    **** void hexdump(unsigned char *data, size_t size)
 327:hardware.c    **** {
 442              		.loc 1 327 0
 443              		.cfi_startproc
 444              		@ args = 0, pretend = 0, frame = 24
 445              		@ frame_needed = 0, uses_anonymous_args = 0
 446              	.LVL41:
 447 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 448              		.cfi_def_cfa_offset 32
 449              		.cfi_offset 4, -32
 450              		.cfi_offset 5, -28
 451              		.cfi_offset 6, -24
 452              		.cfi_offset 7, -20
 453              		.cfi_offset 8, -16
 454              		.cfi_offset 9, -12
 455              		.cfi_offset 10, -8
 456              		.cfi_offset 14, -4
 457 0004 86B0     		sub	sp, sp, #24
 458              		.cfi_def_cfa_offset 56
 459              		.loc 1 327 0
 460 0006 0546     		mov	r5, r0
 461 0008 0E46     		mov	r6, r1
 328:hardware.c    ****     int i;
 329:hardware.c    ****     char cs[17];
 330:hardware.c    ****     memset(cs, 0, 17);
 462              		.loc 1 330 0
 463 000a 1122     		movs	r2, #17
 464 000c 0021     		movs	r1, #0
 465              	.LVL42:
 466 000e 01A8     		add	r0, sp, #4
 467              	.LVL43:
 468 0010 FFF7FEFF 		bl	memset
 469              	.LVL44:
 331:hardware.c    **** 
 332:hardware.c    ****     for(i = 0; i < size; i++)
 470              		.loc 1 332 0
 471 0014 4FF0000A 		mov	r10, #0
 333:hardware.c    ****     {
 334:hardware.c    ****         if(i != 0 && i % 0x10 == 0)
 335:hardware.c    ****         {
 336:hardware.c    ****             debug_print(" |%s|\n", cs);
 337:hardware.c    ****             memset(cs, 0, 17);
 338:hardware.c    ****         }
 339:hardware.c    ****         else if(i != 0 && i % 0x8 == 0)
 340:hardware.c    ****         {
 341:hardware.c    ****             debug_print(" ",0);
 472              		.loc 1 341 0
 473 0018 234F     		ldr	r7, .L44
 336:hardware.c    ****             memset(cs, 0, 17);
 474              		.loc 1 336 0
 475 001a DFF89080 		ldr	r8, .L44+4
 342:hardware.c    ****         }
 343:hardware.c    ****         debug_print("%02X ", data[i]);
 476              		.loc 1 343 0
 477 001e DFF89490 		ldr	r9, .L44+12
 478 0022 013D     		subs	r5, r5, #1
 479              	.LVL45:
 480              	.L29:
 332:hardware.c    ****     {
 481              		.loc 1 332 0 discriminator 2
 482 0024 B245     		cmp	r10, r6
 483 0026 0AF00F04 		and	r4, r10, #15
 484 002a 07D1     		bne	.L33
 485              	.LVL46:
 344:hardware.c    ****         cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
 345:hardware.c    ****     }
 346:hardware.c    **** 
 347:hardware.c    ****     i = i % 0x10;
 348:hardware.c    ****     if(i != 0)
 486              		.loc 1 348 0
 487 002c 64BB     		cbnz	r4, .L34
 488              	.L38:
 349:hardware.c    ****     {
 350:hardware.c    ****         if(i <= 0x8)
 351:hardware.c    ****         {
 352:hardware.c    ****             debug_print(" ",0);
 353:hardware.c    ****         }
 354:hardware.c    ****         while(i++ < 0x10)
 355:hardware.c    ****         {
 356:hardware.c    ****             debug_print("   ",0);
 357:hardware.c    ****         }
 358:hardware.c    ****     }
 359:hardware.c    ****     debug_print(" |%s|\n", cs);
 489              		.loc 1 359 0
 490 002e 01A9     		add	r1, sp, #4
 491 0030 1E48     		ldr	r0, .L44+4
 492 0032 FFF7FEFF 		bl	uart_printf
 493              	.LVL47:
 360:hardware.c    **** }
 494              		.loc 1 360 0
 495 0036 06B0     		add	sp, sp, #24
 496              		.cfi_remember_state
 497              		.cfi_def_cfa_offset 32
 498              		@ sp needed
 499 0038 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 500              	.LVL48:
 501              	.L33:
 502              		.cfi_restore_state
 334:hardware.c    ****         {
 503              		.loc 1 334 0
 504 003c BAF1000F 		cmp	r10, #0
 505 0040 09D0     		beq	.L30
 334:hardware.c    ****         {
 506              		.loc 1 334 0 is_stmt 0 discriminator 1
 507 0042 D4B9     		cbnz	r4, .L31
 336:hardware.c    ****             memset(cs, 0, 17);
 508              		.loc 1 336 0 is_stmt 1 discriminator 1
 509 0044 01A9     		add	r1, sp, #4
 510 0046 4046     		mov	r0, r8
 511 0048 FFF7FEFF 		bl	uart_printf
 512              	.LVL49:
 337:hardware.c    ****         }
 513              		.loc 1 337 0 discriminator 1
 514 004c 1122     		movs	r2, #17
 515 004e 2146     		mov	r1, r4
 516 0050 01A8     		add	r0, sp, #4
 517 0052 FFF7FEFF 		bl	memset
 518              	.LVL50:
 519              	.L30:
 343:hardware.c    ****         cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
 520              		.loc 1 343 0 discriminator 1
 521 0056 15F8011F 		ldrb	r1, [r5, #1]!	@ zero_extendqisi2
 522 005a 4846     		mov	r0, r9
 523 005c FFF7FEFF 		bl	uart_printf
 524              	.LVL51:
 344:hardware.c    ****     }
 525              		.loc 1 344 0 discriminator 1
 526 0060 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 332:hardware.c    ****     {
 527              		.loc 1 332 0 discriminator 1
 528 0062 0AF1010A 		add	r10, r10, #1
 529              	.LVL52:
 344:hardware.c    ****     }
 530              		.loc 1 344 0 discriminator 1
 531 0066 A3F12002 		sub	r2, r3, #32
 532 006a 5E2A     		cmp	r2, #94
 533 006c 88BF     		it	hi
 534 006e 2E23     		movhi	r3, #46
 535 0070 06AA     		add	r2, sp, #24
 536 0072 1444     		add	r4, r4, r2
 537 0074 04F8143C 		strb	r3, [r4, #-20]
 538 0078 D4E7     		b	.L29
 539              	.L31:
 339:hardware.c    ****         {
 540              		.loc 1 339 0 discriminator 1
 541 007a 1AF00701 		ands	r1, r10, #7
 542 007e EAD1     		bne	.L30
 341:hardware.c    ****         }
 543              		.loc 1 341 0 discriminator 1
 544 0080 3846     		mov	r0, r7
 545 0082 FFF7FEFF 		bl	uart_printf
 546              	.LVL53:
 547 0086 E6E7     		b	.L30
 548              	.LVL54:
 549              	.L34:
 350:hardware.c    ****         {
 550              		.loc 1 350 0
 551 0088 082C     		cmp	r4, #8
 552 008a 03DC     		bgt	.L35
 352:hardware.c    ****         }
 553              		.loc 1 352 0 discriminator 1
 554 008c 0021     		movs	r1, #0
 555 008e 0648     		ldr	r0, .L44
 556 0090 FFF7FEFF 		bl	uart_printf
 557              	.LVL55:
 558              	.L35:
 356:hardware.c    ****         }
 559              		.loc 1 356 0
 560 0094 064D     		ldr	r5, .L44+8
 561              	.L36:
 354:hardware.c    ****         {
 562              		.loc 1 354 0
 563 0096 0134     		adds	r4, r4, #1
 564              	.LVL56:
 565 0098 112C     		cmp	r4, #17
 566 009a C8D0     		beq	.L38
 356:hardware.c    ****         }
 567              		.loc 1 356 0 discriminator 1
 568 009c 0021     		movs	r1, #0
 569 009e 2846     		mov	r0, r5
 570 00a0 FFF7FEFF 		bl	uart_printf
 571              	.LVL57:
 572 00a4 F7E7     		b	.L36
 573              	.L45:
 574 00a6 00BF     		.align	2
 575              	.L44:
 576 00a8 07000000 		.word	.LC4
 577 00ac 00000000 		.word	.LC3
 578 00b0 0F000000 		.word	.LC6
 579 00b4 09000000 		.word	.LC5
 580              		.cfi_endproc
 581              	.LFE13:
 583              		.section	.text.print_hash,"ax",%progbits
 584              		.align	1
 585              		.global	print_hash
 586              		.syntax unified
 587              		.thumb
 588              		.thumb_func
 589              		.fpu softvfp
 591              	print_hash:
 592              	.LFB14:
 361:hardware.c    **** 
 362:hardware.c    **** void print_hash(unsigned char hash[])
 363:hardware.c    **** {
 593              		.loc 1 363 0
 594              		.cfi_startproc
 595              		@ args = 0, pretend = 0, frame = 0
 596              		@ frame_needed = 0, uses_anonymous_args = 0
 597              	.LVL58:
 598 0000 70B5     		push	{r4, r5, r6, lr}
 599              		.cfi_def_cfa_offset 16
 600              		.cfi_offset 4, -16
 601              		.cfi_offset 5, -12
 602              		.cfi_offset 6, -8
 603              		.cfi_offset 14, -4
 364:hardware.c    ****    int idx;
 365:hardware.c    ****    for (idx=0; idx < 32; idx++)
 366:hardware.c    ****       debug_print("%02x",hash[idx]);
 604              		.loc 1 366 0
 605 0002 084E     		ldr	r6, .L49
 606 0004 451E     		subs	r5, r0, #1
 607 0006 00F11F04 		add	r4, r0, #31
 608              	.LVL59:
 609              	.L47:
 610              		.loc 1 366 0 is_stmt 0 discriminator 1
 611 000a 15F8011F 		ldrb	r1, [r5, #1]!	@ zero_extendqisi2
 612              	.LVL60:
 613 000e 3046     		mov	r0, r6
 614 0010 FFF7FEFF 		bl	uart_printf
 615              	.LVL61:
 365:hardware.c    ****       debug_print("%02x",hash[idx]);
 616              		.loc 1 365 0 is_stmt 1 discriminator 1
 617 0014 A542     		cmp	r5, r4
 618 0016 F8D1     		bne	.L47
 367:hardware.c    ****    debug_print("\n", 0);
 619              		.loc 1 367 0 discriminator 1
 620 0018 0021     		movs	r1, #0
 368:hardware.c    **** }
 621              		.loc 1 368 0 discriminator 1
 622 001a BDE87040 		pop	{r4, r5, r6, lr}
 623              		.cfi_restore 14
 624              		.cfi_restore 6
 625              		.cfi_restore 5
 626              		.cfi_restore 4
 627              		.cfi_def_cfa_offset 0
 628              	.LVL62:
 367:hardware.c    ****    debug_print("\n", 0);
 629              		.loc 1 367 0 discriminator 1
 630 001e 0248     		ldr	r0, .L49+4
 631 0020 FFF7FEBF 		b	uart_printf
 632              	.LVL63:
 633              	.L50:
 634              		.align	2
 635              	.L49:
 636 0024 05000000 		.word	.LC1
 637 0028 0A000000 		.word	.LC2
 638              		.cfi_endproc
 639              	.LFE14:
 641              		.section	.text.decode_b64,"ax",%progbits
 642              		.align	1
 643              		.global	decode_b64
 644              		.syntax unified
 645              		.thumb
 646              		.thumb_func
 647              		.fpu softvfp
 649              	decode_b64:
 650              	.LFB15:
 369:hardware.c    **** #endif
 370:hardware.c    **** 
 371:hardware.c    **** /*
 372:hardware.c    ****     Base64 functions
 373:hardware.c    **** */
 374:hardware.c    **** size_t decode_b64(const char* input, char* output)
 375:hardware.c    **** {
 651              		.loc 1 375 0
 652              		.cfi_startproc
 653              		@ args = 0, pretend = 0, frame = 8
 654              		@ frame_needed = 0, uses_anonymous_args = 0
 655              	.LVL64:
 656 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 657              		.cfi_def_cfa_offset 24
 658              		.cfi_offset 4, -12
 659              		.cfi_offset 5, -8
 660              		.cfi_offset 14, -4
 661              		.loc 1 375 0
 662 0002 0546     		mov	r5, r0
 376:hardware.c    ****     base64_decodestate s;
 377:hardware.c    ****     size_t cnt;
 378:hardware.c    **** 
 379:hardware.c    ****     base64_init_decodestate(&s);
 663              		.loc 1 379 0
 664 0004 01A8     		add	r0, sp, #4
 665              	.LVL65:
 375:hardware.c    ****     base64_decodestate s;
 666              		.loc 1 375 0
 667 0006 0C46     		mov	r4, r1
 668              		.loc 1 379 0
 669 0008 FFF7FEFF 		bl	base64_init_decodestate
 670              	.LVL66:
 380:hardware.c    ****     cnt = base64_decode_block(input, strlen(input), output, &s);
 671              		.loc 1 380 0
 672 000c 2846     		mov	r0, r5
 673 000e FFF7FEFF 		bl	strlen
 674              	.LVL67:
 675 0012 2246     		mov	r2, r4
 676 0014 0146     		mov	r1, r0
 677 0016 01AB     		add	r3, sp, #4
 678 0018 2846     		mov	r0, r5
 679 001a FFF7FEFF 		bl	base64_decode_block
 680              	.LVL68:
 381:hardware.c    ****     output[cnt] = 0;
 681              		.loc 1 381 0
 682 001e 0022     		movs	r2, #0
 683 0020 2254     		strb	r2, [r4, r0]
 382:hardware.c    **** 
 383:hardware.c    ****     return cnt;
 384:hardware.c    **** }
 684              		.loc 1 384 0
 685 0022 03B0     		add	sp, sp, #12
 686              		.cfi_def_cfa_offset 12
 687              		@ sp needed
 688 0024 30BD     		pop	{r4, r5, pc}
 689              		.cfi_endproc
 690              	.LFE15:
 692              		.section	.text.encode_b64,"ax",%progbits
 693              		.align	1
 694              		.global	encode_b64
 695              		.syntax unified
 696              		.thumb
 697              		.thumb_func
 698              		.fpu softvfp
 700              	encode_b64:
 701              	.LFB16:
 385:hardware.c    **** 
 386:hardware.c    **** size_t encode_b64(const char* input, char* output, int blocksize)
 387:hardware.c    **** {
 702              		.loc 1 387 0
 703              		.cfi_startproc
 704              		@ args = 0, pretend = 0, frame = 8
 705              		@ frame_needed = 0, uses_anonymous_args = 0
 706              	.LVL69:
 707 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 708              		.cfi_def_cfa_offset 24
 709              		.cfi_offset 4, -16
 710              		.cfi_offset 5, -12
 711              		.cfi_offset 6, -8
 712              		.cfi_offset 14, -4
 713              		.loc 1 387 0
 714 0002 0D46     		mov	r5, r1
 715 0004 1646     		mov	r6, r2
 716 0006 0446     		mov	r4, r0
 388:hardware.c    ****     base64_encodestate s;
 389:hardware.c    ****     size_t cnt;
 390:hardware.c    **** 
 391:hardware.c    ****     base64_init_encodestate(&s);
 717              		.loc 1 391 0
 718 0008 6846     		mov	r0, sp
 719              	.LVL70:
 720 000a FFF7FEFF 		bl	base64_init_encodestate
 721              	.LVL71:
 392:hardware.c    ****     cnt = base64_encode_block(input, blocksize, output, &s);
 722              		.loc 1 392 0
 723 000e 6B46     		mov	r3, sp
 724 0010 2A46     		mov	r2, r5
 725 0012 3146     		mov	r1, r6
 726 0014 2046     		mov	r0, r4
 727 0016 FFF7FEFF 		bl	base64_encode_block
 728              	.LVL72:
 393:hardware.c    ****     cnt += base64_encode_blockend(output + cnt, &s);
 729              		.loc 1 393 0
 730 001a 6946     		mov	r1, sp
 392:hardware.c    ****     cnt = base64_encode_block(input, blocksize, output, &s);
 731              		.loc 1 392 0
 732 001c 0446     		mov	r4, r0
 733              	.LVL73:
 734              		.loc 1 393 0
 735 001e 2818     		adds	r0, r5, r0
 736              	.LVL74:
 737 0020 FFF7FEFF 		bl	base64_encode_blockend
 738              	.LVL75:
 394:hardware.c    ****     output[cnt] = 0;
 739              		.loc 1 394 0
 740 0024 0023     		movs	r3, #0
 393:hardware.c    ****     cnt += base64_encode_blockend(output + cnt, &s);
 741              		.loc 1 393 0
 742 0026 2044     		add	r0, r0, r4
 743              	.LVL76:
 744              		.loc 1 394 0
 745 0028 2B54     		strb	r3, [r5, r0]
 395:hardware.c    **** 
 396:hardware.c    ****     return cnt;
 397:hardware.c    **** }
 746              		.loc 1 397 0
 747 002a 02B0     		add	sp, sp, #8
 748              		.cfi_def_cfa_offset 16
 749              		@ sp needed
 750 002c 70BD     		pop	{r4, r5, r6, pc}
 751              		.cfi_endproc
 752              	.LFE16:
 754              		.section	.text.uartInit,"ax",%progbits
 755              		.align	1
 756              		.global	uartInit
 757              		.syntax unified
 758              		.thumb
 759              		.thumb_func
 760              		.fpu softvfp
 762              	uartInit:
 763              	.LFB17:
 398:hardware.c    **** 
 399:hardware.c    **** 
 400:hardware.c    **** void uartInit(void) {
 764              		.loc 1 400 0
 765              		.cfi_startproc
 766              		@ args = 0, pretend = 0, frame = 32
 767              		@ frame_needed = 0, uses_anonymous_args = 0
 768 0000 10B5     		push	{r4, lr}
 769              		.cfi_def_cfa_offset 8
 770              		.cfi_offset 4, -8
 771              		.cfi_offset 14, -4
 401:hardware.c    ****     GPIO_InitTypeDef GPIO_InitStructure;
 402:hardware.c    ****     USART_InitTypeDef USART_InitStructure; 
 403:hardware.c    ****     USART_ClockInitTypeDef USART_ClockInitStructure;
 404:hardware.c    ****      
 405:hardware.c    ****     //enable bus clocks
 406:hardware.c    ****     RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENAB
 772              		.loc 1 406 0
 773 0002 0121     		movs	r1, #1
 400:hardware.c    ****     GPIO_InitTypeDef GPIO_InitStructure;
 774              		.loc 1 400 0
 775 0004 88B0     		sub	sp, sp, #32
 776              		.cfi_def_cfa_offset 40
 777              		.loc 1 406 0
 778 0006 44F20500 		movw	r0, #16389
 779 000a FFF7FEFF 		bl	RCC_APB2PeriphClockCmd
 780              	.LVL77:
 407:hardware.c    ****      
 408:hardware.c    ****     //Set USART1 Tx (PA.09) as AF push-pull
 409:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;  
 781              		.loc 1 409 0
 782 000e 4FF40073 		mov	r3, #512
 783 0012 ADF80430 		strh	r3, [sp, #4]	@ movhi
 410:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;   
 784              		.loc 1 410 0
 785 0016 1823     		movs	r3, #24
 786 0018 8DF80730 		strb	r3, [sp, #7]
 411:hardware.c    ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 787              		.loc 1 411 0
 788 001c 0323     		movs	r3, #3
 412:hardware.c    ****      
 413:hardware.c    ****     GPIO_Init(GPIOA, &GPIO_InitStructure);
 789              		.loc 1 413 0
 790 001e 184C     		ldr	r4, .L54
 791 0020 01A9     		add	r1, sp, #4
 792 0022 2046     		mov	r0, r4
 411:hardware.c    ****     GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
 793              		.loc 1 411 0
 794 0024 8DF80630 		strb	r3, [sp, #6]
 795              		.loc 1 413 0
 796 0028 FFF7FEFF 		bl	GPIO_Init
 797              	.LVL78:
 414:hardware.c    ****      
 415:hardware.c    ****     //Set USART1 Rx (PA.10) as input floating
 416:hardware.c    ****      
 417:hardware.c    ****     GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
 798              		.loc 1 417 0
 799 002c 4FF48063 		mov	r3, #1024
 800 0030 ADF80430 		strh	r3, [sp, #4]	@ movhi
 418:hardware.c    ****      
 419:hardware.c    ****     GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
 801              		.loc 1 419 0
 802 0034 0423     		movs	r3, #4
 420:hardware.c    ****      
 421:hardware.c    ****     GPIO_Init(GPIOA, &GPIO_InitStructure);
 803              		.loc 1 421 0
 804 0036 2046     		mov	r0, r4
 805 0038 0DEB0301 		add	r1, sp, r3
 419:hardware.c    ****      
 806              		.loc 1 419 0
 807 003c 8DF80730 		strb	r3, [sp, #7]
 422:hardware.c    ****      
 423:hardware.c    ****     USART_ClockStructInit(&USART_ClockInitStructure);
 424:hardware.c    ****      
 425:hardware.c    ****     USART_ClockInit(USART1, &USART_ClockInitStructure);
 808              		.loc 1 425 0
 809 0040 04F54054 		add	r4, r4, #12288
 421:hardware.c    ****      
 810              		.loc 1 421 0
 811 0044 FFF7FEFF 		bl	GPIO_Init
 812              	.LVL79:
 423:hardware.c    ****      
 813              		.loc 1 423 0
 814 0048 02A8     		add	r0, sp, #8
 815 004a FFF7FEFF 		bl	USART_ClockStructInit
 816              	.LVL80:
 817              		.loc 1 425 0
 818 004e 02A9     		add	r1, sp, #8
 819 0050 2046     		mov	r0, r4
 820 0052 FFF7FEFF 		bl	USART_ClockInit
 821              	.LVL81:
 426:hardware.c    ****      
 427:hardware.c    ****     USART_InitStructure.USART_BaudRate = 115200;     
 822              		.loc 1 427 0
 823 0056 0023     		movs	r3, #0
 824 0058 4FF4E132 		mov	r2, #115200
 825 005c CDE90423 		strd	r2, r3, [sp, #16]
 428:hardware.c    ****     USART_InitStructure.USART_WordLength = USART_WordLength_8b;     
 429:hardware.c    ****     USART_InitStructure.USART_StopBits = USART_StopBits_1;     
 826              		.loc 1 429 0
 827 0060 4FF44022 		mov	r2, #786432
 430:hardware.c    ****     USART_InitStructure.USART_Parity = USART_Parity_No ;    
 431:hardware.c    ****     USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;    
 432:hardware.c    ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 433:hardware.c    ****      
 434:hardware.c    ****     //Write USART1 parameters     
 435:hardware.c    ****     USART_Init(USART1, &USART_InitStructure);
 828              		.loc 1 435 0
 829 0064 04A9     		add	r1, sp, #16
 830 0066 2046     		mov	r0, r4
 429:hardware.c    ****     USART_InitStructure.USART_Parity = USART_Parity_No ;    
 831              		.loc 1 429 0
 832 0068 0692     		str	r2, [sp, #24]
 431:hardware.c    ****     USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
 833              		.loc 1 431 0
 834 006a ADF81C30 		strh	r3, [sp, #28]	@ movhi
 835              		.loc 1 435 0
 836 006e FFF7FEFF 		bl	USART_Init
 837              	.LVL82:
 436:hardware.c    ****      
 437:hardware.c    ****     //Enable USART1
 438:hardware.c    ****     USART_Cmd(USART1, ENABLE);  
 838              		.loc 1 438 0
 839 0072 0121     		movs	r1, #1
 840 0074 2046     		mov	r0, r4
 841 0076 FFF7FEFF 		bl	USART_Cmd
 842              	.LVL83:
 439:hardware.c    **** }
 843              		.loc 1 439 0
 844 007a 08B0     		add	sp, sp, #32
 845              		.cfi_def_cfa_offset 8
 846              		@ sp needed
 847 007c 10BD     		pop	{r4, pc}
 848              	.L55:
 849 007e 00BF     		.align	2
 850              	.L54:
 851 0080 00080140 		.word	1073809408
 852              		.cfi_endproc
 853              	.LFE17:
 855              		.section	.text.systemReset,"ax",%progbits
 856              		.align	1
 857              		.global	systemReset
 858              		.syntax unified
 859              		.thumb
 860              		.thumb_func
 861              		.fpu softvfp
 863              	systemReset:
 864              	.LFB18:
 440:hardware.c    **** 
 441:hardware.c    **** void systemReset(void) {
 865              		.loc 1 441 0
 866              		.cfi_startproc
 867              		@ args = 0, pretend = 0, frame = 0
 868              		@ frame_needed = 0, uses_anonymous_args = 0
 869              		@ link register save eliminated.
 442:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 870              		.loc 1 442 0
 871 0000 0D4B     		ldr	r3, .L57
 443:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
 872              		.loc 1 443 0
 873 0002 0E49     		ldr	r1, .L57+4
 442:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
 874              		.loc 1 442 0
 875 0004 1A68     		ldr	r2, [r3]
 876 0006 42F00102 		orr	r2, r2, #1
 877 000a 1A60     		str	r2, [r3]
 878              		.loc 1 443 0
 879 000c 0868     		ldr	r0, [r1]
 880 000e 0C4A     		ldr	r2, .L57+8
 881 0010 0240     		ands	r2, r2, r0
 882 0012 0A60     		str	r2, [r1]
 444:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
 883              		.loc 1 444 0
 884 0014 1A68     		ldr	r2, [r3]
 885 0016 22F08472 		bic	r2, r2, #17301504
 886 001a 22F48032 		bic	r2, r2, #65536
 887 001e 1A60     		str	r2, [r3]
 445:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
 888              		.loc 1 445 0
 889 0020 1A68     		ldr	r2, [r3]
 890 0022 22F48022 		bic	r2, r2, #262144
 891 0026 1A60     		str	r2, [r3]
 446:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 447:hardware.c    **** 
 448:hardware.c    ****     SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
 892              		.loc 1 448 0
 893 0028 0022     		movs	r2, #0
 446:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
 894              		.loc 1 446 0
 895 002a 0B68     		ldr	r3, [r1]
 896 002c 23F4FE03 		bic	r3, r3, #8323072
 897 0030 0B60     		str	r3, [r1]
 898              		.loc 1 448 0
 899 0032 044B     		ldr	r3, .L57+12
 900 0034 1A60     		str	r2, [r3]
 449:hardware.c    **** }
 901              		.loc 1 449 0
 902 0036 7047     		bx	lr
 903              	.L58:
 904              		.align	2
 905              	.L57:
 906 0038 00100240 		.word	1073876992
 907 003c 04100240 		.word	1073876996
 908 0040 0000FFF8 		.word	-117506048
 909 0044 08100240 		.word	1073877000
 910              		.cfi_endproc
 911              	.LFE18:
 913              		.section	.text.setupCLK,"ax",%progbits
 914              		.align	1
 915              		.global	setupCLK
 916              		.syntax unified
 917              		.thumb
 918              		.thumb_func
 919              		.fpu softvfp
 921              	setupCLK:
 922              	.LFB19:
 450:hardware.c    **** 
 451:hardware.c    **** void setupCLK(void) {
 923              		.loc 1 451 0
 924              		.cfi_startproc
 925              		@ args = 0, pretend = 0, frame = 0
 926              		@ frame_needed = 0, uses_anonymous_args = 0
 927              		@ link register save eliminated.
 928              	.LVL84:
 452:hardware.c    **** 	unsigned int StartUpCounter=0;
 453:hardware.c    ****     /* enable HSE */
 454:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
 929              		.loc 1 454 0
 930 0000 154B     		ldr	r3, .L69
 931 0002 1A68     		ldr	r2, [r3]
 932 0004 42F00112 		orr	r2, r2, #65537
 933 0008 1A60     		str	r2, [r3]
 934              	.L60:
 455:hardware.c    ****     while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
 935              		.loc 1 455 0 discriminator 1
 936 000a 1A68     		ldr	r2, [r3]
 937 000c 9003     		lsls	r0, r2, #14
 938 000e FCD5     		bpl	.L60
 456:hardware.c    **** 
 457:hardware.c    ****     /* enable flash prefetch buffer */
 458:hardware.c    ****     SET_REG(FLASH_ACR, 0x00000012);
 939              		.loc 1 458 0
 940 0010 1221     		movs	r1, #18
 941 0012 124A     		ldr	r2, .L69+4
 942 0014 1160     		str	r1, [r2]
 459:hardware.c    **** 	
 460:hardware.c    ****      /* Configure PLL */
 461:hardware.c    **** #ifdef XTAL12M
 462:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
 463:hardware.c    **** #else
 464:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
 943              		.loc 1 464 0
 944 0016 A2F6FC72 		subw	r2, r2, #4092
 945 001a 1168     		ldr	r1, [r2]
 946 001c 41F4E811 		orr	r1, r1, #1900544
 947 0020 41F48061 		orr	r1, r1, #1024
 948 0024 1160     		str	r1, [r2]
 465:hardware.c    **** #endif	
 466:hardware.c    **** 
 467:hardware.c    ****     SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
 949              		.loc 1 467 0
 950 0026 1968     		ldr	r1, [r3]
 951 0028 41F08071 		orr	r1, r1, #16777216
 952 002c 1960     		str	r1, [r3]
 953              	.L61:
 468:hardware.c    **** 	
 469:hardware.c    **** 
 470:hardware.c    **** #if !defined  (HSE_STARTUP_TIMEOUT) 
 471:hardware.c    ****   #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
 472:hardware.c    **** #endif /* HSE_STARTUP_TIMEOUT */   
 473:hardware.c    **** 
 474:hardware.c    ****     while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
 954              		.loc 1 474 0 discriminator 2
 955 002e 1968     		ldr	r1, [r3]
 956 0030 11F0407F 		tst	r1, #50331648
 957 0034 FBD0     		beq	.L61
 475:hardware.c    **** 	{
 476:hardware.c    **** //		StartUpCounter++; // This is commented out, so other changes can be committed. It will be uncom
 477:hardware.c    **** 	}	/* wait for it to come on */
 478:hardware.c    **** 
 479:hardware.c    **** 	if (StartUpCounter>=HSE_STARTUP_TIMEOUT)
 480:hardware.c    **** 	{
 481:hardware.c    **** 		// HSE has not started. Try restarting the processor
 482:hardware.c    **** 		systemHardReset(); 
 483:hardware.c    **** 	}
 484:hardware.c    ****     /* Set SYSCLK as PLL */
 485:hardware.c    ****     SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
 958              		.loc 1 485 0
 959 0036 1168     		ldr	r1, [r2]
 960 0038 41F00201 		orr	r1, r1, #2
 961 003c 1160     		str	r1, [r2]
 962              	.L62:
 486:hardware.c    ****     while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
 963              		.loc 1 486 0 discriminator 1
 964 003e 1168     		ldr	r1, [r2]
 965 0040 0907     		lsls	r1, r1, #28
 966 0042 FCD5     		bpl	.L62
 487:hardware.c    **** 	
 488:hardware.c    ****     pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
 967              		.loc 1 488 0
 968 0044 9A69     		ldr	r2, [r3, #24]
 969 0046 42F4FE72 		orr	r2, r2, #508
 970 004a 9A61     		str	r2, [r3, #24]
 489:hardware.c    **** 	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
 971              		.loc 1 489 0
 972 004c DA69     		ldr	r2, [r3, #28]
 973 004e 42F40002 		orr	r2, r2, #8388608
 974 0052 DA61     		str	r2, [r3, #28]
 490:hardware.c    **** 
 491:hardware.c    **** }
 975              		.loc 1 491 0
 976 0054 7047     		bx	lr
 977              	.L70:
 978 0056 00BF     		.align	2
 979              	.L69:
 980 0058 00100240 		.word	1073876992
 981 005c 00200240 		.word	1073881088
 982              		.cfi_endproc
 983              	.LFE19:
 985              		.section	.text.setupLEDAndButton,"ax",%progbits
 986              		.align	1
 987              		.global	setupLEDAndButton
 988              		.syntax unified
 989              		.thumb
 990              		.thumb_func
 991              		.fpu softvfp
 993              	setupLEDAndButton:
 994              	.LFB20:
 492:hardware.c    **** 
 493:hardware.c    **** void setupLEDAndButton (void) { 
 995              		.loc 1 493 0
 996              		.cfi_startproc
 997              		@ args = 0, pretend = 0, frame = 0
 998              		@ frame_needed = 0, uses_anonymous_args = 0
 999              		@ link register save eliminated.
 494:hardware.c    ****   SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUT
 1000              		.loc 1 494 0
 1001 0000 034A     		ldr	r2, .L72
 1002 0002 1368     		ldr	r3, [r2]
 1003 0004 23F47003 		bic	r3, r3, #15728640
 1004 0008 43F48013 		orr	r3, r3, #1048576
 1005 000c 1360     		str	r3, [r2]
 495:hardware.c    **** }
 1006              		.loc 1 495 0
 1007 000e 7047     		bx	lr
 1008              	.L73:
 1009              		.align	2
 1010              	.L72:
 1011 0010 04100140 		.word	1073811460
 1012              		.cfi_endproc
 1013              	.LFE20:
 1015              		.section	.text.setupFLASH,"ax",%progbits
 1016              		.align	1
 1017              		.global	setupFLASH
 1018              		.syntax unified
 1019              		.thumb
 1020              		.thumb_func
 1021              		.fpu softvfp
 1023              	setupFLASH:
 1024              	.LFB21:
 496:hardware.c    **** 
 497:hardware.c    **** void setupFLASH() {
 1025              		.loc 1 497 0
 1026              		.cfi_startproc
 1027              		@ args = 0, pretend = 0, frame = 0
 1028              		@ frame_needed = 0, uses_anonymous_args = 0
 1029              		@ link register save eliminated.
 498:hardware.c    ****     /* configure the HSI oscillator */
 499:hardware.c    ****     if ((pRCC->CR & 0x01) == 0x00) {
 1030              		.loc 1 499 0
 1031 0000 054B     		ldr	r3, .L79
 1032 0002 1A68     		ldr	r2, [r3]
 1033 0004 D107     		lsls	r1, r2, #31
 1034              	.LBB4:
 500:hardware.c    ****         u32 rwmVal = pRCC->CR;
 1035              		.loc 1 500 0
 1036 0006 5EBF     		ittt	pl
 1037 0008 1A68     		ldrpl	r2, [r3]
 1038              	.LVL85:
 501:hardware.c    ****         rwmVal |= 0x01;
 1039              		.loc 1 501 0
 1040 000a 42F00102 		orrpl	r2, r2, #1
 1041              	.LVL86:
 502:hardware.c    ****         pRCC->CR = rwmVal;
 1042              		.loc 1 502 0
 1043 000e 1A60     		strpl	r2, [r3]
 1044              	.LVL87:
 1045              	.L76:
 1046              	.LBE4:
 503:hardware.c    ****     }
 504:hardware.c    **** 
 505:hardware.c    ****     /* wait for it to come on */
 506:hardware.c    ****     while ((pRCC->CR & 0x02) == 0x00) {}
 1047              		.loc 1 506 0 discriminator 1
 1048 0010 1A68     		ldr	r2, [r3]
 1049 0012 9207     		lsls	r2, r2, #30
 1050 0014 FCD5     		bpl	.L76
 507:hardware.c    **** }   
 1051              		.loc 1 507 0
 1052 0016 7047     		bx	lr
 1053              	.L80:
 1054              		.align	2
 1055              	.L79:
 1056 0018 00100240 		.word	1073876992
 1057              		.cfi_endproc
 1058              	.LFE21:
 1060              		.section	.text.uid_read,"ax",%progbits
 1061              		.align	1
 1062              		.global	uid_read
 1063              		.syntax unified
 1064              		.thumb
 1065              		.thumb_func
 1066              		.fpu softvfp
 1068              	uid_read:
 1069              	.LFB22:
 508:hardware.c    **** 
 509:hardware.c    **** /* Read U_ID register */
 510:hardware.c    **** void uid_read(struct u_id *id)
 511:hardware.c    **** {
 1070              		.loc 1 511 0
 1071              		.cfi_startproc
 1072              		@ args = 0, pretend = 0, frame = 0
 1073              		@ frame_needed = 0, uses_anonymous_args = 0
 1074              		@ link register save eliminated.
 1075              	.LVL88:
 512:hardware.c    ****   if (QEMU_BUILD) // put an arbitrary ECID in qemu
 513:hardware.c    ****   {
 514:hardware.c    ****     memcpy(&id, (unsigned char*)0xFF, 23);
 515:hardware.c    ****   } else {
 516:hardware.c    ****     id->off0 = MMIO16(U_ID + 0x0);
 517:hardware.c    ****     id->off2 = MMIO16(U_ID + 0x2);
 518:hardware.c    ****     id->off4 = MMIO32(U_ID + 0x4);
 519:hardware.c    ****     id->off8 = MMIO32(U_ID + 0x8);
 520:hardware.c    ****   }
 521:hardware.c    **** }
 1076              		.loc 1 521 0
 1077 0000 7047     		bx	lr
 1078              		.cfi_endproc
 1079              	.LFE22:
 1081              		.section	.text.setMspAndJump,"ax",%progbits
 1082              		.align	1
 1083              		.global	setMspAndJump
 1084              		.syntax unified
 1085              		.thumb
 1086              		.thumb_func
 1087              		.fpu softvfp
 1089              	setMspAndJump:
 1090              	.LFB23:
 522:hardware.c    **** 
 523:hardware.c    **** void setMspAndJump(u32 usrAddr) {
 1091              		.loc 1 523 0
 1092              		.cfi_startproc
 1093              		@ args = 0, pretend = 0, frame = 0
 1094              		@ frame_needed = 0, uses_anonymous_args = 0
 1095              		@ link register save eliminated.
 1096              	.LVL89:
 524:hardware.c    ****   // Dedicated function with no call to any function (appart the last call)
 525:hardware.c    ****   // This way, there is no manipulation of the stack here, ensuring that GGC
 526:hardware.c    ****   // didn't insert any pop from the SP after having set the MSP.
 527:hardware.c    ****   typedef void (*funcPtr)(void);
 528:hardware.c    ****   u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
 529:hardware.c    **** 
 530:hardware.c    ****   funcPtr usrMain = (funcPtr) jumpAddr;
 531:hardware.c    **** 
 532:hardware.c    ****   SET_REG(SCB_VTOR, (vu32) (usrAddr));
 1097              		.loc 1 532 0
 1098 0000 034A     		ldr	r2, .L83
 528:hardware.c    **** 
 1099              		.loc 1 528 0
 1100 0002 4368     		ldr	r3, [r0, #4]
 1101              	.LVL90:
 1102              		.loc 1 532 0
 1103 0004 1060     		str	r0, [r2]
 533:hardware.c    **** 
 534:hardware.c    ****   asm volatile("msr msp, %0"::"g"
 535:hardware.c    ****                (*(volatile u32 *)usrAddr));
 1104              		.loc 1 535 0
 1105 0006 0268     		ldr	r2, [r0]
 534:hardware.c    ****                (*(volatile u32 *)usrAddr));
 1106              		.loc 1 534 0
 1107              		.syntax unified
 1108              	@ 534 "hardware.c" 1
 1109 0008 82F30888 		msr msp, r2
 1110              	@ 0 "" 2
 536:hardware.c    **** 
 537:hardware.c    ****   usrMain();                                /* go! */
 1111              		.loc 1 537 0
 1112              		.thumb
 1113              		.syntax unified
 1114 000c 1847     		bx	r3	@ indirect register sibling call
 1115              	.LVL91:
 1116              	.L84:
 1117 000e 00BF     		.align	2
 1118              	.L83:
 1119 0010 08ED00E0 		.word	-536810232
 1120              		.cfi_endproc
 1121              	.LFE23:
 1123              		.section	.text.bkp10Write,"ax",%progbits
 1124              		.align	1
 1125              		.global	bkp10Write
 1126              		.syntax unified
 1127              		.thumb
 1128              		.thumb_func
 1129              		.fpu softvfp
 1131              	bkp10Write:
 1132              	.LFB25:
 538:hardware.c    **** }
 539:hardware.c    **** 
 540:hardware.c    **** 
 541:hardware.c    **** void jumpToUser(u32 usrAddr) {
 542:hardware.c    **** 
 543:hardware.c    ****     /* tear down all the dfu related setup */
 544:hardware.c    ****     // disable usb interrupts, clear them, turn off usb, set the disc pin
 545:hardware.c    ****     // todo pick exactly what we want to do here, now its just a conservative
 546:hardware.c    **** 
 547:hardware.c    ****     //flashLock();
 548:hardware.c    ****     usbDsbISR();
 549:hardware.c    ****     nvicDisableInterrupts();
 550:hardware.c    **** 	
 551:hardware.c    **** #ifndef HAS_MAPLE_HARDWARE	
 552:hardware.c    **** 	usbDsbBus();
 553:hardware.c    **** #endif
 554:hardware.c    **** 	
 555:hardware.c    **** // Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(
 556:hardware.c    ****     systemReset(); // resets clocks and periphs, not core regs
 557:hardware.c    ****     //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW
 558:hardware.c    ****     setMspAndJump(usrAddr);
 559:hardware.c    **** }
 560:hardware.c    **** 
 561:hardware.c    **** void bkp10Write(u16 value)
 562:hardware.c    **** {
 1133              		.loc 1 562 0
 1134              		.cfi_startproc
 1135              		@ args = 0, pretend = 0, frame = 0
 1136              		@ frame_needed = 0, uses_anonymous_args = 0
 1137              		@ link register save eliminated.
 1138              	.LVL92:
 563:hardware.c    **** 		// Enable clocks for the backup domain registers
 564:hardware.c    **** 		pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1139              		.loc 1 564 0
 1140 0000 084A     		ldr	r2, .L86
 1141 0002 D369     		ldr	r3, [r2, #28]
 1142 0004 43F0C053 		orr	r3, r3, #402653184
 1143 0008 D361     		str	r3, [r2, #28]
 565:hardware.c    **** 		
 566:hardware.c    ****         // Disable backup register write protection
 567:hardware.c    ****         pPWR->CR |= PWR_CR_DBP;
 1144              		.loc 1 567 0
 1145 000a 074B     		ldr	r3, .L86+4
 1146 000c 1A68     		ldr	r2, [r3]
 1147 000e 42F48072 		orr	r2, r2, #256
 1148 0012 1A60     		str	r2, [r3]
 568:hardware.c    **** 
 569:hardware.c    ****         // store value in pBK DR10
 570:hardware.c    ****         pBKP->DR10 = value;
 1149              		.loc 1 570 0
 1150 0014 054A     		ldr	r2, .L86+8
 1151 0016 1085     		strh	r0, [r2, #40]	@ movhi
 571:hardware.c    **** 
 572:hardware.c    ****         // Re-enable backup register write protection
 573:hardware.c    ****         pPWR->CR &=~ PWR_CR_DBP;	
 1152              		.loc 1 573 0
 1153 0018 1A68     		ldr	r2, [r3]
 1154 001a 22F48072 		bic	r2, r2, #256
 1155 001e 1A60     		str	r2, [r3]
 574:hardware.c    **** }
 1156              		.loc 1 574 0
 1157 0020 7047     		bx	lr
 1158              	.L87:
 1159 0022 00BF     		.align	2
 1160              	.L86:
 1161 0024 00100240 		.word	1073876992
 1162 0028 00700040 		.word	1073770496
 1163 002c 006C0040 		.word	1073769472
 1164              		.cfi_endproc
 1165              	.LFE25:
 1167              		.section	.text.checkAndClearBootloaderFlag,"ax",%progbits
 1168              		.align	1
 1169              		.global	checkAndClearBootloaderFlag
 1170              		.syntax unified
 1171              		.thumb
 1172              		.thumb_func
 1173              		.fpu softvfp
 1175              	checkAndClearBootloaderFlag:
 1176              	.LFB26:
 575:hardware.c    **** 
 576:hardware.c    **** int checkAndClearBootloaderFlag()
 577:hardware.c    **** {
 1177              		.loc 1 577 0
 1178              		.cfi_startproc
 1179              		@ args = 0, pretend = 0, frame = 0
 1180              		@ frame_needed = 0, uses_anonymous_args = 0
 1181              	.LVL93:
 578:hardware.c    ****     bool flagSet = 0x00;// Flag not used
 579:hardware.c    **** 
 580:hardware.c    ****     // Enable clocks for the backup domain registers
 581:hardware.c    ****     pRCC->APB1ENR |= (RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 582:hardware.c    **** 
 583:hardware.c    ****     switch (pBKP->DR10)
 1182              		.loc 1 583 0
 1183 0000 44F24C21 		movw	r1, #16972
 581:hardware.c    **** 
 1184              		.loc 1 581 0
 1185 0004 0E4B     		ldr	r3, .L95
 577:hardware.c    ****     bool flagSet = 0x00;// Flag not used
 1186              		.loc 1 577 0
 1187 0006 10B5     		push	{r4, lr}
 1188              		.cfi_def_cfa_offset 8
 1189              		.cfi_offset 4, -8
 1190              		.cfi_offset 14, -4
 581:hardware.c    **** 
 1191              		.loc 1 581 0
 1192 0008 DA69     		ldr	r2, [r3, #28]
 1193 000a 42F0C052 		orr	r2, r2, #402653184
 1194 000e DA61     		str	r2, [r3, #28]
 1195              		.loc 1 583 0
 1196 0010 0C4A     		ldr	r2, .L95+4
 1197 0012 128D     		ldrh	r2, [r2, #40]
 1198 0014 92B2     		uxth	r2, r2
 1199 0016 8A42     		cmp	r2, r1
 1200 0018 1946     		mov	r1, r3
 1201 001a 05D0     		beq	.L90
 1202 001c 44F24D23 		movw	r3, #16973
 1203 0020 9A42     		cmp	r2, r3
 1204 0022 0BD0     		beq	.L93
 578:hardware.c    ****     bool flagSet = 0x00;// Flag not used
 1205              		.loc 1 578 0
 1206 0024 0024     		movs	r4, #0
 1207 0026 07E0     		b	.L89
 1208              	.L90:
 584:hardware.c    **** 	{
 585:hardware.c    **** 		case RTC_BOOTLOADER_FLAG:
 586:hardware.c    **** 			flagSet = 0x01;
 1209              		.loc 1 586 0
 1210 0028 0124     		movs	r4, #1
 1211              	.L91:
 587:hardware.c    **** 			break;
 588:hardware.c    **** 		case RTC_BOOTLOADER_JUST_UPLOADED:
 589:hardware.c    **** 			flagSet = 0x02;
 590:hardware.c    **** 			break;		
 591:hardware.c    ****     }
 592:hardware.c    **** 
 593:hardware.c    **** 	if (flagSet!=0x00)
 594:hardware.c    **** 	{
 595:hardware.c    **** 		bkp10Write(0x0000);// Clear the flag
 1212              		.loc 1 595 0
 1213 002a 0020     		movs	r0, #0
 1214 002c FFF7FEFF 		bl	bkp10Write
 1215              	.LVL94:
 596:hardware.c    **** 		// Disable clocks
 597:hardware.c    **** 		pRCC->APB1ENR &= ~(RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
 1216              		.loc 1 597 0
 1217 0030 CB69     		ldr	r3, [r1, #28]
 1218 0032 23F0C053 		bic	r3, r3, #402653184
 1219 0036 CB61     		str	r3, [r1, #28]
 1220              	.L89:
 598:hardware.c    **** 	}
 599:hardware.c    ****     return flagSet;
 600:hardware.c    **** }
 1221              		.loc 1 600 0
 1222 0038 2046     		mov	r0, r4
 1223 003a 10BD     		pop	{r4, pc}
 1224              	.L93:
 589:hardware.c    **** 			break;		
 1225              		.loc 1 589 0
 1226 003c 0224     		movs	r4, #2
 1227 003e F4E7     		b	.L91
 1228              	.L96:
 1229              		.align	2
 1230              	.L95:
 1231 0040 00100240 		.word	1073876992
 1232 0044 006C0040 		.word	1073769472
 1233              		.cfi_endproc
 1234              	.LFE26:
 1236              		.section	.text.nvicInit,"ax",%progbits
 1237              		.align	1
 1238              		.global	nvicInit
 1239              		.syntax unified
 1240              		.thumb
 1241              		.thumb_func
 1242              		.fpu softvfp
 1244              	nvicInit:
 1245              	.LFB27:
 601:hardware.c    **** 
 602:hardware.c    **** void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
 1246              		.loc 1 602 0
 1247              		.cfi_startproc
 1248              		@ args = 0, pretend = 0, frame = 0
 1249              		@ frame_needed = 0, uses_anonymous_args = 0
 1250              	.LVL95:
 603:hardware.c    ****     u32 tmppriority = 0x00;
 604:hardware.c    ****     u32 tmpreg      = 0x00;
 605:hardware.c    ****     u32 tmpmask     = 0x00;
 606:hardware.c    ****     u32 tmppre      = 0;
 607:hardware.c    ****     u32 tmpsub      = 0x0F;
 608:hardware.c    **** 
 609:hardware.c    ****     SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
 610:hardware.c    ****     NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
 611:hardware.c    **** 
 612:hardware.c    **** 
 613:hardware.c    ****     /* Compute the Corresponding IRQ Priority --------------------------------*/
 614:hardware.c    ****     tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
 1251              		.loc 1 614 0
 1252 0000 184B     		ldr	r3, .L98
 602:hardware.c    ****     u32 tmppriority = 0x00;
 1253              		.loc 1 602 0
 1254 0002 30B5     		push	{r4, r5, lr}
 1255              		.cfi_def_cfa_offset 12
 1256              		.cfi_offset 4, -12
 1257              		.cfi_offset 5, -8
 1258              		.cfi_offset 14, -4
 1259              		.loc 1 614 0
 1260 0004 DA68     		ldr	r2, [r3, #12]
 615:hardware.c    ****     tmppre = (0x4 - tmppriority);
 616:hardware.c    ****     tmpsub = tmpsub >> tmppriority;
 1261              		.loc 1 616 0
 1262 0006 0F24     		movs	r4, #15
 614:hardware.c    ****     tmppre = (0x4 - tmppriority);
 1263              		.loc 1 614 0
 1264 0008 D243     		mvns	r2, r2
 1265 000a C2F30222 		ubfx	r2, r2, #8, #3
 1266              	.LVL96:
 615:hardware.c    ****     tmppre = (0x4 - tmppriority);
 1267              		.loc 1 615 0
 1268 000e C2F10401 		rsb	r1, r2, #4
 1269              	.LVL97:
 1270              		.loc 1 616 0
 1271 0012 24FA02F2 		lsr	r2, r4, r2
 1272              	.LVL98:
 617:hardware.c    **** 
 618:hardware.c    ****     tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
 619:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 620:hardware.c    **** 
 621:hardware.c    ****     tmppriority = tmppriority << 0x04;
 622:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 623:hardware.c    **** 
 624:hardware.c    ****     tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
 625:hardware.c    ****     tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1273              		.loc 1 625 0
 1274 0016 FF24     		movs	r4, #255
 618:hardware.c    ****     tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
 1275              		.loc 1 618 0
 1276 0018 4378     		ldrb	r3, [r0, #1]	@ zero_extendqisi2
 1277 001a 03FA01F1 		lsl	r1, r3, r1
 1278              	.LVL99:
 619:hardware.c    **** 
 1279              		.loc 1 619 0
 1280 001e 8378     		ldrb	r3, [r0, #2]	@ zero_extendqisi2
 1281 0020 1340     		ands	r3, r3, r2
 622:hardware.c    **** 
 1282              		.loc 1 622 0
 1283 0022 0278     		ldrb	r2, [r0]	@ zero_extendqisi2
 1284              	.LVL100:
 619:hardware.c    **** 
 1285              		.loc 1 619 0
 1286 0024 0B43     		orrs	r3, r3, r1
 1287              	.LVL101:
 1288 0026 02F0FC01 		and	r1, r2, #252
 1289 002a 01F16041 		add	r1, r1, #-536870912
 1290 002e 01F56141 		add	r1, r1, #57600
 622:hardware.c    **** 
 1291              		.loc 1 622 0
 1292 0032 02F00300 		and	r0, r2, #3
 1293              	.LVL102:
 624:hardware.c    ****     tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1294              		.loc 1 624 0
 1295 0036 D1F80053 		ldr	r5, [r1, #768]
 1296              	.LVL103:
 622:hardware.c    **** 
 1297              		.loc 1 622 0
 1298 003a C000     		lsls	r0, r0, #3
 621:hardware.c    ****     tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
 1299              		.loc 1 621 0
 1300 003c 1B01     		lsls	r3, r3, #4
 1301              	.LVL104:
 622:hardware.c    **** 
 1302              		.loc 1 622 0
 1303 003e 8340     		lsls	r3, r3, r0
 1304              	.LVL105:
 1305 0040 6B40     		eors	r3, r3, r5
 1306              		.loc 1 625 0
 1307 0042 04FA00F0 		lsl	r0, r4, r0
 1308              	.LVL106:
 1309 0046 0340     		ands	r3, r3, r0
 626:hardware.c    ****     tmpreg &= ~tmpmask;
 627:hardware.c    ****     tmppriority &= tmpmask;
 628:hardware.c    ****     tmpreg |= tmppriority;
 1310              		.loc 1 628 0
 1311 0048 6B40     		eors	r3, r3, r5
 1312              	.LVL107:
 629:hardware.c    **** 
 630:hardware.c    ****     rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
 1313              		.loc 1 630 0
 1314 004a C1F80033 		str	r3, [r1, #768]
 631:hardware.c    **** 
 632:hardware.c    ****     /* Enable the Selected IRQ Channels --------------------------------------*/
 633:hardware.c    ****     rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
 634:hardware.c    ****         (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 1315              		.loc 1 634 0
 1316 004e 0123     		movs	r3, #1
 1317              	.LVL108:
 633:hardware.c    ****         (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 1318              		.loc 1 633 0
 1319 0050 5109     		lsrs	r1, r2, #5
 1320              	.LVL109:
 1321              		.loc 1 634 0
 1322 0052 02F01F02 		and	r2, r2, #31
 1323              	.LVL110:
 1324 0056 03FA02F2 		lsl	r2, r3, r2
 633:hardware.c    ****         (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
 1325              		.loc 1 633 0
 1326 005a 034B     		ldr	r3, .L98+4
 1327 005c 43F82120 		str	r2, [r3, r1, lsl #2]
 635:hardware.c    **** }
 1328              		.loc 1 635 0
 1329 0060 30BD     		pop	{r4, r5, pc}
 1330              	.L99:
 1331 0062 00BF     		.align	2
 1332              	.L98:
 1333 0064 00ED00E0 		.word	-536810240
 1334 0068 00E100E0 		.word	-536813312
 1335              		.cfi_endproc
 1336              	.LFE27:
 1338              		.section	.text.nvicDisableInterrupts,"ax",%progbits
 1339              		.align	1
 1340              		.global	nvicDisableInterrupts
 1341              		.syntax unified
 1342              		.thumb
 1343              		.thumb_func
 1344              		.fpu softvfp
 1346              	nvicDisableInterrupts:
 1347              	.LFB28:
 636:hardware.c    **** 
 637:hardware.c    **** void nvicDisableInterrupts() {
 1348              		.loc 1 637 0
 1349              		.cfi_startproc
 1350              		@ args = 0, pretend = 0, frame = 0
 1351              		@ frame_needed = 0, uses_anonymous_args = 0
 1352              		@ link register save eliminated.
 1353              	.LVL111:
 638:hardware.c    ****     NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
 639:hardware.c    ****     rNVIC->ICER[0] = 0xFFFFFFFF;
 1354              		.loc 1 639 0
 1355 0000 4FF0FF32 		mov	r2, #-1
 1356 0004 064B     		ldr	r3, .L101
 1357 0006 C3F88020 		str	r2, [r3, #128]
 640:hardware.c    ****     rNVIC->ICER[1] = 0xFFFFFFFF;
 1358              		.loc 1 640 0
 1359 000a C3F88420 		str	r2, [r3, #132]
 641:hardware.c    ****     rNVIC->ICPR[0] = 0xFFFFFFFF;
 1360              		.loc 1 641 0
 1361 000e C3F88021 		str	r2, [r3, #384]
 642:hardware.c    ****     rNVIC->ICPR[1] = 0xFFFFFFFF;
 1362              		.loc 1 642 0
 1363 0012 C3F88421 		str	r2, [r3, #388]
 643:hardware.c    **** 
 644:hardware.c    ****     SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
 1364              		.loc 1 644 0
 1365 0016 0422     		movs	r2, #4
 1366 0018 43F8F02C 		str	r2, [r3, #-240]
 645:hardware.c    **** }
 1367              		.loc 1 645 0
 1368 001c 7047     		bx	lr
 1369              	.L102:
 1370 001e 00BF     		.align	2
 1371              	.L101:
 1372 0020 00E100E0 		.word	-536813312
 1373              		.cfi_endproc
 1374              	.LFE28:
 1376              		.section	.text.jumpToUser,"ax",%progbits
 1377              		.align	1
 1378              		.global	jumpToUser
 1379              		.syntax unified
 1380              		.thumb
 1381              		.thumb_func
 1382              		.fpu softvfp
 1384              	jumpToUser:
 1385              	.LFB24:
 541:hardware.c    **** 
 1386              		.loc 1 541 0
 1387              		.cfi_startproc
 1388              		@ args = 0, pretend = 0, frame = 0
 1389              		@ frame_needed = 0, uses_anonymous_args = 0
 1390              	.LVL112:
 1391 0000 10B5     		push	{r4, lr}
 1392              		.cfi_def_cfa_offset 8
 1393              		.cfi_offset 4, -8
 1394              		.cfi_offset 14, -4
 541:hardware.c    **** 
 1395              		.loc 1 541 0
 1396 0002 0446     		mov	r4, r0
 548:hardware.c    ****     nvicDisableInterrupts();
 1397              		.loc 1 548 0
 1398 0004 FFF7FEFF 		bl	usbDsbISR
 1399              	.LVL113:
 549:hardware.c    **** 	
 1400              		.loc 1 549 0
 1401 0008 FFF7FEFF 		bl	nvicDisableInterrupts
 1402              	.LVL114:
 552:hardware.c    **** #endif
 1403              		.loc 1 552 0
 1404 000c FFF7FEFF 		bl	usbDsbBus
 1405              	.LVL115:
 556:hardware.c    ****     //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW
 1406              		.loc 1 556 0
 1407 0010 FFF7FEFF 		bl	systemReset
 1408              	.LVL116:
 558:hardware.c    **** }
 1409              		.loc 1 558 0
 1410 0014 2046     		mov	r0, r4
 559:hardware.c    **** 
 1411              		.loc 1 559 0
 1412 0016 BDE81040 		pop	{r4, lr}
 1413              		.cfi_restore 14
 1414              		.cfi_restore 4
 1415              		.cfi_def_cfa_offset 0
 1416              	.LVL117:
 558:hardware.c    **** }
 1417              		.loc 1 558 0
 1418 001a FFF7FEBF 		b	setMspAndJump
 1419              	.LVL118:
 1420              		.cfi_endproc
 1421              	.LFE24:
 1423              		.section	.text.systemHardReset,"ax",%progbits
 1424              		.align	1
 1425              		.global	systemHardReset
 1426              		.syntax unified
 1427              		.thumb
 1428              		.thumb_func
 1429              		.fpu softvfp
 1431              	systemHardReset:
 1432              	.LFB29:
 646:hardware.c    **** 
 647:hardware.c    **** void systemHardReset(void) {
 1433              		.loc 1 647 0
 1434              		.cfi_startproc
 1435              		@ args = 0, pretend = 0, frame = 0
 1436              		@ frame_needed = 0, uses_anonymous_args = 0
 1437              		@ link register save eliminated.
 1438              	.LVL119:
 648:hardware.c    ****     SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
 649:hardware.c    **** 
 650:hardware.c    ****     /* Reset  */
 651:hardware.c    ****     rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
 1439              		.loc 1 651 0
 1440 0000 024B     		ldr	r3, .L106
 1441 0002 034A     		ldr	r2, .L106+4
 1442 0004 DA60     		str	r2, [r3, #12]
 1443              	.L105:
 652:hardware.c    **** 
 653:hardware.c    ****     /*  should never get here */
 654:hardware.c    ****     while (1) {
 655:hardware.c    ****         asm volatile("nop");
 1444              		.loc 1 655 0 discriminator 1
 1445              		.syntax unified
 1446              	@ 655 "hardware.c" 1
 1447 0006 00BF     		nop
 1448              	@ 0 "" 2
 1449              		.thumb
 1450              		.syntax unified
 1451 0008 FDE7     		b	.L105
 1452              	.L107:
 1453 000a 00BF     		.align	2
 1454              	.L106:
 1455 000c 00ED00E0 		.word	-536810240
 1456 0010 0400FA05 		.word	100270084
 1457              		.cfi_endproc
 1458              	.LFE29:
 1460              		.section	.text.flashErasePage,"ax",%progbits
 1461              		.align	1
 1462              		.global	flashErasePage
 1463              		.syntax unified
 1464              		.thumb
 1465              		.thumb_func
 1466              		.fpu softvfp
 1468              	flashErasePage:
 1469              	.LFB30:
 656:hardware.c    ****     }
 657:hardware.c    **** }
 658:hardware.c    **** 
 659:hardware.c    **** bool flashErasePage(u32 pageAddr) {
 1470              		.loc 1 659 0
 1471              		.cfi_startproc
 1472              		@ args = 0, pretend = 0, frame = 0
 1473              		@ frame_needed = 0, uses_anonymous_args = 0
 1474              	.LVL120:
 660:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1475              		.loc 1 660 0
 1476 0000 0A4B     		ldr	r3, .L113
 659:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 1477              		.loc 1 659 0
 1478 0002 10B5     		push	{r4, lr}
 1479              		.cfi_def_cfa_offset 8
 1480              		.cfi_offset 4, -8
 1481              		.cfi_offset 14, -4
 1482              		.loc 1 660 0
 1483 0004 1A68     		ldr	r2, [r3]
 1484              	.LVL121:
 661:hardware.c    ****     rwmVal = FLASH_CR_PER;
 662:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1485              		.loc 1 662 0
 1486 0006 0222     		movs	r2, #2
 1487 0008 1A60     		str	r2, [r3]
 663:hardware.c    **** 
 664:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1488              		.loc 1 664 0
 1489 000a 094A     		ldr	r2, .L113+4
 1490 000c 1146     		mov	r1, r2
 1491              	.L109:
 1492              		.loc 1 664 0 is_stmt 0 discriminator 1
 1493 000e 1468     		ldr	r4, [r2]
 1494 0010 E407     		lsls	r4, r4, #31
 1495 0012 FCD4     		bmi	.L109
 665:hardware.c    ****     SET_REG(FLASH_AR, pageAddr);
 1496              		.loc 1 665 0 is_stmt 1
 1497 0014 074A     		ldr	r2, .L113+8
 1498 0016 1060     		str	r0, [r2]
 666:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
 1499              		.loc 1 666 0
 1500 0018 4222     		movs	r2, #66
 1501 001a 1A60     		str	r2, [r3]
 1502              	.L110:
 667:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1503              		.loc 1 667 0 discriminator 1
 1504 001c 0A68     		ldr	r2, [r1]
 1505 001e 12F00102 		ands	r2, r2, #1
 1506 0022 FBD1     		bne	.L110
 1507              	.LVL122:
 668:hardware.c    **** 
 669:hardware.c    ****     /* todo: verify the page was erased */
 670:hardware.c    **** 
 671:hardware.c    ****     rwmVal = 0x00;
 672:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1508              		.loc 1 672 0
 1509 0024 1A60     		str	r2, [r3]
 673:hardware.c    **** 
 674:hardware.c    ****     return TRUE;
 675:hardware.c    **** }
 1510              		.loc 1 675 0
 1511 0026 0120     		movs	r0, #1
 1512              	.LVL123:
 1513 0028 10BD     		pop	{r4, pc}
 1514              	.L114:
 1515 002a 00BF     		.align	2
 1516              	.L113:
 1517 002c 10200240 		.word	1073881104
 1518 0030 0C200240 		.word	1073881100
 1519 0034 14200240 		.word	1073881108
 1520              		.cfi_endproc
 1521              	.LFE30:
 1523              		.section	.text.flashErasePages,"ax",%progbits
 1524              		.align	1
 1525              		.global	flashErasePages
 1526              		.syntax unified
 1527              		.thumb
 1528              		.thumb_func
 1529              		.fpu softvfp
 1531              	flashErasePages:
 1532              	.LFB31:
 676:hardware.c    **** bool flashErasePages(u32 pageAddr, u16 n) {
 1533              		.loc 1 676 0
 1534              		.cfi_startproc
 1535              		@ args = 0, pretend = 0, frame = 0
 1536              		@ frame_needed = 0, uses_anonymous_args = 0
 1537              	.LVL124:
 1538 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1539              		.cfi_def_cfa_offset 24
 1540              		.cfi_offset 3, -24
 1541              		.cfi_offset 4, -20
 1542              		.cfi_offset 5, -16
 1543              		.cfi_offset 6, -12
 1544              		.cfi_offset 7, -8
 1545              		.cfi_offset 14, -4
 1546              		.loc 1 676 0
 1547 0002 0646     		mov	r6, r0
 677:hardware.c    ****     while (n-- > 0) {
 1548              		.loc 1 677 0
 1549 0004 4FF6FF75 		movw	r5, #65535
 1550 0008 0139     		subs	r1, r1, #1
 1551              	.LVL125:
 678:hardware.c    ****         if (!flashErasePage(pageAddr + wTransferSize * n)) {
 1552              		.loc 1 678 0
 1553 000a 084F     		ldr	r7, .L122
 1554 000c 8CB2     		uxth	r4, r1
 1555              	.LVL126:
 1556              	.L116:
 677:hardware.c    ****     while (n-- > 0) {
 1557              		.loc 1 677 0
 1558 000e AC42     		cmp	r4, r5
 1559 0010 01D1     		bne	.L118
 679:hardware.c    ****             return FALSE;
 680:hardware.c    ****         }
 681:hardware.c    ****     }
 682:hardware.c    **** 
 683:hardware.c    ****     return TRUE;
 1560              		.loc 1 683 0
 1561 0012 0120     		movs	r0, #1
 1562 0014 08E0     		b	.L117
 1563              	.L118:
 678:hardware.c    ****         if (!flashErasePage(pageAddr + wTransferSize * n)) {
 1564              		.loc 1 678 0
 1565 0016 3868     		ldr	r0, [r7]
 1566 0018 00FB0460 		mla	r0, r0, r4, r6
 1567 001c FFF7FEFF 		bl	flashErasePage
 1568              	.LVL127:
 1569 0020 013C     		subs	r4, r4, #1
 1570              	.LVL128:
 1571 0022 A4B2     		uxth	r4, r4
 1572 0024 0028     		cmp	r0, #0
 1573 0026 F2D1     		bne	.L116
 1574              	.L117:
 684:hardware.c    **** }
 1575              		.loc 1 684 0
 1576 0028 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1577              	.LVL129:
 1578              	.L123:
 1579 002a 00BF     		.align	2
 1580              	.L122:
 1581 002c 00000000 		.word	wTransferSize
 1582              		.cfi_endproc
 1583              	.LFE31:
 1585              		.section	.text.flashWriteWord,"ax",%progbits
 1586              		.align	1
 1587              		.global	flashWriteWord
 1588              		.syntax unified
 1589              		.thumb
 1590              		.thumb_func
 1591              		.fpu softvfp
 1593              	flashWriteWord:
 1594              	.LFB32:
 685:hardware.c    **** 
 686:hardware.c    **** bool flashWriteWord(u32 addr, u32 word) {
 1595              		.loc 1 686 0
 1596              		.cfi_startproc
 1597              		@ args = 0, pretend = 0, frame = 8
 1598              		@ frame_needed = 0, uses_anonymous_args = 0
 1599              	.LVL130:
 1600 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
 1601              		.cfi_def_cfa_offset 24
 1602              		.cfi_offset 4, -16
 1603              		.cfi_offset 5, -12
 1604              		.cfi_offset 6, -8
 1605              		.cfi_offset 14, -4
 687:hardware.c    ****     vu16 *flashAddr = (vu16 *)addr;
 688:hardware.c    ****     vu32 lhWord = (vu32)word & 0x0000FFFF;
 689:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 690:hardware.c    **** 
 691:hardware.c    ****     u32 rwmVal = GET_REG(FLASH_CR);
 692:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 1606              		.loc 1 692 0
 1607 0002 0124     		movs	r4, #1
 688:hardware.c    ****     vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
 1608              		.loc 1 688 0
 1609 0004 8BB2     		uxth	r3, r1
 1610 0006 0093     		str	r3, [sp]
 689:hardware.c    **** 
 1611              		.loc 1 689 0
 1612 0008 0B0C     		lsrs	r3, r1, #16
 1613 000a 0193     		str	r3, [sp, #4]
 691:hardware.c    ****     SET_REG(FLASH_CR, FLASH_CR_PG);
 1614              		.loc 1 691 0
 1615 000c 0E4B     		ldr	r3, .L131
 1616 000e 1A68     		ldr	r2, [r3]
 1617              	.LVL131:
 1618              		.loc 1 692 0
 1619 0010 1C60     		str	r4, [r3]
 693:hardware.c    **** 
 694:hardware.c    ****     /* apparently we need not write to FLASH_AR and can
 695:hardware.c    ****        simply do a native write of a half word */
 696:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1620              		.loc 1 696 0
 1621 0012 0E4C     		ldr	r4, .L131+4
 1622 0014 2546     		mov	r5, r4
 1623              	.L125:
 1624              		.loc 1 696 0 is_stmt 0 discriminator 1
 1625 0016 2668     		ldr	r6, [r4]
 1626 0018 F607     		lsls	r6, r6, #31
 1627 001a FCD4     		bmi	.L125
 697:hardware.c    ****     *(flashAddr + 0x01) = (vu16)hhWord;
 1628              		.loc 1 697 0 is_stmt 1
 1629 001c 019C     		ldr	r4, [sp, #4]
 1630 001e A4B2     		uxth	r4, r4
 1631 0020 4480     		strh	r4, [r0, #2]	@ movhi
 1632              	.L126:
 698:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1633              		.loc 1 698 0 discriminator 1
 1634 0022 2C68     		ldr	r4, [r5]
 1635 0024 E607     		lsls	r6, r4, #31
 1636 0026 FCD4     		bmi	.L126
 699:hardware.c    ****     *(flashAddr) = (vu16)lhWord;
 1637              		.loc 1 699 0
 1638 0028 009C     		ldr	r4, [sp]
 1639 002a A4B2     		uxth	r4, r4
 1640 002c 0480     		strh	r4, [r0]	@ movhi
 1641              	.L127:
 700:hardware.c    ****     while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
 1642              		.loc 1 700 0 discriminator 1
 1643 002e 2C68     		ldr	r4, [r5]
 1644 0030 E407     		lsls	r4, r4, #31
 1645 0032 FCD4     		bmi	.L127
 701:hardware.c    **** 
 702:hardware.c    ****     rwmVal &= 0xFFFFFFFE;
 1646              		.loc 1 702 0
 1647 0034 22F00102 		bic	r2, r2, #1
 1648              	.LVL132:
 703:hardware.c    ****     SET_REG(FLASH_CR, rwmVal);
 1649              		.loc 1 703 0
 1650 0038 1A60     		str	r2, [r3]
 704:hardware.c    **** 
 705:hardware.c    ****     /* verify the write */
 706:hardware.c    ****     if (*(vu32 *)addr != word) {
 1651              		.loc 1 706 0
 1652 003a 0068     		ldr	r0, [r0]
 1653              	.LVL133:
 707:hardware.c    ****         return FALSE;
 708:hardware.c    ****     }
 709:hardware.c    **** 
 710:hardware.c    ****     return TRUE;
 711:hardware.c    **** }
 1654              		.loc 1 711 0
 1655 003c 431A     		subs	r3, r0, r1
 1656 003e 5842     		rsbs	r0, r3, #0
 1657 0040 5841     		adcs	r0, r0, r3
 1658 0042 02B0     		add	sp, sp, #8
 1659              		.cfi_def_cfa_offset 16
 1660              		@ sp needed
 1661 0044 70BD     		pop	{r4, r5, r6, pc}
 1662              	.L132:
 1663 0046 00BF     		.align	2
 1664              	.L131:
 1665 0048 10200240 		.word	1073881104
 1666 004c 0C200240 		.word	1073881100
 1667              		.cfi_endproc
 1668              	.LFE32:
 1670              		.section	.text.flashLock,"ax",%progbits
 1671              		.align	1
 1672              		.global	flashLock
 1673              		.syntax unified
 1674              		.thumb
 1675              		.thumb_func
 1676              		.fpu softvfp
 1678              	flashLock:
 1679              	.LFB33:
 712:hardware.c    **** 
 713:hardware.c    **** void flashLock() {
 1680              		.loc 1 713 0
 1681              		.cfi_startproc
 1682              		@ args = 0, pretend = 0, frame = 0
 1683              		@ frame_needed = 0, uses_anonymous_args = 0
 1684              		@ link register save eliminated.
 714:hardware.c    ****     /* take down the HSI oscillator? it may be in use elsewhere */
 715:hardware.c    **** 
 716:hardware.c    ****     /* ensure all FPEC functions disabled and lock the FPEC */
 717:hardware.c    ****     SET_REG(FLASH_CR, 0x00000080);
 1685              		.loc 1 717 0
 1686 0000 8022     		movs	r2, #128
 1687 0002 014B     		ldr	r3, .L134
 1688 0004 1A60     		str	r2, [r3]
 718:hardware.c    **** }
 1689              		.loc 1 718 0
 1690 0006 7047     		bx	lr
 1691              	.L135:
 1692              		.align	2
 1693              	.L134:
 1694 0008 10200240 		.word	1073881104
 1695              		.cfi_endproc
 1696              	.LFE33:
 1698              		.section	.text.flashUnlock,"ax",%progbits
 1699              		.align	1
 1700              		.global	flashUnlock
 1701              		.syntax unified
 1702              		.thumb
 1703              		.thumb_func
 1704              		.fpu softvfp
 1706              	flashUnlock:
 1707              	.LFB34:
 719:hardware.c    **** 
 720:hardware.c    **** void flashUnlock() {
 1708              		.loc 1 720 0
 1709              		.cfi_startproc
 1710              		@ args = 0, pretend = 0, frame = 0
 1711              		@ frame_needed = 0, uses_anonymous_args = 0
 1712              		@ link register save eliminated.
 721:hardware.c    ****     /* unlock the flash */
 722:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY1);
 1713              		.loc 1 722 0
 1714 0000 034B     		ldr	r3, .L137
 1715 0002 044A     		ldr	r2, .L137+4
 1716 0004 1A60     		str	r2, [r3]
 723:hardware.c    ****     SET_REG(FLASH_KEYR, FLASH_KEY2);
 1717              		.loc 1 723 0
 1718 0006 02F18832 		add	r2, r2, #-2004318072
 1719 000a 1A60     		str	r2, [r3]
 724:hardware.c    **** }
 1720              		.loc 1 724 0
 1721 000c 7047     		bx	lr
 1722              	.L138:
 1723 000e 00BF     		.align	2
 1724              	.L137:
 1725 0010 04200240 		.word	1073881092
 1726 0014 23016745 		.word	1164378403
 1727              		.cfi_endproc
 1728              	.LFE34:
 1730              		.section	.text.crMask,"ax",%progbits
 1731              		.align	1
 1732              		.global	crMask
 1733              		.syntax unified
 1734              		.thumb
 1735              		.thumb_func
 1736              		.fpu softvfp
 1738              	crMask:
 1739              	.LFB35:
 725:hardware.c    **** 
 726:hardware.c    **** 
 727:hardware.c    **** // Used to create the control register masking pattern, when setting control register mode.
 728:hardware.c    **** unsigned int crMask(int pin)
 729:hardware.c    **** {
 1740              		.loc 1 729 0
 1741              		.cfi_startproc
 1742              		@ args = 0, pretend = 0, frame = 0
 1743              		@ frame_needed = 0, uses_anonymous_args = 0
 1744              		@ link register save eliminated.
 1745              	.LVL134:
 730:hardware.c    **** 	unsigned int mask;
 731:hardware.c    **** 	if (pin>=8)
 732:hardware.c    **** 	{
 733:hardware.c    **** 		pin-=8;
 734:hardware.c    **** 	}
 735:hardware.c    **** 	mask = 0x0F << (pin<<2);
 1746              		.loc 1 735 0
 1747 0000 0F23     		movs	r3, #15
 731:hardware.c    **** 	{
 1748              		.loc 1 731 0
 1749 0002 0728     		cmp	r0, #7
 733:hardware.c    **** 	}
 1750              		.loc 1 733 0
 1751 0004 C8BF     		it	gt
 1752 0006 0838     		subgt	r0, r0, #8
 1753              	.LVL135:
 1754              		.loc 1 735 0
 1755 0008 8000     		lsls	r0, r0, #2
 1756              	.LVL136:
 1757 000a 03FA00F0 		lsl	r0, r3, r0
 1758              	.LVL137:
 736:hardware.c    **** 	return ~mask;
 737:hardware.c    **** }	
 1759              		.loc 1 737 0
 1760 000e C043     		mvns	r0, r0
 1761              	.LVL138:
 1762 0010 7047     		bx	lr
 1763              		.cfi_endproc
 1764              	.LFE35:
 1766              		.section	.text.getFlashEnd,"ax",%progbits
 1767              		.align	1
 1768              		.global	getFlashEnd
 1769              		.syntax unified
 1770              		.thumb
 1771              		.thumb_func
 1772              		.fpu softvfp
 1774              	getFlashEnd:
 1775              	.LFB36:
 738:hardware.c    **** 
 739:hardware.c    **** #define FLASH_SIZE_REG 0x1FFFF7E0
 740:hardware.c    **** int getFlashEnd(void)
 741:hardware.c    **** {
 1776              		.loc 1 741 0
 1777              		.cfi_startproc
 1778              		@ args = 0, pretend = 0, frame = 0
 1779              		@ frame_needed = 0, uses_anonymous_args = 0
 1780              		@ link register save eliminated.
 1781              	.LVL139:
 742:hardware.c    **** 	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
 743:hardware.c    **** 	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
 1782              		.loc 1 743 0
 1783 0000 024B     		ldr	r3, .L142
 1784 0002 1888     		ldrh	r0, [r3]
 1785 0004 00F50030 		add	r0, r0, #131072
 744:hardware.c    **** }
 1786              		.loc 1 744 0
 1787 0008 8002     		lsls	r0, r0, #10
 1788 000a 7047     		bx	lr
 1789              	.L143:
 1790              		.align	2
 1791              	.L142:
 1792 000c E0F7FF1F 		.word	536868832
 1793              		.cfi_endproc
 1794              	.LFE36:
 1796              		.section	.text.getFlashPageSize,"ax",%progbits
 1797              		.align	1
 1798              		.global	getFlashPageSize
 1799              		.syntax unified
 1800              		.thumb
 1801              		.thumb_func
 1802              		.fpu softvfp
 1804              	getFlashPageSize:
 1805              	.LFB37:
 745:hardware.c    **** 
 746:hardware.c    **** int getFlashPageSize(void)
 747:hardware.c    **** {
 1806              		.loc 1 747 0
 1807              		.cfi_startproc
 1808              		@ args = 0, pretend = 0, frame = 0
 1809              		@ frame_needed = 0, uses_anonymous_args = 0
 1810              		@ link register save eliminated.
 1811              	.LVL140:
 748:hardware.c    **** 	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
 749:hardware.c    **** 	if ((*flashSize & 0xffff) > 128)
 1812              		.loc 1 749 0
 1813 0000 044B     		ldr	r3, .L147
 1814 0002 1B88     		ldrh	r3, [r3]
 1815 0004 802B     		cmp	r3, #128
 750:hardware.c    **** 	{
 751:hardware.c    **** 		return 0x800;
 752:hardware.c    **** 	}
 753:hardware.c    **** 	else
 754:hardware.c    **** 	{
 755:hardware.c    **** 		return 0x400;
 756:hardware.c    **** 	}
 757:hardware.c    **** }
 1816              		.loc 1 757 0
 1817 0006 8CBF     		ite	hi
 1818 0008 4FF40060 		movhi	r0, #2048
 1819 000c 4FF48060 		movls	r0, #1024
 1820 0010 7047     		bx	lr
 1821              	.L148:
 1822 0012 00BF     		.align	2
 1823              	.L147:
 1824 0014 E0F7FF1F 		.word	536868832
 1825              		.cfi_endproc
 1826              	.LFE37:
 1828              		.section	.text.isSecure,"ax",%progbits
 1829              		.align	1
 1830              		.global	isSecure
 1831              		.syntax unified
 1832              		.thumb
 1833              		.thumb_func
 1834              		.fpu softvfp
 1836              	isSecure:
 1837              	.LFB38:
 758:hardware.c    **** 
 759:hardware.c    **** // Security Fusings
 760:hardware.c    **** int isSecure(void) 
 761:hardware.c    **** {
 1838              		.loc 1 761 0
 1839              		.cfi_startproc
 1840              		@ args = 0, pretend = 0, frame = 0
 1841              		@ frame_needed = 0, uses_anonymous_args = 0
 1842              		@ link register save eliminated.
 762:hardware.c    ****     // TODO proper fusing
 763:hardware.c    ****     return 0;
 764:hardware.c    **** }
 1843              		.loc 1 764 0
 1844 0000 0020     		movs	r0, #0
 1845 0002 7047     		bx	lr
 1846              		.cfi_endproc
 1847              	.LFE38:
 1849              		.section	.text.isProduction,"ax",%progbits
 1850              		.align	1
 1851              		.global	isProduction
 1852              		.syntax unified
 1853              		.thumb
 1854              		.thumb_func
 1855              		.fpu softvfp
 1857              	isProduction:
 1858              	.LFB41:
 1859              		.cfi_startproc
 1860              		@ args = 0, pretend = 0, frame = 0
 1861              		@ frame_needed = 0, uses_anonymous_args = 0
 1862              		@ link register save eliminated.
 1863 0000 0020     		movs	r0, #0
 1864 0002 7047     		bx	lr
 1865              		.cfi_endproc
 1866              	.LFE41:
 1868              		.comm	rootCA,32,1
 1869              		.comm	wTransferSize,4,4
 1870              		.section	.rodata.hexdump.str1.1,"aMS",%progbits,1
 1871              	.LC3:
 1872 0000 207C2573 		.ascii	" |%s|\012\000"
 1872      7C0A00
 1873              	.LC4:
 1874 0007 2000     		.ascii	" \000"
 1875              	.LC5:
 1876 0009 25303258 		.ascii	"%02X \000"
 1876      2000
 1877              	.LC6:
 1878 000f 20202000 		.ascii	"   \000"
 1879              		.section	.rodata.print_hex.str1.1,"aMS",%progbits,1
 1880              	.LC0:
 1881 0000 25733A20 		.ascii	"%s: \000"
 1881      00
 1882              	.LC1:
 1883 0005 25303278 		.ascii	"%02x\000"
 1883      00
 1884              	.LC2:
 1885 000a 0A00     		.ascii	"\012\000"
 1886              		.text
 1887              	.Letext0:
 1888              		.file 2 "/usr/arm-none-eabi/include/machine/_default_types.h"
 1889              		.file 3 "/usr/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h"
 1890              		.file 4 "/usr/lib/gcc/arm-none-eabi/7.3.1/include/stdarg.h"
 1891              		.file 5 "/usr/arm-none-eabi/include/stdio.h"
 1892              		.file 6 "/usr/arm-none-eabi/include/sys/lock.h"
 1893              		.file 7 "/usr/arm-none-eabi/include/sys/_types.h"
 1894              		.file 8 "/usr/arm-none-eabi/include/sys/reent.h"
 1895              		.file 9 "<built-in>"
 1896              		.file 10 "/usr/arm-none-eabi/include/sys/_stdint.h"
 1897              		.file 11 "/usr/arm-none-eabi/include/sys/unistd.h"
 1898              		.file 12 "/usr/arm-none-eabi/include/sys/errno.h"
 1899              		.file 13 "./stm32_lib/stm32f10x_type.h"
 1900              		.file 14 "hardware.h"
 1901              		.file 15 "./usb_lib/usb_regs.h"
 1902              		.file 16 "./usb_lib/usb_core.h"
 1903              		.file 17 "./usb_lib/usb_init.h"
 1904              		.file 18 "usb_descriptor.h"
 1905              		.file 19 "usb.h"
 1906              		.file 20 "./25519/f25519.h"
 1907              		.file 21 "./25519/c25519.h"
 1908              		.file 22 "image.h"
 1909              		.file 23 "./base64/cencode.h"
 1910              		.file 24 "./base64/cdecode.h"
 1911              		.file 25 "/usr/arm-none-eabi/include/string.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 hardware.c
     /tmp/ccWn3AVX.s:16     .text.gpio_write_bit:0000000000000000 $t
     /tmp/ccWn3AVX.s:23     .text.gpio_write_bit:0000000000000000 gpio_write_bit
     /tmp/ccWn3AVX.s:51     .text.readPin:0000000000000000 $t
     /tmp/ccWn3AVX.s:58     .text.readPin:0000000000000000 readPin
     /tmp/ccWn3AVX.s:82     .text.strobePin:0000000000000000 $t
     /tmp/ccWn3AVX.s:89     .text.strobePin:0000000000000000 strobePin
     /tmp/ccWn3AVX.s:188    .text.UU_PutChar:0000000000000000 $t
     /tmp/ccWn3AVX.s:195    .text.UU_PutChar:0000000000000000 UU_PutChar
     /tmp/ccWn3AVX.s:218    .text.UU_PutString:0000000000000000 $t
     /tmp/ccWn3AVX.s:225    .text.UU_PutString:0000000000000000 UU_PutString
     /tmp/ccWn3AVX.s:258    .text.vprint:0000000000000000 $t
     /tmp/ccWn3AVX.s:265    .text.vprint:0000000000000000 vprint
     /tmp/ccWn3AVX.s:301    .text.vprint:0000000000000020 $d
     /tmp/ccWn3AVX.s:306    .text.uart_printf:0000000000000000 $t
     /tmp/ccWn3AVX.s:313    .text.uart_printf:0000000000000000 uart_printf
     /tmp/ccWn3AVX.s:355    .text.print_hex:0000000000000000 $t
     /tmp/ccWn3AVX.s:362    .text.print_hex:0000000000000000 print_hex
     /tmp/ccWn3AVX.s:426    .text.print_hex:0000000000000030 $d
     /tmp/ccWn3AVX.s:433    .text.hexdump:0000000000000000 $t
     /tmp/ccWn3AVX.s:440    .text.hexdump:0000000000000000 hexdump
     /tmp/ccWn3AVX.s:576    .text.hexdump:00000000000000a8 $d
     /tmp/ccWn3AVX.s:584    .text.print_hash:0000000000000000 $t
     /tmp/ccWn3AVX.s:591    .text.print_hash:0000000000000000 print_hash
     /tmp/ccWn3AVX.s:636    .text.print_hash:0000000000000024 $d
     /tmp/ccWn3AVX.s:642    .text.decode_b64:0000000000000000 $t
     /tmp/ccWn3AVX.s:649    .text.decode_b64:0000000000000000 decode_b64
     /tmp/ccWn3AVX.s:693    .text.encode_b64:0000000000000000 $t
     /tmp/ccWn3AVX.s:700    .text.encode_b64:0000000000000000 encode_b64
     /tmp/ccWn3AVX.s:755    .text.uartInit:0000000000000000 $t
     /tmp/ccWn3AVX.s:762    .text.uartInit:0000000000000000 uartInit
     /tmp/ccWn3AVX.s:851    .text.uartInit:0000000000000080 $d
     /tmp/ccWn3AVX.s:856    .text.systemReset:0000000000000000 $t
     /tmp/ccWn3AVX.s:863    .text.systemReset:0000000000000000 systemReset
     /tmp/ccWn3AVX.s:906    .text.systemReset:0000000000000038 $d
     /tmp/ccWn3AVX.s:914    .text.setupCLK:0000000000000000 $t
     /tmp/ccWn3AVX.s:921    .text.setupCLK:0000000000000000 setupCLK
     /tmp/ccWn3AVX.s:980    .text.setupCLK:0000000000000058 $d
     /tmp/ccWn3AVX.s:986    .text.setupLEDAndButton:0000000000000000 $t
     /tmp/ccWn3AVX.s:993    .text.setupLEDAndButton:0000000000000000 setupLEDAndButton
     /tmp/ccWn3AVX.s:1011   .text.setupLEDAndButton:0000000000000010 $d
     /tmp/ccWn3AVX.s:1016   .text.setupFLASH:0000000000000000 $t
     /tmp/ccWn3AVX.s:1023   .text.setupFLASH:0000000000000000 setupFLASH
     /tmp/ccWn3AVX.s:1056   .text.setupFLASH:0000000000000018 $d
     /tmp/ccWn3AVX.s:1061   .text.uid_read:0000000000000000 $t
     /tmp/ccWn3AVX.s:1068   .text.uid_read:0000000000000000 uid_read
     /tmp/ccWn3AVX.s:1082   .text.setMspAndJump:0000000000000000 $t
     /tmp/ccWn3AVX.s:1089   .text.setMspAndJump:0000000000000000 setMspAndJump
     /tmp/ccWn3AVX.s:1119   .text.setMspAndJump:0000000000000010 $d
     /tmp/ccWn3AVX.s:1124   .text.bkp10Write:0000000000000000 $t
     /tmp/ccWn3AVX.s:1131   .text.bkp10Write:0000000000000000 bkp10Write
     /tmp/ccWn3AVX.s:1161   .text.bkp10Write:0000000000000024 $d
     /tmp/ccWn3AVX.s:1168   .text.checkAndClearBootloaderFlag:0000000000000000 $t
     /tmp/ccWn3AVX.s:1175   .text.checkAndClearBootloaderFlag:0000000000000000 checkAndClearBootloaderFlag
     /tmp/ccWn3AVX.s:1231   .text.checkAndClearBootloaderFlag:0000000000000040 $d
     /tmp/ccWn3AVX.s:1237   .text.nvicInit:0000000000000000 $t
     /tmp/ccWn3AVX.s:1244   .text.nvicInit:0000000000000000 nvicInit
     /tmp/ccWn3AVX.s:1333   .text.nvicInit:0000000000000064 $d
     /tmp/ccWn3AVX.s:1339   .text.nvicDisableInterrupts:0000000000000000 $t
     /tmp/ccWn3AVX.s:1346   .text.nvicDisableInterrupts:0000000000000000 nvicDisableInterrupts
     /tmp/ccWn3AVX.s:1372   .text.nvicDisableInterrupts:0000000000000020 $d
     /tmp/ccWn3AVX.s:1377   .text.jumpToUser:0000000000000000 $t
     /tmp/ccWn3AVX.s:1384   .text.jumpToUser:0000000000000000 jumpToUser
     /tmp/ccWn3AVX.s:1424   .text.systemHardReset:0000000000000000 $t
     /tmp/ccWn3AVX.s:1431   .text.systemHardReset:0000000000000000 systemHardReset
     /tmp/ccWn3AVX.s:1455   .text.systemHardReset:000000000000000c $d
     /tmp/ccWn3AVX.s:1461   .text.flashErasePage:0000000000000000 $t
     /tmp/ccWn3AVX.s:1468   .text.flashErasePage:0000000000000000 flashErasePage
     /tmp/ccWn3AVX.s:1517   .text.flashErasePage:000000000000002c $d
     /tmp/ccWn3AVX.s:1524   .text.flashErasePages:0000000000000000 $t
     /tmp/ccWn3AVX.s:1531   .text.flashErasePages:0000000000000000 flashErasePages
     /tmp/ccWn3AVX.s:1581   .text.flashErasePages:000000000000002c $d
                            *COM*:0000000000000004 wTransferSize
     /tmp/ccWn3AVX.s:1586   .text.flashWriteWord:0000000000000000 $t
     /tmp/ccWn3AVX.s:1593   .text.flashWriteWord:0000000000000000 flashWriteWord
     /tmp/ccWn3AVX.s:1665   .text.flashWriteWord:0000000000000048 $d
     /tmp/ccWn3AVX.s:1671   .text.flashLock:0000000000000000 $t
     /tmp/ccWn3AVX.s:1678   .text.flashLock:0000000000000000 flashLock
     /tmp/ccWn3AVX.s:1694   .text.flashLock:0000000000000008 $d
     /tmp/ccWn3AVX.s:1699   .text.flashUnlock:0000000000000000 $t
     /tmp/ccWn3AVX.s:1706   .text.flashUnlock:0000000000000000 flashUnlock
     /tmp/ccWn3AVX.s:1725   .text.flashUnlock:0000000000000010 $d
     /tmp/ccWn3AVX.s:1731   .text.crMask:0000000000000000 $t
     /tmp/ccWn3AVX.s:1738   .text.crMask:0000000000000000 crMask
     /tmp/ccWn3AVX.s:1767   .text.getFlashEnd:0000000000000000 $t
     /tmp/ccWn3AVX.s:1774   .text.getFlashEnd:0000000000000000 getFlashEnd
     /tmp/ccWn3AVX.s:1792   .text.getFlashEnd:000000000000000c $d
     /tmp/ccWn3AVX.s:1797   .text.getFlashPageSize:0000000000000000 $t
     /tmp/ccWn3AVX.s:1804   .text.getFlashPageSize:0000000000000000 getFlashPageSize
     /tmp/ccWn3AVX.s:1824   .text.getFlashPageSize:0000000000000014 $d
     /tmp/ccWn3AVX.s:1829   .text.isSecure:0000000000000000 $t
     /tmp/ccWn3AVX.s:1836   .text.isSecure:0000000000000000 isSecure
     /tmp/ccWn3AVX.s:1850   .text.isProduction:0000000000000000 $t
     /tmp/ccWn3AVX.s:1857   .text.isProduction:0000000000000000 isProduction
                            *COM*:0000000000000020 rootCA

UNDEFINED SYMBOLS
vsprintf
memset
base64_init_decodestate
strlen
base64_decode_block
base64_init_encodestate
base64_encode_block
base64_encode_blockend
RCC_APB2PeriphClockCmd
GPIO_Init
USART_ClockStructInit
USART_ClockInit
USART_Init
USART_Cmd
usbDsbISR
usbDsbBus
