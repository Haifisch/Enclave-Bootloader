   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"sxmlc.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text._count_new_char_line,"ax",%progbits
  19              		.align	1
  20              		.thumb
  21              		.thumb_func
  23              	_count_new_char_line:
  24              	.LFB34:
  25              		.file 1 "sxmlc/sxmlc.c"
   1:sxmlc/sxmlc.c **** /*
   2:sxmlc/sxmlc.c **** 	Copyright (c) 2010, Matthieu Labas
   3:sxmlc/sxmlc.c **** 	All rights reserved.
   4:sxmlc/sxmlc.c **** 
   5:sxmlc/sxmlc.c **** 	Redistribution and use in source and binary forms, with or without modification,
   6:sxmlc/sxmlc.c **** 	are permitted provided that the following conditions are met:
   7:sxmlc/sxmlc.c **** 
   8:sxmlc/sxmlc.c **** 	1. Redistributions of source code must retain the above copyright notice,
   9:sxmlc/sxmlc.c **** 	   this list of conditions and the following disclaimer.
  10:sxmlc/sxmlc.c **** 
  11:sxmlc/sxmlc.c **** 	2. Redistributions in binary form must reproduce the above copyright notice,
  12:sxmlc/sxmlc.c **** 	   this list of conditions and the following disclaimer in the documentation
  13:sxmlc/sxmlc.c **** 	   and/or other materials provided with the distribution.
  14:sxmlc/sxmlc.c **** 
  15:sxmlc/sxmlc.c **** 	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
  16:sxmlc/sxmlc.c **** 	ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
  17:sxmlc/sxmlc.c **** 	WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  18:sxmlc/sxmlc.c **** 	IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
  19:sxmlc/sxmlc.c **** 	INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  20:sxmlc/sxmlc.c **** 	NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  21:sxmlc/sxmlc.c **** 	PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
  22:sxmlc/sxmlc.c **** 	WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  23:sxmlc/sxmlc.c **** 	ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
  24:sxmlc/sxmlc.c **** 	OF SUCH DAMAGE.
  25:sxmlc/sxmlc.c **** 
  26:sxmlc/sxmlc.c **** 	The views and conclusions contained in the software and documentation are those of the
  27:sxmlc/sxmlc.c **** 	authors and should not be interpreted as representing official policies, either expressed
  28:sxmlc/sxmlc.c **** 	or implied, of the FreeBSD Project.
  29:sxmlc/sxmlc.c **** */
  30:sxmlc/sxmlc.c **** #if defined(WIN32) || defined(WIN64)
  31:sxmlc/sxmlc.c **** #pragma warning(disable : 4996)
  32:sxmlc/sxmlc.c **** #else
  33:sxmlc/sxmlc.c **** #ifndef strdup
  34:sxmlc/sxmlc.c **** #define _GNU_SOURCE
  35:sxmlc/sxmlc.c **** #endif
  36:sxmlc/sxmlc.c **** #endif
  37:sxmlc/sxmlc.c **** 
  38:sxmlc/sxmlc.c **** #include <stdio.h>
  39:sxmlc/sxmlc.c **** #include <stdlib.h>
  40:sxmlc/sxmlc.c **** #include <string.h>
  41:sxmlc/sxmlc.c **** #include <ctype.h>
  42:sxmlc/sxmlc.c **** #include "sxmlc.h"
  43:sxmlc/sxmlc.c **** 
  44:sxmlc/sxmlc.c **** /*
  45:sxmlc/sxmlc.c ****  Struct defining "special" tags such as "<? ?>" or "<![CDATA[ ]]/>".
  46:sxmlc/sxmlc.c ****  These tags are considered having a start and an end with some data in between that will
  47:sxmlc/sxmlc.c ****  be stored in the 'tag' member of an XMLNode.
  48:sxmlc/sxmlc.c ****  The 'tag_type' member is a constant that is associated to such tag.
  49:sxmlc/sxmlc.c ****  All 'len_*' members are basically the "sx_strlen()" of 'start' and 'end' members.
  50:sxmlc/sxmlc.c ****  */
  51:sxmlc/sxmlc.c **** typedef struct _Tag {
  52:sxmlc/sxmlc.c **** 	TagType tag_type;
  53:sxmlc/sxmlc.c **** 	SXML_CHAR* start;
  54:sxmlc/sxmlc.c **** 	int len_start;
  55:sxmlc/sxmlc.c **** 	SXML_CHAR* end;
  56:sxmlc/sxmlc.c **** 	int len_end;
  57:sxmlc/sxmlc.c **** } _TAG;
  58:sxmlc/sxmlc.c **** 
  59:sxmlc/sxmlc.c **** typedef struct _SpecialTag {
  60:sxmlc/sxmlc.c **** 	_TAG *tags;
  61:sxmlc/sxmlc.c **** 	int n_tags;
  62:sxmlc/sxmlc.c **** } SPECIAL_TAG;
  63:sxmlc/sxmlc.c **** 
  64:sxmlc/sxmlc.c **** /*
  65:sxmlc/sxmlc.c ****  List of "special" tags handled by sxmlc.
  66:sxmlc/sxmlc.c ****  NB the "<!DOCTYPE" tag has a special handling because its 'end' changes according
  67:sxmlc/sxmlc.c ****  to its content ('>' or ']>').
  68:sxmlc/sxmlc.c ****  */
  69:sxmlc/sxmlc.c **** static _TAG _spec[] = {
  70:sxmlc/sxmlc.c **** 		{ TAG_INSTR, C2SX("<?"), 2, C2SX("?>"), 2 },
  71:sxmlc/sxmlc.c **** 		{ TAG_COMMENT, C2SX("<!--"), 4, C2SX("-->"), 3 },
  72:sxmlc/sxmlc.c **** 		{ TAG_CDATA, C2SX("<![CDATA["), 9, C2SX("]]>"), 3 }
  73:sxmlc/sxmlc.c **** };
  74:sxmlc/sxmlc.c **** static int NB_SPECIAL_TAGS = (int)(sizeof(_spec) / sizeof(_TAG)); /* Auto computation of number of 
  75:sxmlc/sxmlc.c **** 
  76:sxmlc/sxmlc.c **** /*
  77:sxmlc/sxmlc.c ****  User-registered tags.
  78:sxmlc/sxmlc.c ****  */
  79:sxmlc/sxmlc.c **** static SPECIAL_TAG _user_tags = { NULL, 0 };
  80:sxmlc/sxmlc.c **** 
  81:sxmlc/sxmlc.c **** int XML_register_user_tag(TagType tag_type, SXML_CHAR* start, SXML_CHAR* end)
  82:sxmlc/sxmlc.c **** {
  83:sxmlc/sxmlc.c **** 	_TAG* p;
  84:sxmlc/sxmlc.c **** 	int i, n, le;
  85:sxmlc/sxmlc.c **** 
  86:sxmlc/sxmlc.c **** 	if (tag_type < TAG_USER)
  87:sxmlc/sxmlc.c **** 		return -1;
  88:sxmlc/sxmlc.c **** 
  89:sxmlc/sxmlc.c **** 	if (start == NULL || end == NULL || *start != C2SX('<'))
  90:sxmlc/sxmlc.c **** 		return -1;
  91:sxmlc/sxmlc.c **** 
  92:sxmlc/sxmlc.c **** 	le = sx_strlen(end);
  93:sxmlc/sxmlc.c **** 	if (end[le-1] != C2SX('>'))
  94:sxmlc/sxmlc.c **** 		return -1;
  95:sxmlc/sxmlc.c **** 
  96:sxmlc/sxmlc.c **** 	i = _user_tags.n_tags;
  97:sxmlc/sxmlc.c **** 	n = i + 1;
  98:sxmlc/sxmlc.c **** 	p = (_TAG*)__realloc(_user_tags.tags, n * sizeof(_TAG));
  99:sxmlc/sxmlc.c **** 	if (p == NULL)
 100:sxmlc/sxmlc.c **** 		return -1;
 101:sxmlc/sxmlc.c **** 
 102:sxmlc/sxmlc.c **** 	p[i].tag_type = tag_type;
 103:sxmlc/sxmlc.c **** 	p[i].start = start;
 104:sxmlc/sxmlc.c **** 	p[i].end = end;
 105:sxmlc/sxmlc.c **** 	p[i].len_start = sx_strlen(start);
 106:sxmlc/sxmlc.c **** 	p[i].len_end = le;
 107:sxmlc/sxmlc.c **** 	_user_tags.tags = p;
 108:sxmlc/sxmlc.c **** 	_user_tags.n_tags = n;
 109:sxmlc/sxmlc.c **** 
 110:sxmlc/sxmlc.c **** 	return i;
 111:sxmlc/sxmlc.c **** }
 112:sxmlc/sxmlc.c **** 
 113:sxmlc/sxmlc.c **** int XML_unregister_user_tag(int i_tag)
 114:sxmlc/sxmlc.c **** {
 115:sxmlc/sxmlc.c **** 	_TAG* pt;
 116:sxmlc/sxmlc.c **** 
 117:sxmlc/sxmlc.c **** 	if (i_tag < 0 || i_tag >= _user_tags.n_tags)
 118:sxmlc/sxmlc.c ****  		return -1;
 119:sxmlc/sxmlc.c **** 
 120:sxmlc/sxmlc.c **** 	if (_user_tags.n_tags == 1)
 121:sxmlc/sxmlc.c **** 		pt = NULL;
 122:sxmlc/sxmlc.c **** 	else {
 123:sxmlc/sxmlc.c **** 		pt = (_TAG*)__malloc((_user_tags.n_tags - 1) * sizeof(_TAG));
 124:sxmlc/sxmlc.c **** 		if (pt == NULL)
 125:sxmlc/sxmlc.c **** 			return -1;
 126:sxmlc/sxmlc.c **** 	}
 127:sxmlc/sxmlc.c ****  
 128:sxmlc/sxmlc.c **** 	if (pt != NULL) {
 129:sxmlc/sxmlc.c **** 		memcpy(pt, _user_tags.tags, i_tag * sizeof(_TAG));
 130:sxmlc/sxmlc.c **** 		memcpy(&pt[i_tag], &_user_tags.tags[i_tag + 1], (_user_tags.n_tags - i_tag - 1) * sizeof(_TAG));
 131:sxmlc/sxmlc.c **** 	}
 132:sxmlc/sxmlc.c **** 	if (_user_tags.tags != NULL)
 133:sxmlc/sxmlc.c **** 		__free(_user_tags.tags);
 134:sxmlc/sxmlc.c **** 	_user_tags.tags = pt;
 135:sxmlc/sxmlc.c **** 	_user_tags.n_tags--;
 136:sxmlc/sxmlc.c **** 
 137:sxmlc/sxmlc.c **** 	return _user_tags.n_tags;
 138:sxmlc/sxmlc.c **** }
 139:sxmlc/sxmlc.c **** 
 140:sxmlc/sxmlc.c **** int XML_get_nb_registered_user_tags(void)
 141:sxmlc/sxmlc.c **** {
 142:sxmlc/sxmlc.c **** 	return _user_tags.n_tags;
 143:sxmlc/sxmlc.c **** }
 144:sxmlc/sxmlc.c **** 
 145:sxmlc/sxmlc.c **** int XML_get_registered_user_tag(TagType tag_type)
 146:sxmlc/sxmlc.c **** {
 147:sxmlc/sxmlc.c **** 	int i;
 148:sxmlc/sxmlc.c **** 
 149:sxmlc/sxmlc.c **** 	for (i = 0; i < _user_tags.n_tags; i++)
 150:sxmlc/sxmlc.c **** 		if (_user_tags.tags[i].tag_type == tag_type)
 151:sxmlc/sxmlc.c **** 			return i;
 152:sxmlc/sxmlc.c **** 
 153:sxmlc/sxmlc.c **** 	return -1;
 154:sxmlc/sxmlc.c **** }
 155:sxmlc/sxmlc.c **** 
 156:sxmlc/sxmlc.c **** /* --- XMLNode methods --- */
 157:sxmlc/sxmlc.c **** 
 158:sxmlc/sxmlc.c **** /*
 159:sxmlc/sxmlc.c ****  Add 'node' to given '*children_array' of '*len_array' elements.
 160:sxmlc/sxmlc.c ****  '*len_array' is overwritten with the number of elements in '*children_array' after its reallocatio
 161:sxmlc/sxmlc.c ****  Return the index of the newly added 'node' in '*children_array', or '-1' for memory error.
 162:sxmlc/sxmlc.c ****  */
 163:sxmlc/sxmlc.c **** static int _add_node(XMLNode*** children_array, int* len_array, XMLNode* node)
 164:sxmlc/sxmlc.c **** {
 165:sxmlc/sxmlc.c **** 	XMLNode** pt = (XMLNode**)__realloc(*children_array, (*len_array+1) * sizeof(XMLNode*));
 166:sxmlc/sxmlc.c **** 	
 167:sxmlc/sxmlc.c **** 	if (pt == NULL)
 168:sxmlc/sxmlc.c **** 		return -1;
 169:sxmlc/sxmlc.c **** 	
 170:sxmlc/sxmlc.c **** 	pt[*len_array] = node;
 171:sxmlc/sxmlc.c **** 	*children_array = pt;
 172:sxmlc/sxmlc.c **** 	
 173:sxmlc/sxmlc.c **** 	return (*len_array)++;
 174:sxmlc/sxmlc.c **** }
 175:sxmlc/sxmlc.c **** 
 176:sxmlc/sxmlc.c **** int XMLNode_init(XMLNode* node)
 177:sxmlc/sxmlc.c **** {
 178:sxmlc/sxmlc.c **** 	if (node == NULL)
 179:sxmlc/sxmlc.c **** 		return false;
 180:sxmlc/sxmlc.c **** 	
 181:sxmlc/sxmlc.c **** 	if (node->init_value == XML_INIT_DONE)
 182:sxmlc/sxmlc.c **** 		return true; /*(void)XMLNode_free(node);*/
 183:sxmlc/sxmlc.c **** 
 184:sxmlc/sxmlc.c **** 	node->tag = NULL;
 185:sxmlc/sxmlc.c **** 	node->text = NULL;
 186:sxmlc/sxmlc.c **** 	
 187:sxmlc/sxmlc.c **** 	node->attributes = NULL;
 188:sxmlc/sxmlc.c **** 	node->n_attributes = 0;
 189:sxmlc/sxmlc.c **** 	
 190:sxmlc/sxmlc.c **** 	node->father = NULL;
 191:sxmlc/sxmlc.c **** 	node->children = NULL;
 192:sxmlc/sxmlc.c **** 	node->n_children = 0;
 193:sxmlc/sxmlc.c **** 	
 194:sxmlc/sxmlc.c **** 	node->tag_type = TAG_NONE;
 195:sxmlc/sxmlc.c **** 	node->active = true;
 196:sxmlc/sxmlc.c **** 
 197:sxmlc/sxmlc.c **** 	node->init_value = XML_INIT_DONE;
 198:sxmlc/sxmlc.c **** 
 199:sxmlc/sxmlc.c **** 	return true;
 200:sxmlc/sxmlc.c **** }
 201:sxmlc/sxmlc.c **** 
 202:sxmlc/sxmlc.c **** XMLNode* XMLNode_allocN(int n)
 203:sxmlc/sxmlc.c **** {
 204:sxmlc/sxmlc.c **** 	int i;
 205:sxmlc/sxmlc.c **** 	XMLNode* p;
 206:sxmlc/sxmlc.c **** 	
 207:sxmlc/sxmlc.c **** 	if (n <= 0)
 208:sxmlc/sxmlc.c **** 		return NULL;
 209:sxmlc/sxmlc.c **** 	
 210:sxmlc/sxmlc.c **** 	p = (XMLNode*)__calloc(n, sizeof(XMLNode));
 211:sxmlc/sxmlc.c **** 	if (p == NULL)
 212:sxmlc/sxmlc.c **** 		return NULL;
 213:sxmlc/sxmlc.c **** 
 214:sxmlc/sxmlc.c **** 	for (i = 0; i < n; i++)
 215:sxmlc/sxmlc.c **** 		(void)XMLNode_init(&p[i]);
 216:sxmlc/sxmlc.c **** 	
 217:sxmlc/sxmlc.c **** 	return p;
 218:sxmlc/sxmlc.c **** }
 219:sxmlc/sxmlc.c **** 
 220:sxmlc/sxmlc.c **** XMLNode* XMLNode_dup(const XMLNode* node, int copy_children)
 221:sxmlc/sxmlc.c **** {
 222:sxmlc/sxmlc.c **** 	XMLNode* n;
 223:sxmlc/sxmlc.c **** 
 224:sxmlc/sxmlc.c **** 	if (node == NULL)
 225:sxmlc/sxmlc.c **** 		return NULL;
 226:sxmlc/sxmlc.c **** 
 227:sxmlc/sxmlc.c **** 	n = (XMLNode*)__calloc(1, sizeof(XMLNode));
 228:sxmlc/sxmlc.c **** 	if (n == NULL)
 229:sxmlc/sxmlc.c **** 		return NULL;
 230:sxmlc/sxmlc.c **** 
 231:sxmlc/sxmlc.c **** 	XMLNode_init(n);
 232:sxmlc/sxmlc.c **** 	if (!XMLNode_copy(n, node, copy_children)) {
 233:sxmlc/sxmlc.c **** 		XMLNode_free(n);
 234:sxmlc/sxmlc.c **** 
 235:sxmlc/sxmlc.c **** 		return NULL;
 236:sxmlc/sxmlc.c **** 	}
 237:sxmlc/sxmlc.c **** 
 238:sxmlc/sxmlc.c **** 	return n;
 239:sxmlc/sxmlc.c **** }
 240:sxmlc/sxmlc.c **** 
 241:sxmlc/sxmlc.c **** int XMLNode_free(XMLNode* node)
 242:sxmlc/sxmlc.c **** {
 243:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 244:sxmlc/sxmlc.c **** 		return false;
 245:sxmlc/sxmlc.c **** 	
 246:sxmlc/sxmlc.c **** 	if (node->tag != NULL) {
 247:sxmlc/sxmlc.c **** 		__free(node->tag);
 248:sxmlc/sxmlc.c **** 		node->tag = NULL;
 249:sxmlc/sxmlc.c **** 	}
 250:sxmlc/sxmlc.c **** 
 251:sxmlc/sxmlc.c **** 	XMLNode_remove_text(node);
 252:sxmlc/sxmlc.c **** 	XMLNode_remove_all_attributes(node);
 253:sxmlc/sxmlc.c **** 	XMLNode_remove_children(node);
 254:sxmlc/sxmlc.c **** 	
 255:sxmlc/sxmlc.c **** 	node->tag_type = TAG_NONE;
 256:sxmlc/sxmlc.c **** 
 257:sxmlc/sxmlc.c **** 	return true;
 258:sxmlc/sxmlc.c **** }
 259:sxmlc/sxmlc.c **** 
 260:sxmlc/sxmlc.c **** int XMLNode_copy(XMLNode* dst, const XMLNode* src, int copy_children)
 261:sxmlc/sxmlc.c **** {
 262:sxmlc/sxmlc.c **** 	int i;
 263:sxmlc/sxmlc.c **** 	
 264:sxmlc/sxmlc.c **** 	if (dst == NULL || (src != NULL && src->init_value != XML_INIT_DONE))
 265:sxmlc/sxmlc.c **** 		return false;
 266:sxmlc/sxmlc.c **** 	
 267:sxmlc/sxmlc.c **** 	(void)XMLNode_free(dst); /* 'dst' is freed first */
 268:sxmlc/sxmlc.c **** 	
 269:sxmlc/sxmlc.c **** 	/* NULL 'src' resets 'dst' */
 270:sxmlc/sxmlc.c **** 	if (src == NULL)
 271:sxmlc/sxmlc.c **** 		return true;
 272:sxmlc/sxmlc.c **** 	
 273:sxmlc/sxmlc.c **** 	/* Tag */
 274:sxmlc/sxmlc.c **** 	if (src->tag != NULL) {
 275:sxmlc/sxmlc.c **** 		dst->tag = sx_strdup(src->tag);
 276:sxmlc/sxmlc.c **** 		if (dst->tag == NULL) goto copy_err;
 277:sxmlc/sxmlc.c **** 	}
 278:sxmlc/sxmlc.c **** 
 279:sxmlc/sxmlc.c **** 	/* Text */
 280:sxmlc/sxmlc.c **** 	if (dst->text != NULL) {
 281:sxmlc/sxmlc.c **** 		dst->text = sx_strdup(src->text);
 282:sxmlc/sxmlc.c **** 		if (dst->text == NULL) goto copy_err;
 283:sxmlc/sxmlc.c **** 	}
 284:sxmlc/sxmlc.c **** 
 285:sxmlc/sxmlc.c **** 	/* Attributes */
 286:sxmlc/sxmlc.c **** 	if (src->n_attributes > 0) {
 287:sxmlc/sxmlc.c **** 		dst->attributes = (XMLAttribute*)__calloc(src->n_attributes, sizeof(XMLAttribute));
 288:sxmlc/sxmlc.c **** 		if (dst->attributes== NULL) goto copy_err;
 289:sxmlc/sxmlc.c **** 		dst->n_attributes = src->n_attributes;
 290:sxmlc/sxmlc.c **** 		for (i = 0; i < src->n_attributes; i++) {
 291:sxmlc/sxmlc.c **** 			dst->attributes[i].name = sx_strdup(src->attributes[i].name);
 292:sxmlc/sxmlc.c **** 			dst->attributes[i].value = sx_strdup(src->attributes[i].value);
 293:sxmlc/sxmlc.c **** 			if (dst->attributes[i].name == NULL || dst->attributes[i].value == NULL) goto copy_err;
 294:sxmlc/sxmlc.c **** 			dst->attributes[i].active = src->attributes[i].active;
 295:sxmlc/sxmlc.c **** 		}
 296:sxmlc/sxmlc.c **** 	}
 297:sxmlc/sxmlc.c **** 
 298:sxmlc/sxmlc.c **** 	dst->tag_type = src->tag_type;
 299:sxmlc/sxmlc.c **** 	dst->father = src->father;
 300:sxmlc/sxmlc.c **** 	dst->user = src->user;
 301:sxmlc/sxmlc.c **** 	dst->active = src->active;
 302:sxmlc/sxmlc.c **** 	
 303:sxmlc/sxmlc.c **** 	/* Copy children if required (and there are any) */
 304:sxmlc/sxmlc.c **** 	if (copy_children && src->n_children > 0) {
 305:sxmlc/sxmlc.c **** 		dst->children = (XMLNode**)__calloc(src->n_children, sizeof(XMLNode*));
 306:sxmlc/sxmlc.c **** 		if (dst->children == NULL) goto copy_err;
 307:sxmlc/sxmlc.c **** 		dst->n_children = src->n_children;
 308:sxmlc/sxmlc.c **** 		for (i = 0; i < src->n_children; i++) {
 309:sxmlc/sxmlc.c **** 			if (!XMLNode_copy(dst->children[i], src->children[i], true)) goto copy_err;
 310:sxmlc/sxmlc.c **** 		}
 311:sxmlc/sxmlc.c **** 	}
 312:sxmlc/sxmlc.c **** 	
 313:sxmlc/sxmlc.c **** 	return true;
 314:sxmlc/sxmlc.c **** 	
 315:sxmlc/sxmlc.c **** copy_err:
 316:sxmlc/sxmlc.c **** 	(void)XMLNode_free(dst);
 317:sxmlc/sxmlc.c **** 	
 318:sxmlc/sxmlc.c **** 	return false;
 319:sxmlc/sxmlc.c **** }
 320:sxmlc/sxmlc.c **** 
 321:sxmlc/sxmlc.c **** int XMLNode_set_active(XMLNode* node, int active)
 322:sxmlc/sxmlc.c **** {
 323:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 324:sxmlc/sxmlc.c **** 		return false;
 325:sxmlc/sxmlc.c **** 
 326:sxmlc/sxmlc.c **** 	node->active = active;
 327:sxmlc/sxmlc.c **** 
 328:sxmlc/sxmlc.c **** 	return true;
 329:sxmlc/sxmlc.c **** }
 330:sxmlc/sxmlc.c **** 
 331:sxmlc/sxmlc.c **** int XMLNode_set_tag(XMLNode* node, const SXML_CHAR* tag)
 332:sxmlc/sxmlc.c **** {
 333:sxmlc/sxmlc.c **** 	SXML_CHAR* newtag;
 334:sxmlc/sxmlc.c **** 	if (node == NULL || tag == NULL || node->init_value != XML_INIT_DONE)
 335:sxmlc/sxmlc.c **** 		return false;
 336:sxmlc/sxmlc.c **** 	
 337:sxmlc/sxmlc.c **** 	newtag = sx_strdup(tag);
 338:sxmlc/sxmlc.c **** 	if (newtag == NULL)
 339:sxmlc/sxmlc.c **** 		return false;
 340:sxmlc/sxmlc.c **** 	if (node->tag != NULL) __free(node->tag);
 341:sxmlc/sxmlc.c **** 	node->tag = newtag;
 342:sxmlc/sxmlc.c **** 
 343:sxmlc/sxmlc.c **** 	return true;
 344:sxmlc/sxmlc.c **** }
 345:sxmlc/sxmlc.c **** 
 346:sxmlc/sxmlc.c **** int XMLNode_set_type(XMLNode* node, const TagType tag_type)
 347:sxmlc/sxmlc.c **** {
 348:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 349:sxmlc/sxmlc.c **** 		return false;
 350:sxmlc/sxmlc.c **** 
 351:sxmlc/sxmlc.c **** 	switch (tag_type) {
 352:sxmlc/sxmlc.c **** 		case TAG_ERROR:
 353:sxmlc/sxmlc.c **** 		case TAG_END:
 354:sxmlc/sxmlc.c **** 		case TAG_PARTIAL:
 355:sxmlc/sxmlc.c **** 		case TAG_NONE:
 356:sxmlc/sxmlc.c **** 			return false;
 357:sxmlc/sxmlc.c **** 
 358:sxmlc/sxmlc.c **** 		default:
 359:sxmlc/sxmlc.c **** 			node->tag_type = tag_type;
 360:sxmlc/sxmlc.c **** 			return true;
 361:sxmlc/sxmlc.c **** 	}
 362:sxmlc/sxmlc.c **** }
 363:sxmlc/sxmlc.c **** 
 364:sxmlc/sxmlc.c **** int XMLNode_set_attribute(XMLNode* node, const SXML_CHAR* attr_name, const SXML_CHAR* attr_value)
 365:sxmlc/sxmlc.c **** {
 366:sxmlc/sxmlc.c **** 	XMLAttribute* pt;
 367:sxmlc/sxmlc.c **** 	int i;
 368:sxmlc/sxmlc.c **** 	
 369:sxmlc/sxmlc.c **** 	if (node == NULL || attr_name == NULL || attr_name[0] == NULC || node->init_value != XML_INIT_DONE
 370:sxmlc/sxmlc.c **** 		return -1;
 371:sxmlc/sxmlc.c **** 	
 372:sxmlc/sxmlc.c **** 	i = XMLNode_search_attribute(node, attr_name, 0);
 373:sxmlc/sxmlc.c **** 	if (i >= 0) { /* Attribute found: update it */
 374:sxmlc/sxmlc.c **** 		SXML_CHAR* value = NULL;
 375:sxmlc/sxmlc.c **** 		if (attr_value != NULL && (value = sx_strdup(attr_value)) == NULL)
 376:sxmlc/sxmlc.c **** 			return -1;
 377:sxmlc/sxmlc.c **** 		pt = node->attributes;
 378:sxmlc/sxmlc.c **** 		if (pt[i].value != NULL)
 379:sxmlc/sxmlc.c **** 			__free(pt[i].value);
 380:sxmlc/sxmlc.c **** 		pt[i].value = value;
 381:sxmlc/sxmlc.c **** 	} else { /* Attribute not found: add it */
 382:sxmlc/sxmlc.c **** 		SXML_CHAR* name = sx_strdup(attr_name);
 383:sxmlc/sxmlc.c **** 		SXML_CHAR* value = (attr_value == NULL ? NULL : sx_strdup(attr_value));
 384:sxmlc/sxmlc.c **** 		if (name == NULL || (value == NULL && attr_value != NULL)) {
 385:sxmlc/sxmlc.c **** 			if (value != NULL)
 386:sxmlc/sxmlc.c **** 				__free(value);
 387:sxmlc/sxmlc.c **** 			if (name != NULL)
 388:sxmlc/sxmlc.c **** 				__free(name);
 389:sxmlc/sxmlc.c ****  			return -1;
 390:sxmlc/sxmlc.c **** 		}
 391:sxmlc/sxmlc.c **** 		i = node->n_attributes;
 392:sxmlc/sxmlc.c **** 		pt = (XMLAttribute*)__realloc(node->attributes, (i+1) * sizeof(XMLAttribute));
 393:sxmlc/sxmlc.c **** 		if (pt == NULL) {
 394:sxmlc/sxmlc.c **** 			if (value != NULL)
 395:sxmlc/sxmlc.c **** 				__free(value);
 396:sxmlc/sxmlc.c **** 			__free(name);
 397:sxmlc/sxmlc.c **** 			return -1;
 398:sxmlc/sxmlc.c **** 		}
 399:sxmlc/sxmlc.c **** 
 400:sxmlc/sxmlc.c **** 		pt[i].name = name;
 401:sxmlc/sxmlc.c **** 		pt[i].value = value;
 402:sxmlc/sxmlc.c **** 		pt[i].active = true;
 403:sxmlc/sxmlc.c **** 		node->attributes = pt;
 404:sxmlc/sxmlc.c **** 		node->n_attributes = i + 1;
 405:sxmlc/sxmlc.c **** 	}
 406:sxmlc/sxmlc.c **** 
 407:sxmlc/sxmlc.c **** 	return node->n_attributes;
 408:sxmlc/sxmlc.c **** }
 409:sxmlc/sxmlc.c **** 
 410:sxmlc/sxmlc.c **** int XMLNode_get_attribute_with_default(XMLNode* node, const SXML_CHAR* attr_name, const SXML_CHAR**
 411:sxmlc/sxmlc.c **** {
 412:sxmlc/sxmlc.c **** 	XMLAttribute* pt;
 413:sxmlc/sxmlc.c **** 	int i;
 414:sxmlc/sxmlc.c **** 	
 415:sxmlc/sxmlc.c **** 	if (node == NULL || attr_name == NULL || attr_name[0] == NULC || attr_value == NULL || node->init_
 416:sxmlc/sxmlc.c **** 		return false;
 417:sxmlc/sxmlc.c **** 	
 418:sxmlc/sxmlc.c **** 	i = XMLNode_search_attribute(node, attr_name, 0);
 419:sxmlc/sxmlc.c **** 	if (i >= 0) {
 420:sxmlc/sxmlc.c **** 		pt = node->attributes;
 421:sxmlc/sxmlc.c **** 		if (pt[i].value != NULL) {
 422:sxmlc/sxmlc.c **** 			*attr_value = sx_strdup(pt[i].value);
 423:sxmlc/sxmlc.c **** 			if (*attr_value == NULL)
 424:sxmlc/sxmlc.c **** 				return false;
 425:sxmlc/sxmlc.c **** 		} else
 426:sxmlc/sxmlc.c **** 			*attr_value = NULL; /* NULL but returns 'true' as 'NULL' is the actual attribute value */
 427:sxmlc/sxmlc.c **** 	} else if (default_attr_value != NULL) {
 428:sxmlc/sxmlc.c **** 		*attr_value = sx_strdup(default_attr_value);
 429:sxmlc/sxmlc.c **** 		if (*attr_value == NULL)
 430:sxmlc/sxmlc.c **** 			return false;
 431:sxmlc/sxmlc.c **** 	} else
 432:sxmlc/sxmlc.c **** 		*attr_value = NULL;
 433:sxmlc/sxmlc.c **** 
 434:sxmlc/sxmlc.c **** 	return true;
 435:sxmlc/sxmlc.c **** }
 436:sxmlc/sxmlc.c **** 
 437:sxmlc/sxmlc.c **** int XMLNode_get_attribute_count(const XMLNode* node)
 438:sxmlc/sxmlc.c **** {
 439:sxmlc/sxmlc.c **** 	int i, n;
 440:sxmlc/sxmlc.c **** 
 441:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 442:sxmlc/sxmlc.c **** 		return -1;
 443:sxmlc/sxmlc.c **** 
 444:sxmlc/sxmlc.c **** 	for (i = n = 0; i < node->n_attributes; i++)
 445:sxmlc/sxmlc.c **** 		if (node->attributes[i].active) n++;
 446:sxmlc/sxmlc.c **** 
 447:sxmlc/sxmlc.c **** 	return n;
 448:sxmlc/sxmlc.c **** }
 449:sxmlc/sxmlc.c **** 
 450:sxmlc/sxmlc.c **** int XMLNode_search_attribute(const XMLNode* node, const SXML_CHAR* attr_name, int i_search)
 451:sxmlc/sxmlc.c **** {
 452:sxmlc/sxmlc.c **** 	int i;
 453:sxmlc/sxmlc.c **** 	
 454:sxmlc/sxmlc.c **** 	if (node == NULL || attr_name == NULL || attr_name[0] == NULC || i_search < 0 || i_search >= node-
 455:sxmlc/sxmlc.c **** 		return -1;
 456:sxmlc/sxmlc.c **** 	
 457:sxmlc/sxmlc.c **** 	for (i = i_search; i < node->n_attributes; i++)
 458:sxmlc/sxmlc.c **** 		if (node->attributes[i].active && !sx_strcmp(node->attributes[i].name, attr_name))
 459:sxmlc/sxmlc.c **** 			return i;
 460:sxmlc/sxmlc.c **** 	
 461:sxmlc/sxmlc.c **** 	return -1;
 462:sxmlc/sxmlc.c **** }
 463:sxmlc/sxmlc.c **** 
 464:sxmlc/sxmlc.c **** int XMLNode_remove_attribute(XMLNode* node, int i_attr)
 465:sxmlc/sxmlc.c **** {
 466:sxmlc/sxmlc.c **** 	XMLAttribute* pt;
 467:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || i_attr < 0 || i_attr >= node->n_attribute
 468:sxmlc/sxmlc.c **** 		return -1;
 469:sxmlc/sxmlc.c **** 	
 470:sxmlc/sxmlc.c **** 	/* Before modifying first see if we run out of memory */
 471:sxmlc/sxmlc.c **** 	if (node->n_attributes == 1)
 472:sxmlc/sxmlc.c **** 		pt = NULL;
 473:sxmlc/sxmlc.c **** 	else {
 474:sxmlc/sxmlc.c **** 		pt = (XMLAttribute*)__malloc((node->n_attributes - 1) * sizeof(XMLAttribute));
 475:sxmlc/sxmlc.c **** 		if (pt == NULL)
 476:sxmlc/sxmlc.c **** 			return -1;
 477:sxmlc/sxmlc.c **** 	}
 478:sxmlc/sxmlc.c **** 
 479:sxmlc/sxmlc.c **** 	/* Can't fail anymore, free item */
 480:sxmlc/sxmlc.c **** 	if (node->attributes[i_attr].name != NULL) __free(node->attributes[i_attr].name);
 481:sxmlc/sxmlc.c **** 	if (node->attributes[i_attr].value != NULL) __free(node->attributes[i_attr].value);
 482:sxmlc/sxmlc.c **** 	
 483:sxmlc/sxmlc.c **** 	if (pt != NULL) {
 484:sxmlc/sxmlc.c **** 		memcpy(pt, node->attributes, i_attr * sizeof(XMLAttribute));
 485:sxmlc/sxmlc.c **** 		memcpy(&pt[i_attr], &node->attributes[i_attr + 1], (node->n_attributes - i_attr - 1) * sizeof(XML
 486:sxmlc/sxmlc.c **** 	}
 487:sxmlc/sxmlc.c **** 	if (node->attributes != NULL)
 488:sxmlc/sxmlc.c **** 		__free(node->attributes);
 489:sxmlc/sxmlc.c **** 	node->attributes = pt;
 490:sxmlc/sxmlc.c **** 	node->n_attributes--;
 491:sxmlc/sxmlc.c **** 	
 492:sxmlc/sxmlc.c **** 	return node->n_attributes;
 493:sxmlc/sxmlc.c **** }
 494:sxmlc/sxmlc.c **** 
 495:sxmlc/sxmlc.c **** int XMLNode_remove_all_attributes(XMLNode* node)
 496:sxmlc/sxmlc.c **** {
 497:sxmlc/sxmlc.c **** 	int i;
 498:sxmlc/sxmlc.c **** 
 499:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 500:sxmlc/sxmlc.c **** 		return false;
 501:sxmlc/sxmlc.c **** 
 502:sxmlc/sxmlc.c **** 	if (node->attributes != NULL) {
 503:sxmlc/sxmlc.c **** 		for (i = 0; i < node->n_attributes; i++) {
 504:sxmlc/sxmlc.c **** 			if (node->attributes[i].name != NULL)
 505:sxmlc/sxmlc.c **** 				__free(node->attributes[i].name);
 506:sxmlc/sxmlc.c **** 			if (node->attributes[i].value != NULL)
 507:sxmlc/sxmlc.c **** 				__free(node->attributes[i].value);
 508:sxmlc/sxmlc.c **** 		}
 509:sxmlc/sxmlc.c **** 		__free(node->attributes);
 510:sxmlc/sxmlc.c **** 		node->attributes = NULL;
 511:sxmlc/sxmlc.c **** 	}
 512:sxmlc/sxmlc.c **** 	node->n_attributes = 0;
 513:sxmlc/sxmlc.c **** 
 514:sxmlc/sxmlc.c **** 	return true;
 515:sxmlc/sxmlc.c **** }
 516:sxmlc/sxmlc.c **** 
 517:sxmlc/sxmlc.c **** int XMLNode_set_text(XMLNode* node, const SXML_CHAR* text)
 518:sxmlc/sxmlc.c **** {
 519:sxmlc/sxmlc.c **** 	SXML_CHAR* p;
 520:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 521:sxmlc/sxmlc.c **** 		return false;
 522:sxmlc/sxmlc.c **** 
 523:sxmlc/sxmlc.c **** 	if (text == NULL) { /* We want to remove it => free node text */
 524:sxmlc/sxmlc.c **** 		if (node->text != NULL) {
 525:sxmlc/sxmlc.c **** 			__free(node->text);
 526:sxmlc/sxmlc.c **** 			node->text = NULL;
 527:sxmlc/sxmlc.c **** 		}
 528:sxmlc/sxmlc.c **** 
 529:sxmlc/sxmlc.c **** 		return true;
 530:sxmlc/sxmlc.c **** 	}
 531:sxmlc/sxmlc.c **** 
 532:sxmlc/sxmlc.c **** 	p = (SXML_CHAR*)__realloc(node->text, (sx_strlen(text) + 1)*sizeof(SXML_CHAR)); /* +1 for '\0' */
 533:sxmlc/sxmlc.c **** 	if (p == NULL)
 534:sxmlc/sxmlc.c **** 		return false;
 535:sxmlc/sxmlc.c **** 	node->text = p;
 536:sxmlc/sxmlc.c **** 
 537:sxmlc/sxmlc.c **** 	sx_strcpy(node->text, text);
 538:sxmlc/sxmlc.c **** 
 539:sxmlc/sxmlc.c **** 	return true;
 540:sxmlc/sxmlc.c **** }
 541:sxmlc/sxmlc.c **** 
 542:sxmlc/sxmlc.c **** int XMLNode_add_child(XMLNode* node, XMLNode* child)
 543:sxmlc/sxmlc.c **** {
 544:sxmlc/sxmlc.c **** 	if (node == NULL || child == NULL || node->init_value != XML_INIT_DONE || child->init_value != XML
 545:sxmlc/sxmlc.c **** 		return false;
 546:sxmlc/sxmlc.c **** 	
 547:sxmlc/sxmlc.c **** 	if (_add_node(&node->children, &node->n_children, child) >= 0) {
 548:sxmlc/sxmlc.c **** 		node->tag_type = TAG_FATHER;
 549:sxmlc/sxmlc.c **** 		child->father = node;
 550:sxmlc/sxmlc.c **** 		return true;
 551:sxmlc/sxmlc.c **** 	} else
 552:sxmlc/sxmlc.c **** 		return false;
 553:sxmlc/sxmlc.c **** }
 554:sxmlc/sxmlc.c **** 
 555:sxmlc/sxmlc.c **** int XMLNode_get_children_count(const XMLNode* node)
 556:sxmlc/sxmlc.c **** {
 557:sxmlc/sxmlc.c **** 	int i, n;
 558:sxmlc/sxmlc.c **** 
 559:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 560:sxmlc/sxmlc.c **** 		return -1;
 561:sxmlc/sxmlc.c **** 
 562:sxmlc/sxmlc.c **** 	for (i = n = 0; i < node->n_children; i++)
 563:sxmlc/sxmlc.c **** 		if (node->children[i]->active) n++;
 564:sxmlc/sxmlc.c **** 	
 565:sxmlc/sxmlc.c **** 	return n;
 566:sxmlc/sxmlc.c **** }
 567:sxmlc/sxmlc.c **** 
 568:sxmlc/sxmlc.c **** XMLNode* XMLNode_get_child(const XMLNode* node, int i_child)
 569:sxmlc/sxmlc.c **** {
 570:sxmlc/sxmlc.c **** 	int i;
 571:sxmlc/sxmlc.c **** 	
 572:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || i_child < 0 || i_child >= node->n_childre
 573:sxmlc/sxmlc.c **** 		return NULL;
 574:sxmlc/sxmlc.c **** 	
 575:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_children; i++) {
 576:sxmlc/sxmlc.c **** 		if (!node->children[i]->active)
 577:sxmlc/sxmlc.c **** 			i_child++;
 578:sxmlc/sxmlc.c **** 		else if (i == i_child)
 579:sxmlc/sxmlc.c **** 			return node->children[i];
 580:sxmlc/sxmlc.c **** 	}
 581:sxmlc/sxmlc.c **** 	
 582:sxmlc/sxmlc.c **** 	return NULL;
 583:sxmlc/sxmlc.c **** }
 584:sxmlc/sxmlc.c **** 
 585:sxmlc/sxmlc.c **** int XMLNode_remove_child(XMLNode* node, int i_child, int free_child)
 586:sxmlc/sxmlc.c **** {
 587:sxmlc/sxmlc.c **** 	int i;
 588:sxmlc/sxmlc.c **** 	XMLNode** pt;
 589:sxmlc/sxmlc.c **** 
 590:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || i_child < 0 || i_child >= node->n_childre
 591:sxmlc/sxmlc.c **** 		return -1;
 592:sxmlc/sxmlc.c **** 	
 593:sxmlc/sxmlc.c **** 	/* Lookup 'i_child'th active child */
 594:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_children; i++) {
 595:sxmlc/sxmlc.c **** 		if (!node->children[i]->active)
 596:sxmlc/sxmlc.c **** 			i_child++;
 597:sxmlc/sxmlc.c **** 		else if (i == i_child)
 598:sxmlc/sxmlc.c **** 			break;
 599:sxmlc/sxmlc.c **** 	}
 600:sxmlc/sxmlc.c **** 	if (i >= node->n_children)
 601:sxmlc/sxmlc.c **** 		return -1; /* Children is not found */
 602:sxmlc/sxmlc.c **** 
 603:sxmlc/sxmlc.c **** 	/* Before modifying first see if we run out of memory */
 604:sxmlc/sxmlc.c **** 	if (node->n_children == 1)
 605:sxmlc/sxmlc.c **** 		pt = NULL;
 606:sxmlc/sxmlc.c **** 	else {
 607:sxmlc/sxmlc.c **** 		pt = (XMLNode**)__malloc((node->n_children - 1) * sizeof(XMLNode*));
 608:sxmlc/sxmlc.c **** 		if (pt == NULL)
 609:sxmlc/sxmlc.c **** 			return -1;
 610:sxmlc/sxmlc.c **** 	}
 611:sxmlc/sxmlc.c **** 
 612:sxmlc/sxmlc.c **** 	/* Can't fail anymore, free item */
 613:sxmlc/sxmlc.c **** 	(void)XMLNode_free(node->children[i_child]);
 614:sxmlc/sxmlc.c **** 	if (free_child)
 615:sxmlc/sxmlc.c **** 		__free(node->children[i_child]);
 616:sxmlc/sxmlc.c **** 	
 617:sxmlc/sxmlc.c **** 	if (pt != NULL) {
 618:sxmlc/sxmlc.c **** 		memcpy(pt, node->children, i_child * sizeof(XMLNode*));
 619:sxmlc/sxmlc.c **** 		memcpy(&pt[i_child], &node->children[i_child + 1], (node->n_children - i_child - 1) * sizeof(XMLN
 620:sxmlc/sxmlc.c **** 	}
 621:sxmlc/sxmlc.c **** 	if (node->children != NULL)
 622:sxmlc/sxmlc.c **** 		__free(node->children);
 623:sxmlc/sxmlc.c **** 	node->children = pt;
 624:sxmlc/sxmlc.c **** 	node->n_children--;
 625:sxmlc/sxmlc.c **** 	if (node->n_children == 0)
 626:sxmlc/sxmlc.c **** 		node->tag_type = TAG_SELF;
 627:sxmlc/sxmlc.c **** 	
 628:sxmlc/sxmlc.c **** 	return node->n_children;
 629:sxmlc/sxmlc.c **** }
 630:sxmlc/sxmlc.c **** 
 631:sxmlc/sxmlc.c **** int XMLNode_remove_children(XMLNode* node)
 632:sxmlc/sxmlc.c **** {
 633:sxmlc/sxmlc.c **** 	int i;
 634:sxmlc/sxmlc.c **** 
 635:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 636:sxmlc/sxmlc.c **** 		return false;
 637:sxmlc/sxmlc.c **** 
 638:sxmlc/sxmlc.c **** 	if (node->children != NULL) {
 639:sxmlc/sxmlc.c **** 		for (i = 0; i < node->n_children; i++)
 640:sxmlc/sxmlc.c **** 			if (node->children[i] != NULL) {
 641:sxmlc/sxmlc.c **** 				(void)XMLNode_free(node->children[i]);
 642:sxmlc/sxmlc.c **** 				__free(node->children[i]);
 643:sxmlc/sxmlc.c **** 			}
 644:sxmlc/sxmlc.c **** 		__free(node->children);
 645:sxmlc/sxmlc.c **** 		node->children = NULL;
 646:sxmlc/sxmlc.c **** 	}
 647:sxmlc/sxmlc.c **** 	node->n_children = 0;
 648:sxmlc/sxmlc.c **** 	
 649:sxmlc/sxmlc.c **** 	return true;
 650:sxmlc/sxmlc.c **** }
 651:sxmlc/sxmlc.c **** 
 652:sxmlc/sxmlc.c **** int XMLNode_equal(const XMLNode* node1, const XMLNode* node2)
 653:sxmlc/sxmlc.c **** {
 654:sxmlc/sxmlc.c **** 	int i, j;
 655:sxmlc/sxmlc.c **** 
 656:sxmlc/sxmlc.c **** 	if (node1 == node2)
 657:sxmlc/sxmlc.c **** 		return true;
 658:sxmlc/sxmlc.c **** 
 659:sxmlc/sxmlc.c **** 	if (node1 == NULL || node2 == NULL || node1->init_value != XML_INIT_DONE || node2->init_value != X
 660:sxmlc/sxmlc.c **** 		return false;
 661:sxmlc/sxmlc.c **** 
 662:sxmlc/sxmlc.c **** 	if (sx_strcmp(node1->tag, node2->tag))
 663:sxmlc/sxmlc.c **** 		return false;
 664:sxmlc/sxmlc.c **** 
 665:sxmlc/sxmlc.c **** 	/* Test all attributes from 'node1' */
 666:sxmlc/sxmlc.c **** 	for (i = 0; i < node1->n_attributes; i++) {
 667:sxmlc/sxmlc.c **** 		if (!node1->attributes[i].active)
 668:sxmlc/sxmlc.c **** 			continue;
 669:sxmlc/sxmlc.c **** 		j = XMLNode_search_attribute(node2, node1->attributes[i].name, 0);
 670:sxmlc/sxmlc.c **** 		if (j < 0)
 671:sxmlc/sxmlc.c **** 			return false;
 672:sxmlc/sxmlc.c **** 		if (sx_strcmp(node1->attributes[i].value, node2->attributes[j].value))
 673:sxmlc/sxmlc.c **** 			return false;
 674:sxmlc/sxmlc.c **** 	}
 675:sxmlc/sxmlc.c **** 
 676:sxmlc/sxmlc.c **** 	/* Test other attributes from 'node2' that might not be in 'node1' */
 677:sxmlc/sxmlc.c **** 	for (i = 0; i < node2->n_attributes; i++) {
 678:sxmlc/sxmlc.c **** 		if (!node2->attributes[i].active)
 679:sxmlc/sxmlc.c **** 			continue;
 680:sxmlc/sxmlc.c **** 		j = XMLNode_search_attribute(node1, node2->attributes[i].name, 0);
 681:sxmlc/sxmlc.c **** 		if (j < 0)
 682:sxmlc/sxmlc.c **** 			return false;
 683:sxmlc/sxmlc.c **** 		if (sx_strcmp(node2->attributes[i].name, node1->attributes[j].name))
 684:sxmlc/sxmlc.c **** 			return false;
 685:sxmlc/sxmlc.c **** 	}
 686:sxmlc/sxmlc.c **** 
 687:sxmlc/sxmlc.c **** 	return true;
 688:sxmlc/sxmlc.c **** }
 689:sxmlc/sxmlc.c **** 
 690:sxmlc/sxmlc.c **** XMLNode* XMLNode_next_sibling(const XMLNode* node)
 691:sxmlc/sxmlc.c **** {
 692:sxmlc/sxmlc.c **** 	int i;
 693:sxmlc/sxmlc.c **** 	XMLNode* father;
 694:sxmlc/sxmlc.c **** 
 695:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || node->father == NULL)
 696:sxmlc/sxmlc.c **** 		return NULL;
 697:sxmlc/sxmlc.c **** 
 698:sxmlc/sxmlc.c **** 	father = node->father;
 699:sxmlc/sxmlc.c **** 	for (i = 0; i < father->n_children && father->children[i] != node; i++) ;
 700:sxmlc/sxmlc.c **** 	i++; /* father->children[i] is now 'node' next sibling */
 701:sxmlc/sxmlc.c **** 
 702:sxmlc/sxmlc.c **** 	return i < father->n_children ? father->children[i] : NULL;
 703:sxmlc/sxmlc.c **** }
 704:sxmlc/sxmlc.c **** 
 705:sxmlc/sxmlc.c **** static XMLNode* _XMLNode_next(const XMLNode* node, int in_children)
 706:sxmlc/sxmlc.c **** {
 707:sxmlc/sxmlc.c **** 	XMLNode* node2;
 708:sxmlc/sxmlc.c **** 
 709:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 710:sxmlc/sxmlc.c **** 		return NULL;
 711:sxmlc/sxmlc.c **** 
 712:sxmlc/sxmlc.c **** 	/* Check first child */
 713:sxmlc/sxmlc.c **** 	if (in_children && node->n_children > 0)
 714:sxmlc/sxmlc.c **** 		return node->children[0];
 715:sxmlc/sxmlc.c **** 
 716:sxmlc/sxmlc.c **** 	/* Check next sibling */
 717:sxmlc/sxmlc.c **** 	if ((node2 = XMLNode_next_sibling(node)) != NULL)
 718:sxmlc/sxmlc.c **** 		return node2;
 719:sxmlc/sxmlc.c **** 
 720:sxmlc/sxmlc.c **** 	/* Check next uncle */
 721:sxmlc/sxmlc.c **** 	return _XMLNode_next(node->father, false);
 722:sxmlc/sxmlc.c **** }
 723:sxmlc/sxmlc.c **** 
 724:sxmlc/sxmlc.c **** XMLNode* XMLNode_next(const XMLNode* node)
 725:sxmlc/sxmlc.c **** {
 726:sxmlc/sxmlc.c **** 	return _XMLNode_next(node, true);
 727:sxmlc/sxmlc.c **** }
 728:sxmlc/sxmlc.c **** 
 729:sxmlc/sxmlc.c **** /* --- XMLDoc methods --- */
 730:sxmlc/sxmlc.c **** 
 731:sxmlc/sxmlc.c **** int XMLDoc_init(XMLDoc* doc)
 732:sxmlc/sxmlc.c **** {
 733:sxmlc/sxmlc.c **** 	if (doc == NULL)
 734:sxmlc/sxmlc.c **** 		return false;
 735:sxmlc/sxmlc.c **** 
 736:sxmlc/sxmlc.c **** 	doc->filename[0] = NULC;
 737:sxmlc/sxmlc.c **** #ifdef SXMLC_UNICODE
 738:sxmlc/sxmlc.c **** 	memset(&doc->bom, 0, sizeof(doc->bom));
 739:sxmlc/sxmlc.c **** #endif
 740:sxmlc/sxmlc.c **** 	doc->nodes = NULL;
 741:sxmlc/sxmlc.c **** 	doc->n_nodes = 0;
 742:sxmlc/sxmlc.c **** 	doc->i_root = -1;
 743:sxmlc/sxmlc.c **** 	doc->init_value = XML_INIT_DONE;
 744:sxmlc/sxmlc.c **** 
 745:sxmlc/sxmlc.c **** 	return true;
 746:sxmlc/sxmlc.c **** }
 747:sxmlc/sxmlc.c **** 
 748:sxmlc/sxmlc.c **** int XMLDoc_free(XMLDoc* doc)
 749:sxmlc/sxmlc.c **** {
 750:sxmlc/sxmlc.c **** 	int i;
 751:sxmlc/sxmlc.c **** 	
 752:sxmlc/sxmlc.c **** 	if (doc == NULL || doc->init_value != XML_INIT_DONE)
 753:sxmlc/sxmlc.c **** 		return false;
 754:sxmlc/sxmlc.c **** 
 755:sxmlc/sxmlc.c **** 	for (i = 0; i < doc->n_nodes; i++) {
 756:sxmlc/sxmlc.c **** 		(void)XMLNode_free(doc->nodes[i]);
 757:sxmlc/sxmlc.c **** 		__free(doc->nodes[i]);
 758:sxmlc/sxmlc.c **** 	}
 759:sxmlc/sxmlc.c **** 	__free(doc->nodes);
 760:sxmlc/sxmlc.c **** 	doc->nodes = NULL;
 761:sxmlc/sxmlc.c **** 	doc->n_nodes = 0;
 762:sxmlc/sxmlc.c **** 	doc->i_root = -1;
 763:sxmlc/sxmlc.c **** 
 764:sxmlc/sxmlc.c **** 	return true;
 765:sxmlc/sxmlc.c **** }
 766:sxmlc/sxmlc.c **** 
 767:sxmlc/sxmlc.c **** int XMLDoc_set_root(XMLDoc* doc, int i_root)
 768:sxmlc/sxmlc.c **** {
 769:sxmlc/sxmlc.c **** 	if (doc == NULL || doc->init_value != XML_INIT_DONE || i_root < 0 || i_root >= doc->n_nodes)
 770:sxmlc/sxmlc.c **** 		return false;
 771:sxmlc/sxmlc.c **** 	
 772:sxmlc/sxmlc.c **** 	doc->i_root = i_root;
 773:sxmlc/sxmlc.c **** 	
 774:sxmlc/sxmlc.c **** 	return true;
 775:sxmlc/sxmlc.c **** }
 776:sxmlc/sxmlc.c **** 
 777:sxmlc/sxmlc.c **** int XMLDoc_add_node(XMLDoc* doc, XMLNode* node)
 778:sxmlc/sxmlc.c **** {
 779:sxmlc/sxmlc.c **** 	if (doc == NULL || node == NULL || doc->init_value != XML_INIT_DONE)
 780:sxmlc/sxmlc.c **** 		return -1;
 781:sxmlc/sxmlc.c **** 	
 782:sxmlc/sxmlc.c **** 	if (_add_node(&doc->nodes, &doc->n_nodes, node) < 0)
 783:sxmlc/sxmlc.c **** 		return -1;
 784:sxmlc/sxmlc.c **** 
 785:sxmlc/sxmlc.c **** 	if (node->tag_type == TAG_FATHER)
 786:sxmlc/sxmlc.c **** 		doc->i_root = doc->n_nodes - 1; /* Main root node is the last father node */
 787:sxmlc/sxmlc.c **** 
 788:sxmlc/sxmlc.c **** 	return doc->n_nodes;
 789:sxmlc/sxmlc.c **** }
 790:sxmlc/sxmlc.c **** 
 791:sxmlc/sxmlc.c **** int XMLDoc_remove_node(XMLDoc* doc, int i_node, int free_node)
 792:sxmlc/sxmlc.c **** {
 793:sxmlc/sxmlc.c **** 	XMLNode** pt;
 794:sxmlc/sxmlc.c **** 	if (doc == NULL || doc->init_value != XML_INIT_DONE || i_node < 0 || i_node > doc->n_nodes)
 795:sxmlc/sxmlc.c **** 		return false;
 796:sxmlc/sxmlc.c **** 
 797:sxmlc/sxmlc.c **** 	/* Before modifying first see if we run out of memory */
 798:sxmlc/sxmlc.c **** 	if (doc->n_nodes == 1)
 799:sxmlc/sxmlc.c **** 		pt = NULL;
 800:sxmlc/sxmlc.c **** 	else {
 801:sxmlc/sxmlc.c **** 		pt = (XMLNode**)__malloc((doc->n_nodes - 1) * sizeof(XMLNode*));
 802:sxmlc/sxmlc.c **** 		if (pt == NULL)
 803:sxmlc/sxmlc.c **** 			return false;
 804:sxmlc/sxmlc.c **** 	}
 805:sxmlc/sxmlc.c **** 
 806:sxmlc/sxmlc.c **** 	/* Can't fail anymore, free item */
 807:sxmlc/sxmlc.c **** 	(void)XMLNode_free(doc->nodes[i_node]);
 808:sxmlc/sxmlc.c **** 	if (free_node) __free(doc->nodes[i_node]);
 809:sxmlc/sxmlc.c **** 	
 810:sxmlc/sxmlc.c **** 	if (pt != NULL) {
 811:sxmlc/sxmlc.c **** 		memcpy(pt, &doc->nodes[i_node], i_node * sizeof(XMLNode*));
 812:sxmlc/sxmlc.c **** 		memcpy(&pt[i_node], &doc->nodes[i_node + 1], (doc->n_nodes - i_node - 1) * sizeof(XMLNode*));
 813:sxmlc/sxmlc.c **** 	}
 814:sxmlc/sxmlc.c **** 
 815:sxmlc/sxmlc.c **** 	if (doc->nodes != NULL)
 816:sxmlc/sxmlc.c **** 		__free(doc->nodes);
 817:sxmlc/sxmlc.c **** 	doc->nodes = pt;
 818:sxmlc/sxmlc.c **** 	doc->n_nodes--;
 819:sxmlc/sxmlc.c **** 
 820:sxmlc/sxmlc.c **** 	return true;
 821:sxmlc/sxmlc.c **** }
 822:sxmlc/sxmlc.c **** 
 823:sxmlc/sxmlc.c **** /*
 824:sxmlc/sxmlc.c ****  Helper functions to print formatting before a new tag.
 825:sxmlc/sxmlc.c ****  Returns the new number of characters in the line.
 826:sxmlc/sxmlc.c ****  */
 827:sxmlc/sxmlc.c **** static int _count_new_char_line(const SXML_CHAR* str, int nb_char_tab, int cur_sz_line)
 828:sxmlc/sxmlc.c **** {
  26              		.loc 1 828 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
  31              	.LVL0:
  32 0000 0138     		subs	r0, r0, #1
  33              	.LVL1:
  34              	.L2:
 829:sxmlc/sxmlc.c **** 	for (; *str; str++) {
  35              		.loc 1 829 0 discriminator 1
  36 0002 10F8013F 		ldrb	r3, [r0, #1]!	@ zero_extendqisi2
  37              	.LVL2:
  38 0006 43B1     		cbz	r3, .L8
 830:sxmlc/sxmlc.c **** 		if (*str == C2SX('\n'))
  39              		.loc 1 830 0
  40 0008 0A2B     		cmp	r3, #10
  41 000a 04D0     		beq	.L6
 831:sxmlc/sxmlc.c **** 			cur_sz_line = 0;
 832:sxmlc/sxmlc.c **** 		else if (*str == C2SX('\t'))
  42              		.loc 1 832 0
  43 000c 092B     		cmp	r3, #9
 833:sxmlc/sxmlc.c **** 			cur_sz_line += nb_char_tab;
  44              		.loc 1 833 0
  45 000e 0CBF     		ite	eq
  46 0010 5218     		addeq	r2, r2, r1
  47              	.LVL3:
 834:sxmlc/sxmlc.c **** 		else
 835:sxmlc/sxmlc.c **** 			cur_sz_line++;
  48              		.loc 1 835 0
  49 0012 0132     		addne	r2, r2, #1
  50              	.LVL4:
  51 0014 F5E7     		b	.L2
  52              	.L6:
 831:sxmlc/sxmlc.c **** 			cur_sz_line = 0;
  53              		.loc 1 831 0
  54 0016 0022     		movs	r2, #0
  55              	.LVL5:
  56 0018 F3E7     		b	.L2
  57              	.LVL6:
  58              	.L8:
 836:sxmlc/sxmlc.c **** 	}
 837:sxmlc/sxmlc.c **** 	
 838:sxmlc/sxmlc.c **** 	return cur_sz_line;
 839:sxmlc/sxmlc.c **** }
  59              		.loc 1 839 0
  60 001a 1046     		mov	r0, r2
  61              	.LVL7:
  62 001c 7047     		bx	lr
  63              		.cfi_endproc
  64              	.LFE34:
  66              		.section	.text.DOMXMLDoc_doc_start,"ax",%progbits
  67              		.align	1
  68              		.global	DOMXMLDoc_doc_start
  69              		.thumb
  70              		.thumb_func
  72              	DOMXMLDoc_doc_start:
  73              	.LFB46:
 840:sxmlc/sxmlc.c **** static int _print_formatting(const XMLNode* node, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHA
 841:sxmlc/sxmlc.c **** {
 842:sxmlc/sxmlc.c **** 	if (tag_sep != NULL) {
 843:sxmlc/sxmlc.c **** 		sx_fprintf(f, tag_sep);
 844:sxmlc/sxmlc.c **** 		cur_sz_line = _count_new_char_line(tag_sep, nb_char_tab, cur_sz_line);
 845:sxmlc/sxmlc.c **** 	}
 846:sxmlc/sxmlc.c **** 	if (child_sep != NULL) {
 847:sxmlc/sxmlc.c **** 		for (node = node->father; node != NULL; node = node->father) {
 848:sxmlc/sxmlc.c **** 			sx_fprintf(f, child_sep);
 849:sxmlc/sxmlc.c **** 			cur_sz_line = _count_new_char_line(child_sep, nb_char_tab, cur_sz_line);
 850:sxmlc/sxmlc.c **** 		}
 851:sxmlc/sxmlc.c **** 	}
 852:sxmlc/sxmlc.c **** 	
 853:sxmlc/sxmlc.c **** 	return cur_sz_line;
 854:sxmlc/sxmlc.c **** }
 855:sxmlc/sxmlc.c **** 
 856:sxmlc/sxmlc.c **** static int _XMLNode_print_header(const XMLNode* node, FILE* f, const SXML_CHAR* tag_sep, const SXML
 857:sxmlc/sxmlc.c **** {
 858:sxmlc/sxmlc.c **** 	int i;
 859:sxmlc/sxmlc.c **** 	SXML_CHAR* p;
 860:sxmlc/sxmlc.c **** 
 861:sxmlc/sxmlc.c **** 	if (node == NULL || f == NULL || !node->active || node->tag == NULL || node->tag[0] == NULC)
 862:sxmlc/sxmlc.c **** 		return -1;
 863:sxmlc/sxmlc.c **** 	
 864:sxmlc/sxmlc.c **** 	/* Special handling of DOCTYPE */
 865:sxmlc/sxmlc.c **** 	if (node->tag_type == TAG_DOCTYPE) {
 866:sxmlc/sxmlc.c **** 		/* Search for an unescaped '[' in the DOCTYPE definition, in which case the end delimiter should 
 867:sxmlc/sxmlc.c **** 		for (p = sx_strchr(node->tag, C2SX('[')); p != NULL && *(p-1) == C2SX('\\'); p = sx_strchr(p+1, C
 868:sxmlc/sxmlc.c **** 		cur_sz_line += sx_fprintf(f, C2SX("<!DOCTYPE%s%s>"), node->tag, p != NULL ? C2SX("]") : C2SX(""))
 869:sxmlc/sxmlc.c **** 		return cur_sz_line;
 870:sxmlc/sxmlc.c **** 	}
 871:sxmlc/sxmlc.c **** 
 872:sxmlc/sxmlc.c **** 	/* Check for special tags first */
 873:sxmlc/sxmlc.c **** 	for (i = 0; i < NB_SPECIAL_TAGS; i++) {
 874:sxmlc/sxmlc.c **** 		if (node->tag_type == _spec[i].tag_type) {
 875:sxmlc/sxmlc.c **** 			sx_fprintf(f, C2SX("%s%s%s"), _spec[i].start, node->tag, _spec[i].end);
 876:sxmlc/sxmlc.c **** 			cur_sz_line += sx_strlen(_spec[i].start) + sx_strlen(node->tag) + sx_strlen(_spec[i].end);
 877:sxmlc/sxmlc.c **** 			return cur_sz_line;
 878:sxmlc/sxmlc.c **** 		}
 879:sxmlc/sxmlc.c **** 	}
 880:sxmlc/sxmlc.c **** 
 881:sxmlc/sxmlc.c **** 	/* Check for user tags */
 882:sxmlc/sxmlc.c **** 	for (i = 0; i < _user_tags.n_tags; i++) {
 883:sxmlc/sxmlc.c **** 		if (node->tag_type == _user_tags.tags[i].tag_type) {
 884:sxmlc/sxmlc.c **** 			sx_fprintf(f, C2SX("%s%s%s"), _user_tags.tags[i].start, node->tag, _user_tags.tags[i].end);
 885:sxmlc/sxmlc.c **** 			cur_sz_line += sx_strlen(_user_tags.tags[i].start) + sx_strlen(node->tag) + sx_strlen(_user_tags
 886:sxmlc/sxmlc.c **** 			return cur_sz_line;
 887:sxmlc/sxmlc.c **** 		}
 888:sxmlc/sxmlc.c **** 	}
 889:sxmlc/sxmlc.c **** 	
 890:sxmlc/sxmlc.c **** 	/* Print tag name */
 891:sxmlc/sxmlc.c **** 	cur_sz_line += sx_fprintf(f, C2SX("<%s"), node->tag);
 892:sxmlc/sxmlc.c **** 
 893:sxmlc/sxmlc.c **** 	/* Print attributes */
 894:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_attributes; i++) {
 895:sxmlc/sxmlc.c **** 		if (!node->attributes[i].active)
 896:sxmlc/sxmlc.c **** 			continue;
 897:sxmlc/sxmlc.c **** 		cur_sz_line += sx_strlen(node->attributes[i].name) + sx_strlen(node->attributes[i].value) + 3;
 898:sxmlc/sxmlc.c **** 		if (sz_line > 0 && cur_sz_line > sz_line) {
 899:sxmlc/sxmlc.c **** 			cur_sz_line = _print_formatting(node, f, tag_sep, child_sep, nb_char_tab, cur_sz_line);
 900:sxmlc/sxmlc.c **** 			/* Add extra separator, as if new line was a child of the previous one */
 901:sxmlc/sxmlc.c **** 			if (child_sep != NULL) {
 902:sxmlc/sxmlc.c **** 				sx_fprintf(f, child_sep);
 903:sxmlc/sxmlc.c **** 				cur_sz_line = _count_new_char_line(child_sep, nb_char_tab, cur_sz_line);
 904:sxmlc/sxmlc.c **** 			}
 905:sxmlc/sxmlc.c **** 		}
 906:sxmlc/sxmlc.c **** 		/* Attribute name */
 907:sxmlc/sxmlc.c **** 		if (attr_sep != NULL) {
 908:sxmlc/sxmlc.c **** 			sx_fprintf(f, attr_sep);
 909:sxmlc/sxmlc.c **** 			cur_sz_line = _count_new_char_line(attr_sep, nb_char_tab, cur_sz_line);
 910:sxmlc/sxmlc.c **** 			sx_fprintf(f, C2SX("%s="), node->attributes[i].name);
 911:sxmlc/sxmlc.c **** 		} else
 912:sxmlc/sxmlc.c **** 			sx_fprintf(f, C2SX(" %s="), node->attributes[i].name);
 913:sxmlc/sxmlc.c **** 		
 914:sxmlc/sxmlc.c **** 		/* Attribute value */
 915:sxmlc/sxmlc.c **** 		(void)sx_fputc(XML_DEFAULT_QUOTE, f);
 916:sxmlc/sxmlc.c **** 		cur_sz_line += fprintHTML(f, node->attributes[i].value) + 2;
 917:sxmlc/sxmlc.c **** 		(void)sx_fputc(XML_DEFAULT_QUOTE, f);
 918:sxmlc/sxmlc.c **** 	}
 919:sxmlc/sxmlc.c **** 	
 920:sxmlc/sxmlc.c **** 	/* End the tag if there are no children and no text */
 921:sxmlc/sxmlc.c **** 	if (node->n_children == 0 && (node->text == NULL || node->text[0] == NULC)) {
 922:sxmlc/sxmlc.c **** 		cur_sz_line += sx_fprintf(f, C2SX("/>"));
 923:sxmlc/sxmlc.c **** 	} else {
 924:sxmlc/sxmlc.c **** 		(void)sx_fputc(C2SX('>'), f);
 925:sxmlc/sxmlc.c **** 		cur_sz_line++;
 926:sxmlc/sxmlc.c **** 	}
 927:sxmlc/sxmlc.c **** 
 928:sxmlc/sxmlc.c **** 	return cur_sz_line;
 929:sxmlc/sxmlc.c **** }
 930:sxmlc/sxmlc.c **** 
 931:sxmlc/sxmlc.c **** int XMLNode_print_header(const XMLNode* node, FILE* f, int sz_line, int nb_char_tab)
 932:sxmlc/sxmlc.c **** {
 933:sxmlc/sxmlc.c **** 	return _XMLNode_print_header(node, f, NULL, NULL, NULL, sz_line, 0, nb_char_tab) < 0 ? false : tru
 934:sxmlc/sxmlc.c **** }
 935:sxmlc/sxmlc.c **** 
 936:sxmlc/sxmlc.c **** static int _XMLNode_print(const XMLNode* node, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHAR* 
 937:sxmlc/sxmlc.c **** {
 938:sxmlc/sxmlc.c **** 	int i;
 939:sxmlc/sxmlc.c **** 	SXML_CHAR* p;
 940:sxmlc/sxmlc.c **** 	
 941:sxmlc/sxmlc.c **** 	if (node != NULL && node->tag_type==TAG_TEXT) { /* Text has to be printed: check if it is only spa
 942:sxmlc/sxmlc.c **** 		if (!keep_text_spaces) {
 943:sxmlc/sxmlc.c **** 			for (p = node->text; *p != NULC && sx_isspace(*p); p++) ; /* 'p' points to first non-space chara
 944:sxmlc/sxmlc.c **** 		} else
 945:sxmlc/sxmlc.c **** 			p = node->text; /* '*p' won't be '\0' */
 946:sxmlc/sxmlc.c **** 		if (*p != NULC)
 947:sxmlc/sxmlc.c **** 			cur_sz_line += fprintHTML(f, node->text);
 948:sxmlc/sxmlc.c **** 		return cur_sz_line;
 949:sxmlc/sxmlc.c **** 	}
 950:sxmlc/sxmlc.c **** 
 951:sxmlc/sxmlc.c **** 	if (node == NULL || f == NULL || !node->active || node->tag == NULL || node->tag[0] == NULC)
 952:sxmlc/sxmlc.c **** 		return -1;
 953:sxmlc/sxmlc.c **** 	
 954:sxmlc/sxmlc.c **** 	if (nb_char_tab <= 0)
 955:sxmlc/sxmlc.c **** 		nb_char_tab = 1;
 956:sxmlc/sxmlc.c **** 	
 957:sxmlc/sxmlc.c **** 	/* Print formatting */
 958:sxmlc/sxmlc.c **** 	if (depth < 0) /* UGLY HACK: 'depth' forced negative on very first line so we don't print an extra
 959:sxmlc/sxmlc.c **** 		depth = 0;
 960:sxmlc/sxmlc.c **** 	else
 961:sxmlc/sxmlc.c **** 		cur_sz_line = _print_formatting(node, f, tag_sep, child_sep, nb_char_tab, cur_sz_line);
 962:sxmlc/sxmlc.c **** 	
 963:sxmlc/sxmlc.c **** 	_XMLNode_print_header(node, f, tag_sep, child_sep, attr_sep, sz_line, cur_sz_line, nb_char_tab);
 964:sxmlc/sxmlc.c **** 
 965:sxmlc/sxmlc.c **** 	if (node->text != NULL && node->text[0] != NULC) {
 966:sxmlc/sxmlc.c **** 		/* Text has to be printed: check if it is only spaces */
 967:sxmlc/sxmlc.c **** 		if (!keep_text_spaces) {
 968:sxmlc/sxmlc.c **** 			for (p = node->text; *p != NULC && sx_isspace(*p); p++) ; /* 'p' points to first non-space chara
 969:sxmlc/sxmlc.c **** 		} else
 970:sxmlc/sxmlc.c **** 			p = node->text; /* '*p' won't be '\0' */
 971:sxmlc/sxmlc.c **** 		if (*p != NULC) cur_sz_line += fprintHTML(f, node->text);
 972:sxmlc/sxmlc.c **** 	} else if (node->n_children <= 0) /* Everything has already been printed */
 973:sxmlc/sxmlc.c **** 		return cur_sz_line;
 974:sxmlc/sxmlc.c **** 	
 975:sxmlc/sxmlc.c **** 	/* Recursively print children */
 976:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_children; i++)
 977:sxmlc/sxmlc.c **** 		(void)_XMLNode_print(node->children[i], f, tag_sep, child_sep, attr_sep, keep_text_spaces, sz_lin
 978:sxmlc/sxmlc.c **** 	
 979:sxmlc/sxmlc.c **** 	/* Print tag end after children */
 980:sxmlc/sxmlc.c **** 		/* Print formatting */
 981:sxmlc/sxmlc.c **** 	if (node->n_children > 0)
 982:sxmlc/sxmlc.c **** 		cur_sz_line = _print_formatting(node, f, tag_sep, child_sep, nb_char_tab, cur_sz_line);
 983:sxmlc/sxmlc.c **** 	cur_sz_line += sx_fprintf(f, C2SX("</%s>"), node->tag);
 984:sxmlc/sxmlc.c **** 
 985:sxmlc/sxmlc.c **** 	return cur_sz_line;
 986:sxmlc/sxmlc.c **** }
 987:sxmlc/sxmlc.c **** 
 988:sxmlc/sxmlc.c **** int XMLNode_print_attr_sep(const XMLNode* node, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHAR*
 989:sxmlc/sxmlc.c **** {
 990:sxmlc/sxmlc.c **** 	return _XMLNode_print(node, f, tag_sep, child_sep, attr_sep, keep_text_spaces, sz_line, 0, nb_char
 991:sxmlc/sxmlc.c **** }
 992:sxmlc/sxmlc.c **** 
 993:sxmlc/sxmlc.c **** int XMLDoc_print_attr_sep(const XMLDoc* doc, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHAR* ch
 994:sxmlc/sxmlc.c **** {
 995:sxmlc/sxmlc.c **** 	int i, depth, cur_sz_line;
 996:sxmlc/sxmlc.c **** 	
 997:sxmlc/sxmlc.c **** 	if (doc == NULL || f == NULL || doc->init_value != XML_INIT_DONE)
 998:sxmlc/sxmlc.c **** 		return false;
 999:sxmlc/sxmlc.c **** 	
1000:sxmlc/sxmlc.c **** #ifdef SXMLC_UNICODE
1001:sxmlc/sxmlc.c **** 	/* Write BOM if it exist */
1002:sxmlc/sxmlc.c **** 	if (doc->sz_bom > 0) fwrite(doc->bom, sizeof(unsigned char), doc->sz_bom, f);
1003:sxmlc/sxmlc.c **** #endif
1004:sxmlc/sxmlc.c **** 
1005:sxmlc/sxmlc.c **** 	depth = -1; /* UGLY HACK: 'depth' forced negative on very first line so we don't print an extra 't
1006:sxmlc/sxmlc.c **** 	for (i = 0, cur_sz_line = 0; i < doc->n_nodes; i++) {
1007:sxmlc/sxmlc.c **** 		cur_sz_line = _XMLNode_print(doc->nodes[i], f, tag_sep, child_sep, attr_sep, keep_text_spaces, sz
1008:sxmlc/sxmlc.c **** 		depth = 0;
1009:sxmlc/sxmlc.c **** 	}
1010:sxmlc/sxmlc.c **** 	/* TODO: Find something more graceful than 'depth=-1', even though everyone knows I probably never
1011:sxmlc/sxmlc.c **** 
1012:sxmlc/sxmlc.c **** 	return true;
1013:sxmlc/sxmlc.c **** }
1014:sxmlc/sxmlc.c **** 
1015:sxmlc/sxmlc.c **** /* --- */
1016:sxmlc/sxmlc.c **** 
1017:sxmlc/sxmlc.c **** int XML_parse_attribute_to(const SXML_CHAR* str, int to, XMLAttribute* xmlattr)
1018:sxmlc/sxmlc.c **** {
1019:sxmlc/sxmlc.c **** 	const SXML_CHAR *p;
1020:sxmlc/sxmlc.c **** 	int i, n0, n1, remQ = 0;
1021:sxmlc/sxmlc.c **** 	int ret = 1;
1022:sxmlc/sxmlc.c **** 	SXML_CHAR quote = '\0';
1023:sxmlc/sxmlc.c **** 	
1024:sxmlc/sxmlc.c **** 	if (str == NULL || xmlattr == NULL)
1025:sxmlc/sxmlc.c **** 		return 0;
1026:sxmlc/sxmlc.c **** 
1027:sxmlc/sxmlc.c **** 	if (to < 0)
1028:sxmlc/sxmlc.c **** 		to = sx_strlen(str) - 1;
1029:sxmlc/sxmlc.c **** 	
1030:sxmlc/sxmlc.c **** 	/* Search for the '=' */
1031:sxmlc/sxmlc.c **** 	/* 'n0' is where the attribute name stops, 'n1' is where the attribute value starts */
1032:sxmlc/sxmlc.c **** 	for (n0 = 0; n0 != to && str[n0] != C2SX('=') && !sx_isspace(str[n0]); n0++) ; /* Search for '=' o
1033:sxmlc/sxmlc.c **** 	for (n1 = n0; n1 != to && sx_isspace(str[n1]); n1++) ; /* Search for something not a space */
1034:sxmlc/sxmlc.c **** 	if (str[n1] != C2SX('='))
1035:sxmlc/sxmlc.c **** 		return 0; /* '=' not found: malformed string */
1036:sxmlc/sxmlc.c **** 	for (n1++; n1 != to && sx_isspace(str[n1]); n1++) ; /* Search for something not a space */
1037:sxmlc/sxmlc.c **** 	if (isquote(str[n1])) { /* Remove quotes */
1038:sxmlc/sxmlc.c **** 		quote = str[n1];
1039:sxmlc/sxmlc.c **** 		remQ = 1;
1040:sxmlc/sxmlc.c **** 	}
1041:sxmlc/sxmlc.c **** 	
1042:sxmlc/sxmlc.c **** 	xmlattr->name = (SXML_CHAR*)__malloc((n0+1)*sizeof(SXML_CHAR));
1043:sxmlc/sxmlc.c **** 	xmlattr->value = (SXML_CHAR*)__malloc((to+1 - n1 - remQ + 1) * sizeof(SXML_CHAR));
1044:sxmlc/sxmlc.c **** 	xmlattr->active = true;
1045:sxmlc/sxmlc.c **** 	if (xmlattr->name != NULL && xmlattr->value != NULL) {
1046:sxmlc/sxmlc.c **** 		/* Copy name */
1047:sxmlc/sxmlc.c **** 		sx_strncpy(xmlattr->name, str, n0);
1048:sxmlc/sxmlc.c **** 		xmlattr->name[n0] = NULC;
1049:sxmlc/sxmlc.c **** 		/* (void)str_unescape(xmlattr->name); do not unescape the name */
1050:sxmlc/sxmlc.c **** 		/* Copy value (p starts after the quote (if any) and stops at the end of 'str'
1051:sxmlc/sxmlc.c **** 		  (skipping the quote if any, hence the '*(p+remQ)') */
1052:sxmlc/sxmlc.c **** 		for (i = 0, p = str + n1 + remQ; i + n1 + remQ < to && *(p+remQ) != NULC; i++, p++)
1053:sxmlc/sxmlc.c **** 			xmlattr->value[i] = *p;
1054:sxmlc/sxmlc.c **** 		xmlattr->value[i] = NULC;
1055:sxmlc/sxmlc.c **** 		(void)html2str(xmlattr->value, NULL); /* Convert HTML escape sequences, do not str_unescape(xmlat
1056:sxmlc/sxmlc.c **** 		if (remQ && *p != quote)
1057:sxmlc/sxmlc.c **** 			ret = 2; /* Quote at the beginning but not at the end: probable presence of '>' inside attribute
1058:sxmlc/sxmlc.c **** 	} else
1059:sxmlc/sxmlc.c **** 		ret = 0;
1060:sxmlc/sxmlc.c **** 	
1061:sxmlc/sxmlc.c **** 	if (ret == 0) {
1062:sxmlc/sxmlc.c **** 		if (xmlattr->name != NULL) {
1063:sxmlc/sxmlc.c **** 			__free(xmlattr->name);
1064:sxmlc/sxmlc.c **** 			xmlattr->name = NULL;
1065:sxmlc/sxmlc.c **** 		}
1066:sxmlc/sxmlc.c **** 		if (xmlattr->value != NULL) {
1067:sxmlc/sxmlc.c **** 			__free(xmlattr->value);
1068:sxmlc/sxmlc.c **** 			xmlattr->value = NULL;
1069:sxmlc/sxmlc.c **** 		}
1070:sxmlc/sxmlc.c **** 	}
1071:sxmlc/sxmlc.c **** 	
1072:sxmlc/sxmlc.c **** 	return ret;
1073:sxmlc/sxmlc.c **** }
1074:sxmlc/sxmlc.c **** 
1075:sxmlc/sxmlc.c **** static TagType _parse_special_tag(const SXML_CHAR* str, int len, _TAG* tag, XMLNode* node)
1076:sxmlc/sxmlc.c **** {
1077:sxmlc/sxmlc.c **** 	if (sx_strncmp(str, tag->start, tag->len_start))
1078:sxmlc/sxmlc.c **** 		return TAG_NONE;
1079:sxmlc/sxmlc.c **** 
1080:sxmlc/sxmlc.c **** 	if (sx_strncmp(str + len - tag->len_end, tag->end, tag->len_end)) /* There probably is a '>' insid
1081:sxmlc/sxmlc.c **** 		return TAG_PARTIAL;
1082:sxmlc/sxmlc.c **** 
1083:sxmlc/sxmlc.c **** 	node->tag = (SXML_CHAR*)__malloc((len - tag->len_start - tag->len_end + 1)*sizeof(SXML_CHAR));
1084:sxmlc/sxmlc.c **** 	if (node->tag == NULL)
1085:sxmlc/sxmlc.c **** 		return TAG_NONE;
1086:sxmlc/sxmlc.c **** 	sx_strncpy(node->tag, str + tag->len_start, len - tag->len_start - tag->len_end);
1087:sxmlc/sxmlc.c **** 	node->tag[len - tag->len_start - tag->len_end] = NULC;
1088:sxmlc/sxmlc.c **** 	node->tag_type = tag->tag_type;
1089:sxmlc/sxmlc.c **** 
1090:sxmlc/sxmlc.c **** 	return node->tag_type;
1091:sxmlc/sxmlc.c **** }
1092:sxmlc/sxmlc.c **** 
1093:sxmlc/sxmlc.c **** /*
1094:sxmlc/sxmlc.c ****  Reads a string that is supposed to be an xml tag like '<tag (attribName="attribValue")* [/]>' or '
1095:sxmlc/sxmlc.c ****  Fills the 'xmlnode' structure with the tag name and its attributes.
1096:sxmlc/sxmlc.c ****  Returns 'TAG_ERROR' if an error occurred (malformed 'str' or memory). 'TAG_*' when string is recog
1097:sxmlc/sxmlc.c ****  */
1098:sxmlc/sxmlc.c **** TagType XML_parse_1string(const SXML_CHAR* str, XMLNode* xmlnode)
1099:sxmlc/sxmlc.c **** {
1100:sxmlc/sxmlc.c **** 	SXML_CHAR *p;
1101:sxmlc/sxmlc.c **** 	XMLAttribute* pt;
1102:sxmlc/sxmlc.c **** 	int n, nn, len, rc, tag_end = 0;
1103:sxmlc/sxmlc.c **** 	
1104:sxmlc/sxmlc.c **** 	if (str == NULL || xmlnode == NULL)
1105:sxmlc/sxmlc.c **** 		return TAG_ERROR;
1106:sxmlc/sxmlc.c **** 	len = sx_strlen(str);
1107:sxmlc/sxmlc.c **** 	
1108:sxmlc/sxmlc.c **** 	/* Check for malformed string */
1109:sxmlc/sxmlc.c **** 	if (str[0] != C2SX('<') || str[len-1] != C2SX('>'))
1110:sxmlc/sxmlc.c **** 		return TAG_ERROR;
1111:sxmlc/sxmlc.c **** 
1112:sxmlc/sxmlc.c **** 	for (nn = 0; nn < NB_SPECIAL_TAGS; nn++) {
1113:sxmlc/sxmlc.c **** 		n = (int)_parse_special_tag(str, len, &_spec[nn], xmlnode);
1114:sxmlc/sxmlc.c **** 		switch (n) {
1115:sxmlc/sxmlc.c **** 			case TAG_NONE:	break;				/* Nothing found => do nothing */
1116:sxmlc/sxmlc.c **** 			default:		return (TagType)n;	/* Tag found => return it */
1117:sxmlc/sxmlc.c **** 		}
1118:sxmlc/sxmlc.c **** 	}
1119:sxmlc/sxmlc.c **** 
1120:sxmlc/sxmlc.c **** 	/* "<!DOCTYPE" requires a special handling because it can end with "]>" instead of ">" if a '[' is
1121:sxmlc/sxmlc.c **** 	if (str[1] == C2SX('!')) {
1122:sxmlc/sxmlc.c **** 		/* DOCTYPE */
1123:sxmlc/sxmlc.c **** 		if (!sx_strncmp(str, C2SX("<!DOCTYPE"), 9)) { /* 9 = sizeof("<!DOCTYPE") */
1124:sxmlc/sxmlc.c **** 			for (n = 9; str[n] && str[n] != C2SX('['); n++) ; /* Look for a '[' inside the DOCTYPE, which wo
1125:sxmlc/sxmlc.c **** 			nn = 0;
1126:sxmlc/sxmlc.c **** 			if (str[n]) { /* '[' was found */
1127:sxmlc/sxmlc.c **** 				if (sx_strncmp(str+len-2, C2SX("]>"), 2)) /* There probably is a '>' inside the DOCTYPE */
1128:sxmlc/sxmlc.c **** 					return TAG_PARTIAL;
1129:sxmlc/sxmlc.c **** 				nn = 1;
1130:sxmlc/sxmlc.c **** 			}
1131:sxmlc/sxmlc.c **** 			xmlnode->tag = (SXML_CHAR*)__malloc((len - 9 - nn)*sizeof(SXML_CHAR)); /* 'len' - "<!DOCTYPE" an
1132:sxmlc/sxmlc.c **** 			if (xmlnode->tag == NULL)
1133:sxmlc/sxmlc.c **** 				return TAG_ERROR;
1134:sxmlc/sxmlc.c **** 			sx_strncpy(xmlnode->tag, &str[9], len - 10 - nn);
1135:sxmlc/sxmlc.c **** 			xmlnode->tag[len - 10 - nn] = NULC;
1136:sxmlc/sxmlc.c **** 			xmlnode->tag_type = TAG_DOCTYPE;
1137:sxmlc/sxmlc.c **** 
1138:sxmlc/sxmlc.c **** 			return TAG_DOCTYPE;
1139:sxmlc/sxmlc.c **** 		}
1140:sxmlc/sxmlc.c **** 	}
1141:sxmlc/sxmlc.c **** 	
1142:sxmlc/sxmlc.c **** 	/* Test user tags */
1143:sxmlc/sxmlc.c **** 	for (nn = 0; nn < _user_tags.n_tags; nn++) {
1144:sxmlc/sxmlc.c **** 		n = _parse_special_tag(str, len, &_user_tags.tags[nn], xmlnode);
1145:sxmlc/sxmlc.c **** 		switch (n) {
1146:sxmlc/sxmlc.c **** 			case TAG_ERROR:	return TAG_NONE;	/* Error => exit */
1147:sxmlc/sxmlc.c **** 			case TAG_NONE:	break;				/* Nothing found => do nothing */
1148:sxmlc/sxmlc.c **** 			default:		return (TagType)n;	/* Tag found => return it */
1149:sxmlc/sxmlc.c **** 		}
1150:sxmlc/sxmlc.c **** 	}
1151:sxmlc/sxmlc.c **** 
1152:sxmlc/sxmlc.c **** 	if (str[1] == C2SX('/'))
1153:sxmlc/sxmlc.c **** 		tag_end = 1;
1154:sxmlc/sxmlc.c **** 	
1155:sxmlc/sxmlc.c **** 	/* tag starts at index 1 (or 2 if tag end) and ends at the first space or '/>' */
1156:sxmlc/sxmlc.c **** 	for (n = 1 + tag_end; str[n] != NULC && str[n] != C2SX('>') && str[n] != C2SX('/') && !sx_isspace(
1157:sxmlc/sxmlc.c **** 	xmlnode->tag = (SXML_CHAR*)__malloc((n - tag_end)*sizeof(SXML_CHAR));
1158:sxmlc/sxmlc.c **** 	if (xmlnode->tag == NULL)
1159:sxmlc/sxmlc.c **** 		return TAG_ERROR;
1160:sxmlc/sxmlc.c **** 	sx_strncpy(xmlnode->tag, &str[1 + tag_end], n - 1 - tag_end);
1161:sxmlc/sxmlc.c **** 	xmlnode->tag[n - 1 - tag_end] = NULC;
1162:sxmlc/sxmlc.c **** 	if (tag_end) {
1163:sxmlc/sxmlc.c **** 		xmlnode->tag_type = TAG_END;
1164:sxmlc/sxmlc.c **** 		return TAG_END;
1165:sxmlc/sxmlc.c **** 	}
1166:sxmlc/sxmlc.c **** 	
1167:sxmlc/sxmlc.c **** 	/* Here, 'n' is the position of the first space after tag name */
1168:sxmlc/sxmlc.c **** 	while (n < len) {
1169:sxmlc/sxmlc.c **** 		/* Skips spaces */
1170:sxmlc/sxmlc.c **** 		while (sx_isspace(str[n])) n++;
1171:sxmlc/sxmlc.c **** 		
1172:sxmlc/sxmlc.c **** 		/* Check for XML end ('>' or '/>') */
1173:sxmlc/sxmlc.c **** 		if (str[n] == C2SX('>')) { /* Tag with children */
1174:sxmlc/sxmlc.c **** 			int type = (str[n-1] == '/' ? TAG_SELF : TAG_FATHER); // TODO: Find something better to cope wit
1175:sxmlc/sxmlc.c **** 			xmlnode->tag_type = type;
1176:sxmlc/sxmlc.c **** 			return type;
1177:sxmlc/sxmlc.c **** 		}
1178:sxmlc/sxmlc.c **** 		if (!sx_strcmp(str+n, C2SX("/>"))) { /* Tag without children */
1179:sxmlc/sxmlc.c **** 			xmlnode->tag_type = TAG_SELF;
1180:sxmlc/sxmlc.c **** 			return TAG_SELF;
1181:sxmlc/sxmlc.c **** 		}
1182:sxmlc/sxmlc.c **** 		
1183:sxmlc/sxmlc.c **** 		/* New attribute found */
1184:sxmlc/sxmlc.c **** 		p = sx_strchr(str+n, C2SX('='));
1185:sxmlc/sxmlc.c **** 		if (p == NULL) goto parse_err;
1186:sxmlc/sxmlc.c **** 		pt = (XMLAttribute*)__realloc(xmlnode->attributes, (xmlnode->n_attributes + 1) * sizeof(XMLAttrib
1187:sxmlc/sxmlc.c **** 		if (pt == NULL) goto parse_err;
1188:sxmlc/sxmlc.c **** 		
1189:sxmlc/sxmlc.c **** 		pt[xmlnode->n_attributes].name = NULL;
1190:sxmlc/sxmlc.c **** 		pt[xmlnode->n_attributes].value = NULL;
1191:sxmlc/sxmlc.c **** 		pt[xmlnode->n_attributes].active = false;
1192:sxmlc/sxmlc.c **** 		xmlnode->n_attributes++;
1193:sxmlc/sxmlc.c **** 		xmlnode->attributes = pt;
1194:sxmlc/sxmlc.c **** 		while (*p != NULC && sx_isspace(*++p)) ; /* Skip spaces */
1195:sxmlc/sxmlc.c **** 		if (isquote(*p)) { /* Attribute value starts with a quote, look for next one, ignoring protected 
1196:sxmlc/sxmlc.c **** 			for (nn = p-str+1; str[nn] && str[nn] != *p; nn++) { // CHECK UNICODE "nn = p-str+1"
1197:sxmlc/sxmlc.c **** 				/* if (str[nn] == C2SX('\\')) nn++; [bugs:#7]: '\' is valid in values */
1198:sxmlc/sxmlc.c **** 			}
1199:sxmlc/sxmlc.c **** 		} else { /* Attribute value stops at first space or end of XML string */
1200:sxmlc/sxmlc.c **** 			for (nn = p-str+1; str[nn] != NULC && !sx_isspace(str[nn]) && str[nn] != C2SX('/') && str[nn] !=
1201:sxmlc/sxmlc.c **** 		}
1202:sxmlc/sxmlc.c **** 		
1203:sxmlc/sxmlc.c **** 		/* Here 'str[nn]' is the character after value */
1204:sxmlc/sxmlc.c **** 		/* the attribute definition ('attrName="attrVal"') is between 'str[n]' and 'str[nn]' */
1205:sxmlc/sxmlc.c **** 		rc = XML_parse_attribute_to(&str[n], nn - n, &xmlnode->attributes[xmlnode->n_attributes - 1]);
1206:sxmlc/sxmlc.c **** 		if (!rc) goto parse_err;
1207:sxmlc/sxmlc.c **** 		if (rc == 2) { /* Probable presence of '>' inside attribute value, which is legal XML. Remove att
1208:sxmlc/sxmlc.c **** 			XMLNode_remove_attribute(xmlnode, xmlnode->n_attributes - 1);
1209:sxmlc/sxmlc.c **** 			return TAG_PARTIAL;
1210:sxmlc/sxmlc.c **** 		}
1211:sxmlc/sxmlc.c **** 		
1212:sxmlc/sxmlc.c **** 		n = nn + 1;
1213:sxmlc/sxmlc.c **** 	}
1214:sxmlc/sxmlc.c **** 	
1215:sxmlc/sxmlc.c **** 	sx_fprintf(stderr, C2SX("\nWE SHOULD NOT BE HERE!\n[%s]\n\n"), str);
1216:sxmlc/sxmlc.c **** 	
1217:sxmlc/sxmlc.c **** parse_err:
1218:sxmlc/sxmlc.c **** 	(void)XMLNode_free(xmlnode);
1219:sxmlc/sxmlc.c **** 
1220:sxmlc/sxmlc.c **** 	return TAG_ERROR;
1221:sxmlc/sxmlc.c **** }
1222:sxmlc/sxmlc.c **** 
1223:sxmlc/sxmlc.c **** static int _parse_data_SAX(void* in, const DataSourceType in_type, const SAX_Callbacks* sax, SAX_Da
1224:sxmlc/sxmlc.c **** {
1225:sxmlc/sxmlc.c **** 	SXML_CHAR *line = NULL, *txt_end, *p;
1226:sxmlc/sxmlc.c **** 	XMLNode node;
1227:sxmlc/sxmlc.c **** 	int ret, exit, sz, n0, ncr;
1228:sxmlc/sxmlc.c **** 	TagType tag_type;
1229:sxmlc/sxmlc.c **** 	int (*meos)(void* ds) = (in_type == DATA_SOURCE_BUFFER ? (int(*)(void*))_beob : (int(*)(void*))feo
1230:sxmlc/sxmlc.c **** 
1231:sxmlc/sxmlc.c **** 	if (sax->start_doc != NULL && !sax->start_doc(sd))
1232:sxmlc/sxmlc.c **** 		return true;
1233:sxmlc/sxmlc.c **** 	if (sax->all_event != NULL && !sax->all_event(XML_EVENT_START_DOC, NULL, (SXML_CHAR*)sd->name, 0, 
1234:sxmlc/sxmlc.c **** 		return true;
1235:sxmlc/sxmlc.c **** 
1236:sxmlc/sxmlc.c **** 	ret = true;
1237:sxmlc/sxmlc.c **** 	exit = false;
1238:sxmlc/sxmlc.c **** 	sd->line_num = 1; /* Line counter, starts at 1 */
1239:sxmlc/sxmlc.c **** 	sz = 0; /* 'line' buffer size */
1240:sxmlc/sxmlc.c **** 	node.init_value = 0;
1241:sxmlc/sxmlc.c **** 	(void)XMLNode_init(&node);
1242:sxmlc/sxmlc.c **** 	while ((n0 = read_line_alloc(in, in_type, &line, &sz, 0, NULC, C2SX('>'), true, C2SX('\n'), &ncr))
1243:sxmlc/sxmlc.c **** 		(void)XMLNode_free(&node);
1244:sxmlc/sxmlc.c **** 		for (p = line; *p != NULC && sx_isspace(*p); p++) ; /* Checks if text is only spaces */
1245:sxmlc/sxmlc.c **** 		if (*p == NULC)
1246:sxmlc/sxmlc.c **** 			break;
1247:sxmlc/sxmlc.c **** 		sd->line_num += ncr;
1248:sxmlc/sxmlc.c **** 
1249:sxmlc/sxmlc.c **** 		/* Get text for 'father' (i.e. what is before '<') */
1250:sxmlc/sxmlc.c **** 		while ((txt_end = sx_strchr(line, C2SX('<'))) == NULL) { /* '<' was not found, indicating a proba
1251:sxmlc/sxmlc.c **** 			int n1 = read_line_alloc(in, in_type, &line, &sz, n0, 0, C2SX('>'), true, C2SX('\n'), &ncr); /* 
1252:sxmlc/sxmlc.c **** 			sd->line_num += ncr;
1253:sxmlc/sxmlc.c **** 			if (n1 <= n0) {
1254:sxmlc/sxmlc.c **** 				ret = false;
1255:sxmlc/sxmlc.c **** 				if (sax->on_error == NULL && sax->all_event == NULL)
1256:sxmlc/sxmlc.c **** 					sx_fprintf(stderr, C2SX("%s:%d: MEMORY ERROR.\n"), sd->name, sd->line_num);
1257:sxmlc/sxmlc.c **** 				else {
1258:sxmlc/sxmlc.c **** 					if (sax->on_error != NULL && !sax->on_error(PARSE_ERR_MEMORY, sd->line_num, sd))
1259:sxmlc/sxmlc.c **** 						break;
1260:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->name, PAR
1261:sxmlc/sxmlc.c **** 						break;
1262:sxmlc/sxmlc.c **** 				}
1263:sxmlc/sxmlc.c **** 				break; /* 'txt_end' is still NULL here so we'll display the syntax error below */
1264:sxmlc/sxmlc.c **** 			}
1265:sxmlc/sxmlc.c **** 			n0 = n1;
1266:sxmlc/sxmlc.c **** 		}
1267:sxmlc/sxmlc.c **** 		if (txt_end == NULL) { /* Missing tag start */
1268:sxmlc/sxmlc.c **** 			ret = false;
1269:sxmlc/sxmlc.c **** 			if (sax->on_error == NULL && sax->all_event == NULL)
1270:sxmlc/sxmlc.c **** 				sx_fprintf(stderr, C2SX("%s:%d: ERROR: Unexpected end character '>', without matching '<'!\n"),
1271:sxmlc/sxmlc.c **** 			else {
1272:sxmlc/sxmlc.c **** 				if (sax->on_error != NULL && !sax->on_error(PARSE_ERR_UNEXPECTED_TAG_END, sd->line_num, sd))
1273:sxmlc/sxmlc.c **** 					break;
1274:sxmlc/sxmlc.c **** 				if (sax->all_event != NULL && !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->name, PARS
1275:sxmlc/sxmlc.c **** 					break;
1276:sxmlc/sxmlc.c **** 			}
1277:sxmlc/sxmlc.c **** 			break;
1278:sxmlc/sxmlc.c **** 		}
1279:sxmlc/sxmlc.c **** 		/* First part of 'line' (before '<') is to be added to 'father->text' */
1280:sxmlc/sxmlc.c **** 		*txt_end = NULC; /* Have 'line' be the text for 'father' */
1281:sxmlc/sxmlc.c **** 		if (*line != NULC && (sax->new_text != NULL || sax->all_event != NULL)) {
1282:sxmlc/sxmlc.c **** 			if (sax->new_text != NULL && (exit = !sax->new_text(line, sd))) /* no str_unescape(line) */
1283:sxmlc/sxmlc.c **** 				break;
1284:sxmlc/sxmlc.c **** 			if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_TEXT, NULL, line, sd->line_num, 
1285:sxmlc/sxmlc.c **** 				break;
1286:sxmlc/sxmlc.c **** 		}
1287:sxmlc/sxmlc.c **** 		*txt_end = '<'; /* Restores tag start */
1288:sxmlc/sxmlc.c **** 
1289:sxmlc/sxmlc.c **** 		switch (tag_type = XML_parse_1string(txt_end, &node)) {
1290:sxmlc/sxmlc.c **** 			case TAG_ERROR: /* Memory error */
1291:sxmlc/sxmlc.c **** 				ret = false;
1292:sxmlc/sxmlc.c **** 				if (sax->on_error == NULL && sax->all_event == NULL)
1293:sxmlc/sxmlc.c **** 					sx_fprintf(stderr, C2SX("%s:%d: MEMORY ERROR.\n"), sd->name, sd->line_num);
1294:sxmlc/sxmlc.c **** 				else {
1295:sxmlc/sxmlc.c **** 					if (sax->on_error != NULL && (exit = !sax->on_error(PARSE_ERR_MEMORY, sd->line_num, sd)))
1296:sxmlc/sxmlc.c **** 						break;
1297:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->n
1298:sxmlc/sxmlc.c **** 						break;
1299:sxmlc/sxmlc.c **** 				}
1300:sxmlc/sxmlc.c **** 				break;
1301:sxmlc/sxmlc.c **** 		
1302:sxmlc/sxmlc.c **** 			case TAG_NONE: /* Syntax error */
1303:sxmlc/sxmlc.c **** 				ret = false;
1304:sxmlc/sxmlc.c **** 				p = sx_strchr(txt_end, C2SX('\n'));
1305:sxmlc/sxmlc.c **** 				if (p != NULL)
1306:sxmlc/sxmlc.c **** 					*p = NULC;
1307:sxmlc/sxmlc.c **** 				if (sax->on_error == NULL && sax->all_event == NULL) {
1308:sxmlc/sxmlc.c **** 					sx_fprintf(stderr, C2SX("%s:%d: SYNTAX ERROR (%s%s).\n"), sd->name, sd->line_num, txt_end, p =
1309:sxmlc/sxmlc.c **** 					if (p != NULL)
1310:sxmlc/sxmlc.c **** 						*p = C2SX('\n');
1311:sxmlc/sxmlc.c **** 				} else {
1312:sxmlc/sxmlc.c **** 					if (sax->on_error != NULL && (exit = !sax->on_error(PARSE_ERR_SYNTAX, sd->line_num, sd)))
1313:sxmlc/sxmlc.c **** 						break;
1314:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->n
1315:sxmlc/sxmlc.c **** 						break;
1316:sxmlc/sxmlc.c **** 				}
1317:sxmlc/sxmlc.c **** 				break;
1318:sxmlc/sxmlc.c **** 
1319:sxmlc/sxmlc.c **** 			case TAG_END:
1320:sxmlc/sxmlc.c **** 				if (sax->end_node != NULL || sax->all_event != NULL) {
1321:sxmlc/sxmlc.c **** 					if (sax->end_node != NULL && (exit = !sax->end_node(&node, sd)))
1322:sxmlc/sxmlc.c **** 						break;
1323:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_END_NODE, &node, NULL, sd->lin
1324:sxmlc/sxmlc.c **** 						break;
1325:sxmlc/sxmlc.c **** 				}
1326:sxmlc/sxmlc.c **** 				break;
1327:sxmlc/sxmlc.c **** 
1328:sxmlc/sxmlc.c **** 			default: /* Add 'node' to 'father' children */
1329:sxmlc/sxmlc.c **** 				/* If the line looks like a comment (or CDATA) but is not properly finished, loop until we find
1330:sxmlc/sxmlc.c **** 				while (tag_type == TAG_PARTIAL) {
1331:sxmlc/sxmlc.c **** 					int n1 = read_line_alloc(in, in_type, &line, &sz, n0, NULC, C2SX('>'), true, C2SX('\n'), &ncr)
1332:sxmlc/sxmlc.c **** 					sd->line_num += ncr;
1333:sxmlc/sxmlc.c **** 					if (n1 <= n0) {
1334:sxmlc/sxmlc.c **** 						ret = false;
1335:sxmlc/sxmlc.c **** 						if (sax->on_error == NULL && sax->all_event == NULL)
1336:sxmlc/sxmlc.c **** 							sx_fprintf(stderr, C2SX("%s:%d: SYNTAX ERROR.\n"), sd->name, sd->line_num);
1337:sxmlc/sxmlc.c **** 						else {
1338:sxmlc/sxmlc.c **** 							if (sax->on_error != NULL && (exit = !sax->on_error(meos(in) ? PARSE_ERR_EOF : PARSE_ERR_MEM
1339:sxmlc/sxmlc.c **** 								break;
1340:sxmlc/sxmlc.c **** 							if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd-
1341:sxmlc/sxmlc.c **** 								break;
1342:sxmlc/sxmlc.c **** 						}
1343:sxmlc/sxmlc.c **** 						break;
1344:sxmlc/sxmlc.c **** 					}
1345:sxmlc/sxmlc.c **** 					n0 = n1;
1346:sxmlc/sxmlc.c **** 					txt_end = sx_strchr(line, C2SX('<')); /* In case 'line' has been moved by the '__realloc' in '
1347:sxmlc/sxmlc.c **** 					tag_type = XML_parse_1string(txt_end, &node);
1348:sxmlc/sxmlc.c **** 					if (tag_type == TAG_ERROR) {
1349:sxmlc/sxmlc.c **** 						ret = false;
1350:sxmlc/sxmlc.c **** 						if (sax->on_error == NULL && sax->all_event == NULL)
1351:sxmlc/sxmlc.c **** 							sx_fprintf(stderr, C2SX("%s:%d: PARSE ERROR.\n"), sd->name, sd->line_num);
1352:sxmlc/sxmlc.c **** 						else {
1353:sxmlc/sxmlc.c **** 							if (sax->on_error != NULL && (exit = !sax->on_error(meos(in) ? PARSE_ERR_EOF : PARSE_ERR_SYN
1354:sxmlc/sxmlc.c **** 								break;
1355:sxmlc/sxmlc.c **** 							if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd-
1356:sxmlc/sxmlc.c **** 								break;
1357:sxmlc/sxmlc.c **** 						}
1358:sxmlc/sxmlc.c **** 						break;
1359:sxmlc/sxmlc.c **** 					}
1360:sxmlc/sxmlc.c **** 				}
1361:sxmlc/sxmlc.c **** 				if (ret == false)
1362:sxmlc/sxmlc.c **** 					break;
1363:sxmlc/sxmlc.c **** 				if (sax->start_node != NULL && (exit = !sax->start_node(&node, sd)))
1364:sxmlc/sxmlc.c **** 					break;
1365:sxmlc/sxmlc.c **** 				if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_START_NODE, &node, NULL, sd->li
1366:sxmlc/sxmlc.c **** 					break;
1367:sxmlc/sxmlc.c **** 				if (node.tag_type != TAG_FATHER && (sax->end_node != NULL || sax->all_event != NULL)) {
1368:sxmlc/sxmlc.c **** 					if (sax->end_node != NULL && (exit = !sax->end_node(&node, sd)))
1369:sxmlc/sxmlc.c **** 						break;
1370:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_END_NODE, &node, NULL, sd->lin
1371:sxmlc/sxmlc.c **** 						break;
1372:sxmlc/sxmlc.c **** 				}
1373:sxmlc/sxmlc.c **** 			break;
1374:sxmlc/sxmlc.c **** 		}
1375:sxmlc/sxmlc.c **** 		if (exit == true || ret == false || meos(in))
1376:sxmlc/sxmlc.c **** 			break;
1377:sxmlc/sxmlc.c **** 	}
1378:sxmlc/sxmlc.c **** 	__free(line);
1379:sxmlc/sxmlc.c **** 	(void)XMLNode_free(&node);
1380:sxmlc/sxmlc.c **** 
1381:sxmlc/sxmlc.c **** 	if (sax->end_doc != NULL && !sax->end_doc(sd))
1382:sxmlc/sxmlc.c **** 		return ret;
1383:sxmlc/sxmlc.c **** 	if (sax->all_event != NULL)
1384:sxmlc/sxmlc.c **** 		(void)sax->all_event(XML_EVENT_END_DOC, NULL, (SXML_CHAR*)sd->name, sd->line_num, sd);
1385:sxmlc/sxmlc.c **** 
1386:sxmlc/sxmlc.c **** 	return ret;
1387:sxmlc/sxmlc.c **** }
1388:sxmlc/sxmlc.c **** 
1389:sxmlc/sxmlc.c **** int SAX_Callbacks_init(SAX_Callbacks* sax)
1390:sxmlc/sxmlc.c **** {
1391:sxmlc/sxmlc.c **** 	if (sax == NULL)
1392:sxmlc/sxmlc.c **** 		return false;
1393:sxmlc/sxmlc.c **** 
1394:sxmlc/sxmlc.c **** 	sax->start_doc = NULL;
1395:sxmlc/sxmlc.c **** 	sax->start_node = NULL;
1396:sxmlc/sxmlc.c **** 	sax->end_node = NULL;
1397:sxmlc/sxmlc.c **** 	sax->new_text = NULL;
1398:sxmlc/sxmlc.c **** 	sax->on_error = NULL;
1399:sxmlc/sxmlc.c **** 	sax->end_doc = NULL;
1400:sxmlc/sxmlc.c **** 	sax->all_event = NULL;
1401:sxmlc/sxmlc.c **** 
1402:sxmlc/sxmlc.c **** 	return true;
1403:sxmlc/sxmlc.c **** }
1404:sxmlc/sxmlc.c **** 
1405:sxmlc/sxmlc.c **** int DOMXMLDoc_doc_start(SAX_Data* sd)
1406:sxmlc/sxmlc.c **** {
  74              		.loc 1 1406 0
  75              		.cfi_startproc
  76              		@ args = 0, pretend = 0, frame = 0
  77              		@ frame_needed = 0, uses_anonymous_args = 0
  78              		@ link register save eliminated.
  79              	.LVL8:
1407:sxmlc/sxmlc.c **** 	DOM_through_SAX* dom = (DOM_through_SAX*)sd->user;
  80              		.loc 1 1407 0
  81 0000 8368     		ldr	r3, [r0, #8]
  82              	.LVL9:
1408:sxmlc/sxmlc.c **** 
1409:sxmlc/sxmlc.c **** 	dom->current = NULL;
  83              		.loc 1 1409 0
  84 0002 0022     		movs	r2, #0
  85 0004 5A60     		str	r2, [r3, #4]
1410:sxmlc/sxmlc.c **** 	dom->error = PARSE_ERR_NONE;
  86              		.loc 1 1410 0
  87 0006 1A72     		strb	r2, [r3, #8]
1411:sxmlc/sxmlc.c **** 	dom->line_error = 0;
  88              		.loc 1 1411 0
  89 0008 DA60     		str	r2, [r3, #12]
1412:sxmlc/sxmlc.c **** 
1413:sxmlc/sxmlc.c **** 	return true;
1414:sxmlc/sxmlc.c **** }
  90              		.loc 1 1414 0
  91 000a 0120     		movs	r0, #1
  92              	.LVL10:
  93 000c 7047     		bx	lr
  94              		.cfi_endproc
  95              	.LFE46:
  97              		.section	.text.DOMXMLDoc_parse_error,"ax",%progbits
  98              		.align	1
  99              		.global	DOMXMLDoc_parse_error
 100              		.thumb
 101              		.thumb_func
 103              	DOMXMLDoc_parse_error:
 104              	.LFB50:
1415:sxmlc/sxmlc.c **** 
1416:sxmlc/sxmlc.c **** int DOMXMLDoc_node_start(const XMLNode* node, SAX_Data* sd)
1417:sxmlc/sxmlc.c **** {
1418:sxmlc/sxmlc.c **** 	DOM_through_SAX* dom = (DOM_through_SAX*)sd->user;
1419:sxmlc/sxmlc.c **** 	XMLNode* new_node;
1420:sxmlc/sxmlc.c **** 	int i;
1421:sxmlc/sxmlc.c **** 
1422:sxmlc/sxmlc.c **** 	if ((new_node = XMLNode_dup(node, true)) == NULL) goto node_start_err; /* No real need to put 'tru
1423:sxmlc/sxmlc.c **** 	
1424:sxmlc/sxmlc.c **** 	if (dom->current == NULL) {
1425:sxmlc/sxmlc.c **** 		if ((i = _add_node(&dom->doc->nodes, &dom->doc->n_nodes, new_node)) < 0) goto node_start_err;
1426:sxmlc/sxmlc.c **** 
1427:sxmlc/sxmlc.c **** 		if (dom->doc->i_root < 0 && (node->tag_type == TAG_FATHER || node->tag_type == TAG_SELF))
1428:sxmlc/sxmlc.c **** 			dom->doc->i_root = i;
1429:sxmlc/sxmlc.c **** 	} else {
1430:sxmlc/sxmlc.c **** 		if (_add_node(&dom->current->children, &dom->current->n_children, new_node) < 0) goto node_start_
1431:sxmlc/sxmlc.c **** 	}
1432:sxmlc/sxmlc.c **** 
1433:sxmlc/sxmlc.c **** 	new_node->father = dom->current;
1434:sxmlc/sxmlc.c **** 	dom->current = new_node;
1435:sxmlc/sxmlc.c **** 
1436:sxmlc/sxmlc.c **** 	return true;
1437:sxmlc/sxmlc.c **** 
1438:sxmlc/sxmlc.c **** node_start_err:
1439:sxmlc/sxmlc.c **** 	dom->error = PARSE_ERR_MEMORY;
1440:sxmlc/sxmlc.c **** 	dom->line_error = sd->line_num;
1441:sxmlc/sxmlc.c **** 	(void)XMLNode_free(new_node);
1442:sxmlc/sxmlc.c **** 	__free(new_node);
1443:sxmlc/sxmlc.c **** 
1444:sxmlc/sxmlc.c **** 	return false;
1445:sxmlc/sxmlc.c **** }
1446:sxmlc/sxmlc.c **** 
1447:sxmlc/sxmlc.c **** int DOMXMLDoc_node_end(const XMLNode* node, SAX_Data* sd)
1448:sxmlc/sxmlc.c **** {
1449:sxmlc/sxmlc.c **** 	DOM_through_SAX* dom = (DOM_through_SAX*)sd->user;
1450:sxmlc/sxmlc.c **** 
1451:sxmlc/sxmlc.c **** 	if (dom->current == NULL || sx_strcmp(dom->current->tag, node->tag)) {
1452:sxmlc/sxmlc.c **** 		sx_fprintf(stderr, C2SX("%s:%d: ERROR - End tag </%s> was unexpected"), sd->name, sd->line_num, n
1453:sxmlc/sxmlc.c **** 		if (dom->current != NULL)
1454:sxmlc/sxmlc.c **** 			sx_fprintf(stderr, C2SX(" (</%s> was expected)\n"), dom->current->tag);
1455:sxmlc/sxmlc.c **** 		else
1456:sxmlc/sxmlc.c **** 			sx_fprintf(stderr, C2SX(" (no node to end)\n"));
1457:sxmlc/sxmlc.c **** 
1458:sxmlc/sxmlc.c **** 		dom->error = PARSE_ERR_UNEXPECTED_NODE_END;
1459:sxmlc/sxmlc.c **** 		dom->line_error = sd->line_num;
1460:sxmlc/sxmlc.c **** 
1461:sxmlc/sxmlc.c **** 		return false;
1462:sxmlc/sxmlc.c **** 	}
1463:sxmlc/sxmlc.c **** 
1464:sxmlc/sxmlc.c **** 	dom->current = dom->current->father;
1465:sxmlc/sxmlc.c **** 
1466:sxmlc/sxmlc.c **** 	return true;
1467:sxmlc/sxmlc.c **** }
1468:sxmlc/sxmlc.c **** 
1469:sxmlc/sxmlc.c **** int DOMXMLDoc_node_text(SXML_CHAR* text, SAX_Data* sd)
1470:sxmlc/sxmlc.c **** {
1471:sxmlc/sxmlc.c **** 	SXML_CHAR* p = text;
1472:sxmlc/sxmlc.c **** 	DOM_through_SAX* dom = (DOM_through_SAX*)sd->user;
1473:sxmlc/sxmlc.c **** 
1474:sxmlc/sxmlc.c **** 	/* Keep text, even if it is only spaces */
1475:sxmlc/sxmlc.c **** #if 0
1476:sxmlc/sxmlc.c **** 	while(*p != NULC && sx_isspace(*p++)) ;
1477:sxmlc/sxmlc.c **** 	if (*p == NULC) return true; /* Only spaces */
1478:sxmlc/sxmlc.c **** #endif
1479:sxmlc/sxmlc.c **** 
1480:sxmlc/sxmlc.c **** 	/* If there is no current node to add text to, raise an error, except if text is only spaces, in w
1481:sxmlc/sxmlc.c **** 	if (dom->current == NULL) {
1482:sxmlc/sxmlc.c **** 		while(*p != NULC && sx_isspace(*p++)) ;
1483:sxmlc/sxmlc.c **** 		if (*p == NULC) /* Only spaces => probably pretty-printing */
1484:sxmlc/sxmlc.c **** 			return true;
1485:sxmlc/sxmlc.c **** 		dom->error = PARSE_ERR_TEXT_OUTSIDE_NODE;
1486:sxmlc/sxmlc.c **** 		dom->line_error = sd->line_num;
1487:sxmlc/sxmlc.c **** 		return false; /* There is some "real" text => raise an error */
1488:sxmlc/sxmlc.c **** 	}
1489:sxmlc/sxmlc.c **** 
1490:sxmlc/sxmlc.c **** 	if (dom->text_as_nodes) {
1491:sxmlc/sxmlc.c **** 		XMLNode* new_node = XMLNode_allocN(1);
1492:sxmlc/sxmlc.c **** 		if (new_node == NULL || (new_node->text = sx_strdup(text)) == NULL
1493:sxmlc/sxmlc.c **** 			|| _add_node(&dom->current->children, &dom->current->n_children, new_node) < 0) {
1494:sxmlc/sxmlc.c **** 			dom->error = PARSE_ERR_MEMORY;
1495:sxmlc/sxmlc.c **** 			dom->line_error = sd->line_num;
1496:sxmlc/sxmlc.c **** 			(void)XMLNode_free(new_node);
1497:sxmlc/sxmlc.c **** 			__free(new_node);
1498:sxmlc/sxmlc.c **** 			return false;
1499:sxmlc/sxmlc.c **** 		}
1500:sxmlc/sxmlc.c **** 		new_node->tag_type = TAG_TEXT;
1501:sxmlc/sxmlc.c **** 		new_node->father = dom->current;
1502:sxmlc/sxmlc.c **** 		//dom->current->tag_type = TAG_FATHER; // OS: should parent field be forced to be TAG_FATHER? now
1503:sxmlc/sxmlc.c **** 		return true;
1504:sxmlc/sxmlc.c **** 	} else { /* Old behaviour: concatenate text to the previous one */
1505:sxmlc/sxmlc.c **** 		/* 'p' will point at the new text */
1506:sxmlc/sxmlc.c **** 		if (dom->current->text == NULL) {
1507:sxmlc/sxmlc.c **** 			p = sx_strdup(text);
1508:sxmlc/sxmlc.c **** 		} else {
1509:sxmlc/sxmlc.c **** 			p = (SXML_CHAR*)__realloc(dom->current->text, (sx_strlen(dom->current->text) + sx_strlen(text) +
1510:sxmlc/sxmlc.c **** 			if (p != NULL)
1511:sxmlc/sxmlc.c **** 				sx_strcat(p, text);
1512:sxmlc/sxmlc.c **** 		}
1513:sxmlc/sxmlc.c **** 		if (p == NULL) {
1514:sxmlc/sxmlc.c **** 			dom->error = PARSE_ERR_MEMORY;
1515:sxmlc/sxmlc.c **** 			dom->line_error = sd->line_num;
1516:sxmlc/sxmlc.c **** 			return false;
1517:sxmlc/sxmlc.c **** 		}
1518:sxmlc/sxmlc.c **** 		
1519:sxmlc/sxmlc.c **** 		dom->current->text = p;
1520:sxmlc/sxmlc.c **** 	}
1521:sxmlc/sxmlc.c **** 
1522:sxmlc/sxmlc.c **** 	return true;
1523:sxmlc/sxmlc.c **** }
1524:sxmlc/sxmlc.c **** 
1525:sxmlc/sxmlc.c **** int DOMXMLDoc_parse_error(ParseError error_num, int line_number, SAX_Data* sd)
1526:sxmlc/sxmlc.c **** {
 105              		.loc 1 1526 0
 106              		.cfi_startproc
 107              		@ args = 0, pretend = 0, frame = 0
 108              		@ frame_needed = 0, uses_anonymous_args = 0
 109              		@ link register save eliminated.
 110              	.LVL11:
1527:sxmlc/sxmlc.c **** 	DOM_through_SAX* dom = (DOM_through_SAX*)sd->user;
 111              		.loc 1 1527 0
 112 0000 9368     		ldr	r3, [r2, #8]
 113              	.LVL12:
1528:sxmlc/sxmlc.c **** 
1529:sxmlc/sxmlc.c **** 	dom->error = error_num;
 114              		.loc 1 1529 0
 115 0002 1872     		strb	r0, [r3, #8]
1530:sxmlc/sxmlc.c **** 	dom->line_error = line_number;
 116              		.loc 1 1530 0
 117 0004 D960     		str	r1, [r3, #12]
1531:sxmlc/sxmlc.c **** 
1532:sxmlc/sxmlc.c **** 	/* Complete error message will be displayed in 'DOMXMLDoc_doc_end' callback */
1533:sxmlc/sxmlc.c **** 
1534:sxmlc/sxmlc.c **** 	return false; /* Stop on error */
1535:sxmlc/sxmlc.c **** }
 118              		.loc 1 1535 0
 119 0006 0020     		movs	r0, #0
 120              	.LVL13:
 121 0008 7047     		bx	lr
 122              		.cfi_endproc
 123              	.LFE50:
 125              		.section	.text._bgetc,"ax",%progbits
 126              		.align	1
 127              		.global	_bgetc
 128              		.thumb
 129              		.thumb_func
 131              	_bgetc:
 132              	.LFB57:
1536:sxmlc/sxmlc.c **** 
1537:sxmlc/sxmlc.c **** int DOMXMLDoc_doc_end(SAX_Data* sd)
1538:sxmlc/sxmlc.c **** {
1539:sxmlc/sxmlc.c **** 	DOM_through_SAX* dom = (DOM_through_SAX*)sd->user;
1540:sxmlc/sxmlc.c **** 
1541:sxmlc/sxmlc.c **** 	if (dom->error != PARSE_ERR_NONE) {
1542:sxmlc/sxmlc.c **** 		SXML_CHAR* msg;
1543:sxmlc/sxmlc.c **** 
1544:sxmlc/sxmlc.c **** 		switch (dom->error) {
1545:sxmlc/sxmlc.c **** 			case PARSE_ERR_MEMORY:				msg = C2SX("MEMORY"); break;
1546:sxmlc/sxmlc.c **** 			case PARSE_ERR_UNEXPECTED_TAG_END:	msg = C2SX("UNEXPECTED_TAG_END"); break;
1547:sxmlc/sxmlc.c **** 			case PARSE_ERR_SYNTAX:				msg = C2SX("SYNTAX"); break;
1548:sxmlc/sxmlc.c **** 			case PARSE_ERR_EOF:					msg = C2SX("UNEXPECTED_END_OF_FILE"); break;
1549:sxmlc/sxmlc.c **** 			case PARSE_ERR_TEXT_OUTSIDE_NODE:	msg = C2SX("TEXT_OUTSIDE_NODE"); break;
1550:sxmlc/sxmlc.c **** 			case PARSE_ERR_UNEXPECTED_NODE_END:	msg = C2SX("UNEXPECTED_NODE_END"); break;
1551:sxmlc/sxmlc.c **** 			default:							msg = C2SX("UNKNOWN"); break;
1552:sxmlc/sxmlc.c **** 		}
1553:sxmlc/sxmlc.c **** 		sx_fprintf(stderr, C2SX("%s:%d: An error was found (%s), loading aborted...\n"), sd->name, dom->l
1554:sxmlc/sxmlc.c **** 		dom->current = NULL;
1555:sxmlc/sxmlc.c **** 		(void)XMLDoc_free(dom->doc);
1556:sxmlc/sxmlc.c **** 		dom->doc = NULL;
1557:sxmlc/sxmlc.c **** 	}
1558:sxmlc/sxmlc.c **** 
1559:sxmlc/sxmlc.c **** 	return true;
1560:sxmlc/sxmlc.c **** }
1561:sxmlc/sxmlc.c **** 
1562:sxmlc/sxmlc.c **** int SAX_Callbacks_init_DOM(SAX_Callbacks* sax)
1563:sxmlc/sxmlc.c **** {
1564:sxmlc/sxmlc.c **** 	if (sax == NULL)
1565:sxmlc/sxmlc.c **** 		return false;
1566:sxmlc/sxmlc.c **** 
1567:sxmlc/sxmlc.c **** 	sax->start_doc = DOMXMLDoc_doc_start;
1568:sxmlc/sxmlc.c **** 	sax->start_node = DOMXMLDoc_node_start;
1569:sxmlc/sxmlc.c **** 	sax->end_node = DOMXMLDoc_node_end;
1570:sxmlc/sxmlc.c **** 	sax->new_text = DOMXMLDoc_node_text;
1571:sxmlc/sxmlc.c **** 	sax->on_error = DOMXMLDoc_parse_error;
1572:sxmlc/sxmlc.c **** 	sax->end_doc = DOMXMLDoc_doc_end;
1573:sxmlc/sxmlc.c **** 	sax->all_event = NULL;
1574:sxmlc/sxmlc.c **** 
1575:sxmlc/sxmlc.c **** 	return true;
1576:sxmlc/sxmlc.c **** }
1577:sxmlc/sxmlc.c **** 
1578:sxmlc/sxmlc.c **** int XMLDoc_parse_file_SAX(const SXML_CHAR* filename, const SAX_Callbacks* sax, void* user)
1579:sxmlc/sxmlc.c **** {
1580:sxmlc/sxmlc.c **** 	FILE* f;
1581:sxmlc/sxmlc.c **** 	int ret;
1582:sxmlc/sxmlc.c **** 	SAX_Data sd;
1583:sxmlc/sxmlc.c **** 	SXML_CHAR* fmode = 
1584:sxmlc/sxmlc.c **** #ifndef SXMLC_UNICODE
1585:sxmlc/sxmlc.c **** 	C2SX("rt");
1586:sxmlc/sxmlc.c **** #else
1587:sxmlc/sxmlc.c **** 	C2SX("rb"); /* In Unicode, open the file as binary so that further 'fgetwc' read all bytes */
1588:sxmlc/sxmlc.c **** 	BOM_TYPE bom;
1589:sxmlc/sxmlc.c **** #endif
1590:sxmlc/sxmlc.c **** 
1591:sxmlc/sxmlc.c **** 
1592:sxmlc/sxmlc.c **** 	if (sax == NULL || filename == NULL || filename[0] == NULC)
1593:sxmlc/sxmlc.c **** 		return false;
1594:sxmlc/sxmlc.c **** 
1595:sxmlc/sxmlc.c **** 	f = sx_fopen(filename, fmode);
1596:sxmlc/sxmlc.c **** 	if (f == NULL)
1597:sxmlc/sxmlc.c **** 		return false;
1598:sxmlc/sxmlc.c **** 	/* Microsoft' 'ftell' returns invalid position for Unicode text files
1599:sxmlc/sxmlc.c **** 	   (see http://connect.microsoft.com/VisualStudio/feedback/details/369265/ftell-ftell-nolock-incor
1600:sxmlc/sxmlc.c **** 	   However, we're opening the file as binary in Unicode so we don't fall into that case...
1601:sxmlc/sxmlc.c **** 	*/
1602:sxmlc/sxmlc.c **** 	#if defined(SXMLC_UNICODE) && (defined(WIN32) || defined(WIN64))
1603:sxmlc/sxmlc.c **** 	//setvbuf(f, NULL, _IONBF, 0);
1604:sxmlc/sxmlc.c **** 	#endif
1605:sxmlc/sxmlc.c **** 
1606:sxmlc/sxmlc.c **** 	sd.name = (SXML_CHAR*)filename;
1607:sxmlc/sxmlc.c **** 	sd.user = user;
1608:sxmlc/sxmlc.c **** #ifdef SXMLC_UNICODE
1609:sxmlc/sxmlc.c **** 	bom = freadBOM(f, NULL, NULL); /* Skip BOM, if any */
1610:sxmlc/sxmlc.c **** 	/* In Unicode, re-open the file in text-mode if there is no BOM (or UTF-8) as we assume that
1611:sxmlc/sxmlc.c **** 	   the file is "plain" text (i.e. 1 byte = 1 character). If opened in binary mode, 'fgetwc'
1612:sxmlc/sxmlc.c **** 	   would read 2 bytes for 1 character, which would not work on "plain" files. */
1613:sxmlc/sxmlc.c **** 	if (bom == BOM_NONE || bom == BOM_UTF_8) {
1614:sxmlc/sxmlc.c **** 		fclose(f);
1615:sxmlc/sxmlc.c **** 		f = sx_fopen(filename, C2SX("rt"));
1616:sxmlc/sxmlc.c **** 		if (f == NULL)
1617:sxmlc/sxmlc.c **** 			return false;
1618:sxmlc/sxmlc.c **** 		if (bom == BOM_UTF_8)
1619:sxmlc/sxmlc.c **** 			freadBOM(f, NULL, NULL); /* Skip the UTF-8 BOM that was found */
1620:sxmlc/sxmlc.c **** 	}
1621:sxmlc/sxmlc.c **** #endif
1622:sxmlc/sxmlc.c **** 	ret = _parse_data_SAX((void*)f, DATA_SOURCE_FILE, sax, &sd);
1623:sxmlc/sxmlc.c **** 	(void)fclose(f);
1624:sxmlc/sxmlc.c **** 
1625:sxmlc/sxmlc.c **** 	return ret;
1626:sxmlc/sxmlc.c **** }
1627:sxmlc/sxmlc.c **** 
1628:sxmlc/sxmlc.c **** int XMLDoc_parse_buffer_SAX(const SXML_CHAR* buffer, const SXML_CHAR* name, const SAX_Callbacks* sa
1629:sxmlc/sxmlc.c **** {
1630:sxmlc/sxmlc.c **** 	DataSourceBuffer dsb = { buffer, 0 };
1631:sxmlc/sxmlc.c **** 	SAX_Data sd;
1632:sxmlc/sxmlc.c **** 
1633:sxmlc/sxmlc.c **** 	if (sax == NULL || buffer == NULL)
1634:sxmlc/sxmlc.c **** 		return false;
1635:sxmlc/sxmlc.c **** 
1636:sxmlc/sxmlc.c **** 	sd.name = name;
1637:sxmlc/sxmlc.c **** 	sd.user = user;
1638:sxmlc/sxmlc.c **** 	return _parse_data_SAX((void*)&dsb, DATA_SOURCE_BUFFER, sax, &sd);
1639:sxmlc/sxmlc.c **** }
1640:sxmlc/sxmlc.c **** 
1641:sxmlc/sxmlc.c **** int XMLDoc_parse_file_DOM_text_as_nodes(const SXML_CHAR* filename, XMLDoc* doc, int text_as_nodes)
1642:sxmlc/sxmlc.c **** {
1643:sxmlc/sxmlc.c **** 	DOM_through_SAX dom;
1644:sxmlc/sxmlc.c **** 	SAX_Callbacks sax;
1645:sxmlc/sxmlc.c **** 
1646:sxmlc/sxmlc.c **** 	if (doc == NULL || filename == NULL || filename[0] == NULC || doc->init_value != XML_INIT_DONE)
1647:sxmlc/sxmlc.c **** 		return false;
1648:sxmlc/sxmlc.c **** 
1649:sxmlc/sxmlc.c **** 	sx_strncpy(doc->filename, filename, SXMLC_MAX_PATH - 1);
1650:sxmlc/sxmlc.c **** 	doc->filename[SXMLC_MAX_PATH - 1] = NULC;
1651:sxmlc/sxmlc.c **** 
1652:sxmlc/sxmlc.c **** 	/* Read potential BOM on file, only when unicode is defined */
1653:sxmlc/sxmlc.c **** #ifdef SXMLC_UNICODE
1654:sxmlc/sxmlc.c **** 	{
1655:sxmlc/sxmlc.c **** 		/* In Unicode, open the file as binary so that further 'fgetwc' read all bytes */
1656:sxmlc/sxmlc.c **** 		FILE* f = sx_fopen(filename, C2SX("rb"));
1657:sxmlc/sxmlc.c **** 		if (f != NULL) {
1658:sxmlc/sxmlc.c **** 			#if defined(SXMLC_UNICODE) && (defined(WIN32) || defined(WIN64))
1659:sxmlc/sxmlc.c **** 			//setvbuf(f, NULL, _IONBF, 0);
1660:sxmlc/sxmlc.c **** 			#endif
1661:sxmlc/sxmlc.c **** 			doc->bom_type = freadBOM(f, doc->bom, &doc->sz_bom);
1662:sxmlc/sxmlc.c **** 			fclose(f);
1663:sxmlc/sxmlc.c **** 		}
1664:sxmlc/sxmlc.c **** 	}
1665:sxmlc/sxmlc.c **** #endif
1666:sxmlc/sxmlc.c **** 
1667:sxmlc/sxmlc.c **** 	dom.doc = doc;
1668:sxmlc/sxmlc.c **** 	dom.current = NULL;
1669:sxmlc/sxmlc.c **** 	dom.text_as_nodes = text_as_nodes;
1670:sxmlc/sxmlc.c **** 	SAX_Callbacks_init_DOM(&sax);
1671:sxmlc/sxmlc.c **** 
1672:sxmlc/sxmlc.c **** 	if (!XMLDoc_parse_file_SAX(filename, &sax, &dom)) {
1673:sxmlc/sxmlc.c **** 		(void)XMLDoc_free(doc);
1674:sxmlc/sxmlc.c **** 		dom.doc = NULL;
1675:sxmlc/sxmlc.c **** 		return false;
1676:sxmlc/sxmlc.c **** 	}
1677:sxmlc/sxmlc.c **** 
1678:sxmlc/sxmlc.c **** 	return true;
1679:sxmlc/sxmlc.c **** }
1680:sxmlc/sxmlc.c **** 
1681:sxmlc/sxmlc.c **** int XMLDoc_parse_buffer_DOM_text_as_nodes(const SXML_CHAR* buffer, const SXML_CHAR* name, XMLDoc* d
1682:sxmlc/sxmlc.c **** {
1683:sxmlc/sxmlc.c **** 	DOM_through_SAX dom;
1684:sxmlc/sxmlc.c **** 	SAX_Callbacks sax;
1685:sxmlc/sxmlc.c **** 
1686:sxmlc/sxmlc.c **** 	if (doc == NULL || buffer == NULL || doc->init_value != XML_INIT_DONE)
1687:sxmlc/sxmlc.c **** 		return false;
1688:sxmlc/sxmlc.c **** 
1689:sxmlc/sxmlc.c **** 	dom.doc = doc;
1690:sxmlc/sxmlc.c **** 	dom.current = NULL;
1691:sxmlc/sxmlc.c **** 	dom.text_as_nodes = text_as_nodes;
1692:sxmlc/sxmlc.c **** 	SAX_Callbacks_init_DOM(&sax);
1693:sxmlc/sxmlc.c **** 
1694:sxmlc/sxmlc.c **** 	return XMLDoc_parse_buffer_SAX(buffer, name, &sax, &dom) ? true : XMLDoc_free(doc);
1695:sxmlc/sxmlc.c **** }
1696:sxmlc/sxmlc.c **** 
1697:sxmlc/sxmlc.c **** 
1698:sxmlc/sxmlc.c **** 
1699:sxmlc/sxmlc.c **** /* --- Utility functions (ex sxmlutils.c) --- */
1700:sxmlc/sxmlc.c **** 
1701:sxmlc/sxmlc.c **** #ifdef DBG_MEM
1702:sxmlc/sxmlc.c **** static int nb_alloc = 0, nb_free = 0;
1703:sxmlc/sxmlc.c **** 
1704:sxmlc/sxmlc.c **** void* __malloc(size_t sz)
1705:sxmlc/sxmlc.c **** {
1706:sxmlc/sxmlc.c **** 	void* p = malloc(sz);
1707:sxmlc/sxmlc.c **** 	if (p != NULL)
1708:sxmlc/sxmlc.c **** 		nb_alloc++;
1709:sxmlc/sxmlc.c **** 	printf("0x%x: MALLOC (%d) - NA %d - NF %d = %d\n", p, sz, nb_alloc, nb_free, nb_alloc - nb_free);
1710:sxmlc/sxmlc.c **** 	return p;
1711:sxmlc/sxmlc.c **** }
1712:sxmlc/sxmlc.c **** 
1713:sxmlc/sxmlc.c **** void* __calloc(size_t count, size_t sz)
1714:sxmlc/sxmlc.c **** {
1715:sxmlc/sxmlc.c **** 	void* p = calloc(count, sz);
1716:sxmlc/sxmlc.c **** 	if (p != NULL)
1717:sxmlc/sxmlc.c **** 		nb_alloc++;
1718:sxmlc/sxmlc.c **** 	printf("0x%x: CALLOC (%d, %d) - NA %d - NF %d = %d\n", p, count, sz, nb_alloc, nb_free, nb_alloc -
1719:sxmlc/sxmlc.c **** 	return p;
1720:sxmlc/sxmlc.c **** }
1721:sxmlc/sxmlc.c **** 
1722:sxmlc/sxmlc.c **** void* __realloc(void* mem, size_t sz)
1723:sxmlc/sxmlc.c **** {
1724:sxmlc/sxmlc.c **** 	void* p = realloc(mem, sz);
1725:sxmlc/sxmlc.c **** 	if (mem == NULL && p != NULL)
1726:sxmlc/sxmlc.c **** 		nb_alloc++;
1727:sxmlc/sxmlc.c **** 	else if (mem != NULL && sz == 0)
1728:sxmlc/sxmlc.c **** 		nb_free++;
1729:sxmlc/sxmlc.c **** 	printf("0x%x: REALLOC 0x%x (%d)", p, mem, sz);
1730:sxmlc/sxmlc.c **** 	if (mem == NULL)
1731:sxmlc/sxmlc.c **** 		printf(" - NA %d - NF %d = %d", nb_alloc, nb_free, nb_alloc - nb_free);
1732:sxmlc/sxmlc.c **** 	printf("\n");
1733:sxmlc/sxmlc.c **** 	return p;
1734:sxmlc/sxmlc.c **** }
1735:sxmlc/sxmlc.c **** 
1736:sxmlc/sxmlc.c **** void __free(void* mem)
1737:sxmlc/sxmlc.c **** {
1738:sxmlc/sxmlc.c **** 	nb_free++;
1739:sxmlc/sxmlc.c **** 	printf("0x%x: FREE - NA %d - NF %d = %d\n", mem, nb_alloc, nb_free, nb_alloc - nb_free);
1740:sxmlc/sxmlc.c **** 	free(mem);
1741:sxmlc/sxmlc.c **** }
1742:sxmlc/sxmlc.c **** 
1743:sxmlc/sxmlc.c **** char* __sx_strdup(const char* s)
1744:sxmlc/sxmlc.c **** {
1745:sxmlc/sxmlc.c **** /* Mimic the behavior of sx_strdup(), as we can't use it directly here: DBG_MEM is defined
1746:sxmlc/sxmlc.c ****    and sx_strdup is this function! (bug #5) */
1747:sxmlc/sxmlc.c **** #ifdef SXMLC_UNICODE
1748:sxmlc/sxmlc.c **** 	char* p = wcsdup(s);
1749:sxmlc/sxmlc.c **** #else
1750:sxmlc/sxmlc.c **** 	char* p = strdup(s);
1751:sxmlc/sxmlc.c **** #endif
1752:sxmlc/sxmlc.c **** 	if (p != NULL)
1753:sxmlc/sxmlc.c **** 		nb_alloc++;
1754:sxmlc/sxmlc.c **** 	printf("0x%x: STRDUP (%d) - NA %d - NF %d = %d\n", p, sx_strlen(s), nb_alloc, nb_free, nb_alloc - 
1755:sxmlc/sxmlc.c **** 	return p;
1756:sxmlc/sxmlc.c **** }
1757:sxmlc/sxmlc.c **** #endif
1758:sxmlc/sxmlc.c **** 
1759:sxmlc/sxmlc.c **** /* Dictionary of special characters and their HTML equivalent */
1760:sxmlc/sxmlc.c **** static struct _html_special_dict {
1761:sxmlc/sxmlc.c **** 	SXML_CHAR chr;		/* Original character */
1762:sxmlc/sxmlc.c **** 	SXML_CHAR* html;	/* Equivalent HTML string */
1763:sxmlc/sxmlc.c **** 	int html_len;	/* 'sx_strlen(html)' */
1764:sxmlc/sxmlc.c **** } HTML_SPECIAL_DICT[] = {
1765:sxmlc/sxmlc.c **** 	{ C2SX('<'), C2SX("&lt;"), 4 },
1766:sxmlc/sxmlc.c **** 	{ C2SX('>'), C2SX("&gt;"), 4 },
1767:sxmlc/sxmlc.c **** 	{ C2SX('"'), C2SX("&quot;"), 6 },
1768:sxmlc/sxmlc.c **** 	{ C2SX('\''), C2SX("&apos;"), 6 },
1769:sxmlc/sxmlc.c **** 	{ C2SX('&'), C2SX("&amp;"), 5 },
1770:sxmlc/sxmlc.c **** 	{ NULC, NULL, 0 }, /* Terminator */
1771:sxmlc/sxmlc.c **** };
1772:sxmlc/sxmlc.c **** 
1773:sxmlc/sxmlc.c **** int _bgetc(DataSourceBuffer* ds)
1774:sxmlc/sxmlc.c **** {
 133              		.loc 1 1774 0
 134              		.cfi_startproc
 135              		@ args = 0, pretend = 0, frame = 0
 136              		@ frame_needed = 0, uses_anonymous_args = 0
 137              		@ link register save eliminated.
 138              	.LVL14:
1775:sxmlc/sxmlc.c **** 	if (ds == NULL || ds->buf[ds->cur_pos] == NULC)
 139              		.loc 1 1775 0
 140 0000 38B1     		cbz	r0, .L14
 141              		.loc 1 1775 0 is_stmt 0 discriminator 1
 142 0002 90E80C00 		ldmia	r0, {r2, r3}
 143 0006 D15C     		ldrb	r1, [r2, r3]	@ zero_extendqisi2
 144 0008 19B1     		cbz	r1, .L14
1776:sxmlc/sxmlc.c **** 		return EOF;
1777:sxmlc/sxmlc.c **** 	
1778:sxmlc/sxmlc.c **** 	return (int)(ds->buf[ds->cur_pos++]);
 145              		.loc 1 1778 0 is_stmt 1
 146 000a 591C     		adds	r1, r3, #1
 147 000c 4160     		str	r1, [r0, #4]
 148 000e D05C     		ldrb	r0, [r2, r3]	@ zero_extendqisi2
 149              	.LVL15:
 150 0010 7047     		bx	lr
 151              	.LVL16:
 152              	.L14:
1776:sxmlc/sxmlc.c **** 		return EOF;
 153              		.loc 1 1776 0
 154 0012 4FF0FF30 		mov	r0, #-1
 155              	.LVL17:
1779:sxmlc/sxmlc.c **** }
 156              		.loc 1 1779 0
 157 0016 7047     		bx	lr
 158              		.cfi_endproc
 159              	.LFE57:
 161              		.section	.text._beob,"ax",%progbits
 162              		.align	1
 163              		.global	_beob
 164              		.thumb
 165              		.thumb_func
 167              	_beob:
 168              	.LFB58:
1780:sxmlc/sxmlc.c **** 
1781:sxmlc/sxmlc.c **** int _beob(DataSourceBuffer* ds)
1782:sxmlc/sxmlc.c **** {
 169              		.loc 1 1782 0
 170              		.cfi_startproc
 171              		@ args = 0, pretend = 0, frame = 0
 172              		@ frame_needed = 0, uses_anonymous_args = 0
 173              		@ link register save eliminated.
 174              	.LVL18:
1783:sxmlc/sxmlc.c **** 
1784:sxmlc/sxmlc.c **** 	if (ds == NULL || ds->buf[ds->cur_pos] == NULC)
 175              		.loc 1 1784 0
 176 0000 38B1     		cbz	r0, .L17
 177              		.loc 1 1784 0 is_stmt 0 discriminator 1
 178 0002 90E80C00 		ldmia	r0, {r2, r3}
 179 0006 D05C     		ldrb	r0, [r2, r3]	@ zero_extendqisi2
 180              	.LVL19:
 181 0008 D0F10100 		rsbs	r0, r0, #1
 182 000c 38BF     		it	cc
 183 000e 0020     		movcc	r0, #0
 184 0010 7047     		bx	lr
 185              	.LVL20:
 186              	.L17:
1785:sxmlc/sxmlc.c **** 		return true;
 187              		.loc 1 1785 0 is_stmt 1
 188 0012 0120     		movs	r0, #1
 189              	.LVL21:
1786:sxmlc/sxmlc.c **** 
1787:sxmlc/sxmlc.c **** 	return false;
1788:sxmlc/sxmlc.c **** }
 190              		.loc 1 1788 0
 191 0014 7047     		bx	lr
 192              		.cfi_endproc
 193              	.LFE58:
 195              		.section	.text._add_node,"ax",%progbits
 196              		.align	1
 197              		.thumb
 198              		.thumb_func
 200              	_add_node:
 201              	.LFB4:
 164:sxmlc/sxmlc.c **** {
 202              		.loc 1 164 0
 203              		.cfi_startproc
 204              		@ args = 0, pretend = 0, frame = 0
 205              		@ frame_needed = 0, uses_anonymous_args = 0
 206              	.LVL22:
 207 0000 70B5     		push	{r4, r5, r6, lr}
 208              		.cfi_def_cfa_offset 16
 209              		.cfi_offset 4, -16
 210              		.cfi_offset 5, -12
 211              		.cfi_offset 6, -8
 212              		.cfi_offset 14, -4
 164:sxmlc/sxmlc.c **** {
 213              		.loc 1 164 0
 214 0002 0C46     		mov	r4, r1
 165:sxmlc/sxmlc.c **** 	XMLNode** pt = (XMLNode**)__realloc(*children_array, (*len_array+1) * sizeof(XMLNode*));
 215              		.loc 1 165 0
 216 0004 0968     		ldr	r1, [r1]
 217              	.LVL23:
 164:sxmlc/sxmlc.c **** {
 218              		.loc 1 164 0
 219 0006 0546     		mov	r5, r0
 165:sxmlc/sxmlc.c **** 	XMLNode** pt = (XMLNode**)__realloc(*children_array, (*len_array+1) * sizeof(XMLNode*));
 220              		.loc 1 165 0
 221 0008 0131     		adds	r1, r1, #1
 222 000a 8900     		lsls	r1, r1, #2
 223 000c 0068     		ldr	r0, [r0]
 224              	.LVL24:
 164:sxmlc/sxmlc.c **** {
 225              		.loc 1 164 0
 226 000e 1646     		mov	r6, r2
 165:sxmlc/sxmlc.c **** 	XMLNode** pt = (XMLNode**)__realloc(*children_array, (*len_array+1) * sizeof(XMLNode*));
 227              		.loc 1 165 0
 228 0010 FFF7FEFF 		bl	realloc
 229              	.LVL25:
 167:sxmlc/sxmlc.c **** 	if (pt == NULL)
 230              		.loc 1 167 0
 231 0014 0146     		mov	r1, r0
 232 0016 30B1     		cbz	r0, .L20
 170:sxmlc/sxmlc.c **** 	pt[*len_array] = node;
 233              		.loc 1 170 0
 234 0018 2068     		ldr	r0, [r4]
 235              	.LVL26:
 173:sxmlc/sxmlc.c **** 	return (*len_array)++;
 236              		.loc 1 173 0
 237 001a 421C     		adds	r2, r0, #1
 170:sxmlc/sxmlc.c **** 	pt[*len_array] = node;
 238              		.loc 1 170 0
 239 001c 41F82060 		str	r6, [r1, r0, lsl #2]
 171:sxmlc/sxmlc.c **** 	*children_array = pt;
 240              		.loc 1 171 0
 241 0020 2960     		str	r1, [r5]
 173:sxmlc/sxmlc.c **** 	return (*len_array)++;
 242              		.loc 1 173 0
 243 0022 2260     		str	r2, [r4]
 244 0024 70BD     		pop	{r4, r5, r6, pc}
 245              	.LVL27:
 246              	.L20:
 168:sxmlc/sxmlc.c **** 		return -1;
 247              		.loc 1 168 0
 248 0026 4FF0FF30 		mov	r0, #-1
 249              	.LVL28:
 174:sxmlc/sxmlc.c **** }
 250              		.loc 1 174 0
 251 002a 70BD     		pop	{r4, r5, r6, pc}
 252              		.cfi_endproc
 253              	.LFE4:
 255              		.section	.text._parse_special_tag,"ax",%progbits
 256              		.align	1
 257              		.thumb
 258              		.thumb_func
 260              	_parse_special_tag:
 261              	.LFB42:
1076:sxmlc/sxmlc.c **** {
 262              		.loc 1 1076 0
 263              		.cfi_startproc
 264              		@ args = 0, pretend = 0, frame = 0
 265              		@ frame_needed = 0, uses_anonymous_args = 0
 266              	.LVL29:
 267 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 268              		.cfi_def_cfa_offset 32
 269              		.cfi_offset 4, -32
 270              		.cfi_offset 5, -28
 271              		.cfi_offset 6, -24
 272              		.cfi_offset 7, -20
 273              		.cfi_offset 8, -16
 274              		.cfi_offset 9, -12
 275              		.cfi_offset 10, -8
 276              		.cfi_offset 14, -4
1077:sxmlc/sxmlc.c **** 	if (sx_strncmp(str, tag->start, tag->len_start))
 277              		.loc 1 1077 0
 278 0004 9768     		ldr	r7, [r2, #8]
1076:sxmlc/sxmlc.c **** {
 279              		.loc 1 1076 0
 280 0006 0E46     		mov	r6, r1
 281 0008 1446     		mov	r4, r2
1077:sxmlc/sxmlc.c **** 	if (sx_strncmp(str, tag->start, tag->len_start))
 282              		.loc 1 1077 0
 283 000a 5168     		ldr	r1, [r2, #4]
 284              	.LVL30:
 285 000c 3A46     		mov	r2, r7
 286              	.LVL31:
1076:sxmlc/sxmlc.c **** {
 287              		.loc 1 1076 0
 288 000e 8246     		mov	r10, r0
 289 0010 1D46     		mov	r5, r3
1077:sxmlc/sxmlc.c **** 	if (sx_strncmp(str, tag->start, tag->len_start))
 290              		.loc 1 1077 0
 291 0012 FFF7FEFF 		bl	strncmp
 292              	.LVL32:
 293 0016 08B1     		cbz	r0, .L22
 294              	.L24:
1078:sxmlc/sxmlc.c **** 		return TAG_NONE;
 295              		.loc 1 1078 0
 296 0018 0020     		movs	r0, #0
 297 001a 24E0     		b	.L23
 298              	.L22:
1080:sxmlc/sxmlc.c **** 	if (sx_strncmp(str + len - tag->len_end, tag->end, tag->len_end)) /* There probably is a '>' insid
 299              		.loc 1 1080 0
 300 001c D4F81080 		ldr	r8, [r4, #16]
 301 0020 E168     		ldr	r1, [r4, #12]
 302 0022 C8EB0600 		rsb	r0, r8, r6
 303 0026 5044     		add	r0, r0, r10
 304 0028 4246     		mov	r2, r8
 305 002a FFF7FEFF 		bl	strncmp
 306              	.LVL33:
 307 002e 8146     		mov	r9, r0
 308 0030 C0B9     		cbnz	r0, .L25
1083:sxmlc/sxmlc.c **** 	node->tag = (SXML_CHAR*)__malloc((len - tag->len_start - tag->len_end + 1)*sizeof(SXML_CHAR));
 309              		.loc 1 1083 0
 310 0032 F31B     		subs	r3, r6, r7
 311 0034 C8EB0308 		rsb	r8, r8, r3
 312 0038 08F10100 		add	r0, r8, #1
 313 003c FFF7FEFF 		bl	malloc
 314              	.LVL34:
 315 0040 2860     		str	r0, [r5]
1084:sxmlc/sxmlc.c **** 	if (node->tag == NULL)
 316              		.loc 1 1084 0
 317 0042 0028     		cmp	r0, #0
 318 0044 E8D0     		beq	.L24
1086:sxmlc/sxmlc.c **** 	sx_strncpy(node->tag, str + tag->len_start, len - tag->len_start - tag->len_end);
 319              		.loc 1 1086 0
 320 0046 0AEB0701 		add	r1, r10, r7
 321 004a 4246     		mov	r2, r8
 322 004c FFF7FEFF 		bl	strncpy
 323              	.LVL35:
1087:sxmlc/sxmlc.c **** 	node->tag[len - tag->len_start - tag->len_end] = NULC;
 324              		.loc 1 1087 0
 325 0050 A368     		ldr	r3, [r4, #8]
 326 0052 F61A     		subs	r6, r6, r3
 327              	.LVL36:
 328 0054 2369     		ldr	r3, [r4, #16]
 329 0056 F61A     		subs	r6, r6, r3
 330 0058 2B68     		ldr	r3, [r5]
 331 005a 03F80690 		strb	r9, [r3, r6]
1088:sxmlc/sxmlc.c **** 	node->tag_type = tag->tag_type;
 332              		.loc 1 1088 0
 333 005e 2078     		ldrb	r0, [r4]	@ zero_extendqisi2
 334 0060 2877     		strb	r0, [r5, #28]
1090:sxmlc/sxmlc.c **** 	return node->tag_type;
 335              		.loc 1 1090 0
 336 0062 00E0     		b	.L23
 337              	.LVL37:
 338              	.L25:
1081:sxmlc/sxmlc.c **** 		return TAG_PARTIAL;
 339              		.loc 1 1081 0
 340 0064 0120     		movs	r0, #1
 341              	.LVL38:
 342              	.L23:
1091:sxmlc/sxmlc.c **** }
 343              		.loc 1 1091 0
 344 0066 40B2     		sxtb	r0, r0
 345 0068 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 346              		.cfi_endproc
 347              	.LFE42:
 349              		.section	.text.DOMXMLDoc_node_end,"ax",%progbits
 350              		.align	1
 351              		.global	DOMXMLDoc_node_end
 352              		.thumb
 353              		.thumb_func
 355              	DOMXMLDoc_node_end:
 356              	.LFB48:
1448:sxmlc/sxmlc.c **** {
 357              		.loc 1 1448 0
 358              		.cfi_startproc
 359              		@ args = 0, pretend = 0, frame = 0
 360              		@ frame_needed = 0, uses_anonymous_args = 0
 361              	.LVL39:
 362 0000 F7B5     		push	{r0, r1, r2, r4, r5, r6, r7, lr}
 363              		.cfi_def_cfa_offset 32
 364              		.cfi_offset 0, -32
 365              		.cfi_offset 1, -28
 366              		.cfi_offset 2, -24
 367              		.cfi_offset 4, -20
 368              		.cfi_offset 5, -16
 369              		.cfi_offset 6, -12
 370              		.cfi_offset 7, -8
 371              		.cfi_offset 14, -4
1449:sxmlc/sxmlc.c **** 	DOM_through_SAX* dom = (DOM_through_SAX*)sd->user;
 372              		.loc 1 1449 0
 373 0002 8C68     		ldr	r4, [r1, #8]
 374              	.LVL40:
1448:sxmlc/sxmlc.c **** {
 375              		.loc 1 1448 0
 376 0004 0746     		mov	r7, r0
1451:sxmlc/sxmlc.c **** 	if (dom->current == NULL || sx_strcmp(dom->current->tag, node->tag)) {
 377              		.loc 1 1451 0
 378 0006 6668     		ldr	r6, [r4, #4]
1448:sxmlc/sxmlc.c **** {
 379              		.loc 1 1448 0
 380 0008 0D46     		mov	r5, r1
1451:sxmlc/sxmlc.c **** 	if (dom->current == NULL || sx_strcmp(dom->current->tag, node->tag)) {
 381              		.loc 1 1451 0
 382 000a 26B1     		cbz	r6, .L30
1451:sxmlc/sxmlc.c **** 	if (dom->current == NULL || sx_strcmp(dom->current->tag, node->tag)) {
 383              		.loc 1 1451 0 is_stmt 0 discriminator 1
 384 000c 3068     		ldr	r0, [r6]
 385              	.LVL41:
 386 000e 3968     		ldr	r1, [r7]
 387              	.LVL42:
 388 0010 FFF7FEFF 		bl	strcmp
 389              	.LVL43:
 390 0014 E8B1     		cbz	r0, .L31
 391              	.L30:
1452:sxmlc/sxmlc.c **** 		sx_fprintf(stderr, C2SX("%s:%d: ERROR - End tag </%s> was unexpected"), sd->name, sd->line_num, n
 392              		.loc 1 1452 0 is_stmt 1
 393 0016 114E     		ldr	r6, .L38
 394 0018 3A68     		ldr	r2, [r7]
 395 001a 3368     		ldr	r3, [r6]
 396 001c 0092     		str	r2, [sp]
 397 001e D868     		ldr	r0, [r3, #12]
 398 0020 0F49     		ldr	r1, .L38+4
 399 0022 95E80C00 		ldmia	r5, {r2, r3}
 400 0026 FFF7FEFF 		bl	fprintf
 401              	.LVL44:
1453:sxmlc/sxmlc.c **** 		if (dom->current != NULL)
 402              		.loc 1 1453 0
 403 002a 6368     		ldr	r3, [r4, #4]
 404 002c 33B1     		cbz	r3, .L32
1454:sxmlc/sxmlc.c **** 			sx_fprintf(stderr, C2SX(" (</%s> was expected)\n"), dom->current->tag);
 405              		.loc 1 1454 0
 406 002e 3268     		ldr	r2, [r6]
 407 0030 0C49     		ldr	r1, .L38+8
 408 0032 D068     		ldr	r0, [r2, #12]
 409 0034 1A68     		ldr	r2, [r3]
 410 0036 FFF7FEFF 		bl	fprintf
 411              	.LVL45:
 412 003a 04E0     		b	.L33
 413              	.L32:
1456:sxmlc/sxmlc.c **** 			sx_fprintf(stderr, C2SX(" (no node to end)\n"));
 414              		.loc 1 1456 0
 415 003c 3368     		ldr	r3, [r6]
 416 003e 0A48     		ldr	r0, .L38+12
 417 0040 D968     		ldr	r1, [r3, #12]
 418 0042 FFF7FEFF 		bl	fputs
 419              	.LVL46:
 420              	.L33:
1458:sxmlc/sxmlc.c **** 		dom->error = PARSE_ERR_UNEXPECTED_NODE_END;
 421              		.loc 1 1458 0
 422 0046 FA23     		movs	r3, #250
 423 0048 2372     		strb	r3, [r4, #8]
1459:sxmlc/sxmlc.c **** 		dom->line_error = sd->line_num;
 424              		.loc 1 1459 0
 425 004a 6B68     		ldr	r3, [r5, #4]
1461:sxmlc/sxmlc.c **** 		return false;
 426              		.loc 1 1461 0
 427 004c 0020     		movs	r0, #0
1459:sxmlc/sxmlc.c **** 		dom->line_error = sd->line_num;
 428              		.loc 1 1459 0
 429 004e E360     		str	r3, [r4, #12]
1461:sxmlc/sxmlc.c **** 		return false;
 430              		.loc 1 1461 0
 431 0050 02E0     		b	.L34
 432              	.L31:
1464:sxmlc/sxmlc.c **** 	dom->current = dom->current->father;
 433              		.loc 1 1464 0
 434 0052 3369     		ldr	r3, [r6, #16]
1466:sxmlc/sxmlc.c **** 	return true;
 435              		.loc 1 1466 0
 436 0054 0120     		movs	r0, #1
1464:sxmlc/sxmlc.c **** 	dom->current = dom->current->father;
 437              		.loc 1 1464 0
 438 0056 6360     		str	r3, [r4, #4]
 439              	.L34:
1467:sxmlc/sxmlc.c **** }
 440              		.loc 1 1467 0
 441 0058 03B0     		add	sp, sp, #12
 442              		@ sp needed
 443 005a F0BD     		pop	{r4, r5, r6, r7, pc}
 444              	.LVL47:
 445              	.L39:
 446              		.align	2
 447              	.L38:
 448 005c 00000000 		.word	_impure_ptr
 449 0060 00000000 		.word	.LC0
 450 0064 2C000000 		.word	.LC1
 451 0068 43000000 		.word	.LC2
 452              		.cfi_endproc
 453              	.LFE48:
 455              		.section	.text._print_formatting.isra.0,"ax",%progbits
 456              		.align	1
 457              		.thumb
 458              		.thumb_func
 460              	_print_formatting.isra.0:
 461              	.LFB70:
 840:sxmlc/sxmlc.c **** static int _print_formatting(const XMLNode* node, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHA
 462              		.loc 1 840 0
 463              		.cfi_startproc
 464              		@ args = 8, pretend = 0, frame = 0
 465              		@ frame_needed = 0, uses_anonymous_args = 0
 466              	.LVL48:
 467 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 468              		.cfi_def_cfa_offset 32
 469              		.cfi_offset 3, -32
 470              		.cfi_offset 4, -28
 471              		.cfi_offset 5, -24
 472              		.cfi_offset 6, -20
 473              		.cfi_offset 7, -16
 474              		.cfi_offset 8, -12
 475              		.cfi_offset 9, -8
 476              		.cfi_offset 14, -4
 840:sxmlc/sxmlc.c **** static int _print_formatting(const XMLNode* node, FILE* f, const SXML_CHAR* tag_sep, const SXML_CHA
 477              		.loc 1 840 0
 478 0004 DDF82080 		ldr	r8, [sp, #32]
 479 0008 8146     		mov	r9, r0
 480 000a 0F46     		mov	r7, r1
 481 000c 1D46     		mov	r5, r3
 482 000e 099C     		ldr	r4, [sp, #36]
 842:sxmlc/sxmlc.c **** 	if (tag_sep != NULL) {
 483              		.loc 1 842 0
 484 0010 1646     		mov	r6, r2
 485 0012 4AB1     		cbz	r2, .L41
 843:sxmlc/sxmlc.c **** 		sx_fprintf(f, tag_sep);
 486              		.loc 1 843 0
 487 0014 0846     		mov	r0, r1
 488 0016 1146     		mov	r1, r2
 489              	.LVL49:
 490 0018 FFF7FEFF 		bl	fprintf
 491              	.LVL50:
 844:sxmlc/sxmlc.c **** 		cur_sz_line = _count_new_char_line(tag_sep, nb_char_tab, cur_sz_line);
 492              		.loc 1 844 0
 493 001c 2246     		mov	r2, r4
 494 001e 3046     		mov	r0, r6
 495 0020 4146     		mov	r1, r8
 496 0022 FFF7FEFF 		bl	_count_new_char_line
 497              	.LVL51:
 498 0026 0446     		mov	r4, r0
 499              	.LVL52:
 500              	.L41:
 846:sxmlc/sxmlc.c **** 	if (child_sep != NULL) {
 501              		.loc 1 846 0
 502 0028 75B1     		cbz	r5, .L42
 847:sxmlc/sxmlc.c **** 		for (node = node->father; node != NULL; node = node->father) {
 503              		.loc 1 847 0
 504 002a D9F80060 		ldr	r6, [r9]
 505              	.LVL53:
 506              	.L43:
 507 002e 5EB1     		cbz	r6, .L42
 848:sxmlc/sxmlc.c **** 			sx_fprintf(f, child_sep);
 508              		.loc 1 848 0
 509 0030 2946     		mov	r1, r5
 510 0032 3846     		mov	r0, r7
 511 0034 FFF7FEFF 		bl	fprintf
 512              	.LVL54:
 849:sxmlc/sxmlc.c **** 			cur_sz_line = _count_new_char_line(child_sep, nb_char_tab, cur_sz_line);
 513              		.loc 1 849 0
 514 0038 2246     		mov	r2, r4
 515 003a 2846     		mov	r0, r5
 516 003c 4146     		mov	r1, r8
 517 003e FFF7FEFF 		bl	_count_new_char_line
 518              	.LVL55:
 847:sxmlc/sxmlc.c **** 		for (node = node->father; node != NULL; node = node->father) {
 519              		.loc 1 847 0
 520 0042 3669     		ldr	r6, [r6, #16]
 521              	.LVL56:
 849:sxmlc/sxmlc.c **** 			cur_sz_line = _count_new_char_line(child_sep, nb_char_tab, cur_sz_line);
 522              		.loc 1 849 0
 523 0044 0446     		mov	r4, r0
 524              	.LVL57:
 525 0046 F2E7     		b	.L43
 526              	.LVL58:
 527              	.L42:
 854:sxmlc/sxmlc.c **** }
 528              		.loc 1 854 0
 529 0048 2046     		mov	r0, r4
 530 004a BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 531              		.cfi_endproc
 532              	.LFE70:
 534              		.section	.text.XML_register_user_tag,"ax",%progbits
 535              		.align	1
 536              		.global	XML_register_user_tag
 537              		.thumb
 538              		.thumb_func
 540              	XML_register_user_tag:
 541              	.LFB0:
  82:sxmlc/sxmlc.c **** {
 542              		.loc 1 82 0
 543              		.cfi_startproc
 544              		@ args = 0, pretend = 0, frame = 8
 545              		@ frame_needed = 0, uses_anonymous_args = 0
 546              	.LVL59:
  86:sxmlc/sxmlc.c **** 	if (tag_type < TAG_USER)
 547              		.loc 1 86 0
 548 0000 6328     		cmp	r0, #99
  82:sxmlc/sxmlc.c **** {
 549              		.loc 1 82 0
 550 0002 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 551              		.cfi_def_cfa_offset 48
 552              		.cfi_offset 0, -48
 553              		.cfi_offset 1, -44
 554              		.cfi_offset 2, -40
 555              		.cfi_offset 4, -36
 556              		.cfi_offset 5, -32
 557              		.cfi_offset 6, -28
 558              		.cfi_offset 7, -24
 559              		.cfi_offset 8, -20
 560              		.cfi_offset 9, -16
 561              		.cfi_offset 10, -12
 562              		.cfi_offset 11, -8
 563              		.cfi_offset 14, -4
  82:sxmlc/sxmlc.c **** {
 564              		.loc 1 82 0
 565 0006 8346     		mov	fp, r0
 566 0008 0C46     		mov	r4, r1
 567 000a 1646     		mov	r6, r2
  86:sxmlc/sxmlc.c **** 	if (tag_type < TAG_USER)
 568              		.loc 1 86 0
 569 000c 02DC     		bgt	.L52
 570              	.LVL60:
 571              	.L54:
  87:sxmlc/sxmlc.c **** 		return -1;
 572              		.loc 1 87 0
 573 000e 4FF0FF30 		mov	r0, #-1
 574 0012 32E0     		b	.L53
 575              	.LVL61:
 576              	.L52:
  89:sxmlc/sxmlc.c **** 	if (start == NULL || end == NULL || *start != C2SX('<'))
 577              		.loc 1 89 0
 578 0014 0029     		cmp	r1, #0
 579 0016 FAD0     		beq	.L54
  89:sxmlc/sxmlc.c **** 	if (start == NULL || end == NULL || *start != C2SX('<'))
 580              		.loc 1 89 0 is_stmt 0 discriminator 1
 581 0018 002A     		cmp	r2, #0
 582 001a F8D0     		beq	.L54
 583 001c 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 584 001e 3C2B     		cmp	r3, #60
 585 0020 F5D1     		bne	.L54
  92:sxmlc/sxmlc.c **** 	le = sx_strlen(end);
 586              		.loc 1 92 0 is_stmt 1
 587 0022 1046     		mov	r0, r2
 588              	.LVL62:
 589 0024 FFF7FEFF 		bl	strlen
 590              	.LVL63:
  93:sxmlc/sxmlc.c **** 	if (end[le-1] != C2SX('>'))
 591              		.loc 1 93 0
 592 0028 3318     		adds	r3, r6, r0
 593 002a 13F8013C 		ldrb	r3, [r3, #-1]	@ zero_extendqisi2
  92:sxmlc/sxmlc.c **** 	le = sx_strlen(end);
 594              		.loc 1 92 0
 595 002e 8246     		mov	r10, r0
 596              	.LVL64:
  93:sxmlc/sxmlc.c **** 	if (end[le-1] != C2SX('>'))
 597              		.loc 1 93 0
 598 0030 3E2B     		cmp	r3, #62
 599 0032 ECD1     		bne	.L54
  96:sxmlc/sxmlc.c **** 	i = _user_tags.n_tags;
 600              		.loc 1 96 0
 601 0034 124D     		ldr	r5, .L64
  98:sxmlc/sxmlc.c **** 	p = (_TAG*)__realloc(_user_tags.tags, n * sizeof(_TAG));
 602              		.loc 1 98 0
 603 0036 1423     		movs	r3, #20
  96:sxmlc/sxmlc.c **** 	i = _user_tags.n_tags;
 604              		.loc 1 96 0
 605 0038 D5F80480 		ldr	r8, [r5, #4]
 606              	.LVL65:
  98:sxmlc/sxmlc.c **** 	p = (_TAG*)__realloc(_user_tags.tags, n * sizeof(_TAG));
 607              		.loc 1 98 0
 608 003c 2868     		ldr	r0, [r5]
 609              	.LVL66:
  97:sxmlc/sxmlc.c **** 	n = i + 1;
 610              		.loc 1 97 0
 611 003e 08F10109 		add	r9, r8, #1
 612              	.LVL67:
  98:sxmlc/sxmlc.c **** 	p = (_TAG*)__realloc(_user_tags.tags, n * sizeof(_TAG));
 613              		.loc 1 98 0
 614 0042 03FB09F3 		mul	r3, r3, r9
 615 0046 1946     		mov	r1, r3
 616 0048 0193     		str	r3, [sp, #4]
 617 004a FFF7FEFF 		bl	realloc
 618              	.LVL68:
  99:sxmlc/sxmlc.c **** 	if (p == NULL)
 619              		.loc 1 99 0
 620 004e 019B     		ldr	r3, [sp, #4]
 621 0050 0746     		mov	r7, r0
 622 0052 0028     		cmp	r0, #0
 623 0054 DBD0     		beq	.L54
 102:sxmlc/sxmlc.c **** 	p[i].tag_type = tag_type;
 624              		.loc 1 102 0
 625 0056 A3F11402 		sub	r2, r3, #20
 626 005a 8318     		adds	r3, r0, r2
 627 005c 00F802B0 		strb	fp, [r0, r2]
 103:sxmlc/sxmlc.c **** 	p[i].start = start;
 628              		.loc 1 103 0
 629 0060 5C60     		str	r4, [r3, #4]
 104:sxmlc/sxmlc.c **** 	p[i].end = end;
 630              		.loc 1 104 0
 631 0062 DE60     		str	r6, [r3, #12]
 105:sxmlc/sxmlc.c **** 	p[i].len_start = sx_strlen(start);
 632              		.loc 1 105 0
 633 0064 2046     		mov	r0, r4
 634              	.LVL69:
 635 0066 0193     		str	r3, [sp, #4]
 636 0068 FFF7FEFF 		bl	strlen
 637              	.LVL70:
 638 006c 019B     		ldr	r3, [sp, #4]
 108:sxmlc/sxmlc.c **** 	_user_tags.n_tags = n;
 639              		.loc 1 108 0
 640 006e 85E88002 		stmia	r5, {r7, r9}
 105:sxmlc/sxmlc.c **** 	p[i].len_start = sx_strlen(start);
 641              		.loc 1 105 0
 642 0072 9860     		str	r0, [r3, #8]
 106:sxmlc/sxmlc.c **** 	p[i].len_end = le;
 643              		.loc 1 106 0
 644 0074 C3F810A0 		str	r10, [r3, #16]
 110:sxmlc/sxmlc.c **** 	return i;
 645              		.loc 1 110 0
 646 0078 4046     		mov	r0, r8
 647              	.LVL71:
 648              	.L53:
 111:sxmlc/sxmlc.c **** }
 649              		.loc 1 111 0
 650 007a 03B0     		add	sp, sp, #12
 651              		@ sp needed
 652 007c BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 653              	.LVL72:
 654              	.L65:
 655              		.align	2
 656              	.L64:
 657 0080 00000000 		.word	.LANCHOR0
 658              		.cfi_endproc
 659              	.LFE0:
 661              		.section	.text.XML_unregister_user_tag,"ax",%progbits
 662              		.align	1
 663              		.global	XML_unregister_user_tag
 664              		.thumb
 665              		.thumb_func
 667              	XML_unregister_user_tag:
 668              	.LFB1:
 114:sxmlc/sxmlc.c **** {
 669              		.loc 1 114 0
 670              		.cfi_startproc
 671              		@ args = 0, pretend = 0, frame = 0
 672              		@ frame_needed = 0, uses_anonymous_args = 0
 673              	.LVL73:
 674 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 675              		.cfi_def_cfa_offset 40
 676              		.cfi_offset 3, -40
 677              		.cfi_offset 4, -36
 678              		.cfi_offset 5, -32
 679              		.cfi_offset 6, -28
 680              		.cfi_offset 7, -24
 681              		.cfi_offset 8, -20
 682              		.cfi_offset 9, -16
 683              		.cfi_offset 10, -12
 684              		.cfi_offset 11, -8
 685              		.cfi_offset 14, -4
 117:sxmlc/sxmlc.c **** 	if (i_tag < 0 || i_tag >= _user_tags.n_tags)
 686              		.loc 1 117 0
 687 0004 B0F10009 		subs	r9, r0, #0
 688 0008 03DA     		bge	.L67
 689              	.LVL74:
 690              	.L69:
 118:sxmlc/sxmlc.c ****  		return -1;
 691              		.loc 1 118 0
 692 000a 4FF0FF30 		mov	r0, #-1
 693 000e BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 694              	.LVL75:
 695              	.L67:
 117:sxmlc/sxmlc.c **** 	if (i_tag < 0 || i_tag >= _user_tags.n_tags)
 696              		.loc 1 117 0 discriminator 1
 697 0012 174C     		ldr	r4, .L82
 698 0014 6568     		ldr	r5, [r4, #4]
 699 0016 A945     		cmp	r9, r5
 700 0018 F7DA     		bge	.L69
 120:sxmlc/sxmlc.c **** 	if (_user_tags.n_tags == 1)
 701              		.loc 1 120 0
 702 001a 012D     		cmp	r5, #1
 703 001c 05F1FF3A 		add	r10, r5, #-1
 704 0020 1BD0     		beq	.L73
 123:sxmlc/sxmlc.c **** 		pt = (_TAG*)__malloc((_user_tags.n_tags - 1) * sizeof(_TAG));
 705              		.loc 1 123 0
 706 0022 1427     		movs	r7, #20
 707 0024 07FB0AF0 		mul	r0, r7, r10
 708              	.LVL76:
 709 0028 FFF7FEFF 		bl	malloc
 710              	.LVL77:
 124:sxmlc/sxmlc.c **** 		if (pt == NULL)
 711              		.loc 1 124 0
 712 002c 0646     		mov	r6, r0
 713 002e 0028     		cmp	r0, #0
 714 0030 EBD0     		beq	.L69
 129:sxmlc/sxmlc.c **** 		memcpy(pt, _user_tags.tags, i_tag * sizeof(_TAG));
 715              		.loc 1 129 0
 716 0032 07FB09F8 		mul	r8, r7, r9
 717 0036 D4F800B0 		ldr	fp, [r4]
 718 003a 4246     		mov	r2, r8
 719 003c 5946     		mov	r1, fp
 130:sxmlc/sxmlc.c **** 		memcpy(&pt[i_tag], &_user_tags.tags[i_tag + 1], (_user_tags.n_tags - i_tag - 1) * sizeof(_TAG));
 720              		.loc 1 130 0
 721 003e C9EB0505 		rsb	r5, r9, r5
 129:sxmlc/sxmlc.c **** 		memcpy(pt, _user_tags.tags, i_tag * sizeof(_TAG));
 722              		.loc 1 129 0
 723 0042 FFF7FEFF 		bl	memcpy
 724              	.LVL78:
 130:sxmlc/sxmlc.c **** 		memcpy(&pt[i_tag], &_user_tags.tags[i_tag + 1], (_user_tags.n_tags - i_tag - 1) * sizeof(_TAG));
 725              		.loc 1 130 0
 726 0046 6A1E     		subs	r2, r5, #1
 727 0048 08F11401 		add	r1, r8, #20
 728 004c 06EB0800 		add	r0, r6, r8
 729 0050 5944     		add	r1, r1, fp
 730 0052 7A43     		muls	r2, r7, r2
 731 0054 FFF7FEFF 		bl	memcpy
 732              	.LVL79:
 733 0058 00E0     		b	.L70
 734              	.LVL80:
 735              	.L73:
 121:sxmlc/sxmlc.c **** 		pt = NULL;
 736              		.loc 1 121 0
 737 005a 0026     		movs	r6, #0
 738              	.LVL81:
 739              	.L70:
 132:sxmlc/sxmlc.c **** 	if (_user_tags.tags != NULL)
 740              		.loc 1 132 0
 741 005c 2068     		ldr	r0, [r4]
 742 005e 08B1     		cbz	r0, .L72
 133:sxmlc/sxmlc.c **** 		__free(_user_tags.tags);
 743              		.loc 1 133 0
 744 0060 FFF7FEFF 		bl	free
 745              	.LVL82:
 746              	.L72:
 134:sxmlc/sxmlc.c **** 	_user_tags.tags = pt;
 747              		.loc 1 134 0
 748 0064 2660     		str	r6, [r4]
 135:sxmlc/sxmlc.c **** 	_user_tags.n_tags--;
 749              		.loc 1 135 0
 750 0066 5046     		mov	r0, r10
 751 0068 C4F804A0 		str	r10, [r4, #4]
 137:sxmlc/sxmlc.c **** 	return _user_tags.n_tags;
 752              		.loc 1 137 0
 753 006c BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 754              	.LVL83:
 755              	.L83:
 756              		.align	2
 757              	.L82:
 758 0070 00000000 		.word	.LANCHOR0
 759              		.cfi_endproc
 760              	.LFE1:
 762              		.section	.text.XML_get_nb_registered_user_tags,"ax",%progbits
 763              		.align	1
 764              		.global	XML_get_nb_registered_user_tags
 765              		.thumb
 766              		.thumb_func
 768              	XML_get_nb_registered_user_tags:
 769              	.LFB2:
 141:sxmlc/sxmlc.c **** {
 770              		.loc 1 141 0
 771              		.cfi_startproc
 772              		@ args = 0, pretend = 0, frame = 0
 773              		@ frame_needed = 0, uses_anonymous_args = 0
 774              		@ link register save eliminated.
 143:sxmlc/sxmlc.c **** }
 775              		.loc 1 143 0
 776 0000 014B     		ldr	r3, .L85
 777 0002 5868     		ldr	r0, [r3, #4]
 778 0004 7047     		bx	lr
 779              	.L86:
 780 0006 00BF     		.align	2
 781              	.L85:
 782 0008 00000000 		.word	.LANCHOR0
 783              		.cfi_endproc
 784              	.LFE2:
 786              		.section	.text.XML_get_registered_user_tag,"ax",%progbits
 787              		.align	1
 788              		.global	XML_get_registered_user_tag
 789              		.thumb
 790              		.thumb_func
 792              	XML_get_registered_user_tag:
 793              	.LFB3:
 146:sxmlc/sxmlc.c **** {
 794              		.loc 1 146 0
 795              		.cfi_startproc
 796              		@ args = 0, pretend = 0, frame = 0
 797              		@ frame_needed = 0, uses_anonymous_args = 0
 798              	.LVL84:
 799 0000 10B5     		push	{r4, lr}
 800              		.cfi_def_cfa_offset 8
 801              		.cfi_offset 4, -8
 802              		.cfi_offset 14, -4
 149:sxmlc/sxmlc.c **** 	for (i = 0; i < _user_tags.n_tags; i++)
 803              		.loc 1 149 0
 804 0002 094B     		ldr	r3, .L93
 150:sxmlc/sxmlc.c **** 		if (_user_tags.tags[i].tag_type == tag_type)
 805              		.loc 1 150 0
 806 0004 93E80600 		ldmia	r3, {r1, r2}
 149:sxmlc/sxmlc.c **** 	for (i = 0; i < _user_tags.n_tags; i++)
 807              		.loc 1 149 0
 808 0008 0023     		movs	r3, #0
 809              	.LVL85:
 810              	.L88:
 149:sxmlc/sxmlc.c **** 	for (i = 0; i < _user_tags.n_tags; i++)
 811              		.loc 1 149 0 is_stmt 0 discriminator 1
 812 000a 9342     		cmp	r3, r2
 813 000c 06DA     		bge	.L92
 814 000e 1424     		movs	r4, #20
 815 0010 5C43     		muls	r4, r3, r4
 150:sxmlc/sxmlc.c **** 		if (_user_tags.tags[i].tag_type == tag_type)
 816              		.loc 1 150 0 is_stmt 1
 817 0012 0C57     		ldrsb	r4, [r1, r4]
 818 0014 8442     		cmp	r4, r0
 819 0016 04D0     		beq	.L91
 149:sxmlc/sxmlc.c **** 	for (i = 0; i < _user_tags.n_tags; i++)
 820              		.loc 1 149 0
 821 0018 0133     		adds	r3, r3, #1
 822              	.LVL86:
 823 001a F6E7     		b	.L88
 824              	.L92:
 153:sxmlc/sxmlc.c **** 	return -1;
 825              		.loc 1 153 0
 826 001c 4FF0FF30 		mov	r0, #-1
 827              	.LVL87:
 828 0020 10BD     		pop	{r4, pc}
 829              	.LVL88:
 830              	.L91:
 831 0022 1846     		mov	r0, r3
 832              	.LVL89:
 154:sxmlc/sxmlc.c **** }
 833              		.loc 1 154 0
 834 0024 10BD     		pop	{r4, pc}
 835              	.L94:
 836 0026 00BF     		.align	2
 837              	.L93:
 838 0028 00000000 		.word	.LANCHOR0
 839              		.cfi_endproc
 840              	.LFE3:
 842              		.section	.text.XMLNode_init,"ax",%progbits
 843              		.align	1
 844              		.global	XMLNode_init
 845              		.thumb
 846              		.thumb_func
 848              	XMLNode_init:
 849              	.LFB5:
 177:sxmlc/sxmlc.c **** {
 850              		.loc 1 177 0
 851              		.cfi_startproc
 852              		@ args = 0, pretend = 0, frame = 0
 853              		@ frame_needed = 0, uses_anonymous_args = 0
 854              		@ link register save eliminated.
 855              	.LVL90:
 178:sxmlc/sxmlc.c **** 	if (node == NULL)
 856              		.loc 1 178 0
 857 0000 80B1     		cbz	r0, .L96
 181:sxmlc/sxmlc.c **** 	if (node->init_value == XML_INIT_DONE)
 858              		.loc 1 181 0
 859 0002 094A     		ldr	r2, .L99
 860 0004 836A     		ldr	r3, [r0, #40]
 861 0006 9342     		cmp	r3, r2
 862 0008 0BD0     		beq	.L98
 184:sxmlc/sxmlc.c **** 	node->tag = NULL;
 863              		.loc 1 184 0
 864 000a 0023     		movs	r3, #0
 865 000c 0360     		str	r3, [r0]
 185:sxmlc/sxmlc.c **** 	node->text = NULL;
 866              		.loc 1 185 0
 867 000e 4360     		str	r3, [r0, #4]
 187:sxmlc/sxmlc.c **** 	node->attributes = NULL;
 868              		.loc 1 187 0
 869 0010 8360     		str	r3, [r0, #8]
 188:sxmlc/sxmlc.c **** 	node->n_attributes = 0;
 870              		.loc 1 188 0
 871 0012 C360     		str	r3, [r0, #12]
 190:sxmlc/sxmlc.c **** 	node->father = NULL;
 872              		.loc 1 190 0
 873 0014 0361     		str	r3, [r0, #16]
 191:sxmlc/sxmlc.c **** 	node->children = NULL;
 874              		.loc 1 191 0
 875 0016 4361     		str	r3, [r0, #20]
 192:sxmlc/sxmlc.c **** 	node->n_children = 0;
 876              		.loc 1 192 0
 877 0018 8361     		str	r3, [r0, #24]
 194:sxmlc/sxmlc.c **** 	node->tag_type = TAG_NONE;
 878              		.loc 1 194 0
 879 001a 0377     		strb	r3, [r0, #28]
 195:sxmlc/sxmlc.c **** 	node->active = true;
 880              		.loc 1 195 0
 881 001c 0123     		movs	r3, #1
 882 001e 0362     		str	r3, [r0, #32]
 197:sxmlc/sxmlc.c **** 	node->init_value = XML_INIT_DONE;
 883              		.loc 1 197 0
 884 0020 8262     		str	r2, [r0, #40]
 885              	.L98:
 182:sxmlc/sxmlc.c **** 		return true; /*(void)XMLNode_free(node);*/
 886              		.loc 1 182 0
 887 0022 0120     		movs	r0, #1
 888              	.LVL91:
 889              	.L96:
 200:sxmlc/sxmlc.c **** }
 890              		.loc 1 200 0
 891 0024 7047     		bx	lr
 892              	.L100:
 893 0026 00BF     		.align	2
 894              	.L99:
 895 0028 22057719 		.word	427230498
 896              		.cfi_endproc
 897              	.LFE5:
 899              		.section	.text.XMLNode_allocN,"ax",%progbits
 900              		.align	1
 901              		.global	XMLNode_allocN
 902              		.thumb
 903              		.thumb_func
 905              	XMLNode_allocN:
 906              	.LFB6:
 203:sxmlc/sxmlc.c **** {
 907              		.loc 1 203 0
 908              		.cfi_startproc
 909              		@ args = 0, pretend = 0, frame = 0
 910              		@ frame_needed = 0, uses_anonymous_args = 0
 911              	.LVL92:
 912 0000 70B5     		push	{r4, r5, r6, lr}
 913              		.cfi_def_cfa_offset 16
 914              		.cfi_offset 4, -16
 915              		.cfi_offset 5, -12
 916              		.cfi_offset 6, -8
 917              		.cfi_offset 14, -4
 207:sxmlc/sxmlc.c **** 	if (n <= 0)
 918              		.loc 1 207 0
 919 0002 061E     		subs	r6, r0, #0
 920 0004 01DC     		bgt	.L102
 921              	.LVL93:
 922              	.L104:
 208:sxmlc/sxmlc.c **** 		return NULL;
 923              		.loc 1 208 0
 924 0006 0020     		movs	r0, #0
 925 0008 70BD     		pop	{r4, r5, r6, pc}
 926              	.LVL94:
 927              	.L102:
 210:sxmlc/sxmlc.c **** 	p = (XMLNode*)__calloc(n, sizeof(XMLNode));
 928              		.loc 1 210 0
 929 000a 2C21     		movs	r1, #44
 930 000c FFF7FEFF 		bl	calloc
 931              	.LVL95:
 211:sxmlc/sxmlc.c **** 	if (p == NULL)
 932              		.loc 1 211 0
 933 0010 0546     		mov	r5, r0
 934 0012 0028     		cmp	r0, #0
 935 0014 F7D0     		beq	.L104
 936 0016 0024     		movs	r4, #0
 937              	.LVL96:
 938              	.L105:
 215:sxmlc/sxmlc.c **** 		(void)XMLNode_init(&p[i]);
 939              		.loc 1 215 0 discriminator 2
 940 0018 2C20     		movs	r0, #44
 941 001a 00FB0450 		mla	r0, r0, r4, r5
 214:sxmlc/sxmlc.c **** 	for (i = 0; i < n; i++)
 942              		.loc 1 214 0 discriminator 2
 943 001e 0134     		adds	r4, r4, #1
 944              	.LVL97:
 215:sxmlc/sxmlc.c **** 		(void)XMLNode_init(&p[i]);
 945              		.loc 1 215 0 discriminator 2
 946 0020 FFF7FEFF 		bl	XMLNode_init
 947              	.LVL98:
 214:sxmlc/sxmlc.c **** 	for (i = 0; i < n; i++)
 948              		.loc 1 214 0 discriminator 2
 949 0024 B442     		cmp	r4, r6
 950 0026 F7D1     		bne	.L105
 951 0028 2846     		mov	r0, r5
 218:sxmlc/sxmlc.c **** }
 952              		.loc 1 218 0
 953 002a 70BD     		pop	{r4, r5, r6, pc}
 954              		.cfi_endproc
 955              	.LFE6:
 957              		.section	.text.XMLNode_set_active,"ax",%progbits
 958              		.align	1
 959              		.global	XMLNode_set_active
 960              		.thumb
 961              		.thumb_func
 963              	XMLNode_set_active:
 964              	.LFB10:
 322:sxmlc/sxmlc.c **** {
 965              		.loc 1 322 0
 966              		.cfi_startproc
 967              		@ args = 0, pretend = 0, frame = 0
 968              		@ frame_needed = 0, uses_anonymous_args = 0
 969              		@ link register save eliminated.
 970              	.LVL99:
 323:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 971              		.loc 1 323 0
 972 0000 38B1     		cbz	r0, .L111
 323:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 973              		.loc 1 323 0 is_stmt 0 discriminator 1
 974 0002 836A     		ldr	r3, [r0, #40]
 975 0004 034A     		ldr	r2, .L114
 976 0006 9342     		cmp	r3, r2
 977 0008 02D1     		bne	.L113
 326:sxmlc/sxmlc.c **** 	node->active = active;
 978              		.loc 1 326 0 is_stmt 1
 979 000a 0162     		str	r1, [r0, #32]
 328:sxmlc/sxmlc.c **** 	return true;
 980              		.loc 1 328 0
 981 000c 0120     		movs	r0, #1
 982              	.LVL100:
 983 000e 7047     		bx	lr
 984              	.LVL101:
 985              	.L113:
 324:sxmlc/sxmlc.c **** 		return false;
 986              		.loc 1 324 0
 987 0010 0020     		movs	r0, #0
 988              	.LVL102:
 989              	.L111:
 329:sxmlc/sxmlc.c **** }
 990              		.loc 1 329 0
 991 0012 7047     		bx	lr
 992              	.L115:
 993              		.align	2
 994              	.L114:
 995 0014 22057719 		.word	427230498
 996              		.cfi_endproc
 997              	.LFE10:
 999              		.section	.text.XMLNode_set_tag,"ax",%progbits
 1000              		.align	1
 1001              		.global	XMLNode_set_tag
 1002              		.thumb
 1003              		.thumb_func
 1005              	XMLNode_set_tag:
 1006              	.LFB11:
 332:sxmlc/sxmlc.c **** {
 1007              		.loc 1 332 0
 1008              		.cfi_startproc
 1009              		@ args = 0, pretend = 0, frame = 0
 1010              		@ frame_needed = 0, uses_anonymous_args = 0
 1011              	.LVL103:
 1012 0000 38B5     		push	{r3, r4, r5, lr}
 1013              		.cfi_def_cfa_offset 16
 1014              		.cfi_offset 3, -16
 1015              		.cfi_offset 4, -12
 1016              		.cfi_offset 5, -8
 1017              		.cfi_offset 14, -4
 334:sxmlc/sxmlc.c **** 	if (node == NULL || tag == NULL || node->init_value != XML_INIT_DONE)
 1018              		.loc 1 334 0
 1019 0002 0446     		mov	r4, r0
 1020 0004 08B9     		cbnz	r0, .L117
 1021              	.LVL104:
 1022              	.L119:
 335:sxmlc/sxmlc.c **** 		return false;
 1023              		.loc 1 335 0
 1024 0006 0020     		movs	r0, #0
 1025 0008 38BD     		pop	{r3, r4, r5, pc}
 1026              	.LVL105:
 1027              	.L117:
 334:sxmlc/sxmlc.c **** 	if (node == NULL || tag == NULL || node->init_value != XML_INIT_DONE)
 1028              		.loc 1 334 0 discriminator 1
 1029 000a 0029     		cmp	r1, #0
 1030 000c FBD0     		beq	.L119
 1031 000e 836A     		ldr	r3, [r0, #40]
 1032 0010 074A     		ldr	r2, .L130
 1033 0012 9342     		cmp	r3, r2
 1034 0014 F7D1     		bne	.L119
 337:sxmlc/sxmlc.c **** 	newtag = sx_strdup(tag);
 1035              		.loc 1 337 0
 1036 0016 0846     		mov	r0, r1
 1037              	.LVL106:
 1038 0018 FFF7FEFF 		bl	strdup
 1039              	.LVL107:
 338:sxmlc/sxmlc.c **** 	if (newtag == NULL)
 1040              		.loc 1 338 0
 1041 001c 0546     		mov	r5, r0
 1042 001e 0028     		cmp	r0, #0
 1043 0020 F1D0     		beq	.L119
 340:sxmlc/sxmlc.c **** 	if (node->tag != NULL) __free(node->tag);
 1044              		.loc 1 340 0
 1045 0022 2068     		ldr	r0, [r4]
 1046              	.LVL108:
 1047 0024 08B1     		cbz	r0, .L120
 340:sxmlc/sxmlc.c **** 	if (node->tag != NULL) __free(node->tag);
 1048              		.loc 1 340 0 is_stmt 0 discriminator 1
 1049 0026 FFF7FEFF 		bl	free
 1050              	.LVL109:
 1051              	.L120:
 341:sxmlc/sxmlc.c **** 	node->tag = newtag;
 1052              		.loc 1 341 0 is_stmt 1
 1053 002a 2560     		str	r5, [r4]
 343:sxmlc/sxmlc.c **** 	return true;
 1054              		.loc 1 343 0
 1055 002c 0120     		movs	r0, #1
 344:sxmlc/sxmlc.c **** }
 1056              		.loc 1 344 0
 1057 002e 38BD     		pop	{r3, r4, r5, pc}
 1058              	.LVL110:
 1059              	.L131:
 1060              		.align	2
 1061              	.L130:
 1062 0030 22057719 		.word	427230498
 1063              		.cfi_endproc
 1064              	.LFE11:
 1066              		.section	.text.XMLNode_set_type,"ax",%progbits
 1067              		.align	1
 1068              		.global	XMLNode_set_type
 1069              		.thumb
 1070              		.thumb_func
 1072              	XMLNode_set_type:
 1073              	.LFB12:
 347:sxmlc/sxmlc.c **** {
 1074              		.loc 1 347 0
 1075              		.cfi_startproc
 1076              		@ args = 0, pretend = 0, frame = 0
 1077              		@ frame_needed = 0, uses_anonymous_args = 0
 1078              		@ link register save eliminated.
 1079              	.LVL111:
 348:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 1080              		.loc 1 348 0
 1081 0000 88B1     		cbz	r0, .L133
 348:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 1082              		.loc 1 348 0 is_stmt 0 discriminator 1
 1083 0002 836A     		ldr	r3, [r0, #40]
 1084 0004 084A     		ldr	r2, .L138
 1085 0006 9342     		cmp	r3, r2
 1086 0008 0CD1     		bne	.L137
 1087 000a 4B1C     		adds	r3, r1, #1
 1088 000c DBB2     		uxtb	r3, r3
 1089 000e 092B     		cmp	r3, #9
 1090 0010 05D8     		bhi	.L134
 1091 0012 0122     		movs	r2, #1
 1092 0014 9A40     		lsls	r2, r2, r3
 1093 0016 40F20723 		movw	r3, #519
 1094 001a 1340     		ands	r3, r3, r2
 1095 001c 13B9     		cbnz	r3, .L137
 1096              	.L134:
 359:sxmlc/sxmlc.c **** 			node->tag_type = tag_type;
 1097              		.loc 1 359 0 is_stmt 1
 1098 001e 0177     		strb	r1, [r0, #28]
 360:sxmlc/sxmlc.c **** 			return true;
 1099              		.loc 1 360 0
 1100 0020 0120     		movs	r0, #1
 1101              	.LVL112:
 1102 0022 7047     		bx	lr
 1103              	.LVL113:
 1104              	.L137:
 349:sxmlc/sxmlc.c **** 		return false;
 1105              		.loc 1 349 0
 1106 0024 0020     		movs	r0, #0
 1107              	.LVL114:
 1108              	.L133:
 362:sxmlc/sxmlc.c **** }
 1109              		.loc 1 362 0
 1110 0026 7047     		bx	lr
 1111              	.L139:
 1112              		.align	2
 1113              	.L138:
 1114 0028 22057719 		.word	427230498
 1115              		.cfi_endproc
 1116              	.LFE12:
 1118              		.section	.text.XMLNode_get_attribute_count,"ax",%progbits
 1119              		.align	1
 1120              		.global	XMLNode_get_attribute_count
 1121              		.thumb
 1122              		.thumb_func
 1124              	XMLNode_get_attribute_count:
 1125              	.LFB15:
 438:sxmlc/sxmlc.c **** {
 1126              		.loc 1 438 0
 1127              		.cfi_startproc
 1128              		@ args = 0, pretend = 0, frame = 0
 1129              		@ frame_needed = 0, uses_anonymous_args = 0
 1130              	.LVL115:
 1131 0000 30B5     		push	{r4, r5, lr}
 1132              		.cfi_def_cfa_offset 12
 1133              		.cfi_offset 4, -12
 1134              		.cfi_offset 5, -8
 1135              		.cfi_offset 14, -4
 441:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 1136              		.loc 1 441 0
 1137 0002 98B1     		cbz	r0, .L146
 441:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 1138              		.loc 1 441 0 is_stmt 0 discriminator 1
 1139 0004 836A     		ldr	r3, [r0, #40]
 1140 0006 0B4A     		ldr	r2, .L151
 1141 0008 9342     		cmp	r3, r2
 1142 000a 0FD1     		bne	.L146
 444:sxmlc/sxmlc.c **** 	for (i = n = 0; i < node->n_attributes; i++)
 1143              		.loc 1 444 0 is_stmt 1
 1144 000c 0023     		movs	r3, #0
 1145 000e C468     		ldr	r4, [r0, #12]
 1146 0010 1A46     		mov	r2, r3
 1147              	.L142:
 1148              	.LVL116:
 444:sxmlc/sxmlc.c **** 	for (i = n = 0; i < node->n_attributes; i++)
 1149              		.loc 1 444 0 is_stmt 0 discriminator 1
 1150 0012 A242     		cmp	r2, r4
 1151 0014 08DA     		bge	.L150
 445:sxmlc/sxmlc.c **** 		if (node->attributes[i].active) n++;
 1152              		.loc 1 445 0 is_stmt 1
 1153 0016 8168     		ldr	r1, [r0, #8]
 1154 0018 0C25     		movs	r5, #12
 1155 001a 05FB0211 		mla	r1, r5, r2, r1
 1156 001e 8968     		ldr	r1, [r1, #8]
 1157 0020 01B1     		cbz	r1, .L143
 445:sxmlc/sxmlc.c **** 		if (node->attributes[i].active) n++;
 1158              		.loc 1 445 0 is_stmt 0 discriminator 1
 1159 0022 0133     		adds	r3, r3, #1
 1160              	.LVL117:
 1161              	.L143:
 444:sxmlc/sxmlc.c **** 	for (i = n = 0; i < node->n_attributes; i++)
 1162              		.loc 1 444 0 is_stmt 1
 1163 0024 0132     		adds	r2, r2, #1
 1164              	.LVL118:
 1165 0026 F4E7     		b	.L142
 1166              	.L150:
 1167 0028 1846     		mov	r0, r3
 1168              	.LVL119:
 1169 002a 30BD     		pop	{r4, r5, pc}
 1170              	.LVL120:
 1171              	.L146:
 442:sxmlc/sxmlc.c **** 		return -1;
 1172              		.loc 1 442 0
 1173 002c 4FF0FF30 		mov	r0, #-1
 1174              	.LVL121:
 448:sxmlc/sxmlc.c **** }
 1175              		.loc 1 448 0
 1176 0030 30BD     		pop	{r4, r5, pc}
 1177              	.L152:
 1178 0032 00BF     		.align	2
 1179              	.L151:
 1180 0034 22057719 		.word	427230498
 1181              		.cfi_endproc
 1182              	.LFE15:
 1184              		.section	.text.XMLNode_search_attribute,"ax",%progbits
 1185              		.align	1
 1186              		.global	XMLNode_search_attribute
 1187              		.thumb
 1188              		.thumb_func
 1190              	XMLNode_search_attribute:
 1191              	.LFB16:
 451:sxmlc/sxmlc.c **** {
 1192              		.loc 1 451 0
 1193              		.cfi_startproc
 1194              		@ args = 0, pretend = 0, frame = 0
 1195              		@ frame_needed = 0, uses_anonymous_args = 0
 1196              	.LVL122:
 1197 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1198              		.cfi_def_cfa_offset 24
 1199              		.cfi_offset 3, -24
 1200              		.cfi_offset 4, -20
 1201              		.cfi_offset 5, -16
 1202              		.cfi_offset 6, -12
 1203              		.cfi_offset 7, -8
 1204              		.cfi_offset 14, -4
 451:sxmlc/sxmlc.c **** {
 1205              		.loc 1 451 0
 1206 0002 0E46     		mov	r6, r1
 1207 0004 1446     		mov	r4, r2
 454:sxmlc/sxmlc.c **** 	if (node == NULL || attr_name == NULL || attr_name[0] == NULC || i_search < 0 || i_search >= node-
 1208              		.loc 1 454 0
 1209 0006 E0B1     		cbz	r0, .L163
 454:sxmlc/sxmlc.c **** 	if (node == NULL || attr_name == NULL || attr_name[0] == NULC || i_search < 0 || i_search >= node-
 1210              		.loc 1 454 0 is_stmt 0 discriminator 1
 1211 0008 D9B1     		cbz	r1, .L163
 1212 000a 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 1213 000c CBB1     		cbz	r3, .L163
 1214 000e 002A     		cmp	r2, #0
 1215 0010 17DB     		blt	.L163
 1216 0012 C768     		ldr	r7, [r0, #12]
 1217 0014 BA42     		cmp	r2, r7
 1218 0016 14DA     		bge	.L163
 458:sxmlc/sxmlc.c **** 		if (node->attributes[i].active && !sx_strcmp(node->attributes[i].name, attr_name))
 1219              		.loc 1 458 0 is_stmt 1
 1220 0018 8368     		ldr	r3, [r0, #8]
 1221 001a 0C25     		movs	r5, #12
 1222 001c 05FB0235 		mla	r5, r5, r2, r3
 1223 0020 0835     		adds	r5, r5, #8
 1224              	.LVL123:
 1225              	.L156:
 1226 0022 2B68     		ldr	r3, [r5]
 1227 0024 2BB1     		cbz	r3, .L155
 458:sxmlc/sxmlc.c **** 		if (node->attributes[i].active && !sx_strcmp(node->attributes[i].name, attr_name))
 1228              		.loc 1 458 0 is_stmt 0 discriminator 1
 1229 0026 55F8080C 		ldr	r0, [r5, #-8]
 1230 002a 3146     		mov	r1, r6
 1231 002c FFF7FEFF 		bl	strcmp
 1232              	.LVL124:
 1233 0030 28B1     		cbz	r0, .L162
 1234              	.L155:
 457:sxmlc/sxmlc.c **** 	for (i = i_search; i < node->n_attributes; i++)
 1235              		.loc 1 457 0 is_stmt 1
 1236 0032 0134     		adds	r4, r4, #1
 1237              	.LVL125:
 1238 0034 BC42     		cmp	r4, r7
 1239 0036 05F10C05 		add	r5, r5, #12
 1240 003a F2D1     		bne	.L156
 1241 003c 01E0     		b	.L163
 1242              	.L162:
 1243 003e 2046     		mov	r0, r4
 1244 0040 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1245              	.LVL126:
 1246              	.L163:
 455:sxmlc/sxmlc.c **** 		return -1;
 1247              		.loc 1 455 0
 1248 0042 4FF0FF30 		mov	r0, #-1
 462:sxmlc/sxmlc.c **** }
 1249              		.loc 1 462 0
 1250 0046 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1251              		.cfi_endproc
 1252              	.LFE16:
 1254              		.section	.text.XMLNode_set_attribute,"ax",%progbits
 1255              		.align	1
 1256              		.global	XMLNode_set_attribute
 1257              		.thumb
 1258              		.thumb_func
 1260              	XMLNode_set_attribute:
 1261              	.LFB13:
 365:sxmlc/sxmlc.c **** {
 1262              		.loc 1 365 0
 1263              		.cfi_startproc
 1264              		@ args = 0, pretend = 0, frame = 0
 1265              		@ frame_needed = 0, uses_anonymous_args = 0
 1266              	.LVL127:
 1267 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1268              		.cfi_def_cfa_offset 24
 1269              		.cfi_offset 4, -24
 1270              		.cfi_offset 5, -20
 1271              		.cfi_offset 6, -16
 1272              		.cfi_offset 7, -12
 1273              		.cfi_offset 8, -8
 1274              		.cfi_offset 14, -4
 365:sxmlc/sxmlc.c **** {
 1275              		.loc 1 365 0
 1276 0004 0E46     		mov	r6, r1
 1277 0006 1546     		mov	r5, r2
 369:sxmlc/sxmlc.c **** 	if (node == NULL || attr_name == NULL || attr_name[0] == NULC || node->init_value != XML_INIT_DONE
 1278              		.loc 1 369 0
 1279 0008 0446     		mov	r4, r0
 1280 000a 0028     		cmp	r0, #0
 1281 000c 4ED0     		beq	.L179
 369:sxmlc/sxmlc.c **** 	if (node == NULL || attr_name == NULL || attr_name[0] == NULC || node->init_value != XML_INIT_DONE
 1282              		.loc 1 369 0 is_stmt 0 discriminator 1
 1283 000e 0029     		cmp	r1, #0
 1284 0010 4CD0     		beq	.L179
 1285 0012 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 1286 0014 002B     		cmp	r3, #0
 1287 0016 49D0     		beq	.L179
 1288 0018 836A     		ldr	r3, [r0, #40]
 1289 001a 264A     		ldr	r2, .L206
 1290              	.LVL128:
 1291 001c 9342     		cmp	r3, r2
 1292 001e 45D1     		bne	.L179
 372:sxmlc/sxmlc.c **** 	i = XMLNode_search_attribute(node, attr_name, 0);
 1293              		.loc 1 372 0 is_stmt 1
 1294 0020 0022     		movs	r2, #0
 1295 0022 FFF7FEFF 		bl	XMLNode_search_attribute
 1296              	.LVL129:
 373:sxmlc/sxmlc.c **** 	if (i >= 0) { /* Attribute found: update it */
 1297              		.loc 1 373 0
 1298 0026 071E     		subs	r7, r0, #0
 1299 0028 10DB     		blt	.L171
 1300              	.LVL130:
 1301              	.LBB2:
 375:sxmlc/sxmlc.c **** 		if (attr_value != NULL && (value = sx_strdup(attr_value)) == NULL)
 1302              		.loc 1 375 0
 1303 002a 2DB1     		cbz	r5, .L172
 375:sxmlc/sxmlc.c **** 		if (attr_value != NULL && (value = sx_strdup(attr_value)) == NULL)
 1304              		.loc 1 375 0 is_stmt 0 discriminator 1
 1305 002c 2846     		mov	r0, r5
 1306              	.LVL131:
 1307 002e FFF7FEFF 		bl	strdup
 1308              	.LVL132:
 1309 0032 0546     		mov	r5, r0
 1310              	.LVL133:
 1311 0034 0028     		cmp	r0, #0
 1312 0036 39D0     		beq	.L179
 1313              	.LVL134:
 1314              	.L172:
 378:sxmlc/sxmlc.c **** 		if (pt[i].value != NULL)
 1315              		.loc 1 378 0 is_stmt 1
 1316 0038 A368     		ldr	r3, [r4, #8]
 1317 003a 0C26     		movs	r6, #12
 1318              	.LVL135:
 1319 003c 06FB0736 		mla	r6, r6, r7, r3
 1320 0040 7068     		ldr	r0, [r6, #4]
 1321 0042 08B1     		cbz	r0, .L173
 379:sxmlc/sxmlc.c **** 			__free(pt[i].value);
 1322              		.loc 1 379 0
 1323 0044 FFF7FEFF 		bl	free
 1324              	.LVL136:
 1325              	.L173:
 380:sxmlc/sxmlc.c **** 		pt[i].value = value;
 1326              		.loc 1 380 0
 1327 0048 7560     		str	r5, [r6, #4]
 1328              	.LBE2:
 1329 004a 29E0     		b	.L174
 1330              	.LVL137:
 1331              	.L171:
 1332              	.LBB3:
 382:sxmlc/sxmlc.c **** 		SXML_CHAR* name = sx_strdup(attr_name);
 1333              		.loc 1 382 0
 1334 004c 3046     		mov	r0, r6
 1335              	.LVL138:
 1336 004e FFF7FEFF 		bl	strdup
 1337              	.LVL139:
 1338 0052 0646     		mov	r6, r0
 1339              	.LVL140:
 383:sxmlc/sxmlc.c **** 		SXML_CHAR* value = (attr_value == NULL ? NULL : sx_strdup(attr_value));
 1340              		.loc 1 383 0
 1341 0054 45B1     		cbz	r5, .L175
 383:sxmlc/sxmlc.c **** 		SXML_CHAR* value = (attr_value == NULL ? NULL : sx_strdup(attr_value));
 1342              		.loc 1 383 0 is_stmt 0 discriminator 1
 1343 0056 2846     		mov	r0, r5
 1344              	.LVL141:
 1345 0058 FFF7FEFF 		bl	strdup
 1346              	.LVL142:
 1347 005c 0546     		mov	r5, r0
 1348              	.LVL143:
 384:sxmlc/sxmlc.c **** 		if (name == NULL || (value == NULL && attr_value != NULL)) {
 1349              		.loc 1 384 0 is_stmt 1 discriminator 1
 1350 005e 0EB1     		cbz	r6, .L176
 1351 0060 18B9     		cbnz	r0, .L178
 1352 0062 20E0     		b	.L177
 1353              	.L176:
 385:sxmlc/sxmlc.c **** 			if (value != NULL)
 1354              		.loc 1 385 0
 1355 0064 00BB     		cbnz	r0, .L205
 1356 0066 21E0     		b	.L179
 1357              	.LVL144:
 1358              	.L175:
 384:sxmlc/sxmlc.c **** 		if (name == NULL || (value == NULL && attr_value != NULL)) {
 1359              		.loc 1 384 0
 1360 0068 00B3     		cbz	r0, .L179
 1361              	.LVL145:
 1362              	.L178:
 392:sxmlc/sxmlc.c **** 		pt = (XMLAttribute*)__realloc(node->attributes, (i+1) * sizeof(XMLAttribute));
 1363              		.loc 1 392 0
 1364 006a E768     		ldr	r7, [r4, #12]
 1365 006c 4FF00C08 		mov	r8, #12
 1366 0070 0137     		adds	r7, r7, #1
 1367 0072 08FB07F8 		mul	r8, r8, r7
 1368 0076 A068     		ldr	r0, [r4, #8]
 1369 0078 4146     		mov	r1, r8
 1370 007a FFF7FEFF 		bl	realloc
 1371              	.LVL146:
 393:sxmlc/sxmlc.c **** 		if (pt == NULL) {
 1372              		.loc 1 393 0
 1373 007e 20B9     		cbnz	r0, .L180
 394:sxmlc/sxmlc.c **** 			if (value != NULL)
 1374              		.loc 1 394 0
 1375 0080 8DB1     		cbz	r5, .L177
 395:sxmlc/sxmlc.c **** 				__free(value);
 1376              		.loc 1 395 0
 1377 0082 2846     		mov	r0, r5
 1378              	.LVL147:
 1379 0084 FFF7FEFF 		bl	free
 1380              	.LVL148:
 1381 0088 0DE0     		b	.L177
 1382              	.LVL149:
 1383              	.L180:
 400:sxmlc/sxmlc.c **** 		pt[i].name = name;
 1384              		.loc 1 400 0
 1385 008a A8F10C08 		sub	r8, r8, #12
 1386 008e 00EB0803 		add	r3, r0, r8
 402:sxmlc/sxmlc.c **** 		pt[i].active = true;
 1387              		.loc 1 402 0
 1388 0092 0122     		movs	r2, #1
 400:sxmlc/sxmlc.c **** 		pt[i].name = name;
 1389              		.loc 1 400 0
 1390 0094 40F80860 		str	r6, [r0, r8]
 401:sxmlc/sxmlc.c **** 		pt[i].value = value;
 1391              		.loc 1 401 0
 1392 0098 5D60     		str	r5, [r3, #4]
 402:sxmlc/sxmlc.c **** 		pt[i].active = true;
 1393              		.loc 1 402 0
 1394 009a 9A60     		str	r2, [r3, #8]
 403:sxmlc/sxmlc.c **** 		node->attributes = pt;
 1395              		.loc 1 403 0
 1396 009c A060     		str	r0, [r4, #8]
 404:sxmlc/sxmlc.c **** 		node->n_attributes = i + 1;
 1397              		.loc 1 404 0
 1398 009e E760     		str	r7, [r4, #12]
 1399              	.LVL150:
 1400              	.L174:
 1401              	.LBE3:
 407:sxmlc/sxmlc.c **** 	return node->n_attributes;
 1402              		.loc 1 407 0
 1403 00a0 E068     		ldr	r0, [r4, #12]
 1404 00a2 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1405              	.LVL151:
 1406              	.L177:
 1407              	.LBB4:
 388:sxmlc/sxmlc.c **** 				__free(name);
 1408              		.loc 1 388 0
 1409 00a6 3046     		mov	r0, r6
 1410              	.L205:
 1411 00a8 FFF7FEFF 		bl	free
 1412              	.LVL152:
 1413              	.L179:
 389:sxmlc/sxmlc.c ****  			return -1;
 1414              		.loc 1 389 0
 1415 00ac 4FF0FF30 		mov	r0, #-1
 1416              	.LBE4:
 408:sxmlc/sxmlc.c **** }
 1417              		.loc 1 408 0
 1418 00b0 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1419              	.LVL153:
 1420              	.L207:
 1421              		.align	2
 1422              	.L206:
 1423 00b4 22057719 		.word	427230498
 1424              		.cfi_endproc
 1425              	.LFE13:
 1427              		.section	.text.XMLNode_get_attribute_with_default,"ax",%progbits
 1428              		.align	1
 1429              		.global	XMLNode_get_attribute_with_default
 1430              		.thumb
 1431              		.thumb_func
 1433              	XMLNode_get_attribute_with_default:
 1434              	.LFB14:
 411:sxmlc/sxmlc.c **** {
 1435              		.loc 1 411 0
 1436              		.cfi_startproc
 1437              		@ args = 0, pretend = 0, frame = 0
 1438              		@ frame_needed = 0, uses_anonymous_args = 0
 1439              	.LVL154:
 1440 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1441              		.cfi_def_cfa_offset 24
 1442              		.cfi_offset 3, -24
 1443              		.cfi_offset 4, -20
 1444              		.cfi_offset 5, -16
 1445              		.cfi_offset 6, -12
 1446              		.cfi_offset 7, -8
 1447              		.cfi_offset 14, -4
 411:sxmlc/sxmlc.c **** {
 1448              		.loc 1 411 0
 1449 0002 1446     		mov	r4, r2
 1450 0004 1F46     		mov	r7, r3
 415:sxmlc/sxmlc.c **** 	if (node == NULL || attr_name == NULL || attr_name[0] == NULC || attr_value == NULL || node->init_
 1451              		.loc 1 415 0
 1452 0006 0646     		mov	r6, r0
 1453 0008 00B3     		cbz	r0, .L212
 415:sxmlc/sxmlc.c **** 	if (node == NULL || attr_name == NULL || attr_name[0] == NULC || attr_value == NULL || node->init_
 1454              		.loc 1 415 0 is_stmt 0 discriminator 1
 1455 000a 01B3     		cbz	r1, .L213
 1456 000c 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 1457              	.LVL155:
 1458 000e 03B3     		cbz	r3, .L214
 1459 0010 0AB3     		cbz	r2, .L215
 1460 0012 836A     		ldr	r3, [r0, #40]
 1461 0014 124A     		ldr	r2, .L224
 1462              	.LVL156:
 1463 0016 9342     		cmp	r3, r2
 1464 0018 1FD1     		bne	.L216
 418:sxmlc/sxmlc.c **** 	i = XMLNode_search_attribute(node, attr_name, 0);
 1465              		.loc 1 418 0 is_stmt 1
 1466 001a 0022     		movs	r2, #0
 1467 001c FFF7FEFF 		bl	XMLNode_search_attribute
 1468              	.LVL157:
 419:sxmlc/sxmlc.c **** 	if (i >= 0) {
 1469              		.loc 1 419 0
 1470 0020 0028     		cmp	r0, #0
 1471 0022 09DB     		blt	.L210
 1472              	.LVL158:
 421:sxmlc/sxmlc.c **** 		if (pt[i].value != NULL) {
 1473              		.loc 1 421 0
 1474 0024 B368     		ldr	r3, [r6, #8]
 1475 0026 0C22     		movs	r2, #12
 1476 0028 02FB0030 		mla	r0, r2, r0, r3
 1477              	.LVL159:
 1478 002c 4068     		ldr	r0, [r0, #4]
 1479 002e 30B9     		cbnz	r0, .L223
 1480              	.LVL160:
 1481              	.L211:
 426:sxmlc/sxmlc.c **** 			*attr_value = NULL; /* NULL but returns 'true' as 'NULL' is the actual attribute value */
 1482              		.loc 1 426 0
 1483 0030 0023     		movs	r3, #0
 1484 0032 2360     		str	r3, [r4]
 434:sxmlc/sxmlc.c **** 	return true;
 1485              		.loc 1 434 0
 1486 0034 0120     		movs	r0, #1
 1487 0036 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1488              	.LVL161:
 1489              	.L210:
 427:sxmlc/sxmlc.c **** 	} else if (default_attr_value != NULL) {
 1490              		.loc 1 427 0
 1491 0038 002F     		cmp	r7, #0
 1492 003a F9D0     		beq	.L211
 428:sxmlc/sxmlc.c **** 		*attr_value = sx_strdup(default_attr_value);
 1493              		.loc 1 428 0
 1494 003c 3846     		mov	r0, r7
 1495              	.LVL162:
 1496              	.L223:
 1497 003e FFF7FEFF 		bl	strdup
 1498              	.LVL163:
 1499 0042 2060     		str	r0, [r4]
 429:sxmlc/sxmlc.c **** 		if (*attr_value == NULL)
 1500              		.loc 1 429 0
 1501 0044 0030     		adds	r0, r0, #0
 1502 0046 18BF     		it	ne
 1503 0048 0120     		movne	r0, #1
 1504 004a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1505              	.LVL164:
 1506              	.L212:
 1507 004c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1508              	.LVL165:
 1509              	.L213:
 416:sxmlc/sxmlc.c **** 		return false;
 1510              		.loc 1 416 0
 1511 004e 0846     		mov	r0, r1
 1512              	.LVL166:
 1513 0050 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1514              	.LVL167:
 1515              	.L214:
 1516 0052 1846     		mov	r0, r3
 1517              	.LVL168:
 1518 0054 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1519              	.LVL169:
 1520              	.L215:
 1521 0056 1046     		mov	r0, r2
 1522              	.LVL170:
 1523 0058 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1524              	.LVL171:
 1525              	.L216:
 1526 005a 0020     		movs	r0, #0
 1527              	.LVL172:
 435:sxmlc/sxmlc.c **** }
 1528              		.loc 1 435 0
 1529 005c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1530              	.LVL173:
 1531              	.L225:
 1532 005e 00BF     		.align	2
 1533              	.L224:
 1534 0060 22057719 		.word	427230498
 1535              		.cfi_endproc
 1536              	.LFE14:
 1538              		.section	.text.XMLNode_remove_attribute,"ax",%progbits
 1539              		.align	1
 1540              		.global	XMLNode_remove_attribute
 1541              		.thumb
 1542              		.thumb_func
 1544              	XMLNode_remove_attribute:
 1545              	.LFB17:
 465:sxmlc/sxmlc.c **** {
 1546              		.loc 1 465 0
 1547              		.cfi_startproc
 1548              		@ args = 0, pretend = 0, frame = 0
 1549              		@ frame_needed = 0, uses_anonymous_args = 0
 1550              	.LVL174:
 1551 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1552              		.cfi_def_cfa_offset 24
 1553              		.cfi_offset 3, -24
 1554              		.cfi_offset 4, -20
 1555              		.cfi_offset 5, -16
 1556              		.cfi_offset 6, -12
 1557              		.cfi_offset 7, -8
 1558              		.cfi_offset 14, -4
 465:sxmlc/sxmlc.c **** {
 1559              		.loc 1 465 0
 1560 0002 0F46     		mov	r7, r1
 467:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || i_attr < 0 || i_attr >= node->n_attribute
 1561              		.loc 1 467 0
 1562 0004 0446     		mov	r4, r0
 1563 0006 10B9     		cbnz	r0, .L227
 1564              	.LVL175:
 1565              	.L229:
 468:sxmlc/sxmlc.c **** 		return -1;
 1566              		.loc 1 468 0
 1567 0008 4FF0FF30 		mov	r0, #-1
 1568 000c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1569              	.LVL176:
 1570              	.L227:
 467:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || i_attr < 0 || i_attr >= node->n_attribute
 1571              		.loc 1 467 0 discriminator 1
 1572 000e 836A     		ldr	r3, [r0, #40]
 1573 0010 1D4A     		ldr	r2, .L251
 1574 0012 9342     		cmp	r3, r2
 1575 0014 F8D1     		bne	.L229
 1576 0016 0029     		cmp	r1, #0
 1577 0018 F6DB     		blt	.L229
 1578 001a C068     		ldr	r0, [r0, #12]
 1579              	.LVL177:
 1580 001c 8142     		cmp	r1, r0
 1581 001e F3DA     		bge	.L229
 471:sxmlc/sxmlc.c **** 	if (node->n_attributes == 1)
 1582              		.loc 1 471 0
 1583 0020 0128     		cmp	r0, #1
 1584 0022 07D0     		beq	.L235
 474:sxmlc/sxmlc.c **** 		pt = (XMLAttribute*)__malloc((node->n_attributes - 1) * sizeof(XMLAttribute));
 1585              		.loc 1 474 0
 1586 0024 0C23     		movs	r3, #12
 1587 0026 0138     		subs	r0, r0, #1
 1588 0028 5843     		muls	r0, r3, r0
 1589 002a FFF7FEFF 		bl	malloc
 1590              	.LVL178:
 475:sxmlc/sxmlc.c **** 		if (pt == NULL)
 1591              		.loc 1 475 0
 1592 002e 0546     		mov	r5, r0
 1593 0030 08B9     		cbnz	r0, .L230
 1594 0032 E9E7     		b	.L229
 1595              	.LVL179:
 1596              	.L235:
 472:sxmlc/sxmlc.c **** 		pt = NULL;
 1597              		.loc 1 472 0
 1598 0034 0025     		movs	r5, #0
 1599              	.LVL180:
 1600              	.L230:
 480:sxmlc/sxmlc.c **** 	if (node->attributes[i_attr].name != NULL) __free(node->attributes[i_attr].name);
 1601              		.loc 1 480 0
 1602 0036 0C26     		movs	r6, #12
 1603 0038 7E43     		muls	r6, r7, r6
 1604 003a A368     		ldr	r3, [r4, #8]
 1605 003c 9859     		ldr	r0, [r3, r6]
 1606 003e 08B1     		cbz	r0, .L231
 480:sxmlc/sxmlc.c **** 	if (node->attributes[i_attr].name != NULL) __free(node->attributes[i_attr].name);
 1607              		.loc 1 480 0 is_stmt 0 discriminator 1
 1608 0040 FFF7FEFF 		bl	free
 1609              	.LVL181:
 1610              	.L231:
 481:sxmlc/sxmlc.c **** 	if (node->attributes[i_attr].value != NULL) __free(node->attributes[i_attr].value);
 1611              		.loc 1 481 0 is_stmt 1
 1612 0044 A368     		ldr	r3, [r4, #8]
 1613 0046 3344     		add	r3, r3, r6
 1614 0048 5868     		ldr	r0, [r3, #4]
 1615 004a 08B1     		cbz	r0, .L232
 481:sxmlc/sxmlc.c **** 	if (node->attributes[i_attr].value != NULL) __free(node->attributes[i_attr].value);
 1616              		.loc 1 481 0 is_stmt 0 discriminator 1
 1617 004c FFF7FEFF 		bl	free
 1618              	.LVL182:
 1619              	.L232:
 483:sxmlc/sxmlc.c **** 	if (pt != NULL) {
 1620              		.loc 1 483 0 is_stmt 1
 1621 0050 85B1     		cbz	r5, .L233
 484:sxmlc/sxmlc.c **** 		memcpy(pt, node->attributes, i_attr * sizeof(XMLAttribute));
 1622              		.loc 1 484 0
 1623 0052 A168     		ldr	r1, [r4, #8]
 1624 0054 3246     		mov	r2, r6
 1625 0056 2846     		mov	r0, r5
 1626 0058 FFF7FEFF 		bl	memcpy
 1627              	.LVL183:
 485:sxmlc/sxmlc.c **** 		memcpy(&pt[i_attr], &node->attributes[i_attr + 1], (node->n_attributes - i_attr - 1) * sizeof(XML
 1628              		.loc 1 485 0
 1629 005c E368     		ldr	r3, [r4, #12]
 1630 005e 06F10C01 		add	r1, r6, #12
 1631 0062 DF1B     		subs	r7, r3, r7
 1632              	.LVL184:
 1633 0064 A368     		ldr	r3, [r4, #8]
 1634 0066 013F     		subs	r7, r7, #1
 1635 0068 0C22     		movs	r2, #12
 1636 006a A819     		adds	r0, r5, r6
 1637 006c 1944     		add	r1, r1, r3
 1638 006e 7A43     		muls	r2, r7, r2
 1639 0070 FFF7FEFF 		bl	memcpy
 1640              	.LVL185:
 1641              	.L233:
 487:sxmlc/sxmlc.c **** 	if (node->attributes != NULL)
 1642              		.loc 1 487 0
 1643 0074 A068     		ldr	r0, [r4, #8]
 1644 0076 08B1     		cbz	r0, .L234
 488:sxmlc/sxmlc.c **** 		__free(node->attributes);
 1645              		.loc 1 488 0
 1646 0078 FFF7FEFF 		bl	free
 1647              	.LVL186:
 1648              	.L234:
 490:sxmlc/sxmlc.c **** 	node->n_attributes--;
 1649              		.loc 1 490 0
 1650 007c E068     		ldr	r0, [r4, #12]
 489:sxmlc/sxmlc.c **** 	node->attributes = pt;
 1651              		.loc 1 489 0
 1652 007e A560     		str	r5, [r4, #8]
 490:sxmlc/sxmlc.c **** 	node->n_attributes--;
 1653              		.loc 1 490 0
 1654 0080 0138     		subs	r0, r0, #1
 1655 0082 E060     		str	r0, [r4, #12]
 493:sxmlc/sxmlc.c **** }
 1656              		.loc 1 493 0
 1657 0084 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1658              	.LVL187:
 1659              	.L252:
 1660 0086 00BF     		.align	2
 1661              	.L251:
 1662 0088 22057719 		.word	427230498
 1663              		.cfi_endproc
 1664              	.LFE17:
 1666              		.section	.text.XMLNode_remove_all_attributes,"ax",%progbits
 1667              		.align	1
 1668              		.global	XMLNode_remove_all_attributes
 1669              		.thumb
 1670              		.thumb_func
 1672              	XMLNode_remove_all_attributes:
 1673              	.LFB18:
 496:sxmlc/sxmlc.c **** {
 1674              		.loc 1 496 0
 1675              		.cfi_startproc
 1676              		@ args = 0, pretend = 0, frame = 0
 1677              		@ frame_needed = 0, uses_anonymous_args = 0
 1678              	.LVL188:
 1679 0000 70B5     		push	{r4, r5, r6, lr}
 1680              		.cfi_def_cfa_offset 16
 1681              		.cfi_offset 4, -16
 1682              		.cfi_offset 5, -12
 1683              		.cfi_offset 6, -8
 1684              		.cfi_offset 14, -4
 499:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 1685              		.loc 1 499 0
 1686 0002 0446     		mov	r4, r0
 1687 0004 08B3     		cbz	r0, .L261
 499:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 1688              		.loc 1 499 0 is_stmt 0 discriminator 1
 1689 0006 836A     		ldr	r3, [r0, #40]
 1690 0008 114A     		ldr	r2, .L272
 1691 000a 9342     		cmp	r3, r2
 1692 000c 1DD1     		bne	.L261
 502:sxmlc/sxmlc.c **** 	if (node->attributes != NULL) {
 1693              		.loc 1 502 0 is_stmt 1
 1694 000e 8368     		ldr	r3, [r0, #8]
 1695 0010 BBB1     		cbz	r3, .L255
 1696 0012 0025     		movs	r5, #0
 1697              	.LVL189:
 1698              	.L256:
 503:sxmlc/sxmlc.c **** 		for (i = 0; i < node->n_attributes; i++) {
 1699              		.loc 1 503 0 discriminator 1
 1700 0014 E368     		ldr	r3, [r4, #12]
 1701 0016 9D42     		cmp	r5, r3
 1702 0018 0EDA     		bge	.L271
 1703 001a 0C26     		movs	r6, #12
 1704 001c 6E43     		muls	r6, r5, r6
 504:sxmlc/sxmlc.c **** 			if (node->attributes[i].name != NULL)
 1705              		.loc 1 504 0
 1706 001e A368     		ldr	r3, [r4, #8]
 1707 0020 9859     		ldr	r0, [r3, r6]
 1708 0022 08B1     		cbz	r0, .L257
 505:sxmlc/sxmlc.c **** 				__free(node->attributes[i].name);
 1709              		.loc 1 505 0
 1710 0024 FFF7FEFF 		bl	free
 1711              	.LVL190:
 1712              	.L257:
 506:sxmlc/sxmlc.c **** 			if (node->attributes[i].value != NULL)
 1713              		.loc 1 506 0
 1714 0028 A368     		ldr	r3, [r4, #8]
 1715 002a 1E44     		add	r6, r6, r3
 1716 002c 7068     		ldr	r0, [r6, #4]
 1717 002e 08B1     		cbz	r0, .L258
 507:sxmlc/sxmlc.c **** 				__free(node->attributes[i].value);
 1718              		.loc 1 507 0
 1719 0030 FFF7FEFF 		bl	free
 1720              	.LVL191:
 1721              	.L258:
 503:sxmlc/sxmlc.c **** 		for (i = 0; i < node->n_attributes; i++) {
 1722              		.loc 1 503 0
 1723 0034 0135     		adds	r5, r5, #1
 1724              	.LVL192:
 1725 0036 EDE7     		b	.L256
 1726              	.L271:
 509:sxmlc/sxmlc.c **** 		__free(node->attributes);
 1727              		.loc 1 509 0
 1728 0038 A068     		ldr	r0, [r4, #8]
 1729 003a FFF7FEFF 		bl	free
 1730              	.LVL193:
 510:sxmlc/sxmlc.c **** 		node->attributes = NULL;
 1731              		.loc 1 510 0
 1732 003e 0023     		movs	r3, #0
 1733 0040 A360     		str	r3, [r4, #8]
 1734              	.LVL194:
 1735              	.L255:
 512:sxmlc/sxmlc.c **** 	node->n_attributes = 0;
 1736              		.loc 1 512 0
 1737 0042 0023     		movs	r3, #0
 1738 0044 E360     		str	r3, [r4, #12]
 514:sxmlc/sxmlc.c **** 	return true;
 1739              		.loc 1 514 0
 1740 0046 0120     		movs	r0, #1
 1741 0048 70BD     		pop	{r4, r5, r6, pc}
 1742              	.LVL195:
 1743              	.L261:
 500:sxmlc/sxmlc.c **** 		return false;
 1744              		.loc 1 500 0
 1745 004a 0020     		movs	r0, #0
 1746              	.LVL196:
 515:sxmlc/sxmlc.c **** }
 1747              		.loc 1 515 0
 1748 004c 70BD     		pop	{r4, r5, r6, pc}
 1749              	.LVL197:
 1750              	.L273:
 1751 004e 00BF     		.align	2
 1752              	.L272:
 1753 0050 22057719 		.word	427230498
 1754              		.cfi_endproc
 1755              	.LFE18:
 1757              		.section	.text.XMLNode_set_text,"ax",%progbits
 1758              		.align	1
 1759              		.global	XMLNode_set_text
 1760              		.thumb
 1761              		.thumb_func
 1763              	XMLNode_set_text:
 1764              	.LFB19:
 518:sxmlc/sxmlc.c **** {
 1765              		.loc 1 518 0
 1766              		.cfi_startproc
 1767              		@ args = 0, pretend = 0, frame = 0
 1768              		@ frame_needed = 0, uses_anonymous_args = 0
 1769              	.LVL198:
 1770 0000 38B5     		push	{r3, r4, r5, lr}
 1771              		.cfi_def_cfa_offset 16
 1772              		.cfi_offset 3, -16
 1773              		.cfi_offset 4, -12
 1774              		.cfi_offset 5, -8
 1775              		.cfi_offset 14, -4
 518:sxmlc/sxmlc.c **** {
 1776              		.loc 1 518 0
 1777 0002 0D46     		mov	r5, r1
 520:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 1778              		.loc 1 520 0
 1779 0004 0446     		mov	r4, r0
 1780 0006 08B9     		cbnz	r0, .L275
 1781              	.LVL199:
 1782              	.L277:
 521:sxmlc/sxmlc.c **** 		return false;
 1783              		.loc 1 521 0
 1784 0008 0020     		movs	r0, #0
 1785 000a 38BD     		pop	{r3, r4, r5, pc}
 1786              	.LVL200:
 1787              	.L275:
 520:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 1788              		.loc 1 520 0 discriminator 1
 1789 000c 836A     		ldr	r3, [r0, #40]
 1790 000e 0C4A     		ldr	r2, .L283
 1791 0010 9342     		cmp	r3, r2
 1792 0012 F9D1     		bne	.L277
 523:sxmlc/sxmlc.c **** 	if (text == NULL) { /* We want to remove it => free node text */
 1793              		.loc 1 523 0
 1794 0014 29B9     		cbnz	r1, .L278
 524:sxmlc/sxmlc.c **** 		if (node->text != NULL) {
 1795              		.loc 1 524 0
 1796 0016 4068     		ldr	r0, [r0, #4]
 1797              	.LVL201:
 1798 0018 80B1     		cbz	r0, .L279
 525:sxmlc/sxmlc.c **** 			__free(node->text);
 1799              		.loc 1 525 0
 1800 001a FFF7FEFF 		bl	free
 1801              	.LVL202:
 526:sxmlc/sxmlc.c **** 			node->text = NULL;
 1802              		.loc 1 526 0
 1803 001e 6560     		str	r5, [r4, #4]
 1804 0020 0CE0     		b	.L279
 1805              	.LVL203:
 1806              	.L278:
 532:sxmlc/sxmlc.c **** 	p = (SXML_CHAR*)__realloc(node->text, (sx_strlen(text) + 1)*sizeof(SXML_CHAR)); /* +1 for '\0' */
 1807              		.loc 1 532 0
 1808 0022 0846     		mov	r0, r1
 1809              	.LVL204:
 1810 0024 FFF7FEFF 		bl	strlen
 1811              	.LVL205:
 1812 0028 411C     		adds	r1, r0, #1
 1813 002a 6068     		ldr	r0, [r4, #4]
 1814 002c FFF7FEFF 		bl	realloc
 1815              	.LVL206:
 533:sxmlc/sxmlc.c **** 	if (p == NULL)
 1816              		.loc 1 533 0
 1817 0030 0028     		cmp	r0, #0
 1818 0032 E9D0     		beq	.L277
 535:sxmlc/sxmlc.c **** 	node->text = p;
 1819              		.loc 1 535 0
 1820 0034 6060     		str	r0, [r4, #4]
 537:sxmlc/sxmlc.c **** 	sx_strcpy(node->text, text);
 1821              		.loc 1 537 0
 1822 0036 2946     		mov	r1, r5
 1823 0038 FFF7FEFF 		bl	strcpy
 1824              	.LVL207:
 1825              	.L279:
 529:sxmlc/sxmlc.c **** 		return true;
 1826              		.loc 1 529 0
 1827 003c 0120     		movs	r0, #1
 540:sxmlc/sxmlc.c **** }
 1828              		.loc 1 540 0
 1829 003e 38BD     		pop	{r3, r4, r5, pc}
 1830              	.LVL208:
 1831              	.L284:
 1832              		.align	2
 1833              	.L283:
 1834 0040 22057719 		.word	427230498
 1835              		.cfi_endproc
 1836              	.LFE19:
 1838              		.section	.text.XMLNode_add_child,"ax",%progbits
 1839              		.align	1
 1840              		.global	XMLNode_add_child
 1841              		.thumb
 1842              		.thumb_func
 1844              	XMLNode_add_child:
 1845              	.LFB20:
 543:sxmlc/sxmlc.c **** {
 1846              		.loc 1 543 0
 1847              		.cfi_startproc
 1848              		@ args = 0, pretend = 0, frame = 0
 1849              		@ frame_needed = 0, uses_anonymous_args = 0
 1850              	.LVL209:
 1851 0000 38B5     		push	{r3, r4, r5, lr}
 1852              		.cfi_def_cfa_offset 16
 1853              		.cfi_offset 3, -16
 1854              		.cfi_offset 4, -12
 1855              		.cfi_offset 5, -8
 1856              		.cfi_offset 14, -4
 543:sxmlc/sxmlc.c **** {
 1857              		.loc 1 543 0
 1858 0002 0D46     		mov	r5, r1
 544:sxmlc/sxmlc.c **** 	if (node == NULL || child == NULL || node->init_value != XML_INIT_DONE || child->init_value != XML
 1859              		.loc 1 544 0
 1860 0004 0446     		mov	r4, r0
 1861 0006 08B9     		cbnz	r0, .L286
 1862              	.LVL210:
 1863              	.L288:
 545:sxmlc/sxmlc.c **** 		return false;
 1864              		.loc 1 545 0
 1865 0008 0020     		movs	r0, #0
 1866 000a 38BD     		pop	{r3, r4, r5, pc}
 1867              	.LVL211:
 1868              	.L286:
 544:sxmlc/sxmlc.c **** 	if (node == NULL || child == NULL || node->init_value != XML_INIT_DONE || child->init_value != XML
 1869              		.loc 1 544 0 discriminator 1
 1870 000c 0029     		cmp	r1, #0
 1871 000e FBD0     		beq	.L288
 1872 0010 836A     		ldr	r3, [r0, #40]
 1873 0012 094A     		ldr	r2, .L292
 1874 0014 9342     		cmp	r3, r2
 1875 0016 F7D1     		bne	.L288
 1876 0018 8A6A     		ldr	r2, [r1, #40]
 1877 001a 9A42     		cmp	r2, r3
 1878 001c F4D1     		bne	.L288
 547:sxmlc/sxmlc.c **** 	if (_add_node(&node->children, &node->n_children, child) >= 0) {
 1879              		.loc 1 547 0
 1880 001e 1430     		adds	r0, r0, #20
 1881              	.LVL212:
 1882 0020 04F11801 		add	r1, r4, #24
 1883              	.LVL213:
 1884 0024 2A46     		mov	r2, r5
 1885 0026 FFF7FEFF 		bl	_add_node
 1886              	.LVL214:
 1887 002a 0028     		cmp	r0, #0
 1888 002c ECDB     		blt	.L288
 548:sxmlc/sxmlc.c **** 		node->tag_type = TAG_FATHER;
 1889              		.loc 1 548 0
 1890 002e 0223     		movs	r3, #2
 1891 0030 2377     		strb	r3, [r4, #28]
 550:sxmlc/sxmlc.c **** 		return true;
 1892              		.loc 1 550 0
 1893 0032 0120     		movs	r0, #1
 549:sxmlc/sxmlc.c **** 		child->father = node;
 1894              		.loc 1 549 0
 1895 0034 2C61     		str	r4, [r5, #16]
 553:sxmlc/sxmlc.c **** }
 1896              		.loc 1 553 0
 1897 0036 38BD     		pop	{r3, r4, r5, pc}
 1898              	.LVL215:
 1899              	.L293:
 1900              		.align	2
 1901              	.L292:
 1902 0038 22057719 		.word	427230498
 1903              		.cfi_endproc
 1904              	.LFE20:
 1906              		.section	.text.XMLNode_get_children_count,"ax",%progbits
 1907              		.align	1
 1908              		.global	XMLNode_get_children_count
 1909              		.thumb
 1910              		.thumb_func
 1912              	XMLNode_get_children_count:
 1913              	.LFB21:
 556:sxmlc/sxmlc.c **** {
 1914              		.loc 1 556 0
 1915              		.cfi_startproc
 1916              		@ args = 0, pretend = 0, frame = 0
 1917              		@ frame_needed = 0, uses_anonymous_args = 0
 1918              	.LVL216:
 1919 0000 10B5     		push	{r4, lr}
 1920              		.cfi_def_cfa_offset 8
 1921              		.cfi_offset 4, -8
 1922              		.cfi_offset 14, -4
 559:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 1923              		.loc 1 559 0
 1924 0002 90B1     		cbz	r0, .L300
 559:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 1925              		.loc 1 559 0 is_stmt 0 discriminator 1
 1926 0004 836A     		ldr	r3, [r0, #40]
 1927 0006 0A4A     		ldr	r2, .L305
 1928 0008 9342     		cmp	r3, r2
 1929 000a 0ED1     		bne	.L300
 562:sxmlc/sxmlc.c **** 	for (i = n = 0; i < node->n_children; i++)
 1930              		.loc 1 562 0 is_stmt 1
 1931 000c 0023     		movs	r3, #0
 1932 000e 8469     		ldr	r4, [r0, #24]
 1933 0010 1A46     		mov	r2, r3
 1934              	.L296:
 1935              	.LVL217:
 562:sxmlc/sxmlc.c **** 	for (i = n = 0; i < node->n_children; i++)
 1936              		.loc 1 562 0 is_stmt 0 discriminator 1
 1937 0012 A242     		cmp	r2, r4
 1938 0014 07DA     		bge	.L304
 563:sxmlc/sxmlc.c **** 		if (node->children[i]->active) n++;
 1939              		.loc 1 563 0 is_stmt 1
 1940 0016 4169     		ldr	r1, [r0, #20]
 1941 0018 51F82210 		ldr	r1, [r1, r2, lsl #2]
 1942 001c 096A     		ldr	r1, [r1, #32]
 1943 001e 01B1     		cbz	r1, .L297
 563:sxmlc/sxmlc.c **** 		if (node->children[i]->active) n++;
 1944              		.loc 1 563 0 is_stmt 0 discriminator 1
 1945 0020 0133     		adds	r3, r3, #1
 1946              	.LVL218:
 1947              	.L297:
 562:sxmlc/sxmlc.c **** 	for (i = n = 0; i < node->n_children; i++)
 1948              		.loc 1 562 0 is_stmt 1
 1949 0022 0132     		adds	r2, r2, #1
 1950              	.LVL219:
 1951 0024 F5E7     		b	.L296
 1952              	.L304:
 1953 0026 1846     		mov	r0, r3
 1954              	.LVL220:
 1955 0028 10BD     		pop	{r4, pc}
 1956              	.LVL221:
 1957              	.L300:
 560:sxmlc/sxmlc.c **** 		return -1;
 1958              		.loc 1 560 0
 1959 002a 4FF0FF30 		mov	r0, #-1
 1960              	.LVL222:
 566:sxmlc/sxmlc.c **** }
 1961              		.loc 1 566 0
 1962 002e 10BD     		pop	{r4, pc}
 1963              	.L306:
 1964              		.align	2
 1965              	.L305:
 1966 0030 22057719 		.word	427230498
 1967              		.cfi_endproc
 1968              	.LFE21:
 1970              		.section	.text.XMLNode_get_child,"ax",%progbits
 1971              		.align	1
 1972              		.global	XMLNode_get_child
 1973              		.thumb
 1974              		.thumb_func
 1976              	XMLNode_get_child:
 1977              	.LFB22:
 569:sxmlc/sxmlc.c **** {
 1978              		.loc 1 569 0
 1979              		.cfi_startproc
 1980              		@ args = 0, pretend = 0, frame = 0
 1981              		@ frame_needed = 0, uses_anonymous_args = 0
 1982              	.LVL223:
 1983 0000 30B5     		push	{r4, r5, lr}
 1984              		.cfi_def_cfa_offset 12
 1985              		.cfi_offset 4, -12
 1986              		.cfi_offset 5, -8
 1987              		.cfi_offset 14, -4
 572:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || i_child < 0 || i_child >= node->n_childre
 1988              		.loc 1 572 0
 1989 0002 B0B1     		cbz	r0, .L313
 572:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || i_child < 0 || i_child >= node->n_childre
 1990              		.loc 1 572 0 is_stmt 0 discriminator 1
 1991 0004 836A     		ldr	r3, [r0, #40]
 1992 0006 0D4A     		ldr	r2, .L317
 1993 0008 9342     		cmp	r3, r2
 1994 000a 14D1     		bne	.L316
 1995 000c 0029     		cmp	r1, #0
 1996 000e 12DB     		blt	.L316
 1997 0010 8469     		ldr	r4, [r0, #24]
 1998 0012 A142     		cmp	r1, r4
 1999 0014 0FDA     		bge	.L316
 572:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || i_child < 0 || i_child >= node->n_childre
 2000              		.loc 1 572 0
 2001 0016 0022     		movs	r2, #0
 2002              	.L309:
 2003              	.LVL224:
 575:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_children; i++) {
 2004              		.loc 1 575 0 is_stmt 1 discriminator 1
 2005 0018 A242     		cmp	r2, r4
 2006 001a 0CDA     		bge	.L316
 576:sxmlc/sxmlc.c **** 		if (!node->children[i]->active)
 2007              		.loc 1 576 0
 2008 001c 4369     		ldr	r3, [r0, #20]
 2009 001e 53F82230 		ldr	r3, [r3, r2, lsl #2]
 2010 0022 1D6A     		ldr	r5, [r3, #32]
 2011 0024 0DB9     		cbnz	r5, .L310
 577:sxmlc/sxmlc.c **** 			i_child++;
 2012              		.loc 1 577 0
 2013 0026 0131     		adds	r1, r1, #1
 2014              	.LVL225:
 2015 0028 01E0     		b	.L311
 2016              	.L310:
 578:sxmlc/sxmlc.c **** 		else if (i == i_child)
 2017              		.loc 1 578 0
 2018 002a 8A42     		cmp	r2, r1
 2019 002c 04D0     		beq	.L308
 2020              	.L311:
 575:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_children; i++) {
 2021              		.loc 1 575 0
 2022 002e 0132     		adds	r2, r2, #1
 2023              	.LVL226:
 2024 0030 F2E7     		b	.L309
 2025              	.LVL227:
 2026              	.L313:
 573:sxmlc/sxmlc.c **** 		return NULL;
 2027              		.loc 1 573 0
 2028 0032 0346     		mov	r3, r0
 2029 0034 00E0     		b	.L308
 2030              	.L316:
 2031 0036 0023     		movs	r3, #0
 2032              	.L308:
 583:sxmlc/sxmlc.c **** }
 2033              		.loc 1 583 0
 2034 0038 1846     		mov	r0, r3
 2035              	.LVL228:
 2036 003a 30BD     		pop	{r4, r5, pc}
 2037              	.L318:
 2038              		.align	2
 2039              	.L317:
 2040 003c 22057719 		.word	427230498
 2041              		.cfi_endproc
 2042              	.LFE22:
 2044              		.section	.text.XMLNode_remove_children,"ax",%progbits
 2045              		.align	1
 2046              		.global	XMLNode_remove_children
 2047              		.thumb
 2048              		.thumb_func
 2050              	XMLNode_remove_children:
 2051              	.LFB24:
 632:sxmlc/sxmlc.c **** {
 2052              		.loc 1 632 0
 2053              		.cfi_startproc
 2054              		@ args = 0, pretend = 0, frame = 0
 2055              		@ frame_needed = 0, uses_anonymous_args = 0
 2056              	.LVL229:
 2057 0000 38B5     		push	{r3, r4, r5, lr}
 2058              		.cfi_def_cfa_offset 16
 2059              		.cfi_offset 3, -16
 2060              		.cfi_offset 4, -12
 2061              		.cfi_offset 5, -8
 2062              		.cfi_offset 14, -4
 635:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 2063              		.loc 1 635 0
 2064 0002 0446     		mov	r4, r0
 2065 0004 F8B1     		cbz	r0, .L326
 635:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 2066              		.loc 1 635 0 is_stmt 0 discriminator 1
 2067 0006 836A     		ldr	r3, [r0, #40]
 2068 0008 104A     		ldr	r2, .L334
 2069 000a 9342     		cmp	r3, r2
 2070 000c 1BD1     		bne	.L326
 638:sxmlc/sxmlc.c **** 	if (node->children != NULL) {
 2071              		.loc 1 638 0 is_stmt 1
 2072 000e 4369     		ldr	r3, [r0, #20]
 2073 0010 ABB1     		cbz	r3, .L321
 2074 0012 0025     		movs	r5, #0
 2075              	.LVL230:
 2076              	.L322:
 639:sxmlc/sxmlc.c **** 		for (i = 0; i < node->n_children; i++)
 2077              		.loc 1 639 0 discriminator 1
 2078 0014 A369     		ldr	r3, [r4, #24]
 2079 0016 9D42     		cmp	r5, r3
 2080 0018 0CDA     		bge	.L333
 640:sxmlc/sxmlc.c **** 			if (node->children[i] != NULL) {
 2081              		.loc 1 640 0
 2082 001a 6369     		ldr	r3, [r4, #20]
 2083 001c 53F82500 		ldr	r0, [r3, r5, lsl #2]
 2084 0020 30B1     		cbz	r0, .L323
 641:sxmlc/sxmlc.c **** 				(void)XMLNode_free(node->children[i]);
 2085              		.loc 1 641 0
 2086 0022 FFF7FEFF 		bl	XMLNode_free
 2087              	.LVL231:
 642:sxmlc/sxmlc.c **** 				__free(node->children[i]);
 2088              		.loc 1 642 0
 2089 0026 6369     		ldr	r3, [r4, #20]
 2090 0028 53F82500 		ldr	r0, [r3, r5, lsl #2]
 2091 002c FFF7FEFF 		bl	free
 2092              	.LVL232:
 2093              	.L323:
 639:sxmlc/sxmlc.c **** 		for (i = 0; i < node->n_children; i++)
 2094              		.loc 1 639 0
 2095 0030 0135     		adds	r5, r5, #1
 2096              	.LVL233:
 2097 0032 EFE7     		b	.L322
 2098              	.L333:
 644:sxmlc/sxmlc.c **** 		__free(node->children);
 2099              		.loc 1 644 0
 2100 0034 6069     		ldr	r0, [r4, #20]
 2101 0036 FFF7FEFF 		bl	free
 2102              	.LVL234:
 645:sxmlc/sxmlc.c **** 		node->children = NULL;
 2103              		.loc 1 645 0
 2104 003a 0023     		movs	r3, #0
 2105 003c 6361     		str	r3, [r4, #20]
 2106              	.LVL235:
 2107              	.L321:
 647:sxmlc/sxmlc.c **** 	node->n_children = 0;
 2108              		.loc 1 647 0
 2109 003e 0023     		movs	r3, #0
 2110 0040 A361     		str	r3, [r4, #24]
 649:sxmlc/sxmlc.c **** 	return true;
 2111              		.loc 1 649 0
 2112 0042 0120     		movs	r0, #1
 2113 0044 38BD     		pop	{r3, r4, r5, pc}
 2114              	.LVL236:
 2115              	.L326:
 636:sxmlc/sxmlc.c **** 		return false;
 2116              		.loc 1 636 0
 2117 0046 0020     		movs	r0, #0
 2118              	.LVL237:
 650:sxmlc/sxmlc.c **** }
 2119              		.loc 1 650 0
 2120 0048 38BD     		pop	{r3, r4, r5, pc}
 2121              	.LVL238:
 2122              	.L335:
 2123 004a 00BF     		.align	2
 2124              	.L334:
 2125 004c 22057719 		.word	427230498
 2126              		.cfi_endproc
 2127              	.LFE24:
 2129              		.section	.text.XMLNode_free,"ax",%progbits
 2130              		.align	1
 2131              		.global	XMLNode_free
 2132              		.thumb
 2133              		.thumb_func
 2135              	XMLNode_free:
 2136              	.LFB8:
 242:sxmlc/sxmlc.c **** {
 2137              		.loc 1 242 0
 2138              		.cfi_startproc
 2139              		@ args = 0, pretend = 0, frame = 0
 2140              		@ frame_needed = 0, uses_anonymous_args = 0
 2141              	.LVL239:
 2142 0000 10B5     		push	{r4, lr}
 2143              		.cfi_def_cfa_offset 8
 2144              		.cfi_offset 4, -8
 2145              		.cfi_offset 14, -4
 243:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 2146              		.loc 1 243 0
 2147 0002 0446     		mov	r4, r0
 2148 0004 B8B1     		cbz	r0, .L340
 243:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 2149              		.loc 1 243 0 is_stmt 0 discriminator 1
 2150 0006 836A     		ldr	r3, [r0, #40]
 2151 0008 0C4A     		ldr	r2, .L344
 2152 000a 9342     		cmp	r3, r2
 2153 000c 13D1     		bne	.L340
 2154              	.LVL240:
 2155              	.LBB7:
 2156              	.LBB8:
 246:sxmlc/sxmlc.c **** 	if (node->tag != NULL) {
 2157              		.loc 1 246 0 is_stmt 1
 2158 000e 0068     		ldr	r0, [r0]
 2159              	.LVL241:
 2160 0010 18B1     		cbz	r0, .L338
 247:sxmlc/sxmlc.c **** 		__free(node->tag);
 2161              		.loc 1 247 0
 2162 0012 FFF7FEFF 		bl	free
 2163              	.LVL242:
 248:sxmlc/sxmlc.c **** 		node->tag = NULL;
 2164              		.loc 1 248 0
 2165 0016 0023     		movs	r3, #0
 2166 0018 2360     		str	r3, [r4]
 2167              	.L338:
 251:sxmlc/sxmlc.c **** 	XMLNode_remove_text(node);
 2168              		.loc 1 251 0
 2169 001a 0021     		movs	r1, #0
 2170 001c 2046     		mov	r0, r4
 2171 001e FFF7FEFF 		bl	XMLNode_set_text
 2172              	.LVL243:
 252:sxmlc/sxmlc.c **** 	XMLNode_remove_all_attributes(node);
 2173              		.loc 1 252 0
 2174 0022 2046     		mov	r0, r4
 2175 0024 FFF7FEFF 		bl	XMLNode_remove_all_attributes
 2176              	.LVL244:
 253:sxmlc/sxmlc.c **** 	XMLNode_remove_children(node);
 2177              		.loc 1 253 0
 2178 0028 2046     		mov	r0, r4
 2179 002a FFF7FEFF 		bl	XMLNode_remove_children
 2180              	.LVL245:
 255:sxmlc/sxmlc.c **** 	node->tag_type = TAG_NONE;
 2181              		.loc 1 255 0
 2182 002e 0023     		movs	r3, #0
 2183 0030 2377     		strb	r3, [r4, #28]
 2184 0032 0120     		movs	r0, #1
 2185 0034 10BD     		pop	{r4, pc}
 2186              	.LVL246:
 2187              	.L340:
 2188              	.LBE8:
 2189              	.LBE7:
 244:sxmlc/sxmlc.c **** 		return false;
 2190              		.loc 1 244 0
 2191 0036 0020     		movs	r0, #0
 2192              	.LVL247:
 258:sxmlc/sxmlc.c **** }
 2193              		.loc 1 258 0
 2194 0038 10BD     		pop	{r4, pc}
 2195              	.LVL248:
 2196              	.L345:
 2197 003a 00BF     		.align	2
 2198              	.L344:
 2199 003c 22057719 		.word	427230498
 2200              		.cfi_endproc
 2201              	.LFE8:
 2203              		.section	.text.XMLNode_copy,"ax",%progbits
 2204              		.align	1
 2205              		.global	XMLNode_copy
 2206              		.thumb
 2207              		.thumb_func
 2209              	XMLNode_copy:
 2210              	.LFB9:
 261:sxmlc/sxmlc.c **** {
 2211              		.loc 1 261 0
 2212              		.cfi_startproc
 2213              		@ args = 0, pretend = 0, frame = 0
 2214              		@ frame_needed = 0, uses_anonymous_args = 0
 2215              	.LVL249:
 2216 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 2217              		.cfi_def_cfa_offset 32
 2218              		.cfi_offset 4, -32
 2219              		.cfi_offset 5, -28
 2220              		.cfi_offset 6, -24
 2221              		.cfi_offset 7, -20
 2222              		.cfi_offset 8, -16
 2223              		.cfi_offset 9, -12
 2224              		.cfi_offset 10, -8
 2225              		.cfi_offset 14, -4
 261:sxmlc/sxmlc.c **** {
 2226              		.loc 1 261 0
 2227 0004 0D46     		mov	r5, r1
 2228 0006 9146     		mov	r9, r2
 264:sxmlc/sxmlc.c **** 	if (dst == NULL || (src != NULL && src->init_value != XML_INIT_DONE))
 2229              		.loc 1 264 0
 2230 0008 0446     		mov	r4, r0
 2231 000a 0028     		cmp	r0, #0
 2232 000c 72D0     		beq	.L364
 264:sxmlc/sxmlc.c **** 	if (dst == NULL || (src != NULL && src->init_value != XML_INIT_DONE))
 2233              		.loc 1 264 0 is_stmt 0 discriminator 1
 2234 000e 19B1     		cbz	r1, .L348
 2235 0010 8B6A     		ldr	r3, [r1, #40]
 2236 0012 3A4A     		ldr	r2, .L389
 2237              	.LVL250:
 2238 0014 9342     		cmp	r3, r2
 2239 0016 6DD1     		bne	.L364
 2240              	.L348:
 267:sxmlc/sxmlc.c **** 	(void)XMLNode_free(dst); /* 'dst' is freed first */
 2241              		.loc 1 267 0 is_stmt 1
 2242 0018 2046     		mov	r0, r4
 2243              	.LVL251:
 2244 001a FFF7FEFF 		bl	XMLNode_free
 2245              	.LVL252:
 270:sxmlc/sxmlc.c **** 	if (src == NULL)
 2246              		.loc 1 270 0
 2247 001e 15B9     		cbnz	r5, .L349
 2248              	.L358:
 271:sxmlc/sxmlc.c **** 		return true;
 2249              		.loc 1 271 0
 2250 0020 0120     		movs	r0, #1
 2251 0022 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 2252              	.LVL253:
 2253              	.L349:
 274:sxmlc/sxmlc.c **** 	if (src->tag != NULL) {
 2254              		.loc 1 274 0
 2255 0026 2868     		ldr	r0, [r5]
 2256 0028 10B9     		cbnz	r0, .L350
 2257              	.L354:
 280:sxmlc/sxmlc.c **** 	if (dst->text != NULL) {
 2258              		.loc 1 280 0
 2259 002a 6368     		ldr	r3, [r4, #4]
 2260 002c 33B9     		cbnz	r3, .L351
 2261 002e 0BE0     		b	.L352
 2262              	.L350:
 275:sxmlc/sxmlc.c **** 		dst->tag = sx_strdup(src->tag);
 2263              		.loc 1 275 0
 2264 0030 FFF7FEFF 		bl	strdup
 2265              	.LVL254:
 2266 0034 2060     		str	r0, [r4]
 276:sxmlc/sxmlc.c **** 		if (dst->tag == NULL) goto copy_err;
 2267              		.loc 1 276 0
 2268 0036 0028     		cmp	r0, #0
 2269 0038 F7D1     		bne	.L354
 2270 003a 58E0     		b	.L353
 2271              	.L351:
 281:sxmlc/sxmlc.c **** 		dst->text = sx_strdup(src->text);
 2272              		.loc 1 281 0
 2273 003c 6868     		ldr	r0, [r5, #4]
 2274 003e FFF7FEFF 		bl	strdup
 2275              	.LVL255:
 2276 0042 6060     		str	r0, [r4, #4]
 282:sxmlc/sxmlc.c **** 		if (dst->text == NULL) goto copy_err;
 2277              		.loc 1 282 0
 2278 0044 0028     		cmp	r0, #0
 2279 0046 52D0     		beq	.L353
 2280              	.L352:
 286:sxmlc/sxmlc.c **** 	if (src->n_attributes > 0) {
 2281              		.loc 1 286 0
 2282 0048 EF68     		ldr	r7, [r5, #12]
 2283 004a 002F     		cmp	r7, #0
 2284 004c 0DDD     		ble	.L356
 287:sxmlc/sxmlc.c **** 		dst->attributes = (XMLAttribute*)__calloc(src->n_attributes, sizeof(XMLAttribute));
 2285              		.loc 1 287 0
 2286 004e 3846     		mov	r0, r7
 2287 0050 0C21     		movs	r1, #12
 2288 0052 FFF7FEFF 		bl	calloc
 2289              	.LVL256:
 2290 0056 A060     		str	r0, [r4, #8]
 288:sxmlc/sxmlc.c **** 		if (dst->attributes== NULL) goto copy_err;
 2291              		.loc 1 288 0
 2292 0058 0028     		cmp	r0, #0
 2293 005a 48D0     		beq	.L353
 289:sxmlc/sxmlc.c **** 		dst->n_attributes = src->n_attributes;
 2294              		.loc 1 289 0
 2295 005c E760     		str	r7, [r4, #12]
 2296              	.LVL257:
 2297 005e 00F10806 		add	r6, r0, #8
 290:sxmlc/sxmlc.c **** 		for (i = 0; i < src->n_attributes; i++) {
 2298              		.loc 1 290 0
 2299 0062 0027     		movs	r7, #0
 2300              	.LVL258:
 2301              	.L359:
 290:sxmlc/sxmlc.c **** 		for (i = 0; i < src->n_attributes; i++) {
 2302              		.loc 1 290 0 is_stmt 0 discriminator 1
 2303 0064 EB68     		ldr	r3, [r5, #12]
 2304 0066 9F42     		cmp	r7, r3
 2305 0068 0BDB     		blt	.L360
 2306              	.LVL259:
 2307              	.L356:
 298:sxmlc/sxmlc.c **** 	dst->tag_type = src->tag_type;
 2308              		.loc 1 298 0 is_stmt 1
 2309 006a 2B7F     		ldrb	r3, [r5, #28]	@ zero_extendqisi2
 2310 006c 2377     		strb	r3, [r4, #28]
 299:sxmlc/sxmlc.c **** 	dst->father = src->father;
 2311              		.loc 1 299 0
 2312 006e 2B69     		ldr	r3, [r5, #16]
 2313 0070 2361     		str	r3, [r4, #16]
 300:sxmlc/sxmlc.c **** 	dst->user = src->user;
 2314              		.loc 1 300 0
 2315 0072 6B6A     		ldr	r3, [r5, #36]
 2316 0074 6362     		str	r3, [r4, #36]
 301:sxmlc/sxmlc.c **** 	dst->active = src->active;
 2317              		.loc 1 301 0
 2318 0076 2B6A     		ldr	r3, [r5, #32]
 2319 0078 2362     		str	r3, [r4, #32]
 304:sxmlc/sxmlc.c **** 	if (copy_children && src->n_children > 0) {
 2320              		.loc 1 304 0
 2321 007a B9F1000F 		cmp	r9, #0
 2322 007e 1CD1     		bne	.L357
 2323 0080 CEE7     		b	.L358
 2324              	.LVL260:
 2325              	.L360:
 2326 0082 0C23     		movs	r3, #12
 2327 0084 7B43     		muls	r3, r7, r3
 291:sxmlc/sxmlc.c **** 			dst->attributes[i].name = sx_strdup(src->attributes[i].name);
 2328              		.loc 1 291 0
 2329 0086 AA68     		ldr	r2, [r5, #8]
 2330 0088 D058     		ldr	r0, [r2, r3]
 2331 008a 02EB0308 		add	r8, r2, r3
 2332 008e FFF7FEFF 		bl	strdup
 2333              	.LVL261:
 2334 0092 46F8080C 		str	r0, [r6, #-8]
 2335 0096 8246     		mov	r10, r0
 292:sxmlc/sxmlc.c **** 			dst->attributes[i].value = sx_strdup(src->attributes[i].value);
 2336              		.loc 1 292 0
 2337 0098 D8F80400 		ldr	r0, [r8, #4]
 2338 009c FFF7FEFF 		bl	strdup
 2339              	.LVL262:
 2340 00a0 46F8040C 		str	r0, [r6, #-4]
 293:sxmlc/sxmlc.c **** 			if (dst->attributes[i].name == NULL || dst->attributes[i].value == NULL) goto copy_err;
 2341              		.loc 1 293 0
 2342 00a4 BAF1000F 		cmp	r10, #0
 2343 00a8 21D0     		beq	.L353
 2344 00aa 0C36     		adds	r6, r6, #12
 293:sxmlc/sxmlc.c **** 			if (dst->attributes[i].name == NULL || dst->attributes[i].value == NULL) goto copy_err;
 2345              		.loc 1 293 0 is_stmt 0 discriminator 1
 2346 00ac F8B1     		cbz	r0, .L353
 294:sxmlc/sxmlc.c **** 			dst->attributes[i].active = src->attributes[i].active;
 2347              		.loc 1 294 0 is_stmt 1
 2348 00ae D8F80830 		ldr	r3, [r8, #8]
 290:sxmlc/sxmlc.c **** 		for (i = 0; i < src->n_attributes; i++) {
 2349              		.loc 1 290 0
 2350 00b2 0137     		adds	r7, r7, #1
 2351              	.LVL263:
 294:sxmlc/sxmlc.c **** 			dst->attributes[i].active = src->attributes[i].active;
 2352              		.loc 1 294 0
 2353 00b4 46F80C3C 		str	r3, [r6, #-12]
 2354 00b8 D4E7     		b	.L359
 2355              	.LVL264:
 2356              	.L357:
 304:sxmlc/sxmlc.c **** 	if (copy_children && src->n_children > 0) {
 2357              		.loc 1 304 0 discriminator 1
 2358 00ba AE69     		ldr	r6, [r5, #24]
 2359 00bc 002E     		cmp	r6, #0
 2360 00be AFDD     		ble	.L358
 305:sxmlc/sxmlc.c **** 		dst->children = (XMLNode**)__calloc(src->n_children, sizeof(XMLNode*));
 2361              		.loc 1 305 0
 2362 00c0 3046     		mov	r0, r6
 2363 00c2 0421     		movs	r1, #4
 2364 00c4 FFF7FEFF 		bl	calloc
 2365              	.LVL265:
 2366 00c8 6061     		str	r0, [r4, #20]
 306:sxmlc/sxmlc.c **** 		if (dst->children == NULL) goto copy_err;
 2367              		.loc 1 306 0
 2368 00ca 80B1     		cbz	r0, .L353
 307:sxmlc/sxmlc.c **** 		dst->n_children = src->n_children;
 2369              		.loc 1 307 0
 2370 00cc A661     		str	r6, [r4, #24]
 2371              	.LVL266:
 308:sxmlc/sxmlc.c **** 		for (i = 0; i < src->n_children; i++) {
 2372              		.loc 1 308 0
 2373 00ce 0026     		movs	r6, #0
 2374              	.LVL267:
 2375              	.L361:
 308:sxmlc/sxmlc.c **** 		for (i = 0; i < src->n_children; i++) {
 2376              		.loc 1 308 0 is_stmt 0 discriminator 1
 2377 00d0 AB69     		ldr	r3, [r5, #24]
 2378 00d2 9E42     		cmp	r6, r3
 2379 00d4 A4DA     		bge	.L358
 309:sxmlc/sxmlc.c **** 			if (!XMLNode_copy(dst->children[i], src->children[i], true)) goto copy_err;
 2380              		.loc 1 309 0 is_stmt 1
 2381 00d6 6269     		ldr	r2, [r4, #20]
 2382 00d8 6B69     		ldr	r3, [r5, #20]
 2383 00da 52F82600 		ldr	r0, [r2, r6, lsl #2]
 2384 00de 53F82610 		ldr	r1, [r3, r6, lsl #2]
 2385 00e2 0122     		movs	r2, #1
 2386 00e4 FFF7FEFF 		bl	XMLNode_copy
 2387              	.LVL268:
 2388 00e8 08B1     		cbz	r0, .L353
 308:sxmlc/sxmlc.c **** 		for (i = 0; i < src->n_children; i++) {
 2389              		.loc 1 308 0
 2390 00ea 0136     		adds	r6, r6, #1
 2391              	.LVL269:
 2392 00ec F0E7     		b	.L361
 2393              	.LVL270:
 2394              	.L353:
 2395              	.LDL1:
 316:sxmlc/sxmlc.c **** 	(void)XMLNode_free(dst);
 2396              		.loc 1 316 0
 2397 00ee 2046     		mov	r0, r4
 2398 00f0 FFF7FEFF 		bl	XMLNode_free
 2399              	.LVL271:
 2400              	.L364:
 265:sxmlc/sxmlc.c **** 		return false;
 2401              		.loc 1 265 0
 2402 00f4 0020     		movs	r0, #0
 319:sxmlc/sxmlc.c **** }
 2403              		.loc 1 319 0
 2404 00f6 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 2405              	.LVL272:
 2406              	.L390:
 2407 00fa 00BF     		.align	2
 2408              	.L389:
 2409 00fc 22057719 		.word	427230498
 2410              		.cfi_endproc
 2411              	.LFE9:
 2413              		.section	.text.XMLNode_dup,"ax",%progbits
 2414              		.align	1
 2415              		.global	XMLNode_dup
 2416              		.thumb
 2417              		.thumb_func
 2419              	XMLNode_dup:
 2420              	.LFB7:
 221:sxmlc/sxmlc.c **** {
 2421              		.loc 1 221 0
 2422              		.cfi_startproc
 2423              		@ args = 0, pretend = 0, frame = 0
 2424              		@ frame_needed = 0, uses_anonymous_args = 0
 2425              	.LVL273:
 2426 0000 70B5     		push	{r4, r5, r6, lr}
 2427              		.cfi_def_cfa_offset 16
 2428              		.cfi_offset 4, -16
 2429              		.cfi_offset 5, -12
 2430              		.cfi_offset 6, -8
 2431              		.cfi_offset 14, -4
 221:sxmlc/sxmlc.c **** {
 2432              		.loc 1 221 0
 2433 0002 0E46     		mov	r6, r1
 224:sxmlc/sxmlc.c **** 	if (node == NULL)
 2434              		.loc 1 224 0
 2435 0004 0546     		mov	r5, r0
 2436 0006 08B9     		cbnz	r0, .L392
 2437              	.LVL274:
 2438              	.L394:
 225:sxmlc/sxmlc.c **** 		return NULL;
 2439              		.loc 1 225 0
 2440 0008 0020     		movs	r0, #0
 2441 000a 70BD     		pop	{r4, r5, r6, pc}
 2442              	.LVL275:
 2443              	.L392:
 227:sxmlc/sxmlc.c **** 	n = (XMLNode*)__calloc(1, sizeof(XMLNode));
 2444              		.loc 1 227 0
 2445 000c 0120     		movs	r0, #1
 2446              	.LVL276:
 2447 000e 2C21     		movs	r1, #44
 2448              	.LVL277:
 2449 0010 FFF7FEFF 		bl	calloc
 2450              	.LVL278:
 228:sxmlc/sxmlc.c **** 	if (n == NULL)
 2451              		.loc 1 228 0
 2452 0014 0446     		mov	r4, r0
 2453 0016 0028     		cmp	r0, #0
 2454 0018 F6D0     		beq	.L394
 231:sxmlc/sxmlc.c **** 	XMLNode_init(n);
 2455              		.loc 1 231 0
 2456 001a FFF7FEFF 		bl	XMLNode_init
 2457              	.LVL279:
 232:sxmlc/sxmlc.c **** 	if (!XMLNode_copy(n, node, copy_children)) {
 2458              		.loc 1 232 0
 2459 001e 2946     		mov	r1, r5
 2460 0020 2046     		mov	r0, r4
 2461 0022 3246     		mov	r2, r6
 2462 0024 FFF7FEFF 		bl	XMLNode_copy
 2463              	.LVL280:
 2464 0028 0546     		mov	r5, r0
 2465              	.LVL281:
 233:sxmlc/sxmlc.c **** 		XMLNode_free(n);
 2466              		.loc 1 233 0
 2467 002a 2046     		mov	r0, r4
 232:sxmlc/sxmlc.c **** 	if (!XMLNode_copy(n, node, copy_children)) {
 2468              		.loc 1 232 0
 2469 002c 15B9     		cbnz	r5, .L395
 233:sxmlc/sxmlc.c **** 		XMLNode_free(n);
 2470              		.loc 1 233 0
 2471 002e FFF7FEFF 		bl	XMLNode_free
 2472              	.LVL282:
 2473 0032 E9E7     		b	.L394
 2474              	.LVL283:
 2475              	.L395:
 239:sxmlc/sxmlc.c **** }
 2476              		.loc 1 239 0
 2477 0034 70BD     		pop	{r4, r5, r6, pc}
 2478              		.cfi_endproc
 2479              	.LFE7:
 2481              		.section	.text.XMLNode_remove_child,"ax",%progbits
 2482              		.align	1
 2483              		.global	XMLNode_remove_child
 2484              		.thumb
 2485              		.thumb_func
 2487              	XMLNode_remove_child:
 2488              	.LFB23:
 586:sxmlc/sxmlc.c **** {
 2489              		.loc 1 586 0
 2490              		.cfi_startproc
 2491              		@ args = 0, pretend = 0, frame = 0
 2492              		@ frame_needed = 0, uses_anonymous_args = 0
 2493              	.LVL284:
 2494 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 2495              		.cfi_def_cfa_offset 24
 2496              		.cfi_offset 4, -24
 2497              		.cfi_offset 5, -20
 2498              		.cfi_offset 6, -16
 2499              		.cfi_offset 7, -12
 2500              		.cfi_offset 8, -8
 2501              		.cfi_offset 14, -4
 586:sxmlc/sxmlc.c **** {
 2502              		.loc 1 586 0
 2503 0004 0D46     		mov	r5, r1
 2504 0006 9046     		mov	r8, r2
 590:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || i_child < 0 || i_child >= node->n_childre
 2505              		.loc 1 590 0
 2506 0008 0446     		mov	r4, r0
 2507 000a 18B9     		cbnz	r0, .L400
 2508              	.LVL285:
 2509              	.L402:
 591:sxmlc/sxmlc.c **** 		return -1;
 2510              		.loc 1 591 0
 2511 000c 4FF0FF30 		mov	r0, #-1
 2512 0010 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2513              	.LVL286:
 2514              	.L400:
 590:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || i_child < 0 || i_child >= node->n_childre
 2515              		.loc 1 590 0 discriminator 1
 2516 0014 836A     		ldr	r3, [r0, #40]
 2517 0016 264A     		ldr	r2, .L428
 2518              	.LVL287:
 2519 0018 9342     		cmp	r3, r2
 2520 001a F7D1     		bne	.L402
 2521 001c 0029     		cmp	r1, #0
 2522 001e F5DB     		blt	.L402
 2523 0020 8069     		ldr	r0, [r0, #24]
 2524              	.LVL288:
 2525 0022 8142     		cmp	r1, r0
 2526 0024 F2DA     		bge	.L402
 590:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || i_child < 0 || i_child >= node->n_childre
 2527              		.loc 1 590 0 is_stmt 0
 2528 0026 0023     		movs	r3, #0
 2529              	.LVL289:
 2530              	.L403:
 594:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_children; i++) {
 2531              		.loc 1 594 0 is_stmt 1 discriminator 1
 2532 0028 8342     		cmp	r3, r0
 2533 002a EFDA     		bge	.L402
 595:sxmlc/sxmlc.c **** 		if (!node->children[i]->active)
 2534              		.loc 1 595 0
 2535 002c 6269     		ldr	r2, [r4, #20]
 2536 002e 52F82320 		ldr	r2, [r2, r3, lsl #2]
 2537 0032 126A     		ldr	r2, [r2, #32]
 2538 0034 0AB9     		cbnz	r2, .L404
 596:sxmlc/sxmlc.c **** 			i_child++;
 2539              		.loc 1 596 0
 2540 0036 0135     		adds	r5, r5, #1
 2541              	.LVL290:
 2542 0038 04E0     		b	.L405
 2543              	.L404:
 597:sxmlc/sxmlc.c **** 		else if (i == i_child)
 2544              		.loc 1 597 0
 2545 003a AB42     		cmp	r3, r5
 2546 003c 02D1     		bne	.L405
 604:sxmlc/sxmlc.c **** 	if (node->n_children == 1)
 2547              		.loc 1 604 0
 2548 003e 0128     		cmp	r0, #1
 2549 0040 02D1     		bne	.L426
 2550 0042 08E0     		b	.L427
 2551              	.L405:
 594:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_children; i++) {
 2552              		.loc 1 594 0
 2553 0044 0133     		adds	r3, r3, #1
 2554              	.LVL291:
 2555 0046 EFE7     		b	.L403
 2556              	.L426:
 607:sxmlc/sxmlc.c **** 		pt = (XMLNode**)__malloc((node->n_children - 1) * sizeof(XMLNode*));
 2557              		.loc 1 607 0
 2558 0048 0138     		subs	r0, r0, #1
 2559 004a 8000     		lsls	r0, r0, #2
 2560 004c FFF7FEFF 		bl	malloc
 2561              	.LVL292:
 608:sxmlc/sxmlc.c **** 		if (pt == NULL)
 2562              		.loc 1 608 0
 2563 0050 0646     		mov	r6, r0
 2564 0052 08B9     		cbnz	r0, .L406
 2565 0054 DAE7     		b	.L402
 2566              	.LVL293:
 2567              	.L427:
 605:sxmlc/sxmlc.c **** 		pt = NULL;
 2568              		.loc 1 605 0
 2569 0056 0026     		movs	r6, #0
 2570              	.LVL294:
 2571              	.L406:
 613:sxmlc/sxmlc.c **** 	(void)XMLNode_free(node->children[i_child]);
 2572              		.loc 1 613 0
 2573 0058 6369     		ldr	r3, [r4, #20]
 2574 005a AF00     		lsls	r7, r5, #2
 2575 005c 53F82500 		ldr	r0, [r3, r5, lsl #2]
 2576 0060 FFF7FEFF 		bl	XMLNode_free
 2577              	.LVL295:
 614:sxmlc/sxmlc.c **** 	if (free_child)
 2578              		.loc 1 614 0
 2579 0064 B8F1000F 		cmp	r8, #0
 2580 0068 04D0     		beq	.L410
 615:sxmlc/sxmlc.c **** 		__free(node->children[i_child]);
 2581              		.loc 1 615 0
 2582 006a 6369     		ldr	r3, [r4, #20]
 2583 006c 53F82500 		ldr	r0, [r3, r5, lsl #2]
 2584 0070 FFF7FEFF 		bl	free
 2585              	.LVL296:
 2586              	.L410:
 617:sxmlc/sxmlc.c **** 	if (pt != NULL) {
 2587              		.loc 1 617 0
 2588 0074 76B1     		cbz	r6, .L411
 618:sxmlc/sxmlc.c **** 		memcpy(pt, node->children, i_child * sizeof(XMLNode*));
 2589              		.loc 1 618 0
 2590 0076 6169     		ldr	r1, [r4, #20]
 2591 0078 3A46     		mov	r2, r7
 2592 007a 3046     		mov	r0, r6
 2593 007c FFF7FEFF 		bl	memcpy
 2594              	.LVL297:
 619:sxmlc/sxmlc.c **** 		memcpy(&pt[i_child], &node->children[i_child + 1], (node->n_children - i_child - 1) * sizeof(XMLN
 2595              		.loc 1 619 0
 2596 0080 A369     		ldr	r3, [r4, #24]
 2597 0082 391D     		adds	r1, r7, #4
 2598 0084 5D1B     		subs	r5, r3, r5
 2599              	.LVL298:
 2600 0086 6369     		ldr	r3, [r4, #20]
 2601 0088 6A1E     		subs	r2, r5, #1
 2602 008a F019     		adds	r0, r6, r7
 2603 008c 1944     		add	r1, r1, r3
 2604 008e 9200     		lsls	r2, r2, #2
 2605 0090 FFF7FEFF 		bl	memcpy
 2606              	.LVL299:
 2607              	.L411:
 621:sxmlc/sxmlc.c **** 	if (node->children != NULL)
 2608              		.loc 1 621 0
 2609 0094 6069     		ldr	r0, [r4, #20]
 2610 0096 08B1     		cbz	r0, .L412
 622:sxmlc/sxmlc.c **** 		__free(node->children);
 2611              		.loc 1 622 0
 2612 0098 FFF7FEFF 		bl	free
 2613              	.LVL300:
 2614              	.L412:
 624:sxmlc/sxmlc.c **** 	node->n_children--;
 2615              		.loc 1 624 0
 2616 009c A069     		ldr	r0, [r4, #24]
 623:sxmlc/sxmlc.c **** 	node->children = pt;
 2617              		.loc 1 623 0
 2618 009e 6661     		str	r6, [r4, #20]
 624:sxmlc/sxmlc.c **** 	node->n_children--;
 2619              		.loc 1 624 0
 2620 00a0 0138     		subs	r0, r0, #1
 2621 00a2 A061     		str	r0, [r4, #24]
 625:sxmlc/sxmlc.c **** 	if (node->n_children == 0)
 2622              		.loc 1 625 0
 2623 00a4 08B9     		cbnz	r0, .L401
 626:sxmlc/sxmlc.c **** 		node->tag_type = TAG_SELF;
 2624              		.loc 1 626 0
 2625 00a6 0323     		movs	r3, #3
 2626 00a8 2377     		strb	r3, [r4, #28]
 2627              	.L401:
 629:sxmlc/sxmlc.c **** }
 2628              		.loc 1 629 0
 2629 00aa BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 2630              	.LVL301:
 2631              	.L429:
 2632 00ae 00BF     		.align	2
 2633              	.L428:
 2634 00b0 22057719 		.word	427230498
 2635              		.cfi_endproc
 2636              	.LFE23:
 2638              		.section	.text.DOMXMLDoc_node_start,"ax",%progbits
 2639              		.align	1
 2640              		.global	DOMXMLDoc_node_start
 2641              		.thumb
 2642              		.thumb_func
 2644              	DOMXMLDoc_node_start:
 2645              	.LFB47:
1417:sxmlc/sxmlc.c **** {
 2646              		.loc 1 1417 0
 2647              		.cfi_startproc
 2648              		@ args = 0, pretend = 0, frame = 0
 2649              		@ frame_needed = 0, uses_anonymous_args = 0
 2650              	.LVL302:
 2651 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 2652              		.cfi_def_cfa_offset 24
 2653              		.cfi_offset 3, -24
 2654              		.cfi_offset 4, -20
 2655              		.cfi_offset 5, -16
 2656              		.cfi_offset 6, -12
 2657              		.cfi_offset 7, -8
 2658              		.cfi_offset 14, -4
1418:sxmlc/sxmlc.c **** 	DOM_through_SAX* dom = (DOM_through_SAX*)sd->user;
 2659              		.loc 1 1418 0
 2660 0002 8D68     		ldr	r5, [r1, #8]
 2661              	.LVL303:
1417:sxmlc/sxmlc.c **** {
 2662              		.loc 1 1417 0
 2663 0004 0E46     		mov	r6, r1
1422:sxmlc/sxmlc.c **** 	if ((new_node = XMLNode_dup(node, true)) == NULL) goto node_start_err; /* No real need to put 'tru
 2664              		.loc 1 1422 0
 2665 0006 0121     		movs	r1, #1
 2666              	.LVL304:
1417:sxmlc/sxmlc.c **** {
 2667              		.loc 1 1417 0
 2668 0008 0746     		mov	r7, r0
1422:sxmlc/sxmlc.c **** 	if ((new_node = XMLNode_dup(node, true)) == NULL) goto node_start_err; /* No real need to put 'tru
 2669              		.loc 1 1422 0
 2670 000a FFF7FEFF 		bl	XMLNode_dup
 2671              	.LVL305:
 2672 000e 0446     		mov	r4, r0
 2673 0010 20B3     		cbz	r0, .L431
1424:sxmlc/sxmlc.c **** 	if (dom->current == NULL) {
 2674              		.loc 1 1424 0
 2675 0012 6968     		ldr	r1, [r5, #4]
 2676 0014 A9B9     		cbnz	r1, .L432
1425:sxmlc/sxmlc.c **** 		if ((i = _add_node(&dom->doc->nodes, &dom->doc->n_nodes, new_node)) < 0) goto node_start_err;
 2677              		.loc 1 1425 0
 2678 0016 2968     		ldr	r1, [r5]
 2679 0018 2246     		mov	r2, r4
 2680 001a 01F58070 		add	r0, r1, #256
 2681              	.LVL306:
 2682 001e 01F58271 		add	r1, r1, #260
 2683 0022 FFF7FEFF 		bl	_add_node
 2684              	.LVL307:
 2685 0026 0028     		cmp	r0, #0
 2686 0028 18DB     		blt	.L431
1427:sxmlc/sxmlc.c **** 		if (dom->doc->i_root < 0 && (node->tag_type == TAG_FATHER || node->tag_type == TAG_SELF))
 2687              		.loc 1 1427 0
 2688 002a 2B68     		ldr	r3, [r5]
 2689 002c D3F80821 		ldr	r2, [r3, #264]
 2690 0030 002A     		cmp	r2, #0
 2691 0032 0EDA     		bge	.L434
1427:sxmlc/sxmlc.c **** 		if (dom->doc->i_root < 0 && (node->tag_type == TAG_FATHER || node->tag_type == TAG_SELF))
 2692              		.loc 1 1427 0 is_stmt 0 discriminator 1
 2693 0034 3A7F     		ldrb	r2, [r7, #28]	@ zero_extendqisi2
 2694 0036 023A     		subs	r2, r2, #2
 2695 0038 012A     		cmp	r2, #1
 2696 003a 0AD8     		bhi	.L434
1428:sxmlc/sxmlc.c **** 			dom->doc->i_root = i;
 2697              		.loc 1 1428 0 is_stmt 1
 2698 003c C3F80801 		str	r0, [r3, #264]
 2699 0040 07E0     		b	.L434
 2700              	.LVL308:
 2701              	.L432:
1430:sxmlc/sxmlc.c **** 		if (_add_node(&dom->current->children, &dom->current->n_children, new_node) < 0) goto node_start_
 2702              		.loc 1 1430 0
 2703 0042 01F11400 		add	r0, r1, #20
 2704              	.LVL309:
 2705 0046 2246     		mov	r2, r4
 2706 0048 1831     		adds	r1, r1, #24
 2707 004a FFF7FEFF 		bl	_add_node
 2708              	.LVL310:
 2709 004e 0028     		cmp	r0, #0
 2710 0050 04DB     		blt	.L431
 2711              	.L434:
1433:sxmlc/sxmlc.c **** 	new_node->father = dom->current;
 2712              		.loc 1 1433 0
 2713 0052 6B68     		ldr	r3, [r5, #4]
1436:sxmlc/sxmlc.c **** 	return true;
 2714              		.loc 1 1436 0
 2715 0054 0120     		movs	r0, #1
1433:sxmlc/sxmlc.c **** 	new_node->father = dom->current;
 2716              		.loc 1 1433 0
 2717 0056 2361     		str	r3, [r4, #16]
1434:sxmlc/sxmlc.c **** 	dom->current = new_node;
 2718              		.loc 1 1434 0
 2719 0058 6C60     		str	r4, [r5, #4]
1436:sxmlc/sxmlc.c **** 	return true;
 2720              		.loc 1 1436 0
 2721 005a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2722              	.LVL311:
 2723              	.L431:
 2724              	.LDL2:
1439:sxmlc/sxmlc.c **** 	dom->error = PARSE_ERR_MEMORY;
 2725              		.loc 1 1439 0
 2726 005c FF23     		movs	r3, #255
 2727 005e 2B72     		strb	r3, [r5, #8]
1440:sxmlc/sxmlc.c **** 	dom->line_error = sd->line_num;
 2728              		.loc 1 1440 0
 2729 0060 7368     		ldr	r3, [r6, #4]
1441:sxmlc/sxmlc.c **** 	(void)XMLNode_free(new_node);
 2730              		.loc 1 1441 0
 2731 0062 2046     		mov	r0, r4
1440:sxmlc/sxmlc.c **** 	dom->line_error = sd->line_num;
 2732              		.loc 1 1440 0
 2733 0064 EB60     		str	r3, [r5, #12]
1441:sxmlc/sxmlc.c **** 	(void)XMLNode_free(new_node);
 2734              		.loc 1 1441 0
 2735 0066 FFF7FEFF 		bl	XMLNode_free
 2736              	.LVL312:
1442:sxmlc/sxmlc.c **** 	__free(new_node);
 2737              		.loc 1 1442 0
 2738 006a 2046     		mov	r0, r4
 2739 006c FFF7FEFF 		bl	free
 2740              	.LVL313:
1444:sxmlc/sxmlc.c **** 	return false;
 2741              		.loc 1 1444 0
 2742 0070 0020     		movs	r0, #0
1445:sxmlc/sxmlc.c **** }
 2743              		.loc 1 1445 0
 2744 0072 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2745              		.cfi_endproc
 2746              	.LFE47:
 2748              		.section	.text.DOMXMLDoc_node_text,"ax",%progbits
 2749              		.align	1
 2750              		.global	DOMXMLDoc_node_text
 2751              		.thumb
 2752              		.thumb_func
 2754              	DOMXMLDoc_node_text:
 2755              	.LFB49:
1470:sxmlc/sxmlc.c **** {
 2756              		.loc 1 1470 0
 2757              		.cfi_startproc
 2758              		@ args = 0, pretend = 0, frame = 0
 2759              		@ frame_needed = 0, uses_anonymous_args = 0
 2760              	.LVL314:
 2761 0000 2DE9F843 		push	{r3, r4, r5, r6, r7, r8, r9, lr}
 2762              		.cfi_def_cfa_offset 32
 2763              		.cfi_offset 3, -32
 2764              		.cfi_offset 4, -28
 2765              		.cfi_offset 5, -24
 2766              		.cfi_offset 6, -20
 2767              		.cfi_offset 7, -16
 2768              		.cfi_offset 8, -12
 2769              		.cfi_offset 9, -8
 2770              		.cfi_offset 14, -4
1472:sxmlc/sxmlc.c **** 	DOM_through_SAX* dom = (DOM_through_SAX*)sd->user;
 2771              		.loc 1 1472 0
 2772 0004 8C68     		ldr	r4, [r1, #8]
 2773              	.LVL315:
1470:sxmlc/sxmlc.c **** {
 2774              		.loc 1 1470 0
 2775 0006 0746     		mov	r7, r0
1481:sxmlc/sxmlc.c **** 	if (dom->current == NULL) {
 2776              		.loc 1 1481 0
 2777 0008 6368     		ldr	r3, [r4, #4]
1470:sxmlc/sxmlc.c **** {
 2778              		.loc 1 1470 0
 2779 000a 0E46     		mov	r6, r1
1481:sxmlc/sxmlc.c **** 	if (dom->current == NULL) {
 2780              		.loc 1 1481 0
 2781 000c 93B9     		cbnz	r3, .L441
1482:sxmlc/sxmlc.c **** 		while(*p != NULC && sx_isspace(*p++)) ;
 2782              		.loc 1 1482 0
 2783 000e 314B     		ldr	r3, .L468
 2784 0010 1968     		ldr	r1, [r3]
 2785              	.LVL316:
 2786              	.L443:
 2787 0012 3B46     		mov	r3, r7
 2788              	.LVL317:
1482:sxmlc/sxmlc.c **** 		while(*p != NULC && sx_isspace(*p++)) ;
 2789              		.loc 1 1482 0 is_stmt 0 discriminator 1
 2790 0014 17F8012B 		ldrb	r2, [r7], #1	@ zero_extendqisi2
 2791 0018 22B1     		cbz	r2, .L442
1482:sxmlc/sxmlc.c **** 		while(*p != NULC && sx_isspace(*p++)) ;
 2792              		.loc 1 1482 0 discriminator 2
 2793 001a 0A44     		add	r2, r2, r1
 2794 001c 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 2795 001e 3B46     		mov	r3, r7
 2796              	.LVL318:
 2797 0020 1207     		lsls	r2, r2, #28
 2798 0022 F6D4     		bmi	.L443
 2799              	.L442:
1483:sxmlc/sxmlc.c **** 		if (*p == NULC) /* Only spaces => probably pretty-printing */
 2800              		.loc 1 1483 0 is_stmt 1
 2801 0024 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2802              	.LVL319:
 2803 0026 002B     		cmp	r3, #0
 2804 0028 50D0     		beq	.L451
1485:sxmlc/sxmlc.c **** 		dom->error = PARSE_ERR_TEXT_OUTSIDE_NODE;
 2805              		.loc 1 1485 0
 2806 002a FB23     		movs	r3, #251
 2807 002c 2372     		strb	r3, [r4, #8]
1486:sxmlc/sxmlc.c **** 		dom->line_error = sd->line_num;
 2808              		.loc 1 1486 0
 2809 002e 7368     		ldr	r3, [r6, #4]
 2810 0030 E360     		str	r3, [r4, #12]
 2811 0032 10E0     		b	.L467
 2812              	.LVL320:
 2813              	.L441:
1490:sxmlc/sxmlc.c **** 	if (dom->text_as_nodes) {
 2814              		.loc 1 1490 0
 2815 0034 2569     		ldr	r5, [r4, #16]
 2816 0036 25B3     		cbz	r5, .L445
 2817              	.LBB9:
1491:sxmlc/sxmlc.c **** 		XMLNode* new_node = XMLNode_allocN(1);
 2818              		.loc 1 1491 0
 2819 0038 0120     		movs	r0, #1
 2820              	.LVL321:
 2821 003a FFF7FEFF 		bl	XMLNode_allocN
 2822              	.LVL322:
1492:sxmlc/sxmlc.c **** 		if (new_node == NULL || (new_node->text = sx_strdup(text)) == NULL
 2823              		.loc 1 1492 0
 2824 003e 0546     		mov	r5, r0
 2825 0040 58B9     		cbnz	r0, .L446
 2826              	.LVL323:
 2827              	.L447:
1494:sxmlc/sxmlc.c **** 			dom->error = PARSE_ERR_MEMORY;
 2828              		.loc 1 1494 0
 2829 0042 FF23     		movs	r3, #255
 2830 0044 2372     		strb	r3, [r4, #8]
1495:sxmlc/sxmlc.c **** 			dom->line_error = sd->line_num;
 2831              		.loc 1 1495 0
 2832 0046 7368     		ldr	r3, [r6, #4]
1496:sxmlc/sxmlc.c **** 			(void)XMLNode_free(new_node);
 2833              		.loc 1 1496 0
 2834 0048 2846     		mov	r0, r5
1495:sxmlc/sxmlc.c **** 			dom->line_error = sd->line_num;
 2835              		.loc 1 1495 0
 2836 004a E360     		str	r3, [r4, #12]
1496:sxmlc/sxmlc.c **** 			(void)XMLNode_free(new_node);
 2837              		.loc 1 1496 0
 2838 004c FFF7FEFF 		bl	XMLNode_free
 2839              	.LVL324:
1497:sxmlc/sxmlc.c **** 			__free(new_node);
 2840              		.loc 1 1497 0
 2841 0050 2846     		mov	r0, r5
 2842 0052 FFF7FEFF 		bl	free
 2843              	.LVL325:
 2844              	.L467:
1498:sxmlc/sxmlc.c **** 			return false;
 2845              		.loc 1 1498 0
 2846 0056 0025     		movs	r5, #0
 2847 0058 39E0     		b	.L444
 2848              	.LVL326:
 2849              	.L446:
1492:sxmlc/sxmlc.c **** 		if (new_node == NULL || (new_node->text = sx_strdup(text)) == NULL
 2850              		.loc 1 1492 0 discriminator 1
 2851 005a 3846     		mov	r0, r7
 2852              	.LVL327:
 2853 005c FFF7FEFF 		bl	strdup
 2854              	.LVL328:
 2855 0060 6860     		str	r0, [r5, #4]
 2856 0062 0028     		cmp	r0, #0
 2857 0064 EDD0     		beq	.L447
1493:sxmlc/sxmlc.c **** 			|| _add_node(&dom->current->children, &dom->current->n_children, new_node) < 0) {
 2858              		.loc 1 1493 0
 2859 0066 6168     		ldr	r1, [r4, #4]
 2860 0068 2A46     		mov	r2, r5
 2861 006a 01F11400 		add	r0, r1, #20
 2862 006e 1831     		adds	r1, r1, #24
 2863 0070 FFF7FEFF 		bl	_add_node
 2864              	.LVL329:
 2865 0074 0028     		cmp	r0, #0
 2866 0076 E4DB     		blt	.L447
1500:sxmlc/sxmlc.c **** 		new_node->tag_type = TAG_TEXT;
 2867              		.loc 1 1500 0
 2868 0078 0923     		movs	r3, #9
 2869 007a 2B77     		strb	r3, [r5, #28]
1501:sxmlc/sxmlc.c **** 		new_node->father = dom->current;
 2870              		.loc 1 1501 0
 2871 007c 6368     		ldr	r3, [r4, #4]
 2872 007e 2B61     		str	r3, [r5, #16]
 2873 0080 24E0     		b	.L451
 2874              	.LVL330:
 2875              	.L445:
 2876              	.LBE9:
1506:sxmlc/sxmlc.c **** 		if (dom->current->text == NULL) {
 2877              		.loc 1 1506 0
 2878 0082 D3F80480 		ldr	r8, [r3, #4]
 2879 0086 B8F1000F 		cmp	r8, #0
 2880 008a 04D1     		bne	.L448
1507:sxmlc/sxmlc.c **** 			p = sx_strdup(text);
 2881              		.loc 1 1507 0
 2882 008c FFF7FEFF 		bl	strdup
 2883              	.LVL331:
1513:sxmlc/sxmlc.c **** 		if (p == NULL) {
 2884              		.loc 1 1513 0
 2885 0090 8046     		mov	r8, r0
 2886 0092 C0B9     		cbnz	r0, .L450
 2887 0094 12E0     		b	.L449
 2888              	.LVL332:
 2889              	.L448:
1509:sxmlc/sxmlc.c **** 			p = (SXML_CHAR*)__realloc(dom->current->text, (sx_strlen(dom->current->text) + sx_strlen(text) +
 2890              		.loc 1 1509 0
 2891 0096 4046     		mov	r0, r8
 2892              	.LVL333:
 2893 0098 FFF7FEFF 		bl	strlen
 2894              	.LVL334:
 2895 009c 8146     		mov	r9, r0
 2896 009e 3846     		mov	r0, r7
 2897 00a0 FFF7FEFF 		bl	strlen
 2898              	.LVL335:
 2899 00a4 09EB0001 		add	r1, r9, r0
 2900 00a8 0131     		adds	r1, r1, #1
 2901 00aa 4046     		mov	r0, r8
 2902 00ac FFF7FEFF 		bl	realloc
 2903              	.LVL336:
1510:sxmlc/sxmlc.c **** 			if (p != NULL)
 2904              		.loc 1 1510 0
 2905 00b0 8046     		mov	r8, r0
 2906 00b2 18B1     		cbz	r0, .L449
1511:sxmlc/sxmlc.c **** 				sx_strcat(p, text);
 2907              		.loc 1 1511 0
 2908 00b4 3946     		mov	r1, r7
 2909 00b6 FFF7FEFF 		bl	strcat
 2910              	.LVL337:
 2911 00ba 04E0     		b	.L450
 2912              	.LVL338:
 2913              	.L449:
1514:sxmlc/sxmlc.c **** 			dom->error = PARSE_ERR_MEMORY;
 2914              		.loc 1 1514 0
 2915 00bc FF23     		movs	r3, #255
 2916 00be 2372     		strb	r3, [r4, #8]
1515:sxmlc/sxmlc.c **** 			dom->line_error = sd->line_num;
 2917              		.loc 1 1515 0
 2918 00c0 7368     		ldr	r3, [r6, #4]
 2919 00c2 E360     		str	r3, [r4, #12]
1516:sxmlc/sxmlc.c **** 			return false;
 2920              		.loc 1 1516 0
 2921 00c4 03E0     		b	.L444
 2922              	.LVL339:
 2923              	.L450:
1519:sxmlc/sxmlc.c **** 		dom->current->text = p;
 2924              		.loc 1 1519 0
 2925 00c6 6368     		ldr	r3, [r4, #4]
 2926 00c8 C3F80480 		str	r8, [r3, #4]
 2927              	.LVL340:
 2928              	.L451:
1484:sxmlc/sxmlc.c **** 			return true;
 2929              		.loc 1 1484 0
 2930 00cc 0125     		movs	r5, #1
 2931              	.L444:
1523:sxmlc/sxmlc.c **** }
 2932              		.loc 1 1523 0
 2933 00ce 2846     		mov	r0, r5
 2934 00d0 BDE8F883 		pop	{r3, r4, r5, r6, r7, r8, r9, pc}
 2935              	.LVL341:
 2936              	.L469:
 2937              		.align	2
 2938              	.L468:
 2939 00d4 00000000 		.word	__ctype_ptr__
 2940              		.cfi_endproc
 2941              	.LFE49:
 2943              		.section	.text.XMLNode_equal,"ax",%progbits
 2944              		.align	1
 2945              		.global	XMLNode_equal
 2946              		.thumb
 2947              		.thumb_func
 2949              	XMLNode_equal:
 2950              	.LFB25:
 653:sxmlc/sxmlc.c **** {
 2951              		.loc 1 653 0
 2952              		.cfi_startproc
 2953              		@ args = 0, pretend = 0, frame = 0
 2954              		@ frame_needed = 0, uses_anonymous_args = 0
 2955              	.LVL342:
 656:sxmlc/sxmlc.c **** 	if (node1 == node2)
 2956              		.loc 1 656 0
 2957 0000 8842     		cmp	r0, r1
 653:sxmlc/sxmlc.c **** {
 2958              		.loc 1 653 0
 2959 0002 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 2960              		.cfi_def_cfa_offset 32
 2961              		.cfi_offset 4, -32
 2962              		.cfi_offset 5, -28
 2963              		.cfi_offset 6, -24
 2964              		.cfi_offset 7, -20
 2965              		.cfi_offset 8, -16
 2966              		.cfi_offset 9, -12
 2967              		.cfi_offset 10, -8
 2968              		.cfi_offset 14, -4
 653:sxmlc/sxmlc.c **** {
 2969              		.loc 1 653 0
 2970 0006 0546     		mov	r5, r0
 2971 0008 0E46     		mov	r6, r1
 656:sxmlc/sxmlc.c **** 	if (node1 == node2)
 2972              		.loc 1 656 0
 2973 000a 53D0     		beq	.L478
 659:sxmlc/sxmlc.c **** 	if (node1 == NULL || node2 == NULL || node1->init_value != XML_INIT_DONE || node2->init_value != X
 2974              		.loc 1 659 0
 2975 000c 0028     		cmp	r0, #0
 2976 000e 53D0     		beq	.L479
 659:sxmlc/sxmlc.c **** 	if (node1 == NULL || node2 == NULL || node1->init_value != XML_INIT_DONE || node2->init_value != X
 2977              		.loc 1 659 0 is_stmt 0 discriminator 1
 2978 0010 0029     		cmp	r1, #0
 2979 0012 53D0     		beq	.L480
 2980 0014 836A     		ldr	r3, [r0, #40]
 2981 0016 2C4A     		ldr	r2, .L491
 2982 0018 9342     		cmp	r3, r2
 2983 001a 51D1     		bne	.L483
 2984 001c 8A6A     		ldr	r2, [r1, #40]
 2985 001e 9A42     		cmp	r2, r3
 2986 0020 4ED1     		bne	.L483
 662:sxmlc/sxmlc.c **** 	if (sx_strcmp(node1->tag, node2->tag))
 2987              		.loc 1 662 0 is_stmt 1
 2988 0022 0068     		ldr	r0, [r0]
 2989              	.LVL343:
 2990 0024 0968     		ldr	r1, [r1]
 2991              	.LVL344:
 2992 0026 FFF7FEFF 		bl	strcmp
 2993              	.LVL345:
 2994 002a 0446     		mov	r4, r0
 2995 002c 0028     		cmp	r0, #0
 2996 002e 47D1     		bne	.L483
 666:sxmlc/sxmlc.c **** 	for (i = 0; i < node1->n_attributes; i++) {
 2997              		.loc 1 666 0
 2998 0030 D5F80CA0 		ldr	r10, [r5, #12]
 2999 0034 0746     		mov	r7, r0
 3000              	.L472:
 3001              	.LVL346:
 666:sxmlc/sxmlc.c **** 	for (i = 0; i < node1->n_attributes; i++) {
 3002              		.loc 1 666 0 is_stmt 0 discriminator 1
 3003 0036 5745     		cmp	r7, r10
 3004 0038 1BDA     		bge	.L490
 3005 003a 4FF00C09 		mov	r9, #12
 3006 003e 09FB07F3 		mul	r3, r9, r7
 667:sxmlc/sxmlc.c **** 		if (!node1->attributes[i].active)
 3007              		.loc 1 667 0 is_stmt 1
 3008 0042 AA68     		ldr	r2, [r5, #8]
 3009 0044 02EB0308 		add	r8, r2, r3
 3010 0048 D8F80810 		ldr	r1, [r8, #8]
 3011 004c 79B1     		cbz	r1, .L473
 669:sxmlc/sxmlc.c **** 		j = XMLNode_search_attribute(node2, node1->attributes[i].name, 0);
 3012              		.loc 1 669 0
 3013 004e D158     		ldr	r1, [r2, r3]
 3014 0050 3046     		mov	r0, r6
 3015 0052 0022     		movs	r2, #0
 3016 0054 FFF7FEFF 		bl	XMLNode_search_attribute
 3017              	.LVL347:
 670:sxmlc/sxmlc.c **** 		if (j < 0)
 3018              		.loc 1 670 0
 3019 0058 0028     		cmp	r0, #0
 3020 005a 32DB     		blt	.L471
 672:sxmlc/sxmlc.c **** 		if (sx_strcmp(node1->attributes[i].value, node2->attributes[j].value))
 3021              		.loc 1 672 0
 3022 005c B368     		ldr	r3, [r6, #8]
 3023 005e 09FB0033 		mla	r3, r9, r0, r3
 3024 0062 D8F80400 		ldr	r0, [r8, #4]
 3025              	.LVL348:
 3026 0066 5968     		ldr	r1, [r3, #4]
 3027 0068 FFF7FEFF 		bl	strcmp
 3028              	.LVL349:
 3029 006c 48BB     		cbnz	r0, .L471
 3030              	.L473:
 666:sxmlc/sxmlc.c **** 	for (i = 0; i < node1->n_attributes; i++) {
 3031              		.loc 1 666 0
 3032 006e 0137     		adds	r7, r7, #1
 3033              	.LVL350:
 3034 0070 E1E7     		b	.L472
 3035              	.L490:
 677:sxmlc/sxmlc.c **** 	for (i = 0; i < node2->n_attributes; i++) {
 3036              		.loc 1 677 0
 3037 0072 D6F80CA0 		ldr	r10, [r6, #12]
 3038 0076 0027     		movs	r7, #0
 3039              	.LVL351:
 3040              	.L475:
 677:sxmlc/sxmlc.c **** 	for (i = 0; i < node2->n_attributes; i++) {
 3041              		.loc 1 677 0 is_stmt 0 discriminator 1
 3042 0078 5745     		cmp	r7, r10
 3043 007a 1BDA     		bge	.L478
 3044 007c 4FF00C09 		mov	r9, #12
 3045 0080 09FB07F3 		mul	r3, r9, r7
 678:sxmlc/sxmlc.c **** 		if (!node2->attributes[i].active)
 3046              		.loc 1 678 0 is_stmt 1
 3047 0084 B268     		ldr	r2, [r6, #8]
 3048 0086 D118     		adds	r1, r2, r3
 3049 0088 8968     		ldr	r1, [r1, #8]
 3050 008a 89B1     		cbz	r1, .L476
 680:sxmlc/sxmlc.c **** 		j = XMLNode_search_attribute(node1, node2->attributes[i].name, 0);
 3051              		.loc 1 680 0
 3052 008c 52F80380 		ldr	r8, [r2, r3]
 3053 0090 2846     		mov	r0, r5
 3054 0092 4146     		mov	r1, r8
 3055 0094 0022     		movs	r2, #0
 3056 0096 FFF7FEFF 		bl	XMLNode_search_attribute
 3057              	.LVL352:
 681:sxmlc/sxmlc.c **** 		if (j < 0)
 3058              		.loc 1 681 0
 3059 009a 0028     		cmp	r0, #0
 3060 009c 11DB     		blt	.L471
 683:sxmlc/sxmlc.c **** 		if (sx_strcmp(node2->attributes[i].name, node1->attributes[j].name))
 3061              		.loc 1 683 0
 3062 009e 09FB00F9 		mul	r9, r9, r0
 3063 00a2 AB68     		ldr	r3, [r5, #8]
 3064 00a4 4046     		mov	r0, r8
 3065              	.LVL353:
 3066 00a6 53F80910 		ldr	r1, [r3, r9]
 3067 00aa FFF7FEFF 		bl	strcmp
 3068              	.LVL354:
 3069 00ae 40B9     		cbnz	r0, .L471
 3070              	.L476:
 677:sxmlc/sxmlc.c **** 	for (i = 0; i < node2->n_attributes; i++) {
 3071              		.loc 1 677 0
 3072 00b0 0137     		adds	r7, r7, #1
 3073              	.LVL355:
 3074 00b2 E1E7     		b	.L475
 3075              	.LVL356:
 3076              	.L478:
 657:sxmlc/sxmlc.c **** 		return true;
 3077              		.loc 1 657 0
 3078 00b4 0124     		movs	r4, #1
 3079 00b6 04E0     		b	.L471
 3080              	.LVL357:
 3081              	.L479:
 660:sxmlc/sxmlc.c **** 		return false;
 3082              		.loc 1 660 0
 3083 00b8 0446     		mov	r4, r0
 3084 00ba 02E0     		b	.L471
 3085              	.L480:
 3086 00bc 0C46     		mov	r4, r1
 3087 00be 00E0     		b	.L471
 3088              	.LVL358:
 3089              	.L483:
 3090 00c0 0024     		movs	r4, #0
 3091              	.L471:
 688:sxmlc/sxmlc.c **** }
 3092              		.loc 1 688 0
 3093 00c2 2046     		mov	r0, r4
 3094 00c4 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 3095              	.LVL359:
 3096              	.L492:
 3097              		.align	2
 3098              	.L491:
 3099 00c8 22057719 		.word	427230498
 3100              		.cfi_endproc
 3101              	.LFE25:
 3103              		.section	.text.XMLNode_next_sibling,"ax",%progbits
 3104              		.align	1
 3105              		.global	XMLNode_next_sibling
 3106              		.thumb
 3107              		.thumb_func
 3109              	XMLNode_next_sibling:
 3110              	.LFB26:
 691:sxmlc/sxmlc.c **** {
 3111              		.loc 1 691 0
 3112              		.cfi_startproc
 3113              		@ args = 0, pretend = 0, frame = 0
 3114              		@ frame_needed = 0, uses_anonymous_args = 0
 3115              	.LVL360:
 3116 0000 30B5     		push	{r4, r5, lr}
 3117              		.cfi_def_cfa_offset 12
 3118              		.cfi_offset 4, -12
 3119              		.cfi_offset 5, -8
 3120              		.cfi_offset 14, -4
 695:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || node->father == NULL)
 3121              		.loc 1 695 0
 3122 0002 C0B1     		cbz	r0, .L500
 695:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE || node->father == NULL)
 3123              		.loc 1 695 0 is_stmt 0 discriminator 1
 3124 0004 836A     		ldr	r3, [r0, #40]
 3125 0006 0E4A     		ldr	r2, .L505
 3126 0008 9342     		cmp	r3, r2
 3127 000a 16D1     		bne	.L501
 3128 000c 0369     		ldr	r3, [r0, #16]
 3129 000e ABB1     		cbz	r3, .L494
 699:sxmlc/sxmlc.c **** 	for (i = 0; i < father->n_children && father->children[i] != node; i++) ;
 3130              		.loc 1 699 0 is_stmt 1
 3131 0010 9C69     		ldr	r4, [r3, #24]
 3132 0012 0022     		movs	r2, #0
 3133              	.L495:
 3134              	.LVL361:
 699:sxmlc/sxmlc.c **** 	for (i = 0; i < father->n_children && father->children[i] != node; i++) ;
 3135              		.loc 1 699 0 is_stmt 0 discriminator 1
 3136 0014 A242     		cmp	r2, r4
 3137 0016 02F10101 		add	r1, r2, #1
 3138 001a 05DB     		blt	.L496
 3139              	.LVL362:
 3140              	.L499:
 702:sxmlc/sxmlc.c **** 	return i < father->n_children ? father->children[i] : NULL;
 3141              		.loc 1 702 0 is_stmt 1
 3142 001c A142     		cmp	r1, r4
 3143 001e 0CDA     		bge	.L501
 702:sxmlc/sxmlc.c **** 	return i < father->n_children ? father->children[i] : NULL;
 3144              		.loc 1 702 0 is_stmt 0 discriminator 1
 3145 0020 5B69     		ldr	r3, [r3, #20]
 3146 0022 53F82130 		ldr	r3, [r3, r1, lsl #2]
 3147 0026 09E0     		b	.L494
 3148              	.LVL363:
 3149              	.L496:
 699:sxmlc/sxmlc.c **** 	for (i = 0; i < father->n_children && father->children[i] != node; i++) ;
 3150              		.loc 1 699 0 is_stmt 1 discriminator 2
 3151 0028 5D69     		ldr	r5, [r3, #20]
 3152 002a 55F82220 		ldr	r2, [r5, r2, lsl #2]
 3153              	.LVL364:
 3154 002e 8242     		cmp	r2, r0
 3155 0030 F4D0     		beq	.L499
 699:sxmlc/sxmlc.c **** 	for (i = 0; i < father->n_children && father->children[i] != node; i++) ;
 3156              		.loc 1 699 0 is_stmt 0 discriminator 1
 3157 0032 0A46     		mov	r2, r1
 3158              	.LVL365:
 3159 0034 EEE7     		b	.L495
 3160              	.LVL366:
 3161              	.L500:
 696:sxmlc/sxmlc.c **** 		return NULL;
 3162              		.loc 1 696 0 is_stmt 1
 3163 0036 0346     		mov	r3, r0
 3164 0038 00E0     		b	.L494
 3165              	.L501:
 3166 003a 0023     		movs	r3, #0
 3167              	.L494:
 703:sxmlc/sxmlc.c **** }
 3168              		.loc 1 703 0
 3169 003c 1846     		mov	r0, r3
 3170              	.LVL367:
 3171 003e 30BD     		pop	{r4, r5, pc}
 3172              	.L506:
 3173              		.align	2
 3174              	.L505:
 3175 0040 22057719 		.word	427230498
 3176              		.cfi_endproc
 3177              	.LFE26:
 3179              		.section	.text.XMLNode_next,"ax",%progbits
 3180              		.align	1
 3181              		.global	XMLNode_next
 3182              		.thumb
 3183              		.thumb_func
 3185              	XMLNode_next:
 3186              	.LFB28:
 725:sxmlc/sxmlc.c **** {
 3187              		.loc 1 725 0
 3188              		.cfi_startproc
 3189              		@ args = 0, pretend = 0, frame = 0
 3190              		@ frame_needed = 0, uses_anonymous_args = 0
 3191              	.LVL368:
 3192 0000 10B5     		push	{r4, lr}
 3193              		.cfi_def_cfa_offset 8
 3194              		.cfi_offset 4, -8
 3195              		.cfi_offset 14, -4
 725:sxmlc/sxmlc.c **** {
 3196              		.loc 1 725 0
 3197 0002 0446     		mov	r4, r0
 3198              	.LVL369:
 3199 0004 0120     		movs	r0, #1
 3200              	.LVL370:
 3201              	.L510:
 3202              	.LBB12:
 3203              	.LBB13:
 709:sxmlc/sxmlc.c **** 	if (node == NULL || node->init_value != XML_INIT_DONE)
 3204              		.loc 1 709 0
 3205 0006 84B1     		cbz	r4, .L511
 3206 0008 A36A     		ldr	r3, [r4, #40]
 3207 000a 0A4A     		ldr	r2, .L517
 3208 000c 9342     		cmp	r3, r2
 3209 000e 0ED1     		bne	.L512
 713:sxmlc/sxmlc.c **** 	if (in_children && node->n_children > 0)
 3210              		.loc 1 713 0
 3211 0010 28B1     		cbz	r0, .L509
 3212 0012 A369     		ldr	r3, [r4, #24]
 3213 0014 002B     		cmp	r3, #0
 3214 0016 02DD     		ble	.L509
 714:sxmlc/sxmlc.c **** 		return node->children[0];
 3215              		.loc 1 714 0
 3216 0018 6369     		ldr	r3, [r4, #20]
 3217 001a 1868     		ldr	r0, [r3]
 3218 001c 10BD     		pop	{r4, pc}
 3219              	.L509:
 717:sxmlc/sxmlc.c **** 	if ((node2 = XMLNode_next_sibling(node)) != NULL)
 3220              		.loc 1 717 0
 3221 001e 2046     		mov	r0, r4
 3222 0020 FFF7FEFF 		bl	XMLNode_next_sibling
 3223              	.LVL371:
 3224 0024 20B9     		cbnz	r0, .L508
 721:sxmlc/sxmlc.c **** 	return _XMLNode_next(node->father, false);
 3225              		.loc 1 721 0
 3226 0026 2469     		ldr	r4, [r4, #16]
 3227 0028 EDE7     		b	.L510
 3228              	.LVL372:
 3229              	.L511:
 710:sxmlc/sxmlc.c **** 		return NULL;
 3230              		.loc 1 710 0
 3231 002a 2046     		mov	r0, r4
 3232 002c 10BD     		pop	{r4, pc}
 3233              	.L512:
 3234 002e 0020     		movs	r0, #0
 3235              	.L508:
 3236              	.LBE13:
 3237              	.LBE12:
 727:sxmlc/sxmlc.c **** }
 3238              		.loc 1 727 0
 3239 0030 10BD     		pop	{r4, pc}
 3240              	.L518:
 3241 0032 00BF     		.align	2
 3242              	.L517:
 3243 0034 22057719 		.word	427230498
 3244              		.cfi_endproc
 3245              	.LFE28:
 3247              		.section	.text.XMLDoc_init,"ax",%progbits
 3248              		.align	1
 3249              		.global	XMLDoc_init
 3250              		.thumb
 3251              		.thumb_func
 3253              	XMLDoc_init:
 3254              	.LFB29:
 732:sxmlc/sxmlc.c **** {
 3255              		.loc 1 732 0
 3256              		.cfi_startproc
 3257              		@ args = 0, pretend = 0, frame = 0
 3258              		@ frame_needed = 0, uses_anonymous_args = 0
 3259              		@ link register save eliminated.
 3260              	.LVL373:
 3261 0000 0023     		movs	r3, #0
 733:sxmlc/sxmlc.c **** 	if (doc == NULL)
 3262              		.loc 1 733 0
 3263 0002 60B1     		cbz	r0, .L520
 736:sxmlc/sxmlc.c **** 	doc->filename[0] = NULC;
 3264              		.loc 1 736 0
 3265 0004 0370     		strb	r3, [r0]
 740:sxmlc/sxmlc.c **** 	doc->nodes = NULL;
 3266              		.loc 1 740 0
 3267 0006 C0F80031 		str	r3, [r0, #256]
 741:sxmlc/sxmlc.c **** 	doc->n_nodes = 0;
 3268              		.loc 1 741 0
 3269 000a C0F80431 		str	r3, [r0, #260]
 742:sxmlc/sxmlc.c **** 	doc->i_root = -1;
 3270              		.loc 1 742 0
 3271 000e 4FF0FF33 		mov	r3, #-1
 3272 0012 C0F80831 		str	r3, [r0, #264]
 743:sxmlc/sxmlc.c **** 	doc->init_value = XML_INIT_DONE;
 3273              		.loc 1 743 0
 3274 0016 024B     		ldr	r3, .L522
 3275 0018 C0F80C31 		str	r3, [r0, #268]
 745:sxmlc/sxmlc.c **** 	return true;
 3276              		.loc 1 745 0
 3277 001c 0120     		movs	r0, #1
 3278              	.LVL374:
 3279              	.L520:
 746:sxmlc/sxmlc.c **** }
 3280              		.loc 1 746 0
 3281 001e 7047     		bx	lr
 3282              	.L523:
 3283              		.align	2
 3284              	.L522:
 3285 0020 22057719 		.word	427230498
 3286              		.cfi_endproc
 3287              	.LFE29:
 3289              		.section	.text.XMLDoc_free,"ax",%progbits
 3290              		.align	1
 3291              		.global	XMLDoc_free
 3292              		.thumb
 3293              		.thumb_func
 3295              	XMLDoc_free:
 3296              	.LFB30:
 749:sxmlc/sxmlc.c **** {
 3297              		.loc 1 749 0
 3298              		.cfi_startproc
 3299              		@ args = 0, pretend = 0, frame = 0
 3300              		@ frame_needed = 0, uses_anonymous_args = 0
 3301              	.LVL375:
 3302 0000 38B5     		push	{r3, r4, r5, lr}
 3303              		.cfi_def_cfa_offset 16
 3304              		.cfi_offset 3, -16
 3305              		.cfi_offset 4, -12
 3306              		.cfi_offset 5, -8
 3307              		.cfi_offset 14, -4
 752:sxmlc/sxmlc.c **** 	if (doc == NULL || doc->init_value != XML_INIT_DONE)
 3308              		.loc 1 752 0
 3309 0002 0446     		mov	r4, r0
 3310 0004 30B3     		cbz	r0, .L529
 752:sxmlc/sxmlc.c **** 	if (doc == NULL || doc->init_value != XML_INIT_DONE)
 3311              		.loc 1 752 0 is_stmt 0 discriminator 1
 3312 0006 D0F80C31 		ldr	r3, [r0, #268]
 3313 000a 134A     		ldr	r2, .L531
 3314 000c 9342     		cmp	r3, r2
 3315 000e 21D1     		bne	.L529
 752:sxmlc/sxmlc.c **** 	if (doc == NULL || doc->init_value != XML_INIT_DONE)
 3316              		.loc 1 752 0
 3317 0010 0025     		movs	r5, #0
 3318              	.LVL376:
 3319              	.L526:
 3320              	.LBB16:
 3321              	.LBB17:
 755:sxmlc/sxmlc.c **** 	for (i = 0; i < doc->n_nodes; i++) {
 3322              		.loc 1 755 0 is_stmt 1
 3323 0012 D4F80431 		ldr	r3, [r4, #260]
 3324 0016 9D42     		cmp	r5, r3
 3325 0018 0DDA     		bge	.L530
 756:sxmlc/sxmlc.c **** 		(void)XMLNode_free(doc->nodes[i]);
 3326              		.loc 1 756 0
 3327 001a D4F80031 		ldr	r3, [r4, #256]
 3328 001e 53F82500 		ldr	r0, [r3, r5, lsl #2]
 3329 0022 FFF7FEFF 		bl	XMLNode_free
 3330              	.LVL377:
 757:sxmlc/sxmlc.c **** 		__free(doc->nodes[i]);
 3331              		.loc 1 757 0
 3332 0026 D4F80031 		ldr	r3, [r4, #256]
 3333 002a 53F82500 		ldr	r0, [r3, r5, lsl #2]
 3334 002e FFF7FEFF 		bl	free
 3335              	.LVL378:
 755:sxmlc/sxmlc.c **** 	for (i = 0; i < doc->n_nodes; i++) {
 3336              		.loc 1 755 0
 3337 0032 0135     		adds	r5, r5, #1
 3338              	.LVL379:
 3339 0034 EDE7     		b	.L526
 3340              	.L530:
 759:sxmlc/sxmlc.c **** 	__free(doc->nodes);
 3341              		.loc 1 759 0
 3342 0036 D4F80001 		ldr	r0, [r4, #256]
 3343 003a FFF7FEFF 		bl	free
 3344              	.LVL380:
 760:sxmlc/sxmlc.c **** 	doc->nodes = NULL;
 3345              		.loc 1 760 0
 3346 003e 0023     		movs	r3, #0
 3347 0040 C4F80031 		str	r3, [r4, #256]
 761:sxmlc/sxmlc.c **** 	doc->n_nodes = 0;
 3348              		.loc 1 761 0
 3349 0044 C4F80431 		str	r3, [r4, #260]
 762:sxmlc/sxmlc.c **** 	doc->i_root = -1;
 3350              		.loc 1 762 0
 3351 0048 4FF0FF33 		mov	r3, #-1
 3352 004c C4F80831 		str	r3, [r4, #264]
 3353 0050 0120     		movs	r0, #1
 3354 0052 38BD     		pop	{r3, r4, r5, pc}
 3355              	.LVL381:
 3356              	.L529:
 3357              	.LBE17:
 3358              	.LBE16:
 753:sxmlc/sxmlc.c **** 		return false;
 3359              		.loc 1 753 0
 3360 0054 0020     		movs	r0, #0
 3361              	.LVL382:
 765:sxmlc/sxmlc.c **** }
 3362              		.loc 1 765 0
 3363 0056 38BD     		pop	{r3, r4, r5, pc}
 3364              	.LVL383:
 3365              	.L532:
 3366              		.align	2
 3367              	.L531:
 3368 0058 22057719 		.word	427230498
 3369              		.cfi_endproc
 3370              	.LFE30:
 3372              		.section	.text.DOMXMLDoc_doc_end,"ax",%progbits
 3373              		.align	1
 3374              		.global	DOMXMLDoc_doc_end
 3375              		.thumb
 3376              		.thumb_func
 3378              	DOMXMLDoc_doc_end:
 3379              	.LFB51:
1538:sxmlc/sxmlc.c **** {
 3380              		.loc 1 1538 0
 3381              		.cfi_startproc
 3382              		@ args = 0, pretend = 0, frame = 0
 3383              		@ frame_needed = 0, uses_anonymous_args = 0
 3384              	.LVL384:
 3385 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 3386              		.cfi_def_cfa_offset 24
 3387              		.cfi_offset 0, -24
 3388              		.cfi_offset 1, -20
 3389              		.cfi_offset 2, -16
 3390              		.cfi_offset 4, -12
 3391              		.cfi_offset 5, -8
 3392              		.cfi_offset 14, -4
1539:sxmlc/sxmlc.c **** 	DOM_through_SAX* dom = (DOM_through_SAX*)sd->user;
 3393              		.loc 1 1539 0
 3394 0002 8468     		ldr	r4, [r0, #8]
 3395              	.LVL385:
1538:sxmlc/sxmlc.c **** {
 3396              		.loc 1 1538 0
 3397 0004 0346     		mov	r3, r0
1541:sxmlc/sxmlc.c **** 	if (dom->error != PARSE_ERR_NONE) {
 3398              		.loc 1 1541 0
 3399 0006 227A     		ldrb	r2, [r4, #8]	@ zero_extendqisi2
 3400 0008 B2B1     		cbz	r2, .L534
 3401 000a 0632     		adds	r2, r2, #6
 3402 000c D2B2     		uxtb	r2, r2
 3403 000e 052A     		cmp	r2, #5
 3404 0010 96BF     		itet	ls
 3405 0012 0B49     		ldrls	r1, .L540
 3406              	.LBB18:
1544:sxmlc/sxmlc.c **** 		switch (dom->error) {
 3407              		.loc 1 1544 0
 3408 0014 0B4A     		ldrhi	r2, .L540+4
 3409 0016 51F82220 		ldrls	r2, [r1, r2, lsl #2]
 3410              	.LVL386:
1553:sxmlc/sxmlc.c **** 		sx_fprintf(stderr, C2SX("%s:%d: An error was found (%s), loading aborted...\n"), sd->name, dom->l
 3411              		.loc 1 1553 0
 3412 001a 0B49     		ldr	r1, .L540+8
1554:sxmlc/sxmlc.c **** 		dom->current = NULL;
 3413              		.loc 1 1554 0
 3414 001c 0025     		movs	r5, #0
1553:sxmlc/sxmlc.c **** 		sx_fprintf(stderr, C2SX("%s:%d: An error was found (%s), loading aborted...\n"), sd->name, dom->l
 3415              		.loc 1 1553 0
 3416 001e 0968     		ldr	r1, [r1]
 3417 0020 0092     		str	r2, [sp]
 3418 0022 1A68     		ldr	r2, [r3]
 3419              	.LVL387:
 3420 0024 C868     		ldr	r0, [r1, #12]
 3421              	.LVL388:
 3422 0026 E368     		ldr	r3, [r4, #12]
 3423              	.LVL389:
 3424 0028 0849     		ldr	r1, .L540+12
 3425 002a FFF7FEFF 		bl	fprintf
 3426              	.LVL390:
1554:sxmlc/sxmlc.c **** 		dom->current = NULL;
 3427              		.loc 1 1554 0
 3428 002e 6560     		str	r5, [r4, #4]
1555:sxmlc/sxmlc.c **** 		(void)XMLDoc_free(dom->doc);
 3429              		.loc 1 1555 0
 3430 0030 2068     		ldr	r0, [r4]
 3431 0032 FFF7FEFF 		bl	XMLDoc_free
 3432              	.LVL391:
1556:sxmlc/sxmlc.c **** 		dom->doc = NULL;
 3433              		.loc 1 1556 0
 3434 0036 2560     		str	r5, [r4]
 3435              	.L534:
 3436              	.LBE18:
1560:sxmlc/sxmlc.c **** }
 3437              		.loc 1 1560 0
 3438 0038 0120     		movs	r0, #1
 3439 003a 03B0     		add	sp, sp, #12
 3440              		@ sp needed
 3441 003c 30BD     		pop	{r4, r5, pc}
 3442              	.LVL392:
 3443              	.L541:
 3444 003e 00BF     		.align	2
 3445              	.L540:
 3446 0040 00000000 		.word	.LANCHOR1
 3447 0044 56000000 		.word	.LC3
 3448 0048 00000000 		.word	_impure_ptr
 3449 004c 5E000000 		.word	.LC4
 3450              		.cfi_endproc
 3451              	.LFE51:
 3453              		.section	.text.XMLDoc_set_root,"ax",%progbits
 3454              		.align	1
 3455              		.global	XMLDoc_set_root
 3456              		.thumb
 3457              		.thumb_func
 3459              	XMLDoc_set_root:
 3460              	.LFB31:
 768:sxmlc/sxmlc.c **** {
 3461              		.loc 1 768 0
 3462              		.cfi_startproc
 3463              		@ args = 0, pretend = 0, frame = 0
 3464              		@ frame_needed = 0, uses_anonymous_args = 0
 3465              		@ link register save eliminated.
 3466              	.LVL393:
 769:sxmlc/sxmlc.c **** 	if (doc == NULL || doc->init_value != XML_INIT_DONE || i_root < 0 || i_root >= doc->n_nodes)
 3467              		.loc 1 769 0
 3468 0000 78B1     		cbz	r0, .L543
 769:sxmlc/sxmlc.c **** 	if (doc == NULL || doc->init_value != XML_INIT_DONE || i_root < 0 || i_root >= doc->n_nodes)
 3469              		.loc 1 769 0 is_stmt 0 discriminator 1
 3470 0002 D0F80C31 		ldr	r3, [r0, #268]
 3471 0006 074A     		ldr	r2, .L548
 3472 0008 9342     		cmp	r3, r2
 3473 000a 09D1     		bne	.L547
 3474 000c 0029     		cmp	r1, #0
 3475 000e 07DB     		blt	.L547
 3476 0010 D0F80431 		ldr	r3, [r0, #260]
 3477 0014 9942     		cmp	r1, r3
 3478 0016 03DA     		bge	.L547
 772:sxmlc/sxmlc.c **** 	doc->i_root = i_root;
 3479              		.loc 1 772 0 is_stmt 1
 3480 0018 C0F80811 		str	r1, [r0, #264]
 774:sxmlc/sxmlc.c **** 	return true;
 3481              		.loc 1 774 0
 3482 001c 0120     		movs	r0, #1
 3483              	.LVL394:
 3484 001e 7047     		bx	lr
 3485              	.LVL395:
 3486              	.L547:
 770:sxmlc/sxmlc.c **** 		return false;
 3487              		.loc 1 770 0
 3488 0020 0020     		movs	r0, #0
 3489              	.LVL396:
 3490              	.L543:
 775:sxmlc/sxmlc.c **** }
 3491              		.loc 1 775 0
 3492 0022 7047     		bx	lr
 3493              	.L549:
 3494              		.align	2
 3495              	.L548:
 3496 0024 22057719 		.word	427230498
 3497              		.cfi_endproc
 3498              	.LFE31:
 3500              		.section	.text.XMLDoc_add_node,"ax",%progbits
 3501              		.align	1
 3502              		.global	XMLDoc_add_node
 3503              		.thumb
 3504              		.thumb_func
 3506              	XMLDoc_add_node:
 3507              	.LFB32:
 778:sxmlc/sxmlc.c **** {
 3508              		.loc 1 778 0
 3509              		.cfi_startproc
 3510              		@ args = 0, pretend = 0, frame = 0
 3511              		@ frame_needed = 0, uses_anonymous_args = 0
 3512              	.LVL397:
 3513 0000 38B5     		push	{r3, r4, r5, lr}
 3514              		.cfi_def_cfa_offset 16
 3515              		.cfi_offset 3, -16
 3516              		.cfi_offset 4, -12
 3517              		.cfi_offset 5, -8
 3518              		.cfi_offset 14, -4
 778:sxmlc/sxmlc.c **** {
 3519              		.loc 1 778 0
 3520 0002 0D46     		mov	r5, r1
 779:sxmlc/sxmlc.c **** 	if (doc == NULL || node == NULL || doc->init_value != XML_INIT_DONE)
 3521              		.loc 1 779 0
 3522 0004 0446     		mov	r4, r0
 3523 0006 10B9     		cbnz	r0, .L551
 3524              	.LVL398:
 3525              	.L553:
 780:sxmlc/sxmlc.c **** 		return -1;
 3526              		.loc 1 780 0
 3527 0008 4FF0FF30 		mov	r0, #-1
 3528 000c 38BD     		pop	{r3, r4, r5, pc}
 3529              	.LVL399:
 3530              	.L551:
 779:sxmlc/sxmlc.c **** 	if (doc == NULL || node == NULL || doc->init_value != XML_INIT_DONE)
 3531              		.loc 1 779 0 discriminator 1
 3532 000e 0029     		cmp	r1, #0
 3533 0010 FAD0     		beq	.L553
 3534 0012 D0F80C31 		ldr	r3, [r0, #268]
 3535 0016 0B4A     		ldr	r2, .L558
 3536 0018 9342     		cmp	r3, r2
 3537 001a F5D1     		bne	.L553
 782:sxmlc/sxmlc.c **** 	if (_add_node(&doc->nodes, &doc->n_nodes, node) < 0)
 3538              		.loc 1 782 0
 3539 001c 00F58070 		add	r0, r0, #256
 3540              	.LVL400:
 3541 0020 04F58271 		add	r1, r4, #260
 3542              	.LVL401:
 3543 0024 2A46     		mov	r2, r5
 3544 0026 FFF7FEFF 		bl	_add_node
 3545              	.LVL402:
 3546 002a 0028     		cmp	r0, #0
 3547 002c ECDB     		blt	.L553
 785:sxmlc/sxmlc.c **** 	if (node->tag_type == TAG_FATHER)
 3548              		.loc 1 785 0
 3549 002e 95F91C30 		ldrsb	r3, [r5, #28]
 3550 0032 D4F80401 		ldr	r0, [r4, #260]
 3551 0036 022B     		cmp	r3, #2
 786:sxmlc/sxmlc.c **** 		doc->i_root = doc->n_nodes - 1; /* Main root node is the last father node */
 3552              		.loc 1 786 0
 3553 0038 04BF     		itt	eq
 3554 003a 00F1FF33 		addeq	r3, r0, #-1
 3555 003e C4F80831 		streq	r3, [r4, #264]
 789:sxmlc/sxmlc.c **** }
 3556              		.loc 1 789 0
 3557 0042 38BD     		pop	{r3, r4, r5, pc}
 3558              	.LVL403:
 3559              	.L559:
 3560              		.align	2
 3561              	.L558:
 3562 0044 22057719 		.word	427230498
 3563              		.cfi_endproc
 3564              	.LFE32:
 3566              		.section	.text.XMLDoc_remove_node,"ax",%progbits
 3567              		.align	1
 3568              		.global	XMLDoc_remove_node
 3569              		.thumb
 3570              		.thumb_func
 3572              	XMLDoc_remove_node:
 3573              	.LFB33:
 792:sxmlc/sxmlc.c **** {
 3574              		.loc 1 792 0
 3575              		.cfi_startproc
 3576              		@ args = 0, pretend = 0, frame = 0
 3577              		@ frame_needed = 0, uses_anonymous_args = 0
 3578              	.LVL404:
 3579 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 3580              		.cfi_def_cfa_offset 24
 3581              		.cfi_offset 4, -24
 3582              		.cfi_offset 5, -20
 3583              		.cfi_offset 6, -16
 3584              		.cfi_offset 7, -12
 3585              		.cfi_offset 8, -8
 3586              		.cfi_offset 14, -4
 792:sxmlc/sxmlc.c **** {
 3587              		.loc 1 792 0
 3588 0004 0E46     		mov	r6, r1
 3589 0006 9046     		mov	r8, r2
 794:sxmlc/sxmlc.c **** 	if (doc == NULL || doc->init_value != XML_INIT_DONE || i_node < 0 || i_node > doc->n_nodes)
 3590              		.loc 1 794 0
 3591 0008 0446     		mov	r4, r0
 3592 000a 10B9     		cbnz	r0, .L561
 3593              	.LVL405:
 3594              	.L563:
 795:sxmlc/sxmlc.c **** 		return false;
 3595              		.loc 1 795 0
 3596 000c 0020     		movs	r0, #0
 3597 000e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3598              	.LVL406:
 3599              	.L561:
 794:sxmlc/sxmlc.c **** 	if (doc == NULL || doc->init_value != XML_INIT_DONE || i_node < 0 || i_node > doc->n_nodes)
 3600              		.loc 1 794 0 discriminator 1
 3601 0012 D0F80C31 		ldr	r3, [r0, #268]
 3602 0016 234A     		ldr	r2, .L581
 3603              	.LVL407:
 3604 0018 9342     		cmp	r3, r2
 3605 001a F7D1     		bne	.L563
 3606 001c 0029     		cmp	r1, #0
 3607 001e F5DB     		blt	.L563
 3608 0020 D0F80401 		ldr	r0, [r0, #260]
 3609              	.LVL408:
 3610 0024 8142     		cmp	r1, r0
 3611 0026 F1DC     		bgt	.L563
 798:sxmlc/sxmlc.c **** 	if (doc->n_nodes == 1)
 3612              		.loc 1 798 0
 3613 0028 0128     		cmp	r0, #1
 3614 002a 06D0     		beq	.L568
 801:sxmlc/sxmlc.c **** 		pt = (XMLNode**)__malloc((doc->n_nodes - 1) * sizeof(XMLNode*));
 3615              		.loc 1 801 0
 3616 002c 0138     		subs	r0, r0, #1
 3617 002e 8000     		lsls	r0, r0, #2
 3618 0030 FFF7FEFF 		bl	malloc
 3619              	.LVL409:
 802:sxmlc/sxmlc.c **** 		if (pt == NULL)
 3620              		.loc 1 802 0
 3621 0034 0546     		mov	r5, r0
 3622 0036 08B9     		cbnz	r0, .L564
 3623 0038 E8E7     		b	.L563
 3624              	.LVL410:
 3625              	.L568:
 799:sxmlc/sxmlc.c **** 		pt = NULL;
 3626              		.loc 1 799 0
 3627 003a 0025     		movs	r5, #0
 3628              	.LVL411:
 3629              	.L564:
 807:sxmlc/sxmlc.c **** 	(void)XMLNode_free(doc->nodes[i_node]);
 3630              		.loc 1 807 0
 3631 003c D4F80031 		ldr	r3, [r4, #256]
 3632 0040 B700     		lsls	r7, r6, #2
 3633 0042 53F82600 		ldr	r0, [r3, r6, lsl #2]
 3634 0046 FFF7FEFF 		bl	XMLNode_free
 3635              	.LVL412:
 808:sxmlc/sxmlc.c **** 	if (free_node) __free(doc->nodes[i_node]);
 3636              		.loc 1 808 0
 3637 004a B8F1000F 		cmp	r8, #0
 3638 004e 05D0     		beq	.L565
 808:sxmlc/sxmlc.c **** 	if (free_node) __free(doc->nodes[i_node]);
 3639              		.loc 1 808 0 is_stmt 0 discriminator 1
 3640 0050 D4F80031 		ldr	r3, [r4, #256]
 3641 0054 53F82600 		ldr	r0, [r3, r6, lsl #2]
 3642 0058 FFF7FEFF 		bl	free
 3643              	.LVL413:
 3644              	.L565:
 810:sxmlc/sxmlc.c **** 	if (pt != NULL) {
 3645              		.loc 1 810 0 is_stmt 1
 3646 005c 95B1     		cbz	r5, .L566
 811:sxmlc/sxmlc.c **** 		memcpy(pt, &doc->nodes[i_node], i_node * sizeof(XMLNode*));
 3647              		.loc 1 811 0
 3648 005e D4F80011 		ldr	r1, [r4, #256]
 3649 0062 3A46     		mov	r2, r7
 3650 0064 3944     		add	r1, r1, r7
 3651 0066 2846     		mov	r0, r5
 3652 0068 FFF7FEFF 		bl	memcpy
 3653              	.LVL414:
 812:sxmlc/sxmlc.c **** 		memcpy(&pt[i_node], &doc->nodes[i_node + 1], (doc->n_nodes - i_node - 1) * sizeof(XMLNode*));
 3654              		.loc 1 812 0
 3655 006c D4F80431 		ldr	r3, [r4, #260]
 3656 0070 391D     		adds	r1, r7, #4
 3657 0072 9E1B     		subs	r6, r3, r6
 3658              	.LVL415:
 3659 0074 D4F80031 		ldr	r3, [r4, #256]
 3660 0078 721E     		subs	r2, r6, #1
 3661 007a E819     		adds	r0, r5, r7
 3662 007c 1944     		add	r1, r1, r3
 3663 007e 9200     		lsls	r2, r2, #2
 3664 0080 FFF7FEFF 		bl	memcpy
 3665              	.LVL416:
 3666              	.L566:
 815:sxmlc/sxmlc.c **** 	if (doc->nodes != NULL)
 3667              		.loc 1 815 0
 3668 0084 D4F80001 		ldr	r0, [r4, #256]
 3669 0088 08B1     		cbz	r0, .L567
 816:sxmlc/sxmlc.c **** 		__free(doc->nodes);
 3670              		.loc 1 816 0
 3671 008a FFF7FEFF 		bl	free
 3672              	.LVL417:
 3673              	.L567:
 818:sxmlc/sxmlc.c **** 	doc->n_nodes--;
 3674              		.loc 1 818 0
 3675 008e D4F80431 		ldr	r3, [r4, #260]
 817:sxmlc/sxmlc.c **** 	doc->nodes = pt;
 3676              		.loc 1 817 0
 3677 0092 C4F80051 		str	r5, [r4, #256]
 818:sxmlc/sxmlc.c **** 	doc->n_nodes--;
 3678              		.loc 1 818 0
 3679 0096 013B     		subs	r3, r3, #1
 3680 0098 C4F80431 		str	r3, [r4, #260]
 820:sxmlc/sxmlc.c **** 	return true;
 3681              		.loc 1 820 0
 3682 009c 0120     		movs	r0, #1
 821:sxmlc/sxmlc.c **** }
 3683              		.loc 1 821 0
 3684 009e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 3685              	.LVL418:
 3686              	.L582:
 3687 00a2 00BF     		.align	2
 3688              	.L581:
 3689 00a4 22057719 		.word	427230498
 3690              		.cfi_endproc
 3691              	.LFE33:
 3693              		.section	.text.SAX_Callbacks_init,"ax",%progbits
 3694              		.align	1
 3695              		.global	SAX_Callbacks_init
 3696              		.thumb
 3697              		.thumb_func
 3699              	SAX_Callbacks_init:
 3700              	.LFB45:
1390:sxmlc/sxmlc.c **** {
 3701              		.loc 1 1390 0
 3702              		.cfi_startproc
 3703              		@ args = 0, pretend = 0, frame = 0
 3704              		@ frame_needed = 0, uses_anonymous_args = 0
 3705              		@ link register save eliminated.
 3706              	.LVL419:
 3707 0000 0023     		movs	r3, #0
1391:sxmlc/sxmlc.c **** 	if (sax == NULL)
 3708              		.loc 1 1391 0
 3709 0002 38B1     		cbz	r0, .L584
1394:sxmlc/sxmlc.c **** 	sax->start_doc = NULL;
 3710              		.loc 1 1394 0
 3711 0004 0360     		str	r3, [r0]
1395:sxmlc/sxmlc.c **** 	sax->start_node = NULL;
 3712              		.loc 1 1395 0
 3713 0006 4360     		str	r3, [r0, #4]
1396:sxmlc/sxmlc.c **** 	sax->end_node = NULL;
 3714              		.loc 1 1396 0
 3715 0008 8360     		str	r3, [r0, #8]
1397:sxmlc/sxmlc.c **** 	sax->new_text = NULL;
 3716              		.loc 1 1397 0
 3717 000a C360     		str	r3, [r0, #12]
1398:sxmlc/sxmlc.c **** 	sax->on_error = NULL;
 3718              		.loc 1 1398 0
 3719 000c 4361     		str	r3, [r0, #20]
1399:sxmlc/sxmlc.c **** 	sax->end_doc = NULL;
 3720              		.loc 1 1399 0
 3721 000e 0361     		str	r3, [r0, #16]
1400:sxmlc/sxmlc.c **** 	sax->all_event = NULL;
 3722              		.loc 1 1400 0
 3723 0010 8361     		str	r3, [r0, #24]
1402:sxmlc/sxmlc.c **** 	return true;
 3724              		.loc 1 1402 0
 3725 0012 0120     		movs	r0, #1
 3726              	.LVL420:
 3727              	.L584:
1403:sxmlc/sxmlc.c **** }
 3728              		.loc 1 1403 0
 3729 0014 7047     		bx	lr
 3730              		.cfi_endproc
 3731              	.LFE45:
 3733              		.section	.text.SAX_Callbacks_init_DOM,"ax",%progbits
 3734              		.align	1
 3735              		.global	SAX_Callbacks_init_DOM
 3736              		.thumb
 3737              		.thumb_func
 3739              	SAX_Callbacks_init_DOM:
 3740              	.LFB52:
1563:sxmlc/sxmlc.c **** {
 3741              		.loc 1 1563 0
 3742              		.cfi_startproc
 3743              		@ args = 0, pretend = 0, frame = 0
 3744              		@ frame_needed = 0, uses_anonymous_args = 0
 3745              		@ link register save eliminated.
 3746              	.LVL421:
1564:sxmlc/sxmlc.c **** 	if (sax == NULL)
 3747              		.loc 1 1564 0
 3748 0000 70B1     		cbz	r0, .L587
1567:sxmlc/sxmlc.c **** 	sax->start_doc = DOMXMLDoc_doc_start;
 3749              		.loc 1 1567 0
 3750 0002 084B     		ldr	r3, .L589
 3751 0004 0360     		str	r3, [r0]
1568:sxmlc/sxmlc.c **** 	sax->start_node = DOMXMLDoc_node_start;
 3752              		.loc 1 1568 0
 3753 0006 084B     		ldr	r3, .L589+4
 3754 0008 4360     		str	r3, [r0, #4]
1569:sxmlc/sxmlc.c **** 	sax->end_node = DOMXMLDoc_node_end;
 3755              		.loc 1 1569 0
 3756 000a 084B     		ldr	r3, .L589+8
 3757 000c 8360     		str	r3, [r0, #8]
1570:sxmlc/sxmlc.c **** 	sax->new_text = DOMXMLDoc_node_text;
 3758              		.loc 1 1570 0
 3759 000e 084B     		ldr	r3, .L589+12
 3760 0010 C360     		str	r3, [r0, #12]
1571:sxmlc/sxmlc.c **** 	sax->on_error = DOMXMLDoc_parse_error;
 3761              		.loc 1 1571 0
 3762 0012 084B     		ldr	r3, .L589+16
 3763 0014 4361     		str	r3, [r0, #20]
1572:sxmlc/sxmlc.c **** 	sax->end_doc = DOMXMLDoc_doc_end;
 3764              		.loc 1 1572 0
 3765 0016 084B     		ldr	r3, .L589+20
 3766 0018 0361     		str	r3, [r0, #16]
1573:sxmlc/sxmlc.c **** 	sax->all_event = NULL;
 3767              		.loc 1 1573 0
 3768 001a 0023     		movs	r3, #0
 3769 001c 8361     		str	r3, [r0, #24]
1575:sxmlc/sxmlc.c **** 	return true;
 3770              		.loc 1 1575 0
 3771 001e 0120     		movs	r0, #1
 3772              	.LVL422:
 3773              	.L587:
1576:sxmlc/sxmlc.c **** }
 3774              		.loc 1 1576 0
 3775 0020 7047     		bx	lr
 3776              	.L590:
 3777 0022 00BF     		.align	2
 3778              	.L589:
 3779 0024 00000000 		.word	DOMXMLDoc_doc_start
 3780 0028 00000000 		.word	DOMXMLDoc_node_start
 3781 002c 00000000 		.word	DOMXMLDoc_node_end
 3782 0030 00000000 		.word	DOMXMLDoc_node_text
 3783 0034 00000000 		.word	DOMXMLDoc_parse_error
 3784 0038 00000000 		.word	DOMXMLDoc_doc_end
 3785              		.cfi_endproc
 3786              	.LFE52:
 3788              		.section	.text.read_line_alloc,"ax",%progbits
 3789              		.align	1
 3790              		.global	read_line_alloc
 3791              		.thumb
 3792              		.thumb_func
 3794              	read_line_alloc:
 3795              	.LFB59:
1789:sxmlc/sxmlc.c **** 
1790:sxmlc/sxmlc.c **** int read_line_alloc(void* in, DataSourceType in_type, SXML_CHAR** line, int* sz_line, int i0, SXML_
1791:sxmlc/sxmlc.c **** {
 3796              		.loc 1 1791 0
 3797              		.cfi_startproc
 3798              		@ args = 24, pretend = 0, frame = 24
 3799              		@ frame_needed = 0, uses_anonymous_args = 0
 3800              	.LVL423:
 3801 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 3802              		.cfi_def_cfa_offset 36
 3803              		.cfi_offset 4, -36
 3804              		.cfi_offset 5, -32
 3805              		.cfi_offset 6, -28
 3806              		.cfi_offset 7, -24
 3807              		.cfi_offset 8, -20
 3808              		.cfi_offset 9, -16
 3809              		.cfi_offset 10, -12
 3810              		.cfi_offset 11, -8
 3811              		.cfi_offset 14, -4
 3812 0004 87B0     		sub	sp, sp, #28
 3813              		.cfi_def_cfa_offset 64
 3814              		.loc 1 1791 0
 3815 0006 9B46     		mov	fp, r3
 3816 0008 9DF85030 		ldrb	r3, [sp, #80]	@ zero_extendqisi2
 3817              	.LVL424:
1792:sxmlc/sxmlc.c **** 	int init_sz = 0;
1793:sxmlc/sxmlc.c **** 	SXML_CHAR ch, *pt;
1794:sxmlc/sxmlc.c **** 	int c;
1795:sxmlc/sxmlc.c **** 	int n, ret;
1796:sxmlc/sxmlc.c **** 	int (*mgetc)(void* ds) = (in_type == DATA_SOURCE_BUFFER ? (int(*)(void*))_bgetc : (int(*)(void*))s
 3818              		.loc 1 1796 0
 3819 000c 0129     		cmp	r1, #1
1791:sxmlc/sxmlc.c **** {
 3820              		.loc 1 1791 0
 3821 000e 0393     		str	r3, [sp, #12]
 3822              		.loc 1 1796 0
 3823 0010 4D49     		ldr	r1, .L659
 3824              	.LVL425:
 3825 0012 4E4B     		ldr	r3, .L659+4
1792:sxmlc/sxmlc.c **** 	int init_sz = 0;
 3826              		.loc 1 1792 0
 3827 0014 4FF00004 		mov	r4, #0
 3828              		.loc 1 1796 0
 3829 0018 0CBF     		ite	eq
 3830 001a 9A46     		moveq	r10, r3
 3831 001c 8A46     		movne	r10, r1
 3832 001e 4C49     		ldr	r1, .L659+8
 3833 0020 4C4B     		ldr	r3, .L659+12
1791:sxmlc/sxmlc.c **** {
 3834              		.loc 1 1791 0
 3835 0022 1546     		mov	r5, r2
 3836 0024 9DF84870 		ldrb	r7, [sp, #72]	@ zero_extendqisi2
 3837 0028 9DF84420 		ldrb	r2, [sp, #68]	@ zero_extendqisi2
 3838              	.LVL426:
 3839 002c 159E     		ldr	r6, [sp, #84]
1792:sxmlc/sxmlc.c **** 	int init_sz = 0;
 3840              		.loc 1 1792 0
 3841 002e 0594     		str	r4, [sp, #20]
 3842              		.loc 1 1796 0
 3843 0030 0CBF     		ite	eq
 3844 0032 9946     		moveq	r9, r3
 3845 0034 8946     		movne	r9, r1
 3846              	.LVL427:
1797:sxmlc/sxmlc.c **** 	int (*meos)(void* ds) = (in_type == DATA_SOURCE_BUFFER ? (int(*)(void*))_beob : (int(*)(void*))feo
1798:sxmlc/sxmlc.c **** 	
1799:sxmlc/sxmlc.c **** 	if (in == NULL || line == NULL)
 3847              		.loc 1 1799 0
 3848 0036 8046     		mov	r8, r0
 3849 0038 08B9     		cbnz	r0, .L593
 3850              	.LVL428:
 3851              	.L595:
1800:sxmlc/sxmlc.c **** 		return 0;
 3852              		.loc 1 1800 0
 3853 003a 0020     		movs	r0, #0
 3854 003c 80E0     		b	.L594
 3855              	.LVL429:
 3856              	.L593:
1799:sxmlc/sxmlc.c **** 	if (in == NULL || line == NULL)
 3857              		.loc 1 1799 0 discriminator 1
 3858 003e 002D     		cmp	r5, #0
 3859 0040 FBD0     		beq	.L595
1801:sxmlc/sxmlc.c **** 	
1802:sxmlc/sxmlc.c **** 	if (to == NULC)
1803:sxmlc/sxmlc.c **** 		to = C2SX('\n');
 3860              		.loc 1 1803 0
 3861 0042 002F     		cmp	r7, #0
 3862 0044 08BF     		it	eq
 3863 0046 0A27     		moveq	r7, #10
 3864              	.LVL430:
1804:sxmlc/sxmlc.c **** 	/* Search for character 'from' */
1805:sxmlc/sxmlc.c **** 	if (interest_count != NULL)
 3865              		.loc 1 1805 0
 3866 0048 06B1     		cbz	r6, .L600
1806:sxmlc/sxmlc.c **** 		*interest_count = 0;
 3867              		.loc 1 1806 0
 3868 004a 3460     		str	r4, [r6]
 3869              	.LVL431:
 3870              	.L600:
1807:sxmlc/sxmlc.c **** 	while (true) {
1808:sxmlc/sxmlc.c **** 		/* Reaching EOF before 'to' char is not an error but should trigger 'line' alloc and init to '' *
1809:sxmlc/sxmlc.c **** 		c = mgetc(in);
 3871              		.loc 1 1809 0
 3872 004c 0092     		str	r2, [sp]
 3873 004e 4046     		mov	r0, r8
 3874 0050 D047     		blx	r10
 3875              	.LVL432:
1810:sxmlc/sxmlc.c **** 		ch = (SXML_CHAR)c;
1811:sxmlc/sxmlc.c **** 		if (c == EOF)
 3876              		.loc 1 1811 0
 3877 0052 B0F1FF3F 		cmp	r0, #-1
1809:sxmlc/sxmlc.c **** 		c = mgetc(in);
 3878              		.loc 1 1809 0
 3879 0056 8446     		mov	ip, r0
 3880              	.LVL433:
1810:sxmlc/sxmlc.c **** 		ch = (SXML_CHAR)c;
 3881              		.loc 1 1810 0
 3882 0058 C1B2     		uxtb	r1, r0
 3883              	.LVL434:
 3884              		.loc 1 1811 0
 3885 005a 009A     		ldr	r2, [sp]
 3886 005c 0AD0     		beq	.L598
1812:sxmlc/sxmlc.c **** 			break;
1813:sxmlc/sxmlc.c **** 		if (interest_count != NULL && ch == interest)
 3887              		.loc 1 1813 0
 3888 005e 2EB1     		cbz	r6, .L599
 3889              		.loc 1 1813 0 is_stmt 0 discriminator 1
 3890 0060 039B     		ldr	r3, [sp, #12]
 3891 0062 9942     		cmp	r1, r3
 3892 0064 02D1     		bne	.L599
1814:sxmlc/sxmlc.c **** 			(*interest_count)++;
 3893              		.loc 1 1814 0 is_stmt 1
 3894 0066 3068     		ldr	r0, [r6]
 3895              	.LVL435:
 3896 0068 0130     		adds	r0, r0, #1
 3897 006a 3060     		str	r0, [r6]
 3898              	.L599:
1815:sxmlc/sxmlc.c **** 		/* If 'from' is '\0', we stop here */
1816:sxmlc/sxmlc.c **** 		if (ch == from || from == NULC)
 3899              		.loc 1 1816 0
 3900 006c 9142     		cmp	r1, r2
 3901 006e 01D0     		beq	.L598
 3902              		.loc 1 1816 0 is_stmt 0 discriminator 1
 3903 0070 002A     		cmp	r2, #0
 3904 0072 EBD1     		bne	.L600
 3905              	.L598:
1817:sxmlc/sxmlc.c **** 			break;
1818:sxmlc/sxmlc.c **** 	}
1819:sxmlc/sxmlc.c **** 	
1820:sxmlc/sxmlc.c **** 	if (sz_line == NULL)
 3906              		.loc 1 1820 0 is_stmt 1
 3907 0074 BBF1000F 		cmp	fp, #0
 3908 0078 01D1     		bne	.L601
1821:sxmlc/sxmlc.c **** 		sz_line = &init_sz;
 3909              		.loc 1 1821 0
 3910 007a 0DF1140B 		add	fp, sp, #20
 3911              	.LVL436:
 3912              	.L601:
1822:sxmlc/sxmlc.c **** 	
1823:sxmlc/sxmlc.c **** 	if (*line == NULL || *sz_line == 0) {
 3913              		.loc 1 1823 0
 3914 007e 2868     		ldr	r0, [r5]
 3915 0080 DBF80040 		ldr	r4, [fp]
 3916 0084 40B1     		cbz	r0, .L602
 3917              		.loc 1 1823 0 is_stmt 0 discriminator 1
 3918 0086 44B1     		cbz	r4, .L645
 3919              	.LVL437:
 3920              	.L605:
 3921 0088 109C     		ldr	r4, [sp, #64]
1824:sxmlc/sxmlc.c **** 		if (*sz_line == 0) *sz_line = MEM_INCR_RLA;
1825:sxmlc/sxmlc.c **** 		*line = (SXML_CHAR*)__malloc(*sz_line*sizeof(SXML_CHAR));
1826:sxmlc/sxmlc.c **** 		if (*line == NULL)
1827:sxmlc/sxmlc.c **** 			return 0;
1828:sxmlc/sxmlc.c **** 	}
1829:sxmlc/sxmlc.c **** 	if (i0 < 0)
1830:sxmlc/sxmlc.c **** 		i0 = 0;
1831:sxmlc/sxmlc.c **** 	if (i0 > *sz_line)
 3922              		.loc 1 1831 0 is_stmt 1
 3923 008a DBF80000 		ldr	r0, [fp]
 3924 008e 24EAE474 		bic	r4, r4, r4, asr #31
 3925              	.LVL438:
 3926 0092 8442     		cmp	r4, r0
 3927 0094 15DD     		ble	.L657
 3928 0096 D0E7     		b	.L595
 3929              	.LVL439:
 3930              	.L602:
1824:sxmlc/sxmlc.c **** 		if (*sz_line == 0) *sz_line = MEM_INCR_RLA;
 3931              		.loc 1 1824 0
 3932 0098 1CB9     		cbnz	r4, .L604
 3933              	.L645:
1824:sxmlc/sxmlc.c **** 		if (*sz_line == 0) *sz_line = MEM_INCR_RLA;
 3934              		.loc 1 1824 0 is_stmt 0 discriminator 1
 3935 009a 4FF48070 		mov	r0, #256
 3936 009e CBF80000 		str	r0, [fp]
 3937              	.L604:
1825:sxmlc/sxmlc.c **** 		*line = (SXML_CHAR*)__malloc(*sz_line*sizeof(SXML_CHAR));
 3938              		.loc 1 1825 0 is_stmt 1
 3939 00a2 DBF80000 		ldr	r0, [fp]
 3940 00a6 0191     		str	r1, [sp, #4]
 3941 00a8 0092     		str	r2, [sp]
 3942 00aa CDF808C0 		str	ip, [sp, #8]
 3943 00ae FFF7FEFF 		bl	malloc
 3944              	.LVL440:
1826:sxmlc/sxmlc.c **** 		if (*line == NULL)
 3945              		.loc 1 1826 0
 3946 00b2 0199     		ldr	r1, [sp, #4]
1825:sxmlc/sxmlc.c **** 		*line = (SXML_CHAR*)__malloc(*sz_line*sizeof(SXML_CHAR));
 3947              		.loc 1 1825 0
 3948 00b4 2860     		str	r0, [r5]
1826:sxmlc/sxmlc.c **** 		if (*line == NULL)
 3949              		.loc 1 1826 0
 3950 00b6 009A     		ldr	r2, [sp]
 3951 00b8 DDF808C0 		ldr	ip, [sp, #8]
 3952 00bc 0028     		cmp	r0, #0
 3953 00be E3D1     		bne	.L605
 3954 00c0 BBE7     		b	.L595
 3955              	.LVL441:
 3956              	.L657:
1832:sxmlc/sxmlc.c **** 		return 0;
1833:sxmlc/sxmlc.c **** 	
1834:sxmlc/sxmlc.c **** 	n = i0;
1835:sxmlc/sxmlc.c **** 	if (c == CEOF) { /* EOF reached before 'to' char => return the empty string */
 3957              		.loc 1 1835 0
 3958 00c2 BCF1FF3F 		cmp	ip, #-1
 3959 00c6 2868     		ldr	r0, [r5]
 3960 00c8 02D1     		bne	.L606
1836:sxmlc/sxmlc.c **** 		(*line)[n] = NULC;
 3961              		.loc 1 1836 0
 3962 00ca 0023     		movs	r3, #0
 3963 00cc 0355     		strb	r3, [r0, r4]
 3964 00ce 0FE0     		b	.L658
 3965              	.L606:
1837:sxmlc/sxmlc.c **** 		return meos(in) ? n : 0; /* Error if not EOF */
1838:sxmlc/sxmlc.c **** 	}
1839:sxmlc/sxmlc.c **** 	if (ch != from || keep_fromto)
 3966              		.loc 1 1839 0
 3967 00d0 9142     		cmp	r1, r2
 3968 00d2 01D1     		bne	.L607
 3969              		.loc 1 1839 0 is_stmt 0 discriminator 1
 3970 00d4 139B     		ldr	r3, [sp, #76]
 3971 00d6 0BB1     		cbz	r3, .L608
 3972              	.L607:
 3973              	.LVL442:
1840:sxmlc/sxmlc.c **** 		(*line)[n++] = ch;
 3974              		.loc 1 1840 0 is_stmt 1
 3975 00d8 0155     		strb	r1, [r0, r4]
 3976 00da 0134     		adds	r4, r4, #1
 3977              	.LVL443:
 3978              	.L608:
1841:sxmlc/sxmlc.c **** 	(*line)[n] = NULC;
 3979              		.loc 1 1841 0
 3980 00dc 2A68     		ldr	r2, [r5]
 3981 00de 0021     		movs	r1, #0
 3982 00e0 1155     		strb	r1, [r2, r4]
 3983              	.LVL444:
 3984              	.L614:
1842:sxmlc/sxmlc.c **** 	ret = 0;
1843:sxmlc/sxmlc.c **** 	while (true) {
1844:sxmlc/sxmlc.c **** 		if ((c = mgetc(in)) == CEOF) { /* EOF or error */
 3985              		.loc 1 1844 0
 3986 00e2 4046     		mov	r0, r8
 3987 00e4 D047     		blx	r10
 3988              	.LVL445:
 3989 00e6 431C     		adds	r3, r0, #1
 3990 00e8 2968     		ldr	r1, [r5]
 3991 00ea 05D1     		bne	.L609
1845:sxmlc/sxmlc.c **** 			(*line)[n] = NULC;
 3992              		.loc 1 1845 0
 3993 00ec 0023     		movs	r3, #0
 3994 00ee 0B55     		strb	r3, [r1, r4]
 3995              	.LVL446:
 3996              	.L658:
1846:sxmlc/sxmlc.c **** 			ret = meos(in) ? n : 0;
 3997              		.loc 1 1846 0
 3998 00f0 4046     		mov	r0, r8
 3999 00f2 C847     		blx	r9
 4000              	.LVL447:
 4001 00f4 18BB     		cbnz	r0, .L620
 4002 00f6 A0E7     		b	.L595
 4003              	.LVL448:
 4004              	.L609:
1847:sxmlc/sxmlc.c **** 			break;
1848:sxmlc/sxmlc.c **** 		}
1849:sxmlc/sxmlc.c **** 		ch = (SXML_CHAR)c;
 4005              		.loc 1 1849 0
 4006 00f8 C2B2     		uxtb	r2, r0
 4007              	.LVL449:
1850:sxmlc/sxmlc.c **** 		if (interest_count != NULL && ch == interest)
 4008              		.loc 1 1850 0
 4009 00fa 2EB1     		cbz	r6, .L610
 4010              		.loc 1 1850 0 is_stmt 0 discriminator 1
 4011 00fc 039B     		ldr	r3, [sp, #12]
 4012 00fe 9A42     		cmp	r2, r3
 4013 0100 02D1     		bne	.L610
1851:sxmlc/sxmlc.c **** 			(*interest_count)++;
 4014              		.loc 1 1851 0 is_stmt 1
 4015 0102 3068     		ldr	r0, [r6]
 4016              	.LVL450:
 4017 0104 0130     		adds	r0, r0, #1
 4018 0106 3060     		str	r0, [r6]
 4019              	.L610:
1852:sxmlc/sxmlc.c **** 		(*line)[n] = ch;
1853:sxmlc/sxmlc.c **** 		if (ch != to || (keep_fromto && to != NULC && ch == to)) /* If we reached the 'to' character and 
 4020              		.loc 1 1853 0
 4021 0108 BA42     		cmp	r2, r7
1852:sxmlc/sxmlc.c **** 		(*line)[n] = ch;
 4022              		.loc 1 1852 0
 4023 010a 0A55     		strb	r2, [r1, r4]
 4024              		.loc 1 1853 0
 4025 010c 01D1     		bne	.L611
 4026              		.loc 1 1853 0 is_stmt 0 discriminator 1
 4027 010e 139B     		ldr	r3, [sp, #76]
 4028 0110 03B1     		cbz	r3, .L612
 4029              	.L611:
1854:sxmlc/sxmlc.c **** 			n++;
 4030              		.loc 1 1854 0 is_stmt 1
 4031 0112 0134     		adds	r4, r4, #1
 4032              	.LVL451:
 4033              	.L612:
1855:sxmlc/sxmlc.c **** 		if (n >= *sz_line) { /* Too many characters for our line => realloc some more */
 4034              		.loc 1 1855 0
 4035 0114 DBF80010 		ldr	r1, [fp]
 4036 0118 8C42     		cmp	r4, r1
 4037 011a 0BDB     		blt	.L613
1856:sxmlc/sxmlc.c **** 			*sz_line += MEM_INCR_RLA;
 4038              		.loc 1 1856 0
 4039 011c 01F58071 		add	r1, r1, #256
 4040 0120 CBF80010 		str	r1, [fp]
1857:sxmlc/sxmlc.c **** 			pt = (SXML_CHAR*)__realloc(*line, *sz_line*sizeof(SXML_CHAR));
 4041              		.loc 1 1857 0
 4042 0124 2868     		ldr	r0, [r5]
 4043 0126 0092     		str	r2, [sp]
 4044 0128 FFF7FEFF 		bl	realloc
 4045              	.LVL452:
1858:sxmlc/sxmlc.c **** 			if (pt == NULL) {
 4046              		.loc 1 1858 0
 4047 012c 009A     		ldr	r2, [sp]
 4048 012e 0028     		cmp	r0, #0
 4049 0130 83D0     		beq	.L595
1859:sxmlc/sxmlc.c **** 				ret = 0;
1860:sxmlc/sxmlc.c **** 				break;
1861:sxmlc/sxmlc.c **** 			} else
1862:sxmlc/sxmlc.c **** 				*line = pt;
 4050              		.loc 1 1862 0
 4051 0132 2860     		str	r0, [r5]
 4052              	.LVL453:
 4053              	.L613:
1863:sxmlc/sxmlc.c **** 		}
1864:sxmlc/sxmlc.c **** 		(*line)[n] = NULC; /* If we reached the 'to' character and we want to strip it, 'n' hasn't change
 4054              		.loc 1 1864 0
 4055 0134 2968     		ldr	r1, [r5]
 4056 0136 0020     		movs	r0, #0
1865:sxmlc/sxmlc.c **** 		if (ch == to) {
 4057              		.loc 1 1865 0
 4058 0138 BA42     		cmp	r2, r7
1864:sxmlc/sxmlc.c **** 		(*line)[n] = NULC; /* If we reached the 'to' character and we want to strip it, 'n' hasn't change
 4059              		.loc 1 1864 0
 4060 013a 0855     		strb	r0, [r1, r4]
 4061              		.loc 1 1865 0
 4062 013c D1D1     		bne	.L614
 4063              	.LVL454:
 4064              	.L620:
 4065 013e 2046     		mov	r0, r4
 4066              	.LVL455:
 4067              	.L594:
1866:sxmlc/sxmlc.c **** 			ret = n;
1867:sxmlc/sxmlc.c **** 			break;
1868:sxmlc/sxmlc.c **** 		}
1869:sxmlc/sxmlc.c **** 	}
1870:sxmlc/sxmlc.c **** 	
1871:sxmlc/sxmlc.c **** #if 0 /* Automatic buffer resize is deactivated */
1872:sxmlc/sxmlc.c **** 	/* Resize line to the exact size */
1873:sxmlc/sxmlc.c **** 	pt = (SXML_CHAR*)__realloc(*line, (n+1)*sizeof(SXML_CHAR));
1874:sxmlc/sxmlc.c **** 	if (pt != NULL)
1875:sxmlc/sxmlc.c **** 		*line = pt;
1876:sxmlc/sxmlc.c **** #endif
1877:sxmlc/sxmlc.c **** 	
1878:sxmlc/sxmlc.c **** 	return ret;
1879:sxmlc/sxmlc.c **** }
 4068              		.loc 1 1879 0
 4069 0140 07B0     		add	sp, sp, #28
 4070              		@ sp needed
 4071 0142 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 4072              	.LVL456:
 4073              	.L660:
 4074 0146 00BF     		.align	2
 4075              	.L659:
 4076 0148 00000000 		.word	fgetc
 4077 014c 00000000 		.word	_bgetc
 4078 0150 00000000 		.word	feof
 4079 0154 00000000 		.word	_beob
 4080              		.cfi_endproc
 4081              	.LFE59:
 4083              		.section	.text.strcat_alloc,"ax",%progbits
 4084              		.align	1
 4085              		.global	strcat_alloc
 4086              		.thumb
 4087              		.thumb_func
 4089              	strcat_alloc:
 4090              	.LFB60:
1880:sxmlc/sxmlc.c **** 
1881:sxmlc/sxmlc.c **** /* --- */
1882:sxmlc/sxmlc.c **** 
1883:sxmlc/sxmlc.c **** SXML_CHAR* strcat_alloc(SXML_CHAR** src1, const SXML_CHAR* src2)
1884:sxmlc/sxmlc.c **** {
 4091              		.loc 1 1884 0
 4092              		.cfi_startproc
 4093              		@ args = 0, pretend = 0, frame = 0
 4094              		@ frame_needed = 0, uses_anonymous_args = 0
 4095              	.LVL457:
 4096 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 4097              		.cfi_def_cfa_offset 24
 4098              		.cfi_offset 3, -24
 4099              		.cfi_offset 4, -20
 4100              		.cfi_offset 5, -16
 4101              		.cfi_offset 6, -12
 4102              		.cfi_offset 7, -8
 4103              		.cfi_offset 14, -4
 4104              		.loc 1 1884 0
 4105 0002 0E46     		mov	r6, r1
1885:sxmlc/sxmlc.c **** 	SXML_CHAR* cat;
1886:sxmlc/sxmlc.c **** 	int n;
1887:sxmlc/sxmlc.c **** 
1888:sxmlc/sxmlc.c **** 	/* Do not concatenate '*src1' with itself */
1889:sxmlc/sxmlc.c **** 	if (src1 == NULL || *src1 == src2)
 4106              		.loc 1 1889 0
 4107 0004 0546     		mov	r5, r0
 4108 0006 08B9     		cbnz	r0, .L662
 4109              	.LVL458:
 4110              	.L664:
1890:sxmlc/sxmlc.c **** 		return NULL;
 4111              		.loc 1 1890 0
 4112 0008 0024     		movs	r4, #0
 4113 000a 1EE0     		b	.L663
 4114              	.LVL459:
 4115              	.L662:
1889:sxmlc/sxmlc.c **** 	if (src1 == NULL || *src1 == src2)
 4116              		.loc 1 1889 0 discriminator 1
 4117 000c 0468     		ldr	r4, [r0]
 4118 000e 8C42     		cmp	r4, r1
 4119 0010 FAD0     		beq	.L664
1891:sxmlc/sxmlc.c **** 
1892:sxmlc/sxmlc.c **** 	/* Concatenate a NULL or empty string */
1893:sxmlc/sxmlc.c **** 	if (src2 == NULL || *src2 == NULC)
 4120              		.loc 1 1893 0
 4121 0012 D1B1     		cbz	r1, .L663
 4122              		.loc 1 1893 0 is_stmt 0 discriminator 1
 4123 0014 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 4124 0016 C3B1     		cbz	r3, .L663
1894:sxmlc/sxmlc.c **** 		return *src1;
1895:sxmlc/sxmlc.c **** 
1896:sxmlc/sxmlc.c **** 	n = (*src1 == NULL ? 0 : sx_strlen(*src1)) + sx_strlen(src2) + 1;
 4125              		.loc 1 1896 0 is_stmt 1
 4126 0018 24B1     		cbz	r4, .L667
 4127              		.loc 1 1896 0 is_stmt 0 discriminator 1
 4128 001a 2046     		mov	r0, r4
 4129              	.LVL460:
 4130 001c FFF7FEFF 		bl	strlen
 4131              	.LVL461:
 4132 0020 0746     		mov	r7, r0
 4133 0022 00E0     		b	.L665
 4134              	.LVL462:
 4135              	.L667:
 4136              		.loc 1 1896 0
 4137 0024 2746     		mov	r7, r4
 4138              	.LVL463:
 4139              	.L665:
 4140              		.loc 1 1896 0 discriminator 3
 4141 0026 3046     		mov	r0, r6
 4142 0028 FFF7FEFF 		bl	strlen
 4143              	.LVL464:
 4144 002c 3918     		adds	r1, r7, r0
1897:sxmlc/sxmlc.c **** 	cat = (SXML_CHAR*)__realloc(*src1, n*sizeof(SXML_CHAR));
 4145              		.loc 1 1897 0 is_stmt 1 discriminator 3
 4146 002e 0131     		adds	r1, r1, #1
 4147              	.LVL465:
 4148 0030 2046     		mov	r0, r4
 4149 0032 FFF7FEFF 		bl	realloc
 4150              	.LVL466:
1898:sxmlc/sxmlc.c **** 	if (cat == NULL)
 4151              		.loc 1 1898 0 discriminator 3
 4152 0036 0028     		cmp	r0, #0
 4153 0038 E6D0     		beq	.L664
1899:sxmlc/sxmlc.c **** 		return NULL;
1900:sxmlc/sxmlc.c **** 	if (*src1 == NULL)
 4154              		.loc 1 1900 0
 4155 003a 2B68     		ldr	r3, [r5]
 4156 003c 03B9     		cbnz	r3, .L666
1901:sxmlc/sxmlc.c **** 		*cat = NULC;
 4157              		.loc 1 1901 0
 4158 003e 0370     		strb	r3, [r0]
 4159              	.L666:
1902:sxmlc/sxmlc.c **** 	*src1 = cat;
 4160              		.loc 1 1902 0
 4161 0040 2860     		str	r0, [r5]
1903:sxmlc/sxmlc.c **** 	sx_strcat(*src1, src2);
 4162              		.loc 1 1903 0
 4163 0042 3146     		mov	r1, r6
 4164 0044 FFF7FEFF 		bl	strcat
 4165              	.LVL467:
1904:sxmlc/sxmlc.c **** 
1905:sxmlc/sxmlc.c **** 	return *src1;
 4166              		.loc 1 1905 0
 4167 0048 2C68     		ldr	r4, [r5]
 4168              	.L663:
1906:sxmlc/sxmlc.c **** }
 4169              		.loc 1 1906 0
 4170 004a 2046     		mov	r0, r4
 4171 004c F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 4172              		.cfi_endproc
 4173              	.LFE60:
 4175              		.section	.text.strip_spaces,"ax",%progbits
 4176              		.align	1
 4177              		.global	strip_spaces
 4178              		.thumb
 4179              		.thumb_func
 4181              	strip_spaces:
 4182              	.LFB61:
1907:sxmlc/sxmlc.c **** 
1908:sxmlc/sxmlc.c **** SXML_CHAR* strip_spaces(SXML_CHAR* str, SXML_CHAR repl_sq)
1909:sxmlc/sxmlc.c **** {
 4183              		.loc 1 1909 0
 4184              		.cfi_startproc
 4185              		@ args = 0, pretend = 0, frame = 0
 4186              		@ frame_needed = 0, uses_anonymous_args = 0
 4187              	.LVL468:
1910:sxmlc/sxmlc.c **** 	SXML_CHAR* p;
1911:sxmlc/sxmlc.c **** 	int i, len;
1912:sxmlc/sxmlc.c **** 	
1913:sxmlc/sxmlc.c **** 	/* 'p' to the first non-space */
1914:sxmlc/sxmlc.c **** 	for (p = str; *p != NULC && sx_isspace(*p); p++) ; /* No need to search for 'protect' as it is not
 4188              		.loc 1 1914 0
 4189 0000 2A4A     		ldr	r2, .L703
1909:sxmlc/sxmlc.c **** {
 4190              		.loc 1 1909 0
 4191 0002 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 4192              		.cfi_def_cfa_offset 24
 4193              		.cfi_offset 4, -24
 4194              		.cfi_offset 5, -20
 4195              		.cfi_offset 6, -16
 4196              		.cfi_offset 7, -12
 4197              		.cfi_offset 8, -8
 4198              		.cfi_offset 14, -4
 4199              		.loc 1 1914 0
 4200 0006 1768     		ldr	r7, [r2]
1909:sxmlc/sxmlc.c **** {
 4201              		.loc 1 1909 0
 4202 0008 0546     		mov	r5, r0
 4203 000a 0E46     		mov	r6, r1
 4204 000c 0346     		mov	r3, r0
 4205 000e 9046     		mov	r8, r2
 4206              	.LVL469:
 4207              	.L678:
 4208 0010 1C46     		mov	r4, r3
 4209              	.LVL470:
 4210              		.loc 1 1914 0 discriminator 1
 4211 0012 13F8012B 		ldrb	r2, [r3], #1	@ zero_extendqisi2
 4212              	.LVL471:
 4213 0016 22B9     		cbnz	r2, .L679
 4214              	.L682:
1915:sxmlc/sxmlc.c **** 	len = sx_strlen(str);
 4215              		.loc 1 1915 0
 4216 0018 2846     		mov	r0, r5
 4217 001a FFF7FEFF 		bl	strlen
 4218              	.LVL472:
1916:sxmlc/sxmlc.c **** 	for (i = len-1; sx_isspace(str[i]); i--) ;
 4219              		.loc 1 1916 0
 4220 001e 431E     		subs	r3, r0, #1
 4221              	.LVL473:
 4222 0020 04E0     		b	.L680
 4223              	.LVL474:
 4224              	.L679:
1914:sxmlc/sxmlc.c **** 	for (p = str; *p != NULC && sx_isspace(*p); p++) ; /* No need to search for 'protect' as it is not
 4225              		.loc 1 1914 0 discriminator 2
 4226 0022 3A44     		add	r2, r2, r7
 4227 0024 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 4228 0026 1007     		lsls	r0, r2, #28
 4229 0028 F2D4     		bmi	.L678
 4230 002a F5E7     		b	.L682
 4231              	.LVL475:
 4232              	.L680:
 4233              		.loc 1 1916 0 discriminator 1
 4234 002c EA5C     		ldrb	r2, [r5, r3]	@ zero_extendqisi2
 4235 002e B918     		adds	r1, r7, r2
 4236 0030 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 4237 0032 0907     		lsls	r1, r1, #28
 4238 0034 01D5     		bpl	.L701
 4239              		.loc 1 1916 0 is_stmt 0 discriminator 2
 4240 0036 013B     		subs	r3, r3, #1
 4241              	.LVL476:
 4242 0038 F8E7     		b	.L680
 4243              	.L701:
1917:sxmlc/sxmlc.c **** 	if (str[i] == C2SX('\\')) /* If last non-space is the protection, keep the last space */
 4244              		.loc 1 1917 0 is_stmt 1
 4245 003a 5C2A     		cmp	r2, #92
1918:sxmlc/sxmlc.c **** 		i++;
 4246              		.loc 1 1918 0
 4247 003c 08BF     		it	eq
 4248 003e 0133     		addeq	r3, r3, #1
 4249              	.LVL477:
1919:sxmlc/sxmlc.c **** 	str[i+1] = NULC; /* New end of string to last non-space */
 4250              		.loc 1 1919 0
 4251 0040 E918     		adds	r1, r5, r3
 4252 0042 0022     		movs	r2, #0
 4253 0044 4A70     		strb	r2, [r1, #1]
1920:sxmlc/sxmlc.c **** 	
1921:sxmlc/sxmlc.c **** 	if (repl_sq == NULC) {
 4254              		.loc 1 1921 0
 4255 0046 0EB1     		cbz	r6, .L685
 4256 0048 1346     		mov	r3, r2
 4257              	.LVL478:
 4258 004a 20E0     		b	.L686
 4259              	.LVL479:
 4260              	.L685:
1922:sxmlc/sxmlc.c **** 		if (p == str && i == len)
 4261              		.loc 1 1922 0
 4262 004c AC42     		cmp	r4, r5
 4263 004e 01D0     		beq	.L687
 4264              	.L689:
 4265 0050 0023     		movs	r3, #0
 4266              	.LVL480:
 4267 0052 02E0     		b	.L688
 4268              	.LVL481:
 4269              	.L687:
 4270              		.loc 1 1922 0 is_stmt 0 discriminator 1
 4271 0054 8342     		cmp	r3, r0
 4272 0056 FBD1     		bne	.L689
 4273 0058 25E0     		b	.L690
 4274              	.LVL482:
 4275              	.L688:
1923:sxmlc/sxmlc.c **** 			return str; /* Nothing to do */
1924:sxmlc/sxmlc.c **** 		for (i = 0; (str[i] = *p) != NULC; i++, p++) ; /* Copy 'p' to 'str' */
 4276              		.loc 1 1924 0 is_stmt 1 discriminator 1
 4277 005a E25C     		ldrb	r2, [r4, r3]	@ zero_extendqisi2
 4278 005c EA54     		strb	r2, [r5, r3]
 4279 005e 12B3     		cbz	r2, .L690
 4280              		.loc 1 1924 0 is_stmt 0 discriminator 2
 4281 0060 0133     		adds	r3, r3, #1
 4282              	.LVL483:
 4283 0062 FAE7     		b	.L688
 4284              	.LVL484:
 4285              	.L697:
1925:sxmlc/sxmlc.c **** 		return str;
1926:sxmlc/sxmlc.c **** 	}
1927:sxmlc/sxmlc.c **** 	
1928:sxmlc/sxmlc.c **** 	/* Squeeze all spaces with 'repl_sq' */
1929:sxmlc/sxmlc.c **** 	i = 0;
1930:sxmlc/sxmlc.c **** 	while (*p != NULC) {
1931:sxmlc/sxmlc.c **** 		if (sx_isspace(*p)) {
 4286              		.loc 1 1931 0 is_stmt 1
 4287 0064 D8F80010 		ldr	r1, [r8]
 4288 0068 1144     		add	r1, r1, r2
 4289 006a 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 4290 006c 11F0080F 		tst	r1, #8
 4291 0070 04F10101 		add	r1, r4, #1
 4292 0074 0FD0     		beq	.L693
 4293              	.LVL485:
1932:sxmlc/sxmlc.c **** 			str[i++] = repl_sq;
1933:sxmlc/sxmlc.c **** 			while (sx_isspace(*++p)) ; /* Skips all next spaces */
 4294              		.loc 1 1933 0
 4295 0076 0D4A     		ldr	r2, .L703
1932:sxmlc/sxmlc.c **** 			str[i++] = repl_sq;
 4296              		.loc 1 1932 0
 4297 0078 EE54     		strb	r6, [r5, r3]
 4298              		.loc 1 1933 0
 4299 007a 1068     		ldr	r0, [r2]
 4300 007c 0A46     		mov	r2, r1
 4301              	.L695:
 4302              	.LVL486:
 4303              		.loc 1 1933 0 is_stmt 0 discriminator 1
 4304 007e 1446     		mov	r4, r2
 4305              	.LVL487:
 4306 0080 2178     		ldrb	r1, [r4]	@ zero_extendqisi2
 4307 0082 0132     		adds	r2, r2, #1
 4308              	.LVL488:
 4309 0084 0144     		add	r1, r1, r0
 4310 0086 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 4311 0088 0907     		lsls	r1, r1, #28
 4312 008a F8D4     		bmi	.L695
 4313              	.LVL489:
 4314              	.L694:
 4315 008c 0133     		adds	r3, r3, #1
 4316              	.L686:
 4317              	.LVL490:
1930:sxmlc/sxmlc.c **** 	while (*p != NULC) {
 4318              		.loc 1 1930 0 is_stmt 1 discriminator 1
 4319 008e 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 4320 0090 002A     		cmp	r2, #0
 4321 0092 E7D1     		bne	.L697
 4322 0094 06E0     		b	.L702
 4323              	.L693:
1934:sxmlc/sxmlc.c **** 		} else {
1935:sxmlc/sxmlc.c **** 			if (*p == C2SX('\\'))
1936:sxmlc/sxmlc.c **** 				p++;
 4324              		.loc 1 1936 0
 4325 0096 5C2A     		cmp	r2, #92
 4326 0098 08BF     		it	eq
 4327 009a 0C46     		moveq	r4, r1
 4328              	.LVL491:
1937:sxmlc/sxmlc.c **** 			str[i++] = *p++;
 4329              		.loc 1 1937 0
 4330 009c 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 4331 009e 0134     		adds	r4, r4, #1
 4332              	.LVL492:
 4333 00a0 EA54     		strb	r2, [r5, r3]
 4334 00a2 F3E7     		b	.L694
 4335              	.LVL493:
 4336              	.L702:
1938:sxmlc/sxmlc.c **** 		}
1939:sxmlc/sxmlc.c **** 	}
1940:sxmlc/sxmlc.c **** 	str[i] = NULC;
 4337              		.loc 1 1940 0
 4338 00a4 EA54     		strb	r2, [r5, r3]
 4339              	.LVL494:
 4340              	.L690:
1941:sxmlc/sxmlc.c **** 	
1942:sxmlc/sxmlc.c **** 	return str;
1943:sxmlc/sxmlc.c **** }
 4341              		.loc 1 1943 0
 4342 00a6 2846     		mov	r0, r5
 4343 00a8 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 4344              	.LVL495:
 4345              	.L704:
 4346              		.align	2
 4347              	.L703:
 4348 00ac 00000000 		.word	__ctype_ptr__
 4349              		.cfi_endproc
 4350              	.LFE61:
 4352              		.section	.text.str_unescape,"ax",%progbits
 4353              		.align	1
 4354              		.global	str_unescape
 4355              		.thumb
 4356              		.thumb_func
 4358              	str_unescape:
 4359              	.LFB62:
1944:sxmlc/sxmlc.c **** 
1945:sxmlc/sxmlc.c **** SXML_CHAR* str_unescape(SXML_CHAR* str)
1946:sxmlc/sxmlc.c **** {
 4360              		.loc 1 1946 0
 4361              		.cfi_startproc
 4362              		@ args = 0, pretend = 0, frame = 0
 4363              		@ frame_needed = 0, uses_anonymous_args = 0
 4364              		@ link register save eliminated.
 4365              	.LVL496:
1947:sxmlc/sxmlc.c **** 	int i, j;
1948:sxmlc/sxmlc.c **** 
1949:sxmlc/sxmlc.c **** 	if (str == NULL)
 4366              		.loc 1 1949 0
 4367 0000 58B1     		cbz	r0, .L706
 4368 0002 411E     		subs	r1, r0, #1
 4369 0004 0023     		movs	r3, #0
 4370              	.L707:
 4371              	.LVL497:
1950:sxmlc/sxmlc.c **** 		return NULL;
1951:sxmlc/sxmlc.c **** 
1952:sxmlc/sxmlc.c **** 	for (i = j = 0; str[j]; j++) {
 4372              		.loc 1 1952 0 discriminator 1
 4373 0006 C25C     		ldrb	r2, [r0, r3]	@ zero_extendqisi2
 4374 0008 3AB1     		cbz	r2, .L706
1953:sxmlc/sxmlc.c **** 		if (str[j] == C2SX('\\'))
 4375              		.loc 1 1953 0
 4376 000a 5C2A     		cmp	r2, #92
1954:sxmlc/sxmlc.c **** 			j++;
 4377              		.loc 1 1954 0
 4378 000c 08BF     		it	eq
 4379 000e 0133     		addeq	r3, r3, #1
 4380              	.LVL498:
1955:sxmlc/sxmlc.c **** 		str[i++] = str[j];
 4381              		.loc 1 1955 0
 4382 0010 C25C     		ldrb	r2, [r0, r3]	@ zero_extendqisi2
1952:sxmlc/sxmlc.c **** 	for (i = j = 0; str[j]; j++) {
 4383              		.loc 1 1952 0
 4384 0012 0133     		adds	r3, r3, #1
 4385              	.LVL499:
 4386              		.loc 1 1955 0
 4387 0014 01F8012F 		strb	r2, [r1, #1]!
 4388              	.LVL500:
 4389 0018 F5E7     		b	.L707
 4390              	.LVL501:
 4391              	.L706:
1956:sxmlc/sxmlc.c **** 	}
1957:sxmlc/sxmlc.c **** 
1958:sxmlc/sxmlc.c **** 	return str;
1959:sxmlc/sxmlc.c **** }
 4392              		.loc 1 1959 0
 4393 001a 7047     		bx	lr
 4394              		.cfi_endproc
 4395              	.LFE62:
 4397              		.section	.text.split_left_right,"ax",%progbits
 4398              		.align	1
 4399              		.global	split_left_right
 4400              		.thumb
 4401              		.thumb_func
 4403              	split_left_right:
 4404              	.LFB63:
1960:sxmlc/sxmlc.c **** 
1961:sxmlc/sxmlc.c **** int split_left_right(SXML_CHAR* str, SXML_CHAR sep, int* l0, int* l1, int* i_sep, int* r0, int* r1,
1962:sxmlc/sxmlc.c **** {
 4405              		.loc 1 1962 0
 4406              		.cfi_startproc
 4407              		@ args = 20, pretend = 0, frame = 0
 4408              		@ frame_needed = 0, uses_anonymous_args = 0
 4409              	.LVL502:
 4410 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 4411              		.cfi_def_cfa_offset 36
 4412              		.cfi_offset 4, -36
 4413              		.cfi_offset 5, -32
 4414              		.cfi_offset 6, -28
 4415              		.cfi_offset 7, -24
 4416              		.cfi_offset 8, -20
 4417              		.cfi_offset 9, -16
 4418              		.cfi_offset 10, -12
 4419              		.cfi_offset 11, -8
 4420              		.cfi_offset 14, -4
 4421              		.loc 1 1962 0
 4422 0004 DDF83080 		ldr	r8, [sp, #48]
 4423 0008 9146     		mov	r9, r2
 4424 000a 9A46     		mov	r10, r3
 4425 000c 0A9A     		ldr	r2, [sp, #40]
 4426              	.LVL503:
 4427 000e 099B     		ldr	r3, [sp, #36]
 4428              	.LVL504:
 4429 0010 0D9F     		ldr	r7, [sp, #52]
1963:sxmlc/sxmlc.c **** 	int n0, n1, is;
1964:sxmlc/sxmlc.c **** 	SXML_CHAR quote = '\0';
1965:sxmlc/sxmlc.c **** 
1966:sxmlc/sxmlc.c **** 	if (str == NULL)
 4430              		.loc 1 1966 0
 4431 0012 10B9     		cbnz	r0, .L713
 4432              	.LVL505:
 4433              	.L738:
1967:sxmlc/sxmlc.c **** 		return false;
 4434              		.loc 1 1967 0
 4435 0014 0020     		movs	r0, #0
 4436              	.LVL506:
 4437 0016 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 4438              	.LVL507:
 4439              	.L713:
1968:sxmlc/sxmlc.c **** 
1969:sxmlc/sxmlc.c **** 	if (i_sep != NULL)
 4440              		.loc 1 1969 0
 4441 001a 13B1     		cbz	r3, .L715
1970:sxmlc/sxmlc.c **** 		*i_sep = -1;
 4442              		.loc 1 1970 0
 4443 001c 4FF0FF34 		mov	r4, #-1
 4444 0020 1C60     		str	r4, [r3]
 4445              	.L715:
1971:sxmlc/sxmlc.c **** 
1972:sxmlc/sxmlc.c **** 	if (!ignore_spaces) /* No sense of ignore quotes if spaces are to be kept */
 4446              		.loc 1 1972 0
 4447 0022 B8F1000F 		cmp	r8, #0
 4448 0026 05D0     		beq	.L716
1973:sxmlc/sxmlc.c **** 		ignore_quotes = false;
1974:sxmlc/sxmlc.c **** 
1975:sxmlc/sxmlc.c **** 	/* Parse left part */
1976:sxmlc/sxmlc.c **** 
1977:sxmlc/sxmlc.c **** 	if (ignore_spaces) {
1978:sxmlc/sxmlc.c **** 		for (n0 = 0; str[n0] != NULC && sx_isspace(str[n0]); n0++) ; /* Skip head spaces, n0 points to fi
 4449              		.loc 1 1978 0
 4450 0028 5A4C     		ldr	r4, .L838
 4451 002a 4FF0000C 		mov	ip, #0
 4452 002e D4F800B0 		ldr	fp, [r4]
 4453 0032 08E0     		b	.L717
 4454              	.L716:
1972:sxmlc/sxmlc.c **** 	if (!ignore_spaces) /* No sense of ignore quotes if spaces are to be kept */
 4455              		.loc 1 1972 0
 4456 0034 4446     		mov	r4, r8
 4457 0036 45E0     		b	.L718
 4458              	.LVL508:
 4459              	.L719:
 4460              		.loc 1 1978 0 discriminator 2
 4461 0038 0BEB0604 		add	r4, fp, r6
 4462 003c 6478     		ldrb	r4, [r4, #1]	@ zero_extendqisi2
 4463 003e 2407     		lsls	r4, r4, #28
 4464 0040 07D5     		bpl	.L833
 4465              		.loc 1 1978 0 is_stmt 0 discriminator 1
 4466 0042 0CF1010C 		add	ip, ip, #1
 4467              	.LVL509:
 4468              	.L717:
 4469 0046 10F80C60 		ldrb	r6, [r0, ip]	@ zero_extendqisi2
 4470 004a 002E     		cmp	r6, #0
 4471 004c F4D1     		bne	.L719
 4472              	.L722:
1979:sxmlc/sxmlc.c **** 		if (ignore_quotes && isquote(str[n0])) { /* If quote is found, look for next one */
1980:sxmlc/sxmlc.c **** 			quote = str[n0++]; /* Quote can be '\'' or '"' */
1981:sxmlc/sxmlc.c **** 			for (n1 = n0; str[n1] != NULC && str[n1] != quote; n1++) {
 4473              		.loc 1 1981 0 is_stmt 1
 4474 004e 6446     		mov	r4, ip
 4475 0050 24E0     		b	.L720
 4476              	.L833:
1979:sxmlc/sxmlc.c **** 		if (ignore_quotes && isquote(str[n0])) { /* If quote is found, look for next one */
 4477              		.loc 1 1979 0
 4478 0052 002F     		cmp	r7, #0
 4479 0054 FBD0     		beq	.L722
1979:sxmlc/sxmlc.c **** 		if (ignore_quotes && isquote(str[n0])) { /* If quote is found, look for next one */
 4480              		.loc 1 1979 0 is_stmt 0 discriminator 1
 4481 0056 222E     		cmp	r6, #34
 4482 0058 01D0     		beq	.L723
 4483 005a 272E     		cmp	r6, #39
 4484 005c F7D1     		bne	.L722
 4485              	.L723:
1980:sxmlc/sxmlc.c **** 			quote = str[n0++]; /* Quote can be '\'' or '"' */
 4486              		.loc 1 1980 0 is_stmt 1
 4487 005e 0CF1010C 		add	ip, ip, #1
 4488              	.LVL510:
 4489              		.loc 1 1981 0
 4490 0062 6446     		mov	r4, ip
 4491              	.LVL511:
 4492              	.L724:
 4493              		.loc 1 1981 0 is_stmt 0 discriminator 1
 4494 0064 015D     		ldrb	r1, [r0, r4]	@ zero_extendqisi2
 4495 0066 41B1     		cbz	r1, .L726
 4496              		.loc 1 1981 0 discriminator 2
 4497 0068 B142     		cmp	r1, r6
 4498 006a 06D0     		beq	.L726
1982:sxmlc/sxmlc.c **** 				if (str[n1] == C2SX('\\') && str[++n1] == NULC)
 4499              		.loc 1 1982 0 is_stmt 1
 4500 006c 5C29     		cmp	r1, #92
 4501 006e 02D1     		bne	.L725
 4502              		.loc 1 1982 0 is_stmt 0 discriminator 1
 4503 0070 0134     		adds	r4, r4, #1
 4504              	.LVL512:
 4505 0072 015D     		ldrb	r1, [r0, r4]	@ zero_extendqisi2
 4506 0074 09B1     		cbz	r1, .L726
 4507              	.L725:
1981:sxmlc/sxmlc.c **** 			for (n1 = n0; str[n1] != NULC && str[n1] != quote; n1++) {
 4508              		.loc 1 1981 0 is_stmt 1
 4509 0076 0134     		adds	r4, r4, #1
 4510              	.LVL513:
 4511 0078 F4E7     		b	.L724
 4512              	.L726:
1983:sxmlc/sxmlc.c **** 					break; /* Escape character (can be the last) */
1984:sxmlc/sxmlc.c **** 			}
1985:sxmlc/sxmlc.c **** 			for (is = n1 + 1; str[is] != NULC && sx_isspace(str[is]); is++) ; /* '--' not to take quote into
 4513              		.loc 1 1985 0
 4514 007a 651C     		adds	r5, r4, #1
 4515              	.LVL514:
 4516              	.L728:
 4517              		.loc 1 1985 0 is_stmt 0 discriminator 1
 4518 007c 415D     		ldrb	r1, [r0, r5]	@ zero_extendqisi2
 4519 007e 0029     		cmp	r1, #0
 4520 0080 2DD0     		beq	.L729
 4521              		.loc 1 1985 0 discriminator 2
 4522 0082 5944     		add	r1, r1, fp
 4523 0084 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 4524 0086 0907     		lsls	r1, r1, #28
 4525 0088 29D5     		bpl	.L729
 4526              		.loc 1 1985 0 discriminator 1
 4527 008a 0135     		adds	r5, r5, #1
 4528              	.LVL515:
 4529 008c F6E7     		b	.L728
 4530              	.LVL516:
 4531              	.L731:
1986:sxmlc/sxmlc.c **** 		} else {
1987:sxmlc/sxmlc.c **** 			for (n1 = n0; str[n1] != NULC && str[n1] != sep && !sx_isspace(str[n1]); n1++) ; /* Search for s
 4532              		.loc 1 1987 0 is_stmt 1 discriminator 2
 4533 008e 8D42     		cmp	r5, r1
 4534 0090 07D0     		beq	.L733
 4535              		.loc 1 1987 0 is_stmt 0 discriminator 1
 4536 0092 5D44     		add	r5, r5, fp
 4537 0094 6D78     		ldrb	r5, [r5, #1]	@ zero_extendqisi2
 4538 0096 2D07     		lsls	r5, r5, #28
 4539 0098 03D4     		bmi	.L733
 4540 009a 0134     		adds	r4, r4, #1
 4541              	.LVL517:
 4542              	.L720:
 4543 009c 055D     		ldrb	r5, [r0, r4]	@ zero_extendqisi2
 4544 009e 002D     		cmp	r5, #0
 4545 00a0 F5D1     		bne	.L731
 4546              	.L733:
1981:sxmlc/sxmlc.c **** 			for (n1 = n0; str[n1] != NULC && str[n1] != quote; n1++) {
 4547              		.loc 1 1981 0 is_stmt 1
 4548 00a2 2546     		mov	r5, r4
 4549 00a4 07E0     		b	.L732
 4550              	.LVL518:
 4551              	.L834:
1988:sxmlc/sxmlc.c **** 			for (is = n1; str[is] != NULC && sx_isspace(str[is]); is++) ;
 4552              		.loc 1 1988 0 discriminator 2
 4553 00a6 5E44     		add	r6, r6, fp
 4554 00a8 7178     		ldrb	r1, [r6, #1]	@ zero_extendqisi2
 4555 00aa 01F00801 		and	r1, r1, #8
 4556 00ae 01F0FF06 		and	r6, r1, #255
 4557 00b2 A1B1     		cbz	r1, .L729
 4558              		.loc 1 1988 0 is_stmt 0 discriminator 1
 4559 00b4 0135     		adds	r5, r5, #1
 4560              	.LVL519:
 4561              	.L732:
 4562 00b6 465D     		ldrb	r6, [r0, r5]	@ zero_extendqisi2
 4563 00b8 002E     		cmp	r6, #0
 4564 00ba F4D1     		bne	.L834
 4565 00bc 0FE0     		b	.L729
 4566              	.LVL520:
 4567              	.L836:
1989:sxmlc/sxmlc.c **** 		}
1990:sxmlc/sxmlc.c **** 	} else {
1991:sxmlc/sxmlc.c **** 		n0 = 0;
1992:sxmlc/sxmlc.c **** 		for (n1 = 0; str[n1] != NULC && str[n1] != sep; n1++) ; /* Search for separator only */
 4568              		.loc 1 1992 0 is_stmt 1 discriminator 2
 4569 00be 8D42     		cmp	r5, r1
 4570 00c0 04D0     		beq	.L835
 4571              		.loc 1 1992 0 is_stmt 0 discriminator 1
 4572 00c2 0134     		adds	r4, r4, #1
 4573              	.LVL521:
 4574              	.L718:
 4575 00c4 055D     		ldrb	r5, [r0, r4]	@ zero_extendqisi2
 4576 00c6 002D     		cmp	r5, #0
 4577 00c8 F9D1     		bne	.L836
 4578 00ca 02E0     		b	.L736
 4579              	.L835:
 4580 00cc 2546     		mov	r5, r4
1973:sxmlc/sxmlc.c **** 		ignore_quotes = false;
 4581              		.loc 1 1973 0 is_stmt 1
 4582 00ce 0027     		movs	r7, #0
 4583 00d0 03E0     		b	.L831
 4584              	.L736:
1993:sxmlc/sxmlc.c **** 		if (str[n1] != sep) /* Separator not found: malformed string */
 4585              		.loc 1 1993 0
 4586 00d2 0029     		cmp	r1, #0
 4587 00d4 9ED1     		bne	.L738
 4588 00d6 2546     		mov	r5, r4
1973:sxmlc/sxmlc.c **** 		ignore_quotes = false;
 4589              		.loc 1 1973 0
 4590 00d8 0F46     		mov	r7, r1
 4591              	.L831:
1964:sxmlc/sxmlc.c **** 	SXML_CHAR quote = '\0';
 4592              		.loc 1 1964 0
 4593 00da 3E46     		mov	r6, r7
1991:sxmlc/sxmlc.c **** 		n0 = 0;
 4594              		.loc 1 1991 0
 4595 00dc BC46     		mov	ip, r7
 4596              	.LVL522:
 4597              	.L729:
1994:sxmlc/sxmlc.c **** 			return false;
1995:sxmlc/sxmlc.c **** 		is = n1;
1996:sxmlc/sxmlc.c **** 	}
1997:sxmlc/sxmlc.c **** 
1998:sxmlc/sxmlc.c **** 	/* Here 'n0' is the start of left member, 'n1' is the character after the end of left member */
1999:sxmlc/sxmlc.c **** 
2000:sxmlc/sxmlc.c **** 	if (l0 != NULL)
 4598              		.loc 1 2000 0
 4599 00de B9F1000F 		cmp	r9, #0
 4600 00e2 01D0     		beq	.L739
2001:sxmlc/sxmlc.c **** 		*l0 = n0;
 4601              		.loc 1 2001 0
 4602 00e4 C9F800C0 		str	ip, [r9]
 4603              	.L739:
2002:sxmlc/sxmlc.c **** 	if (l1 != NULL)
 4604              		.loc 1 2002 0
 4605 00e8 BAF1000F 		cmp	r10, #0
 4606 00ec 02D0     		beq	.L740
2003:sxmlc/sxmlc.c **** 		*l1 = n1 - 1;
 4607              		.loc 1 2003 0
 4608 00ee 013C     		subs	r4, r4, #1
 4609              	.LVL523:
 4610 00f0 CAF80040 		str	r4, [r10]
 4611              	.LVL524:
 4612              	.L740:
2004:sxmlc/sxmlc.c **** 	if (i_sep != NULL)
 4613              		.loc 1 2004 0
 4614 00f4 03B1     		cbz	r3, .L741
2005:sxmlc/sxmlc.c **** 		*i_sep = is;
 4615              		.loc 1 2005 0
 4616 00f6 1D60     		str	r5, [r3]
 4617              	.L741:
2006:sxmlc/sxmlc.c **** 	if (str[is] == NULC || str[is+1] == NULC) { /* No separator => empty right member */
 4618              		.loc 1 2006 0
 4619 00f8 445D     		ldrb	r4, [r0, r5]	@ zero_extendqisi2
 4620 00fa 4119     		adds	r1, r0, r5
 4621 00fc 0CB1     		cbz	r4, .L742
 4622              		.loc 1 2006 0 is_stmt 0 discriminator 1
 4623 00fe 4C78     		ldrb	r4, [r1, #1]	@ zero_extendqisi2
 4624 0100 7CB9     		cbnz	r4, .L743
 4625              	.L742:
2007:sxmlc/sxmlc.c **** 		if (r0 != NULL)
 4626              		.loc 1 2007 0 is_stmt 1
 4627 0102 02B1     		cbz	r2, .L744
2008:sxmlc/sxmlc.c **** 			*r0 = is;
 4628              		.loc 1 2008 0
 4629 0104 1560     		str	r5, [r2]
 4630              	.L744:
2009:sxmlc/sxmlc.c **** 		if (r1 != NULL)
 4631              		.loc 1 2009 0
 4632 0106 0B9A     		ldr	r2, [sp, #44]
 4633 0108 12B1     		cbz	r2, .L745
2010:sxmlc/sxmlc.c **** 			*r1 = is-1;
 4634              		.loc 1 2010 0
 4635 010a 0B9C     		ldr	r4, [sp, #44]
 4636 010c 6A1E     		subs	r2, r5, #1
 4637 010e 2260     		str	r2, [r4]
 4638              	.L745:
2011:sxmlc/sxmlc.c **** 		if (i_sep != NULL)
 4639              		.loc 1 2011 0
 4640 0110 002B     		cmp	r3, #0
 4641 0112 3CD0     		beq	.L832
2012:sxmlc/sxmlc.c **** 			*i_sep = (str[is] == NULC ? -1 : is);
 4642              		.loc 1 2012 0
 4643 0114 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 4644 0116 002A     		cmp	r2, #0
 4645 0118 08BF     		it	eq
 4646 011a 4FF0FF35 		moveq	r5, #-1
 4647              	.LVL525:
 4648 011e 1D60     		str	r5, [r3]
 4649 0120 35E0     		b	.L832
 4650              	.LVL526:
 4651              	.L743:
2013:sxmlc/sxmlc.c **** 		return true;
2014:sxmlc/sxmlc.c **** 	}
2015:sxmlc/sxmlc.c **** 
2016:sxmlc/sxmlc.c **** 	/* Parse right part */
2017:sxmlc/sxmlc.c **** 
2018:sxmlc/sxmlc.c **** 	n0 = is + 1;
 4652              		.loc 1 2018 0
 4653 0122 0135     		adds	r5, r5, #1
 4654              	.LVL527:
2019:sxmlc/sxmlc.c **** 	if (ignore_spaces) {
 4655              		.loc 1 2019 0
 4656 0124 B8F1000F 		cmp	r8, #0
 4657 0128 11D0     		beq	.L748
2020:sxmlc/sxmlc.c **** 		for (; str[n0] != NULC && sx_isspace(str[n0]); n0++) ;
 4658              		.loc 1 2020 0
 4659 012a 1A4B     		ldr	r3, .L838
 4660 012c 1C68     		ldr	r4, [r3]
 4661              	.LVL528:
 4662              	.L749:
 4663              		.loc 1 2020 0 is_stmt 0 discriminator 1
 4664 012e 435D     		ldrb	r3, [r0, r5]	@ zero_extendqisi2
 4665 0130 6BB1     		cbz	r3, .L748
 4666              		.loc 1 2020 0 discriminator 2
 4667 0132 E118     		adds	r1, r4, r3
 4668 0134 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 4669 0136 0907     		lsls	r1, r1, #28
 4670 0138 01D5     		bpl	.L837
 4671              		.loc 1 2020 0 discriminator 1
 4672 013a 0135     		adds	r5, r5, #1
 4673              	.LVL529:
 4674 013c F7E7     		b	.L749
 4675              	.L837:
2021:sxmlc/sxmlc.c **** 		if (ignore_quotes && isquote(str[n0]))
 4676              		.loc 1 2021 0 is_stmt 1
 4677 013e 37B1     		cbz	r7, .L748
 4678              		.loc 1 2021 0 is_stmt 0 discriminator 1
 4679 0140 222B     		cmp	r3, #34
 4680 0142 03D0     		beq	.L766
 4681 0144 272B     		cmp	r3, #39
 4682 0146 08BF     		it	eq
 4683 0148 2726     		moveq	r6, #39
 4684              	.LVL530:
 4685 014a 00E0     		b	.L748
 4686              	.LVL531:
 4687              	.L766:
 4688 014c 1E46     		mov	r6, r3
 4689              	.LVL532:
 4690              	.L748:
2022:sxmlc/sxmlc.c **** 			quote = str[n0];
2023:sxmlc/sxmlc.c **** 	}
2024:sxmlc/sxmlc.c **** 
2025:sxmlc/sxmlc.c **** 	for (n1 = ++n0; str[n1]; n1++) {
 4691              		.loc 1 2025 0 is_stmt 1
 4692 014e 0135     		adds	r5, r5, #1
 4693              	.LVL533:
 4694 0150 2B46     		mov	r3, r5
 4695              	.LVL534:
 4696              	.L752:
 4697              		.loc 1 2025 0 is_stmt 0 discriminator 1
 4698 0152 C15C     		ldrb	r1, [r0, r3]	@ zero_extendqisi2
 4699 0154 49B1     		cbz	r1, .L756
2026:sxmlc/sxmlc.c **** 		if (ignore_quotes && str[n1] == quote) /* Quote was reached */
 4700              		.loc 1 2026 0 is_stmt 1
 4701 0156 0FB1     		cbz	r7, .L753
 4702              		.loc 1 2026 0 is_stmt 0 discriminator 1
 4703 0158 B142     		cmp	r1, r6
 4704 015a 07D0     		beq	.L754
 4705              	.L753:
2027:sxmlc/sxmlc.c **** 			break;
2028:sxmlc/sxmlc.c **** 		if (str[n1] == C2SX('\\') && str[++n1] == NULC) /* Escape character (can be the last) */
 4706              		.loc 1 2028 0 is_stmt 1
 4707 015c 5C29     		cmp	r1, #92
 4708 015e 02D1     		bne	.L755
 4709              		.loc 1 2028 0 is_stmt 0 discriminator 1
 4710 0160 0133     		adds	r3, r3, #1
 4711              	.LVL535:
 4712 0162 C15C     		ldrb	r1, [r0, r3]	@ zero_extendqisi2
 4713 0164 09B1     		cbz	r1, .L756
 4714              	.L755:
2025:sxmlc/sxmlc.c **** 	for (n1 = ++n0; str[n1]; n1++) {
 4715              		.loc 1 2025 0 is_stmt 1
 4716 0166 0133     		adds	r3, r3, #1
 4717              	.LVL536:
 4718 0168 F3E7     		b	.L752
 4719              	.L756:
2029:sxmlc/sxmlc.c **** 			break;
2030:sxmlc/sxmlc.c **** 	}
2031:sxmlc/sxmlc.c **** 	if (ignore_quotes && str[n1--] != quote) /* Quote is not the same than earlier, '--' is not to tak
 4720              		.loc 1 2031 0
 4721 016a 27B1     		cbz	r7, .L758
 4722              	.L754:
 4723              	.LVL537:
 4724              		.loc 1 2031 0 is_stmt 0 discriminator 1
 4725 016c C15C     		ldrb	r1, [r0, r3]	@ zero_extendqisi2
 4726 016e B142     		cmp	r1, r6
 4727 0170 7FF450AF 		bne	.L738
 4728              		.loc 1 2031 0
 4729 0174 013B     		subs	r3, r3, #1
 4730              	.LVL538:
 4731              	.L758:
2032:sxmlc/sxmlc.c **** 		return false;
2033:sxmlc/sxmlc.c **** 	if (!ignore_spaces)
 4732              		.loc 1 2033 0 is_stmt 1
 4733 0176 B8F1000F 		cmp	r8, #0
 4734 017a 03D1     		bne	.L759
 4735              	.L760:
2034:sxmlc/sxmlc.c **** 		while (str[++n1]) ; /* Jump down the end of the string */
 4736              		.loc 1 2034 0 discriminator 1
 4737 017c 0133     		adds	r3, r3, #1
 4738              	.LVL539:
 4739 017e C15C     		ldrb	r1, [r0, r3]	@ zero_extendqisi2
 4740 0180 0029     		cmp	r1, #0
 4741 0182 FBD1     		bne	.L760
 4742              	.L759:
2035:sxmlc/sxmlc.c **** 
2036:sxmlc/sxmlc.c **** 	if (r0 != NULL)
 4743              		.loc 1 2036 0
 4744 0184 02B1     		cbz	r2, .L761
2037:sxmlc/sxmlc.c **** 		*r0 = n0;
 4745              		.loc 1 2037 0
 4746 0186 1560     		str	r5, [r2]
 4747              	.L761:
2038:sxmlc/sxmlc.c **** 	if (r1 != NULL)
 4748              		.loc 1 2038 0
 4749 0188 0B9A     		ldr	r2, [sp, #44]
 4750 018a 02B1     		cbz	r2, .L832
2039:sxmlc/sxmlc.c **** 		*r1 = n1;
 4751              		.loc 1 2039 0
 4752 018c 1360     		str	r3, [r2]
 4753              	.LVL540:
 4754              	.L832:
2040:sxmlc/sxmlc.c **** 
2041:sxmlc/sxmlc.c **** 	return true;
 4755              		.loc 1 2041 0
 4756 018e 0120     		movs	r0, #1
 4757              	.LVL541:
2042:sxmlc/sxmlc.c **** }
 4758              		.loc 1 2042 0
 4759 0190 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 4760              	.LVL542:
 4761              	.L839:
 4762              		.align	2
 4763              	.L838:
 4764 0194 00000000 		.word	__ctype_ptr__
 4765              		.cfi_endproc
 4766              	.LFE63:
 4768              		.section	.text.freadBOM,"ax",%progbits
 4769              		.align	1
 4770              		.global	freadBOM
 4771              		.thumb
 4772              		.thumb_func
 4774              	freadBOM:
 4775              	.LFB64:
2043:sxmlc/sxmlc.c **** 
2044:sxmlc/sxmlc.c **** BOM_TYPE freadBOM(FILE* f, unsigned char* bom, int* sz_bom)
2045:sxmlc/sxmlc.c **** {
 4776              		.loc 1 2045 0
 4777              		.cfi_startproc
 4778              		@ args = 0, pretend = 0, frame = 8
 4779              		@ frame_needed = 0, uses_anonymous_args = 0
 4780              	.LVL543:
 4781 0000 2DE9F341 		push	{r0, r1, r4, r5, r6, r7, r8, lr}
 4782              		.cfi_def_cfa_offset 32
 4783              		.cfi_offset 0, -32
 4784              		.cfi_offset 1, -28
 4785              		.cfi_offset 4, -24
 4786              		.cfi_offset 5, -20
 4787              		.cfi_offset 6, -16
 4788              		.cfi_offset 7, -12
 4789              		.cfi_offset 8, -8
 4790              		.cfi_offset 14, -4
 4791              		.loc 1 2045 0
 4792 0004 0C46     		mov	r4, r1
 4793 0006 1646     		mov	r6, r2
2046:sxmlc/sxmlc.c **** 	unsigned char c1, c2;
2047:sxmlc/sxmlc.c **** 	long pos;
2048:sxmlc/sxmlc.c **** 
2049:sxmlc/sxmlc.c **** 	if (f == NULL)
 4794              		.loc 1 2049 0
 4795 0008 0546     		mov	r5, r0
 4796 000a 98B1     		cbz	r0, .L890
2050:sxmlc/sxmlc.c **** 		return BOM_NONE;
2051:sxmlc/sxmlc.c **** 
2052:sxmlc/sxmlc.c **** 	/* Save position and try to read and skip BOM if found. If not, go back to save position. */
2053:sxmlc/sxmlc.c **** 	pos = ftell(f);
 4797              		.loc 1 2053 0
 4798 000c FFF7FEFF 		bl	ftell
 4799              	.LVL544:
2054:sxmlc/sxmlc.c **** 	if (pos < 0)
 4800              		.loc 1 2054 0
 4801 0010 B0F10008 		subs	r8, r0, #0
 4802 0014 0EDB     		blt	.L890
2055:sxmlc/sxmlc.c **** 		return BOM_NONE;
2056:sxmlc/sxmlc.c **** 	if (fread(&c1, sizeof(char), 1, f) != 1 || fread(&c2, sizeof(char), 1, f) != 1) {
 4803              		.loc 1 2056 0
 4804 0016 0121     		movs	r1, #1
 4805 0018 0A46     		mov	r2, r1
 4806 001a 0DF10600 		add	r0, sp, #6
 4807              	.LVL545:
 4808 001e 2B46     		mov	r3, r5
 4809 0020 FFF7FEFF 		bl	fread
 4810              	.LVL546:
 4811 0024 0128     		cmp	r0, #1
 4812 0026 0146     		mov	r1, r0
 4813 0028 06D0     		beq	.L844
 4814              	.L845:
2057:sxmlc/sxmlc.c **** 		fseek(f, pos, SEEK_SET);
 4815              		.loc 1 2057 0
 4816 002a 2846     		mov	r0, r5
 4817 002c 4146     		mov	r1, r8
 4818 002e 0022     		movs	r2, #0
 4819 0030 FFF7FEFF 		bl	fseek
 4820              	.LVL547:
 4821              	.L890:
2058:sxmlc/sxmlc.c **** 		return BOM_NONE;
 4822              		.loc 1 2058 0
 4823 0034 0020     		movs	r0, #0
 4824 0036 A0E0     		b	.L842
 4825              	.LVL548:
 4826              	.L844:
2056:sxmlc/sxmlc.c **** 	if (fread(&c1, sizeof(char), 1, f) != 1 || fread(&c2, sizeof(char), 1, f) != 1) {
 4827              		.loc 1 2056 0 discriminator 1
 4828 0038 0DF10700 		add	r0, sp, #7
 4829 003c 0A46     		mov	r2, r1
 4830 003e 2B46     		mov	r3, r5
 4831 0040 FFF7FEFF 		bl	fread
 4832              	.LVL549:
 4833 0044 0128     		cmp	r0, #1
 4834 0046 F0D1     		bne	.L845
 4835 0048 9DF80670 		ldrb	r7, [sp, #6]	@ zero_extendqisi2
 4836 004c 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
2059:sxmlc/sxmlc.c **** 	}
2060:sxmlc/sxmlc.c **** 	if (bom != NULL) {
 4837              		.loc 1 2060 0
 4838 0050 34B1     		cbz	r4, .L847
2061:sxmlc/sxmlc.c **** 		bom[0] = c1;
2062:sxmlc/sxmlc.c **** 		bom[1] = c2;
2063:sxmlc/sxmlc.c **** 		bom[2] = '\0';
 4839              		.loc 1 2063 0
 4840 0052 0022     		movs	r2, #0
2061:sxmlc/sxmlc.c **** 		bom[0] = c1;
 4841              		.loc 1 2061 0
 4842 0054 2770     		strb	r7, [r4]
2062:sxmlc/sxmlc.c **** 		bom[1] = c2;
 4843              		.loc 1 2062 0
 4844 0056 6370     		strb	r3, [r4, #1]
 4845              		.loc 1 2063 0
 4846 0058 A270     		strb	r2, [r4, #2]
2064:sxmlc/sxmlc.c **** 		if (sz_bom != NULL)
 4847              		.loc 1 2064 0
 4848 005a 0EB1     		cbz	r6, .L847
2065:sxmlc/sxmlc.c **** 			*sz_bom = 2;
 4849              		.loc 1 2065 0
 4850 005c 0222     		movs	r2, #2
 4851 005e 3260     		str	r2, [r6]
 4852              	.L847:
2066:sxmlc/sxmlc.c **** 	}
2067:sxmlc/sxmlc.c **** 	switch ((unsigned short)(c1 << 8) | c2) {
 4853              		.loc 1 2067 0
 4854 0060 43EA0727 		orr	r7, r3, r7, lsl #8
 4855 0064 4EF6BB73 		movw	r3, #61371
 4856 0068 9F42     		cmp	r7, r3
 4857 006a 5BD0     		beq	.L850
 4858 006c 02DC     		bgt	.L851
 4859 006e 002F     		cmp	r7, #0
 4860 0070 37D0     		beq	.L852
 4861 0072 6CE0     		b	.L849
 4862              	.L851:
 4863 0074 4FF6FF63 		movw	r3, #65279
 4864 0078 9F42     		cmp	r7, r3
 4865 007a 76D0     		beq	.L865
 4866 007c 4FF6FE73 		movw	r3, #65534
 4867 0080 9F42     		cmp	r7, r3
 4868 0082 64D1     		bne	.L849
2068:sxmlc/sxmlc.c **** 		case (unsigned short)0xfeff:
2069:sxmlc/sxmlc.c **** 			return BOM_UTF_16BE;
2070:sxmlc/sxmlc.c **** 
2071:sxmlc/sxmlc.c **** 		case (unsigned short)0xfffe:
2072:sxmlc/sxmlc.c **** 			pos = ftell(f); /* Save current position to get it back if BOM is not UTF-32LE */
 4869              		.loc 1 2072 0
 4870 0084 2846     		mov	r0, r5
 4871 0086 FFF7FEFF 		bl	ftell
 4872              	.LVL550:
2073:sxmlc/sxmlc.c **** 			if (pos < 0)
 4873              		.loc 1 2073 0
 4874 008a B0F10008 		subs	r8, r0, #0
 4875 008e 6CDB     		blt	.L865
2074:sxmlc/sxmlc.c **** 				return BOM_UTF_16LE;
2075:sxmlc/sxmlc.c **** 			if (fread(&c1, sizeof(char), 1, f) != 1 || fread(&c2, sizeof(char), 1, f) != 1) {
 4876              		.loc 1 2075 0
 4877 0090 0121     		movs	r1, #1
 4878 0092 0A46     		mov	r2, r1
 4879 0094 0DF10600 		add	r0, sp, #6
 4880              	.LVL551:
 4881 0098 2B46     		mov	r3, r5
 4882 009a FFF7FEFF 		bl	fread
 4883              	.LVL552:
 4884 009e 0128     		cmp	r0, #1
 4885 00a0 0146     		mov	r1, r0
 4886 00a2 16D1     		bne	.L856
 4887              		.loc 1 2075 0 is_stmt 0 discriminator 1
 4888 00a4 0DF10700 		add	r0, sp, #7
 4889 00a8 0A46     		mov	r2, r1
 4890 00aa 2B46     		mov	r3, r5
 4891 00ac FFF7FEFF 		bl	fread
 4892              	.LVL553:
 4893 00b0 0128     		cmp	r0, #1
 4894 00b2 0ED1     		bne	.L856
2076:sxmlc/sxmlc.c **** 				fseek(f, pos, SEEK_SET);
2077:sxmlc/sxmlc.c **** 				return BOM_UTF_16LE;
2078:sxmlc/sxmlc.c **** 			}
2079:sxmlc/sxmlc.c **** 			if (c1 == 0x00 && c2 == 0x00) {
 4895              		.loc 1 2079 0 is_stmt 1
 4896 00b4 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 4897 00b8 5BB9     		cbnz	r3, .L856
 4898              		.loc 1 2079 0 is_stmt 0 discriminator 1
 4899 00ba 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 4900 00be 43B9     		cbnz	r3, .L856
2080:sxmlc/sxmlc.c **** 				if (bom != NULL)
 4901              		.loc 1 2080 0 is_stmt 1
 4902 00c0 14B1     		cbz	r4, .L857
2081:sxmlc/sxmlc.c **** 					bom[2] = bom[3] = bom[4] = '\0';
 4903              		.loc 1 2081 0
 4904 00c2 2371     		strb	r3, [r4, #4]
 4905 00c4 E370     		strb	r3, [r4, #3]
 4906 00c6 A370     		strb	r3, [r4, #2]
 4907              	.L857:
2082:sxmlc/sxmlc.c **** 				if (sz_bom != NULL)
 4908              		.loc 1 2082 0
 4909 00c8 002E     		cmp	r6, #0
 4910 00ca 50D0     		beq	.L866
2083:sxmlc/sxmlc.c **** 					*sz_bom = 4;
 4911              		.loc 1 2083 0
 4912 00cc 0423     		movs	r3, #4
 4913 00ce 3360     		str	r3, [r6]
 4914 00d0 4DE0     		b	.L866
 4915              	.L856:
2084:sxmlc/sxmlc.c **** 				return BOM_UTF_32LE;
2085:sxmlc/sxmlc.c **** 			}
2086:sxmlc/sxmlc.c **** 			fseek(f, pos, SEEK_SET); /* fseek(f, -2, SEEK_CUR) is not garanteed on Windows (and actually fai
 4916              		.loc 1 2086 0
 4917 00d2 2846     		mov	r0, r5
 4918 00d4 4146     		mov	r1, r8
 4919 00d6 0022     		movs	r2, #0
 4920 00d8 FFF7FEFF 		bl	fseek
 4921              	.LVL554:
2087:sxmlc/sxmlc.c **** 			return BOM_UTF_16LE;
 4922              		.loc 1 2087 0
 4923 00dc 4FF6FE70 		movw	r0, #65534
 4924 00e0 4BE0     		b	.L842
 4925              	.L852:
2088:sxmlc/sxmlc.c **** 
2089:sxmlc/sxmlc.c **** 		case (unsigned short)0x0000:
2090:sxmlc/sxmlc.c **** 			if (fread(&c1, sizeof(char), 1, f) == 1 && fread(&c2, sizeof(char), 1, f) == 1
 4926              		.loc 1 2090 0
 4927 00e2 0121     		movs	r1, #1
 4928 00e4 0A46     		mov	r2, r1
 4929 00e6 0DF10600 		add	r0, sp, #6
 4930 00ea 2B46     		mov	r3, r5
 4931 00ec FFF7FEFF 		bl	fread
 4932              	.LVL555:
 4933 00f0 0128     		cmp	r0, #1
 4934 00f2 0146     		mov	r1, r0
 4935 00f4 99D1     		bne	.L845
 4936              		.loc 1 2090 0 is_stmt 0 discriminator 1
 4937 00f6 0DF10700 		add	r0, sp, #7
 4938 00fa 0A46     		mov	r2, r1
 4939 00fc 2B46     		mov	r3, r5
 4940 00fe FFF7FEFF 		bl	fread
 4941              	.LVL556:
 4942 0102 0128     		cmp	r0, #1
 4943 0104 91D1     		bne	.L845
2091:sxmlc/sxmlc.c **** 					&& c1 == 0xfe && c2 == 0xff) {
 4944              		.loc 1 2091 0 is_stmt 1
 4945 0106 9DF80620 		ldrb	r2, [sp, #6]	@ zero_extendqisi2
 4946 010a FE2A     		cmp	r2, #254
 4947 010c 8DD1     		bne	.L845
 4948              		.loc 1 2091 0 is_stmt 0 discriminator 1
 4949 010e 9DF80730 		ldrb	r3, [sp, #7]	@ zero_extendqisi2
 4950 0112 FF2B     		cmp	r3, #255
 4951 0114 89D1     		bne	.L845
2092:sxmlc/sxmlc.c **** 				bom[2] = c1;
 4952              		.loc 1 2092 0 is_stmt 1
 4953 0116 A270     		strb	r2, [r4, #2]
2093:sxmlc/sxmlc.c **** 				bom[3] = c2;
 4954              		.loc 1 2093 0
 4955 0118 E370     		strb	r3, [r4, #3]
2094:sxmlc/sxmlc.c **** 				bom[4] = '\0';
 4956              		.loc 1 2094 0
 4957 011a 2771     		strb	r7, [r4, #4]
2095:sxmlc/sxmlc.c **** 				if (sz_bom != NULL)
 4958              		.loc 1 2095 0
 4959 011c 4EB3     		cbz	r6, .L867
2096:sxmlc/sxmlc.c **** 					*sz_bom = 4;
 4960              		.loc 1 2096 0
 4961 011e 0423     		movs	r3, #4
 4962 0120 3360     		str	r3, [r6]
 4963 0122 26E0     		b	.L867
 4964              	.L850:
2097:sxmlc/sxmlc.c **** 				return BOM_UTF_32BE;
2098:sxmlc/sxmlc.c **** 			}
2099:sxmlc/sxmlc.c **** 			fseek(f, pos, SEEK_SET);
2100:sxmlc/sxmlc.c **** 			return BOM_NONE;
2101:sxmlc/sxmlc.c **** 
2102:sxmlc/sxmlc.c **** 		case (unsigned short)0xefbb: /* UTF-8? */
2103:sxmlc/sxmlc.c **** 			if (fread(&c1, sizeof(char), 1, f) != 1 || c1 != 0xbf) { /* Not UTF-8 */
 4965              		.loc 1 2103 0
 4966 0124 0121     		movs	r1, #1
 4967 0126 0DF10600 		add	r0, sp, #6
 4968 012a 0A46     		mov	r2, r1
 4969 012c 2B46     		mov	r3, r5
 4970 012e FFF7FEFF 		bl	fread
 4971              	.LVL557:
 4972 0132 0128     		cmp	r0, #1
 4973 0134 0BD1     		bne	.L849
 4974              		.loc 1 2103 0 is_stmt 0 discriminator 1
 4975 0136 9DF80630 		ldrb	r3, [sp, #6]	@ zero_extendqisi2
 4976 013a BF2B     		cmp	r3, #191
 4977 013c 07D1     		bne	.L849
2104:sxmlc/sxmlc.c **** 				fseek(f, pos, SEEK_SET);
2105:sxmlc/sxmlc.c **** 				if (bom != NULL)
2106:sxmlc/sxmlc.c **** 					bom[0] = '\0';
2107:sxmlc/sxmlc.c **** 				if (sz_bom != NULL)
2108:sxmlc/sxmlc.c **** 					*sz_bom = 0;
2109:sxmlc/sxmlc.c **** 				return BOM_NONE;
2110:sxmlc/sxmlc.c **** 			}
2111:sxmlc/sxmlc.c **** 			if (bom != NULL) {
 4978              		.loc 1 2111 0 is_stmt 1
 4979 013e 14B1     		cbz	r4, .L862
2112:sxmlc/sxmlc.c **** 				bom[2] = c1;
 4980              		.loc 1 2112 0
 4981 0140 A370     		strb	r3, [r4, #2]
2113:sxmlc/sxmlc.c **** 				bom[3] = '\0';
 4982              		.loc 1 2113 0
 4983 0142 0023     		movs	r3, #0
 4984 0144 E370     		strb	r3, [r4, #3]
 4985              	.L862:
2114:sxmlc/sxmlc.c **** 			}
2115:sxmlc/sxmlc.c **** 			if (sz_bom != NULL)
 4986              		.loc 1 2115 0
 4987 0146 BEB1     		cbz	r6, .L868
2116:sxmlc/sxmlc.c **** 				*sz_bom = 3;
 4988              		.loc 1 2116 0
 4989 0148 0323     		movs	r3, #3
 4990 014a 3360     		str	r3, [r6]
 4991 014c 14E0     		b	.L868
 4992              	.L849:
2117:sxmlc/sxmlc.c **** 			return BOM_UTF_8;
2118:sxmlc/sxmlc.c **** 
2119:sxmlc/sxmlc.c **** 		default: /* No BOM, go back */
2120:sxmlc/sxmlc.c **** 			fseek(f, pos, SEEK_SET);
 4993              		.loc 1 2120 0
 4994 014e 2846     		mov	r0, r5
 4995 0150 4146     		mov	r1, r8
 4996 0152 0022     		movs	r2, #0
 4997 0154 FFF7FEFF 		bl	fseek
 4998              	.LVL558:
2121:sxmlc/sxmlc.c **** 			if (bom != NULL)
 4999              		.loc 1 2121 0
 5000 0158 0CB1     		cbz	r4, .L863
2122:sxmlc/sxmlc.c **** 				bom[0] = '\0';
 5001              		.loc 1 2122 0
 5002 015a 0023     		movs	r3, #0
 5003 015c 2370     		strb	r3, [r4]
 5004              	.L863:
2123:sxmlc/sxmlc.c **** 			if (sz_bom != NULL)
 5005              		.loc 1 2123 0
 5006 015e 002E     		cmp	r6, #0
 5007 0160 3FF468AF 		beq	.L890
2124:sxmlc/sxmlc.c **** 				*sz_bom = 0;
 5008              		.loc 1 2124 0
 5009 0164 0020     		movs	r0, #0
 5010 0166 3060     		str	r0, [r6]
 5011 0168 07E0     		b	.L842
 5012              	.L865:
2074:sxmlc/sxmlc.c **** 				return BOM_UTF_16LE;
 5013              		.loc 1 2074 0
 5014 016a 3846     		mov	r0, r7
 5015 016c 05E0     		b	.L842
 5016              	.L866:
2084:sxmlc/sxmlc.c **** 				return BOM_UTF_32LE;
 5017              		.loc 1 2084 0
 5018 016e 0448     		ldr	r0, .L895
 5019 0170 03E0     		b	.L842
 5020              	.L867:
2097:sxmlc/sxmlc.c **** 				return BOM_UTF_32BE;
 5021              		.loc 1 2097 0
 5022 0172 4FF6FF60 		movw	r0, #65279
 5023 0176 00E0     		b	.L842
 5024              	.L868:
2117:sxmlc/sxmlc.c **** 			return BOM_UTF_8;
 5025              		.loc 1 2117 0
 5026 0178 0248     		ldr	r0, .L895+4
 5027              	.LVL559:
 5028              	.L842:
2125:sxmlc/sxmlc.c **** 			return BOM_NONE;
2126:sxmlc/sxmlc.c **** 	}
2127:sxmlc/sxmlc.c **** }
 5029              		.loc 1 2127 0
 5030 017a 02B0     		add	sp, sp, #8
 5031              		@ sp needed
 5032 017c BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 5033              	.LVL560:
 5034              	.L896:
 5035              		.align	2
 5036              	.L895:
 5037 0180 0000FEFF 		.word	-131072
 5038 0184 BFBBEF00 		.word	15711167
 5039              		.cfi_endproc
 5040              	.LFE64:
 5042              		.section	.text.html2str,"ax",%progbits
 5043              		.align	1
 5044              		.global	html2str
 5045              		.thumb
 5046              		.thumb_func
 5048              	html2str:
 5049              	.LFB65:
2128:sxmlc/sxmlc.c **** 
2129:sxmlc/sxmlc.c **** /* --- */
2130:sxmlc/sxmlc.c **** 
2131:sxmlc/sxmlc.c **** SXML_CHAR* html2str(SXML_CHAR* html, SXML_CHAR* str)
2132:sxmlc/sxmlc.c **** {
 5050              		.loc 1 2132 0
 5051              		.cfi_startproc
 5052              		@ args = 0, pretend = 0, frame = 0
 5053              		@ frame_needed = 0, uses_anonymous_args = 0
 5054              	.LVL561:
 5055 0000 2DE9F047 		push	{r4, r5, r6, r7, r8, r9, r10, lr}
 5056              		.cfi_def_cfa_offset 32
 5057              		.cfi_offset 4, -32
 5058              		.cfi_offset 5, -28
 5059              		.cfi_offset 6, -24
 5060              		.cfi_offset 7, -20
 5061              		.cfi_offset 8, -16
 5062              		.cfi_offset 9, -12
 5063              		.cfi_offset 10, -8
 5064              		.cfi_offset 14, -4
 5065              		.loc 1 2132 0
 5066 0004 0E46     		mov	r6, r1
2133:sxmlc/sxmlc.c **** 	SXML_CHAR *ps, *pd;
2134:sxmlc/sxmlc.c **** 	int i;
2135:sxmlc/sxmlc.c **** 
2136:sxmlc/sxmlc.c **** 	if (html == NULL) return NULL;
 5067              		.loc 1 2136 0
 5068 0006 0446     		mov	r4, r0
 5069 0008 80B3     		cbz	r0, .L909
 5070 000a 0029     		cmp	r1, #0
 5071 000c 08BF     		it	eq
 5072 000e 0646     		moveq	r6, r0
 5073              	.LVL562:
 5074 0010 751C     		adds	r5, r6, #1
 5075              	.LVL563:
 5076              	.L900:
2137:sxmlc/sxmlc.c **** 
2138:sxmlc/sxmlc.c **** 	if (str == NULL) str = html;
2139:sxmlc/sxmlc.c **** 	
2140:sxmlc/sxmlc.c **** 	/* Look for '&' and matches it to any of the recognized HTML pattern. */
2141:sxmlc/sxmlc.c **** 	/* If found, replaces the '&' by the corresponding char. */
2142:sxmlc/sxmlc.c **** 	/* 'p2' is the char to analyze, 'p1' is where to insert it */
2143:sxmlc/sxmlc.c **** 	for (pd = str, ps = html; *ps; ps++, pd++) {
 5077              		.loc 1 2143 0 discriminator 1
 5078 0012 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 5079 0014 05F1FF38 		add	r8, r5, #-1
 5080              	.LVL564:
 5081 0018 1BB3     		cbz	r3, .L914
2144:sxmlc/sxmlc.c **** 		if (*ps != C2SX('&')) {
 5082              		.loc 1 2144 0
 5083 001a 262B     		cmp	r3, #38
 5084 001c 02D0     		beq	.L901
2145:sxmlc/sxmlc.c **** 			if (pd != ps)
 5085              		.loc 1 2145 0
 5086 001e A045     		cmp	r8, r4
 5087 0020 1AD1     		bne	.L913
 5088 0022 1BE0     		b	.L902
 5089              	.L901:
 5090 0024 124F     		ldr	r7, .L916
 5091              	.L904:
2146:sxmlc/sxmlc.c **** 				*pd = *ps;
2147:sxmlc/sxmlc.c **** 			continue;
2148:sxmlc/sxmlc.c **** 		}
2149:sxmlc/sxmlc.c **** 		
2150:sxmlc/sxmlc.c **** 		for (i = 0; HTML_SPECIAL_DICT[i].chr; i++) {
 5092              		.loc 1 2150 0 discriminator 1
 5093 0026 17F8089C 		ldrb	r9, [r7, #-8]	@ zero_extendqisi2
 5094 002a B9F1000F 		cmp	r9, #0
 5095 002e 10D0     		beq	.L915
2151:sxmlc/sxmlc.c **** 			if (sx_strncmp(ps, HTML_SPECIAL_DICT[i].html, HTML_SPECIAL_DICT[i].html_len))
 5096              		.loc 1 2151 0
 5097 0030 D7F800A0 		ldr	r10, [r7]
 5098 0034 57F8041C 		ldr	r1, [r7, #-4]
 5099 0038 2046     		mov	r0, r4
 5100 003a 5246     		mov	r2, r10
 5101 003c FFF7FEFF 		bl	strncmp
 5102              	.LVL565:
 5103 0040 0C37     		adds	r7, r7, #12
 5104 0042 0028     		cmp	r0, #0
 5105 0044 EFD1     		bne	.L904
2152:sxmlc/sxmlc.c **** 				continue;
2153:sxmlc/sxmlc.c **** 			
2154:sxmlc/sxmlc.c **** 			*pd = HTML_SPECIAL_DICT[i].chr;
2155:sxmlc/sxmlc.c **** 			ps += HTML_SPECIAL_DICT[i].html_len-1;
 5106              		.loc 1 2155 0
 5107 0046 0AF1FF3A 		add	r10, r10, #-1
2154:sxmlc/sxmlc.c **** 			*pd = HTML_SPECIAL_DICT[i].chr;
 5108              		.loc 1 2154 0
 5109 004a 05F8019C 		strb	r9, [r5, #-1]
 5110              		.loc 1 2155 0
 5111 004e 5444     		add	r4, r4, r10
 5112              	.LVL566:
 5113 0050 04E0     		b	.L902
 5114              	.L915:
2156:sxmlc/sxmlc.c **** 			break;
2157:sxmlc/sxmlc.c **** 		}
2158:sxmlc/sxmlc.c **** 		/* If no string was found, simply copy the character */
2159:sxmlc/sxmlc.c **** 		if (HTML_SPECIAL_DICT[i].chr == NULC && pd != ps)
 5115              		.loc 1 2159 0
 5116 0052 A045     		cmp	r8, r4
 5117 0054 02D0     		beq	.L902
2160:sxmlc/sxmlc.c **** 			*pd = *ps;
 5118              		.loc 1 2160 0
 5119 0056 2623     		movs	r3, #38
 5120              	.L913:
 5121 0058 05F8013C 		strb	r3, [r5, #-1]
 5122              	.L902:
2143:sxmlc/sxmlc.c **** 	for (pd = str, ps = html; *ps; ps++, pd++) {
 5123              		.loc 1 2143 0
 5124 005c 0134     		adds	r4, r4, #1
 5125              	.LVL567:
 5126 005e 0135     		adds	r5, r5, #1
 5127              	.LVL568:
 5128 0060 D7E7     		b	.L900
 5129              	.LVL569:
 5130              	.L914:
2161:sxmlc/sxmlc.c **** 	}
2162:sxmlc/sxmlc.c **** 	*pd = NULC;
 5131              		.loc 1 2162 0
 5132 0062 88F80030 		strb	r3, [r8]
2163:sxmlc/sxmlc.c **** 	
2164:sxmlc/sxmlc.c **** 	return str;
 5133              		.loc 1 2164 0
 5134 0066 3046     		mov	r0, r6
 5135 0068 BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 5136              	.LVL570:
 5137              	.L909:
 5138 006c BDE8F087 		pop	{r4, r5, r6, r7, r8, r9, r10, pc}
 5139              	.L917:
 5140              		.align	2
 5141              	.L916:
 5142 0070 08000000 		.word	.LANCHOR2+8
 5143              		.cfi_endproc
 5144              	.LFE65:
 5146              		.section	.text.XML_parse_attribute_to,"ax",%progbits
 5147              		.align	1
 5148              		.global	XML_parse_attribute_to
 5149              		.thumb
 5150              		.thumb_func
 5152              	XML_parse_attribute_to:
 5153              	.LFB41:
1018:sxmlc/sxmlc.c **** {
 5154              		.loc 1 1018 0
 5155              		.cfi_startproc
 5156              		@ args = 0, pretend = 0, frame = 8
 5157              		@ frame_needed = 0, uses_anonymous_args = 0
 5158              	.LVL571:
 5159 0000 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5160              		.cfi_def_cfa_offset 48
 5161              		.cfi_offset 0, -48
 5162              		.cfi_offset 1, -44
 5163              		.cfi_offset 2, -40
 5164              		.cfi_offset 4, -36
 5165              		.cfi_offset 5, -32
 5166              		.cfi_offset 6, -28
 5167              		.cfi_offset 7, -24
 5168              		.cfi_offset 8, -20
 5169              		.cfi_offset 9, -16
 5170              		.cfi_offset 10, -12
 5171              		.cfi_offset 11, -8
 5172              		.cfi_offset 14, -4
1018:sxmlc/sxmlc.c **** {
 5173              		.loc 1 1018 0
 5174 0004 0D46     		mov	r5, r1
 5175 0006 1446     		mov	r4, r2
1024:sxmlc/sxmlc.c **** 	if (str == NULL || xmlattr == NULL)
 5176              		.loc 1 1024 0
 5177 0008 0646     		mov	r6, r0
 5178 000a 08B9     		cbnz	r0, .L919
 5179              	.LVL572:
 5180              	.L921:
1025:sxmlc/sxmlc.c **** 		return 0;
 5181              		.loc 1 1025 0
 5182 000c 0020     		movs	r0, #0
 5183 000e 86E0     		b	.L959
 5184              	.LVL573:
 5185              	.L919:
1024:sxmlc/sxmlc.c **** 	if (str == NULL || xmlattr == NULL)
 5186              		.loc 1 1024 0 discriminator 1
 5187 0010 002A     		cmp	r2, #0
 5188 0012 FBD0     		beq	.L921
1027:sxmlc/sxmlc.c **** 	if (to < 0)
 5189              		.loc 1 1027 0
 5190 0014 0029     		cmp	r1, #0
 5191 0016 02DA     		bge	.L922
1028:sxmlc/sxmlc.c **** 		to = sx_strlen(str) - 1;
 5192              		.loc 1 1028 0
 5193 0018 FFF7FEFF 		bl	strlen
 5194              	.LVL574:
 5195 001c 451E     		subs	r5, r0, #1
 5196              	.LVL575:
 5197              	.L922:
1032:sxmlc/sxmlc.c **** 	for (n0 = 0; n0 != to && str[n0] != C2SX('=') && !sx_isspace(str[n0]); n0++) ; /* Search for '=' o
 5198              		.loc 1 1032 0
 5199 001e 414B     		ldr	r3, .L963
 5200 0020 1A68     		ldr	r2, [r3]
 5201 0022 0023     		movs	r3, #0
 5202              	.LVL576:
 5203              	.L923:
1032:sxmlc/sxmlc.c **** 	for (n0 = 0; n0 != to && str[n0] != C2SX('=') && !sx_isspace(str[n0]); n0++) ; /* Search for '=' o
 5204              		.loc 1 1032 0 is_stmt 0 discriminator 1
 5205 0024 AB42     		cmp	r3, r5
 5206 0026 08D0     		beq	.L962
1032:sxmlc/sxmlc.c **** 	for (n0 = 0; n0 != to && str[n0] != C2SX('=') && !sx_isspace(str[n0]); n0++) ; /* Search for '=' o
 5207              		.loc 1 1032 0 discriminator 2
 5208 0028 F15C     		ldrb	r1, [r6, r3]	@ zero_extendqisi2
 5209 002a 3D29     		cmp	r1, #61
 5210 002c 05D0     		beq	.L962
1032:sxmlc/sxmlc.c **** 	for (n0 = 0; n0 != to && str[n0] != C2SX('=') && !sx_isspace(str[n0]); n0++) ; /* Search for '=' o
 5211              		.loc 1 1032 0 discriminator 1
 5212 002e 1144     		add	r1, r1, r2
 5213 0030 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 5214 0032 0807     		lsls	r0, r1, #28
 5215 0034 01D4     		bmi	.L962
 5216 0036 0133     		adds	r3, r3, #1
 5217              	.LVL577:
 5218 0038 F4E7     		b	.L923
 5219              	.L962:
 5220 003a 9A46     		mov	r10, r3
 5221              	.LVL578:
 5222              	.L925:
1033:sxmlc/sxmlc.c **** 	for (n1 = n0; n1 != to && sx_isspace(str[n1]); n1++) ; /* Search for something not a space */
 5223              		.loc 1 1033 0 is_stmt 1 discriminator 1
 5224 003c AB42     		cmp	r3, r5
 5225 003e 04D1     		bne	.L928
 5226              	.L931:
1034:sxmlc/sxmlc.c **** 	if (str[n1] != C2SX('='))
 5227              		.loc 1 1034 0
 5228 0040 F15C     		ldrb	r1, [r6, r3]	@ zero_extendqisi2
 5229 0042 3D29     		cmp	r1, #61
 5230 0044 E2D1     		bne	.L921
1036:sxmlc/sxmlc.c **** 	for (n1++; n1 != to && sx_isspace(str[n1]); n1++) ; /* Search for something not a space */
 5231              		.loc 1 1036 0
 5232 0046 5F1C     		adds	r7, r3, #1
 5233              	.LVL579:
 5234 0048 0CE0     		b	.L932
 5235              	.LVL580:
 5236              	.L928:
1033:sxmlc/sxmlc.c **** 	for (n1 = n0; n1 != to && sx_isspace(str[n1]); n1++) ; /* Search for something not a space */
 5237              		.loc 1 1033 0 discriminator 2
 5238 004a F15C     		ldrb	r1, [r6, r3]	@ zero_extendqisi2
 5239 004c 1144     		add	r1, r1, r2
 5240 004e 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 5241 0050 0907     		lsls	r1, r1, #28
 5242 0052 F5D5     		bpl	.L931
1033:sxmlc/sxmlc.c **** 	for (n1 = n0; n1 != to && sx_isspace(str[n1]); n1++) ; /* Search for something not a space */
 5243              		.loc 1 1033 0 is_stmt 0 discriminator 1
 5244 0054 0133     		adds	r3, r3, #1
 5245              	.LVL581:
 5246 0056 F1E7     		b	.L925
 5247              	.LVL582:
 5248              	.L933:
1036:sxmlc/sxmlc.c **** 	for (n1++; n1 != to && sx_isspace(str[n1]); n1++) ; /* Search for something not a space */
 5249              		.loc 1 1036 0 is_stmt 1 discriminator 2
 5250 0058 F35D     		ldrb	r3, [r6, r7]	@ zero_extendqisi2
 5251 005a 1344     		add	r3, r3, r2
 5252 005c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 5253 005e 1B07     		lsls	r3, r3, #28
 5254 0060 02D5     		bpl	.L937
1036:sxmlc/sxmlc.c **** 	for (n1++; n1 != to && sx_isspace(str[n1]); n1++) ; /* Search for something not a space */
 5255              		.loc 1 1036 0 is_stmt 0 discriminator 1
 5256 0062 0137     		adds	r7, r7, #1
 5257              	.LVL583:
 5258              	.L932:
 5259 0064 AF42     		cmp	r7, r5
 5260 0066 F7D1     		bne	.L933
 5261              	.L937:
1037:sxmlc/sxmlc.c **** 	if (isquote(str[n1])) { /* Remove quotes */
 5262              		.loc 1 1037 0 is_stmt 1
 5263 0068 16F80790 		ldrb	r9, [r6, r7]	@ zero_extendqisi2
 5264 006c B9F1220F 		cmp	r9, #34
 5265 0070 06D0     		beq	.L948
1037:sxmlc/sxmlc.c **** 	if (isquote(str[n1])) { /* Remove quotes */
 5266              		.loc 1 1037 0 is_stmt 0 discriminator 1
 5267 0072 B9F1270F 		cmp	r9, #39
 5268 0076 03D0     		beq	.L948
1022:sxmlc/sxmlc.c **** 	SXML_CHAR quote = '\0';
 5269              		.loc 1 1022 0 is_stmt 1
 5270 0078 4FF00009 		mov	r9, #0
1020:sxmlc/sxmlc.c **** 	int i, n0, n1, remQ = 0;
 5271              		.loc 1 1020 0
 5272 007c C846     		mov	r8, r9
 5273 007e 01E0     		b	.L934
 5274              	.L948:
1039:sxmlc/sxmlc.c **** 		remQ = 1;
 5275              		.loc 1 1039 0
 5276 0080 4FF00108 		mov	r8, #1
 5277              	.L934:
 5278              	.LVL584:
1042:sxmlc/sxmlc.c **** 	xmlattr->name = (SXML_CHAR*)__malloc((n0+1)*sizeof(SXML_CHAR));
 5279              		.loc 1 1042 0
 5280 0084 0AF10100 		add	r0, r10, #1
 5281 0088 FFF7FEFF 		bl	malloc
 5282              	.LVL585:
 5283 008c 2060     		str	r0, [r4]
 5284 008e 8346     		mov	fp, r0
1043:sxmlc/sxmlc.c **** 	xmlattr->value = (SXML_CHAR*)__malloc((to+1 - n1 - remQ + 1) * sizeof(SXML_CHAR));
 5285              		.loc 1 1043 0
 5286 0090 681C     		adds	r0, r5, #1
 5287 0092 C01B     		subs	r0, r0, r7
 5288 0094 C8EB0000 		rsb	r0, r8, r0
 5289 0098 0130     		adds	r0, r0, #1
 5290 009a FFF7FEFF 		bl	malloc
 5291              	.LVL586:
1044:sxmlc/sxmlc.c **** 	xmlattr->active = true;
 5292              		.loc 1 1044 0
 5293 009e 0122     		movs	r2, #1
1043:sxmlc/sxmlc.c **** 	xmlattr->value = (SXML_CHAR*)__malloc((to+1 - n1 - remQ + 1) * sizeof(SXML_CHAR));
 5294              		.loc 1 1043 0
 5295 00a0 0346     		mov	r3, r0
 5296 00a2 6060     		str	r0, [r4, #4]
1044:sxmlc/sxmlc.c **** 	xmlattr->active = true;
 5297              		.loc 1 1044 0
 5298 00a4 A260     		str	r2, [r4, #8]
1045:sxmlc/sxmlc.c **** 	if (xmlattr->name != NULL && xmlattr->value != NULL) {
 5299              		.loc 1 1045 0
 5300 00a6 BBF1000F 		cmp	fp, #0
 5301 00aa 30D0     		beq	.L938
1047:sxmlc/sxmlc.c **** 		sx_strncpy(xmlattr->name, str, n0);
 5302              		.loc 1 1047 0 discriminator 1
 5303 00ac 5846     		mov	r0, fp
1045:sxmlc/sxmlc.c **** 	if (xmlattr->name != NULL && xmlattr->value != NULL) {
 5304              		.loc 1 1045 0 discriminator 1
 5305 00ae 4BB3     		cbz	r3, .L939
1047:sxmlc/sxmlc.c **** 		sx_strncpy(xmlattr->name, str, n0);
 5306              		.loc 1 1047 0
 5307 00b0 3146     		mov	r1, r6
 5308 00b2 5246     		mov	r2, r10
 5309 00b4 FFF7FEFF 		bl	strncpy
 5310              	.LVL587:
1048:sxmlc/sxmlc.c **** 		xmlattr->name[n0] = NULC;
 5311              		.loc 1 1048 0
 5312 00b8 2368     		ldr	r3, [r4]
 5313 00ba 0022     		movs	r2, #0
1052:sxmlc/sxmlc.c **** 		for (i = 0, p = str + n1 + remQ; i + n1 + remQ < to && *(p+remQ) != NULC; i++, p++)
 5314              		.loc 1 1052 0
 5315 00bc 4744     		add	r7, r7, r8
 5316              	.LVL588:
1048:sxmlc/sxmlc.c **** 		xmlattr->name[n0] = NULC;
 5317              		.loc 1 1048 0
 5318 00be 03F80A20 		strb	r2, [r3, r10]
 5319              	.LVL589:
1052:sxmlc/sxmlc.c **** 		for (i = 0, p = str + n1 + remQ; i + n1 + remQ < to && *(p+remQ) != NULC; i++, p++)
 5320              		.loc 1 1052 0
 5321 00c2 3E44     		add	r6, r6, r7
 5322              	.LVL590:
 5323              	.L940:
 5324 00c4 BB18     		adds	r3, r7, r2
1052:sxmlc/sxmlc.c **** 		for (i = 0, p = str + n1 + remQ; i + n1 + remQ < to && *(p+remQ) != NULC; i++, p++)
 5325              		.loc 1 1052 0 is_stmt 0 discriminator 1
 5326 00c6 AB42     		cmp	r3, r5
 5327 00c8 06EB020A 		add	r10, r6, r2
 5328              	.LVL591:
 5329 00cc 6068     		ldr	r0, [r4, #4]
 5330 00ce 09DB     		blt	.L941
 5331              	.L945:
1054:sxmlc/sxmlc.c **** 		xmlattr->value[i] = NULC;
 5332              		.loc 1 1054 0 is_stmt 1
 5333 00d0 0021     		movs	r1, #0
 5334 00d2 8154     		strb	r1, [r0, r2]
1055:sxmlc/sxmlc.c **** 		(void)html2str(xmlattr->value, NULL); /* Convert HTML escape sequences, do not str_unescape(xmlat
 5335              		.loc 1 1055 0
 5336 00d4 6068     		ldr	r0, [r4, #4]
 5337 00d6 FFF7FEFF 		bl	html2str
 5338              	.LVL592:
1056:sxmlc/sxmlc.c **** 		if (remQ && *p != quote)
 5339              		.loc 1 1056 0
 5340 00da B8F1000F 		cmp	r8, #0
 5341 00de 0AD1     		bne	.L942
1021:sxmlc/sxmlc.c **** 	int ret = 1;
 5342              		.loc 1 1021 0
 5343 00e0 0120     		movs	r0, #1
 5344 00e2 1CE0     		b	.L959
 5345              	.LVL593:
 5346              	.L941:
 5347 00e4 06EB0803 		add	r3, r6, r8
1052:sxmlc/sxmlc.c **** 		for (i = 0, p = str + n1 + remQ; i + n1 + remQ < to && *(p+remQ) != NULC; i++, p++)
 5348              		.loc 1 1052 0 discriminator 2
 5349 00e8 9B5C     		ldrb	r3, [r3, r2]	@ zero_extendqisi2
 5350 00ea 002B     		cmp	r3, #0
 5351 00ec F0D0     		beq	.L945
1053:sxmlc/sxmlc.c **** 			xmlattr->value[i] = *p;
 5352              		.loc 1 1053 0 discriminator 1
 5353 00ee B35C     		ldrb	r3, [r6, r2]	@ zero_extendqisi2
 5354 00f0 8354     		strb	r3, [r0, r2]
1052:sxmlc/sxmlc.c **** 		for (i = 0, p = str + n1 + remQ; i + n1 + remQ < to && *(p+remQ) != NULC; i++, p++)
 5355              		.loc 1 1052 0 discriminator 1
 5356 00f2 0132     		adds	r2, r2, #1
 5357              	.LVL594:
 5358 00f4 E6E7     		b	.L940
 5359              	.LVL595:
 5360              	.L942:
1056:sxmlc/sxmlc.c **** 		if (remQ && *p != quote)
 5361              		.loc 1 1056 0 discriminator 1
 5362 00f6 9AF80000 		ldrb	r0, [r10]	@ zero_extendqisi2
1021:sxmlc/sxmlc.c **** 	int ret = 1;
 5363              		.loc 1 1021 0 discriminator 1
 5364 00fa 4845     		cmp	r0, r9
 5365 00fc 14BF     		ite	ne
 5366 00fe 0220     		movne	r0, #2
 5367 0100 0120     		moveq	r0, #1
 5368 0102 0CE0     		b	.L959
 5369              	.LVL596:
 5370              	.L939:
1063:sxmlc/sxmlc.c **** 			__free(xmlattr->name);
 5371              		.loc 1 1063 0
 5372 0104 0193     		str	r3, [sp, #4]
 5373 0106 FFF7FEFF 		bl	free
 5374              	.LVL597:
1064:sxmlc/sxmlc.c **** 			xmlattr->name = NULL;
 5375              		.loc 1 1064 0
 5376 010a 019B     		ldr	r3, [sp, #4]
 5377 010c 2360     		str	r3, [r4]
 5378              	.LVL598:
 5379              	.L938:
1066:sxmlc/sxmlc.c **** 		if (xmlattr->value != NULL) {
 5380              		.loc 1 1066 0
 5381 010e 6068     		ldr	r0, [r4, #4]
 5382 0110 0028     		cmp	r0, #0
 5383 0112 3FF47BAF 		beq	.L921
1067:sxmlc/sxmlc.c **** 			__free(xmlattr->value);
 5384              		.loc 1 1067 0
 5385 0116 FFF7FEFF 		bl	free
 5386              	.LVL599:
1068:sxmlc/sxmlc.c **** 			xmlattr->value = NULL;
 5387              		.loc 1 1068 0
 5388 011a 0020     		movs	r0, #0
 5389 011c 6060     		str	r0, [r4, #4]
 5390              	.LVL600:
 5391              	.L959:
1073:sxmlc/sxmlc.c **** }
 5392              		.loc 1 1073 0
 5393 011e 03B0     		add	sp, sp, #12
 5394              		@ sp needed
 5395 0120 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 5396              	.LVL601:
 5397              	.L964:
 5398              		.align	2
 5399              	.L963:
 5400 0124 00000000 		.word	__ctype_ptr__
 5401              		.cfi_endproc
 5402              	.LFE41:
 5404              		.section	.text.XML_parse_1string,"ax",%progbits
 5405              		.align	1
 5406              		.global	XML_parse_1string
 5407              		.thumb
 5408              		.thumb_func
 5410              	XML_parse_1string:
 5411              	.LFB43:
1099:sxmlc/sxmlc.c **** {
 5412              		.loc 1 1099 0
 5413              		.cfi_startproc
 5414              		@ args = 0, pretend = 0, frame = 8
 5415              		@ frame_needed = 0, uses_anonymous_args = 0
 5416              	.LVL602:
 5417 0000 2DE9F74F 		push	{r0, r1, r2, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5418              		.cfi_def_cfa_offset 48
 5419              		.cfi_offset 0, -48
 5420              		.cfi_offset 1, -44
 5421              		.cfi_offset 2, -40
 5422              		.cfi_offset 4, -36
 5423              		.cfi_offset 5, -32
 5424              		.cfi_offset 6, -28
 5425              		.cfi_offset 7, -24
 5426              		.cfi_offset 8, -20
 5427              		.cfi_offset 9, -16
 5428              		.cfi_offset 10, -12
 5429              		.cfi_offset 11, -8
 5430              		.cfi_offset 14, -4
1099:sxmlc/sxmlc.c **** {
 5431              		.loc 1 1099 0
 5432 0004 0C46     		mov	r4, r1
1104:sxmlc/sxmlc.c **** 	if (str == NULL || xmlnode == NULL)
 5433              		.loc 1 1104 0
 5434 0006 0546     		mov	r5, r0
 5435 0008 0028     		cmp	r0, #0
 5436 000a 00F01781 		beq	.L1055
1104:sxmlc/sxmlc.c **** 	if (str == NULL || xmlnode == NULL)
 5437              		.loc 1 1104 0 is_stmt 0 discriminator 1
 5438 000e 0029     		cmp	r1, #0
 5439 0010 00F01481 		beq	.L1055
1106:sxmlc/sxmlc.c **** 	len = sx_strlen(str);
 5440              		.loc 1 1106 0 is_stmt 1
 5441 0014 FFF7FEFF 		bl	strlen
 5442              	.LVL603:
1109:sxmlc/sxmlc.c **** 	if (str[0] != C2SX('<') || str[len-1] != C2SX('>'))
 5443              		.loc 1 1109 0
 5444 0018 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
1106:sxmlc/sxmlc.c **** 	len = sx_strlen(str);
 5445              		.loc 1 1106 0
 5446 001a 8046     		mov	r8, r0
 5447              	.LVL604:
1109:sxmlc/sxmlc.c **** 	if (str[0] != C2SX('<') || str[len-1] != C2SX('>'))
 5448              		.loc 1 1109 0
 5449 001c 3C2B     		cmp	r3, #60
 5450 001e 40F00D81 		bne	.L1055
1109:sxmlc/sxmlc.c **** 	if (str[0] != C2SX('<') || str[len-1] != C2SX('>'))
 5451              		.loc 1 1109 0 is_stmt 0 discriminator 1
 5452 0022 2B18     		adds	r3, r5, r0
 5453 0024 13F8013C 		ldrb	r3, [r3, #-1]	@ zero_extendqisi2
 5454 0028 3E2B     		cmp	r3, #62
 5455 002a 40F00781 		bne	.L1055
1109:sxmlc/sxmlc.c **** 	if (str[0] != C2SX('<') || str[len-1] != C2SX('>'))
 5456              		.loc 1 1109 0
 5457 002e 0027     		movs	r7, #0
 5458              	.LVL605:
 5459              	.L971:
1113:sxmlc/sxmlc.c **** 		n = (int)_parse_special_tag(str, len, &_spec[nn], xmlnode);
 5460              		.loc 1 1113 0 is_stmt 1
 5461 0030 864A     		ldr	r2, .L1060
 5462 0032 2846     		mov	r0, r5
 5463 0034 4146     		mov	r1, r8
 5464 0036 3A44     		add	r2, r2, r7
 5465 0038 2346     		mov	r3, r4
 5466 003a FFF7FEFF 		bl	_parse_special_tag
 5467              	.LVL606:
1114:sxmlc/sxmlc.c **** 		switch (n) {
 5468              		.loc 1 1114 0
 5469 003e 0646     		mov	r6, r0
 5470 0040 0028     		cmp	r0, #0
 5471 0042 40F0FE80 		bne	.L967
 5472              	.LVL607:
 5473 0046 1437     		adds	r7, r7, #20
1112:sxmlc/sxmlc.c **** 	for (nn = 0; nn < NB_SPECIAL_TAGS; nn++) {
 5474              		.loc 1 1112 0
 5475 0048 3C2F     		cmp	r7, #60
 5476 004a F1D1     		bne	.L971
1121:sxmlc/sxmlc.c **** 	if (str[1] == C2SX('!')) {
 5477              		.loc 1 1121 0
 5478 004c 6B78     		ldrb	r3, [r5, #1]	@ zero_extendqisi2
 5479 004e 212B     		cmp	r3, #33
 5480 0050 05D1     		bne	.L972
1123:sxmlc/sxmlc.c **** 		if (!sx_strncmp(str, C2SX("<!DOCTYPE"), 9)) { /* 9 = sizeof("<!DOCTYPE") */
 5481              		.loc 1 1123 0
 5482 0052 2846     		mov	r0, r5
 5483              	.LVL608:
 5484 0054 7E49     		ldr	r1, .L1060+4
 5485 0056 0922     		movs	r2, #9
 5486 0058 FFF7FEFF 		bl	strncmp
 5487              	.LVL609:
 5488 005c 08B1     		cbz	r0, .L973
 5489              	.L972:
1129:sxmlc/sxmlc.c **** 				nn = 1;
 5490              		.loc 1 1129 0 discriminator 1
 5491 005e 0027     		movs	r7, #0
 5492 0060 29E0     		b	.L974
 5493              	.L973:
 5494 0062 05F10803 		add	r3, r5, #8
 5495              	.L975:
1124:sxmlc/sxmlc.c **** 			for (n = 9; str[n] && str[n] != C2SX('['); n++) ; /* Look for a '[' inside the DOCTYPE, which wo
 5496              		.loc 1 1124 0 discriminator 1
 5497 0066 13F8016F 		ldrb	r6, [r3, #1]!	@ zero_extendqisi2
 5498 006a 66B1     		cbz	r6, .L976
1124:sxmlc/sxmlc.c **** 			for (n = 9; str[n] && str[n] != C2SX('['); n++) ; /* Look for a '[' inside the DOCTYPE, which wo
 5499              		.loc 1 1124 0 is_stmt 0 discriminator 2
 5500 006c 5B2E     		cmp	r6, #91
 5501 006e FAD1     		bne	.L975
 5502              	.LVL610:
1127:sxmlc/sxmlc.c **** 				if (sx_strncmp(str+len-2, C2SX("]>"), 2)) /* There probably is a '>' inside the DOCTYPE */
 5503              		.loc 1 1127 0 is_stmt 1
 5504 0070 A8F10200 		sub	r0, r8, #2
 5505 0074 2844     		add	r0, r0, r5
 5506 0076 7749     		ldr	r1, .L1060+8
 5507 0078 0222     		movs	r2, #2
 5508 007a FFF7FEFF 		bl	strncmp
 5509              	.LVL611:
 5510 007e 0028     		cmp	r0, #0
 5511 0080 40F0DE80 		bne	.L1012
1129:sxmlc/sxmlc.c **** 				nn = 1;
 5512              		.loc 1 1129 0
 5513 0084 0126     		movs	r6, #1
 5514              	.LVL612:
 5515              	.L976:
1131:sxmlc/sxmlc.c **** 			xmlnode->tag = (SXML_CHAR*)__malloc((len - 9 - nn)*sizeof(SXML_CHAR)); /* 'len' - "<!DOCTYPE" an
 5516              		.loc 1 1131 0
 5517 0086 A8F10900 		sub	r0, r8, #9
 5518 008a 801B     		subs	r0, r0, r6
 5519 008c FFF7FEFF 		bl	malloc
 5520              	.LVL613:
 5521 0090 2060     		str	r0, [r4]
1132:sxmlc/sxmlc.c **** 			if (xmlnode->tag == NULL)
 5522              		.loc 1 1132 0
 5523 0092 0028     		cmp	r0, #0
 5524 0094 00F0D280 		beq	.L1055
1134:sxmlc/sxmlc.c **** 			sx_strncpy(xmlnode->tag, &str[9], len - 10 - nn);
 5525              		.loc 1 1134 0
 5526 0098 A8F10A08 		sub	r8, r8, #10
 5527              	.LVL614:
 5528 009c C6EB0806 		rsb	r6, r6, r8
 5529              	.LVL615:
 5530 00a0 3246     		mov	r2, r6
 5531 00a2 05F10901 		add	r1, r5, #9
 5532 00a6 FFF7FEFF 		bl	strncpy
 5533              	.LVL616:
1135:sxmlc/sxmlc.c **** 			xmlnode->tag[len - 10 - nn] = NULC;
 5534              		.loc 1 1135 0
 5535 00aa 2368     		ldr	r3, [r4]
 5536 00ac 0022     		movs	r2, #0
 5537 00ae 9A55     		strb	r2, [r3, r6]
1136:sxmlc/sxmlc.c **** 			xmlnode->tag_type = TAG_DOCTYPE;
 5538              		.loc 1 1136 0
 5539 00b0 0726     		movs	r6, #7
 5540 00b2 49E0     		b	.L1054
 5541              	.LVL617:
 5542              	.L980:
1143:sxmlc/sxmlc.c **** 	for (nn = 0; nn < _user_tags.n_tags; nn++) {
 5543              		.loc 1 1143 0
 5544 00b4 0137     		adds	r7, r7, #1
 5545              	.LVL618:
 5546              	.L974:
1143:sxmlc/sxmlc.c **** 	for (nn = 0; nn < _user_tags.n_tags; nn++) {
 5547              		.loc 1 1143 0 is_stmt 0 discriminator 1
 5548 00b6 684B     		ldr	r3, .L1060+12
 5549 00b8 5A68     		ldr	r2, [r3, #4]
 5550 00ba 9742     		cmp	r7, r2
 5551 00bc 0FDA     		bge	.L1056
1144:sxmlc/sxmlc.c **** 		n = _parse_special_tag(str, len, &_user_tags.tags[nn], xmlnode);
 5552              		.loc 1 1144 0 is_stmt 1
 5553 00be 1B68     		ldr	r3, [r3]
 5554 00c0 1422     		movs	r2, #20
 5555 00c2 4146     		mov	r1, r8
 5556 00c4 02FB0732 		mla	r2, r2, r7, r3
 5557 00c8 2846     		mov	r0, r5
 5558 00ca 2346     		mov	r3, r4
 5559 00cc FFF7FEFF 		bl	_parse_special_tag
 5560              	.LVL619:
1145:sxmlc/sxmlc.c **** 		switch (n) {
 5561              		.loc 1 1145 0
 5562 00d0 411C     		adds	r1, r0, #1
 5563 00d2 00F0B680 		beq	.L967
 5564 00d6 0028     		cmp	r0, #0
 5565 00d8 ECD0     		beq	.L980
1144:sxmlc/sxmlc.c **** 		n = _parse_special_tag(str, len, &_user_tags.tags[nn], xmlnode);
 5566              		.loc 1 1144 0
 5567 00da 0646     		mov	r6, r0
1148:sxmlc/sxmlc.c **** 			default:		return (TagType)n;	/* Tag found => return it */
 5568              		.loc 1 1148 0
 5569 00dc B1E0     		b	.L967
 5570              	.LVL620:
 5571              	.L1056:
1152:sxmlc/sxmlc.c **** 	if (str[1] == C2SX('/'))
 5572              		.loc 1 1152 0
 5573 00de 6F78     		ldrb	r7, [r5, #1]	@ zero_extendqisi2
 5574              	.LVL621:
1156:sxmlc/sxmlc.c **** 	for (n = 1 + tag_end; str[n] != NULC && str[n] != C2SX('>') && str[n] != C2SX('/') && !sx_isspace(
 5575              		.loc 1 1156 0
 5576 00e0 5E4B     		ldr	r3, .L1060+16
1152:sxmlc/sxmlc.c **** 	if (str[1] == C2SX('/'))
 5577              		.loc 1 1152 0
 5578 00e2 B7F12F02 		subs	r2, r7, #47
 5579 00e6 5742     		rsbs	r7, r2, #0
 5580 00e8 5741     		adcs	r7, r7, r2
 5581              	.LVL622:
1156:sxmlc/sxmlc.c **** 	for (n = 1 + tag_end; str[n] != NULC && str[n] != C2SX('>') && str[n] != C2SX('/') && !sx_isspace(
 5582              		.loc 1 1156 0
 5583 00ea 07F1010B 		add	fp, r7, #1
 5584              	.LVL623:
 5585 00ee 1A68     		ldr	r2, [r3]
 5586 00f0 5E46     		mov	r6, fp
 5587 00f2 9A46     		mov	r10, r3
 5588              	.LVL624:
 5589              	.L982:
1156:sxmlc/sxmlc.c **** 	for (n = 1 + tag_end; str[n] != NULC && str[n] != C2SX('>') && str[n] != C2SX('/') && !sx_isspace(
 5590              		.loc 1 1156 0 is_stmt 0 discriminator 1
 5591 00f4 AB5D     		ldrb	r3, [r5, r6]	@ zero_extendqisi2
 5592 00f6 2BB9     		cbnz	r3, .L983
 5593              	.L985:
1157:sxmlc/sxmlc.c **** 	xmlnode->tag = (SXML_CHAR*)__malloc((n - tag_end)*sizeof(SXML_CHAR));
 5594              		.loc 1 1157 0 is_stmt 1
 5595 00f8 F01B     		subs	r0, r6, r7
 5596 00fa FFF7FEFF 		bl	malloc
 5597              	.LVL625:
 5598 00fe 2060     		str	r0, [r4]
1158:sxmlc/sxmlc.c **** 	if (xmlnode->tag == NULL)
 5599              		.loc 1 1158 0
 5600 0100 50B9     		cbnz	r0, .L1052
 5601 0102 9BE0     		b	.L1055
 5602              	.L983:
1156:sxmlc/sxmlc.c **** 	for (n = 1 + tag_end; str[n] != NULC && str[n] != C2SX('>') && str[n] != C2SX('/') && !sx_isspace(
 5603              		.loc 1 1156 0 discriminator 2
 5604 0104 3E2B     		cmp	r3, #62
 5605 0106 F7D0     		beq	.L985
1156:sxmlc/sxmlc.c **** 	for (n = 1 + tag_end; str[n] != NULC && str[n] != C2SX('>') && str[n] != C2SX('/') && !sx_isspace(
 5606              		.loc 1 1156 0 is_stmt 0 discriminator 1
 5607 0108 2F2B     		cmp	r3, #47
 5608 010a F5D0     		beq	.L985
 5609 010c 1344     		add	r3, r3, r2
 5610 010e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 5611 0110 1B07     		lsls	r3, r3, #28
 5612 0112 F1D4     		bmi	.L985
 5613 0114 0136     		adds	r6, r6, #1
 5614              	.LVL626:
 5615 0116 EDE7     		b	.L982
 5616              	.L1052:
1160:sxmlc/sxmlc.c **** 	sx_strncpy(xmlnode->tag, &str[1 + tag_end], n - 1 - tag_end);
 5617              		.loc 1 1160 0 is_stmt 1
 5618 0118 06F1FF39 		add	r9, r6, #-1
 5619 011c C7EB0909 		rsb	r9, r7, r9
 5620 0120 4A46     		mov	r2, r9
 5621 0122 05EB0B01 		add	r1, r5, fp
 5622 0126 FFF7FEFF 		bl	strncpy
 5623              	.LVL627:
1161:sxmlc/sxmlc.c **** 	xmlnode->tag[n - 1 - tag_end] = NULC;
 5624              		.loc 1 1161 0
 5625 012a 2368     		ldr	r3, [r4]
 5626 012c 0022     		movs	r2, #0
 5627 012e 03F80920 		strb	r2, [r3, r9]
1162:sxmlc/sxmlc.c **** 	if (tag_end) {
 5628              		.loc 1 1162 0
 5629 0132 67B1     		cbz	r7, .L988
1163:sxmlc/sxmlc.c **** 		xmlnode->tag_type = TAG_END;
 5630              		.loc 1 1163 0
 5631 0134 0826     		movs	r6, #8
 5632              	.LVL628:
 5633 0136 07E0     		b	.L1054
 5634              	.LVL629:
 5635              	.L1057:
1173:sxmlc/sxmlc.c **** 		if (str[n] == C2SX('>')) { /* Tag with children */
 5636              		.loc 1 1173 0
 5637 0138 3E2B     		cmp	r3, #62
 5638 013a 19D1     		bne	.L990
 5639              	.LBB19:
1174:sxmlc/sxmlc.c **** 			int type = (str[n-1] == '/' ? TAG_SELF : TAG_FATHER); // TODO: Find something better to cope wit
 5640              		.loc 1 1174 0
 5641 013c 19F8013C 		ldrb	r3, [r9, #-1]	@ zero_extendqisi2
 5642 0140 2F2B     		cmp	r3, #47
 5643              	.LVL630:
1175:sxmlc/sxmlc.c **** 			xmlnode->tag_type = type;
 5644              		.loc 1 1175 0
 5645 0142 14BF     		ite	ne
 5646 0144 0226     		movne	r6, #2
 5647 0146 0326     		moveq	r6, #3
 5648              	.LVL631:
 5649              	.L1054:
 5650              	.LBE19:
1179:sxmlc/sxmlc.c **** 			xmlnode->tag_type = TAG_SELF;
 5651              		.loc 1 1179 0
 5652 0148 2677     		strb	r6, [r4, #28]
1180:sxmlc/sxmlc.c **** 			return TAG_SELF;
 5653              		.loc 1 1180 0
 5654 014a 7AE0     		b	.L967
 5655              	.LVL632:
 5656              	.L1005:
1212:sxmlc/sxmlc.c **** 		n = nn + 1;
 5657              		.loc 1 1212 0
 5658 014c 7E1C     		adds	r6, r7, #1
 5659              	.LVL633:
 5660              	.L988:
1168:sxmlc/sxmlc.c **** 	while (n < len) {
 5661              		.loc 1 1168 0 discriminator 1
 5662 014e 4645     		cmp	r6, r8
 5663 0150 6ADA     		bge	.L1006
1170:sxmlc/sxmlc.c **** 		while (sx_isspace(str[n])) n++;
 5664              		.loc 1 1170 0
 5665 0152 DAF80010 		ldr	r1, [r10]
 5666              	.L1007:
1170:sxmlc/sxmlc.c **** 		while (sx_isspace(str[n])) n++;
 5667              		.loc 1 1170 0 is_stmt 0 discriminator 1
 5668 0156 AB5D     		ldrb	r3, [r5, r6]	@ zero_extendqisi2
 5669 0158 05EB0609 		add	r9, r5, r6
 5670 015c CA18     		adds	r2, r1, r3
 5671 015e 5278     		ldrb	r2, [r2, #1]	@ zero_extendqisi2
 5672 0160 02F00802 		and	r2, r2, #8
 5673 0164 02F0FF07 		and	r7, r2, #255
 5674 0168 002A     		cmp	r2, #0
 5675 016a E5D0     		beq	.L1057
1170:sxmlc/sxmlc.c **** 		while (sx_isspace(str[n])) n++;
 5676              		.loc 1 1170 0 discriminator 2
 5677 016c 0136     		adds	r6, r6, #1
 5678              	.LVL634:
 5679 016e F2E7     		b	.L1007
 5680              	.L990:
1178:sxmlc/sxmlc.c **** 		if (!sx_strcmp(str+n, C2SX("/>"))) { /* Tag without children */
 5681              		.loc 1 1178 0 is_stmt 1
 5682 0170 4846     		mov	r0, r9
 5683 0172 3B49     		ldr	r1, .L1060+20
 5684 0174 FFF7FEFF 		bl	strcmp
 5685              	.LVL635:
 5686 0178 08B9     		cbnz	r0, .L992
1179:sxmlc/sxmlc.c **** 			xmlnode->tag_type = TAG_SELF;
 5687              		.loc 1 1179 0
 5688 017a 0326     		movs	r6, #3
 5689              	.LVL636:
 5690 017c E4E7     		b	.L1054
 5691              	.LVL637:
 5692              	.L992:
1184:sxmlc/sxmlc.c **** 		p = sx_strchr(str+n, C2SX('='));
 5693              		.loc 1 1184 0
 5694 017e 4846     		mov	r0, r9
 5695 0180 3D21     		movs	r1, #61
 5696 0182 FFF7FEFF 		bl	strchr
 5697              	.LVL638:
1185:sxmlc/sxmlc.c **** 		if (p == NULL) goto parse_err;
 5698              		.loc 1 1185 0
 5699 0186 0346     		mov	r3, r0
 5700 0188 0028     		cmp	r0, #0
 5701 018a 54D0     		beq	.L994
1186:sxmlc/sxmlc.c **** 		pt = (XMLAttribute*)__realloc(xmlnode->attributes, (xmlnode->n_attributes + 1) * sizeof(XMLAttrib
 5702              		.loc 1 1186 0
 5703 018c E168     		ldr	r1, [r4, #12]
 5704 018e 4FF00C0B 		mov	fp, #12
 5705 0192 01FB0BB1 		mla	r1, r1, fp, fp
 5706 0196 A068     		ldr	r0, [r4, #8]
 5707              	.LVL639:
 5708 0198 0193     		str	r3, [sp, #4]
 5709 019a FFF7FEFF 		bl	realloc
 5710              	.LVL640:
1187:sxmlc/sxmlc.c **** 		if (pt == NULL) goto parse_err;
 5711              		.loc 1 1187 0
 5712 019e 019B     		ldr	r3, [sp, #4]
 5713 01a0 0146     		mov	r1, r0
 5714 01a2 0028     		cmp	r0, #0
 5715 01a4 47D0     		beq	.L994
1189:sxmlc/sxmlc.c **** 		pt[xmlnode->n_attributes].name = NULL;
 5716              		.loc 1 1189 0
 5717 01a6 E068     		ldr	r0, [r4, #12]
 5718              	.LVL641:
 5719 01a8 0BFB00FB 		mul	fp, fp, r0
 5720 01ac 01EB0B02 		add	r2, r1, fp
 5721 01b0 41F80B70 		str	r7, [r1, fp]
1192:sxmlc/sxmlc.c **** 		xmlnode->n_attributes++;
 5722              		.loc 1 1192 0
 5723 01b4 0130     		adds	r0, r0, #1
1190:sxmlc/sxmlc.c **** 		pt[xmlnode->n_attributes].value = NULL;
 5724              		.loc 1 1190 0
 5725 01b6 5760     		str	r7, [r2, #4]
1191:sxmlc/sxmlc.c **** 		pt[xmlnode->n_attributes].active = false;
 5726              		.loc 1 1191 0
 5727 01b8 9760     		str	r7, [r2, #8]
1193:sxmlc/sxmlc.c **** 		xmlnode->attributes = pt;
 5728              		.loc 1 1193 0
 5729 01ba A160     		str	r1, [r4, #8]
1194:sxmlc/sxmlc.c **** 		while (*p != NULC && sx_isspace(*++p)) ; /* Skip spaces */
 5730              		.loc 1 1194 0
 5731 01bc DAF80010 		ldr	r1, [r10]
 5732              	.LVL642:
1192:sxmlc/sxmlc.c **** 		xmlnode->n_attributes++;
 5733              		.loc 1 1192 0
 5734 01c0 E060     		str	r0, [r4, #12]
 5735              	.L997:
 5736 01c2 1F46     		mov	r7, r3
 5737              	.LVL643:
1194:sxmlc/sxmlc.c **** 		while (*p != NULC && sx_isspace(*++p)) ; /* Skip spaces */
 5738              		.loc 1 1194 0 discriminator 1
 5739 01c4 3878     		ldrb	r0, [r7]	@ zero_extendqisi2
 5740 01c6 0133     		adds	r3, r3, #1
 5741              	.LVL644:
 5742 01c8 28B1     		cbz	r0, .L996
1194:sxmlc/sxmlc.c **** 		while (*p != NULC && sx_isspace(*++p)) ; /* Skip spaces */
 5743              		.loc 1 1194 0 is_stmt 0 discriminator 2
 5744 01ca 1878     		ldrb	r0, [r3]	@ zero_extendqisi2
 5745 01cc 1F46     		mov	r7, r3
 5746              	.LVL645:
 5747 01ce 0844     		add	r0, r0, r1
 5748 01d0 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 5749 01d2 0007     		lsls	r0, r0, #28
 5750 01d4 F5D4     		bmi	.L997
 5751              	.LVL646:
 5752              	.L996:
1195:sxmlc/sxmlc.c **** 		if (isquote(*p)) { /* Attribute value starts with a quote, look for next one, ignoring protected 
 5753              		.loc 1 1195 0 is_stmt 1
 5754 01d6 3B78     		ldrb	r3, [r7]	@ zero_extendqisi2
 5755 01d8 7F1B     		subs	r7, r7, r5
 5756              	.LVL647:
 5757 01da 222B     		cmp	r3, #34
1196:sxmlc/sxmlc.c **** 			for (nn = p-str+1; str[nn] && str[nn] != *p; nn++) { // CHECK UNICODE "nn = p-str+1"
 5758              		.loc 1 1196 0
 5759 01dc 07F10107 		add	r7, r7, #1
1195:sxmlc/sxmlc.c **** 		if (isquote(*p)) { /* Attribute value starts with a quote, look for next one, ignoring protected 
 5760              		.loc 1 1195 0
 5761 01e0 05D0     		beq	.L1000
1195:sxmlc/sxmlc.c **** 		if (isquote(*p)) { /* Attribute value starts with a quote, look for next one, ignoring protected 
 5762              		.loc 1 1195 0 is_stmt 0 discriminator 1
 5763 01e2 272B     		cmp	r3, #39
 5764 01e4 10D1     		bne	.L1003
 5765 01e6 02E0     		b	.L1000
 5766              	.LVL648:
 5767              	.L1058:
1196:sxmlc/sxmlc.c **** 			for (nn = p-str+1; str[nn] && str[nn] != *p; nn++) { // CHECK UNICODE "nn = p-str+1"
 5768              		.loc 1 1196 0 is_stmt 1 discriminator 2
 5769 01e8 9942     		cmp	r1, r3
 5770 01ea 10D0     		beq	.L1001
1196:sxmlc/sxmlc.c **** 			for (nn = p-str+1; str[nn] && str[nn] != *p; nn++) { // CHECK UNICODE "nn = p-str+1"
 5771              		.loc 1 1196 0 is_stmt 0 discriminator 1
 5772 01ec 0137     		adds	r7, r7, #1
 5773              	.LVL649:
 5774              	.L1000:
 5775 01ee E95D     		ldrb	r1, [r5, r7]	@ zero_extendqisi2
 5776 01f0 0029     		cmp	r1, #0
 5777 01f2 F9D1     		bne	.L1058
 5778 01f4 0BE0     		b	.L1001
 5779              	.L1059:
1200:sxmlc/sxmlc.c **** 			for (nn = p-str+1; str[nn] != NULC && !sx_isspace(str[nn]) && str[nn] != C2SX('/') && str[nn] !=
 5780              		.loc 1 1200 0 is_stmt 1 discriminator 2
 5781 01f6 C818     		adds	r0, r1, r3
 5782 01f8 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 5783 01fa 0007     		lsls	r0, r0, #28
 5784 01fc 07D4     		bmi	.L1001
1200:sxmlc/sxmlc.c **** 			for (nn = p-str+1; str[nn] != NULC && !sx_isspace(str[nn]) && str[nn] != C2SX('/') && str[nn] !=
 5785              		.loc 1 1200 0 is_stmt 0 discriminator 1
 5786 01fe 2F2B     		cmp	r3, #47
 5787 0200 05D0     		beq	.L1001
 5788 0202 3E2B     		cmp	r3, #62
 5789 0204 03D0     		beq	.L1001
 5790 0206 0137     		adds	r7, r7, #1
 5791              	.LVL650:
 5792              	.L1003:
 5793 0208 EB5D     		ldrb	r3, [r5, r7]	@ zero_extendqisi2
 5794 020a 002B     		cmp	r3, #0
 5795 020c F3D1     		bne	.L1059
 5796              	.L1001:
1205:sxmlc/sxmlc.c **** 		rc = XML_parse_attribute_to(&str[n], nn - n, &xmlnode->attributes[xmlnode->n_attributes - 1]);
 5797              		.loc 1 1205 0 is_stmt 1
 5798 020e 4846     		mov	r0, r9
 5799 0210 B91B     		subs	r1, r7, r6
 5800 0212 FFF7FEFF 		bl	XML_parse_attribute_to
 5801              	.LVL651:
1206:sxmlc/sxmlc.c **** 		if (!rc) goto parse_err;
 5802              		.loc 1 1206 0
 5803 0216 70B1     		cbz	r0, .L994
1207:sxmlc/sxmlc.c **** 		if (rc == 2) { /* Probable presence of '>' inside attribute value, which is legal XML. Remove att
 5804              		.loc 1 1207 0
 5805 0218 0228     		cmp	r0, #2
 5806 021a 97D1     		bne	.L1005
1208:sxmlc/sxmlc.c **** 			XMLNode_remove_attribute(xmlnode, xmlnode->n_attributes - 1);
 5807              		.loc 1 1208 0
 5808 021c E168     		ldr	r1, [r4, #12]
 5809 021e 2046     		mov	r0, r4
 5810              	.LVL652:
 5811 0220 0139     		subs	r1, r1, #1
 5812 0222 FFF7FEFF 		bl	XMLNode_remove_attribute
 5813              	.LVL653:
 5814 0226 0BE0     		b	.L1012
 5815              	.LVL654:
 5816              	.L1006:
1215:sxmlc/sxmlc.c **** 	sx_fprintf(stderr, C2SX("\nWE SHOULD NOT BE HERE!\n[%s]\n\n"), str);
 5817              		.loc 1 1215 0
 5818 0228 0E4B     		ldr	r3, .L1060+24
 5819 022a 0F49     		ldr	r1, .L1060+28
 5820 022c 1B68     		ldr	r3, [r3]
 5821 022e 2A46     		mov	r2, r5
 5822 0230 D868     		ldr	r0, [r3, #12]
 5823 0232 FFF7FEFF 		bl	fprintf
 5824              	.LVL655:
 5825              	.L994:
1218:sxmlc/sxmlc.c **** 	(void)XMLNode_free(xmlnode);
 5826              		.loc 1 1218 0
 5827 0236 2046     		mov	r0, r4
 5828 0238 FFF7FEFF 		bl	XMLNode_free
 5829              	.LVL656:
 5830              	.L1055:
1220:sxmlc/sxmlc.c **** 	return TAG_ERROR;
 5831              		.loc 1 1220 0
 5832 023c FF26     		movs	r6, #255
 5833 023e 00E0     		b	.L967
 5834              	.LVL657:
 5835              	.L1012:
1128:sxmlc/sxmlc.c **** 					return TAG_PARTIAL;
 5836              		.loc 1 1128 0
 5837 0240 0126     		movs	r6, #1
 5838              	.LVL658:
 5839              	.L967:
 5840 0242 70B2     		sxtb	r0, r6
1221:sxmlc/sxmlc.c **** }
 5841              		.loc 1 1221 0
 5842 0244 03B0     		add	sp, sp, #12
 5843              		@ sp needed
 5844 0246 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 5845              	.LVL659:
 5846              	.L1061:
 5847 024a 00BF     		.align	2
 5848              	.L1060:
 5849 024c 00000000 		.word	.LANCHOR3
 5850 0250 92000000 		.word	.LC5
 5851 0254 BE000000 		.word	.LC8
 5852 0258 00000000 		.word	.LANCHOR0
 5853 025c 00000000 		.word	__ctype_ptr__
 5854 0260 9C000000 		.word	.LC6
 5855 0264 00000000 		.word	_impure_ptr
 5856 0268 9F000000 		.word	.LC7
 5857              		.cfi_endproc
 5858              	.LFE43:
 5860              		.section	.text._parse_data_SAX,"ax",%progbits
 5861              		.align	1
 5862              		.thumb
 5863              		.thumb_func
 5865              	_parse_data_SAX:
 5866              	.LFB44:
1224:sxmlc/sxmlc.c **** {
 5867              		.loc 1 1224 0
 5868              		.cfi_startproc
 5869              		@ args = 0, pretend = 0, frame = 56
 5870              		@ frame_needed = 0, uses_anonymous_args = 0
 5871              	.LVL660:
 5872 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 5873              		.cfi_def_cfa_offset 36
 5874              		.cfi_offset 4, -36
 5875              		.cfi_offset 5, -32
 5876              		.cfi_offset 6, -28
 5877              		.cfi_offset 7, -24
 5878              		.cfi_offset 8, -20
 5879              		.cfi_offset 9, -16
 5880              		.cfi_offset 10, -12
 5881              		.cfi_offset 11, -8
 5882              		.cfi_offset 14, -4
 5883 0004 1C46     		mov	r4, r3
 5884 0006 95B0     		sub	sp, sp, #84
 5885              		.cfi_def_cfa_offset 120
1225:sxmlc/sxmlc.c **** 	SXML_CHAR *line = NULL, *txt_end, *p;
 5886              		.loc 1 1225 0
 5887 0008 0023     		movs	r3, #0
 5888              	.LVL661:
1224:sxmlc/sxmlc.c **** {
 5889              		.loc 1 1224 0
 5890 000a 1546     		mov	r5, r2
1225:sxmlc/sxmlc.c **** 	SXML_CHAR *line = NULL, *txt_end, *p;
 5891              		.loc 1 1225 0
 5892 000c 0693     		str	r3, [sp, #24]
1229:sxmlc/sxmlc.c **** 	int (*meos)(void* ds) = (in_type == DATA_SOURCE_BUFFER ? (int(*)(void*))_beob : (int(*)(void*))feo
 5893              		.loc 1 1229 0
 5894 000e 944A     		ldr	r2, .L1234
 5895              	.LVL662:
 5896 0010 944B     		ldr	r3, .L1234+4
1224:sxmlc/sxmlc.c **** {
 5897              		.loc 1 1224 0
 5898 0012 0646     		mov	r6, r0
1229:sxmlc/sxmlc.c **** 	int (*meos)(void* ds) = (in_type == DATA_SOURCE_BUFFER ? (int(*)(void*))_beob : (int(*)(void*))feo
 5899              		.loc 1 1229 0
 5900 0014 0129     		cmp	r1, #1
 5901 0016 14BF     		ite	ne
 5902 0018 9246     		movne	r10, r2
 5903 001a 9A46     		moveq	r10, r3
 5904              	.LVL663:
1231:sxmlc/sxmlc.c **** 	if (sax->start_doc != NULL && !sax->start_doc(sd))
 5905              		.loc 1 1231 0
 5906 001c 2B68     		ldr	r3, [r5]
1224:sxmlc/sxmlc.c **** {
 5907              		.loc 1 1224 0
 5908 001e 8B46     		mov	fp, r1
1231:sxmlc/sxmlc.c **** 	if (sax->start_doc != NULL && !sax->start_doc(sd))
 5909              		.loc 1 1231 0
 5910 0020 13B9     		cbnz	r3, .L1064
 5911              	.LVL664:
 5912              	.L1067:
1233:sxmlc/sxmlc.c **** 	if (sax->all_event != NULL && !sax->all_event(XML_EVENT_START_DOC, NULL, (SXML_CHAR*)sd->name, 0, 
 5913              		.loc 1 1233 0
 5914 0022 AF69     		ldr	r7, [r5, #24]
 5915 0024 37B9     		cbnz	r7, .L1065
 5916 0026 0DE0     		b	.L1066
 5917              	.LVL665:
 5918              	.L1064:
1231:sxmlc/sxmlc.c **** 	if (sax->start_doc != NULL && !sax->start_doc(sd))
 5919              		.loc 1 1231 0 discriminator 1
 5920 0028 2046     		mov	r0, r4
 5921              	.LVL666:
 5922 002a 9847     		blx	r3
 5923              	.LVL667:
 5924 002c 0028     		cmp	r0, #0
 5925 002e F8D1     		bne	.L1067
 5926              	.L1070:
1232:sxmlc/sxmlc.c **** 		return true;
 5927              		.loc 1 1232 0
 5928 0030 0120     		movs	r0, #1
 5929 0032 08E2     		b	.L1217
 5930              	.L1065:
1233:sxmlc/sxmlc.c **** 	if (sax->all_event != NULL && !sax->all_event(XML_EVENT_START_DOC, NULL, (SXML_CHAR*)sd->name, 0, 
 5931              		.loc 1 1233 0 discriminator 1
 5932 0034 0020     		movs	r0, #0
 5933 0036 0094     		str	r4, [sp]
 5934 0038 0146     		mov	r1, r0
 5935 003a 2268     		ldr	r2, [r4]
 5936 003c 0346     		mov	r3, r0
 5937 003e B847     		blx	r7
 5938              	.LVL668:
 5939 0040 0028     		cmp	r0, #0
 5940 0042 F5D0     		beq	.L1070
 5941              	.L1066:
 5942              	.LVL669:
1238:sxmlc/sxmlc.c **** 	sd->line_num = 1; /* Line counter, starts at 1 */
 5943              		.loc 1 1238 0
 5944 0044 0123     		movs	r3, #1
 5945 0046 6360     		str	r3, [r4, #4]
1241:sxmlc/sxmlc.c **** 	(void)XMLNode_init(&node);
 5946              		.loc 1 1241 0
 5947 0048 09A8     		add	r0, sp, #36
1239:sxmlc/sxmlc.c **** 	sz = 0; /* 'line' buffer size */
 5948              		.loc 1 1239 0
 5949 004a 0023     		movs	r3, #0
 5950 004c 0793     		str	r3, [sp, #28]
1240:sxmlc/sxmlc.c **** 	node.init_value = 0;
 5951              		.loc 1 1240 0
 5952 004e 1393     		str	r3, [sp, #76]
1241:sxmlc/sxmlc.c **** 	(void)XMLNode_init(&node);
 5953              		.loc 1 1241 0
 5954 0050 FFF7FEFF 		bl	XMLNode_init
 5955              	.LVL670:
1242:sxmlc/sxmlc.c **** 	while ((n0 = read_line_alloc(in, in_type, &line, &sz, 0, NULC, C2SX('>'), true, C2SX('\n'), &ncr))
 5956              		.loc 1 1242 0
 5957 0054 48E0     		b	.L1069
 5958              	.LVL671:
 5959              	.L1083:
 5960              	.LBB20:
1251:sxmlc/sxmlc.c **** 			int n1 = read_line_alloc(in, in_type, &line, &sz, n0, 0, C2SX('>'), true, C2SX('\n'), &ncr); /* 
 5961              		.loc 1 1251 0
 5962 0056 3E23     		movs	r3, #62
 5963 0058 0293     		str	r3, [sp, #8]
 5964 005a 0123     		movs	r3, #1
 5965 005c 0393     		str	r3, [sp, #12]
 5966 005e 0A23     		movs	r3, #10
 5967 0060 0493     		str	r3, [sp, #16]
 5968 0062 06AA     		add	r2, sp, #24
 5969 0064 07AB     		add	r3, sp, #28
 5970 0066 8DE80003 		stmia	sp, {r8, r9}
 5971 006a 0597     		str	r7, [sp, #20]
 5972 006c 3046     		mov	r0, r6
 5973              	.LVL672:
 5974 006e 5946     		mov	r1, fp
 5975 0070 FFF7FEFF 		bl	read_line_alloc
 5976              	.LVL673:
1252:sxmlc/sxmlc.c **** 			sd->line_num += ncr;
 5977              		.loc 1 1252 0
 5978 0074 6268     		ldr	r2, [r4, #4]
 5979 0076 089B     		ldr	r3, [sp, #32]
1253:sxmlc/sxmlc.c **** 			if (n1 <= n0) {
 5980              		.loc 1 1253 0
 5981 0078 4045     		cmp	r0, r8
1252:sxmlc/sxmlc.c **** 			sd->line_num += ncr;
 5982              		.loc 1 1252 0
 5983 007a 1344     		add	r3, r3, r2
 5984 007c 6360     		str	r3, [r4, #4]
1253:sxmlc/sxmlc.c **** 			if (n1 <= n0) {
 5985              		.loc 1 1253 0
 5986 007e 5DDD     		ble	.L1229
1265:sxmlc/sxmlc.c **** 			n0 = n1;
 5987              		.loc 1 1265 0
 5988 0080 8046     		mov	r8, r0
 5989              	.LVL674:
 5990              	.L1143:
 5991              	.LBE20:
1250:sxmlc/sxmlc.c **** 		while ((txt_end = sx_strchr(line, C2SX('<'))) == NULL) { /* '<' was not found, indicating a proba
 5992              		.loc 1 1250 0 discriminator 1
 5993 0082 0698     		ldr	r0, [sp, #24]
 5994 0084 3C21     		movs	r1, #60
 5995 0086 FFF7FEFF 		bl	strchr
 5996              	.LVL675:
 5997 008a 8146     		mov	r9, r0
 5998 008c 0028     		cmp	r0, #0
 5999 008e E2D0     		beq	.L1083
1280:sxmlc/sxmlc.c **** 		*txt_end = NULC; /* Have 'line' be the text for 'father' */
 6000              		.loc 1 1280 0
 6001 0090 0023     		movs	r3, #0
 6002 0092 0370     		strb	r3, [r0]
1281:sxmlc/sxmlc.c **** 		if (*line != NULC && (sax->new_text != NULL || sax->all_event != NULL)) {
 6003              		.loc 1 1281 0
 6004 0094 0698     		ldr	r0, [sp, #24]
 6005              	.LVL676:
 6006 0096 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 6007 0098 002B     		cmp	r3, #0
 6008 009a 6ED1     		bne	.L1144
 6009              	.LVL677:
 6010              	.L1091:
1287:sxmlc/sxmlc.c **** 		*txt_end = '<'; /* Restores tag start */
 6011              		.loc 1 1287 0
 6012 009c 3C23     		movs	r3, #60
 6013 009e 89F80030 		strb	r3, [r9]
1289:sxmlc/sxmlc.c **** 		switch (tag_type = XML_parse_1string(txt_end, &node)) {
 6014              		.loc 1 1289 0
 6015 00a2 4846     		mov	r0, r9
 6016 00a4 09A9     		add	r1, sp, #36
 6017 00a6 FFF7FEFF 		bl	XML_parse_1string
 6018              	.LVL678:
 6019 00aa 0746     		mov	r7, r0
 6020 00ac 0028     		cmp	r0, #0
 6021 00ae 00F0AA80 		beq	.L1094
 6022 00b2 0828     		cmp	r0, #8
 6023 00b4 00F0ED80 		beq	.L1228
 6024 00b8 421C     		adds	r2, r0, #1
 6025 00ba 75D0     		beq	.L1230
 6026              	.LVL679:
 6027              	.L1125:
1330:sxmlc/sxmlc.c **** 				while (tag_type == TAG_PARTIAL) {
 6028              		.loc 1 1330 0 discriminator 1
 6029 00bc 7FB2     		sxtb	r7, r7
 6030              	.LVL680:
 6031 00be 012F     		cmp	r7, #1
 6032 00c0 00F00281 		beq	.L1132
1363:sxmlc/sxmlc.c **** 				if (sax->start_node != NULL && (exit = !sax->start_node(&node, sd)))
 6033              		.loc 1 1363 0
 6034 00c4 6B68     		ldr	r3, [r5, #4]
 6035 00c6 002B     		cmp	r3, #0
 6036 00c8 40F07181 		bne	.L1231
 6037              	.LVL681:
 6038              	.L1133:
1365:sxmlc/sxmlc.c **** 				if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_START_NODE, &node, NULL, sd->li
 6039              		.loc 1 1365 0
 6040 00cc AF69     		ldr	r7, [r5, #24]
 6041 00ce 002F     		cmp	r7, #0
 6042 00d0 40F07481 		bne	.L1232
 6043              	.LVL682:
 6044              	.L1135:
1367:sxmlc/sxmlc.c **** 				if (node.tag_type != TAG_FATHER && (sax->end_node != NULL || sax->all_event != NULL)) {
 6045              		.loc 1 1367 0
 6046 00d4 9DF94030 		ldrsb	r3, [sp, #64]
 6047 00d8 022B     		cmp	r3, #2
 6048 00da 40F0DA80 		bne	.L1228
 6049              	.LVL683:
 6050              	.L1114:
1375:sxmlc/sxmlc.c **** 		if (exit == true || ret == false || meos(in))
 6051              		.loc 1 1375 0 discriminator 1
 6052 00de 3046     		mov	r0, r6
 6053 00e0 D047     		blx	r10
 6054              	.LVL684:
 6055 00e2 0028     		cmp	r0, #0
 6056 00e4 40F0DF80 		bne	.L1134
 6057              	.LVL685:
 6058              	.L1069:
1242:sxmlc/sxmlc.c **** 	while ((n0 = read_line_alloc(in, in_type, &line, &sz, 0, NULC, C2SX('>'), true, C2SX('\n'), &ncr))
 6059              		.loc 1 1242 0 discriminator 1
 6060 00e8 0023     		movs	r3, #0
 6061 00ea 0093     		str	r3, [sp]
 6062 00ec 0193     		str	r3, [sp, #4]
 6063 00ee 3E23     		movs	r3, #62
 6064 00f0 0293     		str	r3, [sp, #8]
 6065 00f2 0123     		movs	r3, #1
 6066 00f4 0393     		str	r3, [sp, #12]
 6067 00f6 08AF     		add	r7, sp, #32
 6068 00f8 0A23     		movs	r3, #10
 6069 00fa 0493     		str	r3, [sp, #16]
 6070 00fc 0597     		str	r7, [sp, #20]
 6071 00fe 3046     		mov	r0, r6
 6072 0100 5946     		mov	r1, fp
 6073 0102 06AA     		add	r2, sp, #24
 6074 0104 07AB     		add	r3, sp, #28
 6075 0106 FFF7FEFF 		bl	read_line_alloc
 6076              	.LVL686:
 6077 010a 8046     		mov	r8, r0
 6078 010c 0028     		cmp	r0, #0
 6079 010e 00F0CA80 		beq	.L1134
1243:sxmlc/sxmlc.c **** 		(void)XMLNode_free(&node);
 6080              		.loc 1 1243 0
 6081 0112 09A8     		add	r0, sp, #36
 6082              	.LVL687:
 6083 0114 FFF7FEFF 		bl	XMLNode_free
 6084              	.LVL688:
1244:sxmlc/sxmlc.c **** 		for (p = line; *p != NULC && sx_isspace(*p); p++) ; /* Checks if text is only spaces */
 6085              		.loc 1 1244 0
 6086 0118 534B     		ldr	r3, .L1234+8
 6087 011a 069A     		ldr	r2, [sp, #24]
 6088 011c 1968     		ldr	r1, [r3]
 6089 011e 013A     		subs	r2, r2, #1
 6090              	.LVL689:
 6091              	.L1071:
1244:sxmlc/sxmlc.c **** 		for (p = line; *p != NULC && sx_isspace(*p); p++) ; /* Checks if text is only spaces */
 6092              		.loc 1 1244 0 is_stmt 0 discriminator 1
 6093 0120 12F8013F 		ldrb	r3, [r2, #1]!	@ zero_extendqisi2
 6094              	.LVL690:
 6095 0124 002B     		cmp	r3, #0
 6096 0126 00F0BE80 		beq	.L1134
1244:sxmlc/sxmlc.c **** 		for (p = line; *p != NULC && sx_isspace(*p); p++) ; /* Checks if text is only spaces */
 6097              		.loc 1 1244 0 discriminator 2
 6098 012a 0B44     		add	r3, r3, r1
 6099 012c 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 6100 012e 1807     		lsls	r0, r3, #28
 6101 0130 F6D4     		bmi	.L1071
1247:sxmlc/sxmlc.c **** 		sd->line_num += ncr;
 6102              		.loc 1 1247 0 is_stmt 1
 6103 0132 6268     		ldr	r2, [r4, #4]
 6104              	.LVL691:
 6105 0134 089B     		ldr	r3, [sp, #32]
 6106 0136 1344     		add	r3, r3, r2
 6107 0138 6360     		str	r3, [r4, #4]
1250:sxmlc/sxmlc.c **** 		while ((txt_end = sx_strchr(line, C2SX('<'))) == NULL) { /* '<' was not found, indicating a proba
 6108              		.loc 1 1250 0
 6109 013a A2E7     		b	.L1143
 6110              	.LVL692:
 6111              	.L1229:
 6112              	.LBB21:
1255:sxmlc/sxmlc.c **** 				if (sax->on_error == NULL && sax->all_event == NULL)
 6113              		.loc 1 1255 0
 6114 013c 6E69     		ldr	r6, [r5, #20]
 6115              	.LVL693:
 6116 013e A6B9     		cbnz	r6, .L1077
1255:sxmlc/sxmlc.c **** 				if (sax->on_error == NULL && sax->all_event == NULL)
 6117              		.loc 1 1255 0 is_stmt 0 discriminator 1
 6118 0140 AA69     		ldr	r2, [r5, #24]
 6119 0142 52B1     		cbz	r2, .L1078
 6120              	.LVL694:
 6121              	.L1082:
1260:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->name, PAR
 6122              		.loc 1 1260 0 is_stmt 1
 6123 0144 AE69     		ldr	r6, [r5, #24]
 6124 0146 002E     		cmp	r6, #0
 6125 0148 49D0     		beq	.L1081
1260:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->name, PAR
 6126              		.loc 1 1260 0 is_stmt 0 discriminator 1
 6127 014a 0094     		str	r4, [sp]
 6128 014c 0021     		movs	r1, #0
 6129 014e 2268     		ldr	r2, [r4]
 6130 0150 4FF0FF33 		mov	r3, #-1
 6131 0154 0420     		movs	r0, #4
 6132 0156 B047     		blx	r6
 6133              	.LVL695:
 6134              	.LBE21:
 6135 0158 41E0     		b	.L1081
 6136              	.LVL696:
 6137              	.L1078:
 6138              	.LBB22:
1256:sxmlc/sxmlc.c **** 					sx_fprintf(stderr, C2SX("%s:%d: MEMORY ERROR.\n"), sd->name, sd->line_num);
 6139              		.loc 1 1256 0 is_stmt 1
 6140 015a 444A     		ldr	r2, .L1234+12
 6141 015c 4449     		ldr	r1, .L1234+16
 6142 015e 1268     		ldr	r2, [r2]
 6143 0160 D068     		ldr	r0, [r2, #12]
 6144              	.LVL697:
 6145 0162 2268     		ldr	r2, [r4]
 6146 0164 FFF7FEFF 		bl	fprintf
 6147              	.LVL698:
 6148 0168 39E0     		b	.L1081
 6149              	.LVL699:
 6150              	.L1077:
1258:sxmlc/sxmlc.c **** 					if (sax->on_error != NULL && !sax->on_error(PARSE_ERR_MEMORY, sd->line_num, sd))
 6151              		.loc 1 1258 0 discriminator 1
 6152 016a 4FF0FF30 		mov	r0, #-1
 6153              	.LVL700:
 6154 016e 1946     		mov	r1, r3
 6155 0170 2246     		mov	r2, r4
 6156 0172 B047     		blx	r6
 6157              	.LVL701:
 6158 0174 0028     		cmp	r0, #0
 6159 0176 32D0     		beq	.L1081
 6160 0178 E4E7     		b	.L1082
 6161              	.LVL702:
 6162              	.L1144:
 6163              	.LBE22:
1281:sxmlc/sxmlc.c **** 		if (*line != NULC && (sax->new_text != NULL || sax->all_event != NULL)) {
 6164              		.loc 1 1281 0 discriminator 1
 6165 017a EB68     		ldr	r3, [r5, #12]
 6166 017c 13B9     		cbnz	r3, .L1089
 6167 017e AB69     		ldr	r3, [r5, #24]
 6168 0180 2BB9     		cbnz	r3, .L1090
 6169 0182 8BE7     		b	.L1091
 6170              	.L1089:
1282:sxmlc/sxmlc.c **** 			if (sax->new_text != NULL && (exit = !sax->new_text(line, sd))) /* no str_unescape(line) */
 6171              		.loc 1 1282 0 discriminator 1
 6172 0184 2146     		mov	r1, r4
 6173 0186 9847     		blx	r3
 6174              	.LVL703:
 6175 0188 0028     		cmp	r0, #0
 6176 018a 00F08C80 		beq	.L1134
 6177              	.LVL704:
 6178              	.L1090:
1284:sxmlc/sxmlc.c **** 			if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_TEXT, NULL, line, sd->line_num, 
 6179              		.loc 1 1284 0
 6180 018e AF69     		ldr	r7, [r5, #24]
 6181 0190 002F     		cmp	r7, #0
 6182 0192 83D0     		beq	.L1091
1284:sxmlc/sxmlc.c **** 			if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_TEXT, NULL, line, sd->line_num, 
 6183              		.loc 1 1284 0 is_stmt 0 discriminator 1
 6184 0194 0094     		str	r4, [sp]
 6185 0196 0320     		movs	r0, #3
 6186 0198 0021     		movs	r1, #0
 6187 019a 069A     		ldr	r2, [sp, #24]
 6188 019c 6368     		ldr	r3, [r4, #4]
 6189 019e B847     		blx	r7
 6190              	.LVL705:
 6191 01a0 0028     		cmp	r0, #0
 6192 01a2 7FF47BAF 		bne	.L1091
 6193 01a6 7EE0     		b	.L1134
 6194              	.LVL706:
 6195              	.L1230:
1292:sxmlc/sxmlc.c **** 				if (sax->on_error == NULL && sax->all_event == NULL)
 6196              		.loc 1 1292 0 is_stmt 1
 6197 01a8 6B69     		ldr	r3, [r5, #20]
 6198 01aa 8BB9     		cbnz	r3, .L1097
1292:sxmlc/sxmlc.c **** 				if (sax->on_error == NULL && sax->all_event == NULL)
 6199              		.loc 1 1292 0 is_stmt 0 discriminator 1
 6200 01ac AB69     		ldr	r3, [r5, #24]
 6201 01ae 53B1     		cbz	r3, .L1098
 6202              	.LVL707:
 6203              	.L1103:
1297:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->n
 6204              		.loc 1 1297 0 is_stmt 1
 6205 01b0 AE69     		ldr	r6, [r5, #24]
 6206              	.LVL708:
 6207 01b2 002E     		cmp	r6, #0
 6208 01b4 00F04581 		beq	.L1101
1297:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->n
 6209              		.loc 1 1297 0 is_stmt 0 discriminator 1
 6210 01b8 0094     		str	r4, [sp]
 6211 01ba 0420     		movs	r0, #4
 6212 01bc 0021     		movs	r1, #0
 6213 01be 2268     		ldr	r2, [r4]
 6214 01c0 4FF0FF33 		mov	r3, #-1
 6215 01c4 1DE0     		b	.L1224
 6216              	.LVL709:
 6217              	.L1098:
1293:sxmlc/sxmlc.c **** 					sx_fprintf(stderr, C2SX("%s:%d: MEMORY ERROR.\n"), sd->name, sd->line_num);
 6218              		.loc 1 1293 0 is_stmt 1
 6219 01c6 294B     		ldr	r3, .L1234+12
 6220 01c8 2949     		ldr	r1, .L1234+16
 6221 01ca 1B68     		ldr	r3, [r3]
 6222 01cc D868     		ldr	r0, [r3, #12]
 6223              	.LVL710:
 6224 01ce 76E0     		b	.L1223
 6225              	.LVL711:
 6226              	.L1097:
1295:sxmlc/sxmlc.c **** 					if (sax->on_error != NULL && (exit = !sax->on_error(PARSE_ERR_MEMORY, sd->line_num, sd)))
 6227              		.loc 1 1295 0 discriminator 1
 6228 01d0 6168     		ldr	r1, [r4, #4]
 6229 01d2 2246     		mov	r2, r4
 6230 01d4 9847     		blx	r3
 6231              	.LVL712:
 6232 01d6 0028     		cmp	r0, #0
 6233 01d8 00F03381 		beq	.L1101
 6234 01dc E8E7     		b	.L1103
 6235              	.LVL713:
 6236              	.L1081:
1269:sxmlc/sxmlc.c **** 			if (sax->on_error == NULL && sax->all_event == NULL)
 6237              		.loc 1 1269 0
 6238 01de 6B69     		ldr	r3, [r5, #20]
 6239 01e0 002B     		cmp	r3, #0
 6240 01e2 40F02681 		bne	.L1219
1269:sxmlc/sxmlc.c **** 			if (sax->on_error == NULL && sax->all_event == NULL)
 6241              		.loc 1 1269 0 is_stmt 0 discriminator 1
 6242 01e6 AE69     		ldr	r6, [r5, #24]
 6243 01e8 002E     		cmp	r6, #0
 6244 01ea 00F00381 		beq	.L1085
 6245              	.L1088:
1274:sxmlc/sxmlc.c **** 				if (sax->all_event != NULL && !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->name, PARS
 6246              		.loc 1 1274 0 is_stmt 1
 6247 01ee AE69     		ldr	r6, [r5, #24]
 6248 01f0 002E     		cmp	r6, #0
 6249 01f2 00F02681 		beq	.L1101
1274:sxmlc/sxmlc.c **** 				if (sax->all_event != NULL && !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->name, PARS
 6250              		.loc 1 1274 0 is_stmt 0 discriminator 1
 6251 01f6 2268     		ldr	r2, [r4]
 6252 01f8 0094     		str	r4, [sp]
 6253 01fa 0420     		movs	r0, #4
 6254 01fc 0021     		movs	r1, #0
 6255 01fe 6FF00103 		mvn	r3, #1
 6256              	.LVL714:
 6257              	.L1224:
1297:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->n
 6258              		.loc 1 1297 0 is_stmt 1 discriminator 1
 6259 0202 B047     		blx	r6
 6260              	.LVL715:
 6261 0204 1DE1     		b	.L1101
 6262              	.LVL716:
 6263              	.L1094:
1304:sxmlc/sxmlc.c **** 				p = sx_strchr(txt_end, C2SX('\n'));
 6264              		.loc 1 1304 0
 6265 0206 4846     		mov	r0, r9
 6266              	.LVL717:
 6267 0208 0A21     		movs	r1, #10
 6268 020a FFF7FEFF 		bl	strchr
 6269              	.LVL718:
1305:sxmlc/sxmlc.c **** 				if (p != NULL)
 6270              		.loc 1 1305 0
 6271 020e 0646     		mov	r6, r0
 6272              	.LVL719:
 6273 0210 00B1     		cbz	r0, .L1104
1306:sxmlc/sxmlc.c **** 					*p = NULC;
 6274              		.loc 1 1306 0
 6275 0212 0770     		strb	r7, [r0]
 6276              	.L1104:
1307:sxmlc/sxmlc.c **** 				if (sax->on_error == NULL && sax->all_event == NULL) {
 6277              		.loc 1 1307 0
 6278 0214 6B69     		ldr	r3, [r5, #20]
 6279 0216 002B     		cmp	r3, #0
 6280 0218 32D1     		bne	.L1105
1307:sxmlc/sxmlc.c **** 				if (sax->on_error == NULL && sax->all_event == NULL) {
 6281              		.loc 1 1307 0 is_stmt 0 discriminator 1
 6282 021a AB69     		ldr	r3, [r5, #24]
 6283 021c 53B1     		cbz	r3, .L1106
 6284              	.LVL720:
 6285              	.L1109:
1314:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->n
 6286              		.loc 1 1314 0 is_stmt 1
 6287 021e AE69     		ldr	r6, [r5, #24]
 6288              	.LVL721:
 6289 0220 002E     		cmp	r6, #0
 6290 0222 00F00E81 		beq	.L1101
1314:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd->n
 6291              		.loc 1 1314 0 is_stmt 0 discriminator 1
 6292 0226 0094     		str	r4, [sp]
 6293 0228 0420     		movs	r0, #4
 6294 022a 0021     		movs	r1, #0
 6295 022c 2268     		ldr	r2, [r4]
 6296 022e 6FF00203 		mvn	r3, #2
 6297 0232 E6E7     		b	.L1224
 6298              	.LVL722:
 6299              	.L1106:
1308:sxmlc/sxmlc.c **** 					sx_fprintf(stderr, C2SX("%s:%d: SYNTAX ERROR (%s%s).\n"), sd->name, sd->line_num, txt_end, p =
 6300              		.loc 1 1308 0 is_stmt 1
 6301 0234 0D4B     		ldr	r3, .L1234+12
 6302 0236 0F49     		ldr	r1, .L1234+20
 6303 0238 0F4F     		ldr	r7, .L1234+24
 6304 023a 1B68     		ldr	r3, [r3]
 6305 023c 002E     		cmp	r6, #0
 6306 023e 18BF     		it	ne
 6307 0240 3946     		movne	r1, r7
 6308 0242 D868     		ldr	r0, [r3, #12]
 6309              	.LVL723:
 6310 0244 0191     		str	r1, [sp, #4]
 6311 0246 94E80C00 		ldmia	r4, {r2, r3}
 6312 024a CDF80090 		str	r9, [sp]
 6313 024e 0B49     		ldr	r1, .L1234+28
 6314 0250 FFF7FEFF 		bl	fprintf
 6315              	.LVL724:
1309:sxmlc/sxmlc.c **** 					if (p != NULL)
 6316              		.loc 1 1309 0
 6317 0254 002E     		cmp	r6, #0
 6318 0256 00F0F480 		beq	.L1101
1310:sxmlc/sxmlc.c **** 						*p = C2SX('\n');
 6319              		.loc 1 1310 0
 6320 025a 0A23     		movs	r3, #10
 6321 025c 3370     		strb	r3, [r6]
 6322 025e F0E0     		b	.L1101
 6323              	.L1235:
 6324              		.align	2
 6325              	.L1234:
 6326 0260 00000000 		.word	feof
 6327 0264 00000000 		.word	_beob
 6328 0268 00000000 		.word	__ctype_ptr__
 6329 026c 00000000 		.word	_impure_ptr
 6330 0270 C6000000 		.word	.LC11
 6331 0274 C1000000 		.word	.LC9
 6332 0278 C2000000 		.word	.LC10
 6333 027c 1F010000 		.word	.LC13
 6334              	.LVL725:
 6335              	.L1105:
1312:sxmlc/sxmlc.c **** 					if (sax->on_error != NULL && (exit = !sax->on_error(PARSE_ERR_SYNTAX, sd->line_num, sd)))
 6336              		.loc 1 1312 0 discriminator 1
 6337 0280 6FF00200 		mvn	r0, #2
 6338              	.LVL726:
 6339 0284 6168     		ldr	r1, [r4, #4]
 6340 0286 2246     		mov	r2, r4
 6341 0288 9847     		blx	r3
 6342              	.LVL727:
 6343 028a 0028     		cmp	r0, #0
 6344 028c 00F0D980 		beq	.L1101
 6345 0290 C5E7     		b	.L1109
 6346              	.LVL728:
 6347              	.L1228:
1367:sxmlc/sxmlc.c **** 				if (node.tag_type != TAG_FATHER && (sax->end_node != NULL || sax->all_event != NULL)) {
 6348              		.loc 1 1367 0 discriminator 1
 6349 0292 AB68     		ldr	r3, [r5, #8]
 6350 0294 002B     		cmp	r3, #0
 6351 0296 00F09B80 		beq	.L1233
1321:sxmlc/sxmlc.c **** 					if (sax->end_node != NULL && (exit = !sax->end_node(&node, sd)))
 6352              		.loc 1 1321 0 discriminator 1
 6353 029a 09A8     		add	r0, sp, #36
 6354 029c 2146     		mov	r1, r4
 6355 029e 9847     		blx	r3
 6356              	.LVL729:
 6357 02a0 0028     		cmp	r0, #0
 6358 02a2 40F09980 		bne	.L1138
 6359              	.LVL730:
 6360              	.L1134:
1291:sxmlc/sxmlc.c **** 				ret = false;
 6361              		.loc 1 1291 0
 6362 02a6 0126     		movs	r6, #1
 6363              	.LVL731:
 6364 02a8 ACE0     		b	.L1073
 6365              	.LVL732:
 6366              	.L1124:
 6367              	.LBB23:
1350:sxmlc/sxmlc.c **** 						if (sax->on_error == NULL && sax->all_event == NULL)
 6368              		.loc 1 1350 0
 6369 02aa 6F69     		ldr	r7, [r5, #20]
 6370 02ac 002F     		cmp	r7, #0
 6371 02ae 5CD1     		bne	.L1126
1350:sxmlc/sxmlc.c **** 						if (sax->on_error == NULL && sax->all_event == NULL)
 6372              		.loc 1 1350 0 is_stmt 0 discriminator 1
 6373 02b0 AB69     		ldr	r3, [r5, #24]
 6374 02b2 002B     		cmp	r3, #0
 6375 02b4 66D1     		bne	.L1130
1351:sxmlc/sxmlc.c **** 							sx_fprintf(stderr, C2SX("%s:%d: PARSE ERROR.\n"), sd->name, sd->line_num);
 6376              		.loc 1 1351 0 is_stmt 1
 6377 02b6 654B     		ldr	r3, .L1236
 6378 02b8 6549     		ldr	r1, .L1236+4
 6379 02ba 1B68     		ldr	r3, [r3]
 6380 02bc D868     		ldr	r0, [r3, #12]
 6381              	.LVL733:
 6382              	.L1223:
 6383 02be 94E80C00 		ldmia	r4, {r2, r3}
 6384              	.L1225:
 6385 02c2 FFF7FEFF 		bl	fprintf
 6386              	.LVL734:
 6387 02c6 BCE0     		b	.L1101
 6388              	.LVL735:
 6389              	.L1132:
1331:sxmlc/sxmlc.c **** 					int n1 = read_line_alloc(in, in_type, &line, &sz, n0, NULC, C2SX('>'), true, C2SX('\n'), &ncr)
 6390              		.loc 1 1331 0
 6391 02c8 0023     		movs	r3, #0
 6392 02ca 0193     		str	r3, [sp, #4]
 6393 02cc 3E23     		movs	r3, #62
 6394 02ce 0293     		str	r3, [sp, #8]
 6395 02d0 0A23     		movs	r3, #10
 6396 02d2 0493     		str	r3, [sp, #16]
 6397 02d4 08AB     		add	r3, sp, #32
 6398 02d6 0593     		str	r3, [sp, #20]
 6399 02d8 06AA     		add	r2, sp, #24
 6400 02da 07AB     		add	r3, sp, #28
 6401 02dc CDF80080 		str	r8, [sp]
 6402 02e0 0397     		str	r7, [sp, #12]
 6403 02e2 3046     		mov	r0, r6
 6404 02e4 5946     		mov	r1, fp
 6405 02e6 FFF7FEFF 		bl	read_line_alloc
 6406              	.LVL736:
1332:sxmlc/sxmlc.c **** 					sd->line_num += ncr;
 6407              		.loc 1 1332 0
 6408 02ea 6268     		ldr	r2, [r4, #4]
 6409 02ec 089B     		ldr	r3, [sp, #32]
1333:sxmlc/sxmlc.c **** 					if (n1 <= n0) {
 6410              		.loc 1 1333 0
 6411 02ee 4045     		cmp	r0, r8
1332:sxmlc/sxmlc.c **** 					sd->line_num += ncr;
 6412              		.loc 1 1332 0
 6413 02f0 1344     		add	r3, r3, r2
1331:sxmlc/sxmlc.c **** 					int n1 = read_line_alloc(in, in_type, &line, &sz, n0, NULC, C2SX('>'), true, C2SX('\n'), &ncr)
 6414              		.loc 1 1331 0
 6415 02f2 8146     		mov	r9, r0
 6416              	.LVL737:
1332:sxmlc/sxmlc.c **** 					sd->line_num += ncr;
 6417              		.loc 1 1332 0
 6418 02f4 6360     		str	r3, [r4, #4]
1333:sxmlc/sxmlc.c **** 					if (n1 <= n0) {
 6419              		.loc 1 1333 0
 6420 02f6 2CDC     		bgt	.L1115
 6421              	.LVL738:
1335:sxmlc/sxmlc.c **** 						if (sax->on_error == NULL && sax->all_event == NULL)
 6422              		.loc 1 1335 0
 6423 02f8 6F69     		ldr	r7, [r5, #20]
 6424 02fa E7B9     		cbnz	r7, .L1116
1335:sxmlc/sxmlc.c **** 						if (sax->on_error == NULL && sax->all_event == NULL)
 6425              		.loc 1 1335 0 is_stmt 0 discriminator 1
 6426 02fc AA69     		ldr	r2, [r5, #24]
 6427 02fe A2B1     		cbz	r2, .L1117
 6428              	.LVL739:
 6429              	.L1122:
1340:sxmlc/sxmlc.c **** 							if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd-
 6430              		.loc 1 1340 0 is_stmt 1
 6431 0300 AF69     		ldr	r7, [r5, #24]
 6432 0302 002F     		cmp	r7, #0
 6433 0304 00F09D80 		beq	.L1101
1340:sxmlc/sxmlc.c **** 							if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd-
 6434              		.loc 1 1340 0 is_stmt 0 discriminator 1
 6435 0308 3046     		mov	r0, r6
 6436 030a D4F80080 		ldr	r8, [r4]
 6437              	.LVL740:
 6438 030e D047     		blx	r10
 6439              	.LVL741:
 6440 0310 0028     		cmp	r0, #0
 6441 0312 0094     		str	r4, [sp]
 6442 0314 4FF00400 		mov	r0, #4
 6443 0318 4FF00001 		mov	r1, #0
 6444 031c 4246     		mov	r2, r8
 6445 031e 0CBF     		ite	eq
 6446 0320 4FF0FF33 		moveq	r3, #-1
 6447 0324 6FF00303 		mvnne	r3, #3
 6448 0328 3FE0     		b	.L1226
 6449              	.LVL742:
 6450              	.L1117:
1336:sxmlc/sxmlc.c **** 							sx_fprintf(stderr, C2SX("%s:%d: SYNTAX ERROR.\n"), sd->name, sd->line_num);
 6451              		.loc 1 1336 0 is_stmt 1
 6452 032a 484A     		ldr	r2, .L1236
 6453 032c 4949     		ldr	r1, .L1236+8
 6454 032e 1268     		ldr	r2, [r2]
 6455 0330 D068     		ldr	r0, [r2, #12]
 6456              	.LVL743:
 6457 0332 2268     		ldr	r2, [r4]
 6458 0334 C5E7     		b	.L1225
 6459              	.LVL744:
 6460              	.L1116:
1338:sxmlc/sxmlc.c **** 							if (sax->on_error != NULL && (exit = !sax->on_error(meos(in) ? PARSE_ERR_EOF : PARSE_ERR_MEM
 6461              		.loc 1 1338 0 discriminator 1
 6462 0336 3046     		mov	r0, r6
 6463              	.LVL745:
 6464 0338 D047     		blx	r10
 6465              	.LVL746:
 6466 033a 0028     		cmp	r0, #0
 6467 033c 14BF     		ite	ne
 6468 033e 6FF00300 		mvnne	r0, #3
 6469 0342 4FF0FF30 		moveq	r0, #-1
 6470 0346 6168     		ldr	r1, [r4, #4]
 6471 0348 2246     		mov	r2, r4
 6472 034a B847     		blx	r7
 6473              	.LVL747:
 6474 034c 0028     		cmp	r0, #0
 6475 034e 78D0     		beq	.L1101
 6476 0350 D6E7     		b	.L1122
 6477              	.LVL748:
 6478              	.L1115:
1346:sxmlc/sxmlc.c **** 					txt_end = sx_strchr(line, C2SX('<')); /* In case 'line' has been moved by the '__realloc' in '
 6479              		.loc 1 1346 0
 6480 0352 0698     		ldr	r0, [sp, #24]
 6481              	.LVL749:
 6482 0354 3C21     		movs	r1, #60
 6483 0356 FFF7FEFF 		bl	strchr
 6484              	.LVL750:
1347:sxmlc/sxmlc.c **** 					tag_type = XML_parse_1string(txt_end, &node);
 6485              		.loc 1 1347 0
 6486 035a 09A9     		add	r1, sp, #36
 6487 035c FFF7FEFF 		bl	XML_parse_1string
 6488              	.LVL751:
1348:sxmlc/sxmlc.c **** 					if (tag_type == TAG_ERROR) {
 6489              		.loc 1 1348 0
 6490 0360 431C     		adds	r3, r0, #1
1347:sxmlc/sxmlc.c **** 					tag_type = XML_parse_1string(txt_end, &node);
 6491              		.loc 1 1347 0
 6492 0362 0746     		mov	r7, r0
 6493              	.LVL752:
1348:sxmlc/sxmlc.c **** 					if (tag_type == TAG_ERROR) {
 6494              		.loc 1 1348 0
 6495 0364 A1D0     		beq	.L1124
1345:sxmlc/sxmlc.c **** 					n0 = n1;
 6496              		.loc 1 1345 0
 6497 0366 C846     		mov	r8, r9
 6498 0368 A8E6     		b	.L1125
 6499              	.LVL753:
 6500              	.L1126:
1353:sxmlc/sxmlc.c **** 							if (sax->on_error != NULL && (exit = !sax->on_error(meos(in) ? PARSE_ERR_EOF : PARSE_ERR_SYN
 6501              		.loc 1 1353 0 discriminator 1
 6502 036a 3046     		mov	r0, r6
 6503              	.LVL754:
 6504 036c D047     		blx	r10
 6505              	.LVL755:
 6506 036e 0028     		cmp	r0, #0
 6507 0370 14BF     		ite	ne
 6508 0372 6FF00300 		mvnne	r0, #3
 6509 0376 6FF00200 		mvneq	r0, #2
 6510 037a 6168     		ldr	r1, [r4, #4]
 6511 037c 2246     		mov	r2, r4
 6512 037e B847     		blx	r7
 6513              	.LVL756:
 6514 0380 0028     		cmp	r0, #0
 6515 0382 5ED0     		beq	.L1101
 6516              	.LVL757:
 6517              	.L1130:
1355:sxmlc/sxmlc.c **** 							if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd-
 6518              		.loc 1 1355 0
 6519 0384 AF69     		ldr	r7, [r5, #24]
 6520 0386 002F     		cmp	r7, #0
 6521 0388 5BD0     		beq	.L1101
1355:sxmlc/sxmlc.c **** 							if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_ERROR, NULL, (SXML_CHAR*)sd-
 6522              		.loc 1 1355 0 is_stmt 0 discriminator 1
 6523 038a 3046     		mov	r0, r6
 6524 038c D4F80080 		ldr	r8, [r4]
 6525 0390 D047     		blx	r10
 6526              	.LVL758:
 6527 0392 0028     		cmp	r0, #0
 6528 0394 0094     		str	r4, [sp]
 6529 0396 4FF00400 		mov	r0, #4
 6530 039a 4FF00001 		mov	r1, #0
 6531 039e 4246     		mov	r2, r8
 6532 03a0 0CBF     		ite	eq
 6533 03a2 6FF00203 		mvneq	r3, #2
 6534 03a6 6FF00303 		mvnne	r3, #3
 6535              	.LVL759:
 6536              	.L1226:
 6537 03aa B847     		blx	r7
 6538              	.LVL760:
 6539              	.LBE23:
 6540 03ac 49E0     		b	.L1101
 6541              	.LVL761:
 6542              	.L1231:
1363:sxmlc/sxmlc.c **** 				if (sax->start_node != NULL && (exit = !sax->start_node(&node, sd)))
 6543              		.loc 1 1363 0 is_stmt 1 discriminator 1
 6544 03ae 09A8     		add	r0, sp, #36
 6545 03b0 2146     		mov	r1, r4
 6546 03b2 9847     		blx	r3
 6547              	.LVL762:
 6548 03b4 0028     		cmp	r0, #0
 6549 03b6 3FF476AF 		beq	.L1134
 6550 03ba 87E6     		b	.L1133
 6551              	.LVL763:
 6552              	.L1232:
1365:sxmlc/sxmlc.c **** 				if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_START_NODE, &node, NULL, sd->li
 6553              		.loc 1 1365 0 discriminator 1
 6554 03bc 0094     		str	r4, [sp]
 6555 03be 0120     		movs	r0, #1
 6556 03c0 09A9     		add	r1, sp, #36
 6557 03c2 0022     		movs	r2, #0
 6558 03c4 6368     		ldr	r3, [r4, #4]
 6559 03c6 B847     		blx	r7
 6560              	.LVL764:
 6561 03c8 0028     		cmp	r0, #0
 6562 03ca 3FF46CAF 		beq	.L1134
 6563 03ce 81E6     		b	.L1135
 6564              	.LVL765:
 6565              	.L1233:
1367:sxmlc/sxmlc.c **** 				if (node.tag_type != TAG_FATHER && (sax->end_node != NULL || sax->all_event != NULL)) {
 6566              		.loc 1 1367 0 discriminator 1
 6567 03d0 AB69     		ldr	r3, [r5, #24]
 6568 03d2 002B     		cmp	r3, #0
 6569 03d4 3FF483AE 		beq	.L1114
 6570              	.LVL766:
 6571              	.L1138:
1370:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_END_NODE, &node, NULL, sd->lin
 6572              		.loc 1 1370 0
 6573 03d8 AF69     		ldr	r7, [r5, #24]
 6574 03da 002F     		cmp	r7, #0
 6575 03dc 3FF47FAE 		beq	.L1114
1370:sxmlc/sxmlc.c **** 					if (sax->all_event != NULL && (exit = !sax->all_event(XML_EVENT_END_NODE, &node, NULL, sd->lin
 6576              		.loc 1 1370 0 is_stmt 0 discriminator 1
 6577 03e0 0094     		str	r4, [sp]
 6578 03e2 0220     		movs	r0, #2
 6579 03e4 09A9     		add	r1, sp, #36
 6580 03e6 0022     		movs	r2, #0
 6581 03e8 6368     		ldr	r3, [r4, #4]
 6582 03ea B847     		blx	r7
 6583              	.LVL767:
1375:sxmlc/sxmlc.c **** 		if (exit == true || ret == false || meos(in))
 6584              		.loc 1 1375 0 is_stmt 1 discriminator 1
 6585 03ec 0028     		cmp	r0, #0
 6586 03ee 7FF476AE 		bne	.L1114
 6587 03f2 58E7     		b	.L1134
 6588              	.LVL768:
 6589              	.L1085:
1270:sxmlc/sxmlc.c **** 				sx_fprintf(stderr, C2SX("%s:%d: ERROR: Unexpected end character '>', without matching '<'!\n"),
 6590              		.loc 1 1270 0
 6591 03f4 154B     		ldr	r3, .L1236
 6592 03f6 1849     		ldr	r1, .L1236+12
 6593 03f8 1B68     		ldr	r3, [r3]
 6594 03fa D868     		ldr	r0, [r3, #12]
 6595 03fc 94E80C00 		ldmia	r4, {r2, r3}
 6596 0400 FFF7FEFF 		bl	fprintf
 6597              	.LVL769:
 6598              	.L1073:
1378:sxmlc/sxmlc.c **** 	__free(line);
 6599              		.loc 1 1378 0
 6600 0404 0698     		ldr	r0, [sp, #24]
 6601 0406 FFF7FEFF 		bl	free
 6602              	.LVL770:
1379:sxmlc/sxmlc.c **** 	(void)XMLNode_free(&node);
 6603              		.loc 1 1379 0
 6604 040a 09A8     		add	r0, sp, #36
 6605 040c FFF7FEFF 		bl	XMLNode_free
 6606              	.LVL771:
1381:sxmlc/sxmlc.c **** 	if (sax->end_doc != NULL && !sax->end_doc(sd))
 6607              		.loc 1 1381 0
 6608 0410 2B69     		ldr	r3, [r5, #16]
 6609 0412 43B9     		cbnz	r3, .L1140
 6610              	.L1142:
1383:sxmlc/sxmlc.c **** 	if (sax->all_event != NULL)
 6611              		.loc 1 1383 0
 6612 0414 AD69     		ldr	r5, [r5, #24]
 6613              	.LVL772:
 6614 0416 55B1     		cbz	r5, .L1153
1384:sxmlc/sxmlc.c **** 		(void)sax->all_event(XML_EVENT_END_DOC, NULL, (SXML_CHAR*)sd->name, sd->line_num, sd);
 6615              		.loc 1 1384 0
 6616 0418 0094     		str	r4, [sp]
 6617 041a 0021     		movs	r1, #0
 6618 041c 94E80C00 		ldmia	r4, {r2, r3}
 6619 0420 0520     		movs	r0, #5
 6620 0422 A847     		blx	r5
 6621              	.LVL773:
 6622 0424 03E0     		b	.L1153
 6623              	.LVL774:
 6624              	.L1140:
1381:sxmlc/sxmlc.c **** 	if (sax->end_doc != NULL && !sax->end_doc(sd))
 6625              		.loc 1 1381 0 discriminator 1
 6626 0426 2046     		mov	r0, r4
 6627 0428 9847     		blx	r3
 6628              	.LVL775:
 6629 042a 0028     		cmp	r0, #0
 6630 042c F2D1     		bne	.L1142
 6631              	.LVL776:
 6632              	.L1153:
1382:sxmlc/sxmlc.c **** 		return ret;
 6633              		.loc 1 1382 0
 6634 042e 3046     		mov	r0, r6
 6635 0430 09E0     		b	.L1217
 6636              	.LVL777:
 6637              	.L1219:
1272:sxmlc/sxmlc.c **** 				if (sax->on_error != NULL && !sax->on_error(PARSE_ERR_UNEXPECTED_TAG_END, sd->line_num, sd))
 6638              		.loc 1 1272 0 discriminator 1
 6639 0432 6FF00100 		mvn	r0, #1
 6640 0436 6168     		ldr	r1, [r4, #4]
 6641 0438 2246     		mov	r2, r4
 6642 043a 9847     		blx	r3
 6643              	.LVL778:
 6644 043c 0028     		cmp	r0, #0
 6645 043e 7FF4D6AE 		bne	.L1088
 6646              	.LVL779:
 6647              	.L1101:
 6648              	.LBB24:
1345:sxmlc/sxmlc.c **** 					n0 = n1;
 6649              		.loc 1 1345 0
 6650 0442 0026     		movs	r6, #0
 6651 0444 DEE7     		b	.L1073
 6652              	.LVL780:
 6653              	.L1217:
 6654              	.LBE24:
1387:sxmlc/sxmlc.c **** }
 6655              		.loc 1 1387 0
 6656 0446 15B0     		add	sp, sp, #84
 6657              		@ sp needed
 6658 0448 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 6659              	.LVL781:
 6660              	.L1237:
 6661              		.align	2
 6662              	.L1236:
 6663 044c 00000000 		.word	_impure_ptr
 6664 0450 52010000 		.word	.LC15
 6665 0454 3C010000 		.word	.LC14
 6666 0458 DC000000 		.word	.LC12
 6667              		.cfi_endproc
 6668              	.LFE44:
 6670              		.section	.text.XMLDoc_parse_file_SAX,"ax",%progbits
 6671              		.align	1
 6672              		.global	XMLDoc_parse_file_SAX
 6673              		.thumb
 6674              		.thumb_func
 6676              	XMLDoc_parse_file_SAX:
 6677              	.LFB53:
1579:sxmlc/sxmlc.c **** {
 6678              		.loc 1 1579 0
 6679              		.cfi_startproc
 6680              		@ args = 0, pretend = 0, frame = 16
 6681              		@ frame_needed = 0, uses_anonymous_args = 0
 6682              	.LVL782:
 6683 0000 F0B5     		push	{r4, r5, r6, r7, lr}
 6684              		.cfi_def_cfa_offset 20
 6685              		.cfi_offset 4, -20
 6686              		.cfi_offset 5, -16
 6687              		.cfi_offset 6, -12
 6688              		.cfi_offset 7, -8
 6689              		.cfi_offset 14, -4
 6690 0002 0446     		mov	r4, r0
 6691 0004 85B0     		sub	sp, sp, #20
 6692              		.cfi_def_cfa_offset 40
1579:sxmlc/sxmlc.c **** {
 6693              		.loc 1 1579 0
 6694 0006 1746     		mov	r7, r2
1592:sxmlc/sxmlc.c **** 	if (sax == NULL || filename == NULL || filename[0] == NULC)
 6695              		.loc 1 1592 0
 6696 0008 0D46     		mov	r5, r1
 6697 000a 09B9     		cbnz	r1, .L1239
 6698              	.LVL783:
 6699              	.L1241:
1593:sxmlc/sxmlc.c **** 		return false;
 6700              		.loc 1 1593 0
 6701 000c 0020     		movs	r0, #0
 6702 000e 16E0     		b	.L1240
 6703              	.LVL784:
 6704              	.L1239:
1592:sxmlc/sxmlc.c **** 	if (sax == NULL || filename == NULL || filename[0] == NULC)
 6705              		.loc 1 1592 0 discriminator 1
 6706 0010 0028     		cmp	r0, #0
 6707 0012 FBD0     		beq	.L1241
 6708 0014 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 6709 0016 002B     		cmp	r3, #0
 6710 0018 F8D0     		beq	.L1241
1595:sxmlc/sxmlc.c **** 	f = sx_fopen(filename, fmode);
 6711              		.loc 1 1595 0
 6712 001a 0A49     		ldr	r1, .L1251
 6713              	.LVL785:
 6714 001c FFF7FEFF 		bl	fopen
 6715              	.LVL786:
1596:sxmlc/sxmlc.c **** 	if (f == NULL)
 6716              		.loc 1 1596 0
 6717 0020 0646     		mov	r6, r0
 6718 0022 0028     		cmp	r0, #0
 6719 0024 F2D0     		beq	.L1241
1622:sxmlc/sxmlc.c **** 	ret = _parse_data_SAX((void*)f, DATA_SOURCE_FILE, sax, &sd);
 6720              		.loc 1 1622 0
 6721 0026 0021     		movs	r1, #0
 6722 0028 2A46     		mov	r2, r5
 6723 002a 01AB     		add	r3, sp, #4
1606:sxmlc/sxmlc.c **** 	sd.name = (SXML_CHAR*)filename;
 6724              		.loc 1 1606 0
 6725 002c 0194     		str	r4, [sp, #4]
1607:sxmlc/sxmlc.c **** 	sd.user = user;
 6726              		.loc 1 1607 0
 6727 002e 0397     		str	r7, [sp, #12]
1622:sxmlc/sxmlc.c **** 	ret = _parse_data_SAX((void*)f, DATA_SOURCE_FILE, sax, &sd);
 6728              		.loc 1 1622 0
 6729 0030 FFF7FEFF 		bl	_parse_data_SAX
 6730              	.LVL787:
 6731 0034 0446     		mov	r4, r0
 6732              	.LVL788:
1623:sxmlc/sxmlc.c **** 	(void)fclose(f);
 6733              		.loc 1 1623 0
 6734 0036 3046     		mov	r0, r6
 6735              	.LVL789:
 6736 0038 FFF7FEFF 		bl	fclose
 6737              	.LVL790:
1625:sxmlc/sxmlc.c **** 	return ret;
 6738              		.loc 1 1625 0
 6739 003c 2046     		mov	r0, r4
 6740              	.LVL791:
 6741              	.L1240:
1626:sxmlc/sxmlc.c **** }
 6742              		.loc 1 1626 0
 6743 003e 05B0     		add	sp, sp, #20
 6744              		@ sp needed
 6745 0040 F0BD     		pop	{r4, r5, r6, r7, pc}
 6746              	.LVL792:
 6747              	.L1252:
 6748 0042 00BF     		.align	2
 6749              	.L1251:
 6750 0044 67010000 		.word	.LC16
 6751              		.cfi_endproc
 6752              	.LFE53:
 6754              		.section	.text.XMLDoc_parse_file_DOM_text_as_nodes,"ax",%progbits
 6755              		.align	1
 6756              		.global	XMLDoc_parse_file_DOM_text_as_nodes
 6757              		.thumb
 6758              		.thumb_func
 6760              	XMLDoc_parse_file_DOM_text_as_nodes:
 6761              	.LFB55:
1642:sxmlc/sxmlc.c **** {
 6762              		.loc 1 1642 0
 6763              		.cfi_startproc
 6764              		@ args = 0, pretend = 0, frame = 48
 6765              		@ frame_needed = 0, uses_anonymous_args = 0
 6766              	.LVL793:
 6767 0000 70B5     		push	{r4, r5, r6, lr}
 6768              		.cfi_def_cfa_offset 16
 6769              		.cfi_offset 4, -16
 6770              		.cfi_offset 5, -12
 6771              		.cfi_offset 6, -8
 6772              		.cfi_offset 14, -4
 6773 0002 0546     		mov	r5, r0
 6774 0004 8CB0     		sub	sp, sp, #48
 6775              		.cfi_def_cfa_offset 64
1642:sxmlc/sxmlc.c **** {
 6776              		.loc 1 1642 0
 6777 0006 1646     		mov	r6, r2
1646:sxmlc/sxmlc.c **** 	if (doc == NULL || filename == NULL || filename[0] == NULC || doc->init_value != XML_INIT_DONE)
 6778              		.loc 1 1646 0
 6779 0008 0C46     		mov	r4, r1
 6780 000a 01B3     		cbz	r1, .L1255
1646:sxmlc/sxmlc.c **** 	if (doc == NULL || filename == NULL || filename[0] == NULC || doc->init_value != XML_INIT_DONE)
 6781              		.loc 1 1646 0 is_stmt 0 discriminator 1
 6782 000c 30B3     		cbz	r0, .L1254
 6783 000e 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 6784 0010 FBB1     		cbz	r3, .L1257
 6785 0012 D1F80C31 		ldr	r3, [r1, #268]
 6786 0016 134A     		ldr	r2, .L1260
 6787              	.LVL794:
 6788 0018 9342     		cmp	r3, r2
 6789 001a 1CD1     		bne	.L1258
1649:sxmlc/sxmlc.c **** 	sx_strncpy(doc->filename, filename, SXMLC_MAX_PATH - 1);
 6790              		.loc 1 1649 0 is_stmt 1
 6791 001c FF22     		movs	r2, #255
 6792 001e 0846     		mov	r0, r1
 6793              	.LVL795:
 6794 0020 2946     		mov	r1, r5
 6795              	.LVL796:
 6796 0022 FFF7FEFF 		bl	strncpy
 6797              	.LVL797:
1650:sxmlc/sxmlc.c **** 	doc->filename[SXMLC_MAX_PATH - 1] = NULC;
 6798              		.loc 1 1650 0
 6799 0026 0023     		movs	r3, #0
 6800 0028 84F8FF30 		strb	r3, [r4, #255]
1670:sxmlc/sxmlc.c **** 	SAX_Callbacks_init_DOM(&sax);
 6801              		.loc 1 1670 0
 6802 002c 05A8     		add	r0, sp, #20
1668:sxmlc/sxmlc.c **** 	dom.current = NULL;
 6803              		.loc 1 1668 0
 6804 002e 0193     		str	r3, [sp, #4]
1667:sxmlc/sxmlc.c **** 	dom.doc = doc;
 6805              		.loc 1 1667 0
 6806 0030 0094     		str	r4, [sp]
1669:sxmlc/sxmlc.c **** 	dom.text_as_nodes = text_as_nodes;
 6807              		.loc 1 1669 0
 6808 0032 0496     		str	r6, [sp, #16]
1670:sxmlc/sxmlc.c **** 	SAX_Callbacks_init_DOM(&sax);
 6809              		.loc 1 1670 0
 6810 0034 FFF7FEFF 		bl	SAX_Callbacks_init_DOM
 6811              	.LVL798:
1672:sxmlc/sxmlc.c **** 	if (!XMLDoc_parse_file_SAX(filename, &sax, &dom)) {
 6812              		.loc 1 1672 0
 6813 0038 2846     		mov	r0, r5
 6814 003a 05A9     		add	r1, sp, #20
 6815 003c 6A46     		mov	r2, sp
 6816 003e FFF7FEFF 		bl	XMLDoc_parse_file_SAX
 6817              	.LVL799:
 6818 0042 0546     		mov	r5, r0
 6819              	.LVL800:
 6820 0044 48B9     		cbnz	r0, .L1259
1673:sxmlc/sxmlc.c **** 		(void)XMLDoc_free(doc);
 6821              		.loc 1 1673 0
 6822 0046 2046     		mov	r0, r4
 6823 0048 FFF7FEFF 		bl	XMLDoc_free
 6824              	.LVL801:
1675:sxmlc/sxmlc.c **** 		return false;
 6825              		.loc 1 1675 0
 6826 004c 06E0     		b	.L1254
 6827              	.LVL802:
 6828              	.L1255:
1647:sxmlc/sxmlc.c **** 		return false;
 6829              		.loc 1 1647 0
 6830 004e 0D46     		mov	r5, r1
 6831 0050 04E0     		b	.L1254
 6832              	.L1257:
 6833 0052 1D46     		mov	r5, r3
 6834 0054 02E0     		b	.L1254
 6835              	.LVL803:
 6836              	.L1258:
 6837 0056 0025     		movs	r5, #0
 6838 0058 00E0     		b	.L1254
 6839              	.LVL804:
 6840              	.L1259:
1678:sxmlc/sxmlc.c **** 	return true;
 6841              		.loc 1 1678 0
 6842 005a 0125     		movs	r5, #1
 6843              	.L1254:
1679:sxmlc/sxmlc.c **** }
 6844              		.loc 1 1679 0
 6845 005c 2846     		mov	r0, r5
 6846 005e 0CB0     		add	sp, sp, #48
 6847              		@ sp needed
 6848 0060 70BD     		pop	{r4, r5, r6, pc}
 6849              	.LVL805:
 6850              	.L1261:
 6851 0062 00BF     		.align	2
 6852              	.L1260:
 6853 0064 22057719 		.word	427230498
 6854              		.cfi_endproc
 6855              	.LFE55:
 6857              		.section	.text.XMLDoc_parse_buffer_SAX,"ax",%progbits
 6858              		.align	1
 6859              		.global	XMLDoc_parse_buffer_SAX
 6860              		.thumb
 6861              		.thumb_func
 6863              	XMLDoc_parse_buffer_SAX:
 6864              	.LFB54:
1629:sxmlc/sxmlc.c **** {
 6865              		.loc 1 1629 0
 6866              		.cfi_startproc
 6867              		@ args = 0, pretend = 0, frame = 24
 6868              		@ frame_needed = 0, uses_anonymous_args = 0
 6869              	.LVL806:
 6870 0000 10B5     		push	{r4, lr}
 6871              		.cfi_def_cfa_offset 8
 6872              		.cfi_offset 4, -8
 6873              		.cfi_offset 14, -4
1630:sxmlc/sxmlc.c **** 	DataSourceBuffer dsb = { buffer, 0 };
 6874              		.loc 1 1630 0
 6875 0002 0024     		movs	r4, #0
1629:sxmlc/sxmlc.c **** {
 6876              		.loc 1 1629 0
 6877 0004 86B0     		sub	sp, sp, #24
 6878              		.cfi_def_cfa_offset 32
1630:sxmlc/sxmlc.c **** 	DataSourceBuffer dsb = { buffer, 0 };
 6879              		.loc 1 1630 0
 6880 0006 0190     		str	r0, [sp, #4]
 6881 0008 0294     		str	r4, [sp, #8]
1633:sxmlc/sxmlc.c **** 	if (sax == NULL || buffer == NULL)
 6882              		.loc 1 1633 0
 6883 000a 42B1     		cbz	r2, .L1264
1633:sxmlc/sxmlc.c **** 	if (sax == NULL || buffer == NULL)
 6884              		.loc 1 1633 0 is_stmt 0 discriminator 1
 6885 000c 40B1     		cbz	r0, .L1263
1636:sxmlc/sxmlc.c **** 	sd.name = name;
 6886              		.loc 1 1636 0 is_stmt 1
 6887 000e 0391     		str	r1, [sp, #12]
1637:sxmlc/sxmlc.c **** 	sd.user = user;
 6888              		.loc 1 1637 0
 6889 0010 0593     		str	r3, [sp, #20]
1638:sxmlc/sxmlc.c **** 	return _parse_data_SAX((void*)&dsb, DATA_SOURCE_BUFFER, sax, &sd);
 6890              		.loc 1 1638 0
 6891 0012 01A8     		add	r0, sp, #4
 6892              	.LVL807:
 6893 0014 0121     		movs	r1, #1
 6894              	.LVL808:
 6895 0016 03AB     		add	r3, sp, #12
 6896              	.LVL809:
 6897 0018 FFF7FEFF 		bl	_parse_data_SAX
 6898              	.LVL810:
 6899 001c 00E0     		b	.L1263
 6900              	.LVL811:
 6901              	.L1264:
1634:sxmlc/sxmlc.c **** 		return false;
 6902              		.loc 1 1634 0
 6903 001e 1046     		mov	r0, r2
 6904              	.LVL812:
 6905              	.L1263:
1639:sxmlc/sxmlc.c **** }
 6906              		.loc 1 1639 0
 6907 0020 06B0     		add	sp, sp, #24
 6908              		@ sp needed
 6909 0022 10BD     		pop	{r4, pc}
 6910              		.cfi_endproc
 6911              	.LFE54:
 6913              		.section	.text.XMLDoc_parse_buffer_DOM_text_as_nodes,"ax",%progbits
 6914              		.align	1
 6915              		.global	XMLDoc_parse_buffer_DOM_text_as_nodes
 6916              		.thumb
 6917              		.thumb_func
 6919              	XMLDoc_parse_buffer_DOM_text_as_nodes:
 6920              	.LFB56:
1682:sxmlc/sxmlc.c **** {
 6921              		.loc 1 1682 0
 6922              		.cfi_startproc
 6923              		@ args = 0, pretend = 0, frame = 48
 6924              		@ frame_needed = 0, uses_anonymous_args = 0
 6925              	.LVL813:
 6926 0000 70B5     		push	{r4, r5, r6, lr}
 6927              		.cfi_def_cfa_offset 16
 6928              		.cfi_offset 4, -16
 6929              		.cfi_offset 5, -12
 6930              		.cfi_offset 6, -8
 6931              		.cfi_offset 14, -4
 6932 0002 0546     		mov	r5, r0
 6933 0004 8CB0     		sub	sp, sp, #48
 6934              		.cfi_def_cfa_offset 64
1682:sxmlc/sxmlc.c **** {
 6935              		.loc 1 1682 0
 6936 0006 0E46     		mov	r6, r1
1686:sxmlc/sxmlc.c **** 	if (doc == NULL || buffer == NULL || doc->init_value != XML_INIT_DONE)
 6937              		.loc 1 1686 0
 6938 0008 1446     		mov	r4, r2
 6939 000a BAB1     		cbz	r2, .L1268
1686:sxmlc/sxmlc.c **** 	if (doc == NULL || buffer == NULL || doc->init_value != XML_INIT_DONE)
 6940              		.loc 1 1686 0 is_stmt 0 discriminator 1
 6941 000c C0B1     		cbz	r0, .L1269
 6942 000e D2F80C21 		ldr	r2, [r2, #268]
 6943              	.LVL814:
 6944 0012 0D49     		ldr	r1, .L1272
 6945              	.LVL815:
 6946 0014 0020     		movs	r0, #0
 6947              	.LVL816:
 6948 0016 8A42     		cmp	r2, r1
 6949 0018 14D1     		bne	.L1267
1690:sxmlc/sxmlc.c **** 	dom.current = NULL;
 6950              		.loc 1 1690 0 is_stmt 1
 6951 001a 0190     		str	r0, [sp, #4]
1692:sxmlc/sxmlc.c **** 	SAX_Callbacks_init_DOM(&sax);
 6952              		.loc 1 1692 0
 6953 001c 05A8     		add	r0, sp, #20
1691:sxmlc/sxmlc.c **** 	dom.text_as_nodes = text_as_nodes;
 6954              		.loc 1 1691 0
 6955 001e 0493     		str	r3, [sp, #16]
1689:sxmlc/sxmlc.c **** 	dom.doc = doc;
 6956              		.loc 1 1689 0
 6957 0020 0094     		str	r4, [sp]
1692:sxmlc/sxmlc.c **** 	SAX_Callbacks_init_DOM(&sax);
 6958              		.loc 1 1692 0
 6959 0022 FFF7FEFF 		bl	SAX_Callbacks_init_DOM
 6960              	.LVL817:
1694:sxmlc/sxmlc.c **** 	return XMLDoc_parse_buffer_SAX(buffer, name, &sax, &dom) ? true : XMLDoc_free(doc);
 6961              		.loc 1 1694 0
 6962 0026 2846     		mov	r0, r5
 6963 0028 3146     		mov	r1, r6
 6964 002a 05AA     		add	r2, sp, #20
 6965 002c 6B46     		mov	r3, sp
 6966 002e FFF7FEFF 		bl	XMLDoc_parse_buffer_SAX
 6967              	.LVL818:
 6968 0032 30B9     		cbnz	r0, .L1271
1694:sxmlc/sxmlc.c **** 	return XMLDoc_parse_buffer_SAX(buffer, name, &sax, &dom) ? true : XMLDoc_free(doc);
 6969              		.loc 1 1694 0 is_stmt 0 discriminator 1
 6970 0034 2046     		mov	r0, r4
 6971 0036 FFF7FEFF 		bl	XMLDoc_free
 6972              	.LVL819:
 6973 003a 03E0     		b	.L1267
 6974              	.LVL820:
 6975              	.L1268:
1687:sxmlc/sxmlc.c **** 		return false;
 6976              		.loc 1 1687 0 is_stmt 1
 6977 003c 1046     		mov	r0, r2
 6978              	.LVL821:
 6979 003e 01E0     		b	.L1267
 6980              	.LVL822:
 6981              	.L1269:
 6982 0040 00E0     		b	.L1267
 6983              	.LVL823:
 6984              	.L1271:
1694:sxmlc/sxmlc.c **** 	return XMLDoc_parse_buffer_SAX(buffer, name, &sax, &dom) ? true : XMLDoc_free(doc);
 6985              		.loc 1 1694 0
 6986 0042 0120     		movs	r0, #1
 6987              	.L1267:
1695:sxmlc/sxmlc.c **** }
 6988              		.loc 1 1695 0
 6989 0044 0CB0     		add	sp, sp, #48
 6990              		@ sp needed
 6991 0046 70BD     		pop	{r4, r5, r6, pc}
 6992              	.LVL824:
 6993              	.L1273:
 6994              		.align	2
 6995              	.L1272:
 6996 0048 22057719 		.word	427230498
 6997              		.cfi_endproc
 6998              	.LFE56:
 7000              		.section	.text.strlen_html,"ax",%progbits
 7001              		.align	1
 7002              		.global	strlen_html
 7003              		.thumb
 7004              		.thumb_func
 7006              	strlen_html:
 7007              	.LFB67:
2165:sxmlc/sxmlc.c **** }
2166:sxmlc/sxmlc.c **** 
2167:sxmlc/sxmlc.c **** /* TODO: Allocate 'html'? */
2168:sxmlc/sxmlc.c **** SXML_CHAR* str2html(SXML_CHAR* str, SXML_CHAR* html)
2169:sxmlc/sxmlc.c **** {
2170:sxmlc/sxmlc.c **** 	SXML_CHAR *ps, *pd;
2171:sxmlc/sxmlc.c **** 	int i;
2172:sxmlc/sxmlc.c **** 
2173:sxmlc/sxmlc.c **** 	if (str == NULL)
2174:sxmlc/sxmlc.c **** 		return NULL;
2175:sxmlc/sxmlc.c **** 
2176:sxmlc/sxmlc.c **** 	if (html == str) /* Not handled (yet) */
2177:sxmlc/sxmlc.c **** 		return NULL;
2178:sxmlc/sxmlc.c **** 
2179:sxmlc/sxmlc.c **** 	if (html == NULL) { /* Allocate 'html' to the correct size */
2180:sxmlc/sxmlc.c **** 		html = __malloc(strlen_html(str) * sizeof(SXML_CHAR));
2181:sxmlc/sxmlc.c **** 		if (html == NULL)
2182:sxmlc/sxmlc.c **** 			return NULL;
2183:sxmlc/sxmlc.c **** 	}
2184:sxmlc/sxmlc.c **** 
2185:sxmlc/sxmlc.c **** 	for (ps = str, pd = html; *ps; ps++, pd++) {
2186:sxmlc/sxmlc.c **** 		for (i = 0; HTML_SPECIAL_DICT[i].chr; i++) {
2187:sxmlc/sxmlc.c **** 			if (*ps == HTML_SPECIAL_DICT[i].chr) {
2188:sxmlc/sxmlc.c **** 				sx_strcpy(pd, HTML_SPECIAL_DICT[i].html);
2189:sxmlc/sxmlc.c **** 				pd += HTML_SPECIAL_DICT[i].html_len - 1;
2190:sxmlc/sxmlc.c **** 				break;
2191:sxmlc/sxmlc.c **** 			}
2192:sxmlc/sxmlc.c **** 		}
2193:sxmlc/sxmlc.c **** 		if (HTML_SPECIAL_DICT[i].chr == NULC && pd != ps)
2194:sxmlc/sxmlc.c **** 			*pd = *ps;
2195:sxmlc/sxmlc.c **** 	}
2196:sxmlc/sxmlc.c **** 	*pd = NULC;
2197:sxmlc/sxmlc.c **** 
2198:sxmlc/sxmlc.c **** 	return html;
2199:sxmlc/sxmlc.c **** }
2200:sxmlc/sxmlc.c **** 
2201:sxmlc/sxmlc.c **** int strlen_html(SXML_CHAR* str)
2202:sxmlc/sxmlc.c **** {
 7008              		.loc 1 2202 0
 7009              		.cfi_startproc
 7010              		@ args = 0, pretend = 0, frame = 0
 7011              		@ frame_needed = 0, uses_anonymous_args = 0
 7012              	.LVL825:
 7013 0000 70B5     		push	{r4, r5, r6, lr}
 7014              		.cfi_def_cfa_offset 16
 7015              		.cfi_offset 4, -16
 7016              		.cfi_offset 5, -12
 7017              		.cfi_offset 6, -8
 7018              		.cfi_offset 14, -4
2203:sxmlc/sxmlc.c **** 	int i, j, n;
2204:sxmlc/sxmlc.c **** 	
2205:sxmlc/sxmlc.c **** 	if (str == NULL)
 7019              		.loc 1 2205 0
 7020 0002 A0B1     		cbz	r0, .L1285
 7021 0004 421E     		subs	r2, r0, #1
 7022 0006 0020     		movs	r0, #0
 7023              	.LVL826:
 7024              	.L1276:
2206:sxmlc/sxmlc.c **** 		return 0;
2207:sxmlc/sxmlc.c **** 
2208:sxmlc/sxmlc.c **** 	n = 0;
2209:sxmlc/sxmlc.c **** 	for (i = 0; str[i] != NULC; i++) {
 7025              		.loc 1 2209 0 discriminator 1
 7026 0008 12F8011F 		ldrb	r1, [r2, #1]!	@ zero_extendqisi2
 7027              	.LVL827:
 7028 000c 79B1     		cbz	r1, .L1285
 7029              		.loc 1 2209 0 is_stmt 0
 7030 000e 0023     		movs	r3, #0
 7031              	.L1281:
 7032              	.LVL828:
 7033 0010 0C26     		movs	r6, #12
 7034 0012 5E43     		muls	r6, r3, r6
2210:sxmlc/sxmlc.c **** 		for (j = 0; HTML_SPECIAL_DICT[j].chr; j++) {
 7035              		.loc 1 2210 0 is_stmt 1 discriminator 1
 7036 0014 064D     		ldr	r5, .L1287
 7037 0016 745D     		ldrb	r4, [r6, r5]	@ zero_extendqisi2
 7038 0018 3CB1     		cbz	r4, .L1286
2211:sxmlc/sxmlc.c **** 			if (str[i] == HTML_SPECIAL_DICT[j].chr) {
 7039              		.loc 1 2211 0
 7040 001a A142     		cmp	r1, r4
 7041 001c 03D1     		bne	.L1277
2212:sxmlc/sxmlc.c **** 				n += HTML_SPECIAL_DICT[j].html_len;
 7042              		.loc 1 2212 0
 7043 001e 3544     		add	r5, r5, r6
 7044 0020 AB68     		ldr	r3, [r5, #8]
 7045              	.LVL829:
 7046 0022 1844     		add	r0, r0, r3
 7047              	.LVL830:
 7048 0024 F0E7     		b	.L1276
 7049              	.LVL831:
 7050              	.L1277:
2210:sxmlc/sxmlc.c **** 		for (j = 0; HTML_SPECIAL_DICT[j].chr; j++) {
 7051              		.loc 1 2210 0
 7052 0026 0133     		adds	r3, r3, #1
 7053              	.LVL832:
 7054 0028 F2E7     		b	.L1281
 7055              	.L1286:
2213:sxmlc/sxmlc.c **** 				break;
2214:sxmlc/sxmlc.c **** 			}
2215:sxmlc/sxmlc.c **** 		}
2216:sxmlc/sxmlc.c **** 		if (HTML_SPECIAL_DICT[j].chr == NULC)
2217:sxmlc/sxmlc.c **** 			n++;
 7056              		.loc 1 2217 0
 7057 002a 0130     		adds	r0, r0, #1
 7058              	.LVL833:
 7059 002c ECE7     		b	.L1276
 7060              	.LVL834:
 7061              	.L1285:
2218:sxmlc/sxmlc.c **** 	}
2219:sxmlc/sxmlc.c **** 
2220:sxmlc/sxmlc.c **** 	return n;
2221:sxmlc/sxmlc.c **** }
 7062              		.loc 1 2221 0
 7063 002e 70BD     		pop	{r4, r5, r6, pc}
 7064              	.L1288:
 7065              		.align	2
 7066              	.L1287:
 7067 0030 00000000 		.word	.LANCHOR2
 7068              		.cfi_endproc
 7069              	.LFE67:
 7071              		.section	.text.str2html,"ax",%progbits
 7072              		.align	1
 7073              		.global	str2html
 7074              		.thumb
 7075              		.thumb_func
 7077              	str2html:
 7078              	.LFB66:
2169:sxmlc/sxmlc.c **** {
 7079              		.loc 1 2169 0
 7080              		.cfi_startproc
 7081              		@ args = 0, pretend = 0, frame = 0
 7082              		@ frame_needed = 0, uses_anonymous_args = 0
 7083              	.LVL835:
 7084 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 7085              		.cfi_def_cfa_offset 24
 7086              		.cfi_offset 3, -24
 7087              		.cfi_offset 4, -20
 7088              		.cfi_offset 5, -16
 7089              		.cfi_offset 6, -12
 7090              		.cfi_offset 7, -8
 7091              		.cfi_offset 14, -4
2169:sxmlc/sxmlc.c **** {
 7092              		.loc 1 2169 0
 7093 0002 0C46     		mov	r4, r1
2173:sxmlc/sxmlc.c **** 	if (str == NULL)
 7094              		.loc 1 2173 0
 7095 0004 0546     		mov	r5, r0
 7096 0006 08B9     		cbnz	r0, .L1290
 7097              	.LVL836:
 7098              	.L1292:
2174:sxmlc/sxmlc.c **** 		return NULL;
 7099              		.loc 1 2174 0
 7100 0008 0020     		movs	r0, #0
 7101 000a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 7102              	.LVL837:
 7103              	.L1290:
2176:sxmlc/sxmlc.c **** 	if (html == str) /* Not handled (yet) */
 7104              		.loc 1 2176 0
 7105 000c 8142     		cmp	r1, r0
 7106 000e FBD0     		beq	.L1292
2179:sxmlc/sxmlc.c **** 	if (html == NULL) { /* Allocate 'html' to the correct size */
 7107              		.loc 1 2179 0
 7108 0010 31B9     		cbnz	r1, .L1293
2180:sxmlc/sxmlc.c **** 		html = __malloc(strlen_html(str) * sizeof(SXML_CHAR));
 7109              		.loc 1 2180 0
 7110 0012 FFF7FEFF 		bl	strlen_html
 7111              	.LVL838:
 7112 0016 FFF7FEFF 		bl	malloc
 7113              	.LVL839:
2181:sxmlc/sxmlc.c **** 		if (html == NULL)
 7114              		.loc 1 2181 0
 7115 001a 0446     		mov	r4, r0
 7116 001c 0028     		cmp	r0, #0
 7117 001e F3D0     		beq	.L1292
 7118              	.LVL840:
 7119              	.L1293:
2185:sxmlc/sxmlc.c **** 	for (ps = str, pd = html; *ps; ps++, pd++) {
 7120              		.loc 1 2185 0
 7121 0020 2346     		mov	r3, r4
 7122              	.LVL841:
 7123              	.L1294:
 7124 0022 AC46     		mov	ip, r5
 7125              	.LVL842:
2185:sxmlc/sxmlc.c **** 	for (ps = str, pd = html; *ps; ps++, pd++) {
 7126              		.loc 1 2185 0 is_stmt 0 discriminator 1
 7127 0024 15F8012B 		ldrb	r2, [r5], #1	@ zero_extendqisi2
 7128 0028 C2B1     		cbz	r2, .L1299
2185:sxmlc/sxmlc.c **** 	for (ps = str, pd = html; *ps; ps++, pd++) {
 7129              		.loc 1 2185 0
 7130 002a 0021     		movs	r1, #0
 7131              	.L1300:
 7132              	.LVL843:
 7133 002c 0C26     		movs	r6, #12
 7134 002e 4E43     		muls	r6, r1, r6
2186:sxmlc/sxmlc.c **** 		for (i = 0; HTML_SPECIAL_DICT[i].chr; i++) {
 7135              		.loc 1 2186 0 is_stmt 1 discriminator 1
 7136 0030 0C4F     		ldr	r7, .L1308
 7137 0032 F05D     		ldrb	r0, [r6, r7]	@ zero_extendqisi2
 7138 0034 68B1     		cbz	r0, .L1307
2187:sxmlc/sxmlc.c **** 			if (*ps == HTML_SPECIAL_DICT[i].chr) {
 7139              		.loc 1 2187 0
 7140 0036 8242     		cmp	r2, r0
 7141 0038 09D1     		bne	.L1295
2188:sxmlc/sxmlc.c **** 				sx_strcpy(pd, HTML_SPECIAL_DICT[i].html);
 7142              		.loc 1 2188 0
 7143 003a 3E44     		add	r6, r6, r7
 7144 003c 1846     		mov	r0, r3
 7145 003e 7168     		ldr	r1, [r6, #4]
 7146              	.LVL844:
 7147 0040 FFF7FEFF 		bl	strcpy
 7148              	.LVL845:
2189:sxmlc/sxmlc.c **** 				pd += HTML_SPECIAL_DICT[i].html_len - 1;
 7149              		.loc 1 2189 0
 7150 0044 B268     		ldr	r2, [r6, #8]
2188:sxmlc/sxmlc.c **** 				sx_strcpy(pd, HTML_SPECIAL_DICT[i].html);
 7151              		.loc 1 2188 0
 7152 0046 0346     		mov	r3, r0
2189:sxmlc/sxmlc.c **** 				pd += HTML_SPECIAL_DICT[i].html_len - 1;
 7153              		.loc 1 2189 0
 7154 0048 013A     		subs	r2, r2, #1
 7155 004a 1344     		add	r3, r3, r2
 7156              	.LVL846:
 7157 004c 04E0     		b	.L1296
 7158              	.LVL847:
 7159              	.L1295:
2186:sxmlc/sxmlc.c **** 		for (i = 0; HTML_SPECIAL_DICT[i].chr; i++) {
 7160              		.loc 1 2186 0
 7161 004e 0131     		adds	r1, r1, #1
 7162              	.LVL848:
 7163 0050 ECE7     		b	.L1300
 7164              	.L1307:
2193:sxmlc/sxmlc.c **** 		if (HTML_SPECIAL_DICT[i].chr == NULC && pd != ps)
 7165              		.loc 1 2193 0
 7166 0052 6345     		cmp	r3, ip
 7167 0054 00D0     		beq	.L1296
2194:sxmlc/sxmlc.c **** 			*pd = *ps;
 7168              		.loc 1 2194 0
 7169 0056 1A70     		strb	r2, [r3]
 7170              	.LVL849:
 7171              	.L1296:
2185:sxmlc/sxmlc.c **** 	for (ps = str, pd = html; *ps; ps++, pd++) {
 7172              		.loc 1 2185 0
 7173 0058 0133     		adds	r3, r3, #1
 7174              	.LVL850:
 7175 005a E2E7     		b	.L1294
 7176              	.LVL851:
 7177              	.L1299:
2196:sxmlc/sxmlc.c **** 	*pd = NULC;
 7178              		.loc 1 2196 0
 7179 005c 1A70     		strb	r2, [r3]
2198:sxmlc/sxmlc.c **** 	return html;
 7180              		.loc 1 2198 0
 7181 005e 2046     		mov	r0, r4
 7182 0060 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 7183              	.LVL852:
 7184              	.L1309:
 7185 0062 00BF     		.align	2
 7186              	.L1308:
 7187 0064 00000000 		.word	.LANCHOR2
 7188              		.cfi_endproc
 7189              	.LFE66:
 7191              		.section	.text.fprintHTML,"ax",%progbits
 7192              		.align	1
 7193              		.global	fprintHTML
 7194              		.thumb
 7195              		.thumb_func
 7197              	fprintHTML:
 7198              	.LFB68:
2222:sxmlc/sxmlc.c **** 
2223:sxmlc/sxmlc.c **** int fprintHTML(FILE* f, SXML_CHAR* str)
2224:sxmlc/sxmlc.c **** {
 7199              		.loc 1 2224 0
 7200              		.cfi_startproc
 7201              		@ args = 0, pretend = 0, frame = 0
 7202              		@ frame_needed = 0, uses_anonymous_args = 0
 7203              	.LVL853:
 7204 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 7205              		.cfi_def_cfa_offset 24
 7206              		.cfi_offset 3, -24
 7207              		.cfi_offset 4, -20
 7208              		.cfi_offset 5, -16
 7209              		.cfi_offset 6, -12
 7210              		.cfi_offset 7, -8
 7211              		.cfi_offset 14, -4
 7212              		.loc 1 2224 0
 7213 0002 0546     		mov	r5, r0
 7214 0004 4E1E     		subs	r6, r1, #1
2225:sxmlc/sxmlc.c **** 	SXML_CHAR* p;
2226:sxmlc/sxmlc.c **** 	int i, n;
2227:sxmlc/sxmlc.c **** 	
2228:sxmlc/sxmlc.c **** 	for (p = str, n = 0; *p != NULC; p++) {
 7215              		.loc 1 2228 0
 7216 0006 0024     		movs	r4, #0
 7217              	.LVL854:
 7218              	.L1311:
 7219              		.loc 1 2228 0 is_stmt 0 discriminator 1
 7220 0008 16F8013F 		ldrb	r3, [r6, #1]!	@ zero_extendqisi2
 7221              	.LVL855:
 7222 000c BBB1     		cbz	r3, .L1320
 7223              		.loc 1 2228 0
 7224 000e 0022     		movs	r2, #0
 7225              	.L1313:
 7226              	.LVL856:
 7227 0010 0C27     		movs	r7, #12
 7228 0012 5743     		muls	r7, r2, r7
2229:sxmlc/sxmlc.c **** 		for (i = 0; HTML_SPECIAL_DICT[i].chr; i++) {
 7229              		.loc 1 2229 0 is_stmt 1 discriminator 1
 7230 0014 0B48     		ldr	r0, .L1322
 7231 0016 395C     		ldrb	r1, [r7, r0]	@ zero_extendqisi2
 7232 0018 59B1     		cbz	r1, .L1321
2230:sxmlc/sxmlc.c **** 			if (*p != HTML_SPECIAL_DICT[i].chr)
 7233              		.loc 1 2230 0
 7234 001a 8B42     		cmp	r3, r1
 7235 001c 01D0     		beq	.L1312
2229:sxmlc/sxmlc.c **** 		for (i = 0; HTML_SPECIAL_DICT[i].chr; i++) {
 7236              		.loc 1 2229 0
 7237 001e 0132     		adds	r2, r2, #1
 7238              	.LVL857:
 7239 0020 F6E7     		b	.L1313
 7240              	.L1312:
2231:sxmlc/sxmlc.c **** 				continue;
2232:sxmlc/sxmlc.c **** 			sx_fprintf(f, HTML_SPECIAL_DICT[i].html);
 7241              		.loc 1 2232 0
 7242 0022 0744     		add	r7, r7, r0
 7243 0024 7968     		ldr	r1, [r7, #4]
 7244 0026 2846     		mov	r0, r5
 7245 0028 FFF7FEFF 		bl	fprintf
 7246              	.LVL858:
2233:sxmlc/sxmlc.c **** 			n += HTML_SPECIAL_DICT[i].html_len;
 7247              		.loc 1 2233 0
 7248 002c BB68     		ldr	r3, [r7, #8]
 7249 002e 1C44     		add	r4, r4, r3
 7250              	.LVL859:
 7251 0030 EAE7     		b	.L1311
 7252              	.LVL860:
 7253              	.L1321:
2234:sxmlc/sxmlc.c **** 			break;
2235:sxmlc/sxmlc.c **** 		}
2236:sxmlc/sxmlc.c **** 		if (HTML_SPECIAL_DICT[i].chr == NULC) {
2237:sxmlc/sxmlc.c **** 			(void)sx_fputc(*p, f);
 7254              		.loc 1 2237 0
 7255 0032 1846     		mov	r0, r3
 7256 0034 2946     		mov	r1, r5
 7257 0036 FFF7FEFF 		bl	fputc
 7258              	.LVL861:
2238:sxmlc/sxmlc.c **** 			n++;
 7259              		.loc 1 2238 0
 7260 003a 0134     		adds	r4, r4, #1
 7261              	.LVL862:
 7262 003c E4E7     		b	.L1311
 7263              	.LVL863:
 7264              	.L1320:
2239:sxmlc/sxmlc.c **** 		}
2240:sxmlc/sxmlc.c **** 	}
2241:sxmlc/sxmlc.c **** 	
2242:sxmlc/sxmlc.c **** 	return n;
2243:sxmlc/sxmlc.c **** }
 7265              		.loc 1 2243 0
 7266 003e 2046     		mov	r0, r4
 7267 0040 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 7268              	.LVL864:
 7269              	.L1323:
 7270 0042 00BF     		.align	2
 7271              	.L1322:
 7272 0044 00000000 		.word	.LANCHOR2
 7273              		.cfi_endproc
 7274              	.LFE68:
 7276              		.section	.text._XMLNode_print_header,"ax",%progbits
 7277              		.align	1
 7278              		.thumb
 7279              		.thumb_func
 7281              	_XMLNode_print_header:
 7282              	.LFB36:
 857:sxmlc/sxmlc.c **** {
 7283              		.loc 1 857 0
 7284              		.cfi_startproc
 7285              		@ args = 16, pretend = 0, frame = 8
 7286              		@ frame_needed = 0, uses_anonymous_args = 0
 7287              	.LVL865:
 7288 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7289              		.cfi_def_cfa_offset 36
 7290              		.cfi_offset 4, -36
 7291              		.cfi_offset 5, -32
 7292              		.cfi_offset 6, -28
 7293              		.cfi_offset 7, -24
 7294              		.cfi_offset 8, -20
 7295              		.cfi_offset 9, -16
 7296              		.cfi_offset 10, -12
 7297              		.cfi_offset 11, -8
 7298              		.cfi_offset 14, -4
 7299 0004 85B0     		sub	sp, sp, #20
 7300              		.cfi_def_cfa_offset 56
 857:sxmlc/sxmlc.c **** {
 7301              		.loc 1 857 0
 7302 0006 0C46     		mov	r4, r1
 7303 0008 9146     		mov	r9, r2
 7304 000a 1F46     		mov	r7, r3
 7305 000c DDF84080 		ldr	r8, [sp, #64]
 861:sxmlc/sxmlc.c **** 	if (node == NULL || f == NULL || !node->active || node->tag == NULL || node->tag[0] == NULC)
 7306              		.loc 1 861 0
 7307 0010 0546     		mov	r5, r0
 7308 0012 0028     		cmp	r0, #0
 7309 0014 00F0FD80 		beq	.L1347
 861:sxmlc/sxmlc.c **** 	if (node == NULL || f == NULL || !node->active || node->tag == NULL || node->tag[0] == NULC)
 7310              		.loc 1 861 0 is_stmt 0 discriminator 1
 7311 0018 0029     		cmp	r1, #0
 7312 001a 00F0FA80 		beq	.L1347
 7313 001e 036A     		ldr	r3, [r0, #32]
 7314              	.LVL866:
 7315 0020 002B     		cmp	r3, #0
 7316 0022 00F0F680 		beq	.L1347
 7317 0026 0668     		ldr	r6, [r0]
 7318 0028 002E     		cmp	r6, #0
 7319 002a 00F0F280 		beq	.L1347
 7320 002e 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 7321 0030 002B     		cmp	r3, #0
 7322 0032 00F0EE80 		beq	.L1347
 865:sxmlc/sxmlc.c **** 	if (node->tag_type == TAG_DOCTYPE) {
 7323              		.loc 1 865 0 is_stmt 1
 7324 0036 017F     		ldrb	r1, [r0, #28]	@ zero_extendqisi2
 7325              	.LVL867:
 7326 0038 4BB2     		sxtb	r3, r1
 7327 003a 072B     		cmp	r3, #7
 7328 003c 13D1     		bne	.L1326
 867:sxmlc/sxmlc.c **** 		for (p = sx_strchr(node->tag, C2SX('[')); p != NULL && *(p-1) == C2SX('\\'); p = sx_strchr(p+1, C
 7329              		.loc 1 867 0
 7330 003e 3046     		mov	r0, r6
 7331              	.LVL868:
 7332              	.L1360:
 867:sxmlc/sxmlc.c **** 		for (p = sx_strchr(node->tag, C2SX('[')); p != NULL && *(p-1) == C2SX('\\'); p = sx_strchr(p+1, C
 7333              		.loc 1 867 0 is_stmt 0 discriminator 1
 7334 0040 5B21     		movs	r1, #91
 7335 0042 FFF7FEFF 		bl	strchr
 7336              	.LVL869:
 7337 0046 38B1     		cbz	r0, .L1348
 867:sxmlc/sxmlc.c **** 		for (p = sx_strchr(node->tag, C2SX('[')); p != NULL && *(p-1) == C2SX('\\'); p = sx_strchr(p+1, C
 7338              		.loc 1 867 0 discriminator 2
 7339 0048 10F8013C 		ldrb	r3, [r0, #-1]	@ zero_extendqisi2
 7340 004c 5C2B     		cmp	r3, #92
 7341 004e 01D1     		bne	.L1364
 867:sxmlc/sxmlc.c **** 		for (p = sx_strchr(node->tag, C2SX('[')); p != NULL && *(p-1) == C2SX('\\'); p = sx_strchr(p+1, C
 7342              		.loc 1 867 0 discriminator 1
 7343 0050 0130     		adds	r0, r0, #1
 7344              	.LVL870:
 7345 0052 F5E7     		b	.L1360
 7346              	.LVL871:
 7347              	.L1364:
 868:sxmlc/sxmlc.c **** 		cur_sz_line += sx_fprintf(f, C2SX("<!DOCTYPE%s%s>"), node->tag, p != NULL ? C2SX("]") : C2SX(""))
 7348              		.loc 1 868 0 is_stmt 1
 7349 0054 714B     		ldr	r3, .L1368
 7350 0056 00E0     		b	.L1328
 7351              	.L1348:
 7352 0058 714B     		ldr	r3, .L1368+4
 7353              	.L1328:
 868:sxmlc/sxmlc.c **** 		cur_sz_line += sx_fprintf(f, C2SX("<!DOCTYPE%s%s>"), node->tag, p != NULL ? C2SX("]") : C2SX(""))
 7354              		.loc 1 868 0 is_stmt 0 discriminator 3
 7355 005a 2046     		mov	r0, r4
 7356              	.LVL872:
 7357 005c 7149     		ldr	r1, .L1368+8
 7358 005e 3246     		mov	r2, r6
 7359 0060 FFF7FEFF 		bl	fprintf
 7360              	.LVL873:
 7361 0064 CCE0     		b	.L1362
 7362              	.LVL874:
 7363              	.L1326:
 874:sxmlc/sxmlc.c **** 		if (node->tag_type == _spec[i].tag_type) {
 7364              		.loc 1 874 0 is_stmt 1
 7365 0066 704A     		ldr	r2, .L1368+12
 7366              	.LVL875:
 7367 0068 92F90000 		ldrsb	r0, [r2]
 7368              	.LVL876:
 7369 006c 9842     		cmp	r0, r3
 7370 006e 0AD0     		beq	.L1349
 7371              	.LVL877:
 7372 0070 92F91400 		ldrsb	r0, [r2, #20]
 7373 0074 9842     		cmp	r0, r3
 7374 0076 08D0     		beq	.L1350
 7375              	.LVL878:
 7376 0078 92F92800 		ldrsb	r0, [r2, #40]
 7377 007c 9842     		cmp	r0, r3
 873:sxmlc/sxmlc.c **** 	for (i = 0; i < NB_SPECIAL_TAGS; i++) {
 7378              		.loc 1 873 0
 7379 007e 08BF     		it	eq
 7380 0080 0223     		moveq	r3, #2
 874:sxmlc/sxmlc.c **** 		if (node->tag_type == _spec[i].tag_type) {
 7381              		.loc 1 874 0
 7382 0082 1BD1     		bne	.L1365
 7383 0084 02E0     		b	.L1330
 7384              	.LVL879:
 7385              	.L1349:
 7386 0086 0023     		movs	r3, #0
 7387 0088 00E0     		b	.L1330
 7388              	.LVL880:
 7389              	.L1350:
 873:sxmlc/sxmlc.c **** 	for (i = 0; i < NB_SPECIAL_TAGS; i++) {
 7390              		.loc 1 873 0
 7391 008a 0123     		movs	r3, #1
 7392              	.LVL881:
 7393              	.L1330:
 875:sxmlc/sxmlc.c **** 			sx_fprintf(f, C2SX("%s%s%s"), _spec[i].start, node->tag, _spec[i].end);
 7394              		.loc 1 875 0
 7395 008c 1427     		movs	r7, #20
 7396              	.LVL882:
 7397 008e 07FB0327 		mla	r7, r7, r3, r2
 7398 0092 FB68     		ldr	r3, [r7, #12]
 7399 0094 6549     		ldr	r1, .L1368+16
 7400 0096 0093     		str	r3, [sp]
 7401 0098 7A68     		ldr	r2, [r7, #4]
 7402 009a 3346     		mov	r3, r6
 7403 009c 2046     		mov	r0, r4
 7404 009e FFF7FEFF 		bl	fprintf
 7405              	.LVL883:
 876:sxmlc/sxmlc.c **** 			cur_sz_line += sx_strlen(_spec[i].start) + sx_strlen(node->tag) + sx_strlen(_spec[i].end);
 7406              		.loc 1 876 0
 7407 00a2 7868     		ldr	r0, [r7, #4]
 7408 00a4 FFF7FEFF 		bl	strlen
 7409              	.LVL884:
 7410 00a8 0646     		mov	r6, r0
 7411 00aa 2868     		ldr	r0, [r5]
 7412 00ac FFF7FEFF 		bl	strlen
 7413              	.LVL885:
 7414 00b0 0446     		mov	r4, r0
 7415              	.LVL886:
 7416 00b2 F868     		ldr	r0, [r7, #12]
 7417 00b4 FFF7FEFF 		bl	strlen
 7418              	.LVL887:
 7419 00b8 2644     		add	r6, r6, r4
 7420 00ba 2CE0     		b	.L1363
 7421              	.LVL888:
 7422              	.L1365:
 882:sxmlc/sxmlc.c **** 	for (i = 0; i < _user_tags.n_tags; i++) {
 7423              		.loc 1 882 0
 7424 00bc DFF880A1 		ldr	r10, .L1368+36
 883:sxmlc/sxmlc.c **** 		if (node->tag_type == _user_tags.tags[i].tag_type) {
 7425              		.loc 1 883 0
 7426 00c0 0023     		movs	r3, #0
 882:sxmlc/sxmlc.c **** 	for (i = 0; i < _user_tags.n_tags; i++) {
 7427              		.loc 1 882 0
 7428 00c2 DAF80400 		ldr	r0, [r10, #4]
 7429 00c6 DAF80020 		ldr	r2, [r10]
 7430 00ca 00E0     		b	.L1332
 7431              	.LVL889:
 7432              	.L1333:
 7433 00cc 0133     		adds	r3, r3, #1
 7434              	.LVL890:
 7435              	.L1332:
 882:sxmlc/sxmlc.c **** 	for (i = 0; i < _user_tags.n_tags; i++) {
 7436              		.loc 1 882 0 is_stmt 0 discriminator 1
 7437 00ce 8342     		cmp	r3, r0
 7438 00d0 23DA     		bge	.L1366
 883:sxmlc/sxmlc.c **** 		if (node->tag_type == _user_tags.tags[i].tag_type) {
 7439              		.loc 1 883 0 is_stmt 1
 7440 00d2 9646     		mov	lr, r2
 7441 00d4 12F814CB 		ldrb	ip, [r2], #20	@ zero_extendqisi2
 7442 00d8 4FF0140B 		mov	fp, #20
 7443 00dc 6145     		cmp	r1, ip
 7444 00de 0BFB03FB 		mul	fp, fp, r3
 7445 00e2 F3D1     		bne	.L1333
 884:sxmlc/sxmlc.c **** 			sx_fprintf(f, C2SX("%s%s%s"), _user_tags.tags[i].start, node->tag, _user_tags.tags[i].end);
 7446              		.loc 1 884 0
 7447 00e4 DEF80C30 		ldr	r3, [lr, #12]
 7448              	.LVL891:
 7449 00e8 5049     		ldr	r1, .L1368+16
 7450 00ea 0093     		str	r3, [sp]
 7451 00ec DEF80420 		ldr	r2, [lr, #4]
 7452 00f0 3346     		mov	r3, r6
 7453 00f2 2046     		mov	r0, r4
 7454 00f4 FFF7FEFF 		bl	fprintf
 7455              	.LVL892:
 885:sxmlc/sxmlc.c **** 			cur_sz_line += sx_strlen(_user_tags.tags[i].start) + sx_strlen(node->tag) + sx_strlen(_user_tags
 7456              		.loc 1 885 0
 7457 00f8 DAF80040 		ldr	r4, [r10]
 7458              	.LVL893:
 7459 00fc 5C44     		add	r4, r4, fp
 7460 00fe 6068     		ldr	r0, [r4, #4]
 7461 0100 FFF7FEFF 		bl	strlen
 7462              	.LVL894:
 7463 0104 0646     		mov	r6, r0
 7464 0106 2868     		ldr	r0, [r5]
 7465 0108 FFF7FEFF 		bl	strlen
 7466              	.LVL895:
 7467 010c 0546     		mov	r5, r0
 7468              	.LVL896:
 7469 010e E068     		ldr	r0, [r4, #12]
 7470 0110 FFF7FEFF 		bl	strlen
 7471              	.LVL897:
 7472 0114 2E44     		add	r6, r6, r5
 7473              	.LVL898:
 7474              	.L1363:
 7475 0116 B044     		add	r8, r8, r6
 7476 0118 72E0     		b	.L1362
 7477              	.LVL899:
 7478              	.L1366:
 891:sxmlc/sxmlc.c **** 	cur_sz_line += sx_fprintf(f, C2SX("<%s"), node->tag);
 7479              		.loc 1 891 0
 7480 011a 2046     		mov	r0, r4
 7481 011c 4449     		ldr	r1, .L1368+20
 7482 011e 3246     		mov	r2, r6
 7483 0120 FFF7FEFF 		bl	fprintf
 7484              	.LVL900:
 894:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_attributes; i++) {
 7485              		.loc 1 894 0
 7486 0124 4FF0000B 		mov	fp, #0
 891:sxmlc/sxmlc.c **** 	cur_sz_line += sx_fprintf(f, C2SX("<%s"), node->tag);
 7487              		.loc 1 891 0
 7488 0128 8044     		add	r8, r8, r0
 7489              	.LVL901:
 7490              	.L1335:
 894:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_attributes; i++) {
 7491              		.loc 1 894 0 discriminator 1
 7492 012a EB68     		ldr	r3, [r5, #12]
 7493 012c 9B45     		cmp	fp, r3
 7494 012e 5DDA     		bge	.L1367
 7495 0130 4FF00C0A 		mov	r10, #12
 7496 0134 0AFB0BFA 		mul	r10, r10, fp
 895:sxmlc/sxmlc.c **** 		if (!node->attributes[i].active)
 7497              		.loc 1 895 0
 7498 0138 AB68     		ldr	r3, [r5, #8]
 7499 013a 03EB0A06 		add	r6, r3, r10
 7500 013e B268     		ldr	r2, [r6, #8]
 7501 0140 002A     		cmp	r2, #0
 7502 0142 50D0     		beq	.L1336
 897:sxmlc/sxmlc.c **** 		cur_sz_line += sx_strlen(node->attributes[i].name) + sx_strlen(node->attributes[i].value) + 3;
 7503              		.loc 1 897 0
 7504 0144 53F80A00 		ldr	r0, [r3, r10]
 7505 0148 FFF7FEFF 		bl	strlen
 7506              	.LVL902:
 7507 014c 0346     		mov	r3, r0
 7508 014e 7068     		ldr	r0, [r6, #4]
 7509 0150 0393     		str	r3, [sp, #12]
 7510 0152 FFF7FEFF 		bl	strlen
 7511              	.LVL903:
 7512 0156 039B     		ldr	r3, [sp, #12]
 7513 0158 08F10306 		add	r6, r8, #3
 7514 015c 1E44     		add	r6, r6, r3
 898:sxmlc/sxmlc.c **** 		if (sz_line > 0 && cur_sz_line > sz_line) {
 7515              		.loc 1 898 0
 7516 015e 0F9B     		ldr	r3, [sp, #60]
 897:sxmlc/sxmlc.c **** 		cur_sz_line += sx_strlen(node->attributes[i].name) + sx_strlen(node->attributes[i].value) + 3;
 7517              		.loc 1 897 0
 7518 0160 0644     		add	r6, r6, r0
 7519              	.LVL904:
 898:sxmlc/sxmlc.c **** 		if (sz_line > 0 && cur_sz_line > sz_line) {
 7520              		.loc 1 898 0
 7521 0162 002B     		cmp	r3, #0
 7522 0164 17DD     		ble	.L1337
 898:sxmlc/sxmlc.c **** 		if (sz_line > 0 && cur_sz_line > sz_line) {
 7523              		.loc 1 898 0 is_stmt 0 discriminator 1
 7524 0166 9E42     		cmp	r6, r3
 7525 0168 15DD     		ble	.L1337
 899:sxmlc/sxmlc.c **** 			cur_sz_line = _print_formatting(node, f, tag_sep, child_sep, nb_char_tab, cur_sz_line);
 7526              		.loc 1 899 0 is_stmt 1
 7527 016a 119B     		ldr	r3, [sp, #68]
 7528 016c 05F11000 		add	r0, r5, #16
 7529 0170 8DE84800 		stmia	sp, {r3, r6}
 7530 0174 2146     		mov	r1, r4
 7531 0176 4A46     		mov	r2, r9
 7532 0178 3B46     		mov	r3, r7
 7533 017a FFF7FEFF 		bl	_print_formatting.isra.0
 7534              	.LVL905:
 7535 017e 0646     		mov	r6, r0
 7536              	.LVL906:
 901:sxmlc/sxmlc.c **** 			if (child_sep != NULL) {
 7537              		.loc 1 901 0
 7538 0180 4FB1     		cbz	r7, .L1337
 902:sxmlc/sxmlc.c **** 				sx_fprintf(f, child_sep);
 7539              		.loc 1 902 0
 7540 0182 3946     		mov	r1, r7
 7541 0184 2046     		mov	r0, r4
 7542              	.LVL907:
 7543 0186 FFF7FEFF 		bl	fprintf
 7544              	.LVL908:
 903:sxmlc/sxmlc.c **** 				cur_sz_line = _count_new_char_line(child_sep, nb_char_tab, cur_sz_line);
 7545              		.loc 1 903 0
 7546 018a 3246     		mov	r2, r6
 7547 018c 3846     		mov	r0, r7
 7548 018e 1199     		ldr	r1, [sp, #68]
 7549 0190 FFF7FEFF 		bl	_count_new_char_line
 7550              	.LVL909:
 7551 0194 0646     		mov	r6, r0
 7552              	.LVL910:
 7553              	.L1337:
 907:sxmlc/sxmlc.c **** 		if (attr_sep != NULL) {
 7554              		.loc 1 907 0
 7555 0196 0E9B     		ldr	r3, [sp, #56]
 7556 0198 6BB1     		cbz	r3, .L1338
 908:sxmlc/sxmlc.c **** 			sx_fprintf(f, attr_sep);
 7557              		.loc 1 908 0
 7558 019a 1946     		mov	r1, r3
 7559 019c 2046     		mov	r0, r4
 7560 019e FFF7FEFF 		bl	fprintf
 7561              	.LVL911:
 909:sxmlc/sxmlc.c **** 			cur_sz_line = _count_new_char_line(attr_sep, nb_char_tab, cur_sz_line);
 7562              		.loc 1 909 0
 7563 01a2 1199     		ldr	r1, [sp, #68]
 7564 01a4 3246     		mov	r2, r6
 7565 01a6 0E98     		ldr	r0, [sp, #56]
 7566 01a8 FFF7FEFF 		bl	_count_new_char_line
 7567              	.LVL912:
 910:sxmlc/sxmlc.c **** 			sx_fprintf(f, C2SX("%s="), node->attributes[i].name);
 7568              		.loc 1 910 0
 7569 01ac AB68     		ldr	r3, [r5, #8]
 909:sxmlc/sxmlc.c **** 			cur_sz_line = _count_new_char_line(attr_sep, nb_char_tab, cur_sz_line);
 7570              		.loc 1 909 0
 7571 01ae 0646     		mov	r6, r0
 7572              	.LVL913:
 910:sxmlc/sxmlc.c **** 			sx_fprintf(f, C2SX("%s="), node->attributes[i].name);
 7573              		.loc 1 910 0
 7574 01b0 2049     		ldr	r1, .L1368+24
 7575 01b2 2046     		mov	r0, r4
 7576              	.LVL914:
 7577 01b4 02E0     		b	.L1361
 7578              	.L1338:
 912:sxmlc/sxmlc.c **** 			sx_fprintf(f, C2SX(" %s="), node->attributes[i].name);
 7579              		.loc 1 912 0
 7580 01b6 AB68     		ldr	r3, [r5, #8]
 7581 01b8 1F49     		ldr	r1, .L1368+28
 7582 01ba 2046     		mov	r0, r4
 7583              	.LVL915:
 7584              	.L1361:
 7585 01bc 53F80A20 		ldr	r2, [r3, r10]
 7586 01c0 FFF7FEFF 		bl	fprintf
 7587              	.LVL916:
 915:sxmlc/sxmlc.c **** 		(void)sx_fputc(XML_DEFAULT_QUOTE, f);
 7588              		.loc 1 915 0
 7589 01c4 2146     		mov	r1, r4
 7590 01c6 2220     		movs	r0, #34
 7591 01c8 FFF7FEFF 		bl	fputc
 7592              	.LVL917:
 916:sxmlc/sxmlc.c **** 		cur_sz_line += fprintHTML(f, node->attributes[i].value) + 2;
 7593              		.loc 1 916 0
 7594 01cc AB68     		ldr	r3, [r5, #8]
 7595 01ce 2046     		mov	r0, r4
 7596 01d0 5344     		add	r3, r3, r10
 7597 01d2 5968     		ldr	r1, [r3, #4]
 7598 01d4 FFF7FEFF 		bl	fprintHTML
 7599              	.LVL918:
 7600 01d8 0230     		adds	r0, r0, #2
 7601 01da 06EB0008 		add	r8, r6, r0
 7602              	.LVL919:
 917:sxmlc/sxmlc.c **** 		(void)sx_fputc(XML_DEFAULT_QUOTE, f);
 7603              		.loc 1 917 0
 7604 01de 2146     		mov	r1, r4
 7605 01e0 2220     		movs	r0, #34
 7606 01e2 FFF7FEFF 		bl	fputc
 7607              	.LVL920:
 7608              	.L1336:
 894:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_attributes; i++) {
 7609              		.loc 1 894 0
 7610 01e6 0BF1010B 		add	fp, fp, #1
 7611              	.LVL921:
 7612 01ea 9EE7     		b	.L1335
 7613              	.L1367:
 921:sxmlc/sxmlc.c **** 	if (node->n_children == 0 && (node->text == NULL || node->text[0] == NULC)) {
 7614              		.loc 1 921 0
 7615 01ec AB69     		ldr	r3, [r5, #24]
 7616 01ee 4BB9     		cbnz	r3, .L1341
 921:sxmlc/sxmlc.c **** 	if (node->n_children == 0 && (node->text == NULL || node->text[0] == NULC)) {
 7617              		.loc 1 921 0 is_stmt 0 discriminator 1
 7618 01f0 6B68     		ldr	r3, [r5, #4]
 7619 01f2 0BB1     		cbz	r3, .L1342
 7620 01f4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 7621 01f6 2BB9     		cbnz	r3, .L1341
 7622              	.L1342:
 922:sxmlc/sxmlc.c **** 		cur_sz_line += sx_fprintf(f, C2SX("/>"));
 7623              		.loc 1 922 0 is_stmt 1
 7624 01f8 2046     		mov	r0, r4
 7625 01fa 1049     		ldr	r1, .L1368+32
 7626 01fc FFF7FEFF 		bl	fprintf
 7627              	.LVL922:
 7628              	.L1362:
 7629 0200 4044     		add	r0, r0, r8
 7630 0202 08E0     		b	.L1325
 7631              	.LVL923:
 7632              	.L1341:
 924:sxmlc/sxmlc.c **** 		(void)sx_fputc(C2SX('>'), f);
 7633              		.loc 1 924 0
 7634 0204 3E20     		movs	r0, #62
 7635 0206 2146     		mov	r1, r4
 7636 0208 FFF7FEFF 		bl	fputc
 7637              	.LVL924:
 925:sxmlc/sxmlc.c **** 		cur_sz_line++;
 7638              		.loc 1 925 0
 7639 020c 08F10100 		add	r0, r8, #1
 7640              	.LVL925:
 7641 0210 01E0     		b	.L1325
 7642              	.LVL926:
 7643              	.L1347:
 862:sxmlc/sxmlc.c **** 		return -1;
 7644              		.loc 1 862 0
 7645 0212 4FF0FF30 		mov	r0, #-1
 7646              	.LVL927:
 7647              	.L1325:
 929:sxmlc/sxmlc.c **** }
 7648              		.loc 1 929 0
 7649 0216 05B0     		add	sp, sp, #20
 7650              		@ sp needed
 7651 0218 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 7652              	.LVL928:
 7653              	.L1369:
 7654              		.align	2
 7655              	.L1368:
 7656 021c 6A010000 		.word	.LC17
 7657 0220 C1000000 		.word	.LC9
 7658 0224 6C010000 		.word	.LC18
 7659 0228 00000000 		.word	.LANCHOR3
 7660 022c 7B010000 		.word	.LC19
 7661 0230 82010000 		.word	.LC20
 7662 0234 86010000 		.word	.LC21
 7663 0238 8A010000 		.word	.LC22
 7664 023c 9C000000 		.word	.LC6
 7665 0240 00000000 		.word	.LANCHOR0
 7666              		.cfi_endproc
 7667              	.LFE36:
 7669              		.section	.text.XMLNode_print_header,"ax",%progbits
 7670              		.align	1
 7671              		.global	XMLNode_print_header
 7672              		.thumb
 7673              		.thumb_func
 7675              	XMLNode_print_header:
 7676              	.LFB37:
 932:sxmlc/sxmlc.c **** {
 7677              		.loc 1 932 0
 7678              		.cfi_startproc
 7679              		@ args = 0, pretend = 0, frame = 0
 7680              		@ frame_needed = 0, uses_anonymous_args = 0
 7681              	.LVL929:
 7682 0000 1FB5     		push	{r0, r1, r2, r3, r4, lr}
 7683              		.cfi_def_cfa_offset 24
 7684              		.cfi_offset 0, -24
 7685              		.cfi_offset 1, -20
 7686              		.cfi_offset 2, -16
 7687              		.cfi_offset 3, -12
 7688              		.cfi_offset 4, -8
 7689              		.cfi_offset 14, -4
 933:sxmlc/sxmlc.c **** 	return _XMLNode_print_header(node, f, NULL, NULL, NULL, sz_line, 0, nb_char_tab) < 0 ? false : tru
 7690              		.loc 1 933 0
 7691 0002 0024     		movs	r4, #0
 7692 0004 0192     		str	r2, [sp, #4]
 7693 0006 0393     		str	r3, [sp, #12]
 7694 0008 0094     		str	r4, [sp]
 7695 000a 0294     		str	r4, [sp, #8]
 7696 000c 2246     		mov	r2, r4
 7697              	.LVL930:
 7698 000e 2346     		mov	r3, r4
 7699              	.LVL931:
 7700 0010 FFF7FEFF 		bl	_XMLNode_print_header
 7701              	.LVL932:
 934:sxmlc/sxmlc.c **** }
 7702              		.loc 1 934 0
 7703 0014 A042     		cmp	r0, r4
 7704 0016 B4BF     		ite	lt
 7705 0018 0020     		movlt	r0, #0
 7706 001a 0120     		movge	r0, #1
 7707 001c 04B0     		add	sp, sp, #16
 7708              		@ sp needed
 7709 001e 10BD     		pop	{r4, pc}
 7710              		.cfi_endproc
 7711              	.LFE37:
 7713              		.section	.text._XMLNode_print,"ax",%progbits
 7714              		.align	1
 7715              		.thumb
 7716              		.thumb_func
 7718              	_XMLNode_print:
 7719              	.LFB38:
 937:sxmlc/sxmlc.c **** {
 7720              		.loc 1 937 0
 7721              		.cfi_startproc
 7722              		@ args = 24, pretend = 0, frame = 0
 7723              		@ frame_needed = 0, uses_anonymous_args = 0
 7724              	.LVL933:
 7725 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 7726              		.cfi_def_cfa_offset 36
 7727              		.cfi_offset 4, -36
 7728              		.cfi_offset 5, -32
 7729              		.cfi_offset 6, -28
 7730              		.cfi_offset 7, -24
 7731              		.cfi_offset 8, -20
 7732              		.cfi_offset 9, -16
 7733              		.cfi_offset 10, -12
 7734              		.cfi_offset 11, -8
 7735              		.cfi_offset 14, -4
 7736 0004 87B0     		sub	sp, sp, #28
 7737              		.cfi_def_cfa_offset 64
 937:sxmlc/sxmlc.c **** {
 7738              		.loc 1 937 0
 7739 0006 13AD     		add	r5, sp, #76
 7740              	.LVL934:
 7741 0008 0E46     		mov	r6, r1
 7742 000a 9146     		mov	r9, r2
 7743 000c 9846     		mov	r8, r3
 7744 000e 95E8A008 		ldmia	r5, {r5, r7, fp}
 7745              	.LVL935:
 941:sxmlc/sxmlc.c **** 	if (node != NULL && node->tag_type==TAG_TEXT) { /* Text has to be printed: check if it is only spa
 7746              		.loc 1 941 0
 7747 0012 0446     		mov	r4, r0
 7748 0014 0028     		cmp	r0, #0
 7749 0016 00F08E80 		beq	.L1393
 941:sxmlc/sxmlc.c **** 	if (node != NULL && node->tag_type==TAG_TEXT) { /* Text has to be printed: check if it is only spa
 7750              		.loc 1 941 0 is_stmt 0 discriminator 1
 7751 001a 90F91C00 		ldrsb	r0, [r0, #28]
 7752              	.LVL936:
 7753 001e 0928     		cmp	r0, #9
 7754 0020 16D1     		bne	.L1373
 942:sxmlc/sxmlc.c **** 		if (!keep_text_spaces) {
 7755              		.loc 1 942 0 is_stmt 1
 7756 0022 119A     		ldr	r2, [sp, #68]
 7757              	.LVL937:
 7758 0024 6368     		ldr	r3, [r4, #4]
 7759              	.LVL938:
 7760 0026 52B9     		cbnz	r2, .L1374
 7761              	.LVL939:
 943:sxmlc/sxmlc.c **** 			for (p = node->text; *p != NULC && sx_isspace(*p); p++) ; /* 'p' points to first non-space chara
 7762              		.loc 1 943 0
 7763 0028 464A     		ldr	r2, .L1415
 7764 002a 1068     		ldr	r0, [r2]
 7765              	.LVL940:
 7766              	.L1375:
 7767 002c 1A46     		mov	r2, r3
 7768              	.LVL941:
 943:sxmlc/sxmlc.c **** 			for (p = node->text; *p != NULC && sx_isspace(*p); p++) ; /* 'p' points to first non-space chara
 7769              		.loc 1 943 0 is_stmt 0 discriminator 1
 7770 002e 13F8011B 		ldrb	r1, [r3], #1	@ zero_extendqisi2
 7771 0032 29B1     		cbz	r1, .L1376
 943:sxmlc/sxmlc.c **** 			for (p = node->text; *p != NULC && sx_isspace(*p); p++) ; /* 'p' points to first non-space chara
 7772              		.loc 1 943 0 discriminator 2
 7773 0034 0144     		add	r1, r1, r0
 7774 0036 4978     		ldrb	r1, [r1, #1]	@ zero_extendqisi2
 7775 0038 0F07     		lsls	r7, r1, #28
 7776 003a F7D4     		bmi	.L1375
 7777 003c 00E0     		b	.L1376
 7778              	.LVL942:
 7779              	.L1374:
 945:sxmlc/sxmlc.c **** 			p = node->text; /* '*p' won't be '\0' */
 7780              		.loc 1 945 0 is_stmt 1
 7781 003e 1A46     		mov	r2, r3
 7782              	.LVL943:
 7783              	.L1376:
 946:sxmlc/sxmlc.c **** 		if (*p != NULC)
 7784              		.loc 1 946 0
 7785 0040 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 7786 0042 002B     		cmp	r3, #0
 7787 0044 7AD0     		beq	.L1397
 947:sxmlc/sxmlc.c **** 			cur_sz_line += fprintHTML(f, node->text);
 7788              		.loc 1 947 0
 7789 0046 3046     		mov	r0, r6
 7790 0048 6168     		ldr	r1, [r4, #4]
 7791 004a FFF7FEFF 		bl	fprintHTML
 7792              	.LVL944:
 7793 004e 70E0     		b	.L1413
 7794              	.LVL945:
 7795              	.L1373:
 951:sxmlc/sxmlc.c **** 	if (node == NULL || f == NULL || !node->active || node->tag == NULL || node->tag[0] == NULC)
 7796              		.loc 1 951 0 discriminator 1
 7797 0050 0029     		cmp	r1, #0
 7798 0052 70D0     		beq	.L1393
 7799 0054 206A     		ldr	r0, [r4, #32]
 7800 0056 0028     		cmp	r0, #0
 7801 0058 6DD0     		beq	.L1393
 7802 005a 2068     		ldr	r0, [r4]
 7803 005c 0028     		cmp	r0, #0
 7804 005e 6AD0     		beq	.L1393
 7805 0060 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 7806 0062 0028     		cmp	r0, #0
 7807 0064 67D0     		beq	.L1393
 955:sxmlc/sxmlc.c **** 		nb_char_tab = 1;
 7808              		.loc 1 955 0
 7809 0066 012F     		cmp	r7, #1
 7810 0068 B8BF     		it	lt
 7811 006a 0127     		movlt	r7, #1
 7812              	.LVL946:
 958:sxmlc/sxmlc.c **** 	if (depth < 0) /* UGLY HACK: 'depth' forced negative on very first line so we don't print an extra
 7813              		.loc 1 958 0
 7814 006c BBF1000F 		cmp	fp, #0
 7815 0070 07DB     		blt	.L1395
 961:sxmlc/sxmlc.c **** 		cur_sz_line = _print_formatting(node, f, tag_sep, child_sep, nb_char_tab, cur_sz_line);
 7816              		.loc 1 961 0
 7817 0072 0195     		str	r5, [sp, #4]
 7818 0074 0097     		str	r7, [sp]
 7819 0076 04F11000 		add	r0, r4, #16
 7820 007a FFF7FEFF 		bl	_print_formatting.isra.0
 7821              	.LVL947:
 7822 007e 0546     		mov	r5, r0
 7823              	.LVL948:
 7824 0080 01E0     		b	.L1379
 7825              	.LVL949:
 7826              	.L1395:
 959:sxmlc/sxmlc.c **** 		depth = 0;
 7827              		.loc 1 959 0
 7828 0082 4FF0000B 		mov	fp, #0
 7829              	.LVL950:
 7830              	.L1379:
 963:sxmlc/sxmlc.c **** 	_XMLNode_print_header(node, f, tag_sep, child_sep, attr_sep, sz_line, cur_sz_line, nb_char_tab);
 7831              		.loc 1 963 0
 7832 0086 109B     		ldr	r3, [sp, #64]
 7833 0088 129A     		ldr	r2, [sp, #72]
 7834 008a 0093     		str	r3, [sp]
 7835 008c 0192     		str	r2, [sp, #4]
 7836 008e 3146     		mov	r1, r6
 7837 0090 0295     		str	r5, [sp, #8]
 7838 0092 0397     		str	r7, [sp, #12]
 7839 0094 2046     		mov	r0, r4
 7840 0096 4A46     		mov	r2, r9
 7841 0098 4346     		mov	r3, r8
 7842 009a FFF7FEFF 		bl	_XMLNode_print_header
 7843              	.LVL951:
 965:sxmlc/sxmlc.c **** 	if (node->text != NULL && node->text[0] != NULC) {
 7844              		.loc 1 965 0
 7845 009e 6168     		ldr	r1, [r4, #4]
 7846 00a0 C1B1     		cbz	r1, .L1380
 965:sxmlc/sxmlc.c **** 	if (node->text != NULL && node->text[0] != NULC) {
 7847              		.loc 1 965 0 is_stmt 0 discriminator 1
 7848 00a2 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 7849 00a4 B3B1     		cbz	r3, .L1380
 967:sxmlc/sxmlc.c **** 		if (!keep_text_spaces) {
 7850              		.loc 1 967 0 is_stmt 1
 7851 00a6 119B     		ldr	r3, [sp, #68]
 7852 00a8 63B9     		cbnz	r3, .L1396
 968:sxmlc/sxmlc.c **** 			for (p = node->text; *p != NULC && sx_isspace(*p); p++) ; /* 'p' points to first non-space chara
 7853              		.loc 1 968 0
 7854 00aa 264B     		ldr	r3, .L1415
 7855 00ac D3F800E0 		ldr	lr, [r3]
 7856 00b0 0B46     		mov	r3, r1
 7857              	.L1382:
 7858 00b2 1A46     		mov	r2, r3
 7859              	.LVL952:
 968:sxmlc/sxmlc.c **** 			for (p = node->text; *p != NULC && sx_isspace(*p); p++) ; /* 'p' points to first non-space chara
 7860              		.loc 1 968 0 is_stmt 0 discriminator 1
 7861 00b4 13F8010B 		ldrb	r0, [r3], #1	@ zero_extendqisi2
 7862 00b8 28B1     		cbz	r0, .L1381
 968:sxmlc/sxmlc.c **** 			for (p = node->text; *p != NULC && sx_isspace(*p); p++) ; /* 'p' points to first non-space chara
 7863              		.loc 1 968 0 discriminator 2
 7864 00ba 7044     		add	r0, r0, lr
 7865 00bc 4078     		ldrb	r0, [r0, #1]	@ zero_extendqisi2
 7866 00be 0007     		lsls	r0, r0, #28
 7867 00c0 F7D4     		bmi	.L1382
 7868 00c2 00E0     		b	.L1381
 7869              	.LVL953:
 7870              	.L1396:
 7871 00c4 0A46     		mov	r2, r1
 7872              	.L1381:
 7873              	.LVL954:
 971:sxmlc/sxmlc.c **** 		if (*p != NULC) cur_sz_line += fprintHTML(f, node->text);
 7874              		.loc 1 971 0 is_stmt 1
 7875 00c6 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 7876 00c8 3BB1     		cbz	r3, .L1384
 971:sxmlc/sxmlc.c **** 		if (*p != NULC) cur_sz_line += fprintHTML(f, node->text);
 7877              		.loc 1 971 0 is_stmt 0 discriminator 1
 7878 00ca 3046     		mov	r0, r6
 7879 00cc FFF7FEFF 		bl	fprintHTML
 7880              	.LVL955:
 7881 00d0 0544     		add	r5, r5, r0
 7882              	.LVL956:
 7883 00d2 02E0     		b	.L1384
 7884              	.L1380:
 972:sxmlc/sxmlc.c **** 	} else if (node->n_children <= 0) /* Everything has already been printed */
 7885              		.loc 1 972 0 is_stmt 1
 7886 00d4 A369     		ldr	r3, [r4, #24]
 7887 00d6 002B     		cmp	r3, #0
 7888 00d8 30DD     		ble	.L1397
 7889              	.L1384:
 7890              	.LVL957:
 976:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_children; i++)
 7891              		.loc 1 976 0
 7892 00da 4FF0000A 		mov	r10, #0
 7893              	.LVL958:
 7894              	.L1385:
 976:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_children; i++)
 7895              		.loc 1 976 0 is_stmt 0 discriminator 1
 7896 00de A369     		ldr	r3, [r4, #24]
 7897 00e0 9A45     		cmp	r10, r3
 7898 00e2 15DA     		bge	.L1414
 977:sxmlc/sxmlc.c **** 		(void)_XMLNode_print(node->children[i], f, tag_sep, child_sep, attr_sep, keep_text_spaces, sz_lin
 7899              		.loc 1 977 0 is_stmt 1 discriminator 2
 7900 00e4 109A     		ldr	r2, [sp, #64]
 7901 00e6 6369     		ldr	r3, [r4, #20]
 7902 00e8 0092     		str	r2, [sp]
 7903 00ea 119A     		ldr	r2, [sp, #68]
 7904 00ec 0395     		str	r5, [sp, #12]
 7905 00ee 0192     		str	r2, [sp, #4]
 7906 00f0 129A     		ldr	r2, [sp, #72]
 7907 00f2 0497     		str	r7, [sp, #16]
 7908 00f4 0292     		str	r2, [sp, #8]
 7909 00f6 0BF10102 		add	r2, fp, #1
 7910 00fa 0592     		str	r2, [sp, #20]
 7911 00fc 53F82A00 		ldr	r0, [r3, r10, lsl #2]
 7912 0100 3146     		mov	r1, r6
 7913 0102 4A46     		mov	r2, r9
 7914 0104 4346     		mov	r3, r8
 7915 0106 FFF77BFF 		bl	_XMLNode_print
 7916              	.LVL959:
 976:sxmlc/sxmlc.c **** 	for (i = 0; i < node->n_children; i++)
 7917              		.loc 1 976 0 discriminator 2
 7918 010a 0AF1010A 		add	r10, r10, #1
 7919              	.LVL960:
 7920 010e E6E7     		b	.L1385
 7921              	.L1414:
 981:sxmlc/sxmlc.c **** 	if (node->n_children > 0)
 7922              		.loc 1 981 0
 7923 0110 002B     		cmp	r3, #0
 7924 0112 09DD     		ble	.L1387
 982:sxmlc/sxmlc.c **** 		cur_sz_line = _print_formatting(node, f, tag_sep, child_sep, nb_char_tab, cur_sz_line);
 7925              		.loc 1 982 0
 7926 0114 0195     		str	r5, [sp, #4]
 7927 0116 0097     		str	r7, [sp]
 7928 0118 04F11000 		add	r0, r4, #16
 7929 011c 3146     		mov	r1, r6
 7930 011e 4A46     		mov	r2, r9
 7931 0120 4346     		mov	r3, r8
 7932 0122 FFF7FEFF 		bl	_print_formatting.isra.0
 7933              	.LVL961:
 7934 0126 0546     		mov	r5, r0
 7935              	.LVL962:
 7936              	.L1387:
 983:sxmlc/sxmlc.c **** 	cur_sz_line += sx_fprintf(f, C2SX("</%s>"), node->tag);
 7937              		.loc 1 983 0
 7938 0128 3046     		mov	r0, r6
 7939 012a 0749     		ldr	r1, .L1415+4
 7940 012c 2268     		ldr	r2, [r4]
 7941 012e FFF7FEFF 		bl	fprintf
 7942              	.LVL963:
 7943              	.L1413:
 7944 0132 2844     		add	r0, r0, r5
 985:sxmlc/sxmlc.c **** 	return cur_sz_line;
 7945              		.loc 1 985 0
 7946 0134 03E0     		b	.L1372
 7947              	.LVL964:
 7948              	.L1393:
 952:sxmlc/sxmlc.c **** 		return -1;
 7949              		.loc 1 952 0
 7950 0136 4FF0FF30 		mov	r0, #-1
 7951 013a 00E0     		b	.L1372
 7952              	.LVL965:
 7953              	.L1397:
 973:sxmlc/sxmlc.c **** 		return cur_sz_line;
 7954              		.loc 1 973 0
 7955 013c 2846     		mov	r0, r5
 7956              	.L1372:
 986:sxmlc/sxmlc.c **** }
 7957              		.loc 1 986 0
 7958 013e 07B0     		add	sp, sp, #28
 7959              		@ sp needed
 7960 0140 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 7961              	.LVL966:
 7962              	.L1416:
 7963              		.align	2
 7964              	.L1415:
 7965 0144 00000000 		.word	__ctype_ptr__
 7966 0148 8F010000 		.word	.LC23
 7967              		.cfi_endproc
 7968              	.LFE38:
 7970              		.section	.text.XMLNode_print_attr_sep,"ax",%progbits
 7971              		.align	1
 7972              		.global	XMLNode_print_attr_sep
 7973              		.thumb
 7974              		.thumb_func
 7976              	XMLNode_print_attr_sep:
 7977              	.LFB39:
 989:sxmlc/sxmlc.c **** {
 7978              		.loc 1 989 0
 7979              		.cfi_startproc
 7980              		@ args = 16, pretend = 0, frame = 0
 7981              		@ frame_needed = 0, uses_anonymous_args = 0
 7982              	.LVL967:
 7983 0000 30B5     		push	{r4, r5, lr}
 7984              		.cfi_def_cfa_offset 12
 7985              		.cfi_offset 4, -12
 7986              		.cfi_offset 5, -8
 7987              		.cfi_offset 14, -4
 7988 0002 87B0     		sub	sp, sp, #28
 7989              		.cfi_def_cfa_offset 40
 990:sxmlc/sxmlc.c **** 	return _XMLNode_print(node, f, tag_sep, child_sep, attr_sep, keep_text_spaces, sz_line, 0, nb_char
 7990              		.loc 1 990 0
 7991 0004 0A9C     		ldr	r4, [sp, #40]
 7992 0006 0D9D     		ldr	r5, [sp, #52]
 7993 0008 0094     		str	r4, [sp]
 7994 000a 0B9C     		ldr	r4, [sp, #44]
 7995 000c 0495     		str	r5, [sp, #16]
 7996 000e 0194     		str	r4, [sp, #4]
 7997 0010 0C9C     		ldr	r4, [sp, #48]
 7998 0012 0294     		str	r4, [sp, #8]
 7999 0014 0024     		movs	r4, #0
 8000 0016 0394     		str	r4, [sp, #12]
 8001 0018 0594     		str	r4, [sp, #20]
 8002 001a FFF7FEFF 		bl	_XMLNode_print
 8003              	.LVL968:
 991:sxmlc/sxmlc.c **** }
 8004              		.loc 1 991 0
 8005 001e 07B0     		add	sp, sp, #28
 8006              		@ sp needed
 8007 0020 30BD     		pop	{r4, r5, pc}
 8008              		.cfi_endproc
 8009              	.LFE39:
 8011              		.section	.text.XMLDoc_print_attr_sep,"ax",%progbits
 8012              		.align	1
 8013              		.global	XMLDoc_print_attr_sep
 8014              		.thumb
 8015              		.thumb_func
 8017              	XMLDoc_print_attr_sep:
 8018              	.LFB40:
 994:sxmlc/sxmlc.c **** {
 8019              		.loc 1 994 0
 8020              		.cfi_startproc
 8021              		@ args = 16, pretend = 0, frame = 0
 8022              		@ frame_needed = 0, uses_anonymous_args = 0
 8023              	.LVL969:
 8024 0000 2DE9F04A 		push	{r4, r5, r6, r7, r9, fp, lr}
 8025              		.cfi_def_cfa_offset 28
 8026              		.cfi_offset 4, -28
 8027              		.cfi_offset 5, -24
 8028              		.cfi_offset 6, -20
 8029              		.cfi_offset 7, -16
 8030              		.cfi_offset 9, -12
 8031              		.cfi_offset 11, -8
 8032              		.cfi_offset 14, -4
 8033 0004 87B0     		sub	sp, sp, #28
 8034              		.cfi_def_cfa_offset 56
 994:sxmlc/sxmlc.c **** {
 8035              		.loc 1 994 0
 8036 0006 0C46     		mov	r4, r1
 8037 0008 9346     		mov	fp, r2
 8038 000a 1E46     		mov	r6, r3
 8039 000c 119F     		ldr	r7, [sp, #68]
 997:sxmlc/sxmlc.c **** 	if (doc == NULL || f == NULL || doc->init_value != XML_INIT_DONE)
 8040              		.loc 1 997 0
 8041 000e 0546     		mov	r5, r0
 8042 0010 28B3     		cbz	r0, .L1422
 997:sxmlc/sxmlc.c **** 	if (doc == NULL || f == NULL || doc->init_value != XML_INIT_DONE)
 8043              		.loc 1 997 0 is_stmt 0 discriminator 1
 8044 0012 29B3     		cbz	r1, .L1423
 8045 0014 D0F80C31 		ldr	r3, [r0, #268]
 8046              	.LVL970:
 8047 0018 134A     		ldr	r2, .L1426
 8048              	.LVL971:
 998:sxmlc/sxmlc.c **** 		return false;
 8049              		.loc 1 998 0 is_stmt 1 discriminator 1
 8050 001a 0020     		movs	r0, #0
 8051              	.LVL972:
 997:sxmlc/sxmlc.c **** 	if (doc == NULL || f == NULL || doc->init_value != XML_INIT_DONE)
 8052              		.loc 1 997 0 discriminator 1
 8053 001c 9342     		cmp	r3, r2
 8054 001e 20D1     		bne	.L1419
 997:sxmlc/sxmlc.c **** 	if (doc == NULL || f == NULL || doc->init_value != XML_INIT_DONE)
 8055              		.loc 1 997 0 is_stmt 0
 8056 0020 4FF0FF33 		mov	r3, #-1
 8057 0024 8146     		mov	r9, r0
 8058              	.LVL973:
 8059              	.L1420:
1006:sxmlc/sxmlc.c **** 	for (i = 0, cur_sz_line = 0; i < doc->n_nodes; i++) {
 8060              		.loc 1 1006 0 is_stmt 1 discriminator 1
 8061 0026 D5F80421 		ldr	r2, [r5, #260]
 8062 002a 9145     		cmp	r9, r2
 8063 002c 15DA     		bge	.L1425
1007:sxmlc/sxmlc.c **** 		cur_sz_line = _XMLNode_print(doc->nodes[i], f, tag_sep, child_sep, attr_sep, keep_text_spaces, sz
 8064              		.loc 1 1007 0 discriminator 2
 8065 002e 0E99     		ldr	r1, [sp, #56]
 8066 0030 D5F80021 		ldr	r2, [r5, #256]
 8067 0034 0091     		str	r1, [sp]
 8068 0036 0F99     		ldr	r1, [sp, #60]
 8069 0038 0593     		str	r3, [sp, #20]
 8070 003a 0191     		str	r1, [sp, #4]
 8071 003c 1099     		ldr	r1, [sp, #64]
 8072 003e 0390     		str	r0, [sp, #12]
 8073 0040 0291     		str	r1, [sp, #8]
 8074 0042 0497     		str	r7, [sp, #16]
 8075 0044 52F82900 		ldr	r0, [r2, r9, lsl #2]
 8076              	.LVL974:
 8077 0048 3346     		mov	r3, r6
 8078              	.LVL975:
 8079 004a 2146     		mov	r1, r4
 8080 004c 5A46     		mov	r2, fp
 8081 004e FFF7FEFF 		bl	_XMLNode_print
 8082              	.LVL976:
1006:sxmlc/sxmlc.c **** 	for (i = 0, cur_sz_line = 0; i < doc->n_nodes; i++) {
 8083              		.loc 1 1006 0 discriminator 2
 8084 0052 09F10109 		add	r9, r9, #1
 8085              	.LVL977:
1008:sxmlc/sxmlc.c **** 		depth = 0;
 8086              		.loc 1 1008 0 discriminator 2
 8087 0056 0023     		movs	r3, #0
 8088 0058 E5E7     		b	.L1420
 8089              	.LVL978:
 8090              	.L1425:
1012:sxmlc/sxmlc.c **** 	return true;
 8091              		.loc 1 1012 0
 8092 005a 0120     		movs	r0, #1
 8093              	.LVL979:
 8094 005c 01E0     		b	.L1419
 8095              	.LVL980:
 8096              	.L1422:
 8097 005e 00E0     		b	.L1419
 8098              	.L1423:
 998:sxmlc/sxmlc.c **** 		return false;
 8099              		.loc 1 998 0
 8100 0060 0846     		mov	r0, r1
 8101              	.LVL981:
 8102              	.L1419:
1013:sxmlc/sxmlc.c **** }
 8103              		.loc 1 1013 0
 8104 0062 07B0     		add	sp, sp, #28
 8105              		@ sp needed
 8106 0064 BDE8F08A 		pop	{r4, r5, r6, r7, r9, fp, pc}
 8107              	.LVL982:
 8108              	.L1427:
 8109              		.align	2
 8110              	.L1426:
 8111 0068 22057719 		.word	427230498
 8112              		.cfi_endproc
 8113              	.LFE40:
 8115              		.section	.text.regstrcmp,"ax",%progbits
 8116              		.align	1
 8117              		.global	regstrcmp
 8118              		.thumb
 8119              		.thumb_func
 8121              	regstrcmp:
 8122              	.LFB69:
2244:sxmlc/sxmlc.c **** 
2245:sxmlc/sxmlc.c **** int regstrcmp(SXML_CHAR* str, SXML_CHAR* pattern)
2246:sxmlc/sxmlc.c **** {
 8123              		.loc 1 2246 0
 8124              		.cfi_startproc
 8125              		@ args = 0, pretend = 0, frame = 0
 8126              		@ frame_needed = 0, uses_anonymous_args = 0
 8127              	.LVL983:
 8128 0000 10B5     		push	{r4, lr}
 8129              		.cfi_def_cfa_offset 8
 8130              		.cfi_offset 4, -8
 8131              		.cfi_offset 14, -4
2247:sxmlc/sxmlc.c **** 	SXML_CHAR *p, *s;
2248:sxmlc/sxmlc.c **** 
2249:sxmlc/sxmlc.c **** 	if (str == NULL && pattern == NULL)
 8132              		.loc 1 2249 0
 8133 0002 10B9     		cbnz	r0, .L1429
 8134              		.loc 1 2249 0 is_stmt 0 discriminator 1
 8135 0004 D1F10100 		rsbs	r0, r1, #1
 8136              	.LVL984:
 8137 0008 22E0     		b	.L1452
 8138              	.LVL985:
 8139              	.L1429:
2250:sxmlc/sxmlc.c **** 		return true;
2251:sxmlc/sxmlc.c **** 
2252:sxmlc/sxmlc.c **** 	if (str == NULL || pattern == NULL)
 8140              		.loc 1 2252 0 is_stmt 1 discriminator 1
 8141 000a 79B3     		cbz	r1, .L1453
 8142              	.LVL986:
 8143              	.L1431:
2253:sxmlc/sxmlc.c **** 		return false;
2254:sxmlc/sxmlc.c **** 
2255:sxmlc/sxmlc.c **** 	p = pattern;
2256:sxmlc/sxmlc.c **** 	s = str;
2257:sxmlc/sxmlc.c **** 	while (true) {
2258:sxmlc/sxmlc.c **** 		switch (*p) {
 8144              		.loc 1 2258 0
 8145 000c 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 8146 000e 2A2B     		cmp	r3, #42
 8147 0010 0DD0     		beq	.L1436
 8148 0012 3F2B     		cmp	r3, #63
 8149 0014 04D0     		beq	.L1434
 8150 0016 F3B9     		cbnz	r3, .L1451
2259:sxmlc/sxmlc.c **** 			/* Any character matches, go to next one */
2260:sxmlc/sxmlc.c **** 			case C2SX('?'):
2261:sxmlc/sxmlc.c **** 				p++;
2262:sxmlc/sxmlc.c **** 				s++;
2263:sxmlc/sxmlc.c **** 				break;
2264:sxmlc/sxmlc.c **** 
2265:sxmlc/sxmlc.c **** 			/* Go to next character in pattern and wait until it is found in 'str' */
2266:sxmlc/sxmlc.c **** 			case C2SX('*'):
2267:sxmlc/sxmlc.c **** 				for (; *p != NULC; p++) { /* Squeeze '**?*??**' to '*' */
2268:sxmlc/sxmlc.c **** 					if (*p != C2SX('*') && *p != C2SX('?'))
2269:sxmlc/sxmlc.c **** 						break;
2270:sxmlc/sxmlc.c **** 				}
2271:sxmlc/sxmlc.c **** 				for (; *s != NULC; s++) {
2272:sxmlc/sxmlc.c **** 					if (*s == *p)
2273:sxmlc/sxmlc.c **** 						break;
2274:sxmlc/sxmlc.c **** 				}
2275:sxmlc/sxmlc.c **** 				break;
2276:sxmlc/sxmlc.c **** 
2277:sxmlc/sxmlc.c **** 			/* NULL character on pattern has to be matched by 'str' */
2278:sxmlc/sxmlc.c **** 			case 0:
2279:sxmlc/sxmlc.c **** 				return *s ? false : true;
 8151              		.loc 1 2279 0
 8152 0018 0078     		ldrb	r0, [r0]	@ zero_extendqisi2
 8153              	.LVL987:
 8154 001a D0F10100 		rsbs	r0, r0, #1
 8155 001e 17E0     		b	.L1452
 8156              	.LVL988:
 8157              	.L1434:
2261:sxmlc/sxmlc.c **** 				p++;
 8158              		.loc 1 2261 0
 8159 0020 4C1C     		adds	r4, r1, #1
 8160              	.LVL989:
2262:sxmlc/sxmlc.c **** 				s++;
 8161              		.loc 1 2262 0
 8162 0022 421C     		adds	r2, r0, #1
 8163              	.LVL990:
 8164              	.L1437:
2246:sxmlc/sxmlc.c **** {
 8165              		.loc 1 2246 0
 8166 0024 1046     		mov	r0, r2
 8167 0026 2146     		mov	r1, r4
 8168 0028 F0E7     		b	.L1431
 8169              	.LVL991:
 8170              	.L1440:
2268:sxmlc/sxmlc.c **** 					if (*p != C2SX('*') && *p != C2SX('?'))
 8171              		.loc 1 2268 0
 8172 002a 2A2B     		cmp	r3, #42
 8173 002c 05D1     		bne	.L1454
 8174              	.LVL992:
 8175              	.L1436:
 8176 002e 0C46     		mov	r4, r1
 8177              	.LVL993:
2267:sxmlc/sxmlc.c **** 				for (; *p != NULC; p++) { /* Squeeze '**?*??**' to '*' */
 8178              		.loc 1 2267 0 discriminator 1
 8179 0030 11F8013B 		ldrb	r3, [r1], #1	@ zero_extendqisi2
 8180              	.LVL994:
 8181 0034 002B     		cmp	r3, #0
 8182 0036 F8D1     		bne	.L1440
 8183 0038 04E0     		b	.L1439
 8184              	.L1454:
2268:sxmlc/sxmlc.c **** 					if (*p != C2SX('*') && *p != C2SX('?'))
 8185              		.loc 1 2268 0 discriminator 1
 8186 003a 3F2B     		cmp	r3, #63
 8187 003c F7D0     		beq	.L1436
 8188 003e 01E0     		b	.L1439
 8189              	.LVL995:
 8190              	.L1442:
2272:sxmlc/sxmlc.c **** 					if (*s == *p)
 8191              		.loc 1 2272 0
 8192 0040 9942     		cmp	r1, r3
 8193 0042 EFD0     		beq	.L1437
 8194              	.LVL996:
 8195              	.L1439:
 8196 0044 0246     		mov	r2, r0
 8197              	.LVL997:
2271:sxmlc/sxmlc.c **** 				for (; *s != NULC; s++) {
 8198              		.loc 1 2271 0 discriminator 1
 8199 0046 10F8011B 		ldrb	r1, [r0], #1	@ zero_extendqisi2
 8200              	.LVL998:
 8201 004a 0029     		cmp	r1, #0
 8202 004c F8D1     		bne	.L1442
 8203 004e E9E7     		b	.L1437
 8204              	.LVL999:
 8205              	.L1452:
 8206              		.loc 1 2279 0
 8207 0050 38BF     		it	cc
 8208 0052 0020     		movcc	r0, #0
 8209 0054 10BD     		pop	{r4, pc}
 8210              	.LVL1000:
 8211              	.L1451:
2280:sxmlc/sxmlc.c **** 
2281:sxmlc/sxmlc.c **** 			default:
2282:sxmlc/sxmlc.c **** 				if (*p == C2SX('\\')) /* Escape character */
 8212              		.loc 1 2282 0
 8213 0056 5C2B     		cmp	r3, #92
2283:sxmlc/sxmlc.c **** 					p++;
 8214              		.loc 1 2283 0
 8215 0058 08BF     		it	eq
 8216 005a 0131     		addeq	r1, r1, #1
 8217              	.LVL1001:
2284:sxmlc/sxmlc.c **** 				if (*p++ != *s++) /* Characters do not match */
 8218              		.loc 1 2284 0
 8219 005c 4C1C     		adds	r4, r1, #1
 8220              	.LVL1002:
 8221 005e 0378     		ldrb	r3, [r0]	@ zero_extendqisi2
 8222 0060 0978     		ldrb	r1, [r1]	@ zero_extendqisi2
 8223 0062 421C     		adds	r2, r0, #1
 8224              	.LVL1003:
 8225 0064 9942     		cmp	r1, r3
 8226 0066 DDD0     		beq	.L1437
2253:sxmlc/sxmlc.c **** 		return false;
 8227              		.loc 1 2253 0
 8228 0068 0020     		movs	r0, #0
 8229 006a 10BD     		pop	{r4, pc}
 8230              	.LVL1004:
 8231              	.L1453:
 8232 006c 0846     		mov	r0, r1
 8233              	.LVL1005:
2285:sxmlc/sxmlc.c **** 					return false;
2286:sxmlc/sxmlc.c **** 				break;
2287:sxmlc/sxmlc.c **** 		}
2288:sxmlc/sxmlc.c **** 	}
2289:sxmlc/sxmlc.c **** 
2290:sxmlc/sxmlc.c **** 	return false;
2291:sxmlc/sxmlc.c **** }
 8234              		.loc 1 2291 0
 8235 006e 10BD     		pop	{r4, pc}
 8236              		.cfi_endproc
 8237              	.LFE69:
 8239              		.section	.bss._user_tags,"aw",%nobits
 8240              		.align	2
 8241              		.set	.LANCHOR0,. + 0
 8244              	_user_tags:
 8245 0000 00000000 		.space	8
 8245      00000000 
 8246              		.section	.rodata.str1.1,"aMS",%progbits,1
 8247              	.LC0:
 8248 0000 25733A25 		.ascii	"%s:%d: ERROR - End tag </%s> was unexpected\000"
 8248      643A2045 
 8248      52524F52 
 8248      202D2045 
 8248      6E642074 
 8249              	.LC1:
 8250 002c 20283C2F 		.ascii	" (</%s> was expected)\012\000"
 8250      25733E20 
 8250      77617320 
 8250      65787065 
 8250      63746564 
 8251              	.LC2:
 8252 0043 20286E6F 		.ascii	" (no node to end)\012\000"
 8252      206E6F64 
 8252      6520746F 
 8252      20656E64 
 8252      290A00
 8253              	.LC3:
 8254 0056 554E4B4E 		.ascii	"UNKNOWN\000"
 8254      4F574E00 
 8255              	.LC4:
 8256 005e 25733A25 		.ascii	"%s:%d: An error was found (%s), loading aborted...\012"
 8256      643A2041 
 8256      6E206572 
 8256      726F7220 
 8256      77617320 
 8257 0091 00       		.ascii	"\000"
 8258              	.LC5:
 8259 0092 3C21444F 		.ascii	"<!DOCTYPE\000"
 8259      43545950 
 8259      4500
 8260              	.LC6:
 8261 009c 2F3E00   		.ascii	"/>\000"
 8262              	.LC7:
 8263 009f 0A574520 		.ascii	"\012WE SHOULD NOT BE HERE!\012[%s]\012\012\000"
 8263      53484F55 
 8263      4C44204E 
 8263      4F542042 
 8263      45204845 
 8264              	.LC8:
 8265 00be 5D3E00   		.ascii	"]>\000"
 8266              	.LC9:
 8267 00c1 00       		.ascii	"\000"
 8268              	.LC10:
 8269 00c2 2E2E2E00 		.ascii	"...\000"
 8270              	.LC11:
 8271 00c6 25733A25 		.ascii	"%s:%d: MEMORY ERROR.\012\000"
 8271      643A204D 
 8271      454D4F52 
 8271      59204552 
 8271      524F522E 
 8272              	.LC12:
 8273 00dc 25733A25 		.ascii	"%s:%d: ERROR: Unexpected end character '>', without"
 8273      643A2045 
 8273      52524F52 
 8273      3A20556E 
 8273      65787065 
 8274 010f 206D6174 		.ascii	" matching '<'!\012\000"
 8274      6368696E 
 8274      6720273C 
 8274      27210A00 
 8275              	.LC13:
 8276 011f 25733A25 		.ascii	"%s:%d: SYNTAX ERROR (%s%s).\012\000"
 8276      643A2053 
 8276      594E5441 
 8276      58204552 
 8276      524F5220 
 8277              	.LC14:
 8278 013c 25733A25 		.ascii	"%s:%d: SYNTAX ERROR.\012\000"
 8278      643A2053 
 8278      594E5441 
 8278      58204552 
 8278      524F522E 
 8279              	.LC15:
 8280 0152 25733A25 		.ascii	"%s:%d: PARSE ERROR.\012\000"
 8280      643A2050 
 8280      41525345 
 8280      20455252 
 8280      4F522E0A 
 8281              	.LC16:
 8282 0167 727400   		.ascii	"rt\000"
 8283              	.LC17:
 8284 016a 5D00     		.ascii	"]\000"
 8285              	.LC18:
 8286 016c 3C21444F 		.ascii	"<!DOCTYPE%s%s>\000"
 8286      43545950 
 8286      45257325 
 8286      733E00
 8287              	.LC19:
 8288 017b 25732573 		.ascii	"%s%s%s\000"
 8288      257300
 8289              	.LC20:
 8290 0182 3C257300 		.ascii	"<%s\000"
 8291              	.LC21:
 8292 0186 25733D00 		.ascii	"%s=\000"
 8293              	.LC22:
 8294 018a 2025733D 		.ascii	" %s=\000"
 8294      00
 8295              	.LC23:
 8296 018f 3C2F2573 		.ascii	"</%s>\000"
 8296      3E00
 8297              	.LC24:
 8298 0195 554E4558 		.ascii	"UNEXPECTED_NODE_END\000"
 8298      50454354 
 8298      45445F4E 
 8298      4F44455F 
 8298      454E4400 
 8299              	.LC25:
 8300 01a9 54455854 		.ascii	"TEXT_OUTSIDE_NODE\000"
 8300      5F4F5554 
 8300      53494445 
 8300      5F4E4F44 
 8300      4500
 8301              	.LC26:
 8302 01bb 554E4558 		.ascii	"UNEXPECTED_END_OF_FILE\000"
 8302      50454354 
 8302      45445F45 
 8302      4E445F4F 
 8302      465F4649 
 8303              	.LC27:
 8304 01d2 53594E54 		.ascii	"SYNTAX\000"
 8304      415800
 8305              	.LC28:
 8306 01d9 554E4558 		.ascii	"UNEXPECTED_TAG_END\000"
 8306      50454354 
 8306      45445F54 
 8306      41475F45 
 8306      4E4400
 8307              	.LC29:
 8308 01ec 4D454D4F 		.ascii	"MEMORY\000"
 8308      525900
 8309              	.LC30:
 8310 01f3 266C743B 		.ascii	"&lt;\000"
 8310      00
 8311              	.LC31:
 8312 01f8 2667743B 		.ascii	"&gt;\000"
 8312      00
 8313              	.LC32:
 8314 01fd 2671756F 		.ascii	"&quot;\000"
 8314      743B00
 8315              	.LC33:
 8316 0204 2661706F 		.ascii	"&apos;\000"
 8316      733B00
 8317              	.LC34:
 8318 020b 26616D70 		.ascii	"&amp;\000"
 8318      3B00
 8319              	.LC35:
 8320 0211 3C3F00   		.ascii	"<?\000"
 8321              	.LC36:
 8322 0214 3F3E00   		.ascii	"?>\000"
 8323              	.LC37:
 8324 0217 3C212D2D 		.ascii	"<!--\000"
 8324      00
 8325              	.LC38:
 8326 021c 2D2D3E00 		.ascii	"-->\000"
 8327              	.LC39:
 8328 0220 3C215B43 		.ascii	"<![CDATA[\000"
 8328      44415441 
 8328      5B00
 8329              	.LC40:
 8330 022a 5D5D3E00 		.ascii	"]]>\000"
 8331              		.section	.data._spec,"aw",%progbits
 8332              		.align	2
 8333              		.set	.LANCHOR3,. + 0
 8336              	_spec:
 8337 0000 04       		.byte	4
 8338 0001 000000   		.space	3
 8339 0004 11020000 		.word	.LC35
 8340 0008 02000000 		.word	2
 8341 000c 14020000 		.word	.LC36
 8342 0010 02000000 		.word	2
 8343 0014 05       		.byte	5
 8344 0015 000000   		.space	3
 8345 0018 17020000 		.word	.LC37
 8346 001c 04000000 		.word	4
 8347 0020 1C020000 		.word	.LC38
 8348 0024 03000000 		.word	3
 8349 0028 06       		.byte	6
 8350 0029 000000   		.space	3
 8351 002c 20020000 		.word	.LC39
 8352 0030 09000000 		.word	9
 8353 0034 2A020000 		.word	.LC40
 8354 0038 03000000 		.word	3
 8355              		.section	.rodata.HTML_SPECIAL_DICT,"a",%progbits
 8356              		.align	2
 8357              		.set	.LANCHOR2,. + 0
 8360              	HTML_SPECIAL_DICT:
 8361 0000 3C       		.byte	60
 8362 0001 000000   		.space	3
 8363 0004 F3010000 		.word	.LC30
 8364 0008 04000000 		.word	4
 8365 000c 3E       		.byte	62
 8366 000d 000000   		.space	3
 8367 0010 F8010000 		.word	.LC31
 8368 0014 04000000 		.word	4
 8369 0018 22       		.byte	34
 8370 0019 000000   		.space	3
 8371 001c FD010000 		.word	.LC32
 8372 0020 06000000 		.word	6
 8373 0024 27       		.byte	39
 8374 0025 000000   		.space	3
 8375 0028 04020000 		.word	.LC33
 8376 002c 06000000 		.word	6
 8377 0030 26       		.byte	38
 8378 0031 000000   		.space	3
 8379 0034 0B020000 		.word	.LC34
 8380 0038 05000000 		.word	5
 8381 003c 00       		.byte	0
 8382 003d 000000   		.space	3
 8383 0040 00000000 		.word	0
 8384 0044 00000000 		.word	0
 8385              		.section	.rodata.CSWTCH.146,"a",%progbits
 8386              		.align	2
 8387              		.set	.LANCHOR1,. + 0
 8390              	CSWTCH.146:
 8391 0000 95010000 		.word	.LC24
 8392 0004 A9010000 		.word	.LC25
 8393 0008 BB010000 		.word	.LC26
 8394 000c D2010000 		.word	.LC27
 8395 0010 D9010000 		.word	.LC28
 8396 0014 EC010000 		.word	.LC29
 8397              		.text
 8398              	.Letext0:
 8399              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 8400              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\sys\
 8401              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\sys\
 8402              		.file 5 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\sys\
 8403              		.file 6 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdi
 8404              		.file 7 "sxmlc/sxmlc.h"
 8405              		.file 8 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\ctyp
 8406              		.file 9 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdl
 8407              		.file 10 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\str
 8408              		.file 11 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:00000000 sxmlc.c
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:19     .text._count_new_char_line:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:23     .text._count_new_char_line:00000000 _count_new_char_line
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:67     .text.DOMXMLDoc_doc_start:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:72     .text.DOMXMLDoc_doc_start:00000000 DOMXMLDoc_doc_start
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:98     .text.DOMXMLDoc_parse_error:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:103    .text.DOMXMLDoc_parse_error:00000000 DOMXMLDoc_parse_error
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:126    .text._bgetc:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:131    .text._bgetc:00000000 _bgetc
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:162    .text._beob:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:167    .text._beob:00000000 _beob
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:196    .text._add_node:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:200    .text._add_node:00000000 _add_node
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:256    .text._parse_special_tag:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:260    .text._parse_special_tag:00000000 _parse_special_tag
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:350    .text.DOMXMLDoc_node_end:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:355    .text.DOMXMLDoc_node_end:00000000 DOMXMLDoc_node_end
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:448    .text.DOMXMLDoc_node_end:0000005c $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:456    .text._print_formatting.isra.0:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:460    .text._print_formatting.isra.0:00000000 _print_formatting.isra.0
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:535    .text.XML_register_user_tag:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:540    .text.XML_register_user_tag:00000000 XML_register_user_tag
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:657    .text.XML_register_user_tag:00000080 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:662    .text.XML_unregister_user_tag:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:667    .text.XML_unregister_user_tag:00000000 XML_unregister_user_tag
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:758    .text.XML_unregister_user_tag:00000070 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:763    .text.XML_get_nb_registered_user_tags:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:768    .text.XML_get_nb_registered_user_tags:00000000 XML_get_nb_registered_user_tags
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:782    .text.XML_get_nb_registered_user_tags:00000008 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:787    .text.XML_get_registered_user_tag:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:792    .text.XML_get_registered_user_tag:00000000 XML_get_registered_user_tag
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:838    .text.XML_get_registered_user_tag:00000028 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:843    .text.XMLNode_init:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:848    .text.XMLNode_init:00000000 XMLNode_init
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:895    .text.XMLNode_init:00000028 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:900    .text.XMLNode_allocN:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:905    .text.XMLNode_allocN:00000000 XMLNode_allocN
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:958    .text.XMLNode_set_active:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:963    .text.XMLNode_set_active:00000000 XMLNode_set_active
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:995    .text.XMLNode_set_active:00000014 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1000   .text.XMLNode_set_tag:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1005   .text.XMLNode_set_tag:00000000 XMLNode_set_tag
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1062   .text.XMLNode_set_tag:00000030 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1067   .text.XMLNode_set_type:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1072   .text.XMLNode_set_type:00000000 XMLNode_set_type
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1114   .text.XMLNode_set_type:00000028 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1119   .text.XMLNode_get_attribute_count:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1124   .text.XMLNode_get_attribute_count:00000000 XMLNode_get_attribute_count
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1180   .text.XMLNode_get_attribute_count:00000034 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1185   .text.XMLNode_search_attribute:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1190   .text.XMLNode_search_attribute:00000000 XMLNode_search_attribute
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1255   .text.XMLNode_set_attribute:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1260   .text.XMLNode_set_attribute:00000000 XMLNode_set_attribute
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1423   .text.XMLNode_set_attribute:000000b4 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1428   .text.XMLNode_get_attribute_with_default:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1433   .text.XMLNode_get_attribute_with_default:00000000 XMLNode_get_attribute_with_default
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1534   .text.XMLNode_get_attribute_with_default:00000060 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1539   .text.XMLNode_remove_attribute:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1544   .text.XMLNode_remove_attribute:00000000 XMLNode_remove_attribute
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1662   .text.XMLNode_remove_attribute:00000088 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1667   .text.XMLNode_remove_all_attributes:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1672   .text.XMLNode_remove_all_attributes:00000000 XMLNode_remove_all_attributes
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1753   .text.XMLNode_remove_all_attributes:00000050 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1758   .text.XMLNode_set_text:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1763   .text.XMLNode_set_text:00000000 XMLNode_set_text
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1834   .text.XMLNode_set_text:00000040 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1839   .text.XMLNode_add_child:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1844   .text.XMLNode_add_child:00000000 XMLNode_add_child
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1902   .text.XMLNode_add_child:00000038 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1907   .text.XMLNode_get_children_count:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1912   .text.XMLNode_get_children_count:00000000 XMLNode_get_children_count
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1966   .text.XMLNode_get_children_count:00000030 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1971   .text.XMLNode_get_child:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:1976   .text.XMLNode_get_child:00000000 XMLNode_get_child
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2040   .text.XMLNode_get_child:0000003c $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2045   .text.XMLNode_remove_children:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2050   .text.XMLNode_remove_children:00000000 XMLNode_remove_children
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2135   .text.XMLNode_free:00000000 XMLNode_free
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2125   .text.XMLNode_remove_children:0000004c $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2130   .text.XMLNode_free:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2199   .text.XMLNode_free:0000003c $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2204   .text.XMLNode_copy:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2209   .text.XMLNode_copy:00000000 XMLNode_copy
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2409   .text.XMLNode_copy:000000fc $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2414   .text.XMLNode_dup:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2419   .text.XMLNode_dup:00000000 XMLNode_dup
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2482   .text.XMLNode_remove_child:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2487   .text.XMLNode_remove_child:00000000 XMLNode_remove_child
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2634   .text.XMLNode_remove_child:000000b0 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2639   .text.DOMXMLDoc_node_start:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2644   .text.DOMXMLDoc_node_start:00000000 DOMXMLDoc_node_start
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2749   .text.DOMXMLDoc_node_text:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2754   .text.DOMXMLDoc_node_text:00000000 DOMXMLDoc_node_text
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2939   .text.DOMXMLDoc_node_text:000000d4 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2944   .text.XMLNode_equal:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:2949   .text.XMLNode_equal:00000000 XMLNode_equal
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3099   .text.XMLNode_equal:000000c8 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3104   .text.XMLNode_next_sibling:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3109   .text.XMLNode_next_sibling:00000000 XMLNode_next_sibling
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3175   .text.XMLNode_next_sibling:00000040 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3180   .text.XMLNode_next:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3185   .text.XMLNode_next:00000000 XMLNode_next
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3243   .text.XMLNode_next:00000034 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3248   .text.XMLDoc_init:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3253   .text.XMLDoc_init:00000000 XMLDoc_init
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3285   .text.XMLDoc_init:00000020 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3290   .text.XMLDoc_free:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3295   .text.XMLDoc_free:00000000 XMLDoc_free
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3368   .text.XMLDoc_free:00000058 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3373   .text.DOMXMLDoc_doc_end:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3378   .text.DOMXMLDoc_doc_end:00000000 DOMXMLDoc_doc_end
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3446   .text.DOMXMLDoc_doc_end:00000040 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3454   .text.XMLDoc_set_root:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3459   .text.XMLDoc_set_root:00000000 XMLDoc_set_root
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3496   .text.XMLDoc_set_root:00000024 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3501   .text.XMLDoc_add_node:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3506   .text.XMLDoc_add_node:00000000 XMLDoc_add_node
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3562   .text.XMLDoc_add_node:00000044 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3567   .text.XMLDoc_remove_node:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3572   .text.XMLDoc_remove_node:00000000 XMLDoc_remove_node
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3689   .text.XMLDoc_remove_node:000000a4 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3694   .text.SAX_Callbacks_init:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3699   .text.SAX_Callbacks_init:00000000 SAX_Callbacks_init
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3734   .text.SAX_Callbacks_init_DOM:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3739   .text.SAX_Callbacks_init_DOM:00000000 SAX_Callbacks_init_DOM
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3779   .text.SAX_Callbacks_init_DOM:00000024 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3789   .text.read_line_alloc:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:3794   .text.read_line_alloc:00000000 read_line_alloc
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4076   .text.read_line_alloc:00000148 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4084   .text.strcat_alloc:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4089   .text.strcat_alloc:00000000 strcat_alloc
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4176   .text.strip_spaces:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4181   .text.strip_spaces:00000000 strip_spaces
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4348   .text.strip_spaces:000000ac $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4353   .text.str_unescape:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4358   .text.str_unescape:00000000 str_unescape
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4398   .text.split_left_right:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4403   .text.split_left_right:00000000 split_left_right
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4764   .text.split_left_right:00000194 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4769   .text.freadBOM:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:4774   .text.freadBOM:00000000 freadBOM
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:5037   .text.freadBOM:00000180 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:5043   .text.html2str:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:5048   .text.html2str:00000000 html2str
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:5142   .text.html2str:00000070 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:5147   .text.XML_parse_attribute_to:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:5152   .text.XML_parse_attribute_to:00000000 XML_parse_attribute_to
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:5400   .text.XML_parse_attribute_to:00000124 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:5405   .text.XML_parse_1string:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:5410   .text.XML_parse_1string:00000000 XML_parse_1string
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:5849   .text.XML_parse_1string:0000024c $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:5861   .text._parse_data_SAX:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:5865   .text._parse_data_SAX:00000000 _parse_data_SAX
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6326   .text._parse_data_SAX:00000260 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6337   .text._parse_data_SAX:00000280 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6663   .text._parse_data_SAX:0000044c $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6671   .text.XMLDoc_parse_file_SAX:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6676   .text.XMLDoc_parse_file_SAX:00000000 XMLDoc_parse_file_SAX
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6750   .text.XMLDoc_parse_file_SAX:00000044 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6755   .text.XMLDoc_parse_file_DOM_text_as_nodes:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6760   .text.XMLDoc_parse_file_DOM_text_as_nodes:00000000 XMLDoc_parse_file_DOM_text_as_nodes
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6853   .text.XMLDoc_parse_file_DOM_text_as_nodes:00000064 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6858   .text.XMLDoc_parse_buffer_SAX:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6863   .text.XMLDoc_parse_buffer_SAX:00000000 XMLDoc_parse_buffer_SAX
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6914   .text.XMLDoc_parse_buffer_DOM_text_as_nodes:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6919   .text.XMLDoc_parse_buffer_DOM_text_as_nodes:00000000 XMLDoc_parse_buffer_DOM_text_as_nodes
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:6996   .text.XMLDoc_parse_buffer_DOM_text_as_nodes:00000048 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7001   .text.strlen_html:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7006   .text.strlen_html:00000000 strlen_html
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7067   .text.strlen_html:00000030 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7072   .text.str2html:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7077   .text.str2html:00000000 str2html
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7187   .text.str2html:00000064 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7192   .text.fprintHTML:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7197   .text.fprintHTML:00000000 fprintHTML
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7272   .text.fprintHTML:00000044 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7277   .text._XMLNode_print_header:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7281   .text._XMLNode_print_header:00000000 _XMLNode_print_header
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7656   .text._XMLNode_print_header:0000021c $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7670   .text.XMLNode_print_header:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7675   .text.XMLNode_print_header:00000000 XMLNode_print_header
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7714   .text._XMLNode_print:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7718   .text._XMLNode_print:00000000 _XMLNode_print
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7965   .text._XMLNode_print:00000144 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7971   .text.XMLNode_print_attr_sep:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:7976   .text.XMLNode_print_attr_sep:00000000 XMLNode_print_attr_sep
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8012   .text.XMLDoc_print_attr_sep:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8017   .text.XMLDoc_print_attr_sep:00000000 XMLDoc_print_attr_sep
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8111   .text.XMLDoc_print_attr_sep:00000068 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8116   .text.regstrcmp:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8121   .text.regstrcmp:00000000 regstrcmp
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8240   .bss._user_tags:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8244   .bss._user_tags:00000000 _user_tags
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8332   .data._spec:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8336   .data._spec:00000000 _spec
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8356   .rodata.HTML_SPECIAL_DICT:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8360   .rodata.HTML_SPECIAL_DICT:00000000 HTML_SPECIAL_DICT
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8386   .rodata.CSWTCH.146:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccwnvGca.s:8390   .rodata.CSWTCH.146:00000000 CSWTCH.146
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
realloc
strncmp
malloc
strncpy
strcmp
fprintf
fputs
_impure_ptr
strlen
memcpy
free
calloc
strdup
strcpy
strcat
__ctype_ptr__
fgetc
feof
ftell
fread
fseek
strchr
fopen
fclose
fputc
