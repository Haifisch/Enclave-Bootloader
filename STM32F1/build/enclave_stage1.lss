
build/enclave_stage1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000f0  00000000  00000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00007428  000000f0  000000f0  000080f0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         00000488  20000000  00007518  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0000012c  20000488  000079a0  00010488  2**2
                  ALLOC
  4 .bss.bIntPackSOF 00000001  200005b4  00007acc  00010488  2**0
                  ALLOC
  5 .bss.bDeviceState 00000004  200005b8  00007ad0  00010488  2**2
                  ALLOC
  6 .bss.recvBuffer 00000800  200005bc  00007ad4  00010488  2**2
                  ALLOC
  7 .bss.uploadBlockLen 00000002  20000dbc  000082d4  00010488  2**1
                  ALLOC
  8 .bss.thisBlockLen 00000002  20000dbe  000082d6  00010488  2**1
                  ALLOC
  9 .bss.userFirmwareLen 00000004  20000dc0  000082d8  00010488  2**2
                  ALLOC
 10 .bss.userUploadType 00000001  20000dc4  000082dc  00010488  2**0
                  ALLOC
 11 .bss.dfuAppStatus 00000006  20000dc5  000082dd  00010488  2**0
                  ALLOC
 12 .bss.dfuBusy  00000001  20000dcb  000082e3  00010488  2**0
                  ALLOC
 13 .bss.Data_Mul_MaxPacketSize 00000001  20000dcc  000082e4  00010488  2**0
                  ALLOC
 14 .bss.__malloc_sbrk_start 00000004  20000dd0  000082e8  00010488  2**2
                  ALLOC
 15 .bss.__malloc_free_list 00000004  20000dd4  000082ec  00010488  2**2
                  ALLOC
 16 .bss.heap_end.4246 00000004  20000dd8  000082f0  00010488  2**2
                  ALLOC
 17 ._usrstack    00000100  20000ddc  000082f4  00010488  2**0
                  ALLOC
 18 .comment      00000070  00000000  00000000  00010488  2**0
                  CONTENTS, READONLY
 19 .ARM.attributes 0000002f  00000000  00000000  000104f8  2**0
                  CONTENTS, READONLY
 20 .debug_aranges 00000860  00000000  00000000  00010528  2**3
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_info   0000afe2  00000000  00000000  00010d88  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_abbrev 0000297e  00000000  00000000  0001bd6a  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_line   00003cbe  00000000  00000000  0001e6e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_frame  0000181c  00000000  00000000  000223a8  2**2
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_str    00002398  00000000  00000000  00023bc4  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_loc    00009c45  00000000  00000000  00025f5c  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_ranges 00000f70  00000000  00000000  0002fba8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .isr_vector:

00000000 <g_pfnVectors>:




.thumb_func
__WFE:
   0:	20005000 	andcs	r5, r0, r0




.thumb_func
__SEV:
   4:	00000b4d 	andeq	r0, r0, sp, asr #22




.thumb_func
__ISB:
   8:	00000b95 	muleq	r0, r5, fp




.thumb_func
__DSB:
   c:	00000b95 	muleq	r0, r5, fp

  10:	00000b95 	muleq	r0, r5, fp




.thumb_func
__DMB:
  14:	00000b95 	muleq	r0, r5, fp




.thumb_func
__SVC:
  18:	00000b95 	muleq	r0, r5, fp
	...



.thumb_func
__MRS_PSP:

  2c:	00000b95 	muleq	r0, r5, fp
  MRS r0, psp
  30:	00000b95 	muleq	r0, r5, fp




.thumb_func
__MSR_PSP:
  34:	00000000 	andeq	r0, r0, r0




.thumb_func
__MRS_MSP:
  38:	00000b95 	muleq	r0, r5, fp

  3c:	00000b95 	muleq	r0, r5, fp




.thumb_func
__MSR_MSP:
  40:	00000b95 	muleq	r0, r5, fp




.thumb_func
__RESETPRIMASK:
  44:	00000b95 	muleq	r0, r5, fp

  48:	00000b95 	muleq	r0, r5, fp



.thumb_func
__SETPRIMASK:

  4c:	00000b95 	muleq	r0, r5, fp



.thumb_func
__READ_PRIMASK:

  50:	00000b95 	muleq	r0, r5, fp




.thumb_func
__RESETFAULTMASK:
  54:	00000b95 	muleq	r0, r5, fp




.thumb_func
__SETFAULTMASK:
  58:	00000b95 	muleq	r0, r5, fp




.thumb_func
__READ_FAULTMASK:
  5c:	00000b95 	muleq	r0, r5, fp




.thumb_func
__BASEPRICONFIG:
  60:	00000b95 	muleq	r0, r5, fp

  64:	00000b95 	muleq	r0, r5, fp




.thumb_func
__GetBASEPRI:
  68:	00000b95 	muleq	r0, r5, fp



.thumb_func
__REV_HalfWord:

  6c:	00000b95 	muleq	r0, r5, fp
  REV16 r0, r0
  70:	00000b95 	muleq	r0, r5, fp



.thumb_func
__REV_Word:

  74:	00000b95 	muleq	r0, r5, fp
  78:	00000b95 	muleq	r0, r5, fp
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
	f25519_sub(b, x3, z3); /* D */
  7c:	00000b95 	muleq	r0, r5, fp
  80:	00000b95 	muleq	r0, r5, fp
	f25519_mul__distinct(da, a, b);
  84:	00000b95 	muleq	r0, r5, fp
  88:	00000b95 	muleq	r0, r5, fp
  8c:	00000b95 	muleq	r0, r5, fp

	f25519_sub(b, x2, z2);
  90:	00000f81 	andeq	r0, r0, r1, lsl #31
  94:	00000b95 	muleq	r0, r5, fp
	f25519_add(a, x3, z3); /* C */
  98:	00000b95 	muleq	r0, r5, fp
  9c:	00000b95 	muleq	r0, r5, fp
  a0:	00000b95 	muleq	r0, r5, fp
	f25519_mul__distinct(cb, a, b);
  a4:	00000b95 	muleq	r0, r5, fp
  a8:	00000b95 	muleq	r0, r5, fp

	f25519_add(a, da, cb);
  ac:	00000b95 	muleq	r0, r5, fp
  b0:	00000b95 	muleq	r0, r5, fp
  b4:	00000b95 	muleq	r0, r5, fp
	f25519_mul__distinct(b, a, a);
  b8:	00000b95 	muleq	r0, r5, fp
  bc:	00000b95 	muleq	r0, r5, fp
	f25519_mul__distinct(x5, z1, b);
  c0:	00000b95 	muleq	r0, r5, fp
  c4:	00000b95 	muleq	r0, r5, fp
  c8:	00000b95 	muleq	r0, r5, fp

	f25519_sub(a, da, cb);
  cc:	00000b95 	muleq	r0, r5, fp
  d0:	00000b95 	muleq	r0, r5, fp
	f25519_mul__distinct(b, a, a);
  d4:	00000b95 	muleq	r0, r5, fp
  d8:	00000b95 	muleq	r0, r5, fp
  dc:	00000b95 	muleq	r0, r5, fp
	f25519_mul__distinct(z5, x1, b);
  e0:	00000b95 	muleq	r0, r5, fp
  e4:	00000b95 	muleq	r0, r5, fp
	uint8_t x1sq[F25519_SIZE];
	uint8_t z1sq[F25519_SIZE];
	uint8_t x1z1[F25519_SIZE];
	uint8_t a[F25519_SIZE];

	f25519_mul__distinct(x1sq, x1, x1);
  e8:	00000b95 	muleq	r0, r5, fp
  ec:	f108f85f 			; <UNDEFINED> instruction: 0xf108f85f

Disassembly of section .text:

000000f0 <GPIO_DeInit>:
      f0:	b508      	push	{r3, lr}
	f25519_mul__distinct(z1sq, z1, z1);
      f2:	4b2f      	ldr	r3, [pc, #188]	; (1b0 <_Minimum_Stack_Size+0xb0>)
      f4:	4298      	cmp	r0, r3
      f6:	d01e      	beq.n	136 <_Minimum_Stack_Size+0x36>
      f8:	4b2e      	ldr	r3, [pc, #184]	; (1b4 <_Minimum_Stack_Size+0xb4>)
      fa:	4298      	cmp	r0, r3
	f25519_mul__distinct(x1z1, x1, z1);
      fc:	d025      	beq.n	14a <_Minimum_Stack_Size+0x4a>
      fe:	4b2e      	ldr	r3, [pc, #184]	; (1b8 <_Minimum_Stack_Size+0xb8>)
     100:	4298      	cmp	r0, r3
     102:	d02c      	beq.n	15e <_Minimum_Stack_Size+0x5e>
     104:	4b2d      	ldr	r3, [pc, #180]	; (1bc <_Minimum_Stack_Size+0xbc>)

	f25519_sub(a, x1sq, z1sq);
     106:	4298      	cmp	r0, r3
     108:	d033      	beq.n	172 <_Minimum_Stack_Size+0x72>
     10a:	4b2d      	ldr	r3, [pc, #180]	; (1c0 <_Minimum_Stack_Size+0xc0>)
     10c:	4298      	cmp	r0, r3
     10e:	d03a      	beq.n	186 <_Minimum_Stack_Size+0x86>
	f25519_mul__distinct(x3, a, a);
     110:	4b2c      	ldr	r3, [pc, #176]	; (1c4 <_Minimum_Stack_Size+0xc4>)
     112:	4298      	cmp	r0, r3
     114:	d041      	beq.n	19a <_Minimum_Stack_Size+0x9a>
     116:	4b2c      	ldr	r3, [pc, #176]	; (1c8 <_Minimum_Stack_Size+0xc8>)
     118:	4298      	cmp	r0, r3

	f25519_mul_c(a, x1z1, 486662);
     11a:	d000      	beq.n	11e <_Minimum_Stack_Size+0x1e>
     11c:	bd08      	pop	{r3, pc}
     11e:	f44f 7080 	mov.w	r0, #256	; 0x100
     122:	2101      	movs	r1, #1
	f25519_add(a, x1sq, a);
     124:	f000 faac 	bl	680 <RCC_APB2PeriphResetCmd>
     128:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     12c:	f44f 7080 	mov.w	r0, #256	; 0x100
	f25519_add(a, z1sq, a);
     130:	2100      	movs	r1, #0
     132:	f000 baa5 	b.w	680 <RCC_APB2PeriphResetCmd>
     136:	2004      	movs	r0, #4
	f25519_mul__distinct(x1sq, x1z1, a);
     138:	2101      	movs	r1, #1
     13a:	f000 faa1 	bl	680 <RCC_APB2PeriphResetCmd>
     13e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	f25519_mul_c(z3, x1sq, 4);
     142:	2004      	movs	r0, #4
     144:	2100      	movs	r1, #0
     146:	f000 ba9b 	b.w	680 <RCC_APB2PeriphResetCmd>
     14a:	2008      	movs	r0, #8
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	2101      	movs	r1, #1
     14e:	f000 fa97 	bl	680 <RCC_APB2PeriphResetCmd>
     152:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	f25519_sub(b, x3, z3); /* D */
     156:	2008      	movs	r0, #8
     158:	2100      	movs	r1, #0
     15a:	f000 ba91 	b.w	680 <RCC_APB2PeriphResetCmd>
     15e:	2010      	movs	r0, #16
	f25519_mul__distinct(da, a, b);
     160:	2101      	movs	r1, #1
     162:	f000 fa8d 	bl	680 <RCC_APB2PeriphResetCmd>
     166:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	f25519_sub(b, x2, z2);
     16a:	2010      	movs	r0, #16
     16c:	2100      	movs	r1, #0
     16e:	f000 ba87 	b.w	680 <RCC_APB2PeriphResetCmd>
     172:	2020      	movs	r0, #32
	f25519_add(a, x3, z3); /* C */
     174:	2101      	movs	r1, #1
     176:	f000 fa83 	bl	680 <RCC_APB2PeriphResetCmd>
     17a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	f25519_mul__distinct(cb, a, b);
     17e:	2020      	movs	r0, #32
     180:	2100      	movs	r1, #0
     182:	f000 ba7d 	b.w	680 <RCC_APB2PeriphResetCmd>
     186:	2040      	movs	r0, #64	; 0x40

	f25519_add(a, da, cb);
     188:	2101      	movs	r1, #1
     18a:	f000 fa79 	bl	680 <RCC_APB2PeriphResetCmd>
     18e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	f25519_mul__distinct(b, a, a);
     192:	2040      	movs	r0, #64	; 0x40
     194:	2100      	movs	r1, #0
     196:	f000 ba73 	b.w	680 <RCC_APB2PeriphResetCmd>
     19a:	2080      	movs	r0, #128	; 0x80
	f25519_mul__distinct(x5, z1, b);
     19c:	2101      	movs	r1, #1
     19e:	f000 fa6f 	bl	680 <RCC_APB2PeriphResetCmd>
     1a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	f25519_sub(a, da, cb);
     1a6:	2080      	movs	r0, #128	; 0x80
     1a8:	2100      	movs	r1, #0
     1aa:	f000 ba69 	b.w	680 <RCC_APB2PeriphResetCmd>
     1ae:	bf00      	nop
	f25519_mul__distinct(b, a, a);
     1b0:	40010800 	andmi	r0, r1, r0, lsl #16
     1b4:	40010c00 	andmi	r0, r1, r0, lsl #24
     1b8:	40011000 	andmi	r1, r1, r0

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	40011400 	andmi	r1, r1, r0, lsl #8
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	40011800 	andmi	r1, r1, r0, lsl #16
     1c4:	40011c00 	andmi	r1, r1, r0, lsl #24

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1c8:	40012000 	andmi	r2, r1, r0

000001cc <GPIO_AFIODeInit>:
     1cc:	b508      	push	{r3, lr}
     1ce:	2001      	movs	r0, #1
     1d0:	4601      	mov	r1, r0
     1d2:	f000 fa55 	bl	680 <RCC_APB2PeriphResetCmd>
		f25519_select(zm1, zm1, zm, bit);
     1d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     1da:	2001      	movs	r0, #1
     1dc:	2100      	movs	r1, #0
     1de:	f000 ba4f 	b.w	680 <RCC_APB2PeriphResetCmd>
		f25519_select(xm, xm, xms, bit);
     1e2:	bf00      	nop

000001e4 <GPIO_Init>:
     1e4:	78cb      	ldrb	r3, [r1, #3]
     1e6:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
     1ea:	f003 060f 	and.w	r6, r3, #15
		f25519_select(zm, zm, zms, bit);
     1ee:	06db      	lsls	r3, r3, #27
     1f0:	bf48      	it	mi
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1f2:	788b      	ldrbmi	r3, [r1, #2]
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
		f25519_select(zm1, zm1, zm, bit);
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
     1f4:	880a      	ldrh	r2, [r1, #0]
     1f6:	bf48      	it	mi
     1f8:	431e      	orrmi	r6, r3
     1fa:	f012 0fff 	tst.w	r2, #255	; 0xff
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fe:	d026      	beq.n	24e <GPIO_Init+0x6a>
     200:	6807      	ldr	r7, [r0, #0]
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     202:	2300      	movs	r3, #0
     204:	2501      	movs	r5, #1
     206:	f04f 080f 	mov.w	r8, #15
	f25519_mul__distinct(result, zm1, xm);
     20a:	e003      	b.n	214 <GPIO_Init+0x30>
     20c:	3301      	adds	r3, #1
     20e:	2b08      	cmp	r3, #8
     210:	d01b      	beq.n	24a <GPIO_Init+0x66>
     212:	880a      	ldrh	r2, [r1, #0]
	f25519_normalize(result);
     214:	fa05 f403 	lsl.w	r4, r5, r3
     218:	4022      	ands	r2, r4
}
     21a:	42a2      	cmp	r2, r4
     21c:	d1f6      	bne.n	20c <GPIO_Init+0x28>
     21e:	009c      	lsls	r4, r3, #2
     220:	fa08 f904 	lsl.w	r9, r8, r4
     224:	fa06 f404 	lsl.w	r4, r6, r4
     228:	f891 c003 	ldrb.w	ip, [r1, #3]
     22c:	ea27 0709 	bic.w	r7, r7, r9
     230:	f1bc 0f28 	cmp.w	ip, #40	; 0x28
     234:	ea47 0704 	orr.w	r7, r7, r4
     238:	d034      	beq.n	2a4 <GPIO_Init+0xc0>
     23a:	f1bc 0f48 	cmp.w	ip, #72	; 0x48
     23e:	f103 0301 	add.w	r3, r3, #1
     242:	bf08      	it	eq
     244:	6102      	streq	r2, [r0, #16]
     246:	2b08      	cmp	r3, #8
     248:	d1e3      	bne.n	212 <GPIO_Init+0x2e>
     24a:	6007      	str	r7, [r0, #0]
     24c:	880a      	ldrh	r2, [r1, #0]
     24e:	2aff      	cmp	r2, #255	; 0xff
     250:	d925      	bls.n	29e <GPIO_Init+0xba>
     252:	6847      	ldr	r7, [r0, #4]
     254:	2300      	movs	r3, #0
     256:	2501      	movs	r5, #1
     258:	f04f 0c0f 	mov.w	ip, #15
     25c:	e003      	b.n	266 <GPIO_Init+0x82>
     25e:	3301      	adds	r3, #1
     260:	2b08      	cmp	r3, #8
     262:	d01b      	beq.n	29c <GPIO_Init+0xb8>
     264:	880a      	ldrh	r2, [r1, #0]
     266:	f103 0408 	add.w	r4, r3, #8
     26a:	fa05 f404 	lsl.w	r4, r5, r4
     26e:	4022      	ands	r2, r4
     270:	42a2      	cmp	r2, r4
     272:	d1f4      	bne.n	25e <GPIO_Init+0x7a>
     274:	009c      	lsls	r4, r3, #2
     276:	fa0c f904 	lsl.w	r9, ip, r4
     27a:	fa06 f804 	lsl.w	r8, r6, r4
     27e:	78cc      	ldrb	r4, [r1, #3]
     280:	3301      	adds	r3, #1
     282:	2c28      	cmp	r4, #40	; 0x28
     284:	bf04      	itt	eq
     286:	6142      	streq	r2, [r0, #20]
     288:	78cc      	ldrbeq	r4, [r1, #3]
     28a:	ea27 0709 	bic.w	r7, r7, r9
     28e:	2c48      	cmp	r4, #72	; 0x48
     290:	bf08      	it	eq
     292:	6102      	streq	r2, [r0, #16]
     294:	2b08      	cmp	r3, #8
     296:	ea47 0708 	orr.w	r7, r7, r8
     29a:	d1e3      	bne.n	264 <GPIO_Init+0x80>
     29c:	6047      	str	r7, [r0, #4]
     29e:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
     2a2:	4770      	bx	lr
     2a4:	6142      	str	r2, [r0, #20]
     2a6:	e7b1      	b.n	20c <GPIO_Init+0x28>

000002a8 <GPIO_StructInit>:
     2a8:	f64f 71ff 	movw	r1, #65535	; 0xffff
     2ac:	2202      	movs	r2, #2
     2ae:	2304      	movs	r3, #4
     2b0:	8001      	strh	r1, [r0, #0]
     2b2:	7082      	strb	r2, [r0, #2]
     2b4:	70c3      	strb	r3, [r0, #3]
     2b6:	4770      	bx	lr

000002b8 <GPIO_ReadInputDataBit>:
     2b8:	6883      	ldr	r3, [r0, #8]
     2ba:	4219      	tst	r1, r3
     2bc:	bf0c      	ite	eq
     2be:	2000      	moveq	r0, #0
     2c0:	2001      	movne	r0, #1
     2c2:	4770      	bx	lr

000002c4 <GPIO_ReadInputData>:
     2c4:	6880      	ldr	r0, [r0, #8]
     2c6:	b280      	uxth	r0, r0
     2c8:	4770      	bx	lr
     2ca:	bf00      	nop

000002cc <GPIO_ReadOutputDataBit>:
     2cc:	68c3      	ldr	r3, [r0, #12]
     2ce:	4219      	tst	r1, r3
     2d0:	bf0c      	ite	eq
     2d2:	2000      	moveq	r0, #0
     2d4:	2001      	movne	r0, #1
     2d6:	4770      	bx	lr

000002d8 <GPIO_ReadOutputData>:
     2d8:	68c0      	ldr	r0, [r0, #12]
     2da:	b280      	uxth	r0, r0
     2dc:	4770      	bx	lr
     2de:	bf00      	nop

000002e0 <GPIO_SetBits>:
     2e0:	6101      	str	r1, [r0, #16]
     2e2:	4770      	bx	lr

000002e4 <GPIO_ResetBits>:
     2e4:	6141      	str	r1, [r0, #20]
     2e6:	4770      	bx	lr

000002e8 <GPIO_WriteBit>:
     2e8:	b90a      	cbnz	r2, 2ee <GPIO_WriteBit+0x6>
     2ea:	6141      	str	r1, [r0, #20]
     2ec:	4770      	bx	lr
     2ee:	6101      	str	r1, [r0, #16]
     2f0:	4770      	bx	lr
     2f2:	bf00      	nop

000002f4 <GPIO_Write>:
     2f4:	60c1      	str	r1, [r0, #12]
     2f6:	4770      	bx	lr

000002f8 <GPIO_PinLockConfig>:
     2f8:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
     2fc:	6183      	str	r3, [r0, #24]
     2fe:	6181      	str	r1, [r0, #24]
     300:	6183      	str	r3, [r0, #24]
     302:	6983      	ldr	r3, [r0, #24]
     304:	6983      	ldr	r3, [r0, #24]
     306:	4770      	bx	lr

00000308 <GPIO_EventOutputConfig>:
     308:	b410      	push	{r4}
     30a:	4b06      	ldr	r3, [pc, #24]	; (324 <GPIO_EventOutputConfig+0x1c>)
     30c:	f64f 7280 	movw	r2, #65408	; 0xff80
     310:	681c      	ldr	r4, [r3, #0]
     312:	4022      	ands	r2, r4
     314:	4311      	orrs	r1, r2
     316:	ea41 1000 	orr.w	r0, r1, r0, lsl #4
     31a:	6018      	str	r0, [r3, #0]
     31c:	f85d 4b04 	ldr.w	r4, [sp], #4
     320:	4770      	bx	lr
     322:	bf00      	nop
     324:	40010000 	andmi	r0, r1, r0

00000328 <GPIO_EventOutputCmd>:
     328:	4b01      	ldr	r3, [pc, #4]	; (330 <GPIO_EventOutputCmd+0x8>)
     32a:	6018      	str	r0, [r3, #0]
     32c:	4770      	bx	lr
     32e:	bf00      	nop
     330:	4220001c 	eormi	r0, r0, #28

00000334 <GPIO_PinRemapConfig>:
     334:	b430      	push	{r4, r5}
     336:	2800      	cmp	r0, #0
     338:	4b18      	ldr	r3, [pc, #96]	; (39c <GPIO_PinRemapConfig+0x68>)
     33a:	f400 1240 	and.w	r2, r0, #3145728	; 0x300000
     33e:	bfb4      	ite	lt
     340:	69db      	ldrlt	r3, [r3, #28]
     342:	685b      	ldrge	r3, [r3, #4]
     344:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
     348:	b284      	uxth	r4, r0
     34a:	d01f      	beq.n	38c <GPIO_PinRemapConfig+0x58>
     34c:	02c2      	lsls	r2, r0, #11
     34e:	d514      	bpl.n	37a <GPIO_PinRemapConfig+0x46>
     350:	f3c0 4203 	ubfx	r2, r0, #16, #4
     354:	2503      	movs	r5, #3
     356:	fa05 f202 	lsl.w	r2, r5, r2
     35a:	ea23 0302 	bic.w	r3, r3, r2
     35e:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
     362:	b119      	cbz	r1, 36c <GPIO_PinRemapConfig+0x38>
     364:	0d42      	lsrs	r2, r0, #21
     366:	0112      	lsls	r2, r2, #4
     368:	4094      	lsls	r4, r2
     36a:	4323      	orrs	r3, r4
     36c:	4a0b      	ldr	r2, [pc, #44]	; (39c <GPIO_PinRemapConfig+0x68>)
     36e:	2800      	cmp	r0, #0
     370:	bfb4      	ite	lt
     372:	61d3      	strlt	r3, [r2, #28]
     374:	6053      	strge	r3, [r2, #4]
     376:	bc30      	pop	{r4, r5}
     378:	4770      	bx	lr
     37a:	0d42      	lsrs	r2, r0, #21
     37c:	0112      	lsls	r2, r2, #4
     37e:	fa04 f202 	lsl.w	r2, r4, r2
     382:	ea23 0302 	bic.w	r3, r3, r2
     386:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
     38a:	e7ea      	b.n	362 <GPIO_PinRemapConfig+0x2e>
     38c:	4a03      	ldr	r2, [pc, #12]	; (39c <GPIO_PinRemapConfig+0x68>)
     38e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
     392:	6855      	ldr	r5, [r2, #4]
     394:	f025 6570 	bic.w	r5, r5, #251658240	; 0xf000000
     398:	6055      	str	r5, [r2, #4]
     39a:	e7e2      	b.n	362 <GPIO_PinRemapConfig+0x2e>
     39c:	40010000 	andmi	r0, r1, r0

000003a0 <GPIO_EXTILineConfig>:
     3a0:	f001 0303 	and.w	r3, r1, #3
     3a4:	009b      	lsls	r3, r3, #2
     3a6:	220f      	movs	r2, #15
     3a8:	409a      	lsls	r2, r3
     3aa:	fa00 f303 	lsl.w	r3, r0, r3
     3ae:	f001 01fc 	and.w	r1, r1, #252	; 0xfc
     3b2:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
     3b6:	f501 3180 	add.w	r1, r1, #65536	; 0x10000
     3ba:	6888      	ldr	r0, [r1, #8]
     3bc:	ea20 0202 	bic.w	r2, r0, r2
     3c0:	608a      	str	r2, [r1, #8]
     3c2:	688a      	ldr	r2, [r1, #8]
     3c4:	4313      	orrs	r3, r2
     3c6:	608b      	str	r3, [r1, #8]
     3c8:	4770      	bx	lr
     3ca:	bf00      	nop

000003cc <GPIO_ETH_MediaInterfaceConfig>:
     3cc:	4b01      	ldr	r3, [pc, #4]	; (3d4 <GPIO_ETH_MediaInterfaceConfig+0x8>)
     3ce:	6018      	str	r0, [r3, #0]
     3d0:	4770      	bx	lr
     3d2:	bf00      	nop
     3d4:	422000dc 	eormi	r0, r0, #220	; 0xdc

000003d8 <RCC_DeInit>:
     3d8:	4b0d      	ldr	r3, [pc, #52]	; (410 <RCC_DeInit+0x38>)
     3da:	4a0e      	ldr	r2, [pc, #56]	; (414 <RCC_DeInit+0x3c>)
     3dc:	6818      	ldr	r0, [r3, #0]
     3de:	f44f 011f 	mov.w	r1, #10420224	; 0x9f0000
     3e2:	f040 0001 	orr.w	r0, r0, #1
     3e6:	6018      	str	r0, [r3, #0]
     3e8:	6858      	ldr	r0, [r3, #4]
     3ea:	4002      	ands	r2, r0
     3ec:	605a      	str	r2, [r3, #4]
     3ee:	681a      	ldr	r2, [r3, #0]
     3f0:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
     3f4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
     3f8:	601a      	str	r2, [r3, #0]
     3fa:	681a      	ldr	r2, [r3, #0]
     3fc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
     400:	601a      	str	r2, [r3, #0]
     402:	685a      	ldr	r2, [r3, #4]
     404:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
     408:	605a      	str	r2, [r3, #4]
     40a:	6099      	str	r1, [r3, #8]
     40c:	4770      	bx	lr
     40e:	bf00      	nop
     410:	40021000 	andmi	r1, r2, r0
     414:	f8ff0000 			; <UNDEFINED> instruction: 0xf8ff0000

00000418 <RCC_HSEConfig>:
     418:	4b0c      	ldr	r3, [pc, #48]	; (44c <RCC_HSEConfig+0x34>)
     41a:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
     41e:	681a      	ldr	r2, [r3, #0]
     420:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
     424:	601a      	str	r2, [r3, #0]
     426:	681a      	ldr	r2, [r3, #0]
     428:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
     42c:	601a      	str	r2, [r3, #0]
     42e:	d008      	beq.n	442 <RCC_HSEConfig+0x2a>
     430:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
     434:	d104      	bne.n	440 <RCC_HSEConfig+0x28>
     436:	681a      	ldr	r2, [r3, #0]
     438:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
     43c:	601a      	str	r2, [r3, #0]
     43e:	4770      	bx	lr
     440:	4770      	bx	lr
     442:	681a      	ldr	r2, [r3, #0]
     444:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
     448:	601a      	str	r2, [r3, #0]
     44a:	4770      	bx	lr
     44c:	40021000 	andmi	r1, r2, r0

00000450 <RCC_WaitForHSEStartUp>:
     450:	b082      	sub	sp, #8
     452:	2300      	movs	r3, #0
     454:	4a0b      	ldr	r2, [pc, #44]	; (484 <RCC_WaitForHSEStartUp+0x34>)
     456:	9301      	str	r3, [sp, #4]
     458:	6813      	ldr	r3, [r2, #0]
     45a:	039b      	lsls	r3, r3, #14
     45c:	d40c      	bmi.n	478 <RCC_WaitForHSEStartUp+0x28>
     45e:	9b01      	ldr	r3, [sp, #4]
     460:	3301      	adds	r3, #1
     462:	9301      	str	r3, [sp, #4]
     464:	9b01      	ldr	r3, [sp, #4]
     466:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
     46a:	d1f5      	bne.n	458 <RCC_WaitForHSEStartUp+0x8>
     46c:	4b05      	ldr	r3, [pc, #20]	; (484 <RCC_WaitForHSEStartUp+0x34>)
     46e:	6818      	ldr	r0, [r3, #0]
     470:	f3c0 4040 	ubfx	r0, r0, #17, #1
     474:	b002      	add	sp, #8
     476:	4770      	bx	lr
     478:	9b01      	ldr	r3, [sp, #4]
     47a:	3301      	adds	r3, #1
     47c:	9301      	str	r3, [sp, #4]
     47e:	9b01      	ldr	r3, [sp, #4]
     480:	e7f4      	b.n	46c <RCC_WaitForHSEStartUp+0x1c>
     482:	bf00      	nop
     484:	40021000 	andmi	r1, r2, r0

00000488 <RCC_AdjustHSICalibrationValue>:
     488:	4b03      	ldr	r3, [pc, #12]	; (498 <RCC_AdjustHSICalibrationValue+0x10>)
     48a:	681a      	ldr	r2, [r3, #0]
     48c:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
     490:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
     494:	6018      	str	r0, [r3, #0]
     496:	4770      	bx	lr
     498:	40021000 	andmi	r1, r2, r0

0000049c <RCC_HSICmd>:
     49c:	4b01      	ldr	r3, [pc, #4]	; (4a4 <RCC_HSICmd+0x8>)
     49e:	6018      	str	r0, [r3, #0]
     4a0:	4770      	bx	lr
     4a2:	bf00      	nop
     4a4:	42420000 	submi	r0, r2, #0

000004a8 <RCC_PLLConfig>:
     4a8:	4b03      	ldr	r3, [pc, #12]	; (4b8 <RCC_PLLConfig+0x10>)
     4aa:	685a      	ldr	r2, [r3, #4]
     4ac:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
     4b0:	4311      	orrs	r1, r2
     4b2:	4308      	orrs	r0, r1
     4b4:	6058      	str	r0, [r3, #4]
     4b6:	4770      	bx	lr
     4b8:	40021000 	andmi	r1, r2, r0

000004bc <RCC_PLLCmd>:
     4bc:	4b01      	ldr	r3, [pc, #4]	; (4c4 <RCC_PLLCmd+0x8>)
     4be:	6018      	str	r0, [r3, #0]
     4c0:	4770      	bx	lr
     4c2:	bf00      	nop
     4c4:	42420060 	submi	r0, r2, #96	; 0x60

000004c8 <RCC_SYSCLKConfig>:
     4c8:	4b03      	ldr	r3, [pc, #12]	; (4d8 <RCC_SYSCLKConfig+0x10>)
     4ca:	685a      	ldr	r2, [r3, #4]
     4cc:	f022 0203 	bic.w	r2, r2, #3
     4d0:	4310      	orrs	r0, r2
     4d2:	6058      	str	r0, [r3, #4]
     4d4:	4770      	bx	lr
     4d6:	bf00      	nop
     4d8:	40021000 	andmi	r1, r2, r0

000004dc <RCC_GetSYSCLKSource>:
     4dc:	4b02      	ldr	r3, [pc, #8]	; (4e8 <RCC_GetSYSCLKSource+0xc>)
     4de:	6858      	ldr	r0, [r3, #4]
     4e0:	f000 000c 	and.w	r0, r0, #12
     4e4:	4770      	bx	lr
     4e6:	bf00      	nop
     4e8:	40021000 	andmi	r1, r2, r0

000004ec <RCC_HCLKConfig>:
     4ec:	4b03      	ldr	r3, [pc, #12]	; (4fc <RCC_HCLKConfig+0x10>)
     4ee:	685a      	ldr	r2, [r3, #4]
     4f0:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
     4f4:	4310      	orrs	r0, r2
     4f6:	6058      	str	r0, [r3, #4]
     4f8:	4770      	bx	lr
     4fa:	bf00      	nop
     4fc:	40021000 	andmi	r1, r2, r0

00000500 <RCC_PCLK1Config>:
     500:	4b03      	ldr	r3, [pc, #12]	; (510 <RCC_PCLK1Config+0x10>)
     502:	685a      	ldr	r2, [r3, #4]
     504:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
     508:	4310      	orrs	r0, r2
     50a:	6058      	str	r0, [r3, #4]
     50c:	4770      	bx	lr
     50e:	bf00      	nop
     510:	40021000 	andmi	r1, r2, r0

00000514 <RCC_PCLK2Config>:
     514:	4b03      	ldr	r3, [pc, #12]	; (524 <RCC_PCLK2Config+0x10>)
     516:	685a      	ldr	r2, [r3, #4]
     518:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
     51c:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
     520:	6058      	str	r0, [r3, #4]
     522:	4770      	bx	lr
     524:	40021000 	andmi	r1, r2, r0

00000528 <RCC_ITConfig>:
     528:	4b04      	ldr	r3, [pc, #16]	; (53c <RCC_ITConfig+0x14>)
     52a:	781a      	ldrb	r2, [r3, #0]
     52c:	b919      	cbnz	r1, 536 <RCC_ITConfig+0xe>
     52e:	ea22 0000 	bic.w	r0, r2, r0
     532:	7018      	strb	r0, [r3, #0]
     534:	4770      	bx	lr
     536:	4310      	orrs	r0, r2
     538:	7018      	strb	r0, [r3, #0]
     53a:	4770      	bx	lr
     53c:	40021009 	andmi	r1, r2, r9

00000540 <RCC_USBCLKConfig>:
     540:	4b01      	ldr	r3, [pc, #4]	; (548 <RCC_USBCLKConfig+0x8>)
     542:	6018      	str	r0, [r3, #0]
     544:	4770      	bx	lr
     546:	bf00      	nop
     548:	424200d8 	submi	r0, r2, #216	; 0xd8

0000054c <RCC_ADCCLKConfig>:
     54c:	4b03      	ldr	r3, [pc, #12]	; (55c <RCC_ADCCLKConfig+0x10>)
     54e:	685a      	ldr	r2, [r3, #4]
     550:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
     554:	4310      	orrs	r0, r2
     556:	6058      	str	r0, [r3, #4]
     558:	4770      	bx	lr
     55a:	bf00      	nop
     55c:	40021000 	andmi	r1, r2, r0

00000560 <RCC_LSEConfig>:
     560:	4b06      	ldr	r3, [pc, #24]	; (57c <RCC_LSEConfig+0x1c>)
     562:	2200      	movs	r2, #0
     564:	2801      	cmp	r0, #1
     566:	701a      	strb	r2, [r3, #0]
     568:	701a      	strb	r2, [r3, #0]
     56a:	d005      	beq.n	578 <RCC_LSEConfig+0x18>
     56c:	2804      	cmp	r0, #4
     56e:	d102      	bne.n	576 <RCC_LSEConfig+0x16>
     570:	2205      	movs	r2, #5
     572:	701a      	strb	r2, [r3, #0]
     574:	4770      	bx	lr
     576:	4770      	bx	lr
     578:	7018      	strb	r0, [r3, #0]
     57a:	4770      	bx	lr
     57c:	40021020 	andmi	r1, r2, r0, lsr #32

00000580 <RCC_LSICmd>:
     580:	4b01      	ldr	r3, [pc, #4]	; (588 <RCC_LSICmd+0x8>)
     582:	6018      	str	r0, [r3, #0]
     584:	4770      	bx	lr
     586:	bf00      	nop
     588:	42420480 	submi	r0, r2, #128, 8	; 0x80000000

0000058c <RCC_RTCCLKConfig>:
     58c:	4b02      	ldr	r3, [pc, #8]	; (598 <RCC_RTCCLKConfig+0xc>)
     58e:	6a1a      	ldr	r2, [r3, #32]
     590:	4310      	orrs	r0, r2
     592:	6218      	str	r0, [r3, #32]
     594:	4770      	bx	lr
     596:	bf00      	nop
     598:	40021000 	andmi	r1, r2, r0

0000059c <RCC_RTCCLKCmd>:
     59c:	4b01      	ldr	r3, [pc, #4]	; (5a4 <RCC_RTCCLKCmd+0x8>)
     59e:	6018      	str	r0, [r3, #0]
     5a0:	4770      	bx	lr
     5a2:	bf00      	nop
     5a4:	4242043c 	submi	r0, r2, #60, 8	; 0x3c000000

000005a8 <RCC_GetClocksFreq>:
     5a8:	b410      	push	{r4}
     5aa:	4a1f      	ldr	r2, [pc, #124]	; (628 <RCC_GetClocksFreq+0x80>)
     5ac:	6853      	ldr	r3, [r2, #4]
     5ae:	f003 030c 	and.w	r3, r3, #12
     5b2:	2b04      	cmp	r3, #4
     5b4:	d001      	beq.n	5ba <RCC_GetClocksFreq+0x12>
     5b6:	2b08      	cmp	r3, #8
     5b8:	d021      	beq.n	5fe <RCC_GetClocksFreq+0x56>
     5ba:	491c      	ldr	r1, [pc, #112]	; (62c <RCC_GetClocksFreq+0x84>)
     5bc:	6001      	str	r1, [r0, #0]
     5be:	4a1a      	ldr	r2, [pc, #104]	; (628 <RCC_GetClocksFreq+0x80>)
     5c0:	4b1b      	ldr	r3, [pc, #108]	; (630 <RCC_GetClocksFreq+0x88>)
     5c2:	6854      	ldr	r4, [r2, #4]
     5c4:	f3c4 1403 	ubfx	r4, r4, #4, #4
     5c8:	5d1c      	ldrb	r4, [r3, r4]
     5ca:	40e1      	lsrs	r1, r4
     5cc:	6041      	str	r1, [r0, #4]
     5ce:	6854      	ldr	r4, [r2, #4]
     5d0:	f3c4 2402 	ubfx	r4, r4, #8, #3
     5d4:	5d1c      	ldrb	r4, [r3, r4]
     5d6:	fa21 f404 	lsr.w	r4, r1, r4
     5da:	6084      	str	r4, [r0, #8]
     5dc:	6854      	ldr	r4, [r2, #4]
     5de:	f3c4 24c2 	ubfx	r4, r4, #11, #3
     5e2:	5d1c      	ldrb	r4, [r3, r4]
     5e4:	40e1      	lsrs	r1, r4
     5e6:	60c1      	str	r1, [r0, #12]
     5e8:	6852      	ldr	r2, [r2, #4]
     5ea:	f85d 4b04 	ldr.w	r4, [sp], #4
     5ee:	f3c2 3281 	ubfx	r2, r2, #14, #2
     5f2:	4413      	add	r3, r2
     5f4:	7c1b      	ldrb	r3, [r3, #16]
     5f6:	fbb1 f1f3 	udiv	r1, r1, r3
     5fa:	6101      	str	r1, [r0, #16]
     5fc:	4770      	bx	lr
     5fe:	6851      	ldr	r1, [r2, #4]
     600:	6853      	ldr	r3, [r2, #4]
     602:	f3c1 4183 	ubfx	r1, r1, #18, #4
     606:	03dc      	lsls	r4, r3, #15
     608:	f101 0102 	add.w	r1, r1, #2
     60c:	d507      	bpl.n	61e <RCC_GetClocksFreq+0x76>
     60e:	6853      	ldr	r3, [r2, #4]
     610:	039b      	lsls	r3, r3, #14
     612:	d404      	bmi.n	61e <RCC_GetClocksFreq+0x76>
     614:	4b05      	ldr	r3, [pc, #20]	; (62c <RCC_GetClocksFreq+0x84>)
     616:	fb03 f101 	mul.w	r1, r3, r1
     61a:	6001      	str	r1, [r0, #0]
     61c:	e7cf      	b.n	5be <RCC_GetClocksFreq+0x16>
     61e:	4b05      	ldr	r3, [pc, #20]	; (634 <RCC_GetClocksFreq+0x8c>)
     620:	fb03 f101 	mul.w	r1, r3, r1
     624:	6001      	str	r1, [r0, #0]
     626:	e7ca      	b.n	5be <RCC_GetClocksFreq+0x16>
     628:	40021000 	andmi	r1, r2, r0
     62c:	007a1200 	rsbseq	r1, sl, r0, lsl #4
     630:	20000000 	andcs	r0, r0, r0
     634:	003d0900 	eorseq	r0, sp, r0, lsl #18

00000638 <RCC_AHBPeriphClockCmd>:
     638:	4b04      	ldr	r3, [pc, #16]	; (64c <RCC_AHBPeriphClockCmd+0x14>)
     63a:	695a      	ldr	r2, [r3, #20]
     63c:	b919      	cbnz	r1, 646 <RCC_AHBPeriphClockCmd+0xe>
     63e:	ea22 0000 	bic.w	r0, r2, r0
     642:	6158      	str	r0, [r3, #20]
     644:	4770      	bx	lr
     646:	4310      	orrs	r0, r2
     648:	6158      	str	r0, [r3, #20]
     64a:	4770      	bx	lr
     64c:	40021000 	andmi	r1, r2, r0

00000650 <RCC_APB2PeriphClockCmd>:
     650:	4b04      	ldr	r3, [pc, #16]	; (664 <RCC_APB2PeriphClockCmd+0x14>)
     652:	699a      	ldr	r2, [r3, #24]
     654:	b919      	cbnz	r1, 65e <RCC_APB2PeriphClockCmd+0xe>
     656:	ea22 0000 	bic.w	r0, r2, r0
     65a:	6198      	str	r0, [r3, #24]
     65c:	4770      	bx	lr
     65e:	4310      	orrs	r0, r2
     660:	6198      	str	r0, [r3, #24]
     662:	4770      	bx	lr
     664:	40021000 	andmi	r1, r2, r0

00000668 <RCC_APB1PeriphClockCmd>:
     668:	4b04      	ldr	r3, [pc, #16]	; (67c <RCC_APB1PeriphClockCmd+0x14>)
     66a:	69da      	ldr	r2, [r3, #28]
     66c:	b919      	cbnz	r1, 676 <RCC_APB1PeriphClockCmd+0xe>
     66e:	ea22 0000 	bic.w	r0, r2, r0
     672:	61d8      	str	r0, [r3, #28]
     674:	4770      	bx	lr
     676:	4310      	orrs	r0, r2
     678:	61d8      	str	r0, [r3, #28]
     67a:	4770      	bx	lr
     67c:	40021000 	andmi	r1, r2, r0

00000680 <RCC_APB2PeriphResetCmd>:
     680:	4b04      	ldr	r3, [pc, #16]	; (694 <RCC_APB2PeriphResetCmd+0x14>)
     682:	68da      	ldr	r2, [r3, #12]
     684:	b919      	cbnz	r1, 68e <RCC_APB2PeriphResetCmd+0xe>
     686:	ea22 0000 	bic.w	r0, r2, r0
     68a:	60d8      	str	r0, [r3, #12]
     68c:	4770      	bx	lr
     68e:	4310      	orrs	r0, r2
     690:	60d8      	str	r0, [r3, #12]
     692:	4770      	bx	lr
     694:	40021000 	andmi	r1, r2, r0

00000698 <RCC_APB1PeriphResetCmd>:
     698:	4b04      	ldr	r3, [pc, #16]	; (6ac <RCC_APB1PeriphResetCmd+0x14>)
     69a:	691a      	ldr	r2, [r3, #16]
     69c:	b919      	cbnz	r1, 6a6 <RCC_APB1PeriphResetCmd+0xe>
     69e:	ea22 0000 	bic.w	r0, r2, r0
     6a2:	6118      	str	r0, [r3, #16]
     6a4:	4770      	bx	lr
     6a6:	4310      	orrs	r0, r2
     6a8:	6118      	str	r0, [r3, #16]
     6aa:	4770      	bx	lr
     6ac:	40021000 	andmi	r1, r2, r0

000006b0 <RCC_BackupResetCmd>:
     6b0:	4b01      	ldr	r3, [pc, #4]	; (6b8 <RCC_BackupResetCmd+0x8>)
     6b2:	6018      	str	r0, [r3, #0]
     6b4:	4770      	bx	lr
     6b6:	bf00      	nop
     6b8:	42420440 	submi	r0, r2, #64, 8	; 0x40000000

000006bc <RCC_ClockSecuritySystemCmd>:
     6bc:	4b01      	ldr	r3, [pc, #4]	; (6c4 <RCC_ClockSecuritySystemCmd+0x8>)
     6be:	6018      	str	r0, [r3, #0]
     6c0:	4770      	bx	lr
     6c2:	bf00      	nop
     6c4:	4242004c 	submi	r0, r2, #76	; 0x4c

000006c8 <RCC_MCOConfig>:
     6c8:	4b01      	ldr	r3, [pc, #4]	; (6d0 <RCC_MCOConfig+0x8>)
     6ca:	7018      	strb	r0, [r3, #0]
     6cc:	4770      	bx	lr
     6ce:	bf00      	nop
     6d0:	40021007 	andmi	r1, r2, r7

000006d4 <RCC_GetFlagStatus>:
     6d4:	0943      	lsrs	r3, r0, #5
     6d6:	2b01      	cmp	r3, #1
     6d8:	d00b      	beq.n	6f2 <RCC_GetFlagStatus+0x1e>
     6da:	2b02      	cmp	r3, #2
     6dc:	4b09      	ldr	r3, [pc, #36]	; (704 <RCC_GetFlagStatus+0x30>)
     6de:	f000 001f 	and.w	r0, r0, #31
     6e2:	bf0c      	ite	eq
     6e4:	6a1b      	ldreq	r3, [r3, #32]
     6e6:	6a5b      	ldrne	r3, [r3, #36]	; 0x24
     6e8:	fa23 f000 	lsr.w	r0, r3, r0
     6ec:	f000 0001 	and.w	r0, r0, #1
     6f0:	4770      	bx	lr
     6f2:	4b04      	ldr	r3, [pc, #16]	; (704 <RCC_GetFlagStatus+0x30>)
     6f4:	f000 001f 	and.w	r0, r0, #31
     6f8:	681b      	ldr	r3, [r3, #0]
     6fa:	fa23 f000 	lsr.w	r0, r3, r0
     6fe:	f000 0001 	and.w	r0, r0, #1
     702:	4770      	bx	lr
     704:	40021000 	andmi	r1, r2, r0

00000708 <RCC_ClearFlag>:
     708:	4b02      	ldr	r3, [pc, #8]	; (714 <RCC_ClearFlag+0xc>)
     70a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
     70c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
     710:	625a      	str	r2, [r3, #36]	; 0x24
     712:	4770      	bx	lr
     714:	40021000 	andmi	r1, r2, r0

00000718 <RCC_GetITStatus>:
     718:	4b03      	ldr	r3, [pc, #12]	; (728 <RCC_GetITStatus+0x10>)
     71a:	689b      	ldr	r3, [r3, #8]
     71c:	4218      	tst	r0, r3
     71e:	bf0c      	ite	eq
     720:	2000      	moveq	r0, #0
     722:	2001      	movne	r0, #1
     724:	4770      	bx	lr
     726:	bf00      	nop
     728:	40021000 	andmi	r1, r2, r0

0000072c <RCC_ClearITPendingBit>:
     72c:	4b01      	ldr	r3, [pc, #4]	; (734 <RCC_ClearITPendingBit+0x8>)
     72e:	7018      	strb	r0, [r3, #0]
     730:	4770      	bx	lr
     732:	bf00      	nop
     734:	4002100a 	andmi	r1, r2, sl

00000738 <USART_DeInit>:
     738:	b508      	push	{r3, lr}
     73a:	4b26      	ldr	r3, [pc, #152]	; (7d4 <USART_DeInit+0x9c>)
     73c:	4298      	cmp	r0, r3
     73e:	d018      	beq.n	772 <USART_DeInit+0x3a>
     740:	4b25      	ldr	r3, [pc, #148]	; (7d8 <USART_DeInit+0xa0>)
     742:	4298      	cmp	r0, r3
     744:	d021      	beq.n	78a <USART_DeInit+0x52>
     746:	4b25      	ldr	r3, [pc, #148]	; (7dc <USART_DeInit+0xa4>)
     748:	4298      	cmp	r0, r3
     74a:	d02a      	beq.n	7a2 <USART_DeInit+0x6a>
     74c:	4b24      	ldr	r3, [pc, #144]	; (7e0 <USART_DeInit+0xa8>)
     74e:	4298      	cmp	r0, r3
     750:	d033      	beq.n	7ba <USART_DeInit+0x82>
     752:	4b24      	ldr	r3, [pc, #144]	; (7e4 <USART_DeInit+0xac>)
     754:	4298      	cmp	r0, r3
     756:	d000      	beq.n	75a <USART_DeInit+0x22>
     758:	bd08      	pop	{r3, pc}
     75a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
     75e:	2101      	movs	r1, #1
     760:	f7ff ff9a 	bl	698 <RCC_APB1PeriphResetCmd>
     764:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     768:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
     76c:	2100      	movs	r1, #0
     76e:	f7ff bf93 	b.w	698 <RCC_APB1PeriphResetCmd>
     772:	f44f 4080 	mov.w	r0, #16384	; 0x4000
     776:	2101      	movs	r1, #1
     778:	f7ff ff82 	bl	680 <RCC_APB2PeriphResetCmd>
     77c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     780:	f44f 4080 	mov.w	r0, #16384	; 0x4000
     784:	2100      	movs	r1, #0
     786:	f7ff bf7b 	b.w	680 <RCC_APB2PeriphResetCmd>
     78a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
     78e:	2101      	movs	r1, #1
     790:	f7ff ff82 	bl	698 <RCC_APB1PeriphResetCmd>
     794:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     798:	f44f 3000 	mov.w	r0, #131072	; 0x20000
     79c:	2100      	movs	r1, #0
     79e:	f7ff bf7b 	b.w	698 <RCC_APB1PeriphResetCmd>
     7a2:	f44f 2080 	mov.w	r0, #262144	; 0x40000
     7a6:	2101      	movs	r1, #1
     7a8:	f7ff ff76 	bl	698 <RCC_APB1PeriphResetCmd>
     7ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     7b0:	f44f 2080 	mov.w	r0, #262144	; 0x40000
     7b4:	2100      	movs	r1, #0
     7b6:	f7ff bf6f 	b.w	698 <RCC_APB1PeriphResetCmd>
     7ba:	f44f 2000 	mov.w	r0, #524288	; 0x80000
     7be:	2101      	movs	r1, #1
     7c0:	f7ff ff6a 	bl	698 <RCC_APB1PeriphResetCmd>
     7c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     7c8:	f44f 2000 	mov.w	r0, #524288	; 0x80000
     7cc:	2100      	movs	r1, #0
     7ce:	f7ff bf63 	b.w	698 <RCC_APB1PeriphResetCmd>
     7d2:	bf00      	nop
     7d4:	40013800 	andmi	r3, r1, r0, lsl #16
     7d8:	40004400 	andmi	r4, r0, r0, lsl #8
     7dc:	40004800 	andmi	r4, r0, r0, lsl #16
     7e0:	40004c00 	andmi	r4, r0, r0, lsl #24
     7e4:	40005000 	andmi	r5, r0, r0

000007e8 <USART_Init>:
     7e8:	b530      	push	{r4, r5, lr}
     7ea:	8a03      	ldrh	r3, [r0, #16]
     7ec:	88ca      	ldrh	r2, [r1, #6]
     7ee:	b29b      	uxth	r3, r3
     7f0:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
     7f4:	4313      	orrs	r3, r2
     7f6:	8203      	strh	r3, [r0, #16]
     7f8:	8982      	ldrh	r2, [r0, #12]
     7fa:	4604      	mov	r4, r0
     7fc:	890b      	ldrh	r3, [r1, #8]
     7fe:	8888      	ldrh	r0, [r1, #4]
     800:	460d      	mov	r5, r1
     802:	b292      	uxth	r2, r2
     804:	8949      	ldrh	r1, [r1, #10]
     806:	4303      	orrs	r3, r0
     808:	f422 52b0 	bic.w	r2, r2, #5632	; 0x1600
     80c:	430b      	orrs	r3, r1
     80e:	f022 020c 	bic.w	r2, r2, #12
     812:	4313      	orrs	r3, r2
     814:	b29b      	uxth	r3, r3
     816:	81a3      	strh	r3, [r4, #12]
     818:	8aa3      	ldrh	r3, [r4, #20]
     81a:	89aa      	ldrh	r2, [r5, #12]
     81c:	b29b      	uxth	r3, r3
     81e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
     822:	b087      	sub	sp, #28
     824:	4313      	orrs	r3, r2
     826:	82a3      	strh	r3, [r4, #20]
     828:	a801      	add	r0, sp, #4
     82a:	f7ff febd 	bl	5a8 <RCC_GetClocksFreq>
     82e:	89a1      	ldrh	r1, [r4, #12]
     830:	9a04      	ldr	r2, [sp, #16]
     832:	481a      	ldr	r0, [pc, #104]	; (89c <__Stack_Size+0x9c>)
     834:	9b03      	ldr	r3, [sp, #12]
     836:	b209      	sxth	r1, r1
     838:	4284      	cmp	r4, r0
     83a:	bf08      	it	eq
     83c:	4613      	moveq	r3, r2
     83e:	682a      	ldr	r2, [r5, #0]
     840:	2900      	cmp	r1, #0
     842:	eb03 0383 	add.w	r3, r3, r3, lsl #2
     846:	bfb4      	ite	lt
     848:	0052      	lsllt	r2, r2, #1
     84a:	0092      	lslge	r2, r2, #2
     84c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
     850:	4913      	ldr	r1, [pc, #76]	; (8a0 <__Stack_Size+0xa0>)
     852:	fbb3 f3f2 	udiv	r3, r3, r2
     856:	fba1 5203 	umull	r5, r2, r1, r3
     85a:	89a0      	ldrh	r0, [r4, #12]
     85c:	0952      	lsrs	r2, r2, #5
     85e:	b200      	sxth	r0, r0
     860:	2564      	movs	r5, #100	; 0x64
     862:	2800      	cmp	r0, #0
     864:	fb02 3315 	mls	r3, r2, r5, r3
     868:	ea4f 1202 	mov.w	r2, r2, lsl #4
     86c:	db0a      	blt.n	884 <__Stack_Size+0x84>
     86e:	011b      	lsls	r3, r3, #4
     870:	3332      	adds	r3, #50	; 0x32
     872:	fba1 5103 	umull	r5, r1, r1, r3
     876:	f3c1 1143 	ubfx	r1, r1, #5, #4
     87a:	430a      	orrs	r2, r1
     87c:	b292      	uxth	r2, r2
     87e:	8122      	strh	r2, [r4, #8]
     880:	b007      	add	sp, #28
     882:	bd30      	pop	{r4, r5, pc}
     884:	00db      	lsls	r3, r3, #3
     886:	3332      	adds	r3, #50	; 0x32
     888:	fba1 0103 	umull	r0, r1, r1, r3
     88c:	f3c1 1142 	ubfx	r1, r1, #5, #3
     890:	430a      	orrs	r2, r1
     892:	b292      	uxth	r2, r2
     894:	8122      	strh	r2, [r4, #8]
     896:	b007      	add	sp, #28
     898:	bd30      	pop	{r4, r5, pc}
     89a:	bf00      	nop
     89c:	40013800 	andmi	r3, r1, r0, lsl #16
     8a0:	51eb851f 	mvnpl	r8, pc, lsl r5

000008a4 <USART_StructInit>:
     8a4:	2300      	movs	r3, #0
     8a6:	f44f 5116 	mov.w	r1, #9600	; 0x2580
     8aa:	220c      	movs	r2, #12
     8ac:	6001      	str	r1, [r0, #0]
     8ae:	8142      	strh	r2, [r0, #10]
     8b0:	8083      	strh	r3, [r0, #4]
     8b2:	80c3      	strh	r3, [r0, #6]
     8b4:	8103      	strh	r3, [r0, #8]
     8b6:	8183      	strh	r3, [r0, #12]
     8b8:	4770      	bx	lr
     8ba:	bf00      	nop

000008bc <USART_ClockInit>:
     8bc:	b430      	push	{r4, r5}
     8be:	884d      	ldrh	r5, [r1, #2]
     8c0:	880b      	ldrh	r3, [r1, #0]
     8c2:	888c      	ldrh	r4, [r1, #4]
     8c4:	8a02      	ldrh	r2, [r0, #16]
     8c6:	432b      	orrs	r3, r5
     8c8:	88c9      	ldrh	r1, [r1, #6]
     8ca:	4323      	orrs	r3, r4
     8cc:	b292      	uxth	r2, r2
     8ce:	430b      	orrs	r3, r1
     8d0:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
     8d4:	4313      	orrs	r3, r2
     8d6:	b29b      	uxth	r3, r3
     8d8:	8203      	strh	r3, [r0, #16]
     8da:	bc30      	pop	{r4, r5}
     8dc:	4770      	bx	lr
     8de:	bf00      	nop

000008e0 <USART_ClockStructInit>:
     8e0:	2300      	movs	r3, #0
     8e2:	8003      	strh	r3, [r0, #0]
     8e4:	8043      	strh	r3, [r0, #2]
     8e6:	8083      	strh	r3, [r0, #4]
     8e8:	80c3      	strh	r3, [r0, #6]
     8ea:	4770      	bx	lr

000008ec <USART_Cmd>:
     8ec:	8983      	ldrh	r3, [r0, #12]
     8ee:	b929      	cbnz	r1, 8fc <USART_Cmd+0x10>
     8f0:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
     8f4:	041b      	lsls	r3, r3, #16
     8f6:	0c1b      	lsrs	r3, r3, #16
     8f8:	8183      	strh	r3, [r0, #12]
     8fa:	4770      	bx	lr
     8fc:	b29b      	uxth	r3, r3
     8fe:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
     902:	8183      	strh	r3, [r0, #12]
     904:	4770      	bx	lr
     906:	bf00      	nop

00000908 <USART_ITConfig>:
     908:	f001 031f 	and.w	r3, r1, #31
     90c:	b410      	push	{r4}
     90e:	f3c1 1142 	ubfx	r1, r1, #5, #3
     912:	2401      	movs	r4, #1
     914:	42a1      	cmp	r1, r4
     916:	fa04 f303 	lsl.w	r3, r4, r3
     91a:	d010      	beq.n	93e <USART_ITConfig+0x36>
     91c:	2902      	cmp	r1, #2
     91e:	bf0c      	ite	eq
     920:	3010      	addeq	r0, #16
     922:	3014      	addne	r0, #20
     924:	6804      	ldr	r4, [r0, #0]
     926:	b92a      	cbnz	r2, 934 <USART_ITConfig+0x2c>
     928:	ea24 0303 	bic.w	r3, r4, r3
     92c:	6003      	str	r3, [r0, #0]
     92e:	f85d 4b04 	ldr.w	r4, [sp], #4
     932:	4770      	bx	lr
     934:	4323      	orrs	r3, r4
     936:	6003      	str	r3, [r0, #0]
     938:	f85d 4b04 	ldr.w	r4, [sp], #4
     93c:	4770      	bx	lr
     93e:	300c      	adds	r0, #12
     940:	e7f0      	b.n	924 <USART_ITConfig+0x1c>
     942:	bf00      	nop

00000944 <USART_DMACmd>:
     944:	8a83      	ldrh	r3, [r0, #20]
     946:	b29b      	uxth	r3, r3
     948:	b91a      	cbnz	r2, 952 <USART_DMACmd+0xe>
     94a:	ea23 0101 	bic.w	r1, r3, r1
     94e:	8281      	strh	r1, [r0, #20]
     950:	4770      	bx	lr
     952:	4319      	orrs	r1, r3
     954:	8281      	strh	r1, [r0, #20]
     956:	4770      	bx	lr

00000958 <USART_SetAddress>:
     958:	8a03      	ldrh	r3, [r0, #16]
     95a:	f023 030f 	bic.w	r3, r3, #15
     95e:	041b      	lsls	r3, r3, #16
     960:	0c1b      	lsrs	r3, r3, #16
     962:	8203      	strh	r3, [r0, #16]
     964:	8a03      	ldrh	r3, [r0, #16]
     966:	b29b      	uxth	r3, r3
     968:	4319      	orrs	r1, r3
     96a:	8201      	strh	r1, [r0, #16]
     96c:	4770      	bx	lr
     96e:	bf00      	nop

00000970 <USART_WakeUpConfig>:
     970:	8983      	ldrh	r3, [r0, #12]
     972:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
     976:	041b      	lsls	r3, r3, #16
     978:	0c1b      	lsrs	r3, r3, #16
     97a:	8183      	strh	r3, [r0, #12]
     97c:	8983      	ldrh	r3, [r0, #12]
     97e:	b29b      	uxth	r3, r3
     980:	4319      	orrs	r1, r3
     982:	8181      	strh	r1, [r0, #12]
     984:	4770      	bx	lr
     986:	bf00      	nop

00000988 <USART_ReceiverWakeUpCmd>:
     988:	8983      	ldrh	r3, [r0, #12]
     98a:	b929      	cbnz	r1, 998 <USART_ReceiverWakeUpCmd+0x10>
     98c:	f023 0302 	bic.w	r3, r3, #2
     990:	041b      	lsls	r3, r3, #16
     992:	0c1b      	lsrs	r3, r3, #16
     994:	8183      	strh	r3, [r0, #12]
     996:	4770      	bx	lr
     998:	b29b      	uxth	r3, r3
     99a:	f043 0302 	orr.w	r3, r3, #2
     99e:	8183      	strh	r3, [r0, #12]
     9a0:	4770      	bx	lr
     9a2:	bf00      	nop

000009a4 <USART_LINBreakDetectLengthConfig>:
     9a4:	8a03      	ldrh	r3, [r0, #16]
     9a6:	f023 0320 	bic.w	r3, r3, #32
     9aa:	041b      	lsls	r3, r3, #16
     9ac:	0c1b      	lsrs	r3, r3, #16
     9ae:	8203      	strh	r3, [r0, #16]
     9b0:	8a03      	ldrh	r3, [r0, #16]
     9b2:	b29b      	uxth	r3, r3
     9b4:	4319      	orrs	r1, r3
     9b6:	8201      	strh	r1, [r0, #16]
     9b8:	4770      	bx	lr
     9ba:	bf00      	nop

000009bc <USART_LINCmd>:
     9bc:	8a03      	ldrh	r3, [r0, #16]
     9be:	b929      	cbnz	r1, 9cc <USART_LINCmd+0x10>
     9c0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
     9c4:	041b      	lsls	r3, r3, #16
     9c6:	0c1b      	lsrs	r3, r3, #16
     9c8:	8203      	strh	r3, [r0, #16]
     9ca:	4770      	bx	lr
     9cc:	b29b      	uxth	r3, r3
     9ce:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
     9d2:	8203      	strh	r3, [r0, #16]
     9d4:	4770      	bx	lr
     9d6:	bf00      	nop

000009d8 <USART_SendData>:
     9d8:	f3c1 0108 	ubfx	r1, r1, #0, #9
     9dc:	8081      	strh	r1, [r0, #4]
     9de:	4770      	bx	lr

000009e0 <USART_ReceiveData>:
     9e0:	8880      	ldrh	r0, [r0, #4]
     9e2:	f3c0 0008 	ubfx	r0, r0, #0, #9
     9e6:	4770      	bx	lr

000009e8 <USART_SendBreak>:
     9e8:	8983      	ldrh	r3, [r0, #12]
     9ea:	b29b      	uxth	r3, r3
     9ec:	f043 0301 	orr.w	r3, r3, #1
     9f0:	8183      	strh	r3, [r0, #12]
     9f2:	4770      	bx	lr

000009f4 <USART_SetGuardTime>:
     9f4:	8b03      	ldrh	r3, [r0, #24]
     9f6:	b2db      	uxtb	r3, r3
     9f8:	8303      	strh	r3, [r0, #24]
     9fa:	8b03      	ldrh	r3, [r0, #24]
     9fc:	b29b      	uxth	r3, r3
     9fe:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
     a02:	8301      	strh	r1, [r0, #24]
     a04:	4770      	bx	lr
     a06:	bf00      	nop

00000a08 <USART_SetPrescaler>:
     a08:	8b03      	ldrh	r3, [r0, #24]
     a0a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
     a0e:	8303      	strh	r3, [r0, #24]
     a10:	8b03      	ldrh	r3, [r0, #24]
     a12:	b29b      	uxth	r3, r3
     a14:	4319      	orrs	r1, r3
     a16:	8301      	strh	r1, [r0, #24]
     a18:	4770      	bx	lr
     a1a:	bf00      	nop

00000a1c <USART_SmartCardCmd>:
     a1c:	8a83      	ldrh	r3, [r0, #20]
     a1e:	b929      	cbnz	r1, a2c <USART_SmartCardCmd+0x10>
     a20:	f023 0320 	bic.w	r3, r3, #32
     a24:	041b      	lsls	r3, r3, #16
     a26:	0c1b      	lsrs	r3, r3, #16
     a28:	8283      	strh	r3, [r0, #20]
     a2a:	4770      	bx	lr
     a2c:	b29b      	uxth	r3, r3
     a2e:	f043 0320 	orr.w	r3, r3, #32
     a32:	8283      	strh	r3, [r0, #20]
     a34:	4770      	bx	lr
     a36:	bf00      	nop

00000a38 <USART_SmartCardNACKCmd>:
     a38:	8a83      	ldrh	r3, [r0, #20]
     a3a:	b929      	cbnz	r1, a48 <USART_SmartCardNACKCmd+0x10>
     a3c:	f023 0310 	bic.w	r3, r3, #16
     a40:	041b      	lsls	r3, r3, #16
     a42:	0c1b      	lsrs	r3, r3, #16
     a44:	8283      	strh	r3, [r0, #20]
     a46:	4770      	bx	lr
     a48:	b29b      	uxth	r3, r3
     a4a:	f043 0310 	orr.w	r3, r3, #16
     a4e:	8283      	strh	r3, [r0, #20]
     a50:	4770      	bx	lr
     a52:	bf00      	nop

00000a54 <USART_HalfDuplexCmd>:
     a54:	8a83      	ldrh	r3, [r0, #20]
     a56:	b929      	cbnz	r1, a64 <USART_HalfDuplexCmd+0x10>
     a58:	f023 0308 	bic.w	r3, r3, #8
     a5c:	041b      	lsls	r3, r3, #16
     a5e:	0c1b      	lsrs	r3, r3, #16
     a60:	8283      	strh	r3, [r0, #20]
     a62:	4770      	bx	lr
     a64:	b29b      	uxth	r3, r3
     a66:	f043 0308 	orr.w	r3, r3, #8
     a6a:	8283      	strh	r3, [r0, #20]
     a6c:	4770      	bx	lr
     a6e:	bf00      	nop

00000a70 <USART_OverSampling8Cmd>:
     a70:	8983      	ldrh	r3, [r0, #12]
     a72:	b919      	cbnz	r1, a7c <USART_OverSampling8Cmd+0xc>
     a74:	f3c3 030e 	ubfx	r3, r3, #0, #15
     a78:	8183      	strh	r3, [r0, #12]
     a7a:	4770      	bx	lr
     a7c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
     a80:	ea6f 4353 	mvn.w	r3, r3, lsr #17
     a84:	b29b      	uxth	r3, r3
     a86:	8183      	strh	r3, [r0, #12]
     a88:	4770      	bx	lr
     a8a:	bf00      	nop

00000a8c <USART_OneBitMethodCmd>:
     a8c:	8a83      	ldrh	r3, [r0, #20]
     a8e:	b929      	cbnz	r1, a9c <USART_OneBitMethodCmd+0x10>
     a90:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
     a94:	041b      	lsls	r3, r3, #16
     a96:	0c1b      	lsrs	r3, r3, #16
     a98:	8283      	strh	r3, [r0, #20]
     a9a:	4770      	bx	lr
     a9c:	b29b      	uxth	r3, r3
     a9e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
     aa2:	8283      	strh	r3, [r0, #20]
     aa4:	4770      	bx	lr
     aa6:	bf00      	nop

00000aa8 <USART_IrDAConfig>:
     aa8:	8a83      	ldrh	r3, [r0, #20]
     aaa:	f023 0304 	bic.w	r3, r3, #4
     aae:	041b      	lsls	r3, r3, #16
     ab0:	0c1b      	lsrs	r3, r3, #16
     ab2:	8283      	strh	r3, [r0, #20]
     ab4:	8a83      	ldrh	r3, [r0, #20]
     ab6:	b29b      	uxth	r3, r3
     ab8:	4319      	orrs	r1, r3
     aba:	8281      	strh	r1, [r0, #20]
     abc:	4770      	bx	lr
     abe:	bf00      	nop

00000ac0 <USART_IrDACmd>:
     ac0:	8a83      	ldrh	r3, [r0, #20]
     ac2:	b929      	cbnz	r1, ad0 <USART_IrDACmd+0x10>
     ac4:	f023 0302 	bic.w	r3, r3, #2
     ac8:	041b      	lsls	r3, r3, #16
     aca:	0c1b      	lsrs	r3, r3, #16
     acc:	8283      	strh	r3, [r0, #20]
     ace:	4770      	bx	lr
     ad0:	b29b      	uxth	r3, r3
     ad2:	f043 0302 	orr.w	r3, r3, #2
     ad6:	8283      	strh	r3, [r0, #20]
     ad8:	4770      	bx	lr
     ada:	bf00      	nop

00000adc <USART_GetFlagStatus>:
     adc:	8803      	ldrh	r3, [r0, #0]
     ade:	4219      	tst	r1, r3
     ae0:	bf0c      	ite	eq
     ae2:	2000      	moveq	r0, #0
     ae4:	2001      	movne	r0, #1
     ae6:	4770      	bx	lr

00000ae8 <USART_ClearFlag>:
     ae8:	43c9      	mvns	r1, r1
     aea:	b289      	uxth	r1, r1
     aec:	8001      	strh	r1, [r0, #0]
     aee:	4770      	bx	lr

00000af0 <USART_GetITStatus>:
     af0:	b410      	push	{r4}
     af2:	f3c1 1342 	ubfx	r3, r1, #5, #3
     af6:	2401      	movs	r4, #1
     af8:	f001 021f 	and.w	r2, r1, #31
     afc:	42a3      	cmp	r3, r4
     afe:	fa04 f202 	lsl.w	r2, r4, r2
     b02:	d017      	beq.n	b34 <USART_GetITStatus+0x44>
     b04:	2b02      	cmp	r3, #2
     b06:	bf0c      	ite	eq
     b08:	8a03      	ldrheq	r3, [r0, #16]
     b0a:	8a83      	ldrhne	r3, [r0, #20]
     b0c:	b29b      	uxth	r3, r3
     b0e:	4013      	ands	r3, r2
     b10:	8802      	ldrh	r2, [r0, #0]
     b12:	b292      	uxth	r2, r2
     b14:	b153      	cbz	r3, b2c <USART_GetITStatus+0x3c>
     b16:	0a09      	lsrs	r1, r1, #8
     b18:	2301      	movs	r3, #1
     b1a:	fa03 f101 	lsl.w	r1, r3, r1
     b1e:	4211      	tst	r1, r2
     b20:	bf0c      	ite	eq
     b22:	2000      	moveq	r0, #0
     b24:	2001      	movne	r0, #1
     b26:	f85d 4b04 	ldr.w	r4, [sp], #4
     b2a:	4770      	bx	lr
     b2c:	4618      	mov	r0, r3
     b2e:	f85d 4b04 	ldr.w	r4, [sp], #4
     b32:	4770      	bx	lr
     b34:	8983      	ldrh	r3, [r0, #12]
     b36:	b29b      	uxth	r3, r3
     b38:	4013      	ands	r3, r2
     b3a:	e7e9      	b.n	b10 <USART_GetITStatus+0x20>

00000b3c <USART_ClearITPendingBit>:
     b3c:	0a09      	lsrs	r1, r1, #8
     b3e:	2301      	movs	r3, #1
     b40:	408b      	lsls	r3, r1
     b42:	43db      	mvns	r3, r3
     b44:	b29b      	uxth	r3, r3
     b46:	8003      	strh	r3, [r0, #0]
     b48:	4770      	bx	lr
     b4a:	bf00      	nop

00000b4c <Reset_Handler>:
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	2100      	movs	r1, #0
  b	LoopCopyDataInit
     b4e:	f000 b804 	b.w	b5a <LoopCopyDataInit>

00000b52 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
     b52:	4b0b      	ldr	r3, [pc, #44]	; (b80 <LoopFillZerobss+0xe>)
	ldr	r3, [r3, r1]
     b54:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
     b56:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
     b58:	3104      	adds	r1, #4

00000b5a <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
     b5a:	480a      	ldr	r0, [pc, #40]	; (b84 <LoopFillZerobss+0x12>)
	ldr	r3, =_edata
     b5c:	4b0a      	ldr	r3, [pc, #40]	; (b88 <LoopFillZerobss+0x16>)
	adds	r2, r0, r1
     b5e:	1842      	adds	r2, r0, r1
	cmp	r2, r3
     b60:	429a      	cmp	r2, r3
	bcc	CopyDataInit
     b62:	f4ff aff6 	bcc.w	b52 <CopyDataInit>
	ldr	r2, =_sbss
     b66:	4a09      	ldr	r2, [pc, #36]	; (b8c <LoopFillZerobss+0x1a>)
	b	LoopFillZerobss
     b68:	f000 b803 	b.w	b72 <LoopFillZerobss>

00000b6c <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	2300      	movs	r3, #0
	str	r3, [r2], #4
     b6e:	f842 3b04 	str.w	r3, [r2], #4

00000b72 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
     b72:	4b07      	ldr	r3, [pc, #28]	; (b90 <LoopFillZerobss+0x1e>)
	cmp	r2, r3
     b74:	429a      	cmp	r2, r3
	bcc	FillZerobss
     b76:	f4ff aff9 	bcc.w	b6c <FillZerobss>
/* Call the application's entry point.*/
	bl	main
     b7a:	f000 fa5d 	bl	1038 <main>
	bx	lr
     b7e:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	00007518 	andeq	r7, r0, r8, lsl r5
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	20000000 	andcs	r0, r0, r0
	ldr	r3, =_edata
     b88:	20000488 	andcs	r0, r0, r8, lsl #9
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	20000488 	andcs	r0, r0, r8, lsl #9
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	200005b4 			; <UNDEFINED> instruction: 0x200005b4

00000b94 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	f7ff bffe 	b.w	b94 <ADC1_2_IRQHandler>

00000b98 <nothingProc>:
}


/* dummy proc */
void nothingProc(void)
{
     b98:	4770      	bx	lr

00000b9a <usbStatusIn>:
    bDeviceState = ATTACHED;
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}

void usbStatusIn(void)
{
     b9a:	4770      	bx	lr

00000b9c <usbStatusOut>:
    return;
}

void usbStatusOut(void)
{
     b9c:	4770      	bx	lr

00000b9e <usbGetInterfaceSetting>:

RESULT usbGetInterfaceSetting(u8 interface, u8 altSetting)
{
    // alt setting 0 -> program RAM, alt setting 1 or higher -> FLASH
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
     b9e:	2803      	cmp	r0, #3
    }

    return USB_SUCCESS;
}
     ba0:	bf8c      	ite	hi
     ba2:	2002      	movhi	r0, #2
     ba4:	2000      	movls	r0, #0
     ba6:	4770      	bx	lr

00000ba8 <usbGetConfiguration>:
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	4770      	bx	lr
	...

00000bac <usbSetConfiguration>:
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	4b03      	ldr	r3, [pc, #12]	; (bbc <usbSetConfiguration+0x10>)
     bae:	681b      	ldr	r3, [r3, #0]
     bb0:	7a9b      	ldrb	r3, [r3, #10]
     bb2:	b113      	cbz	r3, bba <usbSetConfiguration+0xe>
        bDeviceState = CONFIGURED;
     bb4:	4b02      	ldr	r3, [pc, #8]	; (bc0 <usbSetConfiguration+0x14>)
     bb6:	2205      	movs	r2, #5
     bb8:	601a      	str	r2, [r3, #0]
     bba:	4770      	bx	lr
     bbc:	200005a8 	andcs	r0, r0, r8, lsr #11
     bc0:	200005b8 			; <UNDEFINED> instruction: 0x200005b8

00000bc4 <usbGetInterface>:
    }
}

void usbGetInterface(void)
{
     bc4:	4770      	bx	lr

00000bc6 <usbSetInterface>:
    /* nothing process */
}

void usbSetInterface(void)
{
     bc6:	4770      	bx	lr

00000bc8 <usbGetStatus>:
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	4770      	bx	lr

00000bca <usbClearFeature>:
    /* nothing process */
}

void usbClearFeature(void)
{
     bca:	4770      	bx	lr

00000bcc <usbSetEndpointFeature>:
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	4770      	bx	lr

00000bce <usbSetDeviceFeature>:
    /* nothing process */
}

void usbSetDeviceFeature(void)
{
     bce:	4770      	bx	lr

00000bd0 <usbSetDeviceAddress>:
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	4b01      	ldr	r3, [pc, #4]	; (bd8 <usbSetDeviceAddress+0x8>)
     bd2:	2204      	movs	r2, #4
     bd4:	601a      	str	r2, [r3, #0]
     bd6:	4770      	bx	lr
     bd8:	200005b8 			; <UNDEFINED> instruction: 0x200005b8

00000bdc <usbReset>:
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	b510      	push	{r4, lr}
    dfuUpdateByReset();
     bde:	f000 fcf7 	bl	15d0 <dfuUpdateByReset>

    pInformation->Current_Configuration = 0;
     be2:	4b21      	ldr	r3, [pc, #132]	; (c68 <usbReset+0x8c>)
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	4a21      	ldr	r2, [pc, #132]	; (c6c <usbReset+0x90>)

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be6:	681b      	ldr	r3, [r3, #0]
     be8:	2400      	movs	r4, #0
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     bea:	6812      	ldr	r2, [r2, #0]

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     bec:	729c      	strb	r4, [r3, #10]
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     bee:	79d2      	ldrb	r2, [r2, #7]
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	4620      	mov	r0, r4
void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     bf2:	725a      	strb	r2, [r3, #9]

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	4a1e      	ldr	r2, [pc, #120]	; (c70 <usbReset+0x94>)

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bf6:	4b1f      	ldr	r3, [pc, #124]	; (c74 <usbReset+0x98>)
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf8:	6014      	str	r4, [r2, #0]

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfa:	6819      	ldr	r1, [r3, #0]
     bfc:	f421 41ec 	bic.w	r1, r1, #30208	; 0x7600
     c00:	f021 0170 	bic.w	r1, r1, #112	; 0x70
     c04:	f441 7100 	orr.w	r1, r1, #512	; 0x200
     c08:	b289      	uxth	r1, r1
     c0a:	6019      	str	r1, [r3, #0]
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c0c:	6819      	ldr	r1, [r3, #0]
     c0e:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
     c12:	f021 0140 	bic.w	r1, r1, #64	; 0x40
     c16:	b289      	uxth	r1, r1
     c18:	f081 0110 	eor.w	r1, r1, #16
     c1c:	6019      	str	r1, [r3, #0]

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c1e:	6811      	ldr	r1, [r2, #0]
     c20:	4b15      	ldr	r3, [pc, #84]	; (c78 <usbReset+0x9c>)
     c22:	b289      	uxth	r1, r1
     c24:	440b      	add	r3, r1
     c26:	005b      	lsls	r3, r3, #1
     c28:	2140      	movs	r1, #64	; 0x40
     c2a:	6019      	str	r1, [r3, #0]
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	6813      	ldr	r3, [r2, #0]
     c2e:	2280      	movs	r2, #128	; 0x80
     c30:	b29b      	uxth	r3, r3
     c32:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
     c36:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
     c3a:	005b      	lsls	r3, r3, #1
     c3c:	601a      	str	r2, [r3, #0]

    Clear_Status_Out(ENDP0);
     c3e:	f004 ffe1 	bl	5c04 <Clear_Status_Out>

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c42:	4b0e      	ldr	r3, [pc, #56]	; (c7c <usbReset+0xa0>)
     c44:	4620      	mov	r0, r4
     c46:	681b      	ldr	r3, [r3, #0]
     c48:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
     c4c:	f005 f832 	bl	5cb4 <SetEPRxCount>
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	4620      	mov	r0, r4
     c52:	f004 ffc8 	bl	5be6 <SetEPRxValid>

    bDeviceState = ATTACHED;
     c56:	4b0a      	ldr	r3, [pc, #40]	; (c80 <usbReset+0xa4>)
     c58:	2201      	movs	r2, #1
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c5a:	4620      	mov	r0, r4
}
     c5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	601a      	str	r2, [r3, #0]
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c62:	f005 bcc9 	b.w	65f8 <SetDeviceAddress>
     c66:	bf00      	nop
     c68:	200005a8 	andcs	r0, r0, r8, lsr #11
     c6c:	200002b4 			; <UNDEFINED> instruction: 0x200002b4
     c70:	40005c50 	andmi	r5, r0, r0, asr ip
     c74:	40005c00 	andmi	r5, r0, r0, lsl #24
     c78:	20003004 	andcs	r3, r0, r4
     c7c:	20000580 	andcs	r0, r0, r0, lsl #11
     c80:	200005b8 			; <UNDEFINED> instruction: 0x200005b8

00000c84 <usbDataSetup>:
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	b538      	push	{r3, r4, r5, lr}
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c86:	4b12      	ldr	r3, [pc, #72]	; (cd0 <usbDataSetup+0x4c>)
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c88:	4605      	mov	r5, r0
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8a:	681a      	ldr	r2, [r3, #0]
     c8c:	461c      	mov	r4, r3
     c8e:	7812      	ldrb	r2, [r2, #0]
     c90:	f002 027f 	and.w	r2, r2, #127	; 0x7f
     c94:	2a21      	cmp	r2, #33	; 0x21
     c96:	d119      	bne.n	ccc <usbDataSetup+0x48>
        if (dfuUpdateByRequest()) {
     c98:	f000 fd30 	bl	16fc <dfuUpdateByRequest>
     c9c:	b1b0      	cbz	r0, ccc <usbDataSetup+0x48>
            // successfull state transition, handle the request
            switch (request) {
     c9e:	1e68      	subs	r0, r5, #1
     ca0:	2804      	cmp	r0, #4
     ca2:	d813      	bhi.n	ccc <usbDataSetup+0x48>
     ca4:	e8df f000 	tbb	[pc, r0]
     ca8:	12070503 	andne	r0, r7, #12582912	; 0xc00000
     cac:	4b090009 	blmi	240cd8 <_etext+0x2397c0>
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	e004      	b.n	cbc <usbDataSetup+0x38>
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
     cb2:	4b09      	ldr	r3, [pc, #36]	; (cd8 <usbDataSetup+0x54>)
                break;
     cb4:	e002      	b.n	cbc <usbDataSetup+0x38>
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
     cb6:	4b09      	ldr	r3, [pc, #36]	; (cdc <usbDataSetup+0x58>)
     cb8:	e000      	b.n	cbc <usbDataSetup+0x38>
                break;
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
     cba:	4b09      	ldr	r3, [pc, #36]	; (ce0 <usbDataSetup+0x5c>)
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	6822      	ldr	r2, [r4, #0]
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cbe:	2400      	movs	r4, #0
        (*CopyRoutine)(0);
     cc0:	4620      	mov	r0, r4
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cc2:	6193      	str	r3, [r2, #24]
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	8254      	strh	r4, [r2, #18]
        (*CopyRoutine)(0);
     cc6:	4798      	blx	r3

        return USB_SUCCESS;
     cc8:	4620      	mov	r0, r4
     cca:	bd38      	pop	{r3, r4, r5, pc}
    }

    return USB_UNSUPPORT;
     ccc:	2002      	movs	r0, #2
}
     cce:	bd38      	pop	{r3, r4, r5, pc}
     cd0:	200005a8 	andcs	r0, r0, r8, lsr #11
     cd4:	00001645 	andeq	r1, r0, r5, asr #12
     cd8:	0000166d 	andeq	r1, r0, sp, ror #12
     cdc:	0000162d 	andeq	r1, r0, sp, lsr #12
     ce0:	00001615 	andeq	r1, r0, r5, lsl r6

00000ce4 <usbGetDeviceDescriptor>:
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	4901      	ldr	r1, [pc, #4]	; (cec <usbGetDeviceDescriptor+0x8>)
     ce6:	f005 ba87 	b.w	61f8 <Standard_GetDescriptorData>
     cea:	bf00      	nop
     cec:	20000158 	andcs	r0, r0, r8, asr r1

00000cf0 <usbGetConfigDescriptor>:
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	4901      	ldr	r1, [pc, #4]	; (cf8 <usbGetConfigDescriptor+0x8>)
     cf2:	f005 ba81 	b.w	61f8 <Standard_GetDescriptorData>
     cf6:	bf00      	nop
     cf8:	200002b4 			; <UNDEFINED> instruction: 0x200002b4

00000cfc <usbGetStringDescriptor>:
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	4b05      	ldr	r3, [pc, #20]	; (d14 <usbGetStringDescriptor+0x18>)
     cfe:	681b      	ldr	r3, [r3, #0]
     d00:	789b      	ldrb	r3, [r3, #2]
    if (strIndex > STR_DESC_LEN) {
     d02:	2b07      	cmp	r3, #7
     d04:	d804      	bhi.n	d10 <usbGetStringDescriptor+0x14>
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d06:	4904      	ldr	r1, [pc, #16]	; (d18 <usbGetStringDescriptor+0x1c>)
     d08:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
     d0c:	f005 ba74 	b.w	61f8 <Standard_GetDescriptorData>
    }
}
     d10:	2000      	movs	r0, #0
     d12:	4770      	bx	lr
     d14:	200005a8 	andcs	r0, r0, r8, lsr #11
     d18:	200000a8 	andcs	r0, r0, r8, lsr #1

00000d1c <usbGetFunctionalDescriptor>:

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
     d1c:	4901      	ldr	r1, [pc, #4]	; (d24 <usbGetFunctionalDescriptor+0x8>)
     d1e:	f005 ba6b 	b.w	61f8 <Standard_GetDescriptorData>
     d22:	bf00      	nop
     d24:	200000f4 	strdcs	r0, [r0], -r4

00000d28 <usbNoDataSetup>:

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	b508      	push	{r3, lr}
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2a:	4b08      	ldr	r3, [pc, #32]	; (d4c <usbNoDataSetup+0x24>)
     d2c:	681b      	ldr	r3, [r3, #0]
     d2e:	781b      	ldrb	r3, [r3, #0]
     d30:	f003 037f 	and.w	r3, r3, #127	; 0x7f
     d34:	2b21      	cmp	r3, #33	; 0x21
     d36:	d106      	bne.n	d46 <usbNoDataSetup+0x1e>
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	f000 fce0 	bl	16fc <dfuUpdateByRequest>
     d3c:	2800      	cmp	r0, #0
            return USB_SUCCESS;
     d3e:	bf0c      	ite	eq
     d40:	2002      	moveq	r0, #2
     d42:	2000      	movne	r0, #0
     d44:	bd08      	pop	{r3, pc}
        }
    }
    return USB_UNSUPPORT;
     d46:	2002      	movs	r0, #2
}
     d48:	bd08      	pop	{r3, pc}
     d4a:	bf00      	nop
     d4c:	200005a8 	andcs	r0, r0, r8, lsr #11

00000d50 <setupUSB>:

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	b537      	push	{r0, r1, r2, r4, r5, lr}
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d52:	4814      	ldr	r0, [pc, #80]	; (da4 <setupUSB+0x54>)
     d54:	210c      	movs	r1, #12
     d56:	2200      	movs	r2, #0
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	4c13      	ldr	r4, [pc, #76]	; (da8 <setupUSB+0x58>)
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5a:	f000 f9e3 	bl	1124 <gpio_write_bit>
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d5e:	200c      	movs	r0, #12
     d60:	6825      	ldr	r5, [r4, #0]
     d62:	f000 fbd3 	bl	150c <crMask>
     d66:	4028      	ands	r0, r5
     d68:	f440 3580 	orr.w	r5, r0, #65536	; 0x10000
     d6c:	6025      	str	r5, [r4, #0]
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d6e:	f44f 7380 	mov.w	r3, #256	; 0x100
     d72:	9301      	str	r3, [sp, #4]
     d74:	9b01      	ldr	r3, [sp, #4]
     d76:	b113      	cbz	r3, d7e <setupUSB+0x2e>
     d78:	9b01      	ldr	r3, [sp, #4]
     d7a:	3b01      	subs	r3, #1
     d7c:	e7f9      	b.n	d72 <setupUSB+0x22>
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d7e:	f000 fbd7 	bl	1530 <getFlashPageSize>
     d82:	4b0a      	ldr	r3, [pc, #40]	; (dac <setupUSB+0x5c>)
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	b2c2      	uxtb	r2, r0
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d86:	6018      	str	r0, [r3, #0]
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d88:	4b09      	ldr	r3, [pc, #36]	; (db0 <setupUSB+0x60>)
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8a:	f3c0 2007 	ubfx	r0, r0, #8, #8
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d8e:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d92:	f883 002a 	strb.w	r0, [r3, #42]	; 0x2a
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d96:	4b07      	ldr	r3, [pc, #28]	; (db4 <setupUSB+0x64>)
     d98:	715a      	strb	r2, [r3, #5]
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
     d9a:	7198      	strb	r0, [r3, #6]

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	f005 f854 	bl	5e48 <USB_Init>
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	b003      	add	sp, #12
     da2:	bd30      	pop	{r4, r5, pc}
     da4:	40010800 	andmi	r0, r1, r0, lsl #16
     da8:	40010804 	andmi	r0, r1, r4, lsl #16
     dac:	20000488 	andcs	r0, r0, r8, lsl #9
     db0:	20000100 	andcs	r0, r0, r0, lsl #2
     db4:	2000013d 	andcs	r0, r0, sp, lsr r1

00000db8 <usbSuspend>:
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	4b04      	ldr	r3, [pc, #16]	; (dcc <usbSuspend+0x14>)
     dba:	681a      	ldr	r2, [r3, #0]
     dbc:	b292      	uxth	r2, r2
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dbe:	f042 020c 	orr.w	r2, r2, #12
     dc2:	601a      	str	r2, [r3, #0]

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	4b02      	ldr	r3, [pc, #8]	; (dd0 <usbSuspend+0x18>)
     dc6:	2203      	movs	r2, #3
     dc8:	601a      	str	r2, [r3, #0]
     dca:	4770      	bx	lr
     dcc:	40005c40 	andmi	r5, r0, r0, asr #24
     dd0:	200005b8 			; <UNDEFINED> instruction: 0x200005b8

00000dd4 <usbResumeInit>:
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	4b04      	ldr	r3, [pc, #16]	; (de8 <usbResumeInit+0x14>)
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd6:	f64f 72fb 	movw	r2, #65531	; 0xfffb
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dda:	6819      	ldr	r1, [r3, #0]
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     ddc:	400a      	ands	r2, r1
     dde:	601a      	str	r2, [r3, #0]

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	f44f 423f 	mov.w	r2, #48896	; 0xbf00
     de4:	601a      	str	r2, [r3, #0]
     de6:	4770      	bx	lr
     de8:	40005c40 	andmi	r5, r0, r0, asr #24

00000dec <usbResume>:
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	b510      	push	{r4, lr}
     dee:	4c1e      	ldr	r4, [pc, #120]	; (e68 <usbResume+0x7c>)
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	2807      	cmp	r0, #7
        ResumeS.eState = eResumeSetVal;
     df2:	bf18      	it	ne
     df4:	7020      	strbne	r0, [r4, #0]

    switch (ResumeS.eState) {
     df6:	7823      	ldrb	r3, [r4, #0]
     df8:	2b05      	cmp	r3, #5
     dfa:	d832      	bhi.n	e62 <usbResume+0x76>
     dfc:	e8df f003 	tbb	[pc, r3]
     e00:	0e0a0603 	cfmadd32eq	mvax0, mvfx0, mvfx10, mvfx3
     e04:	f7ff2116 			; <UNDEFINED> instruction: 0xf7ff2116
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	ffe5 e02a 	vaddl.u32	q15, d5, d26
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	f7ff ffe2 	bl	dd4 <usbResumeInit>
        ResumeS.eState = RESUME_START;
     e10:	2304      	movs	r3, #4
     e12:	e027      	b.n	e64 <usbResume+0x78>
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	2302      	movs	r3, #2
     e16:	7063      	strb	r3, [r4, #1]
        ResumeS.eState = RESUME_WAIT;
     e18:	2303      	movs	r3, #3
     e1a:	e023      	b.n	e64 <usbResume+0x78>
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	7863      	ldrb	r3, [r4, #1]
     e1e:	3b01      	subs	r3, #1
     e20:	b2db      	uxtb	r3, r3
     e22:	7063      	strb	r3, [r4, #1]
        if (ResumeS.bESOFcnt == 0)
     e24:	7863      	ldrb	r3, [r4, #1]
     e26:	b9f3      	cbnz	r3, e66 <usbResume+0x7a>
            ResumeS.eState = RESUME_START;
     e28:	2204      	movs	r2, #4
     e2a:	e017      	b.n	e5c <usbResume+0x70>
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	4b0f      	ldr	r3, [pc, #60]	; (e6c <usbResume+0x80>)
     e2e:	681a      	ldr	r2, [r3, #0]
     e30:	b292      	uxth	r2, r2
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e32:	f042 0210 	orr.w	r2, r2, #16
     e36:	601a      	str	r2, [r3, #0]
        ResumeS.eState = RESUME_ON;
     e38:	2305      	movs	r3, #5
     e3a:	7023      	strb	r3, [r4, #0]
        ResumeS.bESOFcnt = 10;
     e3c:	230a      	movs	r3, #10
     e3e:	7063      	strb	r3, [r4, #1]
        break;
     e40:	bd10      	pop	{r4, pc}
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e42:	7863      	ldrb	r3, [r4, #1]
     e44:	3b01      	subs	r3, #1
     e46:	b2db      	uxtb	r3, r3
     e48:	7063      	strb	r3, [r4, #1]
        if (ResumeS.bESOFcnt == 0) {
     e4a:	7863      	ldrb	r3, [r4, #1]
     e4c:	b95b      	cbnz	r3, e66 <usbResume+0x7a>
            wCNTR = _GetCNTR();
     e4e:	4a07      	ldr	r2, [pc, #28]	; (e6c <usbResume+0x80>)
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	f64f 73ef 	movw	r3, #65519	; 0xffef
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	6811      	ldr	r1, [r2, #0]
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e56:	400b      	ands	r3, r1
     e58:	6013      	str	r3, [r2, #0]
            ResumeS.eState = RESUME_OFF;
     e5a:	2206      	movs	r2, #6
     e5c:	4b02      	ldr	r3, [pc, #8]	; (e68 <usbResume+0x7c>)
     e5e:	701a      	strb	r2, [r3, #0]
     e60:	bd10      	pop	{r4, pc}
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e62:	2306      	movs	r3, #6
     e64:	7023      	strb	r3, [r4, #0]
     e66:	bd10      	pop	{r4, pc}
     e68:	2000048e 	andcs	r0, r0, lr, lsl #9
     e6c:	40005c40 	andmi	r5, r0, r0, asr #24

00000e70 <usbPowerOn>:
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	4b0d      	ldr	r3, [pc, #52]	; (ea8 <usbPowerOn+0x38>)
        break;
    }
}

RESULT usbPowerOn(void)
{
     e72:	b510      	push	{r4, lr}
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e74:	69da      	ldr	r2, [r3, #28]

    _SetCNTR(CNTR_FRES);
    _SetCNTR(0);
    _SetISTR(0);
     e76:	490d      	ldr	r1, [pc, #52]	; (eac <usbPowerOn+0x3c>)
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e78:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
     e7c:	61da      	str	r2, [r3, #28]

    _SetCNTR(CNTR_FRES);
     e7e:	f5a3 33d9 	sub.w	r3, r3, #111104	; 0x1b200
     e82:	f5a3 73e0 	sub.w	r3, r3, #448	; 0x1c0
    _SetCNTR(0);
     e86:	2400      	movs	r4, #0
RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;

    _SetCNTR(CNTR_FRES);
     e88:	2201      	movs	r2, #1
    _SetCNTR(0);
    _SetISTR(0);

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e8a:	4809      	ldr	r0, [pc, #36]	; (eb0 <usbPowerOn+0x40>)
RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;

    _SetCNTR(CNTR_FRES);
     e8c:	601a      	str	r2, [r3, #0]
    _SetCNTR(0);
     e8e:	601c      	str	r4, [r3, #0]
    _SetISTR(0);
     e90:	600c      	str	r4, [r1, #0]

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e92:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
     e96:	8001      	strh	r1, [r0, #0]
    _SetCNTR(wInterrupt_Mask);
     e98:	6019      	str	r1, [r3, #0]
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9a:	4806      	ldr	r0, [pc, #24]	; (eb4 <usbPowerOn+0x44>)
     e9c:	210c      	movs	r1, #12
     e9e:	f000 f941 	bl	1124 <gpio_write_bit>
#endif
#endif

    return USB_SUCCESS;
}
     ea2:	4620      	mov	r0, r4
     ea4:	bd10      	pop	{r4, pc}
     ea6:	bf00      	nop
     ea8:	40021000 	andmi	r1, r2, r0
     eac:	40005c44 	andmi	r5, r0, r4, asr #24
     eb0:	200005ac 	andcs	r0, r0, ip, lsr #11
     eb4:	40010800 	andmi	r0, r1, r0, lsl #16

00000eb8 <usbPowerOff>:

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	4b0a      	ldr	r3, [pc, #40]	; (ee4 <usbPowerOff+0x2c>)
     eba:	2201      	movs	r2, #1
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	b510      	push	{r4, lr}
    _SetCNTR(CNTR_FRES);
     ebe:	601a      	str	r2, [r3, #0]
    _SetISTR(0);
     ec0:	4a09      	ldr	r2, [pc, #36]	; (ee8 <usbPowerOff+0x30>)
     ec2:	2400      	movs	r4, #0
     ec4:	6014      	str	r4, [r2, #0]
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec6:	2203      	movs	r2, #3
     ec8:	601a      	str	r2, [r3, #0]
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     eca:	4808      	ldr	r0, [pc, #32]	; (eec <usbPowerOff+0x34>)
     ecc:	4622      	mov	r2, r4
     ece:	210c      	movs	r1, #12
     ed0:	f000 f928 	bl	1124 <gpio_write_bit>
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	4b06      	ldr	r3, [pc, #24]	; (ef0 <usbPowerOff+0x38>)

    return USB_SUCCESS;
}
     ed6:	4620      	mov	r0, r4
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed8:	69da      	ldr	r2, [r3, #28]
     eda:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
     ede:	61da      	str	r2, [r3, #28]

    return USB_SUCCESS;
}
     ee0:	bd10      	pop	{r4, pc}
     ee2:	bf00      	nop
     ee4:	40005c40 	andmi	r5, r0, r0, asr #24
     ee8:	40005c44 	andmi	r5, r0, r4, asr #24
     eec:	40010800 	andmi	r0, r1, r0, lsl #16
     ef0:	40021000 	andmi	r1, r2, r0

00000ef4 <usbDsbBus>:
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	f7ff bfe0 	b.w	eb8 <usbPowerOff>

00000ef8 <usbEnbISR>:
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	b507      	push	{r0, r1, r2, lr}
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efa:	2314      	movs	r3, #20
     efc:	f88d 3004 	strb.w	r3, [sp, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	2300      	movs	r3, #0
     f02:	f88d 3005 	strb.w	r3, [sp, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f06:	f88d 3006 	strb.w	r3, [sp, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
     f0a:	a801      	add	r0, sp, #4
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	2301      	movs	r3, #1
     f0e:	f88d 3007 	strb.w	r3, [sp, #7]
    nvicInit(&NVIC_InitStructure);
     f12:	f000 fa47 	bl	13a4 <nvicInit>
}
     f16:	b003      	add	sp, #12
     f18:	f85d fb04 	ldr.w	pc, [sp], #4

00000f1c <usbInit>:

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	b510      	push	{r4, lr}
    dfuInit();
     f1e:	f000 fb13 	bl	1548 <dfuInit>

    pInformation->Current_Configuration = 0;
     f22:	4b09      	ldr	r3, [pc, #36]	; (f48 <usbInit+0x2c>)
     f24:	2400      	movs	r4, #0
     f26:	681b      	ldr	r3, [r3, #0]
     f28:	729c      	strb	r4, [r3, #10]
    usbPowerOn();
     f2a:	f7ff ffa1 	bl	e70 <usbPowerOn>

    _SetISTR(0);
     f2e:	4b07      	ldr	r3, [pc, #28]	; (f4c <usbInit+0x30>)
    wInterrupt_Mask = ISR_MSK;
     f30:	4a07      	ldr	r2, [pc, #28]	; (f50 <usbInit+0x34>)
    dfuInit();

    pInformation->Current_Configuration = 0;
    usbPowerOn();

    _SetISTR(0);
     f32:	601c      	str	r4, [r3, #0]
    wInterrupt_Mask = ISR_MSK;
     f34:	f44f 433f 	mov.w	r3, #48896	; 0xbf00
     f38:	8013      	strh	r3, [r2, #0]
    _SetCNTR(wInterrupt_Mask);
     f3a:	4a06      	ldr	r2, [pc, #24]	; (f54 <usbInit+0x38>)
     f3c:	6013      	str	r3, [r2, #0]

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f3e:	f7ff ffdb 	bl	ef8 <usbEnbISR>
    bDeviceState = UNCONNECTED;
     f42:	4b05      	ldr	r3, [pc, #20]	; (f58 <usbInit+0x3c>)
     f44:	601c      	str	r4, [r3, #0]
     f46:	bd10      	pop	{r4, pc}
     f48:	200005a8 	andcs	r0, r0, r8, lsr #11
     f4c:	40005c44 	andmi	r5, r0, r4, asr #24
     f50:	200005ac 	andcs	r0, r0, ip, lsr #11
     f54:	40005c40 	andmi	r5, r0, r0, asr #24
     f58:	200005b8 			; <UNDEFINED> instruction: 0x200005b8

00000f5c <usbDsbISR>:
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	b507      	push	{r0, r1, r2, lr}
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f5e:	2314      	movs	r3, #20
     f60:	f88d 3004 	strb.w	r3, [sp, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	a801      	add	r0, sp, #4

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f66:	2300      	movs	r3, #0
     f68:	f88d 3005 	strb.w	r3, [sp, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	f88d 3006 	strb.w	r3, [sp, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	f88d 3007 	strb.w	r3, [sp, #7]
    nvicInit(&NVIC_InitStructure);
     f74:	f000 fa16 	bl	13a4 <nvicInit>
}
     f78:	b003      	add	sp, #12
     f7a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00000f80 <USB_LP_CAN1_RX0_IRQHandler>:

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	b570      	push	{r4, r5, r6, lr}
    wIstr = _GetISTR();
     f82:	4c27      	ldr	r4, [pc, #156]	; (1020 <USB_LP_CAN1_RX0_IRQHandler+0xa0>)
     f84:	4d27      	ldr	r5, [pc, #156]	; (1024 <USB_LP_CAN1_RX0_IRQHandler+0xa4>)
     f86:	6823      	ldr	r3, [r4, #0]

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	4e27      	ldr	r6, [pc, #156]	; (1028 <USB_LP_CAN1_RX0_IRQHandler+0xa8>)
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8a:	b29b      	uxth	r3, r3
     f8c:	802b      	strh	r3, [r5, #0]

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f8e:	882a      	ldrh	r2, [r5, #0]
     f90:	8833      	ldrh	r3, [r6, #0]
     f92:	4013      	ands	r3, r2
     f94:	0418      	lsls	r0, r3, #16
     f96:	d501      	bpl.n	f9c <USB_LP_CAN1_RX0_IRQHandler+0x1c>
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	f004 feac 	bl	5cf4 <CTR_LP>
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	882a      	ldrh	r2, [r5, #0]
     f9e:	8833      	ldrh	r3, [r6, #0]
     fa0:	4013      	ands	r3, r2
     fa2:	0559      	lsls	r1, r3, #21
     fa4:	d505      	bpl.n	fb2 <USB_LP_CAN1_RX0_IRQHandler+0x32>
        _SetISTR((u16)CLR_RESET);
     fa6:	f64f 33ff 	movw	r3, #64511	; 0xfbff
     faa:	6023      	str	r3, [r4, #0]
        Device_Property.Reset();
     fac:	4b1f      	ldr	r3, [pc, #124]	; (102c <USB_LP_CAN1_RX0_IRQHandler+0xac>)
     fae:	685b      	ldr	r3, [r3, #4]
     fb0:	4798      	blx	r3
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb2:	882a      	ldrh	r2, [r5, #0]
     fb4:	8833      	ldrh	r3, [r6, #0]
     fb6:	401a      	ands	r2, r3
     fb8:	0492      	lsls	r2, r2, #18
        _SetISTR((u16)CLR_ERR);
     fba:	bf44      	itt	mi
     fbc:	f64d 72ff 	movwmi	r2, #57343	; 0xdfff
     fc0:	6022      	strmi	r2, [r4, #0]
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc2:	882a      	ldrh	r2, [r5, #0]
     fc4:	4013      	ands	r3, r2
     fc6:	04d8      	lsls	r0, r3, #19
     fc8:	d505      	bpl.n	fd6 <USB_LP_CAN1_RX0_IRQHandler+0x56>
        _SetISTR((u16)CLR_WKUP);
     fca:	f64e 73ff 	movw	r3, #61439	; 0xefff
     fce:	6023      	str	r3, [r4, #0]
        usbResume(RESUME_EXTERNAL);
     fd0:	2000      	movs	r0, #0
     fd2:	f7ff ff0b 	bl	dec <usbResume>
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd6:	882a      	ldrh	r2, [r5, #0]
     fd8:	8833      	ldrh	r3, [r6, #0]
     fda:	4013      	ands	r3, r2
     fdc:	0519      	lsls	r1, r3, #20
     fde:	d504      	bpl.n	fea <USB_LP_CAN1_RX0_IRQHandler+0x6a>

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	f7ff feea 	bl	db8 <usbSuspend>
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
     fe8:	6023      	str	r3, [r4, #0]
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fea:	882a      	ldrh	r2, [r5, #0]
     fec:	8833      	ldrh	r3, [r6, #0]
     fee:	401a      	ands	r2, r3
     ff0:	0592      	lsls	r2, r2, #22
     ff2:	d507      	bpl.n	1004 <USB_LP_CAN1_RX0_IRQHandler+0x84>
        _SetISTR((u16)CLR_SOF);
     ff4:	f64f 52ff 	movw	r2, #65023	; 0xfdff
     ff8:	6022      	str	r2, [r4, #0]
        bIntPackSOF++;
     ffa:	4a0d      	ldr	r2, [pc, #52]	; (1030 <USB_LP_CAN1_RX0_IRQHandler+0xb0>)
     ffc:	7811      	ldrb	r1, [r2, #0]
     ffe:	3101      	adds	r1, #1
    1000:	b2c9      	uxtb	r1, r1
    1002:	7011      	strb	r1, [r2, #0]
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	882a      	ldrh	r2, [r5, #0]
    1006:	4013      	ands	r3, r2
    1008:	05db      	lsls	r3, r3, #23
    100a:	d507      	bpl.n	101c <USB_LP_CAN1_RX0_IRQHandler+0x9c>
        _SetISTR((u16)CLR_ESOF);
    100c:	f64f 63ff 	movw	r3, #65279	; 0xfeff
    1010:	6023      	str	r3, [r4, #0]
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1012:	2007      	movs	r0, #7
    }
#endif

}
    1014:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	f7ff bee8 	b.w	dec <usbResume>
    101c:	bd70      	pop	{r4, r5, r6, pc}
    101e:	bf00      	nop
    1020:	40005c44 	andmi	r5, r0, r4, asr #24
    1024:	2000048c 	andcs	r0, r0, ip, lsl #9
    1028:	200005ac 	andcs	r0, r0, ip, lsr #11
    102c:	20000014 	andcs	r0, r0, r4, lsl r0
    1030:	200005b4 			; <UNDEFINED> instruction: 0x200005b4

00001034 <print_hash>:
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

void print_hash(unsigned char hash[])
{
    1034:	4770      	bx	lr
	...

00001038 <main>:
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
}

int main() 
{
    1038:	b530      	push	{r4, r5, lr}
    103a:	b085      	sub	sp, #20
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    103c:	f000 f93a 	bl	12b4 <systemReset>
    setupCLK();
    1040:	f000 f95c 	bl	12fc <setupCLK>
    setupLEDAndButton();
    1044:	f000 f98a 	bl	135c <setupLEDAndButton>
    setupUSB();
    1048:	f7ff fe82 	bl	d50 <setupUSB>
    setupFLASH();
    104c:	f000 f990 	bl	1370 <setupFLASH>
    uartInit();
    1050:	f000 f8ec 	bl	122c <uartInit>
    usbReset();
    1054:	f7ff fdc2 	bl	bdc <usbReset>
	uart_printf("\nBootloader init...\n");
    1058:	4827      	ldr	r0, [pc, #156]	; (10f8 <main+0xc0>)
    105a:	f000 f8c3 	bl	11e4 <uart_printf>

    if (readPin(GPIOB, 15) == 0x0)
    105e:	210f      	movs	r1, #15
    1060:	4826      	ldr	r0, [pc, #152]	; (10fc <main+0xc4>)
    1062:	f000 f86a 	bl	113a <readPin>
    1066:	4604      	mov	r4, r0
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1068:	4825      	ldr	r0, [pc, #148]	; (1100 <main+0xc8>)
    106a:	f000 f8bb 	bl	11e4 <uart_printf>
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    106e:	a803      	add	r0, sp, #12
    1070:	4924      	ldr	r1, [pc, #144]	; (1104 <main+0xcc>)
    1072:	2200      	movs	r2, #0
    1074:	f004 fce0 	bl	5a38 <imageCheckFromAddress>
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
    1078:	2803      	cmp	r0, #3
    107a:	d008      	beq.n	108e <main+0x56>
    107c:	2804      	cmp	r0, #4
    107e:	d00b      	beq.n	1098 <main+0x60>
    1080:	2802      	cmp	r0, #2
    1082:	d00b      	beq.n	109c <main+0x64>
   debug_print("\n", 0);
}

int main() 
{
	bool no_user_jump = FALSE;
    1084:	f1d4 0401 	rsbs	r4, r4, #1
    1088:	bf38      	it	cc
    108a:	2400      	movcc	r4, #0
    108c:	e00a      	b.n	10a4 <main+0x6c>
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    108e:	481e      	ldr	r0, [pc, #120]	; (1108 <main+0xd0>)
    1090:	f000 f8a8 	bl	11e4 <uart_printf>
			no_user_jump = FALSE;
    1094:	2400      	movs	r4, #0
			break;
    1096:	e005      	b.n	10a4 <main+0x6c>

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    1098:	481c      	ldr	r0, [pc, #112]	; (110c <main+0xd4>)
    109a:	e000      	b.n	109e <main+0x66>
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    109c:	481c      	ldr	r0, [pc, #112]	; (1110 <main+0xd8>)
    109e:	f000 f8a1 	bl	11e4 <uart_printf>
			no_user_jump = TRUE;
    10a2:	2401      	movs	r4, #1
			break;

		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10a4:	2500      	movs	r5, #0
    10a6:	9500      	str	r5, [sp, #0]
    10a8:	481a      	ldr	r0, [pc, #104]	; (1114 <main+0xdc>)
    10aa:	210d      	movs	r1, #13
    10ac:	2205      	movs	r2, #5
    10ae:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
    10b2:	f000 f84b 	bl	114c <strobePin>

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10b6:	2d05      	cmp	r5, #5
    10b8:	dc12      	bgt.n	10e0 <main+0xa8>
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10ba:	2300      	movs	r3, #0
    10bc:	9300      	str	r3, [sp, #0]
    10be:	4815      	ldr	r0, [pc, #84]	; (1114 <main+0xdc>)
    10c0:	210d      	movs	r1, #13
    10c2:	2201      	movs	r2, #1
    10c4:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
    10c8:	f000 f840 	bl	114c <strobePin>

		if (dfuUploadStarted()) 
    10cc:	f000 fc40 	bl	1950 <dfuUploadStarted>
    10d0:	b120      	cbz	r0, 10dc <main+0xa4>
		{
			uart_printf("DFU finished upload\n");
    10d2:	4811      	ldr	r0, [pc, #68]	; (1118 <main+0xe0>)
    10d4:	f000 f886 	bl	11e4 <uart_printf>
			dfuFinishUpload(); // systemHardReset from DFU once done
    10d8:	f000 fc40 	bl	195c <dfuFinishUpload>
    10dc:	3501      	adds	r5, #1
    10de:	e7ea      	b.n	10b6 <main+0x7e>
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10e0:	2c00      	cmp	r4, #0
    10e2:	d1ea      	bne.n	10ba <main+0x82>
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10e4:	480d      	ldr	r0, [pc, #52]	; (111c <main+0xe4>)
    10e6:	f000 f87d 	bl	11e4 <uart_printf>
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10ea:	480d      	ldr	r0, [pc, #52]	; (1120 <main+0xe8>)
    10ec:	f000 f9a2 	bl	1434 <jumpToUser>
	}
	
	return 0;// Added to please the compiler
    10f0:	4620      	mov	r0, r4
    10f2:	b005      	add	sp, #20
    10f4:	bd30      	pop	{r4, r5, pc}
    10f6:	bf00      	nop
    10f8:	00006f90 	muleq	r0, r0, pc	; <UNPREDICTABLE>
    10fc:	40010c00 	andmi	r0, r1, r0, lsl #24
    1100:	00006fa5 	andeq	r6, r0, r5, lsr #31
    1104:	08008000 	stmdaeq	r0, {pc}
    1108:	00006fb8 			; <UNDEFINED> instruction: 0x00006fb8
    110c:	00006fc1 	andeq	r6, r0, r1, asr #31
    1110:	00006fe5 	andeq	r6, r0, r5, ror #31
    1114:	40011000 	andmi	r1, r1, r0
    1118:	0000700d 	andeq	r7, r0, sp
    111c:	00007022 	andeq	r7, r0, r2, lsr #32
    1120:	08008084 	stmdaeq	r0, {r2, r7, pc}

00001124 <gpio_write_bit>:
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1124:	2301      	movs	r3, #1
    1126:	fa03 f101 	lsl.w	r1, r3, r1
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    112a:	f1d2 0201 	rsbs	r2, r2, #1
    112e:	bf38      	it	cc
    1130:	2200      	movcc	r2, #0
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1132:	0113      	lsls	r3, r2, #4
    1134:	4099      	lsls	r1, r3
    1136:	6101      	str	r1, [r0, #16]
    1138:	4770      	bx	lr

0000113a <readPin>:
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    113a:	2201      	movs	r2, #1
    113c:	fa02 f101 	lsl.w	r1, r2, r1
    1140:	6883      	ldr	r3, [r0, #8]
    1142:	420b      	tst	r3, r1
        return TRUE;
    } else {
        return FALSE;
    }
}
    1144:	bf0c      	ite	eq
    1146:	2000      	moveq	r0, #0
    1148:	2001      	movne	r0, #1
    114a:	4770      	bx	lr

0000114c <strobePin>:

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    114c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1150:	f89d a020 	ldrb.w	sl, [sp, #32]
    1154:	4614      	mov	r4, r2
    gpio_write_bit( bank,pin,1-onState);
    1156:	f1ca 0701 	rsb	r7, sl, #1
    115a:	b2ff      	uxtb	r7, r7
    115c:	463a      	mov	r2, r7
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    115e:	4680      	mov	r8, r0
    1160:	4689      	mov	r9, r1
    1162:	461e      	mov	r6, r3
    gpio_write_bit( bank,pin,1-onState);
    1164:	f7ff ffde 	bl	1124 <gpio_write_bit>

    u32 c;
    while (count-- > 0) 
    1168:	b1b4      	cbz	r4, 1198 <strobePin+0x4c>
    116a:	4635      	mov	r5, r6
	{
        for (c = rate; c > 0; c--)
    116c:	b115      	cbz	r5, 1174 <strobePin+0x28>
		{
            asm volatile("nop");
    116e:	bf00      	nop
    gpio_write_bit( bank,pin,1-onState);

    u32 c;
    while (count-- > 0) 
	{
        for (c = rate; c > 0; c--)
    1170:	3d01      	subs	r5, #1
    1172:	e7fb      	b.n	116c <strobePin+0x20>
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1174:	4640      	mov	r0, r8
    1176:	4649      	mov	r1, r9
    1178:	4652      	mov	r2, sl
    117a:	f7ff ffd3 	bl	1124 <gpio_write_bit>
		
        for (c = rate; c > 0; c--)
    117e:	4635      	mov	r5, r6
    1180:	b115      	cbz	r5, 1188 <strobePin+0x3c>
		{
            asm volatile("nop");
    1182:	bf00      	nop
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
		
        for (c = rate; c > 0; c--)
    1184:	3d01      	subs	r5, #1
    1186:	e7fb      	b.n	1180 <strobePin+0x34>
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    1188:	4640      	mov	r0, r8
    118a:	4649      	mov	r1, r9
    118c:	463a      	mov	r2, r7
    118e:	3c01      	subs	r4, #1
    1190:	f7ff ffc8 	bl	1124 <gpio_write_bit>
    1194:	b2e4      	uxtb	r4, r4
    1196:	e7e7      	b.n	1168 <strobePin+0x1c>
    1198:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0000119c <UU_PutChar>:

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    119c:	8803      	ldrh	r3, [r0, #0]
    119e:	061b      	lsls	r3, r3, #24
    11a0:	d5fc      	bpl.n	119c <UU_PutChar>
  USARTx->DR = ch;  
    11a2:	8081      	strh	r1, [r0, #4]
    11a4:	4770      	bx	lr

000011a6 <UU_PutString>:
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11a6:	b538      	push	{r3, r4, r5, lr}
    11a8:	4605      	mov	r5, r0
    11aa:	1e4c      	subs	r4, r1, #1
  while(*str != 0)
    11ac:	f814 1f01 	ldrb.w	r1, [r4, #1]!
    11b0:	b119      	cbz	r1, 11ba <UU_PutString+0x14>
  {
    UU_PutChar(USARTx, *str);
    11b2:	4628      	mov	r0, r5
    11b4:	f7ff fff2 	bl	119c <UU_PutChar>
    11b8:	e7f8      	b.n	11ac <UU_PutString+0x6>
    str++;
  }
}
    11ba:	bd38      	pop	{r3, r4, r5, pc}

000011bc <vprint>:

void vprint(const char *fmt, va_list argp)
{
    11bc:	b500      	push	{lr}
    11be:	4603      	mov	r3, r0
    11c0:	b0b3      	sub	sp, #204	; 0xcc
    11c2:	460a      	mov	r2, r1
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11c4:	4668      	mov	r0, sp
    11c6:	4619      	mov	r1, r3
    11c8:	f005 fad2 	bl	6770 <vsiprintf>
    11cc:	2800      	cmp	r0, #0
    11ce:	dd03      	ble.n	11d8 <vprint+0x1c>
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11d0:	4803      	ldr	r0, [pc, #12]	; (11e0 <vprint+0x24>)
    11d2:	4669      	mov	r1, sp
    11d4:	f7ff ffe7 	bl	11a6 <UU_PutString>

    }
}
    11d8:	b033      	add	sp, #204	; 0xcc
    11da:	f85d fb04 	ldr.w	pc, [sp], #4
    11de:	bf00      	nop
    11e0:	40013800 	andmi	r3, r1, r0, lsl #16

000011e4 <uart_printf>:

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11e4:	b40f      	push	{r0, r1, r2, r3}
    11e6:	b507      	push	{r0, r1, r2, lr}
    11e8:	a904      	add	r1, sp, #16
    11ea:	f851 0b04 	ldr.w	r0, [r1], #4
    va_list argp;
    va_start(argp, fmt);
    11ee:	9101      	str	r1, [sp, #4]
    vprint(fmt, argp);
    11f0:	f7ff ffe4 	bl	11bc <vprint>
    va_end(argp);
}
    11f4:	b003      	add	sp, #12
    11f6:	f85d eb04 	ldr.w	lr, [sp], #4
    11fa:	b004      	add	sp, #16
    11fc:	4770      	bx	lr

000011fe <hexdump>:

void hexdump(unsigned char *data, size_t size)
{
    11fe:	b530      	push	{r4, r5, lr}
    1200:	b087      	sub	sp, #28
    1202:	460d      	mov	r5, r1
    int i;
    char cs[17];
    memset(cs, 0, 17);
    1204:	a801      	add	r0, sp, #4
    1206:	2100      	movs	r1, #0
    1208:	2211      	movs	r2, #17
    120a:	f005 fa90 	bl	672e <memset>

    for(i = 0; i < size; i++)
    120e:	2400      	movs	r4, #0
    1210:	42ac      	cmp	r4, r5
    1212:	d009      	beq.n	1228 <hexdump+0x2a>
    {
        if(i != 0 && i % 0x10 == 0)
    1214:	b134      	cbz	r4, 1224 <hexdump+0x26>
    1216:	f014 010f 	ands.w	r1, r4, #15
    121a:	d103      	bne.n	1224 <hexdump+0x26>
        {
            debug_print(" |%s|\n", cs);
            memset(cs, 0, 17);
    121c:	a801      	add	r0, sp, #4
    121e:	2211      	movs	r2, #17
    1220:	f005 fa85 	bl	672e <memset>
{
    int i;
    char cs[17];
    memset(cs, 0, 17);

    for(i = 0; i < size; i++)
    1224:	3401      	adds	r4, #1
    1226:	e7f3      	b.n	1210 <hexdump+0x12>
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
}
    1228:	b007      	add	sp, #28
    122a:	bd30      	pop	{r4, r5, pc}

0000122c <uartInit>:


#endif
void uartInit(void) {
    122c:	b510      	push	{r4, lr}
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    122e:	4c20      	ldr	r4, [pc, #128]	; (12b0 <uartInit+0x84>)
    debug_print(" |%s|\n", cs);
}


#endif
void uartInit(void) {
    1230:	b086      	sub	sp, #24
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    1232:	f44f 4080 	mov.w	r0, #16384	; 0x4000
    1236:	2101      	movs	r1, #1
    1238:	f7ff fa0a 	bl	650 <RCC_APB2PeriphClockCmd>
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    123c:	4620      	mov	r0, r4
    123e:	2101      	movs	r1, #1
    1240:	f7ff fa06 	bl	650 <RCC_APB2PeriphClockCmd>
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    1244:	f44f 7300 	mov.w	r3, #512	; 0x200
    1248:	f8ad 3004 	strh.w	r3, [sp, #4]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    124c:	2303      	movs	r3, #3
    124e:	f88d 3006 	strb.w	r3, [sp, #6]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1252:	4620      	mov	r0, r4
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1254:	2318      	movs	r3, #24
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1256:	a901      	add	r1, sp, #4
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1258:	f88d 3007 	strb.w	r3, [sp, #7]
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    125c:	f7fe ffc2 	bl	1e4 <GPIO_Init>
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    1260:	f44f 6380 	mov.w	r3, #1024	; 0x400
    1264:	f8ad 3004 	strh.w	r3, [sp, #4]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1268:	2304      	movs	r3, #4
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    126a:	eb0d 0103 	add.w	r1, sp, r3
    126e:	4620      	mov	r0, r4
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1270:	f88d 3007 	strb.w	r3, [sp, #7]
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1274:	f7fe ffb6 	bl	1e4 <GPIO_Init>
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1278:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
    127c:	9302      	str	r3, [sp, #8]
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    127e:	f504 5440 	add.w	r4, r4, #12288	; 0x3000
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    1282:	2300      	movs	r3, #0
    1284:	f8ad 300c 	strh.w	r3, [sp, #12]
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1288:	f8ad 300e 	strh.w	r3, [sp, #14]
    USART_InitStructure.USART_Parity = USART_Parity_No;
    128c:	f8ad 3010 	strh.w	r3, [sp, #16]
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    1290:	f8ad 3014 	strh.w	r3, [sp, #20]
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1294:	a902      	add	r1, sp, #8
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    1296:	230c      	movs	r3, #12
        
    USART_Init(USART1, &USART_InitStructure);
    1298:	4620      	mov	r0, r4
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    129a:	f8ad 3012 	strh.w	r3, [sp, #18]
        
    USART_Init(USART1, &USART_InitStructure);
    129e:	f7ff faa3 	bl	7e8 <USART_Init>
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    12a2:	4620      	mov	r0, r4
    12a4:	2101      	movs	r1, #1
    12a6:	f7ff fb21 	bl	8ec <USART_Cmd>
}
    12aa:	b006      	add	sp, #24
    12ac:	bd10      	pop	{r4, pc}
    12ae:	bf00      	nop
    12b0:	40010800 	andmi	r0, r1, r0, lsl #16

000012b4 <systemReset>:

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    12b4:	4b0d      	ldr	r3, [pc, #52]	; (12ec <systemReset+0x38>)
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    12b6:	490e      	ldr	r1, [pc, #56]	; (12f0 <systemReset+0x3c>)
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
}

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    12b8:	681a      	ldr	r2, [r3, #0]
    12ba:	f042 0201 	orr.w	r2, r2, #1
    12be:	601a      	str	r2, [r3, #0]
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    12c0:	4a0c      	ldr	r2, [pc, #48]	; (12f4 <systemReset+0x40>)
    12c2:	6810      	ldr	r0, [r2, #0]
    12c4:	4001      	ands	r1, r0
    12c6:	6011      	str	r1, [r2, #0]
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    12c8:	6819      	ldr	r1, [r3, #0]
    12ca:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
    12ce:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
    12d2:	6019      	str	r1, [r3, #0]
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    12d4:	6819      	ldr	r1, [r3, #0]
    12d6:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
    12da:	6019      	str	r1, [r3, #0]
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    12dc:	6813      	ldr	r3, [r2, #0]
    12de:	f423 03fe 	bic.w	r3, r3, #8323072	; 0x7f0000
    12e2:	6013      	str	r3, [r2, #0]

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    12e4:	4b04      	ldr	r3, [pc, #16]	; (12f8 <systemReset+0x44>)
    12e6:	2200      	movs	r2, #0
    12e8:	601a      	str	r2, [r3, #0]
    12ea:	4770      	bx	lr
    12ec:	40021000 	andmi	r1, r2, r0
    12f0:	f8ff0000 			; <UNDEFINED> instruction: 0xf8ff0000
    12f4:	40021004 	andmi	r1, r2, r4
    12f8:	40021008 	andmi	r1, r2, r8

000012fc <setupCLK>:
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    12fc:	4b15      	ldr	r3, [pc, #84]	; (1354 <setupCLK+0x58>)
    12fe:	681a      	ldr	r2, [r3, #0]
    1300:	f042 1201 	orr.w	r2, r2, #65537	; 0x10001
    1304:	601a      	str	r2, [r3, #0]
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    1306:	681a      	ldr	r2, [r3, #0]
    1308:	4812      	ldr	r0, [pc, #72]	; (1354 <setupCLK+0x58>)
    130a:	0392      	lsls	r2, r2, #14
    130c:	d5fb      	bpl.n	1306 <setupCLK+0xa>

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    130e:	4a12      	ldr	r2, [pc, #72]	; (1358 <setupCLK+0x5c>)
    1310:	2112      	movs	r1, #18
    1312:	6011      	str	r1, [r2, #0]
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    1314:	f6a2 72fc 	subw	r2, r2, #4092	; 0xffc
    1318:	6811      	ldr	r1, [r2, #0]
    131a:	f441 11e8 	orr.w	r1, r1, #1900544	; 0x1d0000
    131e:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
    1322:	6011      	str	r1, [r2, #0]
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    1324:	6801      	ldr	r1, [r0, #0]
    1326:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
    132a:	6001      	str	r1, [r0, #0]

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    132c:	6819      	ldr	r1, [r3, #0]
    132e:	f011 7f40 	tst.w	r1, #50331648	; 0x3000000
    1332:	d0fb      	beq.n	132c <setupCLK+0x30>
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    1334:	6811      	ldr	r1, [r2, #0]
    1336:	f041 0102 	orr.w	r1, r1, #2
    133a:	6011      	str	r1, [r2, #0]
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    133c:	6811      	ldr	r1, [r2, #0]
    133e:	0709      	lsls	r1, r1, #28
    1340:	d5fc      	bpl.n	133c <setupCLK+0x40>
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    1342:	699a      	ldr	r2, [r3, #24]
    1344:	f442 72fe 	orr.w	r2, r2, #508	; 0x1fc
    1348:	619a      	str	r2, [r3, #24]
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    134a:	69da      	ldr	r2, [r3, #28]
    134c:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
    1350:	61da      	str	r2, [r3, #28]
    1352:	4770      	bx	lr
    1354:	40021000 	andmi	r1, r2, r0
    1358:	40022000 	andmi	r2, r2, r0

0000135c <setupLEDAndButton>:

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    135c:	4b03      	ldr	r3, [pc, #12]	; (136c <setupLEDAndButton+0x10>)
    135e:	681a      	ldr	r2, [r3, #0]
    1360:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    1364:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    1368:	601a      	str	r2, [r3, #0]
    136a:	4770      	bx	lr
    136c:	40011004 	andmi	r1, r1, r4

00001370 <setupFLASH>:
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    1370:	4b05      	ldr	r3, [pc, #20]	; (1388 <setupFLASH+0x18>)
    1372:	681a      	ldr	r2, [r3, #0]
    1374:	07d1      	lsls	r1, r2, #31
    1376:	d403      	bmi.n	1380 <setupFLASH+0x10>
        u32 rwmVal = pRCC->CR;
    1378:	681a      	ldr	r2, [r3, #0]
        rwmVal |= 0x01;
    137a:	f042 0201 	orr.w	r2, r2, #1
        pRCC->CR = rwmVal;
    137e:	601a      	str	r2, [r3, #0]
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    1380:	681a      	ldr	r2, [r3, #0]
    1382:	0792      	lsls	r2, r2, #30
    1384:	d5fc      	bpl.n	1380 <setupFLASH+0x10>
}   
    1386:	4770      	bx	lr
    1388:	40021000 	andmi	r1, r2, r0

0000138c <setMspAndJump>:
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    138c:	4a04      	ldr	r2, [pc, #16]	; (13a0 <setMspAndJump+0x14>)
    }*/

    return 0x3;
}

void setMspAndJump(u32 usrAddr) {
    138e:	b508      	push	{r3, lr}
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    1390:	6843      	ldr	r3, [r0, #4]

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    1392:	6010      	str	r0, [r2, #0]

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1394:	6802      	ldr	r2, [r0, #0]

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1396:	f382 8808 	msr	MSP, r2
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    139a:	4798      	blx	r3
    139c:	bd08      	pop	{r3, pc}
    139e:	bf00      	nop
    13a0:	e000ed08 	and	lr, r0, r8, lsl #26

000013a4 <nvicInit>:
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    13a4:	4b18      	ldr	r3, [pc, #96]	; (1408 <nvicInit+0x64>)
		pRCC->APB1ENR &= ~(RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
	}
    return flagSet;
}

void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
    13a6:	b530      	push	{r4, r5, lr}
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    13a8:	68db      	ldr	r3, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    13aa:	7844      	ldrb	r4, [r0, #1]
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    13ac:	43db      	mvns	r3, r3
    13ae:	f3c3 2302 	ubfx	r3, r3, #8, #3
    tmppre = (0x4 - tmppriority);
    13b2:	f1c3 0204 	rsb	r2, r3, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    13b6:	fa04 f202 	lsl.w	r2, r4, r2


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    13ba:	240f      	movs	r4, #15
    13bc:	40dc      	lsrs	r4, r3

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    13be:	7881      	ldrb	r1, [r0, #2]

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c0:	7803      	ldrb	r3, [r0, #0]
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    13c2:	400c      	ands	r4, r1
    13c4:	4314      	orrs	r4, r2

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c6:	f003 0103 	and.w	r1, r3, #3
    13ca:	00c9      	lsls	r1, r1, #3
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    13cc:	0124      	lsls	r4, r4, #4
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13ce:	22ff      	movs	r2, #255	; 0xff

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d0:	408c      	lsls	r4, r1

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d2:	408a      	lsls	r2, r1
    13d4:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    13d8:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    13dc:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    13e0:	f8d3 5300 	ldr.w	r5, [r3, #768]	; 0x300
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    13e4:	ea25 0102 	bic.w	r1, r5, r2
    tmppriority &= tmpmask;
    13e8:	4022      	ands	r2, r4
    tmpreg |= tmppriority;
    13ea:	430a      	orrs	r2, r1

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    13ec:	f8c3 2300 	str.w	r2, [r3, #768]	; 0x300

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    13f0:	7803      	ldrb	r3, [r0, #0]
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    13f2:	2201      	movs	r2, #1
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    13f4:	0959      	lsrs	r1, r3, #5
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    13f6:	f003 031f 	and.w	r3, r3, #31
    13fa:	fa02 f303 	lsl.w	r3, r2, r3
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    13fe:	4a03      	ldr	r2, [pc, #12]	; (140c <nvicInit+0x68>)
    1400:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    1404:	bd30      	pop	{r4, r5, pc}
    1406:	bf00      	nop
    1408:	e000ed00 	and	lr, r0, r0, lsl #26
    140c:	e000e100 	and	lr, r0, r0, lsl #2

00001410 <nvicDisableInterrupts>:
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    1410:	4b07      	ldr	r3, [pc, #28]	; (1430 <nvicDisableInterrupts+0x20>)
    1412:	f04f 32ff 	mov.w	r2, #4294967295
    1416:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    rNVIC->ICER[1] = 0xFFFFFFFF;
    141a:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    141e:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    1422:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    1426:	2204      	movs	r2, #4
    1428:	f843 2cf0 	str.w	r2, [r3, #-240]
    142c:	4770      	bx	lr
    142e:	bf00      	nop
    1430:	e000e100 	and	lr, r0, r0, lsl #2

00001434 <jumpToUser>:

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    1434:	b510      	push	{r4, lr}
    1436:	4604      	mov	r4, r0
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    1438:	f7ff fd90 	bl	f5c <usbDsbISR>
    nvicDisableInterrupts();
    143c:	f7ff ffe8 	bl	1410 <nvicDisableInterrupts>
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    1440:	f7ff fd58 	bl	ef4 <usbDsbBus>
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    1444:	f7ff ff36 	bl	12b4 <systemReset>
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    1448:	4620      	mov	r0, r4
}
    144a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    144e:	f7ff bf9d 	b.w	138c <setMspAndJump>
	...

00001454 <systemHardReset>:

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1454:	4a02      	ldr	r2, [pc, #8]	; (1460 <systemHardReset+0xc>)
    1456:	4b03      	ldr	r3, [pc, #12]	; (1464 <systemHardReset+0x10>)
    1458:	60da      	str	r2, [r3, #12]

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    145a:	bf00      	nop
    145c:	e7fd      	b.n	145a <systemHardReset+0x6>
    145e:	bf00      	nop
    1460:	05fa0004 	ldrbeq	r0, [sl, #4]!
    1464:	e000ed00 	and	lr, r0, r0, lsl #26

00001468 <flashErasePage>:
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1468:	4b0a      	ldr	r3, [pc, #40]	; (1494 <flashErasePage+0x2c>)
    while (1) {
        asm volatile("nop");
    }
}

bool flashErasePage(u32 pageAddr) {
    146a:	b510      	push	{r4, lr}
    u32 rwmVal = GET_REG(FLASH_CR);
    146c:	681a      	ldr	r2, [r3, #0]
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    146e:	2202      	movs	r2, #2
    1470:	601a      	str	r2, [r3, #0]

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1472:	4a09      	ldr	r2, [pc, #36]	; (1498 <flashErasePage+0x30>)
    1474:	6811      	ldr	r1, [r2, #0]
    1476:	4614      	mov	r4, r2
    1478:	f011 0f01 	tst.w	r1, #1
    147c:	d1f9      	bne.n	1472 <flashErasePage+0xa>
    SET_REG(FLASH_AR, pageAddr);
    147e:	6090      	str	r0, [r2, #8]
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    1480:	2242      	movs	r2, #66	; 0x42
    1482:	601a      	str	r2, [r3, #0]
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1484:	6822      	ldr	r2, [r4, #0]
    1486:	f012 0101 	ands.w	r1, r2, #1
    148a:	d1fb      	bne.n	1484 <flashErasePage+0x1c>

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    148c:	6019      	str	r1, [r3, #0]

    return TRUE;
}
    148e:	2001      	movs	r0, #1
    1490:	bd10      	pop	{r4, pc}
    1492:	bf00      	nop
    1494:	40022010 	andmi	r2, r2, r0, lsl r0
    1498:	4002200c 	andmi	r2, r2, ip

0000149c <flashWriteWord>:
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    149c:	b537      	push	{r0, r1, r2, r4, r5, lr}
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    149e:	b28b      	uxth	r3, r1
    14a0:	9300      	str	r3, [sp, #0]
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    14a2:	0c0b      	lsrs	r3, r1, #16
    14a4:	9301      	str	r3, [sp, #4]

    u32 rwmVal = GET_REG(FLASH_CR);
    14a6:	4b0e      	ldr	r3, [pc, #56]	; (14e0 <flashWriteWord+0x44>)
    SET_REG(FLASH_CR, FLASH_CR_PG);
    14a8:	2201      	movs	r2, #1
bool flashWriteWord(u32 addr, u32 word) {
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;

    u32 rwmVal = GET_REG(FLASH_CR);
    14aa:	681c      	ldr	r4, [r3, #0]
    SET_REG(FLASH_CR, FLASH_CR_PG);
    14ac:	601a      	str	r2, [r3, #0]

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14ae:	4a0d      	ldr	r2, [pc, #52]	; (14e4 <flashWriteWord+0x48>)
    14b0:	6815      	ldr	r5, [r2, #0]
    14b2:	07ed      	lsls	r5, r5, #31
    14b4:	d4fb      	bmi.n	14ae <flashWriteWord+0x12>
    *(flashAddr + 0x01) = (vu16)hhWord;
    14b6:	9d01      	ldr	r5, [sp, #4]
    14b8:	b2ad      	uxth	r5, r5
    14ba:	8045      	strh	r5, [r0, #2]
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14bc:	6815      	ldr	r5, [r2, #0]
    14be:	07ed      	lsls	r5, r5, #31
    14c0:	d4fc      	bmi.n	14bc <flashWriteWord+0x20>
    *(flashAddr) = (vu16)lhWord;
    14c2:	9d00      	ldr	r5, [sp, #0]
    14c4:	b2ad      	uxth	r5, r5
    14c6:	8005      	strh	r5, [r0, #0]
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14c8:	6815      	ldr	r5, [r2, #0]
    14ca:	07ed      	lsls	r5, r5, #31
    14cc:	d4fc      	bmi.n	14c8 <flashWriteWord+0x2c>

    rwmVal &= 0xFFFFFFFE;
    14ce:	f024 0201 	bic.w	r2, r4, #1
    SET_REG(FLASH_CR, rwmVal);
    14d2:	601a      	str	r2, [r3, #0]

    /* verify the write */
    if (*(vu32 *)addr != word) {
    14d4:	6800      	ldr	r0, [r0, #0]
        return FALSE;
    }

    return TRUE;
}
    14d6:	1a43      	subs	r3, r0, r1
    14d8:	4258      	negs	r0, r3
    14da:	4158      	adcs	r0, r3
    14dc:	b003      	add	sp, #12
    14de:	bd30      	pop	{r4, r5, pc}
    14e0:	40022010 	andmi	r2, r2, r0, lsl r0
    14e4:	4002200c 	andmi	r2, r2, ip

000014e8 <flashLock>:

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    14e8:	4b01      	ldr	r3, [pc, #4]	; (14f0 <flashLock+0x8>)
    14ea:	2280      	movs	r2, #128	; 0x80
    14ec:	601a      	str	r2, [r3, #0]
    14ee:	4770      	bx	lr
    14f0:	40022010 	andmi	r2, r2, r0, lsl r0

000014f4 <flashUnlock>:
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    14f4:	4b03      	ldr	r3, [pc, #12]	; (1504 <flashUnlock+0x10>)
    14f6:	4a04      	ldr	r2, [pc, #16]	; (1508 <flashUnlock+0x14>)
    14f8:	601a      	str	r2, [r3, #0]
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    14fa:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
    14fe:	601a      	str	r2, [r3, #0]
    1500:	4770      	bx	lr
    1502:	bf00      	nop
    1504:	40022004 	andmi	r2, r2, r4
    1508:	45670123 	strbmi	r0, [r7, #-291]!	; 0x123

0000150c <crMask>:

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    150c:	2807      	cmp	r0, #7
	{
		pin-=8;
    150e:	bfc8      	it	gt
    1510:	3808      	subgt	r0, #8
	}
	mask = 0x0F << (pin<<2);
    1512:	230f      	movs	r3, #15
    1514:	0080      	lsls	r0, r0, #2
    1516:	fa03 f000 	lsl.w	r0, r3, r0
	return ~mask;
}	
    151a:	43c0      	mvns	r0, r0
    151c:	4770      	bx	lr
	...

00001520 <getFlashEnd>:

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    1520:	4b02      	ldr	r3, [pc, #8]	; (152c <getFlashEnd+0xc>)
    1522:	8818      	ldrh	r0, [r3, #0]
    1524:	f500 3000 	add.w	r0, r0, #131072	; 0x20000
}
    1528:	0280      	lsls	r0, r0, #10
    152a:	4770      	bx	lr
    152c:	1ffff7e0 	svcne	0x00fff7e0

00001530 <getFlashPageSize>:

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    1530:	4b04      	ldr	r3, [pc, #16]	; (1544 <getFlashPageSize+0x14>)
    1532:	881b      	ldrh	r3, [r3, #0]
	{
		return 0x800;
    1534:	2b81      	cmp	r3, #129	; 0x81
	}
	else
	{
		return 0x400;
	}
}
    1536:	bf34      	ite	cc
    1538:	f44f 6080 	movcc.w	r0, #1024	; 0x400
    153c:	f44f 6000 	movcs.w	r0, #2048	; 0x800
    1540:	4770      	bx	lr
    1542:	bf00      	nop
    1544:	1ffff7e0 	svcne	0x00fff7e0

00001548 <dfuInit>:

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1548:	4a15      	ldr	r2, [pc, #84]	; (15a0 <dfuInit+0x58>)


volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    154a:	b508      	push	{r3, lr}
    dfuAppStatus.bStatus = OK;
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    154c:	2102      	movs	r1, #2

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    154e:	2300      	movs	r3, #0
    1550:	7013      	strb	r3, [r2, #0]
    dfuAppStatus.bwPollTimeout0 = 0x00;
    1552:	7053      	strb	r3, [r2, #1]
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1554:	7093      	strb	r3, [r2, #2]
    dfuAppStatus.bwPollTimeout2 = 0x00;
    1556:	70d3      	strb	r3, [r2, #3]
    dfuAppStatus.bState = dfuIDLE;
    1558:	7111      	strb	r1, [r2, #4]
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    155a:	7153      	strb	r3, [r2, #5]
    userFirmwareLen = 0;
    155c:	4a11      	ldr	r2, [pc, #68]	; (15a4 <dfuInit+0x5c>)
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    155e:	4912      	ldr	r1, [pc, #72]	; (15a8 <dfuInit+0x60>)
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    1560:	6013      	str	r3, [r2, #0]
    thisBlockLen = 0;;
    1562:	4a12      	ldr	r2, [pc, #72]	; (15ac <dfuInit+0x64>)
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1564:	4812      	ldr	r0, [pc, #72]	; (15b0 <dfuInit+0x68>)
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    1566:	8013      	strh	r3, [r2, #0]
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1568:	4a12      	ldr	r2, [pc, #72]	; (15b4 <dfuInit+0x6c>)
    156a:	6011      	str	r1, [r2, #0]
    userAppEnd = RAM_END;
    156c:	4a12      	ldr	r2, [pc, #72]	; (15b8 <dfuInit+0x70>)
    156e:	f501 4188 	add.w	r1, r1, #17408	; 0x4400
    1572:	6011      	str	r1, [r2, #0]
    userUploadType=DFU_UPLOAD_NONE;
    1574:	4a11      	ldr	r2, [pc, #68]	; (15bc <dfuInit+0x74>)
    code_copy_lock = WAIT;
    1576:	2103      	movs	r1, #3
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    1578:	7013      	strb	r3, [r2, #0]
    code_copy_lock = WAIT;
    157a:	4a11      	ldr	r2, [pc, #68]	; (15c0 <dfuInit+0x78>)
    157c:	7011      	strb	r1, [r2, #0]
    dfuBusy = FALSE;
    157e:	4a11      	ldr	r2, [pc, #68]	; (15c4 <dfuInit+0x7c>)
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1580:	21ff      	movs	r1, #255	; 0xff
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    1582:	7013      	strb	r3, [r2, #0]
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1584:	2220      	movs	r2, #32
    1586:	f005 f8d2 	bl	672e <memset>
    memset(input, 0xFF, sizeof(input));
    158a:	480f      	ldr	r0, [pc, #60]	; (15c8 <dfuInit+0x80>)
    158c:	21ff      	movs	r1, #255	; 0xff
    158e:	225c      	movs	r2, #92	; 0x5c
    1590:	f005 f8cd 	bl	672e <memset>

    sha256_starts(&ctx);
}
    1594:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1598:	480c      	ldr	r0, [pc, #48]	; (15cc <dfuInit+0x84>)
    159a:	f001 bd1f 	b.w	2fdc <sha256_starts>
    159e:	bf00      	nop
    15a0:	20000dc5 	andcs	r0, r0, r5, asr #27
    15a4:	20000dc0 	andcs	r0, r0, r0, asr #27
    15a8:	20000c00 	andcs	r0, r0, r0, lsl #24
    15ac:	20000dbe 			; <UNDEFINED> instruction: 0x20000dbe
    15b0:	200004ec 	andcs	r0, r0, ip, ror #9
    15b4:	200002c0 	andcs	r0, r0, r0, asr #5
    15b8:	200002bc 			; <UNDEFINED> instruction: 0x200002bc
    15bc:	20000dc4 	andcs	r0, r0, r4, asr #27
    15c0:	20000574 	andcs	r0, r0, r4, ror r5
    15c4:	20000dcb 	andcs	r0, r0, fp, asr #27
    15c8:	20000490 	mulcs	r0, r0, r4
    15cc:	2000050c 	andcs	r0, r0, ip, lsl #10

000015d0 <dfuUpdateByReset>:
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    15d0:	b508      	push	{r3, lr}
    u8 startState = dfuAppStatus.bState;
    15d2:	4b0e      	ldr	r3, [pc, #56]	; (160c <dfuUpdateByReset+0x3c>)
    userFirmwareLen = 0;
    15d4:	480e      	ldr	r0, [pc, #56]	; (1610 <dfuUpdateByReset+0x40>)

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    u8 startState = dfuAppStatus.bState;
    15d6:	7919      	ldrb	r1, [r3, #4]
    userFirmwareLen = 0;
    15d8:	2200      	movs	r2, #0

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    u8 startState = dfuAppStatus.bState;
    15da:	b2c9      	uxtb	r1, r1
    userFirmwareLen = 0;

    if (startState == appDETACH) {
    15dc:	2901      	cmp	r1, #1
    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    15de:	6002      	str	r2, [r0, #0]

    if (startState == appDETACH) {
    15e0:	d108      	bne.n	15f4 <dfuUpdateByReset+0x24>
        dfuAppStatus.bState = dfuIDLE;
    15e2:	2102      	movs	r1, #2
    15e4:	7119      	strb	r1, [r3, #4]
        dfuAppStatus.bStatus = OK;
    15e6:	701a      	strb	r2, [r3, #0]

        nvicDisableInterrupts();
    15e8:	f7ff ff12 	bl	1410 <nvicDisableInterrupts>
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    15ec:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    15f0:	f7ff bc82 	b.w	ef8 <usbEnbISR>
    } else if (startState == appIDLE || startState == dfuIDLE) {
    15f4:	f011 0ffd 	tst.w	r1, #253	; 0xfd
    15f8:	d006      	beq.n	1608 <dfuUpdateByReset+0x38>
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    15fa:	2102      	movs	r1, #2
    15fc:	7119      	strb	r1, [r3, #4]
        dfuAppStatus.bStatus = OK;
    15fe:	701a      	strb	r2, [r3, #0]

        systemHardReset();
    }
}
    1600:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    1604:	f7ff bf26 	b.w	1454 <systemHardReset>
    1608:	bd08      	pop	{r3, pc}
    160a:	bf00      	nop
    160c:	20000dc5 	andcs	r0, r0, r5, asr #27
    1610:	20000dc0 	andcs	r0, r0, r0, asr #27

00001614 <dfuCopyState>:

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    1614:	b920      	cbnz	r0, 1620 <dfuCopyState+0xc>
        pInformation->Ctrl_Info.Usb_wLength = 1;
    1616:	4b03      	ldr	r3, [pc, #12]	; (1624 <dfuCopyState+0x10>)
    1618:	2201      	movs	r2, #1
    161a:	681b      	ldr	r3, [r3, #0]
    161c:	821a      	strh	r2, [r3, #16]
        return NULL;
    161e:	4770      	bx	lr
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    1620:	4801      	ldr	r0, [pc, #4]	; (1628 <dfuCopyState+0x14>)
    }
}
    1622:	4770      	bx	lr
    1624:	200005a8 	andcs	r0, r0, r8, lsr #11
    1628:	20000dc9 	andcs	r0, r0, r9, asr #27

0000162c <dfuCopyStatus>:

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    162c:	b920      	cbnz	r0, 1638 <dfuCopyStatus+0xc>
        pInformation->Ctrl_Info.Usb_wLength = 6;
    162e:	4b03      	ldr	r3, [pc, #12]	; (163c <dfuCopyStatus+0x10>)
    1630:	2206      	movs	r2, #6
    1632:	681b      	ldr	r3, [r3, #0]
    1634:	821a      	strh	r2, [r3, #16]
        return NULL;
    1636:	4770      	bx	lr
    } else {
        return (u8*)(&dfuAppStatus);
    1638:	4801      	ldr	r0, [pc, #4]	; (1640 <dfuCopyStatus+0x14>)
    }
}
    163a:	4770      	bx	lr
    163c:	200005a8 	andcs	r0, r0, r8, lsr #11
    1640:	20000dc5 	andcs	r0, r0, r5, asr #27

00001644 <dfuCopyDNLOAD>:


u8 *dfuCopyDNLOAD(u16 length) {
    1644:	4b06      	ldr	r3, [pc, #24]	; (1660 <dfuCopyDNLOAD+0x1c>)
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    1646:	681b      	ldr	r3, [r3, #0]
    }
}


u8 *dfuCopyDNLOAD(u16 length) {
    if (length == 0) {
    1648:	b930      	cbnz	r0, 1658 <dfuCopyDNLOAD+0x14>
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    164a:	88da      	ldrh	r2, [r3, #6]
    164c:	8a59      	ldrh	r1, [r3, #18]
    164e:	1a51      	subs	r1, r2, r1
    1650:	8219      	strh	r1, [r3, #16]
        thisBlockLen = pInformation->USBwLengths.w;
    1652:	4b04      	ldr	r3, [pc, #16]	; (1664 <dfuCopyDNLOAD+0x20>)
    1654:	801a      	strh	r2, [r3, #0]
        return NULL;
    1656:	4770      	bx	lr
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1658:	8a5b      	ldrh	r3, [r3, #18]
    165a:	4803      	ldr	r0, [pc, #12]	; (1668 <dfuCopyDNLOAD+0x24>)
    165c:	4418      	add	r0, r3
    }
}
    165e:	4770      	bx	lr
    1660:	200005a8 	andcs	r0, r0, r8, lsr #11
    1664:	20000dbe 			; <UNDEFINED> instruction: 0x20000dbe
    1668:	200005bc 			; <UNDEFINED> instruction: 0x200005bc

0000166c <dfuCopyUPLOAD>:

u8 *dfuCopyUPLOAD(u16 length) {
    166c:	4b08      	ldr	r3, [pc, #32]	; (1690 <dfuCopyUPLOAD+0x24>)
    if (length == 0) {
    166e:	b930      	cbnz	r0, 167e <dfuCopyUPLOAD+0x12>
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    1670:	681b      	ldr	r3, [r3, #0]
    1672:	4a08      	ldr	r2, [pc, #32]	; (1694 <dfuCopyUPLOAD+0x28>)
    1674:	8811      	ldrh	r1, [r2, #0]
    1676:	8a5a      	ldrh	r2, [r3, #18]
    1678:	1a8a      	subs	r2, r1, r2
    167a:	821a      	strh	r2, [r3, #16]
        return NULL;
    167c:	4770      	bx	lr
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    167e:	4906      	ldr	r1, [pc, #24]	; (1698 <dfuCopyUPLOAD+0x2c>)
    1680:	4a06      	ldr	r2, [pc, #24]	; (169c <dfuCopyUPLOAD+0x30>)
    1682:	681b      	ldr	r3, [r3, #0]
    1684:	6812      	ldr	r2, [r2, #0]
    1686:	6808      	ldr	r0, [r1, #0]
    1688:	8a5b      	ldrh	r3, [r3, #18]
    168a:	4410      	add	r0, r2
    168c:	4418      	add	r0, r3
    }
}
    168e:	4770      	bx	lr
    1690:	200005a8 	andcs	r0, r0, r8, lsr #11
    1694:	20000dbe 			; <UNDEFINED> instruction: 0x20000dbe
    1698:	200002c0 	andcs	r0, r0, r0, asr #5
    169c:	20000dc0 	andcs	r0, r0, r0, asr #27

000016a0 <dfuCopyBufferToExec>:

void dfuCopyBufferToExec() {
    16a0:	b570      	push	{r4, r5, r6, lr}
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    16a2:	4b12      	ldr	r3, [pc, #72]	; (16ec <dfuCopyBufferToExec+0x4c>)
    16a4:	4e12      	ldr	r6, [pc, #72]	; (16f0 <dfuCopyBufferToExec+0x50>)
    16a6:	781b      	ldrb	r3, [r3, #0]
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    16a8:	6834      	ldr	r4, [r6, #0]
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    16aa:	2b04      	cmp	r3, #4
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    16ac:	f104 6400 	add.w	r4, r4, #134217728	; 0x8000000
    16b0:	bf0c      	ite	eq
    16b2:	f504 4400 	addeq.w	r4, r4, #32768	; 0x8000
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    16b6:	f504 5400 	addne.w	r4, r4, #8192	; 0x2000
	}

    flashErasePage((u32)(userSpace));
    16ba:	4620      	mov	r0, r4
    16bc:	f7ff fed4 	bl	1468 <flashErasePage>

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16c0:	2500      	movs	r5, #0
    16c2:	4b0c      	ldr	r3, [pc, #48]	; (16f4 <dfuCopyBufferToExec+0x54>)
    16c4:	881a      	ldrh	r2, [r3, #0]
    16c6:	b292      	uxth	r2, r2
    16c8:	4295      	cmp	r5, r2
    16ca:	da06      	bge.n	16da <dfuCopyBufferToExec+0x3a>
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    16cc:	4b0a      	ldr	r3, [pc, #40]	; (16f8 <dfuCopyBufferToExec+0x58>)
    16ce:	1960      	adds	r0, r4, r5
    16d0:	58e9      	ldr	r1, [r5, r3]
    16d2:	f7ff fee3 	bl	149c <flashWriteWord>
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16d6:	3504      	adds	r5, #4
    16d8:	e7f3      	b.n	16c2 <dfuCopyBufferToExec+0x22>
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    16da:	6831      	ldr	r1, [r6, #0]
    16dc:	881a      	ldrh	r2, [r3, #0]
    16de:	b292      	uxth	r2, r2
    16e0:	440a      	add	r2, r1
    16e2:	6032      	str	r2, [r6, #0]
    thisBlockLen = 0;
    16e4:	2200      	movs	r2, #0
    16e6:	801a      	strh	r2, [r3, #0]
    16e8:	bd70      	pop	{r4, r5, r6, pc}
    16ea:	bf00      	nop
    16ec:	20000dc4 	andcs	r0, r0, r4, asr #27
    16f0:	20000dc0 	andcs	r0, r0, r0, asr #27
    16f4:	20000dbe 			; <UNDEFINED> instruction: 0x20000dbe
    16f8:	200005bc 			; <UNDEFINED> instruction: 0x200005bc

000016fc <dfuUpdateByRequest>:
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    16fc:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    1700:	4985      	ldr	r1, [pc, #532]	; (1918 <dfuUpdateByRequest+0x21c>)

    u8 startState = dfuAppStatus.bState;
    1702:	4c86      	ldr	r4, [pc, #536]	; (191c <dfuUpdateByRequest+0x220>)
}

bool dfuUpdateByRequest(void) {
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    1704:	2001      	movs	r0, #1
    1706:	7008      	strb	r0, [r1, #0]

    u8 startState = dfuAppStatus.bState;
    1708:	7923      	ldrb	r3, [r4, #4]
    dfuAppStatus.bStatus = OK;
    170a:	2200      	movs	r2, #0
bool dfuUpdateByRequest(void) {
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;

    u8 startState = dfuAppStatus.bState;
    170c:	b2db      	uxtb	r3, r3
    dfuAppStatus.bStatus = OK;
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
    170e:	2b02      	cmp	r3, #2
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;

    u8 startState = dfuAppStatus.bState;
    dfuAppStatus.bStatus = OK;
    1710:	7022      	strb	r2, [r4, #0]
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
    1712:	d151      	bne.n	17b8 <dfuUpdateByRequest+0xbc>
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    1714:	7008      	strb	r0, [r1, #0]

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    1716:	4982      	ldr	r1, [pc, #520]	; (1920 <dfuUpdateByRequest+0x224>)
    1718:	6809      	ldr	r1, [r1, #0]
    171a:	7848      	ldrb	r0, [r1, #1]
    171c:	2801      	cmp	r0, #1
    171e:	d121      	bne.n	1764 <dfuUpdateByRequest+0x68>
            if (pInformation->USBwLengths.w > 0) {
    1720:	88cb      	ldrh	r3, [r1, #6]
    1722:	2b00      	cmp	r3, #0
    1724:	f000 80cc 	beq.w	18c0 <dfuUpdateByRequest+0x1c4>
                userFirmwareLen = 0;
    1728:	4b7e      	ldr	r3, [pc, #504]	; (1924 <dfuUpdateByRequest+0x228>)
    172a:	601a      	str	r2, [r3, #0]
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    172c:	7b0a      	ldrb	r2, [r1, #12]
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop

        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                userFirmwareLen = 0;
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    172e:	2303      	movs	r3, #3
				switch(pInformation->Current_AlternateSetting) {
    1730:	2a01      	cmp	r2, #1
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop

        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                userFirmwareLen = 0;
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    1732:	7123      	strb	r3, [r4, #4]
				switch(pInformation->Current_AlternateSetting) {
    1734:	d008      	beq.n	1748 <dfuUpdateByRequest+0x4c>
    1736:	2a02      	cmp	r2, #2
    1738:	d111      	bne.n	175e <dfuUpdateByRequest+0x62>
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    173a:	4b7b      	ldr	r3, [pc, #492]	; (1928 <dfuUpdateByRequest+0x22c>)
    173c:	2206      	movs	r2, #6
    173e:	701a      	strb	r2, [r3, #0]
						userAppAddr = USER_CODE_FLASH0X8002000;
    1740:	4a7a      	ldr	r2, [pc, #488]	; (192c <dfuUpdateByRequest+0x230>)
    1742:	4b7b      	ldr	r3, [pc, #492]	; (1930 <dfuUpdateByRequest+0x234>)
    1744:	601a      	str	r2, [r3, #0]
    1746:	e005      	b.n	1754 <dfuUpdateByRequest+0x58>
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    1748:	4a7a      	ldr	r2, [pc, #488]	; (1934 <dfuUpdateByRequest+0x238>)
    174a:	4b79      	ldr	r3, [pc, #484]	; (1930 <dfuUpdateByRequest+0x234>)
    174c:	601a      	str	r2, [r3, #0]
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    174e:	4b76      	ldr	r3, [pc, #472]	; (1928 <dfuUpdateByRequest+0x22c>)
    1750:	2204      	movs	r2, #4
    1752:	701a      	strb	r2, [r3, #0]
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1754:	f7ff fe0c 	bl	1370 <setupFLASH>
						flashUnlock();
    1758:	f7ff fecc 	bl	14f4 <flashUnlock>

						break;
    175c:	e0d3      	b.n	1906 <dfuUpdateByRequest+0x20a>

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    175e:	220a      	movs	r2, #10
    1760:	7122      	strb	r2, [r4, #4]
    1762:	e0cf      	b.n	1904 <dfuUpdateByRequest+0x208>
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1764:	2802      	cmp	r0, #2
    1766:	d121      	bne.n	17ac <dfuUpdateByRequest+0xb0>
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1768:	2309      	movs	r3, #9
    176a:	7123      	strb	r3, [r4, #4]
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    176c:	88ca      	ldrh	r2, [r1, #6]
    176e:	4b72      	ldr	r3, [pc, #456]	; (1938 <dfuUpdateByRequest+0x23c>)
    1770:	801a      	strh	r2, [r3, #0]
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    1772:	8818      	ldrh	r0, [r3, #0]
    1774:	4a71      	ldr	r2, [pc, #452]	; (193c <dfuUpdateByRequest+0x240>)
    1776:	b280      	uxth	r0, r0
    1778:	8010      	strh	r0, [r2, #0]
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    177a:	881a      	ldrh	r2, [r3, #0]
    177c:	884b      	ldrh	r3, [r1, #2]
    177e:	b292      	uxth	r2, r2
    1780:	435a      	muls	r2, r3
    1782:	4b68      	ldr	r3, [pc, #416]	; (1924 <dfuUpdateByRequest+0x228>)
    1784:	601a      	str	r2, [r3, #0]
			
            switch(pInformation->Current_AlternateSetting) {
    1786:	7b0b      	ldrb	r3, [r1, #12]
    1788:	2b01      	cmp	r3, #1
    178a:	d003      	beq.n	1794 <dfuUpdateByRequest+0x98>
    178c:	2b02      	cmp	r3, #2
    178e:	d109      	bne.n	17a4 <dfuUpdateByRequest+0xa8>
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1790:	4a66      	ldr	r2, [pc, #408]	; (192c <dfuUpdateByRequest+0x230>)
    1792:	e000      	b.n	1796 <dfuUpdateByRequest+0x9a>
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1794:	4a67      	ldr	r2, [pc, #412]	; (1934 <dfuUpdateByRequest+0x238>)
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1796:	4b66      	ldr	r3, [pc, #408]	; (1930 <dfuUpdateByRequest+0x234>)
    1798:	601a      	str	r2, [r3, #0]
					userAppEnd = getFlashEnd();
    179a:	f7ff fec1 	bl	1520 <getFlashEnd>
    179e:	4b68      	ldr	r3, [pc, #416]	; (1940 <dfuUpdateByRequest+0x244>)
    17a0:	6018      	str	r0, [r3, #0]
					break;
    17a2:	e0b0      	b.n	1906 <dfuUpdateByRequest+0x20a>

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    17a4:	230a      	movs	r3, #10
    17a6:	7123      	strb	r3, [r4, #4]
					dfuAppStatus.bStatus = errWRITE;
    17a8:	2303      	movs	r3, #3
    17aa:	e0ab      	b.n	1904 <dfuUpdateByRequest+0x208>
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    17ac:	2806      	cmp	r0, #6
    17ae:	d04c      	beq.n	184a <dfuUpdateByRequest+0x14e>
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17b0:	2803      	cmp	r0, #3
    17b2:	d019      	beq.n	17e8 <dfuUpdateByRequest+0xec>
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17b4:	2805      	cmp	r0, #5
    17b6:	e04c      	b.n	1852 <dfuUpdateByRequest+0x156>
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    17b8:	2b03      	cmp	r3, #3
    17ba:	d10b      	bne.n	17d4 <dfuUpdateByRequest+0xd8>
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17bc:	4a58      	ldr	r2, [pc, #352]	; (1920 <dfuUpdateByRequest+0x224>)
    17be:	6812      	ldr	r2, [r2, #0]
    17c0:	7852      	ldrb	r2, [r2, #1]
    17c2:	2a03      	cmp	r2, #3
    17c4:	d104      	bne.n	17d0 <dfuUpdateByRequest+0xd4>

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17c6:	2305      	movs	r3, #5
    17c8:	7123      	strb	r3, [r4, #4]
                dfuCopyBufferToExec();
    17ca:	f7ff ff69 	bl	16a0 <dfuCopyBufferToExec>
    17ce:	e09a      	b.n	1906 <dfuUpdateByRequest+0x20a>
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17d0:	2a05      	cmp	r2, #5
    17d2:	e03e      	b.n	1852 <dfuUpdateByRequest+0x156>
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    17d4:	2b04      	cmp	r3, #4
    17d6:	d109      	bne.n	17ec <dfuUpdateByRequest+0xf0>
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    17d8:	495a      	ldr	r1, [pc, #360]	; (1944 <dfuUpdateByRequest+0x248>)
    17da:	7808      	ldrb	r0, [r1, #0]
    17dc:	2802      	cmp	r0, #2
    17de:	d103      	bne.n	17e8 <dfuUpdateByRequest+0xec>

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    17e0:	2303      	movs	r3, #3
        }
    } else if (startState == dfuDNBUSY)              {
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {

            dfuAppStatus.bwPollTimeout0 = 0x00;
    17e2:	7062      	strb	r2, [r4, #1]
            code_copy_lock = WAIT;
    17e4:	700b      	strb	r3, [r1, #0]
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17e6:	2305      	movs	r3, #5
    17e8:	7123      	strb	r3, [r4, #4]
    17ea:	e08c      	b.n	1906 <dfuUpdateByRequest+0x20a>
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    17ec:	2b05      	cmp	r3, #5
    17ee:	d124      	bne.n	183a <dfuUpdateByRequest+0x13e>
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17f0:	4b4b      	ldr	r3, [pc, #300]	; (1920 <dfuUpdateByRequest+0x224>)
    17f2:	681b      	ldr	r3, [r3, #0]
    17f4:	785a      	ldrb	r2, [r3, #1]
    17f6:	2a01      	cmp	r2, #1
    17f8:	d118      	bne.n	182c <dfuUpdateByRequest+0x130>
            if (pInformation->USBwLengths.w > 0) {
    17fa:	88db      	ldrh	r3, [r3, #6]
    17fc:	b10b      	cbz	r3, 1802 <dfuUpdateByRequest+0x106>
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    17fe:	2303      	movs	r3, #3
    1800:	e7f2      	b.n	17e8 <dfuUpdateByRequest+0xec>
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    1802:	2306      	movs	r3, #6
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    1804:	a801      	add	r0, sp, #4
    1806:	494b      	ldr	r1, [pc, #300]	; (1934 <dfuUpdateByRequest+0x238>)
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    1808:	7123      	strb	r3, [r4, #4]
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    180a:	f004 f915 	bl	5a38 <imageCheckFromAddress>
                }
                switch (ret)
    180e:	2803      	cmp	r0, #3
    1810:	d004      	beq.n	181c <dfuUpdateByRequest+0x120>
    1812:	2804      	cmp	r0, #4
    1814:	d004      	beq.n	1820 <dfuUpdateByRequest+0x124>
    1816:	2802      	cmp	r0, #2
    1818:	d105      	bne.n	1826 <dfuUpdateByRequest+0x12a>
    181a:	e001      	b.n	1820 <dfuUpdateByRequest+0x124>
                {
                    case kImageImageIsTrusted:
                        uart_printf("Uploaded signature verified!\n");
    181c:	484a      	ldr	r0, [pc, #296]	; (1948 <dfuUpdateByRequest+0x24c>)
    181e:	e000      	b.n	1822 <dfuUpdateByRequest+0x126>
                        break;

                    case kImageImageMissingMagic:
                    case kImageImageRejectSignature:
                        uart_printf("Image unverified... wiped memory for clean reset.\n");
    1820:	484a      	ldr	r0, [pc, #296]	; (194c <dfuUpdateByRequest+0x250>)
    1822:	f7ff fcdf 	bl	11e4 <uart_printf>
                        break;

                    default:
                        break;
                }
                flashLock();
    1826:	f7ff fe5f 	bl	14e8 <flashLock>
    182a:	e06c      	b.n	1906 <dfuUpdateByRequest+0x20a>
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    182c:	2a06      	cmp	r2, #6
    182e:	d04d      	beq.n	18cc <dfuUpdateByRequest+0x1d0>
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1830:	2a03      	cmp	r2, #3
    1832:	d04b      	beq.n	18cc <dfuUpdateByRequest+0x1d0>
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1834:	2a05      	cmp	r2, #5
    1836:	d162      	bne.n	18fe <dfuUpdateByRequest+0x202>
    1838:	e048      	b.n	18cc <dfuUpdateByRequest+0x1d0>
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuMANIFEST_SYNC) {
    183a:	2b06      	cmp	r3, #6
    183c:	d10b      	bne.n	1856 <dfuUpdateByRequest+0x15a>
        /* device has received last block, waiting DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    183e:	4938      	ldr	r1, [pc, #224]	; (1920 <dfuUpdateByRequest+0x224>)
    1840:	6809      	ldr	r1, [r1, #0]
    1842:	7849      	ldrb	r1, [r1, #1]
    1844:	2903      	cmp	r1, #3
    1846:	d103      	bne.n	1850 <dfuUpdateByRequest+0x154>
            dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    1848:	2308      	movs	r3, #8
    184a:	7123      	strb	r3, [r4, #4]
            dfuAppStatus.bStatus = OK;
    184c:	7022      	strb	r2, [r4, #0]
    184e:	e05a      	b.n	1906 <dfuUpdateByRequest+0x20a>
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1850:	2905      	cmp	r1, #5
    1852:	d154      	bne.n	18fe <dfuUpdateByRequest+0x202>
    1854:	e7c8      	b.n	17e8 <dfuUpdateByRequest+0xec>
            dfuAppStatus.bState  = dfuMANIFEST_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuMANIFEST) {
    1856:	2b07      	cmp	r3, #7
    1858:	d0f6      	beq.n	1848 <dfuUpdateByRequest+0x14c>
        /* device is in manifestation phase */

        /* should never receive request while in manifest! */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
        dfuAppStatus.bStatus = OK;
    } else if (startState == dfuMANIFEST_WAIT_RESET) {
    185a:	2b08      	cmp	r3, #8
    185c:	d0c4      	beq.n	17e8 <dfuUpdateByRequest+0xec>
        /* device has programmed new firmware but needs external
           usb reset or power on reset to run the new code */

        /* consider timing out and self-resetting */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    } else if (startState == dfuUPLOAD_IDLE) {
    185e:	2b09      	cmp	r3, #9
    1860:	d13c      	bne.n	18dc <dfuUpdateByRequest+0x1e0>
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
    1862:	4b2f      	ldr	r3, [pc, #188]	; (1920 <dfuUpdateByRequest+0x224>)
    1864:	681a      	ldr	r2, [r3, #0]
    1866:	7853      	ldrb	r3, [r2, #1]
    1868:	2b02      	cmp	r3, #2
    186a:	d12d      	bne.n	18c8 <dfuUpdateByRequest+0x1cc>
            if (pInformation->USBwLengths.w > 0) {
    186c:	88d0      	ldrh	r0, [r2, #6]
    186e:	b338      	cbz	r0, 18c0 <dfuUpdateByRequest+0x1c4>
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1870:	4931      	ldr	r1, [pc, #196]	; (1938 <dfuUpdateByRequest+0x23c>)
    1872:	8852      	ldrh	r2, [r2, #2]
    1874:	880b      	ldrh	r3, [r1, #0]
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1876:	4d2e      	ldr	r5, [pc, #184]	; (1930 <dfuUpdateByRequest+0x234>)
    } else if (startState == dfuUPLOAD_IDLE) {
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1878:	b29b      	uxth	r3, r3
    187a:	4353      	muls	r3, r2
    187c:	4a29      	ldr	r2, [pc, #164]	; (1924 <dfuUpdateByRequest+0x228>)
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    187e:	4e30      	ldr	r6, [pc, #192]	; (1940 <dfuUpdateByRequest+0x244>)
    } else if (startState == dfuUPLOAD_IDLE) {
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1880:	6013      	str	r3, [r2, #0]
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1882:	682f      	ldr	r7, [r5, #0]
    1884:	f8d2 8000 	ldr.w	r8, [r2]
    1888:	f8b1 c000 	ldrh.w	ip, [r1]
    188c:	4447      	add	r7, r8
    188e:	6833      	ldr	r3, [r6, #0]
    1890:	fa1f fc8c 	uxth.w	ip, ip
    1894:	4467      	add	r7, ip
    1896:	429f      	cmp	r7, r3
    1898:	4b28      	ldr	r3, [pc, #160]	; (193c <dfuUpdateByRequest+0x240>)
    189a:	d803      	bhi.n	18a4 <dfuUpdateByRequest+0x1a8>
                    thisBlockLen = uploadBlockLen;
    189c:	880a      	ldrh	r2, [r1, #0]
    189e:	b292      	uxth	r2, r2
    18a0:	801a      	strh	r2, [r3, #0]
    18a2:	e019      	b.n	18d8 <dfuUpdateByRequest+0x1dc>
                    dfuAppStatus.bState  = dfuUPLOAD_IDLE;
                } else {
                    /* if above comparison was just equal, thisBlockLen becomes zero
                    next time when USBWValue has been increased by one */
                    thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
    18a4:	6836      	ldr	r6, [r6, #0]
    18a6:	682d      	ldr	r5, [r5, #0]
    18a8:	6811      	ldr	r1, [r2, #0]
    18aa:	1b72      	subs	r2, r6, r5
    18ac:	1a52      	subs	r2, r2, r1
    18ae:	b292      	uxth	r2, r2
    18b0:	801a      	strh	r2, [r3, #0]
                    
                    /* check for overflow due to USBwValue out of range */
                    if (thisBlockLen >= pInformation->USBwLengths.w) {
    18b2:	881a      	ldrh	r2, [r3, #0]
    18b4:	b292      	uxth	r2, r2
    18b6:	4282      	cmp	r2, r0
    18b8:	d308      	bcc.n	18cc <dfuUpdateByRequest+0x1d0>
                        thisBlockLen = 0;
    18ba:	2200      	movs	r2, #0
    18bc:	801a      	strh	r2, [r3, #0]
    18be:	e005      	b.n	18cc <dfuUpdateByRequest+0x1d0>
                    }
                    
                    dfuAppStatus.bState  = dfuIDLE;
                }
            } else {
                dfuAppStatus.bState  = dfuERROR;
    18c0:	230a      	movs	r3, #10
    18c2:	7123      	strb	r3, [r4, #4]
                dfuAppStatus.bStatus = errNOTDONE;
    18c4:	2309      	movs	r3, #9
    18c6:	e01d      	b.n	1904 <dfuUpdateByRequest+0x208>
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    18c8:	2b06      	cmp	r3, #6
    18ca:	d101      	bne.n	18d0 <dfuUpdateByRequest+0x1d4>
            dfuAppStatus.bState  = dfuIDLE;
    18cc:	2302      	movs	r3, #2
    18ce:	e78b      	b.n	17e8 <dfuUpdateByRequest+0xec>
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18d0:	2b03      	cmp	r3, #3
    18d2:	d001      	beq.n	18d8 <dfuUpdateByRequest+0x1dc>
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18d4:	2b05      	cmp	r3, #5
    18d6:	d112      	bne.n	18fe <dfuUpdateByRequest+0x202>
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    18d8:	2309      	movs	r3, #9
    18da:	e785      	b.n	17e8 <dfuUpdateByRequest+0xec>
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuERROR)               {
    18dc:	2b0a      	cmp	r3, #10
    18de:	d10e      	bne.n	18fe <dfuUpdateByRequest+0x202>
        /* status is in error, awaiting DFU_CLRSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18e0:	4b0f      	ldr	r3, [pc, #60]	; (1920 <dfuUpdateByRequest+0x224>)
    18e2:	681b      	ldr	r3, [r3, #0]
    18e4:	785b      	ldrb	r3, [r3, #1]
    18e6:	2b03      	cmp	r3, #3
    18e8:	d101      	bne.n	18ee <dfuUpdateByRequest+0x1f2>
            /* todo, add routine to wait for last block write to finish */
            dfuAppStatus.bState  = dfuERROR;
    18ea:	230a      	movs	r3, #10
    18ec:	e77c      	b.n	17e8 <dfuUpdateByRequest+0xec>
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18ee:	2b05      	cmp	r3, #5
    18f0:	d0fb      	beq.n	18ea <dfuUpdateByRequest+0x1ee>
            dfuAppStatus.bState  = dfuERROR;
        } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
    18f2:	2b04      	cmp	r3, #4
    18f4:	d103      	bne.n	18fe <dfuUpdateByRequest+0x202>
            /* todo handle any cleanup we need here */
            dfuAppStatus.bState  = dfuIDLE;
    18f6:	2302      	movs	r3, #2
    18f8:	7123      	strb	r3, [r4, #4]
            dfuAppStatus.bStatus = OK;
    18fa:	2300      	movs	r3, #0
    18fc:	e002      	b.n	1904 <dfuUpdateByRequest+0x208>
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else {
        /* some kind of error... */
        dfuAppStatus.bState  = dfuERROR;
    18fe:	230a      	movs	r3, #10
    1900:	7123      	strb	r3, [r4, #4]
        dfuAppStatus.bStatus = errSTALLEDPKT;
    1902:	230f      	movs	r3, #15
    1904:	7023      	strb	r3, [r4, #0]
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
    1906:	7820      	ldrb	r0, [r4, #0]
}
    1908:	f1d0 0001 	rsbs	r0, r0, #1
    190c:	bf38      	it	cc
    190e:	2000      	movcc	r0, #0
    1910:	b002      	add	sp, #8
    1912:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1916:	bf00      	nop
    1918:	20000dcb 	andcs	r0, r0, fp, asr #27
    191c:	20000dc5 	andcs	r0, r0, r5, asr #27
    1920:	200005a8 	andcs	r0, r0, r8, lsr #11
    1924:	20000dc0 	andcs	r0, r0, r0, asr #27
    1928:	20000dc4 	andcs	r0, r0, r4, asr #27
    192c:	08002000 	stmdaeq	r0, {sp}
    1930:	200002c0 	andcs	r0, r0, r0, asr #5
    1934:	08008000 	stmdaeq	r0, {pc}
    1938:	20000dbc 			; <UNDEFINED> instruction: 0x20000dbc
    193c:	20000dbe 			; <UNDEFINED> instruction: 0x20000dbe
    1940:	200002bc 			; <UNDEFINED> instruction: 0x200002bc
    1944:	20000574 	andcs	r0, r0, r4, ror r5
    1948:	00007032 	andeq	r7, r0, r2, lsr r0
    194c:	00007050 	andeq	r7, r0, r0, asr r0

00001950 <dfuUploadStarted>:
    dfuAppStatus.bState = newState;
}

bool dfuUploadStarted()
{
    return dfuBusy;
    1950:	4b01      	ldr	r3, [pc, #4]	; (1958 <dfuUploadStarted+0x8>)
    1952:	7818      	ldrb	r0, [r3, #0]
}
    1954:	4770      	bx	lr
    1956:	bf00      	nop
    1958:	20000dcb 	andcs	r0, r0, fp, asr #27

0000195c <dfuFinishUpload>:

void dfuFinishUpload() {

    while (1)
	{
		__asm__ __volatile__ ("");
    195c:	e7fe      	b.n	195c <dfuFinishUpload>
	...

00001960 <ed25519_project>:
};

/* Conversion to and from projective coordinates */
void ed25519_project(struct ed25519_pt *p,
		     const uint8_t *x, const uint8_t *y)
{
    1960:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1962:	460d      	mov	r5, r1
void f25519_load(uint8_t *x, uint32_t c);

/* Copy two points */
static inline void f25519_copy(uint8_t *x, const uint8_t *a)
{
	memcpy(x, a, F25519_SIZE);
    1964:	f8d1 e000 	ldr.w	lr, [r1]
    1968:	684f      	ldr	r7, [r1, #4]
    196a:	68eb      	ldr	r3, [r5, #12]
    196c:	6889      	ldr	r1, [r1, #8]
    196e:	f8c0 e000 	str.w	lr, [r0]
    1972:	6047      	str	r7, [r0, #4]
    1974:	6081      	str	r1, [r0, #8]
    1976:	60c3      	str	r3, [r0, #12]
    1978:	f8d5 e010 	ldr.w	lr, [r5, #16]
    197c:	696f      	ldr	r7, [r5, #20]
    197e:	69a9      	ldr	r1, [r5, #24]
    1980:	69eb      	ldr	r3, [r5, #28]
    1982:	f8c0 e010 	str.w	lr, [r0, #16]
    1986:	61c3      	str	r3, [r0, #28]
    1988:	6147      	str	r7, [r0, #20]
    198a:	6181      	str	r1, [r0, #24]
    198c:	f8d2 e000 	ldr.w	lr, [r2]
    1990:	6857      	ldr	r7, [r2, #4]
    1992:	6891      	ldr	r1, [r2, #8]
    1994:	4616      	mov	r6, r2
    1996:	68d2      	ldr	r2, [r2, #12]
    1998:	f8c0 e020 	str.w	lr, [r0, #32]
    199c:	6247      	str	r7, [r0, #36]	; 0x24
    199e:	6281      	str	r1, [r0, #40]	; 0x28
    19a0:	62c2      	str	r2, [r0, #44]	; 0x2c
    19a2:	69b1      	ldr	r1, [r6, #24]
    19a4:	69f2      	ldr	r2, [r6, #28]
    19a6:	f8d6 e010 	ldr.w	lr, [r6, #16]
    19aa:	6977      	ldr	r7, [r6, #20]
    19ac:	4604      	mov	r4, r0
    19ae:	63a1      	str	r1, [r4, #56]	; 0x38
    19b0:	63e2      	str	r2, [r4, #60]	; 0x3c
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
    19b2:	3060      	adds	r0, #96	; 0x60
    19b4:	f8c4 e030 	str.w	lr, [r4, #48]	; 0x30
    19b8:	6367      	str	r7, [r4, #52]	; 0x34
    19ba:	2101      	movs	r1, #1
    19bc:	f000 fa84 	bl	1ec8 <f25519_load>
	f25519_mul__distinct(p->t, x, y);
    19c0:	f104 0040 	add.w	r0, r4, #64	; 0x40
    19c4:	4629      	mov	r1, r5
    19c6:	4632      	mov	r2, r6
}
    19c8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		     const uint8_t *x, const uint8_t *y)
{
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
	f25519_mul__distinct(p->t, x, y);
    19cc:	f000 bbe2 	b.w	2194 <f25519_mul__distinct>

000019d0 <ed25519_unproject>:
}

void ed25519_unproject(uint8_t *x, uint8_t *y,
		       const struct ed25519_pt *p)
{
    19d0:	b570      	push	{r4, r5, r6, lr}
    19d2:	b088      	sub	sp, #32
    19d4:	4614      	mov	r4, r2
    19d6:	4606      	mov	r6, r0
    19d8:	460d      	mov	r5, r1
	uint8_t z1[F25519_SIZE];

	f25519_inv__distinct(z1, p->z);
    19da:	4668      	mov	r0, sp
    19dc:	f102 0160 	add.w	r1, r2, #96	; 0x60
    19e0:	f000 fc1c 	bl	221c <f25519_inv__distinct>
	f25519_mul__distinct(x, p->x, z1);
    19e4:	4630      	mov	r0, r6
    19e6:	4621      	mov	r1, r4
    19e8:	466a      	mov	r2, sp
    19ea:	f000 fbd3 	bl	2194 <f25519_mul__distinct>
	f25519_mul__distinct(y, p->y, z1);
    19ee:	f104 0120 	add.w	r1, r4, #32
    19f2:	466a      	mov	r2, sp
    19f4:	4628      	mov	r0, r5
    19f6:	f000 fbcd 	bl	2194 <f25519_mul__distinct>

	f25519_normalize(x);
    19fa:	4630      	mov	r0, r6
    19fc:	f000 fa74 	bl	1ee8 <f25519_normalize>
	f25519_normalize(y);
    1a00:	4628      	mov	r0, r5
    1a02:	f000 fa71 	bl	1ee8 <f25519_normalize>
}
    1a06:	b008      	add	sp, #32
    1a08:	bd70      	pop	{r4, r5, r6, pc}
    1a0a:	bf00      	nop

00001a0c <ed25519_pack>:
	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
};

void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y)
{
    1a0c:	b5f0      	push	{r4, r5, r6, r7, lr}
    1a0e:	460f      	mov	r7, r1
    1a10:	4605      	mov	r5, r0
    1a12:	4616      	mov	r6, r2
    1a14:	b089      	sub	sp, #36	; 0x24
    1a16:	6808      	ldr	r0, [r1, #0]
    1a18:	68ba      	ldr	r2, [r7, #8]
    1a1a:	68fb      	ldr	r3, [r7, #12]
    1a1c:	6849      	ldr	r1, [r1, #4]
    1a1e:	466c      	mov	r4, sp
    1a20:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1a22:	6938      	ldr	r0, [r7, #16]
    1a24:	6979      	ldr	r1, [r7, #20]
    1a26:	69ba      	ldr	r2, [r7, #24]
    1a28:	69fb      	ldr	r3, [r7, #28]
    1a2a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
    1a2c:	4668      	mov	r0, sp
    1a2e:	f000 fa5b 	bl	1ee8 <f25519_normalize>
    1a32:	6830      	ldr	r0, [r6, #0]
    1a34:	6871      	ldr	r1, [r6, #4]
    1a36:	68b2      	ldr	r2, [r6, #8]
    1a38:	68f3      	ldr	r3, [r6, #12]
    1a3a:	6028      	str	r0, [r5, #0]
    1a3c:	6069      	str	r1, [r5, #4]
    1a3e:	60aa      	str	r2, [r5, #8]
    1a40:	60eb      	str	r3, [r5, #12]
    1a42:	6930      	ldr	r0, [r6, #16]
    1a44:	69f3      	ldr	r3, [r6, #28]
    1a46:	6971      	ldr	r1, [r6, #20]
    1a48:	69b2      	ldr	r2, [r6, #24]
    1a4a:	6128      	str	r0, [r5, #16]
    1a4c:	61eb      	str	r3, [r5, #28]
    1a4e:	6169      	str	r1, [r5, #20]
    1a50:	61aa      	str	r2, [r5, #24]
	parity = (tmp[0] & 1) << 7;

	f25519_copy(c, y);
	f25519_normalize(c);
    1a52:	4628      	mov	r0, r5
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1a54:	f89d 4000 	ldrb.w	r4, [sp]

	f25519_copy(c, y);
	f25519_normalize(c);
    1a58:	f000 fa46 	bl	1ee8 <f25519_normalize>
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1a5c:	01e4      	lsls	r4, r4, #7

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1a5e:	7feb      	ldrb	r3, [r5, #31]
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1a60:	b2e4      	uxtb	r4, r4

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1a62:	431c      	orrs	r4, r3
    1a64:	77ec      	strb	r4, [r5, #31]
}
    1a66:	b009      	add	sp, #36	; 0x24
    1a68:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1a6a:	bf00      	nop

00001a6c <ed25519_try_unpack>:

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1a6c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1a70:	6817      	ldr	r7, [r2, #0]
    1a72:	6856      	ldr	r6, [r2, #4]
    1a74:	6895      	ldr	r5, [r2, #8]
    1a76:	f8d2 e00c 	ldr.w	lr, [r2, #12]
    1a7a:	4614      	mov	r4, r2
	const int parity = comp[31] >> 7;
    1a7c:	f894 801f 	ldrb.w	r8, [r4, #31]
    1a80:	600f      	str	r7, [r1, #0]
    1a82:	604e      	str	r6, [r1, #4]
    1a84:	608d      	str	r5, [r1, #8]
    1a86:	f8c1 e00c 	str.w	lr, [r1, #12]
    1a8a:	f8d4 e01c 	ldr.w	lr, [r4, #28]
    1a8e:	6927      	ldr	r7, [r4, #16]
    1a90:	6966      	ldr	r6, [r4, #20]
    1a92:	69a5      	ldr	r5, [r4, #24]
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1a94:	b098      	sub	sp, #96	; 0x60
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1a96:	f008 037f 	and.w	r3, r8, #127	; 0x7f
    1a9a:	f8c1 e01c 	str.w	lr, [r1, #28]
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1a9e:	4604      	mov	r4, r0
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1aa0:	77cb      	strb	r3, [r1, #31]
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1aa2:	460a      	mov	r2, r1
    1aa4:	610f      	str	r7, [r1, #16]
    1aa6:	614e      	str	r6, [r1, #20]
    1aa8:	618d      	str	r5, [r1, #24]
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1aaa:	a810      	add	r0, sp, #64	; 0x40

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
	f25519_add(a, b, f25519_one);
    1aac:	4d1f      	ldr	r5, [pc, #124]	; (1b2c <ed25519_try_unpack+0xc0>)
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1aae:	f000 fb71 	bl	2194 <f25519_mul__distinct>

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
    1ab2:	a910      	add	r1, sp, #64	; 0x40
    1ab4:	a808      	add	r0, sp, #32
    1ab6:	4a1e      	ldr	r2, [pc, #120]	; (1b30 <ed25519_try_unpack+0xc4>)
    1ab8:	f000 fb6c 	bl	2194 <f25519_mul__distinct>
	f25519_add(a, b, f25519_one);
    1abc:	462a      	mov	r2, r5
    1abe:	a908      	add	r1, sp, #32
    1ac0:	4668      	mov	r0, sp
    1ac2:	f000 faf9 	bl	20b8 <f25519_add>
	f25519_inv__distinct(b, a);
    1ac6:	a808      	add	r0, sp, #32
    1ac8:	4669      	mov	r1, sp
    1aca:	f000 fba7 	bl	221c <f25519_inv__distinct>

	/* Compute a = y^2-1 */
	f25519_sub(a, c, f25519_one);
    1ace:	4668      	mov	r0, sp
    1ad0:	a910      	add	r1, sp, #64	; 0x40
    1ad2:	462a      	mov	r2, r5
    1ad4:	f000 fb14 	bl	2100 <f25519_sub>

	/* Compute c = a*b = (y^2-1)/(1-dy^2) */
	f25519_mul__distinct(c, a, b);
    1ad8:	aa08      	add	r2, sp, #32
    1ada:	a810      	add	r0, sp, #64	; 0x40
    1adc:	4669      	mov	r1, sp
    1ade:	f000 fb59 	bl	2194 <f25519_mul__distinct>

	/* Compute a, b = +/-sqrt(c), if c is square */
	f25519_sqrt(a, c);
    1ae2:	4668      	mov	r0, sp
    1ae4:	a910      	add	r1, sp, #64	; 0x40
    1ae6:	f000 fe8f 	bl	2808 <f25519_sqrt>
	f25519_neg(b, a);
    1aea:	a808      	add	r0, sp, #32
    1aec:	4669      	mov	r1, sp
    1aee:	f000 fb2d 	bl	214c <f25519_neg>

	/* Select one of them, based on the compressed parity bit */
	f25519_select(x, a, b, (a[0] ^ parity) & 1);
    1af2:	f89d 3000 	ldrb.w	r3, [sp]
    1af6:	aa08      	add	r2, sp, #32
    1af8:	ea83 13d8 	eor.w	r3, r3, r8, lsr #7
    1afc:	f003 0301 	and.w	r3, r3, #1
    1b00:	4620      	mov	r0, r4
    1b02:	4669      	mov	r1, sp
    1b04:	f000 fa76 	bl	1ff4 <f25519_select>

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
    1b08:	4621      	mov	r1, r4
    1b0a:	4622      	mov	r2, r4
    1b0c:	4668      	mov	r0, sp
    1b0e:	f000 fb41 	bl	2194 <f25519_mul__distinct>
	f25519_normalize(a);
    1b12:	4668      	mov	r0, sp
    1b14:	f000 f9e8 	bl	1ee8 <f25519_normalize>
	f25519_normalize(c);
    1b18:	a810      	add	r0, sp, #64	; 0x40
    1b1a:	f000 f9e5 	bl	1ee8 <f25519_normalize>

	return f25519_eq(a, c);
    1b1e:	4668      	mov	r0, sp
    1b20:	a910      	add	r1, sp, #64	; 0x40
    1b22:	f000 fa19 	bl	1f58 <f25519_eq>
}
    1b26:	b018      	add	sp, #96	; 0x60
    1b28:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1b2c:	000071e4 	andeq	r7, r0, r4, ror #3
    1b30:	000071a4 	andeq	r7, r0, r4, lsr #3

00001b34 <ed25519_add>:
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1b34:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1b38:	4614      	mov	r4, r2
    1b3a:	b0c0      	sub	sp, #256	; 0x100
    1b3c:	460d      	mov	r5, r1
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b3e:	f101 0820 	add.w	r8, r1, #32
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1b42:	4606      	mov	r6, r0
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b44:	4641      	mov	r1, r8
    1b46:	462a      	mov	r2, r5
    1b48:	a810      	add	r0, sp, #64	; 0x40
	f25519_sub(d, p2->y, p2->x);
    1b4a:	f104 0720 	add.w	r7, r4, #32
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b4e:	f000 fad7 	bl	2100 <f25519_sub>
	f25519_sub(d, p2->y, p2->x);
    1b52:	4639      	mov	r1, r7
    1b54:	4622      	mov	r2, r4
    1b56:	a818      	add	r0, sp, #96	; 0x60
    1b58:	f000 fad2 	bl	2100 <f25519_sub>
	f25519_mul__distinct(a, c, d);
    1b5c:	a910      	add	r1, sp, #64	; 0x40
    1b5e:	aa18      	add	r2, sp, #96	; 0x60
    1b60:	4668      	mov	r0, sp
    1b62:	f000 fb17 	bl	2194 <f25519_mul__distinct>

	/* B = (Y1+X1)(Y2+X2) */
	f25519_add(c, p1->y, p1->x);
    1b66:	a810      	add	r0, sp, #64	; 0x40
    1b68:	4641      	mov	r1, r8
    1b6a:	462a      	mov	r2, r5
    1b6c:	f000 faa4 	bl	20b8 <f25519_add>
	f25519_add(d, p2->y, p2->x);
    1b70:	a818      	add	r0, sp, #96	; 0x60
    1b72:	4639      	mov	r1, r7
    1b74:	4622      	mov	r2, r4
    1b76:	f000 fa9f 	bl	20b8 <f25519_add>
	f25519_mul__distinct(b, c, d);
    1b7a:	a910      	add	r1, sp, #64	; 0x40
    1b7c:	aa18      	add	r2, sp, #96	; 0x60
    1b7e:	a808      	add	r0, sp, #32
    1b80:	f000 fb08 	bl	2194 <f25519_mul__distinct>

	/* C = T1 k T2 */
	f25519_mul__distinct(d, p1->t, p2->t);
    1b84:	a818      	add	r0, sp, #96	; 0x60
    1b86:	f105 0140 	add.w	r1, r5, #64	; 0x40
    1b8a:	f104 0240 	add.w	r2, r4, #64	; 0x40
    1b8e:	f000 fb01 	bl	2194 <f25519_mul__distinct>
	f25519_mul__distinct(c, d, ed25519_k);
    1b92:	a810      	add	r0, sp, #64	; 0x40
    1b94:	a918      	add	r1, sp, #96	; 0x60
    1b96:	4a1e      	ldr	r2, [pc, #120]	; (1c10 <ed25519_add+0xdc>)
    1b98:	f000 fafc 	bl	2194 <f25519_mul__distinct>

	/* D = Z1 2 Z2 */
	f25519_mul__distinct(d, p1->z, p2->z);
    1b9c:	a818      	add	r0, sp, #96	; 0x60
    1b9e:	f105 0160 	add.w	r1, r5, #96	; 0x60
    1ba2:	f104 0260 	add.w	r2, r4, #96	; 0x60
    1ba6:	f000 faf5 	bl	2194 <f25519_mul__distinct>
	f25519_add(d, d, d);
    1baa:	a818      	add	r0, sp, #96	; 0x60
    1bac:	4601      	mov	r1, r0
    1bae:	4602      	mov	r2, r0
    1bb0:	f000 fa82 	bl	20b8 <f25519_add>

	/* E = B - A */
	f25519_sub(e, b, a);
    1bb4:	a908      	add	r1, sp, #32
    1bb6:	466a      	mov	r2, sp
    1bb8:	a820      	add	r0, sp, #128	; 0x80
    1bba:	f000 faa1 	bl	2100 <f25519_sub>

	/* F = D - C */
	f25519_sub(f, d, c);
    1bbe:	a918      	add	r1, sp, #96	; 0x60
    1bc0:	aa10      	add	r2, sp, #64	; 0x40
    1bc2:	a828      	add	r0, sp, #160	; 0xa0
    1bc4:	f000 fa9c 	bl	2100 <f25519_sub>

	/* G = D + C */
	f25519_add(g, d, c);
    1bc8:	a918      	add	r1, sp, #96	; 0x60
    1bca:	aa10      	add	r2, sp, #64	; 0x40
    1bcc:	a830      	add	r0, sp, #192	; 0xc0
    1bce:	f000 fa73 	bl	20b8 <f25519_add>

	/* H = B + A */
	f25519_add(h, b, a);
    1bd2:	a908      	add	r1, sp, #32
    1bd4:	466a      	mov	r2, sp
    1bd6:	a838      	add	r0, sp, #224	; 0xe0
    1bd8:	f000 fa6e 	bl	20b8 <f25519_add>

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1bdc:	4630      	mov	r0, r6
    1bde:	a920      	add	r1, sp, #128	; 0x80
    1be0:	aa28      	add	r2, sp, #160	; 0xa0
    1be2:	f000 fad7 	bl	2194 <f25519_mul__distinct>

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1be6:	f106 0020 	add.w	r0, r6, #32
    1bea:	a930      	add	r1, sp, #192	; 0xc0
    1bec:	aa38      	add	r2, sp, #224	; 0xe0
    1bee:	f000 fad1 	bl	2194 <f25519_mul__distinct>

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1bf2:	a920      	add	r1, sp, #128	; 0x80
    1bf4:	aa38      	add	r2, sp, #224	; 0xe0
    1bf6:	f106 0040 	add.w	r0, r6, #64	; 0x40
    1bfa:	f000 facb 	bl	2194 <f25519_mul__distinct>

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1bfe:	f106 0060 	add.w	r0, r6, #96	; 0x60
    1c02:	a928      	add	r1, sp, #160	; 0xa0
    1c04:	aa30      	add	r2, sp, #192	; 0xc0
    1c06:	f000 fac5 	bl	2194 <f25519_mul__distinct>
}
    1c0a:	b040      	add	sp, #256	; 0x100
    1c0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1c10:	00007084 	andeq	r7, r0, r4, lsl #1

00001c14 <ed25519_double>:

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1c14:	b570      	push	{r4, r5, r6, lr}
    1c16:	b0b8      	sub	sp, #224	; 0xe0
    1c18:	4604      	mov	r4, r0

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1c1a:	f101 0620 	add.w	r6, r1, #32
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1c1e:	460a      	mov	r2, r1
    1c20:	4668      	mov	r0, sp
	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
}

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1c22:	460d      	mov	r5, r1
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1c24:	f000 fab6 	bl	2194 <f25519_mul__distinct>

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1c28:	4631      	mov	r1, r6
    1c2a:	4632      	mov	r2, r6
    1c2c:	a808      	add	r0, sp, #32
    1c2e:	f000 fab1 	bl	2194 <f25519_mul__distinct>

	/* C = 2 Z1^2 */
	f25519_mul__distinct(c, p->z, p->z);
    1c32:	f105 0160 	add.w	r1, r5, #96	; 0x60
    1c36:	460a      	mov	r2, r1
    1c38:	a810      	add	r0, sp, #64	; 0x40
    1c3a:	f000 faab 	bl	2194 <f25519_mul__distinct>
	f25519_add(c, c, c);
    1c3e:	a810      	add	r0, sp, #64	; 0x40
    1c40:	4601      	mov	r1, r0
    1c42:	4602      	mov	r2, r0
    1c44:	f000 fa38 	bl	20b8 <f25519_add>

	/* D = a A (alter sign) */
	/* E = (X1+Y1)^2-A-B */
	f25519_add(f, p->x, p->y);
    1c48:	4632      	mov	r2, r6
    1c4a:	4629      	mov	r1, r5
    1c4c:	a820      	add	r0, sp, #128	; 0x80
    1c4e:	f000 fa33 	bl	20b8 <f25519_add>
	f25519_mul__distinct(e, f, f);
    1c52:	a920      	add	r1, sp, #128	; 0x80
    1c54:	460a      	mov	r2, r1
    1c56:	a818      	add	r0, sp, #96	; 0x60
    1c58:	f000 fa9c 	bl	2194 <f25519_mul__distinct>
	f25519_sub(e, e, a);
    1c5c:	a818      	add	r0, sp, #96	; 0x60
    1c5e:	4601      	mov	r1, r0
    1c60:	466a      	mov	r2, sp
    1c62:	f000 fa4d 	bl	2100 <f25519_sub>
	f25519_sub(e, e, b);
    1c66:	a818      	add	r0, sp, #96	; 0x60
    1c68:	4601      	mov	r1, r0
    1c6a:	aa08      	add	r2, sp, #32
    1c6c:	f000 fa48 	bl	2100 <f25519_sub>

	/* G = D + B */
	f25519_sub(g, b, a);
    1c70:	a908      	add	r1, sp, #32
    1c72:	466a      	mov	r2, sp
    1c74:	a828      	add	r0, sp, #160	; 0xa0
    1c76:	f000 fa43 	bl	2100 <f25519_sub>

	/* F = G - C */
	f25519_sub(f, g, c);
    1c7a:	aa10      	add	r2, sp, #64	; 0x40
    1c7c:	a820      	add	r0, sp, #128	; 0x80
    1c7e:	a928      	add	r1, sp, #160	; 0xa0
    1c80:	f000 fa3e 	bl	2100 <f25519_sub>

	/* H = D - B */
	f25519_neg(h, b);
    1c84:	a908      	add	r1, sp, #32
    1c86:	a830      	add	r0, sp, #192	; 0xc0
    1c88:	f000 fa60 	bl	214c <f25519_neg>
	f25519_sub(h, h, a);
    1c8c:	a830      	add	r0, sp, #192	; 0xc0
    1c8e:	4601      	mov	r1, r0
    1c90:	466a      	mov	r2, sp
    1c92:	f000 fa35 	bl	2100 <f25519_sub>

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1c96:	4620      	mov	r0, r4
    1c98:	a918      	add	r1, sp, #96	; 0x60
    1c9a:	aa20      	add	r2, sp, #128	; 0x80
    1c9c:	f000 fa7a 	bl	2194 <f25519_mul__distinct>

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1ca0:	f104 0020 	add.w	r0, r4, #32
    1ca4:	a928      	add	r1, sp, #160	; 0xa0
    1ca6:	aa30      	add	r2, sp, #192	; 0xc0
    1ca8:	f000 fa74 	bl	2194 <f25519_mul__distinct>

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1cac:	a918      	add	r1, sp, #96	; 0x60
    1cae:	aa30      	add	r2, sp, #192	; 0xc0
    1cb0:	f104 0040 	add.w	r0, r4, #64	; 0x40
    1cb4:	f000 fa6e 	bl	2194 <f25519_mul__distinct>

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1cb8:	f104 0060 	add.w	r0, r4, #96	; 0x60
    1cbc:	a920      	add	r1, sp, #128	; 0x80
    1cbe:	aa28      	add	r2, sp, #160	; 0xa0
    1cc0:	f000 fa68 	bl	2194 <f25519_mul__distinct>
}
    1cc4:	b038      	add	sp, #224	; 0xe0
    1cc6:	bd70      	pop	{r4, r5, r6, pc}

00001cc8 <ed25519_smult>:

void ed25519_smult(struct ed25519_pt *r_out, const struct ed25519_pt *p,
		   const uint8_t *e)
{
    1cc8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1ccc:	b0c0      	sub	sp, #256	; 0x100
    1cce:	4680      	mov	r8, r0
    1cd0:	460f      	mov	r7, r1
    1cd2:	4616      	mov	r6, r2

/* Order of the group generated by the base point */
static inline void ed25519_copy(struct ed25519_pt *dst,
				const struct ed25519_pt *src)
{
	memcpy(dst, src, sizeof(*dst));
    1cd4:	4668      	mov	r0, sp
    1cd6:	491c      	ldr	r1, [pc, #112]	; (1d48 <ed25519_smult+0x80>)
    1cd8:	2280      	movs	r2, #128	; 0x80
    1cda:	f004 fd01 	bl	66e0 <memcpy>
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1cde:	24ff      	movs	r4, #255	; 0xff
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1ce0:	10e3      	asrs	r3, r4, #3
    1ce2:	5cf5      	ldrb	r5, [r6, r3]
    1ce4:	f004 0307 	and.w	r3, r4, #7
    1ce8:	411d      	asrs	r5, r3
		struct ed25519_pt s;

		ed25519_double(&r, &r);
    1cea:	4668      	mov	r0, sp
    1cec:	4669      	mov	r1, sp
    1cee:	f7ff ff91 	bl	1c14 <ed25519_double>
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1cf2:	f005 0501 	and.w	r5, r5, #1
		struct ed25519_pt s;

		ed25519_double(&r, &r);
		ed25519_add(&s, &r, p);
    1cf6:	a820      	add	r0, sp, #128	; 0x80
    1cf8:	4669      	mov	r1, sp
    1cfa:	463a      	mov	r2, r7
    1cfc:	f7ff ff1a 	bl	1b34 <ed25519_add>

		f25519_select(r.x, r.x, s.x, bit);
    1d00:	4668      	mov	r0, sp
    1d02:	4669      	mov	r1, sp
    1d04:	aa20      	add	r2, sp, #128	; 0x80
    1d06:	462b      	mov	r3, r5
    1d08:	f000 f974 	bl	1ff4 <f25519_select>
		f25519_select(r.y, r.y, s.y, bit);
    1d0c:	a808      	add	r0, sp, #32
    1d0e:	4601      	mov	r1, r0
    1d10:	aa28      	add	r2, sp, #160	; 0xa0
    1d12:	462b      	mov	r3, r5
    1d14:	f000 f96e 	bl	1ff4 <f25519_select>
		f25519_select(r.z, r.z, s.z, bit);
    1d18:	a818      	add	r0, sp, #96	; 0x60
    1d1a:	4601      	mov	r1, r0
    1d1c:	aa38      	add	r2, sp, #224	; 0xe0
    1d1e:	462b      	mov	r3, r5
    1d20:	f000 f968 	bl	1ff4 <f25519_select>
		f25519_select(r.t, r.t, s.t, bit);
    1d24:	a810      	add	r0, sp, #64	; 0x40
    1d26:	462b      	mov	r3, r5
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d28:	3c01      	subs	r4, #1
		ed25519_add(&s, &r, p);

		f25519_select(r.x, r.x, s.x, bit);
		f25519_select(r.y, r.y, s.y, bit);
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
    1d2a:	4601      	mov	r1, r0
    1d2c:	aa30      	add	r2, sp, #192	; 0xc0
    1d2e:	f000 f961 	bl	1ff4 <f25519_select>
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d32:	1c63      	adds	r3, r4, #1
    1d34:	d1d4      	bne.n	1ce0 <ed25519_smult+0x18>
    1d36:	4640      	mov	r0, r8
    1d38:	4669      	mov	r1, sp
    1d3a:	2280      	movs	r2, #128	; 0x80
    1d3c:	f004 fcd0 	bl	66e0 <memcpy>
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
	}

	ed25519_copy(r_out, &r);
}
    1d40:	b040      	add	sp, #256	; 0x100
    1d42:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1d46:	bf00      	nop
    1d48:	000070a4 	andeq	r7, r0, r4, lsr #1

00001d4c <edsign_verify>:
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1d4c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1d50:	4606      	mov	r6, r0
    1d52:	460f      	mov	r7, r1
    1d54:	b0e9      	sub	sp, #420	; 0x1a4
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d56:	6800      	ldr	r0, [r0, #0]
    1d58:	6871      	ldr	r1, [r6, #4]
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1d5a:	4698      	mov	r8, r3
    1d5c:	4691      	mov	r9, r2
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d5e:	68f3      	ldr	r3, [r6, #12]
    1d60:	68b2      	ldr	r2, [r6, #8]
    1d62:	ac48      	add	r4, sp, #288	; 0x120
    1d64:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1d66:	6930      	ldr	r0, [r6, #16]
    1d68:	6971      	ldr	r1, [r6, #20]
    1d6a:	69b2      	ldr	r2, [r6, #24]
    1d6c:	69f3      	ldr	r3, [r6, #28]
	memcpy(block + 32, a, 32);
    1d6e:	f50d 7ea0 	add.w	lr, sp, #320	; 0x140
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d72:	c40f      	stmia	r4!, {r0, r1, r2, r3}
	memcpy(block + 32, a, 32);
    1d74:	6838      	ldr	r0, [r7, #0]
    1d76:	6879      	ldr	r1, [r7, #4]
    1d78:	68ba      	ldr	r2, [r7, #8]
    1d7a:	68fb      	ldr	r3, [r7, #12]
extern const struct sha512_state sha512_initial_state;

/* Set up a new context */
static inline void sha512_init(struct sha512_state *s)
{
	memcpy(s, &sha512_initial_state, sizeof(*s));
    1d7c:	4d4f      	ldr	r5, [pc, #316]	; (1ebc <edsign_verify+0x170>)
    1d7e:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    1d82:	6938      	ldr	r0, [r7, #16]
    1d84:	6979      	ldr	r1, [r7, #20]
    1d86:	69ba      	ldr	r2, [r7, #24]
    1d88:	69fb      	ldr	r3, [r7, #28]
    1d8a:	ac28      	add	r4, sp, #160	; 0xa0
    1d8c:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    1d90:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    1d92:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1d94:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    1d96:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1d98:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    1d9a:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1d9c:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
{
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
    1da0:	f1b8 0f3f 	cmp.w	r8, #63	; 0x3f
    1da4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    1da8:	d92a      	bls.n	1e00 <edsign_verify+0xb4>
		memcpy(init_block + prefix_size, message, len);
		sha512_final(&s, init_block, len + prefix_size);
	} else {
		size_t i;

		memcpy(init_block + prefix_size, message,
    1daa:	464c      	mov	r4, r9
    1dac:	f50d 7eb0 	add.w	lr, sp, #352	; 0x160
    1db0:	f109 0c40 	add.w	ip, r9, #64	; 0x40
    1db4:	6820      	ldr	r0, [r4, #0]
    1db6:	6861      	ldr	r1, [r4, #4]
    1db8:	68a2      	ldr	r2, [r4, #8]
    1dba:	68e3      	ldr	r3, [r4, #12]
    1dbc:	4675      	mov	r5, lr
    1dbe:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    1dc0:	3410      	adds	r4, #16
    1dc2:	4564      	cmp	r4, ip
    1dc4:	46ae      	mov	lr, r5
    1dc6:	d1f5      	bne.n	1db4 <edsign_verify+0x68>
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);
    1dc8:	a828      	add	r0, sp, #160	; 0xa0
    1dca:	a948      	add	r1, sp, #288	; 0x120
    1dcc:	f003 fa38 	bl	5240 <sha512_block>

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dd0:	f1b8 0fbf 	cmp.w	r8, #191	; 0xbf
    1dd4:	d970      	bls.n	1eb8 <edsign_verify+0x16c>
		     i + SHA512_BLOCK_SIZE <= len;
    1dd6:	24c0      	movs	r4, #192	; 0xc0

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dd8:	2140      	movs	r1, #64	; 0x40
    1dda:	e001      	b.n	1de0 <edsign_verify+0x94>
    1ddc:	4621      	mov	r1, r4
		     i + SHA512_BLOCK_SIZE <= len;
    1dde:	462c      	mov	r4, r5
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1de0:	4449      	add	r1, r9
    1de2:	a828      	add	r0, sp, #160	; 0xa0
		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
		     i + SHA512_BLOCK_SIZE <= len;
    1de4:	f104 0580 	add.w	r5, r4, #128	; 0x80
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1de8:	f003 fa2a 	bl	5240 <sha512_block>

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dec:	45a8      	cmp	r8, r5
    1dee:	d2f5      	bcs.n	1ddc <edsign_verify+0x90>
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
    1df0:	eb09 0104 	add.w	r1, r9, r4
    1df4:	f108 0240 	add.w	r2, r8, #64	; 0x40
    1df8:	a828      	add	r0, sp, #160	; 0xa0
    1dfa:	f003 fc6b 	bl	56d4 <sha512_final>
    1dfe:	e00a      	b.n	1e16 <edsign_verify+0xca>
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
		memcpy(init_block + prefix_size, message, len);
    1e00:	4649      	mov	r1, r9
    1e02:	4642      	mov	r2, r8
    1e04:	a858      	add	r0, sp, #352	; 0x160
    1e06:	f004 fc6b 	bl	66e0 <memcpy>
		sha512_final(&s, init_block, len + prefix_size);
    1e0a:	a828      	add	r0, sp, #160	; 0xa0
    1e0c:	a948      	add	r1, sp, #288	; 0x120
    1e0e:	f108 0240 	add.w	r2, r8, #64	; 0x40
    1e12:	f003 fc5f 	bl	56d4 <sha512_final>
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
	}

	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
    1e16:	a828      	add	r0, sp, #160	; 0xa0
    1e18:	a948      	add	r1, sp, #288	; 0x120
    1e1a:	2200      	movs	r2, #0
    1e1c:	2340      	movs	r3, #64	; 0x40
    1e1e:	f003 fc9d 	bl	575c <sha512_get>
	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
    1e22:	4b27      	ldr	r3, [pc, #156]	; (1ec0 <edsign_verify+0x174>)
    1e24:	a810      	add	r0, sp, #64	; 0x40
    1e26:	a948      	add	r1, sp, #288	; 0x120
    1e28:	2240      	movs	r2, #64	; 0x40
    1e2a:	f001 f807 	bl	2e3c <fprime_from_bytes>

static void sm_pack(uint8_t *r, const uint8_t *k)
{
	struct ed25519_pt p;

	ed25519_smult(&p, &ed25519_base, k);
    1e2e:	a848      	add	r0, sp, #288	; 0x120
    1e30:	f106 0220 	add.w	r2, r6, #32
    1e34:	4923      	ldr	r1, [pc, #140]	; (1ec4 <edsign_verify+0x178>)
    1e36:	f7ff ff47 	bl	1cc8 <ed25519_smult>
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1e3a:	a820      	add	r0, sp, #128	; 0x80
    1e3c:	a928      	add	r1, sp, #160	; 0xa0
    1e3e:	aa48      	add	r2, sp, #288	; 0x120
    1e40:	f7ff fdc6 	bl	19d0 <ed25519_unproject>
	ed25519_pack(packed, x, y);
    1e44:	a920      	add	r1, sp, #128	; 0x80
    1e46:	4668      	mov	r0, sp
    1e48:	aa28      	add	r2, sp, #160	; 0xa0
    1e4a:	f7ff fddf 	bl	1a0c <ed25519_pack>

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e4e:	a948      	add	r1, sp, #288	; 0x120
    1e50:	463a      	mov	r2, r7
    1e52:	a820      	add	r0, sp, #128	; 0x80
    1e54:	f7ff fe0a 	bl	1a6c <ed25519_try_unpack>

	ed25519_project(p, x, y);
    1e58:	a920      	add	r1, sp, #128	; 0x80

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e5a:	4605      	mov	r5, r0

	ed25519_project(p, x, y);
    1e5c:	aa48      	add	r2, sp, #288	; 0x120
    1e5e:	a828      	add	r0, sp, #160	; 0xa0
    1e60:	f7ff fd7e 	bl	1960 <ed25519_project>
	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
    1e64:	a828      	add	r0, sp, #160	; 0xa0
    1e66:	4601      	mov	r1, r0
    1e68:	aa10      	add	r2, sp, #64	; 0x40
    1e6a:	f7ff ff2d 	bl	1cc8 <ed25519_smult>

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e6e:	4632      	mov	r2, r6
    1e70:	a920      	add	r1, sp, #128	; 0x80
    1e72:	a818      	add	r0, sp, #96	; 0x60
    1e74:	f7ff fdfa 	bl	1a6c <ed25519_try_unpack>

	ed25519_project(p, x, y);
    1e78:	a918      	add	r1, sp, #96	; 0x60

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e7a:	4604      	mov	r4, r0

	ed25519_project(p, x, y);
    1e7c:	aa20      	add	r2, sp, #128	; 0x80
    1e7e:	a848      	add	r0, sp, #288	; 0x120
    1e80:	f7ff fd6e 	bl	1960 <ed25519_project>

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
    1e84:	a828      	add	r0, sp, #160	; 0xa0
    1e86:	4601      	mov	r1, r0
    1e88:	aa48      	add	r2, sp, #288	; 0x120
    1e8a:	f7ff fe53 	bl	1b34 <ed25519_add>
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1e8e:	a818      	add	r0, sp, #96	; 0x60
    1e90:	a920      	add	r1, sp, #128	; 0x80
    1e92:	aa28      	add	r2, sp, #160	; 0xa0
    1e94:	f7ff fd9c 	bl	19d0 <ed25519_unproject>
	ed25519_pack(packed, x, y);
    1e98:	a918      	add	r1, sp, #96	; 0x60
    1e9a:	aa20      	add	r2, sp, #128	; 0x80
    1e9c:	a808      	add	r0, sp, #32
    1e9e:	f7ff fdb5 	bl	1a0c <ed25519_pack>
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
    1ea2:	4668      	mov	r0, sp
    1ea4:	a908      	add	r1, sp, #32
    1ea6:	f000 f857 	bl	1f58 <f25519_eq>

	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
    1eaa:	4028      	ands	r0, r5
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
    1eac:	f000 0001 	and.w	r0, r0, #1
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
}
    1eb0:	4020      	ands	r0, r4
    1eb2:	b069      	add	sp, #420	; 0x1a4
    1eb4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1eb8:	2440      	movs	r4, #64	; 0x40
    1eba:	e799      	b.n	1df0 <edsign_verify+0xa4>
    1ebc:	00007208 	andeq	r7, r0, r8, lsl #4
    1ec0:	000071c4 	andeq	r7, r0, r4, asr #3
    1ec4:	00007124 	andeq	r7, r0, r4, lsr #2

00001ec8 <f25519_load>:

const uint8_t f25519_zero[F25519_SIZE] = {0};
const uint8_t f25519_one[F25519_SIZE] = {1};

void f25519_load(uint8_t *x, uint32_t c)
{
    1ec8:	b410      	push	{r4}
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
		c >>= 8;
    1eca:	0c0a      	lsrs	r2, r1, #16
    1ecc:	0a0c      	lsrs	r4, r1, #8
    1ece:	0e0b      	lsrs	r3, r1, #24
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    1ed0:	7001      	strb	r1, [r0, #0]
    1ed2:	7082      	strb	r2, [r0, #2]
    1ed4:	7044      	strb	r4, [r0, #1]
    1ed6:	70c3      	strb	r3, [r0, #3]
    1ed8:	2100      	movs	r1, #0
    1eda:	3004      	adds	r0, #4
    1edc:	221c      	movs	r2, #28
		c >>= 8;
	}

	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}
    1ede:	f85d 4b04 	ldr.w	r4, [sp], #4
    1ee2:	f004 bc24 	b.w	672e <memset>
    1ee6:	bf00      	nop

00001ee8 <f25519_normalize>:

void f25519_normalize(uint8_t *x)
{
    1ee8:	b410      	push	{r4}
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1eea:	7fc4      	ldrb	r4, [r0, #31]
	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}

void f25519_normalize(uint8_t *x)
{
    1eec:	b089      	sub	sp, #36	; 0x24
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1eee:	09e1      	lsrs	r1, r4, #7
    1ef0:	00ca      	lsls	r2, r1, #3
	x[31] &= 127;
    1ef2:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1ef6:	440a      	add	r2, r1
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1ef8:	2300      	movs	r3, #0
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;
    1efa:	77c4      	strb	r4, [r0, #31]
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1efc:	eb01 0242 	add.w	r2, r1, r2, lsl #1
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
		c += x[i];
    1f00:	5cc1      	ldrb	r1, [r0, r3]
    1f02:	440a      	add	r2, r1
		x[i] = c;
    1f04:	54c2      	strb	r2, [r0, r3]

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1f06:	3301      	adds	r3, #1
    1f08:	2b20      	cmp	r3, #32
		c += x[i];
		x[i] = c;
		c >>= 8;
    1f0a:	f3c2 220f 	ubfx	r2, r2, #8, #16

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1f0e:	d1f7      	bne.n	1f00 <f25519_normalize+0x18>
    1f10:	2300      	movs	r3, #0
    1f12:	2213      	movs	r2, #19
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += x[i];
    1f14:	5cc1      	ldrb	r1, [r0, r3]
    1f16:	440a      	add	r2, r1
		minusp[i] = c;
    1f18:	f80d 2003 	strb.w	r2, [sp, r3]
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1f1c:	3301      	adds	r3, #1
    1f1e:	2b1f      	cmp	r3, #31
		c += x[i];
		minusp[i] = c;
		c >>= 8;
    1f20:	f3c2 220f 	ubfx	r2, r2, #8, #16
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1f24:	d1f6      	bne.n	1f14 <f25519_normalize+0x2c>
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1f26:	7fc1      	ldrb	r1, [r0, #31]
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1f28:	2300      	movs	r3, #0
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1f2a:	3980      	subs	r1, #128	; 0x80
    1f2c:	440a      	add	r2, r1
    1f2e:	b292      	uxth	r2, r2

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1f30:	f342 34c0 	sbfx	r4, r2, #15, #1
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;
    1f34:	f88d 201f 	strb.w	r2, [sp, #31]

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1f38:	b2e4      	uxtb	r4, r4
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    1f3a:	f81d 2003 	ldrb.w	r2, [sp, r3]
    1f3e:	5cc1      	ldrb	r1, [r0, r3]
    1f40:	4051      	eors	r1, r2
    1f42:	4021      	ands	r1, r4
    1f44:	404a      	eors	r2, r1
    1f46:	54c2      	strb	r2, [r0, r3]
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1f48:	3301      	adds	r3, #1
    1f4a:	2b20      	cmp	r3, #32
    1f4c:	d1f5      	bne.n	1f3a <f25519_normalize+0x52>
	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;

	/* Load x-p if no underflow */
	f25519_select(x, minusp, x, (c >> 15) & 1);
}
    1f4e:	b009      	add	sp, #36	; 0x24
    1f50:	f85d 4b04 	ldr.w	r4, [sp], #4
    1f54:	4770      	bx	lr
    1f56:	bf00      	nop

00001f58 <f25519_eq>:

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
    1f58:	ea40 0301 	orr.w	r3, r0, r1
    1f5c:	079b      	lsls	r3, r3, #30
    1f5e:	b4f0      	push	{r4, r5, r6, r7}
    1f60:	d13c      	bne.n	1fdc <f25519_eq+0x84>
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    1f62:	6807      	ldr	r7, [r0, #0]
    1f64:	6842      	ldr	r2, [r0, #4]
    1f66:	684b      	ldr	r3, [r1, #4]
    1f68:	680e      	ldr	r6, [r1, #0]
    1f6a:	6885      	ldr	r5, [r0, #8]
    1f6c:	688c      	ldr	r4, [r1, #8]
    1f6e:	ea82 0c03 	eor.w	ip, r2, r3
    1f72:	407e      	eors	r6, r7
    1f74:	68c2      	ldr	r2, [r0, #12]
    1f76:	68cb      	ldr	r3, [r1, #12]
    1f78:	ea46 060c 	orr.w	r6, r6, ip
    1f7c:	ea85 0c04 	eor.w	ip, r5, r4
    1f80:	6905      	ldr	r5, [r0, #16]
    1f82:	690c      	ldr	r4, [r1, #16]
    1f84:	ea46 0c0c 	orr.w	ip, r6, ip
    1f88:	ea82 0603 	eor.w	r6, r2, r3
    1f8c:	6942      	ldr	r2, [r0, #20]
    1f8e:	694b      	ldr	r3, [r1, #20]
    1f90:	ea4c 0c06 	orr.w	ip, ip, r6
    1f94:	6987      	ldr	r7, [r0, #24]
    1f96:	698e      	ldr	r6, [r1, #24]
    1f98:	406c      	eors	r4, r5
    1f9a:	ea4c 0404 	orr.w	r4, ip, r4
    1f9e:	4053      	eors	r3, r2
    1fa0:	69c0      	ldr	r0, [r0, #28]
    1fa2:	69c9      	ldr	r1, [r1, #28]
    1fa4:	ea44 0203 	orr.w	r2, r4, r3
    1fa8:	ea87 0406 	eor.w	r4, r7, r6
    1fac:	4322      	orrs	r2, r4
    1fae:	ea80 0301 	eor.w	r3, r0, r1
    1fb2:	4313      	orrs	r3, r2
    1fb4:	ea43 2213 	orr.w	r2, r3, r3, lsr #8
    1fb8:	ea42 4213 	orr.w	r2, r2, r3, lsr #16
    1fbc:	f002 02ff 	and.w	r2, r2, #255	; 0xff
    1fc0:	ea42 6213 	orr.w	r2, r2, r3, lsr #24

	sum |= (sum >> 4);
    1fc4:	ea42 1212 	orr.w	r2, r2, r2, lsr #4
	sum |= (sum >> 2);
    1fc8:	ea42 0292 	orr.w	r2, r2, r2, lsr #2
	sum |= (sum >> 1);
    1fcc:	ea42 0252 	orr.w	r2, r2, r2, lsr #1

	return (sum ^ 1) & 1;
    1fd0:	f002 0001 	and.w	r0, r2, #1
}
    1fd4:	f080 0001 	eor.w	r0, r0, #1
    1fd8:	bcf0      	pop	{r4, r5, r6, r7}
    1fda:	4770      	bx	lr
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fdc:	2300      	movs	r3, #0
	f25519_select(x, minusp, x, (c >> 15) & 1);
}

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
    1fde:	461a      	mov	r2, r3
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    1fe0:	5cc5      	ldrb	r5, [r0, r3]
    1fe2:	5ccc      	ldrb	r4, [r1, r3]
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fe4:	3301      	adds	r3, #1
		sum |= x[i] ^ y[i];
    1fe6:	406c      	eors	r4, r5
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fe8:	2b20      	cmp	r3, #32
		sum |= x[i] ^ y[i];
    1fea:	ea42 0204 	orr.w	r2, r2, r4
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fee:	d1f7      	bne.n	1fe0 <f25519_eq+0x88>
    1ff0:	e7e8      	b.n	1fc4 <f25519_eq+0x6c>
    1ff2:	bf00      	nop

00001ff4 <f25519_select>:
}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
    1ff4:	b4f0      	push	{r4, r5, r6, r7}
    1ff6:	1d04      	adds	r4, r0, #4
    1ff8:	1d0f      	adds	r7, r1, #4
    1ffa:	42b8      	cmp	r0, r7
    1ffc:	bf38      	it	cc
    1ffe:	42a1      	cmpcc	r1, r4
    2000:	f102 0504 	add.w	r5, r2, #4
    2004:	bf34      	ite	cc
    2006:	2700      	movcc	r7, #0
    2008:	2701      	movcs	r7, #1
    200a:	42a8      	cmp	r0, r5
    200c:	bf38      	it	cc
    200e:	42a2      	cmpcc	r2, r4
    2010:	bf34      	ite	cc
    2012:	2400      	movcc	r4, #0
    2014:	2401      	movcs	r4, #1
	const uint8_t mask = -condition;
    2016:	425b      	negs	r3, r3
    2018:	4227      	tst	r7, r4
    201a:	b2de      	uxtb	r6, r3
    201c:	d03f      	beq.n	209e <f25519_select+0xaa>
    201e:	ea41 0302 	orr.w	r3, r1, r2
    2022:	4303      	orrs	r3, r0
    2024:	079b      	lsls	r3, r3, #30
    2026:	d13a      	bne.n	209e <f25519_select+0xaa>
    2028:	2300      	movs	r3, #0
    202a:	f366 0307 	bfi	r3, r6, #0, #8
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    202e:	680c      	ldr	r4, [r1, #0]
    2030:	6815      	ldr	r5, [r2, #0]
    2032:	f366 230f 	bfi	r3, r6, #8, #8
    2036:	f366 4317 	bfi	r3, r6, #16, #8
    203a:	f366 631f 	bfi	r3, r6, #24, #8
    203e:	4065      	eors	r5, r4
    2040:	401d      	ands	r5, r3
    2042:	406c      	eors	r4, r5
    2044:	6004      	str	r4, [r0, #0]
    2046:	684c      	ldr	r4, [r1, #4]
    2048:	6855      	ldr	r5, [r2, #4]
    204a:	4065      	eors	r5, r4
    204c:	401d      	ands	r5, r3
    204e:	406c      	eors	r4, r5
    2050:	6044      	str	r4, [r0, #4]
    2052:	688c      	ldr	r4, [r1, #8]
    2054:	6895      	ldr	r5, [r2, #8]
    2056:	4065      	eors	r5, r4
    2058:	401d      	ands	r5, r3
    205a:	406c      	eors	r4, r5
    205c:	6084      	str	r4, [r0, #8]
    205e:	68cc      	ldr	r4, [r1, #12]
    2060:	68d5      	ldr	r5, [r2, #12]
    2062:	4065      	eors	r5, r4
    2064:	401d      	ands	r5, r3
    2066:	406c      	eors	r4, r5
    2068:	60c4      	str	r4, [r0, #12]
    206a:	690c      	ldr	r4, [r1, #16]
    206c:	6915      	ldr	r5, [r2, #16]
    206e:	4065      	eors	r5, r4
    2070:	401d      	ands	r5, r3
    2072:	406c      	eors	r4, r5
    2074:	6104      	str	r4, [r0, #16]
    2076:	694c      	ldr	r4, [r1, #20]
    2078:	6955      	ldr	r5, [r2, #20]
    207a:	4065      	eors	r5, r4
    207c:	401d      	ands	r5, r3
    207e:	406c      	eors	r4, r5
    2080:	6144      	str	r4, [r0, #20]
    2082:	698c      	ldr	r4, [r1, #24]
    2084:	6995      	ldr	r5, [r2, #24]
    2086:	4065      	eors	r5, r4
    2088:	401d      	ands	r5, r3
    208a:	406c      	eors	r4, r5
    208c:	6184      	str	r4, [r0, #24]
    208e:	69c9      	ldr	r1, [r1, #28]
    2090:	69d2      	ldr	r2, [r2, #28]
}
    2092:	bcf0      	pop	{r4, r5, r6, r7}
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    2094:	404a      	eors	r2, r1
    2096:	4013      	ands	r3, r2
    2098:	4059      	eors	r1, r3
    209a:	61c1      	str	r1, [r0, #28]
}
    209c:	4770      	bx	lr
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    209e:	2300      	movs	r3, #0
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    20a0:	5ccc      	ldrb	r4, [r1, r3]
    20a2:	5cd5      	ldrb	r5, [r2, r3]
    20a4:	4065      	eors	r5, r4
    20a6:	4035      	ands	r5, r6
    20a8:	406c      	eors	r4, r5
    20aa:	54c4      	strb	r4, [r0, r3]
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    20ac:	3301      	adds	r3, #1
    20ae:	2b20      	cmp	r3, #32
    20b0:	d1f6      	bne.n	20a0 <f25519_select+0xac>
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}
    20b2:	bcf0      	pop	{r4, r5, r6, r7}
    20b4:	4770      	bx	lr
    20b6:	bf00      	nop

000020b8 <f25519_add>:
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    20b8:	2300      	movs	r3, #0
	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}

void f25519_add(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    20ba:	b470      	push	{r4, r5, r6}
	uint16_t c = 0;
    20bc:	461c      	mov	r4, r3
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
    20be:	5cce      	ldrb	r6, [r1, r3]
    20c0:	5cd5      	ldrb	r5, [r2, r3]
    20c2:	4435      	add	r5, r6
    20c4:	eb05 2414 	add.w	r4, r5, r4, lsr #8
		r[i] = c;
    20c8:	54c4      	strb	r4, [r0, r3]
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    20ca:	3301      	adds	r3, #1
    20cc:	2b20      	cmp	r3, #32
    20ce:	d1f6      	bne.n	20be <f25519_add+0x6>
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;
    20d0:	f3c4 14cf 	ubfx	r4, r4, #7, #16
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20d4:	7fc3      	ldrb	r3, [r0, #31]
	c = (c >> 7) * 19;
    20d6:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20da:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	c = (c >> 7) * 19;
    20de:	eb04 0242 	add.w	r2, r4, r2, lsl #1
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20e2:	77c3      	strb	r3, [r0, #31]
	c = (c >> 7) * 19;
    20e4:	b292      	uxth	r2, r2

	for (i = 0; i < F25519_SIZE; i++) {
    20e6:	2300      	movs	r3, #0
		c += r[i];
    20e8:	5cc1      	ldrb	r1, [r0, r3]
    20ea:	440a      	add	r2, r1
    20ec:	b292      	uxth	r2, r2
		r[i] = c;
    20ee:	54c2      	strb	r2, [r0, r3]

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    20f0:	3301      	adds	r3, #1
    20f2:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    20f4:	ea4f 2212 	mov.w	r2, r2, lsr #8

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    20f8:	d1f6      	bne.n	20e8 <f25519_add+0x30>
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    20fa:	bc70      	pop	{r4, r5, r6}
    20fc:	4770      	bx	lr
    20fe:	bf00      	nop

00002100 <f25519_sub>:

void f25519_sub(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2100:	b470      	push	{r4, r5, r6}
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2102:	2300      	movs	r3, #0
{
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
    2104:	24da      	movs	r4, #218	; 0xda
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2106:	5ccd      	ldrb	r5, [r1, r3]
    2108:	5cd6      	ldrb	r6, [r2, r3]
    210a:	f505 457f 	add.w	r5, r5, #65280	; 0xff00
    210e:	1bad      	subs	r5, r5, r6
    2110:	442c      	add	r4, r5
		r[i] = c;
    2112:	54c4      	strb	r4, [r0, r3]
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2114:	3301      	adds	r3, #1
    2116:	2b1f      	cmp	r3, #31
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2118:	ea4f 2414 	mov.w	r4, r4, lsr #8
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    211c:	d1f3      	bne.n	2106 <f25519_sub+0x6>
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    211e:	7fc9      	ldrb	r1, [r1, #31]
    2120:	7fd2      	ldrb	r2, [r2, #31]
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2122:	2300      	movs	r3, #0
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2124:	1a8a      	subs	r2, r1, r2
    2126:	4414      	add	r4, r2
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2128:	09e2      	lsrs	r2, r4, #7
    212a:	eb02 01c2 	add.w	r1, r2, r2, lsl #3
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    212e:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    2132:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;
    2134:	eb02 0241 	add.w	r2, r2, r1, lsl #1

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2138:	5cc1      	ldrb	r1, [r0, r3]
    213a:	440a      	add	r2, r1
		r[i] = c;
    213c:	54c2      	strb	r2, [r0, r3]

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    213e:	3301      	adds	r3, #1
    2140:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    2142:	ea4f 2212 	mov.w	r2, r2, lsr #8

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2146:	d1f7      	bne.n	2138 <f25519_sub+0x38>
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    2148:	bc70      	pop	{r4, r5, r6}
    214a:	4770      	bx	lr

0000214c <f25519_neg>:

void f25519_neg(uint8_t *r, const uint8_t *a)
{
    214c:	b410      	push	{r4}
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    214e:	2300      	movs	r3, #0
{
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
    2150:	22da      	movs	r2, #218	; 0xda
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 - ((uint32_t)a[i]);
    2152:	5ccc      	ldrb	r4, [r1, r3]
    2154:	f5c4 447f 	rsb	r4, r4, #65280	; 0xff00
    2158:	4422      	add	r2, r4
		r[i] = c;
    215a:	54c2      	strb	r2, [r0, r3]
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    215c:	3301      	adds	r3, #1
    215e:	2b1f      	cmp	r3, #31
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
    2160:	ea4f 2212 	mov.w	r2, r2, lsr #8
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2164:	d1f5      	bne.n	2152 <f25519_neg+0x6>
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
    2166:	7fc9      	ldrb	r1, [r1, #31]
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2168:	2300      	movs	r3, #0
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
    216a:	1a52      	subs	r2, r2, r1
	r[31] = c & 127;
	c = (c >> 7) * 19;
    216c:	09d1      	lsrs	r1, r2, #7
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    216e:	f002 047f 	and.w	r4, r2, #127	; 0x7f
	c = (c >> 7) * 19;
    2172:	eb01 02c1 	add.w	r2, r1, r1, lsl #3
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    2176:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;
    2178:	eb01 0242 	add.w	r2, r1, r2, lsl #1

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    217c:	5cc1      	ldrb	r1, [r0, r3]
    217e:	440a      	add	r2, r1
		r[i] = c;
    2180:	54c2      	strb	r2, [r0, r3]

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2182:	3301      	adds	r3, #1
    2184:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    2186:	ea4f 2212 	mov.w	r2, r2, lsr #8

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    218a:	d1f7      	bne.n	217c <f25519_neg+0x30>
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    218c:	f85d 4b04 	ldr.w	r4, [sp], #4
    2190:	4770      	bx	lr
    2192:	bf00      	nop

00002194 <f25519_mul__distinct>:

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2194:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2198:	f04f 0800 	mov.w	r8, #0
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    219c:	4643      	mov	r3, r8
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    219e:	f04f 0926 	mov.w	r9, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    21a2:	0a1b      	lsrs	r3, r3, #8
    21a4:	eb02 0508 	add.w	r5, r2, r8
		for (j = 0; j <= i; j++)
    21a8:	2400      	movs	r4, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    21aa:	5d0f      	ldrb	r7, [r1, r4]
    21ac:	f815 6901 	ldrb.w	r6, [r5], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    21b0:	3401      	adds	r4, #1
    21b2:	4544      	cmp	r4, r8
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    21b4:	fb07 3306 	mla	r3, r7, r6, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    21b8:	ddf7      	ble.n	21aa <f25519_mul__distinct+0x16>
    21ba:	ea28 75e8 	bic.w	r5, r8, r8, asr #31
    21be:	1c6c      	adds	r4, r5, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21c0:	2c20      	cmp	r4, #32
    21c2:	d00f      	beq.n	21e4 <f25519_mul__distinct+0x50>
    21c4:	ebc5 0608 	rsb	r6, r5, r8
    21c8:	3620      	adds	r6, #32
    21ca:	4416      	add	r6, r2
    21cc:	440d      	add	r5, r1
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    21ce:	f816 7d01 	ldrb.w	r7, [r6, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    21d2:	f815 cf01 	ldrb.w	ip, [r5, #1]!
    21d6:	fb09 f707 	mul.w	r7, r9, r7

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21da:	3401      	adds	r4, #1
    21dc:	2c20      	cmp	r4, #32
			c += ((uint32_t)a[j]) *
    21de:	fb0c 3307 	mla	r3, ip, r7, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21e2:	d1f4      	bne.n	21ce <f25519_mul__distinct+0x3a>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    21e4:	f800 3008 	strb.w	r3, [r0, r8]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    21e8:	f108 0801 	add.w	r8, r8, #1
    21ec:	f1b8 0f20 	cmp.w	r8, #32
    21f0:	d1d7      	bne.n	21a2 <f25519_mul__distinct+0xe>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    21f2:	7fc1      	ldrb	r1, [r0, #31]
	c = (c >> 7) * 19;
    21f4:	09db      	lsrs	r3, r3, #7
    21f6:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    21fa:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    21fe:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2202:	77c1      	strb	r1, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2204:	2300      	movs	r3, #0
		c += r[i];
    2206:	5cc1      	ldrb	r1, [r0, r3]
    2208:	440a      	add	r2, r1
		r[i] = c;
    220a:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    220c:	3301      	adds	r3, #1
    220e:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    2210:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2214:	d1f7      	bne.n	2206 <f25519_mul__distinct+0x72>
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    2216:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
    221a:	4770      	bx	lr

0000221c <f25519_inv__distinct>:
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    221c:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2220:	2600      	movs	r6, #0
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    2222:	b088      	sub	sp, #32
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    2224:	4633      	mov	r3, r6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2226:	f04f 0826 	mov.w	r8, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    222a:	0a1b      	lsrs	r3, r3, #8
    222c:	1874      	adds	r4, r6, r1
		for (j = 0; j <= i; j++)
    222e:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2230:	5c8f      	ldrb	r7, [r1, r2]
    2232:	f814 5901 	ldrb.w	r5, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2236:	3201      	adds	r2, #1
    2238:	42b2      	cmp	r2, r6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    223a:	fb07 3305 	mla	r3, r7, r5, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    223e:	ddf7      	ble.n	2230 <f25519_inv__distinct+0x14>
    2240:	ea26 74e6 	bic.w	r4, r6, r6, asr #31
    2244:	1c62      	adds	r2, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2246:	2a20      	cmp	r2, #32
    2248:	d00e      	beq.n	2268 <f25519_inv__distinct+0x4c>
    224a:	1b35      	subs	r5, r6, r4
    224c:	3520      	adds	r5, #32
    224e:	440d      	add	r5, r1
    2250:	440c      	add	r4, r1
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2252:	f815 7d01 	ldrb.w	r7, [r5, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2256:	f814 cf01 	ldrb.w	ip, [r4, #1]!
    225a:	fb08 f707 	mul.w	r7, r8, r7

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    225e:	3201      	adds	r2, #1
    2260:	2a20      	cmp	r2, #32
			c += ((uint32_t)a[j]) *
    2262:	fb0c 3307 	mla	r3, ip, r7, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2266:	d1f4      	bne.n	2252 <f25519_inv__distinct+0x36>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2268:	f80d 3006 	strb.w	r3, [sp, r6]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    226c:	3601      	adds	r6, #1
    226e:	2e20      	cmp	r6, #32
    2270:	d1db      	bne.n	222a <f25519_inv__distinct+0xe>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2272:	f89d 401f 	ldrb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    2276:	09db      	lsrs	r3, r3, #7
    2278:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    227c:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    2280:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2284:	f88d 401f 	strb.w	r4, [sp, #31]
    2288:	af08      	add	r7, sp, #32
	c = (c >> 7) * 19;
    228a:	466b      	mov	r3, sp

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    228c:	781c      	ldrb	r4, [r3, #0]
    228e:	4422      	add	r2, r4
		r[i] = c;
    2290:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2294:	42bb      	cmp	r3, r7
		c += r[i];
		r[i] = c;
		c >>= 8;
    2296:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    229a:	d1f7      	bne.n	228c <f25519_inv__distinct+0x70>
    229c:	2500      	movs	r5, #0
    229e:	eb0d 0205 	add.w	r2, sp, r5
    22a2:	462b      	mov	r3, r5
    22a4:	f102 091f 	add.w	r9, r2, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22a8:	f04f 0826 	mov.w	r8, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    22ac:	0a1b      	lsrs	r3, r3, #8
    22ae:	194c      	adds	r4, r1, r5
		for (j = 0; j <= i; j++)
    22b0:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22b2:	f81d c002 	ldrb.w	ip, [sp, r2]
    22b6:	f814 6901 	ldrb.w	r6, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22ba:	3201      	adds	r2, #1
    22bc:	42aa      	cmp	r2, r5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22be:	fb0c 3306 	mla	r3, ip, r6, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22c2:	ddf6      	ble.n	22b2 <f25519_inv__distinct+0x96>
    22c4:	ea25 72e5 	bic.w	r2, r5, r5, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22c8:	2a1f      	cmp	r2, #31
    22ca:	d00e      	beq.n	22ea <f25519_inv__distinct+0xce>
    22cc:	1aac      	subs	r4, r5, r2
    22ce:	3420      	adds	r4, #32
    22d0:	ae00      	add	r6, sp, #0
    22d2:	440c      	add	r4, r1
    22d4:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    22d6:	f814 6d01 	ldrb.w	r6, [r4, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22da:	f812 cf01 	ldrb.w	ip, [r2, #1]!
    22de:	fb08 f606 	mul.w	r6, r8, r6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22e2:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) *
    22e4:	fb0c 3306 	mla	r3, ip, r6, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22e8:	d1f5      	bne.n	22d6 <f25519_inv__distinct+0xba>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    22ea:	5543      	strb	r3, [r0, r5]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    22ec:	3501      	adds	r5, #1
    22ee:	2d20      	cmp	r5, #32
    22f0:	d1dc      	bne.n	22ac <f25519_inv__distinct+0x90>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22f2:	7fc4      	ldrb	r4, [r0, #31]
	c = (c >> 7) * 19;
    22f4:	09db      	lsrs	r3, r3, #7
    22f6:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22fa:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    22fe:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2302:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2304:	2300      	movs	r3, #0
		c += r[i];
    2306:	5cc4      	ldrb	r4, [r0, r3]
    2308:	4422      	add	r2, r4
		r[i] = c;
    230a:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    230c:	3301      	adds	r3, #1
    230e:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    2310:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2314:	d1f7      	bne.n	2306 <f25519_inv__distinct+0xea>
    2316:	f04f 0cf8 	mov.w	ip, #248	; 0xf8
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    231a:	2526      	movs	r5, #38	; 0x26
    231c:	f10d 061f 	add.w	r6, sp, #31
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2320:	f04f 0900 	mov.w	r9, #0
    2324:	464b      	mov	r3, r9
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2326:	0a1b      	lsrs	r3, r3, #8
    2328:	eb09 0400 	add.w	r4, r9, r0
		for (j = 0; j <= i; j++)
    232c:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    232e:	f810 a002 	ldrb.w	sl, [r0, r2]
    2332:	f814 8901 	ldrb.w	r8, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2336:	3201      	adds	r2, #1
    2338:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    233a:	fb0a 3308 	mla	r3, sl, r8, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    233e:	ddf6      	ble.n	232e <f25519_inv__distinct+0x112>
    2340:	ea29 74e9 	bic.w	r4, r9, r9, asr #31
    2344:	1c62      	adds	r2, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2346:	2a20      	cmp	r2, #32
    2348:	d010      	beq.n	236c <f25519_inv__distinct+0x150>
    234a:	ebc4 0809 	rsb	r8, r4, r9
    234e:	f108 0820 	add.w	r8, r8, #32
    2352:	4480      	add	r8, r0
    2354:	4404      	add	r4, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2356:	f818 ad01 	ldrb.w	sl, [r8, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    235a:	f814 bf01 	ldrb.w	fp, [r4, #1]!
    235e:	fb05 fa0a 	mul.w	sl, r5, sl

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2362:	3201      	adds	r2, #1
    2364:	2a20      	cmp	r2, #32
			c += ((uint32_t)a[j]) *
    2366:	fb0b 330a 	mla	r3, fp, sl, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    236a:	d1f4      	bne.n	2356 <f25519_inv__distinct+0x13a>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    236c:	f80d 3009 	strb.w	r3, [sp, r9]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2370:	f109 0901 	add.w	r9, r9, #1
    2374:	f1b9 0f20 	cmp.w	r9, #32
    2378:	d1d5      	bne.n	2326 <f25519_inv__distinct+0x10a>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    237a:	f89d 401f 	ldrb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    237e:	09db      	lsrs	r3, r3, #7
    2380:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2384:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    2388:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    238c:	f88d 401f 	strb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    2390:	ab00      	add	r3, sp, #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2392:	781c      	ldrb	r4, [r3, #0]
    2394:	4422      	add	r2, r4
		r[i] = c;
    2396:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    239a:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    239c:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23a0:	d1f7      	bne.n	2392 <f25519_inv__distinct+0x176>
    23a2:	f04f 0900 	mov.w	r9, #0
    23a6:	464b      	mov	r3, r9
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    23a8:	0a1b      	lsrs	r3, r3, #8
    23aa:	eb01 0409 	add.w	r4, r1, r9
		for (j = 0; j <= i; j++)
    23ae:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23b0:	f81d a002 	ldrb.w	sl, [sp, r2]
    23b4:	f814 8901 	ldrb.w	r8, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23b8:	3201      	adds	r2, #1
    23ba:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23bc:	fb0a 3308 	mla	r3, sl, r8, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23c0:	ddf6      	ble.n	23b0 <f25519_inv__distinct+0x194>
    23c2:	ea29 72e9 	bic.w	r2, r9, r9, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23c6:	2a1f      	cmp	r2, #31
    23c8:	d010      	beq.n	23ec <f25519_inv__distinct+0x1d0>
    23ca:	ebc2 0409 	rsb	r4, r2, r9
    23ce:	3420      	adds	r4, #32
    23d0:	f10d 0800 	add.w	r8, sp, #0
    23d4:	440c      	add	r4, r1
    23d6:	4442      	add	r2, r8
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    23d8:	f814 8d01 	ldrb.w	r8, [r4, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    23dc:	f812 af01 	ldrb.w	sl, [r2, #1]!
    23e0:	fb05 f808 	mul.w	r8, r5, r8

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23e4:	42b2      	cmp	r2, r6
			c += ((uint32_t)a[j]) *
    23e6:	fb0a 3308 	mla	r3, sl, r8, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23ea:	d1f5      	bne.n	23d8 <f25519_inv__distinct+0x1bc>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    23ec:	f800 3009 	strb.w	r3, [r0, r9]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    23f0:	f109 0901 	add.w	r9, r9, #1
    23f4:	f1b9 0f20 	cmp.w	r9, #32
    23f8:	d1d6      	bne.n	23a8 <f25519_inv__distinct+0x18c>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    23fa:	7fc4      	ldrb	r4, [r0, #31]
	c = (c >> 7) * 19;
    23fc:	09db      	lsrs	r3, r3, #7
    23fe:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2402:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    2406:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    240a:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    240c:	2300      	movs	r3, #0
		c += r[i];
    240e:	5cc4      	ldrb	r4, [r0, r3]
    2410:	4422      	add	r2, r4
		r[i] = c;
    2412:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2414:	3301      	adds	r3, #1
    2416:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    2418:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    241c:	d1f7      	bne.n	240e <f25519_inv__distinct+0x1f2>
	/* 1 1 */
	f25519_mul__distinct(s, x, x);
	f25519_mul__distinct(r, s, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    241e:	f1bc 0c01 	subs.w	ip, ip, #1
    2422:	f47f af7d 	bne.w	2320 <f25519_inv__distinct+0x104>
    2426:	4663      	mov	r3, ip
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2428:	f04f 0926 	mov.w	r9, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    242c:	0a1b      	lsrs	r3, r3, #8
    242e:	eb00 040c 	add.w	r4, r0, ip
		for (j = 0; j <= i; j++)
    2432:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2434:	5c86      	ldrb	r6, [r0, r2]
    2436:	f814 5901 	ldrb.w	r5, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    243a:	3201      	adds	r2, #1
    243c:	4562      	cmp	r2, ip
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    243e:	fb06 3305 	mla	r3, r6, r5, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2442:	ddf7      	ble.n	2434 <f25519_inv__distinct+0x218>
    2444:	ea2c 74ec 	bic.w	r4, ip, ip, asr #31
    2448:	1c62      	adds	r2, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    244a:	2a20      	cmp	r2, #32
    244c:	d00f      	beq.n	246e <f25519_inv__distinct+0x252>
    244e:	ebc4 050c 	rsb	r5, r4, ip
    2452:	3520      	adds	r5, #32
    2454:	4405      	add	r5, r0
    2456:	4404      	add	r4, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2458:	f815 6d01 	ldrb.w	r6, [r5, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    245c:	f814 8f01 	ldrb.w	r8, [r4, #1]!
    2460:	fb09 f606 	mul.w	r6, r9, r6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2464:	3201      	adds	r2, #1
    2466:	2a20      	cmp	r2, #32
			c += ((uint32_t)a[j]) *
    2468:	fb08 3306 	mla	r3, r8, r6, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    246c:	d1f4      	bne.n	2458 <f25519_inv__distinct+0x23c>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    246e:	f80d 300c 	strb.w	r3, [sp, ip]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2472:	f10c 0c01 	add.w	ip, ip, #1
    2476:	f1bc 0f20 	cmp.w	ip, #32
    247a:	d1d7      	bne.n	242c <f25519_inv__distinct+0x210>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    247c:	f89d 401f 	ldrb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    2480:	09db      	lsrs	r3, r3, #7
    2482:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2486:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    248a:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    248e:	f88d 401f 	strb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    2492:	ab00      	add	r3, sp, #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2494:	781c      	ldrb	r4, [r3, #0]
    2496:	4422      	add	r2, r4
		r[i] = c;
    2498:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    249c:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    249e:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24a2:	d1f7      	bne.n	2494 <f25519_inv__distinct+0x278>
    24a4:	2500      	movs	r5, #0
    24a6:	eb0d 0205 	add.w	r2, sp, r5
    24aa:	462b      	mov	r3, r5
    24ac:	f102 091f 	add.w	r9, r2, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24b0:	f04f 0826 	mov.w	r8, #38	; 0x26
    24b4:	ac00      	add	r4, sp, #0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    24b6:	0a1b      	lsrs	r3, r3, #8
    24b8:	442c      	add	r4, r5
		for (j = 0; j <= i; j++)
    24ba:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24bc:	f81d c002 	ldrb.w	ip, [sp, r2]
    24c0:	f814 6901 	ldrb.w	r6, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24c4:	3201      	adds	r2, #1
    24c6:	42aa      	cmp	r2, r5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24c8:	fb0c 3306 	mla	r3, ip, r6, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24cc:	ddf6      	ble.n	24bc <f25519_inv__distinct+0x2a0>
    24ce:	ea25 72e5 	bic.w	r2, r5, r5, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24d2:	2a1f      	cmp	r2, #31
    24d4:	d00e      	beq.n	24f4 <f25519_inv__distinct+0x2d8>
    24d6:	1aac      	subs	r4, r5, r2
    24d8:	ae00      	add	r6, sp, #0
    24da:	3420      	adds	r4, #32
    24dc:	4434      	add	r4, r6
    24de:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    24e0:	f814 6d01 	ldrb.w	r6, [r4, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24e4:	f812 cf01 	ldrb.w	ip, [r2, #1]!
    24e8:	fb08 f606 	mul.w	r6, r8, r6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24ec:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) *
    24ee:	fb0c 3306 	mla	r3, ip, r6, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24f2:	d1f5      	bne.n	24e0 <f25519_inv__distinct+0x2c4>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    24f4:	5543      	strb	r3, [r0, r5]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    24f6:	3501      	adds	r5, #1
    24f8:	2d20      	cmp	r5, #32
    24fa:	d1db      	bne.n	24b4 <f25519_inv__distinct+0x298>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    24fc:	7fc4      	ldrb	r4, [r0, #31]
	c = (c >> 7) * 19;
    24fe:	09db      	lsrs	r3, r3, #7
    2500:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2504:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    2508:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    250c:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    250e:	2300      	movs	r3, #0
		c += r[i];
    2510:	5cc4      	ldrb	r4, [r0, r3]
    2512:	4422      	add	r2, r4
		r[i] = c;
    2514:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2516:	3301      	adds	r3, #1
    2518:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    251a:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    251e:	d1f7      	bne.n	2510 <f25519_inv__distinct+0x2f4>
    2520:	2600      	movs	r6, #0
    2522:	4633      	mov	r3, r6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2524:	f04f 0926 	mov.w	r9, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2528:	0a1b      	lsrs	r3, r3, #8
    252a:	198c      	adds	r4, r1, r6
		for (j = 0; j <= i; j++)
    252c:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    252e:	f810 c002 	ldrb.w	ip, [r0, r2]
    2532:	f814 5901 	ldrb.w	r5, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2536:	3201      	adds	r2, #1
    2538:	42b2      	cmp	r2, r6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    253a:	fb0c 3305 	mla	r3, ip, r5, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    253e:	ddf6      	ble.n	252e <f25519_inv__distinct+0x312>
    2540:	ea26 74e6 	bic.w	r4, r6, r6, asr #31
    2544:	1c62      	adds	r2, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2546:	2a20      	cmp	r2, #32
    2548:	d00e      	beq.n	2568 <f25519_inv__distinct+0x34c>
    254a:	1b35      	subs	r5, r6, r4
    254c:	3520      	adds	r5, #32
    254e:	440d      	add	r5, r1
    2550:	4404      	add	r4, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2552:	f815 cd01 	ldrb.w	ip, [r5, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2556:	f814 8f01 	ldrb.w	r8, [r4, #1]!
    255a:	fb09 fc0c 	mul.w	ip, r9, ip

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    255e:	3201      	adds	r2, #1
    2560:	2a20      	cmp	r2, #32
			c += ((uint32_t)a[j]) *
    2562:	fb08 330c 	mla	r3, r8, ip, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2566:	d1f4      	bne.n	2552 <f25519_inv__distinct+0x336>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2568:	f80d 3006 	strb.w	r3, [sp, r6]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    256c:	3601      	adds	r6, #1
    256e:	2e20      	cmp	r6, #32
    2570:	d1da      	bne.n	2528 <f25519_inv__distinct+0x30c>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2572:	f89d 401f 	ldrb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    2576:	09db      	lsrs	r3, r3, #7
    2578:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    257c:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    2580:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2584:	f88d 401f 	strb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    2588:	ab00      	add	r3, sp, #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    258a:	781c      	ldrb	r4, [r3, #0]
    258c:	4422      	add	r2, r4
		r[i] = c;
    258e:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2592:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2594:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2598:	d1f7      	bne.n	258a <f25519_inv__distinct+0x36e>
    259a:	2500      	movs	r5, #0
    259c:	eb0d 0805 	add.w	r8, sp, r5
    25a0:	f108 091f 	add.w	r9, r8, #31
    25a4:	462b      	mov	r3, r5
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25a6:	f04f 0826 	mov.w	r8, #38	; 0x26
    25aa:	ac00      	add	r4, sp, #0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    25ac:	0a1b      	lsrs	r3, r3, #8
    25ae:	442c      	add	r4, r5
		for (j = 0; j <= i; j++)
    25b0:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25b2:	f81d c002 	ldrb.w	ip, [sp, r2]
    25b6:	f814 6901 	ldrb.w	r6, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25ba:	3201      	adds	r2, #1
    25bc:	42aa      	cmp	r2, r5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25be:	fb0c 3306 	mla	r3, ip, r6, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25c2:	ddf6      	ble.n	25b2 <f25519_inv__distinct+0x396>
    25c4:	ea25 72e5 	bic.w	r2, r5, r5, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25c8:	2a1f      	cmp	r2, #31
    25ca:	d00e      	beq.n	25ea <f25519_inv__distinct+0x3ce>
    25cc:	1aac      	subs	r4, r5, r2
    25ce:	ae00      	add	r6, sp, #0
    25d0:	3420      	adds	r4, #32
    25d2:	4434      	add	r4, r6
    25d4:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    25d6:	f814 6d01 	ldrb.w	r6, [r4, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25da:	f812 cf01 	ldrb.w	ip, [r2, #1]!
    25de:	fb08 f606 	mul.w	r6, r8, r6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25e2:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) *
    25e4:	fb0c 3306 	mla	r3, ip, r6, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25e8:	d1f5      	bne.n	25d6 <f25519_inv__distinct+0x3ba>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    25ea:	5543      	strb	r3, [r0, r5]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    25ec:	3501      	adds	r5, #1
    25ee:	2d20      	cmp	r5, #32
    25f0:	d1db      	bne.n	25aa <f25519_inv__distinct+0x38e>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25f2:	7fc4      	ldrb	r4, [r0, #31]
	c = (c >> 7) * 19;
    25f4:	09db      	lsrs	r3, r3, #7
    25f6:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25fa:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    25fe:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2602:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2604:	2300      	movs	r3, #0
		c += r[i];
    2606:	5cc4      	ldrb	r4, [r0, r3]
    2608:	4422      	add	r2, r4
		r[i] = c;
    260a:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    260c:	3301      	adds	r3, #1
    260e:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    2610:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2614:	d1f7      	bne.n	2606 <f25519_inv__distinct+0x3ea>
    2616:	2600      	movs	r6, #0
    2618:	4633      	mov	r3, r6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    261a:	f04f 0926 	mov.w	r9, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    261e:	0a1b      	lsrs	r3, r3, #8
    2620:	1984      	adds	r4, r0, r6
		for (j = 0; j <= i; j++)
    2622:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2624:	f810 c002 	ldrb.w	ip, [r0, r2]
    2628:	f814 5901 	ldrb.w	r5, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    262c:	3201      	adds	r2, #1
    262e:	42b2      	cmp	r2, r6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2630:	fb0c 3305 	mla	r3, ip, r5, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2634:	ddf6      	ble.n	2624 <f25519_inv__distinct+0x408>
    2636:	ea26 74e6 	bic.w	r4, r6, r6, asr #31
    263a:	1c62      	adds	r2, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    263c:	2a20      	cmp	r2, #32
    263e:	d00e      	beq.n	265e <f25519_inv__distinct+0x442>
    2640:	1b35      	subs	r5, r6, r4
    2642:	3520      	adds	r5, #32
    2644:	4405      	add	r5, r0
    2646:	4404      	add	r4, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2648:	f815 cd01 	ldrb.w	ip, [r5, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    264c:	f814 8f01 	ldrb.w	r8, [r4, #1]!
    2650:	fb09 fc0c 	mul.w	ip, r9, ip

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2654:	3201      	adds	r2, #1
    2656:	2a20      	cmp	r2, #32
			c += ((uint32_t)a[j]) *
    2658:	fb08 330c 	mla	r3, r8, ip, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    265c:	d1f4      	bne.n	2648 <f25519_inv__distinct+0x42c>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    265e:	f80d 3006 	strb.w	r3, [sp, r6]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2662:	3601      	adds	r6, #1
    2664:	2e20      	cmp	r6, #32
    2666:	d1da      	bne.n	261e <f25519_inv__distinct+0x402>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2668:	f89d 401f 	ldrb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    266c:	09db      	lsrs	r3, r3, #7
    266e:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2672:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    2676:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    267a:	f88d 401f 	strb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    267e:	ab00      	add	r3, sp, #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2680:	781c      	ldrb	r4, [r3, #0]
    2682:	4422      	add	r2, r4
		r[i] = c;
    2684:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2688:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    268a:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    268e:	d1f7      	bne.n	2680 <f25519_inv__distinct+0x464>
    2690:	2500      	movs	r5, #0
    2692:	eb0d 0805 	add.w	r8, sp, r5
    2696:	f108 091f 	add.w	r9, r8, #31
    269a:	462b      	mov	r3, r5
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    269c:	f04f 0826 	mov.w	r8, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    26a0:	0a1b      	lsrs	r3, r3, #8
    26a2:	194c      	adds	r4, r1, r5
		for (j = 0; j <= i; j++)
    26a4:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26a6:	f81d c002 	ldrb.w	ip, [sp, r2]
    26aa:	f814 6901 	ldrb.w	r6, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26ae:	3201      	adds	r2, #1
    26b0:	42aa      	cmp	r2, r5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26b2:	fb0c 3306 	mla	r3, ip, r6, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26b6:	ddf6      	ble.n	26a6 <f25519_inv__distinct+0x48a>
    26b8:	ea25 72e5 	bic.w	r2, r5, r5, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26bc:	2a1f      	cmp	r2, #31
    26be:	d00e      	beq.n	26de <f25519_inv__distinct+0x4c2>
    26c0:	1aac      	subs	r4, r5, r2
    26c2:	3420      	adds	r4, #32
    26c4:	ae00      	add	r6, sp, #0
    26c6:	440c      	add	r4, r1
    26c8:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    26ca:	f814 6d01 	ldrb.w	r6, [r4, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26ce:	f812 cf01 	ldrb.w	ip, [r2, #1]!
    26d2:	fb08 f606 	mul.w	r6, r8, r6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26d6:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) *
    26d8:	fb0c 3306 	mla	r3, ip, r6, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26dc:	d1f5      	bne.n	26ca <f25519_inv__distinct+0x4ae>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    26de:	5543      	strb	r3, [r0, r5]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    26e0:	3501      	adds	r5, #1
    26e2:	2d20      	cmp	r5, #32
    26e4:	d1dc      	bne.n	26a0 <f25519_inv__distinct+0x484>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26e6:	7fc4      	ldrb	r4, [r0, #31]
	c = (c >> 7) * 19;
    26e8:	09db      	lsrs	r3, r3, #7
    26ea:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26ee:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    26f2:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26f6:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    26f8:	2300      	movs	r3, #0
		c += r[i];
    26fa:	5cc4      	ldrb	r4, [r0, r3]
    26fc:	4422      	add	r2, r4
		r[i] = c;
    26fe:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2700:	3301      	adds	r3, #1
    2702:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    2704:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2708:	d1f7      	bne.n	26fa <f25519_inv__distinct+0x4de>
    270a:	2600      	movs	r6, #0
    270c:	4633      	mov	r3, r6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    270e:	f04f 0926 	mov.w	r9, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2712:	0a1b      	lsrs	r3, r3, #8
    2714:	1984      	adds	r4, r0, r6
		for (j = 0; j <= i; j++)
    2716:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2718:	f810 c002 	ldrb.w	ip, [r0, r2]
    271c:	f814 5901 	ldrb.w	r5, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2720:	3201      	adds	r2, #1
    2722:	42b2      	cmp	r2, r6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2724:	fb0c 3305 	mla	r3, ip, r5, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2728:	ddf6      	ble.n	2718 <f25519_inv__distinct+0x4fc>
    272a:	ea26 74e6 	bic.w	r4, r6, r6, asr #31
    272e:	1c62      	adds	r2, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2730:	2a20      	cmp	r2, #32
    2732:	d00e      	beq.n	2752 <f25519_inv__distinct+0x536>
    2734:	1b35      	subs	r5, r6, r4
    2736:	3520      	adds	r5, #32
    2738:	4405      	add	r5, r0
    273a:	4404      	add	r4, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    273c:	f815 cd01 	ldrb.w	ip, [r5, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2740:	f814 8f01 	ldrb.w	r8, [r4, #1]!
    2744:	fb09 fc0c 	mul.w	ip, r9, ip

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2748:	3201      	adds	r2, #1
    274a:	2a20      	cmp	r2, #32
			c += ((uint32_t)a[j]) *
    274c:	fb08 330c 	mla	r3, r8, ip, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2750:	d1f4      	bne.n	273c <f25519_inv__distinct+0x520>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2752:	f80d 3006 	strb.w	r3, [sp, r6]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2756:	3601      	adds	r6, #1
    2758:	2e20      	cmp	r6, #32
    275a:	d1da      	bne.n	2712 <f25519_inv__distinct+0x4f6>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    275c:	f89d 401f 	ldrb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    2760:	09db      	lsrs	r3, r3, #7
    2762:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2766:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    276a:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    276e:	f88d 401f 	strb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    2772:	ab00      	add	r3, sp, #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2774:	781c      	ldrb	r4, [r3, #0]
    2776:	4422      	add	r2, r4
		r[i] = c;
    2778:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    277c:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    277e:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2782:	d1f7      	bne.n	2774 <f25519_inv__distinct+0x558>
    2784:	2500      	movs	r5, #0
    2786:	eb0d 0205 	add.w	r2, sp, r5
    278a:	462b      	mov	r3, r5
    278c:	f102 081f 	add.w	r8, r2, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2790:	f04f 0c26 	mov.w	ip, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2794:	0a1b      	lsrs	r3, r3, #8
    2796:	194c      	adds	r4, r1, r5
		for (j = 0; j <= i; j++)
    2798:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    279a:	f81d 7002 	ldrb.w	r7, [sp, r2]
    279e:	f814 6901 	ldrb.w	r6, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27a2:	3201      	adds	r2, #1
    27a4:	42aa      	cmp	r2, r5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27a6:	fb07 3306 	mla	r3, r7, r6, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27aa:	ddf6      	ble.n	279a <f25519_inv__distinct+0x57e>
    27ac:	ea25 72e5 	bic.w	r2, r5, r5, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27b0:	2a1f      	cmp	r2, #31
    27b2:	d00e      	beq.n	27d2 <f25519_inv__distinct+0x5b6>
    27b4:	1aac      	subs	r4, r5, r2
    27b6:	3420      	adds	r4, #32
    27b8:	ae00      	add	r6, sp, #0
    27ba:	440c      	add	r4, r1
    27bc:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    27be:	f814 6d01 	ldrb.w	r6, [r4, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27c2:	f812 7f01 	ldrb.w	r7, [r2, #1]!
    27c6:	fb0c f606 	mul.w	r6, ip, r6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27ca:	4542      	cmp	r2, r8
			c += ((uint32_t)a[j]) *
    27cc:	fb07 3306 	mla	r3, r7, r6, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27d0:	d1f5      	bne.n	27be <f25519_inv__distinct+0x5a2>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    27d2:	5543      	strb	r3, [r0, r5]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    27d4:	3501      	adds	r5, #1
    27d6:	2d20      	cmp	r5, #32
    27d8:	d1dc      	bne.n	2794 <f25519_inv__distinct+0x578>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    27da:	7fc1      	ldrb	r1, [r0, #31]
	c = (c >> 7) * 19;
    27dc:	09db      	lsrs	r3, r3, #7
    27de:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    27e2:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    27e6:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    27ea:	77c1      	strb	r1, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27ec:	2300      	movs	r3, #0
		c += r[i];
    27ee:	5cc1      	ldrb	r1, [r0, r3]
    27f0:	440a      	add	r2, r1
		r[i] = c;
    27f2:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27f4:	3301      	adds	r3, #1
    27f6:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    27f8:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27fc:	d1f7      	bne.n	27ee <f25519_inv__distinct+0x5d2>
	f25519_mul__distinct(r, s, x);

	/* 1 */
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}
    27fe:	b008      	add	sp, #32
    2800:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    2804:	4770      	bx	lr
    2806:	bf00      	nop

00002808 <f25519_sqrt>:
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    2808:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    280c:	2300      	movs	r3, #0
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    280e:	b0a4      	sub	sp, #144	; 0x90
    2810:	9002      	str	r0, [sp, #8]
    2812:	9103      	str	r1, [sp, #12]
	f25519_copy(r, tmp);
}

void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
    2814:	461a      	mov	r2, r3
    2816:	ae14      	add	r6, sp, #80	; 0x50
    2818:	4608      	mov	r0, r1
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += b * ((uint32_t)a[i]);
    281a:	5cc1      	ldrb	r1, [r0, r3]
    281c:	0049      	lsls	r1, r1, #1
    281e:	eb01 2212 	add.w	r2, r1, r2, lsr #8
		r[i] = c;
    2822:	54f2      	strb	r2, [r6, r3]
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2824:	3301      	adds	r3, #1
    2826:	2b20      	cmp	r3, #32
    2828:	d1f7      	bne.n	281a <f25519_sqrt+0x12>
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    282a:	f89d 306f 	ldrb.w	r3, [sp, #111]	; 0x6f
	c >>= 7;
    282e:	09d2      	lsrs	r2, r2, #7
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    2830:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	c >>= 7;
	c *= 19;
    2834:	eb02 01c2 	add.w	r1, r2, r2, lsl #3
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    2838:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
	c >>= 7;
	c *= 19;
    283c:	eb02 0241 	add.w	r2, r2, r1, lsl #1
    2840:	a81c      	add	r0, sp, #112	; 0x70
    2842:	4633      	mov	r3, r6

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2844:	7819      	ldrb	r1, [r3, #0]
    2846:	440a      	add	r2, r1
		r[i] = c;
    2848:	f803 2b01 	strb.w	r2, [r3], #1

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    284c:	4283      	cmp	r3, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    284e:	ea4f 2212 	mov.w	r2, r2, lsr #8

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2852:	d1f7      	bne.n	2844 <f25519_sqrt+0x3c>
    2854:	2400      	movs	r4, #0
    2856:	4623      	mov	r3, r4
    2858:	f106 0c1f 	add.w	ip, r6, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    285c:	2726      	movs	r7, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    285e:	0a1b      	lsrs	r3, r3, #8
    2860:	1931      	adds	r1, r6, r4
		for (j = 0; j <= i; j++)
    2862:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2864:	f816 8002 	ldrb.w	r8, [r6, r2]
    2868:	f811 5901 	ldrb.w	r5, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    286c:	3201      	adds	r2, #1
    286e:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2870:	fb08 3305 	mla	r3, r8, r5, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2874:	ddf6      	ble.n	2864 <f25519_sqrt+0x5c>
    2876:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    287a:	2a1f      	cmp	r2, #31
    287c:	d00d      	beq.n	289a <f25519_sqrt+0x92>
    287e:	1aa1      	subs	r1, r4, r2
    2880:	3120      	adds	r1, #32
    2882:	4431      	add	r1, r6
    2884:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2886:	f811 5d01 	ldrb.w	r5, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    288a:	f812 8f01 	ldrb.w	r8, [r2, #1]!
    288e:	fb07 f505 	mul.w	r5, r7, r5

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2892:	4562      	cmp	r2, ip
			c += ((uint32_t)a[j]) *
    2894:	fb08 3305 	mla	r3, r8, r5, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2898:	d1f5      	bne.n	2886 <f25519_sqrt+0x7e>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    289a:	a904      	add	r1, sp, #16
    289c:	550b      	strb	r3, [r1, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    289e:	3401      	adds	r4, #1
    28a0:	2c20      	cmp	r4, #32
    28a2:	d1dc      	bne.n	285e <f25519_sqrt+0x56>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28a4:	f89d 102f 	ldrb.w	r1, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    28a8:	09db      	lsrs	r3, r3, #7
    28aa:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28ae:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    28b2:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28b6:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
    28ba:	af0c      	add	r7, sp, #48	; 0x30
	c = (c >> 7) * 19;
    28bc:	ab04      	add	r3, sp, #16

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    28be:	7819      	ldrb	r1, [r3, #0]
    28c0:	440a      	add	r2, r1
		r[i] = c;
    28c2:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28c6:	42bb      	cmp	r3, r7
		c += r[i];
		r[i] = c;
		c >>= 8;
    28c8:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28cc:	d1f7      	bne.n	28be <f25519_sqrt+0xb6>
    28ce:	2400      	movs	r4, #0
    28d0:	4623      	mov	r3, r4
    28d2:	f10d 0c2f 	add.w	ip, sp, #47	; 0x2f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    28d6:	2526      	movs	r5, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    28d8:	0a1b      	lsrs	r3, r3, #8
    28da:	1931      	adds	r1, r6, r4
		for (j = 0; j <= i; j++)
    28dc:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    28de:	f10d 0a10 	add.w	sl, sp, #16
    28e2:	f81a 9002 	ldrb.w	r9, [sl, r2]
    28e6:	f811 8901 	ldrb.w	r8, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    28ea:	3201      	adds	r2, #1
    28ec:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    28ee:	fb09 3308 	mla	r3, r9, r8, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    28f2:	ddf4      	ble.n	28de <f25519_sqrt+0xd6>
    28f4:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    28f8:	2a1f      	cmp	r2, #31
    28fa:	d00d      	beq.n	2918 <f25519_sqrt+0x110>
    28fc:	1aa1      	subs	r1, r4, r2
    28fe:	3120      	adds	r1, #32
    2900:	4431      	add	r1, r6
    2902:	4452      	add	r2, sl
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2904:	f811 8d01 	ldrb.w	r8, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2908:	f812 9f01 	ldrb.w	r9, [r2, #1]!
    290c:	fb05 f808 	mul.w	r8, r5, r8

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2910:	4562      	cmp	r2, ip
			c += ((uint32_t)a[j]) *
    2912:	fb09 3308 	mla	r3, r9, r8, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2916:	d1f5      	bne.n	2904 <f25519_sqrt+0xfc>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2918:	5503      	strb	r3, [r0, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    291a:	3401      	adds	r4, #1
    291c:	2c20      	cmp	r4, #32
    291e:	d1db      	bne.n	28d8 <f25519_sqrt+0xd0>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2920:	f89d 108f 	ldrb.w	r1, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2924:	09db      	lsrs	r3, r3, #7
    2926:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    292a:	f10d 0b90 	add.w	fp, sp, #144	; 0x90
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    292e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    2932:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2936:	f88d 108f 	strb.w	r1, [sp, #143]	; 0x8f
    293a:	f8cd b000 	str.w	fp, [sp]
	c = (c >> 7) * 19;
    293e:	4603      	mov	r3, r0
    2940:	46dc      	mov	ip, fp

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2942:	7819      	ldrb	r1, [r3, #0]
    2944:	440a      	add	r2, r1
		r[i] = c;
    2946:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    294a:	4563      	cmp	r3, ip
		c += r[i];
		r[i] = c;
		c >>= 8;
    294c:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2950:	d1f7      	bne.n	2942 <f25519_sqrt+0x13a>
    2952:	21f8      	movs	r1, #248	; 0xf8
    2954:	9101      	str	r1, [sp, #4]
    2956:	f100 051f 	add.w	r5, r0, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    295a:	2126      	movs	r1, #38	; 0x26
    295c:	f10d 042f 	add.w	r4, sp, #47	; 0x2f

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2960:	f04f 0900 	mov.w	r9, #0
    2964:	464b      	mov	r3, r9
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2966:	0a1b      	lsrs	r3, r3, #8
    2968:	eb00 0809 	add.w	r8, r0, r9
		for (j = 0; j <= i; j++)
    296c:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    296e:	f810 b002 	ldrb.w	fp, [r0, r2]
    2972:	f818 a901 	ldrb.w	sl, [r8], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2976:	3201      	adds	r2, #1
    2978:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    297a:	fb0b 330a 	mla	r3, fp, sl, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    297e:	ddf6      	ble.n	296e <f25519_sqrt+0x166>
    2980:	ea29 72e9 	bic.w	r2, r9, r9, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2984:	2a1f      	cmp	r2, #31
    2986:	d00f      	beq.n	29a8 <f25519_sqrt+0x1a0>
    2988:	ebc2 0809 	rsb	r8, r2, r9
    298c:	f108 0820 	add.w	r8, r8, #32
    2990:	4480      	add	r8, r0
    2992:	4402      	add	r2, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2994:	f818 ad01 	ldrb.w	sl, [r8, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2998:	f812 bf01 	ldrb.w	fp, [r2, #1]!
    299c:	fb01 fa0a 	mul.w	sl, r1, sl

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29a0:	42aa      	cmp	r2, r5
			c += ((uint32_t)a[j]) *
    29a2:	fb0b 330a 	mla	r3, fp, sl, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29a6:	d1f5      	bne.n	2994 <f25519_sqrt+0x18c>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    29a8:	f10d 0810 	add.w	r8, sp, #16
    29ac:	f808 3009 	strb.w	r3, [r8, r9]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    29b0:	f109 0901 	add.w	r9, r9, #1
    29b4:	f1b9 0f20 	cmp.w	r9, #32
    29b8:	d1d5      	bne.n	2966 <f25519_sqrt+0x15e>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29ba:	f89d 802f 	ldrb.w	r8, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    29be:	09db      	lsrs	r3, r3, #7
    29c0:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29c4:	f008 087f 	and.w	r8, r8, #127	; 0x7f
	c = (c >> 7) * 19;
    29c8:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29cc:	f88d 802f 	strb.w	r8, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    29d0:	ab04      	add	r3, sp, #16

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    29d2:	f893 8000 	ldrb.w	r8, [r3]
    29d6:	4442      	add	r2, r8
		r[i] = c;
    29d8:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    29dc:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    29de:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    29e2:	d1f6      	bne.n	29d2 <f25519_sqrt+0x1ca>
    29e4:	f04f 0900 	mov.w	r9, #0
    29e8:	464b      	mov	r3, r9
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    29ea:	0a1b      	lsrs	r3, r3, #8
    29ec:	eb06 0809 	add.w	r8, r6, r9
		for (j = 0; j <= i; j++)
    29f0:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    29f2:	f10d 0c10 	add.w	ip, sp, #16
    29f6:	f81c b002 	ldrb.w	fp, [ip, r2]
    29fa:	f818 a901 	ldrb.w	sl, [r8], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    29fe:	3201      	adds	r2, #1
    2a00:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a02:	fb0b 330a 	mla	r3, fp, sl, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a06:	ddf4      	ble.n	29f2 <f25519_sqrt+0x1ea>
    2a08:	ea29 72e9 	bic.w	r2, r9, r9, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a0c:	2a1f      	cmp	r2, #31
    2a0e:	d00f      	beq.n	2a30 <f25519_sqrt+0x228>
    2a10:	ebc2 0809 	rsb	r8, r2, r9
    2a14:	f108 0820 	add.w	r8, r8, #32
    2a18:	44b0      	add	r8, r6
    2a1a:	4462      	add	r2, ip
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2a1c:	f818 ad01 	ldrb.w	sl, [r8, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a20:	f812 bf01 	ldrb.w	fp, [r2, #1]!
    2a24:	fb01 fa0a 	mul.w	sl, r1, sl

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a28:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) *
    2a2a:	fb0b 330a 	mla	r3, fp, sl, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a2e:	d1f5      	bne.n	2a1c <f25519_sqrt+0x214>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2a30:	f800 3009 	strb.w	r3, [r0, r9]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2a34:	f109 0901 	add.w	r9, r9, #1
    2a38:	f1b9 0f20 	cmp.w	r9, #32
    2a3c:	d1d5      	bne.n	29ea <f25519_sqrt+0x1e2>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a3e:	f89d 808f 	ldrb.w	r8, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2a42:	09db      	lsrs	r3, r3, #7
    2a44:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a48:	f008 087f 	and.w	r8, r8, #127	; 0x7f
	c = (c >> 7) * 19;
    2a4c:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a50:	f88d 808f 	strb.w	r8, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2a54:	4603      	mov	r3, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2a56:	f893 8000 	ldrb.w	r8, [r3]
    2a5a:	4442      	add	r2, r8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a5c:	f8dd 8000 	ldr.w	r8, [sp]
		c += r[i];
		r[i] = c;
    2a60:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a64:	4598      	cmp	r8, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2a66:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a6a:	d1f4      	bne.n	2a56 <f25519_sqrt+0x24e>
	/* 1 1 */
	f25519_mul__distinct(r, x, x);
	f25519_mul__distinct(s, r, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    2a6c:	9a01      	ldr	r2, [sp, #4]
    2a6e:	3a01      	subs	r2, #1
    2a70:	9201      	str	r2, [sp, #4]
    2a72:	f47f af75 	bne.w	2960 <f25519_sqrt+0x158>
    2a76:	4614      	mov	r4, r2
    2a78:	4613      	mov	r3, r2
    2a7a:	f100 081f 	add.w	r8, r0, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a7e:	2526      	movs	r5, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2a80:	0a1b      	lsrs	r3, r3, #8
    2a82:	1901      	adds	r1, r0, r4
		for (j = 0; j <= i; j++)
    2a84:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a86:	f810 a002 	ldrb.w	sl, [r0, r2]
    2a8a:	f811 9901 	ldrb.w	r9, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a8e:	3201      	adds	r2, #1
    2a90:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a92:	fb0a 3309 	mla	r3, sl, r9, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a96:	ddf6      	ble.n	2a86 <f25519_sqrt+0x27e>
    2a98:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a9c:	2a1f      	cmp	r2, #31
    2a9e:	d00d      	beq.n	2abc <f25519_sqrt+0x2b4>
    2aa0:	1aa1      	subs	r1, r4, r2
    2aa2:	3120      	adds	r1, #32
    2aa4:	4401      	add	r1, r0
    2aa6:	4402      	add	r2, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2aa8:	f811 9d01 	ldrb.w	r9, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2aac:	f812 af01 	ldrb.w	sl, [r2, #1]!
    2ab0:	fb05 f909 	mul.w	r9, r5, r9

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ab4:	4542      	cmp	r2, r8
			c += ((uint32_t)a[j]) *
    2ab6:	fb0a 3309 	mla	r3, sl, r9, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2aba:	d1f5      	bne.n	2aa8 <f25519_sqrt+0x2a0>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2abc:	f10d 0a10 	add.w	sl, sp, #16
    2ac0:	f80a 3004 	strb.w	r3, [sl, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2ac4:	3401      	adds	r4, #1
    2ac6:	2c20      	cmp	r4, #32
    2ac8:	d1da      	bne.n	2a80 <f25519_sqrt+0x278>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2aca:	f89d 102f 	ldrb.w	r1, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    2ace:	09db      	lsrs	r3, r3, #7
    2ad0:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2ad4:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    2ad8:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2adc:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    2ae0:	4653      	mov	r3, sl

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2ae2:	7819      	ldrb	r1, [r3, #0]
    2ae4:	440a      	add	r2, r1
		r[i] = c;
    2ae6:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2aea:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2aec:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2af0:	d1f7      	bne.n	2ae2 <f25519_sqrt+0x2da>
    2af2:	2400      	movs	r4, #0
    2af4:	4623      	mov	r3, r4
    2af6:	f10d 082f 	add.w	r8, sp, #47	; 0x2f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2afa:	2526      	movs	r5, #38	; 0x26
    2afc:	a904      	add	r1, sp, #16
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2afe:	0a1b      	lsrs	r3, r3, #8
    2b00:	4421      	add	r1, r4
		for (j = 0; j <= i; j++)
    2b02:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b04:	f10d 0c10 	add.w	ip, sp, #16
    2b08:	f81c a002 	ldrb.w	sl, [ip, r2]
    2b0c:	f811 9901 	ldrb.w	r9, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b10:	3201      	adds	r2, #1
    2b12:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b14:	fb0a 3309 	mla	r3, sl, r9, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b18:	ddf4      	ble.n	2b04 <f25519_sqrt+0x2fc>
    2b1a:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b1e:	2a1f      	cmp	r2, #31
    2b20:	d00d      	beq.n	2b3e <f25519_sqrt+0x336>
    2b22:	1aa1      	subs	r1, r4, r2
    2b24:	3120      	adds	r1, #32
    2b26:	4461      	add	r1, ip
    2b28:	4462      	add	r2, ip
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2b2a:	f811 9d01 	ldrb.w	r9, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b2e:	f812 af01 	ldrb.w	sl, [r2, #1]!
    2b32:	fb05 f909 	mul.w	r9, r5, r9

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b36:	4542      	cmp	r2, r8
			c += ((uint32_t)a[j]) *
    2b38:	fb0a 3309 	mla	r3, sl, r9, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b3c:	d1f5      	bne.n	2b2a <f25519_sqrt+0x322>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2b3e:	5503      	strb	r3, [r0, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2b40:	3401      	adds	r4, #1
    2b42:	2c20      	cmp	r4, #32
    2b44:	d1da      	bne.n	2afc <f25519_sqrt+0x2f4>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b46:	f89d 108f 	ldrb.w	r1, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2b4a:	09db      	lsrs	r3, r3, #7
    2b4c:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b50:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    2b54:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b58:	f88d 108f 	strb.w	r1, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2b5c:	4603      	mov	r3, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2b5e:	7819      	ldrb	r1, [r3, #0]
    2b60:	440a      	add	r2, r1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b62:	9900      	ldr	r1, [sp, #0]
		c += r[i];
		r[i] = c;
    2b64:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b68:	4299      	cmp	r1, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2b6a:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b6e:	d1f6      	bne.n	2b5e <f25519_sqrt+0x356>
    2b70:	2400      	movs	r4, #0
    2b72:	4623      	mov	r3, r4
    2b74:	f100 081f 	add.w	r8, r0, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b78:	2526      	movs	r5, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2b7a:	0a1b      	lsrs	r3, r3, #8
    2b7c:	1931      	adds	r1, r6, r4
		for (j = 0; j <= i; j++)
    2b7e:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b80:	f810 a002 	ldrb.w	sl, [r0, r2]
    2b84:	f811 9901 	ldrb.w	r9, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b88:	3201      	adds	r2, #1
    2b8a:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b8c:	fb0a 3309 	mla	r3, sl, r9, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b90:	ddf6      	ble.n	2b80 <f25519_sqrt+0x378>
    2b92:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b96:	2a1f      	cmp	r2, #31
    2b98:	d00d      	beq.n	2bb6 <f25519_sqrt+0x3ae>
    2b9a:	1aa1      	subs	r1, r4, r2
    2b9c:	3120      	adds	r1, #32
    2b9e:	4431      	add	r1, r6
    2ba0:	4402      	add	r2, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2ba2:	f811 9d01 	ldrb.w	r9, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ba6:	f812 af01 	ldrb.w	sl, [r2, #1]!
    2baa:	fb05 f909 	mul.w	r9, r5, r9

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2bae:	4542      	cmp	r2, r8
			c += ((uint32_t)a[j]) *
    2bb0:	fb0a 3309 	mla	r3, sl, r9, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2bb4:	d1f5      	bne.n	2ba2 <f25519_sqrt+0x39a>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2bb6:	aa04      	add	r2, sp, #16
    2bb8:	5513      	strb	r3, [r2, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2bba:	3401      	adds	r4, #1
    2bbc:	2c20      	cmp	r4, #32
    2bbe:	d1dc      	bne.n	2b7a <f25519_sqrt+0x372>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bc0:	f89d 102f 	ldrb.w	r1, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    2bc4:	09db      	lsrs	r3, r3, #7
    2bc6:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bca:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    2bce:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bd2:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    2bd6:	ab04      	add	r3, sp, #16

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2bd8:	7819      	ldrb	r1, [r3, #0]
    2bda:	440a      	add	r2, r1
		r[i] = c;
    2bdc:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2be0:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2be2:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2be6:	d1f7      	bne.n	2bd8 <f25519_sqrt+0x3d0>
    2be8:	2400      	movs	r4, #0
    2bea:	4623      	mov	r3, r4
    2bec:	f10d 082f 	add.w	r8, sp, #47	; 0x2f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2bf0:	2526      	movs	r5, #38	; 0x26
    2bf2:	a904      	add	r1, sp, #16
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2bf4:	0a1b      	lsrs	r3, r3, #8
    2bf6:	4421      	add	r1, r4
		for (j = 0; j <= i; j++)
    2bf8:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2bfa:	f10d 0b10 	add.w	fp, sp, #16
    2bfe:	f81b a002 	ldrb.w	sl, [fp, r2]
    2c02:	f811 9901 	ldrb.w	r9, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c06:	3201      	adds	r2, #1
    2c08:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c0a:	fb0a 3309 	mla	r3, sl, r9, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c0e:	ddf4      	ble.n	2bfa <f25519_sqrt+0x3f2>
    2c10:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c14:	2a1f      	cmp	r2, #31
    2c16:	d00d      	beq.n	2c34 <f25519_sqrt+0x42c>
    2c18:	1aa1      	subs	r1, r4, r2
    2c1a:	3120      	adds	r1, #32
    2c1c:	4459      	add	r1, fp
    2c1e:	445a      	add	r2, fp
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2c20:	f811 9d01 	ldrb.w	r9, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c24:	f812 af01 	ldrb.w	sl, [r2, #1]!
    2c28:	fb05 f909 	mul.w	r9, r5, r9

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c2c:	4542      	cmp	r2, r8
			c += ((uint32_t)a[j]) *
    2c2e:	fb0a 3309 	mla	r3, sl, r9, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c32:	d1f5      	bne.n	2c20 <f25519_sqrt+0x418>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2c34:	5503      	strb	r3, [r0, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2c36:	3401      	adds	r4, #1
    2c38:	2c20      	cmp	r4, #32
    2c3a:	d1da      	bne.n	2bf2 <f25519_sqrt+0x3ea>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c3c:	f89d 108f 	ldrb.w	r1, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2c40:	09db      	lsrs	r3, r3, #7
    2c42:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c46:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    2c4a:	f8dd c000 	ldr.w	ip, [sp]
	c = (c >> 7) * 19;
    2c4e:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c52:	f88d 108f 	strb.w	r1, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2c56:	4603      	mov	r3, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2c58:	7819      	ldrb	r1, [r3, #0]
    2c5a:	440a      	add	r2, r1
		r[i] = c;
    2c5c:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c60:	459c      	cmp	ip, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2c62:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c66:	d1f7      	bne.n	2c58 <f25519_sqrt+0x450>
    2c68:	2400      	movs	r4, #0
    2c6a:	4623      	mov	r3, r4
    2c6c:	f106 0c1f 	add.w	ip, r6, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c70:	2526      	movs	r5, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2c72:	0a1b      	lsrs	r3, r3, #8
    2c74:	1901      	adds	r1, r0, r4
		for (j = 0; j <= i; j++)
    2c76:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c78:	f816 9002 	ldrb.w	r9, [r6, r2]
    2c7c:	f811 8901 	ldrb.w	r8, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c80:	3201      	adds	r2, #1
    2c82:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c84:	fb09 3308 	mla	r3, r9, r8, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c88:	ddf6      	ble.n	2c78 <f25519_sqrt+0x470>
    2c8a:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c8e:	2a1f      	cmp	r2, #31
    2c90:	d00d      	beq.n	2cae <f25519_sqrt+0x4a6>
    2c92:	1aa1      	subs	r1, r4, r2
    2c94:	3120      	adds	r1, #32
    2c96:	4401      	add	r1, r0
    2c98:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2c9a:	f811 8d01 	ldrb.w	r8, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c9e:	f812 9f01 	ldrb.w	r9, [r2, #1]!
    2ca2:	fb05 f808 	mul.w	r8, r5, r8

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ca6:	4562      	cmp	r2, ip
			c += ((uint32_t)a[j]) *
    2ca8:	fb09 3308 	mla	r3, r9, r8, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cac:	d1f5      	bne.n	2c9a <f25519_sqrt+0x492>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2cae:	553b      	strb	r3, [r7, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2cb0:	3401      	adds	r4, #1
    2cb2:	2c20      	cmp	r4, #32
    2cb4:	d1dd      	bne.n	2c72 <f25519_sqrt+0x46a>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cb6:	f89d 104f 	ldrb.w	r1, [sp, #79]	; 0x4f
	c = (c >> 7) * 19;
    2cba:	09db      	lsrs	r3, r3, #7
    2cbc:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cc0:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    2cc4:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cc8:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
	c = (c >> 7) * 19;
    2ccc:	463b      	mov	r3, r7

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2cce:	7819      	ldrb	r1, [r3, #0]
    2cd0:	440a      	add	r2, r1
		r[i] = c;
    2cd2:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2cd6:	42b3      	cmp	r3, r6
		c += r[i];
		r[i] = c;
		c >>= 8;
    2cd8:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2cdc:	d1f7      	bne.n	2cce <f25519_sqrt+0x4c6>
    2cde:	2300      	movs	r3, #0
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    2ce0:	2201      	movs	r2, #1
    2ce2:	921c      	str	r2, [sp, #112]	; 0x70
    2ce4:	931d      	str	r3, [sp, #116]	; 0x74
    2ce6:	931e      	str	r3, [sp, #120]	; 0x78
    2ce8:	931f      	str	r3, [sp, #124]	; 0x7c
    2cea:	9320      	str	r3, [sp, #128]	; 0x80
    2cec:	9321      	str	r3, [sp, #132]	; 0x84
    2cee:	9322      	str	r3, [sp, #136]	; 0x88
    2cf0:	9323      	str	r3, [sp, #140]	; 0x8c
    2cf2:	22da      	movs	r2, #218	; 0xda
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2cf4:	5cfc      	ldrb	r4, [r7, r3]
    2cf6:	5cc1      	ldrb	r1, [r0, r3]
    2cf8:	f504 447f 	add.w	r4, r4, #65280	; 0xff00
    2cfc:	1a61      	subs	r1, r4, r1
    2cfe:	440a      	add	r2, r1
		r[i] = c;
    2d00:	54fa      	strb	r2, [r7, r3]
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2d02:	3301      	adds	r3, #1
    2d04:	2b1f      	cmp	r3, #31
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2d06:	ea4f 2212 	mov.w	r2, r2, lsr #8
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2d0a:	d1f3      	bne.n	2cf4 <f25519_sqrt+0x4ec>
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2d0c:	f89d 404f 	ldrb.w	r4, [sp, #79]	; 0x4f
    2d10:	f89d 108f 	ldrb.w	r1, [sp, #143]	; 0x8f
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2d14:	463b      	mov	r3, r7
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2d16:	1a61      	subs	r1, r4, r1
    2d18:	4411      	add	r1, r2
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2d1a:	09ca      	lsrs	r2, r1, #7
    2d1c:	eb02 04c2 	add.w	r4, r2, r2, lsl #3
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2d20:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    2d24:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
	c = (c >> 7) * 19;
    2d28:	eb02 0244 	add.w	r2, r2, r4, lsl #1

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2d2c:	7819      	ldrb	r1, [r3, #0]
    2d2e:	440a      	add	r2, r1
		r[i] = c;
    2d30:	f803 2b01 	strb.w	r2, [r3], #1

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d34:	429e      	cmp	r6, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2d36:	ea4f 2212 	mov.w	r2, r2, lsr #8

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d3a:	d1f7      	bne.n	2d2c <f25519_sqrt+0x524>
    2d3c:	2400      	movs	r4, #0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d3e:	f8dd 900c 	ldr.w	r9, [sp, #12]

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d42:	4623      	mov	r3, r4
    2d44:	f10d 0c2f 	add.w	ip, sp, #47	; 0x2f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d48:	2526      	movs	r5, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2d4a:	0a1b      	lsrs	r3, r3, #8
    2d4c:	eb09 0104 	add.w	r1, r9, r4
		for (j = 0; j <= i; j++)
    2d50:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d52:	f10d 0b10 	add.w	fp, sp, #16
    2d56:	f81b a002 	ldrb.w	sl, [fp, r2]
    2d5a:	f811 8901 	ldrb.w	r8, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d5e:	3201      	adds	r2, #1
    2d60:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d62:	fb0a 3308 	mla	r3, sl, r8, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d66:	ddf4      	ble.n	2d52 <f25519_sqrt+0x54a>
    2d68:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d6c:	2a1f      	cmp	r2, #31
    2d6e:	d00d      	beq.n	2d8c <f25519_sqrt+0x584>
    2d70:	1aa1      	subs	r1, r4, r2
    2d72:	3120      	adds	r1, #32
    2d74:	4449      	add	r1, r9
    2d76:	445a      	add	r2, fp
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2d78:	f811 8d01 	ldrb.w	r8, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d7c:	f812 af01 	ldrb.w	sl, [r2, #1]!
    2d80:	fb05 f808 	mul.w	r8, r5, r8

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d84:	4562      	cmp	r2, ip
			c += ((uint32_t)a[j]) *
    2d86:	fb0a 3308 	mla	r3, sl, r8, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d8a:	d1f5      	bne.n	2d78 <f25519_sqrt+0x570>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2d8c:	5533      	strb	r3, [r6, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2d8e:	3401      	adds	r4, #1
    2d90:	2c20      	cmp	r4, #32
    2d92:	d1da      	bne.n	2d4a <f25519_sqrt+0x542>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d94:	f89d 106f 	ldrb.w	r1, [sp, #111]	; 0x6f
	c = (c >> 7) * 19;
    2d98:	09db      	lsrs	r3, r3, #7
    2d9a:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d9e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    2da2:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2da6:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
	c = (c >> 7) * 19;
    2daa:	4633      	mov	r3, r6

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2dac:	7819      	ldrb	r1, [r3, #0]
    2dae:	440a      	add	r2, r1
		r[i] = c;
    2db0:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2db4:	4298      	cmp	r0, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2db6:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2dba:	d1f7      	bne.n	2dac <f25519_sqrt+0x5a4>
    2dbc:	2000      	movs	r0, #0
    2dbe:	4603      	mov	r3, r0
    2dc0:	f106 081f 	add.w	r8, r6, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2dc4:	f04f 0c26 	mov.w	ip, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2dc8:	0a1b      	lsrs	r3, r3, #8
    2dca:	1839      	adds	r1, r7, r0
		for (j = 0; j <= i; j++)
    2dcc:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2dce:	5cb5      	ldrb	r5, [r6, r2]
    2dd0:	f811 4901 	ldrb.w	r4, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2dd4:	3201      	adds	r2, #1
    2dd6:	4282      	cmp	r2, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2dd8:	fb05 3304 	mla	r3, r5, r4, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2ddc:	ddf7      	ble.n	2dce <f25519_sqrt+0x5c6>
    2dde:	ea20 72e0 	bic.w	r2, r0, r0, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2de2:	2a1f      	cmp	r2, #31
    2de4:	d00d      	beq.n	2e02 <f25519_sqrt+0x5fa>
    2de6:	1a81      	subs	r1, r0, r2
    2de8:	3120      	adds	r1, #32
    2dea:	4439      	add	r1, r7
    2dec:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2dee:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2df2:	f812 5f01 	ldrb.w	r5, [r2, #1]!
    2df6:	fb0c f404 	mul.w	r4, ip, r4

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2dfa:	4542      	cmp	r2, r8
			c += ((uint32_t)a[j]) *
    2dfc:	fb05 3304 	mla	r3, r5, r4, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e00:	d1f5      	bne.n	2dee <f25519_sqrt+0x5e6>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2e02:	9a02      	ldr	r2, [sp, #8]
    2e04:	5413      	strb	r3, [r2, r0]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2e06:	3001      	adds	r0, #1
    2e08:	2820      	cmp	r0, #32
    2e0a:	d1dd      	bne.n	2dc8 <f25519_sqrt+0x5c0>

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2e0c:	09db      	lsrs	r3, r3, #7
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e0e:	7fd1      	ldrb	r1, [r2, #31]
	c = (c >> 7) * 19;
    2e10:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    2e14:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e18:	9b02      	ldr	r3, [sp, #8]
    2e1a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    2e1e:	77d9      	strb	r1, [r3, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e20:	9902      	ldr	r1, [sp, #8]
    2e22:	2300      	movs	r3, #0
		c += r[i];
    2e24:	5cc8      	ldrb	r0, [r1, r3]
    2e26:	4402      	add	r2, r0
		r[i] = c;
    2e28:	54ca      	strb	r2, [r1, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e2a:	3301      	adds	r3, #1
    2e2c:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    2e2e:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e32:	d1f7      	bne.n	2e24 <f25519_sqrt+0x61c>
	f25519_sub(i, i, y);

	/* r = avi */
	f25519_mul__distinct(x, v, a);
	f25519_mul__distinct(r, x, i);
}
    2e34:	b024      	add	sp, #144	; 0x90
    2e36:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    2e3a:	4770      	bx	lr

00002e3c <fprime_from_bytes>:
}

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
    2e3c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2e40:	4691      	mov	r9, r2
    2e42:	b08b      	sub	sp, #44	; 0x2c
    2e44:	4604      	mov	r4, r0
    2e46:	460f      	mov	r7, r1
    2e48:	461d      	mov	r5, r3
static int prime_msb(const uint8_t *p)
{
	int i;
	uint8_t x;

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
    2e4a:	221f      	movs	r2, #31
    2e4c:	e003      	b.n	2e56 <fprime_from_bytes+0x1a>
    2e4e:	f112 32ff 	adds.w	r2, r2, #4294967295
    2e52:	f0c0 80b3 	bcc.w	2fbc <fprime_from_bytes+0x180>
		if (p[i])
    2e56:	5cab      	ldrb	r3, [r5, r2]
    2e58:	2b00      	cmp	r3, #0
    2e5a:	d0f8      	beq.n	2e4e <fprime_from_bytes+0x12>
			break;

	x = p[i];
	i <<= 3;
    2e5c:	00d2      	lsls	r2, r2, #3

	while (x) {
    2e5e:	085b      	lsrs	r3, r3, #1
		x >>= 1;
		i++;
    2e60:	f102 0201 	add.w	r2, r2, #1
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    2e64:	d1fb      	bne.n	2e5e <fprime_from_bytes+0x22>
    2e66:	3a02      	subs	r2, #2

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
    2e68:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
		x[i] = 0;
}

static inline int min_int(int a, int b)
{
	return a < b ? a : b;
    2e6c:	4552      	cmp	r2, sl
    2e6e:	bfb4      	ite	lt
    2e70:	4616      	movlt	r6, r2
    2e72:	4656      	movge	r6, sl
void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
    2e74:	ea4f 08e6 	mov.w	r8, r6, asr #3
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);
    2e78:	4620      	mov	r0, r4
    2e7a:	2100      	movs	r1, #0
    2e7c:	2220      	movs	r2, #32
    2e7e:	f003 fc56 	bl	672e <memset>

	for (i = 0; i < preload_bytes; i++)
    2e82:	f1b8 0f00 	cmp.w	r8, #0
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
    2e86:	ebc6 0a0a 	rsb	sl, r6, sl
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
    2e8a:	f006 0607 	and.w	r6, r6, #7
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2e8e:	dd42      	ble.n	2f16 <fprime_from_bytes+0xda>
    2e90:	ebc8 0c09 	rsb	ip, r8, r9
    2e94:	eb07 030c 	add.w	r3, r7, ip
    2e98:	1d22      	adds	r2, r4, #4
    2e9a:	1d19      	adds	r1, r3, #4
    2e9c:	4293      	cmp	r3, r2
    2e9e:	bf38      	it	cc
    2ea0:	428c      	cmpcc	r4, r1
    2ea2:	bf34      	ite	cc
    2ea4:	2200      	movcc	r2, #0
    2ea6:	2201      	movcs	r2, #1
    2ea8:	f1b8 0f09 	cmp.w	r8, #9
    2eac:	bf94      	ite	ls
    2eae:	2200      	movls	r2, #0
    2eb0:	f002 0201 	andhi.w	r2, r2, #1
    2eb4:	2a00      	cmp	r2, #0
    2eb6:	f000 8087 	beq.w	2fc8 <fprime_from_bytes+0x18c>
    2eba:	ea43 0204 	orr.w	r2, r3, r4
    2ebe:	0792      	lsls	r2, r2, #30
    2ec0:	f040 8082 	bne.w	2fc8 <fprime_from_bytes+0x18c>
    2ec4:	ea4f 0298 	mov.w	r2, r8, lsr #2
    2ec8:	2100      	movs	r1, #0
    2eca:	ea4f 0b82 	mov.w	fp, r2, lsl #2
    2ece:	4608      	mov	r0, r1
    2ed0:	9501      	str	r5, [sp, #4]
		n[i] = x[len - preload_bytes + i];
    2ed2:	585d      	ldr	r5, [r3, r1]
    2ed4:	3001      	adds	r0, #1
    2ed6:	4282      	cmp	r2, r0
    2ed8:	5065      	str	r5, [r4, r1]
    2eda:	f101 0104 	add.w	r1, r1, #4
    2ede:	d8f8      	bhi.n	2ed2 <fprime_from_bytes+0x96>
    2ee0:	45c3      	cmp	fp, r8
    2ee2:	9d01      	ldr	r5, [sp, #4]
    2ee4:	d017      	beq.n	2f16 <fprime_from_bytes+0xda>
    2ee6:	eb07 030b 	add.w	r3, r7, fp
    2eea:	f813 100c 	ldrb.w	r1, [r3, ip]
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2eee:	f10b 0301 	add.w	r3, fp, #1
    2ef2:	4598      	cmp	r8, r3
		n[i] = x[len - preload_bytes + i];
    2ef4:	f804 1022 	strb.w	r1, [r4, r2, lsl #2]
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2ef8:	dd0d      	ble.n	2f16 <fprime_from_bytes+0xda>
		n[i] = x[len - preload_bytes + i];
    2efa:	18fa      	adds	r2, r7, r3
    2efc:	f812 200c 	ldrb.w	r2, [r2, ip]
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f00:	f10b 0b02 	add.w	fp, fp, #2
    2f04:	45d8      	cmp	r8, fp
		n[i] = x[len - preload_bytes + i];
    2f06:	54e2      	strb	r2, [r4, r3]
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f08:	dd05      	ble.n	2f16 <fprime_from_bytes+0xda>
		n[i] = x[len - preload_bytes + i];
    2f0a:	eb07 030b 	add.w	r3, r7, fp
    2f0e:	f813 300c 	ldrb.w	r3, [r3, ip]
    2f12:	f804 300b 	strb.w	r3, [r4, fp]

	if (preload_bits) {
    2f16:	b1be      	cbz	r6, 2f48 <fprime_from_bytes+0x10c>
    2f18:	2200      	movs	r2, #0
    2f1a:	4613      	mov	r3, r2
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c |= ((uint16_t)x[i]) << n;
    2f1c:	5ce1      	ldrb	r1, [r4, r3]
    2f1e:	40b1      	lsls	r1, r6
    2f20:	430a      	orrs	r2, r1
    2f22:	b292      	uxth	r2, r2
		x[i] = c;
    2f24:	54e2      	strb	r2, [r4, r3]
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f26:	3301      	adds	r3, #1
    2f28:	2b20      	cmp	r3, #32
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    2f2a:	ea4f 2212 	mov.w	r2, r2, lsr #8
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f2e:	d1f5      	bne.n	2f1c <fprime_from_bytes+0xe0>
	for (i = 0; i < preload_bytes; i++)
		n[i] = x[len - preload_bytes + i];

	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
    2f30:	f109 39ff 	add.w	r9, r9, #4294967295
    2f34:	ebc8 0809 	rsb	r8, r8, r9
    2f38:	f817 2008 	ldrb.w	r2, [r7, r8]
    2f3c:	f1c6 0608 	rsb	r6, r6, #8
    2f40:	4132      	asrs	r2, r6
    2f42:	7823      	ldrb	r3, [r4, #0]
    2f44:	4313      	orrs	r3, r2
    2f46:	7023      	strb	r3, [r4, #0]
	}

	for (i = rbits - 1; i >= 0; i--) {
    2f48:	f1ba 0a01 	subs.w	sl, sl, #1
    2f4c:	d433      	bmi.n	2fb6 <fprime_from_bytes+0x17a>
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;
    2f4e:	ea4f 03ea 	mov.w	r3, sl, asr #3
    2f52:	5cf8      	ldrb	r0, [r7, r3]
    2f54:	f00a 0307 	and.w	r3, sl, #7
    2f58:	4118      	asrs	r0, r3
}

/* Warning: this function may be variable-time in the argument n */
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
    2f5a:	2200      	movs	r2, #0
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
	}

	for (i = rbits - 1; i >= 0; i--) {
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;
    2f5c:	f000 0001 	and.w	r0, r0, #1
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f60:	4613      	mov	r3, r2
		c |= ((uint16_t)x[i]) << n;
    2f62:	5ce1      	ldrb	r1, [r4, r3]
    2f64:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
		x[i] = c;
    2f68:	54e2      	strb	r2, [r4, r3]
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f6a:	3301      	adds	r3, #1
    2f6c:	2b20      	cmp	r3, #32
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    2f6e:	ea4f 2212 	mov.w	r2, r2, lsr #8
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f72:	d1f6      	bne.n	2f62 <fprime_from_bytes+0x126>

	for (i = rbits - 1; i >= 0; i--) {
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;

		shift_n_bits(n, 1);
		n[0] |= bit;
    2f74:	7823      	ldrb	r3, [r4, #0]
}

static void raw_try_sub(uint8_t *x, const uint8_t *p)
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
    2f76:	2200      	movs	r2, #0

	for (i = rbits - 1; i >= 0; i--) {
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;

		shift_n_bits(n, 1);
		n[0] |= bit;
    2f78:	4303      	orrs	r3, r0
    2f7a:	7023      	strb	r3, [r4, #0]
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f7c:	4613      	mov	r3, r2
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
    2f7e:	5ce0      	ldrb	r0, [r4, r3]
    2f80:	5ce9      	ldrb	r1, [r5, r3]
    2f82:	1a41      	subs	r1, r0, r1
    2f84:	1a8a      	subs	r2, r1, r2
    2f86:	b292      	uxth	r2, r2
		minusp[i] = c;
    2f88:	a802      	add	r0, sp, #8
    2f8a:	54c2      	strb	r2, [r0, r3]
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f8c:	3301      	adds	r3, #1
    2f8e:	2b20      	cmp	r3, #32
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
    2f90:	f3c2 2200 	ubfx	r2, r2, #8, #1
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f94:	d1f3      	bne.n	2f7e <fprime_from_bytes+0x142>

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    2f96:	4252      	negs	r2, r2
    2f98:	b2d2      	uxtb	r2, r2
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
    2f9a:	2300      	movs	r3, #0
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    2f9c:	a802      	add	r0, sp, #8
    2f9e:	5cc1      	ldrb	r1, [r0, r3]
    2fa0:	5ce0      	ldrb	r0, [r4, r3]
    2fa2:	4048      	eors	r0, r1
    2fa4:	4010      	ands	r0, r2
    2fa6:	4041      	eors	r1, r0
    2fa8:	54e1      	strb	r1, [r4, r3]
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
    2faa:	3301      	adds	r3, #1
    2fac:	2b20      	cmp	r3, #32
    2fae:	d1f5      	bne.n	2f9c <fprime_from_bytes+0x160>
	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
	}

	for (i = rbits - 1; i >= 0; i--) {
    2fb0:	f11a 3aff 	adds.w	sl, sl, #4294967295
    2fb4:	d2cb      	bcs.n	2f4e <fprime_from_bytes+0x112>

		shift_n_bits(n, 1);
		n[0] |= bit;
		raw_try_sub(n, modulus);
	}
}
    2fb6:	b00b      	add	sp, #44	; 0x2c
    2fb8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
    2fbc:	f815 3c01 	ldrb.w	r3, [r5, #-1]
	i <<= 3;

	while (x) {
    2fc0:	b14b      	cbz	r3, 2fd6 <fprime_from_bytes+0x19a>
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
    2fc2:	f06f 0207 	mvn.w	r2, #7
    2fc6:	e74a      	b.n	2e5e <fprime_from_bytes+0x22>
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fc8:	2200      	movs	r2, #0
		n[i] = x[len - preload_bytes + i];
    2fca:	5c99      	ldrb	r1, [r3, r2]
    2fcc:	54a1      	strb	r1, [r4, r2]
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fce:	3201      	adds	r2, #1
    2fd0:	4542      	cmp	r2, r8
    2fd2:	d1fa      	bne.n	2fca <fprime_from_bytes+0x18e>
    2fd4:	e79f      	b.n	2f16 <fprime_from_bytes+0xda>
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    2fd6:	f06f 0209 	mvn.w	r2, #9
    2fda:	e745      	b.n	2e68 <fprime_from_bytes+0x2c>

00002fdc <sha256_starts>:
    (b)[(i) + 2] = (uint8) ( (n) >>  8 );       \
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    2fdc:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    2fe0:	f8df c048 	ldr.w	ip, [pc, #72]	; 302c <sha256_starts+0x50>
void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    2fe4:	f8df 8048 	ldr.w	r8, [pc, #72]	; 3030 <sha256_starts+0x54>
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    2fe8:	4f0a      	ldr	r7, [pc, #40]	; (3014 <sha256_starts+0x38>)
    ctx->state[3] = 0xA54FF53A;
    2fea:	4e0b      	ldr	r6, [pc, #44]	; (3018 <sha256_starts+0x3c>)
    ctx->state[4] = 0x510E527F;
    2fec:	4d0b      	ldr	r5, [pc, #44]	; (301c <sha256_starts+0x40>)
    ctx->state[5] = 0x9B05688C;
    2fee:	4c0c      	ldr	r4, [pc, #48]	; (3020 <sha256_starts+0x44>)
    ctx->state[6] = 0x1F83D9AB;
    2ff0:	490c      	ldr	r1, [pc, #48]	; (3024 <sha256_starts+0x48>)
    ctx->state[7] = 0x5BE0CD19;
    2ff2:	4a0d      	ldr	r2, [pc, #52]	; (3028 <sha256_starts+0x4c>)
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    2ff4:	2300      	movs	r3, #0
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    2ff6:	f8c0 8008 	str.w	r8, [r0, #8]
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    2ffa:	6107      	str	r7, [r0, #16]
    ctx->state[3] = 0xA54FF53A;
    2ffc:	6146      	str	r6, [r0, #20]
    ctx->state[4] = 0x510E527F;
    2ffe:	6185      	str	r5, [r0, #24]
    ctx->state[5] = 0x9B05688C;
    3000:	61c4      	str	r4, [r0, #28]
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    3002:	f8c0 c00c 	str.w	ip, [r0, #12]
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    3006:	6201      	str	r1, [r0, #32]
    ctx->state[7] = 0x5BE0CD19;
    3008:	6242      	str	r2, [r0, #36]	; 0x24
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    300a:	6003      	str	r3, [r0, #0]
    ctx->total[1] = 0;
    300c:	6043      	str	r3, [r0, #4]
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
}
    300e:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
    3012:	4770      	bx	lr
    3014:	3c6ef372 	stclcc	3, cr15, [lr], #-456	; 0xfffffe38
    3018:	a54ff53a 	strbge	pc, [pc, #-1338]	; 2ae6 <f25519_sqrt+0x2de>	; <UNPREDICTABLE>
    301c:	510e527f 	tstpl	lr, pc, ror r2
    3020:	9b05688c 	blls	15d258 <_etext+0x155d40>
    3024:	1f83d9ab 	svcne	0x0083d9ab
    3028:	5be0cd19 	blpl	ff836494 <BootRAM+0xe7a6c35>
    302c:	bb67ae85 	bllt	19eea48 <_etext+0x19e7530>
    3030:	6a09e667 	bvs	27c9d4 <_etext+0x2754bc>

00003034 <sha256_process>:

void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    3034:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    3038:	b09c      	sub	sp, #112	; 0x70
    303a:	9019      	str	r0, [sp, #100]	; 0x64
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    303c:	9a19      	ldr	r2, [sp, #100]	; 0x64

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    303e:	6980      	ldr	r0, [r0, #24]
    F = ctx->state[5];
    3040:	9b19      	ldr	r3, [sp, #100]	; 0x64
    G = ctx->state[6];
    H = ctx->state[7];
    3042:	9c19      	ldr	r4, [sp, #100]	; 0x64
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3044:	9e19      	ldr	r6, [sp, #100]	; 0x64
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    3046:	9004      	str	r0, [sp, #16]
    F = ctx->state[5];
    G = ctx->state[6];
    3048:	6a12      	ldr	r2, [r2, #32]
    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    304a:	69db      	ldr	r3, [r3, #28]
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    304c:	ea4f 15b0 	mov.w	r5, r0, ror #6
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    3050:	9819      	ldr	r0, [sp, #100]	; 0x64
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];
    3052:	6a64      	ldr	r4, [r4, #36]	; 0x24
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3054:	68b6      	ldr	r6, [r6, #8]
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    3056:	9202      	str	r2, [sp, #8]
    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    3058:	9303      	str	r3, [sp, #12]
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    305a:	68c0      	ldr	r0, [r0, #12]
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    305c:	9608      	str	r6, [sp, #32]
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];
    305e:	9401      	str	r4, [sp, #4]

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3060:	9a04      	ldr	r2, [sp, #16]
    3062:	9c02      	ldr	r4, [sp, #8]
    3064:	9e03      	ldr	r6, [sp, #12]
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    3066:	9007      	str	r0, [sp, #28]
    C = ctx->state[2];
    3068:	9819      	ldr	r0, [sp, #100]	; 0x64
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    306a:	ea85 25f2 	eor.w	r5, r5, r2, ror #11
    306e:	4bd0      	ldr	r3, [pc, #832]	; (33b0 <sha256_process+0x37c>)
    3070:	ea84 0206 	eor.w	r2, r4, r6
    3074:	9c04      	ldr	r4, [sp, #16]
    3076:	9e01      	ldr	r6, [sp, #4]
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3078:	6900      	ldr	r0, [r0, #16]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    307a:	784f      	ldrb	r7, [r1, #1]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    307c:	ea85 6574 	eor.w	r5, r5, r4, ror #25
    3080:	4433      	add	r3, r6
    3082:	4022      	ands	r2, r4
    3084:	9e08      	ldr	r6, [sp, #32]
    3086:	9c07      	ldr	r4, [sp, #28]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3088:	f891 a000 	ldrb.w	sl, [r1]
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    308c:	9006      	str	r0, [sp, #24]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    308e:	f891 c003 	ldrb.w	ip, [r1, #3]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3092:	eb03 0805 	add.w	r8, r3, r5
    3096:	ea44 0006 	orr.w	r0, r4, r6
    309a:	9b02      	ldr	r3, [sp, #8]
    309c:	9c06      	ldr	r4, [sp, #24]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    309e:	043f      	lsls	r7, r7, #16
    30a0:	f891 9002 	ldrb.w	r9, [r1, #2]
    30a4:	ea47 670a 	orr.w	r7, r7, sl, lsl #24
    30a8:	ea47 070c 	orr.w	r7, r7, ip
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30ac:	405a      	eors	r2, r3
    30ae:	4020      	ands	r0, r4
    30b0:	9b07      	ldr	r3, [sp, #28]
    30b2:	9c08      	ldr	r4, [sp, #32]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    30b4:	ea47 2909 	orr.w	r9, r7, r9, lsl #8
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30b8:	ea4f 06b6 	mov.w	r6, r6, ror #2
    30bc:	ea03 0504 	and.w	r5, r3, r4
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30c0:	f891 a005 	ldrb.w	sl, [r1, #5]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30c4:	ea86 3674 	eor.w	r6, r6, r4, ror #13
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30c8:	790c      	ldrb	r4, [r1, #4]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    30ca:	f8cd 906c 	str.w	r9, [sp, #108]	; 0x6c
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    30ce:	9f19      	ldr	r7, [sp, #100]	; 0x64
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30d0:	9b08      	ldr	r3, [sp, #32]
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    30d2:	697f      	ldr	r7, [r7, #20]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30d4:	4328      	orrs	r0, r5
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30d6:	ea4f 4a0a 	mov.w	sl, sl, lsl #16
    30da:	79cd      	ldrb	r5, [r1, #7]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30dc:	ea86 56b3 	eor.w	r6, r6, r3, ror #22
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30e0:	ea4a 6a04 	orr.w	sl, sl, r4, lsl #24
    30e4:	798c      	ldrb	r4, [r1, #6]
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    30e6:	9705      	str	r7, [sp, #20]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30e8:	4430      	add	r0, r6
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30ea:	ea4a 0a05 	orr.w	sl, sl, r5
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    30ee:	9e03      	ldr	r6, [sp, #12]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30f0:	4442      	add	r2, r8
    30f2:	46bc      	mov	ip, r7
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    30f4:	9f04      	ldr	r7, [sp, #16]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30f6:	444a      	add	r2, r9
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30f8:	ea4a 2404 	orr.w	r4, sl, r4, lsl #8
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30fc:	eb00 0b02 	add.w	fp, r0, r2
    3100:	4494      	add	ip, r2
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3102:	940d      	str	r4, [sp, #52]	; 0x34
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    3104:	9d03      	ldr	r5, [sp, #12]
    3106:	9c08      	ldr	r4, [sp, #32]
    3108:	ea86 0207 	eor.w	r2, r6, r7
    310c:	9802      	ldr	r0, [sp, #8]
    310e:	ea0c 0202 	and.w	r2, ip, r2
    3112:	4ba8      	ldr	r3, [pc, #672]	; (33b4 <sha256_process+0x380>)
    3114:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
    3118:	ea4b 0704 	orr.w	r7, fp, r4
    311c:	406a      	eors	r2, r5
    311e:	ea0b 0504 	and.w	r5, fp, r4
    3122:	9c07      	ldr	r4, [sp, #28]
    3124:	4403      	add	r3, r0
    3126:	ea4f 18bc 	mov.w	r8, ip, ror #6
    312a:	ea4f 06bb 	mov.w	r6, fp, ror #2
    312e:	444b      	add	r3, r9
    3130:	ea88 28fc 	eor.w	r8, r8, ip, ror #11
    3134:	4027      	ands	r7, r4
    3136:	ea86 367b 	eor.w	r6, r6, fp, ror #13
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    313a:	7a48      	ldrb	r0, [r1, #9]
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    313c:	ea88 687c 	eor.w	r8, r8, ip, ror #25
    3140:	ea86 56bb 	eor.w	r6, r6, fp, ror #22
    3144:	4413      	add	r3, r2
    3146:	432f      	orrs	r7, r5
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3148:	7a0c      	ldrb	r4, [r1, #8]
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    314a:	4443      	add	r3, r8
    314c:	4437      	add	r7, r6
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    314e:	7acd      	ldrb	r5, [r1, #11]
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    3150:	441f      	add	r7, r3
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3152:	0400      	lsls	r0, r0, #16
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    3154:	970b      	str	r7, [sp, #44]	; 0x2c
    3156:	9e06      	ldr	r6, [sp, #24]
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3158:	9f04      	ldr	r7, [sp, #16]
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    315a:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
    315e:	7a8c      	ldrb	r4, [r1, #10]
    3160:	4328      	orrs	r0, r5
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    3162:	441e      	add	r6, r3
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3164:	ea8c 0907 	eor.w	r9, ip, r7
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3168:	ea40 2404 	orr.w	r4, r0, r4, lsl #8
    316c:	940e      	str	r4, [sp, #56]	; 0x38
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    316e:	9803      	ldr	r0, [sp, #12]
    3170:	ea06 0909 	and.w	r9, r6, r9
    3174:	4a90      	ldr	r2, [pc, #576]	; (33b8 <sha256_process+0x384>)
    3176:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3178:	ea89 0907 	eor.w	r9, r9, r7
    317c:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    317e:	4402      	add	r2, r0
    3180:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
    3184:	ea43 080b 	orr.w	r8, r3, fp
    3188:	ea4f 04b3 	mov.w	r4, r3, ror #2
    318c:	443a      	add	r2, r7
    318e:	ea03 070b 	and.w	r7, r3, fp
    3192:	9b08      	ldr	r3, [sp, #32]
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3194:	7b48      	ldrb	r0, [r1, #13]
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3196:	ea4f 15b6 	mov.w	r5, r6, ror #6
    319a:	ea08 0803 	and.w	r8, r8, r3
    319e:	ea84 347a 	eor.w	r4, r4, sl, ror #13
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31a2:	7b0b      	ldrb	r3, [r1, #12]
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31a4:	ea84 54ba 	eor.w	r4, r4, sl, ror #22
    31a8:	ea85 25f6 	eor.w	r5, r5, r6, ror #11
    31ac:	ea48 0807 	orr.w	r8, r8, r7
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31b0:	0400      	lsls	r0, r0, #16
    31b2:	7bcf      	ldrb	r7, [r1, #15]
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31b4:	ea85 6576 	eor.w	r5, r5, r6, ror #25
    31b8:	444a      	add	r2, r9
    31ba:	44a0      	add	r8, r4
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31bc:	ea40 6303 	orr.w	r3, r0, r3, lsl #24
    31c0:	7b8c      	ldrb	r4, [r1, #14]
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31c2:	442a      	add	r2, r5
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31c4:	433b      	orrs	r3, r7
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31c6:	9d07      	ldr	r5, [sp, #28]
    31c8:	4490      	add	r8, r2
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31ca:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31ce:	4415      	add	r5, r2
    31d0:	f8cd 8030 	str.w	r8, [sp, #48]	; 0x30

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31d4:	7c4f      	ldrb	r7, [r1, #17]
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31d6:	4879      	ldr	r0, [pc, #484]	; (33bc <sha256_process+0x388>)
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31d8:	940f      	str	r4, [sp, #60]	; 0x3c
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31da:	9a04      	ldr	r2, [sp, #16]

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31dc:	7c0b      	ldrb	r3, [r1, #16]
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31de:	4410      	add	r0, r2
    31e0:	9a0b      	ldr	r2, [sp, #44]	; 0x2c

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31e2:	930a      	str	r3, [sp, #40]	; 0x28
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31e4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    31e6:	ea48 0402 	orr.w	r4, r8, r2
    31ea:	ea4f 02b8 	mov.w	r2, r8, ror #2

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31ee:	f891 8013 	ldrb.w	r8, [r1, #19]
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31f2:	4403      	add	r3, r0
    31f4:	9309      	str	r3, [sp, #36]	; 0x24

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31f6:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31fa:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    31fc:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
    3200:	ea86 0a0c 	eor.w	sl, r6, ip
    3204:	ea03 0008 	and.w	r0, r3, r8
    3208:	ea05 0a0a 	and.w	sl, r5, sl
    320c:	ea82 3273 	eor.w	r2, r2, r3, ror #13
    3210:	9b09      	ldr	r3, [sp, #36]	; 0x24

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3212:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3216:	ea04 040b 	and.w	r4, r4, fp
    321a:	ea8a 0a0c 	eor.w	sl, sl, ip
    321e:	449a      	add	sl, r3
    3220:	ea4f 19b5 	mov.w	r9, r5, ror #6
    3224:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    3226:	4320      	orrs	r0, r4

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3228:	043f      	lsls	r7, r7, #16
    322a:	9c10      	ldr	r4, [sp, #64]	; 0x40
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    322c:	ea89 29f5 	eor.w	r9, r9, r5, ror #11

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3230:	ea47 6708 	orr.w	r7, r7, r8, lsl #24
    3234:	f891 8012 	ldrb.w	r8, [r1, #18]
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3238:	ea82 52b3 	eor.w	r2, r2, r3, ror #22

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    323c:	4327      	orrs	r7, r4
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    323e:	ea89 6975 	eor.w	r9, r9, r5, ror #25
    3242:	44d1      	add	r9, sl

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3244:	ea47 2808 	orr.w	r8, r7, r8, lsl #8
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3248:	4410      	add	r0, r2
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    324a:	7d4f      	ldrb	r7, [r1, #21]

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    324c:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    324e:	4b5c      	ldr	r3, [pc, #368]	; (33c0 <sha256_process+0x38c>)
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3250:	4448      	add	r0, r9
    3252:	9009      	str	r0, [sp, #36]	; 0x24
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3254:	9712      	str	r7, [sp, #72]	; 0x48

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3256:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    325a:	4443      	add	r3, r8
    325c:	ea4f 07b0 	mov.w	r7, r0, ror #2
    3260:	ea40 0802 	orr.w	r8, r0, r2
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3264:	7d08      	ldrb	r0, [r1, #20]
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3266:	9c08      	ldr	r4, [sp, #32]
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3268:	9011      	str	r0, [sp, #68]	; 0x44

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    326a:	4463      	add	r3, ip
    326c:	980b      	ldr	r0, [sp, #44]	; 0x2c
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    326e:	444c      	add	r4, r9
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3270:	930a      	str	r3, [sp, #40]	; 0x28
    3272:	ea85 0a06 	eor.w	sl, r5, r6
    3276:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3278:	ea08 0800 	and.w	r8, r8, r0
    327c:	ea04 0a0a 	and.w	sl, r4, sl
    3280:	980a      	ldr	r0, [sp, #40]	; 0x28
    3282:	ea03 0c02 	and.w	ip, r3, r2
    3286:	ea8a 0a06 	eor.w	sl, sl, r6
    328a:	ea87 3773 	eor.w	r7, r7, r3, ror #13
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    328e:	9b12      	ldr	r3, [sp, #72]	; 0x48

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3290:	ea4f 19b4 	mov.w	r9, r4, ror #6
    3294:	4482      	add	sl, r0
    3296:	ea48 0c0c 	orr.w	ip, r8, ip
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    329a:	9811      	ldr	r0, [sp, #68]	; 0x44

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    329c:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    32a0:	ea89 29f4 	eor.w	r9, r9, r4, ror #11
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32a4:	041a      	lsls	r2, r3, #16
    32a6:	7dcb      	ldrb	r3, [r1, #23]

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32a8:	ea89 6974 	eor.w	r9, r9, r4, ror #25
    32ac:	ea87 57b8 	eor.w	r7, r7, r8, ror #22
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32b0:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    32b4:	f891 8016 	ldrb.w	r8, [r1, #22]

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32b8:	44ca      	add	sl, r9
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32ba:	431a      	orrs	r2, r3

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32bc:	44bc      	add	ip, r7
    32be:	44d4      	add	ip, sl
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32c0:	ea42 2808 	orr.w	r8, r2, r8, lsl #8
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32c4:	4b3f      	ldr	r3, [pc, #252]	; (33c4 <sha256_process+0x390>)

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32c6:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32ca:	f8cd 8044 	str.w	r8, [sp, #68]	; 0x44
    GET_UINT32( W[6],  data, 24 );
    32ce:	7e4a      	ldrb	r2, [r1, #25]
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32d0:	4443      	add	r3, r8
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    32d2:	9212      	str	r2, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32d4:	441e      	add	r6, r3
    32d6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    32d8:	9b09      	ldr	r3, [sp, #36]	; 0x24
    32da:	9f09      	ldr	r7, [sp, #36]	; 0x24
    32dc:	ea02 0803 	and.w	r8, r2, r3
    32e0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    32e2:	ea4c 0907 	orr.w	r9, ip, r7
    32e6:	ea4f 0cbc 	mov.w	ip, ip, ror #2

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32ea:	eb0a 000b 	add.w	r0, sl, fp
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32ee:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    32f0:	ea84 0b05 	eor.w	fp, r4, r5
    32f4:	ea8c 3c73 	eor.w	ip, ip, r3, ror #13
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    32f8:	9b12      	ldr	r3, [sp, #72]	; 0x48
    32fa:	7e0f      	ldrb	r7, [r1, #24]
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32fc:	ea00 0b0b 	and.w	fp, r0, fp
    3300:	ea8b 0b05 	eor.w	fp, fp, r5
    3304:	ea09 0902 	and.w	r9, r9, r2
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    3308:	041a      	lsls	r2, r3, #16
    330a:	7ecb      	ldrb	r3, [r1, #27]
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    330c:	445e      	add	r6, fp
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    330e:	ea42 6207 	orr.w	r2, r2, r7, lsl #24
    3312:	f891 b01a 	ldrb.w	fp, [r1, #26]
    3316:	ea42 0703 	orr.w	r7, r2, r3
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    331a:	ea49 0808 	orr.w	r8, r9, r8
    331e:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    3322:	ea47 2b0b 	orr.w	fp, r7, fp, lsl #8
    3326:	f8cd b048 	str.w	fp, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    332a:	ea8c 5cb9 	eor.w	ip, ip, r9, ror #22
    332e:	ea4f 1ab0 	mov.w	sl, r0, ror #6
    3332:	ea8a 2af0 	eor.w	sl, sl, r0, ror #11
    3336:	44e0      	add	r8, ip
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3338:	4b23      	ldr	r3, [pc, #140]	; (33c8 <sha256_process+0x394>)
    333a:	f8dd c048 	ldr.w	ip, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    333e:	ea8a 6a70 	eor.w	sl, sl, r0, ror #25
    3342:	4456      	add	r6, sl
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3344:	4463      	add	r3, ip
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3346:	44b0      	add	r8, r6
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3348:	441d      	add	r5, r3
    334a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    334c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    334e:	f891 a01d 	ldrb.w	sl, [r1, #29]
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3352:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3356:	ea48 0909 	orr.w	r9, r8, r9
    335a:	ea4f 0cb8 	mov.w	ip, r8, ror #2
    335e:	ea08 0803 	and.w	r8, r8, r3
    3362:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3364:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3368:	4432      	add	r2, r6
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    336a:	ea80 0b04 	eor.w	fp, r0, r4
    336e:	9e09      	ldr	r6, [sp, #36]	; 0x24
    3370:	ea8c 3c73 	eor.w	ip, ip, r3, ror #13
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3374:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    3376:	7f0f      	ldrb	r7, [r1, #28]
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3378:	ea02 0b0b 	and.w	fp, r2, fp
    337c:	ea8b 0b04 	eor.w	fp, fp, r4
    3380:	ea09 0906 	and.w	r9, r9, r6
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3384:	041e      	lsls	r6, r3, #16
    3386:	7fcb      	ldrb	r3, [r1, #31]
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3388:	445d      	add	r5, fp
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    338a:	ea46 6607 	orr.w	r6, r6, r7, lsl #24
    338e:	f891 b01e 	ldrb.w	fp, [r1, #30]
    3392:	431e      	orrs	r6, r3
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3394:	ea4f 1ab2 	mov.w	sl, r2, ror #6
    3398:	ea49 0808 	orr.w	r8, r9, r8
    339c:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    33a0:	ea46 2b0b 	orr.w	fp, r6, fp, lsl #8
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33a4:	ea8a 2af2 	eor.w	sl, sl, r2, ror #11
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    33a8:	f8cd b04c 	str.w	fp, [sp, #76]	; 0x4c
    33ac:	e00e      	b.n	33cc <sha256_process+0x398>
    33ae:	bf00      	nop
    33b0:	428a2f98 	addmi	r2, sl, #152, 30	; 0x260
    33b4:	71374491 			; <UNDEFINED> instruction: 0x71374491
    33b8:	b5c0fbcf 	strblt	pc, [r0, #3023]	; 0xbcf	; <UNPREDICTABLE>
    33bc:	e9b5dba5 	ldmib	r5!, {r0, r2, r5, r7, r8, r9, fp, ip, lr, pc}
    33c0:	3956c25b 	ldmdbcc	r6, {r0, r1, r3, r4, r6, r9, lr, pc}^
    33c4:	59f111f1 	ldmibpl	r1!, {r0, r4, r5, r6, r7, r8, ip}^
    33c8:	923f82a4 	eorsls	r8, pc, #164, 4	; 0x4000000a
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33cc:	ea8c 5cb9 	eor.w	ip, ip, r9, ror #22
    33d0:	ea8a 6a72 	eor.w	sl, sl, r2, ror #25
    33d4:	44aa      	add	sl, r5
    33d6:	44e0      	add	r8, ip
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    33d8:	4de9      	ldr	r5, [pc, #932]	; (3780 <sha256_process+0x74c>)
    33da:	f8dd c04c 	ldr.w	ip, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33de:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    33e0:	4465      	add	r5, ip
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33e2:	44d0      	add	r8, sl
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    33e4:	442c      	add	r4, r5
    33e6:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33e8:	4453      	add	r3, sl
    33ea:	f8cd 8030 	str.w	r8, [sp, #48]	; 0x30
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    33ee:	f891 a021 	ldrb.w	sl, [r1, #33]	; 0x21
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    33f2:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    33f4:	ea48 0909 	orr.w	r9, r8, r9
    33f8:	ea4f 0cb8 	mov.w	ip, r8, ror #2
    33fc:	ea08 0805 	and.w	r8, r8, r5
    3400:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3402:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3406:	ea82 0b00 	eor.w	fp, r2, r0
    340a:	ea09 0906 	and.w	r9, r9, r6
    340e:	ea8c 3c75 	eor.w	ip, ip, r5, ror #13
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3412:	9d14      	ldr	r5, [sp, #80]	; 0x50
    3414:	f891 7020 	ldrb.w	r7, [r1, #32]
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3418:	ea03 0b0b 	and.w	fp, r3, fp
    341c:	ea4f 1ab3 	mov.w	sl, r3, ror #6
    3420:	ea49 0808 	orr.w	r8, r9, r8
    3424:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
    3428:	ea8b 0b00 	eor.w	fp, fp, r0
    342c:	ea8a 2af3 	eor.w	sl, sl, r3, ror #11
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3430:	042e      	lsls	r6, r5, #16
    3432:	f891 5023 	ldrb.w	r5, [r1, #35]	; 0x23
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3436:	ea8a 6a73 	eor.w	sl, sl, r3, ror #25
    343a:	ea8c 5cb9 	eor.w	ip, ip, r9, ror #22
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    343e:	ea46 6607 	orr.w	r6, r6, r7, lsl #24
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3442:	445c      	add	r4, fp
    3444:	4454      	add	r4, sl
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3446:	4335      	orrs	r5, r6
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3448:	44e0      	add	r8, ip
    344a:	9e09      	ldr	r6, [sp, #36]	; 0x24
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    344c:	f891 b022 	ldrb.w	fp, [r1, #34]	; 0x22
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3450:	44a0      	add	r8, r4
    3452:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
    3456:	4426      	add	r6, r4
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3458:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
    345c:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    345e:	f891 a025 	ldrb.w	sl, [r1, #37]	; 0x25
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3462:	4fc8      	ldr	r7, [pc, #800]	; (3784 <sha256_process+0x750>)
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3464:	ea45 2b0b 	orr.w	fp, r5, fp, lsl #8
    GET_UINT32( W[9],  data, 36 );
    3468:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    346c:	f8cd b068 	str.w	fp, [sp, #104]	; 0x68
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3470:	ea83 0902 	eor.w	r9, r3, r2
    3474:	445f      	add	r7, fp
    3476:	ea4f 0abc 	mov.w	sl, ip, ror #2
    347a:	ea4c 0b04 	orr.w	fp, ip, r4
    347e:	ea0c 0c04 	and.w	ip, ip, r4
    3482:	9c09      	ldr	r4, [sp, #36]	; 0x24
    3484:	ea06 0909 	and.w	r9, r6, r9
    3488:	ea89 0902 	eor.w	r9, r9, r2
    348c:	4438      	add	r0, r7
    348e:	ea8a 3a74 	eor.w	sl, sl, r4, ror #13
    3492:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3494:	9c14      	ldr	r4, [sp, #80]	; 0x50
    3496:	f891 5024 	ldrb.w	r5, [r1, #36]	; 0x24
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    349a:	ea4f 18b6 	mov.w	r8, r6, ror #6
    349e:	4448      	add	r0, r9
    34a0:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    34a4:	ea88 28f6 	eor.w	r8, r8, r6, ror #11
    34a8:	ea0b 0b07 	and.w	fp, fp, r7
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34ac:	0427      	lsls	r7, r4, #16
    34ae:	f891 4027 	ldrb.w	r4, [r1, #39]	; 0x27
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34b2:	ea88 6876 	eor.w	r8, r8, r6, ror #25
    34b6:	ea8a 5ab9 	eor.w	sl, sl, r9, ror #22
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34ba:	ea47 6505 	orr.w	r5, r7, r5, lsl #24
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34be:	ea4b 0b0c 	orr.w	fp, fp, ip
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34c2:	f891 7026 	ldrb.w	r7, [r1, #38]	; 0x26
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34c6:	4440      	add	r0, r8
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34c8:	432c      	orrs	r4, r5
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34ca:	44d3      	add	fp, sl
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34cc:	4dae      	ldr	r5, [pc, #696]	; (3788 <sha256_process+0x754>)
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34ce:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34d2:	ea44 2707 	orr.w	r7, r4, r7, lsl #8
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34d6:	4483      	add	fp, r0
    34d8:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34dc:	443d      	add	r5, r7
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34de:	4481      	add	r9, r0
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34e0:	442a      	add	r2, r5
    34e2:	9809      	ldr	r0, [sp, #36]	; 0x24
    34e4:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    34e6:	f891 a029 	ldrb.w	sl, [r1, #41]	; 0x29
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34ea:	9714      	str	r7, [sp, #80]	; 0x50
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34ec:	ea4b 0b00 	orr.w	fp, fp, r0
    34f0:	ea05 0700 	and.w	r7, r5, r0
    34f4:	980c      	ldr	r0, [sp, #48]	; 0x30
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    34f6:	f8cd a054 	str.w	sl, [sp, #84]	; 0x54
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34fa:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    34fc:	ea86 0803 	eor.w	r8, r6, r3
    3500:	ea0b 0b00 	and.w	fp, fp, r0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3504:	9815      	ldr	r0, [sp, #84]	; 0x54
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3506:	ea09 0808 	and.w	r8, r9, r8
    350a:	ea4f 1cb9 	mov.w	ip, r9, ror #6
    350e:	ea4f 0ab4 	mov.w	sl, r4, ror #2
    3512:	ea4b 0b07 	orr.w	fp, fp, r7
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3516:	f891 4028 	ldrb.w	r4, [r1, #40]	; 0x28
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    351a:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    351c:	ea88 0803 	eor.w	r8, r8, r3
    3520:	ea8c 2cf9 	eor.w	ip, ip, r9, ror #11
    3524:	ea8a 3a75 	eor.w	sl, sl, r5, ror #13
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3528:	0405      	lsls	r5, r0, #16
    352a:	f891 002b 	ldrb.w	r0, [r1, #43]	; 0x2b
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    352e:	ea8c 6c79 	eor.w	ip, ip, r9, ror #25
    3532:	ea8a 5ab7 	eor.w	sl, sl, r7, ror #22
    3536:	4442      	add	r2, r8
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3538:	ea45 6404 	orr.w	r4, r5, r4, lsl #24
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    353c:	4462      	add	r2, ip
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    353e:	f891 802a 	ldrb.w	r8, [r1, #42]	; 0x2a
    3542:	4304      	orrs	r4, r0
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3544:	44d3      	add	fp, sl
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3546:	980a      	ldr	r0, [sp, #40]	; 0x28
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3548:	4493      	add	fp, r2
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    354a:	4d90      	ldr	r5, [pc, #576]	; (378c <sha256_process+0x758>)
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    354c:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    354e:	ea44 2808 	orr.w	r8, r4, r8, lsl #8
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3552:	ea4b 0c00 	orr.w	ip, fp, r0
    3556:	9809      	ldr	r0, [sp, #36]	; 0x24
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3558:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    355c:	4445      	add	r5, r8
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    355e:	4417      	add	r7, r2
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3560:	ea89 0a06 	eor.w	sl, r9, r6
    3564:	ea4f 04bb 	mov.w	r4, fp, ror #2
    3568:	442b      	add	r3, r5
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    356a:	f891 b02c 	ldrb.w	fp, [r1, #44]	; 0x2c
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    356e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    3570:	ea0c 0c00 	and.w	ip, ip, r0
    3574:	980a      	ldr	r0, [sp, #40]	; 0x28
    3576:	ea07 0a0a 	and.w	sl, r7, sl
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    357a:	f8cd b058 	str.w	fp, [sp, #88]	; 0x58
    357e:	f891 202d 	ldrb.w	r2, [r1, #45]	; 0x2d
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3582:	ea05 0b00 	and.w	fp, r5, r0
    3586:	ea8a 0a06 	eor.w	sl, sl, r6
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    358a:	f8cd 8054 	str.w	r8, [sp, #84]	; 0x54
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    358e:	4453      	add	r3, sl
    3590:	ea4f 18b7 	mov.w	r8, r7, ror #6
    3594:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
    3598:	ea4c 0c0b 	orr.w	ip, ip, fp
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    359c:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35a0:	ea88 28f7 	eor.w	r8, r8, r7, ror #11
    35a4:	ea84 3475 	eor.w	r4, r4, r5, ror #13
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35a8:	0412      	lsls	r2, r2, #16
    35aa:	f891 502f 	ldrb.w	r5, [r1, #47]	; 0x2f
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35ae:	ea88 6877 	eor.w	r8, r8, r7, ror #25
    35b2:	ea84 54ba 	eor.w	r4, r4, sl, ror #22
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35b6:	ea42 620b 	orr.w	r2, r2, fp, lsl #24
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35ba:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35be:	f891 b02e 	ldrb.w	fp, [r1, #46]	; 0x2e
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35c2:	4443      	add	r3, r8
    35c4:	44a4      	add	ip, r4
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35c6:	432a      	orrs	r2, r5
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35c8:	4c71      	ldr	r4, [pc, #452]	; (3790 <sha256_process+0x75c>)
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35ca:	eb0c 0803 	add.w	r8, ip, r3
    35ce:	449a      	add	sl, r3
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35d0:	ea42 2b0b 	orr.w	fp, r2, fp, lsl #8
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35d4:	ea87 0c09 	eor.w	ip, r7, r9
    35d8:	445c      	add	r4, fp
    35da:	ea0a 0c0c 	and.w	ip, sl, ip
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35de:	f8cd b058 	str.w	fp, [sp, #88]	; 0x58
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35e2:	ea8c 0c09 	eor.w	ip, ip, r9
    35e6:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    35e8:	4426      	add	r6, r4
    35ea:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    35ee:	f891 4030 	ldrb.w	r4, [r1, #48]	; 0x30
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35f2:	4466      	add	r6, ip
    35f4:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
    35f8:	ea48 0002 	orr.w	r0, r8, r2
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    35fc:	940c      	str	r4, [sp, #48]	; 0x30
    35fe:	f891 3031 	ldrb.w	r3, [r1, #49]	; 0x31
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3602:	ea00 000b 	and.w	r0, r0, fp
    3606:	ea08 0b0c 	and.w	fp, r8, ip
    360a:	ea4f 15ba 	mov.w	r5, sl, ror #6
    360e:	ea4f 02b8 	mov.w	r2, r8, ror #2
    3612:	ea40 000b 	orr.w	r0, r0, fp
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3616:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
    361a:	f891 4033 	ldrb.w	r4, [r1, #51]	; 0x33
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    361e:	ea85 25fa 	eor.w	r5, r5, sl, ror #11
    3622:	ea82 3278 	eor.w	r2, r2, r8, ror #13
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3626:	041b      	lsls	r3, r3, #16
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3628:	ea85 657a 	eor.w	r5, r5, sl, ror #25
    362c:	ea82 52b8 	eor.w	r2, r2, r8, ror #22
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3630:	ea43 630b 	orr.w	r3, r3, fp, lsl #24
    3634:	f891 b032 	ldrb.w	fp, [r1, #50]	; 0x32
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3638:	442e      	add	r6, r5
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    363a:	4323      	orrs	r3, r4
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    363c:	4410      	add	r0, r2
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    363e:	4a55      	ldr	r2, [pc, #340]	; (3794 <sha256_process+0x760>)
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3640:	9c09      	ldr	r4, [sp, #36]	; 0x24
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3642:	ea43 2b0b 	orr.w	fp, r3, fp, lsl #8
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3646:	4430      	add	r0, r6
    3648:	9009      	str	r0, [sp, #36]	; 0x24
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    364a:	445a      	add	r2, fp
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    364c:	4434      	add	r4, r6
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    364e:	4491      	add	r9, r2
    3650:	ea8a 0607 	eor.w	r6, sl, r7
    3654:	9a09      	ldr	r2, [sp, #36]	; 0x24
    3656:	4026      	ands	r6, r4
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3658:	f891 3035 	ldrb.w	r3, [r1, #53]	; 0x35
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    365c:	407e      	eors	r6, r7
    365e:	ea4f 0cb2 	mov.w	ip, r2, ror #2
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3662:	f8cd b05c 	str.w	fp, [sp, #92]	; 0x5c
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3666:	ea8c 3c72 	eor.w	ip, ip, r2, ror #13
    366a:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    366e:	f891 2034 	ldrb.w	r2, [r1, #52]	; 0x34
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3672:	44b1      	add	r9, r6
    3674:	9e09      	ldr	r6, [sp, #36]	; 0x24
    3676:	ea40 0008 	orr.w	r0, r0, r8
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    367a:	041b      	lsls	r3, r3, #16
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    367c:	ea00 000b 	and.w	r0, r0, fp
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3680:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    3684:	f891 b037 	ldrb.w	fp, [r1, #55]	; 0x37
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3688:	ea06 0208 	and.w	r2, r6, r8
    368c:	4310      	orrs	r0, r2
    368e:	ea4f 15b4 	mov.w	r5, r4, ror #6
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3692:	f891 2036 	ldrb.w	r2, [r1, #54]	; 0x36
    3696:	ea43 030b 	orr.w	r3, r3, fp
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    369a:	ea85 25f4 	eor.w	r5, r5, r4, ror #11
    369e:	ea8c 5cb6 	eor.w	ip, ip, r6, ror #22
    36a2:	ea85 6574 	eor.w	r5, r5, r4, ror #25
    36a6:	4484      	add	ip, r0
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    36a8:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36ac:	980a      	ldr	r0, [sp, #40]	; 0x28
    36ae:	44a9      	add	r9, r5
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    36b0:	9218      	str	r2, [sp, #96]	; 0x60
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36b2:	eb0c 0b09 	add.w	fp, ip, r9
    36b6:	4448      	add	r0, r9
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36b8:	4e37      	ldr	r6, [pc, #220]	; (3798 <sha256_process+0x764>)
    36ba:	f8dd 9060 	ldr.w	r9, [sp, #96]	; 0x60
    36be:	ea84 020a 	eor.w	r2, r4, sl
    36c2:	444e      	add	r6, r9
    36c4:	4002      	ands	r2, r0
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36c6:	f891 5039 	ldrb.w	r5, [r1, #57]	; 0x39
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36ca:	ea82 020a 	eor.w	r2, r2, sl
    36ce:	443e      	add	r6, r7
    36d0:	9f09      	ldr	r7, [sp, #36]	; 0x24
    36d2:	4416      	add	r6, r2
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36d4:	f891 2038 	ldrb.w	r2, [r1, #56]	; 0x38
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36d8:	ea4b 0307 	orr.w	r3, fp, r7
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36dc:	042d      	lsls	r5, r5, #16
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36de:	ea03 0308 	and.w	r3, r3, r8
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36e2:	ea45 6502 	orr.w	r5, r5, r2, lsl #24
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36e6:	ea0b 0207 	and.w	r2, fp, r7
    36ea:	4313      	orrs	r3, r2
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36ec:	f891 203b 	ldrb.w	r2, [r1, #59]	; 0x3b
    36f0:	f891 703a 	ldrb.w	r7, [r1, #58]	; 0x3a
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36f4:	ea4f 1cb0 	mov.w	ip, r0, ror #6
    36f8:	ea4f 09bb 	mov.w	r9, fp, ror #2
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36fc:	4315      	orrs	r5, r2
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36fe:	ea8c 2cf0 	eor.w	ip, ip, r0, ror #11
    3702:	ea89 397b 	eor.w	r9, r9, fp, ror #13
    3706:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    3708:	ea8c 6c70 	eor.w	ip, ip, r0, ror #25
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    370c:	ea45 2707 	orr.w	r7, r5, r7, lsl #8
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3710:	ea89 59bb 	eor.w	r9, r9, fp, ror #22
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3714:	970b      	str	r7, [sp, #44]	; 0x2c
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3716:	4466      	add	r6, ip
    3718:	4499      	add	r9, r3
    371a:	4432      	add	r2, r6
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    371c:	4b1f      	ldr	r3, [pc, #124]	; (379c <sha256_process+0x768>)
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    371e:	444e      	add	r6, r9
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3720:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    3724:	ea80 0704 	eor.w	r7, r0, r4
    3728:	444b      	add	r3, r9
    372a:	4017      	ands	r7, r2
    372c:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
    3730:	4067      	eors	r7, r4
    3732:	449a      	add	sl, r3
    3734:	44ba      	add	sl, r7
    3736:	ea46 070b 	orr.w	r7, r6, fp
    373a:	ea06 030b 	and.w	r3, r6, fp
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    373e:	f891 503d 	ldrb.w	r5, [r1, #61]	; 0x3d
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3742:	ea07 070c 	and.w	r7, r7, ip
    3746:	431f      	orrs	r7, r3
    3748:	ea4f 0cb6 	mov.w	ip, r6, ror #2
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    374c:	f891 303c 	ldrb.w	r3, [r1, #60]	; 0x3c
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3750:	ea8c 3c76 	eor.w	ip, ip, r6, ror #13
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3754:	042d      	lsls	r5, r5, #16
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3756:	ea8c 5cb6 	eor.w	ip, ip, r6, ror #22
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    375a:	ea45 6503 	orr.w	r5, r5, r3, lsl #24
    375e:	f891 303f 	ldrb.w	r3, [r1, #63]	; 0x3f
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3762:	ea4f 19b2 	mov.w	r9, r2, ror #6
    3766:	4467      	add	r7, ip
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3768:	f891 c03e 	ldrb.w	ip, [r1, #62]	; 0x3e
    376c:	431d      	orrs	r5, r3
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    376e:	ea89 29f2 	eor.w	r9, r9, r2, ror #11
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3772:	490b      	ldr	r1, [pc, #44]	; (37a0 <sha256_process+0x76c>)
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3774:	ea45 2c0c 	orr.w	ip, r5, ip, lsl #8
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3778:	ea89 6972 	eor.w	r9, r9, r2, ror #25
    377c:	e012      	b.n	37a4 <sha256_process+0x770>
    377e:	bf00      	nop
    3780:	ab1c5ed5 	blge	71b2dc <_etext+0x713dc4>
    3784:	d807aa98 	stmdale	r7, {r3, r4, r7, r9, fp, sp, pc}
    3788:	12835b01 	addne	r5, r3, #1024	; 0x400
    378c:	243185be 	ldrtcs	r8, [r1], #-1470	; 0x5be
    3790:	550c7dc3 	strpl	r7, [ip, #-3523]	; 0xdc3
    3794:	72be5d74 	adcsvc	r5, lr, #116, 26	; 0x1d00
    3798:	80deb1fe 	ldrshhi	fp, [lr], #30
    379c:	9bdc06a7 	blls	ff705240 <BootRAM+0xe6759e1>
    37a0:	c19bf174 	orrsgt	pc, fp, r4, ror r1	; <UNPREDICTABLE>
    37a4:	44ca      	add	sl, r9
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37a6:	4461      	add	r1, ip
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    37a8:	f8cd c030 	str.w	ip, [sp, #48]	; 0x30
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37ac:	eb0a 0308 	add.w	r3, sl, r8
    37b0:	4457      	add	r7, sl
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37b2:	440c      	add	r4, r1
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37b4:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
    37b8:	991b      	ldr	r1, [sp, #108]	; 0x6c
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37ba:	ea82 0900 	eor.w	r9, r2, r0
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37be:	448a      	add	sl, r1
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37c0:	ea03 0909 	and.w	r9, r3, r9
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37c4:	990b      	ldr	r1, [sp, #44]	; 0x2c
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37c6:	ea89 0900 	eor.w	r9, r9, r0
    37ca:	ea4f 1cb3 	mov.w	ip, r3, ror #6
    37ce:	444c      	add	r4, r9
    37d0:	ea8c 2cf3 	eor.w	ip, ip, r3, ror #11
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37d4:	ea4f 4971 	mov.w	r9, r1, ror #17
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37d8:	ea47 0506 	orr.w	r5, r7, r6
    37dc:	ea4f 08b7 	mov.w	r8, r7, ror #2
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37e0:	ea89 49f1 	eor.w	r9, r9, r1, ror #19
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37e4:	ea8c 6c73 	eor.w	ip, ip, r3, ror #25
    37e8:	44a4      	add	ip, r4
    37ea:	ea05 050b 	and.w	r5, r5, fp
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37ee:	9c0d      	ldr	r4, [sp, #52]	; 0x34
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37f0:	ea88 3877 	eor.w	r8, r8, r7, ror #13
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37f4:	ea89 2991 	eor.w	r9, r9, r1, lsr #10
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37f8:	ea07 0106 	and.w	r1, r7, r6
    37fc:	ea88 58b7 	eor.w	r8, r8, r7, ror #22
    3800:	430d      	orrs	r5, r1
    3802:	4445      	add	r5, r8
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3804:	ea4f 18f4 	mov.w	r8, r4, ror #7
    3808:	ea88 48b4 	eor.w	r8, r8, r4, ror #18
    380c:	ea88 08d4 	eor.w	r8, r8, r4, lsr #3
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3810:	9c09      	ldr	r4, [sp, #36]	; 0x24
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3812:	44d1      	add	r9, sl
    3814:	49eb      	ldr	r1, [pc, #940]	; (3bc4 <sha256_process+0xb90>)
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3816:	4464      	add	r4, ip
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3818:	44c8      	add	r8, r9
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    381a:	4465      	add	r5, ip
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    381c:	4441      	add	r1, r8
    381e:	ea83 0c02 	eor.w	ip, r3, r2
    3822:	ea4f 19b4 	mov.w	r9, r4, ror #6
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3826:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    382a:	ea04 0c0c 	and.w	ip, r4, ip
    382e:	4408      	add	r0, r1
    3830:	ea89 21f4 	eor.w	r1, r9, r4, ror #11
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3834:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3838:	ea8c 0c02 	eor.w	ip, ip, r2
    383c:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3840:	44d1      	add	r9, sl
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3842:	ea45 0807 	orr.w	r8, r5, r7
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3846:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    384a:	ea81 6174 	eor.w	r1, r1, r4, ror #25
    384e:	4460      	add	r0, ip
    3850:	4408      	add	r0, r1
    3852:	ea08 0806 	and.w	r8, r8, r6
    3856:	ea05 0107 	and.w	r1, r5, r7
    385a:	ea4f 0cb5 	mov.w	ip, r5, ror #2
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    385e:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3862:	ea8c 3c75 	eor.w	ip, ip, r5, ror #13
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3866:	ea4f 497a 	mov.w	r9, sl, ror #17
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    386a:	ea48 0801 	orr.w	r8, r8, r1
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    386e:	990e      	ldr	r1, [sp, #56]	; 0x38
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3870:	ea8c 5cb5 	eor.w	ip, ip, r5, ror #22
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3874:	ea89 49fa 	eor.w	r9, r9, sl, ror #19
    3878:	ea89 299a 	eor.w	r9, r9, sl, lsr #10
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    387c:	44e0      	add	r8, ip
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    387e:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    3882:	ea4f 1cf1 	mov.w	ip, r1, ror #7
    3886:	ea8c 4cb1 	eor.w	ip, ip, r1, ror #18
    388a:	44d1      	add	r9, sl
    388c:	ea8c 0cd1 	eor.w	ip, ip, r1, lsr #3
    3890:	49cd      	ldr	r1, [pc, #820]	; (3bc8 <sha256_process+0xb94>)
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3892:	4483      	add	fp, r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3894:	44cc      	add	ip, r9
    3896:	ea84 0903 	eor.w	r9, r4, r3
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    389a:	4480      	add	r8, r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    389c:	4461      	add	r1, ip
    389e:	ea4f 10bb 	mov.w	r0, fp, ror #6
    38a2:	ea0b 0909 	and.w	r9, fp, r9
    38a6:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
    38aa:	ea89 0903 	eor.w	r9, r9, r3
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38ae:	f8dd c058 	ldr.w	ip, [sp, #88]	; 0x58
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38b2:	440a      	add	r2, r1
    38b4:	ea80 21fb 	eor.w	r1, r0, fp, ror #11
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38b8:	980e      	ldr	r0, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38ba:	ea48 0a05 	orr.w	sl, r8, r5
    38be:	ea81 617b 	eor.w	r1, r1, fp, ror #25
    38c2:	444a      	add	r2, r9
    38c4:	ea4f 09b8 	mov.w	r9, r8, ror #2
    38c8:	440a      	add	r2, r1
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38ca:	4484      	add	ip, r0
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38cc:	ea08 0105 	and.w	r1, r8, r5
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38d0:	980f      	ldr	r0, [sp, #60]	; 0x3c
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38d2:	ea0a 0a07 	and.w	sl, sl, r7
    38d6:	ea89 3978 	eor.w	r9, r9, r8, ror #13
    38da:	ea89 59b8 	eor.w	r9, r9, r8, ror #22
    38de:	ea4a 0a01 	orr.w	sl, sl, r1
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38e2:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38e6:	44ca      	add	sl, r9
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38e8:	ea4f 1cf0 	mov.w	ip, r0, ror #7
    38ec:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    38f0:	ea8c 4cb0 	eor.w	ip, ip, r0, ror #18
    38f4:	ea8c 0cd0 	eor.w	ip, ip, r0, lsr #3
    38f8:	ea4f 4179 	mov.w	r1, r9, ror #17
    38fc:	980d      	ldr	r0, [sp, #52]	; 0x34
    38fe:	ea81 41f9 	eor.w	r1, r1, r9, ror #19
    3902:	4484      	add	ip, r0
    3904:	ea81 2199 	eor.w	r1, r1, r9, lsr #10
    3908:	48b0      	ldr	r0, [pc, #704]	; (3bcc <sha256_process+0xb98>)
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    390a:	4416      	add	r6, r2
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    390c:	4461      	add	r1, ip
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    390e:	4492      	add	sl, r2
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3910:	4408      	add	r0, r1
    3912:	ea8b 0204 	eor.w	r2, fp, r4
    3916:	ea4f 1cb6 	mov.w	ip, r6, ror #6
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    391a:	f8dd 905c 	ldr.w	r9, [sp, #92]	; 0x5c
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    391e:	4032      	ands	r2, r6
    3920:	4403      	add	r3, r0
    3922:	ea8c 20f6 	eor.w	r0, ip, r6, ror #11
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3926:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    392a:	4062      	eors	r2, r4
    392c:	910d      	str	r1, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    392e:	44e1      	add	r9, ip
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3930:	ea4a 0108 	orr.w	r1, sl, r8
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3934:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3938:	ea80 6076 	eor.w	r0, r0, r6, ror #25
    393c:	4413      	add	r3, r2
    393e:	4403      	add	r3, r0
    3940:	4029      	ands	r1, r5
    3942:	ea0a 0008 	and.w	r0, sl, r8
    3946:	ea4f 02ba 	mov.w	r2, sl, ror #2
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    394a:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    394e:	ea82 327a 	eor.w	r2, r2, sl, ror #13
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3952:	ea4f 19fc 	mov.w	r9, ip, ror #7
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3956:	4301      	orrs	r1, r0
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3958:	980a      	ldr	r0, [sp, #40]	; 0x28
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    395a:	ea82 52ba 	eor.w	r2, r2, sl, ror #22
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    395e:	ea89 49bc 	eor.w	r9, r9, ip, ror #18
    3962:	ea89 09dc 	eor.w	r9, r9, ip, lsr #3
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3966:	4411      	add	r1, r2
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3968:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
    396c:	ea4f 4270 	mov.w	r2, r0, ror #17
    3970:	ea82 42f0 	eor.w	r2, r2, r0, ror #19
    3974:	44cc      	add	ip, r9
    3976:	ea82 2290 	eor.w	r2, r2, r0, lsr #10
    397a:	4895      	ldr	r0, [pc, #596]	; (3bd0 <sha256_process+0xb9c>)
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    397c:	441f      	add	r7, r3
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    397e:	4462      	add	r2, ip
    3980:	ea86 090b 	eor.w	r9, r6, fp
    3984:	4410      	add	r0, r2
    3986:	ea07 0909 	and.w	r9, r7, r9
    398a:	ea4f 1cb7 	mov.w	ip, r7, ror #6
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    398e:	4419      	add	r1, r3
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3990:	920e      	str	r2, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3992:	9b10      	ldr	r3, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3994:	ea89 090b 	eor.w	r9, r9, fp
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3998:	9a18      	ldr	r2, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    399a:	4420      	add	r0, r4
    399c:	ea8c 2cf7 	eor.w	ip, ip, r7, ror #11
    39a0:	ea41 040a 	orr.w	r4, r1, sl
    39a4:	ea8c 6c77 	eor.w	ip, ip, r7, ror #25
    39a8:	4448      	add	r0, r9
    39aa:	ea4f 09b1 	mov.w	r9, r1, ror #2
    39ae:	4460      	add	r0, ip
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39b0:	441a      	add	r2, r3
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39b2:	ea01 0c0a 	and.w	ip, r1, sl
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39b6:	9b11      	ldr	r3, [sp, #68]	; 0x44
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39b8:	ea04 0408 	and.w	r4, r4, r8
    39bc:	ea89 3971 	eor.w	r9, r9, r1, ror #13
    39c0:	ea89 59b1 	eor.w	r9, r9, r1, ror #22
    39c4:	ea44 040c 	orr.w	r4, r4, ip
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39c8:	920f      	str	r2, [sp, #60]	; 0x3c
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39ca:	444c      	add	r4, r9
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39cc:	ea4f 12f3 	mov.w	r2, r3, ror #7
    39d0:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
    39d4:	ea82 42b3 	eor.w	r2, r2, r3, ror #18
    39d8:	ea82 02d3 	eor.w	r2, r2, r3, lsr #3
    39dc:	ea4f 4c79 	mov.w	ip, r9, ror #17
    39e0:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    39e2:	ea8c 4cf9 	eor.w	ip, ip, r9, ror #19
    39e6:	4413      	add	r3, r2
    39e8:	ea8c 2c99 	eor.w	ip, ip, r9, lsr #10
    39ec:	4a79      	ldr	r2, [pc, #484]	; (3bd4 <sha256_process+0xba0>)
    39ee:	449c      	add	ip, r3
    39f0:	4462      	add	r2, ip
    39f2:	f8cd c03c 	str.w	ip, [sp, #60]	; 0x3c
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39f6:	4405      	add	r5, r0
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    39f8:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39fc:	ea87 0306 	eor.w	r3, r7, r6
    3a00:	4493      	add	fp, r2
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a02:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a04:	402b      	ands	r3, r5
    3a06:	ea4f 1cb5 	mov.w	ip, r5, ror #6
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a0a:	4404      	add	r4, r0
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a0c:	4073      	eors	r3, r6
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a0e:	444a      	add	r2, r9
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a10:	ea8c 2cf5 	eor.w	ip, ip, r5, ror #11
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a14:	9210      	str	r2, [sp, #64]	; 0x40
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a16:	ea44 0001 	orr.w	r0, r4, r1
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a1a:	9a12      	ldr	r2, [sp, #72]	; 0x48
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a1c:	449b      	add	fp, r3
    3a1e:	ea8c 6c75 	eor.w	ip, ip, r5, ror #25
    3a22:	44dc      	add	ip, fp
    3a24:	ea00 000a 	and.w	r0, r0, sl
    3a28:	ea04 0b01 	and.w	fp, r4, r1
    3a2c:	ea4f 09b4 	mov.w	r9, r4, ror #2
    3a30:	ea89 3974 	eor.w	r9, r9, r4, ror #13
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a34:	ea4f 13f2 	mov.w	r3, r2, ror #7
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a38:	ea40 000b 	orr.w	r0, r0, fp
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a3c:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a40:	ea89 59b4 	eor.w	r9, r9, r4, ror #22
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a44:	ea83 43b2 	eor.w	r3, r3, r2, ror #18
    3a48:	ea83 03d2 	eor.w	r3, r3, r2, lsr #3
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a4c:	4448      	add	r0, r9
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a4e:	9a10      	ldr	r2, [sp, #64]	; 0x40
    3a50:	ea4f 497b 	mov.w	r9, fp, ror #17
    3a54:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    3a58:	441a      	add	r2, r3
    3a5a:	ea89 299b 	eor.w	r9, r9, fp, lsr #10
    3a5e:	4b5e      	ldr	r3, [pc, #376]	; (3bd8 <sha256_process+0xba4>)
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a60:	44e0      	add	r8, ip
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a62:	4491      	add	r9, r2
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a64:	4460      	add	r0, ip
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a66:	f8cd 9040 	str.w	r9, [sp, #64]	; 0x40
    3a6a:	ea85 0c07 	eor.w	ip, r5, r7
    3a6e:	444b      	add	r3, r9
    3a70:	ea4f 19b8 	mov.w	r9, r8, ror #6
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a74:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a78:	ea08 0c0c 	and.w	ip, r8, ip
    3a7c:	441e      	add	r6, r3
    3a7e:	ea89 23f8 	eor.w	r3, r9, r8, ror #11
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a82:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a86:	ea8c 0c07 	eor.w	ip, ip, r7
    3a8a:	ea40 0204 	orr.w	r2, r0, r4
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a8e:	44d9      	add	r9, fp
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a90:	ea83 6378 	eor.w	r3, r3, r8, ror #25
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a94:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a98:	4466      	add	r6, ip
    3a9a:	441e      	add	r6, r3
    3a9c:	400a      	ands	r2, r1
    3a9e:	ea00 0304 	and.w	r3, r0, r4
    3aa2:	ea4f 0cb0 	mov.w	ip, r0, ror #2
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3aa6:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3aaa:	ea8c 3c70 	eor.w	ip, ip, r0, ror #13
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3aae:	ea4f 19fb 	mov.w	r9, fp, ror #7
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ab2:	431a      	orrs	r2, r3
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ab4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ab6:	ea8c 5cb0 	eor.w	ip, ip, r0, ror #22
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3aba:	ea89 49bb 	eor.w	r9, r9, fp, ror #18
    3abe:	ea89 09db 	eor.w	r9, r9, fp, lsr #3
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ac2:	4462      	add	r2, ip
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ac4:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
    3ac8:	ea4f 4c73 	mov.w	ip, r3, ror #17
    3acc:	ea8c 4cf3 	eor.w	ip, ip, r3, ror #19
    3ad0:	44cb      	add	fp, r9
    3ad2:	ea8c 2c93 	eor.w	ip, ip, r3, lsr #10
    3ad6:	44dc      	add	ip, fp
    3ad8:	f8cd c044 	str.w	ip, [sp, #68]	; 0x44
    3adc:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    3ae0:	4b3e      	ldr	r3, [pc, #248]	; (3bdc <sha256_process+0xba8>)
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ae2:	4432      	add	r2, r6
    3ae4:	44b2      	add	sl, r6
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ae6:	ea88 0c05 	eor.w	ip, r8, r5
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3aea:	9e1a      	ldr	r6, [sp, #104]	; 0x68
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3aec:	444b      	add	r3, r9
    3aee:	ea0a 0c0c 	and.w	ip, sl, ip
    3af2:	ea8c 0c05 	eor.w	ip, ip, r5
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3af6:	ea4f 1bf6 	mov.w	fp, r6, ror #7
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3afa:	441f      	add	r7, r3
    3afc:	ea4f 19ba 	mov.w	r9, sl, ror #6
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b00:	ea8b 4bb6 	eor.w	fp, fp, r6, ror #18
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b04:	ea89 29fa 	eor.w	r9, r9, sl, ror #11
    3b08:	4467      	add	r7, ip
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b0a:	f8dd c04c 	ldr.w	ip, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b0e:	ea42 0300 	orr.w	r3, r2, r0
    3b12:	ea89 697a 	eor.w	r9, r9, sl, ror #25
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b16:	ea8b 0bd6 	eor.w	fp, fp, r6, lsr #3
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b1a:	ea4f 06b2 	mov.w	r6, r2, ror #2
    3b1e:	444f      	add	r7, r9
    3b20:	4023      	ands	r3, r4
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b22:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    3b26:	44e3      	add	fp, ip
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b28:	ea86 3672 	eor.w	r6, r6, r2, ror #13
    3b2c:	ea02 0c00 	and.w	ip, r2, r0
    3b30:	ea86 56b2 	eor.w	r6, r6, r2, ror #22
    3b34:	ea43 030c 	orr.w	r3, r3, ip
    3b38:	4433      	add	r3, r6
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b3a:	ea4f 4c79 	mov.w	ip, r9, ror #17
    3b3e:	9e09      	ldr	r6, [sp, #36]	; 0x24
    3b40:	ea8c 4cf9 	eor.w	ip, ip, r9, ror #19
    3b44:	44b3      	add	fp, r6
    3b46:	ea8c 2c99 	eor.w	ip, ip, r9, lsr #10
    3b4a:	4e25      	ldr	r6, [pc, #148]	; (3be0 <sha256_process+0xbac>)
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b4c:	443b      	add	r3, r7
    3b4e:	4439      	add	r1, r7
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b50:	44dc      	add	ip, fp
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b52:	9f14      	ldr	r7, [sp, #80]	; 0x50
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b54:	ea8a 0908 	eor.w	r9, sl, r8
    3b58:	4466      	add	r6, ip
    3b5a:	ea01 0909 	and.w	r9, r1, r9
    3b5e:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
    3b62:	4435      	add	r5, r6
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b64:	f8dd c050 	ldr.w	ip, [sp, #80]	; 0x50
    3b68:	ea4f 1bf7 	mov.w	fp, r7, ror #7
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b6c:	ea89 0908 	eor.w	r9, r9, r8
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b70:	ea8b 4bb7 	eor.w	fp, fp, r7, ror #18
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b74:	44a9      	add	r9, r5
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b76:	9d1a      	ldr	r5, [sp, #104]	; 0x68
    3b78:	ea8b 0bdc 	eor.w	fp, fp, ip, lsr #3
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b7c:	ea43 0c02 	orr.w	ip, r3, r2
    3b80:	ea03 0602 	and.w	r6, r3, r2
    3b84:	ea4f 17b1 	mov.w	r7, r1, ror #6
    3b88:	ea0c 0c00 	and.w	ip, ip, r0
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b8c:	445d      	add	r5, fp
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b8e:	ea4f 0bb3 	mov.w	fp, r3, ror #2
    3b92:	ea87 27f1 	eor.w	r7, r7, r1, ror #11
    3b96:	ea8b 3b73 	eor.w	fp, fp, r3, ror #13
    3b9a:	ea4c 0c06 	orr.w	ip, ip, r6
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b9e:	9e11      	ldr	r6, [sp, #68]	; 0x44
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3ba0:	ea87 6771 	eor.w	r7, r7, r1, ror #25
    3ba4:	ea8b 5bb3 	eor.w	fp, fp, r3, ror #22
    3ba8:	44b9      	add	r9, r7
    3baa:	44dc      	add	ip, fp
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bac:	ea4f 4776 	mov.w	r7, r6, ror #17
    3bb0:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    3bb4:	ea87 47f6 	eor.w	r7, r7, r6, ror #19
    3bb8:	445d      	add	r5, fp
    3bba:	ea87 2796 	eor.w	r7, r7, r6, lsr #10
    3bbe:	19ef      	adds	r7, r5, r7
    3bc0:	e010      	b.n	3be4 <sha256_process+0xbb0>
    3bc2:	bf00      	nop
    3bc4:	e49b69c1 	ldr	r6, [fp], #2497	; 0x9c1
    3bc8:	efbe4786 	svc	0x00be4786
    3bcc:	0fc19dc6 	svceq	0x00c19dc6
    3bd0:	240ca1cc 	strcs	sl, [ip], #-460	; 0x1cc
    3bd4:	2de92c6f 	stclcs	12, cr2, [r9, #444]!	; 0x1bc
    3bd8:	4a7484aa 	bmi	1d24e88 <_etext+0x1d1d970>
    3bdc:	5cb0a9dc 	ldcpl	9, cr10, [r0], #880	; 0x370
    3be0:	76f988da 	usatvc	r8, #25, sl, asr #17
    3be4:	9713      	str	r7, [sp, #76]	; 0x4c
    3be6:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
    3bea:	4ee6      	ldr	r6, [pc, #920]	; (3f84 <sha256_process+0xf50>)
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bec:	44cc      	add	ip, r9
    3bee:	444c      	add	r4, r9
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bf0:	ea81 050a 	eor.w	r5, r1, sl
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3bf4:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bf8:	445e      	add	r6, fp
    3bfa:	4025      	ands	r5, r4
    3bfc:	ea85 050a 	eor.w	r5, r5, sl
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c00:	ea4f 17f9 	mov.w	r7, r9, ror #7
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c04:	44b0      	add	r8, r6
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c06:	ea87 47b9 	eor.w	r7, r7, r9, ror #18
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c0a:	ea4f 1bb4 	mov.w	fp, r4, ror #6
    3c0e:	44a8      	add	r8, r5
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c10:	9d14      	ldr	r5, [sp, #80]	; 0x50
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c12:	ea8b 2bf4 	eor.w	fp, fp, r4, ror #11
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c16:	ea87 07d9 	eor.w	r7, r7, r9, lsr #3
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c1a:	ea4c 0603 	orr.w	r6, ip, r3
    3c1e:	ea8b 6b74 	eor.w	fp, fp, r4, ror #25
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c22:	442f      	add	r7, r5
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c24:	ea4f 05bc 	mov.w	r5, ip, ror #2
    3c28:	44d8      	add	r8, fp
    3c2a:	ea0c 0903 	and.w	r9, ip, r3
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c2e:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c32:	4016      	ands	r6, r2
    3c34:	ea85 357c 	eor.w	r5, r5, ip, ror #13
    3c38:	ea85 55bc 	eor.w	r5, r5, ip, ror #22
    3c3c:	ea46 0609 	orr.w	r6, r6, r9
    3c40:	442e      	add	r6, r5
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c42:	ea4f 497b 	mov.w	r9, fp, ror #17
    3c46:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    3c48:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    3c4c:	442f      	add	r7, r5
    3c4e:	ea89 299b 	eor.w	r9, r9, fp, lsr #10
    3c52:	44b9      	add	r9, r7
    3c54:	f8cd 9050 	str.w	r9, [sp, #80]	; 0x50
    3c58:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
    3c5c:	4dca      	ldr	r5, [pc, #808]	; (3f88 <sha256_process+0xf54>)
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c5e:	f8dd 9058 	ldr.w	r9, [sp, #88]	; 0x58
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c62:	4440      	add	r0, r8
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c64:	ea84 0701 	eor.w	r7, r4, r1
    3c68:	445d      	add	r5, fp
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c6a:	4446      	add	r6, r8
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c6c:	44aa      	add	sl, r5
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c6e:	ea4f 18f9 	mov.w	r8, r9, ror #7
    3c72:	9d16      	ldr	r5, [sp, #88]	; 0x58
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c74:	4007      	ands	r7, r0
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c76:	f8dd b054 	ldr.w	fp, [sp, #84]	; 0x54
    3c7a:	ea88 48b9 	eor.w	r8, r8, r9, ror #18
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c7e:	404f      	eors	r7, r1
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c80:	ea88 08d5 	eor.w	r8, r8, r5, lsr #3
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c84:	4457      	add	r7, sl
    3c86:	ea46 0a0c 	orr.w	sl, r6, ip
    3c8a:	ea06 050c 	and.w	r5, r6, ip
    3c8e:	ea4f 19b0 	mov.w	r9, r0, ror #6
    3c92:	ea0a 0a03 	and.w	sl, sl, r3
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c96:	44d8      	add	r8, fp
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c98:	ea4f 0bb6 	mov.w	fp, r6, ror #2
    3c9c:	ea89 29f0 	eor.w	r9, r9, r0, ror #11
    3ca0:	ea8b 3b76 	eor.w	fp, fp, r6, ror #13
    3ca4:	ea4a 0a05 	orr.w	sl, sl, r5
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3ca8:	9d13      	ldr	r5, [sp, #76]	; 0x4c
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3caa:	ea89 6970 	eor.w	r9, r9, r0, ror #25
    3cae:	ea8b 5bb6 	eor.w	fp, fp, r6, ror #22
    3cb2:	444f      	add	r7, r9
    3cb4:	44da      	add	sl, fp
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cb6:	ea4f 4975 	mov.w	r9, r5, ror #17
    3cba:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    3cbe:	ea89 49f5 	eor.w	r9, r9, r5, ror #19
    3cc2:	44d8      	add	r8, fp
    3cc4:	ea89 2995 	eor.w	r9, r9, r5, lsr #10
    3cc8:	44c1      	add	r9, r8
    3cca:	f8cd 9054 	str.w	r9, [sp, #84]	; 0x54
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cce:	44ba      	add	sl, r7
    3cd0:	443a      	add	r2, r7
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cd2:	4dae      	ldr	r5, [pc, #696]	; (3f8c <sha256_process+0xf58>)
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3cd4:	9f17      	ldr	r7, [sp, #92]	; 0x5c
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cd6:	ea80 0804 	eor.w	r8, r0, r4
    3cda:	444d      	add	r5, r9
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3cdc:	ea4f 1bf7 	mov.w	fp, r7, ror #7
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3ce0:	ea02 0808 	and.w	r8, r2, r8
    3ce4:	4429      	add	r1, r5
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3ce6:	ea8b 4bb7 	eor.w	fp, fp, r7, ror #18
    3cea:	9d16      	ldr	r5, [sp, #88]	; 0x58
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cec:	ea88 0804 	eor.w	r8, r8, r4
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3cf0:	ea8b 0bd7 	eor.w	fp, fp, r7, lsr #3
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cf4:	4488      	add	r8, r1
    3cf6:	ea4a 0106 	orr.w	r1, sl, r6
    3cfa:	ea4f 19b2 	mov.w	r9, r2, ror #6
    3cfe:	ea01 010c 	and.w	r1, r1, ip
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d02:	44ab      	add	fp, r5
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d04:	ea4f 07ba 	mov.w	r7, sl, ror #2
    3d08:	ea0a 0506 	and.w	r5, sl, r6
    3d0c:	ea89 29f2 	eor.w	r9, r9, r2, ror #11
    3d10:	ea87 377a 	eor.w	r7, r7, sl, ror #13
    3d14:	4329      	orrs	r1, r5
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d16:	9d14      	ldr	r5, [sp, #80]	; 0x50
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d18:	ea89 6972 	eor.w	r9, r9, r2, ror #25
    3d1c:	ea87 57ba 	eor.w	r7, r7, sl, ror #22
    3d20:	44c8      	add	r8, r9
    3d22:	4439      	add	r1, r7
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d24:	ea4f 4975 	mov.w	r9, r5, ror #17
    3d28:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    3d2a:	ea89 49f5 	eor.w	r9, r9, r5, ror #19
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d2e:	4441      	add	r1, r8
    3d30:	4443      	add	r3, r8
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d32:	44bb      	add	fp, r7
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d34:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d38:	ea89 2995 	eor.w	r9, r9, r5, lsr #10
    3d3c:	4f94      	ldr	r7, [pc, #592]	; (3f90 <sha256_process+0xf5c>)
    3d3e:	44d9      	add	r9, fp
    3d40:	f8cd 9058 	str.w	r9, [sp, #88]	; 0x58
    3d44:	ea82 0500 	eor.w	r5, r2, r0
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d48:	ea4f 1bf8 	mov.w	fp, r8, ror #7
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d4c:	444f      	add	r7, r9
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d4e:	f8dd 9060 	ldr.w	r9, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d52:	401d      	ands	r5, r3
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d54:	ea8b 4bb8 	eor.w	fp, fp, r8, ror #18
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d58:	4427      	add	r7, r4
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d5a:	9c17      	ldr	r4, [sp, #92]	; 0x5c
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d5c:	4045      	eors	r5, r0
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d5e:	ea8b 0bd9 	eor.w	fp, fp, r9, lsr #3
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d62:	ea41 090a 	orr.w	r9, r1, sl
    3d66:	ea4f 18b3 	mov.w	r8, r3, ror #6
    3d6a:	442f      	add	r7, r5
    3d6c:	ea09 0906 	and.w	r9, r9, r6
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d70:	44a3      	add	fp, r4
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d72:	ea4f 05b1 	mov.w	r5, r1, ror #2
    3d76:	ea01 040a 	and.w	r4, r1, sl
    3d7a:	ea88 28f3 	eor.w	r8, r8, r3, ror #11
    3d7e:	ea85 3571 	eor.w	r5, r5, r1, ror #13
    3d82:	ea49 0904 	orr.w	r9, r9, r4
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d86:	9c15      	ldr	r4, [sp, #84]	; 0x54
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d88:	ea88 6873 	eor.w	r8, r8, r3, ror #25
    3d8c:	ea85 55b1 	eor.w	r5, r5, r1, ror #22
    3d90:	4447      	add	r7, r8
    3d92:	44a9      	add	r9, r5
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d94:	ea4f 4874 	mov.w	r8, r4, ror #17
    3d98:	9d10      	ldr	r5, [sp, #64]	; 0x40
    3d9a:	ea88 48f4 	eor.w	r8, r8, r4, ror #19
    3d9e:	44ab      	add	fp, r5
    3da0:	ea88 2894 	eor.w	r8, r8, r4, lsr #10
    3da4:	44d8      	add	r8, fp
    3da6:	f8cd 805c 	str.w	r8, [sp, #92]	; 0x5c
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3daa:	eb07 040c 	add.w	r4, r7, ip
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3dae:	4d79      	ldr	r5, [pc, #484]	; (3f94 <sha256_process+0xf60>)
    3db0:	f8dd c05c 	ldr.w	ip, [sp, #92]	; 0x5c
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3db4:	44b9      	add	r9, r7
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3db6:	ea83 0b02 	eor.w	fp, r3, r2
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3dba:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3dbc:	4465      	add	r5, ip
    3dbe:	ea04 0b0b 	and.w	fp, r4, fp
    3dc2:	ea8b 0b02 	eor.w	fp, fp, r2
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3dc6:	ea4f 18f7 	mov.w	r8, r7, ror #7
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3dca:	4428      	add	r0, r5
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3dcc:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    3dce:	ea88 48b7 	eor.w	r8, r8, r7, ror #18
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3dd2:	4458      	add	r0, fp
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3dd4:	f8dd b060 	ldr.w	fp, [sp, #96]	; 0x60
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3dd8:	ea49 0c01 	orr.w	ip, r9, r1
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3ddc:	ea88 08d5 	eor.w	r8, r8, r5, lsr #3
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3de0:	ea4f 17b4 	mov.w	r7, r4, ror #6
    3de4:	ea09 0501 	and.w	r5, r9, r1
    3de8:	ea0c 0c0a 	and.w	ip, ip, sl
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3dec:	44d8      	add	r8, fp
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3dee:	ea4f 0bb9 	mov.w	fp, r9, ror #2
    3df2:	ea87 27f4 	eor.w	r7, r7, r4, ror #11
    3df6:	ea8b 3b79 	eor.w	fp, fp, r9, ror #13
    3dfa:	ea4c 0c05 	orr.w	ip, ip, r5
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3dfe:	9d16      	ldr	r5, [sp, #88]	; 0x58
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e00:	ea87 6774 	eor.w	r7, r7, r4, ror #25
    3e04:	ea8b 5bb9 	eor.w	fp, fp, r9, ror #22
    3e08:	4438      	add	r0, r7
    3e0a:	44dc      	add	ip, fp
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e0c:	ea4f 4775 	mov.w	r7, r5, ror #17
    3e10:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
    3e14:	ea87 47f5 	eor.w	r7, r7, r5, ror #19
    3e18:	44d8      	add	r8, fp
    3e1a:	ea87 2795 	eor.w	r7, r7, r5, lsr #10
    3e1e:	4d5e      	ldr	r5, [pc, #376]	; (3f98 <sha256_process+0xf64>)
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e20:	eb00 0b06 	add.w	fp, r0, r6
    3e24:	4484      	add	ip, r0
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e26:	4447      	add	r7, r8
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e28:	980c      	ldr	r0, [sp, #48]	; 0x30
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e2a:	ea84 0603 	eor.w	r6, r4, r3
    3e2e:	443d      	add	r5, r7
    3e30:	ea0b 0606 	and.w	r6, fp, r6
    3e34:	405e      	eors	r6, r3
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e36:	ea4f 18f0 	mov.w	r8, r0, ror #7
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e3a:	442a      	add	r2, r5
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e3c:	ea88 48b0 	eor.w	r8, r8, r0, ror #18
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e40:	4432      	add	r2, r6
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e42:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    3e44:	ea88 05d0 	eor.w	r5, r8, r0, lsr #3
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e48:	ea4c 0809 	orr.w	r8, ip, r9
    3e4c:	9718      	str	r7, [sp, #96]	; 0x60
    3e4e:	ea08 0801 	and.w	r8, r8, r1
    3e52:	ea0c 0009 	and.w	r0, ip, r9
    3e56:	ea4f 17bb 	mov.w	r7, fp, ror #6
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e5a:	4435      	add	r5, r6
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e5c:	ea4f 06bc 	mov.w	r6, ip, ror #2
    3e60:	ea87 27fb 	eor.w	r7, r7, fp, ror #11
    3e64:	ea86 367c 	eor.w	r6, r6, ip, ror #13
    3e68:	ea48 0000 	orr.w	r0, r8, r0
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e6c:	f8dd 805c 	ldr.w	r8, [sp, #92]	; 0x5c
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e70:	ea87 677b 	eor.w	r7, r7, fp, ror #25
    3e74:	ea86 56bc 	eor.w	r6, r6, ip, ror #22
    3e78:	443a      	add	r2, r7
    3e7a:	4430      	add	r0, r6
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e7c:	ea4f 4778 	mov.w	r7, r8, ror #17
    3e80:	9e12      	ldr	r6, [sp, #72]	; 0x48
    3e82:	ea87 47f8 	eor.w	r7, r7, r8, ror #19
    3e86:	4435      	add	r5, r6
    3e88:	ea87 2898 	eor.w	r8, r7, r8, lsr #10
    3e8c:	4e43      	ldr	r6, [pc, #268]	; (3f9c <sha256_process+0xf68>)
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e8e:	4492      	add	sl, r2
    3e90:	4410      	add	r0, r2
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3e92:	9f09      	ldr	r7, [sp, #36]	; 0x24
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e94:	44a8      	add	r8, r5
    3e96:	ea8b 0204 	eor.w	r2, fp, r4
    3e9a:	4446      	add	r6, r8
    3e9c:	ea0a 0202 	and.w	r2, sl, r2
    3ea0:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
    3ea4:	4062      	eors	r2, r4
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3ea6:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    3eaa:	ea4f 15f7 	mov.w	r5, r7, ror #7
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3eae:	4433      	add	r3, r6
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3eb0:	ea85 45b7 	eor.w	r5, r5, r7, ror #18
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3eb4:	4413      	add	r3, r2
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3eb6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    3eb8:	ea85 05d8 	eor.w	r5, r5, r8, lsr #3
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ebc:	ea40 080c 	orr.w	r8, r0, ip
    3ec0:	ea08 0809 	and.w	r8, r8, r9
    3ec4:	ea00 060c 	and.w	r6, r0, ip
    3ec8:	ea4f 17ba 	mov.w	r7, sl, ror #6
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3ecc:	4415      	add	r5, r2
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ece:	ea4f 02b0 	mov.w	r2, r0, ror #2
    3ed2:	ea87 27fa 	eor.w	r7, r7, sl, ror #11
    3ed6:	ea82 3270 	eor.w	r2, r2, r0, ror #13
    3eda:	ea48 0606 	orr.w	r6, r8, r6
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3ede:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ee2:	ea87 677a 	eor.w	r7, r7, sl, ror #25
    3ee6:	ea82 52b0 	eor.w	r2, r2, r0, ror #22
    3eea:	443b      	add	r3, r7
    3eec:	4416      	add	r6, r2
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3eee:	ea4f 4778 	mov.w	r7, r8, ror #17
    3ef2:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    3ef4:	ea87 47f8 	eor.w	r7, r7, r8, ror #19
    3ef8:	4415      	add	r5, r2
    3efa:	ea87 2798 	eor.w	r7, r7, r8, lsr #10
    3efe:	4a28      	ldr	r2, [pc, #160]	; (3fa0 <sha256_process+0xf6c>)
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f00:	4419      	add	r1, r3
    3f02:	441e      	add	r6, r3
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f04:	19ef      	adds	r7, r5, r7
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f06:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f08:	ea8a 050b 	eor.w	r5, sl, fp
    3f0c:	443a      	add	r2, r7
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f0e:	ea4f 18f3 	mov.w	r8, r3, ror #7
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f12:	400d      	ands	r5, r1
    3f14:	4422      	add	r2, r4
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f16:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f18:	970c      	str	r7, [sp, #48]	; 0x30
    3f1a:	ea85 050b 	eor.w	r5, r5, fp
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f1e:	9f09      	ldr	r7, [sp, #36]	; 0x24
    3f20:	ea88 48b3 	eor.w	r8, r8, r3, ror #18
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f24:	ea4f 13b1 	mov.w	r3, r1, ror #6
    3f28:	ea83 23f1 	eor.w	r3, r3, r1, ror #11
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f2c:	ea88 08d4 	eor.w	r8, r8, r4, lsr #3
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f30:	442a      	add	r2, r5
    3f32:	ea46 0500 	orr.w	r5, r6, r0
    3f36:	ea83 6471 	eor.w	r4, r3, r1, ror #25
    3f3a:	ea05 050c 	and.w	r5, r5, ip
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f3e:	44b8      	add	r8, r7
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f40:	ea4f 03b6 	mov.w	r3, r6, ror #2
    3f44:	ea06 0700 	and.w	r7, r6, r0
    3f48:	ea83 3376 	eor.w	r3, r3, r6, ror #13
    3f4c:	432f      	orrs	r7, r5
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f4e:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f50:	ea83 53b6 	eor.w	r3, r3, r6, ror #22
    3f54:	4422      	add	r2, r4
    3f56:	441f      	add	r7, r3
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f58:	ea4f 4475 	mov.w	r4, r5, ror #17
    3f5c:	9b14      	ldr	r3, [sp, #80]	; 0x50
    3f5e:	ea84 44f5 	eor.w	r4, r4, r5, ror #19
    3f62:	4498      	add	r8, r3
    3f64:	ea84 2495 	eor.w	r4, r4, r5, lsr #10
    3f68:	4444      	add	r4, r8
    3f6a:	9409      	str	r4, [sp, #36]	; 0x24
    3f6c:	4b0d      	ldr	r3, [pc, #52]	; (3fa4 <sha256_process+0xf70>)
    3f6e:	9d09      	ldr	r5, [sp, #36]	; 0x24
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f70:	4417      	add	r7, r2
    3f72:	4491      	add	r9, r2
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3f74:	9c0d      	ldr	r4, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f76:	ea81 020a 	eor.w	r2, r1, sl
    3f7a:	442b      	add	r3, r5
    3f7c:	ea09 0202 	and.w	r2, r9, r2
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3f80:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    3f82:	e011      	b.n	3fa8 <sha256_process+0xf74>
    3f84:	983e5152 	ldmdals	lr!, {r1, r4, r6, r8, ip, lr}
    3f88:	a831c66d 	ldmdage	r1!, {r0, r2, r3, r5, r6, r9, sl, lr, pc}
    3f8c:	b00327c8 	andlt	r2, r3, r8, asr #15
    3f90:	bf597fc7 	svclt	0x00597fc7
    3f94:	c6e00bf3 			; <UNDEFINED> instruction: 0xc6e00bf3
    3f98:	d5a79147 	strle	r9, [r7, #327]!	; 0x147
    3f9c:	06ca6351 			; <UNDEFINED> instruction: 0x06ca6351
    3fa0:	14292967 	strtne	r2, [r9], #-2407	; 0x967
    3fa4:	27b70a85 	ldrcs	r0, [r7, r5, lsl #21]!
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fa8:	ea82 020a 	eor.w	r2, r2, sl
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3fac:	ea4f 18f4 	mov.w	r8, r4, ror #7
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fb0:	445b      	add	r3, fp
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3fb2:	ea88 48b4 	eor.w	r8, r8, r4, ror #18
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fb6:	4413      	add	r3, r2
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3fb8:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    3fba:	ea88 0bd5 	eor.w	fp, r8, r5, lsr #3
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fbe:	ea47 0806 	orr.w	r8, r7, r6
    3fc2:	ea08 0800 	and.w	r8, r8, r0
    3fc6:	ea07 0506 	and.w	r5, r7, r6
    3fca:	ea4f 14b9 	mov.w	r4, r9, ror #6
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3fce:	4493      	add	fp, r2
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fd0:	ea4f 02b7 	mov.w	r2, r7, ror #2
    3fd4:	ea84 24f9 	eor.w	r4, r4, r9, ror #11
    3fd8:	ea82 3277 	eor.w	r2, r2, r7, ror #13
    3fdc:	ea48 0505 	orr.w	r5, r8, r5
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3fe0:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fe4:	ea84 6479 	eor.w	r4, r4, r9, ror #25
    3fe8:	ea82 52b7 	eor.w	r2, r2, r7, ror #22
    3fec:	4423      	add	r3, r4
    3fee:	4415      	add	r5, r2
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3ff0:	ea4f 4478 	mov.w	r4, r8, ror #17
    3ff4:	9a15      	ldr	r2, [sp, #84]	; 0x54
    3ff6:	ea84 44f8 	eor.w	r4, r4, r8, ror #19
    3ffa:	4493      	add	fp, r2
    3ffc:	ea84 2498 	eor.w	r4, r4, r8, lsr #10
    4000:	445c      	add	r4, fp
    4002:	940a      	str	r4, [sp, #40]	; 0x28
    4004:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4008:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    400a:	4af1      	ldr	r2, [pc, #964]	; (43d0 <sha256_process+0x139c>)
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    400c:	449c      	add	ip, r3
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    400e:	ea89 0b01 	eor.w	fp, r9, r1
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4012:	441d      	add	r5, r3
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4014:	4442      	add	r2, r8
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4016:	ea4f 13f4 	mov.w	r3, r4, ror #7
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    401a:	ea0c 0b0b 	and.w	fp, ip, fp
    401e:	ea8b 0b01 	eor.w	fp, fp, r1
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4022:	ea83 43b4 	eor.w	r3, r3, r4, ror #18
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4026:	4452      	add	r2, sl
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4028:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    402c:	ea83 03d4 	eor.w	r3, r3, r4, lsr #3
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4030:	445a      	add	r2, fp
    4032:	ea45 0b07 	orr.w	fp, r5, r7
    4036:	ea0b 0b06 	and.w	fp, fp, r6
    403a:	ea05 0407 	and.w	r4, r5, r7
    403e:	ea4f 18bc 	mov.w	r8, ip, ror #6
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4042:	449a      	add	sl, r3
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4044:	ea4f 03b5 	mov.w	r3, r5, ror #2
    4048:	ea88 28fc 	eor.w	r8, r8, ip, ror #11
    404c:	ea83 3375 	eor.w	r3, r3, r5, ror #13
    4050:	ea4b 0404 	orr.w	r4, fp, r4
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4054:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4058:	ea88 687c 	eor.w	r8, r8, ip, ror #25
    405c:	ea83 53b5 	eor.w	r3, r3, r5, ror #22
    4060:	4442      	add	r2, r8
    4062:	441c      	add	r4, r3
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4064:	ea4f 487b 	mov.w	r8, fp, ror #17
    4068:	9b16      	ldr	r3, [sp, #88]	; 0x58
    406a:	ea88 48fb 	eor.w	r8, r8, fp, ror #19
    406e:	449a      	add	sl, r3
    4070:	ea88 289b 	eor.w	r8, r8, fp, lsr #10
    4074:	44d0      	add	r8, sl
    4076:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    407a:	4410      	add	r0, r2
    407c:	4414      	add	r4, r2
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    407e:	4bd5      	ldr	r3, [pc, #852]	; (43d4 <sha256_process+0x13a0>)
    4080:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4082:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4086:	ea8c 0b09 	eor.w	fp, ip, r9
    408a:	4413      	add	r3, r2
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    408c:	ea4f 1af8 	mov.w	sl, r8, ror #7
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4090:	ea00 0b0b 	and.w	fp, r0, fp
    4094:	440b      	add	r3, r1
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4096:	990f      	ldr	r1, [sp, #60]	; 0x3c
    4098:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    409a:	ea8b 0b09 	eor.w	fp, fp, r9
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    409e:	ea8a 4ab8 	eor.w	sl, sl, r8, ror #18
    40a2:	ea8a 0ad1 	eor.w	sl, sl, r1, lsr #3
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40a6:	445b      	add	r3, fp
    40a8:	ea44 0b05 	orr.w	fp, r4, r5
    40ac:	ea0b 0b07 	and.w	fp, fp, r7
    40b0:	ea04 0105 	and.w	r1, r4, r5
    40b4:	ea4f 18b0 	mov.w	r8, r0, ror #6
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40b8:	4492      	add	sl, r2
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40ba:	ea4f 02b4 	mov.w	r2, r4, ror #2
    40be:	ea88 28f0 	eor.w	r8, r8, r0, ror #11
    40c2:	ea82 3274 	eor.w	r2, r2, r4, ror #13
    40c6:	ea4b 0101 	orr.w	r1, fp, r1
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40ca:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40ce:	ea88 6870 	eor.w	r8, r8, r0, ror #25
    40d2:	ea82 52b4 	eor.w	r2, r2, r4, ror #22
    40d6:	4443      	add	r3, r8
    40d8:	4411      	add	r1, r2
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40da:	ea4f 487b 	mov.w	r8, fp, ror #17
    40de:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    40e0:	ea88 48fb 	eor.w	r8, r8, fp, ror #19
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40e4:	441e      	add	r6, r3
    40e6:	4419      	add	r1, r3
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40e8:	4492      	add	sl, r2
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    40ea:	9b10      	ldr	r3, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40ec:	ea88 289b 	eor.w	r8, r8, fp, lsr #10
    40f0:	4ab9      	ldr	r2, [pc, #740]	; (43d8 <sha256_process+0x13a4>)
    40f2:	44d0      	add	r8, sl
    40f4:	ea80 0b0c 	eor.w	fp, r0, ip
    40f8:	4442      	add	r2, r8
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    40fa:	ea4f 1af3 	mov.w	sl, r3, ror #7
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40fe:	ea06 0b0b 	and.w	fp, r6, fp
    4102:	ea8b 0b0c 	eor.w	fp, fp, ip
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4106:	ea8a 4ab3 	eor.w	sl, sl, r3, ror #18
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    410a:	4491      	add	r9, r2
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    410c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    410e:	ea8a 0ad3 	eor.w	sl, sl, r3, lsr #3
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4112:	44d9      	add	r9, fp
    4114:	ea41 0b04 	orr.w	fp, r1, r4
    4118:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    411c:	ea0b 0b05 	and.w	fp, fp, r5
    4120:	ea4f 18b6 	mov.w	r8, r6, ror #6
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4124:	4492      	add	sl, r2
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4126:	ea4f 03b1 	mov.w	r3, r1, ror #2
    412a:	ea01 0204 	and.w	r2, r1, r4
    412e:	ea88 28f6 	eor.w	r8, r8, r6, ror #11
    4132:	ea83 3371 	eor.w	r3, r3, r1, ror #13
    4136:	ea4b 0202 	orr.w	r2, fp, r2
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    413a:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    413e:	ea88 6876 	eor.w	r8, r8, r6, ror #25
    4142:	ea83 53b1 	eor.w	r3, r3, r1, ror #22
    4146:	44c1      	add	r9, r8
    4148:	441a      	add	r2, r3
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    414a:	ea4f 487b 	mov.w	r8, fp, ror #17
    414e:	9b18      	ldr	r3, [sp, #96]	; 0x60
    4150:	ea88 48fb 	eor.w	r8, r8, fp, ror #19
    4154:	449a      	add	sl, r3
    4156:	ea88 289b 	eor.w	r8, r8, fp, lsr #10
    415a:	44d0      	add	r8, sl
    415c:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
    4160:	f8dd b03c 	ldr.w	fp, [sp, #60]	; 0x3c
    4164:	4b9d      	ldr	r3, [pc, #628]	; (43dc <sha256_process+0x13a8>)
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4166:	444a      	add	r2, r9
    4168:	444f      	add	r7, r9
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    416a:	ea86 0800 	eor.w	r8, r6, r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    416e:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4172:	445b      	add	r3, fp
    4174:	ea07 0808 	and.w	r8, r7, r8
    4178:	ea88 0800 	eor.w	r8, r8, r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    417c:	ea4f 1af9 	mov.w	sl, r9, ror #7
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4180:	449c      	add	ip, r3
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4182:	9b11      	ldr	r3, [sp, #68]	; 0x44
    4184:	ea8a 4ab9 	eor.w	sl, sl, r9, ror #18
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4188:	44c4      	add	ip, r8
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    418a:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    418e:	ea42 0b01 	orr.w	fp, r2, r1
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4192:	ea8a 0ad3 	eor.w	sl, sl, r3, lsr #3
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4196:	ea0b 0b04 	and.w	fp, fp, r4
    419a:	ea02 0301 	and.w	r3, r2, r1
    419e:	ea4f 19b7 	mov.w	r9, r7, ror #6
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41a2:	44c2      	add	sl, r8
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41a4:	ea4f 08b2 	mov.w	r8, r2, ror #2
    41a8:	ea89 29f7 	eor.w	r9, r9, r7, ror #11
    41ac:	ea88 3872 	eor.w	r8, r8, r2, ror #13
    41b0:	ea4b 0303 	orr.w	r3, fp, r3
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41b4:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41b8:	ea89 6977 	eor.w	r9, r9, r7, ror #25
    41bc:	ea88 58b2 	eor.w	r8, r8, r2, ror #22
    41c0:	44cc      	add	ip, r9
    41c2:	4443      	add	r3, r8
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41c4:	ea4f 497b 	mov.w	r9, fp, ror #17
    41c8:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
    41cc:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    41d0:	44c2      	add	sl, r8
    41d2:	ea89 2b9b 	eor.w	fp, r9, fp, lsr #10
    41d6:	44d3      	add	fp, sl
    41d8:	f8df 820c 	ldr.w	r8, [pc, #524]	; 43e8 <sha256_process+0x13b4>
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    41dc:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41e0:	4465      	add	r5, ip
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41e2:	ea87 0906 	eor.w	r9, r7, r6
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41e6:	4463      	add	r3, ip
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41e8:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    41ec:	ea4f 1cfa 	mov.w	ip, sl, ror #7
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41f0:	44d8      	add	r8, fp
    41f2:	ea05 0909 	and.w	r9, r5, r9
    41f6:	ea4f 1bb5 	mov.w	fp, r5, ror #6
    41fa:	ea89 0906 	eor.w	r9, r9, r6
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    41fe:	ea8c 4cba 	eor.w	ip, ip, sl, ror #18
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4202:	4480      	add	r8, r0
    4204:	ea8b 2bf5 	eor.w	fp, fp, r5, ror #11
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4208:	9811      	ldr	r0, [sp, #68]	; 0x44
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    420a:	ea8b 6b75 	eor.w	fp, fp, r5, ror #25
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    420e:	ea8c 0cda 	eor.w	ip, ip, sl, lsr #3
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4212:	44c8      	add	r8, r9
    4214:	ea43 0a02 	orr.w	sl, r3, r2
    4218:	ea4f 09b3 	mov.w	r9, r3, ror #2
    421c:	44d8      	add	r8, fp
    421e:	ea0a 0a01 	and.w	sl, sl, r1
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4222:	f8dd b03c 	ldr.w	fp, [sp, #60]	; 0x3c
    4226:	4484      	add	ip, r0
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4228:	ea89 3973 	eor.w	r9, r9, r3, ror #13
    422c:	ea03 0002 	and.w	r0, r3, r2
    4230:	ea89 59b3 	eor.w	r9, r9, r3, ror #22
    4234:	ea4a 0000 	orr.w	r0, sl, r0
    4238:	4448      	add	r0, r9
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    423a:	ea4f 4a7b 	mov.w	sl, fp, ror #17
    423e:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
    4242:	ea8a 4afb 	eor.w	sl, sl, fp, ror #19
    4246:	44cc      	add	ip, r9
    4248:	ea8a 2a9b 	eor.w	sl, sl, fp, lsr #10
    424c:	44e2      	add	sl, ip
    424e:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
    4252:	f8df 9198 	ldr.w	r9, [pc, #408]	; 43ec <sha256_process+0x13b8>
    4256:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    425a:	4440      	add	r0, r8
    425c:	4444      	add	r4, r8
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    425e:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4262:	ea85 0807 	eor.w	r8, r5, r7
    4266:	44d9      	add	r9, fp
    4268:	ea04 0808 	and.w	r8, r4, r8
    426c:	ea88 0807 	eor.w	r8, r8, r7
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4270:	ea4f 1cfa 	mov.w	ip, sl, ror #7
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4274:	44b1      	add	r9, r6
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4276:	9e13      	ldr	r6, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4278:	44c1      	add	r9, r8
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    427a:	ea8c 4cba 	eor.w	ip, ip, sl, ror #18
    427e:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4282:	ea40 0b03 	orr.w	fp, r0, r3
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4286:	ea8c 0cd6 	eor.w	ip, ip, r6, lsr #3
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    428a:	ea0b 0b02 	and.w	fp, fp, r2
    428e:	ea00 0603 	and.w	r6, r0, r3
    4292:	ea4f 1ab4 	mov.w	sl, r4, ror #6
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4296:	44c4      	add	ip, r8
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4298:	ea4f 08b0 	mov.w	r8, r0, ror #2
    429c:	ea8a 2af4 	eor.w	sl, sl, r4, ror #11
    42a0:	ea88 3870 	eor.w	r8, r8, r0, ror #13
    42a4:	ea4b 0606 	orr.w	r6, fp, r6
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42a8:	f8dd b040 	ldr.w	fp, [sp, #64]	; 0x40
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42ac:	ea88 58b0 	eor.w	r8, r8, r0, ror #22
    42b0:	ea8a 6a74 	eor.w	sl, sl, r4, ror #25
    42b4:	44ca      	add	sl, r9
    42b6:	4446      	add	r6, r8
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42b8:	ea4f 497b 	mov.w	r9, fp, ror #17
    42bc:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    42c0:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    42c4:	44c4      	add	ip, r8
    42c6:	ea89 299b 	eor.w	r9, r9, fp, lsr #10
    42ca:	44e1      	add	r9, ip
    42cc:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    42d0:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42d4:	f8dd c048 	ldr.w	ip, [sp, #72]	; 0x48
    42d8:	f8df 8114 	ldr.w	r8, [pc, #276]	; 43f0 <sha256_process+0x13bc>
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42dc:	4451      	add	r1, sl
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42de:	ea84 0905 	eor.w	r9, r4, r5
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42e2:	4456      	add	r6, sl
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42e4:	44e0      	add	r8, ip
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    42e6:	ea4f 1afb 	mov.w	sl, fp, ror #7
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42ea:	ea01 0909 	and.w	r9, r1, r9
    42ee:	ea89 0905 	eor.w	r9, r9, r5
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    42f2:	ea8a 4abb 	eor.w	sl, sl, fp, ror #18
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42f6:	4447      	add	r7, r8
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    42f8:	f8dd 804c 	ldr.w	r8, [sp, #76]	; 0x4c
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42fc:	444f      	add	r7, r9
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    42fe:	ea8a 0adb 	eor.w	sl, sl, fp, lsr #3
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4302:	ea46 0900 	orr.w	r9, r6, r0
    4306:	ea09 0903 	and.w	r9, r9, r3
    430a:	ea4f 1cb1 	mov.w	ip, r1, ror #6
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    430e:	44c2      	add	sl, r8
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4310:	ea4f 0bb6 	mov.w	fp, r6, ror #2
    4314:	ea06 0800 	and.w	r8, r6, r0
    4318:	ea8c 2cf1 	eor.w	ip, ip, r1, ror #11
    431c:	ea8b 3b76 	eor.w	fp, fp, r6, ror #13
    4320:	ea49 0808 	orr.w	r8, r9, r8
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4324:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4328:	ea8b 5bb6 	eor.w	fp, fp, r6, ror #22
    432c:	ea8c 6c71 	eor.w	ip, ip, r1, ror #25
    4330:	44bc      	add	ip, r7
    4332:	44d8      	add	r8, fp
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4334:	ea4f 4779 	mov.w	r7, r9, ror #17
    4338:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    433c:	ea87 47f9 	eor.w	r7, r7, r9, ror #19
    4340:	44da      	add	sl, fp
    4342:	ea87 2999 	eor.w	r9, r7, r9, lsr #10
    4346:	44d1      	add	r9, sl
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4348:	4462      	add	r2, ip
    434a:	44e0      	add	r8, ip
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    434c:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4350:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4354:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
    4358:	4f21      	ldr	r7, [pc, #132]	; (43e0 <sha256_process+0x13ac>)
    435a:	ea81 0b04 	eor.w	fp, r1, r4
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    435e:	ea4f 19fc 	mov.w	r9, ip, ror #7
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4362:	4457      	add	r7, sl
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4364:	ea89 49bc 	eor.w	r9, r9, ip, ror #18
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4368:	ea02 0b0b 	and.w	fp, r2, fp
    436c:	ea8b 0b04 	eor.w	fp, fp, r4
    4370:	443d      	add	r5, r7
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4372:	ea89 07dc 	eor.w	r7, r9, ip, lsr #3
    4376:	f8dd c050 	ldr.w	ip, [sp, #80]	; 0x50
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    437a:	445d      	add	r5, fp
    437c:	ea48 0b06 	orr.w	fp, r8, r6
    4380:	ea0b 0b00 	and.w	fp, fp, r0
    4384:	ea4f 1ab2 	mov.w	sl, r2, ror #6
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4388:	4467      	add	r7, ip
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    438a:	ea08 0c06 	and.w	ip, r8, r6
    438e:	ea8a 2af2 	eor.w	sl, sl, r2, ror #11
    4392:	ea4b 0c0c 	orr.w	ip, fp, ip
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4396:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    439a:	ea8a 6a72 	eor.w	sl, sl, r2, ror #25
    439e:	44aa      	add	sl, r5
    43a0:	ea4f 09b8 	mov.w	r9, r8, ror #2
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43a4:	ea4f 457b 	mov.w	r5, fp, ror #17
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43a8:	ea89 3978 	eor.w	r9, r9, r8, ror #13
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43ac:	ea85 45fb 	eor.w	r5, r5, fp, ror #19
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43b0:	ea89 59b8 	eor.w	r9, r9, r8, ror #22
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43b4:	ea85 2b9b 	eor.w	fp, r5, fp, lsr #10
    43b8:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43ba:	44cc      	add	ip, r9
    43bc:	44d4      	add	ip, sl
    43be:	4453      	add	r3, sl
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43c0:	442f      	add	r7, r5
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    43c2:	f8dd a058 	ldr.w	sl, [sp, #88]	; 0x58
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43c6:	4d07      	ldr	r5, [pc, #28]	; (43e4 <sha256_process+0x13b0>)
    43c8:	44bb      	add	fp, r7
    43ca:	f8cd b050 	str.w	fp, [sp, #80]	; 0x50
    43ce:	e011      	b.n	43f4 <sha256_process+0x13c0>
    43d0:	2e1b2138 	mrccs	1, 0, r2, cr11, cr8, {1}
    43d4:	4d2c6dfc 	stcmi	13, cr6, [ip, #-1008]!	; 0xfffffc10
    43d8:	53380d13 	teqpl	r8, #1216	; 0x4c0
    43dc:	650a7354 	strvs	r7, [sl, #-852]	; 0x354
    43e0:	a2bfe8a1 	adcsge	lr, pc, #10551296	; 0xa10000
    43e4:	a81a664b 	ldmdage	sl, {r0, r1, r3, r6, r9, sl, sp, lr}
    43e8:	766a0abb 			; <UNDEFINED> instruction: 0x766a0abb
    43ec:	81c2c92e 	bichi	ip, r2, lr, lsr #18
    43f0:	92722c85 	rsbsls	r2, r2, #34048	; 0x8500
    43f4:	ea82 0701 	eor.w	r7, r2, r1
    43f8:	445d      	add	r5, fp
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    43fa:	ea4f 19fa 	mov.w	r9, sl, ror #7
    43fe:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4402:	401f      	ands	r7, r3
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4404:	ea89 49ba 	eor.w	r9, r9, sl, ror #18
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4408:	442c      	add	r4, r5
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    440a:	9d15      	ldr	r5, [sp, #84]	; 0x54
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    440c:	404f      	eors	r7, r1
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    440e:	ea89 09db 	eor.w	r9, r9, fp, lsr #3
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4412:	ea4c 0b08 	orr.w	fp, ip, r8
    4416:	ea0b 0b06 	and.w	fp, fp, r6
    441a:	ea4f 1ab3 	mov.w	sl, r3, ror #6
    441e:	443c      	add	r4, r7
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4420:	44a9      	add	r9, r5
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4422:	ea4f 07bc 	mov.w	r7, ip, ror #2
    4426:	ea0c 0508 	and.w	r5, ip, r8
    442a:	ea8a 2af3 	eor.w	sl, sl, r3, ror #11
    442e:	ea87 377c 	eor.w	r7, r7, ip, ror #13
    4432:	ea4b 0505 	orr.w	r5, fp, r5
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4436:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    443a:	ea8a 6a73 	eor.w	sl, sl, r3, ror #25
    443e:	ea87 57bc 	eor.w	r7, r7, ip, ror #22
    4442:	4454      	add	r4, sl
    4444:	443d      	add	r5, r7
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4446:	ea4f 4a7b 	mov.w	sl, fp, ror #17
    444a:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    444c:	ea8a 4afb 	eor.w	sl, sl, fp, ror #19
    4450:	44b9      	add	r9, r7
    4452:	ea8a 2a9b 	eor.w	sl, sl, fp, lsr #10
    4456:	44ca      	add	sl, r9
    4458:	f8cd a054 	str.w	sl, [sp, #84]	; 0x54
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    445c:	4420      	add	r0, r4
    445e:	4425      	add	r5, r4
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4460:	f8dd b05c 	ldr.w	fp, [sp, #92]	; 0x5c
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4464:	9c15      	ldr	r4, [sp, #84]	; 0x54
    4466:	4fee      	ldr	r7, [pc, #952]	; (4820 <sha256_process+0x17ec>)
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4468:	ea4f 19fb 	mov.w	r9, fp, ror #7
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    446c:	4427      	add	r7, r4
    446e:	ea83 0a02 	eor.w	sl, r3, r2
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4472:	ea89 49bb 	eor.w	r9, r9, fp, ror #18
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4476:	4439      	add	r1, r7
    4478:	ea4f 1bb0 	mov.w	fp, r0, ror #6
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    447c:	9f17      	ldr	r7, [sp, #92]	; 0x5c
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    447e:	ea8b 2bf0 	eor.w	fp, fp, r0, ror #11
    4482:	ea00 0a0a 	and.w	sl, r0, sl
    4486:	ea8a 0a02 	eor.w	sl, sl, r2
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    448a:	ea89 09d7 	eor.w	r9, r9, r7, lsr #3
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    448e:	ea8b 6770 	eor.w	r7, fp, r0, ror #25
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4492:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4496:	4451      	add	r1, sl
    4498:	ea45 0a0c 	orr.w	sl, r5, ip
    449c:	ea0a 0a08 	and.w	sl, sl, r8
    44a0:	ea05 040c 	and.w	r4, r5, ip
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44a4:	44d9      	add	r9, fp
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44a6:	ea4f 0bb5 	mov.w	fp, r5, ror #2
    44aa:	ea8b 3b75 	eor.w	fp, fp, r5, ror #13
    44ae:	ea4a 0404 	orr.w	r4, sl, r4
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44b2:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44b6:	ea8b 5bb5 	eor.w	fp, fp, r5, ror #22
    44ba:	4439      	add	r1, r7
    44bc:	445c      	add	r4, fp
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44be:	ea4f 477a 	mov.w	r7, sl, ror #17
    44c2:	f8dd b03c 	ldr.w	fp, [sp, #60]	; 0x3c
    44c6:	ea87 47fa 	eor.w	r7, r7, sl, ror #19
    44ca:	44d9      	add	r9, fp
    44cc:	ea87 2a9a 	eor.w	sl, r7, sl, lsr #10
    44d0:	4fd4      	ldr	r7, [pc, #848]	; (4824 <sha256_process+0x17f0>)
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44d2:	440c      	add	r4, r1
    44d4:	440e      	add	r6, r1
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44d6:	44ca      	add	sl, r9
    44d8:	ea80 0103 	eor.w	r1, r0, r3
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    44dc:	f8dd 9060 	ldr.w	r9, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44e0:	4457      	add	r7, sl
    44e2:	4031      	ands	r1, r6
    44e4:	f8cd a058 	str.w	sl, [sp, #88]	; 0x58
    44e8:	4059      	eors	r1, r3
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    44ea:	f8dd a060 	ldr.w	sl, [sp, #96]	; 0x60
    44ee:	ea4f 1bf9 	mov.w	fp, r9, ror #7
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44f2:	4417      	add	r7, r2
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    44f4:	ea8b 4bb9 	eor.w	fp, fp, r9, ror #18
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44f8:	440f      	add	r7, r1
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    44fa:	9917      	ldr	r1, [sp, #92]	; 0x5c
    44fc:	ea8b 0bda 	eor.w	fp, fp, sl, lsr #3
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4500:	ea44 0a05 	orr.w	sl, r4, r5
    4504:	ea0a 0a0c 	and.w	sl, sl, ip
    4508:	ea04 0205 	and.w	r2, r4, r5
    450c:	ea4f 19b6 	mov.w	r9, r6, ror #6
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4510:	448b      	add	fp, r1
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4512:	ea4f 01b4 	mov.w	r1, r4, ror #2
    4516:	ea89 29f6 	eor.w	r9, r9, r6, ror #11
    451a:	ea81 3174 	eor.w	r1, r1, r4, ror #13
    451e:	ea4a 0202 	orr.w	r2, sl, r2
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4522:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4526:	ea89 6976 	eor.w	r9, r9, r6, ror #25
    452a:	ea81 51b4 	eor.w	r1, r1, r4, ror #22
    452e:	444f      	add	r7, r9
    4530:	440a      	add	r2, r1
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4532:	ea4f 497a 	mov.w	r9, sl, ror #17
    4536:	9910      	ldr	r1, [sp, #64]	; 0x40
    4538:	ea89 49fa 	eor.w	r9, r9, sl, ror #19
    453c:	448b      	add	fp, r1
    453e:	ea89 299a 	eor.w	r9, r9, sl, lsr #10
    4542:	44d9      	add	r9, fp
    4544:	f8cd 905c 	str.w	r9, [sp, #92]	; 0x5c
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4548:	44b8      	add	r8, r7
    454a:	443a      	add	r2, r7
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    454c:	49b6      	ldr	r1, [pc, #728]	; (4828 <sha256_process+0x17f4>)
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    454e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4550:	ea86 0b00 	eor.w	fp, r6, r0
    4554:	4449      	add	r1, r9
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4556:	ea4f 1af7 	mov.w	sl, r7, ror #7
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    455a:	ea08 0b0b 	and.w	fp, r8, fp
    455e:	ea8b 0b00 	eor.w	fp, fp, r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4562:	ea8a 4ab7 	eor.w	sl, sl, r7, ror #18
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4566:	440b      	add	r3, r1
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4568:	9918      	ldr	r1, [sp, #96]	; 0x60
    456a:	ea8a 0ad7 	eor.w	sl, sl, r7, lsr #3
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    456e:	445b      	add	r3, fp
    4570:	ea42 0b04 	orr.w	fp, r2, r4
    4574:	ea0b 0b05 	and.w	fp, fp, r5
    4578:	ea4f 19b8 	mov.w	r9, r8, ror #6
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    457c:	448a      	add	sl, r1
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    457e:	ea4f 07b2 	mov.w	r7, r2, ror #2
    4582:	ea02 0104 	and.w	r1, r2, r4
    4586:	ea89 29f8 	eor.w	r9, r9, r8, ror #11
    458a:	ea87 3772 	eor.w	r7, r7, r2, ror #13
    458e:	ea4b 0101 	orr.w	r1, fp, r1
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4592:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4596:	ea89 6978 	eor.w	r9, r9, r8, ror #25
    459a:	ea87 57b2 	eor.w	r7, r7, r2, ror #22
    459e:	444b      	add	r3, r9
    45a0:	4439      	add	r1, r7
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45a2:	ea4f 497b 	mov.w	r9, fp, ror #17
    45a6:	9f11      	ldr	r7, [sp, #68]	; 0x44
    45a8:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    45ac:	44ba      	add	sl, r7
    45ae:	ea89 299b 	eor.w	r9, r9, fp, lsr #10
    45b2:	44d1      	add	r9, sl
    45b4:	f8cd 9060 	str.w	r9, [sp, #96]	; 0x60
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45b8:	449c      	add	ip, r3
    45ba:	4419      	add	r1, r3
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45bc:	4f9b      	ldr	r7, [pc, #620]	; (482c <sha256_process+0x17f8>)
    45be:	9b18      	ldr	r3, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45c0:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45c4:	ea88 0906 	eor.w	r9, r8, r6
    45c8:	441f      	add	r7, r3
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45ca:	ea4f 1afb 	mov.w	sl, fp, ror #7
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45ce:	ea0c 0909 	and.w	r9, ip, r9
    45d2:	4407      	add	r7, r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45d4:	980c      	ldr	r0, [sp, #48]	; 0x30
    45d6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45d8:	ea89 0906 	eor.w	r9, r9, r6
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45dc:	ea8a 4abb 	eor.w	sl, sl, fp, ror #18
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45e0:	ea4f 1bbc 	mov.w	fp, ip, ror #6
    45e4:	ea8b 2bfc 	eor.w	fp, fp, ip, ror #11
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45e8:	ea8a 0ad0 	eor.w	sl, sl, r0, lsr #3
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45ec:	444f      	add	r7, r9
    45ee:	ea41 0902 	orr.w	r9, r1, r2
    45f2:	ea8b 607c 	eor.w	r0, fp, ip, ror #25
    45f6:	ea09 0904 	and.w	r9, r9, r4
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45fa:	449a      	add	sl, r3
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45fc:	ea4f 0bb1 	mov.w	fp, r1, ror #2
    4600:	ea01 0302 	and.w	r3, r1, r2
    4604:	ea8b 3b71 	eor.w	fp, fp, r1, ror #13
    4608:	ea49 0303 	orr.w	r3, r9, r3
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    460c:	f8dd 905c 	ldr.w	r9, [sp, #92]	; 0x5c
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4610:	ea8b 5bb1 	eor.w	fp, fp, r1, ror #22
    4614:	4407      	add	r7, r0
    4616:	445b      	add	r3, fp
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4618:	ea4f 4079 	mov.w	r0, r9, ror #17
    461c:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
    4620:	ea80 40f9 	eor.w	r0, r0, r9, ror #19
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4624:	443b      	add	r3, r7
    4626:	443d      	add	r5, r7
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4628:	44da      	add	sl, fp
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    462a:	9f09      	ldr	r7, [sp, #36]	; 0x24
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    462c:	ea80 2999 	eor.w	r9, r0, r9, lsr #10
    4630:	487f      	ldr	r0, [pc, #508]	; (4830 <sha256_process+0x17fc>)
    4632:	44d1      	add	r9, sl
    4634:	ea8c 0b08 	eor.w	fp, ip, r8
    4638:	4448      	add	r0, r9
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    463a:	ea4f 1af7 	mov.w	sl, r7, ror #7
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    463e:	ea05 0b0b 	and.w	fp, r5, fp
    4642:	ea8b 0b08 	eor.w	fp, fp, r8
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4646:	ea8a 4ab7 	eor.w	sl, sl, r7, ror #18
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    464a:	4406      	add	r6, r0
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    464c:	980c      	ldr	r0, [sp, #48]	; 0x30
    464e:	ea8a 0ad7 	eor.w	sl, sl, r7, lsr #3
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4652:	445e      	add	r6, fp
    4654:	ea43 0b01 	orr.w	fp, r3, r1
    4658:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
    465c:	ea0b 0b02 	and.w	fp, fp, r2
    4660:	ea4f 19b5 	mov.w	r9, r5, ror #6
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4664:	4482      	add	sl, r0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4666:	ea4f 07b3 	mov.w	r7, r3, ror #2
    466a:	ea03 0001 	and.w	r0, r3, r1
    466e:	ea89 29f5 	eor.w	r9, r9, r5, ror #11
    4672:	ea87 3773 	eor.w	r7, r7, r3, ror #13
    4676:	ea4b 0000 	orr.w	r0, fp, r0
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    467a:	f8dd b060 	ldr.w	fp, [sp, #96]	; 0x60
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    467e:	ea89 6975 	eor.w	r9, r9, r5, ror #25
    4682:	ea87 57b3 	eor.w	r7, r7, r3, ror #22
    4686:	444e      	add	r6, r9
    4688:	4438      	add	r0, r7
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    468a:	ea4f 497b 	mov.w	r9, fp, ror #17
    468e:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    4690:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    4694:	44ba      	add	sl, r7
    4696:	ea89 299b 	eor.w	r9, r9, fp, lsr #10
    469a:	44d1      	add	r9, sl
    469c:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46a0:	4430      	add	r0, r6
    46a2:	4434      	add	r4, r6
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46a4:	4f63      	ldr	r7, [pc, #396]	; (4834 <sha256_process+0x1800>)
    46a6:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46a8:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46ac:	4437      	add	r7, r6
    46ae:	ea85 0a0c 	eor.w	sl, r5, ip
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46b2:	ea4f 1bf9 	mov.w	fp, r9, ror #7
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46b6:	4447      	add	r7, r8
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46b8:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46bc:	ea04 0a0a 	and.w	sl, r4, sl
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46c0:	ea8b 4bb9 	eor.w	fp, fp, r9, ror #18
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46c4:	ea8a 0a0c 	eor.w	sl, sl, ip
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46c8:	ea8b 0bd8 	eor.w	fp, fp, r8, lsr #3
    46cc:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46d0:	4457      	add	r7, sl
    46d2:	ea40 0a03 	orr.w	sl, r0, r3
    46d6:	ea0a 0a01 	and.w	sl, sl, r1
    46da:	ea00 0603 	and.w	r6, r0, r3
    46de:	ea4f 19b4 	mov.w	r9, r4, ror #6
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46e2:	44d8      	add	r8, fp
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46e4:	ea4f 0bb0 	mov.w	fp, r0, ror #2
    46e8:	ea89 29f4 	eor.w	r9, r9, r4, ror #11
    46ec:	ea8b 3b70 	eor.w	fp, fp, r0, ror #13
    46f0:	ea4a 0606 	orr.w	r6, sl, r6
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46f4:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46f8:	ea8b 5bb0 	eor.w	fp, fp, r0, ror #22
    46fc:	ea89 6974 	eor.w	r9, r9, r4, ror #25
    4700:	44b9      	add	r9, r7
    4702:	445e      	add	r6, fp
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4704:	ea4f 477a 	mov.w	r7, sl, ror #17
    4708:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
    470c:	ea87 47fa 	eor.w	r7, r7, sl, ror #19
    4710:	44d8      	add	r8, fp
    4712:	ea87 2a9a 	eor.w	sl, r7, sl, lsr #10
    4716:	44c2      	add	sl, r8
    4718:	4f47      	ldr	r7, [pc, #284]	; (4838 <sha256_process+0x1804>)
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    471a:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    471e:	444a      	add	r2, r9
    4720:	444e      	add	r6, r9
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4722:	ea84 0905 	eor.w	r9, r4, r5
    4726:	f8cd a068 	str.w	sl, [sp, #104]	; 0x68
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    472a:	ea4f 1bf8 	mov.w	fp, r8, ror #7
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    472e:	4457      	add	r7, sl
    4730:	ea02 0909 	and.w	r9, r2, r9
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4734:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4738:	ea89 0905 	eor.w	r9, r9, r5
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    473c:	ea8b 4bb8 	eor.w	fp, fp, r8, ror #18
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4740:	4467      	add	r7, ip
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4742:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4746:	444f      	add	r7, r9
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4748:	ea8b 0bda 	eor.w	fp, fp, sl, lsr #3
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    474c:	ea46 0900 	orr.w	r9, r6, r0
    4750:	ea09 0903 	and.w	r9, r9, r3
    4754:	ea4f 18b2 	mov.w	r8, r2, ror #6
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4758:	44e3      	add	fp, ip
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    475a:	ea4f 0ab6 	mov.w	sl, r6, ror #2
    475e:	ea06 0c00 	and.w	ip, r6, r0
    4762:	ea88 28f2 	eor.w	r8, r8, r2, ror #11
    4766:	ea8a 3a76 	eor.w	sl, sl, r6, ror #13
    476a:	ea49 0c0c 	orr.w	ip, r9, ip
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    476e:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4772:	ea8a 5ab6 	eor.w	sl, sl, r6, ror #22
    4776:	ea88 6872 	eor.w	r8, r8, r2, ror #25
    477a:	44b8      	add	r8, r7
    477c:	44d4      	add	ip, sl
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    477e:	ea4f 4779 	mov.w	r7, r9, ror #17
    4782:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
    4786:	ea87 47f9 	eor.w	r7, r7, r9, ror #19
    478a:	ea87 2999 	eor.w	r9, r7, r9, lsr #10
    478e:	44d3      	add	fp, sl
    4790:	4f2a      	ldr	r7, [pc, #168]	; (483c <sha256_process+0x1808>)
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4792:	44c4      	add	ip, r8
    4794:	4441      	add	r1, r8
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4796:	44cb      	add	fp, r9
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4798:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    479c:	445f      	add	r7, fp
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    479e:	ea4f 1af8 	mov.w	sl, r8, ror #7
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47a2:	443d      	add	r5, r7
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47a4:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47a6:	ea82 0904 	eor.w	r9, r2, r4
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47aa:	ea8a 4ab8 	eor.w	sl, sl, r8, ror #18
    47ae:	ea8a 0ad7 	eor.w	sl, sl, r7, lsr #3
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47b2:	ea01 0909 	and.w	r9, r1, r9
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47b6:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47b8:	ea4f 18b1 	mov.w	r8, r1, ror #6
    47bc:	ea89 0904 	eor.w	r9, r9, r4
    47c0:	ea88 28f1 	eor.w	r8, r8, r1, ror #11
    47c4:	444d      	add	r5, r9
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47c6:	4457      	add	r7, sl
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47c8:	ea4c 0906 	orr.w	r9, ip, r6
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47cc:	f8dd a068 	ldr.w	sl, [sp, #104]	; 0x68
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47d0:	ea88 6871 	eor.w	r8, r8, r1, ror #25
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47d4:	9709      	str	r7, [sp, #36]	; 0x24
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47d6:	44a8      	add	r8, r5
    47d8:	ea09 0900 	and.w	r9, r9, r0
    47dc:	ea0c 0506 	and.w	r5, ip, r6
    47e0:	ea4f 07bc 	mov.w	r7, ip, ror #2
    47e4:	ea87 377c 	eor.w	r7, r7, ip, ror #13
    47e8:	ea49 0505 	orr.w	r5, r9, r5
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47ec:	ea4f 497a 	mov.w	r9, sl, ror #17
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47f0:	ea87 57bc 	eor.w	r7, r7, ip, ror #22
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47f4:	ea89 49fa 	eor.w	r9, r9, sl, ror #19
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47f8:	443d      	add	r5, r7
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47fa:	ea89 299a 	eor.w	r9, r9, sl, lsr #10
    47fe:	9f16      	ldr	r7, [sp, #88]	; 0x58
    4800:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4804:	4445      	add	r5, r8
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4806:	44ba      	add	sl, r7
    4808:	44d1      	add	r9, sl
    480a:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    480e:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4812:	4f0b      	ldr	r7, [pc, #44]	; (4840 <sha256_process+0x180c>)
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4814:	ea4f 1af9 	mov.w	sl, r9, ror #7
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4818:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
    481c:	e012      	b.n	4844 <sha256_process+0x1810>
    481e:	bf00      	nop
    4820:	c24b8b70 	subgt	r8, fp, #112, 22	; 0x1c000
    4824:	c76c51a3 	strbgt	r5, [ip, -r3, lsr #3]!
    4828:	d192e819 	orrsle	lr, r2, r9, lsl r8
    482c:	d6990624 	ldrle	r0, [r9], r4, lsr #12
    4830:	f40e3585 	vst3.32	{d3,d5,d7}, [lr], r5
    4834:	106aa070 	rsbne	sl, sl, r0, ror r0
    4838:	19a4c116 	stmibne	r4!, {r1, r2, r4, r8, lr, pc}
    483c:	1e376c08 	cdpne	12, 3, cr6, cr7, cr8, {0}
    4840:	2748774c 	strbcs	r7, [r8, -ip, asr #14]
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4844:	4443      	add	r3, r8
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4846:	444f      	add	r7, r9
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4848:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    484c:	443c      	add	r4, r7
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    484e:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4850:	ea81 0802 	eor.w	r8, r1, r2
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4854:	ea8a 4ab9 	eor.w	sl, sl, r9, ror #18
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4858:	ea03 0808 	and.w	r8, r3, r8
    485c:	ea4f 19b3 	mov.w	r9, r3, ror #6
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4860:	ea8a 0ad7 	eor.w	sl, sl, r7, lsr #3
    4864:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4866:	ea88 0802 	eor.w	r8, r8, r2
    486a:	ea89 29f3 	eor.w	r9, r9, r3, ror #11
    486e:	ea89 6973 	eor.w	r9, r9, r3, ror #25
    4872:	4444      	add	r4, r8
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4874:	44ba      	add	sl, r7
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4876:	ea45 080c 	orr.w	r8, r5, ip
    487a:	ea4f 07b5 	mov.w	r7, r5, ror #2
    487e:	444c      	add	r4, r9
    4880:	ea08 0806 	and.w	r8, r8, r6
    4884:	ea05 090c 	and.w	r9, r5, ip
    4888:	ea87 3775 	eor.w	r7, r7, r5, ror #13
    488c:	ea87 57b5 	eor.w	r7, r7, r5, ror #22
    4890:	ea48 0809 	orr.w	r8, r8, r9
    4894:	44b8      	add	r8, r7
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4896:	ea4f 497b 	mov.w	r9, fp, ror #17
    489a:	9f17      	ldr	r7, [sp, #92]	; 0x5c
    489c:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    48a0:	44ba      	add	sl, r7
    48a2:	ea89 299b 	eor.w	r9, r9, fp, lsr #10
    48a6:	44d1      	add	r9, sl
    48a8:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48ac:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48b0:	4fe8      	ldr	r7, [pc, #928]	; (4c54 <sha256_process+0x1c20>)
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48b2:	ea4f 1af9 	mov.w	sl, r9, ror #7
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48b6:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48ba:	44a0      	add	r8, r4
    48bc:	4420      	add	r0, r4
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48be:	ea83 0401 	eor.w	r4, r3, r1
    48c2:	444f      	add	r7, r9
    48c4:	4004      	ands	r4, r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48c6:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48ca:	404c      	eors	r4, r1
    48cc:	4417      	add	r7, r2
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48ce:	9a10      	ldr	r2, [sp, #64]	; 0x40
    48d0:	ea8a 4ab9 	eor.w	sl, sl, r9, ror #18
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48d4:	4427      	add	r7, r4
    48d6:	ea4f 19b0 	mov.w	r9, r0, ror #6
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48da:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    48dc:	ea8a 0ad2 	eor.w	sl, sl, r2, lsr #3
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48e0:	ea89 29f0 	eor.w	r9, r9, r0, ror #11
    48e4:	ea48 0205 	orr.w	r2, r8, r5
    48e8:	ea89 6970 	eor.w	r9, r9, r0, ror #25
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48ec:	4454      	add	r4, sl
    48ee:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    48f2:	9409      	str	r4, [sp, #36]	; 0x24
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48f4:	444f      	add	r7, r9
    48f6:	ea02 020c 	and.w	r2, r2, ip
    48fa:	ea08 0905 	and.w	r9, r8, r5
    48fe:	ea4f 04b8 	mov.w	r4, r8, ror #2
    4902:	ea84 3478 	eor.w	r4, r4, r8, ror #13
    4906:	ea42 0209 	orr.w	r2, r2, r9
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    490a:	ea4f 497a 	mov.w	r9, sl, ror #17
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    490e:	ea84 54b8 	eor.w	r4, r4, r8, ror #22
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4912:	ea89 49fa 	eor.w	r9, r9, sl, ror #19
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4916:	4422      	add	r2, r4
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4918:	ea89 299a 	eor.w	r9, r9, sl, lsr #10
    491c:	9c18      	ldr	r4, [sp, #96]	; 0x60
    491e:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4922:	443a      	add	r2, r7
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4924:	44a2      	add	sl, r4
    4926:	44d1      	add	r9, sl
    4928:	f8cd 903c 	str.w	r9, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    492c:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4930:	4cc9      	ldr	r4, [pc, #804]	; (4c58 <sha256_process+0x1c24>)
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4932:	ea4f 1af9 	mov.w	sl, r9, ror #7
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4936:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    493a:	443e      	add	r6, r7
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    493c:	444c      	add	r4, r9
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    493e:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4942:	4421      	add	r1, r4
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4944:	9c11      	ldr	r4, [sp, #68]	; 0x44
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4946:	ea80 0703 	eor.w	r7, r0, r3
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    494a:	ea8a 4ab9 	eor.w	sl, sl, r9, ror #18
    494e:	ea8a 0ad4 	eor.w	sl, sl, r4, lsr #3
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4952:	4037      	ands	r7, r6
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4954:	9c10      	ldr	r4, [sp, #64]	; 0x40
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4956:	ea4f 19b6 	mov.w	r9, r6, ror #6
    495a:	405f      	eors	r7, r3
    495c:	ea89 29f6 	eor.w	r9, r9, r6, ror #11
    4960:	ea89 6976 	eor.w	r9, r9, r6, ror #25
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4964:	4454      	add	r4, sl
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4966:	440f      	add	r7, r1
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4968:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    496c:	ea42 0108 	orr.w	r1, r2, r8
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4970:	9409      	str	r4, [sp, #36]	; 0x24
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4972:	444f      	add	r7, r9
    4974:	4029      	ands	r1, r5
    4976:	ea02 0908 	and.w	r9, r2, r8
    497a:	ea4f 04b2 	mov.w	r4, r2, ror #2
    497e:	ea84 3472 	eor.w	r4, r4, r2, ror #13
    4982:	ea41 0109 	orr.w	r1, r1, r9
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4986:	ea4f 497a 	mov.w	r9, sl, ror #17
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    498a:	ea84 54b2 	eor.w	r4, r4, r2, ror #22
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    498e:	ea89 49fa 	eor.w	r9, r9, sl, ror #19
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4992:	4421      	add	r1, r4
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4994:	ea89 299a 	eor.w	r9, r9, sl, lsr #10
    4998:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    499a:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    499e:	4439      	add	r1, r7
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49a0:	44a2      	add	sl, r4
    49a2:	44d1      	add	r9, sl
    49a4:	f8cd 9040 	str.w	r9, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49a8:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49ac:	4cab      	ldr	r4, [pc, #684]	; (4c5c <sha256_process+0x1c28>)
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49ae:	ea4f 1af9 	mov.w	sl, r9, ror #7
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49b2:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49b6:	44bc      	add	ip, r7
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49b8:	ea86 0700 	eor.w	r7, r6, r0
    49bc:	444c      	add	r4, r9
    49be:	ea0c 0707 	and.w	r7, ip, r7
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49c2:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49c6:	4047      	eors	r7, r0
    49c8:	4423      	add	r3, r4
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49ca:	9c12      	ldr	r4, [sp, #72]	; 0x48
    49cc:	ea8a 4ab9 	eor.w	sl, sl, r9, ror #18
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49d0:	443b      	add	r3, r7
    49d2:	ea4f 19bc 	mov.w	r9, ip, ror #6
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49d6:	9f11      	ldr	r7, [sp, #68]	; 0x44
    49d8:	ea8a 0ad4 	eor.w	sl, sl, r4, lsr #3
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49dc:	ea89 29fc 	eor.w	r9, r9, ip, ror #11
    49e0:	ea41 0402 	orr.w	r4, r1, r2
    49e4:	ea89 697c 	eor.w	r9, r9, ip, ror #25
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49e8:	4457      	add	r7, sl
    49ea:	f8dd a03c 	ldr.w	sl, [sp, #60]	; 0x3c
    49ee:	9709      	str	r7, [sp, #36]	; 0x24
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49f0:	444b      	add	r3, r9
    49f2:	ea04 0408 	and.w	r4, r4, r8
    49f6:	ea01 0902 	and.w	r9, r1, r2
    49fa:	ea4f 07b1 	mov.w	r7, r1, ror #2
    49fe:	ea87 3771 	eor.w	r7, r7, r1, ror #13
    4a02:	ea44 0409 	orr.w	r4, r4, r9
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a06:	ea4f 497a 	mov.w	r9, sl, ror #17
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a0a:	ea87 57b1 	eor.w	r7, r7, r1, ror #22
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a0e:	ea89 49fa 	eor.w	r9, r9, sl, ror #19
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a12:	443c      	add	r4, r7
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a14:	ea89 299a 	eor.w	r9, r9, sl, lsr #10
    4a18:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    4a1a:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a1e:	441c      	add	r4, r3
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a20:	44ba      	add	sl, r7
    4a22:	44d1      	add	r9, sl
    4a24:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a28:	441d      	add	r5, r3
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a2a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a2c:	4f8c      	ldr	r7, [pc, #560]	; (4c60 <sha256_process+0x1c2c>)
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a2e:	ea4f 19f3 	mov.w	r9, r3, ror #7
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a32:	9b11      	ldr	r3, [sp, #68]	; 0x44
    4a34:	ea8c 0a06 	eor.w	sl, ip, r6
    4a38:	441f      	add	r7, r3
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a3a:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a3c:	4438      	add	r0, r7
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a3e:	ea89 49b3 	eor.w	r9, r9, r3, ror #18
    4a42:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a44:	ea4f 13b5 	mov.w	r3, r5, ror #6
    4a48:	ea83 23f5 	eor.w	r3, r3, r5, ror #11
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a4c:	ea89 09d7 	eor.w	r9, r9, r7, lsr #3
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a50:	ea05 0a0a 	and.w	sl, r5, sl
    4a54:	ea83 6775 	eor.w	r7, r3, r5, ror #25
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a58:	9b12      	ldr	r3, [sp, #72]	; 0x48
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a5a:	ea8a 0a06 	eor.w	sl, sl, r6
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a5e:	444b      	add	r3, r9
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a60:	4450      	add	r0, sl
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a62:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a66:	ea44 0a01 	orr.w	sl, r4, r1
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a6a:	9309      	str	r3, [sp, #36]	; 0x24
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a6c:	4438      	add	r0, r7
    4a6e:	ea0a 0a02 	and.w	sl, sl, r2
    4a72:	ea04 0701 	and.w	r7, r4, r1
    4a76:	ea4f 03b4 	mov.w	r3, r4, ror #2
    4a7a:	ea83 3374 	eor.w	r3, r3, r4, ror #13
    4a7e:	ea4a 0a07 	orr.w	sl, sl, r7
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a82:	ea4f 4779 	mov.w	r7, r9, ror #17
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a86:	ea83 53b4 	eor.w	r3, r3, r4, ror #22
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a8a:	ea87 47f9 	eor.w	r7, r7, r9, ror #19
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a8e:	449a      	add	sl, r3
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a90:	ea87 2799 	eor.w	r7, r7, r9, lsr #10
    4a94:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    4a96:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a9a:	4482      	add	sl, r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a9c:	4499      	add	r9, r3
    4a9e:	444f      	add	r7, r9
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4aa0:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4aa4:	9712      	str	r7, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4aa6:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4aaa:	4480      	add	r8, r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4aac:	4b6d      	ldr	r3, [pc, #436]	; (4c64 <sha256_process+0x1c30>)
    4aae:	9812      	ldr	r0, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ab0:	ea4f 17fa 	mov.w	r7, sl, ror #7
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4ab4:	4403      	add	r3, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ab6:	ea87 47ba 	eor.w	r7, r7, sl, ror #18
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4aba:	ea85 090c 	eor.w	r9, r5, ip
    4abe:	441e      	add	r6, r3
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ac0:	ea87 07da 	eor.w	r7, r7, sl, lsr #3
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4ac4:	9b09      	ldr	r3, [sp, #36]	; 0x24
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ac6:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4aca:	ea08 0909 	and.w	r9, r8, r9
    4ace:	ea89 090c 	eor.w	r9, r9, ip
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ad2:	4457      	add	r7, sl
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4ad4:	ea4f 0ab3 	mov.w	sl, r3, ror #2
    4ad8:	444e      	add	r6, r9
    4ada:	ea8a 3a73 	eor.w	sl, sl, r3, ror #13
    4ade:	ea43 0904 	orr.w	r9, r3, r4
    4ae2:	ea8a 5ab3 	eor.w	sl, sl, r3, ror #22
    4ae6:	ea4f 10b8 	mov.w	r0, r8, ror #6
    4aea:	4023      	ands	r3, r4
    4aec:	ea09 0901 	and.w	r9, r9, r1
    4af0:	ea80 20f8 	eor.w	r0, r0, r8, ror #11
    4af4:	ea49 0903 	orr.w	r9, r9, r3
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4af8:	9b11      	ldr	r3, [sp, #68]	; 0x44
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4afa:	ea80 6078 	eor.w	r0, r0, r8, ror #25
    4afe:	4406      	add	r6, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b00:	ea4f 4073 	mov.w	r0, r3, ror #17
    4b04:	ea80 40f3 	eor.w	r0, r0, r3, ror #19
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b08:	44d1      	add	r9, sl
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b0a:	445f      	add	r7, fp
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b0c:	44b1      	add	r9, r6
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b0e:	ea80 2093 	eor.w	r0, r0, r3, lsr #10
    4b12:	4b55      	ldr	r3, [pc, #340]	; (4c68 <sha256_process+0x1c34>)
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b14:	4432      	add	r2, r6
    4b16:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b1a:	1838      	adds	r0, r7, r0
    4b1c:	ea88 0605 	eor.w	r6, r8, r5
    4b20:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    4b24:	4403      	add	r3, r0
    4b26:	4016      	ands	r6, r2
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b28:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b2c:	406e      	eors	r6, r5
    4b2e:	449c      	add	ip, r3
    4b30:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    4b34:	44b4      	add	ip, r6
    4b36:	ea4f 06ba 	mov.w	r6, sl, ror #2
    4b3a:	9013      	str	r0, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b3c:	ea4f 17f9 	mov.w	r7, r9, ror #7
    4b40:	9815      	ldr	r0, [sp, #84]	; 0x54
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b42:	ea86 367a 	eor.w	r6, r6, sl, ror #13
    4b46:	ea4a 030b 	orr.w	r3, sl, fp
    4b4a:	ea86 56ba 	eor.w	r6, r6, sl, ror #22
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b4e:	ea87 47b9 	eor.w	r7, r7, r9, ror #18
    4b52:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
    4b56:	ea87 07d0 	eor.w	r7, r7, r0, lsr #3
    4b5a:	4457      	add	r7, sl
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b5c:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    4b60:	ea4f 19b2 	mov.w	r9, r2, ror #6
    4b64:	4023      	ands	r3, r4
    4b66:	ea0a 000b 	and.w	r0, sl, fp
    4b6a:	ea89 29f2 	eor.w	r9, r9, r2, ror #11
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b6e:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b72:	ea89 6972 	eor.w	r9, r9, r2, ror #25
    4b76:	4318      	orrs	r0, r3
    4b78:	44cc      	add	ip, r9
    4b7a:	4430      	add	r0, r6
    4b7c:	4460      	add	r0, ip
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b7e:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    4b80:	ea4f 437b 	mov.w	r3, fp, ror #17
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b84:	900d      	str	r0, [sp, #52]	; 0x34
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4b86:	f8dd a058 	ldr.w	sl, [sp, #88]	; 0x58
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b8a:	ea83 43fb 	eor.w	r3, r3, fp, ror #19
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b8e:	4461      	add	r1, ip
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b90:	ea83 239b 	eor.w	r3, r3, fp, lsr #10
    4b94:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
    4b98:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
    4b9c:	4437      	add	r7, r6
    4b9e:	441f      	add	r7, r3
    4ba0:	4e32      	ldr	r6, [pc, #200]	; (4c6c <sha256_process+0x1c38>)
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4ba2:	ea4f 13fa 	mov.w	r3, sl, ror #7
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4ba6:	ea82 0908 	eor.w	r9, r2, r8
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4baa:	ea83 43ba 	eor.w	r3, r3, sl, ror #18
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bae:	ea4b 0a0c 	orr.w	sl, fp, ip
    4bb2:	ea4f 0cbb 	mov.w	ip, fp, ror #2
    4bb6:	443e      	add	r6, r7
    4bb8:	ea01 0909 	and.w	r9, r1, r9
    4bbc:	ea8c 3c7b 	eor.w	ip, ip, fp, ror #13
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4bc0:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bc4:	ea89 0908 	eor.w	r9, r9, r8
    4bc8:	4435      	add	r5, r6
    4bca:	444d      	add	r5, r9
    4bcc:	9e09      	ldr	r6, [sp, #36]	; 0x24
    4bce:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4bd2:	ea83 03db 	eor.w	r3, r3, fp, lsr #3
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bd6:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    4bda:	ea0a 0a06 	and.w	sl, sl, r6
    4bde:	ea09 060b 	and.w	r6, r9, fp
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4be2:	f8dd 904c 	ldr.w	r9, [sp, #76]	; 0x4c
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4be6:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
    4bea:	ea4f 10b1 	mov.w	r0, r1, ror #6
    4bee:	ea8c 5cbb 	eor.w	ip, ip, fp, ror #22
    4bf2:	ea80 20f1 	eor.w	r0, r0, r1, ror #11
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4bf6:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bfa:	ea4a 0a06 	orr.w	sl, sl, r6
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4bfe:	ea4f 4679 	mov.w	r6, r9, ror #17
    4c02:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c06:	ea80 6071 	eor.w	r0, r0, r1, ror #25
    4c0a:	44e2      	add	sl, ip
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c0c:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c10:	4428      	add	r0, r5
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c12:	ea86 46fb 	eor.w	r6, r6, fp, ror #19
    4c16:	444b      	add	r3, r9
    4c18:	ea86 259b 	eor.w	r5, r6, fp, lsr #10
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c1c:	4482      	add	sl, r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c1e:	4463      	add	r3, ip
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c20:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c24:	442b      	add	r3, r5
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c26:	9d17      	ldr	r5, [sp, #92]	; 0x5c
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c28:	4404      	add	r4, r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c2a:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c2e:	ea4f 10f5 	mov.w	r0, r5, ror #7
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c32:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    4c34:	4e0e      	ldr	r6, [pc, #56]	; (4c70 <sha256_process+0x1c3c>)
    4c36:	ea4b 0c05 	orr.w	ip, fp, r5
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c3a:	f8dd b05c 	ldr.w	fp, [sp, #92]	; 0x5c
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c3e:	441e      	add	r6, r3
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c40:	ea80 40bb 	eor.w	r0, r0, fp, ror #18
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c44:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    4c48:	4446      	add	r6, r8
    4c4a:	ea4f 05bb 	mov.w	r5, fp, ror #2
    4c4e:	ea85 357b 	eor.w	r5, r5, fp, ror #13
    4c52:	e00f      	b.n	4c74 <sha256_process+0x1c40>
    4c54:	34b0bcb5 	ldrtcc	fp, [r0], #3253	; 0xcb5
    4c58:	391c0cb3 	ldmdbcc	ip, {r0, r1, r4, r5, r7, sl, fp}
    4c5c:	4ed8aa4a 	vfnmami.f32	s21, s16, s20
    4c60:	5b9cca4f 	blpl	fe7375a4 <BootRAM+0xd6a7d45>
    4c64:	682e6ff3 	stmdavs	lr!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
    4c68:	748f82ee 	strvc	r8, [pc], #750	; 4c70 <sha256_process+0x1c3c>
    4c6c:	78a5636f 	stmiavc	r5!, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}
    4c70:	84c87814 	strbhi	r7, [r8], #2068	; 0x814
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c74:	f8dd b05c 	ldr.w	fp, [sp, #92]	; 0x5c
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c78:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c7c:	ea80 00db 	eor.w	r0, r0, fp, lsr #3
    4c80:	9014      	str	r0, [sp, #80]	; 0x50
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c82:	ea0c 0c08 	and.w	ip, ip, r8
    4c86:	980e      	ldr	r0, [sp, #56]	; 0x38
    4c88:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
    4c8c:	ea81 0a02 	eor.w	sl, r1, r2
    4c90:	ea00 0b08 	and.w	fp, r0, r8
    4c94:	ea4c 0c0b 	orr.w	ip, ip, fp
    4c98:	ea85 55b0 	eor.w	r5, r5, r0, ror #22
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c9c:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
    4ca0:	9814      	ldr	r0, [sp, #80]	; 0x50
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4ca2:	ea04 0a0a 	and.w	sl, r4, sl
    4ca6:	ea4f 19b4 	mov.w	r9, r4, ror #6
    4caa:	ea8a 0a02 	eor.w	sl, sl, r2
    4cae:	ea89 29f4 	eor.w	r9, r9, r4, ror #11
    4cb2:	44b2      	add	sl, r6
    4cb4:	ea89 6974 	eor.w	r9, r9, r4, ror #25
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cb8:	ea4f 4677 	mov.w	r6, r7, ror #17
    4cbc:	4458      	add	r0, fp
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cbe:	eb0c 0b05 	add.w	fp, ip, r5
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cc2:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cc6:	eb0a 0809 	add.w	r8, sl, r9
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cca:	ea86 46f7 	eor.w	r6, r6, r7, ror #19
    4cce:	ea86 2697 	eor.w	r6, r6, r7, lsr #10
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cd2:	44c3      	add	fp, r8
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4cd4:	9f18      	ldr	r7, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cd6:	4460      	add	r0, ip
    4cd8:	4daa      	ldr	r5, [pc, #680]	; (4f84 <sha256_process+0x1f50>)
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cda:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cde:	4430      	add	r0, r6
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4ce0:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
    4ce4:	44c4      	add	ip, r8
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4ce6:	ea4f 16f7 	mov.w	r6, r7, ror #7
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cea:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    4cee:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    4cf0:	4405      	add	r5, r0
    4cf2:	1955      	adds	r5, r2, r5
    4cf4:	950f      	str	r5, [sp, #60]	; 0x3c
    4cf6:	9a09      	ldr	r2, [sp, #36]	; 0x24
    4cf8:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    4cfa:	ea48 0907 	orr.w	r9, r8, r7
    4cfe:	ea4f 07b8 	mov.w	r7, r8, ror #2
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d02:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d06:	ea84 0b01 	eor.w	fp, r4, r1
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d0a:	ea86 46b8 	eor.w	r6, r6, r8, ror #18
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d0e:	ea02 0805 	and.w	r8, r2, r5
    4d12:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    4d14:	9d09      	ldr	r5, [sp, #36]	; 0x24
    4d16:	ea09 0902 	and.w	r9, r9, r2
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d1a:	9a18      	ldr	r2, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d1c:	ea0c 0b0b 	and.w	fp, ip, fp
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d20:	ea86 06d2 	eor.w	r6, r6, r2, lsr #3
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d24:	ea49 0808 	orr.w	r8, r9, r8
    4d28:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    4d2a:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    4d2e:	ea4f 1abc 	mov.w	sl, ip, ror #6
    4d32:	ea8b 0b01 	eor.w	fp, fp, r1
    4d36:	ea87 3775 	eor.w	r7, r7, r5, ror #13
    4d3a:	4493      	add	fp, r2
    4d3c:	ea87 57b9 	eor.w	r7, r7, r9, ror #22
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d40:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d42:	ea8a 2afc 	eor.w	sl, sl, ip, ror #11
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d46:	ea4f 4573 	mov.w	r5, r3, ror #17
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d4a:	ea8a 6a7c 	eor.w	sl, sl, ip, ror #25
    4d4e:	44b8      	add	r8, r7
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d50:	9f10      	ldr	r7, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d52:	44da      	add	sl, fp
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d54:	4416      	add	r6, r2
    4d56:	ea85 45f3 	eor.w	r5, r5, r3, ror #19
    4d5a:	443e      	add	r6, r7
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d5c:	44d0      	add	r8, sl
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d5e:	ea85 2593 	eor.w	r5, r5, r3, lsr #10
    4d62:	4f89      	ldr	r7, [pc, #548]	; (4f88 <sha256_process+0x1f54>)
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d64:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d68:	1975      	adds	r5, r6, r5
    4d6a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4d6c:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d70:	950f      	str	r5, [sp, #60]	; 0x3c
    4d72:	442f      	add	r7, r5
    4d74:	9d09      	ldr	r5, [sp, #36]	; 0x24
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4d76:	ea4f 18f9 	mov.w	r8, r9, ror #7
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d7a:	ea4f 06b3 	mov.w	r6, r3, ror #2
    4d7e:	ea43 0905 	orr.w	r9, r3, r5
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4d82:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d84:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4d86:	ea88 48b3 	eor.w	r8, r8, r3, ror #18
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d8a:	9b10      	ldr	r3, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d8c:	4452      	add	r2, sl
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d8e:	ea8c 0b04 	eor.w	fp, ip, r4
    4d92:	ea02 0b0b 	and.w	fp, r2, fp
    4d96:	4439      	add	r1, r7
    4d98:	ea03 0705 	and.w	r7, r3, r5
    4d9c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    4d9e:	ea8b 0b04 	eor.w	fp, fp, r4
    4da2:	ea86 3673 	eor.w	r6, r6, r3, ror #13
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4da6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4da8:	ea09 0905 	and.w	r9, r9, r5
    4dac:	4459      	add	r1, fp
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4dae:	f8dd b060 	ldr.w	fp, [sp, #96]	; 0x60
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4db2:	ea4f 1ab2 	mov.w	sl, r2, ror #6
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4db6:	ea88 08d3 	eor.w	r8, r8, r3, lsr #3
    4dba:	ea4f 4570 	mov.w	r5, r0, ror #17
    4dbe:	9b11      	ldr	r3, [sp, #68]	; 0x44
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dc0:	ea49 0707 	orr.w	r7, r9, r7
    4dc4:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    4dc8:	ea8a 2af2 	eor.w	sl, sl, r2, ror #11
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4dcc:	44d8      	add	r8, fp
    4dce:	ea85 45f0 	eor.w	r5, r5, r0, ror #19
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dd2:	ea8a 6a72 	eor.w	sl, sl, r2, ror #25
    4dd6:	ea86 56b9 	eor.w	r6, r6, r9, ror #22
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4dda:	4498      	add	r8, r3
    4ddc:	ea85 2590 	eor.w	r5, r5, r0, lsr #10
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4de0:	980d      	ldr	r0, [sp, #52]	; 0x34
    4de2:	4451      	add	r1, sl
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4de4:	4445      	add	r5, r8
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4de6:	4437      	add	r7, r6
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4de8:	950d      	str	r5, [sp, #52]	; 0x34
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dea:	187b      	adds	r3, r7, r1
    4dec:	4408      	add	r0, r1
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4dee:	990c      	ldr	r1, [sp, #48]	; 0x30
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4df0:	4e66      	ldr	r6, [pc, #408]	; (4f8c <sha256_process+0x1f58>)
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4df2:	ea4f 18f1 	mov.w	r8, r1, ror #7
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4df6:	9910      	ldr	r1, [sp, #64]	; 0x40
    4df8:	442e      	add	r6, r5
    4dfa:	ea4f 17b0 	mov.w	r7, r0, ror #6
    4dfe:	4434      	add	r4, r6
    4e00:	ea87 26f0 	eor.w	r6, r7, r0, ror #11
    4e04:	ea03 0701 	and.w	r7, r3, r1
    4e08:	9909      	ldr	r1, [sp, #36]	; 0x24
    4e0a:	ea43 0a09 	orr.w	sl, r3, r9
    4e0e:	ea0a 0a01 	and.w	sl, sl, r1
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e12:	990c      	ldr	r1, [sp, #48]	; 0x30
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e14:	ea82 0b0c 	eor.w	fp, r2, ip
    4e18:	ea4a 0a07 	orr.w	sl, sl, r7
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e1c:	4d5c      	ldr	r5, [pc, #368]	; (4f90 <sha256_process+0x1f5c>)
    4e1e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e20:	ea00 0b0b 	and.w	fp, r0, fp
    4e24:	ea4f 09b3 	mov.w	r9, r3, ror #2
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e28:	ea88 48b1 	eor.w	r8, r8, r1, ror #18
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e2c:	ea8b 0b0c 	eor.w	fp, fp, ip
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e30:	443d      	add	r5, r7
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e32:	ea89 3973 	eor.w	r9, r9, r3, ror #13
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e36:	ea88 08d1 	eor.w	r8, r8, r1, lsr #3
    4e3a:	990f      	ldr	r1, [sp, #60]	; 0x3c
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e3c:	ea86 6670 	eor.w	r6, r6, r0, ror #25
    4e40:	ea89 59b3 	eor.w	r9, r9, r3, ror #22
    4e44:	445c      	add	r4, fp
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e46:	44a8      	add	r8, r5
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e48:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    4e4a:	4434      	add	r4, r6
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e4c:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e4e:	44ca      	add	sl, r9
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e50:	ea4f 4b71 	mov.w	fp, r1, ror #17
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e54:	4425      	add	r5, r4
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e56:	ea8b 4bf1 	eor.w	fp, fp, r1, ror #19
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e5a:	eb0a 0104 	add.w	r1, sl, r4
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e5e:	9c12      	ldr	r4, [sp, #72]	; 0x48
    4e60:	ea8b 2697 	eor.w	r6, fp, r7, lsr #10
    4e64:	f8dd b040 	ldr.w	fp, [sp, #64]	; 0x40
    4e68:	44a0      	add	r8, r4
    4e6a:	ea41 0403 	orr.w	r4, r1, r3
    4e6e:	ea04 040b 	and.w	r4, r4, fp
    4e72:	940b      	str	r4, [sp, #44]	; 0x2c
    4e74:	ea80 0902 	eor.w	r9, r0, r2
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4e78:	9c1a      	ldr	r4, [sp, #104]	; 0x68
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e7a:	4446      	add	r6, r8
    4e7c:	ea05 0909 	and.w	r9, r5, r9
    4e80:	4466      	add	r6, ip
    4e82:	ea4f 0ab1 	mov.w	sl, r1, ror #2
    4e86:	ea4f 18b5 	mov.w	r8, r5, ror #6
    4e8a:	ea89 0902 	eor.w	r9, r9, r2
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4e8e:	ea4f 1cf4 	mov.w	ip, r4, ror #7
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e92:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    4e94:	ea01 0b03 	and.w	fp, r1, r3
    4e98:	44b1      	add	r9, r6
    4e9a:	ea8a 3a71 	eor.w	sl, sl, r1, ror #13
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4e9e:	9e1a      	ldr	r6, [sp, #104]	; 0x68
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ea0:	ea88 28f5 	eor.w	r8, r8, r5, ror #11
    4ea4:	ea8a 5ab1 	eor.w	sl, sl, r1, ror #22
    4ea8:	ea88 6875 	eor.w	r8, r8, r5, ror #25
    4eac:	ea44 0b0b 	orr.w	fp, r4, fp
    4eb0:	eb0b 040a 	add.w	r4, fp, sl
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4eb4:	ea8c 4cb6 	eor.w	ip, ip, r6, ror #18
    4eb8:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ebc:	eb09 0608 	add.w	r6, r9, r8
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4ec0:	4f34      	ldr	r7, [pc, #208]	; (4f94 <sha256_process+0x1f60>)
    4ec2:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
    4ec6:	f8dd 9068 	ldr.w	r9, [sp, #104]	; 0x68
    4eca:	4447      	add	r7, r8
    4ecc:	ea4f 487a 	mov.w	r8, sl, ror #17
    4ed0:	ea8c 0cd9 	eor.w	ip, ip, r9, lsr #3
    4ed4:	ea88 48fa 	eor.w	r8, r8, sl, ror #19
    4ed8:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
    4edc:	4467      	add	r7, ip
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ede:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4ee2:	4457      	add	r7, sl
    4ee4:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ee8:	4434      	add	r4, r6
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4eea:	ea85 0c00 	eor.w	ip, r5, r0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4eee:	445e      	add	r6, fp
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4ef0:	ea88 289a 	eor.w	r8, r8, sl, lsr #10
    4ef4:	ea06 0c0c 	and.w	ip, r6, ip
    4ef8:	4447      	add	r7, r8
    4efa:	ea8c 0c00 	eor.w	ip, ip, r0
    4efe:	4417      	add	r7, r2
    4f00:	ea44 0b01 	orr.w	fp, r4, r1
    4f04:	9a04      	ldr	r2, [sp, #16]
    4f06:	ea4f 09b4 	mov.w	r9, r4, ror #2
    4f0a:	4467      	add	r7, ip
    4f0c:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
    4f10:	ea0b 0b03 	and.w	fp, fp, r3
    4f14:	ea04 0a01 	and.w	sl, r4, r1
    4f18:	ea89 3974 	eor.w	r9, r9, r4, ror #13
    4f1c:	ea89 59b4 	eor.w	r9, r9, r4, ror #22
    4f20:	4494      	add	ip, r2
    4f22:	ea4b 0a0a 	orr.w	sl, fp, sl
    4f26:	9a08      	ldr	r2, [sp, #32]
    4f28:	44ca      	add	sl, r9
    4f2a:	4492      	add	sl, r2
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    ctx->state[7] += H;
    4f2c:	9a01      	ldr	r2, [sp, #4]
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f2e:	ea4f 18b6 	mov.w	r8, r6, ror #6
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    ctx->state[7] += H;
    4f32:	4410      	add	r0, r2
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    4f34:	9a05      	ldr	r2, [sp, #20]
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f36:	ea88 28f6 	eor.w	r8, r8, r6, ror #11

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    4f3a:	4413      	add	r3, r2
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    4f3c:	9a02      	ldr	r2, [sp, #8]
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f3e:	ea88 6876 	eor.w	r8, r8, r6, ror #25
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    4f42:	4415      	add	r5, r2
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    4f44:	9a06      	ldr	r2, [sp, #24]
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f46:	4447      	add	r7, r8

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    4f48:	4411      	add	r1, r2
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    4f4a:	9a07      	ldr	r2, [sp, #28]
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    4f4c:	f8dd 8064 	ldr.w	r8, [sp, #100]	; 0x64
    ctx->state[1] += B;
    4f50:	4414      	add	r4, r2
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    4f52:	9a03      	ldr	r2, [sp, #12]
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    4f54:	44ba      	add	sl, r7
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    4f56:	4416      	add	r6, r2

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    4f58:	4467      	add	r7, ip
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    4f5a:	f8c8 a008 	str.w	sl, [r8, #8]
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    4f5e:	f8c8 3014 	str.w	r3, [r8, #20]
    ctx->state[4] += E;
    4f62:	f8c8 7018 	str.w	r7, [r8, #24]
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    4f66:	f8c8 400c 	str.w	r4, [r8, #12]
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    4f6a:	f8c8 601c 	str.w	r6, [r8, #28]
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    4f6e:	f8c8 1010 	str.w	r1, [r8, #16]
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    4f72:	f8c8 5020 	str.w	r5, [r8, #32]
    ctx->state[7] += H;
    4f76:	f8c8 0024 	str.w	r0, [r8, #36]	; 0x24
}
    4f7a:	b01c      	add	sp, #112	; 0x70
    4f7c:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    4f80:	4770      	bx	lr
    4f82:	bf00      	nop
    4f84:	8cc70208 	sfmhi	f0, 2, [r7], {8}
    4f88:	90befffa 	ldrshtls	pc, [lr], sl	; <UNPREDICTABLE>
    4f8c:	a4506ceb 	ldrbge	r6, [r0], #-3307	; 0xceb
    4f90:	bef9a3f7 	mrclt	3, 7, sl, cr9, cr7, {7}
    4f94:	c67178f2 			; <UNDEFINED> instruction: 0xc67178f2

00004f98 <sha256_update>:

void sha256_update( sha256_context *ctx, uint8 *input, uint32 length )
{
    4f98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32 left, fill;

    if( ! length ) return;
    4f9c:	4617      	mov	r7, r2
    ctx->state[6] += G;
    ctx->state[7] += H;
}

void sha256_update( sha256_context *ctx, uint8 *input, uint32 length )
{
    4f9e:	4606      	mov	r6, r0
    4fa0:	4688      	mov	r8, r1
    uint32 left, fill;

    if( ! length ) return;
    4fa2:	b302      	cbz	r2, 4fe6 <sha256_update+0x4e>

    left = ctx->total[0] & 0x3F;
    4fa4:	6803      	ldr	r3, [r0, #0]
    fill = 64 - left;

    ctx->total[0] += length;
    4fa6:	441a      	add	r2, r3
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    4fa8:	4297      	cmp	r7, r2
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    4faa:	6002      	str	r2, [r0, #0]
{
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    4fac:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    4fb0:	d902      	bls.n	4fb8 <sha256_update+0x20>
        ctx->total[1]++;
    4fb2:	6842      	ldr	r2, [r0, #4]
    4fb4:	3201      	adds	r2, #1
    4fb6:	6042      	str	r2, [r0, #4]

    if( left && length >= fill )
    4fb8:	b9bb      	cbnz	r3, 4fea <sha256_update+0x52>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    4fba:	2f3f      	cmp	r7, #63	; 0x3f
    4fbc:	d912      	bls.n	4fe4 <sha256_update+0x4c>
    4fbe:	463d      	mov	r5, r7
    4fc0:	4644      	mov	r4, r8
    {
        sha256_process( ctx, input );
    4fc2:	4621      	mov	r1, r4
        length -= 64;
    4fc4:	3d40      	subs	r5, #64	; 0x40
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    4fc6:	4630      	mov	r0, r6
    4fc8:	f7fe f834 	bl	3034 <sha256_process>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    4fcc:	2d3f      	cmp	r5, #63	; 0x3f
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    4fce:	f104 0440 	add.w	r4, r4, #64	; 0x40
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    4fd2:	d8f6      	bhi.n	4fc2 <sha256_update+0x2a>
    4fd4:	f1a7 0340 	sub.w	r3, r7, #64	; 0x40
    4fd8:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
    4fdc:	3340      	adds	r3, #64	; 0x40
    4fde:	4498      	add	r8, r3
    4fe0:	f007 073f 	and.w	r7, r7, #63	; 0x3f
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    4fe4:	b9ef      	cbnz	r7, 5022 <sha256_update+0x8a>
    4fe6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    4fea:	f1c3 0440 	rsb	r4, r3, #64	; 0x40
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    4fee:	42a7      	cmp	r7, r4
    4ff0:	d208      	bcs.n	5004 <sha256_update+0x6c>
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    4ff2:	f103 0028 	add.w	r0, r3, #40	; 0x28
    4ff6:	4430      	add	r0, r6
    4ff8:	4641      	mov	r1, r8
    4ffa:	463a      	mov	r2, r7
                (void *) input, length );
    }
}
    4ffc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    5000:	f001 bb6e 	b.w	66e0 <memcpy>
    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
    5004:	f103 0028 	add.w	r0, r3, #40	; 0x28
    5008:	4641      	mov	r1, r8
    500a:	4622      	mov	r2, r4
    500c:	4430      	add	r0, r6
    500e:	f001 fb67 	bl	66e0 <memcpy>
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    5012:	4630      	mov	r0, r6
    5014:	f106 0128 	add.w	r1, r6, #40	; 0x28
    5018:	f7fe f80c 	bl	3034 <sha256_process>
        length -= fill;
    501c:	1b3f      	subs	r7, r7, r4
        input  += fill;
    501e:	44a0      	add	r8, r4
    5020:	e7cb      	b.n	4fba <sha256_update+0x22>
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    5022:	2300      	movs	r3, #0
    5024:	e7e5      	b.n	4ff2 <sha256_update+0x5a>
    5026:	bf00      	nop

00005028 <sha256_finish>:
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    5028:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32 last, padn;
    uint32 high, low;
    uint8 msglen[8];

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    502c:	e890 0088 	ldmia.w	r0, {r3, r7}
    low  = ( ctx->total[0] <<  3 );
    5030:	00da      	lsls	r2, r3, #3

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );

    last = ctx->total[0] & 0x3F;
    5032:	f003 063f 	and.w	r6, r3, #63	; 0x3f
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    5036:	b083      	sub	sp, #12
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    5038:	ea4f 6812 	mov.w	r8, r2, lsr #24

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    503c:	2e37      	cmp	r6, #55	; 0x37
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    503e:	f88d 8004 	strb.w	r8, [sp, #4]

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    5042:	bf94      	ite	ls
    5044:	f1c6 0838 	rsbls	r8, r6, #56	; 0x38
    5048:	f1c6 0878 	rsbhi	r8, r6, #120	; 0x78
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    504c:	4604      	mov	r4, r0
    uint32 last, padn;
    uint32 high, low;
    uint8 msglen[8];

    high = ( ctx->total[0] >> 29 )
    504e:	0f58      	lsrs	r0, r3, #29
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    5050:	4443      	add	r3, r8
{
    uint32 last, padn;
    uint32 high, low;
    uint8 msglen[8];

    high = ( ctx->total[0] >> 29 )
    5052:	ea40 00c7 	orr.w	r0, r0, r7, lsl #3
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    5056:	4598      	cmp	r8, r3

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    5058:	ea4f 6b10 	mov.w	fp, r0, lsr #24
    505c:	ea4f 4a10 	mov.w	sl, r0, lsr #16
    5060:	ea4f 2910 	mov.w	r9, r0, lsr #8
    PUT_UINT32( low,  msglen, 4 );
    5064:	ea4f 4c12 	mov.w	ip, r2, lsr #16
    5068:	ea4f 2e12 	mov.w	lr, r2, lsr #8

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;
    506c:	bf88      	it	hi
    506e:	3701      	addhi	r7, #1
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    5070:	460d      	mov	r5, r1

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    5072:	f88d 0003 	strb.w	r0, [sp, #3]
    5076:	f88d b000 	strb.w	fp, [sp]
    507a:	f88d a001 	strb.w	sl, [sp, #1]
    507e:	f88d 9002 	strb.w	r9, [sp, #2]
    PUT_UINT32( low,  msglen, 4 );
    5082:	f88d 2007 	strb.w	r2, [sp, #7]
    5086:	f88d c005 	strb.w	ip, [sp, #5]
    508a:	f88d e006 	strb.w	lr, [sp, #6]
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    508e:	6023      	str	r3, [r4, #0]
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;
    5090:	bf88      	it	hi
    5092:	6067      	strhi	r7, [r4, #4]

    if( left && length >= fill )
    5094:	2e00      	cmp	r6, #0
    5096:	f000 80a1 	beq.w	51dc <sha256_finish+0x1b4>
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    509a:	f1c6 0740 	rsb	r7, r6, #64	; 0x40
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    509e:	45b8      	cmp	r8, r7
    50a0:	d273      	bcs.n	518a <sha256_finish+0x162>
    50a2:	f8df 9198 	ldr.w	r9, [pc, #408]	; 523c <sha256_finish+0x214>
    50a6:	4642      	mov	r2, r8
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    50a8:	b12a      	cbz	r2, 50b6 <sha256_finish+0x8e>
    {
        memcpy( (void *) (ctx->buffer + left),
    50aa:	f106 0028 	add.w	r0, r6, #40	; 0x28
    50ae:	4420      	add	r0, r4
    50b0:	4649      	mov	r1, r9
    50b2:	f001 fb15 	bl	66e0 <memcpy>
{
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    50b6:	6822      	ldr	r2, [r4, #0]
    fill = 64 - left;

    ctx->total[0] += length;
    50b8:	f102 0308 	add.w	r3, r2, #8
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    50bc:	2b07      	cmp	r3, #7
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    50be:	6023      	str	r3, [r4, #0]
{
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    50c0:	f002 083f 	and.w	r8, r2, #63	; 0x3f
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    50c4:	d802      	bhi.n	50cc <sha256_finish+0xa4>
        ctx->total[1]++;
    50c6:	6863      	ldr	r3, [r4, #4]
    50c8:	3301      	adds	r3, #1
    50ca:	6063      	str	r3, [r4, #4]

    if( left && length >= fill )
    50cc:	f1b8 0f00 	cmp.w	r8, #0
    50d0:	d005      	beq.n	50de <sha256_finish+0xb6>
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    50d2:	f1c8 0940 	rsb	r9, r8, #64	; 0x40
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    50d6:	f1b9 0f08 	cmp.w	r9, #8
    50da:	f240 8082 	bls.w	51e2 <sha256_finish+0x1ba>
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    50de:	2608      	movs	r6, #8
    50e0:	46e9      	mov	r9, sp
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    50e2:	f108 0028 	add.w	r0, r8, #40	; 0x28
    50e6:	4420      	add	r0, r4
    50e8:	4649      	mov	r1, r9
    50ea:	4632      	mov	r2, r6
    50ec:	f001 faf8 	bl	66e0 <memcpy>
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    sha256_update( ctx, sha256_padding, padn );
    sha256_update( ctx, msglen, 8 );

    PUT_UINT32( ctx->state[0], digest,  0 );
    50f0:	7ae3      	ldrb	r3, [r4, #11]
    50f2:	702b      	strb	r3, [r5, #0]
    50f4:	8963      	ldrh	r3, [r4, #10]
    50f6:	706b      	strb	r3, [r5, #1]
    50f8:	68a3      	ldr	r3, [r4, #8]
    50fa:	0a1b      	lsrs	r3, r3, #8
    50fc:	70ab      	strb	r3, [r5, #2]
    50fe:	68a3      	ldr	r3, [r4, #8]
    5100:	70eb      	strb	r3, [r5, #3]
    PUT_UINT32( ctx->state[1], digest,  4 );
    5102:	7be3      	ldrb	r3, [r4, #15]
    5104:	712b      	strb	r3, [r5, #4]
    5106:	89e3      	ldrh	r3, [r4, #14]
    5108:	716b      	strb	r3, [r5, #5]
    510a:	68e3      	ldr	r3, [r4, #12]
    510c:	0a1b      	lsrs	r3, r3, #8
    510e:	71ab      	strb	r3, [r5, #6]
    5110:	68e3      	ldr	r3, [r4, #12]
    5112:	71eb      	strb	r3, [r5, #7]
    PUT_UINT32( ctx->state[2], digest,  8 );
    5114:	7ce3      	ldrb	r3, [r4, #19]
    5116:	722b      	strb	r3, [r5, #8]
    5118:	8a63      	ldrh	r3, [r4, #18]
    511a:	726b      	strb	r3, [r5, #9]
    511c:	6923      	ldr	r3, [r4, #16]
    511e:	0a1b      	lsrs	r3, r3, #8
    5120:	72ab      	strb	r3, [r5, #10]
    5122:	6923      	ldr	r3, [r4, #16]
    5124:	72eb      	strb	r3, [r5, #11]
    PUT_UINT32( ctx->state[3], digest, 12 );
    5126:	7de3      	ldrb	r3, [r4, #23]
    5128:	732b      	strb	r3, [r5, #12]
    512a:	8ae3      	ldrh	r3, [r4, #22]
    512c:	736b      	strb	r3, [r5, #13]
    512e:	6963      	ldr	r3, [r4, #20]
    5130:	0a1b      	lsrs	r3, r3, #8
    5132:	73ab      	strb	r3, [r5, #14]
    5134:	6963      	ldr	r3, [r4, #20]
    5136:	73eb      	strb	r3, [r5, #15]
    PUT_UINT32( ctx->state[4], digest, 16 );
    5138:	7ee3      	ldrb	r3, [r4, #27]
    513a:	742b      	strb	r3, [r5, #16]
    513c:	8b63      	ldrh	r3, [r4, #26]
    513e:	746b      	strb	r3, [r5, #17]
    5140:	69a3      	ldr	r3, [r4, #24]
    5142:	0a1b      	lsrs	r3, r3, #8
    5144:	74ab      	strb	r3, [r5, #18]
    5146:	69a3      	ldr	r3, [r4, #24]
    5148:	74eb      	strb	r3, [r5, #19]
    PUT_UINT32( ctx->state[5], digest, 20 );
    514a:	7fe3      	ldrb	r3, [r4, #31]
    514c:	752b      	strb	r3, [r5, #20]
    514e:	8be3      	ldrh	r3, [r4, #30]
    5150:	756b      	strb	r3, [r5, #21]
    5152:	69e3      	ldr	r3, [r4, #28]
    5154:	0a1b      	lsrs	r3, r3, #8
    5156:	75ab      	strb	r3, [r5, #22]
    5158:	69e3      	ldr	r3, [r4, #28]
    515a:	75eb      	strb	r3, [r5, #23]
    PUT_UINT32( ctx->state[6], digest, 24 );
    515c:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    5160:	762b      	strb	r3, [r5, #24]
    5162:	8c63      	ldrh	r3, [r4, #34]	; 0x22
    5164:	766b      	strb	r3, [r5, #25]
    5166:	6a23      	ldr	r3, [r4, #32]
    5168:	0a1b      	lsrs	r3, r3, #8
    516a:	76ab      	strb	r3, [r5, #26]
    516c:	6a23      	ldr	r3, [r4, #32]
    516e:	76eb      	strb	r3, [r5, #27]
    PUT_UINT32( ctx->state[7], digest, 28 );
    5170:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
    5174:	772b      	strb	r3, [r5, #28]
    5176:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
    5178:	776b      	strb	r3, [r5, #29]
    517a:	6a63      	ldr	r3, [r4, #36]	; 0x24
    517c:	0a1b      	lsrs	r3, r3, #8
    517e:	77ab      	strb	r3, [r5, #30]
    5180:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5182:	77eb      	strb	r3, [r5, #31]
    5184:	b003      	add	sp, #12
    5186:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
    518a:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 523c <sha256_finish+0x214>
    518e:	f106 0028 	add.w	r0, r6, #40	; 0x28
    5192:	4649      	mov	r1, r9
    5194:	4420      	add	r0, r4
    5196:	463a      	mov	r2, r7
    5198:	f001 faa2 	bl	66e0 <memcpy>
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    519c:	4620      	mov	r0, r4
    519e:	f104 0128 	add.w	r1, r4, #40	; 0x28
        length -= fill;
    51a2:	ebc7 0808 	rsb	r8, r7, r8
        input  += fill;
    51a6:	44b9      	add	r9, r7

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    51a8:	f7fd ff44 	bl	3034 <sha256_process>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    51ac:	f1b8 0f3f 	cmp.w	r8, #63	; 0x3f
    51b0:	d93a      	bls.n	5228 <sha256_finish+0x200>
    51b2:	4647      	mov	r7, r8
    51b4:	464e      	mov	r6, r9
    {
        sha256_process( ctx, input );
    51b6:	4631      	mov	r1, r6
        length -= 64;
    51b8:	3f40      	subs	r7, #64	; 0x40
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    51ba:	4620      	mov	r0, r4
    51bc:	f7fd ff3a 	bl	3034 <sha256_process>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    51c0:	2f3f      	cmp	r7, #63	; 0x3f
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    51c2:	f106 0640 	add.w	r6, r6, #64	; 0x40
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    51c6:	d8f6      	bhi.n	51b6 <sha256_finish+0x18e>
    51c8:	f1a8 0340 	sub.w	r3, r8, #64	; 0x40
    51cc:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
    51d0:	3340      	adds	r3, #64	; 0x40
    51d2:	4499      	add	r9, r3
    51d4:	f008 023f 	and.w	r2, r8, #63	; 0x3f
    51d8:	2600      	movs	r6, #0
    51da:	e765      	b.n	50a8 <sha256_finish+0x80>
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    51dc:	f8df 905c 	ldr.w	r9, [pc, #92]	; 523c <sha256_finish+0x214>
    51e0:	e7e4      	b.n	51ac <sha256_finish+0x184>
    {
        memcpy( (void *) (ctx->buffer + left),
    51e2:	f108 0028 	add.w	r0, r8, #40	; 0x28
    51e6:	464a      	mov	r2, r9
    51e8:	4669      	mov	r1, sp
    51ea:	4420      	add	r0, r4
    51ec:	f001 fa78 	bl	66e0 <memcpy>
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
    51f0:	f1a8 0638 	sub.w	r6, r8, #56	; 0x38
        input  += fill;
    51f4:	ab00      	add	r3, sp, #0

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    51f6:	4620      	mov	r0, r4
    51f8:	f104 0128 	add.w	r1, r4, #40	; 0x28
        length -= fill;
        input  += fill;
    51fc:	4499      	add	r9, r3

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    51fe:	f7fd ff19 	bl	3034 <sha256_process>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5202:	2e3f      	cmp	r6, #63	; 0x3f
    5204:	d913      	bls.n	522e <sha256_finish+0x206>
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
    5206:	464f      	mov	r7, r9
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    5208:	4639      	mov	r1, r7
        length -= 64;
    520a:	3e40      	subs	r6, #64	; 0x40
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    520c:	4620      	mov	r0, r4
    520e:	f7fd ff11 	bl	3034 <sha256_process>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5212:	2e3f      	cmp	r6, #63	; 0x3f
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    5214:	f107 0740 	add.w	r7, r7, #64	; 0x40
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5218:	d8f6      	bhi.n	5208 <sha256_finish+0x1e0>
    521a:	f108 0608 	add.w	r6, r8, #8
    521e:	f1a9 0940 	sub.w	r9, r9, #64	; 0x40
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    5222:	f04f 0800 	mov.w	r8, #0
    5226:	e75c      	b.n	50e2 <sha256_finish+0xba>
    }

    while( length >= 64 )
    5228:	4642      	mov	r2, r8
    522a:	2600      	movs	r6, #0
    522c:	e73c      	b.n	50a8 <sha256_finish+0x80>
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    522e:	2e00      	cmp	r6, #0
    5230:	f43f af5e 	beq.w	50f0 <sha256_finish+0xc8>
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    5234:	f04f 0800 	mov.w	r8, #0
    5238:	e753      	b.n	50e2 <sha256_finish+0xba>
    523a:	bf00      	nop
    523c:	200002c4 	andcs	r0, r0, r4, asr #5

00005240 <sha512_block>:
{
	return (x >> bits) | (x << (64 - bits));
}

void sha512_block(struct sha512_state *s, const uint8_t *blk)
{
    5240:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    5244:	b0e4      	sub	sp, #400	; 0x190
    5246:	460c      	mov	r4, r1
    5248:	9033      	str	r0, [sp, #204]	; 0xcc
    524a:	f101 0c80 	add.w	ip, r1, #128	; 0x80
    524e:	ad42      	add	r5, sp, #264	; 0x108

static inline uint64_t load64(const uint8_t *x)
{
	uint64_t r;

	r = *(x++);
    5250:	7820      	ldrb	r0, [r4, #0]
	r = (r << 8) | *(x++);
    5252:	2100      	movs	r1, #0
    5254:	0e02      	lsrs	r2, r0, #24
    5256:	0203      	lsls	r3, r0, #8
    5258:	9211      	str	r2, [sp, #68]	; 0x44
    525a:	7860      	ldrb	r0, [r4, #1]
    525c:	9310      	str	r3, [sp, #64]	; 0x40
    525e:	e9dd 6710 	ldrd	r6, r7, [sp, #64]	; 0x40
    5262:	4339      	orrs	r1, r7
    5264:	4330      	orrs	r0, r6
	r = (r << 8) | *(x++);
    5266:	020f      	lsls	r7, r1, #8
    5268:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
    526c:	0206      	lsls	r6, r0, #8
    526e:	2100      	movs	r1, #0
    5270:	78a0      	ldrb	r0, [r4, #2]
    5272:	4339      	orrs	r1, r7
    5274:	4330      	orrs	r0, r6
	r = (r << 8) | *(x++);
    5276:	ea4f 2801 	mov.w	r8, r1, lsl #8
    527a:	ea48 6910 	orr.w	r9, r8, r0, lsr #24
    527e:	ea4f 2a00 	mov.w	sl, r0, lsl #8
    5282:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
    5286:	78e0      	ldrb	r0, [r4, #3]
    5288:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
    528c:	2100      	movs	r1, #0
    528e:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
    5292:	4319      	orrs	r1, r3
    5294:	4310      	orrs	r0, r2
	r = (r << 8) | *(x++);
    5296:	020b      	lsls	r3, r1, #8
    5298:	ea43 6810 	orr.w	r8, r3, r0, lsr #24
    529c:	ea4f 2900 	mov.w	r9, r0, lsl #8
    52a0:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
    52a4:	7920      	ldrb	r0, [r4, #4]
    52a6:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
    52aa:	2100      	movs	r1, #0
    52ac:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
    52b0:	ea41 010b 	orr.w	r1, r1, fp
    52b4:	ea40 000a 	orr.w	r0, r0, sl
	r = (r << 8) | *(x++);
    52b8:	ea4f 2b01 	mov.w	fp, r1, lsl #8
    52bc:	ea4b 6b10 	orr.w	fp, fp, r0, lsr #24
    52c0:	ea4f 2a00 	mov.w	sl, r0, lsl #8
    52c4:	2100      	movs	r1, #0
    52c6:	7960      	ldrb	r0, [r4, #5]
    52c8:	ea41 010b 	orr.w	r1, r1, fp
    52cc:	ea40 000a 	orr.w	r0, r0, sl
	r = (r << 8) | *(x++);
    52d0:	ea4f 2901 	mov.w	r9, r1, lsl #8
    52d4:	ea49 6910 	orr.w	r9, r9, r0, lsr #24
    52d8:	ea4f 2800 	mov.w	r8, r0, lsl #8
    52dc:	2100      	movs	r1, #0
    52de:	79a0      	ldrb	r0, [r4, #6]
    52e0:	ea41 0109 	orr.w	r1, r1, r9
    52e4:	ea40 0008 	orr.w	r0, r0, r8
	r = (r << 8) | *(x++);
    52e8:	020b      	lsls	r3, r1, #8
    52ea:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
    52ee:	0202      	lsls	r2, r0, #8
    52f0:	79e0      	ldrb	r0, [r4, #7]
    52f2:	2100      	movs	r1, #0
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
		w[i] = load64(blk);
		blk += 8;
    52f4:	3408      	adds	r4, #8
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
    52f6:	4310      	orrs	r0, r2
    52f8:	4319      	orrs	r1, r3
{
	uint64_t w[16];
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
    52fa:	4564      	cmp	r4, ip
		w[i] = load64(blk);
    52fc:	e9e5 0102 	strd	r0, r1, [r5, #8]!
{
	uint64_t w[16];
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
    5300:	d1a6      	bne.n	5250 <sha512_block+0x10>
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
    5302:	9b33      	ldr	r3, [sp, #204]	; 0xcc
	c = s->h[2];
    5304:	9d33      	ldr	r5, [sp, #204]	; 0xcc
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
    5306:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    530a:	9933      	ldr	r1, [sp, #204]	; 0xcc
	b = s->h[1];
    530c:	e9cd 2336 	strd	r2, r3, [sp, #216]	; 0xd8
	c = s->h[2];
    5310:	e9d5 4504 	ldrd	r4, r5, [r5, #16]
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    5314:	e9d1 0100 	ldrd	r0, r1, [r1]
	b = s->h[1];
    5318:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    531c:	9a33      	ldr	r2, [sp, #204]	; 0xcc
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    531e:	e9cd 4538 	strd	r4, r5, [sp, #224]	; 0xe0
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    5322:	f102 0330 	add.w	r3, r2, #48	; 0x30
    5326:	e9d3 2300 	ldrd	r2, r3, [r3]
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    532a:	e9cd 450e 	strd	r4, r5, [sp, #56]	; 0x38
	d = s->h[3];
    532e:	9f33      	ldr	r7, [sp, #204]	; 0xcc
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    5330:	ac40      	add	r4, sp, #256	; 0x100
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    5332:	4689      	mov	r9, r1
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    5334:	e9c4 2300 	strd	r2, r3, [r4]

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    5338:	e9d7 6706 	ldrd	r6, r7, [r7, #24]
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    533c:	e9cd 0134 	strd	r0, r1, [sp, #208]	; 0xd0
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
    5340:	f8dd b0cc 	ldr.w	fp, [sp, #204]	; 0xcc
	f = s->h[5];
    5344:	9933      	ldr	r1, [sp, #204]	; 0xcc
	g = s->h[6];
	h = s->h[7];
    5346:	9c33      	ldr	r4, [sp, #204]	; 0xcc

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    5348:	e9cd 673a 	strd	r6, r7, [sp, #232]	; 0xe8
	e = s->h[4];
    534c:	e9db ab08 	ldrd	sl, fp, [fp, #32]
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    5350:	f104 0538 	add.w	r5, r4, #56	; 0x38
    5354:	e9d5 4500 	ldrd	r4, r5, [r5]

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    5358:	e9cd 672a 	strd	r6, r7, [sp, #168]	; 0xa8
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    535c:	ae42      	add	r6, sp, #264	; 0x108
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    535e:	4680      	mov	r8, r0
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
    5360:	f04f 0c00 	mov.w	ip, #0
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
    5364:	e9d1 010a 	ldrd	r0, r1, [r1, #40]	; 0x28
	g = s->h[6];
    5368:	461f      	mov	r7, r3
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
    536a:	e9cd 013e 	strd	r0, r1, [sp, #248]	; 0xf8
    536e:	e9cd 0114 	strd	r0, r1, [sp, #80]	; 0x50
	g = s->h[6];
	h = s->h[7];
    5372:	465b      	mov	r3, fp
    5374:	e9c6 4500 	strd	r4, r5, [r6]
    5378:	4620      	mov	r0, r4
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    537a:	4616      	mov	r6, r2
	h = s->h[7];
    537c:	4629      	mov	r1, r5
    537e:	4652      	mov	r2, sl
	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
    5380:	e9cd ab3c 	strd	sl, fp, [sp, #240]	; 0xf0
    5384:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    5388:	46c2      	mov	sl, r8
    538a:	46cb      	mov	fp, r9
    538c:	4690      	mov	r8, r2
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    538e:	e9cd 6712 	strd	r6, r7, [sp, #72]	; 0x48
	h = s->h[7];
    5392:	e9cd 012c 	strd	r0, r1, [sp, #176]	; 0xb0
    5396:	4699      	mov	r9, r3
    5398:	4662      	mov	r2, ip
    539a:	e018      	b.n	53ce <sha512_block+0x18e>

		/* Update round state */
		h = g;
		g = f;
		f = e;
		e = d + temp1;
    539c:	e9dd 4512 	ldrd	r4, r5, [sp, #72]	; 0x48
    53a0:	e9dd 670e 	ldrd	r6, r7, [sp, #56]	; 0x38
    53a4:	e9cd 452c 	strd	r4, r5, [sp, #176]	; 0xb0
    53a8:	e9dd 4514 	ldrd	r4, r5, [sp, #80]	; 0x50
    53ac:	e9cd 672a 	strd	r6, r7, [sp, #168]	; 0xa8
    53b0:	e9dd 670c 	ldrd	r6, r7, [sp, #48]	; 0x30
    53b4:	e9cd 4512 	strd	r4, r5, [sp, #72]	; 0x48
    53b8:	e9cd 670e 	strd	r6, r7, [sp, #56]	; 0x38
    53bc:	e9cd 8914 	strd	r8, r9, [sp, #80]	; 0x50
    53c0:	4690      	mov	r8, r2
    53c2:	9a10      	ldr	r2, [sp, #64]	; 0x40
    53c4:	e9cd ab0c 	strd	sl, fp, [sp, #48]	; 0x30
    53c8:	4699      	mov	r9, r3
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
    53ca:	4682      	mov	sl, r0
    53cc:	468b      	mov	fp, r1
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
    53ce:	ab64      	add	r3, sp, #400	; 0x190
    53d0:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    53d4:	ea4f 4298 	mov.w	r2, r8, lsr #18
    53d8:	ea42 3289 	orr.w	r2, r2, r9, lsl #14
    53dc:	9216      	str	r2, [sp, #88]	; 0x58
    53de:	ea4f 3298 	mov.w	r2, r8, lsr #14
    53e2:	ea42 4289 	orr.w	r2, r2, r9, lsl #18
    53e6:	9218      	str	r2, [sp, #96]	; 0x60
    53e8:	ea4f 4299 	mov.w	r2, r9, lsr #18
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    53ec:	f10c 0c01 	add.w	ip, ip, #1
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    53f0:	ea42 3288 	orr.w	r2, r2, r8, lsl #14
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    53f4:	f00c 040f 	and.w	r4, ip, #15
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    53f8:	9217      	str	r2, [sp, #92]	; 0x5c
    53fa:	ea4f 3299 	mov.w	r2, r9, lsr #14
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    53fe:	eb03 01c4 	add.w	r1, r3, r4, lsl #3
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5402:	ea42 4288 	orr.w	r2, r2, r8, lsl #18
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    5406:	e951 0120 	ldrd	r0, r1, [r1, #-128]	; 0x80
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    540a:	9219      	str	r2, [sp, #100]	; 0x64
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    540c:	09c6      	lsrs	r6, r0, #7
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    540e:	9410      	str	r4, [sp, #64]	; 0x40
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5410:	ea4f 52c8 	mov.w	r2, r8, lsl #23
    5414:	0844      	lsrs	r4, r0, #1
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5416:	ea46 6741 	orr.w	r7, r6, r1, lsl #25
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    541a:	ea44 74c1 	orr.w	r4, r4, r1, lsl #31
    541e:	ea42 2259 	orr.w	r2, r2, r9, lsr #9
    5422:	f10c 030d 	add.w	r3, ip, #13
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5426:	9708      	str	r7, [sp, #32]
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5428:	9422      	str	r4, [sp, #136]	; 0x88
    542a:	921a      	str	r2, [sp, #104]	; 0x68
    542c:	0a04      	lsrs	r4, r0, #8

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    542e:	af64      	add	r7, sp, #400	; 0x190
    5430:	f003 030f 	and.w	r3, r3, #15
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5434:	ea4f 52c9 	mov.w	r2, r9, lsl #23
    5438:	ea44 6401 	orr.w	r4, r4, r1, lsl #24
    543c:	084e      	lsrs	r6, r1, #1

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    543e:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5442:	ea42 2258 	orr.w	r2, r2, r8, lsr #9
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5446:	09cf      	lsrs	r7, r1, #7
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5448:	ea46 76c0 	orr.w	r6, r6, r0, lsl #31
    544c:	9424      	str	r4, [sp, #144]	; 0x90
    544e:	921b      	str	r2, [sp, #108]	; 0x6c
    5450:	0a09      	lsrs	r1, r1, #8

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    5452:	e953 2320 	ldrd	r2, r3, [r3, #-128]	; 0x80
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5456:	0994      	lsrs	r4, r2, #6
    5458:	940a      	str	r4, [sp, #40]	; 0x28
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    545a:	9709      	str	r7, [sp, #36]	; 0x24
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    545c:	9623      	str	r6, [sp, #140]	; 0x8c
    545e:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
    5462:	9125      	str	r1, [sp, #148]	; 0x94
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5464:	e9dd 6722 	ldrd	r6, r7, [sp, #136]	; 0x88
    5468:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    546c:	404f      	eors	r7, r1
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    546e:	990a      	ldr	r1, [sp, #40]	; 0x28
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5470:	4046      	eors	r6, r0
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5472:	ea41 6183 	orr.w	r1, r1, r3, lsl #26
    5476:	910a      	str	r1, [sp, #40]	; 0x28
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5478:	0cd1      	lsrs	r1, r2, #19
    547a:	ea41 3143 	orr.w	r1, r1, r3, lsl #13
    547e:	9126      	str	r1, [sp, #152]	; 0x98
    5480:	ea4f 718a 	mov.w	r1, sl, lsl #30
    5484:	ea41 019b 	orr.w	r1, r1, fp, lsr #2
    5488:	911c      	str	r1, [sp, #112]	; 0x70
    548a:	ea4f 711a 	mov.w	r1, sl, lsr #28
    548e:	ea41 110b 	orr.w	r1, r1, fp, lsl #4
    5492:	911e      	str	r1, [sp, #120]	; 0x78
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
    5494:	e9dd 0124 	ldrd	r0, r1, [sp, #144]	; 0x90
    5498:	4070      	eors	r0, r6
    549a:	4079      	eors	r1, r7
    549c:	e9cd 0130 	strd	r0, r1, [sp, #192]	; 0xc0
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
    54a0:	e9dd 6718 	ldrd	r6, r7, [sp, #96]	; 0x60
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    54a4:	0999      	lsrs	r1, r3, #6
    54a6:	910b      	str	r1, [sp, #44]	; 0x2c

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
    54a8:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
    54ac:	4070      	eors	r0, r6
    54ae:	4079      	eors	r1, r7
    54b0:	f10c 0408 	add.w	r4, ip, #8
    54b4:	e9dd 671a 	ldrd	r6, r7, [sp, #104]	; 0x68
    54b8:	4046      	eors	r6, r0
    54ba:	404f      	eors	r7, r1
    54bc:	e9cd 672e 	strd	r6, r7, [sp, #184]	; 0xb8
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    54c0:	e9dd 0130 	ldrd	r0, r1, [sp, #192]	; 0xc0
	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
    54c4:	af64      	add	r7, sp, #400	; 0x190
    54c6:	f004 040f 	and.w	r4, r4, #15
    54ca:	eb07 04c4 	add.w	r4, r7, r4, lsl #3
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    54ce:	e955 6720 	ldrd	r6, r7, [r5, #-128]	; 0x80
    54d2:	1980      	adds	r0, r0, r6
    54d4:	eb41 0107 	adc.w	r1, r1, r7
    54d8:	e9cd 0130 	strd	r0, r1, [sp, #192]	; 0xc0
    54dc:	e954 0120 	ldrd	r0, r1, [r4, #-128]	; 0x80
    54e0:	e9dd 6730 	ldrd	r6, r7, [sp, #192]	; 0xc0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54e4:	0cdc      	lsrs	r4, r3, #19
    54e6:	ea44 3442 	orr.w	r4, r4, r2, lsl #13
    54ea:	9427      	str	r4, [sp, #156]	; 0x9c
    54ec:	00d4      	lsls	r4, r2, #3
    54ee:	ea44 7453 	orr.w	r4, r4, r3, lsr #29
    54f2:	00db      	lsls	r3, r3, #3
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    54f4:	1980      	adds	r0, r0, r6
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54f6:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    54fa:	eb41 0107 	adc.w	r1, r1, r7
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54fe:	9428      	str	r4, [sp, #160]	; 0xa0
    5500:	9329      	str	r3, [sp, #164]	; 0xa4
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5502:	e9dd 6726 	ldrd	r6, r7, [sp, #152]	; 0x98
    5506:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
    550a:	4056      	eors	r6, r2
    550c:	405f      	eors	r7, r3
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
    550e:	e9dd 2328 	ldrd	r2, r3, [sp, #160]	; 0xa0
    5512:	4056      	eors	r6, r2
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    5514:	1982      	adds	r2, r0, r6
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
    5516:	ea87 0703 	eor.w	r7, r7, r3
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    551a:	eb41 0307 	adc.w	r3, r1, r7
    551e:	e9cd 2330 	strd	r2, r3, [sp, #192]	; 0xc0
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
    5522:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    5526:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
    552a:	ea20 0008 	bic.w	r0, r0, r8
    552e:	ea02 0208 	and.w	r2, r2, r8
    5532:	ea03 0309 	and.w	r3, r3, r9
    5536:	ea21 0109 	bic.w	r1, r1, r9
    553a:	4050      	eors	r0, r2
    553c:	4059      	eors	r1, r3
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    553e:	ea4f 738b 	mov.w	r3, fp, lsl #30

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5542:	e9dd 672e 	ldrd	r6, r7, [sp, #184]	; 0xb8
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5546:	ea43 039a 	orr.w	r3, r3, sl, lsr #2

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    554a:	1980      	adds	r0, r0, r6
    554c:	eb41 0107 	adc.w	r1, r1, r7
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5550:	931d      	str	r3, [sp, #116]	; 0x74

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5552:	e955 6720 	ldrd	r6, r7, [r5, #-128]	; 0x80
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5556:	ea4f 634a 	mov.w	r3, sl, lsl #25

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    555a:	1836      	adds	r6, r6, r0
    555c:	eb47 0701 	adc.w	r7, r7, r1
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5560:	ea43 13db 	orr.w	r3, r3, fp, lsr #7
    5564:	ea4f 721b 	mov.w	r2, fp, lsr #28
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5568:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    556c:	ea42 120a 	orr.w	r2, r2, sl, lsl #4
    5570:	9320      	str	r3, [sp, #128]	; 0x80

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5572:	e9cd 672e 	strd	r6, r7, [sp, #184]	; 0xb8
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5576:	e9dd 670e 	ldrd	r6, r7, [sp, #56]	; 0x38
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    557a:	ea4f 634b 	mov.w	r3, fp, lsl #25
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    557e:	404f      	eors	r7, r1
    5580:	4953      	ldr	r1, [pc, #332]	; (56d0 <sha512_block+0x490>)
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5582:	921f      	str	r2, [sp, #124]	; 0x7c
    5584:	ea43 13da 	orr.w	r3, r3, sl, lsr #7
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5588:	4046      	eors	r6, r0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    558a:	9321      	str	r3, [sp, #132]	; 0x84
    558c:	eb01 04cc 	add.w	r4, r1, ip, lsl #3
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
    5590:	e9dd 231c 	ldrd	r2, r3, [sp, #112]	; 0x70
    5594:	e9dd 011e 	ldrd	r0, r1, [sp, #120]	; 0x78
    5598:	4042      	eors	r2, r0
    559a:	404b      	eors	r3, r1
    559c:	e9dd 0120 	ldrd	r0, r1, [sp, #128]	; 0x80
    55a0:	4050      	eors	r0, r2
    55a2:	4059      	eors	r1, r3
    55a4:	e9cd 0100 	strd	r0, r1, [sp]
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55a8:	e9dd 2330 	ldrd	r2, r3, [sp, #192]	; 0xc0

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55ac:	e9dd 012e 	ldrd	r0, r1, [sp, #184]	; 0xb8
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55b0:	e945 2320 	strd	r2, r3, [r5, #-128]	; 0x80

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55b4:	f1a4 0508 	sub.w	r5, r4, #8
    55b8:	e9d5 4500 	ldrd	r4, r5, [r5]
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    55bc:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55c0:	1900      	adds	r0, r0, r4
    55c2:	eb41 0105 	adc.w	r1, r1, r5
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    55c6:	ea06 060a 	and.w	r6, r6, sl
    55ca:	ea07 070b 	and.w	r7, r7, fp
    55ce:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
    55d2:	4014      	ands	r4, r2
    55d4:	401d      	ands	r5, r3
    55d6:	4074      	eors	r4, r6
    55d8:	407d      	eors	r5, r7

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55da:	e9dd 672c 	ldrd	r6, r7, [sp, #176]	; 0xb0
    55de:	1980      	adds	r0, r0, r6
    55e0:	eb41 0107 	adc.w	r1, r1, r7
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
		const uint64_t temp2 = S0 + maj;
    55e4:	e9dd 2300 	ldrd	r2, r3, [sp]
    55e8:	18a4      	adds	r4, r4, r2
    55ea:	eb45 0503 	adc.w	r5, r5, r3

		/* Update round state */
		h = g;
		g = f;
		f = e;
		e = d + temp1;
    55ee:	e9dd 232a 	ldrd	r2, r3, [sp, #168]	; 0xa8
    55f2:	1812      	adds	r2, r2, r0
    55f4:	eb43 0301 	adc.w	r3, r3, r1
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
    55f8:	1900      	adds	r0, r0, r4
    55fa:	eb41 0105 	adc.w	r1, r1, r5
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
    55fe:	f1bc 0f50 	cmp.w	ip, #80	; 0x50
    5602:	f47f aecb 	bne.w	539c <sha512_block+0x15c>
    5606:	4614      	mov	r4, r2
    5608:	461d      	mov	r5, r3
    560a:	4602      	mov	r2, r0
    560c:	460b      	mov	r3, r1
    560e:	4640      	mov	r0, r8
    5610:	4649      	mov	r1, r9
    5612:	46d0      	mov	r8, sl
    5614:	46d9      	mov	r9, fp
    5616:	4682      	mov	sl, r0
    5618:	468b      	mov	fp, r1
    561a:	4620      	mov	r0, r4
    561c:	4629      	mov	r1, r5
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    561e:	e9dd 4534 	ldrd	r4, r5, [sp, #208]	; 0xd0
    5622:	18a4      	adds	r4, r4, r2
    5624:	eb45 0503 	adc.w	r5, r5, r3
	s->h[1] += b;
    5628:	e9dd 6736 	ldrd	r6, r7, [sp, #216]	; 0xd8
    562c:	eb16 0608 	adds.w	r6, r6, r8
    5630:	eb47 0709 	adc.w	r7, r7, r9
	s->h[2] += c;
    5634:	e9dd 2338 	ldrd	r2, r3, [sp, #224]	; 0xe0
    5638:	e9dd 890c 	ldrd	r8, r9, [sp, #48]	; 0x30
    563c:	eb18 0802 	adds.w	r8, r8, r2
    5640:	eb49 0903 	adc.w	r9, r9, r3
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5644:	e9cd 4506 	strd	r4, r5, [sp, #24]
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    5648:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
	s->h[4] += e;
    564c:	e9dd 233c 	ldrd	r2, r3, [sp, #240]	; 0xf0
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
    5650:	e9cd 6704 	strd	r6, r7, [sp, #16]
	s->h[2] += c;
	s->h[3] += d;
    5654:	e9dd 673a 	ldrd	r6, r7, [sp, #232]	; 0xe8
    5658:	19a4      	adds	r4, r4, r6
    565a:	eb45 0507 	adc.w	r5, r5, r7
	s->h[4] += e;
    565e:	1880      	adds	r0, r0, r2
    5660:	eb41 0103 	adc.w	r1, r1, r3
	s->h[5] += f;
	s->h[6] += g;
    5664:	af40      	add	r7, sp, #256	; 0x100
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
    5666:	e9dd 233e 	ldrd	r2, r3, [sp, #248]	; 0xf8
    566a:	eb12 020a 	adds.w	r2, r2, sl
    566e:	eb43 030b 	adc.w	r3, r3, fp
	s->h[6] += g;
    5672:	e9d7 6700 	ldrd	r6, r7, [r7]

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    5676:	e9cd 4502 	strd	r4, r5, [sp, #8]
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    567a:	e9dd 4514 	ldrd	r4, r5, [sp, #80]	; 0x50
	s->h[7] += h;
    567e:	f50d 7b84 	add.w	fp, sp, #264	; 0x108
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    5682:	19a4      	adds	r4, r4, r6
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5684:	f8dd c0cc 	ldr.w	ip, [sp, #204]	; 0xcc
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    5688:	eb45 0507 	adc.w	r5, r5, r7
	s->h[7] += h;
    568c:	e9db ab00 	ldrd	sl, fp, [fp]
    5690:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
    5694:	eb16 060a 	adds.w	r6, r6, sl
    5698:	eb47 070b 	adc.w	r7, r7, fp
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
    569c:	e9cc 8904 	strd	r8, r9, [ip, #16]
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    56a0:	e9dd ab06 	ldrd	sl, fp, [sp, #24]
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    56a4:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    56a8:	e9cc ab00 	strd	sl, fp, [ip]
	s->h[1] += b;
    56ac:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
	s->h[2] += c;
	s->h[3] += d;
    56b0:	e9cc 8906 	strd	r8, r9, [ip, #24]
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
    56b4:	e9cc ab02 	strd	sl, fp, [ip, #8]
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
    56b8:	e9cc 0108 	strd	r0, r1, [ip, #32]
	s->h[5] += f;
    56bc:	e9cc 230a 	strd	r2, r3, [ip, #40]	; 0x28
	s->h[6] += g;
    56c0:	e9cc 450c 	strd	r4, r5, [ip, #48]	; 0x30
	s->h[7] += h;
    56c4:	e9cc 670e 	strd	r6, r7, [ip, #56]	; 0x38
}
    56c8:	b064      	add	sp, #400	; 0x190
    56ca:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    56ce:	4770      	bx	lr
    56d0:	00007248 	andeq	r7, r0, r8, asr #4

000056d4 <sha512_final>:

void sha512_final(struct sha512_state *s, const uint8_t *blk,
		  size_t total_size)
{
    56d4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
    56d8:	2580      	movs	r5, #128	; 0x80
	s->h[7] += h;
}

void sha512_final(struct sha512_state *s, const uint8_t *blk,
		  size_t total_size)
{
    56da:	b0a0      	sub	sp, #128	; 0x80
    56dc:	4614      	mov	r4, r2
    56de:	4682      	mov	sl, r0
    56e0:	460f      	mov	r7, r1
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
    56e2:	4668      	mov	r0, sp
    56e4:	462a      	mov	r2, r5
    56e6:	2100      	movs	r1, #0
    56e8:	f001 f821 	bl	672e <memset>
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
    56ec:	f014 067f 	ands.w	r6, r4, #127	; 0x7f
    56f0:	d11e      	bne.n	5730 <sha512_final+0x5c>
		memcpy(temp, blk, last_size);
	temp[last_size] = 0x80;
    56f2:	f88d 5000 	strb.w	r5, [sp]
		sha512_block(s, temp);
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
    56f6:	00e2      	lsls	r2, r4, #3

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    56f8:	0a14      	lsrs	r4, r2, #8
	*(x--) = v;
	v >>= 8;
    56fa:	0a26      	lsrs	r6, r4, #8

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    56fc:	2500      	movs	r5, #0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    56fe:	ea4f 2816 	mov.w	r8, r6, lsr #8
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
	sha512_block(s, temp);
    5702:	4650      	mov	r0, sl
    5704:	4669      	mov	r1, sp
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5706:	f88d 207f 	strb.w	r2, [sp, #127]	; 0x7f
	v >>= 8;
	*(x--) = v;
    570a:	f88d 407e 	strb.w	r4, [sp, #126]	; 0x7e
	v >>= 8;
	*(x--) = v;
    570e:	f88d 607d 	strb.w	r6, [sp, #125]	; 0x7d
	v >>= 8;
	*(x--) = v;
    5712:	f88d 807c 	strb.w	r8, [sp, #124]	; 0x7c
	v >>= 8;
	*(x--) = v;
    5716:	f88d 507b 	strb.w	r5, [sp, #123]	; 0x7b
	v >>= 8;
	*(x--) = v;
    571a:	f88d 507a 	strb.w	r5, [sp, #122]	; 0x7a
	v >>= 8;
	*(x--) = v;
    571e:	f88d 5079 	strb.w	r5, [sp, #121]	; 0x79
	v >>= 8;
	*(x--) = v;
    5722:	f88d 5078 	strb.w	r5, [sp, #120]	; 0x78
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
	sha512_block(s, temp);
    5726:	f7ff fd8b 	bl	5240 <sha512_block>
}
    572a:	b020      	add	sp, #128	; 0x80
    572c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
{
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
		memcpy(temp, blk, last_size);
    5730:	4639      	mov	r1, r7
    5732:	4668      	mov	r0, sp
    5734:	4632      	mov	r2, r6
    5736:	f000 ffd3 	bl	66e0 <memcpy>
	temp[last_size] = 0x80;
    573a:	eb0d 0305 	add.w	r3, sp, r5
    573e:	4433      	add	r3, r6

	if (last_size > 111) {
    5740:	2e6f      	cmp	r6, #111	; 0x6f
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
		memcpy(temp, blk, last_size);
	temp[last_size] = 0x80;
    5742:	f803 5c80 	strb.w	r5, [r3, #-128]

	if (last_size > 111) {
    5746:	d9d6      	bls.n	56f6 <sha512_final+0x22>
		sha512_block(s, temp);
    5748:	4650      	mov	r0, sl
    574a:	4669      	mov	r1, sp
    574c:	f7ff fd78 	bl	5240 <sha512_block>
		memset(temp, 0, sizeof(temp));
    5750:	4668      	mov	r0, sp
    5752:	462a      	mov	r2, r5
    5754:	2100      	movs	r1, #0
    5756:	f000 ffea 	bl	672e <memset>
    575a:	e7cc      	b.n	56f6 <sha512_final+0x22>

0000575c <sha512_get>:
	sha512_block(s, temp);
}

void sha512_get(const struct sha512_state *s, uint8_t *hash,
		unsigned int offset, unsigned int len)
{
    575c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int i;

	if (offset > SHA512_BLOCK_SIZE)
    5760:	2a80      	cmp	r2, #128	; 0x80
	sha512_block(s, temp);
}

void sha512_get(const struct sha512_state *s, uint8_t *hash,
		unsigned int offset, unsigned int len)
{
    5762:	b09b      	sub	sp, #108	; 0x6c
    5764:	9014      	str	r0, [sp, #80]	; 0x50
    5766:	910f      	str	r1, [sp, #60]	; 0x3c
	int i;

	if (offset > SHA512_BLOCK_SIZE)
    5768:	d87b      	bhi.n	5862 <sha512_get+0x106>
		return;

	if (len > SHA512_BLOCK_SIZE - offset)
    576a:	f1c2 0180 	rsb	r1, r2, #128	; 0x80
    576e:	4299      	cmp	r1, r3
    5770:	bf28      	it	cs
    5772:	4619      	movcs	r1, r3
		len = SHA512_BLOCK_SIZE - offset;

	/* Skip whole words */
	i = offset >> 3;
    5774:	08d0      	lsrs	r0, r2, #3
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
    5776:	f012 0207 	ands.w	r2, r2, #7
    577a:	910d      	str	r1, [sp, #52]	; 0x34

	if (len > SHA512_BLOCK_SIZE - offset)
		len = SHA512_BLOCK_SIZE - offset;

	/* Skip whole words */
	i = offset >> 3;
    577c:	900e      	str	r0, [sp, #56]	; 0x38
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
    577e:	9215      	str	r2, [sp, #84]	; 0x54
    5780:	d172      	bne.n	5868 <sha512_get+0x10c>
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    5782:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    5784:	2d07      	cmp	r5, #7
    5786:	d969      	bls.n	585c <sha512_get+0x100>
    5788:	f1a5 0308 	sub.w	r3, r5, #8
    578c:	08db      	lsrs	r3, r3, #3
    578e:	980e      	ldr	r0, [sp, #56]	; 0x38
    5790:	9c14      	ldr	r4, [sp, #80]	; 0x50
    5792:	469c      	mov	ip, r3
    5794:	4484      	add	ip, r0
    5796:	930a      	str	r3, [sp, #40]	; 0x28
    5798:	f104 0308 	add.w	r3, r4, #8
    579c:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
    57a0:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
    57a4:	990f      	ldr	r1, [sp, #60]	; 0x3c
    57a6:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
    57aa:	9012      	str	r0, [sp, #72]	; 0x48
		store64(hash, s->h[i++]);
    57ac:	9c12      	ldr	r4, [sp, #72]	; 0x48
    57ae:	e8f4 2302 	ldrd	r2, r3, [r4], #8
    57b2:	e9cd 2306 	strd	r2, r3, [sp, #24]

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    57b6:	9d06      	ldr	r5, [sp, #24]
    57b8:	f8dd c01c 	ldr.w	ip, [sp, #28]
    57bc:	0a2a      	lsrs	r2, r5, #8
    57be:	ea42 620c 	orr.w	r2, r2, ip, lsl #24
    57c2:	ea4f 231c 	mov.w	r3, ip, lsr #8
	*(x--) = v;
	v >>= 8;
    57c6:	0a10      	lsrs	r0, r2, #8
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
		store64(hash, s->h[i++]);
    57c8:	9412      	str	r4, [sp, #72]	; 0x48
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57ca:	ea40 6403 	orr.w	r4, r0, r3, lsl #24
    57ce:	0a1d      	lsrs	r5, r3, #8
	*(x--) = v;
	v >>= 8;
    57d0:	ea4f 2a14 	mov.w	sl, r4, lsr #8
    57d4:	ea4a 6a05 	orr.w	sl, sl, r5, lsl #24
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57d8:	9404      	str	r4, [sp, #16]
	*(x--) = v;
	v >>= 8;
    57da:	ea4f 2b15 	mov.w	fp, r5, lsr #8
	*(x--) = v;
	v >>= 8;
    57de:	ea4f 241a 	mov.w	r4, sl, lsr #8
    57e2:	ea44 640b 	orr.w	r4, r4, fp, lsl #24
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57e6:	9505      	str	r5, [sp, #20]
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57e8:	0a26      	lsrs	r6, r4, #8
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57ea:	ea4f 251b 	mov.w	r5, fp, lsr #8
	*(x--) = v;
	v >>= 8;
    57ee:	ea46 6605 	orr.w	r6, r6, r5, lsl #24
    57f2:	0a2f      	lsrs	r7, r5, #8
	*(x--) = v;
	v >>= 8;
    57f4:	ea4f 2816 	mov.w	r8, r6, lsr #8
    57f8:	ea48 6807 	orr.w	r8, r8, r7, lsl #24
    57fc:	ea4f 2917 	mov.w	r9, r7, lsr #8
	*(x--) = v;
	v >>= 8;
    5800:	ea4f 2018 	mov.w	r0, r8, lsr #8
    5804:	ea40 6c09 	orr.w	ip, r0, r9, lsl #24
    5808:	ea4f 2019 	mov.w	r0, r9, lsr #8
    580c:	9009      	str	r0, [sp, #36]	; 0x24
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    580e:	f89d 0010 	ldrb.w	r0, [sp, #16]
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5812:	f8cd c020 	str.w	ip, [sp, #32]
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5816:	7148      	strb	r0, [r1, #5]
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5818:	f89d c020 	ldrb.w	ip, [sp, #32]
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    581c:	f89d 0018 	ldrb.w	r0, [sp, #24]
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5820:	f881 8001 	strb.w	r8, [r1, #1]
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5824:	71c8      	strb	r0, [r1, #7]
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5826:	708e      	strb	r6, [r1, #2]
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5828:	70cc      	strb	r4, [r1, #3]
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    582a:	f881 a004 	strb.w	sl, [r1, #4]
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    582e:	718a      	strb	r2, [r1, #6]
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    5830:	9812      	ldr	r0, [sp, #72]	; 0x48
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5832:	f801 cb08 	strb.w	ip, [r1], #8
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    5836:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
    583a:	4560      	cmp	r0, ip
    583c:	d1b6      	bne.n	57ac <sha512_get+0x50>
    583e:	980e      	ldr	r0, [sp, #56]	; 0x38
    5840:	990a      	ldr	r1, [sp, #40]	; 0x28
    5842:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    5844:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    5846:	1c4b      	adds	r3, r1, #1
    5848:	f100 0c01 	add.w	ip, r0, #1
    584c:	4461      	add	r1, ip
    584e:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
    5852:	f005 0507 	and.w	r5, r5, #7
    5856:	910e      	str	r1, [sp, #56]	; 0x38
    5858:	940f      	str	r4, [sp, #60]	; 0x3c
    585a:	950d      	str	r5, [sp, #52]	; 0x34
		hash += 8;
		len -= 8;
	}

	/* Read out bytes */
	if (len) {
    585c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    585e:	2b00      	cmp	r3, #0
    5860:	d173      	bne.n	594a <sha512_get+0x1ee>
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
	}
}
    5862:	b01b      	add	sp, #108	; 0x6c
    5864:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    5868:	9c14      	ldr	r4, [sp, #80]	; 0x50
    586a:	eb04 03c0 	add.w	r3, r4, r0, lsl #3
    586e:	e9d3 2300 	ldrd	r2, r3, [r3]

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5872:	0a14      	lsrs	r4, r2, #8
    5874:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
    5878:	0a1d      	lsrs	r5, r3, #8
	*(x--) = v;
	v >>= 8;
    587a:	0a21      	lsrs	r1, r4, #8
    587c:	ea41 6c05 	orr.w	ip, r1, r5, lsl #24
    5880:	ea4f 2e15 	mov.w	lr, r5, lsr #8
	*(x--) = v;
	v >>= 8;
    5884:	ea4f 211c 	mov.w	r1, ip, lsr #8
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5888:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
	*(x--) = v;
	v >>= 8;
    588c:	ea41 6c0e 	orr.w	ip, r1, lr, lsl #24
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5890:	f8cd e02c 	str.w	lr, [sp, #44]	; 0x2c
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5894:	ea4f 211c 	mov.w	r1, ip, lsr #8
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5898:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
    589c:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
	*(x--) = v;
	v >>= 8;
    58a0:	ea41 6c0e 	orr.w	ip, r1, lr, lsl #24
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58a4:	f8cd e044 	str.w	lr, [sp, #68]	; 0x44
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58a8:	ea4f 201c 	mov.w	r0, ip, lsr #8
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58ac:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
	*(x--) = v;
	v >>= 8;
    58b0:	ea40 600e 	orr.w	r0, r0, lr, lsl #24
    58b4:	ea4f 211e 	mov.w	r1, lr, lsr #8
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    58b8:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58bc:	0a02      	lsrs	r2, r0, #8
    58be:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
    58c2:	0a0b      	lsrs	r3, r1, #8
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58c4:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58c8:	0a15      	lsrs	r5, r2, #8
    58ca:	ea45 6c03 	orr.w	ip, r5, r3, lsl #24
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58ce:	f88d 4066 	strb.w	r4, [sp, #102]	; 0x66
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d2:	f89d 5048 	ldrb.w	r5, [sp, #72]	; 0x48
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d6:	f89d 4040 	ldrb.w	r4, [sp, #64]	; 0x40
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58da:	f8cd c018 	str.w	ip, [sp, #24]
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58de:	f8cd e04c 	str.w	lr, [sp, #76]	; 0x4c
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
		uint8_t tmp[8];
		unsigned int c = 8 - offset;
    58e2:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58e6:	f89d e028 	ldrb.w	lr, [sp, #40]	; 0x28
	v >>= 8;
	*(x--) = v;
    58ea:	f88d 4064 	strb.w	r4, [sp, #100]	; 0x64
	v >>= 8;
	*(x--) = v;
    58ee:	f88d 5063 	strb.w	r5, [sp, #99]	; 0x63
    58f2:	9c0d      	ldr	r4, [sp, #52]	; 0x34
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58f4:	f89d 5018 	ldrb.w	r5, [sp, #24]
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58f8:	f88d e065 	strb.w	lr, [sp, #101]	; 0x65
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58fc:	f88d 0062 	strb.w	r0, [sp, #98]	; 0x62
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5900:	ea4f 2e13 	mov.w	lr, r3, lsr #8
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5904:	f88d 2061 	strb.w	r2, [sp, #97]	; 0x61
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    5908:	980e      	ldr	r0, [sp, #56]	; 0x38
		memcpy(hash, tmp + offset, c);
    590a:	9a15      	ldr	r2, [sp, #84]	; 0x54
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    590c:	a91a      	add	r1, sp, #104	; 0x68
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
		uint8_t tmp[8];
		unsigned int c = 8 - offset;
    590e:	f1cc 0308 	rsb	r3, ip, #8
    5912:	429c      	cmp	r4, r3
    5914:	bf38      	it	cc
    5916:	4623      	movcc	r3, r4
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5918:	f801 5d08 	strb.w	r5, [r1, #-8]!
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    591c:	f100 0c01 	add.w	ip, r0, #1
		memcpy(hash, tmp + offset, c);
		len -= c;
    5920:	1ae4      	subs	r4, r4, r3

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    5922:	4411      	add	r1, r2
    5924:	980f      	ldr	r0, [sp, #60]	; 0x3c
    5926:	461a      	mov	r2, r3
		len -= c;
    5928:	940d      	str	r4, [sp, #52]	; 0x34

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    592a:	9302      	str	r3, [sp, #8]
    592c:	f8cd c00c 	str.w	ip, [sp, #12]
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5930:	f8cd e01c 	str.w	lr, [sp, #28]

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    5934:	f000 fed4 	bl	66e0 <memcpy>
		len -= c;
		hash += c;
    5938:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    593a:	9b02      	ldr	r3, [sp, #8]
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    593c:	f8dd c00c 	ldr.w	ip, [sp, #12]
		memcpy(hash, tmp + offset, c);
		len -= c;
		hash += c;
    5940:	441c      	add	r4, r3
    5942:	940f      	str	r4, [sp, #60]	; 0x3c
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    5944:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
    5948:	e71b      	b.n	5782 <sha512_get+0x26>

	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
    594a:	9c14      	ldr	r4, [sp, #80]	; 0x50
    594c:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    594e:	eb04 0cc5 	add.w	ip, r4, r5, lsl #3
    5952:	e9dc 0100 	ldrd	r0, r1, [ip]
    5956:	e9cd 0104 	strd	r0, r1, [sp, #16]

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    595a:	ea4f 2a10 	mov.w	sl, r0, lsr #8
    595e:	ea4a 6a01 	orr.w	sl, sl, r1, lsl #24
    5962:	9905      	ldr	r1, [sp, #20]
	*(x--) = v;
	v >>= 8;
    5964:	ea4f 281a 	mov.w	r8, sl, lsr #8

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5968:	ea4f 2b11 	mov.w	fp, r1, lsr #8
	*(x--) = v;
	v >>= 8;
    596c:	ea48 680b 	orr.w	r8, r8, fp, lsl #24
    5970:	ea4f 291b 	mov.w	r9, fp, lsr #8
	*(x--) = v;
	v >>= 8;
    5974:	ea4f 2618 	mov.w	r6, r8, lsr #8
    5978:	ea46 6609 	orr.w	r6, r6, r9, lsl #24
    597c:	ea4f 2719 	mov.w	r7, r9, lsr #8
	*(x--) = v;
	v >>= 8;
    5980:	0a34      	lsrs	r4, r6, #8
    5982:	ea44 6407 	orr.w	r4, r4, r7, lsl #24
    5986:	0a3d      	lsrs	r5, r7, #8
	*(x--) = v;
	v >>= 8;
    5988:	0a20      	lsrs	r0, r4, #8
    598a:	ea40 6005 	orr.w	r0, r0, r5, lsl #24
    598e:	0a29      	lsrs	r1, r5, #8
	*(x--) = v;
	v >>= 8;
    5990:	0a03      	lsrs	r3, r0, #8
    5992:	ea43 6c01 	orr.w	ip, r3, r1, lsl #24
    5996:	ea4f 2e11 	mov.w	lr, r1, lsr #8
	*(x--) = v;
	v >>= 8;
    599a:	ea4f 231c 	mov.w	r3, ip, lsr #8
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    599e:	f89d 2010 	ldrb.w	r2, [sp, #16]
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59a2:	f8cd c018 	str.w	ip, [sp, #24]
	*(x--) = v;
	v >>= 8;
    59a6:	ea43 6c0e 	orr.w	ip, r3, lr, lsl #24
    59aa:	f8cd c010 	str.w	ip, [sp, #16]
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    59ae:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59b2:	f88d 0062 	strb.w	r0, [sp, #98]	; 0x62
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59b6:	f89d 2010 	ldrb.w	r2, [sp, #16]
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59ba:	f89d 0018 	ldrb.w	r0, [sp, #24]
	v >>= 8;
	*(x--) = v;
    59be:	a91a      	add	r1, sp, #104	; 0x68
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59c0:	f88d 0061 	strb.w	r0, [sp, #97]	; 0x61
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59c4:	f8cd e01c 	str.w	lr, [sp, #28]
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59c8:	f88d a066 	strb.w	sl, [sp, #102]	; 0x66
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59cc:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59d0:	f88d 8065 	strb.w	r8, [sp, #101]	; 0x65
	v >>= 8;
	*(x--) = v;
    59d4:	f88d 6064 	strb.w	r6, [sp, #100]	; 0x64
	v >>= 8;
	*(x--) = v;
    59d8:	f88d 4063 	strb.w	r4, [sp, #99]	; 0x63
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    59dc:	980f      	ldr	r0, [sp, #60]	; 0x3c
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59de:	f801 2d08 	strb.w	r2, [r1, #-8]!
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    59e2:	9a0d      	ldr	r2, [sp, #52]	; 0x34
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59e4:	f8cd e014 	str.w	lr, [sp, #20]
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    59e8:	f000 fe7a 	bl	66e0 <memcpy>
	}
}
    59ec:	b01b      	add	sp, #108	; 0x6c
    59ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    59f2:	bf00      	nop

000059f4 <failErase>:
    for (i = 0; i < len; i++)
        uart_printf("%02x", data[i]);
    uart_printf("\n");
}

void failErase () {
    59f4:	b508      	push	{r3, lr}
	// for whatever reason this only flashes upto 0x08008800
	flashErasePage((u32)(0x08008000));
    59f6:	480a      	ldr	r0, [pc, #40]	; (5a20 <failErase+0x2c>)
    59f8:	f7fb fd36 	bl	1468 <flashErasePage>
	flashErasePage((u32)(0x08008000+1024));
    59fc:	4809      	ldr	r0, [pc, #36]	; (5a24 <failErase+0x30>)
    59fe:	f7fb fd33 	bl	1468 <flashErasePage>
	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
    5a02:	4809      	ldr	r0, [pc, #36]	; (5a28 <failErase+0x34>)
    5a04:	f7fb fd30 	bl	1468 <flashErasePage>
	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
    5a08:	4808      	ldr	r0, [pc, #32]	; (5a2c <failErase+0x38>)
    5a0a:	f7fb fd2d 	bl	1468 <flashErasePage>
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
    5a0e:	4808      	ldr	r0, [pc, #32]	; (5a30 <failErase+0x3c>)
    5a10:	f7fb fd2a 	bl	1468 <flashErasePage>
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
}
    5a14:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	flashErasePage((u32)(0x08008000));
	flashErasePage((u32)(0x08008000+1024));
	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
    5a18:	4806      	ldr	r0, [pc, #24]	; (5a34 <failErase+0x40>)
    5a1a:	f7fb bd25 	b.w	1468 <flashErasePage>
    5a1e:	bf00      	nop
    5a20:	08008000 	stmdaeq	r0, {pc}
    5a24:	08008400 	stmdaeq	r0, {sl, pc}
    5a28:	08008320 	stmdaeq	r0, {r5, r8, r9, pc}
    5a2c:	080084b0 	stmdaeq	r0, {r4, r5, r7, sl, pc}
    5a30:	08008640 	stmdaeq	r0, {r6, r9, sl, pc}
    5a34:	080087d0 	stmdaeq	r0, {r4, r6, r7, r8, r9, sl, pc}

00005a38 <imageCheckFromAddress>:
}

int imageCheckFromAddress(ImageObjectHandle *newHandle, vu32 flashAddress, bool shouldEraseFlashOnFail)
{
    5a38:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5a3c:	b0dc      	sub	sp, #368	; 0x170
    5a3e:	9101      	str	r1, [sp, #4]
    5a40:	4607      	mov	r7, r0
	ImageRootHeader		*hdr;
	ImageInternalState		state;
	int bufferSize = 0x28+0x40;
	unsigned char imageBuffer[bufferSize];
    memset(imageBuffer, 0xFF, sizeof(imageBuffer));
    5a42:	21ff      	movs	r1, #255	; 0xff
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
}

int imageCheckFromAddress(ImageObjectHandle *newHandle, vu32 flashAddress, bool shouldEraseFlashOnFail)
{
    5a44:	4690      	mov	r8, r2
	ImageRootHeader		*hdr;
	ImageInternalState		state;
	int bufferSize = 0x28+0x40;
	unsigned char imageBuffer[bufferSize];
    memset(imageBuffer, 0xFF, sizeof(imageBuffer));
    5a46:	a842      	add	r0, sp, #264	; 0x108
    5a48:	2268      	movs	r2, #104	; 0x68
    5a4a:	f000 fe70 	bl	672e <memset>
    memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
    flashUnlock();
    memset(&state, 0, sizeof(state));
    5a4e:	ae05      	add	r6, sp, #20
	ImageRootHeader		*hdr;
	ImageInternalState		state;
	int bufferSize = 0x28+0x40;
	unsigned char imageBuffer[bufferSize];
    memset(imageBuffer, 0xFF, sizeof(imageBuffer));
    memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
    5a50:	9901      	ldr	r1, [sp, #4]
    5a52:	2268      	movs	r2, #104	; 0x68
    5a54:	a842      	add	r0, sp, #264	; 0x108
    5a56:	f000 fe43 	bl	66e0 <memcpy>
    flashUnlock();
    5a5a:	f7fb fd4b 	bl	14f4 <flashUnlock>
    memset(&state, 0, sizeof(state));
    5a5e:	2214      	movs	r2, #20
    5a60:	4630      	mov	r0, r6
    5a62:	2100      	movs	r1, #0
    5a64:	f000 fe63 	bl	672e <memset>
		{
			failErase();
		}
		return(EINVAL);		/* buffer too small to really contain header */
	}
	if ((hdr->header.magic) != kImageHeaderMagic) {
    5a68:	9b42      	ldr	r3, [sp, #264]	; 0x108
    5a6a:	4a50      	ldr	r2, [pc, #320]	; (5bac <imageCheckFromAddress+0x174>)
    5a6c:	4293      	cmp	r3, r2
    5a6e:	d103      	bne.n	5a78 <imageCheckFromAddress+0x40>
			failErase();
		}
		*newHandle = &state;
		return(kImageImageMissingMagic);		/* magic must match */
	}
	if ((hdr->signing.imageType) != 0x45444f53)
    5a70:	9b46      	ldr	r3, [sp, #280]	; 0x118
    5a72:	4a4f      	ldr	r2, [pc, #316]	; (5bb0 <imageCheckFromAddress+0x178>)
    5a74:	4293      	cmp	r3, r2
    5a76:	d009      	beq.n	5a8c <imageCheckFromAddress+0x54>
	{
		debug_print("bad magic 0x%08x expecting 0x%X\n", (hdr->signing.imageType), 0x45444f53);
		state.flags = kImageImageMissingMagic;
    5a78:	2304      	movs	r3, #4
    5a7a:	6073      	str	r3, [r6, #4]
		if (shouldEraseFlashOnFail)
    5a7c:	f1b8 0f00 	cmp.w	r8, #0
    5a80:	d001      	beq.n	5a86 <imageCheckFromAddress+0x4e>
		{
			failErase();
    5a82:	f7ff ffb7 	bl	59f4 <failErase>
		}
		*newHandle = &state;
    5a86:	603e      	str	r6, [r7, #0]
		return(kImageImageMissingMagic);		/* magic must match */
    5a88:	2004      	movs	r0, #4
    5a8a:	e08c      	b.n	5ba6 <imageCheckFromAddress+0x16e>
	}
	state.flags = kImageImageWasInstantiated;
    5a8c:	2401      	movs	r4, #1
    5a8e:	6074      	str	r4, [r6, #4]

	debug_print("dataSize: 0x0%X\n", (0x08008000+(hdr->header.dataSize)));

	state.cursor = (hdr->header.dataSize)+0x200;
    5a90:	9b44      	ldr	r3, [sp, #272]	; 0x110
	state.lastTag = -1;

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5a92:	21ff      	movs	r1, #255	; 0xff
	}
	state.flags = kImageImageWasInstantiated;

	debug_print("dataSize: 0x0%X\n", (0x08008000+(hdr->header.dataSize)));

	state.cursor = (hdr->header.dataSize)+0x200;
    5a94:	f503 7300 	add.w	r3, r3, #512	; 0x200
	state.lastTag = -1;

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5a98:	2220      	movs	r2, #32
	}
	state.flags = kImageImageWasInstantiated;

	debug_print("dataSize: 0x0%X\n", (0x08008000+(hdr->header.dataSize)));

	state.cursor = (hdr->header.dataSize)+0x200;
    5a9a:	60f3      	str	r3, [r6, #12]
	state.lastTag = -1;

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5a9c:	a810      	add	r0, sp, #64	; 0x40
	state.flags = kImageImageWasInstantiated;

	debug_print("dataSize: 0x0%X\n", (0x08008000+(hdr->header.dataSize)));

	state.cursor = (hdr->header.dataSize)+0x200;
	state.lastTag = -1;
    5a9e:	f04f 33ff 	mov.w	r3, #4294967295
    5aa2:	6133      	str	r3, [r6, #16]

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5aa4:	f000 fe43 	bl	672e <memset>

    sha256_context ctx;
    sha256_starts(&ctx);
    5aa8:	a828      	add	r0, sp, #160	; 0xa0
    5aaa:	f7fd fa97 	bl	2fdc <sha256_starts>
    int buffSize = 0x4;
    char buff[buffSize];

    int i = 0x84;
    char cmpEnd[4] = {0x01, 0x00, 0x00, 0x00,}; 
    hexdump((flashAddress+i), 0x20);
    5aae:	9801      	ldr	r0, [sp, #4]

    int buffSize = 0x4;
    char buff[buffSize];

    int i = 0x84;
    char cmpEnd[4] = {0x01, 0x00, 0x00, 0x00,}; 
    5ab0:	2300      	movs	r3, #0
    hexdump((flashAddress+i), 0x20);
    5ab2:	3084      	adds	r0, #132	; 0x84
    5ab4:	2120      	movs	r1, #32

    int buffSize = 0x4;
    char buff[buffSize];

    int i = 0x84;
    char cmpEnd[4] = {0x01, 0x00, 0x00, 0x00,}; 
    5ab6:	f88d 400c 	strb.w	r4, [sp, #12]
    5aba:	f88d 300d 	strb.w	r3, [sp, #13]
    5abe:	f88d 300e 	strb.w	r3, [sp, #14]
    5ac2:	f88d 300f 	strb.w	r3, [sp, #15]
    hexdump((flashAddress+i), 0x20);
    5ac6:	f7fb fb9a 	bl	11fe <hexdump>
    sha256_starts(&ctx);

    int buffSize = 0x4;
    char buff[buffSize];

    int i = 0x84;
    5aca:	2484      	movs	r4, #132	; 0x84
    char cmpEnd[4] = {0x01, 0x00, 0x00, 0x00,}; 
    hexdump((flashAddress+i), 0x20);
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), ((hdr->header.dataSize) - 0x40));
    while ((flashAddress+i) <= (flashAddress+state.cursor))
    5acc:	9a01      	ldr	r2, [sp, #4]
    5ace:	68f3      	ldr	r3, [r6, #12]
    5ad0:	9901      	ldr	r1, [sp, #4]
    5ad2:	4422      	add	r2, r4
    5ad4:	440b      	add	r3, r1
    5ad6:	429a      	cmp	r2, r3
    5ad8:	d828      	bhi.n	5b2c <imageCheckFromAddress+0xf4>
    {
      memset(buff, 0xFF, buffSize);
    5ada:	f04f 33ff 	mov.w	r3, #4294967295
    5ade:	9304      	str	r3, [sp, #16]
      memcpy(buff, (unsigned char *)(flashAddress+i), buffSize);
    5ae0:	9b01      	ldr	r3, [sp, #4]
      if ((memmem(&buff, buffSize, &cmpEnd, buffSize) > 0) && ((flashAddress + hdr->header.dataSize) - 0x40) < (vu32 *)(flashAddress+i)) // our end of image should be somewhere around here
    5ae2:	2104      	movs	r1, #4
    hexdump((flashAddress+i), 0x20);
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), ((hdr->header.dataSize) - 0x40));
    while ((flashAddress+i) <= (flashAddress+state.cursor))
    {
      memset(buff, 0xFF, buffSize);
      memcpy(buff, (unsigned char *)(flashAddress+i), buffSize);
    5ae4:	58e0      	ldr	r0, [r4, r3]
      if ((memmem(&buff, buffSize, &cmpEnd, buffSize) > 0) && ((flashAddress + hdr->header.dataSize) - 0x40) < (vu32 *)(flashAddress+i)) // our end of image should be somewhere around here
    5ae6:	aa03      	add	r2, sp, #12
    hexdump((flashAddress+i), 0x20);
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), ((hdr->header.dataSize) - 0x40));
    while ((flashAddress+i) <= (flashAddress+state.cursor))
    {
      memset(buff, 0xFF, buffSize);
      memcpy(buff, (unsigned char *)(flashAddress+i), buffSize);
    5ae8:	9004      	str	r0, [sp, #16]
      if ((memmem(&buff, buffSize, &cmpEnd, buffSize) > 0) && ((flashAddress + hdr->header.dataSize) - 0x40) < (vu32 *)(flashAddress+i)) // our end of image should be somewhere around here
    5aea:	460b      	mov	r3, r1
    5aec:	a804      	add	r0, sp, #16
    5aee:	f000 fe00 	bl	66f2 <memmem>
    5af2:	b198      	cbz	r0, 5b1c <imageCheckFromAddress+0xe4>
    5af4:	9901      	ldr	r1, [sp, #4]
    5af6:	9b44      	ldr	r3, [sp, #272]	; 0x110
    5af8:	9a01      	ldr	r2, [sp, #4]
    5afa:	440b      	add	r3, r1
    5afc:	3b40      	subs	r3, #64	; 0x40
    5afe:	4422      	add	r2, r4
    5b00:	4293      	cmp	r3, r2
    5b02:	d20b      	bcs.n	5b1c <imageCheckFromAddress+0xe4>
      {
      	sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
    5b04:	9901      	ldr	r1, [sp, #4]
    5b06:	a828      	add	r0, sp, #160	; 0xa0
    5b08:	4421      	add	r1, r4
    5b0a:	2204      	movs	r2, #4
    5b0c:	f7ff fa44 	bl	4f98 <sha256_update>
      	debug_print("Hash Finish: %X\n", (flashAddress+i));
      	hexdump((flashAddress+i), 0xC);
    5b10:	9801      	ldr	r0, [sp, #4]
    5b12:	210c      	movs	r1, #12
    5b14:	4420      	add	r0, r4
    5b16:	f7fb fb72 	bl	11fe <hexdump>
      	break;
    5b1a:	e007      	b.n	5b2c <imageCheckFromAddress+0xf4>
      }
      sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
    5b1c:	9901      	ldr	r1, [sp, #4]
    5b1e:	a828      	add	r0, sp, #160	; 0xa0
    5b20:	4421      	add	r1, r4
    5b22:	2204      	movs	r2, #4
    5b24:	f7ff fa38 	bl	4f98 <sha256_update>
      i += 0x4;
    5b28:	3404      	adds	r4, #4
    5b2a:	e7cf      	b.n	5acc <imageCheckFromAddress+0x94>
	    uid_read(&id);
	    sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
	    sha256_update(&ctx, uniqueID, 0x17);
    } else {
    	// QEMU builds get FF ECIDs
    	memcpy(&uniqueID, (unsigned char*)"FFFFFFFFFFFFFFFFFFFFFFF", 0x17);
    5b2c:	4b21      	ldr	r3, [pc, #132]	; (5bb4 <imageCheckFromAddress+0x17c>)
    5b2e:	ac0a      	add	r4, sp, #40	; 0x28
    5b30:	f103 0510 	add.w	r5, r3, #16
    5b34:	6818      	ldr	r0, [r3, #0]
    5b36:	6859      	ldr	r1, [r3, #4]
    5b38:	4622      	mov	r2, r4
    5b3a:	c203      	stmia	r2!, {r0, r1}
    5b3c:	3308      	adds	r3, #8
    5b3e:	42ab      	cmp	r3, r5
    5b40:	4614      	mov	r4, r2
    5b42:	d1f7      	bne.n	5b34 <imageCheckFromAddress+0xfc>
    5b44:	6818      	ldr	r0, [r3, #0]
	    sha256_update(&ctx, uniqueID, 0x17);
    5b46:	a90a      	add	r1, sp, #40	; 0x28
	    uid_read(&id);
	    sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
	    sha256_update(&ctx, uniqueID, 0x17);
    } else {
    	// QEMU builds get FF ECIDs
    	memcpy(&uniqueID, (unsigned char*)"FFFFFFFFFFFFFFFFFFFFFFF", 0x17);
    5b48:	6010      	str	r0, [r2, #0]
    5b4a:	889a      	ldrh	r2, [r3, #4]
    5b4c:	799b      	ldrb	r3, [r3, #6]
    5b4e:	80a2      	strh	r2, [r4, #4]
    5b50:	71a3      	strb	r3, [r4, #6]
	    sha256_update(&ctx, uniqueID, 0x17);
    5b52:	2217      	movs	r2, #23
    5b54:	a828      	add	r0, sp, #160	; 0xa0
    5b56:	f7ff fa1f 	bl	4f98 <sha256_update>
    }

    debug_print("%s\n", uniqueID);
    
    sha256_finish(&ctx, sha256sum);
    5b5a:	a910      	add	r1, sp, #64	; 0x40
    5b5c:	a828      	add	r0, sp, #160	; 0xa0
    5b5e:	f7ff fa63 	bl	5028 <sha256_finish>
    print_hash(sha256sum);
    // verify signature against recalc hash
    uint8_t sigbuff[0x40];
    memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
    5b62:	ac18      	add	r4, sp, #96	; 0x60
    }

    debug_print("%s\n", uniqueID);
    
    sha256_finish(&ctx, sha256sum);
    print_hash(sha256sum);
    5b64:	a810      	add	r0, sp, #64	; 0x40
    // verify signature against recalc hash
    uint8_t sigbuff[0x40];
    memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
    5b66:	ad47      	add	r5, sp, #284	; 0x11c
    }

    debug_print("%s\n", uniqueID);
    
    sha256_finish(&ctx, sha256sum);
    print_hash(sha256sum);
    5b68:	f7fb fa64 	bl	1034 <print_hash>
    // verify signature against recalc hash
    uint8_t sigbuff[0x40];
    memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
    5b6c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    5b6e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5b70:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    5b72:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5b74:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    5b76:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5b78:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    5b7c:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    if (edsign_verify(sigbuff, rootCA, sha256sum, 32) <= 0) {
    5b80:	a818      	add	r0, sp, #96	; 0x60
    5b82:	490d      	ldr	r1, [pc, #52]	; (5bb8 <imageCheckFromAddress+0x180>)
    5b84:	aa10      	add	r2, sp, #64	; 0x40
    5b86:	2320      	movs	r3, #32
    5b88:	f7fc f8e0 	bl	1d4c <edsign_verify>
    5b8c:	b948      	cbnz	r0, 5ba2 <imageCheckFromAddress+0x16a>
    	state.flags = kImageImageRejectSignature;
    5b8e:	2302      	movs	r3, #2
    5b90:	6073      	str	r3, [r6, #4]
    	if (shouldEraseFlashOnFail)
    5b92:	f1b8 0f00 	cmp.w	r8, #0
    5b96:	d001      	beq.n	5b9c <imageCheckFromAddress+0x164>
		{
			failErase();
    5b98:	f7ff ff2c 	bl	59f4 <failErase>
		}
    	*newHandle = &state;
    5b9c:	603e      	str	r6, [r7, #0]
    	return kImageImageRejectSignature;
    5b9e:	2002      	movs	r0, #2
    5ba0:	e001      	b.n	5ba6 <imageCheckFromAddress+0x16e>
    } else {
    	state.flags = kImageImageIsTrusted;
    	*newHandle = &state;
    5ba2:	603e      	str	r6, [r7, #0]
    	return kImageImageIsTrusted;
    5ba4:	2003      	movs	r0, #3
    }
	
	*newHandle = &state;
	return(0);
}
    5ba6:	b05c      	add	sp, #368	; 0x170
    5ba8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5bac:	45626332 	strbmi	r6, [r2, #-818]!	; 0x332
    5bb0:	45444f53 	strbmi	r4, [r4, #-3923]	; 0xf53
    5bb4:	000074c8 	andeq	r7, r0, r8, asr #9
    5bb8:	20000404 	andcs	r0, r0, r4, lsl #8

00005bbc <SetEPTxStatus>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxStatus(u8 bEpNum, u16 wState)
{
  _SetEPTxStatus(bEpNum, wState);
    5bbc:	0080      	lsls	r0, r0, #2
    5bbe:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    5bc2:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
    5bc6:	6803      	ldr	r3, [r0, #0]
    5bc8:	06ca      	lsls	r2, r1, #27
    5bca:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
    5bce:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    5bd2:	b29b      	uxth	r3, r3
    5bd4:	bf48      	it	mi
    5bd6:	f083 0310 	eormi.w	r3, r3, #16
    5bda:	068a      	lsls	r2, r1, #26
    5bdc:	bf48      	it	mi
    5bde:	f083 0320 	eormi.w	r3, r3, #32
    5be2:	6003      	str	r3, [r0, #0]
    5be4:	4770      	bx	lr

00005be6 <SetEPRxValid>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxValid(u8 bEpNum)
{
  _SetEPRxStatus(bEpNum, EP_RX_VALID);
    5be6:	0080      	lsls	r0, r0, #2
    5be8:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    5bec:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
    5bf0:	6803      	ldr	r3, [r0, #0]
    5bf2:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    5bf6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    5bfa:	b29b      	uxth	r3, r3
    5bfc:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
    5c00:	6003      	str	r3, [r0, #0]
    5c02:	4770      	bx	lr

00005c04 <Clear_Status_Out>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void Clear_Status_Out(u8 bEpNum)
{
  _ClearEP_KIND(bEpNum);
    5c04:	0080      	lsls	r0, r0, #2
    5c06:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    5c0a:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
    5c0e:	6803      	ldr	r3, [r0, #0]
    5c10:	f423 43e2 	bic.w	r3, r3, #28928	; 0x7100
    5c14:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    5c18:	041b      	lsls	r3, r3, #16
    5c1a:	0c1b      	lsrs	r3, r3, #16
    5c1c:	6003      	str	r3, [r0, #0]
    5c1e:	4770      	bx	lr

00005c20 <ClearDTOG_RX>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_RX(u8 bEpNum)
{
  _ClearDTOG_RX(bEpNum);
    5c20:	0080      	lsls	r0, r0, #2
    5c22:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    5c26:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
    5c2a:	6803      	ldr	r3, [r0, #0]
    5c2c:	045b      	lsls	r3, r3, #17
    5c2e:	d506      	bpl.n	5c3e <ClearDTOG_RX+0x1e>
    5c30:	6802      	ldr	r2, [r0, #0]
    5c32:	f648 738f 	movw	r3, #36751	; 0x8f8f
    5c36:	4013      	ands	r3, r2
    5c38:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    5c3c:	6003      	str	r3, [r0, #0]
    5c3e:	4770      	bx	lr

00005c40 <ClearDTOG_TX>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_TX(u8 bEpNum)
{
  _ClearDTOG_TX(bEpNum);
    5c40:	0080      	lsls	r0, r0, #2
    5c42:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    5c46:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
    5c4a:	6803      	ldr	r3, [r0, #0]
    5c4c:	065b      	lsls	r3, r3, #25
    5c4e:	d506      	bpl.n	5c5e <ClearDTOG_TX+0x1e>
    5c50:	6802      	ldr	r2, [r0, #0]
    5c52:	f648 738f 	movw	r3, #36751	; 0x8f8f
    5c56:	4013      	ands	r3, r2
    5c58:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    5c5c:	6003      	str	r3, [r0, #0]
    5c5e:	4770      	bx	lr

00005c60 <GetEPTxAddr>:
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
u16 GetEPTxAddr(u8 bEpNum)
{
  return(_GetEPTxAddr(bEpNum));
    5c60:	4b05      	ldr	r3, [pc, #20]	; (5c78 <GetEPTxAddr+0x18>)
    5c62:	681b      	ldr	r3, [r3, #0]
    5c64:	b29b      	uxth	r3, r3
    5c66:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    5c6a:	f100 5000 	add.w	r0, r0, #536870912	; 0x20000000
    5c6e:	f500 5040 	add.w	r0, r0, #12288	; 0x3000
    5c72:	0040      	lsls	r0, r0, #1
}
    5c74:	8800      	ldrh	r0, [r0, #0]
    5c76:	4770      	bx	lr
    5c78:	40005c50 	andmi	r5, r0, r0, asr ip

00005c7c <GetEPRxAddr>:
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
u16 GetEPRxAddr(u8 bEpNum)
{
  return(_GetEPRxAddr(bEpNum));
    5c7c:	4b04      	ldr	r3, [pc, #16]	; (5c90 <GetEPRxAddr+0x14>)
    5c7e:	681b      	ldr	r3, [r3, #0]
    5c80:	b29b      	uxth	r3, r3
    5c82:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    5c86:	4b03      	ldr	r3, [pc, #12]	; (5c94 <GetEPRxAddr+0x18>)
    5c88:	4403      	add	r3, r0
    5c8a:	005b      	lsls	r3, r3, #1
}
    5c8c:	8818      	ldrh	r0, [r3, #0]
    5c8e:	4770      	bx	lr
    5c90:	40005c50 	andmi	r5, r0, r0, asr ip
    5c94:	20003004 	andcs	r3, r0, r4

00005c98 <SetEPTxCount>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxCount(u8 bEpNum, u16 wCount)
{
  _SetEPTxCount(bEpNum, wCount);
    5c98:	4b04      	ldr	r3, [pc, #16]	; (5cac <SetEPTxCount+0x14>)
    5c9a:	681b      	ldr	r3, [r3, #0]
    5c9c:	b29b      	uxth	r3, r3
    5c9e:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    5ca2:	4b03      	ldr	r3, [pc, #12]	; (5cb0 <SetEPTxCount+0x18>)
    5ca4:	4403      	add	r3, r0
    5ca6:	005b      	lsls	r3, r3, #1
    5ca8:	6019      	str	r1, [r3, #0]
    5caa:	4770      	bx	lr
    5cac:	40005c50 	andmi	r5, r0, r0, asr ip
    5cb0:	20003002 	andcs	r3, r0, r2

00005cb4 <SetEPRxCount>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxCount(u8 bEpNum, u16 wCount)
{
  _SetEPRxCount(bEpNum, wCount);
    5cb4:	4b0d      	ldr	r3, [pc, #52]	; (5cec <SetEPRxCount+0x38>)
    5cb6:	293e      	cmp	r1, #62	; 0x3e
    5cb8:	681b      	ldr	r3, [r3, #0]
    5cba:	b29b      	uxth	r3, r3
    5cbc:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    5cc0:	4b0b      	ldr	r3, [pc, #44]	; (5cf0 <SetEPRxCount+0x3c>)
    5cc2:	4403      	add	r3, r0
    5cc4:	ea4f 0243 	mov.w	r2, r3, lsl #1
    5cc8:	d909      	bls.n	5cde <SetEPRxCount+0x2a>
    5cca:	094b      	lsrs	r3, r1, #5
    5ccc:	06c8      	lsls	r0, r1, #27
    5cce:	bf04      	itt	eq
    5cd0:	f103 33ff 	addeq.w	r3, r3, #4294967295
    5cd4:	b29b      	uxtheq	r3, r3
    5cd6:	029b      	lsls	r3, r3, #10
    5cd8:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    5cdc:	e004      	b.n	5ce8 <SetEPRxCount+0x34>
    5cde:	084b      	lsrs	r3, r1, #1
    5ce0:	07c9      	lsls	r1, r1, #31
    5ce2:	bf48      	it	mi
    5ce4:	3301      	addmi	r3, #1
    5ce6:	029b      	lsls	r3, r3, #10
    5ce8:	6013      	str	r3, [r2, #0]
    5cea:	4770      	bx	lr
    5cec:	40005c50 	andmi	r5, r0, r0, asr ip
    5cf0:	20003006 	andcs	r3, r0, r6

00005cf4 <CTR_LP>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CTR_LP(void)
{
    5cf4:	b570      	push	{r4, r5, r6, lr}
  u32 wEPVal = 0;
  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
    5cf6:	4a4c      	ldr	r2, [pc, #304]	; (5e28 <CTR_LP+0x134>)
    5cf8:	4b4c      	ldr	r3, [pc, #304]	; (5e2c <CTR_LP+0x138>)
    5cfa:	6811      	ldr	r1, [r2, #0]
    5cfc:	b288      	uxth	r0, r1
    5cfe:	040c      	lsls	r4, r1, #16
    5d00:	8018      	strh	r0, [r3, #0]
    5d02:	f140 8090 	bpl.w	5e26 <CTR_LP+0x132>
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
    5d06:	f647 71ff 	movw	r1, #32767	; 0x7fff
    5d0a:	6011      	str	r1, [r2, #0]
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
    5d0c:	881a      	ldrh	r2, [r3, #0]
    5d0e:	4c48      	ldr	r4, [pc, #288]	; (5e30 <CTR_LP+0x13c>)
    5d10:	f002 020f 	and.w	r2, r2, #15
    5d14:	7022      	strb	r2, [r4, #0]
    if (EPindex == 0)
    5d16:	2a00      	cmp	r2, #0
    5d18:	d15f      	bne.n	5dda <CTR_LP+0xe6>
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */
      SaveRState = _GetEPRxStatus(ENDP0);
    5d1a:	4c46      	ldr	r4, [pc, #280]	; (5e34 <CTR_LP+0x140>)
    5d1c:	4d46      	ldr	r5, [pc, #280]	; (5e38 <CTR_LP+0x144>)
    5d1e:	6822      	ldr	r2, [r4, #0]
      SaveTState = _GetEPTxStatus(ENDP0);
    5d20:	4e46      	ldr	r6, [pc, #280]	; (5e3c <CTR_LP+0x148>)
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */
      SaveRState = _GetEPRxStatus(ENDP0);
    5d22:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
    5d26:	802a      	strh	r2, [r5, #0]
      SaveTState = _GetEPTxStatus(ENDP0);
    5d28:	6822      	ldr	r2, [r4, #0]
    5d2a:	f002 0230 	and.w	r2, r2, #48	; 0x30
    5d2e:	8032      	strh	r2, [r6, #0]
      _SetEPRxStatus(ENDP0, EP_RX_NAK);
    5d30:	6822      	ldr	r2, [r4, #0]
    5d32:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    5d36:	f022 0270 	bic.w	r2, r2, #112	; 0x70
    5d3a:	b292      	uxth	r2, r2
    5d3c:	f482 5200 	eor.w	r2, r2, #8192	; 0x2000
    5d40:	6022      	str	r2, [r4, #0]
      _SetEPTxStatus(ENDP0, EP_TX_NAK);
    5d42:	6822      	ldr	r2, [r4, #0]
    5d44:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
    5d48:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    5d4c:	b292      	uxth	r2, r2
    5d4e:	f082 0220 	eor.w	r2, r2, #32
    5d52:	6022      	str	r2, [r4, #0]


      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
    5d54:	881b      	ldrh	r3, [r3, #0]
    5d56:	06d8      	lsls	r0, r3, #27
    5d58:	d502      	bpl.n	5d60 <CTR_LP+0x6c>
        /* DIR = 1 */

        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */

        wEPVal = _GetENDPOINT(ENDP0);
    5d5a:	6823      	ldr	r3, [r4, #0]
        if ((wEPVal & EP_CTR_TX) != 0)
    5d5c:	0619      	lsls	r1, r3, #24
    5d5e:	d507      	bpl.n	5d70 <CTR_LP+0x7c>
        {
          _ClearEP_CTR_TX(ENDP0);
    5d60:	6822      	ldr	r2, [r4, #0]
    5d62:	f648 730f 	movw	r3, #36623	; 0x8f0f
    5d66:	4013      	ands	r3, r2
    5d68:	6023      	str	r3, [r4, #0]
          In0_Process();
    5d6a:	f000 fc61 	bl	6630 <In0_Process>
    5d6e:	e012      	b.n	5d96 <CTR_LP+0xa2>
          /* before terminate set Tx & Rx status */
          _SetEPRxStatus(ENDP0, SaveRState);
          _SetEPTxStatus(ENDP0, SaveTState);
          return;
        }
        else if ((wEPVal &EP_SETUP) != 0)
    5d70:	051a      	lsls	r2, r3, #20
    5d72:	d507      	bpl.n	5d84 <CTR_LP+0x90>
        {
          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
    5d74:	6822      	ldr	r2, [r4, #0]
    5d76:	f640 738f 	movw	r3, #3983	; 0xf8f
    5d7a:	4013      	ands	r3, r2
    5d7c:	6023      	str	r3, [r4, #0]
          Setup0_Process();
    5d7e:	f000 fa69 	bl	6254 <Setup0_Process>
    5d82:	e008      	b.n	5d96 <CTR_LP+0xa2>
          _SetEPRxStatus(ENDP0, SaveRState);
          _SetEPTxStatus(ENDP0, SaveTState);
          return;
        }

        else if ((wEPVal & EP_CTR_RX) != 0)
    5d84:	0418      	lsls	r0, r3, #16
    5d86:	d5b6      	bpl.n	5cf6 <CTR_LP+0x2>
        {
          _ClearEP_CTR_RX(ENDP0);
    5d88:	6822      	ldr	r2, [r4, #0]
    5d8a:	f640 738f 	movw	r3, #3983	; 0xf8f
    5d8e:	4013      	ands	r3, r2
    5d90:	6023      	str	r3, [r4, #0]
          Out0_Process();
    5d92:	f000 fbcd 	bl	6530 <Out0_Process>
          /* before terminate set Tx & Rx status */
          _SetEPRxStatus(ENDP0, SaveRState);
    5d96:	6823      	ldr	r3, [r4, #0]
    5d98:	882a      	ldrh	r2, [r5, #0]
    5d9a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    5d9e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    5da2:	b29b      	uxth	r3, r3
    5da4:	04d1      	lsls	r1, r2, #19
    5da6:	bf48      	it	mi
    5da8:	f483 5380 	eormi.w	r3, r3, #4096	; 0x1000
    5dac:	0495      	lsls	r5, r2, #18
    5dae:	4a21      	ldr	r2, [pc, #132]	; (5e34 <CTR_LP+0x140>)
    5db0:	bf48      	it	mi
    5db2:	f483 5300 	eormi.w	r3, r3, #8192	; 0x2000
    5db6:	6013      	str	r3, [r2, #0]
          _SetEPTxStatus(ENDP0, SaveTState);
    5db8:	6813      	ldr	r3, [r2, #0]
    5dba:	8831      	ldrh	r1, [r6, #0]
    5dbc:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
    5dc0:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    5dc4:	b29b      	uxth	r3, r3
    5dc6:	06cc      	lsls	r4, r1, #27
    5dc8:	bf48      	it	mi
    5dca:	f083 0310 	eormi.w	r3, r3, #16
    5dce:	0688      	lsls	r0, r1, #26
    5dd0:	bf48      	it	mi
    5dd2:	f083 0320 	eormi.w	r3, r3, #32
    5dd6:	6013      	str	r3, [r2, #0]
          return;
    5dd8:	bd70      	pop	{r4, r5, r6, pc}
    else
    {
      /* Decode and service non control endpoints interrupt  */

      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
    5dda:	0093      	lsls	r3, r2, #2
    5ddc:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    5de0:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
    5de4:	681d      	ldr	r5, [r3, #0]
      if ((wEPVal & EP_CTR_RX) != 0)
    5de6:	0429      	lsls	r1, r5, #16
    5de8:	d509      	bpl.n	5dfe <CTR_LP+0x10a>
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
    5dea:	6818      	ldr	r0, [r3, #0]
    5dec:	f640 718f 	movw	r1, #3983	; 0xf8f
    5df0:	4001      	ands	r1, r0
    5df2:	6019      	str	r1, [r3, #0]

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
    5df4:	4b12      	ldr	r3, [pc, #72]	; (5e40 <CTR_LP+0x14c>)
    5df6:	3a01      	subs	r2, #1
    5df8:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5dfc:	4798      	blx	r3

      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
    5dfe:	062b      	lsls	r3, r5, #24
    5e00:	f57f af79 	bpl.w	5cf6 <CTR_LP+0x2>
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
    5e04:	7821      	ldrb	r1, [r4, #0]
    5e06:	f648 720f 	movw	r2, #36623	; 0x8f0f
    5e0a:	008b      	lsls	r3, r1, #2
    5e0c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    5e10:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
    5e14:	6818      	ldr	r0, [r3, #0]

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
    5e16:	3901      	subs	r1, #1
      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
    5e18:	4002      	ands	r2, r0
    5e1a:	601a      	str	r2, [r3, #0]

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
    5e1c:	4b09      	ldr	r3, [pc, #36]	; (5e44 <CTR_LP+0x150>)
    5e1e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    5e22:	4798      	blx	r3
    5e24:	e767      	b.n	5cf6 <CTR_LP+0x2>
    5e26:	bd70      	pop	{r4, r5, r6, pc}
    5e28:	40005c44 	andmi	r5, r0, r4, asr #24
    5e2c:	2000048c 	andcs	r0, r0, ip, lsl #9
    5e30:	20000584 	andcs	r0, r0, r4, lsl #11
    5e34:	40005c00 	andmi	r5, r0, r0, lsl #24
    5e38:	20000576 	andcs	r0, r0, r6, ror r5
    5e3c:	20000578 	andcs	r0, r0, r8, ror r5
    5e40:	20000064 	andcs	r0, r0, r4, rrx
    5e44:	20000048 	andcs	r0, r0, r8, asr #32

00005e48 <USB_Init>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void USB_Init(void)
{
    5e48:	b508      	push	{r3, lr}
  pInformation = &Device_Info;
    5e4a:	4a07      	ldr	r2, [pc, #28]	; (5e68 <USB_Init+0x20>)
    5e4c:	4b07      	ldr	r3, [pc, #28]	; (5e6c <USB_Init+0x24>)
  pInformation->ControlState = 2;
  pProperty = &Device_Property;
  pUser_Standard_Requests = &User_Standard_Requests;
    5e4e:	4908      	ldr	r1, [pc, #32]	; (5e70 <USB_Init+0x28>)
* Output         : None.
* Return         : None.
*******************************************************************************/
void USB_Init(void)
{
  pInformation = &Device_Info;
    5e50:	6013      	str	r3, [r2, #0]
  pInformation->ControlState = 2;
    5e52:	2202      	movs	r2, #2
    5e54:	721a      	strb	r2, [r3, #8]
  pProperty = &Device_Property;
    5e56:	4b07      	ldr	r3, [pc, #28]	; (5e74 <USB_Init+0x2c>)
    5e58:	4a07      	ldr	r2, [pc, #28]	; (5e78 <USB_Init+0x30>)
    5e5a:	6013      	str	r3, [r2, #0]
  pUser_Standard_Requests = &User_Standard_Requests;
    5e5c:	4a07      	ldr	r2, [pc, #28]	; (5e7c <USB_Init+0x34>)
  /* Initialize devices one by one */

  pProperty->Init();
    5e5e:	681b      	ldr	r3, [r3, #0]
void USB_Init(void)
{
  pInformation = &Device_Info;
  pInformation->ControlState = 2;
  pProperty = &Device_Property;
  pUser_Standard_Requests = &User_Standard_Requests;
    5e60:	6011      	str	r1, [r2, #0]
  /* Initialize devices one by one */

  pProperty->Init();
    5e62:	4798      	blx	r3
    5e64:	bd08      	pop	{r3, pc}
    5e66:	bf00      	nop
    5e68:	200005a8 	andcs	r0, r0, r8, lsr #11
    5e6c:	20000588 	andcs	r0, r0, r8, lsl #11
    5e70:	20000080 	andcs	r0, r0, r0, lsl #1
    5e74:	20000014 	andcs	r0, r0, r4, lsl r0
    5e78:	20000580 	andcs	r0, r0, r0, lsl #11
    5e7c:	200005a4 	andcs	r0, r0, r4, lsr #11

00005e80 <Standard_GetConfiguration>:
* Output         : None.
* Return         : Return 1 , if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
u8 *Standard_GetConfiguration(u16 Length)
{
    5e80:	b510      	push	{r4, lr}
    5e82:	4c06      	ldr	r4, [pc, #24]	; (5e9c <Standard_GetConfiguration+0x1c>)
  if (Length == 0)
    5e84:	b918      	cbnz	r0, 5e8e <Standard_GetConfiguration+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength =
    5e86:	6823      	ldr	r3, [r4, #0]
    5e88:	2201      	movs	r2, #1
    5e8a:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_Configuration);
    return 0;
    5e8c:	bd10      	pop	{r4, pc}
  }
  pUser_Standard_Requests->User_GetConfiguration();
    5e8e:	4b04      	ldr	r3, [pc, #16]	; (5ea0 <Standard_GetConfiguration+0x20>)
    5e90:	681b      	ldr	r3, [r3, #0]
    5e92:	681b      	ldr	r3, [r3, #0]
    5e94:	4798      	blx	r3
  return (u8 *)&pInformation->Current_Configuration;
    5e96:	6820      	ldr	r0, [r4, #0]
    5e98:	300a      	adds	r0, #10
}
    5e9a:	bd10      	pop	{r4, pc}
    5e9c:	200005a8 	andcs	r0, r0, r8, lsr #11
    5ea0:	200005a4 	andcs	r0, r0, r4, lsr #11

00005ea4 <Standard_GetInterface>:
* Output         : None.
* Return         : Return 0, if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
u8 *Standard_GetInterface(u16 Length)
{
    5ea4:	b510      	push	{r4, lr}
    5ea6:	4c06      	ldr	r4, [pc, #24]	; (5ec0 <Standard_GetInterface+0x1c>)
  if (Length == 0)
    5ea8:	b918      	cbnz	r0, 5eb2 <Standard_GetInterface+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength =
    5eaa:	6823      	ldr	r3, [r4, #0]
    5eac:	2201      	movs	r2, #1
    5eae:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_AlternateSetting);
    return 0;
    5eb0:	bd10      	pop	{r4, pc}
  }
  pUser_Standard_Requests->User_GetInterface();
    5eb2:	4b04      	ldr	r3, [pc, #16]	; (5ec4 <Standard_GetInterface+0x20>)
    5eb4:	681b      	ldr	r3, [r3, #0]
    5eb6:	689b      	ldr	r3, [r3, #8]
    5eb8:	4798      	blx	r3
  return (u8 *)&pInformation->Current_AlternateSetting;
    5eba:	6820      	ldr	r0, [r4, #0]
    5ebc:	300c      	adds	r0, #12
}
    5ebe:	bd10      	pop	{r4, pc}
    5ec0:	200005a8 	andcs	r0, r0, r8, lsr #11
    5ec4:	200005a4 	andcs	r0, r0, r4, lsr #11

00005ec8 <Standard_GetStatus>:
* Output         : None.
* Return         : Return 0, if the request is at end of data block,
*                  or is invalid when "Length" is 0.
*******************************************************************************/
u8 *Standard_GetStatus(u16 Length)
{
    5ec8:	b510      	push	{r4, lr}
    5eca:	4b20      	ldr	r3, [pc, #128]	; (5f4c <Standard_GetStatus+0x84>)
  if (Length == 0)
    5ecc:	b918      	cbnz	r0, 5ed6 <Standard_GetStatus+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
    5ece:	681b      	ldr	r3, [r3, #0]
    5ed0:	2202      	movs	r2, #2
    5ed2:	821a      	strh	r2, [r3, #16]
    return 0;
    5ed4:	bd10      	pop	{r4, pc}
  }

  StatusInfo.w = 0;
    5ed6:	4a1e      	ldr	r2, [pc, #120]	; (5f50 <Standard_GetStatus+0x88>)
  /* Reset Status Information */

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    5ed8:	6819      	ldr	r1, [r3, #0]
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
    return 0;
  }

  StatusInfo.w = 0;
    5eda:	2000      	movs	r0, #0
    5edc:	8010      	strh	r0, [r2, #0]
  /* Reset Status Information */

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    5ede:	780c      	ldrb	r4, [r1, #0]
    5ee0:	4613      	mov	r3, r2
    5ee2:	f014 047f 	ands.w	r4, r4, #127	; 0x7f
    5ee6:	d10d      	bne.n	5f04 <Standard_GetStatus+0x3c>
  {
    /*Get Device Status */
    u8 Feature = pInformation->Current_Feature;
    5ee8:	7a4a      	ldrb	r2, [r1, #9]

    /* Remote Wakeup enabled */
    if (ValBit(Feature, 5))
    5eea:	0691      	lsls	r1, r2, #26
    {
      SetBit(StatusInfo0, 1);
    5eec:	bf44      	itt	mi
    5eee:	2102      	movmi	r1, #2
    5ef0:	7019      	strbmi	r1, [r3, #0]
    }

    /* Bus-powered */
    if (ValBit(Feature, 6))
    5ef2:	f012 0f40 	tst.w	r2, #64	; 0x40
    {
      ClrBit(StatusInfo0, 0);
    5ef6:	781a      	ldrb	r2, [r3, #0]
    5ef8:	bf14      	ite	ne
    5efa:	f022 0201 	bicne.w	r2, r2, #1
    }
    else /* Self-powered */
    {
      SetBit(StatusInfo0, 0);
    5efe:	f042 0201 	orreq.w	r2, r2, #1
    5f02:	e014      	b.n	5f2e <Standard_GetStatus+0x66>
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    5f04:	2c01      	cmp	r4, #1
    5f06:	d01f      	beq.n	5f48 <Standard_GetStatus+0x80>
  {
    return (u8 *)&StatusInfo;
  }
  /*Get EndPoint Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    5f08:	2c02      	cmp	r4, #2
    5f0a:	d11e      	bne.n	5f4a <Standard_GetStatus+0x82>
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;
    5f0c:	7909      	ldrb	r1, [r1, #4]

    Related_Endpoint = (wIndex0 & 0x0f);
    5f0e:	f001 020f 	and.w	r2, r1, #15
    5f12:	0092      	lsls	r2, r2, #2
    if (ValBit(wIndex0, 7))
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5f14:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    5f18:	f502 42b8 	add.w	r2, r2, #23552	; 0x5c00
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;

    Related_Endpoint = (wIndex0 & 0x0f);
    if (ValBit(wIndex0, 7))
    5f1c:	f011 0f80 	tst.w	r1, #128	; 0x80
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5f20:	6812      	ldr	r2, [r2, #0]
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;

    Related_Endpoint = (wIndex0 & 0x0f);
    if (ValBit(wIndex0, 7))
    5f22:	d006      	beq.n	5f32 <Standard_GetStatus+0x6a>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5f24:	f002 0230 	and.w	r2, r2, #48	; 0x30
    5f28:	2a10      	cmp	r2, #16
    5f2a:	d107      	bne.n	5f3c <Standard_GetStatus+0x74>
      {
        SetBit(StatusInfo0, 0); /* IN Endpoint stalled */
    5f2c:	2201      	movs	r2, #1
    5f2e:	701a      	strb	r2, [r3, #0]
    5f30:	e004      	b.n	5f3c <Standard_GetStatus+0x74>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
    5f32:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
    5f36:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    5f3a:	e7f6      	b.n	5f2a <Standard_GetStatus+0x62>
  }
  else
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
    5f3c:	4b05      	ldr	r3, [pc, #20]	; (5f54 <Standard_GetStatus+0x8c>)
    5f3e:	681b      	ldr	r3, [r3, #0]
    5f40:	691b      	ldr	r3, [r3, #16]
    5f42:	4798      	blx	r3
  return (u8 *)&StatusInfo;
    5f44:	4802      	ldr	r0, [pc, #8]	; (5f50 <Standard_GetStatus+0x88>)
    5f46:	bd10      	pop	{r4, pc}
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
  {
    return (u8 *)&StatusInfo;
    5f48:	4610      	mov	r0, r2
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
  return (u8 *)&StatusInfo;
}
    5f4a:	bd10      	pop	{r4, pc}
    5f4c:	200005a8 	andcs	r0, r0, r8, lsr #11
    5f50:	200005ae 	andcs	r0, r0, lr, lsr #11
    5f54:	200005a4 	andcs	r0, r0, r4, lsr #11

00005f58 <DataStageIn>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
    5f58:	4a23      	ldr	r2, [pc, #140]	; (5fe8 <DataStageIn+0x90>)
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
    5f5a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
    5f5e:	6814      	ldr	r4, [r2, #0]
    5f60:	4690      	mov	r8, r2
  u32 save_wLength = pEPinfo->Usb_wLength;
    5f62:	8a23      	ldrh	r3, [r4, #16]
  u32 ControlState = pInformation->ControlState;
    5f64:	7a26      	ldrb	r6, [r4, #8]
    5f66:	4f21      	ldr	r7, [pc, #132]	; (5fec <DataStageIn+0x94>)

  u8 *DataBuffer;
  u32 Length;

  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
    5f68:	b9a3      	cbnz	r3, 5f94 <DataStageIn+0x3c>
    5f6a:	2e04      	cmp	r6, #4
    5f6c:	d112      	bne.n	5f94 <DataStageIn+0x3c>
  {
    if(Data_Mul_MaxPacketSize == TRUE)
    5f6e:	4920      	ldr	r1, [pc, #128]	; (5ff0 <DataStageIn+0x98>)
    5f70:	780a      	ldrb	r2, [r1, #0]
    5f72:	2a01      	cmp	r2, #1
    5f74:	d10a      	bne.n	5f8c <DataStageIn+0x34>
    {
      /* No more data to send and empty packet */
      Send0LengthData();
    5f76:	4a1f      	ldr	r2, [pc, #124]	; (5ff4 <DataStageIn+0x9c>)
    5f78:	6810      	ldr	r0, [r2, #0]
    5f7a:	4a1f      	ldr	r2, [pc, #124]	; (5ff8 <DataStageIn+0xa0>)
    5f7c:	b280      	uxth	r0, r0
    5f7e:	4402      	add	r2, r0
    5f80:	0052      	lsls	r2, r2, #1
    5f82:	6013      	str	r3, [r2, #0]
    5f84:	2230      	movs	r2, #48	; 0x30
    5f86:	803a      	strh	r2, [r7, #0]
      ControlState = LAST_IN_DATA;
      Data_Mul_MaxPacketSize = FALSE;
    5f88:	700b      	strb	r3, [r1, #0]
    5f8a:	e027      	b.n	5fdc <DataStageIn+0x84>
    }
    else
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
      vSetEPTxStatus(EP_TX_STALL);
    5f8c:	2310      	movs	r3, #16
    5f8e:	803b      	strh	r3, [r7, #0]
      Data_Mul_MaxPacketSize = FALSE;
    }
    else
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
    5f90:	2607      	movs	r6, #7
    5f92:	e023      	b.n	5fdc <DataStageIn+0x84>
    }

    goto Expect_Status_Out;
  }

  Length = pEPinfo->PacketSize;
    5f94:	8aa5      	ldrh	r5, [r4, #20]
  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
    5f96:	42ab      	cmp	r3, r5
    5f98:	bf8c      	ite	hi
    5f9a:	2602      	movhi	r6, #2
    5f9c:	2604      	movls	r6, #4
  if (Length > save_wLength)
  {
    Length = save_wLength;
  }

  DataBuffer = (*pEPinfo->CopyData)(Length);
    5f9e:	429d      	cmp	r5, r3
    5fa0:	bf28      	it	cs
    5fa2:	461d      	movcs	r5, r3
    5fa4:	4628      	mov	r0, r5
    5fa6:	69a3      	ldr	r3, [r4, #24]
    5fa8:	4798      	blx	r3
    5faa:	4681      	mov	r9, r0

  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
    5fac:	2000      	movs	r0, #0
    5fae:	f7ff fe57 	bl	5c60 <GetEPTxAddr>
    5fb2:	462a      	mov	r2, r5
    5fb4:	4601      	mov	r1, r0
    5fb6:	4648      	mov	r0, r9
    5fb8:	f000 fb68 	bl	668c <UserToPMABufferCopy>

  SetEPTxCount(ENDP0, Length);
    5fbc:	4629      	mov	r1, r5
    5fbe:	2000      	movs	r0, #0
    5fc0:	f7ff fe6a 	bl	5c98 <SetEPTxCount>

  pEPinfo->Usb_wLength -= Length;
    5fc4:	8a23      	ldrh	r3, [r4, #16]
  pEPinfo->Usb_wOffset += Length;
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */
    5fc6:	f44f 5240 	mov.w	r2, #12288	; 0x3000

  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
    5fca:	1b5b      	subs	r3, r3, r5
    5fcc:	8223      	strh	r3, [r4, #16]
  pEPinfo->Usb_wOffset += Length;
    5fce:	8a63      	ldrh	r3, [r4, #18]
    5fd0:	441d      	add	r5, r3
  vSetEPTxStatus(EP_TX_VALID);
    5fd2:	2330      	movs	r3, #48	; 0x30
    5fd4:	803b      	strh	r3, [r7, #0]

  USB_StatusOut();/* Expect the host to abort the data IN stage */
    5fd6:	4b09      	ldr	r3, [pc, #36]	; (5ffc <DataStageIn+0xa4>)
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
  pEPinfo->Usb_wOffset += Length;
    5fd8:	8265      	strh	r5, [r4, #18]
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */
    5fda:	801a      	strh	r2, [r3, #0]

Expect_Status_Out:
  pInformation->ControlState = ControlState;
    5fdc:	f8d8 3000 	ldr.w	r3, [r8]
    5fe0:	721e      	strb	r6, [r3, #8]
    5fe2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    5fe6:	bf00      	nop
    5fe8:	200005a8 	andcs	r0, r0, r8, lsr #11
    5fec:	20000578 	andcs	r0, r0, r8, ror r5
    5ff0:	20000dcc 	andcs	r0, r0, ip, asr #27
    5ff4:	40005c50 	andmi	r5, r0, r0, asr ip
    5ff8:	20003002 	andcs	r3, r0, r2
    5ffc:	20000576 	andcs	r0, r0, r6, ror r5

00006000 <Standard_SetConfiguration>:
* Output         : None.
* Return         : Return USB_SUCCESS, if the request is performed.
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{
    6000:	b510      	push	{r4, lr}

  if ((pInformation->USBwValue0 <=
    6002:	4b0a      	ldr	r3, [pc, #40]	; (602c <Standard_SetConfiguration+0x2c>)
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
    6004:	490a      	ldr	r1, [pc, #40]	; (6030 <Standard_SetConfiguration+0x30>)
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{

  if ((pInformation->USBwValue0 <=
    6006:	681b      	ldr	r3, [r3, #0]
    6008:	7849      	ldrb	r1, [r1, #1]
    600a:	789a      	ldrb	r2, [r3, #2]
    600c:	4291      	cmp	r1, r2
    600e:	d30a      	bcc.n	6026 <Standard_SetConfiguration+0x26>
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
    6010:	78d9      	ldrb	r1, [r3, #3]
    6012:	b941      	cbnz	r1, 6026 <Standard_SetConfiguration+0x26>
      && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
    6014:	889c      	ldrh	r4, [r3, #4]
    6016:	b934      	cbnz	r4, 6026 <Standard_SetConfiguration+0x26>
  {
    pInformation->Current_Configuration = pInformation->USBwValue0;
    6018:	729a      	strb	r2, [r3, #10]
    pUser_Standard_Requests->User_SetConfiguration();
    601a:	4b06      	ldr	r3, [pc, #24]	; (6034 <Standard_SetConfiguration+0x34>)
    601c:	681b      	ldr	r3, [r3, #0]
    601e:	685b      	ldr	r3, [r3, #4]
    6020:	4798      	blx	r3
    return USB_SUCCESS;
    6022:	4620      	mov	r0, r4
    6024:	bd10      	pop	{r4, pc}
  }
  else
  {
    return USB_UNSUPPORT;
    6026:	2002      	movs	r0, #2
  }
}
    6028:	bd10      	pop	{r4, pc}
    602a:	bf00      	nop
    602c:	200005a8 	andcs	r0, r0, r8, lsr #11
    6030:	200000a4 	andcs	r0, r0, r4, lsr #1
    6034:	200005a4 	andcs	r0, r0, r4, lsr #11

00006038 <Standard_SetInterface>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetInterface(void)
{
    6038:	b538      	push	{r3, r4, r5, lr}
  RESULT Re;
  /*Test if the specified Interface and Alternate Setting are supported by
    the application Firmware*/
  Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
    603a:	4a0e      	ldr	r2, [pc, #56]	; (6074 <Standard_SetInterface+0x3c>)
    603c:	4c0e      	ldr	r4, [pc, #56]	; (6078 <Standard_SetInterface+0x40>)
    603e:	6812      	ldr	r2, [r2, #0]
    6040:	6823      	ldr	r3, [r4, #0]
    6042:	6992      	ldr	r2, [r2, #24]
    6044:	7918      	ldrb	r0, [r3, #4]
    6046:	7899      	ldrb	r1, [r3, #2]
    6048:	4790      	blx	r2

  if (pInformation->Current_Configuration != 0)
    604a:	6823      	ldr	r3, [r4, #0]
    604c:	7a9a      	ldrb	r2, [r3, #10]
    604e:	b17a      	cbz	r2, 6070 <Standard_SetInterface+0x38>
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
    6050:	b970      	cbnz	r0, 6070 <Standard_SetInterface+0x38>
    6052:	795a      	ldrb	r2, [r3, #5]
    6054:	b962      	cbnz	r2, 6070 <Standard_SetInterface+0x38>
        || (pInformation->USBwValue1 != 0))
    6056:	78dd      	ldrb	r5, [r3, #3]
    6058:	b955      	cbnz	r5, 6070 <Standard_SetInterface+0x38>
    {
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
    605a:	4b08      	ldr	r3, [pc, #32]	; (607c <Standard_SetInterface+0x44>)
    605c:	681b      	ldr	r3, [r3, #0]
    605e:	68db      	ldr	r3, [r3, #12]
    6060:	4798      	blx	r3
      pInformation->Current_Interface = pInformation->USBwIndex0;
    6062:	6823      	ldr	r3, [r4, #0]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
      return USB_SUCCESS;
    6064:	4628      	mov	r0, r5
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
      pInformation->Current_Interface = pInformation->USBwIndex0;
    6066:	791a      	ldrb	r2, [r3, #4]
    6068:	72da      	strb	r2, [r3, #11]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
    606a:	789a      	ldrb	r2, [r3, #2]
    606c:	731a      	strb	r2, [r3, #12]
      return USB_SUCCESS;
    606e:	bd38      	pop	{r3, r4, r5, pc}
    }

  }

  return USB_UNSUPPORT;
    6070:	2002      	movs	r0, #2
}
    6072:	bd38      	pop	{r3, r4, r5, pc}
    6074:	20000580 	andcs	r0, r0, r0, lsl #11
    6078:	200005a8 	andcs	r0, r0, r8, lsr #11
    607c:	200005a4 	andcs	r0, r0, r4, lsr #11

00006080 <Standard_ClearFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_ClearFeature(void)
{
    6080:	b538      	push	{r3, r4, r5, lr}
  u32     Type_Rec = Type_Recipient;
    6082:	4b2f      	ldr	r3, [pc, #188]	; (6140 <Standard_ClearFeature+0xc0>)
    6084:	681b      	ldr	r3, [r3, #0]
    6086:	7818      	ldrb	r0, [r3, #0]
  u32     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6088:	f010 007f 	ands.w	r0, r0, #127	; 0x7f
    608c:	d104      	bne.n	6098 <Standard_ClearFeature+0x18>
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
    608e:	7a5a      	ldrb	r2, [r3, #9]
    6090:	f022 0220 	bic.w	r2, r2, #32
    6094:	725a      	strb	r2, [r3, #9]
    return USB_SUCCESS;
    6096:	bd38      	pop	{r3, r4, r5, pc}
  }
  else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    6098:	2802      	cmp	r0, #2
    609a:	d14e      	bne.n	613a <Standard_ClearFeature+0xba>
    DEVICE* pDev;
    u32 Related_Endpoint;
    u32 wIndex0;
    u32 rEP;

    if ((pInformation->USBwValue != ENDPOINT_STALL)
    609c:	885a      	ldrh	r2, [r3, #2]
    609e:	2a00      	cmp	r2, #0
    60a0:	d14c      	bne.n	613c <Standard_ClearFeature+0xbc>
        || (pInformation->USBwIndex1 != 0))
    60a2:	795a      	ldrb	r2, [r3, #5]
    60a4:	2a00      	cmp	r2, #0
    60a6:	d149      	bne.n	613c <Standard_ClearFeature+0xbc>
    {
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    60a8:	791a      	ldrb	r2, [r3, #4]
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    60aa:	4d26      	ldr	r5, [pc, #152]	; (6144 <Standard_ClearFeature+0xc4>)
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    rEP = wIndex0 & ~0x80;
    60ac:	f022 0080 	bic.w	r0, r2, #128	; 0x80
    60b0:	0084      	lsls	r4, r0, #2

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
    60b2:	f104 4180 	add.w	r1, r4, #1073741824	; 0x40000000
    60b6:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
    60ba:	6809      	ldr	r1, [r1, #0]
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    60bc:	782d      	ldrb	r5, [r5, #0]
    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    rEP = wIndex0 & ~0x80;
    Related_Endpoint = ENDP0 + rEP;

    if (ValBit(pInformation->USBwIndex0, 7))
    60be:	f012 0f80 	tst.w	r2, #128	; 0x80
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
    60c2:	bf14      	ite	ne
    60c4:	f001 0130 	andne.w	r1, r1, #48	; 0x30
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    60c8:	f401 5140 	andeq.w	r1, r1, #12288	; 0x3000
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    60cc:	42a8      	cmp	r0, r5
    60ce:	d234      	bcs.n	613a <Standard_ClearFeature+0xba>
    60d0:	2900      	cmp	r1, #0
    60d2:	d032      	beq.n	613a <Standard_ClearFeature+0xba>
        || (pInformation->Current_Configuration == 0))
    60d4:	7a9b      	ldrb	r3, [r3, #10]
    60d6:	b383      	cbz	r3, 613a <Standard_ClearFeature+0xba>


    if (wIndex0 & 0x80)
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    60d8:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
    60dc:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
    {
      return USB_UNSUPPORT;
    }


    if (wIndex0 & 0x80)
    60e0:	0612      	lsls	r2, r2, #24
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    60e2:	6823      	ldr	r3, [r4, #0]
    {
      return USB_UNSUPPORT;
    }


    if (wIndex0 & 0x80)
    60e4:	d50c      	bpl.n	6100 <Standard_ClearFeature+0x80>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    60e6:	f003 0330 	and.w	r3, r3, #48	; 0x30
    60ea:	2b10      	cmp	r3, #16
    60ec:	d11f      	bne.n	612e <Standard_ClearFeature+0xae>
      {
        ClearDTOG_TX(Related_Endpoint);
    60ee:	b2c4      	uxtb	r4, r0
    60f0:	4620      	mov	r0, r4
    60f2:	f7ff fda5 	bl	5c40 <ClearDTOG_TX>
        SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
    60f6:	4620      	mov	r0, r4
    60f8:	2130      	movs	r1, #48	; 0x30
    60fa:	f7ff fd5f 	bl	5bbc <SetEPTxStatus>
    60fe:	e016      	b.n	612e <Standard_ClearFeature+0xae>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
    6100:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
    6104:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    6108:	d111      	bne.n	612e <Standard_ClearFeature+0xae>
      {
        if (Related_Endpoint == ENDP0)
    610a:	b928      	cbnz	r0, 6118 <Standard_ClearFeature+0x98>
        {
          /* After clear the STALL, enable the default endpoint receiver */
          SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
    610c:	4b0e      	ldr	r3, [pc, #56]	; (6148 <Standard_ClearFeature+0xc8>)
    610e:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
    6112:	f7ff fdcf 	bl	5cb4 <SetEPRxCount>
    6116:	e001      	b.n	611c <Standard_ClearFeature+0x9c>
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
        }
        else
        {
          ClearDTOG_RX(Related_Endpoint);
    6118:	f7ff fd82 	bl	5c20 <ClearDTOG_RX>
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
    611c:	6823      	ldr	r3, [r4, #0]
    611e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    6122:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    6126:	b29b      	uxth	r3, r3
    6128:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
    612c:	6023      	str	r3, [r4, #0]
        }
      }
    }
    pUser_Standard_Requests->User_ClearFeature();
    612e:	4b07      	ldr	r3, [pc, #28]	; (614c <Standard_ClearFeature+0xcc>)
    6130:	681b      	ldr	r3, [r3, #0]
    6132:	695b      	ldr	r3, [r3, #20]
    6134:	4798      	blx	r3
    return USB_SUCCESS;
    6136:	2000      	movs	r0, #0
    6138:	bd38      	pop	{r3, r4, r5, pc}
  }

  return USB_UNSUPPORT;
    613a:	2002      	movs	r0, #2
}
    613c:	bd38      	pop	{r3, r4, r5, pc}
    613e:	bf00      	nop
    6140:	200005a8 	andcs	r0, r0, r8, lsr #11
    6144:	200000a4 	andcs	r0, r0, r4, lsr #1
    6148:	20000014 	andcs	r0, r0, r4, lsl r0
    614c:	200005a4 	andcs	r0, r0, r4, lsr #11

00006150 <Standard_SetEndPointFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetEndPointFeature(void)
{
    6150:	b538      	push	{r3, r4, r5, lr}
  u32    wIndex0;
  u32    Related_Endpoint;
  u32    rEP;
  u32   Status;

  wIndex0 = pInformation->USBwIndex0;
    6152:	4b1d      	ldr	r3, [pc, #116]	; (61c8 <Standard_SetEndPointFeature+0x78>)
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    6154:	4d1d      	ldr	r5, [pc, #116]	; (61cc <Standard_SetEndPointFeature+0x7c>)
  u32    wIndex0;
  u32    Related_Endpoint;
  u32    rEP;
  u32   Status;

  wIndex0 = pInformation->USBwIndex0;
    6156:	6819      	ldr	r1, [r3, #0]
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    6158:	782d      	ldrb	r5, [r5, #0]
  u32    wIndex0;
  u32    Related_Endpoint;
  u32    rEP;
  u32   Status;

  wIndex0 = pInformation->USBwIndex0;
    615a:	790a      	ldrb	r2, [r1, #4]
  rEP = wIndex0 & ~0x80;
    615c:	f022 0480 	bic.w	r4, r2, #128	; 0x80
    6160:	00a3      	lsls	r3, r4, #2

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
    6162:	f103 4080 	add.w	r0, r3, #1073741824	; 0x40000000
    6166:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
    616a:	6800      	ldr	r0, [r0, #0]

  wIndex0 = pInformation->USBwIndex0;
  rEP = wIndex0 & ~0x80;
  Related_Endpoint = ENDP0 + rEP;

  if (ValBit(pInformation->USBwIndex0, 7))
    616c:	f012 0f80 	tst.w	r2, #128	; 0x80
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
    6170:	bf14      	ite	ne
    6172:	f000 0030 	andne.w	r0, r0, #48	; 0x30
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
    6176:	f400 5040 	andeq.w	r0, r0, #12288	; 0x3000
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    617a:	42ac      	cmp	r4, r5
    617c:	d222      	bcs.n	61c4 <Standard_SetEndPointFeature+0x74>
      || pInformation->USBwValue != 0 || Status == 0
    617e:	884c      	ldrh	r4, [r1, #2]
    6180:	bb04      	cbnz	r4, 61c4 <Standard_SetEndPointFeature+0x74>
    6182:	b1f8      	cbz	r0, 61c4 <Standard_SetEndPointFeature+0x74>
      || pInformation->Current_Configuration == 0)
    6184:	7a89      	ldrb	r1, [r1, #10]
    6186:	b1e9      	cbz	r1, 61c4 <Standard_SetEndPointFeature+0x74>
  else
  {
    if (wIndex0 & 0x80)
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6188:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    618c:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
  {
    return USB_UNSUPPORT;
  }
  else
  {
    if (wIndex0 & 0x80)
    6190:	f012 0f80 	tst.w	r2, #128	; 0x80
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6194:	681a      	ldr	r2, [r3, #0]
  {
    return USB_UNSUPPORT;
  }
  else
  {
    if (wIndex0 & 0x80)
    6196:	d007      	beq.n	61a8 <Standard_SetEndPointFeature+0x58>
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6198:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
    619c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    61a0:	b292      	uxth	r2, r2
    61a2:	f082 0210 	eor.w	r2, r2, #16
    61a6:	e006      	b.n	61b6 <Standard_SetEndPointFeature+0x66>
    }

    else
    {
      /* OUT endpoint */
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    61a8:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    61ac:	f022 0270 	bic.w	r2, r2, #112	; 0x70
    61b0:	b292      	uxth	r2, r2
    61b2:	f482 5280 	eor.w	r2, r2, #4096	; 0x1000
    61b6:	601a      	str	r2, [r3, #0]
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
    61b8:	4b05      	ldr	r3, [pc, #20]	; (61d0 <Standard_SetEndPointFeature+0x80>)
    61ba:	681b      	ldr	r3, [r3, #0]
    61bc:	699b      	ldr	r3, [r3, #24]
    61be:	4798      	blx	r3
  return USB_SUCCESS;
    61c0:	2000      	movs	r0, #0
    61c2:	bd38      	pop	{r3, r4, r5, pc}

  if (Related_Endpoint >= Device_Table.Total_Endpoint
      || pInformation->USBwValue != 0 || Status == 0
      || pInformation->Current_Configuration == 0)
  {
    return USB_UNSUPPORT;
    61c4:	2002      	movs	r0, #2
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
  return USB_SUCCESS;
}
    61c6:	bd38      	pop	{r3, r4, r5, pc}
    61c8:	200005a8 	andcs	r0, r0, r8, lsr #11
    61cc:	200000a4 	andcs	r0, r0, r4, lsr #1
    61d0:	200005a4 	andcs	r0, r0, r4, lsr #11

000061d4 <Standard_SetDeviceFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetDeviceFeature(void)
{
    61d4:	b508      	push	{r3, lr}
  SetBit(pInformation->Current_Feature, 5);
    61d6:	4b06      	ldr	r3, [pc, #24]	; (61f0 <Standard_SetDeviceFeature+0x1c>)
    61d8:	681b      	ldr	r3, [r3, #0]
    61da:	7a5a      	ldrb	r2, [r3, #9]
    61dc:	f042 0220 	orr.w	r2, r2, #32
    61e0:	725a      	strb	r2, [r3, #9]
  pUser_Standard_Requests->User_SetDeviceFeature();
    61e2:	4b04      	ldr	r3, [pc, #16]	; (61f4 <Standard_SetDeviceFeature+0x20>)
    61e4:	681b      	ldr	r3, [r3, #0]
    61e6:	69db      	ldr	r3, [r3, #28]
    61e8:	4798      	blx	r3
  return USB_SUCCESS;
}
    61ea:	2000      	movs	r0, #0
    61ec:	bd08      	pop	{r3, pc}
    61ee:	bf00      	nop
    61f0:	200005a8 	andcs	r0, r0, r8, lsr #11
    61f4:	200005a4 	andcs	r0, r0, r4, lsr #11

000061f8 <Standard_GetDescriptorData>:
*******************************************************************************/
u8 *Standard_GetDescriptorData(u16 Length, ONE_DESCRIPTOR *pDesc)
{
  u32  wOffset;

  wOffset = pInformation->Ctrl_Info.Usb_wOffset;
    61f8:	4b05      	ldr	r3, [pc, #20]	; (6210 <Standard_GetDescriptorData+0x18>)
    61fa:	681a      	ldr	r2, [r3, #0]
    61fc:	8a53      	ldrh	r3, [r2, #18]
  if (Length == 0)
    61fe:	b918      	cbnz	r0, 6208 <Standard_GetDescriptorData+0x10>
  {
    pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
    6200:	8889      	ldrh	r1, [r1, #4]
    6202:	1acb      	subs	r3, r1, r3
    6204:	8213      	strh	r3, [r2, #16]
    return 0;
    6206:	4770      	bx	lr
  }

  return pDesc->Descriptor + wOffset;
    6208:	6808      	ldr	r0, [r1, #0]
    620a:	4418      	add	r0, r3
}
    620c:	4770      	bx	lr
    620e:	bf00      	nop
    6210:	200005a8 	andcs	r0, r0, r8, lsr #11

00006214 <Post0_Process>:
* Output         : None.
* Return         : - 0 if the control State is in PAUSE
*                  - 1 if not.
*******************************************************************************/
u8 Post0_Process(void)
{
    6214:	b508      	push	{r3, lr}
  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
    6216:	4b0b      	ldr	r3, [pc, #44]	; (6244 <Post0_Process+0x30>)
    6218:	2000      	movs	r0, #0
    621a:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
    621e:	f7ff fd49 	bl	5cb4 <SetEPRxCount>

  if (pInformation->ControlState == STALLED)
    6222:	4b09      	ldr	r3, [pc, #36]	; (6248 <Post0_Process+0x34>)
    6224:	681b      	ldr	r3, [r3, #0]
    6226:	7a18      	ldrb	r0, [r3, #8]
    6228:	2808      	cmp	r0, #8
    622a:	d106      	bne.n	623a <Post0_Process+0x26>
  {
    vSetEPRxStatus(EP_RX_STALL);
    622c:	4b07      	ldr	r3, [pc, #28]	; (624c <Post0_Process+0x38>)
    622e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    6232:	801a      	strh	r2, [r3, #0]
    vSetEPTxStatus(EP_TX_STALL);
    6234:	4b06      	ldr	r3, [pc, #24]	; (6250 <Post0_Process+0x3c>)
    6236:	2210      	movs	r2, #16
    6238:	801a      	strh	r2, [r3, #0]
  }

  return (pInformation->ControlState == PAUSE);
}
    623a:	f1b0 0309 	subs.w	r3, r0, #9
    623e:	4258      	negs	r0, r3
    6240:	4158      	adcs	r0, r3
    6242:	bd08      	pop	{r3, pc}
    6244:	20000014 	andcs	r0, r0, r4, lsl r0
    6248:	200005a8 	andcs	r0, r0, r8, lsr #11
    624c:	20000576 	andcs	r0, r0, r6, ror r5
    6250:	20000578 	andcs	r0, r0, r8, ror r5

00006254 <Setup0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 Setup0_Process(void)
{
    6254:	b573      	push	{r0, r1, r4, r5, r6, lr}
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    6256:	4e96      	ldr	r6, [pc, #600]	; (64b0 <Setup0_Process+0x25c>)
    6258:	4b96      	ldr	r3, [pc, #600]	; (64b4 <Setup0_Process+0x260>)
    625a:	6832      	ldr	r2, [r6, #0]

  if (pInformation->ControlState != PAUSE)
    625c:	4d96      	ldr	r5, [pc, #600]	; (64b8 <Setup0_Process+0x264>)
    625e:	b292      	uxth	r2, r2
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    6260:	4413      	add	r3, r2
    6262:	005b      	lsls	r3, r3, #1
    6264:	681a      	ldr	r2, [r3, #0]

  if (pInformation->ControlState != PAUSE)
    6266:	682b      	ldr	r3, [r5, #0]
    6268:	7a19      	ldrb	r1, [r3, #8]
    626a:	2909      	cmp	r1, #9
    626c:	d00f      	beq.n	628e <Setup0_Process+0x3a>
    626e:	b292      	uxth	r2, r2
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    6270:	0052      	lsls	r2, r2, #1
    6272:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    6276:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
    627a:	7811      	ldrb	r1, [r2, #0]
    627c:	7019      	strb	r1, [r3, #0]
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
    627e:	7851      	ldrb	r1, [r2, #1]
    6280:	7059      	strb	r1, [r3, #1]
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = *pBuf.w++; /* wValue in Little Endian */
    6282:	8891      	ldrh	r1, [r2, #4]
    6284:	8059      	strh	r1, [r3, #2]
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = *pBuf.w++; /* wIndex in Little Endian */
    6286:	8911      	ldrh	r1, [r2, #8]
    6288:	8099      	strh	r1, [r3, #4]
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwLength = *pBuf.w; /* wLength in Little Endian */
    628a:	8992      	ldrh	r2, [r2, #12]
    628c:	80da      	strh	r2, [r3, #6]
  }

  pInformation->ControlState = SETTING_UP;
    628e:	2201      	movs	r2, #1
    6290:	721a      	strb	r2, [r3, #8]
  if (pInformation->USBwLength == 0)
    6292:	88da      	ldrh	r2, [r3, #6]
    6294:	785c      	ldrb	r4, [r3, #1]
    6296:	2a00      	cmp	r2, #0
    6298:	d161      	bne.n	635e <Setup0_Process+0x10a>
{
  RESULT Result = USB_UNSUPPORT;
  u32 RequestNo = pInformation->USBbRequest;
  u32 ControlState;

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    629a:	781a      	ldrb	r2, [r3, #0]
    629c:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
    62a0:	d13a      	bne.n	6318 <Setup0_Process+0xc4>
  {
    /* Device Request*/
    /* SET_CONFIGURATION*/
    if (RequestNo == SET_CONFIGURATION)
    62a2:	2c09      	cmp	r4, #9
    62a4:	d102      	bne.n	62ac <Setup0_Process+0x58>
    {
      Result = Standard_SetConfiguration();
    62a6:	f7ff feab 	bl	6000 <Standard_SetConfiguration>
    62aa:	e044      	b.n	6336 <Setup0_Process+0xe2>
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    62ac:	2c05      	cmp	r4, #5
    62ae:	d10f      	bne.n	62d0 <Setup0_Process+0x7c>
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
    62b0:	f993 2002 	ldrsb.w	r2, [r3, #2]
    62b4:	2a00      	cmp	r2, #0
    62b6:	da01      	bge.n	62bc <Setup0_Process+0x68>
          || (pInformation->USBwIndex != 0)
          || (pInformation->Current_Configuration != 0))
        /* Device Address should be 127 or less*/
      {
        ControlState = STALLED;
    62b8:	2308      	movs	r3, #8
    62ba:	e04d      	b.n	6358 <Setup0_Process+0x104>
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
    62bc:	78da      	ldrb	r2, [r3, #3]
    62be:	2a00      	cmp	r2, #0
    62c0:	d1fa      	bne.n	62b8 <Setup0_Process+0x64>
          || (pInformation->USBwIndex != 0)
    62c2:	889a      	ldrh	r2, [r3, #4]
    62c4:	2a00      	cmp	r2, #0
    62c6:	d1f7      	bne.n	62b8 <Setup0_Process+0x64>
          || (pInformation->Current_Configuration != 0))
    62c8:	7a9b      	ldrb	r3, [r3, #10]
    62ca:	2b00      	cmp	r3, #0
    62cc:	d037      	beq.n	633e <Setup0_Process+0xea>
    62ce:	e7f3      	b.n	62b8 <Setup0_Process+0x64>
      {
        Result = USB_SUCCESS;
      }
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    62d0:	2c03      	cmp	r4, #3
    62d2:	d113      	bne.n	62fc <Setup0_Process+0xa8>
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
    62d4:	789a      	ldrb	r2, [r3, #2]
    62d6:	2a01      	cmp	r2, #1
    62d8:	d007      	beq.n	62ea <Setup0_Process+0x96>
  }


  if (Result != USB_SUCCESS)
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    62da:	4b78      	ldr	r3, [pc, #480]	; (64bc <Setup0_Process+0x268>)
    62dc:	4620      	mov	r0, r4
    62de:	681b      	ldr	r3, [r3, #0]
    62e0:	695b      	ldr	r3, [r3, #20]
    62e2:	4798      	blx	r3
    if (Result == USB_NOT_READY)
    62e4:	2803      	cmp	r0, #3
    62e6:	d128      	bne.n	633a <Setup0_Process+0xe6>
    62e8:	e035      	b.n	6356 <Setup0_Process+0x102>
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
          && (pInformation->USBwIndex == 0)
    62ea:	889a      	ldrh	r2, [r3, #4]
    62ec:	2a00      	cmp	r2, #0
    62ee:	d1f4      	bne.n	62da <Setup0_Process+0x86>
          && (ValBit(pInformation->Current_Feature, 5)))
    62f0:	7a5b      	ldrb	r3, [r3, #9]
    62f2:	0698      	lsls	r0, r3, #26
    62f4:	d5f1      	bpl.n	62da <Setup0_Process+0x86>
      {
        Result = Standard_SetDeviceFeature();
    62f6:	f7ff ff6d 	bl	61d4 <Standard_SetDeviceFeature>
    62fa:	e01c      	b.n	6336 <Setup0_Process+0xe2>
      {
        Result = USB_UNSUPPORT;
      }
    }
    /*Clear FEATURE for Device */
    else if (RequestNo == CLEAR_FEATURE)
    62fc:	2c01      	cmp	r4, #1
    62fe:	d1ec      	bne.n	62da <Setup0_Process+0x86>
    {
      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
    6300:	789a      	ldrb	r2, [r3, #2]
    6302:	2a01      	cmp	r2, #1
    6304:	d1e9      	bne.n	62da <Setup0_Process+0x86>
          && pInformation->USBwIndex == 0
    6306:	889a      	ldrh	r2, [r3, #4]
    6308:	2a00      	cmp	r2, #0
    630a:	d1e6      	bne.n	62da <Setup0_Process+0x86>
          && ValBit(pInformation->Current_Feature, 5))
    630c:	7a5b      	ldrb	r3, [r3, #9]
    630e:	0699      	lsls	r1, r3, #26
    6310:	d5e3      	bpl.n	62da <Setup0_Process+0x86>
      {
        Result = Standard_ClearFeature();
    6312:	f7ff feb5 	bl	6080 <Standard_ClearFeature>
    6316:	e00e      	b.n	6336 <Setup0_Process+0xe2>
    }

  }

  /* Interface Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    6318:	2a01      	cmp	r2, #1
    631a:	d104      	bne.n	6326 <Setup0_Process+0xd2>
  {
    /*SET INTERFACE*/
    if (RequestNo == SET_INTERFACE)
    631c:	2c0b      	cmp	r4, #11
    631e:	d1dc      	bne.n	62da <Setup0_Process+0x86>
    {
      Result = Standard_SetInterface();
    6320:	f7ff fe8a 	bl	6038 <Standard_SetInterface>
    6324:	e007      	b.n	6336 <Setup0_Process+0xe2>
    }
  }

  /* EndPoint Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    6326:	2a02      	cmp	r2, #2
    6328:	d1d7      	bne.n	62da <Setup0_Process+0x86>
  {
    /*CLEAR FEATURE for EndPoint*/
    if (RequestNo == CLEAR_FEATURE)
    632a:	2c01      	cmp	r4, #1
    632c:	d0f1      	beq.n	6312 <Setup0_Process+0xbe>
    {
      Result = Standard_ClearFeature();
    }
    /* SET FEATURE for EndPoint*/
    else if (RequestNo == SET_FEATURE)
    632e:	2c03      	cmp	r4, #3
    6330:	d1d3      	bne.n	62da <Setup0_Process+0x86>
    {
      Result = Standard_SetEndPointFeature();
    6332:	f7ff ff0d 	bl	6150 <Standard_SetEndPointFeature>
  {
    Result = USB_UNSUPPORT;
  }


  if (Result != USB_SUCCESS)
    6336:	b110      	cbz	r0, 633e <Setup0_Process+0xea>
    6338:	e7cf      	b.n	62da <Setup0_Process+0x86>
      ControlState = PAUSE;
      goto exit_NoData_Setup0;
    }
  }

  if (Result != USB_SUCCESS)
    633a:	2800      	cmp	r0, #0
    633c:	d1bc      	bne.n	62b8 <Setup0_Process+0x64>
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();
    633e:	6832      	ldr	r2, [r6, #0]
    6340:	4b5f      	ldr	r3, [pc, #380]	; (64c0 <Setup0_Process+0x26c>)
    6342:	b292      	uxth	r2, r2
    6344:	4413      	add	r3, r2
    6346:	005b      	lsls	r3, r3, #1
    6348:	2200      	movs	r2, #0
    634a:	601a      	str	r2, [r3, #0]
    634c:	4b5d      	ldr	r3, [pc, #372]	; (64c4 <Setup0_Process+0x270>)
    634e:	2230      	movs	r2, #48	; 0x30
    6350:	801a      	strh	r2, [r3, #0]
  {
    ControlState = STALLED;
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
    6352:	2306      	movs	r3, #6
    6354:	e000      	b.n	6358 <Setup0_Process+0x104>
  if (Result != USB_SUCCESS)
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    if (Result == USB_NOT_READY)
    {
      ControlState = PAUSE;
    6356:	2309      	movs	r3, #9
  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();

exit_NoData_Setup0:
  pInformation->ControlState = ControlState;
    6358:	682a      	ldr	r2, [r5, #0]
    635a:	7213      	strb	r3, [r2, #8]
    635c:	e0d4      	b.n	6508 <Setup0_Process+0x2b4>


  CopyRoutine = NULL;
  wOffset = 0;

  if (Request_No == GET_DESCRIPTOR)
    635e:	2c06      	cmp	r4, #6
    6360:	d118      	bne.n	6394 <Setup0_Process+0x140>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6362:	781a      	ldrb	r2, [r3, #0]
    6364:	0652      	lsls	r2, r2, #25
    6366:	d17c      	bne.n	6462 <Setup0_Process+0x20e>
    {
      u8 wValue1 = pInformation->USBwValue1;
    6368:	78da      	ldrb	r2, [r3, #3]
    636a:	4b54      	ldr	r3, [pc, #336]	; (64bc <Setup0_Process+0x268>)
      if (wValue1 == DEVICE_DESCRIPTOR)
    636c:	2a01      	cmp	r2, #1
    636e:	d102      	bne.n	6376 <Setup0_Process+0x122>
      {
        CopyRoutine = pProperty->GetDeviceDescriptor;
    6370:	681b      	ldr	r3, [r3, #0]
    6372:	69db      	ldr	r3, [r3, #28]
    6374:	e06c      	b.n	6450 <Setup0_Process+0x1fc>
      }
      else if (wValue1 == CONFIG_DESCRIPTOR)
    6376:	2a02      	cmp	r2, #2
    6378:	d102      	bne.n	6380 <Setup0_Process+0x12c>
      {
        CopyRoutine = pProperty->GetConfigDescriptor;
    637a:	681b      	ldr	r3, [r3, #0]
    637c:	6a1b      	ldr	r3, [r3, #32]
    637e:	e067      	b.n	6450 <Setup0_Process+0x1fc>
      }
      else if (wValue1 == STRING_DESCRIPTOR)
    6380:	2a03      	cmp	r2, #3
    6382:	d102      	bne.n	638a <Setup0_Process+0x136>
      {
        CopyRoutine = pProperty->GetStringDescriptor;
    6384:	681b      	ldr	r3, [r3, #0]
    6386:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6388:	e062      	b.n	6450 <Setup0_Process+0x1fc>
      } else if (wValue1 == 0x21) /* added to support functional descriptors */
    638a:	2a21      	cmp	r2, #33	; 0x21
    638c:	d169      	bne.n	6462 <Setup0_Process+0x20e>
      {
	CopyRoutine = pProperty->GetFunctionalDescriptor;
    638e:	681b      	ldr	r3, [r3, #0]
    6390:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6392:	e05d      	b.n	6450 <Setup0_Process+0x1fc>
      } /* End of GET_DESCRIPTOR */
    }
  }

  /*GET STATUS*/
  else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
    6394:	2c00      	cmp	r4, #0
    6396:	d13c      	bne.n	6412 <Setup0_Process+0x1be>
    6398:	8859      	ldrh	r1, [r3, #2]
    639a:	2900      	cmp	r1, #0
    639c:	d161      	bne.n	6462 <Setup0_Process+0x20e>
           && (pInformation->USBwLength == 0x0002)
           && (pInformation->USBwIndex1 == 0))
    639e:	685a      	ldr	r2, [r3, #4]
    63a0:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
    63a4:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
    63a8:	d15b      	bne.n	6462 <Setup0_Process+0x20e>
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    63aa:	781a      	ldrb	r2, [r3, #0]
    63ac:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
    63b0:	d104      	bne.n	63bc <Setup0_Process+0x168>
        && (pInformation->USBwIndex == 0))
    63b2:	889b      	ldrh	r3, [r3, #4]
    63b4:	2b00      	cmp	r3, #0
    63b6:	f000 80ab 	beq.w	6510 <Setup0_Process+0x2bc>
    63ba:	e052      	b.n	6462 <Setup0_Process+0x20e>
    {
      CopyRoutine = Standard_GetStatus;
    }

    /* GET STATUS for Interface*/
    else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    63bc:	2a01      	cmp	r2, #1
    63be:	d10c      	bne.n	63da <Setup0_Process+0x186>
    {
      if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
    63c0:	4a3e      	ldr	r2, [pc, #248]	; (64bc <Setup0_Process+0x268>)
    63c2:	7918      	ldrb	r0, [r3, #4]
    63c4:	6812      	ldr	r2, [r2, #0]
    63c6:	6992      	ldr	r2, [r2, #24]
    63c8:	4790      	blx	r2
    63ca:	2800      	cmp	r0, #0
    63cc:	d149      	bne.n	6462 <Setup0_Process+0x20e>
          && (pInformation->Current_Configuration != 0))
    63ce:	682b      	ldr	r3, [r5, #0]
    63d0:	7a9b      	ldrb	r3, [r3, #10]
    63d2:	2b00      	cmp	r3, #0
    63d4:	f040 809c 	bne.w	6510 <Setup0_Process+0x2bc>
    63d8:	e043      	b.n	6462 <Setup0_Process+0x20e>
        CopyRoutine = Standard_GetStatus;
      }
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    63da:	2a02      	cmp	r2, #2
    63dc:	d141      	bne.n	6462 <Setup0_Process+0x20e>
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
    63de:	791b      	ldrb	r3, [r3, #4]
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    63e0:	4839      	ldr	r0, [pc, #228]	; (64c8 <Setup0_Process+0x274>)
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
    63e2:	f003 010f 	and.w	r1, r3, #15
    63e6:	008a      	lsls	r2, r1, #2

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
    63e8:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    63ec:	f502 42b8 	add.w	r2, r2, #23552	; 0x5c00
    63f0:	6812      	ldr	r2, [r2, #0]
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    63f2:	7800      	ldrb	r0, [r0, #0]
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
      Reserved = pInformation->USBwIndex0 & 0x70;

      if (ValBit(pInformation->USBwIndex0, 7))
    63f4:	f013 0f80 	tst.w	r3, #128	; 0x80
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
    63f8:	bf14      	ite	ne
    63fa:	f002 0230 	andne.w	r2, r2, #48	; 0x30
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
    63fe:	f402 5240 	andeq.w	r2, r2, #12288	; 0x3000
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    6402:	4281      	cmp	r1, r0
    6404:	d22d      	bcs.n	6462 <Setup0_Process+0x20e>
    6406:	f013 0f70 	tst.w	r3, #112	; 0x70
    640a:	d12a      	bne.n	6462 <Setup0_Process+0x20e>
          && (Status != 0))
    640c:	2a00      	cmp	r2, #0
    640e:	d17f      	bne.n	6510 <Setup0_Process+0x2bc>
    6410:	e027      	b.n	6462 <Setup0_Process+0x20e>
    }

  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
    6412:	2c08      	cmp	r4, #8
    6414:	d103      	bne.n	641e <Setup0_Process+0x1ca>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6416:	781b      	ldrb	r3, [r3, #0]
    6418:	065b      	lsls	r3, r3, #25
    641a:	d07b      	beq.n	6514 <Setup0_Process+0x2c0>
    641c:	e021      	b.n	6462 <Setup0_Process+0x20e>
    {
      CopyRoutine = Standard_GetConfiguration;
    }
  }
  /*GET INTERFACE*/
  else if (Request_No == GET_INTERFACE)
    641e:	2c0a      	cmp	r4, #10
    6420:	d11f      	bne.n	6462 <Setup0_Process+0x20e>
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    6422:	781a      	ldrb	r2, [r3, #0]
    6424:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    6428:	2a01      	cmp	r2, #1
    642a:	d11a      	bne.n	6462 <Setup0_Process+0x20e>
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
    642c:	7a9a      	ldrb	r2, [r3, #10]
    642e:	b1c2      	cbz	r2, 6462 <Setup0_Process+0x20e>
    6430:	8859      	ldrh	r1, [r3, #2]
    6432:	b9b1      	cbnz	r1, 6462 <Setup0_Process+0x20e>
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
    6434:	685a      	ldr	r2, [r3, #4]
    6436:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
    643a:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    643e:	d110      	bne.n	6462 <Setup0_Process+0x20e>
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
    6440:	4a1e      	ldr	r2, [pc, #120]	; (64bc <Setup0_Process+0x268>)
    6442:	7918      	ldrb	r0, [r3, #4]
    6444:	6812      	ldr	r2, [r2, #0]
    6446:	6992      	ldr	r2, [r2, #24]
    6448:	4790      	blx	r2
    644a:	2800      	cmp	r0, #0
    644c:	d064      	beq.n	6518 <Setup0_Process+0x2c4>
    644e:	e008      	b.n	6462 <Setup0_Process+0x20e>
      CopyRoutine = Standard_GetInterface;
    }

  }

  if (CopyRoutine)
    6450:	b13b      	cbz	r3, 6462 <Setup0_Process+0x20e>
  {
    pInformation->Ctrl_Info.Usb_wOffset = wOffset;
    6452:	682a      	ldr	r2, [r5, #0]
    6454:	2400      	movs	r4, #0
    6456:	8254      	strh	r4, [r2, #18]
    pInformation->Ctrl_Info.CopyData = CopyRoutine;
    6458:	6193      	str	r3, [r2, #24]
    /* sb in the original the cast to word was directly */
    /* now the cast is made step by step */
    (*CopyRoutine)(0);
    645a:	4620      	mov	r0, r4
    645c:	4798      	blx	r3
    Result = USB_SUCCESS;
    645e:	4620      	mov	r0, r4
    6460:	e00a      	b.n	6478 <Setup0_Process+0x224>
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
    6462:	4b16      	ldr	r3, [pc, #88]	; (64bc <Setup0_Process+0x268>)
    6464:	681a      	ldr	r2, [r3, #0]
    6466:	682b      	ldr	r3, [r5, #0]
    6468:	6912      	ldr	r2, [r2, #16]
    646a:	7858      	ldrb	r0, [r3, #1]
    646c:	4790      	blx	r2
    if (Result == USB_NOT_READY)
    646e:	2803      	cmp	r0, #3
    6470:	d102      	bne.n	6478 <Setup0_Process+0x224>
    {
      pInformation->ControlState = PAUSE;
    6472:	4b11      	ldr	r3, [pc, #68]	; (64b8 <Setup0_Process+0x264>)
    6474:	681b      	ldr	r3, [r3, #0]
    6476:	e005      	b.n	6484 <Setup0_Process+0x230>
      return;
    }
  }

  if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
    6478:	682b      	ldr	r3, [r5, #0]
    647a:	f64f 71ff 	movw	r1, #65535	; 0xffff
    647e:	8a1a      	ldrh	r2, [r3, #16]
    6480:	428a      	cmp	r2, r1
    6482:	d101      	bne.n	6488 <Setup0_Process+0x234>
  {
    /* Data is not ready, wait it */
    pInformation->ControlState = PAUSE;
    6484:	2209      	movs	r2, #9
    6486:	e003      	b.n	6490 <Setup0_Process+0x23c>
    return;
  }
  if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
    6488:	2802      	cmp	r0, #2
    648a:	d000      	beq.n	648e <Setup0_Process+0x23a>
    648c:	b912      	cbnz	r2, 6494 <Setup0_Process+0x240>
  {
    /* Unsupported request */
    pInformation->ControlState = STALLED;
    648e:	2208      	movs	r2, #8
    6490:	721a      	strb	r2, [r3, #8]
    6492:	e039      	b.n	6508 <Setup0_Process+0x2b4>
    return;
  }


  if (ValBit(pInformation->USBbmRequestType, 7))
    6494:	f993 1000 	ldrsb.w	r1, [r3]
    6498:	2900      	cmp	r1, #0
    649a:	da2f      	bge.n	64fc <Setup0_Process+0x2a8>
  {
    /* Device ==> Host */
    vu32 wLength = pInformation->USBwLength;
    649c:	88d9      	ldrh	r1, [r3, #6]
    649e:	9101      	str	r1, [sp, #4]

    /* Restrict the data length to be the one host asks */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
    64a0:	9801      	ldr	r0, [sp, #4]
    64a2:	4282      	cmp	r2, r0
    64a4:	4805      	ldr	r0, [pc, #20]	; (64bc <Setup0_Process+0x268>)
    64a6:	d911      	bls.n	64cc <Setup0_Process+0x278>
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
    64a8:	9a01      	ldr	r2, [sp, #4]
    64aa:	821a      	strh	r2, [r3, #16]
    64ac:	e01f      	b.n	64ee <Setup0_Process+0x29a>
    64ae:	bf00      	nop
    64b0:	40005c50 	andmi	r5, r0, r0, asr ip
    64b4:	20003004 	andcs	r3, r0, r4
    64b8:	200005a8 	andcs	r0, r0, r8, lsr #11
    64bc:	20000580 	andcs	r0, r0, r0, lsl #11
    64c0:	20003002 	andcs	r3, r0, r2
    64c4:	20000578 	andcs	r0, r0, r8, ror r5
    64c8:	200000a4 	andcs	r0, r0, r4, lsr #1
    }

    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
    64cc:	428a      	cmp	r2, r1
    64ce:	d20e      	bcs.n	64ee <Setup0_Process+0x29a>
    {
      if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
    64d0:	6801      	ldr	r1, [r0, #0]
    64d2:	f891 1030 	ldrb.w	r1, [r1, #48]	; 0x30
    64d6:	428a      	cmp	r2, r1
    64d8:	d201      	bcs.n	64de <Setup0_Process+0x28a>
      {
        Data_Mul_MaxPacketSize = FALSE;
    64da:	2100      	movs	r1, #0
    64dc:	e005      	b.n	64ea <Setup0_Process+0x296>
      }
      else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
    64de:	fb92 f4f1 	sdiv	r4, r2, r1
    64e2:	fb01 2214 	mls	r2, r1, r4, r2
    64e6:	b912      	cbnz	r2, 64ee <Setup0_Process+0x29a>
      {
        Data_Mul_MaxPacketSize = TRUE;
    64e8:	2101      	movs	r1, #1
    64ea:	4a0c      	ldr	r2, [pc, #48]	; (651c <Setup0_Process+0x2c8>)
    64ec:	7011      	strb	r1, [r2, #0]
      }
    }

    pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
    64ee:	6802      	ldr	r2, [r0, #0]
    64f0:	f892 2030 	ldrb.w	r2, [r2, #48]	; 0x30
    64f4:	829a      	strh	r2, [r3, #20]
    DataStageIn();
    64f6:	f7ff fd2f 	bl	5f58 <DataStageIn>
    64fa:	e005      	b.n	6508 <Setup0_Process+0x2b4>
  }
  else
  {
    pInformation->ControlState = OUT_DATA;
    64fc:	2203      	movs	r2, #3
    64fe:	721a      	strb	r2, [r3, #8]
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
    6500:	4b07      	ldr	r3, [pc, #28]	; (6520 <Setup0_Process+0x2cc>)
    6502:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    6506:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Setup with data stage */
    Data_Setup0();
  }
  return Post0_Process();
    6508:	f7ff fe84 	bl	6214 <Post0_Process>
}
    650c:	b002      	add	sp, #8
    650e:	bd70      	pop	{r4, r5, r6, pc}
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
        && (pInformation->USBwIndex == 0))
    {
      CopyRoutine = Standard_GetStatus;
    6510:	4b04      	ldr	r3, [pc, #16]	; (6524 <Setup0_Process+0x2d0>)
    6512:	e79e      	b.n	6452 <Setup0_Process+0x1fe>
  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    {
      CopyRoutine = Standard_GetConfiguration;
    6514:	4b04      	ldr	r3, [pc, #16]	; (6528 <Setup0_Process+0x2d4>)
    6516:	e79c      	b.n	6452 <Setup0_Process+0x1fe>
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
    {
      CopyRoutine = Standard_GetInterface;
    6518:	4b04      	ldr	r3, [pc, #16]	; (652c <Setup0_Process+0x2d8>)
    651a:	e79a      	b.n	6452 <Setup0_Process+0x1fe>
    651c:	20000dcc 	andcs	r0, r0, ip, asr #27
    6520:	20000576 	andcs	r0, r0, r6, ror r5
    6524:	00005ec9 	andeq	r5, r0, r9, asr #29
    6528:	00005e81 	andeq	r5, r0, r1, lsl #29
    652c:	00005ea5 	andeq	r5, r0, r5, lsr #29

00006530 <Out0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 Out0_Process(void)
{
    6530:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  u32 ControlState = pInformation->ControlState;
    6532:	4d2b      	ldr	r5, [pc, #172]	; (65e0 <Out0_Process+0xb0>)
    6534:	682c      	ldr	r4, [r5, #0]
    6536:	7a23      	ldrb	r3, [r4, #8]

  if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
    6538:	2b03      	cmp	r3, #3
    653a:	d001      	beq.n	6540 <Out0_Process+0x10>
    653c:	2b05      	cmp	r3, #5
    653e:	d141      	bne.n	65c4 <Out0_Process+0x94>
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  u32 save_rLength;

  save_rLength = pEPinfo->Usb_rLength;

  if (pEPinfo->CopyData && save_rLength)
    6540:	69a3      	ldr	r3, [r4, #24]
void DataStageOut(void)
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  u32 save_rLength;

  save_rLength = pEPinfo->Usb_rLength;
    6542:	8a22      	ldrh	r2, [r4, #16]

  if (pEPinfo->CopyData && save_rLength)
    6544:	b1ab      	cbz	r3, 6572 <Out0_Process+0x42>
    6546:	b1a2      	cbz	r2, 6572 <Out0_Process+0x42>
  {
    u8 *Buffer;
    u32 Length;

    Length = pEPinfo->PacketSize;
    6548:	8aa6      	ldrh	r6, [r4, #20]
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    654a:	4296      	cmp	r6, r2
    654c:	bf28      	it	cs
    654e:	4616      	movcs	r6, r2
    6550:	4630      	mov	r0, r6
    6552:	4798      	blx	r3
    pEPinfo->Usb_rLength -= Length;
    6554:	8a23      	ldrh	r3, [r4, #16]
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    6556:	4607      	mov	r7, r0
    pEPinfo->Usb_rLength -= Length;
    6558:	1b9b      	subs	r3, r3, r6
    655a:	8223      	strh	r3, [r4, #16]
    pEPinfo->Usb_rOffset += Length;
    655c:	8a63      	ldrh	r3, [r4, #18]

    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
    655e:	2000      	movs	r0, #0
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    pEPinfo->Usb_rLength -= Length;
    pEPinfo->Usb_rOffset += Length;
    6560:	4433      	add	r3, r6
    6562:	8263      	strh	r3, [r4, #18]

    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
    6564:	f7ff fb8a 	bl	5c7c <GetEPRxAddr>
    6568:	4632      	mov	r2, r6
    656a:	4601      	mov	r1, r0
    656c:	4638      	mov	r0, r7
    656e:	f000 f8a5 	bl	66bc <PMAToUserBufferCopy>
  }

  if (pEPinfo->Usb_rLength != 0)
    6572:	8a23      	ldrh	r3, [r4, #16]
    6574:	b153      	cbz	r3, 658c <Out0_Process+0x5c>
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    6576:	4b1b      	ldr	r3, [pc, #108]	; (65e4 <Out0_Process+0xb4>)
    SetEPTxCount(ENDP0, 0);
    6578:	2000      	movs	r0, #0
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
  }

  if (pEPinfo->Usb_rLength != 0)
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    657a:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    SetEPTxCount(ENDP0, 0);
    657e:	4601      	mov	r1, r0
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
  }

  if (pEPinfo->Usb_rLength != 0)
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    6580:	801a      	strh	r2, [r3, #0]
    SetEPTxCount(ENDP0, 0);
    6582:	f7ff fb89 	bl	5c98 <SetEPTxCount>
    vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
    6586:	4b18      	ldr	r3, [pc, #96]	; (65e8 <Out0_Process+0xb8>)
    6588:	2230      	movs	r2, #48	; 0x30
    658a:	801a      	strh	r2, [r3, #0]
  }
  /* Set the next State*/
  if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
    658c:	8a23      	ldrh	r3, [r4, #16]
    658e:	8aa2      	ldrh	r2, [r4, #20]
    6590:	429a      	cmp	r2, r3
    6592:	d802      	bhi.n	659a <Out0_Process+0x6a>
  {
    pInformation->ControlState = OUT_DATA;
    6594:	682b      	ldr	r3, [r5, #0]
    6596:	2203      	movs	r2, #3
    6598:	e002      	b.n	65a0 <Out0_Process+0x70>
  }
  else
  {
    if (pEPinfo->Usb_rLength > 0)
    659a:	b11b      	cbz	r3, 65a4 <Out0_Process+0x74>
    {
      pInformation->ControlState = LAST_OUT_DATA;
    659c:	682b      	ldr	r3, [r5, #0]
    659e:	2205      	movs	r2, #5
    65a0:	721a      	strb	r2, [r3, #8]
    65a2:	e00c      	b.n	65be <Out0_Process+0x8e>
    }
    else if (pEPinfo->Usb_rLength == 0)
    {
      pInformation->ControlState = WAIT_STATUS_IN;
    65a4:	682a      	ldr	r2, [r5, #0]
    65a6:	2106      	movs	r1, #6
    65a8:	7211      	strb	r1, [r2, #8]
      USB_StatusIn();
    65aa:	4a10      	ldr	r2, [pc, #64]	; (65ec <Out0_Process+0xbc>)
    65ac:	6811      	ldr	r1, [r2, #0]
    65ae:	4a10      	ldr	r2, [pc, #64]	; (65f0 <Out0_Process+0xc0>)
    65b0:	b289      	uxth	r1, r1
    65b2:	440a      	add	r2, r1
    65b4:	0052      	lsls	r2, r2, #1
    65b6:	6013      	str	r3, [r2, #0]
    65b8:	4b0b      	ldr	r3, [pc, #44]	; (65e8 <Out0_Process+0xb8>)
    65ba:	2230      	movs	r2, #48	; 0x30
    65bc:	801a      	strh	r2, [r3, #0]
  u32 ControlState = pInformation->ControlState;

  if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
  {
    DataStageOut();
    ControlState = pInformation->ControlState; /* may be changed outside the function */
    65be:	682b      	ldr	r3, [r5, #0]
    65c0:	7a1b      	ldrb	r3, [r3, #8]
    65c2:	e006      	b.n	65d2 <Out0_Process+0xa2>
  }

  else if (ControlState == WAIT_STATUS_OUT)
    65c4:	2b07      	cmp	r3, #7
    65c6:	d103      	bne.n	65d0 <Out0_Process+0xa0>
  {
    (*pProperty->Process_Status_OUT)();
    65c8:	4b0a      	ldr	r3, [pc, #40]	; (65f4 <Out0_Process+0xc4>)
    65ca:	681b      	ldr	r3, [r3, #0]
    65cc:	68db      	ldr	r3, [r3, #12]
    65ce:	4798      	blx	r3
  }

  else if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
  {
    /* host aborts the transfer before finish */
    ControlState = STALLED;
    65d0:	2308      	movs	r3, #8
  else
  {
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;
    65d2:	682a      	ldr	r2, [r5, #0]
    65d4:	7213      	strb	r3, [r2, #8]

  return Post0_Process();
}
    65d6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
    65da:	f7ff be1b 	b.w	6214 <Post0_Process>
    65de:	bf00      	nop
    65e0:	200005a8 	andcs	r0, r0, r8, lsr #11
    65e4:	20000576 	andcs	r0, r0, r6, ror r5
    65e8:	20000578 	andcs	r0, r0, r8, ror r5
    65ec:	40005c50 	andmi	r5, r0, r0, asr ip
    65f0:	20003002 	andcs	r3, r0, r2
    65f4:	20000580 	andcs	r0, r0, r0, lsl #11

000065f8 <SetDeviceAddress>:
* Input          : - Val: device adress.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetDeviceAddress(u8 Val)
{
    65f8:	b530      	push	{r4, r5, lr}
  u32 i;
  u32 nEP = Device_Table.Total_Endpoint;
    65fa:	4b0b      	ldr	r3, [pc, #44]	; (6628 <SetDeviceAddress+0x30>)
    65fc:	781c      	ldrb	r4, [r3, #0]

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
    65fe:	2300      	movs	r3, #0
    6600:	42a3      	cmp	r3, r4
    6602:	d20c      	bcs.n	661e <SetDeviceAddress+0x26>
    6604:	f103 5280 	add.w	r2, r3, #268435456	; 0x10000000
    6608:	f502 52b8 	add.w	r2, r2, #5888	; 0x1700
    660c:	0091      	lsls	r1, r2, #2
  {
    _SetEPAddress((u8)i, (u8)i);
    660e:	680d      	ldr	r5, [r1, #0]
    6610:	f648 728f 	movw	r2, #36751	; 0x8f8f
    6614:	402a      	ands	r2, r5
    6616:	431a      	orrs	r2, r3
    6618:	600a      	str	r2, [r1, #0]
{
  u32 i;
  u32 nEP = Device_Table.Total_Endpoint;

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
    661a:	3301      	adds	r3, #1
    661c:	e7f0      	b.n	6600 <SetDeviceAddress+0x8>
  {
    _SetEPAddress((u8)i, (u8)i);
  } /* for */
  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
    661e:	4b03      	ldr	r3, [pc, #12]	; (662c <SetDeviceAddress+0x34>)
    6620:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    6624:	6018      	str	r0, [r3, #0]
    6626:	bd30      	pop	{r4, r5, pc}
    6628:	200000a4 	andcs	r0, r0, r4, lsr #1
    662c:	40005c4c 	andmi	r5, r0, ip, asr #24

00006630 <In0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 In0_Process(void)
{
    6630:	b510      	push	{r4, lr}
  u32 ControlState = pInformation->ControlState;
    6632:	4c13      	ldr	r4, [pc, #76]	; (6680 <In0_Process+0x50>)
    6634:	6823      	ldr	r3, [r4, #0]
    6636:	7a1a      	ldrb	r2, [r3, #8]

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
    6638:	2a02      	cmp	r2, #2
    663a:	d001      	beq.n	6640 <In0_Process+0x10>
    663c:	2a04      	cmp	r2, #4
    663e:	d104      	bne.n	664a <In0_Process+0x1a>
  {
    DataStageIn();
    6640:	f7ff fc8a 	bl	5f58 <DataStageIn>
    /* ControlState may be changed outside the function */
    ControlState = pInformation->ControlState;
    6644:	6823      	ldr	r3, [r4, #0]
    6646:	7a1b      	ldrb	r3, [r3, #8]
    6648:	e013      	b.n	6672 <In0_Process+0x42>
  }

  else if (ControlState == WAIT_STATUS_IN)
    664a:	2a06      	cmp	r2, #6
    664c:	d110      	bne.n	6670 <In0_Process+0x40>
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
    664e:	785a      	ldrb	r2, [r3, #1]
    6650:	2a05      	cmp	r2, #5
    6652:	d109      	bne.n	6668 <In0_Process+0x38>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    6654:	781a      	ldrb	r2, [r3, #0]
    ControlState = pInformation->ControlState;
  }

  else if (ControlState == WAIT_STATUS_IN)
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
    6656:	0652      	lsls	r2, r2, #25
    6658:	d106      	bne.n	6668 <In0_Process+0x38>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    {
      SetDeviceAddress(pInformation->USBwValue0);
    665a:	7898      	ldrb	r0, [r3, #2]
    665c:	f7ff ffcc 	bl	65f8 <SetDeviceAddress>
      pUser_Standard_Requests->User_SetDeviceAddress();
    6660:	4b08      	ldr	r3, [pc, #32]	; (6684 <In0_Process+0x54>)
    6662:	681b      	ldr	r3, [r3, #0]
    6664:	6a1b      	ldr	r3, [r3, #32]
    6666:	4798      	blx	r3
    }
    (*pProperty->Process_Status_IN)();
    6668:	4b07      	ldr	r3, [pc, #28]	; (6688 <In0_Process+0x58>)
    666a:	681b      	ldr	r3, [r3, #0]
    666c:	689b      	ldr	r3, [r3, #8]
    666e:	4798      	blx	r3
    ControlState = STALLED;
  }

  else
  {
    ControlState = STALLED;
    6670:	2308      	movs	r3, #8
  }

  pInformation->ControlState = ControlState;
    6672:	6822      	ldr	r2, [r4, #0]
    6674:	7213      	strb	r3, [r2, #8]

  return Post0_Process();
}
    6676:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
    667a:	f7ff bdcb 	b.w	6214 <Post0_Process>
    667e:	bf00      	nop
    6680:	200005a8 	andcs	r0, r0, r8, lsr #11
    6684:	200005a4 	andcs	r0, r0, r4, lsr #11
    6688:	20000580 	andcs	r0, r0, r0, lsl #11

0000668c <UserToPMABufferCopy>:
*                  - wNBytes: no. of bytes to be copied.
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
    668c:	b530      	push	{r4, r5, lr}
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
    668e:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
    6692:	3201      	adds	r2, #1
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
    6694:	f501 5140 	add.w	r1, r1, #12288	; 0x3000
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
    6698:	1052      	asrs	r2, r2, #1
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
    669a:	0049      	lsls	r1, r1, #1
  for (i = n; i != 0; i--)
    669c:	2300      	movs	r3, #0
    669e:	4293      	cmp	r3, r2
    66a0:	f100 0002 	add.w	r0, r0, #2
    66a4:	d009      	beq.n	66ba <UserToPMABufferCopy+0x2e>
  {
    temp1 = (u16) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (u16) * pbUsrBuf << 8;
    66a6:	f810 5c01 	ldrb.w	r5, [r0, #-1]
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
  {
    temp1 = (u16) * pbUsrBuf;
    66aa:	f810 4c02 	ldrb.w	r4, [r0, #-2]
    pbUsrBuf++;
    temp2 = temp1 | (u16) * pbUsrBuf << 8;
    66ae:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    *pdwVal++ = temp2;
    66b2:	f821 4023 	strh.w	r4, [r1, r3, lsl #2]
    66b6:	3301      	adds	r3, #1
    66b8:	e7f1      	b.n	669e <UserToPMABufferCopy+0x12>
    pdwVal++;
    pbUsrBuf++;
  }
}
    66ba:	bd30      	pop	{r4, r5, pc}

000066bc <PMAToUserBufferCopy>:
*                  - wNBytes     = no. of bytes to be copied.
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
    66bc:	b510      	push	{r4, lr}
  u32 n = (wNBytes + 1) >> 1;/* /2*/
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
    66be:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;/* /2*/
    66c2:	3201      	adds	r2, #1
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
    66c4:	f501 5140 	add.w	r1, r1, #12288	; 0x3000
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;/* /2*/
    66c8:	1052      	asrs	r2, r2, #1
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
    66ca:	0049      	lsls	r1, r1, #1
  for (i = n; i != 0; i--)
    66cc:	2300      	movs	r3, #0
    66ce:	4293      	cmp	r3, r2
    66d0:	d005      	beq.n	66de <PMAToUserBufferCopy+0x22>
  {
    *(u16*)pbUsrBuf++ = *pdwVal++;
    66d2:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
    66d6:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
    66da:	3301      	adds	r3, #1
    66dc:	e7f7      	b.n	66ce <PMAToUserBufferCopy+0x12>
    pbUsrBuf++;
  }
}
    66de:	bd10      	pop	{r4, pc}

000066e0 <memcpy>:
    66e0:	b510      	push	{r4, lr}
    66e2:	2300      	movs	r3, #0
    66e4:	4293      	cmp	r3, r2
    66e6:	d003      	beq.n	66f0 <memcpy+0x10>
    66e8:	5ccc      	ldrb	r4, [r1, r3]
    66ea:	54c4      	strb	r4, [r0, r3]
    66ec:	3301      	adds	r3, #1
    66ee:	e7f9      	b.n	66e4 <memcpy+0x4>
    66f0:	bd10      	pop	{r4, pc}

000066f2 <memmem>:
    66f2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    66f6:	4606      	mov	r6, r0
    66f8:	460f      	mov	r7, r1
    66fa:	4691      	mov	r9, r2
    66fc:	461d      	mov	r5, r3
    66fe:	b18b      	cbz	r3, 6724 <memmem+0x32>
    6700:	460c      	mov	r4, r1
    6702:	eb06 0807 	add.w	r8, r6, r7
    6706:	42a5      	cmp	r5, r4
    6708:	ebc4 0808 	rsb	r8, r4, r8
    670c:	d807      	bhi.n	671e <memmem+0x2c>
    670e:	4640      	mov	r0, r8
    6710:	4649      	mov	r1, r9
    6712:	462a      	mov	r2, r5
    6714:	f000 f83a 	bl	678c <memcmp>
    6718:	b130      	cbz	r0, 6728 <memmem+0x36>
    671a:	3c01      	subs	r4, #1
    671c:	e7f1      	b.n	6702 <memmem+0x10>
    671e:	2000      	movs	r0, #0
    6720:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6724:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6728:	4640      	mov	r0, r8
    672a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0000672e <memset>:
    672e:	4402      	add	r2, r0
    6730:	4603      	mov	r3, r0
    6732:	4293      	cmp	r3, r2
    6734:	d002      	beq.n	673c <memset+0xe>
    6736:	f803 1b01 	strb.w	r1, [r3], #1
    673a:	e7fa      	b.n	6732 <memset+0x4>
    673c:	4770      	bx	lr

0000673e <_vsiprintf_r>:
    673e:	b510      	push	{r4, lr}
    6740:	b09a      	sub	sp, #104	; 0x68
    6742:	9100      	str	r1, [sp, #0]
    6744:	9104      	str	r1, [sp, #16]
    6746:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    674a:	9102      	str	r1, [sp, #8]
    674c:	9105      	str	r1, [sp, #20]
    674e:	f64f 71ff 	movw	r1, #65535	; 0xffff
    6752:	f8ad 100e 	strh.w	r1, [sp, #14]
    6756:	f44f 7402 	mov.w	r4, #520	; 0x208
    675a:	4669      	mov	r1, sp
    675c:	f8ad 400c 	strh.w	r4, [sp, #12]
    6760:	f000 f880 	bl	6864 <_svfiprintf_r>
    6764:	9b00      	ldr	r3, [sp, #0]
    6766:	2200      	movs	r2, #0
    6768:	701a      	strb	r2, [r3, #0]
    676a:	b01a      	add	sp, #104	; 0x68
    676c:	bd10      	pop	{r4, pc}
	...

00006770 <vsiprintf>:
    6770:	b530      	push	{r4, r5, lr}
    6772:	4613      	mov	r3, r2
    6774:	4a04      	ldr	r2, [pc, #16]	; (6788 <vsiprintf+0x18>)
    6776:	4605      	mov	r5, r0
    6778:	460c      	mov	r4, r1
    677a:	6810      	ldr	r0, [r2, #0]
    677c:	4629      	mov	r1, r5
    677e:	4622      	mov	r2, r4
    6780:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    6784:	f7ff bfdb 	b.w	673e <_vsiprintf_r>
    6788:	20000484 	andcs	r0, r0, r4, lsl #9

0000678c <memcmp>:
    678c:	b530      	push	{r4, r5, lr}
    678e:	2300      	movs	r3, #0
    6790:	4293      	cmp	r3, r2
    6792:	d008      	beq.n	67a6 <memcmp+0x1a>
    6794:	5cc5      	ldrb	r5, [r0, r3]
    6796:	3301      	adds	r3, #1
    6798:	18cc      	adds	r4, r1, r3
    679a:	f814 4c01 	ldrb.w	r4, [r4, #-1]
    679e:	42a5      	cmp	r5, r4
    67a0:	d0f6      	beq.n	6790 <memcmp+0x4>
    67a2:	1b28      	subs	r0, r5, r4
    67a4:	bd30      	pop	{r4, r5, pc}
    67a6:	2000      	movs	r0, #0
    67a8:	bd30      	pop	{r4, r5, pc}

000067aa <__ssputs_r>:
    67aa:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    67ae:	688d      	ldr	r5, [r1, #8]
    67b0:	4681      	mov	r9, r0
    67b2:	42ab      	cmp	r3, r5
    67b4:	460c      	mov	r4, r1
    67b6:	4692      	mov	sl, r2
    67b8:	461f      	mov	r7, r3
    67ba:	d343      	bcc.n	6844 <__ssputs_r+0x9a>
    67bc:	898b      	ldrh	r3, [r1, #12]
    67be:	f413 6f90 	tst.w	r3, #1152	; 0x480
    67c2:	d03d      	beq.n	6840 <__ssputs_r+0x96>
    67c4:	6826      	ldr	r6, [r4, #0]
    67c6:	6909      	ldr	r1, [r1, #16]
    67c8:	2202      	movs	r2, #2
    67ca:	ebc1 0806 	rsb	r8, r1, r6
    67ce:	6966      	ldr	r6, [r4, #20]
    67d0:	eb06 0646 	add.w	r6, r6, r6, lsl #1
    67d4:	fb96 f6f2 	sdiv	r6, r6, r2
    67d8:	f108 0201 	add.w	r2, r8, #1
    67dc:	443a      	add	r2, r7
    67de:	4296      	cmp	r6, r2
    67e0:	bf38      	it	cc
    67e2:	4616      	movcc	r6, r2
    67e4:	055b      	lsls	r3, r3, #21
    67e6:	d50f      	bpl.n	6808 <__ssputs_r+0x5e>
    67e8:	4631      	mov	r1, r6
    67ea:	f000 fb1b 	bl	6e24 <_malloc_r>
    67ee:	4605      	mov	r5, r0
    67f0:	b198      	cbz	r0, 681a <__ssputs_r+0x70>
    67f2:	6921      	ldr	r1, [r4, #16]
    67f4:	4642      	mov	r2, r8
    67f6:	f7ff ff73 	bl	66e0 <memcpy>
    67fa:	89a3      	ldrh	r3, [r4, #12]
    67fc:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
    6800:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    6804:	81a3      	strh	r3, [r4, #12]
    6806:	e013      	b.n	6830 <__ssputs_r+0x86>
    6808:	4632      	mov	r2, r6
    680a:	f000 fb5f 	bl	6ecc <_realloc_r>
    680e:	4605      	mov	r5, r0
    6810:	b970      	cbnz	r0, 6830 <__ssputs_r+0x86>
    6812:	4648      	mov	r0, r9
    6814:	6921      	ldr	r1, [r4, #16]
    6816:	f000 fac1 	bl	6d9c <_free_r>
    681a:	230c      	movs	r3, #12
    681c:	f8c9 3000 	str.w	r3, [r9]
    6820:	89a3      	ldrh	r3, [r4, #12]
    6822:	f04f 30ff 	mov.w	r0, #4294967295
    6826:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    682a:	81a3      	strh	r3, [r4, #12]
    682c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6830:	6125      	str	r5, [r4, #16]
    6832:	6166      	str	r6, [r4, #20]
    6834:	4445      	add	r5, r8
    6836:	ebc8 0606 	rsb	r6, r8, r6
    683a:	6025      	str	r5, [r4, #0]
    683c:	60a6      	str	r6, [r4, #8]
    683e:	463d      	mov	r5, r7
    6840:	42af      	cmp	r7, r5
    6842:	d200      	bcs.n	6846 <__ssputs_r+0x9c>
    6844:	463d      	mov	r5, r7
    6846:	462a      	mov	r2, r5
    6848:	6820      	ldr	r0, [r4, #0]
    684a:	4651      	mov	r1, sl
    684c:	f000 fa8a 	bl	6d64 <memmove>
    6850:	68a3      	ldr	r3, [r4, #8]
    6852:	2000      	movs	r0, #0
    6854:	1b5b      	subs	r3, r3, r5
    6856:	60a3      	str	r3, [r4, #8]
    6858:	6823      	ldr	r3, [r4, #0]
    685a:	441d      	add	r5, r3
    685c:	6025      	str	r5, [r4, #0]
    685e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

00006864 <_svfiprintf_r>:
    6864:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    6868:	b09d      	sub	sp, #116	; 0x74
    686a:	9303      	str	r3, [sp, #12]
    686c:	898b      	ldrh	r3, [r1, #12]
    686e:	4607      	mov	r7, r0
    6870:	061c      	lsls	r4, r3, #24
    6872:	460d      	mov	r5, r1
    6874:	4616      	mov	r6, r2
    6876:	d50c      	bpl.n	6892 <_svfiprintf_r+0x2e>
    6878:	690b      	ldr	r3, [r1, #16]
    687a:	b953      	cbnz	r3, 6892 <_svfiprintf_r+0x2e>
    687c:	2140      	movs	r1, #64	; 0x40
    687e:	f000 fad1 	bl	6e24 <_malloc_r>
    6882:	6028      	str	r0, [r5, #0]
    6884:	6128      	str	r0, [r5, #16]
    6886:	b910      	cbnz	r0, 688e <_svfiprintf_r+0x2a>
    6888:	230c      	movs	r3, #12
    688a:	603b      	str	r3, [r7, #0]
    688c:	e0c7      	b.n	6a1e <_svfiprintf_r+0x1ba>
    688e:	2340      	movs	r3, #64	; 0x40
    6890:	616b      	str	r3, [r5, #20]
    6892:	2300      	movs	r3, #0
    6894:	9309      	str	r3, [sp, #36]	; 0x24
    6896:	2320      	movs	r3, #32
    6898:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    689c:	2330      	movs	r3, #48	; 0x30
    689e:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    68a2:	4633      	mov	r3, r6
    68a4:	461c      	mov	r4, r3
    68a6:	f813 2b01 	ldrb.w	r2, [r3], #1
    68aa:	b91a      	cbnz	r2, 68b4 <_svfiprintf_r+0x50>
    68ac:	ebb4 0906 	subs.w	r9, r4, r6
    68b0:	d00f      	beq.n	68d2 <_svfiprintf_r+0x6e>
    68b2:	e002      	b.n	68ba <_svfiprintf_r+0x56>
    68b4:	2a25      	cmp	r2, #37	; 0x25
    68b6:	d1f5      	bne.n	68a4 <_svfiprintf_r+0x40>
    68b8:	e7f8      	b.n	68ac <_svfiprintf_r+0x48>
    68ba:	4638      	mov	r0, r7
    68bc:	4629      	mov	r1, r5
    68be:	4632      	mov	r2, r6
    68c0:	464b      	mov	r3, r9
    68c2:	f7ff ff72 	bl	67aa <__ssputs_r>
    68c6:	3001      	adds	r0, #1
    68c8:	f000 80a4 	beq.w	6a14 <_svfiprintf_r+0x1b0>
    68cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
    68ce:	444b      	add	r3, r9
    68d0:	9309      	str	r3, [sp, #36]	; 0x24
    68d2:	7823      	ldrb	r3, [r4, #0]
    68d4:	2b00      	cmp	r3, #0
    68d6:	f000 809d 	beq.w	6a14 <_svfiprintf_r+0x1b0>
    68da:	2300      	movs	r3, #0
    68dc:	f04f 32ff 	mov.w	r2, #4294967295
    68e0:	9304      	str	r3, [sp, #16]
    68e2:	9307      	str	r3, [sp, #28]
    68e4:	9205      	str	r2, [sp, #20]
    68e6:	9306      	str	r3, [sp, #24]
    68e8:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    68ec:	931a      	str	r3, [sp, #104]	; 0x68
    68ee:	f104 0901 	add.w	r9, r4, #1
    68f2:	4e4d      	ldr	r6, [pc, #308]	; (6a28 <_svfiprintf_r+0x1c4>)
    68f4:	464c      	mov	r4, r9
    68f6:	4630      	mov	r0, r6
    68f8:	7821      	ldrb	r1, [r4, #0]
    68fa:	2205      	movs	r2, #5
    68fc:	f000 fa24 	bl	6d48 <memchr>
    6900:	f109 0901 	add.w	r9, r9, #1
    6904:	9b04      	ldr	r3, [sp, #16]
    6906:	b128      	cbz	r0, 6914 <_svfiprintf_r+0xb0>
    6908:	1b86      	subs	r6, r0, r6
    690a:	2001      	movs	r0, #1
    690c:	40b0      	lsls	r0, r6
    690e:	4303      	orrs	r3, r0
    6910:	9304      	str	r3, [sp, #16]
    6912:	e7ee      	b.n	68f2 <_svfiprintf_r+0x8e>
    6914:	06d9      	lsls	r1, r3, #27
    6916:	bf44      	itt	mi
    6918:	2220      	movmi	r2, #32
    691a:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    691e:	071a      	lsls	r2, r3, #28
    6920:	bf44      	itt	mi
    6922:	222b      	movmi	r2, #43	; 0x2b
    6924:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    6928:	7822      	ldrb	r2, [r4, #0]
    692a:	2a2a      	cmp	r2, #42	; 0x2a
    692c:	d002      	beq.n	6934 <_svfiprintf_r+0xd0>
    692e:	9b07      	ldr	r3, [sp, #28]
    6930:	4621      	mov	r1, r4
    6932:	e00e      	b.n	6952 <_svfiprintf_r+0xee>
    6934:	9a03      	ldr	r2, [sp, #12]
    6936:	1d11      	adds	r1, r2, #4
    6938:	6812      	ldr	r2, [r2, #0]
    693a:	9103      	str	r1, [sp, #12]
    693c:	2a00      	cmp	r2, #0
    693e:	db01      	blt.n	6944 <_svfiprintf_r+0xe0>
    6940:	9207      	str	r2, [sp, #28]
    6942:	e004      	b.n	694e <_svfiprintf_r+0xea>
    6944:	4252      	negs	r2, r2
    6946:	f043 0302 	orr.w	r3, r3, #2
    694a:	9207      	str	r2, [sp, #28]
    694c:	9304      	str	r3, [sp, #16]
    694e:	3401      	adds	r4, #1
    6950:	e00a      	b.n	6968 <_svfiprintf_r+0x104>
    6952:	460c      	mov	r4, r1
    6954:	7822      	ldrb	r2, [r4, #0]
    6956:	3101      	adds	r1, #1
    6958:	3a30      	subs	r2, #48	; 0x30
    695a:	2a09      	cmp	r2, #9
    695c:	d803      	bhi.n	6966 <_svfiprintf_r+0x102>
    695e:	200a      	movs	r0, #10
    6960:	fb00 2303 	mla	r3, r0, r3, r2
    6964:	e7f5      	b.n	6952 <_svfiprintf_r+0xee>
    6966:	9307      	str	r3, [sp, #28]
    6968:	7823      	ldrb	r3, [r4, #0]
    696a:	2b2e      	cmp	r3, #46	; 0x2e
    696c:	d119      	bne.n	69a2 <_svfiprintf_r+0x13e>
    696e:	7863      	ldrb	r3, [r4, #1]
    6970:	2b2a      	cmp	r3, #42	; 0x2a
    6972:	d109      	bne.n	6988 <_svfiprintf_r+0x124>
    6974:	9b03      	ldr	r3, [sp, #12]
    6976:	3402      	adds	r4, #2
    6978:	1d1a      	adds	r2, r3, #4
    697a:	681b      	ldr	r3, [r3, #0]
    697c:	9203      	str	r2, [sp, #12]
    697e:	2b00      	cmp	r3, #0
    6980:	bfb8      	it	lt
    6982:	f04f 33ff 	movlt.w	r3, #4294967295
    6986:	e00b      	b.n	69a0 <_svfiprintf_r+0x13c>
    6988:	1c61      	adds	r1, r4, #1
    698a:	2300      	movs	r3, #0
    698c:	460c      	mov	r4, r1
    698e:	7822      	ldrb	r2, [r4, #0]
    6990:	3101      	adds	r1, #1
    6992:	3a30      	subs	r2, #48	; 0x30
    6994:	2a09      	cmp	r2, #9
    6996:	d803      	bhi.n	69a0 <_svfiprintf_r+0x13c>
    6998:	200a      	movs	r0, #10
    699a:	fb00 2303 	mla	r3, r0, r3, r2
    699e:	e7f5      	b.n	698c <_svfiprintf_r+0x128>
    69a0:	9305      	str	r3, [sp, #20]
    69a2:	4e22      	ldr	r6, [pc, #136]	; (6a2c <_svfiprintf_r+0x1c8>)
    69a4:	7821      	ldrb	r1, [r4, #0]
    69a6:	4630      	mov	r0, r6
    69a8:	2203      	movs	r2, #3
    69aa:	f000 f9cd 	bl	6d48 <memchr>
    69ae:	b130      	cbz	r0, 69be <_svfiprintf_r+0x15a>
    69b0:	1b86      	subs	r6, r0, r6
    69b2:	2040      	movs	r0, #64	; 0x40
    69b4:	40b0      	lsls	r0, r6
    69b6:	9b04      	ldr	r3, [sp, #16]
    69b8:	3401      	adds	r4, #1
    69ba:	4303      	orrs	r3, r0
    69bc:	9304      	str	r3, [sp, #16]
    69be:	7821      	ldrb	r1, [r4, #0]
    69c0:	481b      	ldr	r0, [pc, #108]	; (6a30 <_svfiprintf_r+0x1cc>)
    69c2:	2206      	movs	r2, #6
    69c4:	1c66      	adds	r6, r4, #1
    69c6:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    69ca:	f000 f9bd 	bl	6d48 <memchr>
    69ce:	b188      	cbz	r0, 69f4 <_svfiprintf_r+0x190>
    69d0:	4b18      	ldr	r3, [pc, #96]	; (6a34 <_svfiprintf_r+0x1d0>)
    69d2:	b933      	cbnz	r3, 69e2 <_svfiprintf_r+0x17e>
    69d4:	9b03      	ldr	r3, [sp, #12]
    69d6:	3307      	adds	r3, #7
    69d8:	f023 0307 	bic.w	r3, r3, #7
    69dc:	3308      	adds	r3, #8
    69de:	9303      	str	r3, [sp, #12]
    69e0:	e014      	b.n	6a0c <_svfiprintf_r+0x1a8>
    69e2:	ab03      	add	r3, sp, #12
    69e4:	9300      	str	r3, [sp, #0]
    69e6:	4638      	mov	r0, r7
    69e8:	a904      	add	r1, sp, #16
    69ea:	462a      	mov	r2, r5
    69ec:	4b12      	ldr	r3, [pc, #72]	; (6a38 <_svfiprintf_r+0x1d4>)
    69ee:	f3af 8000 	nop.w
    69f2:	e007      	b.n	6a04 <_svfiprintf_r+0x1a0>
    69f4:	ab03      	add	r3, sp, #12
    69f6:	9300      	str	r3, [sp, #0]
    69f8:	4638      	mov	r0, r7
    69fa:	a904      	add	r1, sp, #16
    69fc:	462a      	mov	r2, r5
    69fe:	4b0e      	ldr	r3, [pc, #56]	; (6a38 <_svfiprintf_r+0x1d4>)
    6a00:	f000 f88e 	bl	6b20 <_printf_i>
    6a04:	f1b0 3fff 	cmp.w	r0, #4294967295
    6a08:	4680      	mov	r8, r0
    6a0a:	d003      	beq.n	6a14 <_svfiprintf_r+0x1b0>
    6a0c:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6a0e:	4443      	add	r3, r8
    6a10:	9309      	str	r3, [sp, #36]	; 0x24
    6a12:	e746      	b.n	68a2 <_svfiprintf_r+0x3e>
    6a14:	89ab      	ldrh	r3, [r5, #12]
    6a16:	065b      	lsls	r3, r3, #25
    6a18:	d401      	bmi.n	6a1e <_svfiprintf_r+0x1ba>
    6a1a:	9809      	ldr	r0, [sp, #36]	; 0x24
    6a1c:	e001      	b.n	6a22 <_svfiprintf_r+0x1be>
    6a1e:	f04f 30ff 	mov.w	r0, #4294967295
    6a22:	b01d      	add	sp, #116	; 0x74
    6a24:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    6a28:	000074e2 	andeq	r7, r0, r2, ror #9
    6a2c:	000074e8 	andeq	r7, r0, r8, ror #9
    6a30:	000074ec 	andeq	r7, r0, ip, ror #9
    6a34:	00000000 	andeq	r0, r0, r0
    6a38:	000067ab 	andeq	r6, r0, fp, lsr #15

00006a3c <_printf_common>:
    6a3c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    6a40:	4615      	mov	r5, r2
    6a42:	461f      	mov	r7, r3
    6a44:	688a      	ldr	r2, [r1, #8]
    6a46:	690b      	ldr	r3, [r1, #16]
    6a48:	4606      	mov	r6, r0
    6a4a:	429a      	cmp	r2, r3
    6a4c:	bfa8      	it	ge
    6a4e:	4613      	movge	r3, r2
    6a50:	602b      	str	r3, [r5, #0]
    6a52:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
    6a56:	460c      	mov	r4, r1
    6a58:	f8dd 8020 	ldr.w	r8, [sp, #32]
    6a5c:	b10a      	cbz	r2, 6a62 <_printf_common+0x26>
    6a5e:	3301      	adds	r3, #1
    6a60:	602b      	str	r3, [r5, #0]
    6a62:	6823      	ldr	r3, [r4, #0]
    6a64:	0699      	lsls	r1, r3, #26
    6a66:	d502      	bpl.n	6a6e <_printf_common+0x32>
    6a68:	682b      	ldr	r3, [r5, #0]
    6a6a:	3302      	adds	r3, #2
    6a6c:	602b      	str	r3, [r5, #0]
    6a6e:	6823      	ldr	r3, [r4, #0]
    6a70:	f013 0906 	ands.w	r9, r3, #6
    6a74:	d01d      	beq.n	6ab2 <_printf_common+0x76>
    6a76:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    6a7a:	6822      	ldr	r2, [r4, #0]
    6a7c:	3300      	adds	r3, #0
    6a7e:	bf18      	it	ne
    6a80:	2301      	movne	r3, #1
    6a82:	0692      	lsls	r2, r2, #26
    6a84:	d51f      	bpl.n	6ac6 <_printf_common+0x8a>
    6a86:	18e1      	adds	r1, r4, r3
    6a88:	2030      	movs	r0, #48	; 0x30
    6a8a:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
    6a8e:	1c5a      	adds	r2, r3, #1
    6a90:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
    6a94:	4422      	add	r2, r4
    6a96:	3302      	adds	r3, #2
    6a98:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
    6a9c:	e013      	b.n	6ac6 <_printf_common+0x8a>
    6a9e:	4630      	mov	r0, r6
    6aa0:	4639      	mov	r1, r7
    6aa2:	f104 0219 	add.w	r2, r4, #25
    6aa6:	2301      	movs	r3, #1
    6aa8:	47c0      	blx	r8
    6aaa:	3001      	adds	r0, #1
    6aac:	d007      	beq.n	6abe <_printf_common+0x82>
    6aae:	f109 0901 	add.w	r9, r9, #1
    6ab2:	68e2      	ldr	r2, [r4, #12]
    6ab4:	682b      	ldr	r3, [r5, #0]
    6ab6:	1ad3      	subs	r3, r2, r3
    6ab8:	4599      	cmp	r9, r3
    6aba:	dbf0      	blt.n	6a9e <_printf_common+0x62>
    6abc:	e7db      	b.n	6a76 <_printf_common+0x3a>
    6abe:	f04f 30ff 	mov.w	r0, #4294967295
    6ac2:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6ac6:	4630      	mov	r0, r6
    6ac8:	4639      	mov	r1, r7
    6aca:	f104 0243 	add.w	r2, r4, #67	; 0x43
    6ace:	47c0      	blx	r8
    6ad0:	3001      	adds	r0, #1
    6ad2:	d0f4      	beq.n	6abe <_printf_common+0x82>
    6ad4:	6823      	ldr	r3, [r4, #0]
    6ad6:	682a      	ldr	r2, [r5, #0]
    6ad8:	f003 0306 	and.w	r3, r3, #6
    6adc:	68e1      	ldr	r1, [r4, #12]
    6ade:	2b04      	cmp	r3, #4
    6ae0:	bf08      	it	eq
    6ae2:	ebc2 0501 	rsbeq	r5, r2, r1
    6ae6:	6923      	ldr	r3, [r4, #16]
    6ae8:	68a2      	ldr	r2, [r4, #8]
    6aea:	bf0c      	ite	eq
    6aec:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
    6af0:	2500      	movne	r5, #0
    6af2:	429a      	cmp	r2, r3
    6af4:	bfc4      	itt	gt
    6af6:	ebc3 0302 	rsbgt	r3, r3, r2
    6afa:	18ed      	addgt	r5, r5, r3
    6afc:	f04f 0900 	mov.w	r9, #0
    6b00:	45a9      	cmp	r9, r5
    6b02:	da0a      	bge.n	6b1a <_printf_common+0xde>
    6b04:	4630      	mov	r0, r6
    6b06:	4639      	mov	r1, r7
    6b08:	f104 021a 	add.w	r2, r4, #26
    6b0c:	2301      	movs	r3, #1
    6b0e:	47c0      	blx	r8
    6b10:	3001      	adds	r0, #1
    6b12:	d0d4      	beq.n	6abe <_printf_common+0x82>
    6b14:	f109 0901 	add.w	r9, r9, #1
    6b18:	e7f2      	b.n	6b00 <_printf_common+0xc4>
    6b1a:	2000      	movs	r0, #0
    6b1c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00006b20 <_printf_i>:
    6b20:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    6b24:	7e0e      	ldrb	r6, [r1, #24]
    6b26:	4680      	mov	r8, r0
    6b28:	2e6e      	cmp	r6, #110	; 0x6e
    6b2a:	460c      	mov	r4, r1
    6b2c:	4691      	mov	r9, r2
    6b2e:	469a      	mov	sl, r3
    6b30:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    6b32:	f101 0043 	add.w	r0, r1, #67	; 0x43
    6b36:	f000 80a5 	beq.w	6c84 <_printf_i+0x164>
    6b3a:	d811      	bhi.n	6b60 <_printf_i+0x40>
    6b3c:	2e63      	cmp	r6, #99	; 0x63
    6b3e:	d022      	beq.n	6b86 <_printf_i+0x66>
    6b40:	d809      	bhi.n	6b56 <_printf_i+0x36>
    6b42:	2e00      	cmp	r6, #0
    6b44:	f000 80af 	beq.w	6ca6 <_printf_i+0x186>
    6b48:	2e58      	cmp	r6, #88	; 0x58
    6b4a:	f040 80bf 	bne.w	6ccc <_printf_i+0x1ac>
    6b4e:	f881 6045 	strb.w	r6, [r1, #69]	; 0x45
    6b52:	4a7b      	ldr	r2, [pc, #492]	; (6d40 <_printf_i+0x220>)
    6b54:	e04f      	b.n	6bf6 <_printf_i+0xd6>
    6b56:	2e64      	cmp	r6, #100	; 0x64
    6b58:	d01e      	beq.n	6b98 <_printf_i+0x78>
    6b5a:	2e69      	cmp	r6, #105	; 0x69
    6b5c:	d01c      	beq.n	6b98 <_printf_i+0x78>
    6b5e:	e0b5      	b.n	6ccc <_printf_i+0x1ac>
    6b60:	2e73      	cmp	r6, #115	; 0x73
    6b62:	f000 80a4 	beq.w	6cae <_printf_i+0x18e>
    6b66:	d809      	bhi.n	6b7c <_printf_i+0x5c>
    6b68:	2e6f      	cmp	r6, #111	; 0x6f
    6b6a:	d02b      	beq.n	6bc4 <_printf_i+0xa4>
    6b6c:	2e70      	cmp	r6, #112	; 0x70
    6b6e:	f040 80ad 	bne.w	6ccc <_printf_i+0x1ac>
    6b72:	680b      	ldr	r3, [r1, #0]
    6b74:	f043 0320 	orr.w	r3, r3, #32
    6b78:	600b      	str	r3, [r1, #0]
    6b7a:	e038      	b.n	6bee <_printf_i+0xce>
    6b7c:	2e75      	cmp	r6, #117	; 0x75
    6b7e:	d021      	beq.n	6bc4 <_printf_i+0xa4>
    6b80:	2e78      	cmp	r6, #120	; 0x78
    6b82:	d034      	beq.n	6bee <_printf_i+0xce>
    6b84:	e0a2      	b.n	6ccc <_printf_i+0x1ac>
    6b86:	682b      	ldr	r3, [r5, #0]
    6b88:	f101 0742 	add.w	r7, r1, #66	; 0x42
    6b8c:	1d1a      	adds	r2, r3, #4
    6b8e:	681b      	ldr	r3, [r3, #0]
    6b90:	602a      	str	r2, [r5, #0]
    6b92:	f881 3042 	strb.w	r3, [r1, #66]	; 0x42
    6b96:	e09d      	b.n	6cd4 <_printf_i+0x1b4>
    6b98:	6822      	ldr	r2, [r4, #0]
    6b9a:	682b      	ldr	r3, [r5, #0]
    6b9c:	f012 0f80 	tst.w	r2, #128	; 0x80
    6ba0:	d003      	beq.n	6baa <_printf_i+0x8a>
    6ba2:	1d1a      	adds	r2, r3, #4
    6ba4:	602a      	str	r2, [r5, #0]
    6ba6:	681d      	ldr	r5, [r3, #0]
    6ba8:	e005      	b.n	6bb6 <_printf_i+0x96>
    6baa:	0651      	lsls	r1, r2, #25
    6bac:	d5f9      	bpl.n	6ba2 <_printf_i+0x82>
    6bae:	1d1a      	adds	r2, r3, #4
    6bb0:	602a      	str	r2, [r5, #0]
    6bb2:	f9b3 5000 	ldrsh.w	r5, [r3]
    6bb6:	2d00      	cmp	r5, #0
    6bb8:	da39      	bge.n	6c2e <_printf_i+0x10e>
    6bba:	232d      	movs	r3, #45	; 0x2d
    6bbc:	426d      	negs	r5, r5
    6bbe:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    6bc2:	e034      	b.n	6c2e <_printf_i+0x10e>
    6bc4:	6822      	ldr	r2, [r4, #0]
    6bc6:	682b      	ldr	r3, [r5, #0]
    6bc8:	f012 0f80 	tst.w	r2, #128	; 0x80
    6bcc:	d003      	beq.n	6bd6 <_printf_i+0xb6>
    6bce:	1d1a      	adds	r2, r3, #4
    6bd0:	602a      	str	r2, [r5, #0]
    6bd2:	681d      	ldr	r5, [r3, #0]
    6bd4:	e004      	b.n	6be0 <_printf_i+0xc0>
    6bd6:	0652      	lsls	r2, r2, #25
    6bd8:	d5f9      	bpl.n	6bce <_printf_i+0xae>
    6bda:	1d1a      	adds	r2, r3, #4
    6bdc:	602a      	str	r2, [r5, #0]
    6bde:	881d      	ldrh	r5, [r3, #0]
    6be0:	7e23      	ldrb	r3, [r4, #24]
    6be2:	4a57      	ldr	r2, [pc, #348]	; (6d40 <_printf_i+0x220>)
    6be4:	2b6f      	cmp	r3, #111	; 0x6f
    6be6:	bf14      	ite	ne
    6be8:	230a      	movne	r3, #10
    6bea:	2308      	moveq	r3, #8
    6bec:	e01b      	b.n	6c26 <_printf_i+0x106>
    6bee:	2378      	movs	r3, #120	; 0x78
    6bf0:	4a54      	ldr	r2, [pc, #336]	; (6d44 <_printf_i+0x224>)
    6bf2:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    6bf6:	6823      	ldr	r3, [r4, #0]
    6bf8:	6829      	ldr	r1, [r5, #0]
    6bfa:	f013 0f80 	tst.w	r3, #128	; 0x80
    6bfe:	f101 0604 	add.w	r6, r1, #4
    6c02:	602e      	str	r6, [r5, #0]
    6c04:	d001      	beq.n	6c0a <_printf_i+0xea>
    6c06:	680d      	ldr	r5, [r1, #0]
    6c08:	e002      	b.n	6c10 <_printf_i+0xf0>
    6c0a:	065f      	lsls	r7, r3, #25
    6c0c:	d5fb      	bpl.n	6c06 <_printf_i+0xe6>
    6c0e:	880d      	ldrh	r5, [r1, #0]
    6c10:	07de      	lsls	r6, r3, #31
    6c12:	bf44      	itt	mi
    6c14:	f043 0320 	orrmi.w	r3, r3, #32
    6c18:	6023      	strmi	r3, [r4, #0]
    6c1a:	b91d      	cbnz	r5, 6c24 <_printf_i+0x104>
    6c1c:	6823      	ldr	r3, [r4, #0]
    6c1e:	f023 0320 	bic.w	r3, r3, #32
    6c22:	6023      	str	r3, [r4, #0]
    6c24:	2310      	movs	r3, #16
    6c26:	2100      	movs	r1, #0
    6c28:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
    6c2c:	e001      	b.n	6c32 <_printf_i+0x112>
    6c2e:	4a44      	ldr	r2, [pc, #272]	; (6d40 <_printf_i+0x220>)
    6c30:	230a      	movs	r3, #10
    6c32:	6866      	ldr	r6, [r4, #4]
    6c34:	2e00      	cmp	r6, #0
    6c36:	60a6      	str	r6, [r4, #8]
    6c38:	db03      	blt.n	6c42 <_printf_i+0x122>
    6c3a:	6821      	ldr	r1, [r4, #0]
    6c3c:	f021 0104 	bic.w	r1, r1, #4
    6c40:	6021      	str	r1, [r4, #0]
    6c42:	b905      	cbnz	r5, 6c46 <_printf_i+0x126>
    6c44:	b16e      	cbz	r6, 6c62 <_printf_i+0x142>
    6c46:	f104 0142 	add.w	r1, r4, #66	; 0x42
    6c4a:	fbb5 f6f3 	udiv	r6, r5, r3
    6c4e:	fb03 5516 	mls	r5, r3, r6, r5
    6c52:	5d55      	ldrb	r5, [r2, r5]
    6c54:	460f      	mov	r7, r1
    6c56:	f801 5901 	strb.w	r5, [r1], #-1
    6c5a:	4635      	mov	r5, r6
    6c5c:	2e00      	cmp	r6, #0
    6c5e:	d1f4      	bne.n	6c4a <_printf_i+0x12a>
    6c60:	e000      	b.n	6c64 <_printf_i+0x144>
    6c62:	4607      	mov	r7, r0
    6c64:	2b08      	cmp	r3, #8
    6c66:	d10a      	bne.n	6c7e <_printf_i+0x15e>
    6c68:	6823      	ldr	r3, [r4, #0]
    6c6a:	07dd      	lsls	r5, r3, #31
    6c6c:	d507      	bpl.n	6c7e <_printf_i+0x15e>
    6c6e:	6862      	ldr	r2, [r4, #4]
    6c70:	6923      	ldr	r3, [r4, #16]
    6c72:	429a      	cmp	r2, r3
    6c74:	dc03      	bgt.n	6c7e <_printf_i+0x15e>
    6c76:	2330      	movs	r3, #48	; 0x30
    6c78:	f807 3c01 	strb.w	r3, [r7, #-1]
    6c7c:	3f01      	subs	r7, #1
    6c7e:	1bc0      	subs	r0, r0, r7
    6c80:	6120      	str	r0, [r4, #16]
    6c82:	e02c      	b.n	6cde <_printf_i+0x1be>
    6c84:	6809      	ldr	r1, [r1, #0]
    6c86:	682b      	ldr	r3, [r5, #0]
    6c88:	f011 0f80 	tst.w	r1, #128	; 0x80
    6c8c:	6962      	ldr	r2, [r4, #20]
    6c8e:	d004      	beq.n	6c9a <_printf_i+0x17a>
    6c90:	1d19      	adds	r1, r3, #4
    6c92:	6029      	str	r1, [r5, #0]
    6c94:	681b      	ldr	r3, [r3, #0]
    6c96:	601a      	str	r2, [r3, #0]
    6c98:	e005      	b.n	6ca6 <_printf_i+0x186>
    6c9a:	0649      	lsls	r1, r1, #25
    6c9c:	d5f8      	bpl.n	6c90 <_printf_i+0x170>
    6c9e:	1d19      	adds	r1, r3, #4
    6ca0:	6029      	str	r1, [r5, #0]
    6ca2:	681b      	ldr	r3, [r3, #0]
    6ca4:	801a      	strh	r2, [r3, #0]
    6ca6:	2300      	movs	r3, #0
    6ca8:	6123      	str	r3, [r4, #16]
    6caa:	4607      	mov	r7, r0
    6cac:	e017      	b.n	6cde <_printf_i+0x1be>
    6cae:	682b      	ldr	r3, [r5, #0]
    6cb0:	1d1a      	adds	r2, r3, #4
    6cb2:	602a      	str	r2, [r5, #0]
    6cb4:	681f      	ldr	r7, [r3, #0]
    6cb6:	4638      	mov	r0, r7
    6cb8:	f000 f93e 	bl	6f38 <strlen>
    6cbc:	6863      	ldr	r3, [r4, #4]
    6cbe:	6120      	str	r0, [r4, #16]
    6cc0:	4298      	cmp	r0, r3
    6cc2:	bf88      	it	hi
    6cc4:	6123      	strhi	r3, [r4, #16]
    6cc6:	6923      	ldr	r3, [r4, #16]
    6cc8:	6063      	str	r3, [r4, #4]
    6cca:	e005      	b.n	6cd8 <_printf_i+0x1b8>
    6ccc:	f104 0742 	add.w	r7, r4, #66	; 0x42
    6cd0:	f884 6042 	strb.w	r6, [r4, #66]	; 0x42
    6cd4:	2301      	movs	r3, #1
    6cd6:	6123      	str	r3, [r4, #16]
    6cd8:	2300      	movs	r3, #0
    6cda:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    6cde:	f8cd a000 	str.w	sl, [sp]
    6ce2:	4640      	mov	r0, r8
    6ce4:	4621      	mov	r1, r4
    6ce6:	aa03      	add	r2, sp, #12
    6ce8:	464b      	mov	r3, r9
    6cea:	f7ff fea7 	bl	6a3c <_printf_common>
    6cee:	3001      	adds	r0, #1
    6cf0:	d102      	bne.n	6cf8 <_printf_i+0x1d8>
    6cf2:	f04f 30ff 	mov.w	r0, #4294967295
    6cf6:	e01f      	b.n	6d38 <_printf_i+0x218>
    6cf8:	4640      	mov	r0, r8
    6cfa:	4649      	mov	r1, r9
    6cfc:	463a      	mov	r2, r7
    6cfe:	6923      	ldr	r3, [r4, #16]
    6d00:	47d0      	blx	sl
    6d02:	3001      	adds	r0, #1
    6d04:	d0f5      	beq.n	6cf2 <_printf_i+0x1d2>
    6d06:	6823      	ldr	r3, [r4, #0]
    6d08:	079b      	lsls	r3, r3, #30
    6d0a:	d405      	bmi.n	6d18 <_printf_i+0x1f8>
    6d0c:	68e0      	ldr	r0, [r4, #12]
    6d0e:	9b03      	ldr	r3, [sp, #12]
    6d10:	4298      	cmp	r0, r3
    6d12:	bfb8      	it	lt
    6d14:	4618      	movlt	r0, r3
    6d16:	e00f      	b.n	6d38 <_printf_i+0x218>
    6d18:	2500      	movs	r5, #0
    6d1a:	68e2      	ldr	r2, [r4, #12]
    6d1c:	9b03      	ldr	r3, [sp, #12]
    6d1e:	1ad3      	subs	r3, r2, r3
    6d20:	429d      	cmp	r5, r3
    6d22:	daf3      	bge.n	6d0c <_printf_i+0x1ec>
    6d24:	4640      	mov	r0, r8
    6d26:	4649      	mov	r1, r9
    6d28:	f104 0219 	add.w	r2, r4, #25
    6d2c:	2301      	movs	r3, #1
    6d2e:	47d0      	blx	sl
    6d30:	3001      	adds	r0, #1
    6d32:	d0de      	beq.n	6cf2 <_printf_i+0x1d2>
    6d34:	3501      	adds	r5, #1
    6d36:	e7f0      	b.n	6d1a <_printf_i+0x1fa>
    6d38:	b004      	add	sp, #16
    6d3a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6d3e:	bf00      	nop
    6d40:	000074f3 	strdeq	r7, [r0], -r3
    6d44:	00007504 	andeq	r7, r0, r4, lsl #10

00006d48 <memchr>:
    6d48:	b510      	push	{r4, lr}
    6d4a:	b2c9      	uxtb	r1, r1
    6d4c:	4402      	add	r2, r0
    6d4e:	4290      	cmp	r0, r2
    6d50:	4603      	mov	r3, r0
    6d52:	d005      	beq.n	6d60 <memchr+0x18>
    6d54:	781c      	ldrb	r4, [r3, #0]
    6d56:	3001      	adds	r0, #1
    6d58:	428c      	cmp	r4, r1
    6d5a:	d1f8      	bne.n	6d4e <memchr+0x6>
    6d5c:	4618      	mov	r0, r3
    6d5e:	bd10      	pop	{r4, pc}
    6d60:	2000      	movs	r0, #0
    6d62:	bd10      	pop	{r4, pc}

00006d64 <memmove>:
    6d64:	4281      	cmp	r1, r0
    6d66:	b570      	push	{r4, r5, r6, lr}
    6d68:	d301      	bcc.n	6d6e <memmove+0xa>
    6d6a:	2300      	movs	r3, #0
    6d6c:	e00e      	b.n	6d8c <memmove+0x28>
    6d6e:	188c      	adds	r4, r1, r2
    6d70:	42a0      	cmp	r0, r4
    6d72:	d2fa      	bcs.n	6d6a <memmove+0x6>
    6d74:	1885      	adds	r5, r0, r2
    6d76:	4613      	mov	r3, r2
    6d78:	f113 33ff 	adds.w	r3, r3, #4294967295
    6d7c:	d305      	bcc.n	6d8a <memmove+0x26>
    6d7e:	4251      	negs	r1, r2
    6d80:	1866      	adds	r6, r4, r1
    6d82:	5cf6      	ldrb	r6, [r6, r3]
    6d84:	4429      	add	r1, r5
    6d86:	54ce      	strb	r6, [r1, r3]
    6d88:	e7f6      	b.n	6d78 <memmove+0x14>
    6d8a:	bd70      	pop	{r4, r5, r6, pc}
    6d8c:	4293      	cmp	r3, r2
    6d8e:	d003      	beq.n	6d98 <memmove+0x34>
    6d90:	5ccc      	ldrb	r4, [r1, r3]
    6d92:	54c4      	strb	r4, [r0, r3]
    6d94:	3301      	adds	r3, #1
    6d96:	e7f9      	b.n	6d8c <memmove+0x28>
    6d98:	bd70      	pop	{r4, r5, r6, pc}
	...

00006d9c <_free_r>:
    6d9c:	b530      	push	{r4, r5, lr}
    6d9e:	2900      	cmp	r1, #0
    6da0:	d03c      	beq.n	6e1c <_free_r+0x80>
    6da2:	f851 2c04 	ldr.w	r2, [r1, #-4]
    6da6:	1f0b      	subs	r3, r1, #4
    6da8:	491d      	ldr	r1, [pc, #116]	; (6e20 <_free_r+0x84>)
    6daa:	2a00      	cmp	r2, #0
    6dac:	bfb8      	it	lt
    6dae:	189b      	addlt	r3, r3, r2
    6db0:	680a      	ldr	r2, [r1, #0]
    6db2:	460c      	mov	r4, r1
    6db4:	b912      	cbnz	r2, 6dbc <_free_r+0x20>
    6db6:	605a      	str	r2, [r3, #4]
    6db8:	600b      	str	r3, [r1, #0]
    6dba:	bd30      	pop	{r4, r5, pc}
    6dbc:	4293      	cmp	r3, r2
    6dbe:	d20d      	bcs.n	6ddc <_free_r+0x40>
    6dc0:	6819      	ldr	r1, [r3, #0]
    6dc2:	1858      	adds	r0, r3, r1
    6dc4:	4290      	cmp	r0, r2
    6dc6:	d103      	bne.n	6dd0 <_free_r+0x34>
    6dc8:	585a      	ldr	r2, [r3, r1]
    6dca:	4411      	add	r1, r2
    6dcc:	6842      	ldr	r2, [r0, #4]
    6dce:	6019      	str	r1, [r3, #0]
    6dd0:	605a      	str	r2, [r3, #4]
    6dd2:	6023      	str	r3, [r4, #0]
    6dd4:	bd30      	pop	{r4, r5, pc}
    6dd6:	4299      	cmp	r1, r3
    6dd8:	d803      	bhi.n	6de2 <_free_r+0x46>
    6dda:	460a      	mov	r2, r1
    6ddc:	6851      	ldr	r1, [r2, #4]
    6dde:	2900      	cmp	r1, #0
    6de0:	d1f9      	bne.n	6dd6 <_free_r+0x3a>
    6de2:	6814      	ldr	r4, [r2, #0]
    6de4:	1915      	adds	r5, r2, r4
    6de6:	429d      	cmp	r5, r3
    6de8:	d10a      	bne.n	6e00 <_free_r+0x64>
    6dea:	681b      	ldr	r3, [r3, #0]
    6dec:	4423      	add	r3, r4
    6dee:	18d0      	adds	r0, r2, r3
    6df0:	4288      	cmp	r0, r1
    6df2:	6013      	str	r3, [r2, #0]
    6df4:	d112      	bne.n	6e1c <_free_r+0x80>
    6df6:	6808      	ldr	r0, [r1, #0]
    6df8:	4403      	add	r3, r0
    6dfa:	6013      	str	r3, [r2, #0]
    6dfc:	684b      	ldr	r3, [r1, #4]
    6dfe:	e00c      	b.n	6e1a <_free_r+0x7e>
    6e00:	d902      	bls.n	6e08 <_free_r+0x6c>
    6e02:	230c      	movs	r3, #12
    6e04:	6003      	str	r3, [r0, #0]
    6e06:	bd30      	pop	{r4, r5, pc}
    6e08:	6818      	ldr	r0, [r3, #0]
    6e0a:	181c      	adds	r4, r3, r0
    6e0c:	428c      	cmp	r4, r1
    6e0e:	d103      	bne.n	6e18 <_free_r+0x7c>
    6e10:	680c      	ldr	r4, [r1, #0]
    6e12:	6849      	ldr	r1, [r1, #4]
    6e14:	4420      	add	r0, r4
    6e16:	6018      	str	r0, [r3, #0]
    6e18:	6059      	str	r1, [r3, #4]
    6e1a:	6053      	str	r3, [r2, #4]
    6e1c:	bd30      	pop	{r4, r5, pc}
    6e1e:	bf00      	nop
    6e20:	20000dd4 	ldrdcs	r0, [r0], -r4

00006e24 <_malloc_r>:
    6e24:	b570      	push	{r4, r5, r6, lr}
    6e26:	1ccd      	adds	r5, r1, #3
    6e28:	f025 0503 	bic.w	r5, r5, #3
    6e2c:	3508      	adds	r5, #8
    6e2e:	2d0c      	cmp	r5, #12
    6e30:	bf38      	it	cc
    6e32:	250c      	movcc	r5, #12
    6e34:	2d00      	cmp	r5, #0
    6e36:	4606      	mov	r6, r0
    6e38:	db3f      	blt.n	6eba <_malloc_r+0x96>
    6e3a:	428d      	cmp	r5, r1
    6e3c:	d33d      	bcc.n	6eba <_malloc_r+0x96>
    6e3e:	4b21      	ldr	r3, [pc, #132]	; (6ec4 <_malloc_r+0xa0>)
    6e40:	681c      	ldr	r4, [r3, #0]
    6e42:	4618      	mov	r0, r3
    6e44:	4621      	mov	r1, r4
    6e46:	b1a1      	cbz	r1, 6e72 <_malloc_r+0x4e>
    6e48:	680b      	ldr	r3, [r1, #0]
    6e4a:	1b5b      	subs	r3, r3, r5
    6e4c:	d40e      	bmi.n	6e6c <_malloc_r+0x48>
    6e4e:	2b0b      	cmp	r3, #11
    6e50:	d903      	bls.n	6e5a <_malloc_r+0x36>
    6e52:	600b      	str	r3, [r1, #0]
    6e54:	18cc      	adds	r4, r1, r3
    6e56:	50cd      	str	r5, [r1, r3]
    6e58:	e01f      	b.n	6e9a <_malloc_r+0x76>
    6e5a:	428c      	cmp	r4, r1
    6e5c:	d102      	bne.n	6e64 <_malloc_r+0x40>
    6e5e:	6862      	ldr	r2, [r4, #4]
    6e60:	6002      	str	r2, [r0, #0]
    6e62:	e01a      	b.n	6e9a <_malloc_r+0x76>
    6e64:	684b      	ldr	r3, [r1, #4]
    6e66:	6063      	str	r3, [r4, #4]
    6e68:	460c      	mov	r4, r1
    6e6a:	e016      	b.n	6e9a <_malloc_r+0x76>
    6e6c:	460c      	mov	r4, r1
    6e6e:	6849      	ldr	r1, [r1, #4]
    6e70:	e7e9      	b.n	6e46 <_malloc_r+0x22>
    6e72:	4c15      	ldr	r4, [pc, #84]	; (6ec8 <_malloc_r+0xa4>)
    6e74:	6823      	ldr	r3, [r4, #0]
    6e76:	b91b      	cbnz	r3, 6e80 <_malloc_r+0x5c>
    6e78:	4630      	mov	r0, r6
    6e7a:	f000 f84d 	bl	6f18 <_sbrk_r>
    6e7e:	6020      	str	r0, [r4, #0]
    6e80:	4629      	mov	r1, r5
    6e82:	4630      	mov	r0, r6
    6e84:	f000 f848 	bl	6f18 <_sbrk_r>
    6e88:	1c43      	adds	r3, r0, #1
    6e8a:	4601      	mov	r1, r0
    6e8c:	d015      	beq.n	6eba <_malloc_r+0x96>
    6e8e:	1cc4      	adds	r4, r0, #3
    6e90:	f024 0403 	bic.w	r4, r4, #3
    6e94:	4284      	cmp	r4, r0
    6e96:	d10a      	bne.n	6eae <_malloc_r+0x8a>
    6e98:	6025      	str	r5, [r4, #0]
    6e9a:	f104 000b 	add.w	r0, r4, #11
    6e9e:	1d23      	adds	r3, r4, #4
    6ea0:	f020 0007 	bic.w	r0, r0, #7
    6ea4:	1ac3      	subs	r3, r0, r3
    6ea6:	d00b      	beq.n	6ec0 <_malloc_r+0x9c>
    6ea8:	425a      	negs	r2, r3
    6eaa:	50e2      	str	r2, [r4, r3]
    6eac:	bd70      	pop	{r4, r5, r6, pc}
    6eae:	4630      	mov	r0, r6
    6eb0:	1a61      	subs	r1, r4, r1
    6eb2:	f000 f831 	bl	6f18 <_sbrk_r>
    6eb6:	3001      	adds	r0, #1
    6eb8:	d1ee      	bne.n	6e98 <_malloc_r+0x74>
    6eba:	230c      	movs	r3, #12
    6ebc:	6033      	str	r3, [r6, #0]
    6ebe:	2000      	movs	r0, #0
    6ec0:	bd70      	pop	{r4, r5, r6, pc}
    6ec2:	bf00      	nop
    6ec4:	20000dd4 	ldrdcs	r0, [r0], -r4
    6ec8:	20000dd0 	ldrdcs	r0, [r0], -r0	; <UNPREDICTABLE>

00006ecc <_realloc_r>:
    6ecc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6ece:	4606      	mov	r6, r0
    6ed0:	4614      	mov	r4, r2
    6ed2:	460d      	mov	r5, r1
    6ed4:	b921      	cbnz	r1, 6ee0 <_realloc_r+0x14>
    6ed6:	4611      	mov	r1, r2
    6ed8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    6edc:	f7ff bfa2 	b.w	6e24 <_malloc_r>
    6ee0:	b91a      	cbnz	r2, 6eea <_realloc_r+0x1e>
    6ee2:	f7ff ff5b 	bl	6d9c <_free_r>
    6ee6:	4620      	mov	r0, r4
    6ee8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6eea:	f000 f82d 	bl	6f48 <_malloc_usable_size_r>
    6eee:	42a0      	cmp	r0, r4
    6ef0:	d20e      	bcs.n	6f10 <_realloc_r+0x44>
    6ef2:	4630      	mov	r0, r6
    6ef4:	4621      	mov	r1, r4
    6ef6:	f7ff ff95 	bl	6e24 <_malloc_r>
    6efa:	4607      	mov	r7, r0
    6efc:	b150      	cbz	r0, 6f14 <_realloc_r+0x48>
    6efe:	4629      	mov	r1, r5
    6f00:	4622      	mov	r2, r4
    6f02:	f7ff fbed 	bl	66e0 <memcpy>
    6f06:	4630      	mov	r0, r6
    6f08:	4629      	mov	r1, r5
    6f0a:	f7ff ff47 	bl	6d9c <_free_r>
    6f0e:	e001      	b.n	6f14 <_realloc_r+0x48>
    6f10:	4628      	mov	r0, r5
    6f12:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6f14:	4638      	mov	r0, r7
    6f16:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00006f18 <_sbrk_r>:
    6f18:	b538      	push	{r3, r4, r5, lr}
    6f1a:	4c06      	ldr	r4, [pc, #24]	; (6f34 <_sbrk_r+0x1c>)
    6f1c:	2300      	movs	r3, #0
    6f1e:	4605      	mov	r5, r0
    6f20:	4608      	mov	r0, r1
    6f22:	6023      	str	r3, [r4, #0]
    6f24:	f000 f81a 	bl	6f5c <_sbrk>
    6f28:	1c43      	adds	r3, r0, #1
    6f2a:	d102      	bne.n	6f32 <_sbrk_r+0x1a>
    6f2c:	6823      	ldr	r3, [r4, #0]
    6f2e:	b103      	cbz	r3, 6f32 <_sbrk_r+0x1a>
    6f30:	602b      	str	r3, [r5, #0]
    6f32:	bd38      	pop	{r3, r4, r5, pc}
    6f34:	200005b0 			; <UNDEFINED> instruction: 0x200005b0

00006f38 <strlen>:
    6f38:	4603      	mov	r3, r0
    6f3a:	f813 2b01 	ldrb.w	r2, [r3], #1
    6f3e:	2a00      	cmp	r2, #0
    6f40:	d1fb      	bne.n	6f3a <strlen+0x2>
    6f42:	1a18      	subs	r0, r3, r0
    6f44:	3801      	subs	r0, #1
    6f46:	4770      	bx	lr

00006f48 <_malloc_usable_size_r>:
    6f48:	f851 0c04 	ldr.w	r0, [r1, #-4]
    6f4c:	2800      	cmp	r0, #0
    6f4e:	da02      	bge.n	6f56 <_malloc_usable_size_r+0xe>
    6f50:	3904      	subs	r1, #4
    6f52:	580b      	ldr	r3, [r1, r0]
    6f54:	4418      	add	r0, r3
    6f56:	3804      	subs	r0, #4
    6f58:	4770      	bx	lr
	...

00006f5c <_sbrk>:
    6f5c:	4a09      	ldr	r2, [pc, #36]	; (6f84 <_sbrk+0x28>)
    6f5e:	6813      	ldr	r3, [r2, #0]
    6f60:	b163      	cbz	r3, 6f7c <_sbrk+0x20>
    6f62:	4418      	add	r0, r3
    6f64:	4669      	mov	r1, sp
    6f66:	4288      	cmp	r0, r1
    6f68:	d802      	bhi.n	6f70 <_sbrk+0x14>
    6f6a:	6010      	str	r0, [r2, #0]
    6f6c:	4618      	mov	r0, r3
    6f6e:	4770      	bx	lr
    6f70:	4b05      	ldr	r3, [pc, #20]	; (6f88 <_sbrk+0x2c>)
    6f72:	220c      	movs	r2, #12
    6f74:	601a      	str	r2, [r3, #0]
    6f76:	f04f 30ff 	mov.w	r0, #4294967295
    6f7a:	4770      	bx	lr
    6f7c:	4b03      	ldr	r3, [pc, #12]	; (6f8c <_sbrk+0x30>)
    6f7e:	6013      	str	r3, [r2, #0]
    6f80:	e7ef      	b.n	6f62 <_sbrk+0x6>
    6f82:	bf00      	nop
    6f84:	20000dd8 	ldrdcs	r0, [r0], -r8
    6f88:	200005b0 			; <UNDEFINED> instruction: 0x200005b0
    6f8c:	200005b4 			; <UNDEFINED> instruction: 0x200005b4
    6f90:	6f6f420a 	svcvs	0x006f420a
    6f94:	616f6c74 	smcvs	63172	; 0xf6c4
    6f98:	20726564 	rsbscs	r6, r2, r4, ror #10
    6f9c:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
    6fa0:	0a2e2e2e 	beq	b92860 <_etext+0xb8b348>
    6fa4:	65686300 	strbvs	r6, [r8, #-768]!	; 0x300
    6fa8:	6e696b63 	vnmulvs.f64	d22, d9, d19
    6fac:	68632067 	stmdavs	r3!, {r0, r1, r2, r5, r6, sp}^
    6fb0:	2e6e6961 	cdpcs	9, 6, cr6, cr14, cr1, {3}
    6fb4:	000a2e2e 	andeq	r2, sl, lr, lsr #28
    6fb8:	746f6f42 	strbtvc	r6, [pc], #-3906	; 6fc0 <_sbrk+0x64>
    6fbc:	0a4b4f20 	beq	12dac44 <_etext+0x12d372c>
    6fc0:	72694600 	rsbvc	r4, r9, #0, 12
    6fc4:	7261776d 	rsbvc	r7, r1, #28573696	; 0x1b40000
    6fc8:	696d2065 	stmdbvs	sp!, {r0, r2, r5, r6, sp}^
    6fcc:	6e697373 	mcrvs	3, 3, r7, cr9, cr3, {3}
    6fd0:	2e2e2e67 	cdpcs	14, 2, cr2, cr14, cr7, {3}
    6fd4:	69617720 	stmdbvs	r1!, {r5, r8, r9, sl, ip, sp, lr}^
    6fd8:	676e6974 			; <UNDEFINED> instruction: 0x676e6974
    6fdc:	206e6920 	rsbcs	r6, lr, r0, lsr #18
    6fe0:	0a554644 	beq	15588f8 <_etext+0x15513e0>
    6fe4:	67695300 	strbvs	r5, [r9, -r0, lsl #6]!
    6fe8:	7574616e 	ldrbvc	r6, [r4, #-366]!	; 0x16e
    6fec:	75206572 	strvc	r6, [r0, #-1394]!	; 0x572
    6ff0:	7265766e 	rsbvc	r7, r5, #115343360	; 0x6e00000
    6ff4:	65696669 	strbvs	r6, [r9, #-1641]!	; 0x669
    6ff8:	2e2e2e64 	cdpcs	14, 2, cr2, cr14, cr4, {3}
    6ffc:	69617720 	stmdbvs	r1!, {r5, r8, r9, sl, ip, sp, lr}^
    7000:	676e6974 			; <UNDEFINED> instruction: 0x676e6974
    7004:	206e6920 	rsbcs	r6, lr, r0, lsr #18
    7008:	0a554644 	beq	1558920 <_etext+0x1551408>
    700c:	55464400 	strbpl	r4, [r6, #-1024]	; 0x400
    7010:	6e696620 	cdpvs	6, 6, cr6, cr9, cr0, {1}
    7014:	65687369 	strbvs	r7, [r8, #-873]!	; 0x369
    7018:	70752064 	rsbsvc	r2, r5, r4, rrx
    701c:	64616f6c 	strbtvs	r6, [r1], #-3948	; 0xf6c
    7020:	754a000a 	strbvc	r0, [sl, #-10]
    7024:	6e69706d 	cdpvs	0, 6, cr7, cr9, cr13, {3}
    7028:	6f742067 	svcvs	0x00742067
    702c:	2e534f20 	cdpcs	15, 5, cr4, cr3, cr0, {1}
    7030:	7055000a 	subsvc	r0, r5, sl
    7034:	64616f6c 	strbtvs	r6, [r1], #-3948	; 0xf6c
    7038:	73206465 	teqvc	r0, #1694498816	; 0x65000000
    703c:	616e6769 	cmnvs	lr, r9, ror #14
    7040:	65727574 	ldrbvs	r7, [r2, #-1396]!	; 0x574
    7044:	72657620 	rsbvc	r7, r5, #32, 12	; 0x2000000
    7048:	65696669 	strbvs	r6, [r9, #-1641]!	; 0x669
    704c:	000a2164 	andeq	r2, sl, r4, ror #2
    7050:	67616d49 	strbvs	r6, [r1, -r9, asr #26]!
    7054:	6e752065 	cdpvs	0, 7, cr2, cr5, cr5, {3}
    7058:	69726576 	ldmdbvs	r2!, {r1, r2, r4, r5, r6, r8, sl, sp, lr}^
    705c:	64656966 	strbtvs	r6, [r5], #-2406	; 0x966
    7060:	202e2e2e 	eorcs	r2, lr, lr, lsr #28
    7064:	65706977 	ldrbvs	r6, [r0, #-2423]!	; 0x977
    7068:	656d2064 	strbvs	r2, [sp, #-100]!	; 0x64
    706c:	79726f6d 	ldmdbvc	r2!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    7070:	726f6620 	rsbvc	r6, pc, #32, 12	; 0x2000000
    7074:	656c6320 	strbvs	r6, [ip, #-800]!	; 0x320
    7078:	72206e61 	eorvc	r6, r0, #1552	; 0x610
    707c:	74657365 	strbtvc	r7, [r5], #-869	; 0x365
    7080:	00000a2e 	andeq	r0, r0, lr, lsr #20

00007084 <ed25519_k>:
    7084:	26b2f159 	ssatcs	pc, #19, r9, asr #2	; <UNPREDICTABLE>
    7088:	ebd69b94 	bl	ff5adee0 <BootRAM+0xe51e681>
    708c:	8283b156 	addhi	fp, r3, #-2147483627	; 0x80000015
    7090:	00e0149a 	smlaleq	r1, r0, sl, r4
    7094:	eef3d130 	mrc	1, 7, sp, cr3, cr0, {1}
    7098:	198e80f2 	stmibne	lr, {r1, r4, r5, r6, r7, pc}
    709c:	56dffce7 	ldrbpl	pc, [pc], r7, ror #25	; <UNPREDICTABLE>
    70a0:	2406d9dc 	strcs	sp, [r6], #-2524	; 0x9dc

000070a4 <ed25519_neutral>:
	...
    70c4:	00000001 	andeq	r0, r0, r1
	...
    7104:	00000001 	andeq	r0, r0, r1
	...

00007124 <ed25519_base>:
    7124:	8f25d51a 	svchi	0x0025d51a
    7128:	c9562d60 	ldmdbgt	r6, {r5, r6, r8, sl, fp, sp}^
    712c:	9525a7b2 	strls	sl, [r5, #-1970]!	; 0x7b2
    7130:	692cc760 	stmdbvs	ip!, {r5, r6, r8, r9, sl, lr, pc}
    7134:	fdd6dc5c 	ldc2l	12, cr13, [r6, #368]	; 0x170
    7138:	c0a4e231 	adcgt	lr, r4, r1, lsr r2
    713c:	cd6e53fe 	stclgt	3, cr5, [lr, #-1016]!	; 0xfffffc08
    7140:	216936d3 	ldrdcs	r3, [r9, #-99]!	; 0xffffff9d
    7144:	66666658 			; <UNDEFINED> instruction: 0x66666658
    7148:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    714c:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    7150:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    7154:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    7158:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    715c:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    7160:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    7164:	a5b7dda3 	ldrge	sp, [r7, #3491]!	; 0xda3
    7168:	6dde8ab3 	vldrvs	s17, [lr, #716]	; 0x2cc
    716c:	775152f5 	smmlsrvc	r1, r5, r2, r5
    7170:	20f09f80 	rscscs	r9, r0, r0, lsl #31
    7174:	64abe37d 	strtvs	lr, [fp], #893	; 0x37d
    7178:	66ea4e8e 	strbtvs	r4, [sl], lr, lsl #29
    717c:	d78b7665 	strle	r7, [fp, r5, ror #12]
    7180:	67875f0f 	strvs	r5, [r7, pc, lsl #30]
    7184:	00000001 	andeq	r0, r0, r1
	...

000071a4 <ed25519_d>:
    71a4:	135978a3 	cmpne	r9, #10682368	; 0xa30000
    71a8:	75eb4dca 	strbvc	r4, [fp, #3530]!	; 0xdca
    71ac:	4141d8ab 	smlaltbmi	sp, r1, fp, r8
    71b0:	00700a4d 	rsbseq	r0, r0, sp, asr #20
    71b4:	7779e898 			; <UNDEFINED> instruction: 0x7779e898
    71b8:	8cc74079 	stclhi	0, cr4, [r7], {121}	; 0x79
    71bc:	2b6ffe73 	blcs	1c06b90 <_etext+0x1bff678>
    71c0:	52036cee 	andpl	r6, r3, #60928	; 0xee00

000071c4 <ed25519_order>:
    71c4:	5cf5d3ed 	ldclpl	3, cr13, [r5], #948	; 0x3b4
    71c8:	5812631a 	ldmdapl	r2, {r1, r3, r4, r8, r9, sp, lr}
    71cc:	a2f79cd6 	rscsge	r9, r7, #54784	; 0xd600
    71d0:	14def9de 	ldrbne	pc, [lr], #2526	; 0x9de	; <UNPREDICTABLE>
	...
    71e0:	10000000 	andne	r0, r0, r0

000071e4 <f25519_one>:
    71e4:	00000001 	andeq	r0, r0, r1
	...

00007208 <sha512_initial_state>:
    7208:	f3bcc908 	vtbl.8	d12, {d12-d13}, d8
    720c:	6a09e667 	bvs	280bb0 <_etext+0x279698>
    7210:	84caa73b 	strbhi	sl, [sl], #1851	; 0x73b
    7214:	bb67ae85 	bllt	19f2c30 <_etext+0x19eb718>
    7218:	fe94f82b 	cdp2	8, 9, cr15, cr4, cr11, {1}
    721c:	3c6ef372 	stclcc	3, cr15, [lr], #-456	; 0xfffffe38
    7220:	5f1d36f1 	svcpl	0x001d36f1
    7224:	a54ff53a 	strbge	pc, [pc, #-1338]	; 6cf2 <_printf_i+0x1d2>	; <UNPREDICTABLE>
    7228:	ade682d1 	sfmge	f0, 3, [r6, #836]!	; 0x344
    722c:	510e527f 	tstpl	lr, pc, ror r2
    7230:	2b3e6c1f 	blcs	fa22b4 <_etext+0xf9ad9c>
    7234:	9b05688c 	blls	16146c <_etext+0x159f54>
    7238:	fb41bd6b 	blx	10767ee <_etext+0x106f2d6>
    723c:	1f83d9ab 	svcne	0x0083d9ab
    7240:	137e2179 	cmnne	lr, #1073741854	; 0x4000001e
    7244:	5be0cd19 	blpl	ff83a6b0 <BootRAM+0xe7aae51>

00007248 <round_k>:
    7248:	d728ae22 	strle	sl, [r8, -r2, lsr #28]!
    724c:	428a2f98 	addmi	r2, sl, #152, 30	; 0x260
    7250:	23ef65cd 	mvncs	r6, #859832320	; 0x33400000
    7254:	71374491 			; <UNDEFINED> instruction: 0x71374491
    7258:	ec4d3b2f 	mcrr	11, 2, r3, sp, cr15
    725c:	b5c0fbcf 	strblt	pc, [r0, #3023]	; 0xbcf	; <UNPREDICTABLE>
    7260:	8189dbbc 			; <UNDEFINED> instruction: 0x8189dbbc
    7264:	e9b5dba5 	ldmib	r5!, {r0, r2, r5, r7, r8, r9, fp, ip, lr, pc}
    7268:	f348b538 	vqrshl.u8	d27, d24, d8
    726c:	3956c25b 	ldmdbcc	r6, {r0, r1, r3, r4, r6, r9, lr, pc}^
    7270:	b605d019 			; <UNDEFINED> instruction: 0xb605d019
    7274:	59f111f1 	ldmibpl	r1!, {r0, r4, r5, r6, r7, r8, ip}^
    7278:	af194f9b 	svcge	0x00194f9b
    727c:	923f82a4 	eorsls	r8, pc, #164, 4	; 0x4000000a
    7280:	da6d8118 	ble	1b676e8 <_etext+0x1b601d0>
    7284:	ab1c5ed5 	blge	71ede0 <_etext+0x7178c8>
    7288:	a3030242 	movwge	r0, #12866	; 0x3242
    728c:	d807aa98 	stmdale	r7, {r3, r4, r7, r9, fp, sp, pc}
    7290:	45706fbe 	ldrbmi	r6, [r0, #-4030]!	; 0xfbe
    7294:	12835b01 	addne	r5, r3, #1024	; 0x400
    7298:	4ee4b28c 	cdpmi	2, 14, cr11, cr4, cr12, {4}
    729c:	243185be 	ldrtcs	r8, [r1], #-1470	; 0x5be
    72a0:	d5ffb4e2 	ldrble	fp, [pc, #1250]!	; 778a <_etext+0x272>
    72a4:	550c7dc3 	strpl	r7, [ip, #-3523]	; 0xdc3
    72a8:	f27b896f 	vmla.i<illegal width 64>	q12, <illegal reg q5.5>, <illegal reg q15.5>
    72ac:	72be5d74 	adcsvc	r5, lr, #116, 26	; 0x1d00
    72b0:	3b1696b1 	blcc	5acd7c <_etext+0x5a5864>
    72b4:	80deb1fe 	ldrshhi	fp, [lr], #30
    72b8:	25c71235 	strbcs	r1, [r7, #565]	; 0x235
    72bc:	9bdc06a7 	blls	ff708d60 <BootRAM+0xe679501>
    72c0:	cf692694 	svcgt	0x00692694
    72c4:	c19bf174 	orrsgt	pc, fp, r4, ror r1	; <UNPREDICTABLE>
    72c8:	9ef14ad2 	mrcls	10, 7, r4, cr1, cr2, {6}
    72cc:	e49b69c1 	ldr	r6, [fp], #2497	; 0x9c1
    72d0:	384f25e3 	stmdacc	pc, {r0, r1, r5, r6, r7, r8, sl, sp}^	; <UNPREDICTABLE>
    72d4:	efbe4786 	svc	0x00be4786
    72d8:	8b8cd5b5 	blhi	fe33c9b4 <BootRAM+0xd2ad155>
    72dc:	0fc19dc6 	svceq	0x00c19dc6
    72e0:	77ac9c65 	strvc	r9, [ip, r5, ror #24]!
    72e4:	240ca1cc 	strcs	sl, [ip], #-460	; 0x1cc
    72e8:	592b0275 	stmdbpl	fp!, {r0, r2, r4, r5, r6, r9}
    72ec:	2de92c6f 	stclcs	12, cr2, [r9, #444]!	; 0x1bc
    72f0:	6ea6e483 	cdpvs	4, 10, cr14, cr6, cr3, {4}
    72f4:	4a7484aa 	bmi	1d285a4 <_etext+0x1d2108c>
    72f8:	bd41fbd4 	vstrlt	d31, [r1, #-848]	; 0xfffffcb0
    72fc:	5cb0a9dc 	ldcpl	9, cr10, [r0], #880	; 0x370
    7300:	831153b5 	tsthi	r1, #-738197502	; 0xd4000002
    7304:	76f988da 	usatvc	r8, #25, sl, asr #17
    7308:	ee66dfab 	cdp	15, 6, cr13, cr6, cr11, {5}
    730c:	983e5152 	ldmdals	lr!, {r1, r4, r6, r8, ip, lr}
    7310:	2db43210 	lfmcs	f3, 4, [r4, #64]!	; 0x40
    7314:	a831c66d 	ldmdage	r1!, {r0, r2, r3, r5, r6, r9, sl, lr, pc}
    7318:	98fb213f 	ldmls	fp!, {r0, r1, r2, r3, r4, r5, r8, sp}^
    731c:	b00327c8 	andlt	r2, r3, r8, asr #15
    7320:	beef0ee4 	cdplt	14, 14, cr0, cr15, cr4, {7}
    7324:	bf597fc7 	svclt	0x00597fc7
    7328:	3da88fc2 	stccc	15, cr8, [r8, #776]!	; 0x308
    732c:	c6e00bf3 			; <UNDEFINED> instruction: 0xc6e00bf3
    7330:	930aa725 	movwls	sl, #42789	; 0xa725
    7334:	d5a79147 	strle	r9, [r7, #327]!	; 0x147
    7338:	e003826f 	and	r8, r3, pc, ror #4
    733c:	06ca6351 			; <UNDEFINED> instruction: 0x06ca6351
    7340:	0a0e6e70 	beq	3a2d08 <_etext+0x39b7f0>
    7344:	14292967 	strtne	r2, [r9], #-2407	; 0x967
    7348:	46d22ffc 			; <UNDEFINED> instruction: 0x46d22ffc
    734c:	27b70a85 	ldrcs	r0, [r7, r5, lsl #21]!
    7350:	5c26c926 	stcpl	9, cr12, [r6], #-152	; 0xffffff68
    7354:	2e1b2138 	mrccs	1, 0, r2, cr11, cr8, {1}
    7358:	5ac42aed 	bpl	ff111f14 <BootRAM+0xe0826b5>
    735c:	4d2c6dfc 	stcmi	13, cr6, [ip, #-1008]!	; 0xfffffc10
    7360:	9d95b3df 	ldcls	3, cr11, [r5, #892]	; 0x37c
    7364:	53380d13 	teqpl	r8, #1216	; 0x4c0
    7368:	8baf63de 	blhi	febe02e8 <BootRAM+0xdb50a89>
    736c:	650a7354 	strvs	r7, [sl, #-852]	; 0x354
    7370:	3c77b2a8 	lfmcc	f3, 3, [r7], #-672	; 0xfffffd60
    7374:	766a0abb 			; <UNDEFINED> instruction: 0x766a0abb
    7378:	47edaee6 	strbmi	sl, [sp, r6, ror #29]!
    737c:	81c2c92e 	bichi	ip, r2, lr, lsr #18
    7380:	1482353b 	strne	r3, [r2], #1339	; 0x53b
    7384:	92722c85 	rsbsls	r2, r2, #34048	; 0x8500
    7388:	4cf10364 	ldclmi	3, cr0, [r1], #400	; 0x190
    738c:	a2bfe8a1 	adcsge	lr, pc, #10551296	; 0xa10000
    7390:	bc423001 	mcrrlt	0, 0, r3, r2, cr1
    7394:	a81a664b 	ldmdage	sl, {r0, r1, r3, r6, r9, sl, sp, lr}
    7398:	d0f89791 	smlalsle	r9, r8, r1, r7
    739c:	c24b8b70 	subgt	r8, fp, #112, 22	; 0x1c000
    73a0:	0654be30 			; <UNDEFINED> instruction: 0x0654be30
    73a4:	c76c51a3 	strbgt	r5, [ip, -r3, lsr #3]!
    73a8:	d6ef5218 	usatle	r5, #15, r8, lsl #4
    73ac:	d192e819 	orrsle	lr, r2, r9, lsl r8
    73b0:	5565a910 	strbpl	sl, [r5, #-2320]!	; 0x910
    73b4:	d6990624 	ldrle	r0, [r9], r4, lsr #12
    73b8:	5771202a 	ldrbpl	r2, [r1, -sl, lsr #32]!
    73bc:	f40e3585 	vst3.32	{d3,d5,d7}, [lr], r5
    73c0:	32bbd1b8 	adcscc	sp, fp, #184, 2	; 0x2e
    73c4:	106aa070 	rsbne	sl, sl, r0, ror r0
    73c8:	b8d2d0c8 	ldmlt	r2, {r3, r6, r7, ip, lr, pc}^
    73cc:	19a4c116 	stmibne	r4!, {r1, r2, r4, r8, lr, pc}
    73d0:	5141ab53 	cmppl	r1, r3, asr fp
    73d4:	1e376c08 	cdpne	12, 3, cr6, cr7, cr8, {0}
    73d8:	df8eeb99 	svcle	0x008eeb99
    73dc:	2748774c 	strbcs	r7, [r8, -ip, asr #14]
    73e0:	e19b48a8 	orrs	r4, fp, r8, lsr #17
    73e4:	34b0bcb5 	ldrtcc	fp, [r0], #3253	; 0xcb5
    73e8:	c5c95a63 	strbgt	r5, [r9, #2659]	; 0xa63
    73ec:	391c0cb3 	ldmdbcc	ip, {r0, r1, r4, r5, r7, sl, fp}
    73f0:	e3418acb 	movt	r8, #6859	; 0x1acb
    73f4:	4ed8aa4a 	vfnmami.f32	s21, s16, s20
    73f8:	7763e373 			; <UNDEFINED> instruction: 0x7763e373
    73fc:	5b9cca4f 	blpl	fe739d40 <BootRAM+0xd6aa4e1>
    7400:	d6b2b8a3 	ldrtle	fp, [r2], r3, lsr #17
    7404:	682e6ff3 	stmdavs	lr!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
    7408:	5defb2fc 	sfmpl	f3, 3, [pc, #1008]!	; 7800 <_etext+0x2e8>
    740c:	748f82ee 	strvc	r8, [pc], #750	; 7414 <round_k+0x1cc>
    7410:	43172f60 	tstmi	r7, #96, 30	; 0x180
    7414:	78a5636f 	stmiavc	r5!, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}
    7418:	a1f0ab72 	mvnsge	sl, r2, ror fp
    741c:	84c87814 	strbhi	r7, [r8], #2068	; 0x814
    7420:	1a6439ec 	bne	1915bd8 <_etext+0x190e6c0>
    7424:	8cc70208 	sfmhi	f0, 2, [r7], {8}
    7428:	23631e28 	cmncs	r3, #40, 28	; 0x280
    742c:	90befffa 	ldrshtls	pc, [lr], sl	; <UNPREDICTABLE>
    7430:	de82bde9 	cdple	13, 8, cr11, cr2, cr9, {7}
    7434:	a4506ceb 	ldrbge	r6, [r0], #-3307	; 0xceb
    7438:	b2c67915 	sbclt	r7, r6, #344064	; 0x54000
    743c:	bef9a3f7 	mrclt	3, 7, sl, cr9, cr7, {7}
    7440:	e372532b 	cmn	r2, #-1409286144	; 0xac000000
    7444:	c67178f2 			; <UNDEFINED> instruction: 0xc67178f2
    7448:	ea26619c 	b	99fac0 <_etext+0x9985a8>
    744c:	ca273ece 	bgt	9d6f8c <_etext+0x9cfa74>
    7450:	21c0c207 	biccs	ip, r0, r7, lsl #4
    7454:	d186b8c7 	orrle	fp, r6, r7, asr #17
    7458:	cde0eb1e 	stclgt	11, cr14, [r0, #120]!	; 0x78
    745c:	eada7dd6 	b	ff6a6bbc <BootRAM+0xe61735d>
    7460:	ee6ed178 	mcr	1, 3, sp, cr14, cr8, {3}
    7464:	f57d4f7f 			; <UNDEFINED> instruction: 0xf57d4f7f
    7468:	72176fba 	andsvc	r6, r7, #744	; 0x2e8
    746c:	06f067aa 	ldrbteq	r6, [r0], sl, lsr #15
    7470:	a2c898a6 	sbcge	r9, r8, #10878976	; 0xa60000
    7474:	0a637dc5 	beq	18e6b90 <_etext+0x18df678>
    7478:	bef90dae 	cdplt	13, 15, cr0, cr9, cr14, {5}
    747c:	113f9804 	teqne	pc, r4, lsl #16
    7480:	131c471b 	tstne	ip, #7077888	; 0x6c0000
    7484:	1b710b35 	blne	1c4a160 <_etext+0x1c42c48>
    7488:	23047d84 	movwcs	r7, #19844	; 0x4d84
    748c:	28db77f5 	ldmcs	fp, {r0, r2, r4, r5, r6, r7, r8, r9, sl, ip, sp, lr}^
    7490:	40c72493 	smullmi	r2, r7, r3, r4
    7494:	32caab7b 	sbccc	sl, sl, #125952	; 0x1ec00
    7498:	15c9bebc 	strbne	fp, [r9, #3772]	; 0xebc
    749c:	3c9ebe0a 	ldccc	14, cr11, [lr], {10}
    74a0:	9c100d4c 	ldcls	13, cr0, [r0], {76}	; 0x4c
    74a4:	431d67c4 	tstmi	sp, #196, 14	; 0x3100000
    74a8:	cb3e42b6 	blgt	f97f88 <_etext+0xf90a70>
    74ac:	4cc5d4be 	cfstrdmi	mvd13, [r5], {190}	; 0xbe
    74b0:	fc657e2a 	stc2l	14, cr7, [r5], #-168	; 0xffffff58
    74b4:	597f299c 	ldmdbpl	pc!, {r2, r3, r4, r7, r8, fp, sp}^	; <UNPREDICTABLE>
    74b8:	3ad6faec 	bcc	ff5c6070 <BootRAM+0xe536811>
    74bc:	5fcb6fab 	svcpl	0x00cb6fab
    74c0:	4a475817 	bmi	11dd524 <_etext+0x11d600c>
    74c4:	6c44198c 	mcrrvs	9, 8, r1, r4, cr12
    74c8:	46464646 	strbmi	r4, [r6], -r6, asr #12
    74cc:	46464646 	strbmi	r4, [r6], -r6, asr #12
    74d0:	46464646 	strbmi	r4, [r6], -r6, asr #12
    74d4:	46464646 	strbmi	r4, [r6], -r6, asr #12
    74d8:	46464646 	strbmi	r4, [r6], -r6, asr #12
    74dc:	00464646 	subeq	r4, r6, r6, asr #12
    74e0:	2d230043 	stccs	0, cr0, [r3, #-268]!	; 0xfffffef4
    74e4:	00202b30 	eoreq	r2, r0, r0, lsr fp
    74e8:	004c6c68 	subeq	r6, ip, r8, ror #24
    74ec:	45676665 	strbmi	r6, [r7, #-1637]!	; 0x665
    74f0:	30004746 	andcc	r4, r0, r6, asr #14
    74f4:	34333231 	ldrtcc	r3, [r3], #-561	; 0x231
    74f8:	38373635 	ldmdacc	r7!, {r0, r2, r4, r5, r9, sl, ip, sp}
    74fc:	43424139 	movtmi	r4, #8505	; 0x2139
    7500:	00464544 	subeq	r4, r6, r4, asr #10
    7504:	33323130 	teqcc	r2, #48, 2
    7508:	37363534 			; <UNDEFINED> instruction: 0x37363534
    750c:	62613938 	rsbvs	r3, r1, #56, 18	; 0xe0000
    7510:	66656463 	strbtvs	r6, [r5], -r3, ror #8
    7514:	00000000 	andeq	r0, r0, r0

Disassembly of section .data:

20000000 <_sdata>:
20000000:	00000000 	andeq	r0, r0, r0
20000004:	04030201 	streq	r0, [r3], #-513	; 0x201
20000008:	04030201 	streq	r0, [r3], #-513	; 0x201
2000000c:	09080706 	stmdbeq	r8, {r1, r2, r8, r9, sl}

20000010 <ADCPrescTable>:
20000010:	08060402 	stmdaeq	r6, {r1, sl}

20000014 <Device_Property>:
20000014:	00000f1d 	andeq	r0, r0, sp, lsl pc
20000018:	00000bdd 	ldrdeq	r0, [r0], -sp
2000001c:	00000b9b 	muleq	r0, fp, fp
20000020:	00000b9d 	muleq	r0, sp, fp
20000024:	00000c85 	andeq	r0, r0, r5, lsl #25
20000028:	00000d29 	andeq	r0, r0, r9, lsr #26
2000002c:	00000b9f 	muleq	r0, pc, fp	; <UNPREDICTABLE>
20000030:	00000ce5 	andeq	r0, r0, r5, ror #25
20000034:	00000cf1 	strdeq	r0, [r0], -r1
20000038:	00000cfd 	strdeq	r0, [r0], -sp
2000003c:	00000d1d 	andeq	r0, r0, sp, lsl sp
20000040:	00000000 	andeq	r0, r0, r0
20000044:	00000040 	andeq	r0, r0, r0, asr #32

20000048 <pEpInt_IN>:
20000048:	00000b99 	muleq	r0, r9, fp
2000004c:	00000b99 	muleq	r0, r9, fp
20000050:	00000b99 	muleq	r0, r9, fp
20000054:	00000b99 	muleq	r0, r9, fp
20000058:	00000b99 	muleq	r0, r9, fp
2000005c:	00000b99 	muleq	r0, r9, fp
20000060:	00000b99 	muleq	r0, r9, fp

20000064 <pEpInt_OUT>:
20000064:	00000b99 	muleq	r0, r9, fp
20000068:	00000b99 	muleq	r0, r9, fp
2000006c:	00000b99 	muleq	r0, r9, fp
20000070:	00000b99 	muleq	r0, r9, fp
20000074:	00000b99 	muleq	r0, r9, fp
20000078:	00000b99 	muleq	r0, r9, fp
2000007c:	00000b99 	muleq	r0, r9, fp

20000080 <User_Standard_Requests>:
20000080:	00000ba9 	andeq	r0, r0, r9, lsr #23
20000084:	00000bad 	andeq	r0, r0, sp, lsr #23
20000088:	00000bc5 	andeq	r0, r0, r5, asr #23
2000008c:	00000bc7 	andeq	r0, r0, r7, asr #23
20000090:	00000bc9 	andeq	r0, r0, r9, asr #23
20000094:	00000bcb 	andeq	r0, r0, fp, asr #23
20000098:	00000bcd 	andeq	r0, r0, sp, asr #23
2000009c:	00000bcf 	andeq	r0, r0, pc, asr #23
200000a0:	00000bd1 	ldrdeq	r0, [r0], -r1

200000a4 <Device_Table>:
200000a4:	00000101 	andeq	r0, r0, r1, lsl #2

200000a8 <usbStringDescriptor>:
200000a8:	200000fc 	strdcs	r0, [r0], -ip
200000ac:	00000004 	andeq	r0, r0, r4
200000b0:	20000146 	andcs	r0, r0, r6, asr #2
200000b4:	00000012 	andeq	r0, r0, r2, lsl r0
200000b8:	20000160 	andcs	r0, r0, r0, ror #2
200000bc:	00000014 	andeq	r0, r0, r4, lsl r0
200000c0:	2000012d 	andcs	r0, r0, sp, lsr #2
200000c4:	00000010 	andeq	r0, r0, r0, lsl r0
200000c8:	20000174 	andcs	r0, r0, r4, ror r1
200000cc:	00000078 	andeq	r0, r0, r8, ror r0
200000d0:	200001ec 	andcs	r0, r0, ip, ror #3
200000d4:	00000064 	andeq	r0, r0, r4, rrx
200000d8:	20000250 	andcs	r0, r0, r0, asr r2
200000dc:	00000064 	andeq	r0, r0, r4, rrx

200000e0 <u8_usbDeviceDescriptorDFU>:
200000e0:	01000112 	tsteq	r0, r2, lsl r1
200000e4:	40000000 	andmi	r0, r0, r0
200000e8:	00031eaf 	andeq	r1, r3, pc, lsr #29
200000ec:	02010201 	andeq	r0, r1, #268435456	; 0x10000000
200000f0:	00000103 	andeq	r0, r0, r3, lsl #2

200000f4 <usbFunctionalDescriptor>:
200000f4:	2000013d 	andcs	r0, r0, sp, lsr r1
200000f8:	00000009 	andeq	r0, r0, r9

200000fc <u8_usbStringLangId>:
200000fc:	04090304 	streq	r0, [r9], #-772	; 0x304

20000100 <u8_usbConfigDescriptorDFU>:
20000100:	002d0209 	eoreq	r0, sp, r9, lsl #4
20000104:	80000101 	andhi	r0, r0, r1, lsl #2
20000108:	00040932 	andeq	r0, r4, r2, lsr r9
2000010c:	01fe0000 	mvnseq	r0, r0
20000110:	04090402 	streq	r0, [r9], #-1026	; 0x402
20000114:	fe000100 	cdp2	1, 0, cr0, cr0, cr0, {0}
20000118:	09050201 	stmdbeq	r5, {r0, r9}
2000011c:	00020004 	andeq	r0, r2, r4
20000120:	060201fe 			; <UNDEFINED> instruction: 0x060201fe
20000124:	ff032109 			; <UNDEFINED> instruction: 0xff032109
20000128:	10080000 	andne	r0, r8, r0
2000012c:	44031001 	strmi	r1, [r3], #-1

2000012d <u8_usbStringSerial>:
2000012d:	00440310 	subeq	r0, r4, r0, lsl r3
20000131:	00560045 	subseq	r0, r6, r5, asr #32
20000135:	00300020 	eorseq	r0, r0, r0, lsr #32
20000139:	00310030 	eorseq	r0, r1, r0, lsr r0

2000013d <u8_usbFunctionalDescriptor>:
2000013d:	ff032109 			; <UNDEFINED> instruction: 0xff032109
20000141:	10080000 	andne	r0, r8, r0
20000145:	4c031201 	sfmmi	f1, 4, [r3], {1}

20000146 <u8_usbStringVendor>:
20000146:	004c0312 	subeq	r0, ip, r2, lsl r3
2000014a:	00610065 	rsbeq	r0, r1, r5, rrx
2000014e:	004c0066 	subeq	r0, ip, r6, rrx
20000152:	00620061 	rsbeq	r0, r2, r1, rrx
20000156:	00e00073 	rsceq	r0, r0, r3, ror r0

20000158 <usbDeviceDescriptorDFU>:
20000158:	200000e0 	andcs	r0, r0, r0, ror #1
2000015c:	00000012 	andeq	r0, r0, r2, lsl r0

20000160 <u8_usbStringProduct>:
20000160:	004d0314 	subeq	r0, sp, r4, lsl r3
20000164:	00700061 	rsbseq	r0, r0, r1, rrx
20000168:	0065006c 	rsbeq	r0, r5, ip, rrx
2000016c:	00300020 	eorseq	r0, r0, r0, lsr #32
20000170:	00330030 	eorseq	r0, r3, r0, lsr r0

20000174 <u8_usbStringAlt0>:
20000174:	00450378 	subeq	r0, r5, r8, ror r3
20000178:	0063006e 	rsbeq	r0, r3, lr, rrx
2000017c:	0061006c 	rsbeq	r0, r1, ip, rrx
20000180:	00650076 	rsbeq	r0, r5, r6, ror r0
20000184:	00440020 	subeq	r0, r4, r0, lsr #32
20000188:	00550046 	subseq	r0, r5, r6, asr #32
2000018c:	00420020 	subeq	r0, r2, r0, lsr #32
20000190:	006f006f 	rsbeq	r0, pc, pc, rrx
20000194:	006c0074 	rsbeq	r0, ip, r4, ror r0
20000198:	0061006f 	rsbeq	r0, r1, pc, rrx
2000019c:	00650064 	rsbeq	r0, r5, r4, rrx
200001a0:	00200072 	eoreq	r0, r0, r2, ror r0
200001a4:	00450020 	subeq	r0, r5, r0, lsr #32
200001a8:	00520052 	subseq	r0, r2, r2, asr r0
200001ac:	0052004f 	subseq	r0, r2, pc, asr #32
200001b0:	0020002e 	eoreq	r0, r0, lr, lsr #32
200001b4:	00700055 	rsbseq	r0, r0, r5, asr r0
200001b8:	006f006c 	rsbeq	r0, pc, ip, rrx
200001bc:	00640061 	rsbeq	r0, r4, r1, rrx
200001c0:	00740020 	rsbseq	r0, r4, r0, lsr #32
200001c4:	0020006f 	eoreq	r0, r0, pc, rrx
200001c8:	00410052 	subeq	r0, r1, r2, asr r0
200001cc:	0020004d 	eoreq	r0, r0, sp, asr #32
200001d0:	006f006e 	rsbeq	r0, pc, lr, rrx
200001d4:	00200074 	eoreq	r0, r0, r4, ror r0
200001d8:	00750073 	rsbseq	r0, r5, r3, ror r0
200001dc:	00700070 	rsbseq	r0, r0, r0, ror r0
200001e0:	0072006f 	rsbseq	r0, r2, pc, rrx
200001e4:	00650074 	rsbeq	r0, r5, r4, ror r0
200001e8:	002e0064 	eoreq	r0, lr, r4, rrx

200001ec <u8_usbStringAlt1>:
200001ec:	00450364 	subeq	r0, r5, r4, ror #6
200001f0:	0063006e 	rsbeq	r0, r3, lr, rrx
200001f4:	0061006c 	rsbeq	r0, r1, ip, rrx
200001f8:	00650076 	rsbeq	r0, r5, r6, ror r0
200001fc:	00440020 	subeq	r0, r4, r0, lsr #32
20000200:	00550046 	subseq	r0, r5, r6, asr #32
20000204:	00420020 	subeq	r0, r2, r0, lsr #32
20000208:	006f006f 	rsbeq	r0, pc, pc, rrx
2000020c:	006c0074 	rsbeq	r0, ip, r4, ror r0
20000210:	0061006f 	rsbeq	r0, r1, pc, rrx
20000214:	00650064 	rsbeq	r0, r5, r4, rrx
20000218:	00200072 	eoreq	r0, r0, r2, ror r0
2000021c:	00550020 	subseq	r0, r5, r0, lsr #32
20000220:	006c0070 	rsbeq	r0, ip, r0, ror r0
20000224:	0061006f 	rsbeq	r0, r1, pc, rrx
20000228:	00200064 	eoreq	r0, r0, r4, rrx
2000022c:	006f0074 	rsbeq	r0, pc, r4, ror r0	; <UNPREDICTABLE>
20000230:	00460020 	subeq	r0, r6, r0, lsr #32
20000234:	0061006c 	rsbeq	r0, r1, ip, rrx
20000238:	00680073 	rsbeq	r0, r8, r3, ror r0
2000023c:	00300020 	eorseq	r0, r0, r0, lsr #32
20000240:	00380078 	eorseq	r0, r8, r8, ror r0
20000244:	00300030 	eorseq	r0, r0, r0, lsr r0
20000248:	00300037 	eorseq	r0, r0, r7, lsr r0
2000024c:	00300030 	eorseq	r0, r0, r0, lsr r0

20000250 <u8_usbStringAlt2>:
20000250:	00450364 	subeq	r0, r5, r4, ror #6
20000254:	0063006e 	rsbeq	r0, r3, lr, rrx
20000258:	0061006c 	rsbeq	r0, r1, ip, rrx
2000025c:	00650076 	rsbeq	r0, r5, r6, ror r0
20000260:	00440020 	subeq	r0, r4, r0, lsr #32
20000264:	00550046 	subseq	r0, r5, r6, asr #32
20000268:	00420020 	subeq	r0, r2, r0, lsr #32
2000026c:	006f006f 	rsbeq	r0, pc, pc, rrx
20000270:	006c0074 	rsbeq	r0, ip, r4, ror r0
20000274:	0061006f 	rsbeq	r0, r1, pc, rrx
20000278:	00650064 	rsbeq	r0, r5, r4, rrx
2000027c:	00200072 	eoreq	r0, r0, r2, ror r0
20000280:	00550020 	subseq	r0, r5, r0, lsr #32
20000284:	006c0070 	rsbeq	r0, ip, r0, ror r0
20000288:	0061006f 	rsbeq	r0, r1, pc, rrx
2000028c:	00200064 	eoreq	r0, r0, r4, rrx
20000290:	006f0074 	rsbeq	r0, pc, r4, ror r0	; <UNPREDICTABLE>
20000294:	00460020 	subeq	r0, r6, r0, lsr #32
20000298:	0061006c 	rsbeq	r0, r1, ip, rrx
2000029c:	00680073 	rsbeq	r0, r8, r3, ror r0
200002a0:	00300020 	eorseq	r0, r0, r0, lsr #32
200002a4:	00380078 	eorseq	r0, r8, r8, ror r0
200002a8:	00300030 	eorseq	r0, r0, r0, lsr r0
200002ac:	00300032 	eorseq	r0, r0, r2, lsr r0
200002b0:	00300030 	eorseq	r0, r0, r0, lsr r0

200002b4 <usbConfigDescriptorDFU>:
200002b4:	20000100 	andcs	r0, r0, r0, lsl #2
200002b8:	0000002d 	andeq	r0, r0, sp, lsr #32

200002bc <userAppEnd>:
200002bc:	20005000 	andcs	r5, r0, r0

200002c0 <userAppAddr>:
200002c0:	20000c00 	andcs	r0, r0, r0, lsl #24

200002c4 <sha256_padding>:
200002c4:	00000080 	andeq	r0, r0, r0, lsl #1
	...

20000304 <k>:
20000304:	428a2f98 	addmi	r2, sl, #152, 30	; 0x260
20000308:	71374491 			; <UNDEFINED> instruction: 0x71374491
2000030c:	b5c0fbcf 	strblt	pc, [r0, #3023]	; 0xbcf	; <UNPREDICTABLE>
20000310:	e9b5dba5 	ldmib	r5!, {r0, r2, r5, r7, r8, r9, fp, ip, lr, pc}
20000314:	3956c25b 	ldmdbcc	r6, {r0, r1, r3, r4, r6, r9, lr, pc}^
20000318:	59f111f1 	ldmibpl	r1!, {r0, r4, r5, r6, r7, r8, ip}^
2000031c:	923f82a4 	eorsls	r8, pc, #164, 4	; 0x4000000a
20000320:	ab1c5ed5 	blge	20717e7c <_estack+0x712e7c>
20000324:	d807aa98 	stmdale	r7, {r3, r4, r7, r9, fp, sp, pc}
20000328:	12835b01 	addne	r5, r3, #1024	; 0x400
2000032c:	243185be 	ldrtcs	r8, [r1], #-1470	; 0x5be
20000330:	550c7dc3 	strpl	r7, [ip, #-3523]	; 0xdc3
20000334:	72be5d74 	adcsvc	r5, lr, #116, 26	; 0x1d00
20000338:	80deb1fe 	ldrshhi	fp, [lr], #30
2000033c:	9bdc06a7 	blls	1f701de0 <_etext+0x1f6fa8c8>
20000340:	c19bf174 	orrsgt	pc, fp, r4, ror r1	; <UNPREDICTABLE>
20000344:	e49b69c1 	ldr	r6, [fp], #2497	; 0x9c1
20000348:	efbe4786 	svc	0x00be4786
2000034c:	0fc19dc6 	svceq	0x00c19dc6
20000350:	240ca1cc 	strcs	sl, [ip], #-460	; 0x1cc
20000354:	2de92c6f 	stclcs	12, cr2, [r9, #444]!	; 0x1bc
20000358:	4a7484aa 	bmi	21d21608 <_estack+0x1d1c608>
2000035c:	5cb0a9dc 	ldcpl	9, cr10, [r0], #880	; 0x370
20000360:	76f988da 	usatvc	r8, #25, sl, asr #17
20000364:	983e5152 	ldmdals	lr!, {r1, r4, r6, r8, ip, lr}
20000368:	a831c66d 	ldmdage	r1!, {r0, r2, r3, r5, r6, r9, sl, lr, pc}
2000036c:	b00327c8 	andlt	r2, r3, r8, asr #15
20000370:	bf597fc7 	svclt	0x00597fc7
20000374:	c6e00bf3 			; <UNDEFINED> instruction: 0xc6e00bf3
20000378:	d5a79147 	strle	r9, [r7, #327]!	; 0x147
2000037c:	06ca6351 			; <UNDEFINED> instruction: 0x06ca6351
20000380:	14292967 	strtne	r2, [r9], #-2407	; 0x967
20000384:	27b70a85 	ldrcs	r0, [r7, r5, lsl #21]!
20000388:	2e1b2138 	mrccs	1, 0, r2, cr11, cr8, {1}
2000038c:	4d2c6dfc 	stcmi	13, cr6, [ip, #-1008]!	; 0xfffffc10
20000390:	53380d13 	teqpl	r8, #1216	; 0x4c0
20000394:	650a7354 	strvs	r7, [sl, #-852]	; 0x354
20000398:	766a0abb 			; <UNDEFINED> instruction: 0x766a0abb
2000039c:	81c2c92e 	bichi	ip, r2, lr, lsr #18
200003a0:	92722c85 	rsbsls	r2, r2, #34048	; 0x8500
200003a4:	a2bfe8a1 	adcsge	lr, pc, #10551296	; 0xa10000
200003a8:	a81a664b 	ldmdage	sl, {r0, r1, r3, r6, r9, sl, sp, lr}
200003ac:	c24b8b70 	subgt	r8, fp, #112, 22	; 0x1c000
200003b0:	c76c51a3 	strbgt	r5, [ip, -r3, lsr #3]!
200003b4:	d192e819 	orrsle	lr, r2, r9, lsl r8
200003b8:	d6990624 	ldrle	r0, [r9], r4, lsr #12
200003bc:	f40e3585 	vst3.32	{d3,d5,d7}, [lr], r5
200003c0:	106aa070 	rsbne	sl, sl, r0, ror r0
200003c4:	19a4c116 	stmibne	r4!, {r1, r2, r4, r8, lr, pc}
200003c8:	1e376c08 	cdpne	12, 3, cr6, cr7, cr8, {0}
200003cc:	2748774c 	strbcs	r7, [r8, -ip, asr #14]
200003d0:	34b0bcb5 	ldrtcc	fp, [r0], #3253	; 0xcb5
200003d4:	391c0cb3 	ldmdbcc	ip, {r0, r1, r4, r5, r7, sl, fp}
200003d8:	4ed8aa4a 	vfnmami.f32	s21, s16, s20
200003dc:	5b9cca4f 	blpl	1e732d20 <_etext+0x1e72b808>
200003e0:	682e6ff3 	stmdavs	lr!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
200003e4:	748f82ee 	strvc	r8, [pc], #750	; 200003ec <k+0xe8>
200003e8:	78a5636f 	stmiavc	r5!, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}
200003ec:	84c87814 	strbhi	r7, [r8], #2068	; 0x814
200003f0:	8cc70208 	sfmhi	f0, 2, [r7], {8}
200003f4:	90befffa 	ldrshtls	pc, [lr], sl	; <UNPREDICTABLE>
200003f8:	a4506ceb 	ldrbge	r6, [r0], #-3307	; 0xceb
200003fc:	bef9a3f7 	mrclt	3, 7, sl, cr9, cr7, {7}
20000400:	c67178f2 			; <UNDEFINED> instruction: 0xc67178f2

20000404 <rootCA>:
20000404:	042d0cbd 	strteq	r0, [sp], #-3261	; 0xcbd
20000408:	c6955a2e 	ldrgt	r5, [r5], lr, lsr #20
2000040c:	3ffc28b6 	svccc	0x00fc28b6
20000410:	fba16c85 	blx	1e85b62e <_etext+0x1e854116>
20000414:	380725b5 	stmdacc	r7, {r0, r2, r4, r5, r7, r8, sl, sp}
20000418:	449d05c0 	ldrmi	r0, [sp], #1472	; 0x5c0
2000041c:	a6e3a704 	strbtge	sl, [r3], r4, lsl #14
20000420:	41b83bac 			; <UNDEFINED> instruction: 0x41b83bac

20000424 <impure_data>:
	...
20000444:	000074e0 	andeq	r7, r0, r0, ror #9
	...

20000484 <_impure_ptr>:
20000484:	20000424 	andcs	r0, r0, r4, lsr #8

Disassembly of section .bss:

20000488 <_sbss>:
20000488:	00000000 	andeq	r0, r0, r0

2000048c <wIstr>:
	...

2000048e <ResumeS>:
	...

20000490 <input>:
	...

200004ec <sha256sum>:
	...

2000050c <ctx>:
	...

20000574 <code_copy_lock>:
	...

20000576 <SaveRState>:
	...

20000578 <SaveTState>:
20000578:	00000000 	andeq	r0, r0, r0

2000057c <SaveState>:
2000057c:	00000000 	andeq	r0, r0, r0

20000580 <pProperty>:
20000580:	00000000 	andeq	r0, r0, r0

20000584 <EPindex>:
20000584:	00000000 	andeq	r0, r0, r0

20000588 <Device_Info>:
	...

200005a4 <pUser_Standard_Requests>:
200005a4:	00000000 	andeq	r0, r0, r0

200005a8 <pInformation>:
200005a8:	00000000 	andeq	r0, r0, r0

200005ac <wInterrupt_Mask>:
	...

200005ae <StatusInfo>:
	...

200005b0 <errno>:
200005b0:	00000000 	andeq	r0, r0, r0

Disassembly of section .bss.bIntPackSOF:

200005b4 <bIntPackSOF>:
	...

Disassembly of section .bss.bDeviceState:

200005b8 <bDeviceState>:
200005b8:	00000000 	andeq	r0, r0, r0

Disassembly of section .bss.recvBuffer:

200005bc <recvBuffer>:
	...

Disassembly of section .bss.uploadBlockLen:

20000dbc <uploadBlockLen>:
	...

Disassembly of section .bss.thisBlockLen:

20000dbe <thisBlockLen>:
	...

Disassembly of section .bss.userFirmwareLen:

20000dc0 <userFirmwareLen>:
20000dc0:	00000000 	andeq	r0, r0, r0

Disassembly of section .bss.userUploadType:

20000dc4 <userUploadType>:
	...

Disassembly of section .bss.dfuAppStatus:

20000dc5 <dfuAppStatus>:
20000dc5:	00000000 	andeq	r0, r0, r0
	...

Disassembly of section .bss.dfuBusy:

20000dcb <dfuBusy>:
	...

Disassembly of section .bss.Data_Mul_MaxPacketSize:

20000dcc <Data_Mul_MaxPacketSize>:
	...

Disassembly of section .bss.__malloc_sbrk_start:

20000dd0 <__malloc_sbrk_start>:
20000dd0:	00000000 	andeq	r0, r0, r0

Disassembly of section .bss.__malloc_free_list:

20000dd4 <__malloc_free_list>:
20000dd4:	00000000 	andeq	r0, r0, r0

Disassembly of section .bss.heap_end.4246:

20000dd8 <heap_end.4246>:
20000dd8:	00000000 	andeq	r0, r0, r0

Disassembly of section ._usrstack:

20000ddc <_susrstack>:
	...

Disassembly of section .comment:

00000000 <.comment>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void NOP_Process(void)
{
   0:	3a434347 	bcc	10d0d24 <_etext+0x10c980c>
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
   4:	4e472820 	cdpmi	8, 4, cr2, cr7, cr0, {1}
   8:	6f542055 	svcvs	0x00542055
   c:	20736c6f 	rsbscs	r6, r3, pc, ror #24
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
  10:	20726f66 	rsbscs	r6, r2, r6, ror #30
  14:	204d5241 	subcs	r5, sp, r1, asr #4
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
  18:	65626d45 	strbvs	r6, [r2, #-3397]!	; 0xd45
  1c:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
  20:	6f725020 	svcvs	0x00725020
  24:	73736563 	cmnvc	r3, #415236096	; 0x18c00000
  28:	2973726f 	ldmdbcs	r3!, {r0, r1, r2, r3, r5, r6, r9, ip, sp, lr}^
    if ((wEPVal & EP_CTR_RX) != 0)
  2c:	382e3420 	stmdacc	lr!, {r5, sl, ip, sp}
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
  30:	3220342e 	eorcc	r3, r0, #771751936	; 0x2e000000
  34:	30343130 	eorscc	r3, r4, r0, lsr r1
  38:	20353237 	eorscs	r3, r5, r7, lsr r2

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
  3c:	6c657228 	sfmvs	f7, 2, [r5], #-160	; 0xffffff60

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
  40:	65736165 	ldrbvs	r6, [r3, #-357]!	; 0x165
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
  44:	415b2029 	cmpmi	fp, r9, lsr #32
  48:	652f4d52 	strvs	r4, [pc, #-3410]!	; fffff2fe <BootRAM+0xef6fa9f>
  4c:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
  50:	2d646564 	cfstr64cs	mvdx6, [r4, #-400]!	; 0xfffffe70
  54:	2d385f34 	ldccs	15, cr5, [r8, #-208]!	; 0xffffff30
  58:	6e617262 	cdpvs	2, 6, cr7, cr1, cr2, {3}
  5c:	72206863 	eorvc	r6, r0, #6488064	; 0x630000
  60:	73697665 	cmnvc	r9, #105906176	; 0x6500000
  64:	206e6f69 	rsbcs	r6, lr, r9, ror #30
  68:	31333132 	teqcc	r3, r2, lsr r1
  6c:	005d3734 	subseq	r3, sp, r4, lsr r7

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:
   0:	00002e41 	andeq	r2, r0, r1, asr #28
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	00000024 	andeq	r0, r0, r4, lsr #32
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
  10:	726f4305 	rsbvc	r4, pc, #335544320	; 0x14000000
  14:	2d786574 	cfldr64cs	mvdx6, [r8, #-464]!	; 0xfffffe30
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
  18:	0600334d 	streq	r3, [r0], -sp, asr #6
  1c:	094d070a 	stmdbeq	sp, {r1, r3, r8, r9, sl}^
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
  20:	14041202 	strne	r1, [r4], #-514	; 0x202
  24:	17011501 	strne	r1, [r1, -r1, lsl #10]
  28:	1a011803 	bne	4603c <_etext+0x3eb24>
    if ((wEPVal & EP_CTR_RX) != 0)
  2c:	Address 0x0000002c is out of bounds.


Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	00000024 	andeq	r0, r0, r4, lsr #32
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
   c:	00000000 	andeq	r0, r0, r0
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
  10:	00000b4c 	andeq	r0, r0, ip, asr #22
  14:	00000048 	andeq	r0, r0, r8, asr #32
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
  18:	00000b94 	muleq	r0, r4, fp
  1c:	00000004 	andeq	r0, r0, r4
	...
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
  28:	0000001c 	andeq	r0, r0, ip, lsl r0
    if ((wEPVal & EP_CTR_RX) != 0)
  2c:	007c0002 	rsbseq	r0, ip, r2
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
  30:	00040000 	andeq	r0, r4, r0
	...

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
  3c:	0000007a 	andeq	r0, r0, sl, ror r0
	...

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
  48:	0000011c 	andeq	r0, r0, ip, lsl r1
  4c:	00fe0002 	rscseq	r0, lr, r2

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
  50:	00040000 	andeq	r0, r4, r0
  54:	00000000 	andeq	r0, r0, r0
  58:	00000b98 	muleq	r0, r8, fp
  5c:	00000002 	andeq	r0, r0, r2
  60:	00000b9a 	muleq	r0, sl, fp
  64:	00000002 	andeq	r0, r0, r2
  68:	00000b9c 	muleq	r0, ip, fp
  6c:	00000002 	andeq	r0, r0, r2
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPDblBuffCount(u8 bEpNum, u8 bDir, u16 wCount)
{
  _SetEPDblBuffCount(bEpNum, bDir, wCount);
  70:	00000b9e 	muleq	r0, lr, fp
  74:	0000000a 	andeq	r0, r0, sl
  78:	00000ba8 	andeq	r0, r0, r8, lsr #23
  7c:	00000002 	andeq	r0, r0, r2
  80:	00000bac 	andeq	r0, r0, ip, lsr #23
  84:	00000018 	andeq	r0, r0, r8, lsl r0
  88:	00000bc4 	andeq	r0, r0, r4, asr #23
  8c:	00000002 	andeq	r0, r0, r2
  90:	00000bc6 	andeq	r0, r0, r6, asr #23
  94:	00000002 	andeq	r0, r0, r2
  98:	00000bc8 	andeq	r0, r0, r8, asr #23
  9c:	00000002 	andeq	r0, r0, r2
  a0:	00000bca 	andeq	r0, r0, sl, asr #23
  a4:	00000002 	andeq	r0, r0, r2
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
  a8:	00000bcc 	andeq	r0, r0, ip, asr #23

	return f25519_eq(a, c);
  ac:	00000002 	andeq	r0, r0, r2
  b0:	00000bce 	andeq	r0, r0, lr, asr #23
  b4:	00000002 	andeq	r0, r0, r2
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
  b8:	00000bd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
	f25519_normalize(ey);
  bc:	0000000c 	andeq	r0, r0, ip
  c0:	00000bdc 	ldrdeq	r0, [r0], -ip

	return ok;
}
  c4:	000000a8 	andeq	r0, r0, r8, lsr #1
  c8:	00000c84 	andeq	r0, r0, r4, lsl #25
  cc:	00000060 	andeq	r0, r0, r0, rrx
  d0:	00000ce4 	andeq	r0, r0, r4, ror #25
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
  d4:	0000000c 	andeq	r0, r0, ip
  d8:	00000cf0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
		minusp[i] = c;
  dc:	0000000c 	andeq	r0, r0, ip
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
  e0:	00000cfc 	strdeq	r0, [r0], -ip
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
  e4:	00000020 	andeq	r0, r0, r0, lsr #32

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
  e8:	00000d1c 	andeq	r0, r0, ip, lsl sp
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
  ec:	0000000c 	andeq	r0, r0, ip
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
  f0:	00000d28 	andeq	r0, r0, r8, lsr #26
  f4:	00000028 	andeq	r0, r0, r8, lsr #32
  f8:	00000d50 	andeq	r0, r0, r0, asr sp
  fc:	00000068 	andeq	r0, r0, r8, rrx
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
 100:	00000000 	andeq	r0, r0, r0

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
 104:	00000004 	andeq	r0, r0, r4
 108:	00000db8 			; <UNDEFINED> instruction: 0x00000db8
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
 10c:	0000001c 	andeq	r0, r0, ip, lsl r0
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
 110:	00000dd4 	ldrdeq	r0, [r0], -r4
 114:	00000018 	andeq	r0, r0, r8, lsl r0
 118:	00000dec 	andeq	r0, r0, ip, ror #27
 11c:	00000084 	andeq	r0, r0, r4, lsl #1
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
 120:	00000e70 	andeq	r0, r0, r0, ror lr
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
 124:	00000048 	andeq	r0, r0, r8, asr #32
 128:	00000eb8 			; <UNDEFINED> instruction: 0x00000eb8
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
 12c:	0000003c 	andeq	r0, r0, ip, lsr r0

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
 130:	00000ef4 	strdeq	r0, [r0], -r4
	i <<= 3;

	while (x) {
 134:	00000004 	andeq	r0, r0, r4
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
 138:	00000ef8 	strdeq	r0, [r0], -r8
 13c:	00000024 	andeq	r0, r0, r4, lsr #32
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
 140:	00000f1c 	andeq	r0, r0, ip, lsl pc
	f25519_mul_c(z3, x1sq, 4);
 144:	00000040 	andeq	r0, r0, r0, asr #32
 148:	00000f5c 	andeq	r0, r0, ip, asr pc
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
 14c:	00000022 	andeq	r0, r0, r2, lsr #32
 150:	00000f80 	andeq	r0, r0, r0, lsl #31
 154:	000000b4 	strheq	r0, [r0], -r4
	f25519_sub(b, x3, z3); /* D */
 158:	00000000 	andeq	r0, r0, r0
 15c:	0000000c 	andeq	r0, r0, ip
	...
	f25519_mul__distinct(da, a, b);
 168:	00000014 	andeq	r0, r0, r4, lsl r0

	f25519_sub(b, x2, z2);
 16c:	0f0a0002 	svceq	0x000a0002
 170:	00040000 	andeq	r0, r4, r0
	...
	f25519_add(a, x3, z3); /* C */
	f25519_mul__distinct(cb, a, b);
 180:	00000024 	andeq	r0, r0, r4, lsr #32
 184:	11670002 	cmnne	r7, r2

	f25519_add(a, da, cb);
 188:	00040000 	andeq	r0, r4, r0
 18c:	00000000 	andeq	r0, r0, r0
 190:	00001034 	andeq	r1, r0, r4, lsr r0
	f25519_mul__distinct(b, a, a);
 194:	00000002 	andeq	r0, r0, r2
 198:	00001038 	andeq	r1, r0, r8, lsr r0
	f25519_mul__distinct(x5, z1, b);
 19c:	000000ec 	andeq	r0, r0, ip, ror #1
	...

	f25519_sub(a, da, cb);
 1a8:	00000104 	andeq	r0, r0, r4, lsl #2
 1ac:	16340002 	ldrtne	r0, [r4], -r2
	f25519_mul__distinct(b, a, a);
 1b0:	00040000 	andeq	r0, r4, r0
 1b4:	00000000 	andeq	r0, r0, r0
 1b8:	00001124 	andeq	r1, r0, r4, lsr #2

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
 1bc:	00000016 	andeq	r0, r0, r6, lsl r0
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
 1c0:	0000113a 	andeq	r1, r0, sl, lsr r1
 1c4:	00000012 	andeq	r0, r0, r2, lsl r0

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
 1c8:	0000114c 	andeq	r1, r0, ip, asr #2
 1cc:	00000050 	andeq	r0, r0, r0, asr r0
 1d0:	0000119c 	muleq	r0, ip, r1
 1d4:	0000000a 	andeq	r0, r0, sl
		f25519_select(zm1, zm1, zm, bit);
 1d8:	000011a6 	andeq	r1, r0, r6, lsr #3
 1dc:	00000016 	andeq	r0, r0, r6, lsl r0
 1e0:	000011bc 			; <UNDEFINED> instruction: 0x000011bc
		f25519_select(xm, xm, xms, bit);
 1e4:	00000028 	andeq	r0, r0, r8, lsr #32
 1e8:	000011e4 	andeq	r1, r0, r4, ror #3
 1ec:	0000001a 	andeq	r0, r0, sl, lsl r0
		f25519_select(zm, zm, zms, bit);
 1f0:	000011fe 	strdeq	r1, [r0], -lr
 1f4:	0000002e 	andeq	r0, r0, lr, lsr #32
 1f8:	0000122c 	andeq	r1, r0, ip, lsr #4
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
 1fc:	00000088 	andeq	r0, r0, r8, lsl #1
 200:	000012b4 			; <UNDEFINED> instruction: 0x000012b4
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
 204:	00000048 	andeq	r0, r0, r8, asr #32
 208:	000012fc 	strdeq	r1, [r0], -ip
	f25519_mul__distinct(result, zm1, xm);
 20c:	00000060 	andeq	r0, r0, r0, rrx
 210:	0000135c 	andeq	r1, r0, ip, asr r3
	f25519_normalize(result);
 214:	00000014 	andeq	r0, r0, r4, lsl r0
 218:	00001370 	andeq	r1, r0, r0, ror r3
}
 21c:	0000001c 	andeq	r0, r0, ip, lsl r0
 220:	00000000 	andeq	r0, r0, r0
 224:	0000002e 	andeq	r0, r0, lr, lsr #32
 228:	00000000 	andeq	r0, r0, r0
 22c:	00000004 	andeq	r0, r0, r4
 230:	0000138c 	andeq	r1, r0, ip, lsl #7
 234:	00000018 	andeq	r0, r0, r8, lsl r0
 238:	00000000 	andeq	r0, r0, r0
 23c:	0000002c 	andeq	r0, r0, ip, lsr #32
 240:	00000000 	andeq	r0, r0, r0
 244:	00000048 	andeq	r0, r0, r8, asr #32
 248:	000013a4 	andeq	r1, r0, r4, lsr #7
 24c:	0000006c 	andeq	r0, r0, ip, rrx
 250:	00001410 	andeq	r1, r0, r0, lsl r4
 254:	00000024 	andeq	r0, r0, r4, lsr #32
 258:	00001434 	andeq	r1, r0, r4, lsr r4
 25c:	0000001e 	andeq	r0, r0, lr, lsl r0
 260:	00001454 	andeq	r1, r0, r4, asr r4
 264:	00000014 	andeq	r0, r0, r4, lsl r0
 268:	00001468 	andeq	r1, r0, r8, ror #8
 26c:	00000034 	andeq	r0, r0, r4, lsr r0
 270:	00000000 	andeq	r0, r0, r0
 274:	00000030 	andeq	r0, r0, r0, lsr r0
 278:	0000149c 	muleq	r0, ip, r4
 27c:	0000004c 	andeq	r0, r0, ip, asr #32
 280:	000014e8 	andeq	r1, r0, r8, ror #9
 284:	0000000c 	andeq	r0, r0, ip
 288:	000014f4 	strdeq	r1, [r0], -r4
 28c:	00000018 	andeq	r0, r0, r8, lsl r0
 290:	0000150c 	andeq	r1, r0, ip, lsl #10
 294:	00000012 	andeq	r0, r0, r2, lsl r0
 298:	00001520 	andeq	r1, r0, r0, lsr #10
 29c:	00000010 	andeq	r0, r0, r0, lsl r0
 2a0:	00001530 	andeq	r1, r0, r0, lsr r5
 2a4:	00000018 	andeq	r0, r0, r8, lsl r0
	...
 2b0:	00000084 	andeq	r0, r0, r4, lsl #1
 2b4:	27d00002 	ldrbcs	r0, [r0, r2]
 2b8:	00040000 	andeq	r0, r4, r0
 2bc:	00000000 	andeq	r0, r0, r0
 2c0:	00001548 	andeq	r1, r0, r8, asr #10
 2c4:	00000088 	andeq	r0, r0, r8, lsl #1
 2c8:	000015d0 	ldrdeq	r1, [r0], -r0
 2cc:	00000044 	andeq	r0, r0, r4, asr #32
 2d0:	00000000 	andeq	r0, r0, r0
 2d4:	00000002 	andeq	r0, r0, r2
 2d8:	00001614 	andeq	r1, r0, r4, lsl r6
 2dc:	00000018 	andeq	r0, r0, r8, lsl r0
 2e0:	0000162c 	andeq	r1, r0, ip, lsr #12
 2e4:	00000018 	andeq	r0, r0, r8, lsl r0
 2e8:	00001644 	andeq	r1, r0, r4, asr #12
 2ec:	00000028 	andeq	r0, r0, r8, lsr #32
 2f0:	0000166c 	andeq	r1, r0, ip, ror #12
 2f4:	00000034 	andeq	r0, r0, r4, lsr r0
 2f8:	000016a0 	andeq	r1, r0, r0, lsr #13
 2fc:	0000005c 	andeq	r0, r0, ip, asr r0
 300:	000016fc 	strdeq	r1, [r0], -ip
 304:	00000254 	andeq	r0, r0, r4, asr r2
 308:	00000000 	andeq	r0, r0, r0
 30c:	0000000c 	andeq	r0, r0, ip
 310:	00000000 	andeq	r0, r0, r0
 314:	0000000c 	andeq	r0, r0, ip
 318:	00001950 	andeq	r1, r0, r0, asr r9
 31c:	0000000c 	andeq	r0, r0, ip
 320:	00000000 	andeq	r0, r0, r0
 324:	0000001c 	andeq	r0, r0, ip, lsl r0
 328:	0000195c 	andeq	r1, r0, ip, asr r9
 32c:	00000002 	andeq	r0, r0, r2
	...
 338:	0000001c 	andeq	r0, r0, ip, lsl r0
 33c:	31490002 	cmpcc	r9, r2
 340:	00040000 	andeq	r0, r4, r0
	...
 34c:	00000228 	andeq	r0, r0, r8, lsr #4
	...
 358:	0000004c 	andeq	r0, r0, ip, asr #32
 35c:	3b800002 	blcc	fe00036c <BootRAM+0xcf70b0d>
 360:	00040000 	andeq	r0, r4, r0
 364:	00000000 	andeq	r0, r0, r0
 368:	00001960 	andeq	r1, r0, r0, ror #18
 36c:	00000070 	andeq	r0, r0, r0, ror r0
 370:	000019d0 	ldrdeq	r1, [r0], -r0
 374:	0000003a 	andeq	r0, r0, sl, lsr r0
 378:	00001a0c 	andeq	r1, r0, ip, lsl #20
 37c:	0000005e 	andeq	r0, r0, lr, asr r0
 380:	00001a6c 	andeq	r1, r0, ip, ror #20
 384:	000000c8 	andeq	r0, r0, r8, asr #1
 388:	00001b34 	andeq	r1, r0, r4, lsr fp
 38c:	000000e0 	andeq	r0, r0, r0, ror #1
 390:	00001c14 	andeq	r1, r0, r4, lsl ip
 394:	000000b4 	strheq	r0, [r0], -r4
 398:	00001cc8 	andeq	r1, r0, r8, asr #25
 39c:	00000084 	andeq	r0, r0, r4, lsl #1
	...
 3a8:	00000024 	andeq	r0, r0, r4, lsr #32
 3ac:	4a360002 	bmi	d803bc <_etext+0xd78ea4>
 3b0:	00040000 	andeq	r0, r4, r0
	...
 3bc:	0000007c 	andeq	r0, r0, ip, ror r0
 3c0:	00001d4c 	andeq	r1, r0, ip, asr #26
 3c4:	0000017c 	andeq	r0, r0, ip, ror r1
	...
 3d0:	0000007c 	andeq	r0, r0, ip, ror r0
 3d4:	55920002 	ldrpl	r0, [r2, #2]
 3d8:	00040000 	andeq	r0, r4, r0
 3dc:	00000000 	andeq	r0, r0, r0
 3e0:	00001ec8 	andeq	r1, r0, r8, asr #29
 3e4:	0000001e 	andeq	r0, r0, lr, lsl r0
 3e8:	00001ee8 	andeq	r1, r0, r8, ror #29
 3ec:	0000006e 	andeq	r0, r0, lr, rrx
 3f0:	00001f58 	andeq	r1, r0, r8, asr pc
 3f4:	0000009a 	muleq	r0, sl, r0
 3f8:	00001ff4 	strdeq	r1, [r0], -r4
 3fc:	000000c2 	andeq	r0, r0, r2, asr #1
 400:	000020b8 	strheq	r2, [r0], -r8
 404:	00000046 	andeq	r0, r0, r6, asr #32
 408:	00002100 	andeq	r2, r0, r0, lsl #2
 40c:	0000004c 	andeq	r0, r0, ip, asr #32
 410:	0000214c 	andeq	r2, r0, ip, asr #2
 414:	00000046 	andeq	r0, r0, r6, asr #32
 418:	00002194 	muleq	r0, r4, r1
 41c:	00000088 	andeq	r0, r0, r8, lsl #1
 420:	00000000 	andeq	r0, r0, r0
 424:	000000b8 	strheq	r0, [r0], -r8
 428:	00000000 	andeq	r0, r0, r0
 42c:	00000040 	andeq	r0, r0, r0, asr #32
 430:	0000221c 	andeq	r2, r0, ip, lsl r2
 434:	000005ea 	andeq	r0, r0, sl, ror #11
 438:	00000000 	andeq	r0, r0, r0
 43c:	00000026 	andeq	r0, r0, r6, lsr #32
 440:	00002808 	andeq	r2, r0, r8, lsl #16
 444:	00000634 	andeq	r0, r0, r4, lsr r6
	...
 450:	0000005c 	andeq	r0, r0, ip, asr r0
 454:	65390002 	ldrvs	r0, [r9, #-2]!
 458:	00040000 	andeq	r0, r4, r0
	...
 464:	0000001e 	andeq	r0, r0, lr, lsl r0
 468:	00002e3c 	andeq	r2, r0, ip, lsr lr
 46c:	000001a0 	andeq	r0, r0, r0, lsr #3
 470:	00000000 	andeq	r0, r0, r0
 474:	0000002c 	andeq	r0, r0, ip, lsr #32
 478:	00000000 	andeq	r0, r0, r0
 47c:	0000009a 	muleq	r0, sl, r0
 480:	00000000 	andeq	r0, r0, r0
 484:	000000c2 	andeq	r0, r0, r2, asr #1
 488:	00000000 	andeq	r0, r0, r0
 48c:	00000058 	andeq	r0, r0, r8, asr r0
 490:	00000000 	andeq	r0, r0, r0
 494:	0000008e 	andeq	r0, r0, lr, lsl #1
 498:	00000000 	andeq	r0, r0, r0
 49c:	0000013e 	andeq	r0, r0, lr, lsr r1
 4a0:	00000000 	andeq	r0, r0, r0
 4a4:	000000d2 	ldrdeq	r0, [r0], -r2
	...
 4b0:	00000024 	andeq	r0, r0, r4, lsr #32
 4b4:	72ad0002 	adcvc	r0, sp, #2
 4b8:	00040000 	andeq	r0, r4, r0
	...
 4c4:	00000040 	andeq	r0, r0, r0, asr #32
 4c8:	00000000 	andeq	r0, r0, r0
 4cc:	000000d4 	ldrdeq	r0, [r0], -r4
	...
 4d8:	00000034 	andeq	r0, r0, r4, lsr r0
 4dc:	78d70002 	ldmvc	r7, {r1}^
 4e0:	00040000 	andeq	r0, r4, r0
 4e4:	00000000 	andeq	r0, r0, r0
 4e8:	00002fdc 	ldrdeq	r2, [r0], -ip
 4ec:	00000058 	andeq	r0, r0, r8, asr r0
 4f0:	00003034 	andeq	r3, r0, r4, lsr r0
 4f4:	00001f64 	andeq	r1, r0, r4, ror #30
 4f8:	00004f98 	muleq	r0, r8, pc	; <UNPREDICTABLE>
 4fc:	0000008e 	andeq	r0, r0, lr, lsl #1
 500:	00005028 	andeq	r5, r0, r8, lsr #32
 504:	00000218 	andeq	r0, r0, r8, lsl r2
	...
 510:	0000002c 	andeq	r0, r0, ip, lsr #32
 514:	7e870002 	cdpvc	0, 8, cr0, cr7, cr2, {0}
 518:	00040000 	andeq	r0, r4, r0
 51c:	00000000 	andeq	r0, r0, r0
 520:	00005240 	andeq	r5, r0, r0, asr #4
 524:	00000494 	muleq	r0, r4, r4
 528:	000056d4 	ldrdeq	r5, [r0], -r4
 52c:	00000088 	andeq	r0, r0, r8, lsl #1
 530:	0000575c 	andeq	r5, r0, ip, asr r7
 534:	00000296 	muleq	r0, r6, r2
	...
 540:	00000024 	andeq	r0, r0, r4, lsr #32
 544:	860a0002 	strhi	r0, [sl], -r2
 548:	00040000 	andeq	r0, r4, r0
 54c:	00000000 	andeq	r0, r0, r0
 550:	000059f4 	strdeq	r5, [r0], -r4
 554:	00000044 	andeq	r0, r0, r4, asr #32
 558:	00005a38 	andeq	r5, r0, r8, lsr sl
 55c:	00000184 	andeq	r0, r0, r4, lsl #3
	...
 568:	000001ec 	andeq	r0, r0, ip, ror #3
 56c:	8e250002 	cdphi	0, 2, cr0, cr5, cr2, {0}
 570:	00040000 	andeq	r0, r4, r0
	...
 57c:	0000000c 	andeq	r0, r0, ip
 580:	00000000 	andeq	r0, r0, r0
 584:	0000000c 	andeq	r0, r0, ip
 588:	00000000 	andeq	r0, r0, r0
 58c:	0000000c 	andeq	r0, r0, ip
 590:	00000000 	andeq	r0, r0, r0
 594:	0000000c 	andeq	r0, r0, ip
 598:	00000000 	andeq	r0, r0, r0
 59c:	0000000c 	andeq	r0, r0, ip
 5a0:	00000000 	andeq	r0, r0, r0
 5a4:	0000000c 	andeq	r0, r0, ip
 5a8:	00000000 	andeq	r0, r0, r0
 5ac:	0000000c 	andeq	r0, r0, ip
 5b0:	00000000 	andeq	r0, r0, r0
 5b4:	00000010 	andeq	r0, r0, r0, lsl r0
 5b8:	00000000 	andeq	r0, r0, r0
 5bc:	0000000c 	andeq	r0, r0, ip
 5c0:	00000000 	andeq	r0, r0, r0
 5c4:	0000000e 	andeq	r0, r0, lr
 5c8:	00000000 	andeq	r0, r0, r0
 5cc:	00000010 	andeq	r0, r0, r0, lsl r0
 5d0:	00000000 	andeq	r0, r0, r0
 5d4:	0000001c 	andeq	r0, r0, ip, lsl r0
 5d8:	00000000 	andeq	r0, r0, r0
 5dc:	00000012 	andeq	r0, r0, r2, lsl r0
 5e0:	00005bbc 			; <UNDEFINED> instruction: 0x00005bbc
 5e4:	0000002a 	andeq	r0, r0, sl, lsr #32
 5e8:	00000000 	andeq	r0, r0, r0
 5ec:	0000002a 	andeq	r0, r0, sl, lsr #32
 5f0:	00000000 	andeq	r0, r0, r0
 5f4:	00000024 	andeq	r0, r0, r4, lsr #32
 5f8:	00000000 	andeq	r0, r0, r0
 5fc:	00000012 	andeq	r0, r0, r2, lsl r0
 600:	00000000 	andeq	r0, r0, r0
 604:	00000012 	andeq	r0, r0, r2, lsl r0
 608:	00000000 	andeq	r0, r0, r0
 60c:	0000001e 	andeq	r0, r0, lr, lsl r0
 610:	00005be6 	andeq	r5, r0, r6, ror #23
 614:	0000001e 	andeq	r0, r0, lr, lsl r0
 618:	00000000 	andeq	r0, r0, r0
 61c:	0000001e 	andeq	r0, r0, lr, lsl r0
 620:	00000000 	andeq	r0, r0, r0
 624:	0000001c 	andeq	r0, r0, ip, lsl r0
 628:	00005c04 	andeq	r5, r0, r4, lsl #24
 62c:	0000001c 	andeq	r0, r0, ip, lsl r0
 630:	00000000 	andeq	r0, r0, r0
 634:	0000001e 	andeq	r0, r0, lr, lsl r0
 638:	00000000 	andeq	r0, r0, r0
 63c:	0000001e 	andeq	r0, r0, lr, lsl r0
 640:	00000000 	andeq	r0, r0, r0
 644:	0000001c 	andeq	r0, r0, ip, lsl r0
 648:	00000000 	andeq	r0, r0, r0
 64c:	0000001a 	andeq	r0, r0, sl, lsl r0
 650:	00000000 	andeq	r0, r0, r0
 654:	0000001a 	andeq	r0, r0, sl, lsl r0
 658:	00000000 	andeq	r0, r0, r0
 65c:	00000018 	andeq	r0, r0, r8, lsl r0
 660:	00000000 	andeq	r0, r0, r0
 664:	0000001c 	andeq	r0, r0, ip, lsl r0
 668:	00000000 	andeq	r0, r0, r0
 66c:	00000020 	andeq	r0, r0, r0, lsr #32
 670:	00000000 	andeq	r0, r0, r0
 674:	00000020 	andeq	r0, r0, r0, lsr #32
 678:	00005c20 	andeq	r5, r0, r0, lsr #24
 67c:	00000020 	andeq	r0, r0, r0, lsr #32
 680:	00005c40 	andeq	r5, r0, r0, asr #24
 684:	00000020 	andeq	r0, r0, r0, lsr #32
 688:	00000000 	andeq	r0, r0, r0
 68c:	0000001e 	andeq	r0, r0, lr, lsl r0
 690:	00000000 	andeq	r0, r0, r0
 694:	00000012 	andeq	r0, r0, r2, lsl r0
 698:	00000000 	andeq	r0, r0, r0
 69c:	00000020 	andeq	r0, r0, r0, lsr #32
 6a0:	00000000 	andeq	r0, r0, r0
 6a4:	00000020 	andeq	r0, r0, r0, lsr #32
 6a8:	00005c60 	andeq	r5, r0, r0, ror #24
 6ac:	0000001c 	andeq	r0, r0, ip, lsl r0
 6b0:	00005c7c 	andeq	r5, r0, ip, ror ip
 6b4:	0000001c 	andeq	r0, r0, ip, lsl r0
 6b8:	00005c98 	muleq	r0, r8, ip
 6bc:	0000001c 	andeq	r0, r0, ip, lsl r0
 6c0:	00000000 	andeq	r0, r0, r0
 6c4:	00000026 	andeq	r0, r0, r6, lsr #32
 6c8:	00005cb4 			; <UNDEFINED> instruction: 0x00005cb4
 6cc:	00000040 	andeq	r0, r0, r0, asr #32
 6d0:	00000000 	andeq	r0, r0, r0
 6d4:	00000020 	andeq	r0, r0, r0, lsr #32
 6d8:	00000000 	andeq	r0, r0, r0
 6dc:	00000020 	andeq	r0, r0, r0, lsr #32
 6e0:	00000000 	andeq	r0, r0, r0
 6e4:	00000038 	andeq	r0, r0, r8, lsr r0
 6e8:	00000000 	andeq	r0, r0, r0
 6ec:	00000020 	andeq	r0, r0, r0, lsr #32
 6f0:	00000000 	andeq	r0, r0, r0
 6f4:	00000020 	andeq	r0, r0, r0, lsr #32
 6f8:	00000000 	andeq	r0, r0, r0
 6fc:	0000001c 	andeq	r0, r0, ip, lsl r0
 700:	00000000 	andeq	r0, r0, r0
 704:	0000001c 	andeq	r0, r0, ip, lsl r0
 708:	00000000 	andeq	r0, r0, r0
 70c:	000000a8 	andeq	r0, r0, r8, lsr #1
 710:	00000000 	andeq	r0, r0, r0
 714:	0000005c 	andeq	r0, r0, ip, asr r0
 718:	00000000 	andeq	r0, r0, r0
 71c:	0000005c 	andeq	r0, r0, ip, asr r0
 720:	00000000 	andeq	r0, r0, r0
 724:	00000020 	andeq	r0, r0, r0, lsr #32
 728:	00000000 	andeq	r0, r0, r0
 72c:	00000020 	andeq	r0, r0, r0, lsr #32
 730:	00000000 	andeq	r0, r0, r0
 734:	00000044 	andeq	r0, r0, r4, asr #32
 738:	00000000 	andeq	r0, r0, r0
 73c:	0000003a 	andeq	r0, r0, sl, lsr r0
 740:	00000000 	andeq	r0, r0, r0
 744:	00000006 	andeq	r0, r0, r6
 748:	00000000 	andeq	r0, r0, r0
 74c:	0000000a 	andeq	r0, r0, sl
	...
 758:	00000024 	andeq	r0, r0, r4, lsr #32
 75c:	9ab10002 	bls	fec4076c <BootRAM+0xdbb0f0d>
 760:	00040000 	andeq	r0, r4, r0
 764:	00000000 	andeq	r0, r0, r0
 768:	00005cf4 	strdeq	r5, [r0], -r4
 76c:	00000154 	andeq	r0, r0, r4, asr r1
 770:	00000000 	andeq	r0, r0, r0
 774:	00000070 	andeq	r0, r0, r0, ror r0
	...
 780:	0000001c 	andeq	r0, r0, ip, lsl r0
 784:	9c8d0002 	stcls	0, cr0, [sp], {2}
 788:	00040000 	andeq	r0, r4, r0
 78c:	00000000 	andeq	r0, r0, r0
 790:	00005e48 	andeq	r5, r0, r8, asr #28
 794:	00000038 	andeq	r0, r0, r8, lsr r0
	...
 7a0:	00000094 	muleq	r0, r4, r0
 7a4:	a08a0002 	addge	r0, sl, r2
 7a8:	00040000 	andeq	r0, r4, r0
 7ac:	00000000 	andeq	r0, r0, r0
 7b0:	00005e80 	andeq	r5, r0, r0, lsl #29
 7b4:	00000024 	andeq	r0, r0, r4, lsr #32
 7b8:	00005ea4 	andeq	r5, r0, r4, lsr #29
 7bc:	00000024 	andeq	r0, r0, r4, lsr #32
 7c0:	00005ec8 	andeq	r5, r0, r8, asr #29
 7c4:	00000090 	muleq	r0, r0, r0
 7c8:	00005f58 	andeq	r5, r0, r8, asr pc
 7cc:	000000a8 	andeq	r0, r0, r8, lsr #1
 7d0:	00006000 	andeq	r6, r0, r0
 7d4:	00000038 	andeq	r0, r0, r8, lsr r0
 7d8:	00006038 	andeq	r6, r0, r8, lsr r0
 7dc:	00000048 	andeq	r0, r0, r8, asr #32
 7e0:	00006080 	andeq	r6, r0, r0, lsl #1
 7e4:	000000d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
 7e8:	00006150 	andeq	r6, r0, r0, asr r1
 7ec:	00000084 	andeq	r0, r0, r4, lsl #1
 7f0:	000061d4 	ldrdeq	r6, [r0], -r4
 7f4:	00000024 	andeq	r0, r0, r4, lsr #32
 7f8:	000061f8 	strdeq	r6, [r0], -r8
 7fc:	0000001c 	andeq	r0, r0, ip, lsl r0
 800:	00006214 	andeq	r6, r0, r4, lsl r2
 804:	00000040 	andeq	r0, r0, r0, asr #32
 808:	00006254 	andeq	r6, r0, r4, asr r2
 80c:	000002dc 	ldrdeq	r0, [r0], -ip
 810:	00006530 	andeq	r6, r0, r0, lsr r5
 814:	000000c8 	andeq	r0, r0, r8, asr #1
 818:	000065f8 	strdeq	r6, [r0], -r8
 81c:	00000038 	andeq	r0, r0, r8, lsr r0
 820:	00006630 	andeq	r6, r0, r0, lsr r6
 824:	0000005c 	andeq	r0, r0, ip, asr r0
 828:	00000000 	andeq	r0, r0, r0
 82c:	00000002 	andeq	r0, r0, r2
	...
 838:	00000024 	andeq	r0, r0, r4, lsr #32
 83c:	ae6e0002 	cdpge	0, 6, cr0, cr14, cr2, {0}
 840:	00040000 	andeq	r0, r4, r0
 844:	00000000 	andeq	r0, r0, r0
 848:	0000668c 	andeq	r6, r0, ip, lsl #13
 84c:	00000030 	andeq	r0, r0, r0, lsr r0
 850:	000066bc 			; <UNDEFINED> instruction: 0x000066bc
 854:	00000024 	andeq	r0, r0, r4, lsr #32
	...

Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	00000078 	andeq	r0, r0, r8, ror r0
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
       4:	00000002 	andeq	r0, r0, r2
       8:	01040000 	mrseq	r0, (UNDEF: 4)
	...
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
      14:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
      18:	696c5f32 	stmdbvs	ip!, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
      1c:	5f632f62 	svcpl	0x00632f62
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
      20:	796c6e6f 	stmdbvc	ip!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
      24:	6174735f 	cmnvs	r4, pc, asr r3
      28:	70757472 	rsbsvc	r7, r5, r2, ror r4
    if ((wEPVal & EP_CTR_RX) != 0)
      2c:	4300732e 	movwmi	r7, #814	; 0x32e
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
      30:	73555c3a 	cmpvc	r5, #14848	; 0x3a00
      34:	5c737265 	lfmpl	f7, 2, [r3], #-404	; 0xfffffe6c
      38:	66696168 	strbtvs	r6, [r9], -r8, ror #2

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
      3c:	68637369 	stmdavs	r3!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}^

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
      40:	7365445c 	cmnvc	r5, #92, 8	; 0x5c000000
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
      44:	706f746b 	rsbvc	r7, pc, fp, ror #8
      48:	636e655c 	cmnvs	lr, #92, 10	; 0x17000000
      4c:	6576616c 	ldrbvs	r6, [r6, #-364]!	; 0x16c

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
      50:	6f72705f 	svcvs	0x0072705f
      54:	7463656a 	strbtvc	r6, [r3], #-1386	; 0x56a
      58:	6f6f625c 	svcvs	0x006f625c
      5c:	616f6c74 	smcvs	63172	; 0xf6c4
      60:	5c726564 	cfldr64pl	mvdx6, [r2], #-400	; 0xfffffe70
      64:	334d5453 	movtcc	r5, #54355	; 0xd453
      68:	00314632 	eorseq	r4, r1, r2, lsr r6
      6c:	20554e47 	subscs	r4, r5, r7, asr #28
      70:	32205341 	eorcc	r5, r0, #67108865	; 0x4000001
      74:	2e33322e 	cdpcs	2, 3, cr3, cr3, cr14, {1}
      78:	80010032 	andhi	r0, r1, r2, lsr r0
      7c:	0000007e 	andeq	r0, r0, lr, ror r0
      80:	00120002 	andseq	r0, r2, r2
      84:	01040000 	mrseq	r0, (UNDEF: 4)
      88:	00000075 	andeq	r0, r0, r5, ror r0
	...
      94:	74732f2e 	ldrbtvc	r2, [r3], #-3886	; 0xf2e
      98:	5f32336d 	svcpl	0x0032336d
      9c:	2f62696c 	svccs	0x0062696c
      a0:	74726f63 	ldrbtvc	r6, [r2], #-3939	; 0xf63
      a4:	336d7865 	cmncc	sp, #6619136	; 0x650000
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
      a8:	63616d5f 	cmnvs	r1, #6080	; 0x17c0

	return f25519_eq(a, c);
      ac:	532e6f72 	teqpl	lr, #456	; 0x1c8
      b0:	5c3a4300 	ldcpl	3, cr4, [sl], #-0
      b4:	72657355 	rsbvc	r7, r5, #1409286145	; 0x54000001
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
      b8:	61685c73 	smcvs	34243	; 0x85c3
	f25519_normalize(ey);
      bc:	73696669 	cmnvc	r9, #110100480	; 0x6900000
      c0:	445c6863 	ldrbmi	r6, [ip], #-2147	; 0x863

	return ok;
}
      c4:	746b7365 	strbtvc	r7, [fp], #-869	; 0x365
      c8:	655c706f 	ldrbvs	r7, [ip, #-111]	; 0x6f
      cc:	616c636e 	cmnvs	ip, lr, ror #6
      d0:	705f6576 	subsvc	r6, pc, r6, ror r5	; <UNPREDICTABLE>
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
      d4:	656a6f72 	strbvs	r6, [sl, #-3954]!	; 0xf72
      d8:	625c7463 	subsvs	r7, ip, #1660944384	; 0x63000000
		minusp[i] = c;
      dc:	6c746f6f 	ldclvs	15, cr6, [r4], #-444	; 0xfffffe44
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
      e0:	6564616f 	strbvs	r6, [r4, #-367]!	; 0x16f
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
      e4:	54535c72 	ldrbpl	r5, [r3], #-3186	; 0xc72

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
      e8:	4632334d 	ldrtmi	r3, [r2], -sp, asr #6
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
      ec:	4e470031 	mcrmi	0, 2, r0, cr7, cr1, {1}
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
      f0:	53412055 	movtpl	r2, #4181	; 0x1055
      f4:	322e3220 	eorcc	r3, lr, #32, 4
      f8:	00322e33 	eorseq	r2, r2, r3, lsr lr
      fc:	0e088001 	cdpeq	0, 0, cr8, cr8, cr1, {0}
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     100:	00040000 	andeq	r0, r4, r0

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
     104:	00000026 	andeq	r0, r0, r6, lsr #32
     108:	06390104 	ldrteq	r0, [r9], -r4, lsl #2
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     10c:	eb010000 	bl	40114 <_etext+0x38bfc>
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
     110:	93000003 	movwls	r0, #3
     114:	20000008 	andcs	r0, r0, r8
     118:	00000000 	andeq	r0, r0, r0
     11c:	1b000000 	blne	124 <_Minimum_Stack_Size+0x24>
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     120:	02000001 	andeq	r0, r0, #1
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
     124:	02570704 	subseq	r0, r7, #4, 14	; 0x100000
     128:	04030000 	streq	r0, [r3], #-0
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
     12c:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
     130:	06010200 	streq	r0, [r1], -r0, lsl #4
	i <<= 3;

	while (x) {
     134:	0000081a 	andeq	r0, r0, sl, lsl r8
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
     138:	18080102 	stmdane	r8, {r1, r8}
     13c:	02000008 	andeq	r0, r0, #8
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
     140:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
	f25519_mul_c(z3, x1sq, 4);
     144:	02020000 	andeq	r0, r2, #0
     148:	00094907 	andeq	r4, r9, r7, lsl #18
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	05040200 	streq	r0, [r4, #-512]	; 0x200
     150:	000004da 	ldrdeq	r0, [r0], -sl
     154:	52070402 	andpl	r0, r7, #33554432	; 0x2000000
	f25519_sub(b, x3, z3); /* D */
     158:	02000002 	andeq	r0, r0, #2
     15c:	04d50508 	ldrbeq	r0, [r5], #1288	; 0x508
	f25519_mul__distinct(da, a, b);
     160:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
     164:	00024d07 	andeq	r4, r2, r7, lsl #26
     168:	07040200 	streq	r0, [r4, -r0, lsl #4]

	f25519_sub(b, x2, z2);
     16c:	0000078b 	andeq	r0, r0, fp, lsl #15
     170:	00780404 	rsbseq	r0, r8, r4, lsl #8
	f25519_add(a, x3, z3); /* C */
     174:	02050000 	andeq	r0, r5, #0
     178:	08210801 	stmdaeq	r1!, {r0, fp}
     17c:	75060000 	strvc	r0, [r6, #-0]
	f25519_mul__distinct(cb, a, b);
     180:	02003233 	andeq	r3, r0, #805306371	; 0x30000003
     184:	00005627 	andeq	r5, r0, r7, lsr #12

	f25519_add(a, da, cb);
     188:	31750600 	cmncc	r5, r0, lsl #12
     18c:	28020036 	stmdacs	r2, {r1, r2, r4, r5}
     190:	00000048 	andeq	r0, r0, r8, asr #32
	f25519_mul__distinct(b, a, a);
     194:	00387506 	eorseq	r7, r8, r6, lsl #10
     198:	003a2902 	eorseq	r2, sl, r2, lsl #18
	f25519_mul__distinct(x5, z1, b);
     19c:	5a070000 	bpl	1c01a4 <_etext+0x1b8c8c>
     1a0:	02000003 	andeq	r0, r0, #3
     1a4:	0000ab2f 	andeq	sl, r0, pc, lsr #22

	f25519_sub(a, da, cb);
     1a8:	00560800 	subseq	r0, r6, r0, lsl #16
     1ac:	e3070000 	movw	r0, #28672	; 0x7000
	f25519_mul__distinct(b, a, a);
     1b0:	02000001 	andeq	r0, r0, #1
     1b4:	0000bb30 	andeq	fp, r0, r0, lsr fp
     1b8:	00480800 	subeq	r0, r8, r0, lsl #16

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	76060000 	strvc	r0, [r6], -r0
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	02003875 	andeq	r3, r0, #7667712	; 0x750000
     1c4:	0000cb31 	andeq	ip, r0, r1, lsr fp

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1c8:	003a0800 	eorseq	r0, sl, r0, lsl #16
     1cc:	01090000 	mrseq	r0, (UNDEF: 9)
     1d0:	00e53702 	rsceq	r3, r5, r2, lsl #14
     1d4:	530a0000 	movwpl	r0, #40960	; 0xa000
		f25519_select(zm1, zm1, zm, bit);
     1d8:	00000007 	andeq	r0, r0, r7
     1dc:	0001a70a 	andeq	sl, r1, sl, lsl #14
     1e0:	07000100 	streq	r0, [r0, -r0, lsl #2]
		f25519_select(xm, xm, xms, bit);
     1e4:	0000052d 	andeq	r0, r0, sp, lsr #10
     1e8:	00d03702 	sbcseq	r3, r0, r2, lsl #14
     1ec:	040b0000 	streq	r0, [fp], #-0
		f25519_select(zm, zm, zms, bit);
     1f0:	0129ae03 	teqeq	r9, r3, lsl #28
     1f4:	b60c0000 	strlt	r0, [ip], -r0
     1f8:	03000005 	movweq	r0, #5
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fc:	000096af 	andeq	r9, r0, pc, lsr #13
     200:	700c0000 	andvc	r0, ip, r0
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     204:	03000009 	movweq	r0, #9
     208:	000096b0 			; <UNDEFINED> instruction: 0x000096b0
	f25519_mul__distinct(result, zm1, xm);
     20c:	dd0c0100 	stfles	f0, [ip, #-0]
     210:	03000008 	movweq	r0, #8
	f25519_normalize(result);
     214:	000096b1 			; <UNDEFINED> instruction: 0x000096b1
     218:	960c0200 	strls	r0, [ip], -r0, lsl #4
}
     21c:	03000003 	movweq	r0, #3
     220:	0000e5b2 			; <UNDEFINED> instruction: 0x0000e5b2
     224:	07000300 	streq	r0, [r0, -r0, lsl #6]
     228:	000001f5 	strdeq	r0, [r0], -r5
     22c:	00f0b303 	rscseq	fp, r0, r3, lsl #6
     230:	280b0000 	stmdacs	fp, {}	; <UNPREDICTABLE>
     234:	01b4d903 			; <UNDEFINED> instruction: 0x01b4d903
     238:	430d0000 	movwmi	r0, #53248	; 0xd000
     23c:	da030052 	ble	c038c <_etext+0xb8e74>
     240:	000000a0 	andeq	r0, r0, r0, lsr #1
     244:	07590c00 	ldrbeq	r0, [r9, -r0, lsl #24]
     248:	db030000 	blle	c0250 <_etext+0xb8d38>
     24c:	000000a0 	andeq	r0, r0, r0, lsr #1
     250:	49430d04 	stmdbmi	r3, {r2, r8, sl, fp}^
     254:	dc030052 	stcle	0, cr0, [r3], {82}	; 0x52
     258:	000000a0 	andeq	r0, r0, r0, lsr #1
     25c:	002a0c08 	eoreq	r0, sl, r8, lsl #24
     260:	dd030000 	stcle	0, cr0, [r3, #-0]
     264:	000000a0 	andeq	r0, r0, r0, lsr #1
     268:	00f10c0c 	rscseq	r0, r1, ip, lsl #24
     26c:	de030000 	cdple	0, 0, cr0, cr3, cr0, {0}
     270:	000000a0 	andeq	r0, r0, r0, lsr #1
     274:	04450c10 	strbeq	r0, [r5], #-3088	; 0xc10
     278:	df030000 	svcle	0x00030000
     27c:	000000a0 	andeq	r0, r0, r0, lsr #1
     280:	05ef0c14 	strbeq	r0, [pc, #3092]!	; e9c <usbPowerOn+0x2c>
     284:	e0030000 	and	r0, r3, r0
     288:	000000a0 	andeq	r0, r0, r0, lsr #1
     28c:	00000c18 	andeq	r0, r0, r8, lsl ip
     290:	e1030000 	mrs	r0, (UNDEF: 3)
     294:	000000a0 	andeq	r0, r0, r0, lsr #1
     298:	061a0c1c 			; <UNDEFINED> instruction: 0x061a0c1c
     29c:	e2030000 	and	r0, r3, #0
     2a0:	000000a0 	andeq	r0, r0, r0, lsr #1
     2a4:	53430d20 	movtpl	r0, #15648	; 0x3d20
     2a8:	e3030052 	movw	r0, #12370	; 0x3052
     2ac:	000000a0 	andeq	r0, r0, r0, lsr #1
     2b0:	33070024 	movwcc	r0, #28708	; 0x7024
     2b4:	03000003 	movweq	r0, #3
     2b8:	000134e4 	andeq	r3, r1, r4, ror #9
     2bc:	023d0e00 	eorseq	r0, sp, #0, 28
     2c0:	05010000 	streq	r0, [r1, #-0]
     2c4:	0001e416 	andeq	lr, r1, r6, lsl r4
     2c8:	05320a00 	ldreq	r0, [r2, #-2560]!	; 0xa00
     2cc:	0a000000 	beq	2d4 <GPIO_ReadOutputDataBit+0x8>
     2d0:	00000724 	andeq	r0, r0, r4, lsr #14
     2d4:	017e0a01 	cmneq	lr, r1, lsl #20
     2d8:	0a020000 	beq	802e0 <_etext+0x78dc8>
     2dc:	00000920 	andeq	r0, r0, r0, lsr #18
     2e0:	330f0003 	movwcc	r0, #61443	; 0xf003
     2e4:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
     2e8:	02092404 	andeq	r2, r9, #4, 8	; 0x4000000
     2ec:	e00c0000 	and	r0, ip, r0
     2f0:	04000002 	streq	r0, [r0], #-2
     2f4:	00020926 	andeq	r0, r2, r6, lsr #18
     2f8:	f10c0000 	cpsid	
     2fc:	04000003 	streq	r0, [r0], #-3
     300:	00008b27 	andeq	r8, r0, r7, lsr #22
     304:	04000400 	streq	r0, [r0], #-1024	; 0x400
     308:	00009604 	andeq	r9, r0, r4, lsl #12
     30c:	05720700 	ldrbeq	r0, [r2, #-1792]!	; 0x700
     310:	29040000 	stmdbcs	r4, {}	; <UNPREDICTABLE>
     314:	000001e4 	andeq	r0, r0, r4, ror #3
     318:	00057107 	andeq	r7, r5, r7, lsl #2
     31c:	25290400 	strcs	r0, [r9, #-1024]!	; 0x400
     320:	04000002 	streq	r0, [r0], #-2
     324:	0001e404 	andeq	lr, r1, r4, lsl #8
     328:	07c00e00 	strbeq	r0, [r0, r0, lsl #28]
     32c:	04010000 	streq	r0, [r1], #-0
     330:	0002502d 	andeq	r5, r2, sp, lsr #32
     334:	02860a00 	addeq	r0, r6, #0, 20
     338:	0a000000 	beq	340 <GPIO_PinRemapConfig+0xc>
     33c:	000009a9 	andeq	r0, r0, r9, lsr #19
     340:	01300a01 	teqeq	r0, r1, lsl #20
     344:	0a020000 	beq	8034c <_etext+0x78e34>
     348:	0000062b 	andeq	r0, r0, fp, lsr #12
     34c:	c1070003 	tstgt	r7, r3
     350:	04000007 	streq	r0, [r0], #-7
     354:	00022b34 	andeq	r2, r2, r4, lsr fp
     358:	05ff0f00 	ldrbeq	r0, [pc, #3840]!	; 1260 <uartInit+0x34>
     35c:	040c0000 	streq	r0, [ip], #-0
     360:	00029838 	andeq	r9, r2, r8, lsr r8
     364:	01d70c00 	bicseq	r0, r7, r0, lsl #24
     368:	50040000 	andpl	r0, r4, r0
     36c:	0000008b 	andeq	r0, r0, fp, lsl #1
     370:	086d0c00 	stmdaeq	sp!, {sl, fp}^
     374:	51040000 	mrspl	r0, (UNDEF: 4)
     378:	0000008b 	andeq	r0, r0, fp, lsl #1
     37c:	213a0c02 	teqcs	sl, r2, lsl #24
     380:	52040000 	andpl	r0, r4, #0
     384:	0000008b 	andeq	r0, r0, fp, lsl #1
     388:	07380c04 	ldreq	r0, [r8, -r4, lsl #24]!
     38c:	53040000 	movwpl	r0, #16384	; 0x4000
     390:	000002a7 	andeq	r0, r0, r7, lsr #5
     394:	09100008 	ldmdbeq	r0, {r3}
     398:	a7000002 	strge	r0, [r0, -r2]
     39c:	11000002 	tstne	r0, r2
     3a0:	0000008b 	andeq	r0, r0, fp, lsl #1
     3a4:	98040400 	stmdals	r4, {sl}
     3a8:	07000002 	streq	r0, [r0, -r2]
     3ac:	00000600 	andeq	r0, r0, r0, lsl #12
     3b0:	025b5404 	subseq	r5, fp, #4, 8	; 0x4000000
     3b4:	230f0000 	movwcs	r0, #61440	; 0xf000
     3b8:	02000006 	andeq	r0, r0, #6
     3bc:	02dd5804 	sbcseq	r5, sp, #4, 16	; 0x40000
     3c0:	700c0000 	andvc	r0, ip, r0
     3c4:	04000003 	streq	r0, [r0], #-3
     3c8:	0000965a 	andeq	r9, r0, sl, asr r6
     3cc:	8c0c0000 	stchi	0, cr0, [ip], {-0}
     3d0:	04000005 	streq	r0, [r0], #-5
     3d4:	0000965b 	andeq	r9, r0, fp, asr r6
     3d8:	07000100 	streq	r0, [r0, -r0, lsl #2]
     3dc:	00000624 	andeq	r0, r0, r4, lsr #12
     3e0:	02b85d04 	adcseq	r5, r8, #4, 26	; 0x100
     3e4:	42120000 	andsmi	r0, r2, #0
     3e8:	04020057 	streq	r0, [r2], #-87	; 0x57
     3ec:	00030c62 	andeq	r0, r3, r2, ror #24
     3f0:	62620d00 	rsbvs	r0, r2, #0, 26
     3f4:	65040030 	strvs	r0, [r4, #-48]	; 0x30
     3f8:	00000096 	muleq	r0, r6, r0
     3fc:	62620d00 	rsbvs	r0, r2, #0, 26
     400:	66040031 			; <UNDEFINED> instruction: 0x66040031
     404:	00000096 	muleq	r0, r6, r0
     408:	02130001 	andseq	r0, r3, #1
     40c:	03285f04 	teqeq	r8, #4, 30
     410:	77140000 	ldrvc	r0, [r4, -r0]
     414:	8b610400 	blhi	184141c <_etext+0x1839f04>
     418:	14000000 	strne	r0, [r0], #-0
     41c:	04007762 	streq	r7, [r0], #-1890	; 0x762
     420:	0002e868 	andeq	lr, r2, r8, ror #16
     424:	30070000 	andcc	r0, r7, r0
     428:	04000009 	streq	r0, [r0], #-9
     42c:	00030c69 	andeq	r0, r3, r9, ror #24
     430:	01140f00 	tsteq	r4, r0, lsl #30
     434:	041c0000 	ldreq	r0, [ip], #-0
     438:	0003c46b 	andeq	ip, r3, fp, ror #8
     43c:	07670c00 	strbeq	r0, [r7, -r0, lsl #24]!
     440:	6d040000 	stcvs	0, cr0, [r4, #-0]
     444:	00000096 	muleq	r0, r6, r0
     448:	00150c00 	andseq	r0, r5, r0, lsl #24
     44c:	6e040000 	cdpvs	0, 0, cr0, cr4, cr0, {0}
     450:	00000096 	muleq	r0, r6, r0
     454:	03110c01 	tsteq	r1, #256	; 0x100
     458:	6f040000 	svcvs	0x00040000
     45c:	00000328 	andeq	r0, r0, r8, lsr #6
     460:	01480c02 	cmpeq	r8, r2, lsl #24
     464:	70040000 	andvc	r0, r4, r0
     468:	00000328 	andeq	r0, r0, r8, lsr #6
     46c:	04eb0c04 	strbteq	r0, [fp], #3076	; 0xc04
     470:	71040000 	mrsvc	r0, (UNDEF: 4)
     474:	00000328 	andeq	r0, r0, r8, lsr #6
     478:	06ef0c06 	strbteq	r0, [pc], r6, lsl #24
     47c:	73040000 	movwvc	r0, #16384	; 0x4000
     480:	00000096 	muleq	r0, r6, r0
     484:	08080c08 	stmdaeq	r8, {r3, sl, fp}
     488:	74040000 	strvc	r0, [r4], #-0
     48c:	00000096 	muleq	r0, r6, r0
     490:	05070c09 	streq	r0, [r7, #-3081]	; 0xc09
     494:	75040000 	strvc	r0, [r4, #-0]
     498:	00000096 	muleq	r0, r6, r0
     49c:	054f0c0a 	strbeq	r0, [pc, #-3082]	; fffff89a <BootRAM+0xef7003b>
     4a0:	76040000 	strvc	r0, [r4], -r0
     4a4:	00000096 	muleq	r0, r6, r0
     4a8:	05d60c0b 	ldrbeq	r0, [r6, #3083]	; 0xc0b
     4ac:	77040000 	strvc	r0, [r4, -r0]
     4b0:	00000096 	muleq	r0, r6, r0
     4b4:	07c80c0c 	strbeq	r0, [r8, ip, lsl #24]
     4b8:	7a040000 	bvc	1004c0 <_etext+0xf8fa8>
     4bc:	000002ad 	andeq	r0, r0, sp, lsr #5
     4c0:	15070010 	strne	r0, [r7, #-16]
     4c4:	04000001 	streq	r0, [r0], #-1
     4c8:	0003337b 	andeq	r3, r3, fp, ror r3
     4cc:	03a90f00 			; <UNDEFINED> instruction: 0x03a90f00
     4d0:	04340000 	ldrteq	r0, [r4], #-0
     4d4:	0004787d 	andeq	r7, r4, sp, ror r8
     4d8:	02960c00 	addseq	r0, r6, #0, 24
     4dc:	7f040000 	svcvc	0x00040000
     4e0:	00000072 	andeq	r0, r0, r2, ror r0
     4e4:	04b80c00 	ldrteq	r0, [r8], #3072	; 0xc00
     4e8:	80040000 	andhi	r0, r4, r0
     4ec:	00000072 	andeq	r0, r0, r2, ror r0
     4f0:	09370c04 	ldmdbeq	r7!, {r2, sl, fp}
     4f4:	83040000 	movwhi	r0, #16384	; 0x4000
     4f8:	00000072 	andeq	r0, r0, r2, ror r0
     4fc:	07780c08 	ldrbeq	r0, [r8, -r8, lsl #24]!
     500:	84040000 	strhi	r0, [r4], #-0
     504:	00000072 	andeq	r0, r0, r2, ror r0
     508:	02c30c0c 	sbceq	r0, r3, #12, 24	; 0xc00
     50c:	96040000 	strls	r0, [r4], -r0
     510:	00000487 	andeq	r0, r0, r7, lsl #9
     514:	006d0c10 	rsbeq	r0, sp, r0, lsl ip
     518:	a1040000 	mrsge	r0, (UNDEF: 4)
     51c:	00000487 	andeq	r0, r0, r7, lsl #9
     520:	09c50c14 	stmibeq	r5, {r2, r4, sl, fp}^
     524:	ab040000 	blge	10052c <_etext+0xf9014>
     528:	000004a1 	andeq	r0, r0, r1, lsr #9
     52c:	02d70c18 	sbcseq	r0, r7, #24, 24	; 0x1800
     530:	ad040000 	stcge	0, cr0, [r4, #-0]
     534:	000002a7 	andeq	r0, r0, r7, lsr #5
     538:	03b90c1c 			; <UNDEFINED> instruction: 0x03b90c1c
     53c:	ae040000 	cdpge	0, 0, cr0, cr4, cr0, {0}
     540:	000002a7 	andeq	r0, r0, r7, lsr #5
     544:	01c30c20 	biceq	r0, r3, r0, lsr #24
     548:	af040000 	svcge	0x00040000
     54c:	000002a7 	andeq	r0, r0, r7, lsr #5
     550:	03420c24 	movteq	r0, #11300	; 0x2c24
     554:	b0040000 	andlt	r0, r4, r0
     558:	000002a7 	andeq	r0, r0, r7, lsr #5
     55c:	04670c28 	strbteq	r0, [r7], #-3112	; 0xc28
     560:	b2040000 	andlt	r0, r4, #0
     564:	00000209 	andeq	r0, r0, r9, lsl #4
     568:	21370c2c 	teqcs	r7, ip, lsr #24
     56c:	b3040000 	movwlt	r0, #16384	; 0x4000
     570:	00000096 	muleq	r0, r6, r0
     574:	50100030 	andspl	r0, r0, r0, lsr r0
     578:	87000002 	strhi	r0, [r0, -r2]
     57c:	11000004 	tstne	r0, r4
     580:	00000096 	muleq	r0, r6, r0
     584:	78040400 	stmdavc	r4, {sl}
     588:	10000004 	andne	r0, r0, r4
     58c:	00000250 	andeq	r0, r0, r0, asr r2
     590:	000004a1 	andeq	r0, r0, r1, lsr #9
     594:	00009611 	andeq	r9, r0, r1, lsl r6
     598:	00961100 	addseq	r1, r6, r0, lsl #2
     59c:	04000000 	streq	r0, [r0], #-0
     5a0:	00048d04 	andeq	r8, r4, r4, lsl #26
     5a4:	03aa0700 			; <UNDEFINED> instruction: 0x03aa0700
     5a8:	b5040000 	strlt	r0, [r4, #-0]
     5ac:	000003cf 	andeq	r0, r0, pc, asr #7
     5b0:	00008a0f 	andeq	r8, r0, pc, lsl #20
     5b4:	b7042400 	strlt	r2, [r4, -r0, lsl #8]
     5b8:	0000052b 	andeq	r0, r0, fp, lsr #10
     5bc:	0005a00c 	andeq	sl, r5, ip
     5c0:	72b90400 	adcsvc	r0, r9, #0, 8
     5c4:	00000000 	andeq	r0, r0, r0
     5c8:	00041d0c 	andeq	r1, r4, ip, lsl #26
     5cc:	72ba0400 	adcsvc	r0, sl, #0, 8
     5d0:	04000000 	streq	r0, [r0], #-0
     5d4:	00029b0c 	andeq	r9, r2, ip, lsl #22
     5d8:	72bb0400 	adcsvc	r0, fp, #0, 8
     5dc:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
     5e0:	0004330c 	andeq	r3, r4, ip, lsl #6
     5e4:	72bc0400 	adcsvc	r0, ip, #0, 8
     5e8:	0c000000 	stceq	0, cr0, [r0], {-0}
     5ec:	0000a20c 	andeq	sl, r0, ip, lsl #4
     5f0:	72bd0400 	adcsvc	r0, sp, #0, 8
     5f4:	10000000 	andne	r0, r0, r0
     5f8:	0007410c 	andeq	r4, r7, ip, lsl #2
     5fc:	72be0400 	adcsvc	r0, lr, #0, 8
     600:	14000000 	strne	r0, [r0], #-0
     604:	0008f80c 	andeq	pc, r8, ip, lsl #16
     608:	72bf0400 	adcsvc	r0, pc, #0, 8
     60c:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
     610:	0001910c 	andeq	r9, r1, ip, lsl #2
     614:	72c00400 	sbcvc	r0, r0, #0, 8
     618:	1c000000 	stcne	0, cr0, [r0], {-0}
     61c:	0002ad0c 	andeq	sl, r2, ip, lsl #26
     620:	72c10400 	sbcvc	r0, r1, #0, 8
     624:	20000000 	andcs	r0, r0, r0
     628:	008b0700 	addeq	r0, fp, r0, lsl #14
     62c:	c3040000 	movwgt	r0, #16384	; 0x4000
     630:	000004b2 			; <UNDEFINED> instruction: 0x000004b2
     634:	0000fa0e 	andeq	pc, r0, lr, lsl #20
     638:	3d060100 	stfccs	f0, [r6, #-0]
     63c:	00000573 	andeq	r0, r0, r3, ror r5
     640:	0005c60a 	andeq	ip, r5, sl, lsl #12
     644:	570a0000 	strpl	r0, [sl, -r0]
     648:	01000004 	tsteq	r0, r4
     64c:	0000080a 	andeq	r0, r0, sl, lsl #16
     650:	670a0200 	strvs	r0, [sl, -r0, lsl #4]
     654:	03000001 	movweq	r0, #1
     658:	0008d00a 	andeq	sp, r8, sl
     65c:	8c0a0400 	cfstrshi	mvf0, [sl], {-0}
     660:	05000003 	streq	r0, [r0, #-3]
     664:	0004ca0a 	andeq	ip, r4, sl, lsl #20
     668:	1c0a0600 	stcne	6, cr0, [sl], {-0}
     66c:	07000003 	streq	r0, [r0, -r3]
     670:	00fb0700 	rscseq	r0, fp, r0, lsl #14
     674:	46060000 	strmi	r0, [r6], -r0
     678:	00000536 	andeq	r0, r0, r6, lsr r5
     67c:	0008790e 	andeq	r7, r8, lr, lsl #18
     680:	48060100 	stmdami	r6, {r8}
     684:	000005af 	andeq	r0, r0, pc, lsr #11
     688:	0008870a 	andeq	r8, r8, sl, lsl #14
     68c:	5c0a0000 	stcpl	0, cr0, [sl], {-0}
     690:	01000009 	tsteq	r0, r9
     694:	0004e30a 	andeq	lr, r4, sl, lsl #6
     698:	920a0200 	andls	r0, sl, #0, 4
     69c:	03000009 	movweq	r0, #9
     6a0:	0003cd0a 	andeq	ip, r3, sl, lsl #26
     6a4:	f70a0400 			; <UNDEFINED> instruction: 0xf70a0400
     6a8:	05000007 	streq	r0, [r0, #-7]
     6ac:	087a0700 	ldmdaeq	sl!, {r8, r9, sl}^
     6b0:	4f060000 	svcmi	0x00060000
     6b4:	0000057e 	andeq	r0, r0, lr, ror r5
     6b8:	6301020b 	movwvs	r0, #4619	; 0x120b
     6bc:	000005db 	ldrdeq	r0, [r0], -fp
     6c0:	0003010c 	andeq	r0, r3, ip, lsl #2
     6c4:	db640100 	blle	1900acc <_etext+0x18f95b4>
     6c8:	00000005 	andeq	r0, r0, r5
     6cc:	0003080c 	andeq	r0, r3, ip, lsl #16
     6d0:	e0650100 	rsb	r0, r5, r0, lsl #2
     6d4:	01000005 	tsteq	r0, r5
     6d8:	05730800 	ldrbeq	r0, [r3, #-2048]!	; 0x800
     6dc:	96080000 	strls	r0, [r8], -r0
     6e0:	15000000 	strne	r0, [r0, #-0]
     6e4:	00000121 	andeq	r0, r0, r1, lsr #2
     6e8:	50018801 	andpl	r8, r1, r1, lsl #16
     6ec:	01000002 	tsteq	r0, r2
     6f0:	00000603 	andeq	r0, r0, r3, lsl #12
     6f4:	0005f716 	andeq	pc, r5, r6, lsl r7	; <UNPREDICTABLE>
     6f8:	01880100 	orreq	r0, r8, r0, lsl #2
     6fc:	00000096 	muleq	r0, r6, r0
     700:	03281700 	teqeq	r8, #0, 14
     704:	ad010000 	stcge	0, cr0, [r1, #-0]
     708:	01081801 	tsteq	r8, r1, lsl #16
     70c:	a7010000 	strge	r0, [r1, -r0]
     710:	00000b98 	muleq	r0, r8, fp
     714:	00000002 	andeq	r0, r0, r2
     718:	be199c01 	cdplt	12, 1, cr9, cr9, cr1, {0}
     71c:	01000004 	tsteq	r0, r4
     720:	0b9a0157 	bleq	fe680c84 <BootRAM+0xd5f1425>
     724:	00020000 	andeq	r0, r2, r0
     728:	9c010000 	stcls	0, cr0, [r1], {-0}
     72c:	00049a19 	andeq	r9, r4, r9, lsl sl
     730:	015c0100 	cmpeq	ip, r0, lsl #2
     734:	00000b9c 	muleq	r0, ip, fp
     738:	00000002 	andeq	r0, r0, r2
     73c:	da1a9c01 	ble	6a7748 <_etext+0x6a0230>
     740:	01000000 	mrseq	r0, (UNDEF: 0)
     744:	02500193 	subseq	r0, r0, #-1073741788	; 0xc0000024
     748:	0b9e0000 	bleq	fe780750 <BootRAM+0xd6f0ef1>
     74c:	000a0000 	andeq	r0, sl, r0
     750:	9c010000 	stcls	0, cr0, [r1], {-0}
     754:	00000679 	andeq	r0, r0, r9, ror r6
     758:	0000631b 	andeq	r6, r0, fp, lsl r3
     75c:	01930100 	orrseq	r0, r3, r0, lsl #2
     760:	00000096 	muleq	r0, r6, r0
     764:	00000000 	andeq	r0, r0, r0
     768:	0001731c 	andeq	r7, r1, ip, lsl r3
     76c:	01930100 	orrseq	r0, r3, r0, lsl #2
     770:	00000096 	muleq	r0, r6, r0
     774:	19005101 	stmdbne	r0, {r0, r8, ip, lr}
     778:	00000206 	andeq	r0, r0, r6, lsl #4
     77c:	a801bf01 	stmdage	r1, {r0, r8, r9, sl, fp, ip, sp, pc}
     780:	0200000b 	andeq	r0, r0, #11
     784:	01000000 	mrseq	r0, (UNDEF: 0)
     788:	0153199c 			; <UNDEFINED> instruction: 0x0153199c
     78c:	c4010000 	strgt	r0, [r1], #-0
     790:	000bac01 	andeq	sl, fp, r1, lsl #24
     794:	00001800 	andeq	r1, r0, r0, lsl #16
     798:	199c0100 	ldmibne	ip, {r8}
     79c:	00000706 	andeq	r0, r0, r6, lsl #14
     7a0:	c401cb01 	strgt	ip, [r1], #-2817	; 0xb01
     7a4:	0200000b 	andeq	r0, r0, #11
     7a8:	01000000 	mrseq	r0, (UNDEF: 0)
     7ac:	04f7199c 	ldrbteq	r1, [r7], #2460	; 0x99c
     7b0:	d0010000 	andle	r0, r1, r0
     7b4:	000bc601 	andeq	ip, fp, r1, lsl #12
     7b8:	00000200 	andeq	r0, r0, r0, lsl #4
     7bc:	199c0100 	ldmibne	ip, {r8}
     7c0:	0000084c 	andeq	r0, r0, ip, asr #16
     7c4:	c801d501 	stmdagt	r1, {r0, r8, sl, ip, lr, pc}
     7c8:	0200000b 	andeq	r0, r0, #11
     7cc:	01000000 	mrseq	r0, (UNDEF: 0)
     7d0:	0910199c 	ldmdbeq	r0, {r2, r3, r4, r7, r8, fp, ip}
     7d4:	da010000 	ble	407dc <_etext+0x392c4>
     7d8:	000bca01 	andeq	ip, fp, r1, lsl #20
     7dc:	00000200 	andeq	r0, r0, r0, lsl #4
     7e0:	199c0100 	ldmibne	ip, {r8}
     7e4:	00000227 	andeq	r0, r0, r7, lsr #4
     7e8:	cc01df01 	stcgt	15, cr13, [r1], {1}
     7ec:	0200000b 	andeq	r0, r0, #11
     7f0:	01000000 	mrseq	r0, (UNDEF: 0)
     7f4:	0859199c 	ldmdaeq	r9, {r2, r3, r4, r7, r8, fp, ip}^
     7f8:	e4010000 	str	r0, [r1], #-0
     7fc:	000bce01 	andeq	ip, fp, r1, lsl #28
     800:	00000200 	andeq	r0, r0, r0, lsl #4
     804:	199c0100 	ldmibne	ip, {r8}
     808:	000001ac 	andeq	r0, r0, ip, lsr #3
     80c:	d001e901 	andle	lr, r1, r1, lsl #18
     810:	0c00000b 	stceq	0, cr0, [r0], {11}
     814:	01000000 	mrseq	r0, (UNDEF: 0)
     818:	04b51d9c 	ldrteq	r1, [r5], #3484	; 0xd9c
     81c:	3d010000 	stccc	0, cr0, [r1, #-0]
     820:	000bdc01 	andeq	sp, fp, r1, lsl #24
     824:	0000a800 	andeq	sl, r0, r0, lsl #16
     828:	a49c0100 	ldrge	r0, [ip], #256	; 0x100
     82c:	1e000007 	cdpne	0, 0, cr0, cr0, cr7, {0}
     830:	00000c0c 	andeq	r0, r0, ip, lsl #24
     834:	00000012 	andeq	r0, r0, r2, lsl r0
     838:	0000074f 	andeq	r0, r0, pc, asr #14
     83c:	00075e1f 	andeq	r5, r7, pc, lsl lr
     840:	01480100 	mrseq	r0, (UNDEF: 88)
     844:	0000008b 	andeq	r0, r0, fp, lsl #1
     848:	00000021 	andeq	r0, r0, r1, lsr #32
     84c:	0be22000 	bleq	ff888854 <BootRAM+0xe7f8ff5>
     850:	0d280000 	stceq	0, cr0, [r8, #-0]
     854:	42210000 	eormi	r0, r1, #0
     858:	2f00000c 	svccs	0x0000000c
     85c:	6c00000d 	stcvs	0, cr0, [r0], {13}
     860:	22000007 	andcs	r0, r0, #7
     864:	74025001 	strvc	r5, [r2], #-1
     868:	50210000 	eorpl	r0, r1, r0
     86c:	4100000c 	tstmi	r0, ip
     870:	8000000d 	andhi	r0, r0, sp
     874:	22000007 	andcs	r0, r0, #7
     878:	74025001 	strvc	r5, [r2], #-1
     87c:	56210000 	strtpl	r0, [r1], -r0
     880:	5800000c 	stmdapl	r0, {r2, r3}
     884:	9400000d 	strls	r0, [r0], #-13
     888:	22000007 	andcs	r0, r0, #7
     88c:	74025001 	strvc	r5, [r2], #-1
     890:	66230000 	strtvs	r0, [r3], -r0
     894:	6a00000c 	bvs	8cc <USART_ClockInit+0x10>
     898:	2200000d 	andcs	r0, r0, #13
     89c:	30015001 	andcc	r5, r1, r1
     8a0:	ea1a0000 	b	6808a8 <_etext+0x679390>
     8a4:	01000007 	tsteq	r0, r7
     8a8:	02500161 	subseq	r0, r0, #1073741848	; 0x40000018
     8ac:	0c840000 	stceq	0, cr0, [r4], {0}
     8b0:	00600000 	rsbeq	r0, r0, r0
     8b4:	9c010000 	stcls	0, cr0, [r1], {-0}
     8b8:	000007f4 	strdeq	r0, [r0], -r4
     8bc:	0005f71b 	andeq	pc, r5, fp, lsl r7	; <UNPREDICTABLE>
     8c0:	01610100 	cmneq	r1, r0, lsl #2
     8c4:	00000096 	muleq	r0, r6, r0
     8c8:	00000070 	andeq	r0, r0, r0, ror r0
     8cc:	00060e1f 	andeq	r0, r6, pc, lsl lr
     8d0:	01620100 	cmneq	r2, r0, lsl #2
     8d4:	000002a7 	andeq	r0, r0, r7, lsr #5
     8d8:	00000091 	muleq	r0, r1, r0
     8dc:	000c9c20 	andeq	r9, ip, r0, lsr #24
     8e0:	000d7b00 	andeq	r7, sp, r0, lsl #22
     8e4:	0cc82400 	cfstrdeq	mvd2, [r8], {0}
     8e8:	01220000 	teqeq	r2, r0
     8ec:	00740250 	rsbseq	r0, r4, r0, asr r2
     8f0:	d41a0000 	ldrle	r0, [sl], #-0
     8f4:	01000002 	tsteq	r0, r2
     8f8:	0209019d 	andeq	r0, r9, #1073741863	; 0x40000027
     8fc:	0ce40000 	stcleq	0, cr0, [r4]
     900:	000c0000 	andeq	r0, ip, r0
     904:	9c010000 	stcls	0, cr0, [r1], {-0}
     908:	00000828 	andeq	r0, r0, r8, lsr #16
     90c:	6e656c25 	cdpvs	12, 6, cr6, cr5, cr5, {1}
     910:	019d0100 	orrseq	r0, sp, r0, lsl #2
     914:	0000008b 	andeq	r0, r0, fp, lsl #1
     918:	000000c8 	andeq	r0, r0, r8, asr #1
     91c:	000cea26 	andeq	lr, ip, r6, lsr #20
     920:	000d8600 	andeq	r8, sp, r0, lsl #12
     924:	b61a0000 	ldrlt	r0, [sl], -r0
     928:	01000003 	tsteq	r0, r3
     92c:	020901a2 	andeq	r0, r9, #-2147483608	; 0x80000028
     930:	0cf00000 	ldcleq	0, cr0, [r0]
     934:	000c0000 	andeq	r0, ip, r0
     938:	9c010000 	stcls	0, cr0, [r1], {-0}
     93c:	0000085c 	andeq	r0, r0, ip, asr r8
     940:	6e656c25 	cdpvs	12, 6, cr6, cr5, cr5, {1}
     944:	01a20100 			; <UNDEFINED> instruction: 0x01a20100
     948:	0000008b 	andeq	r0, r0, fp, lsl #1
     94c:	000000e9 	andeq	r0, r0, r9, ror #1
     950:	000cf626 	andeq	pc, ip, r6, lsr #12
     954:	000d8600 	andeq	r8, sp, r0, lsl #12
     958:	c01a0000 	andsgt	r0, sl, r0
     95c:	01000001 	tsteq	r0, r1
     960:	020901a7 	andeq	r0, r9, #-1073741783	; 0xc0000029
     964:	0cfc0000 	ldcleq	0, cr0, [ip]
     968:	00200000 	eoreq	r0, r0, r0
     96c:	9c010000 	stcls	0, cr0, [r1], {-0}
     970:	0000089c 	muleq	r0, ip, r8
     974:	6e656c25 	cdpvs	12, 6, cr6, cr5, cr5, {1}
     978:	01a70100 			; <UNDEFINED> instruction: 0x01a70100
     97c:	0000008b 	andeq	r0, r0, fp, lsl #1
     980:	0000010a 	andeq	r0, r0, sl, lsl #2
     984:	00002127 	andeq	r2, r0, r7, lsr #2
     988:	01a90100 			; <UNDEFINED> instruction: 0x01a90100
     98c:	00000096 	muleq	r0, r6, r0
     990:	000d1026 	andeq	r1, sp, r6, lsr #32
     994:	000d8600 	andeq	r8, sp, r0, lsl #12
     998:	3f1a0000 	svccc	0x001a0000
     99c:	01000003 	tsteq	r0, r3
     9a0:	020901b1 	andeq	r0, r9, #1073741868	; 0x4000002c
     9a4:	0d1c0000 	ldceq	0, cr0, [ip, #-0]
     9a8:	000c0000 	andeq	r0, ip, r0
     9ac:	9c010000 	stcls	0, cr0, [r1], {-0}
     9b0:	000008d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     9b4:	6e656c25 	cdpvs	12, 6, cr6, cr5, cr5, {1}
     9b8:	01b10100 			; <UNDEFINED> instruction: 0x01b10100
     9bc:	0000008b 	andeq	r0, r0, fp, lsl #1
     9c0:	00000144 	andeq	r0, r0, r4, asr #2
     9c4:	000d2226 	andeq	r2, sp, r6, lsr #4
     9c8:	000d8600 	andeq	r8, sp, r0, lsl #12
     9cc:	e5280000 	str	r0, [r8, #-0]!
     9d0:	28000005 	stmdacs	r0, {r0, r2}
     9d4:	2800000d 	stmdacs	r0, {r0, r2, r3}
     9d8:	01000000 	mrseq	r0, (UNDEF: 0)
     9dc:	0009099c 	muleq	r9, ip, r9
     9e0:	05f62900 	ldrbeq	r2, [r6, #2304]!	; 0x900
     9e4:	01650000 	cmneq	r5, r0
     9e8:	382a0000 	stmdacc	sl!, {}	; <UNPREDICTABLE>
     9ec:	0e00000d 	cdpeq	0, 0, cr0, cr0, cr13, {0}
     9f0:	29000000 	stmdbcs	r0, {}	; <UNPREDICTABLE>
     9f4:	000005f6 	strdeq	r0, [r0], -r6
     9f8:	0000019f 	muleq	r0, pc, r1	; <UNPREDICTABLE>
     9fc:	000d3c20 	andeq	r3, sp, r0, lsr #24
     a00:	000d7b00 	andeq	r7, sp, r0, lsl #22
     a04:	2b000000 	blcs	a0c <USART_SetPrescaler+0x4>
     a08:	000007d2 	ldrdeq	r0, [r0], -r2
     a0c:	0d506c01 	ldcleq	12, cr6, [r0, #-4]
     a10:	00680000 	rsbeq	r0, r8, r0
     a14:	9c010000 	stcls	0, cr0, [r1], {-0}
     a18:	00000987 	andeq	r0, r0, r7, lsl #19
     a1c:	00071e2c 	andeq	r1, r7, ip, lsr #28
     a20:	878d0100 	strhi	r0, [sp, r0, lsl #2]
     a24:	02000009 	andeq	r0, r0, #9
     a28:	032d6c91 	teqeq	sp, #37120	; 0x9100
     a2c:	9c000006 	stcls	0, cr0, [r0], {6}
     a30:	0400000d 	streq	r0, [r0], #-13
     a34:	01000000 	mrseq	r0, (UNDEF: 0)
     a38:	0009499c 	muleq	r9, ip, r9
     a3c:	0da02000 	stceq	0, cr2, [r0]
     a40:	0da00000 	stceq	0, cr0, [r0]
     a44:	21000000 	mrscs	r0, (UNDEF: 0)
     a48:	00000d5e 	andeq	r0, r0, lr, asr sp
     a4c:	00000da7 	andeq	r0, r0, r7, lsr #27
     a50:	0000096a 	andeq	r0, r0, sl, ror #18
     a54:	01520122 	cmpeq	r2, r2, lsr #2
     a58:	51012230 	tstpl	r1, r0, lsr r2
     a5c:	01223c01 	teqeq	r2, r1, lsl #24
     a60:	000c0550 	andeq	r0, ip, r0, asr r5
     a64:	00400108 	subeq	r0, r0, r8, lsl #2
     a68:	000d6621 	andeq	r6, sp, r1, lsr #12
     a6c:	000dc300 	andeq	ip, sp, r0, lsl #6
     a70:	00097d00 	andeq	r7, r9, r0, lsl #26
     a74:	50012200 	andpl	r2, r1, r0, lsl #4
     a78:	20003c01 	andcs	r3, r0, r1, lsl #24
     a7c:	00000d82 	andeq	r0, r0, r2, lsl #27
     a80:	00000dd9 	ldrdeq	r0, [r0], -r9
     a84:	00800800 	addeq	r0, r0, r0, lsl #16
     a88:	03280000 	teqeq	r8, #0
     a8c:	00000006 	andeq	r0, r0, r6
     a90:	04000000 	streq	r0, [r0], #-0
     a94:	01000000 	mrseq	r0, (UNDEF: 0)
     a98:	0009a99c 	muleq	r9, ip, r9
     a9c:	00002600 	andeq	r2, r0, r0, lsl #12
     aa0:	0da00000 	stceq	0, cr0, [r0]
     aa4:	2b000000 	blcs	aac <USART_IrDAConfig+0x4>
     aa8:	00000581 	andeq	r0, r0, r1, lsl #11
     aac:	0db8b301 	ldceq	3, cr11, [r8, #4]!
     ab0:	001c0000 	andseq	r0, ip, r0
     ab4:	9c010000 	stcls	0, cr0, [r1], {-0}
     ab8:	000009ce 	andeq	r0, r0, lr, asr #19
     abc:	0005612e 	andeq	r6, r5, lr, lsr #2
     ac0:	8bb50100 	blhi	fed40ec8 <BootRAM+0xdcb1669>
     ac4:	b5000000 	strlt	r0, [r0, #-0]
     ac8:	00000001 	andeq	r0, r0, r1
     acc:	0004a72b 	andeq	sl, r4, fp, lsr #14
     ad0:	d4be0100 	ldrtle	r0, [lr], #256	; 0x100
     ad4:	1800000d 	stmdane	r0, {r0, r2, r3}
     ad8:	01000000 	mrseq	r0, (UNDEF: 0)
     adc:	0009f69c 	muleq	r9, ip, r6
     ae0:	05612c00 	strbeq	r2, [r1, #-3072]!	; 0xc00
     ae4:	c0010000 	andgt	r0, r1, r0
     ae8:	0000008b 	andeq	r0, r0, fp, lsl #1
     aec:	09007106 	stmdbeq	r0, {r1, r2, r8, ip, sp, lr}
     af0:	009f1afb 			; <UNDEFINED> instruction: 0x009f1afb
     af4:	00047d2b 	andeq	r7, r4, fp, lsr #26
     af8:	eccb0100 	stfe	f0, [fp], {0}
     afc:	8400000d 	strhi	r0, [r0], #-13
     b00:	01000000 	mrseq	r0, (UNDEF: 0)
     b04:	000a3c9c 	muleq	sl, ip, ip
     b08:	08262f00 	stmdaeq	r6!, {r8, r9, sl, fp, sp}
     b0c:	cb010000 	blgt	40b14 <_etext+0x395fc>
     b10:	00000573 	andeq	r0, r0, r3, ror r5
     b14:	000001cc 	andeq	r0, r0, ip, asr #3
     b18:	0005612e 	andeq	r6, r5, lr, lsr #2
     b1c:	8bcd0100 	blhi	ff340f24 <BootRAM+0xe2b16c5>
     b20:	1f000000 	svcne	0x00000000
     b24:	20000002 	andcs	r0, r0, r2
     b28:	00000e0a 	andeq	r0, r0, sl, lsl #28
     b2c:	000009ce 	andeq	r0, r0, lr, asr #19
     b30:	000e1020 	andeq	r1, lr, r0, lsr #32
     b34:	0009ce00 	andeq	ip, r9, r0, lsl #28
     b38:	4c300000 	ldcmi	0, cr0, [r0], #-0
     b3c:	01000004 	tsteq	r0, r4
     b40:	000250fc 	strdeq	r5, [r2], -ip
     b44:	000e7000 	andeq	r7, lr, r0
     b48:	00004800 	andeq	r4, r0, r0, lsl #16
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	739c0100 	orrsvc	r0, ip, #0, 2
  b	LoopCopyDataInit
     b50:	3100000a 	tstcc	r0, sl

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
     b54:	00000ea2 	andeq	r0, r0, r2, lsr #29
	str	r3, [r0, r1]
	adds	r1, r1, #4
     b58:	00000da7 	andeq	r0, r0, r7, lsr #27

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
     b5c:	01520122 	cmpeq	r2, r2, lsr #2
	adds	r2, r0, r1
	cmp	r2, r3
     b60:	51012231 	tstpl	r1, r1, lsr r2
	bcc	CopyDataInit
     b64:	01223c01 	teqeq	r2, r1, lsl #24
	ldr	r2, =_sbss
	b	LoopFillZerobss
     b68:	000c0550 	andeq	r0, ip, r0, asr r5
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	00400108 	subeq	r0, r0, r8, lsl #2
	str	r3, [r2], #4
     b70:	06e31a00 	strbteq	r1, [r3], r0, lsl #20

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
     b74:	14010000 	strne	r0, [r1], #-0
	bcc	FillZerobss
     b78:	00025001 	andeq	r5, r2, r1
/* Call the application's entry point.*/
	bl	main
     b7c:	000eb800 	andeq	fp, lr, r0, lsl #16
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	00003c00 	andeq	r3, r0, r0, lsl #24
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	ac9c0100 	ldfges	f0, [ip], {0}
	ldr	r3, =_edata
     b88:	3100000a 	tstcc	r0, sl
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	00000ed4 	ldrdeq	r0, [r0], -r4
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	00000da7 	andeq	r0, r0, r7, lsr #27
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	02520122 	subseq	r0, r2, #-2147483640	; 0x80000008
}


/* dummy proc */
void nothingProc(void)
{
     b98:	01220074 	teqeq	r2, r4, ror r0
{
    return;
}

void usbStatusOut(void)
{
     b9c:	223c0151 	eorscs	r0, ip, #1073741844	; 0x40000014
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
     ba0:	0c055001 	stceq	0, cr5, [r5], {1}
     ba4:	40010800 	andmi	r0, r1, r0, lsl #16
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	672b0000 	strvs	r0, [fp, -r0]!
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	01000005 	tsteq	r0, r5
     bb0:	000ef4a0 	andeq	pc, lr, r0, lsr #9
        bDeviceState = CONFIGURED;
     bb4:	00000400 	andeq	r0, r0, r0, lsl #8
     bb8:	cb9c0100 	blgt	fe700fc0 <BootRAM+0xd671761>
     bbc:	2600000a 	strcs	r0, [r0], -sl
     bc0:	00000ef8 	strdeq	r0, [r0], -r8
    }
}

void usbGetInterface(void)
{
     bc4:	00000a73 	andeq	r0, r0, r3, ror sl
{
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	04731d00 	ldrbteq	r1, [r3], #-3328	; 0xd00
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	f0010000 			; <UNDEFINED> instruction: 0xf0010000
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	000ef801 	andeq	pc, lr, r1, lsl #16
     bd4:	00002400 	andeq	r2, r0, r0, lsl #8
     bd8:	019c0100 	orrseq	r0, ip, r0, lsl #2
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	3200000b 	andcc	r0, r0, #11
    dfuUpdateByReset();
     be0:	00000401 	andeq	r0, r0, r1, lsl #8

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	2901f201 	stmdbcs	r1, {r0, r9, ip, sp, lr, pc}

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be8:	02000001 	andeq	r0, r0, #1
     bec:	16317491 			; <UNDEFINED> instruction: 0x16317491
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	e500000f 	str	r0, [r0, #-15]
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	2200000d 	andcs	r0, r0, #13
     bf8:	7d025001 	stcvc	0, cr5, [r2, #-4]

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfc:	1d000004 	stcne	0, cr0, [r0, #-16]
     c00:	0000005b 	andeq	r0, r0, fp, asr r0
     c04:	1c012d01 	stcne	13, cr2, [r1], {1}
     c08:	4000000f 	andmi	r0, r0, pc
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c0c:	01000000 	mrseq	r0, (UNDEF: 0)
     c10:	000b339c 	muleq	fp, ip, r3
     c14:	0f222000 	svceq	0x00222000
     c18:	0dfd0000 	ldcleq	0, cr0, [sp]
     c1c:	2e200000 	cdpcs	0, 2, cr0, cr0, cr0, {0}

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c20:	3c00000f 	stccc	0, cr0, [r0], {15}
     c24:	2000000a 	andcs	r0, r0, sl
     c28:	00000f42 	andeq	r0, r0, r2, asr #30
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	00000acb 	andeq	r0, r0, fp, asr #21
     c30:	00801d00 	addeq	r1, r0, r0, lsl #26
     c34:	fb010000 	blx	40c3e <_etext+0x39726>
     c38:	000f5c01 	andeq	r5, pc, r1, lsl #24
     c3c:	00002200 	andeq	r2, r0, r0, lsl #4

    Clear_Status_Out(ENDP0);
     c40:	699c0100 	ldmibvs	ip, {r8}

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c44:	3200000b 	andcc	r0, r0, #11
     c48:	00000401 	andeq	r0, r0, r1, lsl #8
     c4c:	2901fd01 	stmdbcs	r1, {r0, r8, sl, fp, ip, sp, lr, pc}
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	02000001 	andeq	r0, r0, #1
     c54:	78317491 	ldmdavc	r1!, {r0, r4, r7, sl, ip, sp, lr}

    bDeviceState = ATTACHED;
     c58:	e500000f 	str	r0, [r0, #-15]
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
     c5c:	2200000d 	andcs	r0, r0, #13

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	7d025001 	stcvc	0, cr5, [r2, #-4]
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c64:	33000004 	movwcc	r0, #4
     c68:	000000bf 	strheq	r0, [r0], -pc	; <UNPREDICTABLE>
     c6c:	80020501 	andhi	r0, r2, r1, lsl #10
     c70:	b400000f 	strlt	r0, [r0], #-15
     c74:	01000000 	mrseq	r0, (UNDEF: 0)
     c78:	000bb49c 	muleq	fp, ip, r4
     c7c:	0f9c2000 	svceq	0x009c2000
     c80:	0e040000 	cdpeq	0, 0, cr0, cr4, cr0, {0}
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	d6210000 	strtle	r0, [r1], -r0
     c88:	f600000f 			; <UNDEFINED> instruction: 0xf600000f
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8c:	9b000009 	blls	cb8 <usbDataSetup+0x34>
     c90:	2200000b 	andcs	r0, r0, #11
     c94:	30015001 	andcc	r5, r1, r1
        if (dfuUpdateByRequest()) {
     c98:	0fe42000 	svceq	0x00e42000
     c9c:	09a90000 	stmibeq	r9!, {}	; <UNPREDICTABLE>
            // successfull state transition, handle the request
            switch (request) {
     ca0:	1c230000 	stcne	0, cr0, [r3], #-0
     ca4:	f6000010 			; <UNDEFINED> instruction: 0xf6000010
     ca8:	22000009 	andcs	r0, r0, #9
     cac:	37015001 	strcc	r5, [r1, -r1]
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	43340000 	teqmi	r4, #0
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
     cb4:	01000005 	tsteq	r0, r5
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
     cb8:	05af0255 	streq	r0, [pc, #597]!	; f15 <usbEnbISR+0x1d>
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	00000000 	andeq	r0, r0, r0
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
     cc0:	000c0000 	andeq	r0, ip, r0
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	9c010000 	stcls	0, cr0, [r1], {-0}
        (*CopyRoutine)(0);

        return USB_SUCCESS;
     cc8:	00041435 	andeq	r1, r4, r5, lsr r4
    }

    return USB_UNSUPPORT;
     ccc:	d9690100 	stmdble	r9!, {r8}^
}
     cd0:	0000000b 	andeq	r0, r0, fp
     cd4:	36400210 			; <UNDEFINED> instruction: 0x36400210
     cd8:	00000bde 	ldrdeq	r0, [r0], -lr
     cdc:	01b40404 			; <UNDEFINED> instruction: 0x01b40404
     ce0:	02370000 	eorseq	r0, r7, #0
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	01000008 	tsteq	r0, r8
     ce8:	0000b02b 	andeq	fp, r0, fp, lsr #32
     cec:	8c030500 	cfstr32hi	mvfx0, [r3], {-0}
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	37200004 	strcc	r0, [r0, -r4]!
     cf4:	000002eb 	andeq	r0, r0, fp, ror #5
     cf8:	04a73301 	strteq	r3, [r7], #769	; 0x301
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	03050000 	movweq	r0, #20480	; 0x5000
     d00:	20000014 	andcs	r0, r0, r4, lsl r0
    if (strIndex > STR_DESC_LEN) {
     d04:	001f8237 	andseq	r8, pc, r7, lsr r2	; <UNPREDICTABLE>
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d08:	2b430100 	blcs	10c1110 <_etext+0x10b9bf8>
     d0c:	05000005 	streq	r0, [r0, #-5]
    }
}
     d10:	00008003 	andeq	r8, r0, r3
     d14:	021a3720 	andseq	r3, sl, #32, 14	; 0x800000
     d18:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
     d1c:	000002dd 	ldrdeq	r0, [r0], -sp
     d20:	00a40305 	adceq	r0, r4, r5, lsl #6
     d24:	e8382000 	ldmda	r8!, {sp}

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	07000001 	streq	r0, [r0, -r1]
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2c:	000c3322 	andeq	r3, ip, r2, lsr #6
     d30:	c4040400 	strgt	r0, [r4], #-1024	; 0x400
     d34:	38000003 	stmdacc	r0, {r0, r1}
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	0000013e 	andeq	r0, r0, lr, lsr r1
     d3c:	0c442507 	cfstr64eq	mvdx2, [r4], {7}
            return USB_SUCCESS;
     d40:	04040000 	streq	r0, [r4], #-0
     d44:	000004a7 	andeq	r0, r0, r7, lsr #9
        }
    }
    return USB_UNSUPPORT;
}
     d48:	00051d38 	andeq	r1, r5, r8, lsr sp
     d4c:	8b2d0700 	blhi	b42954 <_etext+0xb3b43c>

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d54:	00000a27 	andeq	r0, r0, r7, lsr #20
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	020f2308 	andeq	r2, pc, #8, 6	; 0x20000000
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5c:	44380000 	ldrtmi	r0, [r8], #-0
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d60:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
     d64:	00020f24 	andeq	r0, r2, r4, lsr #30
     d68:	020f3900 	andeq	r3, pc, #0, 18
     d6c:	0c7b0000 	ldcleq	0, cr0, [fp], #-0
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d70:	6b3a0000 	blvs	e80d78 <_etext+0xe79860>
     d74:	06000000 	streq	r0, [r0], -r0
     d78:	03d73800 	bicseq	r3, r7, #0, 16
     d7c:	25080000 	strcs	r0, [r8, #-0]
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d80:	00000c6b 	andeq	r0, r0, fp, ror #24
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	0007a838 	andeq	sl, r7, r8, lsr r8
     d88:	0f260800 	svceq	0x00260800
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8c:	37000002 	strcc	r0, [r0, -r2]
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d90:	000000b1 	strheq	r0, [r0], -r1
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d94:	002c2c06 	eoreq	r2, ip, r6, lsl #24
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d98:	03050000 	movweq	r0, #20480	; 0x5000

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	20000488 	andcs	r0, r0, r8, lsl #9
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	00009639 	andeq	r9, r0, r9, lsr r6
     da4:	000cad00 	andeq	sl, ip, r0, lsl #26
     da8:	38003b00 	stmdacc	r0, {r8, r9, fp, ip, sp}
     dac:	00000041 	andeq	r0, r0, r1, asr #32
     db0:	0ca22501 	cfstr32eq	mvfx2, [r2], #4
     db4:	a5380000 	ldrge	r0, [r8, #-0]!
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	01000007 	tsteq	r0, r7
     dbc:	000ca226 	andeq	sl, ip, r6, lsr #4
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dc0:	02fb3700 	rscseq	r3, fp, #0, 14

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	28010000 	stmdacs	r1, {}	; <UNPREDICTABLE>
     dc8:	000000a0 	andeq	r0, r0, r0, lsr #1
     dcc:	05b80305 	ldreq	r0, [r8, #773]!	; 0x305
     dd0:	d7372000 	ldrle	r2, [r7, -r0]!
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	01000006 	tsteq	r0, r6
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd8:	0000c02c 	andeq	ip, r0, ip, lsr #32
     ddc:	b4030500 	strlt	r0, [r3], #-1280	; 0x500

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	39200005 	stmdbcc	r0!, {r0, r2}
     de4:	00000072 	andeq	r0, r0, r2, ror r0
     de8:	00000cf5 	strdeq	r0, [r0], -r5
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	00006b3a 	andeq	r6, r0, sl, lsr fp
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	37000600 	strcc	r0, [r0, -r0, lsl #12]
        ResumeS.eState = eResumeSetVal;
     df4:	000009b3 			; <UNDEFINED> instruction: 0x000009b3

    switch (ResumeS.eState) {
     df8:	0ce54f01 	stcleq	15, cr4, [r5], #4
     dfc:	03050000 	movweq	r0, #20480	; 0x5000
     e00:	20000048 	andcs	r0, r0, r8, asr #32
     e04:	00096537 	andeq	r6, r9, r7, lsr r5
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	e5590100 	ldrb	r0, [r9, #-256]	; 0x100
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	0500000c 	streq	r0, [r0, #-12]
        ResumeS.eState = RESUME_START;
     e10:	00006403 	andeq	r6, r0, r3, lsl #8
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	07163720 	ldreq	r3, [r6, -r0, lsr #14]
        ResumeS.eState = RESUME_WAIT;
     e18:	66010000 	strvs	r0, [r1], -r0
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	000005ba 			; <UNDEFINED> instruction: 0x000005ba
     e20:	048e0305 	streq	r0, [lr], #773	; 0x305
        if (ResumeS.bESOFcnt == 0)
     e24:	3b3c2000 	blcc	f08e2c <_etext+0xf01914>
            ResumeS.eState = RESUME_START;
     e28:	09000008 	stmdbeq	r0, {r3}
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	07943d6e 	ldreq	r3, [r4, lr, ror #26]
     e30:	460a0000 	strmi	r0, [sl], -r0
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e34:	000d4102 	andeq	r4, sp, r2, lsl #2
        ResumeS.eState = RESUME_ON;
     e38:	00961100 	addseq	r1, r6, r0, lsl #2
        ResumeS.bESOFcnt = 10;
     e3c:	3d000000 	stccc	0, cr0, [r0, #-0]
        break;
     e40:	0000099c 	muleq	r0, ip, r9
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e44:	5802570a 	stmdapl	r2, {r1, r3, r8, r9, sl, ip, lr}
     e48:	1100000d 	tstne	r0, sp
        if (ResumeS.bESOFcnt == 0) {
     e4c:	00000096 	muleq	r0, r6, r0
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	00008b11 	andeq	r8, r0, r1, lsl fp
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	7f3d0000 	svcvc	0x003d0000
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e58:	0a000003 	beq	e6c <usbResume+0x80>
            ResumeS.eState = RESUME_OFF;
     e5c:	0d6a0240 	sfmeq	f0, 2, [sl, #-256]!	; 0xffffff00
     e60:	96110000 	ldrls	r0, [r1], -r0
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e64:	00000000 	andeq	r0, r0, r0
     e68:	0002b23e 	andeq	fp, r2, lr, lsr r2
     e6c:	7be90400 	blvc	ffa41e74 <BootRAM+0xe9b2615>
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	1100000d 	tstne	r0, sp
     e74:	00000096 	muleq	r0, r6, r0
     e78:	04873f00 	streq	r3, [r7], #3840	; 0xf00
     e7c:	6d090000 	stcvs	0, cr0, [r9, #-0]

    _SetCNTR(CNTR_FRES);
     e80:	000000e5 	andeq	r0, r0, r5, ror #1
     e84:	00026440 	andeq	r6, r2, r0, asr #8
     e88:	09e50400 	stmibeq	r5!, {sl}^
     e8c:	a0000002 	andge	r0, r0, r2
    _SetCNTR(0);
    _SetISTR(0);
     e90:	1100000d 	tstne	r0, sp

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e94:	0000008b 	andeq	r0, r0, fp, lsl #1
    _SetCNTR(wInterrupt_Mask);
     e98:	00021a11 	andeq	r1, r2, r1, lsl sl
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9c:	923c0000 	eorsls	r0, ip, #0
     ea0:	07000002 	streq	r0, [r0, -r2]
#endif
#endif

    return USB_SUCCESS;
}
     ea4:	07db3d19 	bfieq	r3, r9, #26, #2
     ea8:	24030000 	strcs	r0, [r3], #-0
     eac:	000dc301 	andeq	ip, sp, r1, lsl #6
     eb0:	00801100 	addeq	r1, r0, r0, lsl #2
     eb4:	96110000 	ldrls	r0, [r1], -r0

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	11000000 	mrsne	r0, (UNDEF: 0)
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	00000096 	muleq	r0, r6, r0
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
     ec0:	027f4100 	rsbseq	r4, pc, #0, 2
     ec4:	25030000 	strcs	r0, [r3, #-0]
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec8:	00002501 	andeq	r2, r0, r1, lsl #10
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     ecc:	000dd900 	andeq	sp, sp, r0, lsl #18
     ed0:	002c1100 	eoreq	r1, ip, r0, lsl #2
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	42000000 	andmi	r0, r0, #0
     ed8:	0000035f 	andeq	r0, r0, pc, asr r3
     edc:	2c013d03 	stccs	13, cr3, [r1], {3}

    return USB_SUCCESS;
}
     ee0:	3d000000 	stccc	0, cr0, [r0, #-0]
     ee4:	000009e1 	andeq	r0, r0, r1, ror #19
     ee8:	f7013903 			; <UNDEFINED> instruction: 0xf7013903
     eec:	1100000d 	tstne	r0, sp
     ef0:	00000df7 	strdeq	r0, [r0], -r7
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	29040400 	stmdbcs	r4, {sl}
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	3c000001 	stccc	0, cr0, [r0], {1}
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efc:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	343c6a09 	ldrtcc	r6, [ip], #-2569	; 0xa09
     f04:	0b000008 	bleq	f2c <usbInit+0x10>
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f08:	0259001a 	subseq	r0, r9, #26
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	00040000 	andeq	r0, r4, r0
     f10:	0000040b 	andeq	r0, r0, fp, lsl #8
    nvicInit(&NVIC_InitStructure);
     f14:	06390104 	ldrteq	r0, [r9], -r4, lsl #2
}
     f18:	9a010000 	bls	40f20 <_etext+0x39a08>

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	9300000a 	movwls	r0, #10
    dfuInit();
     f20:	c6000008 	strgt	r0, [r0], -r8

    pInformation->Current_Configuration = 0;
     f24:	02000004 	andeq	r0, r0, #4
     f28:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    usbPowerOn();
     f2c:	04030074 	streq	r0, [r3], #-116	; 0x74

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
     f30:	00025707 	andeq	r5, r2, r7, lsl #14
     f34:	06010300 	streq	r0, [r1], -r0, lsl #6
     f38:	0000081a 	andeq	r0, r0, sl, lsl r8
    _SetCNTR(wInterrupt_Mask);
     f3c:	18080103 	stmdane	r8, {r0, r1, r8}

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f40:	03000008 	movweq	r0, #8
    bDeviceState = UNCONNECTED;
     f44:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
     f48:	02030000 	andeq	r0, r3, #0
     f4c:	00094907 	andeq	r4, r9, r7, lsl #18
     f50:	05040300 	streq	r0, [r4, #-768]	; 0x300
     f54:	000004da 	ldrdeq	r0, [r0], -sl
     f58:	52070403 	andpl	r0, r7, #50331648	; 0x3000000
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	03000002 	movweq	r0, #2
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f60:	04d50508 	ldrbeq	r0, [r5], #1288	; 0x508
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	08030000 	stmdaeq	r3, {}	; <UNPREDICTABLE>

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f68:	00024d07 	andeq	r4, r2, r7, lsl #26
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	07040300 	streq	r0, [r4, -r0, lsl #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	0000078b 	andeq	r0, r0, fp, lsl #15
    nvicInit(&NVIC_InitStructure);
     f74:	21080103 	tstcs	r8, r3, lsl #2
}
     f78:	04000008 	streq	r0, [r0], #-8
     f7c:	00363175 	eorseq	r3, r6, r5, ror r1

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	00402801 	subeq	r2, r0, r1, lsl #16
    wIstr = _GetISTR();
     f84:	75040000 	strvc	r0, [r4, #-0]

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	29010038 	stmdbcs	r1, {r3, r4, r5}
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8c:	00000032 	andeq	r0, r0, r2, lsr r0

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f90:	00003305 	andeq	r3, r0, r5, lsl #6
     f94:	24020800 	strcs	r0, [r2], #-2048	; 0x800
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	000000ab 	andeq	r0, r0, fp, lsr #1
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	0002e006 	andeq	lr, r2, r6
     fa0:	ab260200 	blge	9817a8 <_etext+0x97a290>
     fa4:	00000000 	andeq	r0, r0, r0
        _SetISTR((u16)CLR_RESET);
     fa8:	0003f106 	andeq	pc, r3, r6, lsl #2
        Device_Property.Reset();
     fac:	71270200 	teqvc	r7, r0, lsl #4
     fb0:	04000000 	streq	r0, [r0], #-0
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb4:	7c040700 	stcvc	7, cr0, [r4], {-0}
     fb8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
        _SetISTR((u16)CLR_ERR);
     fbc:	00000572 	andeq	r0, r0, r2, ror r5
     fc0:	00862902 	addeq	r2, r6, r2, lsl #18
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc4:	b1090000 	mrslt	r0, (UNDEF: 9)
     fc8:	03000000 	movweq	r0, #0
        _SetISTR((u16)CLR_WKUP);
     fcc:	00001d2c 	andeq	r1, r0, ip, lsr #26
        usbResume(RESUME_EXTERNAL);
     fd0:	88030500 	stmdahi	r3, {r8, sl}
     fd4:	09200004 	stmdbeq	r0!, {r2}
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd8:	00000a27 	andeq	r0, r0, r7, lsr #20
     fdc:	00b13d04 	adcseq	r3, r1, r4, lsl #26

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	03050000 	movweq	r0, #20480	; 0x5000
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	20000158 	andcs	r0, r0, r8, asr r1
     fe8:	00004409 	andeq	r4, r0, r9, lsl #8
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fec:	b1970400 	orrslt	r0, r7, r0, lsl #8
     ff0:	05000000 	streq	r0, [r0, #-0]
        _SetISTR((u16)CLR_SOF);
     ff4:	0002b403 	andeq	fp, r2, r3, lsl #8
     ff8:	00b10a20 	adcseq	r0, r1, r0, lsr #20
        bIntPackSOF++;
     ffc:	00ff0000 	rscseq	r0, pc, r0
    1000:	630b0000 	movwvs	r0, #45056	; 0xb000
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	06000000 	streq	r0, [r0], -r0
    1008:	03d70900 	bicseq	r0, r7, #0, 18
        _SetISTR((u16)CLR_ESOF);
    100c:	cc040000 	stcgt	0, cr0, [r4], {-0}
    1010:	000000ef 	andeq	r0, r0, pc, ror #1
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    }
#endif

}
    1014:	00a80305 	adceq	r0, r8, r5, lsl #6
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	a8092000 	stmdage	r9, {sp}
    101c:	04000007 	streq	r0, [r0], #-7
    1020:	0000b14f 	andeq	fp, r0, pc, asr #2
    1024:	f4030500 	vst3.8	{d0,d2,d4}, [r3], r0
    1028:	0a200000 	beq	801030 <_etext+0x7f9b18>
    102c:	0000007c 	andeq	r0, r0, ip, ror r0
    1030:	00000131 	andeq	r0, r0, r1, lsr r1
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

void print_hash(unsigned char hash[])
{
    1034:	0000630b 	andeq	r6, r0, fp, lsl #6
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
}

int main() 
{
    1038:	09001100 	stmdbeq	r0, {r8, ip}
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    103c:	00000a24 	andeq	r0, r0, r4, lsr #20
    setupCLK();
    1040:	01212604 	teqeq	r1, r4, lsl #12
    setupLEDAndButton();
    1044:	03050000 	movweq	r0, #20480	; 0x5000
    setupUSB();
    1048:	200000e0 	andcs	r0, r0, r0, ror #1
    setupFLASH();
    104c:	00007c0a 	andeq	r7, r0, sl, lsl #24
    uartInit();
    1050:	00015200 	andeq	r5, r1, r0, lsl #4
    usbReset();
    1054:	00630b00 	rsbeq	r0, r3, r0, lsl #22
	uart_printf("\nBootloader init...\n");
    1058:	00080000 	andeq	r0, r8, r0
    105c:	0007a509 	andeq	sl, r7, r9, lsl #10

    if (readPin(GPIOB, 15) == 0x0)
    1060:	42420400 	submi	r0, r2, #0, 8
    1064:	05000001 	streq	r0, [r0, #-1]
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1068:	00013d03 	andeq	r3, r1, r3, lsl #26
    106c:	007c0a20 	rsbseq	r0, ip, r0, lsr #20
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    1070:	01730000 	cmneq	r3, r0
    1074:	630b0000 	movwvs	r0, #45056	; 0xb000
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
    1078:	2c000000 	stccs	0, cr0, [r0], {-0}
    107c:	00410900 	subeq	r0, r1, r0, lsl #18
    1080:	55040000 	strpl	r0, [r4, #-0]
   debug_print("\n", 0);
}

int main() 
{
	bool no_user_jump = FALSE;
    1084:	00000163 	andeq	r0, r0, r3, ror #2
    1088:	01000305 	tsteq	r0, r5, lsl #6
    108c:	7c0a2000 	stcvc	0, cr2, [sl], {-0}
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1090:	94000000 	strls	r0, [r0], #-0
			no_user_jump = FALSE;
    1094:	0b000001 	bleq	10a0 <main+0x68>
			break;

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    1098:	00000063 	andeq	r0, r0, r3, rrx
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    109c:	87090003 	strhi	r0, [r9, -r3]
    10a0:	0400000a 	streq	r0, [r0], #-10
			break;

		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10a4:	0001849d 	muleq	r1, sp, r4
    10a8:	fc030500 	stc2	5, cr0, [r3], {-0}
    10ac:	09200000 	stmdbeq	r0!, {}	; <UNPREDICTABLE>
    10b0:	000009ea 	andeq	r0, r0, sl, ror #19
    10b4:	0121a404 	teqeq	r1, r4, lsl #8

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10b8:	03050000 	movweq	r0, #20480	; 0x5000
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10bc:	20000146 	andcs	r0, r0, r6, asr #2
    10c0:	00007c0a 	andeq	r7, r0, sl, lsl #24
    10c4:	0001c600 	andeq	ip, r1, r0, lsl #12
    10c8:	00630b00 	rsbeq	r0, r3, r0, lsl #22

		if (dfuUploadStarted()) 
    10cc:	00130000 	andseq	r0, r3, r0
    10d0:	000a7309 	andeq	r7, sl, r9, lsl #6
		{
			uart_printf("DFU finished upload\n");
    10d4:	b6aa0400 	strtlt	r0, [sl], r0, lsl #8
			dfuFinishUpload(); // systemHardReset from DFU once done
    10d8:	05000001 	streq	r0, [r0, #-1]
    10dc:	00016003 	andeq	r6, r1, r3
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10e0:	007c0a20 	rsbseq	r0, ip, r0, lsr #20
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10e4:	01e70000 	mvneq	r0, r0
    10e8:	630b0000 	movwvs	r0, #45056	; 0xb000
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10ec:	0f000000 	svceq	0x00000000
	}
	
	return 0;// Added to please the compiler
    10f0:	0a4f0900 	beq	13c34f8 <_etext+0x13bbfe0>
    10f4:	b0040000 	andlt	r0, r4, r0
    10f8:	000001d7 	ldrdeq	r0, [r0], -r7
    10fc:	012d0305 	teqeq	sp, r5, lsl #6
    1100:	7c0a2000 	stcvc	0, cr2, [sl], {-0}
    1104:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    1108:	0b000002 	bleq	1118 <main+0xe0>
    110c:	00000063 	andeq	r0, r0, r3, rrx
    1110:	62090077 	andvs	r0, r9, #119	; 0x77
    1114:	0400000a 	streq	r0, [r0], #-10
    1118:	0001f8b6 			; <UNDEFINED> instruction: 0x0001f8b6
    111c:	74030500 	strvc	r0, [r3], #-1280	; 0x500
    1120:	0a200001 	beq	80112c <_etext+0x7f9c14>
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1124:	0000007c 	andeq	r0, r0, ip, ror r0
    1128:	00000229 	andeq	r0, r0, r9, lsr #4
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    112c:	0000630b 	andeq	r6, r0, fp, lsl #6
    1130:	09006300 	stmdbeq	r0, {r8, r9, sp, lr}
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1134:	00000a13 	andeq	r0, r0, r3, lsl sl
    1138:	0219bd04 	andseq	fp, r9, #4, 26	; 0x100
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    113c:	03050000 	movweq	r0, #20480	; 0x5000
    1140:	200001ec 	andcs	r0, r0, ip, ror #3
        return TRUE;
    } else {
        return FALSE;
    }
}
    1144:	000a3e09 	andeq	r3, sl, r9, lsl #28
    1148:	19c40400 	stmibne	r4, {sl}^

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    114c:	05000002 	streq	r0, [r0, #-2]
    1150:	00025003 	andeq	r5, r2, r3
    1154:	09fd0920 	ldmibeq	sp!, {r5, r8, fp}^
    gpio_write_bit( bank,pin,1-onState);
    1158:	ca040000 	bgt	101160 <_etext+0xf9c48>
    115c:	0000007c 	andeq	r0, r0, ip, ror r0
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	00000305 	andeq	r0, r0, r5, lsl #6
    gpio_write_bit( bank,pin,1-onState);
    1164:	c9000000 	stmdbgt	r0, {}	; <UNPREDICTABLE>

    u32 c;
    while (count-- > 0) 
    1168:	04000004 	streq	r0, [r0], #-4
	{
        for (c = rate; c > 0; c--)
    116c:	00049500 	andeq	r9, r4, r0, lsl #10
    1170:	39010400 	stmdbcc	r1, {sl}
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1174:	01000006 	tsteq	r0, r6
    1178:	00000bd1 	ldrdeq	r0, [r0], -r1
    117c:	00000893 	muleq	r0, r3, r8
		
        for (c = rate; c > 0; c--)
    1180:	00000130 	andeq	r0, r0, r0, lsr r1
    1184:	00000000 	andeq	r0, r0, r0
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    1188:	00000538 	andeq	r0, r0, r8, lsr r5
    118c:	000ac702 	andeq	ip, sl, r2, lsl #14
    1190:	30d40200 	sbcscc	r0, r4, r0, lsl #4
    1194:	03000000 	movweq	r0, #0
    1198:	02570704 	subseq	r0, r7, #4, 14	; 0x100000

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    119c:	04040000 	streq	r0, [r4], #-0
    11a0:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
  USARTx->DR = ch;  
    11a4:	06010300 	streq	r0, [r1], -r0, lsl #6
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11a8:	0000081a 	andeq	r0, r0, sl, lsl r8
  while(*str != 0)
    11ac:	000b0102 	andeq	r0, fp, r2, lsl #2
    11b0:	501c0300 	andspl	r0, ip, r0, lsl #6
  {
    UU_PutChar(USARTx, *str);
    11b4:	03000000 	movweq	r0, #0
    11b8:	08180801 	ldmdaeq	r8, {r0, fp}
    str++;
  }
}

void vprint(const char *fmt, va_list argp)
{
    11bc:	02030000 	andeq	r0, r3, #0
    11c0:	0006fc05 	andeq	pc, r6, r5, lsl #24
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11c4:	07020300 	streq	r0, [r2, -r0, lsl #6]
    11c8:	00000949 	andeq	r0, r0, r9, asr #18
    11cc:	da050403 	ble	1421e0 <_etext+0x13acc8>
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11d0:	02000004 	andeq	r0, r0, #4
    11d4:	00000ace 	andeq	r0, r0, lr, asr #21

    }
}
    11d8:	00773803 	rsbseq	r3, r7, r3, lsl #16
    11dc:	04030000 	streq	r0, [r3], #-0
    11e0:	00025207 	andeq	r5, r2, r7, lsl #4

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11e4:	05080300 	streq	r0, [r8, #-768]	; 0x300
    11e8:	000004d5 	ldrdeq	r0, [r0], -r5
    11ec:	4d070803 	stcmi	8, cr0, [r7, #-12]
    va_list argp;
    va_start(argp, fmt);
    vprint(fmt, argp);
    11f0:	03000002 	movweq	r0, #2
    va_end(argp);
}
    11f4:	078b0704 	streq	r0, [fp, r4, lsl #14]
    11f8:	04050000 	streq	r0, [r5], #-0
    11fc:	00000050 	andeq	r0, r0, r0, asr r0

void hexdump(unsigned char *data, size_t size)
{
    1200:	21080103 	tstcs	r8, r3, lsl #2
    int i;
    char cs[17];
    memset(cs, 0, 17);
    1204:	05000008 	streq	r0, [r0, #-8]
    1208:	0000a604 	andeq	sl, r0, r4, lsl #12
    120c:	00990600 	addseq	r0, r9, r0, lsl #12

    for(i = 0; i < size; i++)
    1210:	03020000 	movweq	r0, #8192	; 0x2000
    {
        if(i != 0 && i % 0x10 == 0)
    1214:	0400000b 	streq	r0, [r0], #-11
    1218:	0000452a 	andeq	r4, r0, sl, lsr #10
        {
            debug_print(" |%s|\n", cs);
            memset(cs, 0, 17);
    121c:	0ad00200 	beq	ff401a24 <BootRAM+0xe3721c5>
    1220:	42040000 	andmi	r0, r4, #0
{
    int i;
    char cs[17];
    memset(cs, 0, 17);

    for(i = 0; i < size; i++)
    1224:	0000006c 	andeq	r0, r0, ip, rrx
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
}
    1228:	32337507 	eorscc	r7, r3, #29360128	; 0x1c00000


#endif
void uartInit(void) {
    122c:	77270500 	strvc	r0, [r7, -r0, lsl #10]!
    1230:	07000000 	streq	r0, [r0, -r0]
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    1234:	05003875 	streq	r3, [r0, #-2165]	; 0x875
    1238:	00005029 	andeq	r5, r0, r9, lsr #32
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    123c:	035a0200 	cmpeq	sl, #0, 4
    1240:	2f050000 	svccs	0x00050000
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    1244:	000000e1 	andeq	r0, r0, r1, ror #1
    1248:	00007708 	andeq	r7, r0, r8, lsl #14
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    124c:	05010900 	streq	r0, [r1, #-2304]	; 0x900
    1250:	0000fb37 	andeq	pc, r0, r7, lsr fp	; <UNPREDICTABLE>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1254:	07530a00 	ldrbeq	r0, [r3, -r0, lsl #20]
    1258:	0a000000 	beq	1260 <uartInit+0x34>
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    125c:	000001a7 	andeq	r0, r0, r7, lsr #3
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    1260:	2d020001 	stccs	0, cr0, [r2, #-4]
    1264:	05000005 	streq	r0, [r0, #-5]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1268:	0000e637 	andeq	lr, r0, r7, lsr r6
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    126c:	0aab0b00 	beq	feac3e74 <BootRAM+0xda34615>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1270:	06140000 	ldreq	r0, [r4], -r0
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1274:	00015b0d 	andeq	r5, r1, sp, lsl #22
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1278:	0b0b0c00 	bleq	2c4280 <_etext+0x2bcd68>
    127c:	0e060000 	cdpeq	0, 0, cr0, cr6, cr0, {0}
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1280:	000000b6 	strheq	r0, [r0], -r6
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    1284:	0bc20c00 	bleq	ff08428c <BootRAM+0xdff4a2d>
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1288:	10060000 	andne	r0, r6, r0
    USART_InitStructure.USART_Parity = USART_Parity_No;
    128c:	000000b6 	strheq	r0, [r0], -r6
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    1290:	0b730c04 	bleq	1cc42a8 <_etext+0x1cbcd90>
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1294:	11060000 	mrsne	r0, (UNDEF: 6)
    1298:	000000b6 	strheq	r0, [r0], -r6
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    129c:	0c070c08 	stceq	12, cr0, [r7], {8}
        
    USART_Init(USART1, &USART_InitStructure);
    12a0:	13060000 	movwne	r0, #24576	; 0x6000
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    12a4:	000000b6 	strheq	r0, [r0], -r6
    12a8:	0b950c0c 	bleq	fe5442e0 <BootRAM+0xd4b4a81>
}
    12ac:	14060000 	strne	r0, [r6], #-0
    12b0:	000000b6 	strheq	r0, [r0], -r6

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    12b4:	0af00c10 	beq	ffc042fc <BootRAM+0xeb74a9d>
    12b8:	15060000 	strne	r0, [r6, #-0]
    12bc:	0000015b 	andeq	r0, r0, fp, asr r1
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    12c0:	ab0d0014 	blge	341318 <_etext+0x339e00>
    12c4:	6a000000 	bvs	12cc <systemReset+0x18>
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    12c8:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    12cc:	0000008c 	andeq	r0, r0, ip, lsl #1
    12d0:	0aac0200 	beq	feb01ad8 <BootRAM+0xda72279>
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    12d4:	16060000 	strne	r0, [r6], -r0
    12d8:	00000106 	andeq	r0, r0, r6, lsl #2
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    12dc:	000b130b 	andeq	r1, fp, fp, lsl #6
    12e0:	18061400 	stmdane	r6, {sl, ip}

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    12e4:	000001be 			; <UNDEFINED> instruction: 0x000001be
    12e8:	000bd80c 	andeq	sp, fp, ip, lsl #16
    12ec:	be190600 	cfmsub32lt	mvax0, mvfx0, mvfx9, mvfx0
    12f0:	00000001 	andeq	r0, r0, r1
    12f4:	000b5b0c 	andeq	r5, fp, ip, lsl #22
    12f8:	b61a0600 	ldrlt	r0, [sl], -r0, lsl #12
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    12fc:	04000000 	streq	r0, [r0], #-0
    1300:	000b8b0c 	andeq	r8, fp, ip, lsl #22
    1304:	251f0600 	ldrcs	r0, [pc, #-1536]	; d0c <usbGetStringDescriptor+0x10>
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    1308:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    130c:	000b270c 	andeq	r2, fp, ip, lsl #14

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    1310:	37210600 	strcc	r0, [r1, -r0, lsl #12]!
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    1314:	0c000000 	stceq	0, cr0, [r0], {-0}
    1318:	000c160c 	andeq	r1, ip, ip, lsl #12
    131c:	37220600 	strcc	r0, [r2, -r0, lsl #12]!
    1320:	10000000 	andne	r0, r0, r0
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    1324:	6a040500 	bvs	10272c <_etext+0xfb214>
    1328:	02000001 	andeq	r0, r0, #1

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    132c:	00000c39 	andeq	r0, r0, r9, lsr ip
    1330:	01cf2606 	biceq	r2, pc, r6, lsl #12
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    1334:	04050000 	streq	r0, [r5], #-0
    1338:	00000175 	andeq	r0, r0, r5, ror r1
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    133c:	000c2e0f 	andeq	r2, ip, pc, lsl #28
    1340:	343d0100 	ldrtcc	r0, [sp], #-256	; 0x100
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    1344:	02000010 	andeq	r0, r0, #16
    1348:	01000000 	mrseq	r0, (UNDEF: 0)
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    134c:	0002049c 	muleq	r2, ip, r4
    1350:	0c341000 	ldceq	0, cr1, [r4], #-0
    1354:	3d010000 	stccc	0, cr0, [r1, #-0]
    1358:	00000093 	muleq	r0, r3, r0

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    135c:	69115001 	ldmdbvs	r1, {r0, ip, lr}
    1360:	01007864 	tsteq	r0, r4, ror #16
    1364:	0000373f 	andeq	r3, r0, pc, lsr r7
    1368:	12000000 	andne	r0, r0, #0
    136c:	00000b9c 	muleq	r0, ip, fp
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    1370:	00374501 	eorseq	r4, r7, r1, lsl #10
    1374:	10380000 	eorsne	r0, r8, r0
        u32 rwmVal = pRCC->CR;
    1378:	00ec0000 	rsceq	r0, ip, r0
        rwmVal |= 0x01;
    137c:	9c010000 	stcls	0, cr0, [r1], {-0}
        pRCC->CR = rwmVal;
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    1380:	000003e0 	andeq	r0, r0, r0, ror #7
    1384:	000b4e13 	andeq	r4, fp, r3, lsl lr
}   
    1388:	fb470100 	blx	11c1792 <_etext+0x11ba27a>
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    138c:	46000000 	strmi	r0, [r0], -r0
void setMspAndJump(u32 usrAddr) {
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    1390:	14000002 	strne	r0, [r0], #-2
  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1394:	00000ba1 	andeq	r0, r0, r1, lsr #23

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1398:	00fb4801 	rscseq	r4, fp, r1, lsl #16
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    139c:	15000000 	strne	r0, [r0, #-0]
    13a0:	00000bef 	andeq	r0, r0, pc, ror #23
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    13a4:	01c45901 	biceq	r5, r4, r1, lsl #18
    13a8:	91020000 	mrsls	r0, (UNDEF: 2)
    13ac:	6572166c 	ldrbvs	r1, [r2, #-1644]!	; 0x66c
    13b0:	5b010074 	blpl	41588 <_etext+0x3a070>
    tmppre = (0x4 - tmppriority);
    13b4:	00000037 	andeq	r0, r0, r7, lsr r0
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    13b8:	000002cc 	andeq	r0, r0, ip, asr #5


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    13bc:	000bab13 	andeq	sl, fp, r3, lsl fp

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c0:	37740100 	ldrbcc	r0, [r4, -r0, lsl #2]!
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    13c4:	f5000000 			; <UNDEFINED> instruction: 0xf5000000

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c8:	17000002 	strne	r0, [r0, -r2]
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    13cc:	00001040 	andeq	r1, r0, r0, asr #32
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d0:	000003f1 	strdeq	r0, [r0], -r1

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d4:	00104417 	andseq	r4, r0, r7, lsl r4
    13d8:	0003f900 	andeq	pc, r3, r0, lsl #18
    13dc:	10481700 	subne	r1, r8, r0, lsl #14
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    13e0:	04010000 	streq	r0, [r1], #-0
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    13e4:	4c170000 	ldcmi	0, cr0, [r7], {-0}
    tmppriority &= tmpmask;
    13e8:	09000010 	stmdbeq	r0, {r4}
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    13ec:	17000004 	strne	r0, [r0, -r4]

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    13f0:	00001050 	andeq	r1, r0, r0, asr r0
    13f4:	00000410 	andeq	r0, r0, r0, lsl r4
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    13f8:	00105417 	andseq	r5, r0, r7, lsl r4
    13fc:	00041800 	andeq	r1, r4, r0, lsl #16
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    1400:	10581700 	subsne	r1, r8, r0, lsl #14
    1404:	04200000 	strteq	r0, [r0], #-0
    1408:	5e180000 	cdppl	0, 1, cr0, cr8, cr0, {0}
    140c:	27000010 	smladcs	r0, r0, r0, r0
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    1410:	ba000004 	blt	1428 <nvicDisableInterrupts+0x18>
    1414:	19000002 	stmdbne	r0, {r1}
    1418:	03055001 	movweq	r5, #20481	; 0x5001
    rNVIC->ICER[1] = 0xFFFFFFFF;
    141c:	00006f90 	muleq	r0, r0, pc	; <UNPREDICTABLE>
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    1420:	10661800 	rsbne	r1, r6, r0, lsl #16
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    1424:	043a0000 	ldrteq	r0, [sl], #-0

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    1428:	02d60000 	sbcseq	r0, r6, #0
    142c:	01190000 	tsteq	r9, r0
    1430:	193f0151 	ldmdbne	pc!, {r0, r4, r6, r8}	; <UNPREDICTABLE>

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    1434:	0c055001 	stceq	0, cr5, [r5], {1}
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    1438:	40010c00 	andmi	r0, r1, r0, lsl #24
    nvicDisableInterrupts();
    143c:	106e1800 	rsbne	r1, lr, r0, lsl #16
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    1440:	04270000 	strteq	r0, [r7], #-0
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    1444:	02ed0000 	rsceq	r0, sp, #0
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    1448:	01190000 	tsteq	r9, r0
}
    144c:	a5030550 	strge	r0, [r3, #-1360]	; 0x550
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    1450:	0000006f 	andeq	r0, r0, pc, rrx

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1454:	00107818 	andseq	r7, r0, r8, lsl r8
    1458:	00045500 	andeq	r5, r4, r0, lsl #10

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    145c:	00030f00 	andeq	r0, r3, r0, lsl #30
    1460:	52011900 	andpl	r1, r1, #0, 18
    1464:	01193001 	tsteq	r9, r1
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1468:	000c0551 	andeq	r0, ip, r1, asr r5
    146c:	19080080 	stmdbne	r8, {r7}
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    1470:	91025001 	tstls	r2, r1

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1474:	9418006c 	ldrls	r0, [r8], #-108	; 0x6c
    1478:	27000010 	smladcs	r0, r0, r0, r0
    147c:	26000004 	strcs	r0, [r0], -r4
    SET_REG(FLASH_AR, pageAddr);
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    1480:	19000003 	stmdbne	r0, {r0, r1}
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1484:	03055001 	movweq	r5, #20481	; 0x5001
    1488:	00006fb8 			; <UNDEFINED> instruction: 0x00006fb8

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    148c:	10a21700 	adcne	r1, r2, r0, lsl #14

    return TRUE;
}
    1490:	04270000 	strteq	r0, [r7], #-0
    1494:	b6180000 	ldrlt	r0, [r8], -r0
    1498:	7a000010 	bvc	14e0 <flashWriteWord+0x44>
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    149c:	5e000004 	cdppl	0, 0, cr0, cr0, cr4, {0}
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    14a0:	19000003 	stmdbne	r0, {r0, r1}
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    14a4:	44035301 	strmi	r5, [r3], #-769	; 0x301

    u32 rwmVal = GET_REG(FLASH_CR);
    SET_REG(FLASH_CR, FLASH_CR_PG);
    14a8:	0119243e 	tsteq	r9, lr, lsr r4
    14ac:	19350152 	ldmdbne	r5!, {r1, r4, r6, r8}

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14b0:	3d015101 	stfccs	f5, [r1, #-4]
    14b4:	05500119 	ldrbeq	r0, [r0, #-281]	; 0x119
    *(flashAddr + 0x01) = (vu16)hhWord;
    14b8:	0110000c 	tsteq	r0, ip
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14bc:	7d021940 	stcvc	9, cr1, [r2, #-256]	; 0xffffff00
    14c0:	00750200 	rsbseq	r0, r5, r0, lsl #4
    *(flashAddr) = (vu16)lhWord;
    14c4:	10cc1800 	sbcne	r1, ip, r0, lsl #16
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14c8:	047a0000 	ldrbteq	r0, [sl], #-0
    14cc:	038c0000 	orreq	r0, ip, #0

    rwmVal &= 0xFFFFFFFE;
    14d0:	01190000 	tsteq	r9, r0
    SET_REG(FLASH_CR, rwmVal);

    /* verify the write */
    if (*(vu32 *)addr != word) {
    14d4:	40400353 	submi	r0, r0, r3, asr r3
        return FALSE;
    }

    return TRUE;
}
    14d8:	52011924 	andpl	r1, r1, #36, 18	; 0x90000
    14dc:	01193101 	tsteq	r9, r1, lsl #2
    14e0:	193d0151 	ldmdbne	sp!, {r0, r4, r6, r8}
    14e4:	0c055001 	stceq	0, cr5, [r5], {1}

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    14e8:	40011000 	andmi	r1, r1, r0
    14ec:	007d0219 	rsbseq	r0, sp, r9, lsl r2
    14f0:	17003001 	strne	r3, [r0, -r1]
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    14f4:	000010d0 	ldrdeq	r1, [r0], -r0
    14f8:	000004a0 	andeq	r0, r0, r0, lsr #9
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    14fc:	0010d818 	andseq	sp, r0, r8, lsl r8
    1500:	00042700 	andeq	r2, r4, r0, lsl #14
    1504:	0003ac00 	andeq	sl, r3, r0, lsl #24
    1508:	50011900 	andpl	r1, r1, r0, lsl #18

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    150c:	700d0305 	andvc	r0, sp, r5, lsl #6
	{
		pin-=8;
    1510:	17000000 	strne	r0, [r0, -r0]
	}
	mask = 0x0F << (pin<<2);
    1514:	000010dc 	ldrdeq	r1, [r0], -ip
    1518:	000004b1 			; <UNDEFINED> instruction: 0x000004b1
	return ~mask;
}	
    151c:	0010ea18 	andseq	lr, r0, r8, lsl sl

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    1520:	00042700 	andeq	r2, r4, r0, lsl #14
    1524:	0003cc00 	andeq	ip, r3, r0, lsl #24
}
    1528:	50011900 	andpl	r1, r1, r0, lsl #18
    152c:	70220305 	eorvc	r0, r2, r5, lsl #6

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    1530:	1a000000 	bne	1538 <getFlashPageSize+0x8>
	{
		return 0x800;
    1534:	000010f0 	strdeq	r1, [r0], -r0
	}
	else
	{
		return 0x400;
	}
}
    1538:	000004be 			; <UNDEFINED> instruction: 0x000004be
    153c:	05500119 	ldrbeq	r0, [r0, #-281]	; 0x119
    1540:	0080840c 	addeq	r8, r0, ip, lsl #8
    1544:	1b000008 	blne	156c <dfuInit+0x24>

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1548:	000000b1 	strheq	r0, [r0], -r1
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    154c:	00372c08 	eorseq	r2, r7, r8, lsl #24

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1550:	03050000 	movweq	r0, #20480	; 0x5000
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1554:	20000488 	andcs	r0, r0, r8, lsl #9
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    1558:	000ad91c 	andeq	sp, sl, ip, lsl r9
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    155c:	012c0700 	teqeq	ip, r0, lsl #14
    1560:	000abe1c 	andeq	fp, sl, ip, lsl lr
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1564:	012d0700 	teqeq	sp, r0, lsl #14
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1568:	000b611c 	andeq	r6, fp, ip, lsl r1
    userAppEnd = RAM_END;
    156c:	012e0700 	teqeq	lr, r0, lsl #14
    1570:	0007d21d 	andeq	sp, r7, sp, lsl r2
    userUploadType=DFU_UPLOAD_NONE;
    1574:	1c510800 	mrrcne	8, 0, r0, r1, cr0
    1578:	00000ae5 	andeq	r0, r0, r5, ror #21
    code_copy_lock = WAIT;
    157c:	1c012f07 	stcne	15, cr2, [r1], {7}
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1580:	00000b82 	andeq	r0, r0, r2, lsl #23
    1584:	1d012a07 	vstrne	s4, [r1, #-28]	; 0xffffffe4
    1588:	000004b5 			; <UNDEFINED> instruction: 0x000004b5
    memset(input, 0xFF, sizeof(input));
    158c:	fb1e5d08 	blx	7989b6 <_etext+0x79149e>
    1590:	0700000b 	streq	r0, [r0, -fp]

    sha256_starts(&ctx);
}
    1594:	043a0140 	ldrteq	r0, [sl], #-320	; 0x140
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1598:	a01f0000 	andsge	r0, pc, r0
    159c:	20000000 	andcs	r0, r0, r0
    15a0:	0af92100 	beq	ffe499a8 <BootRAM+0xedba149>
    15a4:	27070000 	strcs	r0, [r7, -r0]
    15a8:	0000fb01 	andeq	pc, r0, r1, lsl #22
    15ac:	00045500 	andeq	r5, r4, r0, lsl #10
    15b0:	00c11f00 	sbceq	r1, r1, r0, lsl #30
    15b4:	cc1f0000 	ldcgt	0, cr0, [pc], {-0}
    15b8:	00000000 	andeq	r0, r0, r0
    15bc:	000b2e22 	andeq	r2, fp, r2, lsr #28
    15c0:	37660600 	strbcc	r0, [r6, -r0, lsl #12]!
    15c4:	74000000 	strvc	r0, [r0], #-0
    15c8:	1f000004 	svcne	0x00000004
    15cc:	00000474 	andeq	r0, r0, r4, ror r4
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    15d0:	0000d61f 	andeq	sp, r0, pc, lsl r6
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    15d4:	00fb1f00 	rscseq	r1, fp, r0, lsl #30
    15d8:	05000000 	streq	r0, [r0, #-0]

    if (startState == appDETACH) {
    15dc:	0001c404 	andeq	ip, r1, r4, lsl #8
    15e0:	0b441e00 	bleq	1108de8 <_etext+0x11018d0>
        dfuAppStatus.bState = dfuIDLE;
    15e4:	28070000 	stmdacs	r7, {}	; <UNPREDICTABLE>
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
    15e8:	0004a001 	andeq	sl, r4, r1
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    15ec:	00c11f00 	sbceq	r1, r1, r0, lsl #30
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    15f0:	cc1f0000 	ldcgt	0, cr0, [pc], {-0}
    } else if (startState == appIDLE || startState == dfuIDLE) {
    15f4:	1f000000 	svcne	0x00000000
    15f8:	000000cc 	andeq	r0, r0, ip, asr #1
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    15fc:	0000c11f 	andeq	ip, r0, pc, lsl r1
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1600:	00cc1f00 	sbceq	r1, ip, r0, lsl #30
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    1604:	23000000 	movwcs	r0, #0
    1608:	00000bde 	ldrdeq	r0, [r0], -lr
    160c:	00fb7c09 	rscseq	r7, fp, r9, lsl #24
    1610:	04b10000 	ldrteq	r0, [r1], #0

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    1614:	00200000 	eoreq	r0, r0, r0
        pInformation->Ctrl_Info.Usb_wLength = 1;
    1618:	000c1e24 	andeq	r1, ip, r4, lsr #28
    161c:	be7e0900 	cdplt	9, 7, cr0, cr14, cr0, {0}
        return NULL;
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    1620:	20000004 	andcs	r0, r0, r4
    }
}
    1624:	0bb72500 	bleq	fedcaa2c <BootRAM+0xdd3b1cd>
    1628:	31070000 	mrscc	r0, (UNDEF: 7)

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    162c:	00c11f01 	sbceq	r1, r1, r1, lsl #30
        pInformation->Ctrl_Info.Usb_wLength = 6;
    1630:	00000000 	andeq	r0, r0, r0
    1634:	00001198 	muleq	r0, r8, r1
        return NULL;
    } else {
        return (u8*)(&dfuAppStatus);
    1638:	06a20004 	strteq	r0, [r2], r4
    }
}
    163c:	01040000 	mrseq	r0, (UNDEF: 4)
    1640:	00000639 	andeq	r0, r0, r9, lsr r6


u8 *dfuCopyDNLOAD(u16 length) {
    1644:	000ceb01 	andeq	lr, ip, r1, lsl #22
    if (length == 0) {
    1648:	00089300 	andeq	r9, r8, r0, lsl #6
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    164c:	00014800 	andeq	r4, r1, r0, lsl #16
    1650:	00000000 	andeq	r0, r0, r0
        thisBlockLen = pInformation->USBwLengths.w;
    1654:	00072600 	andeq	r2, r7, r0, lsl #12
        return NULL;
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1658:	0ac70200 	beq	ff1c1e60 <BootRAM+0xe132601>
    165c:	d4020000 	strle	r0, [r2], #-0
    }
}
    1660:	00000030 	andeq	r0, r0, r0, lsr r0
    1664:	57070403 	strpl	r0, [r7, -r3, lsl #8]
    1668:	02000002 	andeq	r0, r0, #2

u8 *dfuCopyUPLOAD(u16 length) {
    166c:	00000de7 	andeq	r0, r0, r7, ror #27
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    1670:	00422803 	subeq	r2, r2, r3, lsl #16
    1674:	6f040000 	svcvs	0x00040000
    1678:	04000010 	streq	r0, [r0], #-16
        return NULL;
    167c:	00590008 	subseq	r0, r9, r8
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    1680:	eb050000 	bl	141688 <_etext+0x13a170>
    1684:	5900000e 	stmdbpl	r0, {r1, r2, r3}
    1688:	00000000 	andeq	r0, r0, r0
    168c:	07040600 	streq	r0, [r4, -r0, lsl #12]
    }
}
    1690:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    1694:	01030074 	tsteq	r3, r4, ror r0
    1698:	00081a06 	andeq	r1, r8, r6, lsl #20
    169c:	0b010200 	bleq	41ea4 <_etext+0x3a98c>

void dfuCopyBufferToExec() {
    16a0:	1c040000 	stcne	0, cr0, [r4], {-0}
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    16a4:	00000074 	andeq	r0, r0, r4, ror r0
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    16a8:	18080103 	stmdane	r8, {r0, r1, r8}
    16ac:	03000008 	movweq	r0, #8
    16b0:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
    16b4:	af020000 	svcge	0x00020000
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    16b8:	0400000d 	streq	r0, [r0], #-13
	}

    flashErasePage((u32)(userSpace));
    16bc:	00008d26 	andeq	r8, r0, r6, lsr #26

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16c0:	07020300 	streq	r0, [r2, -r0, lsl #6]
    16c4:	00000949 	andeq	r0, r0, r9, asr #18
    16c8:	da050403 	ble	1426dc <_etext+0x13b1c4>
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    16cc:	02000004 	andeq	r0, r0, #4
    16d0:	00000ace 	andeq	r0, r0, lr, asr #21
    16d4:	00a63804 	adceq	r3, r6, r4, lsl #16
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16d8:	04030000 	streq	r0, [r3], #-0
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    16dc:	00025207 	andeq	r5, r2, r7, lsl #4
    16e0:	05080300 	streq	r0, [r8, #-768]	; 0x300
    thisBlockLen = 0;
    16e4:	000004d5 	ldrdeq	r0, [r0], -r5
    16e8:	4d070803 	stcmi	8, cr0, [r7, #-12]
    16ec:	03000002 	movweq	r0, #2
    16f0:	078b0704 	streq	r0, [fp, r4, lsl #14]
    16f4:	04080000 	streq	r0, [r8], #-0
    16f8:	000000c8 	andeq	r0, r0, r8, asr #1
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    16fc:	74040809 	strvc	r0, [r4], #-2057	; 0x809
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    1700:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    1704:	0000d504 	andeq	sp, r0, r4, lsl #10

    u8 startState = dfuAppStatus.bState;
    1708:	08010300 	stmdaeq	r1, {r8, r9}
    170c:	00000821 	andeq	r0, r0, r1, lsr #16
    dfuAppStatus.bStatus = OK;
    1710:	00e20408 	rsceq	r0, r2, r8, lsl #8
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    1714:	d50a0000 	strle	r0, [sl, #-0]

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    1718:	02000000 	andeq	r0, r0, #0
    171c:	00000b03 	andeq	r0, r0, r3, lsl #22
            if (pInformation->USBwLengths.w > 0) {
    1720:	00692a05 	rsbeq	r2, r9, r5, lsl #20
    1724:	b1020000 	mrslt	r0, (UNDEF: 2)
                userFirmwareLen = 0;
    1728:	0500000d 	streq	r0, [r0, #-13]
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    172c:	00008236 	andeq	r8, r0, r6, lsr r2
    1730:	0ad00200 	beq	ff401f38 <BootRAM+0xe3726d9>
    1734:	42050000 	andmi	r0, r5, #0
    1738:	0000009b 	muleq	r0, fp, r0
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    173c:	00107102 	andseq	r7, r0, r2, lsl #2
						userAppAddr = USER_CODE_FLASH0X8002000;
    1740:	37620300 	strbcc	r0, [r2, -r0, lsl #6]!
    1744:	0b000000 	bleq	174c <dfuUpdateByRequest+0x50>
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    1748:	00323375 	eorseq	r3, r2, r5, ror r3
    174c:	00a62706 	adceq	r2, r6, r6, lsl #14
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    1750:	750b0000 	strvc	r0, [fp, #-0]
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1754:	06003631 			; <UNDEFINED> instruction: 0x06003631
						flashUnlock();
    1758:	00008d28 	andeq	r8, r0, r8, lsr #26

						break;
    175c:	38750b00 	ldmdacc	r5!, {r8, r9, fp}^

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    1760:	74290600 	strtvc	r0, [r9], #-1536	; 0x600
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1764:	02000000 	andeq	r0, r0, #0
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1768:	0000035a 	andeq	r0, r0, sl, asr r3
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    176c:	013e2f06 	teqeq	lr, r6, lsl #30
    1770:	a60c0000 	strge	r0, [ip], -r0
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    1774:	02000000 	andeq	r0, r0, #0
    1778:	000001e3 	andeq	r0, r0, r3, ror #3
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    177c:	014e3006 	cmpeq	lr, r6
    1780:	8d0c0000 	stchi	0, cr0, [ip, #-0]
    1784:	02000000 	andeq	r0, r0, #0
			
            switch(pInformation->Current_AlternateSetting) {
    1788:	0000112e 	andeq	r1, r0, lr, lsr #2
    178c:	015e3306 	cmpeq	lr, r6, lsl #6
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1790:	3e0a0000 	cdpcc	0, 0, cr0, cr10, cr0, {0}
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1794:	0d000001 	stceq	0, cr0, [r0, #-4]
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1798:	78370601 	ldmdavc	r7!, {r0, r9, sl}
					userAppEnd = getFlashEnd();
    179c:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    17a0:	00000753 	andeq	r0, r0, r3, asr r7

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    17a4:	01a70e00 			; <UNDEFINED> instruction: 0x01a70e00
					dfuAppStatus.bStatus = errWRITE;
    17a8:	00010000 	andeq	r0, r1, r0
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    17ac:	00052d02 	andeq	r2, r5, r2, lsl #26
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17b0:	63370600 	teqvs	r7, #0, 12
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17b4:	0d000001 	stceq	0, cr0, [r0, #-4]
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    17b8:	983b0601 	ldmdals	fp!, {r0, r9, sl}
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17bc:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    17c0:	00000e62 	andeq	r0, r0, r2, ror #28
    17c4:	10790e00 	rsbsne	r0, r9, r0, lsl #28

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17c8:	00010000 	andeq	r0, r1, r0
                dfuCopyBufferToExec();
    17cc:	000c9302 	andeq	r9, ip, r2, lsl #6
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17d0:	833b0600 	teqhi	fp, #0, 12
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    17d4:	0f000001 	svceq	0x00000001
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    17d8:	23920728 	orrscs	r0, r2, #40, 14	; 0xa00000
    17dc:	10000002 	andne	r0, r0, r2

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    17e0:	07005243 	streq	r5, [r0, -r3, asr #4]
    17e4:	00013393 	muleq	r1, r3, r3
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17e8:	59110000 	ldmdbpl	r1, {}	; <UNPREDICTABLE>
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    17ec:	07000007 	streq	r0, [r0, -r7]
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17f0:	00013394 	muleq	r1, r4, r3
    17f4:	43100400 	tstmi	r0, #0, 8
    17f8:	07005249 	streq	r5, [r0, -r9, asr #4]
            if (pInformation->USBwLengths.w > 0) {
    17fc:	00013395 	muleq	r1, r5, r3
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    1800:	2a110800 	bcs	443808 <_etext+0x43c2f0>
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    1804:	07000000 	streq	r0, [r0, -r0]
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    1808:	00013396 	muleq	r1, r6, r3
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    180c:	1b110c00 	blne	444814 <_etext+0x43d2fc>
                }
                switch (ret)
    1810:	0700000e 	streq	r0, [r0, -lr]
    1814:	00013397 	muleq	r1, r7, r3
    1818:	45111000 	ldrmi	r1, [r1, #-0]
                {
                    case kImageImageIsTrusted:
                        uart_printf("Uploaded signature verified!\n");
    181c:	07000004 	streq	r0, [r0, -r4]
                        break;

                    case kImageImageMissingMagic:
                    case kImageImageRejectSignature:
                        uart_printf("Image unverified... wiped memory for clean reset.\n");
    1820:	00013398 	muleq	r1, r8, r3
    1824:	ef111400 	svc	0x00111400
                        break;

                    default:
                        break;
                }
                flashLock();
    1828:	07000005 	streq	r0, [r0, -r5]
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    182c:	00013399 	muleq	r1, r9, r3
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1830:	00111800 	andseq	r1, r1, r0, lsl #16
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1834:	07000000 	streq	r0, [r0, -r0]
    1838:	0001339a 	muleq	r1, sl, r3
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuMANIFEST_SYNC) {
    183c:	1e111c00 	cdpne	12, 1, cr1, cr1, cr0, {0}
        /* device has received last block, waiting DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1840:	07000006 	streq	r0, [r0, -r6]
    1844:	0001339b 	muleq	r1, fp, r3
            dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    1848:	43102000 	tstmi	r0, #0
            dfuAppStatus.bStatus = OK;
    184c:	07005253 	smlsdeq	r0, r3, r2, r5
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1850:	0001339c 	muleq	r1, ip, r3
    1854:	02002400 	andeq	r2, r0, #0, 8
            dfuAppStatus.bState  = dfuMANIFEST_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuMANIFEST) {
    1858:	00000f2b 	andeq	r0, r0, fp, lsr #30
        /* device is in manifestation phase */

        /* should never receive request while in manifest! */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
        dfuAppStatus.bStatus = OK;
    } else if (startState == dfuMANIFEST_WAIT_RESET) {
    185c:	01a39d07 			; <UNDEFINED> instruction: 0x01a39d07
        /* device has programmed new firmware but needs external
           usb reset or power on reset to run the new code */

        /* consider timing out and self-resetting */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    } else if (startState == dfuUPLOAD_IDLE) {
    1860:	3c120000 	ldccc	0, cr0, [r2], {-0}
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
    1864:	c3a00703 	movgt	r0, #786432	; 0xc0000
    1868:	11000002 	tstne	r0, r2
            if (pInformation->USBwLengths.w > 0) {
    186c:	00000d6e 	andeq	r0, r0, lr, ror #26
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1870:	02d3a107 	sbcseq	sl, r3, #-1073741823	; 0xc0000001
    1874:	11000000 	mrsne	r0, (UNDEF: 0)
    1878:	00000f8a 	andeq	r0, r0, sl, lsl #31
    187c:	02d8a207 	sbcseq	sl, r8, #1879048192	; 0x70000000
    1880:	11080000 	mrsne	r0, (UNDEF: 8)
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1884:	0000110d 	andeq	r1, r0, sp, lsl #2
    1888:	02e8a307 	rsceq	sl, r8, #469762048	; 0x1c000000
    188c:	11800000 	orrne	r0, r0, r0
    1890:	00000d73 	andeq	r0, r0, r3, ror sp
    1894:	02d8a407 	sbcseq	sl, r8, #117440512	; 0x7000000
    1898:	13880000 	orrne	r0, r8, #0
                    thisBlockLen = uploadBlockLen;
    189c:	00001178 	andeq	r1, r0, r8, ror r1
    18a0:	02eda507 	rsceq	sl, sp, #29360128	; 0x1c00000
                    dfuAppStatus.bState  = dfuUPLOAD_IDLE;
                } else {
                    /* if above comparison was just equal, thisBlockLen becomes zero
                    next time when USBWValue has been increased by one */
                    thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
    18a4:	01000000 	mrseq	r0, (UNDEF: 0)
    18a8:	000f9e13 	andeq	r9, pc, r3, lsl lr	; <UNPREDICTABLE>
    18ac:	d8a60700 	stmiale	r6!, {r8, r9, sl}
    18b0:	08000002 	stmdaeq	r0, {r1}
                    
                    /* check for overflow due to USBwValue out of range */
                    if (thisBlockLen >= pInformation->USBwLengths.w) {
    18b4:	0f261301 	svceq	0x00261301
    18b8:	a7070000 	strge	r0, [r7, -r0]
                        thisBlockLen = 0;
    18bc:	000002f2 	strdeq	r0, [r0], -r2
                    }
                    
                    dfuAppStatus.bState  = dfuIDLE;
                }
            } else {
                dfuAppStatus.bState  = dfuERROR;
    18c0:	a8130180 	ldmdage	r3, {r7, r8}
                dfuAppStatus.bStatus = errNOTDONE;
    18c4:	0700000f 	streq	r0, [r0, -pc]
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    18c8:	0002d8a8 	andeq	sp, r2, r8, lsr #17
            dfuAppStatus.bState  = dfuIDLE;
    18cc:	13018800 	movwne	r8, #6144	; 0x1800
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18d0:	00001129 	andeq	r1, r0, r9, lsr #2
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18d4:	02f7a907 	rscseq	sl, r7, #114688	; 0x1c000
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    18d8:	02000000 	andeq	r0, r0, #0
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuERROR)               {
    18dc:	000fb213 	andeq	fp, pc, r3, lsl r2	; <UNPREDICTABLE>
        /* status is in error, awaiting DFU_CLRSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18e0:	fcaa0700 	stc2	7, cr0, [sl]
    18e4:	08000002 	stmdaeq	r0, {r1}
    18e8:	50491402 	subpl	r1, r9, r2, lsl #8
            /* todo, add routine to wait for last block write to finish */
            dfuAppStatus.bState  = dfuERROR;
    18ec:	ab070052 	blge	1c1a3c <_etext+0x1ba524>
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18f0:	0000031c 	andeq	r0, r0, ip, lsl r3
            dfuAppStatus.bState  = dfuERROR;
        } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
    18f4:	15000300 	strne	r0, [r0, #-768]	; 0x300
            /* todo handle any cleanup we need here */
            dfuAppStatus.bState  = dfuIDLE;
    18f8:	00000133 	andeq	r0, r0, r3, lsr r1
            dfuAppStatus.bStatus = OK;
    18fc:	000002d3 	ldrdeq	r0, [r0], -r3
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else {
        /* some kind of error... */
        dfuAppStatus.bState  = dfuERROR;
    1900:	0000bb16 	andeq	fp, r0, r6, lsl fp
        dfuAppStatus.bStatus = errSTALLEDPKT;
    1904:	0c000100 	stfeqs	f0, [r0], {-0}
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}
    1908:	000002c3 	andeq	r0, r0, r3, asr #5
    190c:	00011315 	andeq	r1, r1, r5, lsl r3
    1910:	0002e800 	andeq	lr, r2, r0, lsl #16
    1914:	00bb1600 	adcseq	r1, fp, r0, lsl #12
    1918:	001d0000 	andseq	r0, sp, r0
    191c:	0002c30c 	andeq	ip, r2, ip, lsl #6
    1920:	02c30c00 	sbceq	r0, r3, #0, 24
    1924:	c30c0000 	movwgt	r0, #49152	; 0xc000
    1928:	0c000002 	stceq	0, cr0, [r0], {2}
    192c:	000002c3 	andeq	r0, r0, r3, asr #5
    1930:	00011315 	andeq	r1, r1, r5, lsl r3
    1934:	00030c00 	andeq	r0, r3, r0, lsl #24
    1938:	00bb1600 	adcseq	r1, fp, r0, lsl #12
    193c:	003d0000 	eorseq	r0, sp, r0
    1940:	00013315 	andeq	r3, r1, r5, lsl r3
    1944:	00031c00 	andeq	r1, r3, r0, lsl #24
    1948:	00bb1600 	adcseq	r1, fp, r0, lsl #12
    194c:	000e0000 	andeq	r0, lr, r0
    dfuAppStatus.bState = newState;
}

bool dfuUploadStarted()
{
    return dfuBusy;
    1950:	00030c0c 	andeq	r0, r3, ip, lsl #24
}
    1954:	105b0200 	subsne	r0, fp, r0, lsl #4
    1958:	ac070000 	stcge	0, cr0, [r7], {-0}

void dfuFinishUpload() {

    while (1)
	{
		__asm__ __volatile__ ("");
    195c:	0000022e 	andeq	r0, r0, lr, lsr #4
};

/* Conversion to and from projective coordinates */
void ed25519_project(struct ed25519_pt *p,
		     const uint8_t *x, const uint8_t *y)
{
    1960:	ae07040f 	cdpge	4, 0, cr0, cr7, cr15, {0}
    1964:	00000365 	andeq	r0, r0, r5, ror #6
    1968:	0005b611 	andeq	fp, r5, r1, lsl r6
    196c:	29af0700 	stmibcs	pc!, {r8, r9, sl}	; <UNPREDICTABLE>
    1970:	00000001 	andeq	r0, r0, r1
    1974:	00097011 	andeq	r7, r9, r1, lsl r0
    1978:	29b00700 	ldmibcs	r0!, {r8, r9, sl}
    197c:	01000001 	tsteq	r0, r1
    1980:	0008dd11 	andeq	sp, r8, r1, lsl sp
    1984:	29b10700 	ldmibcs	r1!, {r8, r9, sl}
    1988:	02000001 	andeq	r0, r0, #1
    198c:	00039611 	andeq	r9, r3, r1, lsl r6
    1990:	78b20700 	ldmvc	r2!, {r8, r9, sl}
    1994:	03000001 	movweq	r0, #1
    1998:	01f50200 	mvnseq	r0, r0, lsl #4
    199c:	b3070000 	movwlt	r0, #28672	; 0x7000
    19a0:	0000032c 	andeq	r0, r0, ip, lsr #6
    19a4:	b507400f 	strlt	r4, [r7, #-15]
    19a8:	00000421 	andeq	r0, r0, r1, lsr #8
    19ac:	000df611 	andeq	pc, sp, r1, lsl r6	; <UNPREDICTABLE>
    19b0:	53b60700 			; <UNDEFINED> instruction: 0x53b60700
    19b4:	00000001 	andeq	r0, r0, r1
    19b8:	00108011 	andseq	r8, r0, r1, lsl r0
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
    19bc:	33b70700 			; <UNDEFINED> instruction: 0x33b70700
	f25519_mul__distinct(p->t, x, y);
    19c0:	04000001 	streq	r0, [r0], #-1
    19c4:	00104511 	andseq	r4, r0, r1, lsl r5
}
    19c8:	33b80700 			; <UNDEFINED> instruction: 0x33b80700
		     const uint8_t *x, const uint8_t *y)
{
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
	f25519_mul__distinct(p->t, x, y);
    19cc:	08000001 	stmdaeq	r0, {r0}
}

void ed25519_unproject(uint8_t *x, uint8_t *y,
		       const struct ed25519_pt *p)
{
    19d0:	000e6a11 	andeq	r6, lr, r1, lsl sl
    19d4:	33b90700 			; <UNDEFINED> instruction: 0x33b90700
    19d8:	0c000001 	stceq	0, cr0, [r0], {1}
	uint8_t z1[F25519_SIZE];

	f25519_inv__distinct(z1, p->z);
    19dc:	52435310 	subpl	r5, r3, #16, 6	; 0x40000000
    19e0:	33ba0700 			; <UNDEFINED> instruction: 0x33ba0700
	f25519_mul__distinct(x, p->x, z1);
    19e4:	10000001 	andne	r0, r0, r1
    19e8:	52434310 	subpl	r4, r3, #16, 6	; 0x40000000
    19ec:	33bb0700 			; <UNDEFINED> instruction: 0x33bb0700
	f25519_mul__distinct(y, p->y, z1);
    19f0:	14000001 	strne	r0, [r0], #-1
    19f4:	000e0311 	andeq	r0, lr, r1, lsl r3
    19f8:	31bc0700 			; <UNDEFINED> instruction: 0x31bc0700

	f25519_normalize(x);
    19fc:	18000004 	stmdane	r0, {r2}
	f25519_normalize(y);
    1a00:	000eb911 	andeq	fp, lr, r1, lsl r9
    1a04:	33bd0700 			; <UNDEFINED> instruction: 0x33bd0700
}
    1a08:	24000001 	strcs	r0, [r0], #-1
	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
};

void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y)
{
    1a0c:	000ed911 	andeq	sp, lr, r1, lsl r9
    1a10:	33be0700 			; <UNDEFINED> instruction: 0x33be0700
    1a14:	28000001 	stmdacs	r0, {r0}
    1a18:	000e2411 	andeq	r2, lr, r1, lsl r4
    1a1c:	33bf0700 			; <UNDEFINED> instruction: 0x33bf0700
    1a20:	2c000001 	stccs	0, cr0, [r0], {1}
    1a24:	000cbf11 	andeq	fp, ip, r1, lsl pc
    1a28:	33c00700 	biccc	r0, r0, #0, 14
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
    1a2c:	30000001 	andcc	r0, r0, r1
    1a30:	000f7611 	andeq	r7, pc, r1, lsl r6	; <UNPREDICTABLE>
    1a34:	33c10700 	biccc	r0, r1, #0, 14
    1a38:	34000001 	strcc	r0, [r0], #-1
    1a3c:	00103311 	andseq	r3, r0, r1, lsl r3
    1a40:	33c20700 	biccc	r0, r2, #0, 14
    1a44:	38000001 	stmdacc	r0, {r0}
    1a48:	000e0811 	andeq	r0, lr, r1, lsl r8
    1a4c:	33c30700 	biccc	r0, r3, #0, 14
    1a50:	3c000001 	stccc	0, cr0, [r0], {1}
	parity = (tmp[0] & 1) << 7;
    1a54:	01331500 	teqeq	r3, r0, lsl #10

	f25519_copy(c, y);
	f25519_normalize(c);
    1a58:	04310000 	ldrteq	r0, [r1], #-0
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1a5c:	bb160000 	bllt	581a64 <_etext+0x57a54c>
    1a60:	02000000 	andeq	r0, r0, #0

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1a64:	04210c00 	strteq	r0, [r1], #-3072	; 0xc00
}
    1a68:	8a020000 	bhi	81a70 <_etext+0x7a558>

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1a6c:	07000010 	smladeq	r0, r0, r0, r0
    1a70:	000370c4 	andeq	r7, r3, r4, asr #1
    1a74:	071c0f00 	ldreq	r0, [ip, -r0, lsl #30]
    1a78:	0004f0c6 	andeq	pc, r4, r6, asr #1
	const int parity = comp[31] >> 7;
    1a7c:	52531000 	subspl	r1, r3, #0
    1a80:	f0c80700 			; <UNDEFINED> instruction: 0xf0c80700
    1a84:	00000004 	andeq	r0, r0, r4
    1a88:	000f8a11 	andeq	r8, pc, r1, lsl sl	; <UNPREDICTABLE>
    1a8c:	f2c90700 	vabdl.s8	q8, d9, d0
    1a90:	02000000 	andeq	r0, r0, #0
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1a94:	00524410 	subseq	r4, r2, r0, lsl r4
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1a98:	04f0ca07 	ldrbteq	ip, [r0], #2567	; 0xa07
    1a9c:	11040000 	mrsne	r0, (UNDEF: 4)
    1aa0:	00000f94 	muleq	r0, r4, pc	; <UNPREDICTABLE>
    1aa4:	00f2cb07 	rscseq	ip, r2, r7, lsl #22
    1aa8:	10060000 	andne	r0, r6, r0
	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
	f25519_add(a, b, f25519_one);
    1aac:	00525242 	subseq	r5, r2, r2, asr #4
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1ab0:	04f0cc07 	ldrbteq	ip, [r0], #3079	; 0xc07

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
    1ab4:	11080000 	mrsne	r0, (UNDEF: 8)
    1ab8:	00000f9e 	muleq	r0, lr, pc	; <UNPREDICTABLE>
	f25519_add(a, b, f25519_one);
    1abc:	00f2cd07 	rscseq	ip, r2, r7, lsl #26
    1ac0:	100a0000 	andne	r0, sl, r0
    1ac4:	00315243 	eorseq	r5, r1, r3, asr #4
	f25519_inv__distinct(b, a);
    1ac8:	04f0ce07 	ldrbteq	ip, [r0], #3591	; 0xe07
    1acc:	110c0000 	mrsne	r0, (UNDEF: 12)

	/* Compute a = y^2-1 */
	f25519_sub(a, c, f25519_one);
    1ad0:	00000fa8 	andeq	r0, r0, r8, lsr #31
    1ad4:	00f2cf07 	rscseq	ip, r2, r7, lsl #30

	/* Compute c = a*b = (y^2-1)/(1-dy^2) */
	f25519_mul__distinct(c, a, b);
    1ad8:	100e0000 	andne	r0, lr, r0
    1adc:	00325243 	eorseq	r5, r2, r3, asr #4
    1ae0:	04f0d007 	ldrbteq	sp, [r0], #7

	/* Compute a, b = +/-sqrt(c), if c is square */
	f25519_sqrt(a, c);
    1ae4:	11100000 	tstne	r0, r0
    1ae8:	00000fb2 			; <UNDEFINED> instruction: 0x00000fb2
	f25519_neg(b, a);
    1aec:	00f2d107 	rscseq	sp, r2, r7, lsl #2
    1af0:	10120000 	andsne	r0, r2, r0

	/* Select one of them, based on the compressed parity bit */
	f25519_select(x, a, b, (a[0] ^ parity) & 1);
    1af4:	00335243 	eorseq	r5, r3, r3, asr #4
    1af8:	04f0d207 	ldrbteq	sp, [r0], #519	; 0x207
    1afc:	11140000 	tstne	r4, r0
    1b00:	00000fbc 			; <UNDEFINED> instruction: 0x00000fbc
    1b04:	00f2d307 	rscseq	sp, r2, r7, lsl #6

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
    1b08:	11160000 	tstne	r6, r0
    1b0c:	00000d44 	andeq	r0, r0, r4, asr #26
    1b10:	04f0d407 	ldrbteq	sp, [r0], #1031	; 0x407
	f25519_normalize(a);
    1b14:	11180000 	tstne	r8, r0
	f25519_normalize(c);
    1b18:	00000fc6 	andeq	r0, r0, r6, asr #31
    1b1c:	00f2d507 	rscseq	sp, r2, r7, lsl #10

	return f25519_eq(a, c);
    1b20:	001a0000 	andseq	r0, sl, r0
    1b24:	0000f20c 	andeq	pc, r0, ip, lsl #4
}
    1b28:	0e0d0200 	cdpeq	2, 0, cr0, cr13, cr0, {0}
    1b2c:	d6070000 	strle	r0, [r7], -r0
    1b30:	00000441 	andeq	r0, r0, r1, asr #8
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1b34:	000d0504 	andeq	r0, sp, r4, lsl #10
    1b38:	e7070800 	str	r0, [r7, -r0, lsl #16]
    1b3c:	00000524 	andeq	r0, r0, r4, lsr #10
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b40:	00524310 	subseq	r4, r2, r0, lsl r3
    1b44:	0133e807 	teqeq	r3, r7, lsl #16
    1b48:	10000000 	andne	r0, r0, r0
	f25519_sub(d, p2->y, p2->x);
    1b4c:	00525343 	subseq	r5, r2, r3, asr #6
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b50:	0133e907 	teqeq	r3, r7, lsl #18
	f25519_sub(d, p2->y, p2->x);
    1b54:	00040000 	andeq	r0, r4, r0
    1b58:	000d8d04 	andeq	r8, sp, r4, lsl #26
	f25519_mul__distinct(a, c, d);
    1b5c:	f4073800 	vst2.8	{d3-d4}, [r7], r0
    1b60:	0000065d 	andeq	r0, r0, sp, asr r6
    1b64:	000f9411 	andeq	r9, pc, r1, lsl r4	; <UNPREDICTABLE>

	/* B = (Y1+X1)(Y2+X2) */
	f25519_add(c, p1->y, p1->x);
    1b68:	5df50700 	ldclpl	7, cr0, [r5]
    1b6c:	00000006 	andeq	r0, r0, r6
	f25519_add(d, p2->y, p2->x);
    1b70:	31524410 	cmpcc	r2, r0, lsl r4
    1b74:	43f60700 	mvnsmi	r0, #0, 14
    1b78:	04000001 	streq	r0, [r0], #-1
	f25519_mul__distinct(b, c, d);
    1b7c:	000f9e11 	andeq	r9, pc, r1, lsl lr	; <UNPREDICTABLE>
    1b80:	62f70700 	rscsvs	r0, r7, #0, 14

	/* C = T1 k T2 */
	f25519_mul__distinct(d, p1->t, p2->t);
    1b84:	06000006 	streq	r0, [r0], -r6
    1b88:	32524410 	subscc	r4, r2, #16, 8	; 0x10000000
    1b8c:	43f80700 	mvnsmi	r0, #0, 14
    1b90:	08000001 	stmdaeq	r0, {r0}
	f25519_mul__distinct(c, d, ed25519_k);
    1b94:	000fa811 	andeq	sl, pc, r1, lsl r8	; <UNPREDICTABLE>
    1b98:	62f90700 	rscsvs	r0, r9, #0, 14

	/* D = Z1 2 Z2 */
	f25519_mul__distinct(d, p1->z, p2->z);
    1b9c:	0a000006 	beq	1bbc <ed25519_add+0x88>
    1ba0:	33524410 	cmpcc	r2, #16, 8	; 0x10000000
    1ba4:	43fa0700 	mvnsmi	r0, #0, 14
    1ba8:	0c000001 	stceq	0, cr0, [r0], {1}
	f25519_add(d, d, d);
    1bac:	000fb211 	andeq	fp, pc, r1, lsl r2	; <UNPREDICTABLE>
    1bb0:	62fb0700 	rscsvs	r0, fp, #0, 14

	/* E = B - A */
	f25519_sub(e, b, a);
    1bb4:	0e000006 	cdpeq	0, 0, cr0, cr0, cr6, {0}
    1bb8:	34524410 	ldrbcc	r4, [r2], #-1040	; 0x410
    1bbc:	43fc0700 	mvnsmi	r0, #0, 14

	/* F = D - C */
	f25519_sub(f, d, c);
    1bc0:	10000001 	andne	r0, r0, r1
    1bc4:	000fbc11 	andeq	fp, pc, r1, lsl ip	; <UNPREDICTABLE>

	/* G = D + C */
	f25519_add(g, d, c);
    1bc8:	62fd0700 	rscsvs	r0, sp, #0, 14
    1bcc:	12000006 	andne	r0, r0, #6
    1bd0:	35524410 	ldrbcc	r4, [r2, #-1040]	; 0x410

	/* H = B + A */
	f25519_add(h, b, a);
    1bd4:	43fe0700 	mvnsmi	r0, #0, 14
    1bd8:	14000001 	strne	r0, [r0], #-1

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1bdc:	000fc611 	andeq	ip, pc, r1, lsl r6	; <UNPREDICTABLE>
    1be0:	62ff0700 	rscsvs	r0, pc, #0, 14
    1be4:	16000006 	strne	r0, [r0], -r6

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1be8:	36524417 			; <UNDEFINED> instruction: 0x36524417
    1bec:	01000700 	tsteq	r0, r0, lsl #14
    1bf0:	00000143 	andeq	r0, r0, r3, asr #2

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1bf4:	119c1818 	orrsne	r1, ip, r8, lsl r8
    1bf8:	01070000 	mrseq	r0, (UNDEF: 7)
    1bfc:	00066201 	andeq	r6, r6, r1, lsl #4

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1c00:	44171a00 	ldrmi	r1, [r7], #-2560	; 0xa00
    1c04:	07003752 	smlsdeq	r0, r2, r7, r3
    1c08:	01430102 	cmpeq	r3, r2, lsl #2
}
    1c0c:	181c0000 	ldmdane	ip, {}	; <UNPREDICTABLE>
    1c10:	00000fd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1c14:	62010307 	andvs	r0, r1, #469762048	; 0x1c000000
    1c18:	1e000006 	cdpne	0, 0, cr0, cr0, cr6, {0}

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1c1c:	38524417 	ldmdacc	r2, {r0, r1, r2, r4, sl, lr}^
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1c20:	01040700 	tsteq	r4, r0, lsl #14
    1c24:	00000143 	andeq	r0, r0, r3, asr #2

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1c28:	0fda1820 	svceq	0x00da1820
    1c2c:	05070000 	streq	r0, [r7, #-0]
    1c30:	00066201 	andeq	r6, r6, r1, lsl #4

	/* C = 2 Z1^2 */
	f25519_mul__distinct(c, p->z, p->z);
    1c34:	44172200 	ldrmi	r2, [r7], #-512	; 0x200
    1c38:	07003952 	smlsdeq	r0, r2, r9, r3
    1c3c:	01430106 	cmpeq	r3, r6, lsl #2
	f25519_add(c, c, c);
    1c40:	18240000 	stmdane	r4!, {}	; <UNPREDICTABLE>
    1c44:	000010f7 	strdeq	r1, [r0], -r7

	/* D = a A (alter sign) */
	/* E = (X1+Y1)^2-A-B */
	f25519_add(f, p->x, p->y);
    1c48:	62010707 	andvs	r0, r1, #1835008	; 0x1c0000
    1c4c:	26000006 	strcs	r0, [r0], -r6
    1c50:	000f2118 	andeq	r2, pc, r8, lsl r1	; <UNPREDICTABLE>
	f25519_mul__distinct(e, f, f);
    1c54:	01080700 	tsteq	r8, r0, lsl #14
    1c58:	00000143 	andeq	r0, r0, r3, asr #2
	f25519_sub(e, e, a);
    1c5c:	11021828 	tstne	r2, r8, lsr #16
    1c60:	09070000 	stmdbeq	r7, {}	; <UNPREDICTABLE>
    1c64:	00066201 	andeq	r6, r6, r1, lsl #4
	f25519_sub(e, e, b);
    1c68:	4b182a00 	blmi	60c470 <_etext+0x604f58>
    1c6c:	07000011 	smladeq	r0, r1, r0, r0

	/* G = D + B */
	f25519_sub(g, b, a);
    1c70:	0133010a 	teqeq	r3, sl, lsl #2
    1c74:	172c0000 	strne	r0, [ip, -r0]!
    1c78:	07005243 	streq	r5, [r0, -r3, asr #4]

	/* F = G - C */
	f25519_sub(f, g, c);
    1c7c:	0133010b 	teqeq	r3, fp, lsl #2
    1c80:	17300000 	ldrne	r0, [r0, -r0]!

	/* H = D - B */
	f25519_neg(h, b);
    1c84:	00525343 	subseq	r5, r2, r3, asr #6
    1c88:	33010c07 	movwcc	r0, #7175	; 0x1c07
	f25519_sub(h, h, a);
    1c8c:	34000001 	strcc	r0, [r0], #-1
    1c90:	01130a00 	tsteq	r3, r0, lsl #20
    1c94:	1e0a0000 	cdpne	0, 0, cr0, cr10, cr0, {0}

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1c98:	19000001 	stmdbne	r0, {r0}
    1c9c:	00000f53 	andeq	r0, r0, r3, asr pc

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1ca0:	0115070c 	tsteq	r5, ip, lsl #14
    1ca4:	000006a9 	andeq	r0, r0, r9, lsr #13
    1ca8:	00108518 	andseq	r8, r0, r8, lsl r5

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1cac:	01160700 	tsteq	r6, r0, lsl #14
    1cb0:	000000f2 	strdeq	r0, [r0], -r2
    1cb4:	10201800 	eorne	r1, r0, r0, lsl #16

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1cb8:	17070000 	strne	r0, [r7, -r0]
    1cbc:	0000f201 	andeq	pc, r0, r1, lsl #4
    1cc0:	96180200 	ldrls	r0, [r8], -r0, lsl #4
}
    1cc4:	07000010 	smladeq	r0, r0, r0, r0

void ed25519_smult(struct ed25519_pt *r_out, const struct ed25519_pt *p,
		   const uint8_t *e)
{
    1cc8:	00fd0118 	rscseq	r0, sp, r8, lsl r1
    1ccc:	18040000 	stmdane	r4, {}	; <UNPREDICTABLE>
    1cd0:	0000109b 	muleq	r0, fp, r0
    1cd4:	fd011907 	stc2	9, cr1, [r1, #-28]	; 0xffffffe4
    1cd8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    1cdc:	01100f00 	tsteq	r0, r0, lsl #30
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1ce0:	0006fa5f 	andeq	pc, r6, pc, asr sl	; <UNPREDICTABLE>
    1ce4:	0d511100 	ldfeqe	f1, [r1, #-0]
    1ce8:	61010000 	mrsvs	r0, (UNDEF: 1)
		struct ed25519_pt s;

		ed25519_double(&r, &r);
    1cec:	000000fd 	strdeq	r0, [r0], -sp
    1cf0:	0cda1100 	ldfeqe	f1, [sl], {0}
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1cf4:	66010000 	strvs	r0, [r1], -r0
		struct ed25519_pt s;

		ed25519_double(&r, &r);
		ed25519_add(&s, &r, p);
    1cf8:	000000f2 	strdeq	r0, [r0], -r2
    1cfc:	0cf61104 	ldfeqe	f1, [r6], #16

		f25519_select(r.x, r.x, s.x, bit);
    1d00:	69010000 	stmdbvs	r1, {}	; <UNPREDICTABLE>
    1d04:	000000f2 	strdeq	r0, [r0], -r2
    1d08:	0da21106 	stfeqs	f1, [r2, #24]!
		f25519_select(r.y, r.y, s.y, bit);
    1d0c:	6c010000 	stcvs	0, cr0, [r1], {-0}
    1d10:	000000f2 	strdeq	r0, [r0], -r2
    1d14:	0e971108 	fmleqs	f1, f7, #0.0
		f25519_select(r.z, r.z, s.z, bit);
    1d18:	73010000 	movwvc	r0, #4096	; 0x1000
    1d1c:	000000f2 	strdeq	r0, [r0], -r2
    1d20:	0ebf110a 	frdeqe	f1, f7, #2.0
		f25519_select(r.t, r.t, s.t, bit);
    1d24:	76010000 	strvc	r0, [r1], -r0
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d28:	000000f2 	strdeq	r0, [r0], -r2
		ed25519_add(&s, &r, p);

		f25519_select(r.x, r.x, s.x, bit);
		f25519_select(r.y, r.y, s.y, bit);
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
    1d2c:	1702000c 	strne	r0, [r2, -ip]
    1d30:	01000011 	tsteq	r0, r1, lsl r0
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d34:	0006a979 	andeq	sl, r6, r9, ror r9
    1d38:	01010d00 	tsteq	r1, r0, lsl #26
    1d3c:	00072092 	muleq	r7, r2, r0
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
	}

	ed25519_copy(r_out, &r);
}
    1d40:	0d7c0e00 	ldcleq	14, cr0, [ip, #-0]
    1d44:	0e010000 	cdpeq	0, 0, cr0, cr1, cr0, {0}
    1d48:	00000d34 	andeq	r0, r0, r4, lsr sp
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1d4c:	10cb0e02 	sbcne	r0, fp, r2, lsl #28
    1d50:	00030000 	andeq	r0, r3, r0
    1d54:	00115102 	andseq	r5, r1, r2, lsl #2
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d58:	05960100 	ldreq	r0, [r6, #256]	; 0x100
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1d5c:	0d000007 	stceq	0, cr0, [r0, #-28]	; 0xffffffe4
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d60:	65990101 	ldrvs	r0, [r9, #257]	; 0x101
    1d64:	0e000007 	cdpeq	0, 0, cr0, cr0, cr7, {0}
    1d68:	00000f7c 	andeq	r0, r0, ip, ror pc
    1d6c:	11860e00 	orrne	r0, r6, r0, lsl #28
	memcpy(block + 32, a, 32);
    1d70:	0e040000 	cdpeq	0, 0, cr0, cr4, cr0, {0}
    1d74:	00000dc5 	andeq	r0, r0, r5, asr #27
    1d78:	0dd90e28 	ldcleq	14, cr0, [r9, #160]	; 0xa0
    1d7c:	00c80000 	sbceq	r0, r8, r0
    1d80:	0010e60e 	andseq	lr, r0, lr, lsl #12
    1d84:	4c0e1400 	cfstrsmi	mvf1, [lr], {-0}
    1d88:	1000000e 	andne	r0, r0, lr
    1d8c:	000f390e 	andeq	r3, pc, lr, lsl #18
    1d90:	e40e1c00 	str	r1, [lr], #-3072	; 0xc00
    1d94:	1800000f 	stmdane	r0, {r0, r1, r2, r3}
    1d98:	104a0200 	subne	r0, sl, r0, lsl #4
    1d9c:	a1010000 	mrsge	r0, (UNDEF: 1)
{
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
    1da0:	0000072b 	andeq	r0, r0, fp, lsr #14
    1da4:	a301040f 	movwge	r0, #5135	; 0x140f
    1da8:	0000079d 	muleq	r0, sp, r7
		memcpy(init_block + prefix_size, message, len);
		sha512_final(&s, init_block, len + prefix_size);
	} else {
		size_t i;

		memcpy(init_block + prefix_size, message,
    1dac:	000c6911 	andeq	r6, ip, r1, lsl r9
    1db0:	f2a50100 	vaddw.s32	q0, <illegal reg q2.5>, d0
    1db4:	00000000 	andeq	r0, r0, r0
    1db8:	000ff411 	andeq	pc, pc, r1, lsl r4	; <UNPREDICTABLE>
    1dbc:	20a80100 	adccs	r0, r8, r0, lsl #2
    1dc0:	02000007 	andeq	r0, r0, #7
    1dc4:	000c5f11 	andeq	r5, ip, r1, lsl pc
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);
    1dc8:	65ab0100 	strvs	r0, [fp, #256]!	; 0x100
    1dcc:	03000007 	movweq	r0, #7

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dd0:	10a00200 	adcne	r0, r0, r0, lsl #4
    1dd4:	ad010000 	stcge	0, cr0, [r1, #-0]
    1dd8:	00000770 	andeq	r0, r0, r0, ror r7
    1ddc:	af011c0f 	svcge	0x00011c0f
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1de0:	00000805 	andeq	r0, r0, r5, lsl #16
		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
		     i + SHA512_BLOCK_SIZE <= len;
    1de4:	4c524310 	mrrcmi	3, 1, r4, r2, cr0
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1de8:	05b10100 	ldreq	r0, [r1, #256]!	; 0x100

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dec:	00000008 	andeq	r0, r0, r8
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
    1df0:	48524310 	ldmdami	r2, {r4, r8, r9, lr}^
    1df4:	05b20100 	ldreq	r0, [r2, #256]!	; 0x100
    1df8:	04000008 	streq	r0, [r0], #-8
    1dfc:	52444910 	subpl	r4, r4, #16, 18	; 0x40000
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
		memcpy(init_block + prefix_size, message, len);
    1e00:	05b30100 	ldreq	r0, [r3, #256]!	; 0x100
    1e04:	08000008 	stmdaeq	r0, {r3}
    1e08:	52444f10 	subpl	r4, r4, #16, 30	; 0x40
		sha512_final(&s, init_block, len + prefix_size);
    1e0c:	05b40100 	ldreq	r0, [r4, #256]!	; 0x100
    1e10:	0c000008 	stceq	0, cr0, [r0], {8}
    1e14:	000c5a11 	andeq	r5, ip, r1, lsl sl
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
	}

	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
    1e18:	05b50100 	ldreq	r0, [r5, #256]!	; 0x100
    1e1c:	10000008 	andne	r0, r0, r8
    1e20:	52524210 	subspl	r4, r2, #16, 4
	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
    1e24:	05b60100 	ldreq	r0, [r6, #256]!	; 0x100
    1e28:	14000008 	strne	r0, [r0], #-8
    1e2c:	0011c811 	andseq	ip, r1, r1, lsl r8

static void sm_pack(uint8_t *r, const uint8_t *k)
{
	struct ed25519_pt p;

	ed25519_smult(&p, &ed25519_base, k);
    1e30:	05b70100 	ldreq	r0, [r7, #256]!	; 0x100
    1e34:	18000008 	stmdane	r0, {r3}
    1e38:	00fd0c00 	rscseq	r0, sp, r0, lsl #24
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1e3c:	38020000 	stmdacc	r2, {}	; <UNPREDICTABLE>
    1e40:	01000010 	tsteq	r0, r0, lsl r0
	ed25519_pack(packed, x, y);
    1e44:	0007a8b8 			; <UNDEFINED> instruction: 0x0007a8b8
    1e48:	07db1a00 	ldrbeq	r1, [fp, r0, lsl #20]
    1e4c:	3a010000 	bcc	41e54 <_etext+0x3a93c>

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e50:	00001124 	andeq	r1, r0, r4, lsr #2
    1e54:	00000016 	andeq	r0, r0, r6, lsl r0

	ed25519_project(p, x, y);
    1e58:	08569c01 	ldmdaeq	r6, {r0, sl, fp, ip, pc}^
    1e5c:	631b0000 	tstvs	fp, #0
    1e60:	01000011 	tsteq	r0, r1, lsl r0
	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
    1e64:	0001133a 	andeq	r1, r1, sl, lsr r3
    1e68:	1c500100 	ldfnee	f0, [r0], {-0}
    1e6c:	006e6970 	rsbeq	r6, lr, r0, ror r9

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e70:	01293a01 	teqeq	r9, r1, lsl #20
    1e74:	03220000 	teqeq	r2, #0

	ed25519_project(p, x, y);
    1e78:	761c0000 	ldrvc	r0, [ip], -r0
    1e7c:	01006c61 	tsteq	r0, r1, ror #24
    1e80:	0001293a 	andeq	r2, r1, sl, lsr r9

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
    1e84:	00034300 	andeq	r4, r3, r0, lsl #6
    1e88:	f91d0000 			; <UNDEFINED> instruction: 0xf91d0000
    1e8c:	0100000a 	tsteq	r0, sl
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1e90:	0001783f 	andeq	r7, r1, pc, lsr r8
    1e94:	00113a00 	andseq	r3, r1, r0, lsl #20
	ed25519_pack(packed, x, y);
    1e98:	00001200 	andeq	r1, r0, r0, lsl #4
    1e9c:	8e9c0100 	fmlhie	f0, f4, f0
    1ea0:	1e000008 	cdpne	0, 0, cr0, cr0, cr8, {0}
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
    1ea4:	00001163 	andeq	r1, r0, r3, ror #2
    1ea8:	01133f01 	tsteq	r3, r1, lsl #30
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
    1eac:	03790000 	cmneq	r9, #0
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
}
    1eb0:	701c0000 	andsvc	r0, ip, r0
    1eb4:	01006e69 	tsteq	r0, r9, ror #28

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1eb8:	0001293f 	andeq	r2, r1, pc, lsr r9
    1ebc:	00039a00 	andeq	r9, r3, r0, lsl #20
    1ec0:	441a0000 	ldrmi	r0, [sl], #-0
    1ec4:	0100000b 	tsteq	r0, fp

const uint8_t f25519_zero[F25519_SIZE] = {0};
const uint8_t f25519_one[F25519_SIZE] = {1};

void f25519_load(uint8_t *x, uint32_t c)
{
    1ec8:	00114c48 	andseq	r4, r1, r8, asr #24
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
		c >>= 8;
    1ecc:	00005000 	andeq	r5, r0, r0
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    1ed0:	579c0100 	ldrpl	r0, [ip, r0, lsl #2]
    1ed4:	1e000009 	cdpne	0, 0, cr0, cr0, cr9, {0}
    1ed8:	00001163 	andeq	r1, r0, r3, ror #2
    1edc:	01134801 	tsteq	r3, r1, lsl #16
		c >>= 8;
	}

	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}
    1ee0:	03bb0000 			; <UNDEFINED> instruction: 0x03bb0000
    1ee4:	701c0000 	andsvc	r0, ip, r0

void f25519_normalize(uint8_t *x)
{
    1ee8:	01006e69 	tsteq	r0, r9, ror #28
    1eec:	00012948 	andeq	r2, r1, r8, asr #18
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1ef0:	0003d900 	andeq	sp, r3, r0, lsl #18
	x[31] &= 127;
    1ef4:	0bb11e00 	bleq	fec496fc <BootRAM+0xdbb9e9d>

	for (i = 0; i < F25519_SIZE; i++) {
    1ef8:	48010000 	stmdami	r1, {}	; <UNPREDICTABLE>
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1efc:	00000129 	andeq	r0, r0, r9, lsr #2
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
		c += x[i];
    1f00:	000003fa 	strdeq	r0, [r0], -sl
		x[i] = c;
    1f04:	000e5d1e 	andeq	r5, lr, lr, lsl sp

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1f08:	13480100 	movtne	r0, #33024	; 0x8100
		c += x[i];
		x[i] = c;
		c >>= 8;
    1f0c:	42000001 	andmi	r0, r0, #1

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1f10:	1b000004 	blne	1f28 <f25519_normalize+0x40>
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += x[i];
    1f14:	00000d49 	andeq	r0, r0, r9, asr #26
		minusp[i] = c;
    1f18:	01294801 	teqeq	r9, r1, lsl #16
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1f1c:	91020000 	mrsls	r0, (UNDEF: 2)
		c += x[i];
		minusp[i] = c;
		c >>= 8;
    1f20:	00631f00 	rsbeq	r1, r3, r0, lsl #30
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1f24:	01134c01 	tsteq	r3, r1, lsl #24
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1f28:	04600000 	strbteq	r0, [r0], #-0
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1f2c:	68200000 	stmdavs	r0!, {}	; <UNPREDICTABLE>

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1f30:	15000011 	strne	r0, [r0, #-17]
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;
    1f34:	1a000008 	bne	1f5c <f25519_eq+0x4>

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1f38:	21000009 	tstcs	r0, r9
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    1f3c:	77025201 	strvc	r5, [r2, -r1, lsl #4]
    1f40:	51012100 	mrspl	r2, (UNDEF: 17)
    1f44:	21007902 	tstcs	r0, r2, lsl #18
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1f48:	78025001 	stmdavc	r2, {r0, ip, lr}
    1f4c:	7e200000 	cdpvc	0, 2, cr0, cr0, cr0, {0}
	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;

	/* Load x-p if no underflow */
	f25519_select(x, minusp, x, (c >> 15) & 1);
}
    1f50:	15000011 	strne	r0, [r0, #-17]
    1f54:	3a000008 	bcc	1f7c <f25519_eq+0x24>

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
    1f58:	21000009 	tstcs	r0, r9
    1f5c:	7a025201 	bvc	96768 <_etext+0x8f250>
    1f60:	51012100 	mrspl	r2, (UNDEF: 17)
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    1f64:	21007902 	tstcs	r0, r2, lsl #18
    1f68:	78025001 	stmdavc	r2, {r0, ip, lr}
    1f6c:	94220000 	strtls	r0, [r2], #-0
    1f70:	15000011 	strne	r0, [r0, #-17]
    1f74:	21000008 	tstcs	r0, r8
    1f78:	77025201 	strvc	r5, [r2, -r1, lsl #4]
    1f7c:	51012100 	mrspl	r2, (UNDEF: 17)
    1f80:	21007902 	tstcs	r0, r2, lsl #18
    1f84:	78025001 	stmdavc	r2, {r0, ip, lr}
    1f88:	23000000 	movwcs	r0, #0
    1f8c:	00001006 	andeq	r1, r0, r6
    1f90:	9c011f01 	stcls	15, cr1, [r1], {1}
    1f94:	0a000011 	beq	1fe0 <f25519_eq+0x88>
    1f98:	01000000 	mrseq	r0, (UNDEF: 0)
    1f9c:	0009899c 	muleq	r9, ip, r9
    1fa0:	0f6f2400 	svceq	0x006f2400
    1fa4:	1f010000 	svcne	0x00010000
    1fa8:	00098901 	andeq	r8, r9, r1, lsl #18
    1fac:	25500100 	ldrbcs	r0, [r0, #-256]	; 0x100
    1fb0:	01006863 	tsteq	r0, r3, ror #16
    1fb4:	00e7011f 	rsceq	r0, r7, pc, lsl r1
    1fb8:	51010000 	mrspl	r0, (UNDEF: 1)
    1fbc:	f5040800 			; <UNDEFINED> instruction: 0xf5040800
    1fc0:	23000004 	movwcs	r0, #4

	sum |= (sum >> 4);
    1fc4:	00000ede 	ldrdeq	r0, [r0], -lr
	sum |= (sum >> 2);
    1fc8:	a6012501 	strge	r2, [r1], -r1, lsl #10
	sum |= (sum >> 1);
    1fcc:	16000011 			; <UNDEFINED> instruction: 0x16000011

	return (sum ^ 1) & 1;
    1fd0:	01000000 	mrseq	r0, (UNDEF: 0)
}
    1fd4:	0009d69c 	muleq	r9, ip, r6
    1fd8:	0f6f2600 	svceq	0x006f2600
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fdc:	25010000 	strcs	r0, [r1, #-0]
		sum |= x[i] ^ y[i];
    1fe0:	00098901 	andeq	r8, r9, r1, lsl #18
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fe4:	00048900 	andeq	r8, r4, r0, lsl #18
    1fe8:	74732700 	ldrbtvc	r2, [r3], #-1792	; 0x700
		sum |= x[i] ^ y[i];
    1fec:	25010072 	strcs	r0, [r1, #-114]	; 0x72
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1ff0:	0009d601 	andeq	sp, r9, r1, lsl #12
}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
    1ff4:	0004a700 	andeq	sl, r4, r0, lsl #14
    1ff8:	11b82200 			; <UNDEFINED> instruction: 0x11b82200
    1ffc:	09570000 	ldmdbeq	r7, {}^	; <UNPREDICTABLE>
    2000:	01210000 	teqeq	r1, r0
    2004:	00750250 	rsbseq	r0, r5, r0, asr r2
    2008:	04080000 	streq	r0, [r8], #-0
    200c:	000000e7 	andeq	r0, r0, r7, ror #1
    2010:	000f6823 	andeq	r6, pc, r3, lsr #16
    2014:	012e0100 	teqeq	lr, r0, lsl #2
	const uint8_t mask = -condition;
    2018:	000011bc 			; <UNDEFINED> instruction: 0x000011bc
    201c:	00000028 	andeq	r0, r0, r8, lsr #32
    2020:	0a579c01 	beq	15e902c <_etext+0x15e1b14>
    2024:	66270000 	strtvs	r0, [r7], -r0
    2028:	0100746d 	tsteq	r0, sp, ror #8
    202c:	00dc012e 	sbcseq	r0, ip, lr, lsr #2
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    2030:	04ea0000 	strbteq	r0, [sl], #0
    2034:	4e260000 	cdpmi	0, 2, cr0, cr6, cr0, {0}
    2038:	0100000f 	tsteq	r0, pc
    203c:	0108012e 	tsteq	r8, lr, lsr #2
    2040:	05160000 	ldreq	r0, [r6, #-0]
    2044:	78280000 	stmdavc	r8!, {}	; <UNPREDICTABLE>
    2048:	0100000e 	tsteq	r0, lr
    204c:	0a570130 	beq	15c2514 <_etext+0x15baffc>
    2050:	91030000 	mrsls	r0, (UNDEF: 3)
    2054:	cc207eb0 	stcgt	14, cr7, [r0], #-704	; 0xfffffd40
    2058:	f3000011 	vqadd.u8	d0, d0, d1
    205c:	3d000010 	stccc	0, cr0, [r0, #-64]	; 0xffffffc0
    2060:	2100000a 	tstcs	r0, sl
    2064:	f3035101 	vrhadd.u8	d5, d3, d1
    2068:	01215001 	teqeq	r1, r1
    206c:	007d0250 	rsbseq	r0, sp, r0, asr r2
    2070:	11d82200 	bicsne	r2, r8, r0, lsl #4
    2074:	098f0000 	stmibeq	pc, {}	; <UNPREDICTABLE>
    2078:	01210000 	teqeq	r1, r0
    207c:	007d0251 	rsbseq	r0, sp, r1, asr r2
    2080:	05500121 	ldrbeq	r0, [r0, #-289]	; 0x121
    2084:	0138000c 	teqeq	r8, ip
    2088:	15000040 	strne	r0, [r0, #-64]	; 0x40
    208c:	000000d5 	ldrdeq	r0, [r0], -r5
    2090:	00000a67 	andeq	r0, r0, r7, ror #20
    2094:	0000bb16 	andeq	fp, r0, r6, lsl fp
    2098:	2300c700 	movwcs	ip, #1792	; 0x700
}
    209c:	00000bfb 	strdeq	r0, [r0], -fp
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    20a0:	e4013801 	str	r3, [r1], #-2049	; 0x801
    20a4:	1a000011 	bne	20f0 <f25519_add+0x38>
    20a8:	01000000 	mrseq	r0, (UNDEF: 0)
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    20ac:	000ab49c 	muleq	sl, ip, r4
    20b0:	6d662500 	cfstr64vs	mvdx2, [r6, #-0]
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}
    20b4:	38010074 	stmdacc	r1, {r2, r4, r5, r6}
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    20b8:	0000dc01 	andeq	sp, r0, r1, lsl #24
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}

void f25519_add(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint16_t c = 0;
    20bc:	70910200 	addsvc	r0, r1, r0, lsl #4
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
    20c0:	0f4e2829 	svceq	0x004e2829
    20c4:	3a010000 	bcc	420cc <_etext+0x3abb4>
		r[i] = c;
    20c8:	00010801 	andeq	r0, r1, r1, lsl #16
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    20cc:	64910200 	ldrvs	r0, [r1], #512	; 0x200
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;
    20d0:	0011f422 	andseq	pc, r1, r2, lsr #8
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20d4:	0009dc00 	andeq	sp, r9, r0, lsl #24
	c = (c >> 7) * 19;
    20d8:	51012100 	mrspl	r2, (UNDEF: 17)
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20dc:	21549102 	cmpcs	r4, r2, lsl #2
	c = (c >> 7) * 19;
    20e0:	91035001 	tstls	r3, r1
    20e4:	00000650 	andeq	r0, r0, r0, asr r6

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    20e8:	000d2c23 	andeq	r2, sp, r3, lsr #24
    20ec:	01400100 	mrseq	r0, (UNDEF: 80)

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    20f0:	000011fe 	strdeq	r1, [r0], -lr
		c += r[i];
		r[i] = c;
		c >>= 8;
    20f4:	0000002e 	andeq	r0, r0, lr, lsr #32

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    20f8:	0b429c01 	bleq	10a9104 <_etext+0x10a1bec>
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    20fc:	8b260000 	blhi	982104 <_etext+0x97abec>

void f25519_sub(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2100:	0100000e 	tsteq	r0, lr
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
    2104:	00c90140 	sbceq	r0, r9, r0, asr #2
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2108:	05290000 	streq	r0, [r9, #-0]!
    210c:	18260000 	stmdane	r6!, {}	; <UNPREDICTABLE>
    2110:	0100001a 	tsteq	r0, sl, lsl r0
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2114:	00250140 	eoreq	r0, r5, r0, asr #2
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2118:	054a0000 	strbeq	r0, [sl, #-0]
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    211c:	692a0000 	stmdbvs	sl!, {}	; <UNPREDICTABLE>
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2120:	01420100 	mrseq	r0, (UNDEF: 82)
    2124:	0000005b 	andeq	r0, r0, fp, asr r0
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2128:	00000568 	andeq	r0, r0, r8, ror #10
    212c:	0073632b 	rsbseq	r6, r3, fp, lsr #6
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2130:	42014301 	andmi	r4, r1, #67108864	; 0x4000000
	c = (c >> 7) * 19;
    2134:	0200000b 	andeq	r0, r0, #11

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2138:	0e205c91 	mcreq	12, 1, r5, cr0, cr1, {4}
		r[i] = c;
    213c:	12000012 	andne	r0, r0, #18

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2140:	24000011 	strcs	r0, [r0], #-17
		c += r[i];
		r[i] = c;
		c >>= 8;
    2144:	2100000b 	tstcs	r0, fp
	}
}
    2148:	41015201 	tstmi	r1, r1, lsl #4

void f25519_neg(uint8_t *r, const uint8_t *a)
{
    214c:	01510121 	cmpeq	r1, r1, lsr #2
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
    2150:	50012130 	andpl	r2, r1, r0, lsr r1
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 - ((uint32_t)a[i]);
    2154:	005c9102 	subseq	r9, ip, r2, lsl #2
    2158:	00122422 	andseq	r2, r2, r2, lsr #8
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    215c:	00111200 	andseq	r1, r1, r0, lsl #4
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
    2160:	52012100 	andpl	r2, r1, #0, 2
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2164:	01214101 	teqeq	r1, r1, lsl #2

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2168:	00740451 	rsbseq	r0, r4, r1, asr r4
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;
    216c:	01211a3f 	teqeq	r1, pc, lsr sl
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    2170:	5c910250 	lfmpl	f0, 4, [r1], {80}	; 0x50
	c = (c >> 7) * 19;
    2174:	d5150000 	ldrle	r0, [r5, #-0]
    2178:	52000000 	andpl	r0, r0, #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    217c:	1600000b 	strne	r0, [r0], -fp
		r[i] = c;
    2180:	000000bb 	strheq	r0, [r0], -fp

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2184:	82230010 	eorhi	r0, r3, #16
		c += r[i];
		r[i] = c;
		c >>= 8;
    2188:	0100000b 	tsteq	r0, fp
	}
}
    218c:	122c0166 	eorne	r0, ip, #-2147483623	; 0x80000019
    2190:	00880000 	addeq	r0, r8, r0

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2194:	9c010000 	stcls	0, cr0, [r1], {-0}
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2198:	00000c41 	andeq	r0, r0, r1, asr #24
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    219c:	000f0e28 	andeq	r0, pc, r8, lsr #28
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    21a0:	01670100 	cmneq	r7, r0, lsl #2
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    21a4:	0000079d 	muleq	r0, sp, r7
		for (j = 0; j <= i; j++)
    21a8:	28649102 	stmdacs	r4!, {r1, r8, ip, pc}^
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    21ac:	00000e38 	andeq	r0, r0, r8, lsr lr

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    21b0:	fa016801 	blx	5c1bc <_etext+0x54ca4>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    21b4:	02000006 	andeq	r0, r0, #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    21b8:	ba2c6891 	blt	b1c404 <_etext+0xb14eec>
    21bc:	0100000d 	tsteq	r0, sp
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21c0:	005b0183 	subseq	r0, fp, r3, lsl #3
    21c4:	0b980000 	bleq	fe6021cc <BootRAM+0xd57296d>
    21c8:	00290000 	eoreq	r0, r9, r0
    21cc:	0010dc2c 	andseq	sp, r0, ip, lsr #24
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    21d0:	01860100 	orreq	r0, r6, r0, lsl #2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    21d4:	0000005b 	andeq	r0, r0, fp, asr r0
    21d8:	00000baa 	andeq	r0, r0, sl, lsr #23

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21dc:	3c200029 	stccc	0, cr0, [r0], #-164	; 0xffffff5c
			c += ((uint32_t)a[j]) *
    21e0:	2f000012 	svccs	0x00000012
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    21e4:	c4000011 	strgt	r0, [r0], #-17
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    21e8:	2100000b 	tstcs	r0, fp
    21ec:	31015101 	tstcc	r1, r1, lsl #2
    21f0:	03500121 	cmpeq	r0, #1073741832	; 0x40000008

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    21f4:	0040000a 	subeq	r0, r0, sl
    21f8:	00124420 	andseq	r4, r2, r0, lsr #8
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    21fc:	00112f00 	andseq	r2, r1, r0, lsl #30
	c = (c >> 7) * 19;
    2200:	000bdd00 	andeq	sp, fp, r0, lsl #26

	for (i = 0; i < F25519_SIZE; i++) {
    2204:	51012100 	mrspl	r2, (UNDEF: 17)
		c += r[i];
    2208:	01213101 	teqeq	r1, r1, lsl #2
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    220c:	00740250 	rsbseq	r0, r4, r0, asr r2
		c += r[i];
		r[i] = c;
		c >>= 8;
    2210:	12602000 	rsbne	r2, r0, #0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2214:	11460000 	mrsne	r0, (UNDEF: 70)
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    2218:	0bf70000 	bleq	ffdc2220 <BootRAM+0xed329c1>
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    221c:	01210000 	teqeq	r1, r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2220:	64910251 	ldrvs	r0, [r1], #593	; 0x251
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    2224:	02500121 	subseq	r0, r0, #1073741832	; 0x40000008
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2228:	20000074 	andcs	r0, r0, r4, ror r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    222c:	00001278 	andeq	r1, r0, r8, ror r2
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2230:	00001146 	andeq	r1, r0, r6, asr #2
    2234:	00000c11 	andeq	r0, r0, r1, lsl ip

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2238:	02510121 	subseq	r0, r1, #1073741832	; 0x40000008
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    223c:	01216491 			; <UNDEFINED> instruction: 0x01216491

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2240:	00740250 	rsbseq	r0, r4, r0, asr r2
    2244:	12a22000 	adcne	r2, r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2248:	11690000 	cmnne	r9, r0
    224c:	0c2b0000 	stceq	0, cr0, [fp], #-0
    2250:	01210000 	teqeq	r1, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2254:	68910251 	ldmvs	r1, {r0, r4, r6, r9}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2258:	02500121 	subseq	r0, r0, #1073741832	; 0x40000008
    225c:	22000074 	andcs	r0, r0, #116	; 0x74

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2260:	000012aa 	andeq	r1, r0, sl, lsr #5
			c += ((uint32_t)a[j]) *
    2264:	0000117b 	andeq	r1, r0, fp, ror r1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2268:	01510121 	cmpeq	r1, r1, lsr #2
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    226c:	50012131 	andpl	r2, r1, r1, lsr r1
    2270:	00007402 	andeq	r7, r0, r2, lsl #8
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2274:	0ad92d00 	beq	ff64d67c <BootRAM+0xe5bde1d>
	c = (c >> 7) * 19;
    2278:	89010000 	stmdbhi	r1, {}	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    227c:	0012b401 	andseq	fp, r2, r1, lsl #8
	c = (c >> 7) * 19;
    2280:	00004800 	andeq	r4, r0, r0, lsl #16
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2284:	239c0100 	orrscs	r0, ip, #0, 2
    2288:	00000abe 			; <UNDEFINED> instruction: 0x00000abe
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    228c:	fc019301 	stc2	3, cr9, [r1], {1}
		r[i] = c;
    2290:	60000012 	andvs	r0, r0, r2, lsl r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2294:	01000000 	mrseq	r0, (UNDEF: 0)
		c += r[i];
		r[i] = c;
		c >>= 8;
    2298:	000c779c 	muleq	ip, ip, r7
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    229c:	11b92e00 			; <UNDEFINED> instruction: 0x11b92e00
    22a0:	94010000 	strls	r0, [r1], #-0
    22a4:	00003001 	andeq	r3, r0, r1
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22a8:	2f000000 	svccs	0x00000000
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    22ac:	0000027f 	andeq	r0, r0, pc, ror r2
		for (j = 0; j <= i; j++)
    22b0:	3002f901 	andcc	pc, r2, r1, lsl #18
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22b4:	01000000 	mrseq	r0, (UNDEF: 0)
    22b8:	00000ca1 	andeq	r0, r0, r1, lsr #25

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22bc:	6e697030 	mcrvs	0, 3, r7, cr9, cr0, {1}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22c0:	02f90100 	rscseq	r0, r9, #0, 2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22c4:	0000005b 	andeq	r0, r0, fp, asr r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22c8:	000d2731 	andeq	r2, sp, r1, lsr r7
    22cc:	02fb0100 	rscseq	r0, fp, #0, 2
    22d0:	00000030 	andeq	r0, r0, r0, lsr r0
    22d4:	0b612d00 	bleq	184d6dc <_etext+0x18461c4>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    22d8:	bd010000 	stclt	0, cr0, [r1, #-0]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22dc:	00135c01 	andseq	r5, r3, r1, lsl #24
    22e0:	00001400 	andeq	r1, r0, r0, lsl #8
    22e4:	239c0100 	orrscs	r0, ip, #0, 2

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22e8:	00000ae5 	andeq	r0, r0, r5, ror #21
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    22ec:	7001c101 	andvc	ip, r1, r1, lsl #2
    22f0:	1c000013 	stcne	0, cr0, [r0], {19}

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    22f4:	01000000 	mrseq	r0, (UNDEF: 0)
    22f8:	000ce49c 	muleq	ip, ip, r4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22fc:	13783200 	cmnne	r8, #0, 4
	c = (c >> 7) * 19;
    2300:	00080000 	andeq	r0, r8, r0

	for (i = 0; i < F25519_SIZE; i++) {
    2304:	a2330000 	eorsge	r0, r3, #0
		c += r[i];
    2308:	0100000e 	tsteq	r0, lr
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    230c:	011301c4 	tsteq	r3, r4, asr #3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2310:	05870000 	streq	r0, [r7]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2314:	00000000 	andeq	r0, r0, r0
    2318:	000d9923 	andeq	r9, sp, r3, lsr #18
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    231c:	01ce0100 	biceq	r0, lr, r0, lsl #2
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2320:	00000000 	andeq	r0, r0, r0
    2324:	0000002e 	andeq	r0, r0, lr, lsr #32
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2328:	0d0a9c01 	stceq	12, cr9, [sl, #-4]
		for (j = 0; j <= i; j++)
    232c:	69270000 	stmdbvs	r7!, {}	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2330:	ce010064 	cdpgt	0, 0, cr0, cr1, cr4, {3}
    2334:	000d0a01 	andeq	r0, sp, r1, lsl #20

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2338:	00059a00 	andeq	r9, r5, r0, lsl #20
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    233c:	04080000 	streq	r0, [r8], #-0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2340:	00000667 	andeq	r0, r0, r7, ror #12
    2344:	000d6034 	andeq	r6, sp, r4, lsr r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2348:	01db0100 	bicseq	r0, fp, r0, lsl #2
    234c:	0000005b 	andeq	r0, r0, fp, asr r0
    2350:	00000000 	andeq	r0, r0, r0
    2354:	00000004 	andeq	r0, r0, r4
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2358:	0d3b9c01 	ldceq	12, cr9, [fp, #-4]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    235c:	b1260000 	teqlt	r6, r0
    2360:	0100000e 	tsteq	r0, lr

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2364:	011301db 			; <UNDEFINED> instruction: 0x011301db
			c += ((uint32_t)a[j]) *
    2368:	05bb0000 	ldreq	r0, [fp, #0]!
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    236c:	35000000 	strcc	r0, [r0, #-0]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2370:	00001025 	andeq	r1, r0, r5, lsr #32
    2374:	8c022c01 	stchi	12, cr2, [r2], {1}
    2378:	18000013 	stmdane	r0, {r0, r1, r4}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    237c:	01000000 	mrseq	r0, (UNDEF: 0)
	c = (c >> 7) * 19;
    2380:	000d8e9c 	muleq	sp, ip, lr
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2384:	0eb12600 	cdpeq	6, 11, cr2, cr1, cr0, {0}
	c = (c >> 7) * 19;
    2388:	2c010000 	stccs	0, cr0, [r1], {-0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    238c:	00011302 	andeq	r1, r1, r2, lsl #6
	c = (c >> 7) * 19;
    2390:	0005dc00 	andeq	sp, r5, r0, lsl #24

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2394:	0e703600 	cdpeq	6, 7, cr3, cr0, cr0, {0}
		r[i] = c;
    2398:	30010000 	andcc	r0, r1, r0
		c >>= 8;
    239c:	0000c202 	andeq	ip, r0, r2, lsl #4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23a0:	117d3300 	cmnne	sp, r0, lsl #6
    23a4:	31010000 	mrscc	r0, (UNDEF: 1)
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    23a8:	00011302 	andeq	r1, r1, r2, lsl #6
    23ac:	0005fd00 	andeq	pc, r5, r0, lsl #26
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23b0:	0ef03300 	cdpeq	3, 15, cr3, cr0, cr0, {0}
    23b4:	33010000 	movwcc	r0, #4096	; 0x1000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23b8:	000d6102 	andeq	r6, sp, r2, lsl #2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23bc:	0005fd00 	andeq	pc, r5, r0, lsl #26

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23c0:	82230000 	eorhi	r0, r3, #0
    23c4:	0100000c 	tsteq	r0, ip
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23c8:	00000252 	andeq	r0, r0, r2, asr r2
    23cc:	002c0000 	eoreq	r0, ip, r0
    23d0:	9c010000 	stcls	0, cr0, [r1], {-0}
    23d4:	00000db3 			; <UNDEFINED> instruction: 0x00000db3
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    23d8:	000dd324 	andeq	sp, sp, r4, lsr #6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    23dc:	02520100 	subseq	r0, r2, #0, 2
    23e0:	0000011e 	andeq	r0, r0, lr, lsl r1

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23e4:	37005001 	strcc	r5, [r0, -r1]
			c += ((uint32_t)a[j]) *
    23e8:	00000ca3 	andeq	r0, r0, r3, lsr #25
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    23ec:	5b026101 	blpl	9a7f8 <_etext+0x932e0>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    23f0:	00000000 	andeq	r0, r0, r0
    23f4:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
    23f8:	01000000 	mrseq	r0, (UNDEF: 0)

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    23fc:	000ded9c 	muleq	sp, ip, sp
    2400:	0ea93300 	cdpeq	3, 10, cr3, cr9, cr0, {0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2404:	63010000 	movwvs	r0, #4096	; 0x1000
	c = (c >> 7) * 19;
    2408:	00017802 	andeq	r7, r1, r2, lsl #16

	for (i = 0; i < F25519_SIZE; i++) {
    240c:	00061000 	andeq	r1, r6, r0
		c += r[i];
    2410:	00002200 	andeq	r2, r0, r0, lsl #4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2414:	0d8e0000 	stceq	0, cr0, [lr]
		c += r[i];
		r[i] = c;
		c >>= 8;
    2418:	01210000 	teqeq	r1, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    241c:	00300150 	eorseq	r0, r0, r0, asr r1
	/* 1 1 */
	f25519_mul__distinct(s, x, x);
	f25519_mul__distinct(r, s, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    2420:	09e12300 	stmibeq	r1!, {r8, r9, sp}^
    2424:	7b010000 	blvc	4242c <_etext+0x3af14>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2428:	0013a402 	andseq	sl, r3, r2, lsl #8
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    242c:	00006c00 	andeq	r6, r0, r0, lsl #24
    2430:	849c0100 	ldrhi	r0, [ip], #256	; 0x100
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2434:	2400000e 	strcs	r0, [r0], #-14
    2438:	000010bb 	strheq	r1, [r0], -fp

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    243c:	84027b01 	strhi	r7, [r2], #-2817	; 0xb01
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2440:	0100000e 	tsteq	r0, lr

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2444:	11ad3350 			; <UNDEFINED> instruction: 0x11ad3350
    2448:	7c010000 	stcvc	0, cr0, [r1], {-0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    244c:	00011302 	andeq	r1, r1, r2, lsl #6
    2450:	00062f00 	andeq	r2, r6, r0, lsl #30
    2454:	0dfc3300 	ldcleq	3, cr3, [ip]
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2458:	7d010000 	stcvc	0, cr0, [r1, #-0]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    245c:	00011302 	andeq	r1, r1, r2, lsl #6
    2460:	00069b00 	andeq	r9, r6, r0, lsl #22

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2464:	0d243300 	stceq	3, cr3, [r4, #-0]
			c += ((uint32_t)a[j]) *
    2468:	7e010000 	cdpvc	0, 0, cr0, cr1, cr0, {0}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    246c:	00011302 	andeq	r1, r1, r2, lsl #6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2470:	0006d000 	andeq	sp, r6, r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2474:	0e903300 	cdpeq	3, 9, cr3, cr0, cr0, {0}
    2478:	7f010000 	svcvc	0x00010000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    247c:	00011302 	andeq	r1, r1, r2, lsl #6
	c = (c >> 7) * 19;
    2480:	00070800 	andeq	r0, r7, r0, lsl #16
    2484:	10683300 	rsbne	r3, r8, r0, lsl #6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2488:	80010000 	andhi	r0, r1, r0
	c = (c >> 7) * 19;
    248c:	00011302 	andeq	r1, r1, r2, lsl #6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2490:	00074500 	andeq	r4, r7, r0, lsl #10
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2494:	0f493800 	svceq	0x00493800
		r[i] = c;
    2498:	82010000 	andhi	r0, r1, #0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    249c:	000e8a02 	andeq	r8, lr, r2, lsl #20
		c += r[i];
		r[i] = c;
		c >>= 8;
    24a0:	83da8000 	bicshi	r8, sl, #0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24a4:	8d387e80 	ldchi	14, cr7, [r8, #-512]!	; 0xfffffe00
    24a8:	0100000c 	tsteq	r0, ip
    24ac:	0e900283 	cdpeq	2, 9, cr0, cr0, cr3, {4}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24b0:	c2800000 	addgt	r0, r0, #0
    24b4:	007e8083 	rsbseq	r8, lr, r3, lsl #1
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    24b8:	03650408 	cmneq	r5, #8, 8	; 0x8000000
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24bc:	04080000 	streq	r0, [r8], #-0
    24c0:	00000436 	andeq	r0, r0, r6, lsr r4

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24c4:	03210408 	teqeq	r1, #8, 8	; 0x8000000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24c8:	c4230000 	strtgt	r0, [r3], #-0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24cc:	0100000c 	tsteq	r0, ip
    24d0:	1410029e 	ldrne	r0, [r0], #-670	; 0x29e
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24d4:	00240000 	eoreq	r0, r4, r0
    24d8:	9c010000 	stcls	0, cr0, [r1], {-0}
    24dc:	00000ebe 			; <UNDEFINED> instruction: 0x00000ebe
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    24e0:	000c8d38 	andeq	r8, ip, r8, lsr sp
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24e4:	029f0100 	addseq	r0, pc, #0, 2
    24e8:	00000e90 	muleq	r0, r0, lr

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24ec:	8083c280 	addhi	ip, r3, r0, lsl #5
			c += ((uint32_t)a[j]) *
    24f0:	b723007e 			; <UNDEFINED> instruction: 0xb723007e
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    24f4:	0100000b 	tsteq	r0, fp
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    24f8:	1434023e 	ldrtne	r0, [r4], #-574	; 0x23e
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    24fc:	001e0000 	andseq	r0, lr, r0
	c = (c >> 7) * 19;
    2500:	9c010000 	stcls	0, cr0, [r1], {-0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2504:	00000f1a 	andeq	r0, r0, sl, lsl pc
	c = (c >> 7) * 19;
    2508:	000eb126 	andeq	fp, lr, r6, lsr #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    250c:	023e0100 	eorseq	r0, lr, #0, 2
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2510:	00000113 	andeq	r0, r0, r3, lsl r1
		r[i] = c;
    2514:	00000773 	andeq	r0, r0, r3, ror r7
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2518:	00143c39 	andseq	r3, r4, r9, lsr ip
		c += r[i];
		r[i] = c;
		c >>= 8;
    251c:	00118d00 	andseq	r8, r1, r0, lsl #26
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2520:	14403900 	strbne	r3, [r0], #-2304	; 0x900
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2524:	0e960000 	cdpeq	0, 9, cr0, cr6, cr0, {0}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2528:	44390000 	ldrtmi	r0, [r9], #-0
		for (j = 0; j <= i; j++)
    252c:	94000014 	strls	r0, [r0], #-20
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2530:	39000011 	stmdbcc	r0, {r0, r4}
    2534:	00001448 	andeq	r1, r0, r8, asr #8

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2538:	00000c41 	andeq	r0, r0, r1, asr #24
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    253c:	0014523a 	andseq	r5, r4, sl, lsr r2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2540:	000d3b00 	andeq	r3, sp, r0, lsl #22
    2544:	50012100 	andpl	r2, r1, r0, lsl #2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2548:	5001f303 	andpl	pc, r1, r3, lsl #6
    254c:	72230000 	eorvc	r0, r3, #0
    2550:	0100000c 	tsteq	r0, ip
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2554:	145402a8 	ldrbne	r0, [r4], #-680	; 0x2a8
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2558:	00140000 	andseq	r0, r4, r0
    255c:	9c010000 	stcls	0, cr0, [r1], {-0}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2560:	00000f42 	andeq	r0, r0, r2, asr #30
			c += ((uint32_t)a[j]) *
    2564:	000f4938 	andeq	r4, pc, r8, lsr r9	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2568:	02a90100 	adceq	r0, r9, #0, 2
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    256c:	00000e8a 	andeq	r0, r0, sl, lsl #29
    2570:	8083da80 	addhi	sp, r3, r0, lsl #21
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2574:	4b34007e 	blmi	d02774 <_etext+0xcfb25c>
	c = (c >> 7) * 19;
    2578:	0100000c 	tsteq	r0, ip
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    257c:	017802b4 	ldrheq	r0, [r8, #-36]!	; 0xffffffdc
	c = (c >> 7) * 19;
    2580:	14680000 	strbtne	r0, [r8], #-0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2584:	00340000 	eorseq	r0, r4, r0
	c = (c >> 7) * 19;
    2588:	9c010000 	stcls	0, cr0, [r1], {-0}

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    258c:	00000f7d 	andeq	r0, r0, sp, ror pc
		r[i] = c;
    2590:	00116826 	andseq	r6, r1, r6, lsr #16
		c >>= 8;
    2594:	02b40100 	adcseq	r0, r4, #0, 2
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2598:	00000113 	andeq	r0, r0, r3, lsl r1
    259c:	000007aa 	andeq	r0, r0, sl, lsr #15
    25a0:	000ea233 	andeq	sl, lr, r3, lsr r2
    25a4:	02b50100 	adcseq	r0, r5, #0, 2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25a8:	00000113 	andeq	r0, r0, r3, lsl r1
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    25ac:	000007cb 	andeq	r0, r0, fp, asr #15
		for (j = 0; j <= i; j++)
    25b0:	0f583400 	svceq	0x00583400
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25b4:	c5010000 	strgt	r0, [r1, #-0]
    25b8:	00017802 	andeq	r7, r1, r2, lsl #16

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25bc:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25c0:	00003000 	andeq	r3, r0, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25c4:	bf9c0100 	svclt	0x009c0100
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25c8:	2600000f 	strcs	r0, [r0], -pc
    25cc:	00001168 	andeq	r1, r0, r8, ror #2
    25d0:	1302c501 	movwne	ip, #9473	; 0x2501
    25d4:	eb000001 	bl	25e0 <f25519_inv__distinct+0x3c4>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    25d8:	27000007 	strcs	r0, [r0, -r7]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25dc:	c501006e 	strgt	r0, [r1, #-110]	; 0x6e
    25e0:	00011e02 	andeq	r1, r1, r2, lsl #28
    25e4:	00081700 	andeq	r1, r8, r0, lsl #14

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25e8:	00003900 	andeq	r3, r0, r0, lsl #18
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    25ec:	0f420000 	svceq	0x00420000
    25f0:	34000000 	strcc	r0, [r0], #-0

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    25f4:	00000e29 	andeq	r0, r0, r9, lsr #28
    25f8:	7802cf01 	stmdavc	r2, {r0, r8, r9, sl, fp, lr, pc}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25fc:	9c000001 	stcls	0, cr0, [r0], {1}
	c = (c >> 7) * 19;
    2600:	4c000014 	stcmi	0, cr0, [r0], {20}

	for (i = 0; i < F25519_SIZE; i++) {
    2604:	01000000 	mrseq	r0, (UNDEF: 0)
		c += r[i];
    2608:	0010369c 	mulseq	r0, ip, r6
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    260c:	11122600 	tstne	r2, r0, lsl #12
		c += r[i];
		r[i] = c;
		c >>= 8;
    2610:	cf010000 	svcgt	0x00010000
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2614:	00011302 	andeq	r1, r1, r2, lsl #6
    2618:	00085b00 	andeq	r5, r8, r0, lsl #22
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    261c:	101b2400 	andsne	r2, fp, r0, lsl #8
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2620:	cf010000 	svcgt	0x00010000
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2624:	00011302 	andeq	r1, r1, r2, lsl #6
    2628:	33510100 	cmpcc	r1, #0, 2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    262c:	000010b1 	strheq	r1, [r0], -r1	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2630:	3602d001 	strcc	sp, [r2], -r1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2634:	5b000010 	blpl	267c <f25519_inv__distinct+0x460>
    2638:	28000008 	stmdacs	r0, {r3}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    263c:	00001171 	andeq	r1, r0, r1, ror r1
    2640:	3302d101 	movwcc	sp, #8449	; 0x2101
    2644:	02000001 	andeq	r0, r0, #1
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2648:	a6286891 			; <UNDEFINED> instruction: 0xa6286891
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    264c:	01000011 	tsteq	r0, r1, lsl r0
    2650:	013302d2 			; <UNDEFINED> instruction: 0x013302d2

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2654:	91020000 	mrsls	r0, (UNDEF: 2)
			c += ((uint32_t)a[j]) *
    2658:	0ea2336c 	cdpeq	3, 10, cr3, cr2, cr12, {3}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    265c:	d4010000 	strle	r0, [r1], #-0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2660:	00011302 	andeq	r1, r1, r2, lsl #6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2664:	00087c00 	andeq	r7, r8, r0, lsl #24
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2668:	04080000 	streq	r0, [r8], #-0
	c = (c >> 7) * 19;
    266c:	00000143 	andeq	r0, r0, r3, asr #2
    2670:	0010112d 	andseq	r1, r0, sp, lsr #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2674:	02ea0100 	rsceq	r0, sl, #0, 2
	c = (c >> 7) * 19;
    2678:	000014e8 	andeq	r1, r0, r8, ror #9
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    267c:	0000000c 	andeq	r0, r0, ip
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2680:	7f2d9c01 	svcvc	0x002d9c01
		r[i] = c;
    2684:	0100000e 	tsteq	r0, lr
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2688:	14f402f1 	ldrbtne	r0, [r4], #753	; 0x2f1
		c += r[i];
		r[i] = c;
		c >>= 8;
    268c:	00180000 	andseq	r0, r8, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2690:	9c010000 	stcls	0, cr0, [r1], {-0}
    2694:	000c773b 	andeq	r7, ip, fp, lsr r7
    2698:	00150c00 	andseq	r0, r5, r0, lsl #24
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    269c:	00001200 	andeq	r1, r0, r0, lsl #4
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    26a0:	869c0100 	ldrhi	r0, [ip], r0, lsl #2
		for (j = 0; j <= i; j++)
    26a4:	3c000010 	stccc	0, cr0, [r0], {16}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26a8:	00000c88 	andeq	r0, r0, r8, lsl #25
    26ac:	0000089a 	muleq	r0, sl, r8

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26b0:	000c943d 	andeq	r9, ip, sp, lsr r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26b4:	0008b800 	andeq	fp, r8, r0, lsl #16

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26b8:	f8340000 			; <UNDEFINED> instruction: 0xf8340000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26bc:	0100000e 	tsteq	r0, lr
    26c0:	005b0305 	subseq	r0, fp, r5, lsl #6
    26c4:	15200000 	strne	r0, [r0, #-0]!
    26c8:	00100000 	andseq	r0, r0, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    26cc:	9c010000 	stcls	0, cr0, [r1], {-0}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26d0:	000010b1 	strheq	r1, [r0], -r1	; <UNPREDICTABLE>
    26d4:	000f043e 	andeq	r0, pc, lr, lsr r4	; <UNPREDICTABLE>
    26d8:	03070100 	movweq	r0, #28928	; 0x7100

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26dc:	000010b1 	strheq	r1, [r0], -r1	; <UNPREDICTABLE>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    26e0:	1ffff7e0 	svcne	0x00fff7e0
    26e4:	8d040800 	stchi	8, cr0, [r4, #-0]

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    26e8:	34000000 	strcc	r0, [r0], #-0
    26ec:	0000035f 	andeq	r0, r0, pc, asr r3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26f0:	5b030b01 	blpl	c52fc <_etext+0xbdde4>
	c = (c >> 7) * 19;
    26f4:	30000000 	andcc	r0, r0, r0

	for (i = 0; i < F25519_SIZE; i++) {
    26f8:	18000015 	stmdane	r0, {r0, r2, r4}
		c += r[i];
    26fc:	01000000 	mrseq	r0, (UNDEF: 0)
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2700:	0010e29c 	mulseq	r0, ip, r2
		c += r[i];
		r[i] = c;
		c >>= 8;
    2704:	0f043e00 	svceq	0x00043e00
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2708:	0e010000 	cdpeq	0, 0, cr0, cr1, cr0, {0}
    270c:	0010b103 	andseq	fp, r0, r3, lsl #2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2710:	fff7e000 			; <UNDEFINED> instruction: 0xfff7e000
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2714:	b13f001f 	teqlt	pc, pc, lsl r0	; <UNPREDICTABLE>
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2718:	0a000000 	beq	2720 <f25519_inv__distinct+0x504>
    271c:	00005b2c 	andeq	r5, r0, ip, lsr #22

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2720:	88030500 	stmdahi	r3, {r8, sl}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2724:	40200004 	eormi	r0, r0, r4

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2728:	00000d11 	andeq	r0, r0, r1, lsl sp
    272c:	005bb709 	subseq	fp, fp, r9, lsl #14
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2730:	11120000 	tstne	r2, r0
    2734:	cf410000 	svcgt	0x00410000
    2738:	41000000 	mrsmi	r0, (UNDEF: 0)
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    273c:	000000dc 	ldrdeq	r0, [r0], -ip
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2740:	00003741 	andeq	r3, r0, r1, asr #14
    2744:	ff420000 			; <UNDEFINED> instruction: 0xff420000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2748:	5900000f 	stmdbpl	r0, {r0, r1, r2, r3}
			c += ((uint32_t)a[j]) *
    274c:	2f000000 	svccs	0x00000000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2750:	41000011 	tstmi	r0, r1, lsl r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2754:	00000059 	andeq	r0, r0, r9, asr r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2758:	00005b41 	andeq	r5, r0, r1, asr #22
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    275c:	00bb4100 	adcseq	r4, fp, r0, lsl #2
	c = (c >> 7) * 19;
    2760:	43000000 	movwmi	r0, #0
    2764:	00001134 	andeq	r1, r0, r4, lsr r1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2768:	46011301 	strmi	r1, [r1], -r1, lsl #6
	c = (c >> 7) * 19;
    276c:	41000011 	tstmi	r0, r1, lsl r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2770:	000000fd 	strdeq	r0, [r0], -sp
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2774:	00019841 	andeq	r9, r1, r1, asr #16
		r[i] = c;
    2778:	1a430000 	bne	10c2780 <_etext+0x10bb268>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    277c:	0100000d 	tsteq	r0, sp
		c += r[i];
		r[i] = c;
		c >>= 8;
    2780:	115d0114 	cmpne	sp, r4, lsl r1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2784:	5d410000 	stclpl	0, cr0, [r1, #-0]
    2788:	41000011 	tstmi	r0, r1, lsl r0
    278c:	00001163 	andeq	r1, r0, r3, ror #2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2790:	0a040800 	beq	104798 <_etext+0xfd280>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2794:	08000008 	stmdaeq	r0, {r3}
		for (j = 0; j <= i; j++)
    2798:	00079d04 	andeq	r9, r7, r4, lsl #26
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    279c:	0dba2c00 	ldceq	12, cr2, [sl]
    27a0:	83010000 	movwhi	r0, #4096	; 0x1000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27a4:	00005b01 	andeq	r5, r0, r1, lsl #22
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27a8:	00117b00 	andseq	r7, r1, r0, lsl #22

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27ac:	2c002900 	stccs	9, cr2, [r0], {-0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27b0:	000010dc 	ldrdeq	r1, [r0], -ip
    27b4:	5b018601 	blpl	63fc0 <_etext+0x5caa8>
    27b8:	8d000000 	stchi	0, cr0, [r0, #-0]
    27bc:	29000011 	stmdbcs	r0, {r0, r4}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    27c0:	00804400 	addeq	r4, r0, r0, lsl #8
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27c4:	820a0000 	andhi	r0, sl, #0
    27c8:	00056744 	andeq	r6, r5, r4, asr #14
    27cc:	00520a00 	subseq	r0, r2, r0, lsl #20

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27d0:	00000975 	andeq	r0, r0, r5, ror r9
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    27d4:	0a8d0004 	beq	fe3427ec <BootRAM+0xd2b2f8d>
    27d8:	01040000 	mrseq	r0, (UNDEF: 4)

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    27dc:	00000639 	andeq	r0, r0, r9, lsr r6
    27e0:	0012c601 	andseq	ip, r2, r1, lsl #12
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    27e4:	00089300 	andeq	r9, r8, r0, lsl #6
	c = (c >> 7) * 19;
    27e8:	00024000 	andeq	r4, r2, r0

	for (i = 0; i < F25519_SIZE; i++) {
    27ec:	00000000 	andeq	r0, r0, r0
		c += r[i];
    27f0:	000bfd00 	andeq	pc, fp, r0, lsl #26
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27f4:	06010200 	streq	r0, [r1], -r0, lsl #4
		c += r[i];
		r[i] = c;
		c >>= 8;
    27f8:	0000081a 	andeq	r0, r0, sl, lsl r8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27fc:	000b0103 	andeq	r0, fp, r3, lsl #2
	f25519_mul__distinct(r, s, x);

	/* 1 */
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}
    2800:	371c0200 	ldrcc	r0, [ip, -r0, lsl #4]
    2804:	02000000 	andeq	r0, r0, #0
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    2808:	08180801 	ldmdaeq	r8, {r0, fp}
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    280c:	02020000 	andeq	r0, r2, #0
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    2810:	0006fc05 	andeq	pc, r6, r5, lsl #24
	f25519_copy(r, tmp);
}

void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
    2814:	07020200 	streq	r0, [r2, -r0, lsl #4]
    2818:	00000949 	andeq	r0, r0, r9, asr #18
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += b * ((uint32_t)a[i]);
    281c:	da050402 	ble	14382c <_etext+0x13c314>
    2820:	03000004 	movweq	r0, #4
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2824:	00000ace 	andeq	r0, r0, lr, asr #21
    2828:	005e3802 	subseq	r3, lr, r2, lsl #16
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    282c:	04020000 	streq	r0, [r2], #-0
    2830:	00025207 	andeq	r5, r2, r7, lsl #4
	c >>= 7;
	c *= 19;
    2834:	05080200 	streq	r0, [r8, #-512]	; 0x200
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    2838:	000004d5 	ldrdeq	r0, [r0], -r5
	c >>= 7;
	c *= 19;
    283c:	4d070802 	stcmi	8, cr0, [r7, #-8]
    2840:	04000002 	streq	r0, [r0], #-2

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2844:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
		r[i] = c;
    2848:	04020074 	streq	r0, [r2], #-116	; 0x74

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    284c:	00025707 	andeq	r5, r2, r7, lsl #14
		c += r[i];
		r[i] = c;
		c >>= 8;
    2850:	0b030300 	bleq	c3458 <_etext+0xbbf40>

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2854:	2a030000 	bcs	c285c <_etext+0xbb344>
    2858:	0000002c 	andeq	r0, r0, ip, lsr #32
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    285c:	000ad003 	andeq	sp, sl, r3
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2860:	53420300 	movtpl	r0, #8960	; 0x2300
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2864:	05000000 	streq	r0, [r0, #-0]
    2868:	00323375 	eorseq	r3, r2, r5, ror r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    286c:	005e2704 	subseq	r2, lr, r4, lsl #14
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2870:	75050000 	strvc	r0, [r5, #-0]

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2874:	04003631 	streq	r3, [r0], #-1585	; 0x631
    2878:	00004528 	andeq	r4, r0, r8, lsr #10
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    287c:	38750500 	ldmdacc	r5!, {r8, sl}^
    2880:	37290400 	strcc	r0, [r9, -r0, lsl #8]!
    2884:	03000000 	movweq	r0, #0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2888:	0000035a 	andeq	r0, r0, sl, asr r3
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    288c:	00c22f04 	sbceq	r2, r2, r4, lsl #30
    2890:	5e060000 	cdppl	0, 0, cr0, cr6, cr0, {0}
    2894:	07000000 	streq	r0, [r0, -r0]

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2898:	dc370401 	cfldrsle	mvf0, [r7], #-4
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    289c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28a0:	00000753 	andeq	r0, r0, r3, asr r7
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28a4:	01a70800 			; <UNDEFINED> instruction: 0x01a70800
	c = (c >> 7) * 19;
    28a8:	00010000 	andeq	r0, r1, r0
    28ac:	00052d03 	andeq	r2, r5, r3, lsl #26
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28b0:	c7370400 	ldrgt	r0, [r7, -r0, lsl #8]!
	c = (c >> 7) * 19;
    28b4:	03000000 	movweq	r0, #0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28b8:	00000ac7 	andeq	r0, r0, r7, asr #21
	c = (c >> 7) * 19;
    28bc:	007ad405 	rsbseq	sp, sl, r5, lsl #8

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    28c0:	04090000 	streq	r0, [r9], #-0
		r[i] = c;
    28c4:	8b070402 	blhi	1c38d4 <_etext+0x1bc3bc>
		c >>= 8;
    28c8:	02000007 	andeq	r0, r0, #7
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28cc:	08210801 	stmdaeq	r1!, {r0, fp}
    28d0:	040a0000 	streq	r0, [sl], #-0
    28d4:	00000108 	andeq	r0, r0, r8, lsl #2
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    28d8:	0000fb0b 	andeq	pc, r0, fp, lsl #22
		for (j = 0; j <= i; j++)
    28dc:	ad040a00 	vstrge	s0, [r4, #-0]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    28e0:	0c000000 	stceq	0, cr0, [r0], {-0}
    28e4:	000005ff 	strdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    28e8:	5038060c 	eorspl	r0, r8, ip, lsl #12

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    28ec:	0d000001 	stceq	0, cr0, [r0, #-4]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    28f0:	000001d7 	ldrdeq	r0, [r0], -r7

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    28f4:	00a25006 	adceq	r5, r2, r6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    28f8:	0d000000 	stceq	0, cr0, [r0, #-0]
    28fc:	0000086d 	andeq	r0, r0, sp, ror #16
    2900:	00a25106 	adceq	r5, r2, r6, lsl #2
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2904:	0d020000 	stceq	0, cr0, [r2, #-0]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2908:	0000213a 	andeq	r2, r0, sl, lsr r1
    290c:	00a25206 	adceq	r5, r2, r6, lsl #4

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2910:	0d040000 	stceq	0, cr0, [r4, #-0]
			c += ((uint32_t)a[j]) *
    2914:	00000738 	andeq	r0, r0, r8, lsr r7
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2918:	015f5306 	cmpeq	pc, r6, lsl #6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    291c:	00080000 	andeq	r0, r8, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2920:	00010d0e 	andeq	r0, r1, lr, lsl #26
	c = (c >> 7) * 19;
    2924:	00015f00 	andeq	r5, r1, r0, lsl #30
    2928:	00a20f00 	adceq	r0, r2, r0, lsl #30
    292c:	0a000000 	beq	2934 <f25519_sqrt+0x12c>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2930:	00015004 	andeq	r5, r1, r4
	c = (c >> 7) * 19;
    2934:	06000300 	streq	r0, [r0], -r0, lsl #6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2938:	54060000 	strpl	r0, [r6], #-0
    293c:	00000113 	andeq	r0, r0, r3, lsl r1
	c = (c >> 7) * 19;
    2940:	00574210 	subseq	r4, r7, r0, lsl r2

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2944:	94620602 	strbtls	r0, [r2], #-1538	; 0x602
		r[i] = c;
    2948:	11000001 	tstne	r0, r1
		c >>= 8;
    294c:	00306262 	eorseq	r6, r0, r2, ror #4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2950:	00ad6506 	adceq	r6, sp, r6, lsl #10
    2954:	11000000 	mrsne	r0, (UNDEF: 0)
    2958:	00316262 	eorseq	r6, r1, r2, ror #4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    295c:	00ad6606 	adceq	r6, sp, r6, lsl #12

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2960:	00010000 	andeq	r0, r1, r0
    2964:	5f060212 	svcpl	0x00060212
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2968:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
		for (j = 0; j <= i; j++)
    296c:	06007713 			; <UNDEFINED> instruction: 0x06007713
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2970:	0000a261 	andeq	sl, r0, r1, ror #4
    2974:	77621300 	strbvc	r1, [r2, -r0, lsl #6]!

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2978:	70680600 	rsbvc	r0, r8, r0, lsl #12
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    297c:	00000001 	andeq	r0, r0, r1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2980:	00093003 	andeq	r3, r9, r3
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2984:	94690600 	strbtls	r0, [r9], #-1536	; 0x600
    2988:	0c000001 	stceq	0, cr0, [r0], {1}
    298c:	00000114 	andeq	r0, r0, r4, lsl r1
    2990:	4c6b061c 	stclmi	6, cr0, [fp], #-112	; 0xffffff90
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2994:	0d000002 	stceq	0, cr0, [r0, #-8]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2998:	00000767 	andeq	r0, r0, r7, ror #14
    299c:	00ad6d06 	adceq	r6, sp, r6, lsl #26

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29a0:	0d000000 	stceq	0, cr0, [r0, #-0]
			c += ((uint32_t)a[j]) *
    29a4:	00000015 	andeq	r0, r0, r5, lsl r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    29a8:	00ad6e06 	adceq	r6, sp, r6, lsl #28
    29ac:	0d010000 	stceq	0, cr0, [r1, #-0]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    29b0:	00000311 	andeq	r0, r0, r1, lsl r3
    29b4:	01b06f06 	lslseq	r6, r6, #30
    29b8:	0d020000 	stceq	0, cr0, [r2, #-0]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29bc:	00000148 	andeq	r0, r0, r8, asr #2
	c = (c >> 7) * 19;
    29c0:	01b07006 	movseq	r7, r6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29c4:	0d040000 	stceq	0, cr0, [r4, #-0]
	c = (c >> 7) * 19;
    29c8:	000004eb 	andeq	r0, r0, fp, ror #9
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29cc:	01b07106 	lslseq	r7, r6, #2
	c = (c >> 7) * 19;
    29d0:	0d060000 	stceq	0, cr0, [r6, #-0]

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    29d4:	000006ef 	andeq	r0, r0, pc, ror #13
		r[i] = c;
    29d8:	00ad7306 	adceq	r7, sp, r6, lsl #6
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    29dc:	0d080000 	stceq	0, cr0, [r8, #-0]
		c += r[i];
		r[i] = c;
		c >>= 8;
    29e0:	00000808 	andeq	r0, r0, r8, lsl #16
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    29e4:	00ad7406 	adceq	r7, sp, r6, lsl #8
    29e8:	0d090000 	stceq	0, cr0, [r9, #-0]
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    29ec:	00000507 	andeq	r0, r0, r7, lsl #10
		for (j = 0; j <= i; j++)
    29f0:	00ad7506 	adceq	r7, sp, r6, lsl #10
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    29f4:	0d0a0000 	stceq	0, cr0, [sl, #-0]
    29f8:	0000054f 	andeq	r0, r0, pc, asr #10
    29fc:	00ad7606 	adceq	r7, sp, r6, lsl #12

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a00:	0d0b0000 	stceq	0, cr0, [fp, #-0]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a04:	000005d6 	ldrdeq	r0, [r0], -r6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a08:	00ad7706 	adceq	r7, sp, r6, lsl #14
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a0c:	0d0c0000 	stceq	0, cr0, [ip, #-0]
    2a10:	000007c8 	andeq	r0, r0, r8, asr #15
    2a14:	01657a06 	cmneq	r5, r6, lsl #20
    2a18:	00100000 	andseq	r0, r0, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2a1c:	00011503 	andeq	r1, r1, r3, lsl #10
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a20:	bb7b0600 	bllt	1ec4228 <_etext+0x1ebcd10>
    2a24:	07000001 	streq	r0, [r0, -r1]

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a28:	8a230701 	bhi	8c4634 <_etext+0x8bd11c>
			c += ((uint32_t)a[j]) *
    2a2c:	08000002 	stmdaeq	r0, {r1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2a30:	00001308 	andeq	r1, r0, r8, lsl #6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2a34:	124b0800 	subne	r0, fp, #0, 16
    2a38:	08010000 	stmdaeq	r1, {}	; <UNPREDICTABLE>
    2a3c:	000012ab 	andeq	r1, r0, fp, lsr #5
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a40:	11cd0802 	bicne	r0, sp, r2, lsl #16
	c = (c >> 7) * 19;
    2a44:	08030000 	stmdaeq	r3, {}	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a48:	000012ed 	andeq	r1, r0, sp, ror #5
	c = (c >> 7) * 19;
    2a4c:	13db0804 	bicsne	r0, fp, #4, 16	; 0x40000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a50:	08050000 	stmdaeq	r5, {}	; <UNPREDICTABLE>
	c = (c >> 7) * 19;
    2a54:	00001205 	andeq	r1, r0, r5, lsl #4

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2a58:	2c030006 	stccs	0, cr0, [r3], {6}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a5c:	07000012 	smladeq	r0, r2, r0, r0
		c += r[i];
		r[i] = c;
    2a60:	00025723 	andeq	r5, r2, r3, lsr #14
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a64:	13430c00 	movtne	r0, #15360	; 0x3c00
		c += r[i];
		r[i] = c;
		c >>= 8;
    2a68:	07060000 	streq	r0, [r6, -r0]
	/* 1 1 */
	f25519_mul__distinct(r, x, x);
	f25519_mul__distinct(s, r, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    2a6c:	0002ea29 	andeq	lr, r2, r9, lsr #20
    2a70:	13620d00 	cmnne	r2, #0, 26
    2a74:	2a070000 	bcs	1c2a7c <_etext+0x1bb564>
    2a78:	000000ad 	andeq	r0, r0, sp, lsr #1
    2a7c:	13780d00 	cmnne	r8, #0, 26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2a80:	2b070000 	blcs	1c2a88 <_etext+0x1bb570>
		for (j = 0; j <= i; j++)
    2a84:	000000ad 	andeq	r0, r0, sp, lsr #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a88:	13870d01 	orrne	r0, r7, #1, 26	; 0x40
    2a8c:	2c070000 	stccs	0, cr0, [r7], {-0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a90:	000000ad 	andeq	r0, r0, sp, lsr #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a94:	13960d02 	orrsne	r0, r6, #2, 26	; 0x80

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a98:	2d070000 	stccs	0, cr0, [r7, #-0]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a9c:	000000ad 	andeq	r0, r0, sp, lsr #1
    2aa0:	14400d03 	strbne	r0, [r0], #-3331	; 0xd03
    2aa4:	2e070000 	cdpcs	0, 0, cr0, cr7, cr0, {0}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2aa8:	000000ad 	andeq	r0, r0, sp, lsr #1
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2aac:	12d60d04 	sbcsne	r0, r6, #4, 26	; 0x100
    2ab0:	2f070000 	svccs	0x00070000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ab4:	000000ad 	andeq	r0, r0, sp, lsr #1
			c += ((uint32_t)a[j]) *
    2ab8:	44030005 	strmi	r0, [r3], #-5
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2abc:	07000013 	smladeq	r0, r3, r0, r0
    2ac0:	00029530 	andeq	r9, r2, r0, lsr r5
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2ac4:	12a51400 	adcne	r1, r5, #0, 8
    2ac8:	07010000 	streq	r0, [r1, -r0]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2acc:	00031a32 	andeq	r1, r3, r2, lsr sl
	c = (c >> 7) * 19;
    2ad0:	13b40800 			; <UNDEFINED> instruction: 0x13b40800
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2ad4:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
	c = (c >> 7) * 19;
    2ad8:	0000140d 	andeq	r1, r0, sp, lsl #8
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2adc:	4e451501 	cdpmi	5, 4, cr1, cr5, cr1, {0}
	c = (c >> 7) * 19;
    2ae0:	08020044 	stmdaeq	r2, {r2, r6}

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2ae4:	0000016e 	andeq	r0, r0, lr, ror #2
		r[i] = c;
    2ae8:	a6030003 	strge	r0, [r3], -r3
		c >>= 8;
    2aec:	07000012 	smladeq	r0, r2, r0, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2af0:	0002f537 	andeq	pc, r2, r7, lsr r5	; <UNPREDICTABLE>
    2af4:	08681600 	stmdaeq	r8!, {r9, sl, ip}^
    2af8:	0003520c 	andeq	r5, r3, ip, lsl #4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2afc:	19170d00 	ldmdbne	r7, {r8, sl, fp}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2b00:	0e080000 	cdpeq	0, 0, cr0, cr8, cr0, {0}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b04:	00000352 	andeq	r0, r0, r2, asr r3
    2b08:	17c70d00 	strbne	r0, [r7, r0, lsl #26]
    2b0c:	0f080000 	svceq	0x00080000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b10:	00000362 	andeq	r0, r0, r2, ror #6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b14:	046c0d08 	strbteq	r0, [ip], #-3336	; 0xd08

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b18:	10080000 	andne	r0, r8, r0
    2b1c:	00000372 	andeq	r0, r0, r2, ror r3
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b20:	5e170028 	cdppl	0, 1, cr0, cr7, cr8, {1}
    2b24:	62000000 	andvs	r0, r0, #0
    2b28:	18000003 	stmdane	r0, {r0, r1}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2b2c:	000000f4 	strdeq	r0, [r0], -r4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b30:	5e170001 	cdppl	0, 1, cr0, cr7, cr1, {0}
    2b34:	72000000 	andvc	r0, r0, #0
    2b38:	18000003 	stmdane	r0, {r0, r1}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b3c:	000000f4 	strdeq	r0, [r0], -r4
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2b40:	37170007 	ldrcc	r0, [r7, -r7]
    2b44:	82000000 	andhi	r0, r0, #0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b48:	18000003 	stmdane	r0, {r0, r1}
	c = (c >> 7) * 19;
    2b4c:	000000f4 	strdeq	r0, [r0], -r4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b50:	a503003f 	strge	r0, [r3, #-63]	; 0x3f
	c = (c >> 7) * 19;
    2b54:	08000013 	stmdaeq	r0, {r0, r1, r4}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b58:	00032512 	andeq	r2, r3, r2, lsl r5
	c = (c >> 7) * 19;
    2b5c:	0aab0c00 	beq	feac5b64 <BootRAM+0xda36305>

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2b60:	09140000 	ldmdbeq	r4, {}	; <UNPREDICTABLE>
		r[i] = c;
    2b64:	0003e20d 	andeq	lr, r3, sp, lsl #4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b68:	0b0b0d00 	bleq	2c5f70 <_etext+0x2bea58>
		c += r[i];
		r[i] = c;
		c >>= 8;
    2b6c:	0e090000 	cdpeq	0, 0, cr0, cr9, cr0, {0}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b70:	0000008c 	andeq	r0, r0, ip, lsl #1
    2b74:	0bc20d00 	bleq	ff085f7c <BootRAM+0xdff671d>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b78:	10090000 	andne	r0, r9, r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2b7c:	0000008c 	andeq	r0, r0, ip, lsl #1
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b80:	0b730d04 	bleq	1cc5f98 <_etext+0x1cbea80>
    2b84:	11090000 	mrsne	r0, (UNDEF: 9)

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b88:	0000008c 	andeq	r0, r0, ip, lsl #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b8c:	0c070d08 	stceq	13, cr0, [r7], {8}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b90:	13090000 	movwne	r0, #36864	; 0x9000
    2b94:	0000008c 	andeq	r0, r0, ip, lsl #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b98:	0b950d0c 	bleq	fe545fd0 <BootRAM+0xd4b6771>
    2b9c:	14090000 	strne	r0, [r9], #-0
    2ba0:	0000008c 	andeq	r0, r0, ip, lsl #1
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2ba4:	0af00d10 	beq	ffc05fec <BootRAM+0xeb7678d>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ba8:	15090000 	strne	r0, [r9, #-0]
    2bac:	000003e2 	andeq	r0, r0, r2, ror #7
    2bb0:	81170014 	tsthi	r7, r4, lsl r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2bb4:	f1000000 	cps	#0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2bb8:	19000003 	stmdbne	r0, {r0, r1}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2bbc:	000000f4 	strdeq	r0, [r0], -r4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bc0:	0aac0300 	beq	feb037c8 <BootRAM+0xda73f69>
	c = (c >> 7) * 19;
    2bc4:	16090000 	strne	r0, [r9], -r0
    2bc8:	0000038d 	andeq	r0, r0, sp, lsl #7
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bcc:	000b130c 	andeq	r1, fp, ip, lsl #6
	c = (c >> 7) * 19;
    2bd0:	18091400 	stmdane	r9, {sl, ip}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bd4:	00000445 	andeq	r0, r0, r5, asr #8
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2bd8:	000bd80d 	andeq	sp, fp, sp, lsl #16
		r[i] = c;
    2bdc:	45190900 	ldrmi	r0, [r9, #-2304]	; 0x900
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2be0:	00000004 	andeq	r0, r0, r4
		c += r[i];
		r[i] = c;
		c >>= 8;
    2be4:	000b5b0d 	andeq	r5, fp, sp, lsl #22
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2be8:	8c1a0900 	ldchi	9, cr0, [sl], {-0}
    2bec:	04000000 	streq	r0, [r0], #-0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2bf0:	000b8b0d 	andeq	r8, fp, sp, lsl #22
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2bf4:	e71f0900 	ldr	r0, [pc, -r0, lsl #18]
		for (j = 0; j <= i; j++)
    2bf8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2bfc:	000b270d 	andeq	r2, fp, sp, lsl #14
    2c00:	73210900 	teqvc	r1, #0, 18
    2c04:	0c000000 	stceq	0, cr0, [r0], {-0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c08:	000c160d 	andeq	r1, ip, sp, lsl #12
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c0c:	73220900 	teqvc	r2, #0, 18

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c10:	10000000 	andne	r0, r0, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c14:	f1040a00 			; <UNDEFINED> instruction: 0xf1040a00
    2c18:	03000003 	movweq	r0, #3
    2c1c:	00000c39 	andeq	r0, r0, r9, lsr ip
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2c20:	04562609 	ldrbeq	r2, [r6], #-1545	; 0x609
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c24:	040a0000 	streq	r0, [sl], #-0
    2c28:	000003fc 	strdeq	r0, [r0], -ip

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c2c:	0009bd1a 	andeq	fp, r9, sl, lsl sp
			c += ((uint32_t)a[j]) *
    2c30:	483d0100 	ldmdami	sp!, {r8}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2c34:	88000015 	stmdahi	r0, {r0, r2, r4}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2c38:	01000000 	mrseq	r0, (UNDEF: 0)
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c3c:	0004cb9c 	muleq	r4, ip, fp
	c = (c >> 7) * 19;
    2c40:	158a1b00 	strne	r1, [sl, #2816]	; 0xb00
    2c44:	089e0000 	ldmeq	lr, {}	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c48:	04940000 	ldreq	r0, [r4], #0
    2c4c:	011c0000 	tsteq	ip, r0
	c = (c >> 7) * 19;
    2c50:	20080252 	andcs	r0, r8, r2, asr r2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c54:	0251011c 	subseq	r0, r1, #28, 2
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2c58:	011cff08 	tsteq	ip, r8, lsl #30
		r[i] = c;
    2c5c:	ec030550 	cfstr32	mvfx0, [r3], {80}	; 0x50
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c60:	00200004 	eoreq	r0, r0, r4
		c += r[i];
		r[i] = c;
		c >>= 8;
    2c64:	0015941b 	andseq	r9, r5, fp, lsl r4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c68:	00089e00 	andeq	r9, r8, r0, lsl #28
    2c6c:	0004b700 	andeq	fp, r4, r0, lsl #14
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c70:	52011c00 	andpl	r1, r1, #0, 24
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2c74:	1c5c0802 	mrrcne	8, 0, r0, ip, cr2
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c78:	08025101 	stmdaeq	r2, {r0, r8, ip, lr}
    2c7c:	50011cff 	strdpl	r1, [r1], -pc	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c80:	04900305 	ldreq	r0, [r0], #773	; 0x305
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c84:	1d002000 	stcne	0, cr2, [r0, #-0]

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c88:	0000159e 	muleq	r0, lr, r5
    2c8c:	000008bd 			; <UNDEFINED> instruction: 0x000008bd
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c90:	0550011c 	ldrbeq	r0, [r0, #-284]	; 0x11c
    2c94:	00050c03 	andeq	r0, r5, r3, lsl #24
    2c98:	1e000020 	cdpne	0, 0, cr0, cr0, cr0, {1}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2c9c:	0000083b 	andeq	r0, r0, fp, lsr r8
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ca0:	d0018801 	andle	r8, r1, r1, lsl #16
    2ca4:	44000015 	strmi	r0, [r0], #-21
    2ca8:	01000000 	mrseq	r0, (UNDEF: 0)

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cac:	00050d9c 	muleq	r5, ip, sp
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2cb0:	11ee1f00 	mvnne	r1, r0, lsl #30
    2cb4:	89010000 	stmdbhi	r1, {}	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cb8:	0000ad01 	andeq	sl, r0, r1, lsl #26
	c = (c >> 7) * 19;
    2cbc:	0008ea00 	andeq	lr, r8, r0, lsl #20
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cc0:	15ec2000 	strbne	r2, [ip, #0]!
	c = (c >> 7) * 19;
    2cc4:	08d40000 	ldmeq	r4, {}^	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cc8:	f4210000 	vld4.8	{d0-d3}, [r1], r0
	c = (c >> 7) * 19;
    2ccc:	dc000015 	stcle	0, cr0, [r0], {21}

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2cd0:	21000008 	tstcs	r0, r8
		r[i] = c;
    2cd4:	00001608 	andeq	r1, r0, r8, lsl #12
		c >>= 8;
    2cd8:	000008e3 	andeq	r0, r0, r3, ror #17
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2cdc:	128a2200 	addne	r2, sl, #0, 4
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    2ce0:	9f010000 	svcls	0x00010000
    2ce4:	00000001 	andeq	r0, r0, r1
    2ce8:	00000200 	andeq	r0, r0, r0, lsl #4
    2cec:	239c0100 	orrscs	r0, ip, #0, 2
    2cf0:	00001355 	andeq	r1, r0, r5, asr r3
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2cf4:	0d01a201 	sfmeq	f2, 1, [r1, #-4]
    2cf8:	14000001 	strne	r0, [r0], #-1
    2cfc:	18000016 	stmdane	r0, {r1, r2, r4}
		r[i] = c;
    2d00:	01000000 	mrseq	r0, (UNDEF: 0)
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2d04:	00054a9c 	muleq	r5, ip, sl
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2d08:	134e2400 	movtne	r2, #58368	; 0xe400
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2d0c:	a2010000 	andge	r0, r1, #0
    2d10:	0000a201 	andeq	sl, r0, r1, lsl #4
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2d14:	00091300 	andeq	r1, r9, r0, lsl #6
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2d18:	be230000 	cdplt	0, 2, cr0, cr3, cr0, {0}
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2d1c:	01000013 	tsteq	r0, r3, lsl r0
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2d20:	010d01ab 	smlatbeq	sp, fp, r1, r0
    2d24:	162c0000 	strtne	r0, [ip], -r0
	c = (c >> 7) * 19;
    2d28:	00180000 	andseq	r0, r8, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2d2c:	9c010000 	stcls	0, cr0, [r1], {-0}
		r[i] = c;
    2d30:	00000575 	andeq	r0, r0, r5, ror r5

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d34:	00134e24 	andseq	r4, r3, r4, lsr #28
		c += r[i];
		r[i] = c;
		c >>= 8;
    2d38:	01ab0100 			; <UNDEFINED> instruction: 0x01ab0100

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d3c:	000000a2 	andeq	r0, r0, r2, lsr #1
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d40:	00000934 	andeq	r0, r0, r4, lsr r9

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d44:	136a2300 	cmnne	sl, #0, 6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d48:	b5010000 	strlt	r0, [r1, #-0]
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2d4c:	00010d01 	andeq	r0, r1, r1, lsl #26
		for (j = 0; j <= i; j++)
    2d50:	00164400 	andseq	r4, r6, r0, lsl #8
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d54:	00002800 	andeq	r2, r0, r0, lsl #16
    2d58:	a09c0100 	addsge	r0, ip, r0, lsl #2
    2d5c:	24000005 	strcs	r0, [r0], #-5

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d60:	0000134e 	andeq	r1, r0, lr, asr #6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d64:	a201b501 	andge	fp, r1, #4194304	; 0x400000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d68:	55000000 	strpl	r0, [r0, #-0]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d6c:	00000009 	andeq	r0, r0, r9
    2d70:	00126523 	andseq	r6, r2, r3, lsr #10
    2d74:	01bf0100 			; <UNDEFINED> instruction: 0x01bf0100
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2d78:	0000010d 	andeq	r0, r0, sp, lsl #2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d7c:	0000166c 	andeq	r1, r0, ip, ror #12
    2d80:	00000034 	andeq	r0, r0, r4, lsr r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d84:	05cb9c01 	strbeq	r9, [fp, #3073]	; 0xc01
			c += ((uint32_t)a[j]) *
    2d88:	4e240000 	cdpmi	0, 2, cr0, cr4, cr0, {0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2d8c:	01000013 	tsteq	r0, r3, lsl r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2d90:	00a201bf 			; <UNDEFINED> instruction: 0x00a201bf
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d94:	09760000 	ldmdbeq	r6!, {}^	; <UNPREDICTABLE>
	c = (c >> 7) * 19;
    2d98:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    2d9c:	0000142c 	andeq	r1, r0, ip, lsr #8
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2da0:	a001c801 	andge	ip, r1, r1, lsl #16
	c = (c >> 7) * 19;
    2da4:	5c000016 	stcpl	0, cr0, [r0], {22}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2da8:	01000000 	mrseq	r0, (UNDEF: 0)
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2dac:	0006239c 	muleq	r6, ip, r3
		r[i] = c;
    2db0:	00692500 	rsbeq	r2, r9, r0, lsl #10
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2db4:	7301c901 	movwvc	ip, #6401	; 0x1901
		c += r[i];
		r[i] = c;
		c >>= 8;
    2db8:	97000000 	strls	r0, [r0, -r0]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2dbc:	26000009 	strcs	r0, [r0], -r9
    2dc0:	000012cc 	andeq	r1, r0, ip, asr #5
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2dc4:	2301ca01 	movwcs	ip, #6657	; 0x1a01
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2dc8:	1b000006 	blne	2de8 <f25519_sqrt+0x5e0>
		for (j = 0; j <= i; j++)
    2dcc:	000016c0 	andeq	r1, r0, r0, asr #13
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2dd0:	000008eb 	andeq	r0, r0, fp, ror #17

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2dd4:	0000060f 	andeq	r0, r0, pc, lsl #12
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2dd8:	0250011c 	subseq	r0, r0, #28, 2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2ddc:	27000074 	smlsdxcs	r0, r4, r0, r0
    2de0:	000016d6 	ldrdeq	r1, [r0], -r6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2de4:	00000901 	andeq	r0, r0, r1, lsl #18
    2de8:	0550011c 	ldrbeq	r0, [r0, #-284]	; 0x11c
    2dec:	00750074 	rsbseq	r0, r5, r4, ror r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2df0:	0a000022 	beq	2e80 <fprime_from_bytes+0x44>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2df4:	00009704 	andeq	r9, r0, r4, lsl #14
    2df8:	04872800 	streq	r2, [r7], #2048	; 0x800
    2dfc:	51010000 	mrspl	r0, (UNDEF: 1)

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e00:	000000dc 	ldrdeq	r0, [r0], -ip
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2e04:	000016fc 	strdeq	r1, [r0], -ip
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2e08:	00000254 	andeq	r0, r0, r4, asr r2

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2e0c:	06d29c01 	ldrbeq	r9, [r2], r1, lsl #24
    2e10:	ee290000 	cdp	0, 2, cr0, cr9, cr0, {0}
    2e14:	01000011 	tsteq	r0, r1, lsl r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e18:	0000ad56 	andeq	sl, r0, r6, asr sp
    2e1c:	0009b600 	andeq	fp, r9, r0, lsl #12
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e20:	18022a00 	stmdane	r2, {r9, fp, sp}
		c += r[i];
    2e24:	002a0000 	eoreq	r0, sl, r0
		r[i] = c;
    2e28:	06ad0000 	strteq	r0, [sp], r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e2c:	ef2b0000 	svc	0x002b0000
		c += r[i];
		r[i] = c;
		c >>= 8;
    2e30:	0100000b 	tsteq	r0, fp
	f25519_sub(i, i, y);

	/* r = avi */
	f25519_mul__distinct(x, v, a);
	f25519_mul__distinct(r, x, i);
}
    2e34:	044b0113 	strbeq	r0, [fp], #-275	; 0x113
    2e38:	91020000 	mrsls	r0, (UNDEF: 2)
}

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
    2e3c:	65722564 	ldrbvs	r2, [r2, #-1380]!	; 0x564
    2e40:	14010074 	strne	r0, [r1], #-116	; 0x74
    2e44:	00007301 	andeq	r7, r0, r1, lsl #6
    2e48:	000a1600 	andeq	r1, sl, r0, lsl #12
static int prime_msb(const uint8_t *p)
{
	int i;
	uint8_t x;

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
    2e4c:	180e1b00 	stmdane	lr, {r8, r9, fp, ip}
    2e50:	091c0000 	ldmdbeq	ip, {}	; <UNPREDICTABLE>
    2e54:	069a0000 	ldreq	r0, [sl], r0
		if (p[i])
    2e58:	011c0000 	tsteq	ip, r0
			break;

	x = p[i];
	i <<= 3;
    2e5c:	000c0551 	andeq	r0, ip, r1, asr r5

	while (x) {
		x >>= 1;
		i++;
    2e60:	1c080080 	stcne	0, cr0, [r8], {128}	; 0x80
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    2e64:	7d025001 	stcvc	0, cr5, [r2, #-4]

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
    2e68:	26200004 	strtcs	r0, [r0], -r4
		x[i] = 0;
}

static inline int min_int(int a, int b)
{
	return a < b ? a : b;
    2e6c:	41000018 	tstmi	r0, r8, lsl r0
    2e70:	20000009 	andcs	r0, r0, r9
void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
    2e74:	0000182a 	andeq	r1, r0, sl, lsr #16
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);
    2e78:	00000954 	andeq	r0, r0, r4, asr r9
    2e7c:	17582000 	ldrbne	r2, [r8, -r0]
    2e80:	095c0000 	ldmdbeq	ip, {}^	; <UNPREDICTABLE>

	for (i = 0; i < preload_bytes; i++)
    2e84:	5c200000 	stcpl	0, cr0, [r0], #-0
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
    2e88:	64000017 	strvs	r0, [r0], #-23
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
    2e8c:	20000009 	andcs	r0, r0, r9
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2e90:	0000179e 	muleq	r0, lr, r7
    2e94:	0000096c 	andeq	r0, r0, ip, ror #18
    2e98:	0017ce20 	andseq	ip, r7, r0, lsr #28
    2e9c:	0005cb00 	andeq	ip, r5, r0, lsl #22
    2ea0:	f62c0000 			; <UNDEFINED> instruction: 0xf62c0000
    2ea4:	01000013 	tsteq	r0, r3, lsl r0
    2ea8:	00ad01f0 	strdeq	r0, [sp], r0	; <UNPREDICTABLE>
    2eac:	00000000 	andeq	r0, r0, r0
    2eb0:	000c0000 	andeq	r0, ip, r0
    2eb4:	9c010000 	stcls	0, cr0, [r1], {-0}
    2eb8:	0012201e 	andseq	r2, r2, lr, lsl r0
    2ebc:	01f50100 	mvnseq	r0, r0, lsl #2
    2ec0:	00000000 	andeq	r0, r0, r0
    2ec4:	0000000c 	andeq	r0, r0, ip
    2ec8:	070d9c01 	streq	r9, [sp, -r1, lsl #24]
    2ecc:	232d0000 	teqcs	sp, #0
    2ed0:	01000014 	tsteq	r0, r4, lsl r0
		n[i] = x[len - preload_bytes + i];
    2ed4:	00ad01f5 	strdeq	r0, [sp], r5	; <UNPREDICTABLE>
    2ed8:	50010000 	andpl	r0, r1, r0
    2edc:	0bde2e00 	bleq	ff78e6e4 <BootRAM+0xe6fee85>
    2ee0:	fa010000 	blx	42ee8 <_etext+0x3b9d0>
    2ee4:	0000dc01 	andeq	sp, r0, r1, lsl #24
    2ee8:	00195000 	andseq	r5, r9, r0
    2eec:	00000c00 	andeq	r0, r0, r0, lsl #24
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2ef0:	2e9c0100 	fmlcse	f0, f4, f0
		n[i] = x[len - preload_bytes + i];
    2ef4:	0000123d 	andeq	r1, r0, sp, lsr r2
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2ef8:	dc01ff01 	stcle	15, cr15, [r1], {1}
		n[i] = x[len - preload_bytes + i];
    2efc:	00000000 	andeq	r0, r0, r0
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f00:	1c000000 	stcne	0, cr0, [r0], {-0}
    2f04:	01000000 	mrseq	r0, (UNDEF: 0)
    2f08:	0c1e2f9c 	ldceq	15, cr2, [lr], {156}	; 0x9c
		n[i] = x[len - preload_bytes + i];
    2f0c:	05010000 	streq	r0, [r1, #-0]
    2f10:	00195c02 	andseq	r5, r9, r2, lsl #24
    2f14:	00000200 	andeq	r0, r0, r0, lsl #4

	if (preload_bits) {
    2f18:	309c0100 	addscc	r0, ip, r0, lsl #2
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c |= ((uint16_t)x[i]) << n;
    2f1c:	000011f9 	strdeq	r1, [r0], -r9
    2f20:	075c2801 	ldrbeq	r2, [ip, -r1, lsl #16]
		x[i] = c;
    2f24:	03050000 	movweq	r0, #20480	; 0x5000
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f28:	200002c0 	andcs	r0, r0, r0, asr #5
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    2f2c:	00009706 	andeq	r9, r0, r6, lsl #14
	for (i = 0; i < preload_bytes; i++)
		n[i] = x[len - preload_bytes + i];

	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
    2f30:	14023000 	strne	r3, [r2], #-0
    2f34:	29010000 	stmdbcs	r1, {}	; <UNPREDICTABLE>
    2f38:	0000075c 	andeq	r0, r0, ip, asr r7
    2f3c:	02bc0305 	adcseq	r0, ip, #335544320	; 0x14000000
    2f40:	28302000 	ldmdacs	r0!, {sp}
    2f44:	01000013 	tsteq	r0, r3, lsl r0
	}

	for (i = rbits - 1; i >= 0; i--) {
    2f48:	0007832a 	andeq	r8, r7, sl, lsr #6
    2f4c:	c5030500 	strgt	r0, [r3, #-1280]	; 0x500
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;
    2f50:	0620000d 	strteq	r0, [r0], -sp
    2f54:	000002ea 	andeq	r0, r0, sl, ror #5
    2f58:	0000ad17 	andeq	sl, r0, r7, lsl sp
    2f5c:	00079900 	andeq	r9, r7, r0, lsl #18
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f60:	00f43100 	rscseq	r3, r4, r0, lsl #2
		c |= ((uint16_t)x[i]) << n;
    2f64:	07ff0000 	ldrbeq	r0, [pc, r0]!
		x[i] = c;
    2f68:	125a3000 	subsne	r3, sl, #0
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f6c:	33010000 	movwcc	r0, #4096	; 0x1000
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    2f70:	000007aa 	andeq	r0, r0, sl, lsr #15

	for (i = rbits - 1; i >= 0; i--) {
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;

		shift_n_bits(n, 1);
		n[0] |= bit;
    2f74:	05bc0305 	ldreq	r0, [ip, #773]!	; 0x305
    2f78:	88062000 	stmdahi	r6, {sp}
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f7c:	30000007 	andcc	r0, r0, r7
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
    2f80:	00001318 	andeq	r1, r0, r8, lsl r3
    2f84:	075c3501 	ldrbeq	r3, [ip, -r1, lsl #10]
		minusp[i] = c;
    2f88:	03050000 	movweq	r0, #20480	; 0x5000
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f8c:	20000dc0 	andcs	r0, r0, r0, asr #27
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
    2f90:	00127330 	andseq	r7, r2, r0, lsr r3
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f94:	d1360100 	teqle	r6, r0, lsl #2

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    2f98:	05000007 	streq	r0, [r0, #-7]
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    2f9c:	000dbe03 	andeq	fp, sp, r3, lsl #28
    2fa0:	00a20620 	adceq	r0, r2, r0, lsr #12
    2fa4:	de300000 	cdple	0, 3, cr0, cr0, cr0, {0}
    2fa8:	01000012 	tsteq	r0, r2, lsl r0
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
    2fac:	0007d137 	andeq	sp, r7, r7, lsr r1
	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
	}

	for (i = rbits - 1; i >= 0; i--) {
    2fb0:	bc030500 	cfstr32lt	mvfx0, [r3], {-0}
    2fb4:	3220000d 	eorcc	r0, r0, #13

		shift_n_bits(n, 1);
		n[0] |= bit;
		raw_try_sub(n, modulus);
	}
}
    2fb8:	000001e8 	andeq	r0, r0, r8, ror #3

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
    2fbc:	07f2220a 	ldrbeq	r2, [r2, sl, lsl #4]!
	i <<= 3;

	while (x) {
    2fc0:	040a0000 	streq	r0, [sl], #-0
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
    2fc4:	0000024c 	andeq	r0, r0, ip, asr #4
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fc8:	0000b133 	andeq	fp, r0, r3, lsr r1
		n[i] = x[len - preload_bytes + i];
    2fcc:	732c0b00 	teqvc	ip, #0, 22
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fd0:	05000000 	streq	r0, [r0, #-0]
    2fd4:	00048803 	andeq	r8, r4, r3, lsl #16
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    2fd8:	129d3320 	addsne	r3, sp, #32, 6	; 0x80000000
    (b)[(i) + 2] = (uint8) ( (n) >>  8 );       \
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    2fdc:	2c010000 	stccs	0, cr0, [r1], {-0}
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    2fe0:	0000081a 	andeq	r0, r0, sl, lsl r8
void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    2fe4:	0dcb0305 	stcleq	3, cr0, [fp, #20]
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    2fe8:	dc062000 	stcle	0, cr2, [r6], {-0}
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    2fec:	33000000 	movwcc	r0, #0
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    2ff0:	00001414 	andeq	r1, r0, r4, lsl r4
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    2ff4:	08302b01 	ldmdaeq	r0!, {r0, r8, r9, fp, sp}
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    2ff8:	03050000 	movweq	r0, #20480	; 0x5000
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    2ffc:	20000dc4 	andcs	r0, r0, r4, asr #27
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    3000:	00028a06 	andeq	r8, r2, r6, lsl #20
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    3004:	00371700 	eorseq	r1, r7, r0, lsl #14
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
    3008:	08450000 	stmdaeq	r5, {}^	; <UNPREDICTABLE>
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;
    300c:	f4180000 			; <UNDEFINED> instruction: 0xf4180000
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
}
    3010:	1f000000 	svcne	0x00000000
    3014:	12803300 	addne	r3, r0, #0, 6
    3018:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    301c:	00000835 	andeq	r0, r0, r5, lsr r8
    3020:	04ec0305 	strbteq	r0, [ip], #773	; 0x305
    3024:	81172000 	tsthi	r7, r0
    3028:	66000000 	strvs	r0, [r0], -r0
    302c:	18000008 	stmdane	r0, {r3}
    3030:	000000f4 	strdeq	r0, [r0], -r4

void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    3034:	e833005b 	ldmda	r3!, {r0, r1, r3, r4, r6}
    3038:	01000011 	tsteq	r0, r1, lsl r0
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    303c:	0008562f 	andeq	r5, r8, pc, lsr #12
    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    3040:	90030500 	andls	r0, r3, r0, lsl #10
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3044:	34200004 	strtcc	r0, [r0], #-4
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    3048:	00787463 	rsbseq	r7, r8, r3, ror #8
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    304c:	03823001 	orreq	r3, r2, #1
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    3050:	03050000 	movweq	r0, #20480	; 0x5000
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3054:	2000050c 	andcs	r0, r0, ip, lsl #10
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    3058:	0013cc33 	andseq	ip, r3, r3, lsr ip
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    305c:	993a0100 	ldmdbls	sl!, {r8}
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3060:	05000008 	streq	r0, [r0, #-8]
    3064:	00057403 	andeq	r7, r5, r3, lsl #8
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3068:	031a0620 	tsteq	sl, #32, 12	; 0x2000000
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    306c:	ff350000 			; <UNDEFINED> instruction: 0xff350000
    3070:	0d00000f 	stceq	0, cr0, [r0, #-60]	; 0xffffffc4
    3074:	0000f219 	andeq	pc, r0, r9, lsl r2	; <UNPREDICTABLE>
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3078:	0008bd00 	andeq	fp, r8, r0, lsl #26
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    307c:	00f20f00 	rscseq	r0, r2, r0, lsl #30
    3080:	730f0000 	movwvc	r0, #61440	; 0xf000
    3084:	0f000000 	svceq	0x00000000
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3088:	000000e7 	andeq	r0, r0, r7, ror #1
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    308c:	13353600 	teqne	r5, #0, 12
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3090:	14080000 	strne	r0, [r8], #-0
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3094:	000008ce 	andeq	r0, r0, lr, asr #17
    3098:	0008ce0f 	andeq	ip, r8, pc, lsl #28
    309c:	040a0000 	streq	r0, [sl], #-0
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    30a0:	00000382 	andeq	r0, r0, r2, lsl #7
    30a4:	000cc437 	andeq	ip, ip, r7, lsr r4
    30a8:	013a0c00 	teqeq	sl, r0, lsl #24
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30ac:	00047338 	andeq	r7, r4, r8, lsr r3
    30b0:	37830b00 	strcc	r0, [r3, r0, lsl #22]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    30b4:	00000c72 	andeq	r0, r0, r2, ror ip
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30b8:	39012b0c 	stmdbcc	r1, {r2, r3, r8, r9, fp, sp}
    30bc:	00000c4b 	andeq	r0, r0, fp, asr #24
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30c0:	dc01350c 	cfstr32le	mvfx3, [r1], {12}
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30c4:	01000000 	mrseq	r0, (UNDEF: 0)
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30c8:	0f000009 	svceq	0x00000009
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    30cc:	00000097 	muleq	r0, r7, r0
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30d0:	0e293900 	cdpeq	9, 2, cr3, cr9, cr0, {0}
    30d4:	340c0000 	strcc	r0, [ip], #-0
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30d8:	0000dc01 	andeq	sp, r0, r1, lsl #24
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30dc:	00091c00 	andeq	r1, r9, r0, lsl #24
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30e0:	00970f00 	addseq	r0, r7, r0, lsl #30
    30e4:	970f0000 	strls	r0, [pc, -r0]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30e8:	00000000 	andeq	r0, r0, r0
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30ec:	000b2e35 	andeq	r2, fp, r5, lsr lr
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30f0:	73660900 	cmnvc	r6, #0, 18
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    30f4:	3b000000 	blcc	30fc <sha256_process+0xc8>
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30f8:	0f000009 	svceq	0x00000009
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30fc:	0000093b 	andeq	r0, r0, fp, lsr r9
    3100:	0000b70f 	andeq	fp, r0, pc, lsl #14
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    3104:	00dc0f00 	sbcseq	r0, ip, r0, lsl #30
    3108:	0a000000 	beq	3110 <sha256_process+0xdc>
    310c:	00044b04 	andeq	r4, r4, r4, lsl #22
    3110:	0bfb3a00 	bleq	ffed1918 <BootRAM+0xee420b9>
    3114:	400c0000 	andmi	r0, ip, r0
    3118:	00095401 	andeq	r5, r9, r1, lsl #8
    311c:	01020f00 	tsteq	r2, r0, lsl #30
    3120:	003b0000 	eorseq	r0, fp, r0
    3124:	00101137 	andseq	r1, r0, r7, lsr r1
    3128:	01370c00 	teqeq	r7, r0, lsl #24
    312c:	000ae537 	andeq	lr, sl, r7, lsr r5
    3130:	012f0c00 	teqeq	pc, r0, lsl #24
    3134:	000e7f37 	andeq	r7, lr, r7, lsr pc
    3138:	01380c00 	teqeq	r8, r0, lsl #24
    313c:	000ef83c 	andeq	pc, lr, ip, lsr r8	; <UNPREDICTABLE>
    3140:	013c0c00 	teqeq	ip, r0, lsl #24
    3144:	00000073 	andeq	r0, r0, r3, ror r0
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3148:	000a3300 	andeq	r3, sl, r0, lsl #6
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    314c:	09000400 	stmdbeq	r0, {sl}
    3150:	0400000e 	streq	r0, [r0], #-14
    3154:	0014b401 	andseq	fp, r4, r1, lsl #8
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3158:	14470100 	strbne	r0, [r7], #-256	; 0x100
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    315c:	08930000 	ldmeq	r3, {}	; <UNPREDICTABLE>
    3160:	03380000 	teqeq	r8, #0
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3164:	00000000 	andeq	r0, r0, r0
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3168:	0fb90000 	svceq	0x00b90000
    316c:	01020000 	mrseq	r0, (UNDEF: 2)
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3170:	00081a06 	andeq	r1, r8, r6, lsl #20
    3174:	0b010300 	bleq	43d7c <_etext+0x3c864>
    3178:	1c030000 	stcne	0, cr0, [r3], {-0}
    317c:	00000037 	andeq	r0, r0, r7, lsr r0
    3180:	18080102 	stmdane	r8, {r1, r8}
    3184:	02000008 	andeq	r0, r0, #8
    3188:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
    318c:	02020000 	andeq	r0, r2, #0
    3190:	00094907 	andeq	r4, r9, r7, lsl #18
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3194:	05040200 	streq	r0, [r4, #-512]	; 0x200
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3198:	000004da 	ldrdeq	r0, [r0], -sl
    319c:	000ace03 	andeq	ip, sl, r3, lsl #28
    31a0:	5e380300 	cdppl	3, 3, cr0, cr8, cr0, {0}
    31a4:	02000000 	andeq	r0, r0, #0
    31a8:	02520704 	subseq	r0, r2, #4, 14	; 0x100000
    31ac:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31b0:	0004d505 	andeq	sp, r4, r5, lsl #10
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31b4:	07080200 	streq	r0, [r8, -r0, lsl #4]
    31b8:	0000024d 	andeq	r0, r0, sp, asr #4
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31bc:	69050404 	stmdbvs	r5, {r2, sl}
    31c0:	0200746e 	andeq	r7, r0, #1845493760	; 0x6e000000
    31c4:	02570704 	subseq	r0, r7, #4, 14	; 0x100000
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31c8:	03030000 	movweq	r0, #12288	; 0x3000
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31cc:	0400000b 	streq	r0, [r0], #-11
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31d0:	00002c2a 	andeq	r2, r0, sl, lsr #24

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31d4:	0ad00300 	beq	ff403ddc <BootRAM+0xe37457d>
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31d8:	42040000 	andmi	r0, r4, #0
    GET_UINT32( W[4],  data, 16 );
    31dc:	00000053 	andeq	r0, r0, r3, asr r0
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31e0:	8b070402 	blhi	1c41f0 <_etext+0x1bccd8>
    31e4:	02000007 	andeq	r0, r0, #7
    31e8:	08210801 	stmdaeq	r1!, {r0, fp}
    31ec:	60050000 	andvs	r0, r5, r0

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31f0:	02000014 	andeq	r0, r0, #20
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31f4:	00c40322 	sbceq	r0, r4, r2, lsr #6

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31f8:	78060000 	stmdavc	r6, {}	; <UNPREDICTABLE>
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31fc:	c4220200 	strtgt	r0, [r2], #-512	; 0x200
    3200:	06000000 	streq	r0, [r0], -r0
    3204:	22020061 	andcs	r0, r2, #97	; 0x61
    3208:	000000ca 	andeq	r0, r0, sl, asr #1
    320c:	81040700 	tsthi	r4, r0, lsl #14
    3210:	07000000 	streq	r0, [r0, -r0]

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3214:	0000d004 	andeq	sp, r0, r4
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3218:	00810800 	addeq	r0, r1, r0, lsl #16
    321c:	b2050000 	andlt	r0, r5, #0
    3220:	01000015 	tsteq	r0, r5, lsl r0
    3224:	0158012a 	cmpeq	r8, sl, lsr #2

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3228:	78060000 	stmdavc	r6, {}	; <UNPREDICTABLE>
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    322c:	2a010035 	bcs	43308 <_etext+0x3bdf0>

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3230:	000000c4 	andeq	r0, r0, r4, asr #1
    3234:	00357a06 	eorseq	r7, r5, r6, lsl #20
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3238:	00c42a01 	sbceq	r2, r4, r1, lsl #20

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    323c:	78060000 	stmdavc	r6, {}	; <UNPREDICTABLE>
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3240:	2b010031 	blcs	4330c <_etext+0x3bdf4>

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3244:	000000ca 	andeq	r0, r0, sl, asr #1
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3248:	00317a06 	eorseq	r7, r1, r6, lsl #20
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    324c:	00ca2b01 	sbceq	r2, sl, r1, lsl #22
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3250:	78060000 	stmdavc	r6, {}	; <UNPREDICTABLE>
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3254:	2c010032 	stccs	0, cr0, [r1], {50}	; 0x32

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3258:	000000ca 	andeq	r0, r0, sl, asr #1

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    325c:	00327a06 	eorseq	r7, r2, r6, lsl #20
    3260:	00ca2c01 	sbceq	r2, sl, r1, lsl #24
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3264:	78060000 	stmdavc	r6, {}	; <UNPREDICTABLE>
    3268:	2d010033 	stccs	0, cr0, [r1, #-204]	; 0xffffff34

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    326c:	000000ca 	andeq	r0, r0, sl, asr #1
    3270:	00337a06 	eorseq	r7, r3, r6, lsl #20
    3274:	00ca2d01 	sbceq	r2, sl, r1, lsl #26
    3278:	64090000 	strvs	r0, [r9], #-0
    327c:	3d010061 	stccc	0, cr0, [r1, #-388]	; 0xfffffe7c
    3280:	00000158 	andeq	r0, r0, r8, asr r1
    3284:	00626309 	rsbeq	r6, r2, r9, lsl #6
    3288:	01583e01 	cmpeq	r8, r1, lsl #28
    328c:	61090000 	mrsvs	r0, (UNDEF: 9)
    3290:	583f0100 	ldmdapl	pc!, {r8}	; <UNPREDICTABLE>
    3294:	09000001 	stmdbeq	r0, {r0}
    3298:	40010062 	andmi	r0, r1, r2, rrx
    329c:	00000158 	andeq	r0, r0, r8, asr r1
    32a0:	00810a00 	addeq	r0, r1, r0, lsl #20
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32a4:	01680000 	cmneq	r8, r0

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32a8:	970b0000 	strls	r0, [fp, -r0]
    32ac:	1f000000 	svcne	0x00000000
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32b0:	14560500 	ldrbne	r0, [r6], #-1280	; 0x500
    32b4:	0c010000 	stceq	0, cr0, [r1], {-0}

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32b8:	0001c701 	andeq	ip, r1, r1, lsl #14
    32bc:	33780600 	cmncc	r8, #0, 12
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32c0:	c40c0100 	strgt	r0, [ip], #-256	; 0x100
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32c4:	06000000 	streq	r0, [r0], -r0

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32c8:	0100337a 	tsteq	r0, sl, ror r3
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32cc:	0000c40c 	andeq	ip, r0, ip, lsl #8
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32d0:	31780600 	cmncc	r8, r0, lsl #12
    32d4:	ca0d0100 	bgt	3436dc <_etext+0x33c1c4>
    32d8:	06000000 	streq	r0, [r0], -r0
    32dc:	0100317a 	tsteq	r0, sl, ror r1
    32e0:	0000ca0d 	andeq	ip, r0, sp, lsl #20
    32e4:	14920c00 	ldrne	r0, [r2], #3072	; 0xc00
    32e8:	16010000 	strne	r0, [r1], -r0

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32ec:	00000158 	andeq	r0, r0, r8, asr r1
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32f0:	0014a20c 	andseq	sl, r4, ip, lsl #4
    32f4:	58170100 	ldmdapl	r7, {r8}
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    32f8:	0c000001 	stceq	0, cr0, [r0], {1}
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32fc:	0000155d 	andeq	r1, r0, sp, asr r5
    3300:	01581801 	cmpeq	r8, r1, lsl #16
    3304:	61090000 	mrsvs	r0, (UNDEF: 9)
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    3308:	58190100 	ldmdapl	r9, {r8}
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    330c:	00000001 	andeq	r0, r0, r1
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    3310:	0014a70d 	andseq	sl, r4, sp, lsl #14
    3314:	00530100 	subseq	r0, r3, r0, lsl #2
    3318:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    331c:	01000002 	tsteq	r0, r2
    3320:	00095c9c 	muleq	r9, ip, ip
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    3324:	15ab0e00 	strne	r0, [fp, #3584]!	; 0xe00
    3328:	53010000 	movwpl	r0, #4096	; 0x1000
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    332c:	000000c4 	andeq	r0, r0, r4, asr #1
    3330:	00000a34 	andeq	r0, r0, r4, lsr sl
    3334:	0100710f 	tsteq	r0, pc, lsl #2
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3338:	0000ca53 	andeq	ip, r0, r3, asr sl
    333c:	000a6000 	andeq	r6, sl, r0
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3340:	00650f00 	rsbeq	r0, r5, r0, lsl #30
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3344:	00ca5301 	sbceq	r5, sl, r1, lsl #6
    3348:	0a8c0000 	beq	fe303350 <BootRAM+0xd273af1>
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    334c:	78100000 	ldmdavc	r0, {}	; <UNPREDICTABLE>
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3350:	5601006d 	strpl	r0, [r1], -sp, rrx
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3354:	00000158 	andeq	r0, r0, r8, asr r1
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3358:	7da89103 	stfvcd	f1, [r8, #12]!
    335c:	006d7a10 	rsbeq	r7, sp, r0, lsl sl
    3360:	01585701 	cmpeq	r8, r1, lsl #14
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3364:	91030000 	mrsls	r0, (UNDEF: 3)
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3368:	78107dc8 	ldmdavc	r0, {r3, r6, r7, r8, sl, fp, ip, sp, lr}
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    336c:	0100316d 	tsteq	r0, sp, ror #2
    3370:	0001585a 	andeq	r5, r1, sl, asr r8
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3374:	e8910300 	ldm	r1, {r8, r9}
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3378:	6d7a107d 	ldclvs	0, cr1, [sl, #-500]!	; 0xfffffe0c
    337c:	5b010031 	blpl	43448 <_etext+0x3bf30>
    3380:	00000158 	andeq	r0, r0, r8, asr r1
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3384:	7e889103 	sinvce	f1, f3
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3388:	01006911 	tsteq	r0, r1, lsl r9
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    338c:	0000735d 	andeq	r7, r0, sp, asr r3
    3390:	000ab800 	andeq	fp, sl, r0, lsl #16
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3394:	00a51200 	adceq	r1, r5, r0, lsl #4
    3398:	00000000 	andeq	r0, r0, r0
    339c:	02b80000 	adcseq	r0, r8, #0
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    33a0:	60010000 	andvs	r0, r1, r0
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33a4:	00000272 	andeq	r0, r0, r2, ror r2
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    33a8:	0000ba13 	andeq	fp, r0, r3, lsl sl
    33ac:	000ae300 	andeq	lr, sl, r0, lsl #6
    33b0:	00b11300 	adcseq	r1, r1, r0, lsl #6
    33b4:	0b040000 	bleq	1033bc <_etext+0xfbea4>
    33b8:	14000000 	strne	r0, [r0], #-0
    33bc:	000002e8 	andeq	r0, r0, r8, ror #5
    33c0:	0000090e 	andeq	r0, r0, lr, lsl #18
    33c4:	74696211 	strbtvc	r6, [r9], #-529	; 0x211
    33c8:	5c630100 	stfple	f0, [r3], #-0
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33cc:	33000009 	movwcc	r0, #9
    33d0:	1000000b 	andne	r0, r0, fp
    33d4:	00736d78 	rsbseq	r6, r3, r8, ror sp
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    33d8:	01586401 	cmpeq	r8, r1, lsl #8
    33dc:	91030000 	mrsls	r0, (UNDEF: 3)
    33e0:	7a107ea8 	bvc	422e88 <_etext+0x41b970>
    33e4:	0100736d 	tsteq	r0, sp, ror #6
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33e8:	00015865 	andeq	r5, r1, r5, ror #16
    33ec:	c8910300 	ldmgt	r1, {r8, r9}
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    33f0:	00d5127e 	sbcseq	r1, r5, lr, ror r2
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    33f4:	00000000 	andeq	r0, r0, r0
    33f8:	03000000 	movweq	r0, #0
    33fc:	68010000 	stmdavs	r1, {}	; <UNPREDICTABLE>
    3400:	000004b7 			; <UNDEFINED> instruction: 0x000004b7
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3404:	0000ff15 	andeq	pc, r0, r5, lsl pc	; <UNPREDICTABLE>
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3408:	01271300 	teqeq	r7, r0, lsl #6
    340c:	0b460000 	bleq	1183414 <_etext+0x117befc>
    3410:	1d130000 	ldcne	0, cr0, [r3, #-0]
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3414:	b5000001 	strlt	r0, [r0, #-1]
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3418:	1300000b 	movwne	r0, #11
    341c:	00000113 	andeq	r0, r0, r3, lsl r1
    3420:	00000c0b 	andeq	r0, r0, fp, lsl #24
    3424:	00010913 	andeq	r0, r1, r3, lsl r9
    3428:	000c7a00 	andeq	r7, ip, r0, lsl #20
    342c:	00f51300 	rscseq	r1, r5, r0, lsl #6
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3430:	0ca90000 	stceq	0, cr0, [r9]
    3434:	eb130000 	bl	4c343c <_etext+0x4bbf24>
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3438:	46000000 	strmi	r0, [r0], -r0
    343c:	1300000b 	movwne	r0, #11
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3440:	000000e1 	andeq	r0, r0, r1, ror #1
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3444:	00000bb5 			; <UNDEFINED> instruction: 0x00000bb5
    3448:	00030016 	andeq	r0, r3, r6, lsl r0
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    344c:	01311700 	teqeq	r1, r0, lsl #14
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3450:	91030000 	mrsls	r0, (UNDEF: 3)
    3454:	3b177ee8 	blcc	5e2ffc <_etext+0x5dbae4>
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3458:	03000001 	movweq	r0, #1
    345c:	177f8891 			; <UNDEFINED> instruction: 0x177f8891
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3460:	00000145 	andeq	r0, r0, r5, asr #2
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3464:	7fa89103 	svcvc	0x00a89103
    GET_UINT32( W[9],  data, 36 );
    3468:	00014e17 	andeq	r4, r1, r7, lsl lr
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    346c:	48910200 	ldmmi	r1, {r9}
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3470:	00000018 	andeq	r0, r0, r8, lsl r0
    3474:	00098700 	andeq	r8, r9, r0, lsl #14
    3478:	00034900 	andeq	r4, r3, r0, lsl #18
    347c:	52011900 	andpl	r1, r1, #0, 18
    3480:	7dc89103 	stfvcp	f1, [r8, #12]
    3484:	02510119 	subseq	r0, r1, #1073741830	; 0x40000006
    3488:	0119007d 	tsteq	r9, sp, ror r0
    348c:	a8910350 	ldmge	r1, {r4, r6, r8, r9}
    3490:	0018007f 	andseq	r0, r8, pc, ror r0
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3494:	a2000000 	andge	r0, r0, #0
    3498:	6b000009 	blvs	34c4 <sha256_process+0x490>
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    349c:	19000003 	stmdbne	r0, {r0, r1}
    34a0:	91035201 	tstls	r3, r1, lsl #4
    34a4:	01197e88 	tsteq	r9, r8, lsl #29
    34a8:	e8910351 	ldm	r1, {r0, r4, r6, r8, r9}
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34ac:	5001197d 	andpl	r1, r1, sp, ror r9
    34b0:	00489102 	subeq	r9, r8, r2, lsl #2
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34b4:	00000018 	andeq	r0, r0, r8, lsl r0
    34b8:	0009bd00 	andeq	fp, r9, r0, lsl #26
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34bc:	00038d00 	andeq	r8, r3, r0, lsl #26
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34c0:	52011900 	andpl	r1, r1, #0, 18
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34c4:	19489102 	stmdbne	r8, {r1, r8, ip, pc}^
    34c8:	91035101 	tstls	r3, r1, lsl #2
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34cc:	01197fa8 	tsteq	r9, r8, lsr #31
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34d0:	e8910350 	ldm	r1, {r4, r6, r8, r9}
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34d4:	0018007e 	andseq	r0, r8, lr, ror r0
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34d8:	a2000000 	andge	r0, r0, #0
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34dc:	ae000009 	cdpge	0, 0, cr0, cr0, cr9, {0}
    34e0:	19000003 	stmdbne	r0, {r0, r1}
    34e4:	91035201 	tstls	r3, r1, lsl #4
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    34e8:	01197dc8 	tsteq	r9, r8, asr #27
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34ec:	007d0251 	rsbseq	r0, sp, r1, asr r2
    34f0:	02500119 	subseq	r0, r0, #1073741830	; 0x40000006
    34f4:	18004891 	stmdane	r0, {r0, r4, r7, fp, lr}
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    34f8:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34fc:	00000987 	andeq	r0, r0, r7, lsl #19
    3500:	000003d1 	ldrdeq	r0, [r0], -r1
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3504:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3508:	197e8891 	ldmdbne	lr!, {r0, r4, r7, fp, pc}^
    350c:	91035101 	tstls	r3, r1, lsl #2
    3510:	01197de8 	tsteq	r9, r8, ror #27
    3514:	a8910350 	ldmge	r1, {r4, r6, r8, r9}
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3518:	0018007f 	andseq	r0, r8, pc, ror r0
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    351c:	bd000000 	stclt	0, cr0, [r0, #-0]
    3520:	f3000009 	vhadd.u8	d0, d0, d9
    3524:	19000003 	stmdbne	r0, {r0, r1}
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3528:	91025201 	tstls	r2, r1, lsl #4
    352c:	51011948 	tstpl	r1, r8, asr #18
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3530:	7fa89103 	svcvc	0x00a89103
    3534:	03500119 	cmpeq	r0, #1073741830	; 0x40000006
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3538:	007f8891 			; <UNDEFINED> instruction: 0x007f8891
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    353c:	00000018 	andeq	r0, r0, r8, lsl r0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3540:	00098700 	andeq	r8, r9, r0, lsl #14
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3544:	00041600 	andeq	r1, r4, r0, lsl #12
    3548:	52011900 	andpl	r1, r1, #0, 18
    354c:	7f889103 	svcvc	0x00889103
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3550:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3554:	197ee891 	ldmdbne	lr!, {r0, r4, r7, fp, sp, lr, pc}^
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3558:	91035001 	tstls	r3, r1
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    355c:	18007fa8 	stmdane	r0, {r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    3560:	00000000 	andeq	r0, r0, r0
    3564:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    3568:	00000438 	andeq	r0, r0, r8, lsr r4
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    356c:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3570:	197fa891 	ldmdbne	pc!, {r0, r4, r7, fp, sp, pc}^	; <UNPREDICTABLE>
    3574:	91035101 	tstls	r3, r1, lsl #2
    3578:	01197fa8 	tsteq	r9, r8, lsr #31
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    357c:	48910250 	ldmmi	r1, {r4, r6, r9}
    3580:	00001800 	andeq	r1, r0, r0, lsl #16
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3584:	09bd0000 	ldmibeq	sp!, {}	; <UNPREDICTABLE>
    3588:	04530000 	ldrbeq	r0, [r3], #-0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    358c:	01190000 	tsteq	r9, r0
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3590:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    3594:	03500119 	cmpeq	r0, #1073741830	; 0x40000006
    3598:	007de891 			; <UNDEFINED> instruction: 0x007de891
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    359c:	00000018 	andeq	r0, r0, r8, lsl r0
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35a0:	0009a200 	andeq	sl, r9, r0, lsl #4
    35a4:	00047600 	andeq	r7, r4, r0, lsl #12
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35a8:	52011900 	andpl	r1, r1, #0, 18
    35ac:	7f889103 	svcvc	0x00889103
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35b0:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    35b4:	197ee891 	ldmdbne	lr!, {r0, r4, r7, fp, sp, lr, pc}^
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35b8:	91035001 	tstls	r3, r1
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35bc:	18007fa8 	stmdane	r0, {r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35c0:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35c4:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35c8:	00000498 	muleq	r0, r8, r4
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35cc:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35d0:	197fa891 	ldmdbne	pc!, {r0, r4, r7, fp, sp, pc}^	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35d4:	91035101 	tstls	r3, r1, lsl #2
    35d8:	01197fa8 	tsteq	r9, r8, lsr #31
    35dc:	48910250 	ldmmi	r1, {r4, r6, r9}
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35e0:	00001a00 	andeq	r1, r0, r0, lsl #20
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35e4:	09bd0000 	ldmibeq	sp!, {}	; <UNPREDICTABLE>
    35e8:	01190000 	tsteq	r9, r0
    35ec:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    35f0:	02510119 	subseq	r0, r1, #1073741830	; 0x40000006
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35f4:	01190076 	tsteq	r9, r6, ror r0
    35f8:	88910350 	ldmhi	r1, {r4, r6, r8, r9}
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    35fc:	0000007e 	andeq	r0, r0, lr, ror r0
    3600:	0001681b 	andeq	r6, r1, fp, lsl r8
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3604:	00000000 	andeq	r0, r0, r0
    3608:	00006400 	andeq	r6, r0, r0, lsl #8
    360c:	69690100 	stmdbvs	r9!, {r8}^
    3610:	13000006 	movwne	r0, #6
    3614:	00000192 	muleq	r0, r2, r1
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3618:	00000c0b 	andeq	r0, r0, fp, lsl #24
    361c:	00018813 	andeq	r8, r1, r3, lsl r8
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3620:	000c7a00 	andeq	r7, ip, r0, lsl #20
    3624:	017e1300 	cmneq	lr, r0, lsl #6
    3628:	0c0b0000 	stceq	0, cr0, [fp], {-0}
    362c:	74130000 	ldrvc	r0, [r3], #-0
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3630:	7a000001 	bvc	363c <sha256_process+0x608>
    3634:	1c00000c 	stcne	0, cr0, [r0], {12}
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3638:	00000000 	andeq	r0, r0, r0
    363c:	00000064 	andeq	r0, r0, r4, rrx
    3640:	00019c17 	andeq	r9, r1, r7, lsl ip
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3644:	e8910300 	ldm	r1, {r8, r9}
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3648:	01a7177e 			; <UNDEFINED> instruction: 0x01a7177e
    364c:	91030000 	mrsls	r0, (UNDEF: 3)
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3650:	b2177f88 	andslt	r7, r7, #136, 30	; 0x220
    3654:	03000001 	movweq	r0, #1
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3658:	177fa891 			; <UNDEFINED> instruction: 0x177fa891
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    365c:	000001bd 			; <UNDEFINED> instruction: 0x000001bd
    3660:	18489102 	stmdane	r8, {r1, r8, ip, pc}^
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3664:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3668:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    366c:	0000053b 	andeq	r0, r0, fp, lsr r5
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3670:	02520119 	subseq	r0, r2, #1073741830	; 0x40000006
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3674:	0119007d 	tsteq	r9, sp, ror r0
    3678:	007d0251 	rsbseq	r0, sp, r1, asr r2
    367c:	03500119 	cmpeq	r0, #1073741830	; 0x40000006
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3680:	007ee891 			; <UNDEFINED> instruction: 0x007ee891
    3684:	00000018 	andeq	r0, r0, r8, lsl r0
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3688:	0009bd00 	andeq	fp, r9, r0, lsl #26
    368c:	00055e00 	andeq	r5, r5, r0, lsl #28
    3690:	52011900 	andpl	r1, r1, #0, 18
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3694:	7dc89103 	stfvcp	f1, [r8, #12]
    3698:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    369c:	197dc891 	ldmdbne	sp!, {r0, r4, r7, fp, lr, pc}^
    36a0:	91035001 	tstls	r3, r1
    36a4:	18007f88 	stmdane	r0, {r3, r7, r8, r9, sl, fp, ip, sp, lr}
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    36a8:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36ac:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    36b0:	00000580 	andeq	r0, r0, r0, lsl #11
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36b4:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36b8:	197dc891 	ldmdbne	sp!, {r0, r4, r7, fp, lr, pc}^
    36bc:	7d025101 	stfvcs	f5, [r2, #-4]
    36c0:	50011900 	andpl	r1, r1, r0, lsl #18
    36c4:	7fa89103 	svcvc	0x00a89103
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36c8:	00001800 	andeq	r1, r0, r0, lsl #16
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36cc:	09a20000 	stmibeq	r2!, {}	; <UNPREDICTABLE>
    36d0:	05a20000 	streq	r0, [r2, #0]!
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36d4:	01190000 	tsteq	r9, r0
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36d8:	88910352 	ldmhi	r1, {r1, r4, r6, r8, r9}
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36dc:	5101197f 	tstpl	r1, pc, ror r9
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36e0:	7ee89103 	urdvce	f1, f3
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36e4:	02500119 	subseq	r0, r0, #1073741830	; 0x40000006
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36e8:	18004891 	stmdane	r0, {r0, r4, r7, fp, lr}
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36ec:	00000000 	andeq	r0, r0, r0
    36f0:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36f4:	000005c2 	andeq	r0, r0, r2, asr #11
    36f8:	02520119 	subseq	r0, r2, #1073741830	; 0x40000006
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36fc:	01194891 			; <UNDEFINED> instruction: 0x01194891
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3700:	48910251 	ldmmi	r1, {r0, r4, r6, r9}
    3704:	02500119 	subseq	r0, r0, #1073741830	; 0x40000006
    3708:	1800007d 	stmdane	r0, {r0, r2, r3, r4, r5, r6}
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    370c:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3710:	000009d8 	ldrdeq	r0, [r0], -r8
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3714:	000005e6 	andeq	r0, r0, r6, ror #11
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3718:	05520119 	ldrbeq	r0, [r2, #-281]	; 0x119
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    371c:	076d060c 	strbeq	r0, [sp, -ip, lsl #12]!
    3720:	51011900 	tstpl	r1, r0, lsl #18
    3724:	7fa89103 	svcvc	0x00a89103
    3728:	02500119 	subseq	r0, r0, #1073741830	; 0x40000006
    372c:	18004891 	stmdane	r0, {r0, r4, r7, fp, lr}
    3730:	00000000 	andeq	r0, r0, r0
    3734:	00000987 	andeq	r0, r0, r7, lsl #19
    3738:	00000607 	andeq	r0, r0, r7, lsl #12
    373c:	02520119 	subseq	r0, r2, #1073741830	; 0x40000006
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3740:	01194891 			; <UNDEFINED> instruction: 0x01194891
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3744:	e8910351 	ldm	r1, {r0, r4, r6, r8, r9}
    3748:	5001197e 	andpl	r1, r1, lr, ror r9
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    374c:	00489102 	subeq	r9, r8, r2, lsl #2
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3750:	00000018 	andeq	r0, r0, r8, lsl r0
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3754:	00098700 	andeq	r8, r9, r0, lsl #14
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3758:	00062800 	andeq	r2, r6, r0, lsl #16
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    375c:	52011900 	andpl	r1, r1, #0, 18
    3760:	19489102 	stmdbne	r8, {r1, r8, ip, pc}^
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3764:	91035101 	tstls	r3, r1, lsl #2
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3768:	01197f88 	tsteq	r9, r8, lsl #31
    376c:	48910250 	ldmmi	r1, {r4, r6, r9}
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3770:	00001800 	andeq	r1, r0, r0, lsl #16
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3774:	09bd0000 	ldmibeq	sp!, {}	; <UNPREDICTABLE>
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3778:	064a0000 	strbeq	r0, [sl], -r0
    377c:	01190000 	tsteq	r9, r0
    3780:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    3784:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    3788:	197fa891 	ldmdbne	pc!, {r0, r4, r7, fp, sp, pc}^	; <UNPREDICTABLE>
    378c:	91035001 	tstls	r3, r1
    3790:	1a007ee8 	bne	23338 <_etext+0x1be20>
    3794:	00000000 	andeq	r0, r0, r0
    3798:	000009d8 	ldrdeq	r0, [r0], -r8
    379c:	01520119 	cmpeq	r2, r9, lsl r1
    37a0:	51011934 	tstpl	r1, r4, lsr r9
    37a4:	7ee89103 	urdvce	f1, f3
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    37a8:	03500119 	cmpeq	r0, #1073741830	; 0x40000006
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37ac:	007dc891 			; <UNDEFINED> instruction: 0x007dc891
    37b0:	d5120000 	ldrle	r0, [r2, #-0]
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37b4:	00000000 	andeq	r0, r0, r0
    37b8:	20000000 	andcs	r0, r0, r0
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37bc:	01000003 	tsteq	r0, r3
    37c0:	0008706c 	andeq	r7, r8, ip, rrx
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37c4:	01271500 	teqeq	r7, r0, lsl #10
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37c8:	1d130000 	ldcne	0, cr0, [r3, #-0]
    37cc:	a9000001 	stmdbge	r0, {r0}
    37d0:	1300000c 	movwne	r0, #12
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37d4:	00000113 	andeq	r0, r0, r3, lsl r1
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37d8:	00000c0b 	andeq	r0, r0, fp, lsl #24
    37dc:	00010913 	andeq	r0, r1, r3, lsl r9
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37e0:	000c7a00 	andeq	r7, ip, r0, lsl #20
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37e4:	00ff1300 	rscseq	r1, pc, r0, lsl #6
    37e8:	0b460000 	bleq	11837f0 <_etext+0x117c2d8>
    37ec:	f5130000 			; <UNDEFINED> instruction: 0xf5130000
    37f0:	b5000000 	strlt	r0, [r0, #-0]
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37f4:	1300000b 	movwne	r0, #11
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37f8:	000000eb 	andeq	r0, r0, fp, ror #1
    37fc:	00000cca 	andeq	r0, r0, sl, asr #25
    3800:	0000e113 	andeq	lr, r0, r3, lsl r1
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3804:	000d2000 	andeq	r2, sp, r0
    3808:	03201600 	teqeq	r0, #0, 12
    380c:	31170000 	tstcc	r7, r0
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3810:	03000001 	movweq	r0, #1
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3814:	177ee891 			; <UNDEFINED> instruction: 0x177ee891
    3818:	0000013b 	andeq	r0, r0, fp, lsr r1
    381c:	7f889103 	svcvc	0x00889103
    3820:	00014517 	andeq	r4, r1, r7, lsl r5
    3824:	a8910300 	ldmge	r1, {r8, r9}
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3828:	014e177f 	hvceq	57727	; 0xe17f
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    382c:	91020000 	mrsls	r0, (UNDEF: 2)
    3830:	00001848 	andeq	r1, r0, r8, asr #16
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3834:	09870000 	stmibeq	r7, {}	; <UNPREDICTABLE>
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3838:	070a0000 	streq	r0, [sl, -r0]
    383c:	01190000 	tsteq	r9, r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3840:	c8910352 	ldmgt	r1, {r1, r4, r6, r8, r9}
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3844:	5101197d 	tstpl	r1, sp, ror r9
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3848:	19007d02 	stmdbne	r0, {r1, r8, sl, fp, ip, sp, lr}
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    384c:	91035001 	tstls	r3, r1
    3850:	18007fa8 	stmdane	r0, {r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    3854:	00000000 	andeq	r0, r0, r0
    3858:	000009a2 	andeq	r0, r0, r2, lsr #19
    385c:	00000724 	andeq	r0, r0, r4, lsr #14
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3860:	02510119 	subseq	r0, r1, #1073741830	; 0x40000006
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3864:	01190076 	tsteq	r9, r6, ror r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3868:	48910250 	ldmmi	r1, {r4, r6, r9}
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    386c:	00001800 	andeq	r1, r0, r0, lsl #16
    3870:	09bd0000 	ldmibeq	sp!, {}	; <UNPREDICTABLE>
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3874:	07460000 	strbeq	r0, [r6, -r0]
    3878:	01190000 	tsteq	r9, r0
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    387c:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3880:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    3884:	197fa891 	ldmdbne	pc!, {r0, r4, r7, fp, sp, pc}^	; <UNPREDICTABLE>
    3888:	91035001 	tstls	r3, r1
    388c:	18007ee8 	stmdane	r0, {r3, r5, r6, r7, r9, sl, fp, ip, sp, lr}
    3890:	00000000 	andeq	r0, r0, r0
    3894:	000009a2 	andeq	r0, r0, r2, lsr #19
    3898:	00000767 	andeq	r0, r0, r7, ror #14
    389c:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    38a0:	197dc891 	ldmdbne	sp!, {r0, r4, r7, fp, lr, pc}^
    38a4:	7d025101 	stfvcs	f5, [r2, #-4]
    38a8:	50011900 	andpl	r1, r1, r0, lsl #18
    38ac:	00489102 	subeq	r9, r8, r2, lsl #2
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38b0:	00000018 	andeq	r0, r0, r8, lsl r0
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38b4:	00098700 	andeq	r8, r9, r0, lsl #14
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38b8:	00078200 	andeq	r8, r7, r0, lsl #4
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38bc:	51011900 	tstpl	r1, r0, lsl #18
    38c0:	19007602 	stmdbne	r0, {r1, r9, sl, ip, sp, lr}
    38c4:	91035001 	tstls	r3, r1
    38c8:	18007fa8 	stmdane	r0, {r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    38cc:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38d0:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38d4:	000007a4 	andeq	r0, r0, r4, lsr #15
    38d8:	02520119 	subseq	r0, r2, #1073741830	; 0x40000006
    38dc:	01194891 			; <UNDEFINED> instruction: 0x01194891
    38e0:	a8910351 	ldmge	r1, {r0, r4, r6, r8, r9}
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38e4:	5001197f 	andpl	r1, r1, pc, ror r9
    38e8:	7f889103 	svcvc	0x00889103
    38ec:	00001800 	andeq	r1, r0, r0, lsl #16
    38f0:	09870000 	stmibeq	r7, {}	; <UNPREDICTABLE>
    38f4:	07c70000 	strbeq	r0, [r7, r0]
    38f8:	01190000 	tsteq	r9, r0
    38fc:	88910352 	ldmhi	r1, {r1, r4, r6, r8, r9}
    3900:	5101197f 	tstpl	r1, pc, ror r9
    3904:	7ee89103 	urdvce	f1, f3
    3908:	03500119 	cmpeq	r0, #1073741830	; 0x40000006
    390c:	007fa891 			; <UNDEFINED> instruction: 0x007fa891
    3910:	00000018 	andeq	r0, r0, r8, lsl r0
    3914:	0009bd00 	andeq	fp, r9, r0, lsl #26
    3918:	0007e900 	andeq	lr, r7, r0, lsl #18
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    391c:	52011900 	andpl	r1, r1, #0, 18
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3920:	7fa89103 	svcvc	0x00a89103
    3924:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3928:	197fa891 	ldmdbne	pc!, {r0, r4, r7, fp, sp, pc}^	; <UNPREDICTABLE>
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    392c:	91025001 	tstls	r2, r1
    3930:	00180048 	andseq	r0, r8, r8, asr #32
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3934:	bd000000 	stclt	0, cr0, [r0, #-0]
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3938:	0b000009 	bleq	3964 <sha256_process+0x930>
    393c:	19000008 	stmdbne	r0, {r3}
    3940:	91025201 	tstls	r2, r1, lsl #4
    3944:	51011948 	tstpl	r1, r8, asr #18
    3948:	7e889103 	sinvce	f1, f3
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    394c:	03500119 	cmpeq	r0, #1073741830	; 0x40000006
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3950:	007ea891 			; <UNDEFINED> instruction: 0x007ea891
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3954:	00000018 	andeq	r0, r0, r8, lsl r0
    3958:	0009a200 	andeq	sl, r9, r0, lsl #4
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    395c:	00082e00 	andeq	r2, r8, r0, lsl #28
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3960:	52011900 	andpl	r1, r1, #0, 18
    3964:	7f889103 	svcvc	0x00889103
    3968:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    396c:	197ee891 	ldmdbne	lr!, {r0, r4, r7, fp, sp, lr, pc}^
    3970:	91035001 	tstls	r3, r1
    3974:	18007fa8 	stmdane	r0, {r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    3978:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    397c:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3980:	00000850 	andeq	r0, r0, r0, asr r8
    3984:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    3988:	197fa891 	ldmdbne	pc!, {r0, r4, r7, fp, sp, pc}^	; <UNPREDICTABLE>
    398c:	91035101 	tstls	r3, r1, lsl #2
    3990:	01197fa8 	tsteq	r9, r8, lsr #31
    3994:	48910250 	ldmmi	r1, {r4, r6, r9}
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3998:	00001a00 	andeq	r1, r0, r0, lsl #20
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    399c:	09bd0000 	ldmibeq	sp!, {}	; <UNPREDICTABLE>
    39a0:	01190000 	tsteq	r9, r0
    39a4:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    39a8:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    39ac:	197de891 	ldmdbne	sp!, {r0, r4, r7, fp, sp, lr, pc}^
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39b0:	91035001 	tstls	r3, r1
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39b4:	00007ec8 	andeq	r7, r0, r8, asr #29
    39b8:	00001800 	andeq	r1, r0, r0, lsl #16
    39bc:	09f30000 	ldmibeq	r3!, {}^	; <UNPREDICTABLE>
    39c0:	08980000 	ldmeq	r8, {}	; <UNPREDICTABLE>
    39c4:	01190000 	tsteq	r9, r0
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39c8:	00750253 	rsbseq	r0, r5, r3, asr r2
    39cc:	02520119 	subseq	r0, r2, #1073741830	; 0x40000006
    39d0:	0119007d 	tsteq	r9, sp, ror r0
    39d4:	e8910351 	ldm	r1, {r0, r4, r6, r8, r9}
    39d8:	5001197d 	andpl	r1, r1, sp, ror r9
    39dc:	7de89103 	stfvcp	f1, [r8, #12]!
    39e0:	00001800 	andeq	r1, r0, r0, lsl #16
    39e4:	09f30000 	ldmibeq	r3!, {}^	; <UNPREDICTABLE>
    39e8:	08c10000 	stmiaeq	r1, {}^	; <UNPREDICTABLE>
    39ec:	01190000 	tsteq	r9, r0
    39f0:	00750253 	rsbseq	r0, r5, r3, asr r2
    39f4:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    39f8:	197dc891 	ldmdbne	sp!, {r0, r4, r7, fp, lr, pc}^
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39fc:	91035101 	tstls	r3, r1, lsl #2
    3a00:	01197e88 	tsteq	r9, r8, lsl #29
    3a04:	88910350 	ldmhi	r1, {r4, r6, r8, r9}
    3a08:	0018007e 	andseq	r0, r8, lr, ror r0
    3a0c:	f3000000 	vhadd.u8	d0, d0, d0
    3a10:	e8000009 	stmda	r0, {r0, r3}
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a14:	19000008 	stmdbne	r0, {r3}
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a18:	75025301 	strvc	r5, [r2, #-769]	; 0x301
    3a1c:	52011900 	andpl	r1, r1, #0, 18
    3a20:	7ea89103 	tanvce	f1, f3
    3a24:	02510119 	subseq	r0, r1, #1073741830	; 0x40000006
    3a28:	0119007d 	tsteq	r9, sp, ror r0
    3a2c:	007d0250 	rsbseq	r0, sp, r0, asr r2
    3a30:	00001a00 	andeq	r1, r0, r0, lsl #20
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a34:	09f30000 	ldmibeq	r3!, {}^	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a38:	01190000 	tsteq	r9, r0
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a3c:	00750253 	rsbseq	r0, r5, r3, asr r2
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a40:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a44:	197ec891 	ldmdbne	lr!, {r0, r4, r7, fp, lr, pc}^
    3a48:	91035101 	tstls	r3, r1, lsl #2
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a4c:	01197dc8 	tsteq	r9, r8, asr #27
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a50:	c8910350 	ldmgt	r1, {r4, r6, r8, r9}
    3a54:	1800007d 	stmdane	r0, {r0, r2, r3, r4, r5, r6}
    3a58:	00000000 	andeq	r0, r0, r0
    3a5c:	00000a13 	andeq	r0, r0, r3, lsl sl
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a60:	0000092a 	andeq	r0, r0, sl, lsr #18
    3a64:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a68:	197dc891 	ldmdbne	sp!, {r0, r4, r7, fp, lr, pc}^
    3a6c:	91035001 	tstls	r3, r1
    3a70:	18007e88 	stmdane	r0, {r3, r7, r9, sl, fp, ip, sp, lr}
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a74:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a78:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    3a7c:	0000094b 	andeq	r0, r0, fp, asr #18
    3a80:	02520119 	subseq	r0, r2, #1073741830	; 0x40000006
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a84:	0119007d 	tsteq	r9, sp, ror r0
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a88:	88910351 	ldmhi	r1, {r0, r4, r6, r8, r9}
    3a8c:	5001197e 	andpl	r1, r1, lr, ror r9
    3a90:	00007802 	andeq	r7, r0, r2, lsl #16
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a94:	0000001a 	andeq	r0, r0, sl, lsl r0
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a98:	000a2900 	andeq	r2, sl, r0, lsl #18
    3a9c:	50011900 	andpl	r1, r1, r0, lsl #18
    3aa0:	00007802 	andeq	r7, r0, r2, lsl #16
    3aa4:	00730800 	rsbseq	r0, r3, r0, lsl #16
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3aa8:	971d0000 	ldrls	r0, [sp, -r0]
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3aac:	02000014 	andeq	r0, r0, #20
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ab0:	00096c1c 	andeq	r6, r9, ip, lsl ip
    3ab4:	01580800 	cmpeq	r8, r0, lsl #16
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ab8:	6c1e0000 	ldcvs	0, cr0, [lr], {-0}
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3abc:	01000014 	tsteq	r0, r4, lsl r0
    3ac0:	00098209 	andeq	r8, r9, r9, lsl #4
    3ac4:	00030500 	andeq	r0, r3, r0, lsl #10
    3ac8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    3acc:	00000158 	andeq	r0, r0, r8, asr r1
    3ad0:	00147a1f 	andseq	r7, r4, pc, lsl sl
    3ad4:	a23a0200 	eorsge	r0, sl, #0, 4
    3ad8:	20000009 	andcs	r0, r0, r9
    3adc:	000000c4 	andeq	r0, r0, r4, asr #1
    3ae0:	0000ca20 	andeq	ip, r0, r0, lsr #20
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ae4:	00ca2000 	sbceq	r2, sl, r0
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ae8:	1f000000 	svcne	0x00000000
    3aec:	00001552 	andeq	r1, r0, r2, asr r5
    3af0:	09bd3b02 	ldmibeq	sp!, {r1, r8, r9, fp, ip, sp}
    3af4:	c4200000 	strtgt	r0, [r0], #-0
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3af8:	20000000 	andcs	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3afc:	000000ca 	andeq	r0, r0, sl, asr #1
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b00:	0000ca20 	andeq	ip, r0, r0, lsr #20
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b04:	731f0000 	tstvc	pc, #0
    3b08:	02000015 	andeq	r0, r0, #21
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b0c:	0009d844 	andeq	sp, r9, r4, asr #16
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b10:	00c42000 	sbceq	r2, r4, r0
    3b14:	ca200000 	bgt	803b1c <_etext+0x7fc604>
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b18:	20000000 	andcs	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b1c:	000000ca 	andeq	r0, r0, sl, asr #1
    3b20:	14851f00 	strne	r1, [r5], #3840	; 0xf00
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b24:	4b020000 	blmi	83b2c <_etext+0x7c614>
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b28:	000009f3 	strdeq	r0, [r0], -r3
    3b2c:	0000c420 	andeq	ip, r0, r0, lsr #8
    3b30:	00ca2000 	sbceq	r2, sl, r0
    3b34:	8c200000 	stchi	0, cr0, [r0], #-0
    3b38:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b3c:	00159d1f 	andseq	r9, r5, pc, lsl sp
    3b40:	13330200 	teqne	r3, #0, 4
    3b44:	2000000a 	andcs	r0, r0, sl
    3b48:	000000c4 	andeq	r0, r0, r4, asr #1
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b4c:	0000ca20 	andeq	ip, r0, r0, lsr #20
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b50:	00ca2000 	sbceq	r2, sl, r0
    3b54:	81200000 	teqhi	r0, r0
    3b58:	00000000 	andeq	r0, r0, r0
    3b5c:	0015881f 	andseq	r8, r5, pc, lsl r8
    3b60:	29510200 	ldmdbcs	r1, {r9}^
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b64:	2000000a 	andcs	r0, r0, sl
    3b68:	000000c4 	andeq	r0, r0, r4, asr #1
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b6c:	0000ca20 	andeq	ip, r0, r0, lsr #20
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b70:	62210000 	eorvs	r0, r1, #0
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b74:	02000015 	andeq	r0, r0, #21
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b78:	00c42028 	sbceq	r2, r4, r8, lsr #32
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b7c:	00000000 	andeq	r0, r0, r0
    3b80:	00000eb2 			; <UNDEFINED> instruction: 0x00000eb2
    3b84:	0fb50004 	svceq	0x00b50004
    3b88:	01040000 	mrseq	r0, (UNDEF: 4)
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b8c:	000014b4 			; <UNDEFINED> instruction: 0x000014b4
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b90:	00161c01 	andseq	r1, r6, r1, lsl #24
    3b94:	00089300 	andeq	r9, r8, r0, lsl #6
    3b98:	0003b000 	andeq	fp, r3, r0
    3b9c:	00000000 	andeq	r0, r0, r0
    3ba0:	00120c00 	andseq	r0, r2, r0, lsl #24
    3ba4:	06010200 	streq	r0, [r1], -r0, lsl #4
    3ba8:	0000081a 	andeq	r0, r0, sl, lsl r8
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bac:	000b0103 	andeq	r0, fp, r3, lsl #2
    3bb0:	371c0400 	ldrcc	r0, [ip, -r0, lsl #8]
    3bb4:	02000000 	andeq	r0, r0, #0
    3bb8:	08180801 	ldmdaeq	r8, {r0, fp}
    3bbc:	02020000 	andeq	r0, r2, #0
    3bc0:	0006fc05 	andeq	pc, r6, r5, lsl #24
    3bc4:	07020200 	streq	r0, [r2, -r0, lsl #4]
    3bc8:	00000949 	andeq	r0, r0, r9, asr #18
    3bcc:	da050402 	ble	144bdc <_etext+0x13d6c4>
    3bd0:	03000004 	movweq	r0, #4
    3bd4:	00000ace 	andeq	r0, r0, lr, asr #21
    3bd8:	005e3804 	subseq	r3, lr, r4, lsl #16
    3bdc:	04020000 	streq	r0, [r2], #-0
    3be0:	00025207 	andeq	r5, r2, r7, lsl #4
    3be4:	05080200 	streq	r0, [r8, #-512]	; 0x200
    3be8:	000004d5 	ldrdeq	r0, [r0], -r5
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bec:	4d070802 	stcmi	8, cr0, [r7, #-8]
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bf0:	04000002 	streq	r0, [r0], #-2
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3bf4:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bf8:	04020074 	streq	r0, [r2], #-116	; 0x74
    3bfc:	00025707 	andeq	r5, r2, r7, lsl #14
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c00:	0b030300 	bleq	c4808 <_etext+0xbd2f0>
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c04:	2a050000 	bcs	143c0c <_etext+0x13c6f4>
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c08:	0000002c 	andeq	r0, r0, ip, lsr #32
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c0c:	000ad003 	andeq	sp, sl, r3
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c10:	53420500 	movtpl	r0, #9472	; 0x2500
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c14:	02000000 	andeq	r0, r0, #0
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c18:	078b0704 	streq	r0, [fp, r4, lsl #14]
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c1c:	04050000 	streq	r0, [r5], #-0
    3c20:	21080102 	tstcs	r8, r2, lsl #2
    3c24:	06000008 	streq	r0, [r0], -r8
    3c28:	0000168e 	andeq	r1, r0, lr, lsl #13
    3c2c:	dc200380 	stcle	3, cr0, [r0], #-512	; 0xfffffe00
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c30:	07000000 	streq	r0, [r0, -r0]
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c34:	21030078 	tstcs	r3, r8, ror r0
    3c38:	000000dc 	ldrdeq	r0, [r0], -ip
    3c3c:	00790700 	rsbseq	r0, r9, r0, lsl #14
    3c40:	00dc2203 	sbcseq	r2, ip, r3, lsl #4
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c44:	07200000 	streq	r0, [r0, -r0]!
    3c48:	23030074 	movwcs	r0, #12404	; 0x3074
    3c4c:	000000dc 	ldrdeq	r0, [r0], -ip
    3c50:	007a0740 	rsbseq	r0, sl, r0, asr #14
    3c54:	00dc2403 	sbcseq	r2, ip, r3, lsl #8
    3c58:	00600000 	rsbeq	r0, r0, r0
    3c5c:	00008108 	andeq	r8, r0, r8, lsl #2
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c60:	0000ec00 	andeq	lr, r0, r0, lsl #24
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c64:	00970900 	addseq	r0, r7, r0, lsl #18
    3c68:	001f0000 	andseq	r0, pc, r0
    3c6c:	0014600a 	andseq	r6, r4, sl
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c70:	03220200 	teqeq	r2, #0, 4
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c74:	0000010b 	andeq	r0, r0, fp, lsl #2
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c78:	0200780b 	andeq	r7, r0, #720896	; 0xb0000
    3c7c:	00010b22 	andeq	r0, r1, r2, lsr #22
    3c80:	00610b00 	rsbeq	r0, r1, r0, lsl #22
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c84:	01112202 	tsteq	r1, r2, lsl #4
    3c88:	0c000000 	stceq	0, cr0, [r0], {-0}
    3c8c:	00008104 	andeq	r8, r0, r4, lsl #2
    3c90:	17040c00 	strne	r0, [r4, -r0, lsl #24]
    3c94:	0d000001 	stceq	0, cr0, [r0, #-4]
    3c98:	00000081 	andeq	r0, r0, r1, lsl #1
    3c9c:	0016a60a 	andseq	sl, r6, sl, lsl #12
    3ca0:	03460300 	movteq	r0, #25344	; 0x6300
    3ca4:	0000013f 	andeq	r0, r0, pc, lsr r1
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3ca8:	7473640b 	ldrbtvc	r6, [r3], #-1035	; 0x40b
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cac:	3f460300 	svccc	0x00460300
    3cb0:	0b000001 	bleq	3cbc <sha256_process+0xc88>
    3cb4:	00637273 	rsbeq	r7, r3, r3, ror r2
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cb8:	01454703 	cmpeq	r5, r3, lsl #14
    3cbc:	0c000000 	stceq	0, cr0, [r0], {-0}
    3cc0:	0000a704 	andeq	sl, r0, r4, lsl #14
    3cc4:	4b040c00 	blmi	106ccc <_etext+0xff7b4>
    3cc8:	0d000001 	stceq	0, cr0, [r0, #-4]
    3ccc:	000000a7 	andeq	r0, r0, r7, lsr #1
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cd0:	00160c0e 	andseq	r0, r6, lr, lsl #24
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3cd4:	60320100 	eorsvs	r0, r2, r0, lsl #2
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cd8:	70000019 	andvc	r0, r0, r9, lsl r0
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3cdc:	01000000 	mrseq	r0, (UNDEF: 0)
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3ce0:	0002109c 	muleq	r2, ip, r0
    3ce4:	00700f00 	rsbseq	r0, r0, r0, lsl #30
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3ce8:	013f3201 	teqeq	pc, r1, lsl #4
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cec:	0d5d0000 	ldcleq	0, cr0, [sp, #-0]
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3cf0:	780f0000 	stmdavc	pc, {}	; <UNPREDICTABLE>
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cf4:	11330100 	teqne	r3, r0, lsl #2
    3cf8:	96000001 	strls	r0, [r0], -r1
    3cfc:	0f00000d 	svceq	0x0000000d
    3d00:	33010079 	movwcc	r0, #4217	; 0x1079
    3d04:	00000111 	andeq	r0, r0, r1, lsl r1
    3d08:	00000dcd 	andeq	r0, r0, sp, asr #27
    3d0c:	0000ec10 	andeq	lr, r0, r0, lsl ip
    3d10:	00196400 	andseq	r6, r9, r0, lsl #8
    3d14:	00002800 	andeq	r2, r0, r0, lsl #16
    3d18:	b2350100 	eorslt	r0, r5, #0, 2
    3d1c:	11000001 	tstne	r0, r1
    3d20:	00000101 	andeq	r0, r0, r1, lsl #2
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d24:	00000e04 	andeq	r0, r0, r4, lsl #28
    3d28:	0000f811 	andeq	pc, r0, r1, lsl r8	; <UNPREDICTABLE>
    3d2c:	000e3000 	andeq	r3, lr, r0
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d30:	ec120000 	ldc	0, cr0, [r2], {-0}
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d34:	8c000000 	stchi	0, cr0, [r0], {-0}
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d38:	48000019 	stmdami	r0, {r0, r3, r4}
    3d3c:	01000003 	tsteq	r0, r3
    3d40:	0001d436 	andeq	sp, r1, r6, lsr r4
    3d44:	01011300 	mrseq	r1, SP_irq
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d48:	f8110000 			; <UNDEFINED> instruction: 0xf8110000
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d4c:	69000000 	stmdbvs	r0, {}	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d50:	0000000e 	andeq	r0, r0, lr
    3d54:	0019c014 	andseq	ip, r9, r4, lsl r0
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d58:	000d9d00 	andeq	r9, sp, r0, lsl #26
    3d5c:	0001ee00 	andeq	lr, r1, r0, lsl #28
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d60:	51011500 	tstpl	r1, r0, lsl #10
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d64:	01153101 	tsteq	r5, r1, lsl #2
    3d68:	e0740350 	rsbs	r0, r4, r0, asr r3
    3d6c:	d0160000 	andsle	r0, r6, r0
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d70:	b3000019 	movwlt	r0, #25
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d74:	1500000d 	strne	r0, [r0, #-13]
    3d78:	f3035201 	vhsub.u8	d5, d3, d1
    3d7c:	01155201 	tsteq	r5, r1, lsl #4
    3d80:	01f30351 	mvnseq	r0, r1, asr r3
    3d84:	50011551 	andpl	r1, r1, r1, asr r5
    3d88:	5001f305 	andpl	pc, r1, r5, lsl #6
    3d8c:	00004023 	andeq	r4, r0, r3, lsr #32
    3d90:	0016460e 	andseq	r4, r6, lr, lsl #12
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d94:	d03b0100 	eorsle	r0, fp, r0, lsl #2
    3d98:	3a000019 	bcc	3e04 <sha256_process+0xdd0>
    3d9c:	01000000 	mrseq	r0, (UNDEF: 0)
    3da0:	0002d99c 	muleq	r2, ip, r9
    3da4:	00780f00 	rsbseq	r0, r8, r0, lsl #30
    3da8:	010b3b01 	tsteq	fp, r1, lsl #22
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3dac:	0ea80000 	cdpeq	0, 10, cr0, cr8, cr0, {0}
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3db0:	790f0000 	stmdbvc	pc, {}	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3db4:	0b3b0100 	bleq	ec41bc <_etext+0xebcca4>
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3db8:	c6000001 	strgt	r0, [r0], -r1
    3dbc:	0f00000e 	svceq	0x0000000e
    3dc0:	3c010070 	stccc	0, cr0, [r1], {112}	; 0x70
    3dc4:	00000145 	andeq	r0, r0, r5, asr #2
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3dc8:	00000ee4 	andeq	r0, r0, r4, ror #29
    3dcc:	00317a17 	eorseq	r7, r1, r7, lsl sl
    3dd0:	00dc3e01 	sbcseq	r3, ip, r1, lsl #28
    3dd4:	91020000 	mrsls	r0, (UNDEF: 2)
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3dd8:	19e41450 	stmibne	r4!, {r4, r6, sl, ip}^
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3ddc:	0dce0000 	stcleq	0, cr0, [lr]
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3de0:	02740000 	rsbseq	r0, r4, #0
    3de4:	01150000 	tsteq	r5, r0
    3de8:	e0740351 	rsbs	r0, r4, r1, asr r3
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3dec:	50011500 	andpl	r1, r1, r0, lsl #10
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3df0:	00007d02 	andeq	r7, r0, r2, lsl #26
    3df4:	0019ee14 	andseq	lr, r9, r4, lsl lr
    3df8:	000db300 	andeq	fp, sp, r0, lsl #6
    3dfc:	00029400 	andeq	r9, r2, r0, lsl #8
    3e00:	52011500 	andpl	r1, r1, #0, 10
    3e04:	15007d02 	strne	r7, [r0, #-3330]	; 0xd02
    3e08:	74025101 	strvc	r5, [r2], #-257	; 0x101
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e0c:	50011500 	andpl	r1, r1, r0, lsl #10
    3e10:	00007602 	andeq	r7, r0, r2, lsl #12
    3e14:	0019fa14 	andseq	pc, r9, r4, lsl sl	; <UNPREDICTABLE>
    3e18:	000db300 	andeq	fp, sp, r0, lsl #6
    3e1c:	0002b400 	andeq	fp, r2, r0, lsl #8
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e20:	52011500 	andpl	r1, r1, #0, 10
    3e24:	15007d02 	strne	r7, [r0, #-3330]	; 0xd02
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e28:	74025101 	strvc	r5, [r2], #-257	; 0x101
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e2c:	50011520 	andpl	r1, r1, r0, lsr #10
    3e30:	00007502 	andeq	r7, r0, r2, lsl #10
    3e34:	001a0014 	andseq	r0, sl, r4, lsl r0
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e38:	000de400 	andeq	lr, sp, r0, lsl #8
    3e3c:	0002c800 	andeq	ip, r2, r0, lsl #16
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e40:	50011500 	andpl	r1, r1, r0, lsl #10
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e44:	00007602 	andeq	r7, r0, r2, lsl #12
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e48:	001a0618 	andseq	r0, sl, r8, lsl r6
    3e4c:	000de400 	andeq	lr, sp, r0, lsl #8
    3e50:	50011500 	andpl	r1, r1, r0, lsl #10
    3e54:	00007502 	andeq	r7, r0, r2, lsl #10
    3e58:	15d90e00 	ldrbne	r0, [r9, #3584]	; 0xe00
    3e5c:	5e010000 	cdppl	0, 0, cr0, cr1, cr0, {0}
    3e60:	00001a0c 	andeq	r1, r0, ip, lsl #20
    3e64:	0000005e 	andeq	r0, r0, lr, asr r0
    3e68:	039f9c01 	orrseq	r9, pc, #256	; 0x100
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e6c:	630f0000 	movwvs	r0, #61440	; 0xf000
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e70:	0b5e0100 	bleq	1784278 <_etext+0x177cd60>
    3e74:	02000001 	andeq	r0, r0, #1
    3e78:	0f00000f 	svceq	0x0000000f
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e7c:	5e010078 	mcrpl	0, 0, r0, cr1, cr8, {3}
    3e80:	00000111 	andeq	r0, r0, r1, lsl r1
    3e84:	00000f20 	andeq	r0, r0, r0, lsr #30
    3e88:	0100790f 	tsteq	r0, pc, lsl #18
    3e8c:	0001115e 	andeq	r1, r1, lr, asr r1
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e90:	000f3e00 	andeq	r3, pc, r0, lsl #28
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e94:	6d741700 	ldclvs	7, cr1, [r4, #-0]
    3e98:	60010070 	andvs	r0, r1, r0, ror r0
    3e9c:	000000dc 	ldrdeq	r0, [r0], -ip
    3ea0:	19489102 	stmdbne	r8, {r1, r8, ip, pc}^
    3ea4:	000015e6 	andeq	r1, r0, r6, ror #11
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3ea8:	00816101 	addeq	r6, r1, r1, lsl #2
    3eac:	0f5c0000 	svceq	0x005c0000
    3eb0:	ec100000 	ldc	0, cr0, [r0], {-0}
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3eb4:	16000000 	strne	r0, [r0], -r0
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3eb8:	1600001a 			; <UNDEFINED> instruction: 0x1600001a
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ebc:	01000000 	mrseq	r0, (UNDEF: 0)
    3ec0:	00035863 	andeq	r5, r3, r3, ror #16
    3ec4:	01011100 	mrseq	r1, (UNDEF: 17)
    3ec8:	0f6f0000 	svceq	0x006f0000
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3ecc:	f8110000 			; <UNDEFINED> instruction: 0xf8110000
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ed0:	8d000000 	stchi	0, cr0, [r0, #-0]
    3ed4:	0000000f 	andeq	r0, r0, pc
    3ed8:	0000ec10 	andeq	lr, r0, r0, lsl ip
    3edc:	001a3200 	andseq	r3, sl, r0, lsl #4
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3ee0:	00002000 	andeq	r2, r0, r0
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ee4:	7a670100 	bvc	19c42ec <_etext+0x19bcdd4>
    3ee8:	1a000003 	bne	3efc <sha256_process+0xec8>
    3eec:	00000101 	andeq	r0, r0, r1, lsl #2
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3ef0:	f81a5601 			; <UNDEFINED> instruction: 0xf81a5601
    3ef4:	01000000 	mrseq	r0, (UNDEF: 0)
    3ef8:	32140055 	andscc	r0, r4, #85	; 0x55
    3efc:	e400001a 	str	r0, [r0], #-26
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f00:	8e00000d 	cdphi	0, 0, cr0, cr0, cr13, {0}
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f04:	15000003 	strne	r0, [r0, #-3]
    3f08:	7d025001 	stcvc	0, cr5, [r2, #-4]
    3f0c:	5c180000 	ldcpl	0, cr0, [r8], {-0}
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f10:	e400001a 	str	r0, [r0], #-26
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f14:	1500000d 	strne	r0, [r0, #-13]
    3f18:	75025001 	strvc	r5, [r2, #-1]
    3f1c:	1b000000 	blne	3f24 <sha256_process+0xef0>
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f20:	000015f9 	strdeq	r1, [r0], -r9
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f24:	00816c01 	addeq	r6, r1, r1, lsl #24
    3f28:	1a6c0000 	bne	1b03f30 <_etext+0x1afca18>
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f2c:	00c80000 	sbceq	r0, r8, r0
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f30:	9c010000 	stcls	0, cr0, [r1], {-0}
    3f34:	000005b4 			; <UNDEFINED> instruction: 0x000005b4
    3f38:	0100780f 	tsteq	r0, pc, lsl #16
    3f3c:	00010b6c 	andeq	r0, r1, ip, ror #22
    3f40:	000fad00 	andeq	sl, pc, r0, lsl #26
    3f44:	00790f00 	rsbseq	r0, r9, r0, lsl #30
    3f48:	010b6c01 	tsteq	fp, r1, lsl #24
    3f4c:	0fd90000 	svceq	0x00d90000
    3f50:	bd1c0000 	ldclt	0, cr0, [ip, #-0]
    3f54:	01000015 	tsteq	r0, r5, lsl r0
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f58:	0001116c 	andeq	r1, r1, ip, ror #2
    3f5c:	000ffa00 	andeq	pc, pc, r0, lsl #20
    3f60:	15e61900 	strbne	r1, [r6, #2304]!	; 0x900
    3f64:	6e010000 	cdpvs	0, 0, cr0, cr1, cr0, {0}
    3f68:	000005b4 			; <UNDEFINED> instruction: 0x000005b4
    3f6c:	0000101b 	andeq	r1, r0, fp, lsl r0
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f70:	01006117 	tsteq	r0, r7, lsl r1
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3f74:	0000dc6f 	andeq	sp, r0, pc, ror #24
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f78:	88910300 	ldmhi	r1, {r8, r9}
    3f7c:	0062177f 	rsbeq	r1, r2, pc, ror r7
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3f80:	00dc7001 	sbcseq	r7, ip, r1
    3f84:	91030000 	mrsls	r0, (UNDEF: 3)
    3f88:	63177fa8 	tstvs	r7, #168, 30	; 0x2a0
    3f8c:	dc710100 	ldflee	f0, [r1], #-0
    3f90:	02000000 	andeq	r0, r0, #0
    3f94:	ec124891 	ldc	8, cr4, [r2], {145}	; 0x91
    3f98:	70000000 	andvc	r0, r0, r0
    3f9c:	7000001a 	andvc	r0, r0, sl, lsl r0
    3fa0:	01000003 	tsteq	r0, r3
    3fa4:	00043c74 	andeq	r3, r4, r4, ror ip
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fa8:	01011100 	mrseq	r1, (UNDEF: 17)
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3fac:	10350000 	eorsne	r0, r5, r0
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fb0:	f8110000 			; <UNDEFINED> instruction: 0xf8110000
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3fb4:	56000000 	strpl	r0, [r0], -r0
    3fb8:	00000010 	andeq	r0, r0, r0, lsl r0
    3fbc:	001ab214 	andseq	fp, sl, r4, lsl r2
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fc0:	000db300 	andeq	fp, sp, r0, lsl #6
    3fc4:	00045e00 	andeq	r5, r4, r0, lsl #28
    3fc8:	52011500 	andpl	r1, r1, #0, 10
    3fcc:	5101f303 	tstpl	r1, r3, lsl #6
    3fd0:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    3fd4:	155101f3 	ldrbne	r0, [r1, #-499]	; 0x1f3
    3fd8:	91025001 	tstls	r2, r1
    3fdc:	bc140048 	ldclt	0, cr0, [r4], {72}	; 0x48
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3fe0:	b300001a 	movwlt	r0, #26
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fe4:	8200000d 	andhi	r0, r0, #13
    3fe8:	15000004 	strne	r0, [r0, #-4]
    3fec:	03055201 	movweq	r5, #20993	; 0x5201
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3ff0:	000071a4 	andeq	r7, r0, r4, lsr #3
    3ff4:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    3ff8:	01154891 			; <UNDEFINED> instruction: 0x01154891
    3ffc:	a8910350 	ldmge	r1, {r4, r6, r8, r9}
    4000:	c614007f 			; <UNDEFINED> instruction: 0xc614007f
    4004:	f500001a 			; <UNDEFINED> instruction: 0xf500001a
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4008:	a300000d 	movwge	r0, #13
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    400c:	15000004 	strne	r0, [r0, #-4]
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4010:	75025201 	strvc	r5, [r2, #-513]	; 0x201
    4014:	51011500 	tstpl	r1, r0, lsl #10
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4018:	7fa89103 	svcvc	0x00a89103
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    401c:	02500115 	subseq	r0, r0, #1073741829	; 0x40000005
    4020:	1400007d 	strne	r0, [r0], #-125	; 0x7d
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4024:	00001ace 	andeq	r1, r0, lr, asr #21
    4028:	00000dce 	andeq	r0, r0, lr, asr #27
    402c:	000004be 			; <UNDEFINED> instruction: 0x000004be
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4030:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    4034:	0115007d 	tsteq	r5, sp, ror r0
    4038:	a8910350 	ldmge	r1, {r4, r6, r8, r9}
    403c:	d814007f 	ldmdale	r4, {r0, r1, r2, r3, r4, r5, r6}
    4040:	1000001a 	andne	r0, r0, sl, lsl r0
    4044:	de00000e 	cdple	0, 0, cr0, cr0, cr14, {0}
    4048:	15000004 	strne	r0, [r0, #-4]
    404c:	75025201 	strvc	r5, [r2, #-513]	; 0x201
    4050:	51011500 	tstpl	r1, r0, lsl #10
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4054:	15489102 	strbne	r9, [r8, #-258]	; 0x102
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4058:	7d025001 	stcvc	0, cr5, [r2, #-4]
    405c:	e2140000 	ands	r0, r4, #0
    4060:	b300001a 	movwlt	r0, #26
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4064:	ff00000d 			; <UNDEFINED> instruction: 0xff00000d
    4068:	15000004 	strne	r0, [r0, #-4]
    406c:	91035201 	tstls	r3, r1, lsl #4
    4070:	01157fa8 	tsteq	r5, r8, lsr #31
    4074:	007d0251 	rsbseq	r0, sp, r1, asr r2
    4078:	02500115 	subseq	r0, r0, #1073741829	; 0x40000005
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    407c:	14004891 	strne	r4, [r0], #-2193	; 0x891
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4080:	00001aea 	andeq	r1, r0, sl, ror #21
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4084:	00000e2b 	andeq	r0, r0, fp, lsr #28
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4088:	00000519 	andeq	r0, r0, r9, lsl r5
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    408c:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4090:	01154891 			; <UNDEFINED> instruction: 0x01154891
    4094:	007d0250 	rsbseq	r0, sp, r0, asr r2
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4098:	1af21400 	bne	ffc890a0 <BootRAM+0xebf9841>
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    409c:	0e410000 	cdpeq	0, 4, cr0, cr1, cr0, {0}
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40a0:	05340000 	ldreq	r0, [r4, #-0]!
    40a4:	01150000 	tsteq	r5, r0
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40a8:	007d0251 	rsbseq	r0, sp, r1, asr r2
    40ac:	03500115 	cmpeq	r0, #1073741829	; 0x40000005
    40b0:	007fa891 			; <UNDEFINED> instruction: 0x007fa891
    40b4:	001b0814 	andseq	r0, fp, r4, lsl r8
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40b8:	000e5700 	andeq	r5, lr, r0, lsl #14
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40bc:	00055500 	andeq	r5, r5, r0, lsl #10
    40c0:	52011500 	andpl	r1, r1, #0, 10
    40c4:	7fa89103 	svcvc	0x00a89103
    40c8:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40cc:	0115007d 	tsteq	r5, sp, ror r0
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40d0:	00740250 	rsbseq	r0, r4, r0, asr r2
    40d4:	1b121400 	blne	4890dc <_etext+0x481bc4>
    40d8:	0db30000 	ldceq	0, cr0, [r3]
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40dc:	05750000 	ldrbeq	r0, [r5, #-0]!
    40e0:	01150000 	tsteq	r5, r0
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40e4:	00740252 	rsbseq	r0, r4, r2, asr r2
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40e8:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    40ec:	01150074 	tsteq	r5, r4, ror r0
    40f0:	007d0250 	rsbseq	r0, sp, r0, asr r2
    40f4:	1b181400 	blne	6090fc <_etext+0x601be4>
    40f8:	0de40000 	stcleq	0, cr0, [r4]
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    40fc:	05890000 	streq	r0, [r9]
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4100:	01150000 	tsteq	r5, r0
    4104:	007d0250 	rsbseq	r0, sp, r0, asr r2
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4108:	1b1e1400 	blne	789110 <_etext+0x781bf8>
    410c:	0de40000 	stcleq	0, cr0, [r4]
    4110:	059d0000 	ldreq	r0, [sp]
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4114:	01150000 	tsteq	r5, r0
    4118:	48910250 	ldmmi	r1, {r4, r6, r9}
    411c:	1b261800 	blne	98a124 <_etext+0x982c0c>
    4120:	0e770000 	cdpeq	0, 7, cr0, cr7, cr0, {0}
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4124:	01150000 	tsteq	r5, r0
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4128:	48910251 	ldmmi	r1, {r0, r4, r6, r9}
    412c:	02500115 	subseq	r0, r0, #1073741829	; 0x40000005
    4130:	0000007d 	andeq	r0, r0, sp, ror r0
    4134:	0000730d 	andeq	r7, r0, sp, lsl #6
    4138:	15ed0e00 	strbne	r0, [sp, #3584]!	; 0xe00
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    413c:	9c010000 	stcls	0, cr0, [r1], {-0}
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4140:	00001b34 	andeq	r1, r0, r4, lsr fp
    4144:	000000e0 	andeq	r0, r0, r0, ror #1
    4148:	08c39c01 	stmiaeq	r3, {r0, sl, fp, ip, pc}^
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    414c:	720f0000 	andvc	r0, pc, #0
    4150:	3f9c0100 	svccc	0x009c0100
    4154:	77000001 	strvc	r0, [r0, -r1]
    4158:	0f000010 	svceq	0x00000010
    415c:	01003170 	tsteq	r0, r0, ror r1
    4160:	0001459d 	muleq	r1, sp, r5
    4164:	0010a300 	andseq	sl, r0, r0, lsl #6
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4168:	32700f00 	rsbscc	r0, r0, #0, 30
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    416c:	459d0100 	ldrmi	r0, [sp, #256]	; 0x100
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4170:	cf000001 	svcgt	0x00000001
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4174:	17000010 	smladne	r0, r0, r0, r0
    4178:	b3010061 	movwlt	r0, #4193	; 0x1061
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    417c:	000000dc 	ldrdeq	r0, [r0], -ip
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4180:	7de89103 	stfvcp	f1, [r8, #12]!
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4184:	01006217 	tsteq	r0, r7, lsl r2
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4188:	0000dcb4 			; <UNDEFINED> instruction: 0x0000dcb4
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    418c:	88910300 	ldmhi	r1, {r8, r9}
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4190:	0063177e 	rsbeq	r1, r3, lr, ror r7
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4194:	00dcb501 	sbcseq	fp, ip, r1, lsl #10
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4198:	91030000 	mrsls	r0, (UNDEF: 3)
    419c:	64177ea8 	ldrvs	r7, [r7], #-3752	; 0xea8
    41a0:	dcb60100 	ldfles	f0, [r6]
    41a4:	03000000 	movweq	r0, #0
    41a8:	177ec891 			; <UNDEFINED> instruction: 0x177ec891
    41ac:	b7010065 	strlt	r0, [r1, -r5, rrx]
    41b0:	000000dc 	ldrdeq	r0, [r0], -ip
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41b4:	7ee89103 	urdvce	f1, f3
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41b8:	01006617 	tsteq	r0, r7, lsl r6
    41bc:	0000dcb8 			; <UNDEFINED> instruction: 0x0000dcb8
    41c0:	88910300 	ldmhi	r1, {r8, r9}
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41c4:	0067177f 	rsbeq	r1, r7, pc, ror r7
    41c8:	00dcb901 	sbcseq	fp, ip, r1, lsl #18
    41cc:	91030000 	mrsls	r0, (UNDEF: 3)
    41d0:	68177fa8 	ldmdavs	r7, {r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    41d4:	dcba0100 	ldfles	f0, [sl]
    41d8:	02000000 	andeq	r0, r0, #0
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    41dc:	52144891 	andspl	r4, r4, #9502720	; 0x910000
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41e0:	1000001b 	andne	r0, r0, fp, lsl r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41e4:	7f00000e 	svcvc	0x0000000e
    41e8:	15000006 	strne	r0, [r0, #-6]
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    41ec:	75025201 	strvc	r5, [r2, #-513]	; 0x201
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41f0:	51011500 	tstpl	r1, r0, lsl #10
    41f4:	15007802 	strne	r7, [r0, #-2050]	; 0x802
    41f8:	91035001 	tstls	r3, r1
    41fc:	14007ea8 	strne	r7, [r0], #-3752	; 0xea8
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4200:	00001b5c 	andeq	r1, r0, ip, asr fp
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4204:	00000e10 	andeq	r0, r0, r0, lsl lr
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4208:	000006a0 	andeq	r0, r0, r0, lsr #13
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    420c:	02520115 	subseq	r0, r2, #1073741829	; 0x40000005
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4210:	01150074 	tsteq	r5, r4, ror r0
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4214:	00770251 	rsbseq	r0, r7, r1, asr r2
    4218:	03500115 	cmpeq	r0, #1073741829	; 0x40000005
    421c:	007ec891 			; <UNDEFINED> instruction: 0x007ec891
    4220:	001b6614 	andseq	r6, fp, r4, lsl r6
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4224:	000db300 	andeq	fp, sp, r0, lsl #6
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4228:	0006c200 	andeq	ip, r6, r0, lsl #4
    422c:	52011500 	andpl	r1, r1, #0, 10
    4230:	7ec89103 	acsvce	f1, f3
    4234:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    4238:	157ea891 	ldrbne	sl, [lr, #-2193]!	; 0x891
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    423c:	7d025001 	stcvc	0, cr5, [r2, #-4]
    4240:	70140000 	andsvc	r0, r4, r0
    4244:	f500001b 			; <UNDEFINED> instruction: 0xf500001b
    4248:	e300000d 	movw	r0, #13
    424c:	15000006 	strne	r0, [r0, #-6]
    4250:	75025201 	strvc	r5, [r2, #-513]	; 0x201
    4254:	51011500 	tstpl	r1, r0, lsl #10
    4258:	15007802 	strne	r7, [r0, #-2050]	; 0x802
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    425c:	91035001 	tstls	r3, r1
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4260:	14007ea8 	strne	r7, [r0], #-3752	; 0xea8
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4264:	00001b7a 	andeq	r1, r0, sl, ror fp
    4268:	00000df5 	strdeq	r0, [r0], -r5
    426c:	00000704 	andeq	r0, r0, r4, lsl #14
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4270:	02520115 	subseq	r0, r2, #1073741829	; 0x40000005
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4274:	01150074 	tsteq	r5, r4, ror r0
    4278:	00770251 	rsbseq	r0, r7, r1, asr r2
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    427c:	03500115 	cmpeq	r0, #1073741829	; 0x40000005
    4280:	007ec891 			; <UNDEFINED> instruction: 0x007ec891
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4284:	001b8414 	andseq	r8, fp, r4, lsl r4
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4288:	000db300 	andeq	fp, sp, r0, lsl #6
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    428c:	00072700 	andeq	r2, r7, r0, lsl #14
    4290:	52011500 	andpl	r1, r1, #0, 10
    4294:	7ec89103 	acsvce	f1, f3
    4298:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    429c:	157ea891 	ldrbne	sl, [lr, #-2193]!	; 0x891
    42a0:	91035001 	tstls	r3, r1
    42a4:	14007e88 	strne	r7, [r0], #-3720	; 0xe88
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42a8:	00001b92 	muleq	r0, r2, fp
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42ac:	00000db3 			; <UNDEFINED> instruction: 0x00000db3
    42b0:	0000074a 	andeq	r0, r0, sl, asr #14
    42b4:	03520115 	cmpeq	r2, #1073741829	; 0x40000005
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42b8:	1500c074 	strne	ip, [r0, #-116]	; 0x74
    42bc:	75035101 	strvc	r5, [r3, #-257]	; 0x101
    42c0:	011500c0 	tsteq	r5, r0, asr #1
    42c4:	c8910350 	ldmgt	r1, {r4, r6, r8, r9}
    42c8:	9c14007e 	ldcls	0, cr0, [r4], {126}	; 0x7e
    42cc:	b300001b 	movwlt	r0, #27
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    42d0:	6f00000d 	svcvs	0x0000000d
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42d4:	15000007 	strne	r0, [r0, #-7]
    42d8:	03055201 	movweq	r5, #20993	; 0x5201
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42dc:	00007084 	andeq	r7, r0, r4, lsl #1
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42e0:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    42e4:	157ec891 	ldrbne	ip, [lr, #-2193]!	; 0x891
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    42e8:	91035001 	tstls	r3, r1
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42ec:	14007ea8 	strne	r7, [r0], #-3752	; 0xea8
    42f0:	00001baa 	andeq	r1, r0, sl, lsr #23
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    42f4:	00000db3 			; <UNDEFINED> instruction: 0x00000db3
    42f8:	00000792 	muleq	r0, r2, r7
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42fc:	03520115 	cmpeq	r2, #1073741829	; 0x40000005
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4300:	1500e074 	strne	lr, [r0, #-116]	; 0x74
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4304:	75035101 	strvc	r5, [r3, #-257]	; 0x101
    4308:	011500e0 	tsteq	r5, r0, ror #1
    430c:	c8910350 	ldmgt	r1, {r4, r6, r8, r9}
    4310:	b414007e 	ldrlt	r0, [r4], #-126	; 0x7e
    4314:	f500001b 			; <UNDEFINED> instruction: 0xf500001b
    4318:	b500000d 	strlt	r0, [r0, #-13]
    431c:	15000007 	strne	r0, [r0, #-7]
    4320:	91035201 	tstls	r3, r1, lsl #4
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4324:	01157ec8 	tsteq	r5, r8, asr #29
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4328:	c8910351 	ldmgt	r1, {r0, r4, r6, r8, r9}
    432c:	5001157e 	andpl	r1, r1, lr, ror r5
    4330:	7ec89103 	acsvce	f1, f3
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4334:	1bbe1400 	blne	fef8933c <BootRAM+0xdef9add>
    4338:	0e100000 	cdpeq	0, 1, cr0, cr0, cr0, {0}
    433c:	07d70000 	ldrbeq	r0, [r7, r0]
    4340:	01150000 	tsteq	r5, r0
    4344:	007d0252 	rsbseq	r0, sp, r2, asr r2
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4348:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    434c:	157e8891 	ldrbne	r8, [lr, #-2193]!	; 0x891
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4350:	91035001 	tstls	r3, r1
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4354:	14007ee8 	strne	r7, [r0], #-3816	; 0xee8
    4358:	00001bc8 	andeq	r1, r0, r8, asr #23
    435c:	00000e10 	andeq	r0, r0, r0, lsl lr
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4360:	000007fa 	strdeq	r0, [r0], -sl
    4364:	03520115 	cmpeq	r2, #1073741829	; 0x40000005
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4368:	157ea891 	ldrbne	sl, [lr, #-2193]!	; 0x891
    436c:	91035101 	tstls	r3, r1, lsl #2
    4370:	01157ec8 	tsteq	r5, r8, asr #29
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4374:	88910350 	ldmhi	r1, {r4, r6, r8, r9}
    4378:	d214007f 	andsle	r0, r4, #127	; 0x7f
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    437c:	f500001b 			; <UNDEFINED> instruction: 0xf500001b
    4380:	1d00000d 	stcne	0, cr0, [r0, #-52]	; 0xffffffcc
    4384:	15000008 	strne	r0, [r0, #-8]
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4388:	91035201 	tstls	r3, r1, lsl #4
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    438c:	01157ea8 	tsteq	r5, r8, lsr #29
    4390:	c8910351 	ldmgt	r1, {r0, r4, r6, r8, r9}
    4394:	5001157e 	andpl	r1, r1, lr, ror r5
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4398:	7fa89103 	svcvc	0x00a89103
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    439c:	1bdc1400 	blne	ff7093a4 <BootRAM+0xe679b45>
    43a0:	0df50000 	ldcleq	0, cr0, [r5]
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43a4:	083e0000 	ldmdaeq	lr!, {}	; <UNPREDICTABLE>
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43a8:	01150000 	tsteq	r5, r0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43ac:	007d0252 	rsbseq	r0, sp, r2, asr r2
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43b0:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43b4:	157e8891 	ldrbne	r8, [lr, #-2193]!	; 0x891
    43b8:	91025001 	tstls	r2, r1
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43bc:	e6140048 	ldr	r0, [r4], -r8, asr #32
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43c0:	b300001b 	movwlt	r0, #27
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    43c4:	6000000d 	andvs	r0, r0, sp
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43c8:	15000008 	strne	r0, [r0, #-8]
    43cc:	91035201 	tstls	r3, r1, lsl #4
    43d0:	01157f88 	tsteq	r5, r8, lsl #31
    43d4:	e8910351 	ldm	r1, {r0, r4, r6, r8, r9}
    43d8:	5001157e 	andpl	r1, r1, lr, ror r5
    43dc:	00007602 	andeq	r7, r0, r2, lsl #12
    43e0:	001bf214 	andseq	pc, fp, r4, lsl r2	; <UNPREDICTABLE>
    43e4:	000db300 	andeq	fp, sp, r0, lsl #6
    43e8:	00088100 	andeq	r8, r8, r0, lsl #2
    43ec:	52011500 	andpl	r1, r1, #0, 10
    43f0:	15489102 	strbne	r9, [r8, #-258]	; 0x102
    43f4:	91035101 	tstls	r3, r1, lsl #2
    43f8:	01157fa8 	tsteq	r5, r8, lsr #31
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    43fc:	20760250 	rsbscs	r0, r6, r0, asr r2
    4400:	1bfe1400 	blne	fff89408 <BootRAM+0xeef9ba9>
    4404:	0db30000 	ldceq	0, cr0, [r3]
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4408:	08a30000 	stmiaeq	r3!, {}	; <UNPREDICTABLE>
    440c:	01150000 	tsteq	r5, r0
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4410:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4414:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    4418:	157ee891 	ldrbne	lr, [lr, #-2193]!	; 0x891
    441c:	76035001 	strvc	r5, [r3], -r1
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4420:	180000c0 	stmdane	r0, {r6, r7}
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4424:	00001c0a 	andeq	r1, r0, sl, lsl #24
    4428:	00000db3 			; <UNDEFINED> instruction: 0x00000db3
    442c:	03520115 	cmpeq	r2, #1073741829	; 0x40000005
    4430:	157fa891 	ldrbne	sl, [pc, #-2193]!	; 3ba7 <sha256_process+0xb73>
    4434:	91035101 	tstls	r3, r1, lsl #2
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4438:	01157f88 	tsteq	r5, r8, lsl #31
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    443c:	e0760350 	rsbs	r0, r6, r0, asr r3
    4440:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    4444:	0000167f 	andeq	r1, r0, pc, ror r6
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4448:	1c14e701 	ldcne	7, cr14, [r4], {1}
    444c:	00b40000 	adcseq	r0, r4, r0
    4450:	9c010000 	stcls	0, cr0, [r1], {-0}
    4454:	00000b62 	andeq	r0, r0, r2, ror #22
    4458:	0100720f 	tsteq	r0, pc, lsl #4
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    445c:	00013fe7 	andeq	r3, r1, r7, ror #31
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4460:	0010fb00 	andseq	pc, r0, r0, lsl #22
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4464:	00700f00 	rsbseq	r0, r0, r0, lsl #30
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4468:	0145e701 	cmpeq	r5, r1, lsl #14
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    446c:	11190000 	tstne	r9, r0
    4470:	61170000 	tstvs	r7, r0
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4474:	dcfa0100 	ldflee	f0, [sl]
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4478:	03000000 	movweq	r0, #0
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    447c:	177e9091 			; <UNDEFINED> instruction: 0x177e9091
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4480:	fb010062 	blx	44612 <_etext+0x3d0fa>
    4484:	000000dc 	ldrdeq	r0, [r0], -ip
    4488:	7eb09103 	asnvcs	f1, f3
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    448c:	01006317 	tsteq	r0, r7, lsl r3
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4490:	0000dcfc 	strdeq	sp, [r0], -ip
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4494:	d0910300 	addsle	r0, r1, r0, lsl #6
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4498:	0065177e 	rsbeq	r1, r5, lr, ror r7
    449c:	00dcfd01 	sbcseq	pc, ip, r1, lsl #26
    44a0:	91030000 	mrsls	r0, (UNDEF: 3)
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44a4:	66177ef0 			; <UNDEFINED> instruction: 0x66177ef0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44a8:	dcfe0100 	ldflee	f0, [lr]
    44ac:	03000000 	movweq	r0, #0
    44b0:	177f9091 			; <UNDEFINED> instruction: 0x177f9091
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44b4:	ff010067 			; <UNDEFINED> instruction: 0xff010067
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44b8:	000000dc 	ldrdeq	r0, [r0], -ip
    44bc:	7fb09103 	svcvc	0x00b09103
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44c0:	0100681d 	tsteq	r0, sp, lsl r8
    44c4:	00dc0100 	sbcseq	r0, ip, r0, lsl #2
    44c8:	91020000 	mrsls	r0, (UNDEF: 2)
    44cc:	1c281450 	cfstrsne	mvf1, [r8], #-320	; 0xfffffec0
    44d0:	0db30000 	ldceq	0, cr0, [r3]
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44d4:	096d0000 	stmdbeq	sp!, {}^	; <UNPREDICTABLE>
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44d8:	01150000 	tsteq	r5, r0
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    44dc:	00750252 	rsbseq	r0, r5, r2, asr r2
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44e0:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    44e4:	01150075 	tsteq	r5, r5, ror r0
    44e8:	007d0250 	rsbseq	r0, sp, r0, asr r2
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    44ec:	1c321400 	cfldrsne	mvf1, [r2], #-0
    44f0:	0db30000 	ldceq	0, cr0, [r3]
    44f4:	098e0000 	stmibeq	lr, {}	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44f8:	01150000 	tsteq	r5, r0
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    44fc:	00760252 	rsbseq	r0, r6, r2, asr r2
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4500:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    4504:	01150076 	tsteq	r5, r6, ror r0
    4508:	b0910350 	addslt	r0, r1, r0, asr r3
    450c:	3e14007e 	mrccc	0, 0, r0, cr4, cr14, {3}
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4510:	b300001c 	movwlt	r0, #28
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4514:	b100000d 	tstlt	r0, sp
    4518:	15000009 	strne	r0, [r0, #-9]
    451c:	75035201 	strvc	r5, [r3, #-513]	; 0x201
    4520:	011500e0 	tsteq	r5, r0, ror #1
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4524:	e0750351 	rsbs	r0, r5, r1, asr r3
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4528:	50011500 	andpl	r1, r1, r0, lsl #10
    452c:	7ed09103 	atnvcs	f1, f3
    4530:	1c481400 	cfstrdne	mvd1, [r8], {-0}
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4534:	0df50000 	ldcleq	0, cr0, [r5]
    4538:	09d40000 	ldmibeq	r4, {}^	; <UNPREDICTABLE>
    453c:	01150000 	tsteq	r5, r0
    4540:	d0910352 	addsle	r0, r1, r2, asr r3
    4544:	5101157e 	tstpl	r1, lr, ror r5
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4548:	7ed09103 	atnvcs	f1, f3
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    454c:	03500115 	cmpeq	r0, #1073741829	; 0x40000005
    4550:	007ed091 			; <UNDEFINED> instruction: 0x007ed091
    4554:	001c5214 	andseq	r5, ip, r4, lsl r2
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4558:	000df500 	andeq	pc, sp, r0, lsl #10
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    455c:	0009f500 	andeq	pc, r9, r0, lsl #10
    4560:	52011500 	andpl	r1, r1, #0, 10
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4564:	15007602 	strne	r7, [r0, #-1538]	; 0x602
    4568:	75025101 	strvc	r5, [r2, #-257]	; 0x101
    456c:	50011500 	andpl	r1, r1, r0, lsl #10
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4570:	7f909103 	svcvc	0x00909103
    4574:	1c5c1400 	cfldrdne	mvd1, [ip], {-0}
    4578:	0db30000 	ldceq	0, cr0, [r3]
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    457c:	0a180000 	beq	604584 <_etext+0x5fd06c>
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4580:	01150000 	tsteq	r5, r0
    4584:	90910352 	addsls	r0, r1, r2, asr r3
    4588:	5101157f 	tstpl	r1, pc, ror r5
    458c:	7f909103 	svcvc	0x00909103
    4590:	03500115 	cmpeq	r0, #1073741829	; 0x40000005
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4594:	007ef091 			; <UNDEFINED> instruction: 0x007ef091
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4598:	001c6614 	andseq	r6, ip, r4, lsl r6
    459c:	000e1000 	andeq	r1, lr, r0
    45a0:	000a3a00 	andeq	r3, sl, r0, lsl #20
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45a4:	52011500 	andpl	r1, r1, #0, 10
    45a8:	15007d02 	strne	r7, [r0, #-3330]	; 0xd02
    45ac:	91035101 	tstls	r3, r1, lsl #2
    45b0:	01157ef0 			; <UNDEFINED> instruction: 0x01157ef0
    45b4:	f0910350 			; <UNDEFINED> instruction: 0xf0910350
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45b8:	7014007e 	andsvc	r0, r4, lr, ror r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45bc:	1000001c 	andne	r0, r0, ip, lsl r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45c0:	5d00000e 	stcpl	0, cr0, [r0, #-56]	; 0xffffffc8
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45c4:	1500000a 	strne	r0, [r0, #-10]
    45c8:	91035201 	tstls	r3, r1, lsl #4
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45cc:	01157eb0 			; <UNDEFINED> instruction: 0x01157eb0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45d0:	f0910351 			; <UNDEFINED> instruction: 0xf0910351
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45d4:	5001157e 	andpl	r1, r1, lr, ror r5
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45d8:	7ef09103 	nrmvcs	f1, f3
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45dc:	1c7a1400 	cfldrdne	mvd1, [sl], #-0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45e0:	0e100000 	cdpeq	0, 1, cr0, cr0, cr0, {0}
    45e4:	0a7f0000 	beq	1fc45ec <_etext+0x1fbd0d4>
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45e8:	01150000 	tsteq	r5, r0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45ec:	007d0252 	rsbseq	r0, sp, r2, asr r2
    45f0:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    45f4:	157eb091 	ldrbne	fp, [lr, #-145]!	; 0x91
    45f8:	91035001 	tstls	r3, r1
    45fc:	14007fb0 	strne	r7, [r0], #-4016	; 0xfb0
    4600:	00001c84 	andeq	r1, r0, r4, lsl #25
    4604:	00000e10 	andeq	r0, r0, r0, lsl lr
    4608:	00000aa2 	andeq	r0, r0, r2, lsr #21
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    460c:	03520115 	cmpeq	r2, #1073741829	; 0x40000005
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4610:	157ed091 	ldrbne	sp, [lr, #-145]!	; 0x91
    4614:	91035101 	tstls	r3, r1, lsl #2
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4618:	01157fb0 			; <UNDEFINED> instruction: 0x01157fb0
    461c:	90910350 	addsls	r0, r1, r0, asr r3
    4620:	8c14007f 	ldchi	0, cr0, [r4], {127}	; 0x7f
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4624:	4100001c 	tstmi	r0, ip, lsl r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4628:	bd00000e 	stclt	0, cr0, [r0, #-56]	; 0xffffffc8
    462c:	1500000a 	strne	r0, [r0, #-10]
    4630:	91035101 	tstls	r3, r1, lsl #2
    4634:	01157eb0 			; <UNDEFINED> instruction: 0x01157eb0
    4638:	50910250 	addspl	r0, r1, r0, asr r2
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    463c:	1c961400 	cfldrsne	mvf1, [r6], {0}
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4640:	0e100000 	cdpeq	0, 1, cr0, cr0, cr0, {0}
    4644:	0add0000 	beq	ff74464c <BootRAM+0xe6b4ded>
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4648:	01150000 	tsteq	r5, r0
    464c:	007d0252 	rsbseq	r0, sp, r2, asr r2
    4650:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4654:	01155091 			; <UNDEFINED> instruction: 0x01155091
    4658:	50910250 	addspl	r0, r1, r0, asr r2
    465c:	1ca01400 	cfstrsne	mvf1, [r0]
    4660:	0db30000 	ldceq	0, cr0, [r3]
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4664:	0aff0000 	beq	fffc466c <BootRAM+0xef34e0d>
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4668:	01150000 	tsteq	r5, r0
    466c:	90910352 	addsls	r0, r1, r2, asr r3
    4670:	5101157f 	tstpl	r1, pc, ror r5
    4674:	7ef09103 	nrmvcs	f1, f3
    4678:	02500115 	subseq	r0, r0, #1073741829	; 0x40000005
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    467c:	14000074 	strne	r0, [r0], #-116	; 0x74
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4680:	00001cac 	andeq	r1, r0, ip, lsr #25
    4684:	00000db3 			; <UNDEFINED> instruction: 0x00000db3
    4688:	00000b20 	andeq	r0, r0, r0, lsr #22
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    468c:	02520115 	subseq	r0, r2, #1073741829	; 0x40000005
    4690:	01155091 			; <UNDEFINED> instruction: 0x01155091
    4694:	b0910351 	addslt	r0, r1, r1, asr r3
    4698:	5001157f 	andpl	r1, r1, pc, ror r5
    469c:	00207402 	eoreq	r7, r0, r2, lsl #8
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46a0:	001cb814 	andseq	fp, ip, r4, lsl r8
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46a4:	000db300 	andeq	fp, sp, r0, lsl #6
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46a8:	000b4200 	andeq	r4, fp, r0, lsl #4
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46ac:	52011500 	andpl	r1, r1, #0, 10
    46b0:	15509102 	ldrbne	r9, [r0, #-258]	; 0x102
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46b4:	91035101 	tstls	r3, r1, lsl #2
    46b8:	01157ef0 			; <UNDEFINED> instruction: 0x01157ef0
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46bc:	c0740350 	rsbsgt	r0, r4, r0, asr r3
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46c0:	c4180000 	ldrgt	r0, [r8], #-0
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46c4:	b300001c 	movwlt	r0, #28
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46c8:	1500000d 	strne	r0, [r0, #-13]
    46cc:	91035201 	tstls	r3, r1, lsl #4
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46d0:	01157fb0 			; <UNDEFINED> instruction: 0x01157fb0
    46d4:	90910351 	addsls	r0, r1, r1, asr r3
    46d8:	5001157f 	andpl	r1, r1, pc, ror r5
    46dc:	00e07403 	rsceq	r7, r0, r3, lsl #8
    46e0:	2c1e0000 	ldccs	0, cr0, [lr], {-0}
    46e4:	01000016 	tsteq	r0, r6, lsl r0
    46e8:	1cc8012a 	stfnee	f0, [r8], {42}	; 0x2a
    46ec:	00840000 	addeq	r0, r4, r0
    46f0:	9c010000 	stcls	0, cr0, [r1], {-0}
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46f4:	00000d49 	andeq	r0, r0, r9, asr #26
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46f8:	0015cc1f 	andseq	ip, r5, pc, lsl ip
    46fc:	012a0100 	teqeq	sl, r0, lsl #2
    4700:	0000013f 	andeq	r0, r0, pc, lsr r1
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4704:	00001137 	andeq	r1, r0, r7, lsr r1
    4708:	01007020 	tsteq	r0, r0, lsr #32
    470c:	0145012a 	cmpeq	r5, sl, lsr #2
    4710:	11630000 	cmnne	r3, r0
    4714:	65200000 	strvs	r0, [r0, #-0]!
    4718:	012b0100 	teqeq	fp, r0, lsl #2
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    471c:	00000111 	andeq	r0, r0, r1, lsl r1
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4720:	0000118f 	andeq	r1, r0, pc, lsl #3
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4724:	0100721d 	tsteq	r0, sp, lsl r2
    4728:	00a7012d 	adceq	r0, r7, sp, lsr #2
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    472c:	91030000 	mrsls	r0, (UNDEF: 3)
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4730:	69217de8 	stmdbvs	r1!, {r3, r5, r6, r7, r8, sl, fp, ip, sp, lr}
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4734:	012e0100 	teqeq	lr, r0, lsl #2
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4738:	00000073 	andeq	r0, r0, r3, ror r0
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    473c:	000011bb 			; <UNDEFINED> instruction: 0x000011bb
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4740:	00011c22 	andeq	r1, r1, r2, lsr #24
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4744:	001cd400 	andseq	sp, ip, r0, lsl #8
    4748:	00000a00 	andeq	r0, r0, r0, lsl #20
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    474c:	01300100 	teqeq	r0, r0, lsl #2
    4750:	00000c09 	andeq	r0, r0, r9, lsl #24
    4754:	0001331a 	andeq	r3, r1, sl, lsl r3
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4758:	a4030600 	strge	r0, [r3], #-1536	; 0x600
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    475c:	9f000070 	svcls	0x00000070
    4760:	00012811 	andeq	r2, r1, r1, lsl r8
    4764:	0011f300 	andseq	pc, r1, r0, lsl #6
    4768:	1cde1800 	ldclne	8, cr1, [lr], {0}
    476c:	0e910000 	cdpeq	0, 9, cr0, cr1, cr0, {0}
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4770:	01150000 	tsteq	r5, r0
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4774:	80080252 	andhi	r0, r8, r2, asr r2
    4778:	05510115 	ldrbeq	r0, [r1, #-277]	; 0x115
    477c:	0070a403 	rsbseq	sl, r0, r3, lsl #8
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4780:	50011500 	andpl	r1, r1, r0, lsl #10
    4784:	00007d02 	andeq	r7, r0, r2, lsl #26
    4788:	03982300 	orrseq	r2, r8, #0, 6
    478c:	0d090000 	stceq	0, cr0, [r9, #-0]
    4790:	62210000 	eorvs	r0, r1, #0
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4794:	01007469 	tsteq	r0, r9, ror #8
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4798:	01170133 	tsteq	r7, r3, lsr r1
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    479c:	12220000 	eorne	r0, r2, #0
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47a0:	731d0000 	tstvc	sp, #0
    47a4:	01340100 	teqeq	r4, r0, lsl #2
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47a8:	000000a7 	andeq	r0, r0, r7, lsr #1
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47ac:	7ee89103 	urdvce	f1, f3
    47b0:	001cf214 	andseq	pc, ip, r4, lsl r2	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47b4:	0008c300 	andeq	ip, r8, r0, lsl #6
    47b8:	000c4a00 	andeq	r4, ip, r0, lsl #20
    47bc:	51011500 	tstpl	r1, r0, lsl #10
    47c0:	15007d02 	strne	r7, [r0, #-3330]	; 0xd02
    47c4:	7d025001 	stcvc	0, cr5, [r2, #-4]
    47c8:	00140000 	andseq	r0, r4, r0
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47cc:	b900001d 	stmdblt	r0, {r0, r2, r3, r4}
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47d0:	6b000005 	blvs	47ec <sha256_process+0x17b8>
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47d4:	1500000c 	strne	r0, [r0, #-12]
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47d8:	77025201 	strvc	r5, [r2, -r1, lsl #4]
    47dc:	51011500 	tstpl	r1, r0, lsl #10
    47e0:	15007d02 	strne	r7, [r0, #-3330]	; 0xd02
    47e4:	91035001 	tstls	r3, r1
    47e8:	14007ee8 	strne	r7, [r0], #-3816	; 0xee8
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47ec:	00001d0c 	andeq	r1, r0, ip, lsl #26
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47f0:	00000e57 	andeq	r0, r0, r7, asr lr
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47f4:	00000c92 	muleq	r0, r2, ip
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47f8:	02530115 	subseq	r0, r3, #1073741829	; 0x40000005
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47fc:	01150075 	tsteq	r5, r5, ror r0
    4800:	e8910352 	ldm	r1, {r1, r4, r6, r8, r9}
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4804:	5101157e 	tstpl	r1, lr, ror r5
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4808:	15007d02 	strne	r7, [r0, #-3330]	; 0xd02
    480c:	7d025001 	stcvc	0, cr5, [r2, #-4]
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4810:	18140000 	ldmdane	r4, {}	; <UNPREDICTABLE>
    4814:	5700001d 	smladpl	r0, sp, r0, r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4818:	bb00000e 	bllt	4858 <sha256_process+0x1824>
    481c:	1500000c 	strne	r0, [r0, #-12]
    4820:	75025301 	strvc	r5, [r2, #-769]	; 0x301
    4824:	52011500 	andpl	r1, r1, #0, 10
    4828:	7f889103 	svcvc	0x00889103
    482c:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    4830:	157e8891 	ldrbne	r8, [lr, #-2193]!	; 0x891
    4834:	91035001 	tstls	r3, r1
    4838:	14007e88 	strne	r7, [r0], #-3720	; 0xe88
    483c:	00001d24 	andeq	r1, r0, r4, lsr #26
    4840:	00000e57 	andeq	r0, r0, r7, asr lr
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4844:	00000ce3 	andeq	r0, r0, r3, ror #25
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4848:	02530115 	subseq	r0, r3, #1073741829	; 0x40000005
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    484c:	01150075 	tsteq	r5, r5, ror r0
    4850:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4854:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4858:	157ec891 	ldrbne	ip, [lr, #-2193]!	; 0x891
    485c:	91035001 	tstls	r3, r1
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4860:	18007ec8 	stmdane	r0, {r3, r6, r7, r9, sl, fp, ip, sp, lr}
    4864:	00001d32 	andeq	r1, r0, r2, lsr sp
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4868:	00000e57 	andeq	r0, r0, r7, asr lr
    486c:	02530115 	subseq	r0, r3, #1073741829	; 0x40000005
    4870:	01150075 	tsteq	r5, r5, ror r0
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4874:	a8910352 	ldmge	r1, {r1, r4, r6, r8, r9}
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4878:	5101157f 	tstpl	r1, pc, ror r5
    487c:	7ea89103 	tanvce	f1, f3
    4880:	03500115 	cmpeq	r0, #1073741829	; 0x40000005
    4884:	007ea891 			; <UNDEFINED> instruction: 0x007ea891
    4888:	011c2400 	tsteq	ip, r0, lsl #8
    488c:	1d360000 	ldcne	0, cr0, [r6, #-0]
    4890:	000a0000 	andeq	r0, sl, r0
    4894:	3f010000 	svccc	0x00010000
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4898:	01331101 	teqeq	r3, r1, lsl #2
    489c:	12350000 	eorsne	r0, r5, #0
    48a0:	28110000 	ldmdacs	r1, {}	; <UNPREDICTABLE>
    48a4:	64000001 	strvs	r0, [r0], #-1
    48a8:	18000012 	stmdane	r0, {r1, r4}
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48ac:	00001d40 	andeq	r1, r0, r0, asr #26
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48b0:	00000e91 	muleq	r0, r1, lr
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48b4:	02520115 	subseq	r0, r2, #1073741829	; 0x40000005
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48b8:	01158008 	tsteq	r5, r8
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48bc:	007d0251 	rsbseq	r0, sp, r1, asr r2
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48c0:	02500115 	subseq	r0, r0, #1073741829	; 0x40000005
    48c4:	00000078 	andeq	r0, r0, r8, ror r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48c8:	16b32500 	ldrtne	r2, [r3], r0, lsl #10
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48cc:	57010000 	strpl	r0, [r1, -r0]
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48d0:	00000d5a 	andeq	r0, r0, sl, asr sp
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48d4:	71a40305 			; <UNDEFINED> instruction: 0x71a40305
    48d8:	dc0d0000 	stcle	0, cr0, [sp], {-0}
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48dc:	25000000 	strcs	r0, [r0, #-0]
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48e0:	000016bd 			; <UNDEFINED> instruction: 0x000016bd
    48e4:	0d5a9501 	cfldr64eq	mvdx9, [sl, #-4]
    48e8:	03050000 	movweq	r0, #20480	; 0x5000
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48ec:	00007084 	andeq	r7, r0, r4, lsl #1
    48f0:	00149726 	andseq	r9, r4, r6, lsr #14
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48f4:	5a1c0200 	bpl	7050fc <_etext+0x6fdbe4>
    48f8:	2700000d 	strcs	r0, [r0, -sp]
    48fc:	00001699 	muleq	r0, r9, r6
    4900:	014b1401 	cmpeq	fp, r1, lsl #8
    4904:	03050000 	movweq	r0, #20480	; 0x5000
    4908:	00007124 	andeq	r7, r0, r4, lsr #2
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    490c:	00165827 	andseq	r5, r6, r7, lsr #16
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4910:	4b2a0100 	blmi	a84d18 <_etext+0xa7d800>
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4914:	05000001 	streq	r0, [r0, #-1]
    4918:	0070a403 	rsbseq	sl, r0, r3, lsl #8
    491c:	163a2800 	ldrtne	r2, [sl], -r0, lsl #16
    4920:	1f020000 	svcne	0x00020000
    4924:	00000db3 			; <UNDEFINED> instruction: 0x00000db3
    4928:	00010b29 	andeq	r0, r1, r9, lsr #22
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    492c:	008c2900 	addeq	r2, ip, r0, lsl #18
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4930:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4934:	00001573 	andeq	r1, r0, r3, ror r5
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4938:	0dce4402 	cfstrdeq	mvd4, [lr, #8]
    493c:	0b290000 	bleq	a44944 <_etext+0xa3d42c>
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4940:	29000001 	stmdbcs	r0, {r0}
    4944:	00000111 	andeq	r0, r0, r1, lsl r1
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4948:	00011129 	andeq	r1, r1, r9, lsr #2
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    494c:	88280000 	stmdahi	r8!, {}	; <UNPREDICTABLE>
    4950:	02000015 	andeq	r0, r0, #21
    4954:	000de451 	andeq	lr, sp, r1, asr r4
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4958:	010b2900 	tsteq	fp, r0, lsl #18
    495c:	11290000 	teqne	r9, r0
    4960:	00000001 	andeq	r0, r0, r1
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4964:	00156228 	andseq	r6, r5, r8, lsr #4
    4968:	f5280200 			; <UNDEFINED> instruction: 0xf5280200
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    496c:	2900000d 	stmdbcs	r0, {r0, r2, r3}
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4970:	0000010b 	andeq	r0, r0, fp, lsl #2
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4974:	147a2800 	ldrbtne	r2, [sl], #-2048	; 0x800
    4978:	3a020000 	bcc	84980 <_etext+0x7d468>
    497c:	00000e10 	andeq	r0, r0, r0, lsl lr
    4980:	00010b29 	andeq	r0, r1, r9, lsr #22
    4984:	01112900 	tsteq	r1, r0, lsl #18
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4988:	11290000 	teqne	r9, r0
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    498c:	00000001 	andeq	r0, r0, r1
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4990:	00155228 	andseq	r5, r5, r8, lsr #4
    4994:	2b3b0200 	blcs	ec519c <_etext+0xebdc84>
    4998:	2900000e 	stmdbcs	r0, {r1, r2, r3}
    499c:	0000010b 	andeq	r0, r0, fp, lsl #2
    49a0:	00011129 	andeq	r1, r1, r9, lsr #2
    49a4:	01112900 	tsteq	r1, r0, lsl #18
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49a8:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49ac:	00001668 	andeq	r1, r0, r8, ror #12
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49b0:	0e415a02 	vmlaeq.f32	s11, s2, s4
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49b4:	0b290000 	bleq	a449bc <_etext+0xa3d4a4>
    49b8:	29000001 	stmdbcs	r0, {r0}
    49bc:	00000111 	andeq	r0, r0, r1, lsl r1
    49c0:	16742800 	ldrbtne	r2, [r4], -r0, lsl #16
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49c4:	3e020000 	cdpcc	0, 0, cr0, cr2, cr0, {0}
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49c8:	00000e57 	andeq	r0, r0, r7, asr lr
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49cc:	00010b29 	andeq	r0, r1, r9, lsr #22
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49d0:	01112900 	tsteq	r1, r0, lsl #18
    49d4:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49d8:	0000159d 	muleq	r0, sp, r5
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49dc:	0e773302 	cdpeq	3, 7, cr3, cr7, cr2, {0}
    49e0:	0b290000 	bleq	a449e8 <_etext+0xa3d4d0>
    49e4:	29000001 	stmdbcs	r0, {r0}
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49e8:	00000111 	andeq	r0, r0, r1, lsl r1
    49ec:	00011129 	andeq	r1, r1, r9, lsr #2
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49f0:	00812900 	addeq	r2, r1, r0, lsl #18
    49f4:	2a000000 	bcs	49fc <sha256_process+0x19c8>
    49f8:	000015c2 	andeq	r1, r0, r2, asr #11
    49fc:	00812d02 	addeq	r2, r1, r2, lsl #26
    4a00:	0e910000 	cdpeq	0, 9, cr0, cr1, cr0, {0}
    4a04:	11290000 	teqne	r9, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a08:	29000001 	stmdbcs	r0, {r0}
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a0c:	00000111 	andeq	r0, r0, r1, lsl r1
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a10:	15d22b00 	ldrbne	r2, [r2, #2816]	; 0xb00
    4a14:	009e0000 	addseq	r0, lr, r0
    4a18:	0eae0000 	cdpeq	0, 10, cr0, cr14, cr0, {0}
    4a1c:	9e290000 	cdpls	0, 2, cr0, cr9, cr0, {0}
    4a20:	29000000 	stmdbcs	r0, {}	; <UNPREDICTABLE>
    4a24:	00000eae 	andeq	r0, r0, lr, lsr #29
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a28:	00009729 	andeq	r9, r0, r9, lsr #14
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a2c:	040c0000 	streq	r0, [ip], #-0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a30:	00000eb4 			; <UNDEFINED> instruction: 0x00000eb4
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a34:	0b58002c 	bleq	1604aec <_etext+0x15fd5d4>
    4a38:	00040000 	andeq	r0, r4, r0
    4a3c:	00001227 	andeq	r1, r0, r7, lsr #4
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a40:	14b40104 	ldrtne	r0, [r4], #260	; 0x104
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a44:	df010000 	svcle	0x00010000
    4a48:	93000016 	movwls	r0, #22
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a4c:	08000008 	stmdaeq	r0, {r3}
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a50:	00000005 	andeq	r0, r0, r5
    4a54:	ae000000 	cdpge	0, 0, cr0, cr0, cr0, {0}
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a58:	02000014 	andeq	r0, r0, #20
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a5c:	081a0601 	ldmdaeq	sl, {r0, r9, sl}
    4a60:	01030000 	mrseq	r0, (UNDEF: 3)
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a64:	0400000b 	streq	r0, [r0], #-11
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a68:	0000371c 	andeq	r3, r0, ip, lsl r7
    4a6c:	08010200 	stmdaeq	r1, {r9}
    4a70:	00000818 	andeq	r0, r0, r8, lsl r8
    4a74:	fc050202 	stc2	2, cr0, [r5], {2}
    4a78:	02000006 	andeq	r0, r0, #6
    4a7c:	09490702 	stmdbeq	r9, {r1, r8, r9, sl}^
    4a80:	04020000 	streq	r0, [r2], #-0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a84:	0004da05 	andeq	sp, r4, r5, lsl #20
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a88:	07040200 	streq	r0, [r4, -r0, lsl #4]
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a8c:	00000252 	andeq	r0, r0, r2, asr r2
    4a90:	d5050802 	strle	r0, [r5, #-2050]	; 0x802
    4a94:	03000004 	movweq	r0, #4
    4a98:	00001751 	andeq	r1, r0, r1, asr r7
    4a9c:	006c4e04 	rsbeq	r4, ip, r4, lsl #28
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4aa0:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4aa4:	00024d07 	andeq	r4, r2, r7, lsl #26
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4aa8:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4aac:	00746e69 	rsbseq	r6, r4, r9, ror #28
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ab0:	57070402 	strpl	r0, [r7, -r2, lsl #8]
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4ab4:	03000002 	movweq	r0, #2
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ab8:	00000b03 	andeq	r0, r0, r3, lsl #22
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4abc:	002c2a05 	eoreq	r2, ip, r5, lsl #20
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ac0:	53030000 	movwpl	r0, #12288	; 0x3000
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4ac4:	05000017 	streq	r0, [r0, #-23]
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ac8:	0000614e 	andeq	r6, r0, lr, asr #2
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4acc:	0ac70300 	beq	ff1c56d4 <BootRAM+0xe135e75>
    4ad0:	d4060000 	strle	r0, [r6], #-0
    4ad4:	0000007a 	andeq	r0, r0, sl, ror r0
    4ad8:	8b070402 	blhi	1c5ae8 <_etext+0x1be5d0>
    4adc:	05000007 	streq	r0, [r0, #-7]
    4ae0:	08010204 	stmdaeq	r1, {r2, r9}
    4ae4:	00000821 	andeq	r0, r0, r1, lsr #16
    4ae8:	00168e06 	andseq	r8, r6, r6, lsl #28
    4aec:	20038000 	andcs	r8, r3, r0
    4af0:	000000e7 	andeq	r0, r0, r7, ror #1
    4af4:	03007807 	movweq	r7, #2055	; 0x807
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4af8:	0000e721 	andeq	lr, r0, r1, lsr #14
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4afc:	79070000 	stmdbvc	r7, {}	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b00:	e7220300 	str	r0, [r2, -r0, lsl #6]!
    4b04:	20000000 	andcs	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b08:	03007407 	movweq	r7, #1031	; 0x407
    4b0c:	0000e723 	andeq	lr, r0, r3, lsr #14
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b10:	7a074000 	bvc	1d4b18 <_etext+0x1cd600>
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b14:	e7240300 	str	r0, [r4, -r0, lsl #6]!
    4b18:	60000000 	andvs	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b1c:	00810800 	addeq	r0, r1, r0, lsl #16
    4b20:	00f70000 	rscseq	r0, r7, r0
    4b24:	a2090000 	andge	r0, r9, #0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b28:	1f000000 	svcne	0x00000000
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b2c:	17c00600 	strbne	r0, [r0, r0, lsl #12]
    4b30:	02400000 	subeq	r0, r0, #0
    4b34:	00010e14 	andeq	r0, r1, r4, lsl lr
    4b38:	00680700 	rsbeq	r0, r8, r0, lsl #14
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b3c:	010e1502 	tsteq	lr, r2, lsl #10
    4b40:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b44:	00008c08 	andeq	r8, r0, r8, lsl #24
    4b48:	00011e00 	andeq	r1, r1, r0, lsl #28
    4b4c:	00a20900 	adceq	r0, r2, r0, lsl #18
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b50:	00070000 	andeq	r0, r7, r0
    4b54:	0017db0a 	andseq	sp, r7, sl, lsl #22
    4b58:	031c0200 	tsteq	ip, #0, 4
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b5c:	00000134 	andeq	r0, r0, r4, lsr r1
    4b60:	0200730b 	andeq	r7, r0, #738197504	; 0x2c000000
    4b64:	0001341c 	andeq	r3, r1, ip, lsl r4
    4b68:	040c0000 	streq	r0, [ip], #-0
    4b6c:	000000f7 	strdeq	r0, [r0], -r7
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b70:	0016ee0a 	andseq	lr, r6, sl, lsl #28
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b74:	033e0300 	teqeq	lr, #0, 6
    4b78:	00000150 	andeq	r0, r0, r0, asr r1
    4b7c:	0300650b 	movweq	r6, #1291	; 0x50b
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b80:	0001503e 	andeq	r5, r1, lr, lsr r0
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b84:	040c0000 	streq	r0, [ip], #-0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4b88:	00000081 	andeq	r0, r0, r1, lsl #1
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b8c:	0017950a 	andseq	r9, r7, sl, lsl #10
    4b90:	01420100 	mrseq	r0, (UNDEF: 82)
    4b94:	000001ae 	andeq	r0, r0, lr, lsr #3
    4b98:	0017330d 	andseq	r3, r7, sp, lsl #6
    4b9c:	50420100 	subpl	r0, r2, r0, lsl #2
    4ba0:	0d000001 	stceq	0, cr0, [r0, #-4]
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4ba4:	000016d4 	ldrdeq	r1, [r0], -r4
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4ba8:	01504301 	cmpeq	r0, r1, lsl #6
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4bac:	5c0d0000 	stcpl	0, cr0, [sp], {-0}
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bb0:	01000017 	tsteq	r0, r7, lsl r0
    4bb4:	00007343 	andeq	r7, r0, r3, asr #6
    4bb8:	178d0d00 	strne	r0, [sp, r0, lsl #26]
    4bbc:	44010000 	strmi	r0, [r1], #-0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4bc0:	000001ae 	andeq	r0, r0, lr, lsr #3
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bc4:	6e656c0b 	cdpvs	12, 6, cr6, cr5, cr11, {0}
    4bc8:	97440100 	strbls	r0, [r4, -r0, lsl #2]
    4bcc:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    4bd0:	46010073 			; <UNDEFINED> instruction: 0x46010073
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4bd4:	000000f7 	strdeq	r0, [r0], -r7
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bd8:	00690e0f 	rsbeq	r0, r9, pc, lsl #28
    4bdc:	00974e01 	addseq	r4, r7, r1, lsl #28
    4be0:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4be4:	01b4040c 			; <UNDEFINED> instruction: 0x01b4040c
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4be8:	81100000 	tsthi	r0, r0
    4bec:	0a000000 	beq	4bf4 <sha256_process+0x1bc0>
    4bf0:	00001728 	andeq	r1, r0, r8, lsr #14
    4bf4:	e5011501 	str	r1, [r1, #-1281]	; 0x501
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4bf8:	0d000001 	stceq	0, cr0, [r0, #-4]
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bfc:	00001741 	andeq	r1, r0, r1, asr #14
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c00:	01501501 	cmpeq	r0, r1, lsl #10
    4c04:	3a0d0000 	bcc	344c0c <_etext+0x33d6f4>
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c08:	01000017 	tsteq	r0, r7, lsl r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c0c:	0001ae15 	andeq	sl, r1, r5, lsl lr
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c10:	00730e00 	rsbseq	r0, r3, r0, lsl #28
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c14:	00f71701 	rscseq	r1, r7, r1, lsl #14
    4c18:	0a000000 	beq	4c20 <sha256_process+0x1bec>
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c1c:	000017b8 			; <UNDEFINED> instruction: 0x000017b8
    4c20:	0d013201 	sfmeq	f3, 4, [r1, #-4]
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c24:	0b000002 	bleq	4c34 <sha256_process+0x1c00>
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c28:	32010072 	andcc	r0, r1, #114	; 0x72
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c2c:	00000150 	andeq	r0, r0, r0, asr r1
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c30:	01006b0b 	tsteq	r0, fp, lsl #22
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c34:	0001ae32 	andeq	sl, r1, r2, lsr lr
    4c38:	00700e00 	rsbseq	r0, r0, r0, lsl #28
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c3c:	00b23401 	adcseq	r3, r2, r1, lsl #8
    4c40:	11000000 	mrsne	r0, (UNDEF: 0)
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c44:	01007070 	tsteq	r0, r0, ror r0
    4c48:	023f0129 	eorseq	r0, pc, #1073741834	; 0x4000000a
    4c4c:	4a0d0000 	bmi	344c54 <_etext+0x33d73c>
    4c50:	01000017 	tsteq	r0, r7, lsl r0
    4c54:	00015029 	andeq	r5, r1, r9, lsr #32
    4c58:	00700b00 	rsbseq	r0, r0, r0, lsl #22
    4c5c:	023f2901 	eorseq	r2, pc, #16384	; 0x4000
    4c60:	780e0000 	stmdavc	lr, {}	; <UNPREDICTABLE>
    4c64:	e72b0100 	str	r0, [fp, -r0, lsl #2]!
    4c68:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    4c6c:	2c010079 	stccs	0, cr0, [r1], {121}	; 0x79
    4c70:	000000e7 	andeq	r0, r0, r7, ror #1
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c74:	45040c00 	strmi	r0, [r4, #-3072]	; 0xc00
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c78:	10000002 	andne	r0, r0, r2
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c7c:	000000b2 	strheq	r0, [r0], -r2
    4c80:	0017a612 	andseq	sl, r7, r2, lsl r6
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c84:	003a0100 	eorseq	r0, sl, r0, lsl #2
    4c88:	7c000000 	stcvc	0, cr0, [r0], {-0}
    4c8c:	01000000 	mrseq	r0, (UNDEF: 0)
    4c90:	0004089c 	muleq	r4, ip, r8
    4c94:	75701300 	ldrbvc	r1, [r0, #-768]!	; 0x300
    4c98:	3a010062 	bcc	44e28 <_etext+0x3d910>
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c9c:	00000150 	andeq	r0, r0, r0, asr r1
    4ca0:	00001285 	andeq	r1, r0, r5, lsl #5
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4ca4:	00173a14 	andseq	r3, r7, r4, lsl sl
    4ca8:	ae3a0100 	rsfgee	f0, f2, f0
    4cac:	b1000001 	tstlt	r0, r1
    4cb0:	15000012 	strne	r0, [r0, #-18]
    4cb4:	00001741 	andeq	r1, r0, r1, asr #14
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cb8:	04083c01 	streq	r3, [r8], #-3073	; 0xc01
    4cbc:	91030000 	mrsls	r0, (UNDEF: 3)
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cc0:	b9167ea8 	ldmdblt	r6, {r3, r5, r7, r9, sl, fp, ip, sp, lr}
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cc4:	00000001 	andeq	r0, r0, r1
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cc8:	f0000000 			; <UNDEFINED> instruction: 0xf0000000
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4ccc:	01000003 	tsteq	r0, r3
    4cd0:	00033d3e 	andeq	r3, r3, lr, lsr sp
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4cd4:	01d01700 	bicseq	r1, r0, r0, lsl #14
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cd8:	12dd0000 	sbcsne	r0, sp, #0
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cdc:	c5170000 	ldrgt	r0, [r7, #-0]
    4ce0:	09000001 	stmdbeq	r0, {r0}
    4ce4:	18000013 	stmdane	r0, {r0, r1, r4}
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4ce8:	000003f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cec:	0001db19 	andeq	sp, r1, r9, lsl fp
    4cf0:	e8910300 	ldm	r1, {r8, r9}
    4cf4:	011e167e 	tsteq	lr, lr, ror r6
    4cf8:	00000000 	andeq	r0, r0, r0
    4cfc:	04200000 	strteq	r0, [r0], #-0
    4d00:	19010000 	stmdbne	r1, {}	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d04:	000002dc 	ldrdeq	r0, [r0], -ip
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d08:	00012a17 	andeq	r2, r1, r7, lsl sl
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d0c:	00135f00 	andseq	r5, r3, r0, lsl #30
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d10:	3a160000 	bcc	584d18 <_etext+0x57d800>
    4d14:	00000001 	andeq	r0, r0, r1
    4d18:	40000000 	andmi	r0, r0, r0
    4d1c:	01000004 	tsteq	r0, r4
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d20:	0002f91c 	andeq	pc, r2, ip, lsl r9	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d24:	01461700 	cmpeq	r6, r0, lsl #14
    4d28:	14170000 	ldrne	r0, [r7], #-0
    4d2c:	1a000000 	bne	4d34 <sha256_process+0x1d00>
    4d30:	00000000 	andeq	r0, r0, r0
    4d34:	00000a04 	andeq	r0, r0, r4, lsl #20
    4d38:	00000319 	andeq	r0, r0, r9, lsl r3
    4d3c:	0252011b 	subseq	r0, r2, #-1073741818	; 0xc0000006
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d40:	011b2008 	tsteq	fp, r8
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d44:	00770251 	rsbseq	r0, r7, r1, asr r2
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d48:	0250011b 	subseq	r0, r0, #-1073741818	; 0xc0000006
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d4c:	1c005074 	stcne	0, cr5, [r0], {116}	; 0x74
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d50:	00000000 	andeq	r0, r0, r0
    4d54:	00000a1f 	andeq	r0, r0, pc, lsl sl
    4d58:	0253011b 	subseq	r0, r3, #-1073741818	; 0xc0000006
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d5c:	011b4008 	tsteq	fp, r8
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d60:	1b300152 	blne	c052b0 <_etext+0xbfdd98>
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d64:	91035101 	tstls	r3, r1, lsl #2
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d68:	011b7ea8 	tsteq	fp, r8, lsr #29
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4d6c:	50740250 	rsbspl	r0, r4, r0, asr r2
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d70:	1d000000 	stcne	0, cr0, [r0, #-0]
    4d74:	000001e5 	andeq	r0, r0, r5, ror #3
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4d78:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d7c:	00000460 	andeq	r0, r0, r0, ror #8
    4d80:	fa173f01 	blx	5d498c <_etext+0x5cd474>
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d84:	54000001 	strpl	r0, [r0], #-1
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4d88:	17000014 	smladne	r0, r4, r0, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d8c:	000001f1 	strdeq	r0, [r0], -r1
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d90:	00001483 	andeq	r1, r0, r3, lsl #9
    4d94:	00046018 	andeq	r6, r4, r8, lsl r0
    4d98:	02031900 	andeq	r1, r3, #0, 18
    4d9c:	91030000 	mrsls	r0, (UNDEF: 3)
    4da0:	0d1e7ee8 	ldceq	14, cr7, [lr, #-928]	; 0xfffffc60
    4da4:	00000002 	andeq	r0, r0, r2
    4da8:	14000000 	strne	r0, [r0], #-0
    4dac:	01000000 	mrseq	r0, (UNDEF: 0)
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4db0:	0003ed37 	andeq	lr, r3, r7, lsr sp
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4db4:	02231700 	eoreq	r1, r3, #0, 14
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4db8:	14a40000 	strtne	r0, [r4], #0
    4dbc:	18170000 	ldmdane	r7, {}	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dc0:	e1000002 	tst	r0, r2
    4dc4:	1f000014 	svcne	0x00000014
    4dc8:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4dcc:	00000014 	andeq	r0, r0, r4, lsl r0
    4dd0:	00022c19 	andeq	r2, r2, r9, lsl ip
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dd4:	e8910300 	ldm	r1, {r8, r9}
    4dd8:	0235197d 	eorseq	r1, r5, #2048000	; 0x1f4000
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ddc:	91030000 	mrsls	r0, (UNDEF: 3)
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4de0:	001a7e88 	andseq	r7, sl, r8, lsl #29
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4de4:	45000000 	strmi	r0, [r0, #-0]
    4de8:	ce00000a 	cdpgt	0, 0, cr0, cr0, cr10, {0}
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dec:	1b000003 	blne	4e00 <sha256_process+0x1dcc>
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4df0:	91035201 	tstls	r3, r1, lsl #4
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4df4:	011b7ee8 	tsteq	fp, r8, ror #29
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4df8:	88910351 	ldmhi	r1, {r0, r4, r6, r8, r9}
    4dfc:	50011b7e 	andpl	r1, r1, lr, ror fp
    4e00:	00007d02 	andeq	r7, r0, r2, lsl #26
    4e04:	0000001c 	andeq	r0, r0, ip, lsl r0
    4e08:	000a6000 	andeq	r6, sl, r0
    4e0c:	52011b00 	andpl	r1, r1, #0, 22
    4e10:	7e889103 	sinvce	f1, f3
    4e14:	0251011b 	subseq	r0, r1, #-1073741818	; 0xc0000006
    4e18:	011b007d 	tsteq	fp, sp, ror r0
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e1c:	00760250 	rsbseq	r0, r6, r0, asr r2
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e20:	1c000000 	stcne	0, cr0, [r0], {-0}
    4e24:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e28:	00000a7b 	andeq	r0, r0, fp, ror sl
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e2c:	0352011b 	cmpeq	r2, #-1073741818	; 0xc0000006
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e30:	1b7ea891 	blne	1faf07c <_etext+0x1fa7b64>
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e34:	91035001 	tstls	r3, r1
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e38:	00007ee8 	andeq	r7, r0, r8, ror #29
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e3c:	81080000 	mrshi	r0, (UNDEF: 8)
    4e40:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
    4e44:	09000004 	stmdbeq	r0, {r2}
    4e48:	000000a2 	andeq	r0, r0, r2, lsr #1
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e4c:	880a003f 	stmdahi	sl, {r0, r1, r2, r3, r4, r5}
    4e50:	01000017 	tsteq	r0, r7, lsl r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e54:	045f0169 	ldrbeq	r0, [pc], #-361	; 4e5c <sha256_process+0x1e28>
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e58:	7a0b0000 	bvc	2c4e60 <_etext+0x2bd948>
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e5c:	50690100 	rsbpl	r0, r9, r0, lsl #2
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e60:	0b000001 	bleq	4e6c <sha256_process+0x1e38>
    4e64:	69010072 	stmdbvs	r1, {r1, r4, r5, r6}
    4e68:	000001ae 	andeq	r0, r0, lr, lsr #3
    4e6c:	0100610b 	tsteq	r0, fp, lsl #2
    4e70:	0001ae69 	andeq	sl, r1, r9, ror #28
    4e74:	006d0b00 	rsbeq	r0, sp, r0, lsl #22
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4e78:	01ae6a01 			; <UNDEFINED> instruction: 0x01ae6a01
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e7c:	6c0b0000 	stcvs	0, cr0, [fp], {-0}
    4e80:	01006e65 	tsteq	r0, r5, ror #28
    4e84:	0000976a 	andeq	r9, r0, sl, ror #14
    4e88:	17ee2000 	strbne	r2, [lr, r0]!
    4e8c:	6c010000 	stcvs	0, cr0, [r1], {-0}
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4e90:	0000045f 	andeq	r0, r0, pc, asr r4
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e94:	00810800 	addeq	r0, r1, r0, lsl #16
    4e98:	046f0000 	strbteq	r0, [pc], #-0	; 4ea0 <sha256_process+0x1e6c>
    4e9c:	a2090000 	andge	r0, r9, #0
    4ea0:	7f000000 	svcvc	0x00000000
    4ea4:	70752100 	rsbsvc	r2, r5, r0, lsl #2
    4ea8:	1f010070 	svcne	0x00010070
    4eac:	00000081 	andeq	r0, r0, r1, lsl #1
    4eb0:	0004b001 	andeq	fp, r4, r1
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4eb4:	00700b00 	rsbseq	r0, r0, r0, lsl #22
    4eb8:	04b01f01 	ldrteq	r1, [r0], #3841	; 0xf01
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ebc:	4a0d0000 	bmi	344ec4 <_etext+0x33d9ac>
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4ec0:	01000017 	tsteq	r0, r7, lsl r0
    4ec4:	0001ae1f 	andeq	sl, r1, pc, lsl lr
    4ec8:	00780e00 	rsbseq	r0, r8, r0, lsl #28
    4ecc:	00e72101 	rsceq	r2, r7, r1, lsl #2
    4ed0:	790e0000 	stmdbvc	lr, {}	; <UNPREDICTABLE>
    4ed4:	e7220100 	str	r0, [r2, -r0, lsl #2]!
    4ed8:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    4edc:	01006b6f 	tsteq	r0, pc, ror #22
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ee0:	00008123 	andeq	r8, r0, r3, lsr #2
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4ee4:	040c0000 	streq	r0, [ip], #-0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ee8:	000000b2 	strheq	r0, [r0], -r2
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4eec:	0017cd22 	andseq	ip, r7, r2, lsr #26
    4ef0:	818c0100 	orrhi	r0, ip, r0, lsl #2
    4ef4:	4c000000 	stcmi	0, cr0, [r0], {-0}
    4ef8:	7c00001d 	stcvc	0, cr0, [r0], {29}
    4efc:	01000001 	tsteq	r0, r1
    4f00:	0009d39c 	muleq	r9, ip, r3
    4f04:	171e1400 	ldrne	r1, [lr, -r0, lsl #8]
    4f08:	8c010000 	stchi	0, cr0, [r1], {-0}
    4f0c:	000001ae 	andeq	r0, r0, lr, lsr #3
    4f10:	00001502 	andeq	r1, r0, r2, lsl #10
    4f14:	62757013 	rsbsvs	r7, r5, #19
    4f18:	ae8c0100 	rmfgee	f0, f4, f0
    4f1c:	20000001 	andcs	r0, r0, r1
    4f20:	14000015 	strne	r0, [r0], #-21
    4f24:	0000178d 	andeq	r1, r0, sp, lsl #15
    4f28:	01ae8d01 			; <UNDEFINED> instruction: 0x01ae8d01
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    ctx->state[7] += H;
    4f2c:	153e0000 	ldrne	r0, [lr, #-0]!
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f30:	6c130000 	ldcvs	0, cr0, [r3], {-0}

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    4f34:	01006e65 	tsteq	r0, r5, ror #28
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f38:	0000978d 	andeq	r9, r0, sp, lsl #15
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    4f3c:	00155c00 	andseq	r5, r5, r0, lsl #24
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f40:	00702300 	rsbseq	r2, r0, r0, lsl #6

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    4f44:	00b28f01 	adcseq	r8, r2, r1, lsl #30
    4f48:	91030000 	mrsls	r0, (UNDEF: 3)
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    4f4c:	71237de0 	teqvc	r3, r0, ror #27
    ctx->state[1] += B;
    4f50:	b2900100 	addslt	r0, r0, #0, 2
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    4f54:	03000000 	movweq	r0, #0
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    4f58:	237ee091 	cmncs	lr, #145	; 0x91
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    4f5c:	0073686c 	rsbseq	r6, r3, ip, ror #16
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    4f60:	00e79101 	rsceq	r9, r7, r1, lsl #2
    ctx->state[4] += E;
    4f64:	91030000 	mrsls	r0, (UNDEF: 3)
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    4f68:	72237cc0 	eorvc	r7, r3, #192, 24	; 0xc000
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    4f6c:	01007368 	tsteq	r0, r8, ror #6
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    4f70:	0000e792 	muleq	r0, r2, r7
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    4f74:	e0910300 	adds	r0, r1, r0, lsl #6
    ctx->state[7] += H;
    4f78:	007a237c 	rsbseq	r2, sl, ip, ror r3
}
    4f7c:	00e79301 	rsceq	r9, r7, r1, lsl #6
    4f80:	91030000 	mrsls	r0, (UNDEF: 3)
    4f84:	6f247d80 	svcvs	0x00247d80
    4f88:	9401006b 	strls	r0, [r1], #-107	; 0x6b
    4f8c:	00000081 	andeq	r0, r0, r1, lsl #1
    4f90:	0000157a 	andeq	r1, r0, sl, ror r5
    4f94:	00041816 	andeq	r1, r4, r6, lsl r8

void sha256_update( sha256_context *ctx, uint8 *input, uint32 length )
{
    4f98:	001d5600 	andseq	r5, sp, r0, lsl #12
    uint32 left, fill;

    if( ! length ) return;
    4f9c:	00048000 	andeq	r8, r4, r0
    ctx->state[6] += G;
    ctx->state[7] += H;
}

void sha256_update( sha256_context *ctx, uint8 *input, uint32 length )
{
    4fa0:	06970100 	ldreq	r0, [r7], r0, lsl #2
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    4fa4:	17000007 	strne	r0, [r0, -r7]
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    4fa8:	00000448 	andeq	r0, r0, r8, asr #8
{
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    4fac:	000015bb 			; <UNDEFINED> instruction: 0x000015bb
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    4fb0:	00043f17 	andeq	r3, r4, r7, lsl pc
        ctx->total[1]++;
    4fb4:	0015d900 	andseq	sp, r5, r0, lsl #18

    if( left && length >= fill )
    4fb8:	04361700 	ldrteq	r1, [r6], #-1792	; 0x700
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    4fbc:	15f70000 	ldrbne	r0, [r7, #0]!
    4fc0:	2d170000 	ldccs	0, cr0, [r7, #-0]
    {
        sha256_process( ctx, input );
        length -= 64;
    4fc4:	15000004 	strne	r0, [r0, #-4]
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    4fc8:	17000016 	smladne	r0, r6, r0, r0
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    4fcc:	00000424 	andeq	r0, r0, r4, lsr #8
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    4fd0:	00001633 	andeq	r1, r0, r3, lsr r6
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    4fd4:	00048018 	andeq	r8, r4, r8, lsl r0
    4fd8:	04531900 	ldrbeq	r1, [r3], #-2304	; 0x900
    4fdc:	91030000 	mrsls	r0, (UNDEF: 3)
    4fe0:	561d7ee0 	ldrpl	r7, [sp], -r0, ror #29
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    4fe4:	7c000001 	stcvc	0, cr0, [r0], {1}
    4fe8:	a000001d 	andge	r0, r0, sp, lsl r0
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    4fec:	01000004 	tsteq	r0, r4
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    4ff0:	01782570 	cmneq	r8, r0, ror r5
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    4ff4:	26400000 	strbcs	r0, [r0], -r0
    4ff8:	0000018e 	andeq	r0, r0, lr, lsl #3
                (void *) input, length );
    }
}
    4ffc:	83265801 	teqhi	r6, #65536	; 0x10000
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    5000:	01000001 	tsteq	r0, r1
    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
    5004:	016d1759 	cmneq	sp, r9, asr r7
    5008:	167b0000 	ldrbtne	r0, [fp], -r0
    500c:	62170000 	andsvs	r0, r7, #0
    5010:	8b000001 	blhi	501c <sha256_update+0x84>
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    5014:	18000017 	stmdane	r0, {r0, r1, r2, r4}
    5018:	000004a0 	andeq	r0, r0, r0, lsr #9
        length -= fill;
    501c:	00019919 	andeq	r9, r1, r9, lsl r9
        input  += fill;
    5020:	e0910300 	adds	r0, r1, r0, lsl #6
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    5024:	011e167d 	tsteq	lr, sp, ror r6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    5028:	1d7c0000 	ldclne	0, cr0, [ip, #-0]
    uint32 last, padn;
    uint32 high, low;
    uint8 msglen[8];

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    502c:	04c80000 	strbeq	r0, [r8], #0
    low  = ( ctx->total[0] <<  3 );
    5030:	48010000 	stmdami	r1, {}	; <UNPREDICTABLE>

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );

    last = ctx->total[0] & 0x3F;
    5034:	0000060c 	andeq	r0, r0, ip, lsl #12
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    5038:	00012a17 	andeq	r2, r1, r7, lsl sl

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    503c:	0017d300 	andseq	sp, r7, r0, lsl #6
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    5040:	f0270000 			; <UNDEFINED> instruction: 0xf0270000

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    5044:	71000004 	tstvc	r0, r4
    5048:	28000006 	stmdacs	r0, {r1, r2}
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    504c:	000001a3 	andeq	r0, r0, r3, lsr #3
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    5050:	0000193b 	andeq	r1, r0, fp, lsr r9
{
    uint32 last, padn;
    uint32 high, low;
    uint8 msglen[8];

    high = ( ctx->total[0] >> 29 )
    5054:	001dd01a 	andseq	sp, sp, sl, lsl r0
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    5058:	000a9600 	andeq	r9, sl, r0, lsl #12
    505c:	00063a00 	andeq	r3, r6, r0, lsl #20
    5060:	51011b00 	tstpl	r1, r0, lsl #22
    PUT_UINT32( low,  msglen, 4 );
    5064:	7ee09103 	urdvcs	f1, f3
    5068:	0350011b 	cmpeq	r0, #-1073741818	; 0xc0000006

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;
    506c:	007de091 			; <UNDEFINED> instruction: 0x007de091
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    5070:	001dec1a 	andseq	lr, sp, sl, lsl ip

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    5074:	000a9600 	andeq	r9, sl, r0, lsl #12
    5078:	00064f00 	andeq	r4, r6, r0, lsl #30
    507c:	50011b00 	andpl	r1, r1, r0, lsl #22
    5080:	7de09103 	stfvcp	f1, [r0, #12]!
    PUT_UINT32( low,  msglen, 4 );
    5084:	1dfe1c00 	ldclne	12, cr1, [lr]
    5088:	0a040000 	beq	105090 <_etext+0xfdb78>
    508c:	011b0000 	tsteq	fp, r0

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;
    5090:	c0780352 	rsbsgt	r0, r8, r2, asr r3

    if( left && length >= fill )
    5094:	51011b00 	tstpl	r1, r0, lsl #22
    5098:	74007905 	strvc	r7, [r0], #-2309	; 0x905
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    509c:	011b2200 	tsteq	fp, r0, lsl #4
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    50a0:	e0910350 	adds	r0, r1, r0, asr r3
    50a4:	1a00007d 	bne	52a0 <sha512_block+0x60>
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    50a8:	00001e0a 	andeq	r1, r0, sl, lsl #28
    {
        memcpy( (void *) (ctx->buffer + left),
    50ac:	00000aac 	andeq	r0, r0, ip, lsr #21
    50b0:	00000692 	muleq	r0, r2, r6
    50b4:	0252011b 	subseq	r0, r2, #-1073741818	; 0xc0000006
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    50b8:	011b0078 	tsteq	fp, r8, ror r0
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    50bc:	00790251 	rsbseq	r0, r9, r1, asr r2
{
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    50c0:	0350011b 	cmpeq	r0, #-1073741818	; 0xc0000006
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    50c4:	007fa091 			; <UNDEFINED> instruction: 0x007fa091
        ctx->total[1]++;
    50c8:	001e161a 	andseq	r1, lr, sl, lsl r6

    if( left && length >= fill )
    50cc:	000a0400 	andeq	r0, sl, r0, lsl #8
    50d0:	0006b400 	andeq	fp, r6, r0, lsl #8
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    50d4:	52011b00 	andpl	r1, r1, #0, 22
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    50d8:	00c07803 	sbceq	r7, r0, r3, lsl #16
    50dc:	0351011b 	cmpeq	r1, #-1073741818	; 0xc0000006
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    50e0:	1b7ee091 	blne	1fbd32c <_etext+0x1fb5e14>
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    50e4:	74025001 	strvc	r5, [r2], #-1
    50e8:	221a0050 	andscs	r0, sl, #80	; 0x50
    50ec:	1f00001e 	svcne	0x0000001e
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    sha256_update( ctx, sha256_padding, padn );
    sha256_update( ctx, msglen, 8 );

    PUT_UINT32( ctx->state[0], digest,  0 );
    50f0:	db00000a 	blle	5120 <sha256_finish+0xf8>
    50f4:	1b000006 	blne	5114 <sha256_finish+0xec>
    50f8:	08025301 	stmdaeq	r2, {r0, r8, r9, ip, lr}
    50fc:	52011b40 	andpl	r1, r1, #64, 22	; 0x10000
    5100:	011b3001 	tsteq	fp, r1
    PUT_UINT32( ctx->state[1], digest,  4 );
    5104:	e0910351 	adds	r0, r1, r1, asr r3
    5108:	50011b7e 	andpl	r1, r1, lr, ror fp
    510c:	7de09103 	stfvcp	f1, [r0, #12]!
    5110:	1e2e1c00 	cdpne	12, 2, cr1, cr14, cr0, {0}
    PUT_UINT32( ctx->state[2], digest,  8 );
    5114:	0ad00000 	beq	ff40511c <BootRAM+0xe3758bd>
    5118:	011b0000 	tsteq	fp, r0
    511c:	c4030553 	strgt	r0, [r3], #-1363	; 0x553
    5120:	1b000071 	blne	52ec <sha512_block+0xac>
    5124:	08025201 	stmdaeq	r2, {r0, r9, ip, lr}
    PUT_UINT32( ctx->state[3], digest, 12 );
    5128:	51011b40 	tstpl	r1, r0, asr #22
    512c:	7ee09103 	urdvcs	f1, f3
    5130:	0350011b 	cmpeq	r0, #-1073741818	; 0xc0000006
    5134:	007d8091 			; <UNDEFINED> instruction: 0x007d8091
    PUT_UINT32( ctx->state[4], digest, 16 );
    5138:	00000000 	andeq	r0, r0, r0
    513c:	0001e51e 	andeq	lr, r1, lr, lsl r5
    5140:	001e2e00 	andseq	r2, lr, r0, lsl #28
    5144:	00002000 	andeq	r2, r0, r0
    5148:	d99a0100 	ldmible	sl, {r8}
    PUT_UINT32( ctx->state[5], digest, 20 );
    514c:	17000007 	strne	r0, [r0, -r7]
    5150:	000001fa 	strdeq	r0, [r0], -sl
    5154:	0000197e 	andeq	r1, r0, lr, ror r9
    5158:	0001f117 	andeq	pc, r1, r7, lsl r1	; <UNPREDICTABLE>
    PUT_UINT32( ctx->state[6], digest, 24 );
    515c:	0019ab00 	andseq	sl, r9, r0, lsl #22
    5160:	1e2e1f00 	cdpne	15, 2, cr1, cr14, cr0, {0}
    5164:	00200000 	eoreq	r0, r0, r0
    5168:	03190000 	tsteq	r9, #0
    516c:	03000002 	movweq	r0, #2
    PUT_UINT32( ctx->state[7], digest, 28 );
    5170:	1e7ee091 	mrcne	0, 3, lr, cr14, cr1, {4}
    5174:	0000020d 	andeq	r0, r0, sp, lsl #4
    5178:	00001e3a 	andeq	r1, r0, sl, lsr lr
    517c:	00000014 	andeq	r0, r0, r4, lsl r0
    5180:	07c03701 	strbeq	r3, [r0, r1, lsl #14]
    5184:	23170000 	tstcs	r7, #0
    5188:	cc000002 	stcgt	0, cr0, [r0], {2}
    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
    518c:	17000019 	smladne	r0, r9, r0, r0
    5190:	00000218 	andeq	r0, r0, r8, lsl r2
    5194:	00001a5f 	andeq	r1, r0, pc, asr sl
    5198:	001e3a1f 	andseq	r3, lr, pc, lsl sl
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    519c:	00001400 	andeq	r1, r0, r0, lsl #8
    51a0:	022c1900 	eoreq	r1, ip, #0, 18
        length -= fill;
    51a4:	91030000 	mrsls	r0, (UNDEF: 3)

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    51a8:	35197dc0 	ldrcc	r7, [r9, #-3520]	; 0xdc0
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    51ac:	03000002 	movweq	r0, #2
    51b0:	1a7de091 	bne	1f7d3fc <_etext+0x1f75ee4>
    51b4:	00001e44 	andeq	r1, r0, r4, asr #28
    {
        sha256_process( ctx, input );
        length -= 64;
    51b8:	00000a45 	andeq	r0, r0, r5, asr #20
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    51bc:	000007a0 	andeq	r0, r0, r0, lsr #15
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    51c0:	0352011b 	cmpeq	r2, #-1073741818	; 0xc0000006
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    51c4:	1b7ee091 	blne	1fbd410 <_etext+0x1fb5ef8>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    51c8:	91035101 	tstls	r3, r1, lsl #2
    51cc:	011b7de0 	tsteq	fp, r0, ror #27
    51d0:	c0910350 	addsgt	r0, r1, r0, asr r3
    51d4:	4e1c007d 	mrcmi	0, 0, r0, cr12, cr13, {3}
    51d8:	6000001e 	andvs	r0, r0, lr, lsl r0
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    51dc:	1b00000a 	blne	520c <sha256_finish+0x1e4>
    51e0:	91035201 	tstls	r3, r1, lsl #4
    {
        memcpy( (void *) (ctx->buffer + left),
    51e4:	011b7de0 	tsteq	fp, r0, ror #27
    51e8:	c0910351 	addsgt	r0, r1, r1, asr r3
    51ec:	50011b7d 	andpl	r1, r1, sp, ror fp
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
    51f0:	00007d02 	andeq	r7, r0, r2, lsl #26
        input  += fill;
    51f4:	3a1c0000 	bcc	7051fc <_etext+0x6fdce4>

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    51f8:	7b00001e 	blvc	5278 <sha512_block+0x38>
        length -= fill;
        input  += fill;
    51fc:	1b00000a 	blne	522c <sha256_finish+0x204>

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    5200:	76025201 	strvc	r5, [r2], -r1, lsl #4
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5204:	50011b20 	andpl	r1, r1, r0, lsr #22
    {
        sha256_process( ctx, input );
    5208:	7ee09103 	urdvcs	f1, f3
    520c:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    5210:	0000046f 	andeq	r0, r0, pc, ror #8
        length -= 64;
        input  += 64;
    5214:	00001e4e 	andeq	r1, r0, lr, asr #28
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5218:	00000016 	andeq	r0, r0, r6, lsl r0
    521c:	08659d01 	stmdaeq	r5!, {r0, r8, sl, fp, ip, pc}^
    5220:	88170000 	ldmdahi	r7, {}	; <UNPREDICTABLE>
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    5224:	80000004 	andhi	r0, r0, r4
    }

    while( length >= 64 )
    5228:	1700001a 	smladne	r0, sl, r0, r0
    522c:	0000047f 	andeq	r0, r0, pc, ror r4
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    5230:	00001a93 	muleq	r0, r3, sl
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    5234:	001e4e1f 	andseq	r4, lr, pc, lsl lr
    5238:	00001600 	andeq	r1, r0, r0, lsl #12
    523c:	04931900 	ldreq	r1, [r3], #2304	; 0x900
{
	return (x >> bits) | (x << (64 - bits));
}

void sha512_block(struct sha512_state *s, const uint8_t *blk)
{
    5240:	91030000 	mrsls	r0, (UNDEF: 3)
    5244:	9c197dc0 	ldcls	13, cr7, [r9], {192}	; 0xc0
    5248:	03000004 	movweq	r0, #4
    524c:	287ee091 	ldmdacs	lr!, {r0, r4, r7, sp, lr, pc}^

static inline uint64_t load64(const uint8_t *x)
{
	uint64_t r;

	r = *(x++);
    5250:	000004a5 	andeq	r0, r0, r5, lsr #9
	r = (r << 8) | *(x++);
    5254:	00001b0d 	andeq	r1, r0, sp, lsl #22
    5258:	001e581a 	andseq	r5, lr, sl, lsl r8
    525c:	000af000 	andeq	pc, sl, r0
    5260:	00084400 	andeq	r4, r8, r0, lsl #8
    5264:	52011b00 	andpl	r1, r1, #0, 22
	r = (r << 8) | *(x++);
    5268:	1b007702 	blne	22e78 <_etext+0x1b960>
    526c:	91035101 	tstls	r3, r1, lsl #2
    5270:	011b7ee0 	tsteq	fp, r0, ror #29
    5274:	c0910350 	addsgt	r0, r1, r0, asr r3
	r = (r << 8) | *(x++);
    5278:	641c007d 	ldrvs	r0, [ip], #-125	; 0x7d
    527c:	0f00001e 	svceq	0x0000001e
    5280:	1b00000b 	blne	52b4 <sha512_block+0x74>
    5284:	91035201 	tstls	r3, r1, lsl #4
    5288:	011b7ee0 	tsteq	fp, r0, ror #29
    528c:	c0910351 	addsgt	r0, r1, r1, asr r3
    5290:	50011b7d 	andpl	r1, r1, sp, ror fp
    5294:	7de09103 	stfvcp	f1, [r0, #12]!
	r = (r << 8) | *(x++);
    5298:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    529c:	0000046f 	andeq	r0, r0, pc, ror #8
    52a0:	00001e6e 	andeq	r1, r0, lr, ror #28
    52a4:	00000016 	andeq	r0, r0, r6, lsl r0
    52a8:	08f19f01 	ldmeq	r1!, {r0, r8, r9, sl, fp, ip, pc}^
    52ac:	88170000 	ldmdahi	r7, {}	; <UNPREDICTABLE>
    52b0:	2b000004 	blcs	52c8 <sha512_block+0x88>
    52b4:	1700001b 	smladne	r0, fp, r0, r0
	r = (r << 8) | *(x++);
    52b8:	0000047f 	andeq	r0, r0, pc, ror r4
    52bc:	00001b3e 	andeq	r1, r0, lr, lsr fp
    52c0:	001e6e1f 	andseq	r6, lr, pc, lsl lr
    52c4:	00001600 	andeq	r1, r0, r0, lsl #12
    52c8:	04931900 	ldreq	r1, [r3], #2304	; 0x900
    52cc:	91030000 	mrsls	r0, (UNDEF: 3)
	r = (r << 8) | *(x++);
    52d0:	9c197da0 	ldcls	13, cr7, [r9], {160}	; 0xa0
    52d4:	03000004 	movweq	r0, #4
    52d8:	287dc091 	ldmdacs	sp!, {r0, r4, r7, lr, pc}^
    52dc:	000004a5 	andeq	r0, r0, r5, lsr #9
    52e0:	00001b86 	andeq	r1, r0, r6, lsl #23
    52e4:	001e781a 	andseq	r7, lr, sl, lsl r8
	r = (r << 8) | *(x++);
    52e8:	000af000 	andeq	pc, sl, r0
    52ec:	0008d000 	andeq	sp, r8, r0
    52f0:	52011b00 	andpl	r1, r1, #0, 22
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
		w[i] = load64(blk);
		blk += 8;
    52f4:	1b007602 	blne	22b04 <_etext+0x1b5ec>
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
    52f8:	91035101 	tstls	r3, r1, lsl #2
	uint64_t w[16];
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
		w[i] = load64(blk);
    52fc:	011b7dc0 	tsteq	fp, r0, asr #27
{
	uint64_t w[16];
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
    5300:	a0910350 	addsge	r0, r1, r0, asr r3
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    5304:	841c007d 	ldrhi	r0, [ip], #-125	; 0x7d
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
    5308:	0f00001e 	svceq	0x0000001e
    530c:	1b00000b 	blne	5340 <sha512_block+0x100>
	c = s->h[2];
    5310:	91035201 	tstls	r3, r1, lsl #4
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    5314:	011b7dc0 	tsteq	fp, r0, asr #27
	b = s->h[1];
    5318:	a0910351 	addsge	r0, r1, r1, asr r3
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    531c:	50011b7d 	andpl	r1, r1, sp, ror fp
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    5320:	7ee09103 	urdvcs	f1, f3
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    5324:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    5328:	0000020d 	andeq	r0, r0, sp, lsl #4
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    532c:	00001e8e 	andeq	r1, r0, lr, lsl #29
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    5330:	00000014 	andeq	r0, r0, r4, lsl r0
    5334:	0975a101 	ldmdbeq	r5!, {r0, r8, sp, pc}^

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    5338:	23170000 	tstcs	r7, #0
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    533c:	a4000002 	strge	r0, [r0], #-2
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
    5340:	1700001b 	smladne	r0, fp, r0, r0
	f = s->h[5];
    5344:	00000218 	andeq	r0, r0, r8, lsl r2

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    5348:	00001bd3 	ldrdeq	r1, [r0], -r3
	e = s->h[4];
    534c:	001e8e1f 	andseq	r8, lr, pc, lsl lr
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    5350:	00001400 	andeq	r1, r0, r0, lsl #8
    5354:	022c1900 	eoreq	r1, ip, #0, 18

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    5358:	91030000 	mrsls	r0, (UNDEF: 3)
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    535c:	35197da0 	ldrcc	r7, [r9, #-3488]	; 0xda0

	for (i = 0; i < 80; i++) {
    5360:	03000002 	movweq	r0, #2
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
    5364:	1a7dc091 	bne	1f755b0 <_etext+0x1f6e098>
	g = s->h[6];
    5368:	00001e98 	muleq	r0, r8, lr
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
    536c:	00000a45 	andeq	r0, r0, r5, asr #20
    5370:	00000954 	andeq	r0, r0, r4, asr r9
	g = s->h[6];
	h = s->h[7];
    5374:	0352011b 	cmpeq	r2, #-1073741818	; 0xc0000006
    5378:	1b7de091 	blne	1f7d5c4 <_etext+0x1f760ac>
    537c:	91035101 	tstls	r3, r1, lsl #2
	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
    5380:	011b7dc0 	tsteq	fp, r0, asr #27
    5384:	a0910350 	addsge	r0, r1, r0, asr r3
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    5388:	a21c007d 	andsge	r0, ip, #125	; 0x7d
    538c:	6000001e 	andvs	r0, r0, lr, lsl r0
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    5390:	1b00000a 	blne	53c0 <sha512_block+0x180>
	h = s->h[7];
    5394:	91035201 	tstls	r3, r1, lsl #4
    5398:	011b7dc0 	tsteq	fp, r0, asr #27

		/* Update round state */
		h = g;
		g = f;
		f = e;
		e = d + temp1;
    539c:	a0910351 	addsge	r0, r1, r1, asr r3
    53a0:	50011b7d 	andpl	r1, r1, sp, ror fp
    53a4:	7ce09103 	stfvcp	f1, [r0], #12
    53a8:	1a000000 	bne	53b0 <sha512_block+0x170>
    53ac:	00001e6e 	andeq	r1, r0, lr, ror #28
    53b0:	00000a7b 	andeq	r0, r0, fp, ror sl
    53b4:	00000998 	muleq	r0, r8, r9
    53b8:	0352011b 	cmpeq	r2, #-1073741818	; 0xc0000006
    53bc:	1b7d8091 	blne	1f65608 <_etext+0x1f5e0f0>
    53c0:	91035101 	tstls	r3, r1, lsl #2
    53c4:	011b7de0 	tsteq	fp, r0, ror #27
    53c8:	e0910350 	adds	r0, r1, r0, asr r3
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
    53cc:	8e1a007d 	mrchi	0, 0, r0, cr10, cr13, {3}
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
    53d0:	2a00001e 	bcs	5450 <sha512_block+0x210>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    53d4:	bb00000b 	bllt	5408 <sha512_block+0x1c8>
    53d8:	1b000009 	blne	5404 <sha512_block+0x1c4>
    53dc:	91035201 	tstls	r3, r1, lsl #4
    53e0:	011b7ee0 	tsteq	fp, r0, ror #29
    53e4:	e0910351 	adds	r0, r1, r1, asr r3
    53e8:	50011b7d 	andpl	r1, r1, sp, ror fp
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    53ec:	7de09103 	stfvcp	f1, [r0, #12]!
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    53f0:	1eaa1c00 	cdpne	12, 10, cr1, cr10, cr0, {0}
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    53f4:	0b450000 	bleq	11453fc <_etext+0x113dee4>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    53f8:	011b0000 	tsteq	fp, r0
    53fc:	e0910351 	adds	r0, r1, r1, asr r3
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    5400:	50011b7c 	andpl	r1, r1, ip, ror fp
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5404:	00007d02 	andeq	r7, r0, r2, lsl #26
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    5408:	17681500 	strbne	r1, [r8, -r0, lsl #10]!
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    540c:	0e010000 	cdpeq	0, 0, cr0, cr1, cr0, {0}
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5410:	000009e4 	andeq	r0, r0, r4, ror #19
    5414:	71c40305 	bicvc	r0, r4, r5, lsl #6
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5418:	e7100000 	ldr	r0, [r0, -r0]
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    541c:	29000000 	stmdbcs	r0, {}	; <UNPREDICTABLE>
    5420:	00001699 	muleq	r0, r9, r6
    5424:	02452703 	subeq	r2, r5, #786432	; 0xc0000
    5428:	fe290000 	cdp2	0, 2, cr0, cr9, cr0, {0}
    542c:	02000016 	andeq	r0, r0, #22

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    5430:	0009ff19 	andeq	pc, r9, r9, lsl pc	; <UNPREDICTABLE>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5434:	00f71000 	rscseq	r1, r7, r0
    5438:	c72a0000 	strgt	r0, [sl, -r0]!
    543c:	02000016 	andeq	r0, r0, #22

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    5440:	000a1f2b 	andeq	r1, sl, fp, lsr #30
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5444:	01342b00 	teqeq	r4, r0, lsl #22
    5448:	ae2b0000 	cdpge	0, 2, cr0, cr11, cr0, {0}
    544c:	2b000001 	blcs	5458 <sha512_block+0x218>
    5450:	00000097 	muleq	r0, r7, r0

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    5454:	17132a00 	ldrne	r2, [r3, -r0, lsl #20]
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5458:	31020000 	mrscc	r0, (UNDEF: 2)
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    545c:	00000a3f 	andeq	r0, r0, pc, lsr sl
    5460:	000a3f2b 	andeq	r3, sl, fp, lsr #30
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5464:	01502b00 	cmpeq	r0, r0, lsl #22
    5468:	7a2b0000 	bvc	ac5470 <_etext+0xabdf58>
    546c:	2b000000 	blcs	5474 <sha512_block+0x234>
    5470:	0000007a 	andeq	r0, r0, sl, ror r0
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5474:	ff040c00 			; <UNDEFINED> instruction: 0xff040c00
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5478:	2a000009 	bcs	54a4 <sha512_block+0x264>
    547c:	00001646 	andeq	r1, r0, r6, asr #12
    5480:	0a602e03 	beq	1810c94 <_etext+0x180977c>
    5484:	502b0000 	eorpl	r0, fp, r0
    5488:	2b000001 	blcs	5494 <sha512_block+0x254>
    548c:	00000150 	andeq	r0, r0, r0, asr r1
    5490:	00023f2b 	andeq	r3, r2, fp, lsr #30
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
    5494:	d92a0000 	stmdble	sl!, {}	; <UNPREDICTABLE>
    5498:	03000015 	movweq	r0, #21
    549c:	000a7b37 	andeq	r7, sl, r7, lsr fp
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
    54a0:	01502b00 	cmpeq	r0, r0, lsl #22
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    54a4:	ae2b0000 	cdpge	0, 2, cr0, cr11, cr0, {0}

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
    54a8:	2b000001 	blcs	54b4 <sha512_block+0x274>
    54ac:	000001ae 	andeq	r0, r0, lr, lsr #3
    54b0:	162c2a00 	strtne	r2, [ip], -r0, lsl #20
    54b4:	4f030000 	svcmi	0x00030000
    54b8:	00000a96 	muleq	r0, r6, sl
    54bc:	0004b02b 	andeq	fp, r4, fp, lsr #32
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    54c0:	023f2b00 	eorseq	r2, pc, #0, 22
	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
    54c4:	ae2b0000 	cdpge	0, 2, cr0, cr11, cr0, {0}
    54c8:	00000001 	andeq	r0, r0, r1
    54cc:	0017e72a 	andseq	lr, r7, sl, lsr #14
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    54d0:	ac240200 	sfmge	f0, 4, [r4], #-0
    54d4:	2b00000a 	blcs	5504 <sha512_block+0x2c4>
    54d8:	00000134 	andeq	r0, r0, r4, lsr r1
    54dc:	0001ae2b 	andeq	sl, r1, fp, lsr #28
    54e0:	d22c0000 	eorle	r0, ip, #0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54e4:	a9000015 	stmdbge	r0, {r0, r2, r4}
    54e8:	c9000000 	stmdbgt	r0, {}	; <UNPREDICTABLE>
    54ec:	2b00000a 	blcs	551c <sha512_block+0x2dc>
    54f0:	000000a9 	andeq	r0, r0, r9, lsr #1
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    54f4:	000ac92b 	andeq	ip, sl, fp, lsr #18
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54f8:	00a22b00 	adceq	r2, r2, r0, lsl #22
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    54fc:	0c000000 	stceq	0, cr0, [r0], {-0}
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5500:	000acf04 	andeq	ip, sl, r4, lsl #30
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5504:	762a2d00 	strtvc	r2, [sl], -r0, lsl #26
    5508:	07000017 	smladeq	r0, r7, r0, r0
    550c:	000af021 	andeq	pc, sl, r1, lsr #32
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
    5510:	01502b00 	cmpeq	r0, r0, lsl #22
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    5514:	ae2b0000 	cdpge	0, 2, cr0, cr11, cr0, {0}
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
    5518:	2b000001 	blcs	5524 <sha512_block+0x2e4>
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    551c:	00000097 	muleq	r0, r7, r0
    5520:	0001ae2b 	andeq	sl, r1, fp, lsr #28
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
    5524:	f92e0000 			; <UNDEFINED> instruction: 0xf92e0000
    5528:	03000015 	movweq	r0, #21
    552c:	00008138 	andeq	r8, r0, r8, lsr r1
    5530:	000b0f00 	andeq	r0, fp, r0, lsl #30
    5534:	01502b00 	cmpeq	r0, r0, lsl #22
    5538:	502b0000 	eorpl	r0, fp, r0
    553c:	2b000001 	blcs	5548 <sha512_block+0x308>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5540:	000001ae 	andeq	r0, r0, lr, lsr #3

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5544:	160c2a00 	strne	r2, [ip], -r0, lsl #20
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5548:	2b030000 	blcs	c5550 <_etext+0xbe038>

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    554c:	00000b2a 	andeq	r0, r0, sl, lsr #22
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5550:	0004b02b 	andeq	fp, r4, fp, lsr #32

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5554:	01ae2b00 			; <UNDEFINED> instruction: 0x01ae2b00
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5558:	ae2b0000 	cdpge	0, 2, cr0, cr11, cr0, {0}

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    555c:	00000001 	andeq	r0, r0, r1
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5560:	0015ed2a 	andseq	lr, r5, sl, lsr #26
    5564:	454c0300 	strbmi	r0, [ip, #-768]	; 0x300
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5568:	2b00000b 	blcs	559c <sha512_block+0x35c>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    556c:	000004b0 			; <UNDEFINED> instruction: 0x000004b0
    5570:	00023f2b 	andeq	r3, r2, fp, lsr #30

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5574:	023f2b00 	eorseq	r2, pc, #0, 22
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5578:	2f000000 	svccs	0x00000000
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    557c:	000015c2 	andeq	r1, r0, r2, asr #11
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5580:	00812d08 	addeq	r2, r1, r8, lsl #26
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5584:	ae2b0000 	cdpge	0, 2, cr0, cr11, cr0, {0}
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5588:	2b000001 	blcs	5594 <sha512_block+0x354>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    558c:	000001ae 	andeq	r0, r0, lr, lsr #3
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
    5590:	0fa30000 	svceq	0x00a30000
    5594:	00040000 	andeq	r0, r4, r0
    5598:	0000149a 	muleq	r0, sl, r4
    559c:	14b40104 	ldrtne	r0, [r4], #260	; 0x104
    55a0:	08010000 	stmdaeq	r1, {}	; <UNPREDICTABLE>
    55a4:	93000018 	movwls	r0, #24
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55a8:	60000008 	andvs	r0, r0, r8

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55ac:	00000006 	andeq	r0, r0, r6
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55b0:	1c000000 	stcne	0, cr0, [r0], {-0}

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55b4:	02000017 	andeq	r0, r0, #23
    55b8:	081a0601 	ldmdaeq	sl, {r0, r9, sl}
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    55bc:	01030000 	mrseq	r0, (UNDEF: 3)

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55c0:	0300000b 	movweq	r0, #11
    55c4:	0000371c 	andeq	r3, r0, ip, lsl r7
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    55c8:	08010200 	stmdaeq	r1, {r9}
    55cc:	00000818 	andeq	r0, r0, r8, lsl r8
    55d0:	fc050202 	stc2	2, cr0, [r5], {2}
    55d4:	03000006 	movweq	r0, #6
    55d8:	00000daf 	andeq	r0, r0, pc, lsr #27

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55dc:	00502603 	subseq	r2, r0, r3, lsl #12
    55e0:	02020000 	andeq	r0, r2, #0
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
		const uint64_t temp2 = S0 + maj;
    55e4:	00094907 	andeq	r4, r9, r7, lsl #18
    55e8:	05040200 	streq	r0, [r4, #-512]	; 0x200
    55ec:	000004da 	ldrdeq	r0, [r0], -sl

		/* Update round state */
		h = g;
		g = f;
		f = e;
		e = d + temp1;
    55f0:	000ace03 	andeq	ip, sl, r3, lsl #28
    55f4:	69380300 	ldmdbvs	r8!, {r8, r9}
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
    55f8:	02000000 	andeq	r0, r0, #0
    55fc:	02520704 	subseq	r0, r2, #4, 14	; 0x100000
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
    5600:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    5604:	0004d505 	andeq	sp, r4, r5, lsl #10
    5608:	07080200 	streq	r0, [r8, -r0, lsl #4]
    560c:	0000024d 	andeq	r0, r0, sp, asr #4
    5610:	69050404 	stmdbvs	r5, {r2, sl}
    5614:	0200746e 	andeq	r7, r0, #1845493760	; 0x6e000000
    5618:	02570704 	subseq	r0, r7, #4, 14	; 0x100000
    561c:	03030000 	movweq	r0, #12288	; 0x3000
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5620:	0400000b 	streq	r0, [r0], #-11
    5624:	00002c2a 	andeq	r2, r0, sl, lsr #24
	s->h[1] += b;
    5628:	0db10300 	ldceq	3, cr0, [r1]
    562c:	36040000 	strcc	r0, [r4], -r0
    5630:	00000045 	andeq	r0, r0, r5, asr #32
	s->h[2] += c;
    5634:	000ad003 	andeq	sp, sl, r3
    5638:	5e420400 	cdppl	4, 4, cr0, cr2, cr0, {0}
    563c:	02000000 	andeq	r0, r0, #0
    5640:	078b0704 	streq	r0, [fp, r4, lsl #14]
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5644:	04050000 	streq	r0, [r5], #-0
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    5648:	21080102 	tstcs	r8, r2, lsl #2
	s->h[4] += e;
    564c:	06000008 	streq	r0, [r0], -r8
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
    5650:	0000159d 	muleq	r0, sp, r5
	s->h[2] += c;
	s->h[3] += d;
    5654:	0a014b01 	beq	58260 <_etext+0x50d48>
    5658:	07000001 	streq	r0, [r0, -r1]
    565c:	00747364 	rsbseq	r7, r4, r4, ror #6
	s->h[4] += e;
    5660:	010a4b01 	tsteq	sl, r1, lsl #22
	s->h[5] += f;
	s->h[6] += g;
    5664:	fb080000 	blx	20566e <_etext+0x1fe156>
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
    5668:	01000017 	tsteq	r0, r7, lsl r0
    566c:	0001104c 	andeq	r1, r1, ip, asr #32
    5670:	6e6f0700 	cdpvs	7, 6, cr0, cr15, cr0, {0}
	s->h[6] += g;
    5674:	4c010065 	stcmi	0, cr0, [r1], {101}	; 0x65

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    5678:	00000110 	andeq	r0, r0, r0, lsl r1
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    567c:	00182d08 	andseq	r2, r8, r8, lsl #26
	s->h[7] += h;
    5680:	8c4d0100 	stfhie	f0, [sp], {-0}
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5684:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    5688:	00000d27 	andeq	r0, r0, r7, lsr #26
	s->h[7] += h;
    568c:	01164f01 	tsteq	r6, r1, lsl #30
    5690:	690a0000 	stmdbvs	sl, {}	; <UNPREDICTABLE>
    5694:	7e500100 	rdfvcs	f0, f0, f0
    5698:	00000000 	andeq	r0, r0, r0
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
    569c:	008c040b 	addeq	r0, ip, fp, lsl #8
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    56a0:	040b0000 	streq	r0, [fp], #-0
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    56a4:	00000116 	andeq	r0, r0, r6, lsl r1
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    56a8:	00008c0c 	andeq	r8, r0, ip, lsl #24
	s->h[1] += b;
    56ac:	14600d00 	strbtne	r0, [r0], #-3328	; 0xd00
	s->h[2] += c;
	s->h[3] += d;
    56b0:	22020000 	andcs	r0, r2, #0
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
    56b4:	00013a03 	andeq	r3, r1, r3, lsl #20
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
    56b8:	00780700 	rsbseq	r0, r8, r0, lsl #14
	s->h[5] += f;
    56bc:	010a2202 	tsteq	sl, r2, lsl #4
	s->h[6] += g;
    56c0:	61070000 	mrsvs	r0, (UNDEF: 7)
	s->h[7] += h;
    56c4:	10220200 	eorne	r0, r2, r0, lsl #4
}
    56c8:	00000001 	andeq	r0, r0, r1
    56cc:	00163a06 	andseq	r3, r6, r6, lsl #20
    56d0:	010c0100 	mrseq	r0, (UNDEF: 28)

void sha512_final(struct sha512_state *s, const uint8_t *blk,
		  size_t total_size)
{
    56d4:	00000162 	andeq	r0, r0, r2, ror #2
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
    56d8:	01007807 	tsteq	r0, r7, lsl #16
	s->h[7] += h;
}

void sha512_final(struct sha512_state *s, const uint8_t *blk,
		  size_t total_size)
{
    56dc:	00010a0c 	andeq	r0, r1, ip, lsl #20
    56e0:	00630700 	rsbeq	r0, r3, r0, lsl #14
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
    56e4:	00a20c01 	adceq	r0, r2, r1, lsl #24
    56e8:	690a0000 	stmdbvs	sl, {}	; <UNPREDICTABLE>
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
    56ec:	7e0e0100 	adfvce	f0, f6, f0
    56f0:	00000000 	andeq	r0, r0, r0
		memcpy(temp, blk, last_size);
	temp[last_size] = 0x80;
    56f4:	00013a0e 	andeq	r3, r1, lr, lsl #20

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    56f8:	001ec800 	andseq	ip, lr, r0, lsl #16
    56fc:	00001e00 	andeq	r1, r0, r0, lsl #28
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5700:	ae9c0100 	fmlgee	f0, f4, f0
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
	sha512_block(s, temp);
    5704:	0f000001 	svceq	0x00000001
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5708:	00000146 	andeq	r0, r0, r6, asr #2
	v >>= 8;
	*(x--) = v;
    570c:	00001c1b 	andeq	r1, r0, fp, lsl ip
	v >>= 8;
	*(x--) = v;
    5710:	00014f0f 	andeq	r4, r1, pc, lsl #30
	v >>= 8;
	*(x--) = v;
    5714:	001c4900 	andseq	r4, ip, r0, lsl #18
	v >>= 8;
	*(x--) = v;
    5718:	01581000 	cmpeq	r8, r0
	v >>= 8;
	*(x--) = v;
    571c:	1c9b0000 	ldcne	0, cr0, [fp], {0}
	v >>= 8;
	*(x--) = v;
    5720:	e6110000 	ldr	r0, [r1], -r0
	v >>= 8;
	*(x--) = v;
    5724:	8d00001e 	stchi	0, cr0, [r0, #-120]	; 0xffffff88
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
	sha512_block(s, temp);
    5728:	1200000f 	andne	r0, r0, #15
}
    572c:	4c015201 	sfmmi	f5, 4, [r1], {1}
{
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
		memcpy(temp, blk, last_size);
    5730:	01510112 	cmpeq	r1, r2, lsl r1
    5734:	50011230 	andpl	r1, r1, r0, lsr r2
    5738:	5001f305 	andpl	pc, r1, r5, lsl #6
	temp[last_size] = 0x80;
    573c:	00000423 	andeq	r0, r0, r3, lsr #8

	if (last_size > 111) {
    5740:	00156213 	andseq	r6, r5, r3, lsl r2
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
		memcpy(temp, blk, last_size);
	temp[last_size] = 0x80;
    5744:	e8190100 	ldmda	r9, {r8}

	if (last_size > 111) {
		sha512_block(s, temp);
    5748:	6e00001e 	mcrvs	0, 0, r0, cr0, cr14, {0}
    574c:	01000000 	mrseq	r0, (UNDEF: 0)
		memset(temp, 0, sizeof(temp));
    5750:	00023d9c 	muleq	r2, ip, sp
    5754:	00781400 	rsbseq	r1, r8, r0, lsl #8
    5758:	010a1901 	tsteq	sl, r1, lsl #18
	sha512_block(s, temp);
}

void sha512_get(const struct sha512_state *s, uint8_t *hash,
		unsigned int offset, unsigned int len)
{
    575c:	50010000 	andpl	r0, r1, r0
	int i;

	if (offset > SHA512_BLOCK_SIZE)
    5760:	00183715 	andseq	r3, r8, r5, lsl r7
	sha512_block(s, temp);
}

void sha512_get(const struct sha512_state *s, uint8_t *hash,
		unsigned int offset, unsigned int len)
{
    5764:	3d1b0100 	ldfccs	f0, [fp, #-0]
	int i;

	if (offset > SHA512_BLOCK_SIZE)
    5768:	02000002 	andeq	r0, r0, #2
		return;

	if (len > SHA512_BLOCK_SIZE - offset)
    576c:	63165891 	tstvs	r6, #9502720	; 0x910000
    5770:	971c0100 	ldrls	r0, [ip, -r0, lsl #2]
		len = SHA512_BLOCK_SIZE - offset;

	/* Skip whole words */
	i = offset >> 3;
    5774:	d3000000 	movwle	r0, #0
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
    5778:	1600001c 			; <UNDEFINED> instruction: 0x1600001c

	if (len > SHA512_BLOCK_SIZE - offset)
		len = SHA512_BLOCK_SIZE - offset;

	/* Skip whole words */
	i = offset >> 3;
    577c:	1d010069 	stcne	0, cr0, [r1, #-420]	; 0xfffffe5c
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
    5780:	0000007e 	andeq	r0, r0, lr, ror r0
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    5784:	00001cf1 	strdeq	r1, [r0], -r1	; <UNPREDICTABLE>
    5788:	0000bd17 	andeq	fp, r0, r7, lsl sp
    578c:	001f2800 	andseq	r2, pc, r0, lsl #16
    5790:	00052000 	andeq	r2, r5, r0
    5794:	0f390100 	svceq	0x00390100
    5798:	000000ea 	andeq	r0, r0, sl, ror #1
    579c:	00001d3f 	andeq	r1, r0, pc, lsr sp
    57a0:	0000df18 	andeq	sp, r0, r8, lsl pc
    57a4:	0f500100 	svceq	0x00500100
    57a8:	000000d4 	ldrdeq	r0, [r0], -r4
		store64(hash, s->h[i++]);
    57ac:	00001d56 	andeq	r1, r0, r6, asr sp
    57b0:	0000c918 	andeq	ip, r0, r8, lsl r9
    57b4:	19500100 	ldmdbne	r0, {r8}^

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    57b8:	00000520 	andeq	r0, r0, r0, lsr #10
    57bc:	0000f510 	andeq	pc, r0, r0, lsl r5	; <UNPREDICTABLE>
    57c0:	001d7600 	andseq	r7, sp, r0, lsl #12
    57c4:	01001a00 	tsteq	r0, r0, lsl #20
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
		store64(hash, s->h[i++]);
    57c8:	53010000 	movwpl	r0, #4096	; 0x1000
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57cc:	1b000000 	blne	57d4 <sha512_get+0x78>
	*(x--) = v;
	v >>= 8;
    57d0:	0000008c 	andeq	r0, r0, ip, lsl #1
    57d4:	0000024d 	andeq	r0, r0, sp, asr #4
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57d8:	0000ad1c 	andeq	sl, r0, ip, lsl sp
	*(x--) = v;
	v >>= 8;
    57dc:	1d001f00 	stcne	15, cr1, [r0, #-0]
	*(x--) = v;
	v >>= 8;
    57e0:	000015c2 	andeq	r1, r0, r2, asr #11
    57e4:	008c3c01 	addeq	r3, ip, r1, lsl #24
	*(x--) = v;
	v >>= 8;
    57e8:	1f580000 	svcne	0x00580000
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57ec:	009a0000 	addseq	r0, sl, r0
	*(x--) = v;
	v >>= 8;
    57f0:	9c010000 	stcls	0, cr0, [r1], {-0}
	*(x--) = v;
	v >>= 8;
    57f4:	0000029d 	muleq	r0, sp, r2
    57f8:	0100781e 	tsteq	r0, lr, lsl r8
    57fc:	0001103c 	andeq	r1, r1, ip, lsr r0
	*(x--) = v;
	v >>= 8;
    5800:	001d8900 	andseq	r8, sp, r0, lsl #18
    5804:	00791e00 	rsbseq	r1, r9, r0, lsl #28
    5808:	01103c01 	tsteq	r0, r1, lsl #24
    580c:	1db50000 	ldcne	0, cr0, [r5]
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5810:	73160000 	tstvc	r6, #0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5814:	01006d75 	tsteq	r0, r5, ror sp
	*(x--) = v;
    5818:	00008c3e 	andeq	r8, r0, lr, lsr ip
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    581c:	001de100 	andseq	lr, sp, r0, lsl #2
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5820:	00691600 	rsbeq	r1, r9, r0, lsl #12
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5824:	007e3f01 	rsbseq	r3, lr, r1, lsl #30
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5828:	1e290000 	cdpne	0, 2, cr0, cr9, cr0, {0}
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    582c:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    5830:	000000bd 	strheq	r0, [r0], -sp
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5834:	00001ff4 	strdeq	r1, [r0], -r4
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    5838:	000000c2 	andeq	r0, r0, r2, asr #1
    583c:	02e59c01 	rsceq	r9, r5, #256	; 0x100
    5840:	c9180000 	ldmdbgt	r8, {}	; <UNPREDICTABLE>
    5844:	01000000 	mrseq	r0, (UNDEF: 0)
    5848:	00d40f50 	sbcseq	r0, r4, r0, asr pc
    584c:	1e6c0000 	cdpne	0, 6, cr0, cr12, cr0, {0}
    5850:	df0f0000 	svcle	0x000f0000
    5854:	98000000 	stmdals	r0, {}	; <UNPREDICTABLE>
    5858:	0f00001e 	svceq	0x0000001e
		hash += 8;
		len -= 8;
	}

	/* Read out bytes */
	if (len) {
    585c:	000000ea 	andeq	r0, r0, sl, ror #1
    5860:	00001ec4 	andeq	r1, r0, r4, asr #29
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
	}
}
    5864:	0000f510 	andeq	pc, r0, r0, lsl r5	; <UNPREDICTABLE>
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    5868:	001ee500 	andseq	lr, lr, r0, lsl #10
    586c:	01001000 	mrseq	r1, (UNDEF: 0)
    5870:	1f0e0000 	svcne	0x000e0000

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5874:	13000000 	movwne	r0, #0
    5878:	0000147a 	andeq	r1, r0, sl, ror r4
	*(x--) = v;
	v >>= 8;
    587c:	20b85601 	adcscs	r5, r8, r1, lsl #12
    5880:	00460000 	subeq	r0, r6, r0
	*(x--) = v;
	v >>= 8;
    5884:	9c010000 	stcls	0, cr0, [r1], {-0}
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5888:	0000033a 	andeq	r0, r0, sl, lsr r3
	*(x--) = v;
	v >>= 8;
    588c:	01007214 	tsteq	r0, r4, lsl r2
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5890:	00010a56 	andeq	r0, r1, r6, asr sl
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5894:	1e500100 	rdfnes	f0, f0, f0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5898:	56010061 	strpl	r0, [r1], -r1, rrx
    589c:	00000110 	andeq	r0, r0, r0, lsl r1
	*(x--) = v;
	v >>= 8;
    58a0:	00001f39 	andeq	r1, r0, r9, lsr pc
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58a4:	0100621e 	tsteq	r0, lr, lsl r2
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58a8:	00011056 	andeq	r1, r1, r6, asr r0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58ac:	001f5a00 	andseq	r5, pc, r0, lsl #20
	*(x--) = v;
	v >>= 8;
    58b0:	00631600 	rsbeq	r1, r3, r0, lsl #12
    58b4:	00975801 	addseq	r5, r7, r1, lsl #16
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    58b8:	1f7b0000 	svcne	0x007b0000
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58bc:	69160000 	ldmdbvs	r6, {}	; <UNPREDICTABLE>
    58c0:	7e590100 	rdfvce	f0, f1, f0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58c4:	bf000000 	svclt	0x00000000
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58c8:	0000001f 	andeq	r0, r0, pc, lsl r0
    58cc:	00155206 	andseq	r5, r5, r6, lsl #4
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d0:	016d0100 	cmneq	sp, r0, lsl #2
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d4:	00000374 	andeq	r0, r0, r4, ror r3
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d8:	01007207 	tsteq	r0, r7, lsl #4
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58dc:	00010a6d 	andeq	r0, r1, sp, ror #20
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58e0:	00610700 	rsbeq	r0, r1, r0, lsl #14
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
		uint8_t tmp[8];
		unsigned int c = 8 - offset;
    58e4:	01106d01 	tsteq	r0, r1, lsl #26
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58e8:	62070000 	andvs	r0, r7, #0
	v >>= 8;
	*(x--) = v;
    58ec:	106d0100 	rsbne	r0, sp, r0, lsl #2
	v >>= 8;
	*(x--) = v;
    58f0:	0a000001 	beq	58fc <sha512_get+0x1a0>
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58f4:	6f010063 	svcvs	0x00010063
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58f8:	000000a2 	andeq	r0, r0, r2, lsr #1
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58fc:	0100690a 	tsteq	r0, sl, lsl #18
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5900:	00007e70 	andeq	r7, r0, r0, ror lr
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5904:	3a0e0000 	bcc	38590c <_etext+0x37e3f4>
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    5908:	00000003 	andeq	r0, r0, r3
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    590c:	4c000021 	stcmi	0, cr0, [r0], {33}	; 0x21
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
		uint8_t tmp[8];
		unsigned int c = 8 - offset;
    5910:	01000000 	mrseq	r0, (UNDEF: 0)
    5914:	0003b39c 	muleq	r3, ip, r3
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5918:	03461800 	movteq	r1, #26624	; 0x6800
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    591c:	50010000 	andpl	r0, r1, r0
		memcpy(hash, tmp + offset, c);
		len -= c;
    5920:	00034f0f 	andeq	r4, r3, pc, lsl #30

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    5924:	00200d00 	eoreq	r0, r0, r0, lsl #26
		len -= c;
    5928:	03580f00 	cmpeq	r8, #0, 30

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    592c:	202e0000 	eorcs	r0, lr, r0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5930:	61100000 	tstvs	r0, r0

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    5934:	4f000003 	svcmi	0x00000003
		len -= c;
		hash += c;
    5938:	10000020 	andne	r0, r0, r0, lsr #32
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    593c:	0000036a 	andeq	r0, r0, sl, ror #6
		memcpy(hash, tmp + offset, c);
		len -= c;
		hash += c;
    5940:	0000207a 	andeq	r2, r0, sl, ror r0
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    5944:	16741300 	ldrbtne	r1, [r4], -r0, lsl #6
    5948:	85010000 	strhi	r0, [r1, #-0]

	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
    594c:	0000214c 	andeq	r2, r0, ip, asr #2
    5950:	00000046 	andeq	r0, r0, r6, asr #32
    5954:	03fb9c01 	mvnseq	r9, #256	; 0x100
    5958:	72140000 	andsvc	r0, r4, #0

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    595c:	0a850100 	beq	fe145d64 <BootRAM+0xd0b6505>
    5960:	01000001 	tsteq	r0, r1
	*(x--) = v;
	v >>= 8;
    5964:	00611e50 	rsbeq	r1, r1, r0, asr lr

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5968:	01108501 	tsteq	r0, r1, lsl #10
	*(x--) = v;
	v >>= 8;
    596c:	20d40000 	sbcscs	r0, r4, r0
    5970:	63160000 	tstvs	r6, #0
	*(x--) = v;
	v >>= 8;
    5974:	a2870100 	addge	r0, r7, #0, 2
    5978:	f5000000 			; <UNDEFINED> instruction: 0xf5000000
    597c:	16000020 	strne	r0, [r0], -r0, lsr #32
	*(x--) = v;
	v >>= 8;
    5980:	88010069 	stmdahi	r1, {r0, r3, r5, r6}
    5984:	0000007e 	andeq	r0, r0, lr, ror r0
	*(x--) = v;
	v >>= 8;
    5988:	00002120 	andeq	r2, r0, r0, lsr #2
    598c:	15730600 	ldrbne	r0, [r3, #-1536]!	; 0x600
	*(x--) = v;
	v >>= 8;
    5990:	9d010000 	stcls	0, cr0, [r1, #-0]
    5994:	00044001 	andeq	r4, r4, r1
    5998:	00720700 	rsbseq	r0, r2, r0, lsl #14
	*(x--) = v;
	v >>= 8;
    599c:	010a9d01 	tsteq	sl, r1, lsl #26
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    59a0:	61070000 	mrsvs	r0, (UNDEF: 7)
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59a4:	109d0100 	addsne	r0, sp, r0, lsl #2
	*(x--) = v;
	v >>= 8;
    59a8:	07000001 	streq	r0, [r0, -r1]
    59ac:	9d010062 	stcls	0, cr0, [r1, #-392]	; 0xfffffe78
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    59b0:	00000110 	andeq	r0, r0, r0, lsl r1
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59b4:	0100630a 	tsteq	r0, sl, lsl #6
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59b8:	0000a29f 	muleq	r0, pc, r2	; <UNPREDICTABLE>
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59bc:	00690a00 	rsbeq	r0, r9, r0, lsl #20
    59c0:	007ea001 	rsbseq	sl, lr, r1
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59c4:	0a1f0000 	beq	7c59cc <_etext+0x7be4b4>
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59c8:	a301006a 	movwge	r0, #4202	; 0x106a
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59cc:	0000007e 	andeq	r0, r0, lr, ror r0
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59d0:	fb0e0000 	blx	3859da <_etext+0x37e4c2>
	v >>= 8;
	*(x--) = v;
    59d4:	94000003 	strls	r0, [r0], #-3
	v >>= 8;
	*(x--) = v;
    59d8:	88000021 	stmdahi	r0, {r0, r5}
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    59dc:	01000000 	mrseq	r0, (UNDEF: 0)
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59e0:	0004929c 	muleq	r4, ip, r2
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59e4:	04071800 	streq	r1, [r7], #-2048	; 0x800
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    59e8:	50010000 	andpl	r0, r1, r0
	}
}
    59ec:	0004100f 	andeq	r1, r4, pc
    59f0:	00217a00 	eoreq	r7, r1, r0, lsl #20
    for (i = 0; i < len; i++)
        uart_printf("%02x", data[i]);
    uart_printf("\n");
}

void failErase () {
    59f4:	04190f00 	ldreq	r0, [r9], #-3840	; 0xf00
	// for whatever reason this only flashes upto 0x08008800
	flashErasePage((u32)(0x08008000));
    59f8:	219b0000 	orrscs	r0, fp, r0
	flashErasePage((u32)(0x08008000+1024));
    59fc:	22100000 	andscs	r0, r0, #0
    5a00:	bc000004 	stclt	0, cr0, [r0], {4}
	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
    5a04:	10000021 	andne	r0, r0, r1, lsr #32
	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
    5a08:	0000042b 	andeq	r0, r0, fp, lsr #8
    5a0c:	000021e6 	andeq	r2, r0, r6, ror #3
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
    5a10:	00219e20 	eoreq	r9, r1, r0, lsr #28
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
}
    5a14:	00004a00 	andeq	r4, r0, r0, lsl #20
	flashErasePage((u32)(0x08008000));
	flashErasePage((u32)(0x08008000+1024));
	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
    5a18:	04351000 	ldrteq	r1, [r5], #-0
    5a1c:	22340000 	eorscs	r0, r4, #0
    5a20:	00000000 	andeq	r0, r0, r0
    5a24:	00182213 	andseq	r2, r8, r3, lsl r2
    5a28:	00ba0100 	adcseq	r0, sl, r0, lsl #2
    5a2c:	b8000000 	stmdalt	r0, {}	; <UNPREDICTABLE>
    5a30:	01000000 	mrseq	r0, (UNDEF: 0)
    5a34:	0005599c 	muleq	r5, ip, r9
}

int imageCheckFromAddress(ImageObjectHandle *newHandle, vu32 flashAddress, bool shouldEraseFlashOnFail)
{
    5a38:	00721e00 	rsbseq	r1, r2, r0, lsl #28
    5a3c:	010aba01 	tsteq	sl, r1, lsl #20
    5a40:	22830000 	addcs	r0, r3, #0
    5a44:	611e0000 	tstvs	lr, r0
	ImageRootHeader		*hdr;
	ImageInternalState		state;
	int bufferSize = 0x28+0x40;
	unsigned char imageBuffer[bufferSize];
    memset(imageBuffer, 0xFF, sizeof(imageBuffer));
    5a48:	10ba0100 	adcsne	r0, sl, r0, lsl #2
    5a4c:	af000001 	svcge	0x00000001
    memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
    5a50:	1e000022 	cdpne	0, 0, cr0, cr0, cr2, {1}
    5a54:	ba010062 	blt	45be4 <_etext+0x3e6cc>
    5a58:	00000110 	andeq	r0, r0, r0, lsl r1
    flashUnlock();
    5a5c:	000022d0 	ldrdeq	r2, [r0], -r0
    memset(&state, 0, sizeof(state));
    5a60:	706d7421 	rsbvc	r7, sp, r1, lsr #8
    5a64:	3dbc0100 	ldfccs	f0, [ip]
		{
			failErase();
		}
		return(EINVAL);		/* buffer too small to really contain header */
	}
	if ((hdr->header.magic) != kImageHeaderMagic) {
    5a68:	02000002 	andeq	r0, r0, #2
    5a6c:	fb224891 	blx	897cba <_etext+0x8907a2>
			failErase();
		}
		*newHandle = &state;
		return(kImageImageMissingMagic);		/* magic must match */
	}
	if ((hdr->signing.imageType) != 0x45444f53)
    5a70:	00000003 	andeq	r0, r0, r3
    5a74:	40000000 	andmi	r0, r0, r0
	{
		debug_print("bad magic 0x%08x expecting 0x%X\n", (hdr->signing.imageType), 0x45444f53);
		state.flags = kImageImageMissingMagic;
    5a78:	01000005 	tsteq	r0, r5
		if (shouldEraseFlashOnFail)
    5a7c:	000536be 			; <UNDEFINED> instruction: 0x000536be
    5a80:	04190f00 	ldreq	r0, [r9], #-3840	; 0xf00
		{
			failErase();
    5a84:	22f10000 	rscscs	r0, r1, #0
		}
		*newHandle = &state;
		return(kImageImageMissingMagic);		/* magic must match */
    5a88:	100f0000 	andne	r0, pc, r0
	}
	state.flags = kImageImageWasInstantiated;
    5a8c:	12000004 	andne	r0, r0, #4

	debug_print("dataSize: 0x0%X\n", (0x08008000+(hdr->header.dataSize)));

	state.cursor = (hdr->header.dataSize)+0x200;
    5a90:	0f000023 	svceq	0x00000023
    5a94:	00000407 	andeq	r0, r0, r7, lsl #8
	state.lastTag = -1;

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5a98:	00002333 	andeq	r2, r0, r3, lsr r3
    5a9c:	00054019 	andeq	r4, r5, r9, lsl r0
	state.flags = kImageImageWasInstantiated;

	debug_print("dataSize: 0x0%X\n", (0x08008000+(hdr->header.dataSize)));

	state.cursor = (hdr->header.dataSize)+0x200;
	state.lastTag = -1;
    5aa0:	04221000 	strteq	r1, [r2], #-0

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5aa4:	23600000 	cmncs	r0, #0

    sha256_context ctx;
    sha256_starts(&ctx);
    5aa8:	2b100000 	blcs	405ab0 <_etext+0x3fe598>
    5aac:	8a000004 	bhi	5ac4 <imageCheckFromAddress+0x8c>

    int buffSize = 0x4;
    char buff[buffSize];

    int i = 0x84;
    char cmpEnd[4] = {0x01, 0x00, 0x00, 0x00,}; 
    5ab0:	20000023 	andcs	r0, r0, r3, lsr #32
    hexdump((flashAddress+i), 0x20);
    5ab4:	00000000 	andeq	r0, r0, r0

    int buffSize = 0x4;
    char buff[buffSize];

    int i = 0x84;
    char cmpEnd[4] = {0x01, 0x00, 0x00, 0x00,}; 
    5ab8:	00000048 	andeq	r0, r0, r8, asr #32
    5abc:	00043510 	andeq	r3, r4, r0, lsl r5
    5ac0:	0023eb00 	eoreq	lr, r3, r0, lsl #22
    5ac4:	00000000 	andeq	r0, r0, r0
    hexdump((flashAddress+i), 0x20);
    5ac8:	00011b23 	andeq	r1, r1, r3, lsr #22
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), ((hdr->header.dataSize) - 0x40));
    while ((flashAddress+i) <= (flashAddress+state.cursor))
    5acc:	00000000 	andeq	r0, r0, r0
    5ad0:	00002600 	andeq	r2, r0, r0, lsl #12
    5ad4:	0fbf0100 	svceq	0x00bf0100
    5ad8:	00000130 	andeq	r0, r0, r0, lsr r1
    {
      memset(buff, 0xFF, buffSize);
    5adc:	0000243a 	andeq	r2, r0, sl, lsr r4
      memcpy(buff, (unsigned char *)(flashAddress+i), buffSize);
    5ae0:	0001270f 	andeq	r2, r1, pc, lsl #14
    5ae4:	00246700 	eoreq	r6, r4, r0, lsl #14
    5ae8:	06000000 	streq	r0, [r0], -r0
      if ((memmem(&buff, buffSize, &cmpEnd, buffSize) > 0) && ((flashAddress + hdr->header.dataSize) - 0x40) < (vu32 *)(flashAddress+i)) // our end of image should be somewhere around here
    5aec:	00001485 	andeq	r1, r0, r5, lsl #9
    5af0:	9301c201 	movwls	ip, #4609	; 0x1201
    5af4:	07000005 	streq	r0, [r0, -r5]
    5af8:	c2010072 	andgt	r0, r1, #114	; 0x72
    5afc:	0000010a 	andeq	r0, r0, sl, lsl #2
    5b00:	01006107 	tsteq	r0, r7, lsl #2
      {
      	sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
    5b04:	000110c2 	andeq	r1, r1, r2, asr #1
    5b08:	00620700 	rsbeq	r0, r2, r0, lsl #14
    5b0c:	00a2c201 	adceq	ip, r2, r1, lsl #4
      	debug_print("Hash Finish: %X\n", (flashAddress+i));
      	hexdump((flashAddress+i), 0xC);
    5b10:	630a0000 	movwvs	r0, #40960	; 0xa000
    5b14:	a2c40100 	sbcge	r0, r4, #0, 2
    5b18:	0a000000 	beq	5b20 <imageCheckFromAddress+0xe8>
      	break;
      }
      sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
    5b1c:	c5010069 	strgt	r0, [r1, #-105]	; 0x69
    5b20:	0000007e 	andeq	r0, r0, lr, ror r0
    5b24:	05590e00 	ldrbeq	r0, [r9, #-3584]	; 0xe00
      i += 0x4;
    5b28:	00000000 	andeq	r0, r0, r0
	    uid_read(&id);
	    sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
	    sha256_update(&ctx, uniqueID, 0x17);
    } else {
    	// QEMU builds get FF ECIDs
    	memcpy(&uniqueID, (unsigned char*)"FFFFFFFFFFFFFFFFFFFFFFF", 0x17);
    5b2c:	00400000 	subeq	r0, r0, r0
    5b30:	9c010000 	stcls	0, cr0, [r1], {-0}
    5b34:	000005d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    5b38:	00056518 	andeq	r6, r5, r8, lsl r5
    5b3c:	18500100 	ldmdane	r0, {r8}^
    5b40:	0000056e 	andeq	r0, r0, lr, ror #10
    5b44:	770f5101 	strvc	r5, [pc, -r1, lsl #2]
    5b48:	88000005 	stmdahi	r0, {r0, r2}
    5b4c:	10000024 	andne	r0, r0, r4, lsr #32
    5b50:	00000580 	andeq	r0, r0, r0, lsl #11
	    sha256_update(&ctx, uniqueID, 0x17);
    5b54:	000024a9 	andeq	r2, r0, r9, lsr #9
    5b58:	00058910 	andeq	r8, r5, r0, lsl r9
    }

    debug_print("%s\n", uniqueID);
    
    sha256_finish(&ctx, sha256sum);
    5b5c:	0024d700 	eoreq	sp, r4, r0, lsl #14
    5b60:	88130000 	ldmdahi	r3, {}	; <UNPREDICTABLE>
    print_hash(sha256sum);
    5b64:	01000015 	tsteq	r0, r5, lsl r0
    5b68:	00221cd8 	ldrdeq	r1, [r2], -r8	; <UNPREDICTABLE>
    // verify signature against recalc hash
    uint8_t sigbuff[0x40];
    memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
    5b6c:	0005ea00 	andeq	lr, r5, r0, lsl #20
    5b70:	e79c0100 	ldr	r0, [ip, r0, lsl #2]
    5b74:	14000009 	strne	r0, [r0], #-9
    5b78:	d8010072 	stmdale	r1, {r1, r4, r5, r6}
    5b7c:	0000010a 	andeq	r0, r0, sl, lsl #2

    if (edsign_verify(sigbuff, rootCA, sha256sum, 32) <= 0) {
    5b80:	781e5001 	ldmdavc	lr, {r0, ip, lr}
    5b84:	10d80100 	sbcsne	r0, r8, r0, lsl #2
    5b88:	25000001 	strcs	r0, [r0, #-1]
    5b8c:	21000025 	tstcs	r0, r5, lsr #32
    	state.flags = kImageImageRejectSignature;
    5b90:	da010073 	ble	45d64 <_etext+0x3e84c>
    	if (shouldEraseFlashOnFail)
    5b94:	0000023d 	andeq	r0, r0, sp, lsr r2
		{
			failErase();
    5b98:	0a409102 	beq	1029fa8 <_etext+0x1022a90>
		}
    	*newHandle = &state;
    5b9c:	db010069 	blle	45d48 <_etext+0x3e830>
    	return kImageImageRejectSignature;
    5ba0:	0000007e 	andeq	r0, r0, lr, ror r0
    } else {
    	state.flags = kImageImageIsTrusted;
    	*newHandle = &state;
    	return kImageImageIsTrusted;
    5ba4:	0003fb22 	andeq	pc, r3, r2, lsr #22
    }
	
	*newHandle = &state;
	return(0);
}
    5ba8:	00222000 	eoreq	r2, r2, r0
    5bac:	00055800 	andeq	r5, r5, r0, lsl #16
    5bb0:	6cee0100 	stfvse	f0, [lr]
    5bb4:	0f000006 	svceq	0x00000006
    5bb8:	00000419 	andeq	r0, r0, r9, lsl r4
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxStatus(u8 bEpNum, u16 wState)
{
  _SetEPTxStatus(bEpNum, wState);
    5bbc:	00002546 	andeq	r2, r0, r6, asr #10
    5bc0:	0004100f 	andeq	r1, r4, pc
    5bc4:	00254600 	eoreq	r4, r5, r0, lsl #12
    5bc8:	04070f00 	streq	r0, [r7], #-3840	; 0xf00
    5bcc:	25670000 	strbcs	r0, [r7, #-0]!
    5bd0:	58190000 	ldmdapl	r9, {}	; <UNPREDICTABLE>
    5bd4:	10000005 	andne	r0, r0, r5
    5bd8:	00000422 	andeq	r0, r0, r2, lsr #8
    5bdc:	00002594 	muleq	r0, r4, r5
    5be0:	00042b10 	andeq	r2, r4, r0, lsl fp
    5be4:	0025be00 	eoreq	fp, r5, r0, lsl #28
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxValid(u8 bEpNum)
{
  _SetEPRxStatus(bEpNum, EP_RX_VALID);
    5be8:	22262000 	eorcs	r2, r6, #0
    5bec:	00460000 	subeq	r0, r6, r0
    5bf0:	35100000 	ldrcc	r0, [r0, #-0]
    5bf4:	1f000004 	svcne	0x00000004
    5bf8:	00000026 	andeq	r0, r0, r6, lsr #32
    5bfc:	fb220000 	blx	885c06 <_etext+0x87e6ee>
    5c00:	a8000003 	stmdage	r0, {r0, r1}
* Output         : None.
* Return         : None.
*******************************************************************************/
void Clear_Status_Out(u8 bEpNum)
{
  _ClearEP_KIND(bEpNum);
    5c04:	70000022 	andvc	r0, r0, r2, lsr #32
    5c08:	01000005 	tsteq	r0, r5
    5c0c:	0006baef 	andeq	fp, r6, pc, ror #21
    5c10:	04192400 	ldreq	r2, [r9], #-1024	; 0x400
    5c14:	10240000 	eorne	r0, r4, r0
    5c18:	24000004 	strcs	r0, [r0], #-4
    5c1c:	00000407 	andeq	r0, r0, r7, lsl #8
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_RX(u8 bEpNum)
{
  _ClearDTOG_RX(bEpNum);
    5c20:	00057019 	andeq	r7, r5, r9, lsl r0
    5c24:	04221000 	strteq	r1, [r2], #-0
    5c28:	266e0000 	strbtcs	r0, [lr], -r0
    5c2c:	2b100000 	blcs	405c34 <_etext+0x3fe71c>
    5c30:	8c000004 	stchi	0, cr0, [r0], {4}
    5c34:	20000026 	andcs	r0, r0, r6, lsr #32
    5c38:	000022a8 	andeq	r2, r0, r8, lsr #5
    5c3c:	00000044 	andeq	r0, r0, r4, asr #32
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_TX(u8 bEpNum)
{
  _ClearDTOG_TX(bEpNum);
    5c40:	00043510 	andeq	r3, r4, r0, lsl r5
    5c44:	0026ce00 	eoreq	ip, r6, r0, lsl #28
    5c48:	00000000 	andeq	r0, r0, r0
    5c4c:	0003fb22 	andeq	pc, r3, r2, lsr #22
    5c50:	00231a00 	eoreq	r1, r3, r0, lsl #20
    5c54:	00058800 	andeq	r8, r5, r0, lsl #16
    5c58:	04f30100 	ldrbteq	r0, [r3], #256	; 0x100
    5c5c:	24000007 	strcs	r0, [r0], #-7
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
u16 GetEPTxAddr(u8 bEpNum)
{
  return(_GetEPTxAddr(bEpNum));
    5c60:	00000419 	andeq	r0, r0, r9, lsl r4
    5c64:	00041024 	andeq	r1, r4, r4, lsr #32
    5c68:	04072400 	streq	r2, [r7], #-1024	; 0x400
    5c6c:	88190000 	ldmdahi	r9, {}	; <UNPREDICTABLE>
    5c70:	10000005 	andne	r0, r0, r5
}
    5c74:	00000422 	andeq	r0, r0, r2, lsr #8
    5c78:	00002748 	andeq	r2, r0, r8, asr #14
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
u16 GetEPRxAddr(u8 bEpNum)
{
  return(_GetEPRxAddr(bEpNum));
    5c7c:	00042b10 	andeq	r2, r4, r0, lsl fp
    5c80:	00277200 	eoreq	r7, r7, r0, lsl #4
    5c84:	05a01900 	streq	r1, [r0, #2304]!	; 0x900
    5c88:	35100000 	ldrcc	r0, [r0, #-0]
}
    5c8c:	d3000004 	movwle	r0, #4
    5c90:	00000027 	andeq	r0, r0, r7, lsr #32
    5c94:	fb250000 	blx	945c9e <_etext+0x93e786>
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxCount(u8 bEpNum, u16 wCount)
{
  _SetEPTxCount(bEpNum, wCount);
    5c98:	a8000003 	stmdage	r0, {r0, r1}
    5c9c:	76000023 	strvc	r0, [r0], -r3, lsr #32
    5ca0:	01000000 	mrseq	r0, (UNDEF: 0)
    5ca4:	000756f4 	strdeq	r5, [r7], -r4
    5ca8:	04192400 	ldreq	r2, [r9], #-1024	; 0x400
    5cac:	10240000 	eorne	r0, r4, r0
    5cb0:	24000004 	strcs	r0, [r0], #-4
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxCount(u8 bEpNum, u16 wCount)
{
  _SetEPRxCount(bEpNum, wCount);
    5cb4:	00000407 	andeq	r0, r0, r7, lsl #8
    5cb8:	0023a820 	eoreq	sl, r3, r0, lsr #16
    5cbc:	00007600 	andeq	r7, r0, r0, lsl #12
    5cc0:	04221000 	strteq	r1, [r2], #-0
    5cc4:	28220000 	stmdacs	r2!, {}	; <UNPREDICTABLE>
    5cc8:	2b100000 	blcs	405cd0 <_etext+0x3fe7b8>
    5ccc:	40000004 	andmi	r0, r0, r4
    5cd0:	20000028 	andcs	r0, r0, r8, lsr #32
    5cd4:	000023a8 	andeq	r2, r0, r8, lsr #7
    5cd8:	00000048 	andeq	r0, r0, r8, asr #32
    5cdc:	00043510 	andeq	r3, r4, r0, lsl r5
    5ce0:	00288200 	eoreq	r8, r8, r0, lsl #4
    5ce4:	00000000 	andeq	r0, r0, r0
    5ce8:	0003fb25 	andeq	pc, r3, r5, lsr #22
    5cec:	00242800 	eoreq	r2, r4, r0, lsl #16
    5cf0:	00008800 	andeq	r8, r0, r0, lsl #16
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CTR_LP(void)
{
    5cf4:	a8f80100 	ldmge	r8!, {r8}^
  u32 wEPVal = 0;
  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
    5cf8:	24000007 	strcs	r0, [r0], #-7
    5cfc:	00000419 	andeq	r0, r0, r9, lsl r4
    5d00:	00041024 	andeq	r1, r4, r4, lsr #32
    5d04:	04072400 	streq	r2, [r7], #-1024	; 0x400
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
    5d08:	28200000 	stmdacs	r0!, {}	; <UNPREDICTABLE>
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
    5d0c:	88000024 	stmdahi	r0, {r2, r5}
    5d10:	10000000 	andne	r0, r0, r0
    5d14:	00000422 	andeq	r0, r0, r2, lsr #8
    if (EPindex == 0)
    5d18:	000028fc 	strdeq	r2, [r0], -ip
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */
      SaveRState = _GetEPRxStatus(ENDP0);
    5d1c:	00042b10 	andeq	r2, r4, r0, lsl fp
      SaveTState = _GetEPTxStatus(ENDP0);
    5d20:	00291a00 	eoreq	r1, r9, r0, lsl #20
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */
      SaveRState = _GetEPRxStatus(ENDP0);
    5d24:	24282000 	strtcs	r2, [r8], #-0
      SaveTState = _GetEPTxStatus(ENDP0);
    5d28:	004a0000 	subeq	r0, sl, r0
    5d2c:	35100000 	ldrcc	r0, [r0, #-0]
      _SetEPRxStatus(ENDP0, EP_RX_NAK);
    5d30:	6f000004 	svcvs	0x00000004
    5d34:	00000029 	andeq	r0, r0, r9, lsr #32
    5d38:	fb250000 	blx	945d42 <_etext+0x93e82a>
    5d3c:	b0000003 	andlt	r0, r0, r3
    5d40:	74000024 	strvc	r0, [r0], #-36	; 0x24
      _SetEPTxStatus(ENDP0, EP_TX_NAK);
    5d44:	01000000 	mrseq	r0, (UNDEF: 0)
    5d48:	0007fafb 	strdeq	pc, [r7], -fp
    5d4c:	04192400 	ldreq	r2, [r9], #-1024	; 0x400
    5d50:	10240000 	eorne	r0, r4, r0


      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
    5d54:	24000004 	strcs	r0, [r0], #-4
    5d58:	00000407 	andeq	r0, r0, r7, lsl #8

        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */

        wEPVal = _GetENDPOINT(ENDP0);
        if ((wEPVal & EP_CTR_TX) != 0)
    5d5c:	0024b020 	eoreq	fp, r4, r0, lsr #32
        {
          _ClearEP_CTR_TX(ENDP0);
    5d60:	00007400 	andeq	r7, r0, r0, lsl #8
    5d64:	04221000 	strteq	r1, [r2], #-0
    5d68:	29be0000 	ldmibcs	lr!, {}	; <UNPREDICTABLE>
          In0_Process();
    5d6c:	2b100000 	blcs	405d74 <_etext+0x3fe85c>
          /* before terminate set Tx & Rx status */
          _SetEPRxStatus(ENDP0, SaveRState);
          _SetEPTxStatus(ENDP0, SaveTState);
          return;
        }
        else if ((wEPVal &EP_SETUP) != 0)
    5d70:	dc000004 	stcle	0, cr0, [r0], {4}
        {
          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
    5d74:	20000029 	andcs	r0, r0, r9, lsr #32
    5d78:	000024b0 			; <UNDEFINED> instruction: 0x000024b0
    5d7c:	00000046 	andeq	r0, r0, r6, asr #32
          Setup0_Process();
    5d80:	00043510 	andeq	r3, r4, r0, lsl r5
          _SetEPRxStatus(ENDP0, SaveRState);
          _SetEPTxStatus(ENDP0, SaveTState);
          return;
        }

        else if ((wEPVal & EP_CTR_RX) != 0)
    5d84:	002a1e00 	eoreq	r1, sl, r0, lsl #28
        {
          _ClearEP_CTR_RX(ENDP0);
    5d88:	00000000 	andeq	r0, r0, r0
    5d8c:	0003fb25 	andeq	pc, r3, r5, lsr #22
    5d90:	00252400 	eoreq	r2, r5, r0, lsl #8
          Out0_Process();
    5d94:	00008200 	andeq	r8, r0, r0, lsl #4
          /* before terminate set Tx & Rx status */
          _SetEPRxStatus(ENDP0, SaveRState);
    5d98:	4cfc0100 	ldfmie	f0, [ip]
    5d9c:	24000008 	strcs	r0, [r0], #-8
    5da0:	00000419 	andeq	r0, r0, r9, lsl r4
    5da4:	00041024 	andeq	r1, r4, r4, lsr #32
    5da8:	04072400 	streq	r2, [r7], #-1024	; 0x400
    5dac:	24200000 	strtcs	r0, [r0], #-0
    5db0:	82000025 	andhi	r0, r0, #37	; 0x25
    5db4:	10000000 	andne	r0, r0, r0
          _SetEPTxStatus(ENDP0, SaveTState);
    5db8:	00000422 	andeq	r0, r0, r2, lsr #8
    5dbc:	00002a98 	muleq	r0, r8, sl
    5dc0:	00042b10 	andeq	r2, r4, r0, lsl fp
    5dc4:	002ab600 	eoreq	fp, sl, r0, lsl #12
    5dc8:	25242000 	strcs	r2, [r4, #-0]!
    5dcc:	00480000 	subeq	r0, r8, r0
    5dd0:	35100000 	ldrcc	r0, [r0, #-0]
    5dd4:	0b000004 	bleq	5dec <CTR_LP+0xf8>
          return;
    5dd8:	0000002b 	andeq	r0, r0, fp, lsr #32
    else
    {
      /* Decode and service non control endpoints interrupt  */

      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
    5ddc:	fb250000 	blx	945de6 <_etext+0x93e8ce>
    5de0:	a6000003 	strge	r0, [r0], -r3
    5de4:	74000025 	strvc	r0, [r0], #-37	; 0x25
      if ((wEPVal & EP_CTR_RX) != 0)
    5de8:	01000000 	mrseq	r0, (UNDEF: 0)
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
    5dec:	00089eff 	strdeq	r9, [r8], -pc	; <UNPREDICTABLE>
    5df0:	04192400 	ldreq	r2, [r9], #-1024	; 0x400

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
    5df4:	10240000 	eorne	r0, r4, r0
    5df8:	24000004 	strcs	r0, [r0], #-4
    5dfc:	00000407 	andeq	r0, r0, r7, lsl #8

      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
    5e00:	0025a620 	eoreq	sl, r5, r0, lsr #12
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
    5e04:	00007400 	andeq	r7, r0, r0, lsl #8
    5e08:	04221000 	strteq	r1, [r2], #-0
    5e0c:	2b5a0000 	blcs	1685e14 <_etext+0x167e8fc>
    5e10:	2b100000 	blcs	405e18 <_etext+0x3fe900>
    5e14:	78000004 	stmdavc	r0, {r2}
    5e18:	2000002b 	andcs	r0, r0, fp, lsr #32

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
    5e1c:	000025a6 	andeq	r2, r0, r6, lsr #11
    5e20:	00000046 	andeq	r0, r0, r6, asr #32
    5e24:	00043510 	andeq	r3, r4, r0, lsl r5
    5e28:	002bba00 	eoreq	fp, fp, r0, lsl #20
    5e2c:	00000000 	andeq	r0, r0, r0
    5e30:	0003fb26 	andeq	pc, r3, r6, lsr #22
    5e34:	00261a00 	eoreq	r1, r6, r0, lsl #20
    5e38:	00008200 	andeq	r8, r0, r0, lsl #4
    5e3c:	01020100 	mrseq	r0, (UNDEF: 18)
    5e40:	000008f1 	strdeq	r0, [r0], -r1
    5e44:	00041924 	andeq	r1, r4, r4, lsr #18
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void USB_Init(void)
{
    5e48:	04102400 	ldreq	r2, [r0], #-1024	; 0x400
  pInformation = &Device_Info;
    5e4c:	07240000 	streq	r0, [r4, -r0]!
    5e50:	20000004 	andcs	r0, r0, r4
  pInformation->ControlState = 2;
    5e54:	0000261a 	andeq	r2, r0, sl, lsl r6
  pProperty = &Device_Property;
    5e58:	00000082 	andeq	r0, r0, r2, lsl #1
  pUser_Standard_Requests = &User_Standard_Requests;
    5e5c:	00042210 	andeq	r2, r4, r0, lsl r2
    5e60:	002c3400 	eoreq	r3, ip, r0, lsl #8
  /* Initialize devices one by one */

  pProperty->Init();
    5e64:	042b1000 	strteq	r1, [fp], #-0
    5e68:	2c520000 	mracs	r0, r2, acc0
    5e6c:	1a200000 	bne	805e74 <_etext+0x7fe95c>
    5e70:	48000026 	stmdami	r0, {r1, r2, r5}
    5e74:	10000000 	andne	r0, r0, r0
    5e78:	00000435 	andeq	r0, r0, r5, lsr r4
    5e7c:	00002ca7 	andeq	r2, r0, r7, lsr #25
* Output         : None.
* Return         : Return 1 , if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
u8 *Standard_GetConfiguration(u16 Length)
{
    5e80:	26000000 	strcs	r0, [r0], -r0
  if (Length == 0)
    5e84:	000003fb 	strdeq	r0, [r0], -fp
  {
    pInformation->Ctrl_Info.Usb_wLength =
    5e88:	0000269c 	muleq	r0, ip, r6
      sizeof(pInformation->Current_Configuration);
    return 0;
    5e8c:	00000072 	andeq	r0, r0, r2, ror r0
  }
  pUser_Standard_Requests->User_GetConfiguration();
    5e90:	44010301 	strmi	r0, [r1], #-769	; 0x301
    5e94:	24000009 	strcs	r0, [r0], #-9
  return (u8 *)&pInformation->Current_Configuration;
    5e98:	00000419 	andeq	r0, r0, r9, lsl r4
}
    5e9c:	00041024 	andeq	r1, r4, r4, lsr #32
    5ea0:	04072400 	streq	r2, [r7], #-1024	; 0x400
* Output         : None.
* Return         : Return 0, if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
u8 *Standard_GetInterface(u16 Length)
{
    5ea4:	9c200000 	stcls	0, cr0, [r0], #-0
  if (Length == 0)
    5ea8:	72000026 	andvc	r0, r0, #38	; 0x26
  {
    pInformation->Ctrl_Info.Usb_wLength =
    5eac:	10000000 	andne	r0, r0, r0
      sizeof(pInformation->Current_AlternateSetting);
    return 0;
    5eb0:	00000422 	andeq	r0, r0, r2, lsr #8
  }
  pUser_Standard_Requests->User_GetInterface();
    5eb4:	00002cf6 	strdeq	r2, [r0], -r6
    5eb8:	00042b10 	andeq	r2, r4, r0, lsl fp
  return (u8 *)&pInformation->Current_AlternateSetting;
    5ebc:	002d1400 	eoreq	r1, sp, r0, lsl #8
}
    5ec0:	269c2000 	ldrcs	r2, [ip], r0
    5ec4:	00440000 	subeq	r0, r4, r0
* Output         : None.
* Return         : Return 0, if the request is at end of data block,
*                  or is invalid when "Length" is 0.
*******************************************************************************/
u8 *Standard_GetStatus(u16 Length)
{
    5ec8:	35100000 	ldrcc	r0, [r0, #-0]
  if (Length == 0)
    5ecc:	56000004 	strpl	r0, [r0], -r4
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
    5ed0:	0000002d 	andeq	r0, r0, sp, lsr #32
    return 0;
    5ed4:	fb260000 	blx	985ede <_etext+0x97e9c6>
  }

  StatusInfo.w = 0;
  /* Reset Status Information */

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    5ed8:	0e000003 	cdpeq	0, 0, cr0, cr0, cr3, {0}
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
    return 0;
  }

  StatusInfo.w = 0;
    5edc:	82000027 	andhi	r0, r0, #39	; 0x27
  /* Reset Status Information */

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    5ee0:	01000000 	mrseq	r0, (UNDEF: 0)
    5ee4:	09970106 	ldmibeq	r7, {r1, r2, r8}
  {
    /*Get Device Status */
    u8 Feature = pInformation->Current_Feature;
    5ee8:	19240000 	stmdbne	r4!, {}	; <UNPREDICTABLE>

    /* Remote Wakeup enabled */
    if (ValBit(Feature, 5))
    {
      SetBit(StatusInfo0, 1);
    5eec:	24000004 	strcs	r0, [r0], #-4
    5ef0:	00000410 	andeq	r0, r0, r0, lsl r4
    }

    /* Bus-powered */
    if (ValBit(Feature, 6))
    5ef4:	00040724 	andeq	r0, r4, r4, lsr #14
    {
      ClrBit(StatusInfo0, 0);
    5ef8:	270e2000 	strcs	r2, [lr, -r0]
    5efc:	00820000 	addeq	r0, r2, r0
    }
    else /* Self-powered */
    {
      SetBit(StatusInfo0, 0);
    5f00:	22100000 	andscs	r0, r0, #0
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    5f04:	d0000004 	andle	r0, r0, r4
  {
    return (u8 *)&StatusInfo;
  }
  /*Get EndPoint Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    5f08:	1000002d 	andne	r0, r0, sp, lsr #32
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;
    5f0c:	0000042b 	andeq	r0, r0, fp, lsr #8

    Related_Endpoint = (wIndex0 & 0x0f);
    5f10:	00002dee 	andeq	r2, r0, lr, ror #27
    if (ValBit(wIndex0, 7))
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5f14:	00270e20 	eoreq	r0, r7, r0, lsr #28
    5f18:	00004800 	andeq	r4, r0, r0, lsl #16
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;

    Related_Endpoint = (wIndex0 & 0x0f);
    if (ValBit(wIndex0, 7))
    5f1c:	04351000 	ldrteq	r1, [r5], #-0
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5f20:	2e430000 	cdpcs	0, 4, cr0, cr3, cr0, {0}
    5f24:	00000000 	andeq	r0, r0, r0
    5f28:	03fb2700 	mvnseq	r2, #0, 14
      {
        SetBit(StatusInfo0, 0); /* IN Endpoint stalled */
    5f2c:	27900000 	ldrcs	r0, [r0, r0]
    5f30:	006e0000 	rsbeq	r0, lr, r0
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
    5f34:	07010000 	streq	r0, [r1, -r0]
    5f38:	04192401 	ldreq	r2, [r9], #-1025	; 0x401
  }
  else
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
    5f3c:	10240000 	eorne	r0, r4, r0
    5f40:	24000004 	strcs	r0, [r0], #-4
  return (u8 *)&StatusInfo;
    5f44:	00000407 	andeq	r0, r0, r7, lsl #8
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
  {
    return (u8 *)&StatusInfo;
    5f48:	00279020 	eoreq	r9, r7, r0, lsr #32
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
  return (u8 *)&StatusInfo;
}
    5f4c:	00006e00 	andeq	r6, r0, r0, lsl #28
    5f50:	04221000 	strteq	r1, [r2], #-0
    5f54:	2e920000 	cdpcs	0, 9, cr0, cr2, cr0, {0}
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
    5f58:	2b100000 	blcs	405f60 <_etext+0x3fea48>
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
    5f5c:	b0000004 	andlt	r0, r0, r4
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
    5f60:	2000002e 	andcs	r0, r0, lr, lsr #32
  u32 save_wLength = pEPinfo->Usb_wLength;
  u32 ControlState = pInformation->ControlState;
    5f64:	00002790 	muleq	r0, r0, r7

  u8 *DataBuffer;
  u32 Length;

  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
    5f68:	00000044 	andeq	r0, r0, r4, asr #32
    5f6c:	00043510 	andeq	r3, r4, r0, lsl r5
  {
    if(Data_Mul_MaxPacketSize == TRUE)
    5f70:	002ef200 	eoreq	pc, lr, r0, lsl #4
    5f74:	00000000 	andeq	r0, r0, r0
    {
      /* No more data to send and empty packet */
      Send0LengthData();
    5f78:	18172800 	ldmdane	r7, {fp, sp}
    5f7c:	0a010000 	beq	45f84 <_etext+0x3ea6c>
    5f80:	00000001 	andeq	r0, r0, r1
    5f84:	00002600 	andeq	r2, r0, r0, lsl #12
      ControlState = LAST_IN_DATA;
      Data_Mul_MaxPacketSize = FALSE;
    5f88:	659c0100 	ldrvs	r0, [ip, #256]	; 0x100
    }
    else
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
      vSetEPTxStatus(EP_TX_STALL);
    5f8c:	2900000a 	stmdbcs	r0, {r1, r3}
      Data_Mul_MaxPacketSize = FALSE;
    }
    else
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
    5f90:	0a010072 	beq	46160 <_etext+0x3ec48>
    }

    goto Expect_Status_Out;
  }

  Length = pEPinfo->PacketSize;
    5f94:	00010a01 	andeq	r0, r1, r1, lsl #20
  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
    5f98:	002f6c00 	eoreq	r6, pc, r0, lsl #24
    5f9c:	00782900 	rsbseq	r2, r8, r0, lsl #18
  if (Length > save_wLength)
  {
    Length = save_wLength;
  }

  DataBuffer = (*pEPinfo->CopyData)(Length);
    5fa0:	10010a01 	andne	r0, r1, r1, lsl #20
    5fa4:	8a000001 	bhi	5fb0 <DataStageIn+0x58>
    5fa8:	2a00002f 	bcs	606c <Standard_SetInterface+0x34>

  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
    5fac:	00706d74 	rsbseq	r6, r0, r4, ror sp
    5fb0:	3d010c01 	stccc	12, cr0, [r1, #-4]
    5fb4:	02000002 	andeq	r0, r0, #2
    5fb8:	1b265091 	blne	99a204 <_etext+0x992cec>

  SetEPTxCount(ENDP0, Length);
    5fbc:	00000001 	andeq	r0, r0, r1
    5fc0:	16000000 	strne	r0, [r0], -r0

  pEPinfo->Usb_wLength -= Length;
    5fc4:	01000000 	mrseq	r0, (UNDEF: 0)
  pEPinfo->Usb_wOffset += Length;
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */
    5fc8:	0a4d010f 	beq	134640c <_etext+0x133eef4>

  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
    5fcc:	300f0000 	andcc	r0, pc, r0
  pEPinfo->Usb_wOffset += Length;
    5fd0:	ab000001 	blge	5fdc <DataStageIn+0x84>
  vSetEPTxStatus(EP_TX_VALID);
    5fd4:	1800002f 	stmdane	r0, {r0, r1, r2, r3, r5}
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
  pEPinfo->Usb_wOffset += Length;
    5fd8:	00000127 	andeq	r0, r0, r7, lsr #2
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */

Expect_Status_Out:
  pInformation->ControlState = ControlState;
    5fdc:	2b005501 	blcs	1b3e8 <_etext+0x13ed0>
    5fe0:	00000000 	andeq	r0, r0, r0
    5fe4:	000005d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    5fe8:	03510112 	cmpeq	r1, #-2147483644	; 0x80000004
    5fec:	125101f3 	subsne	r0, r1, #-1073741764	; 0xc000003c
    5ff0:	7d025001 	stcvc	0, cr5, [r2, #-4]
    5ff4:	2c000000 	stccs	0, cr0, [r0], {-0}
    5ff8:	00001800 	andeq	r1, r0, r0, lsl #16
    5ffc:	01011501 	tsteq	r1, r1, lsl #10
* Output         : None.
* Return         : Return USB_SUCCESS, if the request is performed.
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{
    6000:	00000a9b 	muleq	r0, fp, sl

  if ((pInformation->USBwValue0 <=
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
    6004:	0100722d 	tsteq	r0, sp, lsr #4
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{

  if ((pInformation->USBwValue0 <=
    6008:	010a0115 	tsteq	sl, r5, lsl r1
    600c:	782d0000 	stmdavc	sp!, {}	; <UNPREDICTABLE>
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
    6010:	01150100 	tsteq	r5, r0, lsl #2
      && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
    6014:	00000110 	andeq	r0, r0, r0, lsl r1
  {
    pInformation->Current_Configuration = pInformation->USBwValue0;
    6018:	0100732d 	tsteq	r0, sp, lsr #6
    pUser_Standard_Requests->User_SetConfiguration();
    601c:	010a0115 	tsteq	sl, r5, lsl r1
    6020:	692e0000 	stmdbvs	lr!, {}	; <UNPREDICTABLE>
    return USB_SUCCESS;
    6024:	01170100 	tsteq	r7, r0, lsl #2
  }
  else
  {
    return USB_UNSUPPORT;
  }
}
    6028:	0000007e 	andeq	r0, r0, lr, ror r0
    602c:	16682800 	strbtne	r2, [r8], -r0, lsl #16
    6030:	30010000 	andcc	r0, r1, r0
    6034:	00280801 	eoreq	r0, r8, r1, lsl #16
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetInterface(void)
{
    6038:	00063400 	andeq	r3, r6, r0, lsl #8
  RESULT Re;
  /*Test if the specified Interface and Alternate Setting are supported by
    the application Firmware*/
  Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
    603c:	619c0100 	orrsvs	r0, ip, r0, lsl #2
    6040:	2900000f 	stmdbcs	r0, {r0, r1, r2, r3}
    6044:	30010072 	andcc	r0, r1, r2, ror r0
    6048:	00010a01 	andeq	r0, r1, r1, lsl #20

  if (pInformation->Current_Configuration != 0)
    604c:	002fcb00 	eoreq	ip, pc, r0, lsl #22
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
    6050:	00612900 	rsbeq	r2, r1, r0, lsl #18
    6054:	10013001 	andne	r3, r1, r1
        || (pInformation->USBwValue1 != 0))
    6058:	f8000001 			; <UNDEFINED> instruction: 0xf8000001
    {
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
    605c:	2a00002f 	bcs	6120 <Standard_ClearFeature+0xa0>
    6060:	32010076 	andcc	r0, r1, #118	; 0x76
      pInformation->Current_Interface = pInformation->USBwIndex0;
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
      return USB_SUCCESS;
    6064:	00023d01 	andeq	r3, r2, r1, lsl #26
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
      pInformation->Current_Interface = pInformation->USBwIndex0;
    6068:	e0910300 	adds	r0, r1, r0, lsl #6
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
    606c:	00692a7e 	rsbeq	r2, r9, lr, ror sl
      return USB_SUCCESS;
    }

  }

  return USB_UNSUPPORT;
    6070:	3d013301 	stccc	3, cr3, [r1, #-4]
}
    6074:	03000002 	movweq	r0, #2
    6078:	2a7f8091 	bcs	1fe62c4 <_etext+0x1fdedac>
    607c:	34010078 	strcc	r0, [r1], #-120	; 0x78
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_ClearFeature(void)
{
    6080:	00023d01 	andeq	r3, r2, r1, lsl #26
  u32     Type_Rec = Type_Recipient;
    6084:	a0910300 	addsge	r0, r1, r0, lsl #6
  u32     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6088:	00792a7f 	rsbseq	r2, r9, pc, ror sl
    608c:	3d013501 	cfstr32cc	mvfx3, [r1, #-4]
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
    6090:	02000002 	andeq	r0, r0, #2
    6094:	592f4091 	stmdbpl	pc!, {r0, r4, r7, lr}	; <UNPREDICTABLE>
    return USB_SUCCESS;
  }
  else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    6098:	0c000005 	stceq	0, cr0, [r0], {5}
    DEVICE* pDev;
    u32 Related_Endpoint;
    u32 wIndex0;
    u32 rEP;

    if ((pInformation->USBwValue != ENDPOINT_STALL)
    609c:	b8000028 	stmdalt	r0, {r3, r5}
    60a0:	01000005 	tsteq	r0, r5
        || (pInformation->USBwIndex1 != 0))
    60a4:	0b490138 	bleq	124658c <_etext+0x123f074>
    {
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    60a8:	77300000 	ldrvc	r0, [r0, -r0]!
    rEP = wIndex0 & ~0x80;
    60ac:	02000005 	andeq	r0, r0, #5
    60b0:	00056e0f 	andeq	r6, r5, pc, lsl #28

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
    60b4:	00303000 	eorseq	r3, r0, r0
    60b8:	05650f00 	strbeq	r0, [r5, #-3840]!	; 0xf00
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    60bc:	30680000 	rsbcc	r0, r8, r0
    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    rEP = wIndex0 & ~0x80;
    Related_Endpoint = ENDP0 + rEP;

    if (ValBit(pInformation->USBwIndex0, 7))
    60c0:	b8190000 	ldmdalt	r9, {}	; <UNPREDICTABLE>
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
    60c4:	10000005 	andne	r0, r0, r5
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    60c8:	00000580 	andeq	r0, r0, r0, lsl #11
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    60cc:	00003097 	muleq	r0, r7, r0
    60d0:	00058910 	andeq	r8, r5, r0, lsl r9
        || (pInformation->Current_Configuration == 0))
    60d4:	0030c500 	eorseq	ip, r0, r0, lsl #10


    if (wIndex0 & 0x80)
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    60d8:	26000000 	strcs	r0, [r0], -r0
    60dc:	00000a65 	andeq	r0, r0, r5, ror #20
    {
      return USB_UNSUPPORT;
    }


    if (wIndex0 & 0x80)
    60e0:	0000285c 	andeq	r2, r0, ip, asr r8
    60e4:	00000394 	muleq	r0, r4, r3
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    60e8:	b1013901 	tstlt	r1, r1, lsl #18
    60ec:	2400000d 	strcs	r0, [r0], #-13
      {
        ClearDTOG_TX(Related_Endpoint);
    60f0:	00000a86 	andeq	r0, r0, r6, lsl #21
    60f4:	000a7c24 	andeq	r7, sl, r4, lsr #24
        SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
    60f8:	0a722400 	beq	1c8f100 <_etext+0x1c87be8>
    60fc:	5c200000 	stcpl	0, cr0, [r0], #-0
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
    6100:	94000028 	strls	r0, [r0], #-40	; 0x28
    6104:	31000003 	tstcc	r0, r3
    6108:	00000a90 	muleq	r0, r0, sl
      {
        if (Related_Endpoint == ENDP0)
        {
          /* After clear the STALL, enable the default endpoint receiver */
          SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
    610c:	0003fb26 	andeq	pc, r3, r6, lsr #22
    6110:	00285c00 	eoreq	r5, r8, r0, lsl #24
    6114:	00007a00 	andeq	r7, r0, r0, lsl #20
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
        }
        else
        {
          ClearDTOG_RX(Related_Endpoint);
    6118:	011f0100 	tsteq	pc, r0, lsl #2
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
    611c:	00000bcd 	andeq	r0, r0, sp, asr #23
    6120:	00041924 	andeq	r1, r4, r4, lsr #18
    6124:	04102400 	ldreq	r2, [r0], #-1024	; 0x400
    6128:	07240000 	streq	r0, [r4, -r0]!
    612c:	20000004 	andcs	r0, r0, r4
        }
      }
    }
    pUser_Standard_Requests->User_ClearFeature();
    6130:	0000285c 	andeq	r2, r0, ip, asr r8
    6134:	0000007a 	andeq	r0, r0, sl, ror r0
    return USB_SUCCESS;
    6138:	00042210 	andeq	r2, r4, r0, lsl r2
  }

  return USB_UNSUPPORT;
}
    613c:	00312600 	eorseq	r2, r1, r0, lsl #12
    6140:	042b1000 	strteq	r1, [fp], #-0
    6144:	31440000 	mrscc	r0, (UNDEF: 68)
    6148:	5c200000 	stcpl	0, cr0, [r0], #-0
    614c:	42000028 	andmi	r0, r0, #40	; 0x28
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetEndPointFeature(void)
{
    6150:	10000000 	andne	r0, r0, r0
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    6154:	00000435 	andeq	r0, r0, r5, lsr r4
    6158:	0000319c 	muleq	r0, ip, r1
  u32    Related_Endpoint;
  u32    rEP;
  u32   Status;

  wIndex0 = pInformation->USBwIndex0;
  rEP = wIndex0 & ~0x80;
    615c:	2f000000 	svccs	0x00000000
    6160:	000003fb 	strdeq	r0, [r0], -fp

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
    6164:	000028d6 	ldrdeq	r2, [r0], -r6
    6168:	000005d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>

  wIndex0 = pInformation->USBwIndex0;
  rEP = wIndex0 & ~0x80;
  Related_Endpoint = ENDP0 + rEP;

  if (ValBit(pInformation->USBwIndex0, 7))
    616c:	1c012001 	stcne	0, cr2, [r1], {1}
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
    6170:	2400000c 	strcs	r0, [r0], #-12
    6174:	00000419 	andeq	r0, r0, r9, lsl r4
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
    6178:	00041024 	andeq	r1, r4, r4, lsr #32
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    617c:	04072400 	streq	r2, [r7], #-1024	; 0x400
      || pInformation->USBwValue != 0 || Status == 0
    6180:	d0190000 	andsle	r0, r9, r0
      || pInformation->Current_Configuration == 0)
    6184:	10000005 	andne	r0, r0, r5
  else
  {
    if (wIndex0 & 0x80)
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6188:	00000422 	andeq	r0, r0, r2, lsr #8
    618c:	00003216 	andeq	r3, r0, r6, lsl r2
  {
    return USB_UNSUPPORT;
  }
  else
  {
    if (wIndex0 & 0x80)
    6190:	00042b10 	andeq	r2, r4, r0, lsl fp
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6194:	00323400 	eorseq	r3, r2, r0, lsl #8
    6198:	28d62000 	ldmcs	r6, {sp}^
    619c:	00440000 	subeq	r0, r4, r0
    61a0:	35100000 	ldrcc	r0, [r0, #-0]
    61a4:	89000004 	stmdbhi	r0, {r2}
    }

    else
    {
      /* OUT endpoint */
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    61a8:	00000032 	andeq	r0, r0, r2, lsr r0
    61ac:	fb2f0000 	blx	bc61b6 <_etext+0xbbec9e>
    61b0:	5a000003 	bpl	61c4 <Standard_SetEndPointFeature+0x74>
    61b4:	e8000029 	stmda	r0, {r0, r3, r5}
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
    61b8:	01000005 	tsteq	r0, r5
    61bc:	0c670124 	stfeqe	f0, [r7], #-144	; 0xffffff70
  return USB_SUCCESS;
    61c0:	19240000 	stmdbne	r4!, {}	; <UNPREDICTABLE>

  if (Related_Endpoint >= Device_Table.Total_Endpoint
      || pInformation->USBwValue != 0 || Status == 0
      || pInformation->Current_Configuration == 0)
  {
    return USB_UNSUPPORT;
    61c4:	24000004 	strcs	r0, [r0], #-4
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
  return USB_SUCCESS;
}
    61c8:	00000410 	andeq	r0, r0, r0, lsl r4
    61cc:	00040724 	andeq	r0, r4, r4, lsr #14
    61d0:	05e81900 	strbeq	r1, [r8, #2304]!	; 0x900
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetDeviceFeature(void)
{
    61d4:	22100000 	andscs	r0, r0, #0
  SetBit(pInformation->Current_Feature, 5);
    61d8:	06000004 	streq	r0, [r0], -r4
    61dc:	10000033 	andne	r0, r0, r3, lsr r0
    61e0:	0000042b 	andeq	r0, r0, fp, lsr #8
  pUser_Standard_Requests->User_SetDeviceFeature();
    61e4:	00003330 	andeq	r3, r0, r0, lsr r3
    61e8:	00060019 	andeq	r0, r6, r9, lsl r0
  return USB_SUCCESS;
}
    61ec:	04351000 	ldrteq	r1, [r5], #-0
    61f0:	33940000 	orrscc	r0, r4, #0
    61f4:	00000000 	andeq	r0, r0, r0
*******************************************************************************/
u8 *Standard_GetDescriptorData(u16 Length, ONE_DESCRIPTOR *pDesc)
{
  u32  wOffset;

  wOffset = pInformation->Ctrl_Info.Usb_wOffset;
    61f8:	03fb2600 	mvnseq	r2, #0, 12
    61fc:	29ea0000 	stmibcs	sl!, {}^	; <UNPREDICTABLE>
  if (Length == 0)
  {
    pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
    6200:	00820000 	addeq	r0, r2, r0
    6204:	25010000 	strcs	r0, [r1, #-0]
    return 0;
  }

  return pDesc->Descriptor + wOffset;
    6208:	000cba01 	andeq	fp, ip, r1, lsl #20
}
    620c:	04192400 	ldreq	r2, [r9], #-1024	; 0x400
    6210:	10240000 	eorne	r0, r4, r0
* Output         : None.
* Return         : - 0 if the control State is in PAUSE
*                  - 1 if not.
*******************************************************************************/
u8 Post0_Process(void)
{
    6214:	24000004 	strcs	r0, [r0], #-4
  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
    6218:	00000407 	andeq	r0, r0, r7, lsl #8
    621c:	0029ea20 	eoreq	lr, r9, r0, lsr #20
    6220:	00008200 	andeq	r8, r0, r0, lsl #4

  if (pInformation->ControlState == STALLED)
    6224:	04221000 	strteq	r1, [r2], #-0
    6228:	340e0000 	strcc	r0, [lr], #-0
  {
    vSetEPRxStatus(EP_RX_STALL);
    622c:	2b100000 	blcs	406234 <_etext+0x3fed1c>
    6230:	2c000004 	stccs	0, cr0, [r0], {4}
    vSetEPTxStatus(EP_TX_STALL);
    6234:	20000034 	andcs	r0, r0, r4, lsr r0
    6238:	000029ea 	andeq	r2, r0, sl, ror #19
  }

  return (pInformation->ControlState == PAUSE);
}
    623c:	0000004a 	andeq	r0, r0, sl, asr #32
    6240:	00043510 	andeq	r3, r4, r0, lsl r5
    6244:	00348100 	eorseq	r8, r4, r0, lsl #2
    6248:	00000000 	andeq	r0, r0, r0
    624c:	0003fb26 	andeq	pc, r3, r6, lsr #22
    6250:	002a7e00 	eoreq	r7, sl, r0, lsl #28
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 Setup0_Process(void)
{
    6254:	00007c00 	andeq	r7, r0, r0, lsl #24
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    6258:	01290100 	teqeq	r9, r0, lsl #2

  if (pInformation->ControlState != PAUSE)
    625c:	00000d0d 	andeq	r0, r0, sp, lsl #26
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    6260:	00041924 	andeq	r1, r4, r4, lsr #18
    6264:	04102400 	ldreq	r2, [r0], #-1024	; 0x400

  if (pInformation->ControlState != PAUSE)
    6268:	07240000 	streq	r0, [r4, -r0]!
    626c:	20000004 	andcs	r0, r0, r4
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    6270:	00002a7e 	andeq	r2, r0, lr, ror sl
    6274:	0000007c 	andeq	r0, r0, ip, ror r0
    6278:	00042210 	andeq	r2, r4, r0, lsl r2

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
    627c:	0034fe00 	eorseq	pc, r4, r0, lsl #28
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
    6280:	042b1000 	strteq	r1, [fp], #-0
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = *pBuf.w++; /* wValue in Little Endian */
    6284:	351c0000 	ldrcc	r0, [ip, #-0]
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = *pBuf.w++; /* wIndex in Little Endian */
    6288:	7e200000 	cdpvc	0, 2, cr0, cr0, cr0, {0}
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwLength = *pBuf.w; /* wLength in Little Endian */
    628c:	4600002a 	strmi	r0, [r0], -sl, lsr #32
  }

  pInformation->ControlState = SETTING_UP;
    6290:	10000000 	andne	r0, r0, r0
  if (pInformation->USBwLength == 0)
    6294:	00000435 	andeq	r0, r0, r5, lsr r4
    6298:	00003574 	andeq	r3, r0, r4, ror r5
{
  RESULT Result = USB_UNSUPPORT;
  u32 RequestNo = pInformation->USBbRequest;
  u32 ControlState;

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    629c:	26000000 	strcs	r0, [r0], -r0
    62a0:	000003fb 	strdeq	r0, [r0], -fp
  {
    /* Device Request*/
    /* SET_CONFIGURATION*/
    if (RequestNo == SET_CONFIGURATION)
    62a4:	00002afa 	strdeq	r2, [r0], -sl
    {
      Result = Standard_SetConfiguration();
    62a8:	0000007e 	andeq	r0, r0, lr, ror r0
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    62ac:	60012c01 	andvs	r2, r1, r1, lsl #24
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
    62b0:	2400000d 	strcs	r0, [r0], #-13
    62b4:	00000419 	andeq	r0, r0, r9, lsl r4
          || (pInformation->USBwIndex != 0)
          || (pInformation->Current_Configuration != 0))
        /* Device Address should be 127 or less*/
      {
        ControlState = STALLED;
    62b8:	00041024 	andeq	r1, r4, r4, lsr #32
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
    62bc:	04072400 	streq	r2, [r7], #-1024	; 0x400
    62c0:	fa200000 	blx	8062c8 <_etext+0x7fedb0>
          || (pInformation->USBwIndex != 0)
    62c4:	7e00002a 	cdpvc	0, 0, cr0, cr0, cr10, {1}
          || (pInformation->Current_Configuration != 0))
    62c8:	10000000 	andne	r0, r0, r0
    62cc:	00000422 	andeq	r0, r0, r2, lsr #8
      {
        Result = USB_SUCCESS;
      }
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    62d0:	000035ee 	andeq	r3, r0, lr, ror #11
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
    62d4:	00042b10 	andeq	r2, r4, r0, lsl fp
    62d8:	00360c00 	eorseq	r0, r6, r0, lsl #24
  }


  if (Result != USB_SUCCESS)
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    62dc:	2afa2000 	bcs	ffe8e2e4 <BootRAM+0xedfea85>
    62e0:	00460000 	subeq	r0, r6, r0
    if (Result == USB_NOT_READY)
    62e4:	35100000 	ldrcc	r0, [r0, #-0]
    62e8:	61000004 	tstvs	r0, r4
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
          && (pInformation->USBwIndex == 0)
    62ec:	00000036 	andeq	r0, r0, r6, lsr r0
          && (ValBit(pInformation->Current_Feature, 5)))
    62f0:	fb270000 	blx	9c62fa <_etext+0x9bede2>
    62f4:	78000003 	stmdavc	r0, {r0, r1}
      {
        Result = Standard_SetDeviceFeature();
    62f8:	7800002b 	stmdavc	r0, {r0, r1, r3, r5}
      {
        Result = USB_UNSUPPORT;
      }
    }
    /*Clear FEATURE for Device */
    else if (RequestNo == CLEAR_FEATURE)
    62fc:	01000000 	mrseq	r0, (UNDEF: 0)
    {
      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
    6300:	1924012d 	stmdbne	r4!, {r0, r2, r3, r5, r8}
    6304:	24000004 	strcs	r0, [r0], #-4
          && pInformation->USBwIndex == 0
    6308:	00000410 	andeq	r0, r0, r0, lsl r4
          && ValBit(pInformation->Current_Feature, 5))
    630c:	00040724 	andeq	r0, r4, r4, lsr #14
    6310:	2b782000 	blcs	1e0e318 <_etext+0x1e06e00>
      {
        Result = Standard_ClearFeature();
    6314:	00780000 	rsbseq	r0, r8, r0
    }

  }

  /* Interface Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    6318:	22100000 	andscs	r0, r0, #0
  {
    /*SET INTERFACE*/
    if (RequestNo == SET_INTERFACE)
    631c:	de000004 	cdple	0, 0, cr0, cr0, cr4, {0}
    {
      Result = Standard_SetInterface();
    6320:	10000036 	andne	r0, r0, r6, lsr r0
    6324:	0000042b 	andeq	r0, r0, fp, lsr #8
    }
  }

  /* EndPoint Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    6328:	000036fc 	strdeq	r3, [r0], -ip
  {
    /*CLEAR FEATURE for EndPoint*/
    if (RequestNo == CLEAR_FEATURE)
    632c:	002b7820 	eoreq	r7, fp, r0, lsr #16
    {
      Result = Standard_ClearFeature();
    }
    /* SET FEATURE for EndPoint*/
    else if (RequestNo == SET_FEATURE)
    6330:	00004200 	andeq	r4, r0, r0, lsl #4
    {
      Result = Standard_SetEndPointFeature();
    6334:	04351000 	ldrteq	r1, [r5], #-0
  {
    Result = USB_UNSUPPORT;
  }


  if (Result != USB_SUCCESS)
    6338:	37540000 	ldrbcc	r0, [r4, -r0]
      ControlState = PAUSE;
      goto exit_NoData_Setup0;
    }
  }

  if (Result != USB_SUCCESS)
    633c:	00000000 	andeq	r0, r0, r0
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();
    6340:	26000000 	strcs	r0, [r0], -r0
    6344:	000003fb 	strdeq	r0, [r0], -fp
    6348:	00002bf0 	strdeq	r2, [r0], -r0
    634c:	00000080 	andeq	r0, r0, r0, lsl #1
    6350:	04013c01 	streq	r3, [r1], #-3073	; 0xc01
  {
    ControlState = STALLED;
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
    6354:	2400000e 	strcs	r0, [r0], #-14

  USB_StatusIn();

exit_NoData_Setup0:
  pInformation->ControlState = ControlState;
    6358:	00000419 	andeq	r0, r0, r9, lsl r4
    635c:	00041024 	andeq	r1, r4, r4, lsr #32


  CopyRoutine = NULL;
  wOffset = 0;

  if (Request_No == GET_DESCRIPTOR)
    6360:	04072400 	streq	r2, [r7], #-1024	; 0x400
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6364:	f0200000 			; <UNDEFINED> instruction: 0xf0200000
    {
      u8 wValue1 = pInformation->USBwValue1;
    6368:	8000002b 	andhi	r0, r0, fp, lsr #32
      if (wValue1 == DEVICE_DESCRIPTOR)
    636c:	10000000 	andne	r0, r0, r0
      {
        CopyRoutine = pProperty->GetDeviceDescriptor;
    6370:	00000422 	andeq	r0, r0, r2, lsr #8
    6374:	000037ce 	andeq	r3, r0, lr, asr #15
      }
      else if (wValue1 == CONFIG_DESCRIPTOR)
    6378:	00042b10 	andeq	r2, r4, r0, lsl fp
      {
        CopyRoutine = pProperty->GetConfigDescriptor;
    637c:	0037ec00 	eorseq	lr, r7, r0, lsl #24
      }
      else if (wValue1 == STRING_DESCRIPTOR)
    6380:	2bf02000 	blcs	ffc0e388 <BootRAM+0xeb7eb29>
      {
        CopyRoutine = pProperty->GetStringDescriptor;
    6384:	00460000 	subeq	r0, r6, r0
    6388:	35100000 	ldrcc	r0, [r0, #-0]
      } else if (wValue1 == 0x21) /* added to support functional descriptors */
    638c:	41000004 	tstmi	r0, r4
      {
	CopyRoutine = pProperty->GetFunctionalDescriptor;
    6390:	00000038 	andeq	r0, r0, r8, lsr r0
      } /* End of GET_DESCRIPTOR */
    }
  }

  /*GET STATUS*/
  else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
    6394:	fb260000 	blx	98639e <_etext+0x97ee86>
    6398:	70000003 	andvc	r0, r0, r3
    639c:	7000002c 	andvc	r0, r0, ip, lsr #32
           && (pInformation->USBwLength == 0x0002)
           && (pInformation->USBwIndex1 == 0))
    63a0:	01000000 	mrseq	r0, (UNDEF: 0)
    63a4:	0e57013d 	mrceq	1, 2, r0, cr7, cr13, {1}
    63a8:	19240000 	stmdbne	r4!, {}	; <UNPREDICTABLE>
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    63ac:	24000004 	strcs	r0, [r0], #-4
    63b0:	00000410 	andeq	r0, r0, r0, lsl r4
        && (pInformation->USBwIndex == 0))
    63b4:	00040724 	andeq	r0, r4, r4, lsr #14
    63b8:	2c702000 	ldclcs	0, cr2, [r0], #-0
    {
      CopyRoutine = Standard_GetStatus;
    }

    /* GET STATUS for Interface*/
    else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    63bc:	00700000 	rsbseq	r0, r0, r0
    {
      if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
    63c0:	22100000 	andscs	r0, r0, #0
    63c4:	be000004 	cdplt	0, 0, cr0, cr0, cr4, {0}
    63c8:	10000038 	andne	r0, r0, r8, lsr r0
    63cc:	0000042b 	andeq	r0, r0, fp, lsr #8
          && (pInformation->Current_Configuration != 0))
    63d0:	000038dc 	ldrdeq	r3, [r0], -ip
    63d4:	002c7020 	eoreq	r7, ip, r0, lsr #32
    63d8:	00004000 	andeq	r4, r0, r0
        CopyRoutine = Standard_GetStatus;
      }
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    63dc:	04351000 	ldrteq	r1, [r5], #-0
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    63e0:	39330000 	ldmdbcc	r3!, {}	; <UNPREDICTABLE>
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
    63e4:	00000000 	andeq	r0, r0, r0

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
    63e8:	013a2600 	teqeq	sl, r0, lsl #12
    63ec:	2ce00000 	stclcs	0, cr0, [r0]
    63f0:	00140000 	andseq	r0, r4, r0
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
      Reserved = pInformation->USBwIndex0 & 0x70;

      if (ValBit(pInformation->USBwIndex0, 7))
    63f4:	3e010000 	cdpcc	0, 0, cr0, cr1, cr0, {0}
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
    63f8:	000e8a01 	andeq	r8, lr, r1, lsl #20
    63fc:	014f3000 	mrseq	r3, SPSR
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
    6400:	24000000 	strcs	r0, [r0], #-0
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    6404:	00000146 	andeq	r0, r0, r6, asr #2
    6408:	002ce020 	eoreq	lr, ip, r0, lsr #32
          && (Status != 0))
    640c:	00001400 	andeq	r1, r0, r0, lsl #8
    6410:	01581000 	cmpeq	r8, r0
    }

  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
    6414:	39ad0000 	stmibcc	sp!, {}	; <UNPREDICTABLE>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6418:	00000000 	andeq	r0, r0, r0
    641c:	00033a2f 	andeq	r3, r3, pc, lsr #20
    {
      CopyRoutine = Standard_GetConfiguration;
    }
  }
  /*GET INTERFACE*/
  else if (Request_No == GET_INTERFACE)
    6420:	002cf400 	eoreq	pc, ip, r0, lsl #8
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    6424:	00061800 	andeq	r1, r6, r0, lsl #16
    6428:	013f0100 	teqeq	pc, r0, lsl #2
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
    642c:	00000ec6 	andeq	r0, r0, r6, asr #29
    6430:	00035824 	andeq	r5, r3, r4, lsr #16
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
    6434:	034f2400 	movteq	r2, #62464	; 0xf400
    6438:	46240000 	strtmi	r0, [r4], -r0
    643c:	19000003 	stmdbne	r0, {r0, r1}
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
    6440:	00000618 	andeq	r0, r0, r8, lsl r6
    6444:	00036110 	andeq	r6, r3, r0, lsl r1
    6448:	0039cd00 	eorseq	ip, r9, r0, lsl #26
    644c:	036a1000 	cmneq	sl, #0
      CopyRoutine = Standard_GetInterface;
    }

  }

  if (CopyRoutine)
    6450:	39f60000 	ldmibcc	r6!, {}^	; <UNPREDICTABLE>
  {
    pInformation->Ctrl_Info.Usb_wOffset = wOffset;
    6454:	00000000 	andeq	r0, r0, r0
    pInformation->Ctrl_Info.CopyData = CopyRoutine;
    6458:	0003fb2f 	andeq	pc, r3, pc, lsr #22
    /* sb in the original the cast to word was directly */
    /* now the cast is made step by step */
    (*CopyRoutine)(0);
    645c:	002d3e00 	eoreq	r3, sp, r0, lsl #28
    Result = USB_SUCCESS;
    6460:	00063000 	andeq	r3, r6, r0
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
    6464:	01420100 	mrseq	r0, (UNDEF: 82)
    6468:	00000f11 	andeq	r0, r0, r1, lsl pc
    646c:	00041924 	andeq	r1, r4, r4, lsr #18
    if (Result == USB_NOT_READY)
    6470:	04102400 	ldreq	r2, [r0], #-1024	; 0x400
    {
      pInformation->ControlState = PAUSE;
    6474:	07240000 	streq	r0, [r4, -r0]!
      return;
    }
  }

  if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
    6478:	19000004 	stmdbne	r0, {r2}
    647c:	00000630 	andeq	r0, r0, r0, lsr r6
    6480:	00042210 	andeq	r2, r4, r0, lsl r2
  {
    /* Data is not ready, wait it */
    pInformation->ControlState = PAUSE;
    6484:	003a5900 	eorseq	r5, sl, r0, lsl #18
    return;
  }
  if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
    6488:	042b1000 	strteq	r1, [fp], #-0
    648c:	3a770000 	bcc	1dc6494 <_etext+0x1dbef7c>
  {
    /* Unsupported request */
    pInformation->ControlState = STALLED;
    6490:	48190000 	ldmdami	r9, {}	; <UNPREDICTABLE>
    return;
  }


  if (ValBit(pInformation->USBbmRequestType, 7))
    6494:	10000006 	andne	r0, r0, r6
    6498:	00000435 	andeq	r0, r0, r5, lsr r4
  {
    /* Device ==> Host */
    vu32 wLength = pInformation->USBwLength;
    649c:	00003acc 	andeq	r3, r0, ip, asr #21

    /* Restrict the data length to be the one host asks */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
    64a0:	27000000 	strcs	r0, [r0, -r0]
    64a4:	000003fb 	strdeq	r0, [r0], -fp
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
    64a8:	00002dc4 	andeq	r2, r0, r4, asr #27
    64ac:	00000070 	andeq	r0, r0, r0, ror r0
    64b0:	24014301 	strcs	r4, [r1], #-769	; 0x301
    64b4:	00000419 	andeq	r0, r0, r9, lsl r4
    64b8:	00041024 	andeq	r1, r4, r4, lsr #32
    64bc:	04072400 	streq	r2, [r7], #-1024	; 0x400
    64c0:	c4200000 	strtgt	r0, [r0], #-0
    64c4:	7000002d 	andvc	r0, r0, sp, lsr #32
    64c8:	10000000 	andne	r0, r0, r0
    }

    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
    64cc:	00000422 	andeq	r0, r0, r2, lsr #8
    {
      if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
    64d0:	00003b49 	andeq	r3, r0, r9, asr #22
    64d4:	00042b10 	andeq	r2, r4, r0, lsl fp
    64d8:	003b6700 	eorseq	r6, fp, r0, lsl #14
      {
        Data_Mul_MaxPacketSize = FALSE;
    64dc:	2dc42000 	stclcs	0, cr2, [r4]
      }
      else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
    64e0:	00420000 	subeq	r0, r2, r0
    64e4:	35100000 	ldrcc	r0, [r0, #-0]
      {
        Data_Mul_MaxPacketSize = TRUE;
    64e8:	a9000004 	stmdbge	r0, {r2}
    64ec:	0000003b 	andeq	r0, r0, fp, lsr r0
      }
    }

    pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
    64f0:	32000000 	andcc	r0, r0, #0
    64f4:	000017f4 	strdeq	r1, [r0], -r4
    DataStageIn();
    64f8:	0f720901 	svceq	0x00720901
  }
  else
  {
    pInformation->ControlState = OUT_DATA;
    64fc:	03050000 	movweq	r0, #20480	; 0x5000
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
    6500:	00000000 	andeq	r0, r0, r0
    6504:	00023d0c 	andeq	r3, r2, ip, lsl #26
  else
  {
    /* Setup with data stage */
    Data_Setup0();
  }
  return Post0_Process();
    6508:	14973200 	ldrne	r3, [r7], #512	; 0x200
}
    650c:	0a010000 	beq	46514 <_etext+0x3effc>
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
        && (pInformation->USBwIndex == 0))
    {
      CopyRoutine = Standard_GetStatus;
    6510:	00000f88 	andeq	r0, r0, r8, lsl #31
  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    {
      CopyRoutine = Standard_GetConfiguration;
    6514:	71e40305 	mvnvc	r0, r5, lsl #6
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
    {
      CopyRoutine = Standard_GetInterface;
    6518:	3d0c0000 	stccc	0, cr0, [ip, #-0]
    651c:	33000002 	movwcc	r0, #2
    6520:	00000fff 	strdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    6524:	000000b4 	strheq	r0, [r0], -r4
    6528:	0000b434 	andeq	fp, r0, r4, lsr r4
    652c:	007e3400 	rsbseq	r3, lr, r0, lsl #8
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 Out0_Process(void)
{
    6530:	ad340000 	ldcge	0, cr0, [r4, #-0]
  u32 ControlState = pInformation->ControlState;
    6534:	00000000 	andeq	r0, r0, r0

  if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
    6538:	000d7000 	andeq	r7, sp, r0
    653c:	57000400 	strpl	r0, [r0, -r0, lsl #8]
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  u32 save_rLength;

  save_rLength = pEPinfo->Usb_rLength;

  if (pEPinfo->CopyData && save_rLength)
    6540:	04000017 	streq	r0, [r0], #-23
    6544:	0014b401 	andseq	fp, r4, r1, lsl #8
  {
    u8 *Buffer;
    u32 Length;

    Length = pEPinfo->PacketSize;
    6548:	19000100 	stmdbne	r0, {r8}
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    654c:	08930000 	ldmeq	r3, {}	; <UNPREDICTABLE>
    6550:	08380000 	ldmdaeq	r8!, {}	; <UNPREDICTABLE>
    pEPinfo->Usb_rLength -= Length;
    6554:	00000000 	andeq	r0, r0, r0
    6558:	1e220000 	cdpne	0, 2, cr0, cr2, cr0, {0}
    pEPinfo->Usb_rOffset += Length;
    655c:	01020000 	mrseq	r0, (UNDEF: 2)
    6560:	00081a06 	andeq	r1, r8, r6, lsl #20

    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
    6564:	0b010300 	bleq	4716c <_etext+0x3fc54>
    6568:	1c030000 	stcne	0, cr0, [r3], {-0}
    656c:	00000037 	andeq	r0, r0, r7, lsr r0
    6570:	18080102 	stmdane	r8, {r1, r8}
  }

  if (pEPinfo->Usb_rLength != 0)
    6574:	02000008 	andeq	r0, r0, #8
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    SetEPTxCount(ENDP0, 0);
    6578:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
  }

  if (pEPinfo->Usb_rLength != 0)
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    657c:	af030000 	svcge	0x00030000
    6580:	0300000d 	movweq	r0, #13
    SetEPTxCount(ENDP0, 0);
    6584:	00005026 	andeq	r5, r0, r6, lsr #32
    vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
    6588:	07020200 	streq	r0, [r2, -r0, lsl #4]
  }
  /* Set the next State*/
  if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
    658c:	00000949 	andeq	r0, r0, r9, asr #18
    6590:	da050402 	ble	1475a0 <_etext+0x140088>
  {
    pInformation->ControlState = OUT_DATA;
    6594:	03000004 	movweq	r0, #4
    6598:	00000ace 	andeq	r0, r0, lr, asr #21
  }
  else
  {
    if (pEPinfo->Usb_rLength > 0)
    {
      pInformation->ControlState = LAST_OUT_DATA;
    659c:	00693803 	rsbeq	r3, r9, r3, lsl #16
    65a0:	04020000 	streq	r0, [r2], #-0
    }
    else if (pEPinfo->Usb_rLength == 0)
    {
      pInformation->ControlState = WAIT_STATUS_IN;
    65a4:	00025207 	andeq	r5, r2, r7, lsl #4
    65a8:	05080200 	streq	r0, [r8, #-512]	; 0x200
      USB_StatusIn();
    65ac:	000004d5 	ldrdeq	r0, [r0], -r5
    65b0:	4d070802 	stcmi	8, cr0, [r7, #-8]
    65b4:	04000002 	streq	r0, [r0], #-2
    65b8:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    65bc:	04020074 	streq	r0, [r2], #-116	; 0x74
  u32 ControlState = pInformation->ControlState;

  if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
  {
    DataStageOut();
    ControlState = pInformation->ControlState; /* may be changed outside the function */
    65c0:	00025707 	andeq	r5, r2, r7, lsl #14
  }

  else if (ControlState == WAIT_STATUS_OUT)
    65c4:	0b030300 	bleq	c71cc <_etext+0xbfcb4>
  {
    (*pProperty->Process_Status_OUT)();
    65c8:	2a040000 	bcs	1065d0 <_etext+0xff0b8>
    65cc:	0000002c 	andeq	r0, r0, ip, lsr #32
  }

  else if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
  {
    /* host aborts the transfer before finish */
    ControlState = STALLED;
    65d0:	000db103 	andeq	fp, sp, r3, lsl #2
  else
  {
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;
    65d4:	45360400 	ldrmi	r0, [r6, #-1024]!	; 0x400

  return Post0_Process();
}
    65d8:	03000000 	movweq	r0, #0
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
    65dc:	00000ad0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    65e0:	005e4204 	subseq	r4, lr, r4, lsl #4
    65e4:	c7030000 	strgt	r0, [r3, -r0]
    65e8:	0500000a 	streq	r0, [r0, #-10]
    65ec:	000085d4 	ldrdeq	r8, [r0], -r4
    65f0:	07040200 	streq	r0, [r4, -r0, lsl #4]
    65f4:	0000078b 	andeq	r0, r0, fp, lsl #15
* Input          : - Val: device adress.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetDeviceAddress(u8 Val)
{
    65f8:	01020405 	tsteq	r2, r5, lsl #8
  u32 i;
  u32 nEP = Device_Table.Total_Endpoint;
    65fc:	00082108 	andeq	r2, r8, r8, lsl #2

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
    6600:	187d0600 	ldmdane	sp!, {r9, sl}^
    6604:	8f010000 	svchi	0x00010000
    6608:	00011501 	andeq	r1, r1, r1, lsl #10
    660c:	73640700 	cmnvc	r4, #0, 14
  {
    _SetEPAddress((u8)i, (u8)i);
    6610:	8f010074 	svchi	0x00010074
    6614:	00000115 	andeq	r0, r0, r5, lsl r1
    6618:	0017fb08 	andseq	pc, r7, r8, lsl #22
{
  u32 i;
  u32 nEP = Device_Table.Total_Endpoint;

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
    661c:	1b900100 	blne	fe406a24 <BootRAM+0xd3771c5>
  {
    _SetEPAddress((u8)i, (u8)i);
  } /* for */
  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
    6620:	07000001 	streq	r0, [r0, -r1]
    6624:	00656e6f 	rsbeq	r6, r5, pc, ror #28
    6628:	011b9001 	tsteq	fp, r1
    662c:	2d080000 	stccs	0, cr0, [r8, #-0]
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 In0_Process(void)
{
    6630:	01000018 	tsteq	r0, r8, lsl r0
  u32 ControlState = pInformation->ControlState;
    6634:	00008c91 	muleq	r0, r1, ip

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
    6638:	0d270900 	stceq	9, cr0, [r7, #-0]
    663c:	93010000 	movwls	r0, #4096	; 0x1000
  {
    DataStageIn();
    6640:	00000121 	andeq	r0, r0, r1, lsr #2
    /* ControlState may be changed outside the function */
    ControlState = pInformation->ControlState;
    6644:	0100690a 	tsteq	r0, sl, lsl #18
    6648:	00007e94 	muleq	r0, r4, lr
  }

  else if (ControlState == WAIT_STATUS_IN)
    664c:	040b0000 	streq	r0, [fp], #-0
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
    6650:	0000008c 	andeq	r0, r0, ip, lsl #1
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    6654:	0121040b 	teqeq	r1, fp, lsl #8
    ControlState = pInformation->ControlState;
  }

  else if (ControlState == WAIT_STATUS_IN)
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
    6658:	8c0c0000 	stchi	0, cr0, [ip], {-0}
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    {
      SetDeviceAddress(pInformation->USBwValue0);
    665c:	0d000000 	stceq	0, cr0, [r0, #-0]
      pUser_Standard_Requests->User_SetDeviceAddress();
    6660:	000018a1 	andeq	r1, r0, r1, lsr #17
    6664:	007e5601 	rsbseq	r5, lr, r1, lsl #12
    }
    (*pProperty->Process_Status_IN)();
    6668:	49030000 	stmdbmi	r3, {}	; <UNPREDICTABLE>
    666c:	07000001 	streq	r0, [r0, -r1]
    ControlState = STALLED;
  }

  else
  {
    ControlState = STALLED;
    6670:	56010061 	strpl	r0, [r1], -r1, rrx
  }

  pInformation->ControlState = ControlState;
    6674:	0000007e 	andeq	r0, r0, lr, ror r0

  return Post0_Process();
}
    6678:	01006207 	tsteq	r0, r7, lsl #4
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
    667c:	00007e56 	andeq	r7, r0, r6, asr lr
    6680:	700e0000 	andvc	r0, lr, r0
    6684:	01000018 	tsteq	r0, r8, lsl r0
    6688:	017a013d 	cmneq	sl, sp, lsr r1
*                  - wNBytes: no. of bytes to be copied.
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
    668c:	78070000 	stmdavc	r7, {}	; <UNPREDICTABLE>
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
    6690:	153d0100 	ldrne	r0, [sp, #-256]!	; 0x100
    6694:	07000001 	streq	r0, [r0, -r1]
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
    6698:	3d01006e 	stccc	0, cr0, [r1, #-440]	; 0xfffffe48
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
    669c:	0000007e 	andeq	r0, r0, lr, ror r0
    66a0:	0100630a 	tsteq	r0, sl, lsl #6
    66a4:	0000973f 	andeq	r9, r0, pc, lsr r7
  {
    temp1 = (u16) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (u16) * pbUsrBuf << 8;
    66a8:	00690a00 	rsbeq	r0, r9, r0, lsl #20
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
  {
    temp1 = (u16) * pbUsrBuf;
    66ac:	007e4001 	rsbseq	r4, lr, r1
    pbUsrBuf++;
    temp2 = temp1 | (u16) * pbUsrBuf << 8;
    66b0:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    *pdwVal++ = temp2;
    66b4:	000018f4 	strdeq	r1, [r0], -r4
    66b8:	99032602 	stmdbls	r3, {r1, r9, sl, sp}
*                  - wNBytes     = no. of bytes to be copied.
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
    66bc:	07000001 	streq	r0, [r0, -r1]
  u32 n = (wNBytes + 1) >> 1;/* /2*/
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
    66c0:	26020078 			; <UNDEFINED> instruction: 0x26020078
    66c4:	00000115 	andeq	r0, r0, r5, lsl r1
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;/* /2*/
    66c8:	02006107 	andeq	r6, r0, #-1073741823	; 0xc0000001
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
    66cc:	00011b26 	andeq	r1, r1, r6, lsr #22
    66d0:	2e0e0000 	cdpcs	0, 0, cr0, cr14, cr0, {0}
  {
    *(u16*)pbUsrBuf++ = *pdwVal++;
    66d4:	01000019 	tsteq	r0, r9, lsl r0
    66d8:	01ca010c 	biceq	r0, sl, ip, lsl #2
    66dc:	78070000 	stmdavc	r7, {}	; <UNPREDICTABLE>
    66e0:	150c0100 	strne	r0, [ip, #-256]	; 0x100
    66e4:	07000001 	streq	r0, [r0, -r1]
    66e8:	0c010070 	stceq	0, cr0, [r1], {112}	; 0x70
    66ec:	0000011b 	andeq	r0, r0, fp, lsl r1
    66f0:	0100630a 	tsteq	r0, sl, lsl #6
    66f4:	0000970e 	andeq	r9, r0, lr, lsl #14
    66f8:	00690a00 	rsbeq	r0, r9, r0, lsl #20
    66fc:	007e0f01 	rsbseq	r0, lr, r1, lsl #30
    6700:	06000000 	streq	r0, [r0], -r0
    6704:	000018e8 	andeq	r1, r0, r8, ror #17
    6708:	f2014901 	vmla.i8	d4, d1, d1
    670c:	07000001 	streq	r0, [r0, -r1]
    6710:	49010078 	stmdbmi	r1, {r3, r4, r5, r6}
    6714:	00000115 	andeq	r0, r0, r5, lsl r1
    6718:	01006307 	tsteq	r0, r7, lsl #6
    671c:	0000a249 	andeq	sl, r0, r9, asr #4
    6720:	00690a00 	rsbeq	r0, r9, r0, lsl #20
    6724:	007e4b01 	rsbseq	r4, lr, r1, lsl #22
    6728:	0f000000 	svceq	0x00000000
    672c:	000001ca 	andeq	r0, r0, sl, asr #3
    6730:	00000000 	andeq	r0, r0, r0
    6734:	0000001e 	andeq	r0, r0, lr, lsl r0
    6738:	023e9c01 	eorseq	r9, lr, #256	; 0x100
    673c:	d6100000 	ldrle	r0, [r0], -r0
    6740:	23000001 	movwcs	r0, #1
    6744:	1000003c 	andne	r0, r0, ip, lsr r0
    6748:	000001df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    674c:	00003c51 	andeq	r3, r0, r1, asr ip
    6750:	0001e811 	andeq	lr, r1, r1, lsl r8
    6754:	003ca300 	eorseq	sl, ip, r0, lsl #6
    6758:	00001200 	andeq	r1, r0, r0, lsl #4
    675c:	0d5a0000 	ldcleq	0, cr0, [sl, #-0]
    6760:	01130000 	tsteq	r3, r0
    6764:	134c0152 	movtne	r0, #49490	; 0xc152
    6768:	30015101 	andcc	r5, r1, r1, lsl #2
    676c:	05500113 	ldrbeq	r0, [r0, #-275]	; 0x113
    6770:	235001f3 	cmpcs	r0, #-1073741764	; 0xc000003c
    6774:	0d000004 	stceq	0, cr0, [r0, #-16]
    6778:	000018d4 	ldrdeq	r1, [r0], -r4
    677c:	007e2801 	rsbseq	r2, lr, r1, lsl #16
    6780:	6a010000 	bvs	46788 <_etext+0x3f270>
    6784:	07000002 	streq	r0, [r0, -r2]
    6788:	28010070 	stmdacs	r1, {r4, r5, r6}
    678c:	0000011b 	andeq	r0, r0, fp, lsl r1
    6790:	0100690a 	tsteq	r0, sl, lsl #18
    6794:	00007e2a 	andeq	r7, r0, sl, lsr #28
    6798:	00780a00 	rsbseq	r0, r8, r0, lsl #20
    679c:	008c2b01 	addeq	r2, ip, r1, lsl #22
    67a0:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    67a4:	000018c8 	andeq	r1, r0, r8, asr #17
    67a8:	a6011801 	strge	r1, [r1], -r1, lsl #16
    67ac:	07000002 	streq	r0, [r0, -r2]
    67b0:	18010078 	stmdane	r1, {r3, r4, r5, r6}
    67b4:	00000115 	andeq	r0, r0, r5, lsl r1
    67b8:	01007007 	tsteq	r0, r7
    67bc:	00011b18 	andeq	r1, r1, r8, lsl fp
    67c0:	18370900 	ldmdane	r7!, {r8, fp}
    67c4:	1a010000 	bne	467cc <_etext+0x3f2b4>
    67c8:	000002a6 	andeq	r0, r0, r6, lsr #5
    67cc:	0100630a 	tsteq	r0, sl, lsl #6
    67d0:	0000971b 	andeq	r9, r0, fp, lsl r7
    67d4:	00690a00 	rsbeq	r0, r9, r0, lsl #20
    67d8:	007e1c01 	rsbseq	r1, lr, r1, lsl #24
    67dc:	14000000 	strne	r0, [r0], #-0
    67e0:	0000008c 	andeq	r0, r0, ip, lsl #1
    67e4:	000002b6 			; <UNDEFINED> instruction: 0x000002b6
    67e8:	0000b815 	andeq	fp, r0, r5, lsl r8
    67ec:	16001f00 	strne	r1, [r0], -r0, lsl #30
    67f0:	00001776 	andeq	r1, r0, r6, ror r7
    67f4:	2e3c5b01 	vaddcs.f64	d5, d12, d1
    67f8:	01a00000 	moveq	r0, r0
    67fc:	9c010000 	stcls	0, cr0, [r1], {-0}
    6800:	000004d7 	ldrdeq	r0, [r0], -r7
    6804:	01006e17 	tsteq	r0, r7, lsl lr
    6808:	0001155b 	andeq	r1, r1, fp, asr r5
    680c:	003cdb00 	eorseq	sp, ip, r0, lsl #22
    6810:	00781700 	rsbseq	r1, r8, r0, lsl #14
    6814:	011b5c01 	tsteq	fp, r1, lsl #24
    6818:	3d1a0000 	ldccc	0, cr0, [sl, #-0]
    681c:	6c170000 	ldcvs	0, cr0, [r7], {-0}
    6820:	01006e65 	tsteq	r0, r5, ror #28
    6824:	0000ad5c 	andeq	sl, r0, ip, asr sp
    6828:	003d5900 	eorseq	r5, sp, r0, lsl #18
    682c:	18a91800 	stmiane	r9!, {fp, ip}
    6830:	5d010000 	stcpl	0, cr0, [r1, #-0]
    6834:	0000011b 	andeq	r0, r0, fp, lsl r1
    6838:	00003d9d 	muleq	r0, sp, sp
    683c:	00190f09 	andseq	r0, r9, r9, lsl #30
    6840:	d75f0100 	ldrble	r0, [pc, -r0, lsl #2]
    6844:	19000004 	stmdbne	r0, {r2}
    6848:	0000183e 	andeq	r1, r0, lr, lsr r8
    684c:	04d76001 	ldrbeq	r6, [r7], #1
    6850:	3de10000 	stclcc	0, cr0, [r1]
    6854:	4c190000 	ldcmi	0, cr0, [r9], {-0}
    6858:	01000018 	tsteq	r0, r8, lsl r0
    685c:	0004d761 	andeq	sp, r4, r1, ror #14
    6860:	003dff00 	eorseq	pc, sp, r0, lsl #30
    6864:	18641900 	stmdane	r4!, {r8, fp, ip}^
    6868:	62010000 	andvs	r0, r1, #0
    686c:	000004d7 	ldrdeq	r0, [r0], -r7
    6870:	00003e1d 	andeq	r3, r0, sp, lsl lr
    6874:	0100691a 	tsteq	r0, sl, lsl r9
    6878:	00007e63 	andeq	r7, r0, r3, ror #28
    687c:	003e4800 	eorseq	r4, lr, r0, lsl #16
    6880:	023e1b00 	eorseq	r1, lr, #0, 22
    6884:	2e4a0000 	cdpcs	0, 4, cr0, cr10, cr0, {0}
    6888:	06d00000 	ldrbeq	r0, [r0], r0
    688c:	5f010000 	svcpl	0x00010000
    6890:	0000037d 	andeq	r0, r0, sp, ror r3
    6894:	00024e10 	andeq	r4, r2, r0, lsl lr
    6898:	003ec100 	eorseq	ip, lr, r0, lsl #2
    689c:	06d01c00 	ldrbeq	r1, [r0], r0, lsl #24
    68a0:	57110000 	ldrpl	r0, [r1, -r0]
    68a4:	05000002 	streq	r0, [r0, #-2]
    68a8:	1100003f 	tstne	r0, pc, lsr r0
    68ac:	00000260 	andeq	r0, r0, r0, ror #4
    68b0:	00003f63 	andeq	r3, r0, r3, ror #30
    68b4:	261d0000 	ldrcs	r0, [sp], -r0
    68b8:	6c000001 	stcvs	0, cr0, [r0], {1}
    68bc:	0800002e 	stmdaeq	r0, {r1, r2, r3, r5}
    68c0:	01000000 	mrseq	r0, (UNDEF: 0)
    68c4:	0003a35f 	andeq	sl, r3, pc, asr r3
    68c8:	013f1000 	teqeq	pc, r0
    68cc:	3fa10000 	svccc	0x00a10000
    68d0:	36100000 	ldrcc	r0, [r0], -r0
    68d4:	f1000001 	cps	#1
    68d8:	0000003f 	andeq	r0, r0, pc, lsr r0
    68dc:	0001491d 	andeq	r4, r1, sp, lsl r9
    68e0:	002f1c00 	eoreq	r1, pc, r0, lsl #24
    68e4:	00001400 	andeq	r1, r0, r0, lsl #8
    68e8:	dd6b0100 	stflee	f0, [fp, #-0]
    68ec:	1e000003 	cdpne	0, 0, cr0, cr0, cr3, {0}
    68f0:	0000015e 	andeq	r0, r0, lr, asr r1
    68f4:	0001551e 	andeq	r5, r1, lr, lsl r5
    68f8:	2f1c1f00 	svccs	0x001c1f00
    68fc:	00140000 	andseq	r0, r4, r0
    6900:	67110000 	ldrvs	r0, [r1, -r0]
    6904:	04000001 	streq	r0, [r0], #-1
    6908:	11000040 	tstne	r0, r0, asr #32
    690c:	00000170 	andeq	r0, r0, r0, ror r1
    6910:	00004022 	andeq	r4, r0, r2, lsr #32
    6914:	4e200000 	cdpmi	0, 2, cr0, cr0, cr0, {0}
    6918:	6200002f 	andvs	r0, r0, #47	; 0x2f
    691c:	bb000000 	bllt	6924 <_svfiprintf_r+0xc0>
    6920:	1a000004 	bne	6938 <_svfiprintf_r+0xd4>
    6924:	00746962 	rsbseq	r6, r4, r2, ror #18
    6928:	01217001 	teqeq	r1, r1
    692c:	404d0000 	submi	r0, sp, r0
    6930:	491b0000 	ldmdbmi	fp, {}	; <UNPREDICTABLE>
    6934:	5a000001 	bpl	6940 <_svfiprintf_r+0xdc>
    6938:	f000002f 			; <UNDEFINED> instruction: 0xf000002f
    693c:	01000006 	tsteq	r0, r6
    6940:	00043372 	andeq	r3, r4, r2, ror r3
    6944:	015e1000 	cmpeq	lr, r0
    6948:	40600000 	rsbmi	r0, r0, r0
    694c:	551e0000 	ldrpl	r0, [lr, #-0]
    6950:	1c000001 	stcne	0, cr0, [r0], {1}
    6954:	000006f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    6958:	00016711 	andeq	r6, r1, r1, lsl r7
    695c:	00407400 	subeq	r7, r0, r0, lsl #8
    6960:	01701100 	cmneq	r0, r0, lsl #2
    6964:	40930000 	addsmi	r0, r3, r0
    6968:	00000000 	andeq	r0, r0, r0
    696c:	00026a21 	andeq	r6, r2, r1, lsr #20
    6970:	002f7600 	eoreq	r7, pc, r0, lsl #12
    6974:	00070800 	andeq	r0, r7, r0, lsl #16
    6978:	1e740100 	rpwnes	f0, f4, f0
    697c:	0000027f 	andeq	r0, r0, pc, ror r2
    6980:	00027610 	andeq	r7, r2, r0, lsl r6
    6984:	0040ca00 	subeq	ip, r0, r0, lsl #20
    6988:	07081c00 	streq	r1, [r8, -r0, lsl #24]
    698c:	88220000 	stmdahi	r2!, {}	; <UNPREDICTABLE>
    6990:	03000002 	movweq	r0, #2
    6994:	117fb891 			; <UNDEFINED> instruction: 0x117fb891
    6998:	00000293 	muleq	r0, r3, r2
    699c:	000040dd 	ldrdeq	r4, [r0], -sp
    69a0:	00029c11 	andeq	r9, r2, r1, lsl ip
    69a4:	00411500 	subeq	r1, r1, r0, lsl #10
    69a8:	00c82300 	sbceq	r2, r8, r0, lsl #6
    69ac:	2f960000 	svccs	0x00960000
    69b0:	001a0000 	andseq	r0, sl, r0
    69b4:	24010000 	strcs	r0, [r1], #-0
    69b8:	0000f510 	andeq	pc, r0, r0, lsl r5	; <UNPREDICTABLE>
    69bc:	00414c00 	subeq	r4, r1, r0, lsl #24
    69c0:	00ea1e00 	rsceq	r1, sl, r0, lsl #28
    69c4:	df100000 	svcle	0x00100000
    69c8:	6d000000 	stcvs	0, cr0, [r0, #-0]
    69cc:	1e000041 	cdpne	0, 0, cr0, cr0, cr1, {2}
    69d0:	000000d4 	ldrdeq	r0, [r0], -r4
    69d4:	002f961f 	eoreq	r9, pc, pc, lsl r6	; <UNPREDICTABLE>
    69d8:	00001a00 	andeq	r1, r0, r0, lsl #20
    69dc:	01001100 	mrseq	r1, (UNDEF: 16)
    69e0:	41800000 	orrmi	r0, r0, r0
    69e4:	0b110000 	bleq	4469ec <_etext+0x43f4d4>
    69e8:	93000001 	movwls	r0, #1
    69ec:	00000041 	andeq	r0, r0, r1, asr #32
    69f0:	00000000 	andeq	r0, r0, r0
    69f4:	002e8224 	eoreq	r8, lr, r4, lsr #4
    69f8:	000d5a00 	andeq	r5, sp, r0, lsl #20
    69fc:	52011300 	andpl	r1, r1, #0, 6
    6a00:	13200802 	teqne	r0, #131072	; 0x20000
    6a04:	30015101 	andcc	r5, r1, r1, lsl #2
    6a08:	02500113 	subseq	r0, r0, #-1073741820	; 0xc0000004
    6a0c:	00000074 	andeq	r0, r0, r4, ror r0
    6a10:	00007e0c 	andeq	r7, r0, ip, lsl #28
    6a14:	191d1600 	ldmdbne	sp, {r9, sl, ip}
    6a18:	78010000 	stmdavc	r1, {}	; <UNPREDICTABLE>
    6a1c:	00000000 	andeq	r0, r0, r0
    6a20:	0000002c 	andeq	r0, r0, ip, lsr #32
    6a24:	05619c01 	strbeq	r9, [r1, #-3073]!	; 0xc01
    6a28:	78170000 	ldmdavc	r7, {}	; <UNPREDICTABLE>
    6a2c:	15780100 	ldrbne	r0, [r8, #-256]!	; 0x100
    6a30:	b2000001 	andlt	r0, r0, #1
    6a34:	18000041 	stmdane	r0, {r0, r6}
    6a38:	000018a9 	andeq	r1, r0, r9, lsr #17
    6a3c:	011b7801 	tsteq	fp, r1, lsl #16
    6a40:	41db0000 	bicsmi	r0, fp, r0
    6a44:	6e250000 	cdpvs	0, 2, cr0, cr5, cr0, {0}
    6a48:	a67a0100 	ldrbtge	r0, [sl], -r0, lsl #2
    6a4c:	02000002 	andeq	r0, r0, #2
    6a50:	7a1d5091 	bvc	75ac9c <_etext+0x753784>
    6a54:	00000001 	andeq	r0, r0, r1
    6a58:	16000000 	strne	r0, [r0], -r0
    6a5c:	01000000 	mrseq	r0, (UNDEF: 0)
    6a60:	00053d7d 	andeq	r3, r5, sp, ror sp
    6a64:	018f1000 	orreq	r1, pc, r0
    6a68:	42070000 	andmi	r0, r7, #0
    6a6c:	86260000 	strthi	r0, [r6], -r0
    6a70:	01000001 	tsteq	r0, r1
    6a74:	00240055 	eoreq	r0, r4, r5, asr r0
    6a78:	b6000000 	strlt	r0, [r0], -r0
    6a7c:	13000002 	movwne	r0, #2
    6a80:	f3035301 	vcgt.u8	d5, d3, d1
    6a84:	01135101 	tsteq	r3, r1, lsl #2
    6a88:	20080252 	andcs	r0, r8, r2, asr r2
    6a8c:	02510113 	subseq	r0, r1, #-1073741820	; 0xc0000004
    6a90:	01130075 	tsteq	r3, r5, ror r0
    6a94:	007d0250 	rsbseq	r0, sp, r0, asr r2
    6a98:	de270000 	cdple	0, 2, cr0, cr7, cr0, {0}
    6a9c:	01000018 	tsteq	r0, r8, lsl r0
    6aa0:	00008c80 	andeq	r8, r0, r0, lsl #25
    6aa4:	00000000 	andeq	r0, r0, r0
    6aa8:	00009a00 	andeq	r9, r0, r0, lsl #20
    6aac:	b19c0100 	orrslt	r0, ip, r0, lsl #2
    6ab0:	17000005 	strne	r0, [r0, -r5]
    6ab4:	80010078 	andhi	r0, r1, r8, ror r0
    6ab8:	0000011b 	andeq	r0, r0, fp, lsl r1
    6abc:	00004227 	andeq	r4, r0, r7, lsr #4
    6ac0:	01007917 	tsteq	r0, r7, lsl r9
    6ac4:	00011b80 	andeq	r1, r1, r0, lsl #23
    6ac8:	00425300 	subeq	r5, r2, r0, lsl #6
    6acc:	75731a00 	ldrbvc	r1, [r3, #-2560]!	; 0xa00
    6ad0:	8201006d 	andhi	r0, r1, #109	; 0x6d
    6ad4:	0000008c 	andeq	r0, r0, ip, lsl #1
    6ad8:	0000427f 	andeq	r4, r0, pc, ror r2
    6adc:	0100691a 	tsteq	r0, sl, lsl r9
    6ae0:	00007e83 	andeq	r7, r0, r3, lsl #29
    6ae4:	0042c700 	subeq	ip, r2, r0, lsl #14
    6ae8:	c80f0000 	stmdagt	pc, {}	; <UNPREDICTABLE>
    6aec:	00000000 	andeq	r0, r0, r0
    6af0:	c2000000 	andgt	r0, r0, #0
    6af4:	01000000 	mrseq	r0, (UNDEF: 0)
    6af8:	0005f99c 	muleq	r5, ip, r9
    6afc:	00d42600 	sbcseq	r2, r4, r0, lsl #12
    6b00:	50010000 	andpl	r0, r1, r0
    6b04:	0000df10 	andeq	sp, r0, r0, lsl pc
    6b08:	00430a00 	subeq	r0, r3, r0, lsl #20
    6b0c:	00ea1000 	rsceq	r1, sl, r0
    6b10:	43360000 	teqmi	r6, #0
    6b14:	f5100000 			; <UNDEFINED> instruction: 0xf5100000
    6b18:	62000000 	andvs	r0, r0, #0
    6b1c:	11000043 	tstne	r0, r3, asr #32
    6b20:	00000100 	andeq	r0, r0, r0, lsl #2
    6b24:	00004383 	andeq	r4, r0, r3, lsl #7
    6b28:	00010b11 	andeq	r0, r1, r1, lsl fp
    6b2c:	0043ac00 	subeq	sl, r3, r0, lsl #24
    6b30:	96060000 	strls	r0, [r6], -r0
    6b34:	01000018 	tsteq	r0, r8, lsl r0
    6b38:	0623019a 			; <UNDEFINED> instruction: 0x0623019a
    6b3c:	72070000 	andvc	r0, r7, #0
    6b40:	159a0100 	ldrne	r0, [sl, #256]	; 0x100
    6b44:	07000001 	streq	r0, [r0, -r1]
    6b48:	9a010061 	bls	46cd4 <_etext+0x3f7bc>
    6b4c:	0000011b 	andeq	r0, r0, fp, lsl r1
    6b50:	0018a908 	andseq	sl, r8, r8, lsl #18
    6b54:	1b9a0100 	blne	fe686f5c <BootRAM+0xd5f76fd>
    6b58:	00000001 	andeq	r0, r0, r1
    6b5c:	0005f90f 	andeq	pc, r5, pc, lsl #18
    6b60:	00000000 	andeq	r0, r0, r0
    6b64:	00005800 	andeq	r5, r0, r0, lsl #16
    6b68:	149c0100 	ldrne	r0, [ip], #256	; 0x100
    6b6c:	26000007 	strcs	r0, [r0], -r7
    6b70:	00000605 	andeq	r0, r0, r5, lsl #12
    6b74:	0e105001 	cdpeq	0, 1, cr5, cr0, cr1, {0}
    6b78:	d7000006 	strle	r0, [r0, -r6]
    6b7c:	10000043 	andne	r0, r0, r3, asr #32
    6b80:	00000617 	andeq	r0, r0, r7, lsl r6
    6b84:	000043f8 	strdeq	r4, [r0], -r8
    6b88:	0001991b 	andeq	r9, r1, fp, lsl r9
    6b8c:	00000000 	andeq	r0, r0, r0
    6b90:	00072000 	andeq	r2, r7, r0
    6b94:	8b9c0100 	blhi	fe706f9c <BootRAM+0xd67773d>
    6b98:	10000006 	andne	r0, r0, r6
    6b9c:	000001ae 	andeq	r0, r0, lr, lsr #3
    6ba0:	00004419 	andeq	r4, r0, r9, lsl r4
    6ba4:	0001a526 	andeq	sl, r1, r6, lsr #10
    6ba8:	1c500100 	ldfnee	f0, [r0], {-0}
    6bac:	00000720 	andeq	r0, r0, r0, lsr #14
    6bb0:	0001b711 	andeq	fp, r1, r1, lsl r7
    6bb4:	00443a00 	subeq	r3, r4, r0, lsl #20
    6bb8:	01c01100 	biceq	r1, r0, r0, lsl #2
    6bbc:	44590000 	ldrbmi	r0, [r9], #-0
    6bc0:	00000000 	andeq	r0, r0, r0
    6bc4:	00026a23 	andeq	r6, r2, r3, lsr #20
    6bc8:	00000000 	andeq	r0, r0, r0
    6bcc:	00003200 	andeq	r3, r0, r0, lsl #4
    6bd0:	1e9d0100 	fmlnee	f0, f5, f0
    6bd4:	0000027f 	andeq	r0, r0, pc, ror r2
    6bd8:	0002761e 	andeq	r7, r2, lr, lsl r6
    6bdc:	00001f00 	andeq	r1, r0, r0, lsl #30
    6be0:	00320000 	eorseq	r0, r2, r0
    6be4:	88220000 	stmdahi	r2!, {}	; <UNPREDICTABLE>
    6be8:	02000002 	andeq	r0, r0, #2
    6bec:	93115091 	tstls	r1, #145	; 0x91
    6bf0:	90000002 	andls	r0, r0, r2
    6bf4:	11000044 	tstne	r0, r4, asr #32
    6bf8:	0000029c 	muleq	r0, ip, r2
    6bfc:	000044bc 			; <UNDEFINED> instruction: 0x000044bc
    6c00:	0000c823 	andeq	ip, r0, r3, lsr #16
    6c04:	00000000 	andeq	r0, r0, r0
    6c08:	00001a00 	andeq	r1, r0, r0, lsl #20
    6c0c:	10240100 	eorne	r0, r4, r0, lsl #2
    6c10:	000000f5 	strdeq	r0, [r0], -r5
    6c14:	000044e7 	andeq	r4, r0, r7, ror #9
    6c18:	0000ea26 	andeq	lr, r0, r6, lsr #20
    6c1c:	10500100 	subsne	r0, r0, r0, lsl #2
    6c20:	000000df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    6c24:	00004508 	andeq	r4, r0, r8, lsl #10
    6c28:	0000d426 	andeq	sp, r0, r6, lsr #8
    6c2c:	1f500100 	svcne	0x00500100
    6c30:	00000000 	andeq	r0, r0, r0
    6c34:	0000001a 	andeq	r0, r0, sl, lsl r0
    6c38:	00010022 	andeq	r0, r1, r2, lsr #32
    6c3c:	11510100 	cmpne	r1, r0, lsl #2
    6c40:	0000010b 	andeq	r0, r0, fp, lsl #2
    6c44:	00004535 	andeq	r4, r0, r5, lsr r5
    6c48:	00000000 	andeq	r0, r0, r0
    6c4c:	188b1600 	stmne	fp, {r9, sl, ip}
    6c50:	a0010000 	andge	r0, r1, r0
    6c54:	00000000 	andeq	r0, r0, r0
    6c58:	0000008e 	andeq	r0, r0, lr, lsl #1
    6c5c:	08a99c01 	stmiaeq	r9!, {r0, sl, fp, ip, pc}
    6c60:	72280000 	eorvc	r0, r8, #0
    6c64:	15a00100 	strne	r0, [r0, #256]!	; 0x100
    6c68:	01000001 	tsteq	r0, r1
    6c6c:	00611750 	rsbeq	r1, r1, r0, asr r7
    6c70:	011ba001 	tsteq	fp, r1
    6c74:	45540000 	ldrbmi	r0, [r4, #-0]
    6c78:	a9180000 	ldmdbge	r8, {}	; <UNPREDICTABLE>
    6c7c:	01000018 	tsteq	r0, r8, lsl r0
    6c80:	00011ba0 	andeq	r1, r1, r0, lsr #23
    6c84:	00457500 	subeq	r7, r5, r0, lsl #10
    6c88:	01991b00 	orrseq	r1, r9, r0, lsl #22
    6c8c:	00000000 	andeq	r0, r0, r0
    6c90:	07380000 	ldreq	r0, [r8, -r0]!
    6c94:	a2010000 	andge	r0, r1, #0
    6c98:	0000078c 	andeq	r0, r0, ip, lsl #15
    6c9c:	0001ae10 	andeq	sl, r1, r0, lsl lr
    6ca0:	00459600 	subeq	r9, r5, r0, lsl #12
    6ca4:	01a52600 			; <UNDEFINED> instruction: 0x01a52600
    6ca8:	50010000 	andpl	r0, r1, r0
    6cac:	0007381c 	andeq	r3, r7, ip, lsl r8
    6cb0:	01b71100 			; <UNDEFINED> instruction: 0x01b71100
    6cb4:	45b70000 	ldrmi	r0, [r7, #0]!
    6cb8:	c0110000 	andsgt	r0, r1, r0
    6cbc:	d6000001 	strle	r0, [r0], -r1
    6cc0:	00000045 	andeq	r0, r0, r5, asr #32
    6cc4:	026a1d00 	rsbeq	r1, sl, #0, 26
    6cc8:	00000000 	andeq	r0, r0, r0
    6ccc:	00320000 	eorseq	r0, r2, r0
    6cd0:	a3010000 	movwge	r0, #4096	; 0x1000
    6cd4:	0000081a 	andeq	r0, r0, sl, lsl r8
    6cd8:	00027f1e 	andeq	r7, r2, lr, lsl pc
    6cdc:	02761e00 	rsbseq	r1, r6, #0, 28
    6ce0:	001f0000 	andseq	r0, pc, r0
    6ce4:	32000000 	andcc	r0, r0, #0
    6ce8:	22000000 	andcs	r0, r0, #0
    6cec:	00000288 	andeq	r0, r0, r8, lsl #5
    6cf0:	11509102 	cmpne	r0, r2, lsl #2
    6cf4:	00000293 	muleq	r0, r3, r2
    6cf8:	0000460d 	andeq	r4, r0, sp, lsl #12
    6cfc:	00029c11 	andeq	r9, r2, r1, lsl ip
    6d00:	00463900 	subeq	r3, r6, r0, lsl #18
    6d04:	00c82300 	sbceq	r2, r8, r0, lsl #6
    6d08:	00000000 	andeq	r0, r0, r0
    6d0c:	001a0000 	andseq	r0, sl, r0
    6d10:	24010000 	strcs	r0, [r1], #-0
    6d14:	0000f510 	andeq	pc, r0, r0, lsl r5	; <UNPREDICTABLE>
    6d18:	00466400 	subeq	r6, r6, r0, lsl #8
    6d1c:	00ea2600 	rsceq	r2, sl, r0, lsl #12
    6d20:	50010000 	andpl	r0, r1, r0
    6d24:	0000df10 	andeq	sp, r0, r0, lsl pc
    6d28:	00468500 	subeq	r8, r6, r0, lsl #10
    6d2c:	00d42600 	sbcseq	r2, r4, r0, lsl #12
    6d30:	50010000 	andpl	r0, r1, r0
    6d34:	0000001f 	andeq	r0, r0, pc, lsl r0
    6d38:	00001a00 	andeq	r1, r0, r0, lsl #20
    6d3c:	01001100 	mrseq	r1, (UNDEF: 16)
    6d40:	46b20000 	ldrtmi	r0, [r2], r0
    6d44:	0b110000 	bleq	446d4c <_etext+0x43f834>
    6d48:	c5000001 	strgt	r0, [r0, #-1]
    6d4c:	00000046 	andeq	r0, r0, r6, asr #32
    6d50:	23000000 	movwcs	r0, #0
    6d54:	0000026a 	andeq	r0, r0, sl, ror #4
    6d58:	00000000 	andeq	r0, r0, r0
    6d5c:	00000036 	andeq	r0, r0, r6, lsr r0
    6d60:	7f10a401 	svcvc	0x0010a401
    6d64:	e4000002 	str	r0, [r0], #-2
    6d68:	26000046 	strcs	r0, [r0], -r6, asr #32
    6d6c:	00000276 	andeq	r0, r0, r6, ror r2
    6d70:	001f5001 	andseq	r5, pc, r1
    6d74:	36000000 	strcc	r0, [r0], -r0
    6d78:	22000000 	andcs	r0, r0, #0
    6d7c:	00000288 	andeq	r0, r0, r8, lsl #5
    6d80:	11509102 	cmpne	r0, r2, lsl #2
    6d84:	00000293 	muleq	r0, r3, r2
    6d88:	00004705 	andeq	r4, r0, r5, lsl #14
    6d8c:	00029c11 	andeq	r9, r2, r1, lsl ip
    6d90:	00473d00 	subeq	r3, r7, r0, lsl #26
    6d94:	00c82300 	sbceq	r2, r8, r0, lsl #6
    6d98:	00000000 	andeq	r0, r0, r0
    6d9c:	001a0000 	andseq	r0, sl, r0
    6da0:	24010000 	strcs	r0, [r1], #-0
    6da4:	0000f510 	andeq	pc, r0, r0, lsl r5	; <UNPREDICTABLE>
    6da8:	00477400 	subeq	r7, r7, r0, lsl #8
    6dac:	00ea2600 	rsceq	r2, sl, r0, lsl #12
    6db0:	50010000 	andpl	r0, r1, r0
    6db4:	0000df10 	andeq	sp, r0, r0, lsl pc
    6db8:	00479500 	subeq	r9, r7, r0, lsl #10
    6dbc:	00d42600 	sbcseq	r2, r4, r0, lsl #12
    6dc0:	50010000 	andpl	r0, r1, r0
    6dc4:	0000001f 	andeq	r0, r0, pc, lsl r0
    6dc8:	00001a00 	andeq	r1, r0, r0, lsl #20
    6dcc:	01002200 	mrseq	r2, R8_usr
    6dd0:	51010000 	mrspl	r0, (UNDEF: 1)
    6dd4:	00010b11 	andeq	r0, r1, r1, lsl fp
    6dd8:	0047c200 	subeq	ip, r7, r0, lsl #4
    6ddc:	00000000 	andeq	r0, r0, r0
    6de0:	b1160000 	tstlt	r6, r0
    6de4:	01000018 	tsteq	r0, r8, lsl r0
    6de8:	000000a7 	andeq	r0, r0, r7, lsr #1
    6dec:	00013e00 	andeq	r3, r1, r0, lsl #28
    6df0:	9b9c0100 	blls	fe7071f8 <BootRAM+0xd677999>
    6df4:	1700000b 	strne	r0, [r0, -fp]
    6df8:	a7010072 	smlsdxge	r1, r2, r0, r0
    6dfc:	00000115 	andeq	r0, r0, r5, lsl r1
    6e00:	000047e1 	andeq	r4, r0, r1, ror #15
    6e04:	01006117 	tsteq	r0, r7, lsl r1
    6e08:	00011ba7 	andeq	r1, r1, r7, lsr #23
    6e0c:	0047ff00 	subeq	pc, r7, r0, lsl #30
    6e10:	00621700 	rsbeq	r1, r2, r0, lsl #14
    6e14:	011ba701 	tsteq	fp, r1, lsl #14
    6e18:	481d0000 	ldmdami	sp, {}	; <UNPREDICTABLE>
    6e1c:	a9180000 	ldmdbge	r8, {}	; <UNPREDICTABLE>
    6e20:	01000018 	tsteq	r0, r8, lsl r0
    6e24:	00011ba8 	andeq	r1, r1, r8, lsr #23
    6e28:	00483b00 	subeq	r3, r8, r0, lsl #22
    6e2c:	00691a00 	rsbeq	r1, r9, r0, lsl #20
    6e30:	007eaa01 	rsbseq	sl, lr, r1, lsl #20
    6e34:	48590000 	ldmdami	r9, {}^	; <UNPREDICTABLE>
    6e38:	3e1b0000 	cdpcc	0, 1, cr0, cr11, cr0, {0}
    6e3c:	00000002 	andeq	r0, r0, r2
    6e40:	50000000 	andpl	r0, r0, r0
    6e44:	01000007 	tsteq	r0, r7
    6e48:	000934ae 	andeq	r3, r9, lr, lsr #9
    6e4c:	024e2600 	subeq	r2, lr, #0, 12
    6e50:	57010000 	strpl	r0, [r1, -r0]
    6e54:	0007501c 	andeq	r5, r7, ip, lsl r0
    6e58:	02571100 	subseq	r1, r7, #0, 2
    6e5c:	48860000 	stmmi	r6, {}	; <UNPREDICTABLE>
    6e60:	60110000 	andsvs	r0, r1, r0
    6e64:	d7000002 	strle	r0, [r0, -r2]
    6e68:	00000048 	andeq	r0, r0, r8, asr #32
    6e6c:	00002000 	andeq	r2, r0, r0
    6e70:	00ea0000 	rsceq	r0, sl, r0
    6e74:	0b7f0000 	bleq	1fc6e7c <_etext+0x1fbf964>
    6e78:	621a0000 	andsvs	r0, sl, #0
    6e7c:	01007469 	tsteq	r0, r9, ror #8
    6e80:	000121af 	andeq	r2, r1, pc, lsr #3
    6e84:	00490900 	subeq	r0, r9, r0, lsl #18
    6e88:	186a2900 	stmdane	sl!, {r8, fp, sp}^
    6e8c:	b0010000 	andlt	r0, r1, r0
    6e90:	000002a6 	andeq	r0, r0, r6, lsr #5
    6e94:	7f989103 	svcvc	0x00989103
    6e98:	0001491b 	andeq	r4, r1, fp, lsl r9
    6e9c:	00000000 	andeq	r0, r0, r0
    6ea0:	00076800 	andeq	r6, r7, r0, lsl #16
    6ea4:	99b20100 	ldmibls	r2!, {r8}
    6ea8:	10000009 	andne	r0, r0, r9
    6eac:	0000015e 	andeq	r0, r0, lr, asr r1
    6eb0:	0000492a 	andeq	r4, r0, sl, lsr #18
    6eb4:	0001551e 	andeq	r5, r1, lr, lsl r5
    6eb8:	07681c00 	strbeq	r1, [r8, -r0, lsl #24]!
    6ebc:	67110000 	ldrvs	r0, [r1, -r0]
    6ec0:	3e000001 	cdpcc	0, 0, cr0, cr0, cr1, {0}
    6ec4:	11000049 	tstne	r0, r9, asr #32
    6ec8:	00000170 	andeq	r0, r0, r0, ror r1
    6ecc:	0000495d 	andeq	r4, r0, sp, asr r9
    6ed0:	6a1d0000 	bvs	746ed8 <_etext+0x73f9c0>
    6ed4:	00000002 	andeq	r0, r0, r2
    6ed8:	2e000000 	cdpcs	0, 0, cr0, cr0, cr0, {0}
    6edc:	01000000 	mrseq	r0, (UNDEF: 0)
    6ee0:	000a24b3 			; <UNDEFINED> instruction: 0x000a24b3
    6ee4:	027f1e00 	rsbseq	r1, pc, #0, 28
    6ee8:	761e0000 	ldrvc	r0, [lr], -r0
    6eec:	1f000002 	svcne	0x00000002
    6ef0:	00000000 	andeq	r0, r0, r0
    6ef4:	0000002e 	andeq	r0, r0, lr, lsr #32
    6ef8:	00028822 	andeq	r8, r2, r2, lsr #16
    6efc:	b8910300 	ldmlt	r1, {r8, r9}
    6f00:	0293117f 	addseq	r1, r3, #-1073741793	; 0xc000001f
    6f04:	49940000 	ldmibmi	r4, {}	; <UNPREDICTABLE>
    6f08:	9c110000 	ldcls	0, cr0, [r1], {-0}
    6f0c:	c0000002 	andgt	r0, r0, r2
    6f10:	23000049 	movwcs	r0, #73	; 0x49
    6f14:	000000c8 	andeq	r0, r0, r8, asr #1
    6f18:	00000000 	andeq	r0, r0, r0
    6f1c:	00000018 	andeq	r0, r0, r8, lsl r0
    6f20:	f5102401 			; <UNDEFINED> instruction: 0xf5102401
    6f24:	eb000000 	bl	6f2c <_sbrk_r+0x14>
    6f28:	1e000049 	cdpne	0, 0, cr0, cr0, cr9, {2}
    6f2c:	000000ea 	andeq	r0, r0, sl, ror #1
    6f30:	0000df10 	andeq	sp, r0, r0, lsl pc
    6f34:	004a0c00 	subeq	r0, sl, r0, lsl #24
    6f38:	00d41e00 	sbcseq	r1, r4, r0, lsl #28
    6f3c:	001f0000 	andseq	r0, pc, r0
    6f40:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
    6f44:	11000000 	mrsne	r0, (UNDEF: 0)
    6f48:	00000100 	andeq	r0, r0, r0, lsl #2
    6f4c:	00004a1f 	andeq	r4, r0, pc, lsl sl
    6f50:	00010b11 	andeq	r0, r1, r1, lsl fp
    6f54:	004a3200 	subeq	r3, sl, r0, lsl #4
    6f58:	00000000 	andeq	r0, r0, r0
    6f5c:	017a1b00 	cmneq	sl, r0, lsl #22
    6f60:	00000000 	andeq	r0, r0, r0
    6f64:	07800000 	streq	r0, [r0, r0]
    6f68:	b5010000 	strlt	r0, [r1, #-0]
    6f6c:	00000a4a 	andeq	r0, r0, sl, asr #20
    6f70:	00018f10 	andeq	r8, r1, r0, lsl pc
    6f74:	004a5100 	subeq	r5, sl, r0, lsl #2
    6f78:	01861000 	orreq	r1, r6, r0
    6f7c:	4a640000 	bmi	1906f84 <_etext+0x18ffa6c>
    6f80:	1b000000 	blne	6f88 <_sbrk+0x2c>
    6f84:	000005f9 	strdeq	r0, [r0], -r9
    6f88:	00000000 	andeq	r0, r0, r0
    6f8c:	00000798 	muleq	r0, r8, r7
    6f90:	0b36b601 	bleq	db479c <_etext+0xdad284>
    6f94:	171e0000 	ldrne	r0, [lr, -r0]
    6f98:	1e000006 	cdpne	0, 0, cr0, cr0, cr6, {0}
    6f9c:	0000060e 	andeq	r0, r0, lr, lsl #12
    6fa0:	00060510 	andeq	r0, r6, r0, lsl r5
    6fa4:	004a7700 	subeq	r7, sl, r0, lsl #14
    6fa8:	01991b00 	orrseq	r1, r9, r0, lsl #22
    6fac:	00000000 	andeq	r0, r0, r0
    6fb0:	07b00000 	ldreq	r0, [r0, r0]!
    6fb4:	9c010000 	stcls	0, cr0, [r1], {-0}
    6fb8:	00000aa6 	andeq	r0, r0, r6, lsr #21
    6fbc:	0001ae1e 	andeq	sl, r1, lr, lsl lr
    6fc0:	01a51e00 			; <UNDEFINED> instruction: 0x01a51e00
    6fc4:	b01c0000 	andslt	r0, ip, r0
    6fc8:	11000007 	tstne	r0, r7
    6fcc:	000001b7 			; <UNDEFINED> instruction: 0x000001b7
    6fd0:	00004a8a 	andeq	r4, r0, sl, lsl #21
    6fd4:	0001c011 	andeq	ip, r1, r1, lsl r0
    6fd8:	004abf00 	subeq	fp, sl, r0, lsl #30
    6fdc:	23000000 	movwcs	r0, #0
    6fe0:	0000026a 	andeq	r0, r0, sl, ror #4
    6fe4:	00000000 	andeq	r0, r0, r0
    6fe8:	00000034 	andeq	r0, r0, r4, lsr r0
    6fec:	7f1e9d01 	svcvc	0x001e9d01
    6ff0:	1e000002 	cdpne	0, 0, cr0, cr0, cr2, {0}
    6ff4:	00000276 	andeq	r0, r0, r6, ror r2
    6ff8:	0000001f 	andeq	r0, r0, pc, lsl r0
    6ffc:	00003400 	andeq	r3, r0, r0, lsl #8
    7000:	02882200 	addeq	r2, r8, #0, 4
    7004:	91030000 	mrsls	r0, (UNDEF: 3)
    7008:	93117fb8 	tstls	r1, #184, 30	; 0x2e0
    700c:	f6000002 			; <UNDEFINED> instruction: 0xf6000002
    7010:	1100004a 	tstne	r0, sl, asr #32
    7014:	0000029c 	muleq	r0, ip, r2
    7018:	00004b22 	andeq	r4, r0, r2, lsr #22
    701c:	0000c823 	andeq	ip, r0, r3, lsr #16
    7020:	00000000 	andeq	r0, r0, r0
    7024:	00001c00 	andeq	r1, r0, r0, lsl #24
    7028:	10240100 	eorne	r0, r4, r0, lsl #2
    702c:	000000f5 	strdeq	r0, [r0], -r5
    7030:	00004b4d 	andeq	r4, r0, sp, asr #22
    7034:	0000ea10 	andeq	lr, r0, r0, lsl sl
    7038:	004b6e00 	subeq	r6, fp, r0, lsl #28
    703c:	00df1000 	sbcseq	r1, pc, r0
    7040:	4b810000 	blmi	fe047048 <BootRAM+0xcfb77e9>
    7044:	d4100000 	ldrle	r0, [r0], #-0
    7048:	6e000000 	cdpvs	0, 0, cr0, cr0, cr0, {0}
    704c:	1f00004b 	svcne	0x0000004b
    7050:	00000000 	andeq	r0, r0, r0
    7054:	0000001c 	andeq	r0, r0, ip, lsl r0
    7058:	00010011 	andeq	r0, r1, r1, lsl r0
    705c:	004b9400 	subeq	r9, fp, r0, lsl #8
    7060:	010b1100 	mrseq	r1, (UNDEF: 27)
    7064:	4ba70000 	blmi	fe9c706c <BootRAM+0xd93780d>
    7068:	00000000 	andeq	r0, r0, r0
    706c:	23000000 	movwcs	r0, #0
    7070:	000000c8 	andeq	r0, r0, r8, asr #1
    7074:	00000000 	andeq	r0, r0, r0
    7078:	00000020 	andeq	r0, r0, r0, lsr #32
    707c:	f510b801 			; <UNDEFINED> instruction: 0xf510b801
    7080:	c6000000 	strgt	r0, [r0], -r0
    7084:	1000004b 	andne	r0, r0, fp, asr #32
    7088:	000000ea 	andeq	r0, r0, sl, ror #1
    708c:	00004be7 	andeq	r4, r0, r7, ror #23
    7090:	0000df1e 	andeq	sp, r0, lr, lsl pc
    7094:	00d41e00 	sbcseq	r1, r4, r0, lsl #28
    7098:	001f0000 	andseq	r0, pc, r0
    709c:	20000000 	andcs	r0, r0, r0
    70a0:	11000000 	mrsne	r0, (UNDEF: 0)
    70a4:	00000100 	andeq	r0, r0, r0, lsl #2
    70a8:	00004bfa 	strdeq	r4, [r0], -sl
    70ac:	00010b11 	andeq	r0, r1, r1, lsl fp
    70b0:	004c0d00 	subeq	r0, ip, r0, lsl #26
    70b4:	00000000 	andeq	r0, r0, r0
    70b8:	00000024 	andeq	r0, r0, r4, lsr #32
    70bc:	000d5a00 	andeq	r5, sp, r0, lsl #20
    70c0:	52011300 	andpl	r1, r1, #0, 6
    70c4:	13200802 	teqne	r0, #131072	; 0x20000
    70c8:	30015101 	andcc	r5, r1, r1, lsl #2
    70cc:	02500113 	subseq	r0, r0, #-1073741820	; 0xc0000004
    70d0:	00000075 	andeq	r0, r0, r5, ror r0
    70d4:	00185916 	andseq	r5, r8, r6, lsl r9
    70d8:	00bc0100 	adcseq	r0, ip, r0, lsl #2
    70dc:	d2000000 	andle	r0, r0, #0
    70e0:	01000000 	mrseq	r0, (UNDEF: 0)
    70e4:	000d2e9c 	muleq	sp, ip, lr
    70e8:	00721700 	rsbseq	r1, r2, r0, lsl #14
    70ec:	0115bc01 	tsteq	r5, r1, lsl #24
    70f0:	4c2c0000 	stcmi	0, cr0, [ip], #-0
    70f4:	61170000 	tstvs	r7, r0
    70f8:	1bbc0100 	blne	fef07500 <BootRAM+0xde77ca1>
    70fc:	4a000001 	bmi	7108 <ed25519_neutral+0x64>
    7100:	1800004c 	stmdane	r0, {r2, r3, r6}
    7104:	000018a9 	andeq	r1, r0, r9, lsr #17
    7108:	011bbc01 	tsteq	fp, r1, lsl #24
    710c:	4c680000 	stclmi	0, cr0, [r8], #-0
    7110:	70250000 	eorvc	r0, r5, r0
    7114:	0100326d 	tsteq	r0, sp, ror #4
    7118:	0002a6be 			; <UNDEFINED> instruction: 0x0002a6be
    711c:	a8910300 	ldmge	r1, {r8, r9}
    7120:	00631a7f 	rsbeq	r1, r3, pc, ror sl
    7124:	0097bf01 	addseq	fp, r7, r1, lsl #30
    7128:	4c860000 	stcmi	0, cr0, [r6], {0}
    712c:	691a0000 	ldmdbvs	sl, {}	; <UNPREDICTABLE>
    7130:	7ec00100 	polvcs	f0, f0, f0
    7134:	bb000000 	bllt	713c <ed25519_base+0x18>
    7138:	1b00004c 	blne	7270 <round_k+0x28>
    713c:	0000017a 	andeq	r0, r0, sl, ror r1
    7140:	00000000 	andeq	r0, r0, r0
    7144:	000007c8 	andeq	r0, r0, r8, asr #15
    7148:	0c28c301 	stceq	3, cr12, [r8], #-4
    714c:	8f100000 	svchi	0x00100000
    7150:	3a000001 	bcc	715c <ed25519_base+0x38>
    7154:	1000004d 	andne	r0, r0, sp, asr #32
    7158:	00000186 	andeq	r0, r0, r6, lsl #3
    715c:	00004d58 	andeq	r4, r0, r8, asr sp
    7160:	01ca1d00 	biceq	r1, sl, r0, lsl #26
    7164:	00000000 	andeq	r0, r0, r0
    7168:	00180000 	andseq	r0, r8, r0
    716c:	cb010000 	blgt	47174 <_etext+0x3fc5c>
    7170:	00000c5d 	andeq	r0, r0, sp, asr ip
    7174:	0001df10 	andeq	sp, r1, r0, lsl pc
    7178:	004d8400 	subeq	r8, sp, r0, lsl #8
    717c:	01d61e00 	bicseq	r1, r6, r0, lsl #28
    7180:	001f0000 	andseq	r0, pc, r0
    7184:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
    7188:	11000000 	mrsne	r0, (UNDEF: 0)
    718c:	000001e8 	andeq	r0, r0, r8, ror #3
    7190:	00004da4 	andeq	r4, r0, r4, lsr #27
    7194:	3e1b0000 	cdpcc	0, 1, cr0, cr11, cr0, {0}
    7198:	00000002 	andeq	r0, r0, r2
    719c:	e8000000 	stmda	r0, {}	; <UNPREDICTABLE>
    71a0:	01000007 	tsteq	r0, r7
    71a4:	000c8ecd 	andeq	r8, ip, sp, asr #29
    71a8:	024e1e00 	subeq	r1, lr, #0, 28
    71ac:	e81c0000 	ldmda	ip, {}	; <UNPREDICTABLE>
    71b0:	11000007 	tstne	r0, r7
    71b4:	00000257 	andeq	r0, r0, r7, asr r2
    71b8:	00004de8 	andeq	r4, r0, r8, ror #27
    71bc:	00026011 	andeq	r6, r2, r1, lsl r0
    71c0:	004e4500 	subeq	r4, lr, r0, lsl #10
    71c4:	2a000000 	bcs	71cc <ed25519_order+0x8>
    71c8:	00000800 	andeq	r0, r0, r0, lsl #16
    71cc:	00000d13 	andeq	r0, r0, r3, lsl sp
    71d0:	00327225 	eorseq	r7, r2, r5, lsr #4
    71d4:	02a6ce01 	adceq	ip, r6, #1, 28
    71d8:	91020000 	mrsls	r0, (UNDEF: 2)
    71dc:	017a1b48 	cmneq	sl, r8, asr #22
    71e0:	00000000 	andeq	r0, r0, r0
    71e4:	08200000 	stmdaeq	r0!, {}	; <UNPREDICTABLE>
    71e8:	d5010000 	strle	r0, [r1, #-0]
    71ec:	00000cca 	andeq	r0, r0, sl, asr #25
    71f0:	00018f10 	andeq	r8, r1, r0, lsl pc
    71f4:	004e7700 	subeq	r7, lr, r0, lsl #14
    71f8:	01861000 	orreq	r1, r6, r0
    71fc:	4ed60000 	cdpmi	0, 13, cr0, cr6, cr0, {0}
    7200:	2b000000 	blcs	7208 <sha512_initial_state>
    7204:	00000000 	andeq	r0, r0, r0
    7208:	000008a9 	andeq	r0, r0, r9, lsr #17
    720c:	00000cf0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    7210:	02530113 	subseq	r0, r3, #-1073741820	; 0xc0000004
    7214:	01130077 	tsteq	r3, r7, ror r0
    7218:	00760252 	rsbseq	r0, r6, r2, asr r2
    721c:	02510113 	subseq	r0, r1, #-1073741820	; 0xc0000004
    7220:	01130076 	tsteq	r3, r6, ror r0
    7224:	48910250 	ldmmi	r1, {r4, r6, r9}
    7228:	00002400 	andeq	r2, r0, r0, lsl #8
    722c:	08a90000 	stmiaeq	r9!, {}	; <UNPREDICTABLE>
    7230:	01130000 	tsteq	r3, r0
    7234:	00770253 	rsbseq	r0, r7, r3, asr r2
    7238:	02520113 	subseq	r0, r2, #-1073741820	; 0xc0000004
    723c:	01130078 	tsteq	r3, r8, ror r0
    7240:	48910251 	ldmmi	r1, {r0, r4, r6, r9}
    7244:	02500113 	subseq	r0, r0, #-1073741820	; 0xc0000004
    7248:	00000076 	andeq	r0, r0, r6, ror r0
    724c:	00000024 	andeq	r0, r0, r4, lsr #32
    7250:	000d5a00 	andeq	r5, sp, r0, lsl #20
    7254:	52011300 	andpl	r1, r1, #0, 6
    7258:	01134c01 	tsteq	r3, r1, lsl #24
    725c:	13300151 	teqne	r0, #1073741844	; 0x40000014
    7260:	76025001 	strvc	r5, [r2], -r1
    7264:	2c000004 	stccs	0, cr0, [r0], {4}
    7268:	000018bc 			; <UNDEFINED> instruction: 0x000018bc
    726c:	0d3f0901 	ldceq	9, cr0, [pc, #-4]!	; 7270 <round_k+0x28>
    7270:	03050000 	movweq	r0, #20480	; 0x5000
    7274:	00000000 	andeq	r0, r0, r0
    7278:	0002a60c 	andeq	sl, r2, ip, lsl #12
    727c:	19362c00 	ldmdbne	r6!, {sl, fp, sp}
    7280:	0a010000 	beq	47288 <_etext+0x3fd70>
    7284:	00000d55 	andeq	r0, r0, r5, asr sp
    7288:	00000305 	andeq	r0, r0, r5, lsl #6
    728c:	a60c0000 	strge	r0, [ip], -r0
    7290:	2d000002 	stccs	0, cr0, [r0, #-8]
    7294:	00000fff 	strdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    7298:	000000bf 	strheq	r0, [r0], -pc	; <UNPREDICTABLE>
    729c:	0000bf2e 	andeq	fp, r0, lr, lsr #30
    72a0:	007e2e00 	rsbseq	r2, lr, r0, lsl #28
    72a4:	b82e0000 	stmdalt	lr!, {}	; <UNPREDICTABLE>
    72a8:	00000000 	andeq	r0, r0, r0
    72ac:	00062600 	andeq	r2, r6, r0, lsl #12
    72b0:	bd000400 	cfstrslt	mvf0, [r0, #-0]
    72b4:	04000019 	streq	r0, [r0], #-25
    72b8:	0014b401 	andseq	fp, r4, r1, lsl #8
    72bc:	19410100 	stmdbne	r1, {r8}^
    72c0:	08930000 	ldmeq	r3, {}	; <UNPREDICTABLE>
    72c4:	08a80000 	stmiaeq	r8!, {}	; <UNPREDICTABLE>
    72c8:	00000000 	andeq	r0, r0, r0
    72cc:	22200000 	eorcs	r0, r0, #0
    72d0:	01020000 	mrseq	r0, (UNDEF: 2)
    72d4:	00081a06 	andeq	r1, r8, r6, lsl #20
    72d8:	0b010300 	bleq	47ee0 <_etext+0x409c8>
    72dc:	1c020000 	stcne	0, cr0, [r2], {-0}
    72e0:	00000037 	andeq	r0, r0, r7, lsr r0
    72e4:	18080102 	stmdane	r8, {r1, r8}
    72e8:	02000008 	andeq	r0, r0, #8
    72ec:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
    72f0:	02020000 	andeq	r0, r2, #0
    72f4:	00094907 	andeq	r4, r9, r7, lsl #18
    72f8:	05040200 	streq	r0, [r4, #-512]	; 0x200
    72fc:	000004da 	ldrdeq	r0, [r0], -sl
    7300:	52070402 	andpl	r0, r7, #33554432	; 0x2000000
    7304:	02000002 	andeq	r0, r0, #2
    7308:	04d50508 	ldrbeq	r0, [r5], #1288	; 0x508
    730c:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    7310:	00024d07 	andeq	r4, r2, r7, lsl #26
    7314:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    7318:	00746e69 	rsbseq	r6, r4, r9, ror #28
    731c:	57070402 	strpl	r0, [r7, -r2, lsl #8]
    7320:	03000002 	movweq	r0, #2
    7324:	00000b03 	andeq	r0, r0, r3, lsl #22
    7328:	002c2a03 	eoreq	r2, ip, r3, lsl #20
    732c:	04020000 	streq	r0, [r2], #-0
    7330:	00078b07 	andeq	r8, r7, r7, lsl #22
    7334:	08010200 	stmdaeq	r1, {r9}
    7338:	00000821 	andeq	r0, r0, r1, lsr #16
    733c:	00195a05 	andseq	r5, r9, r5, lsl #20
    7340:	000a0100 	andeq	r0, sl, r0, lsl #2
    7344:	40000000 	andmi	r0, r0, r0
    7348:	01000000 	mrseq	r0, (UNDEF: 0)
    734c:	0001689c 	muleq	r1, ip, r8
    7350:	196f0600 	stmdbne	pc!, {r9, sl}^	; <UNPREDICTABLE>
    7354:	0a010000 	beq	4735c <_etext+0x3fe44>
    7358:	00000168 	andeq	r0, r0, r8, ror #2
    735c:	00004ef4 	strdeq	r4, [r0], -r4	; <UNPREDICTABLE>
    7360:	01007907 	tsteq	r0, r7, lsl #18
    7364:	00016e0a 	andeq	r6, r1, sl, lsl #28
    7368:	004f2000 	subeq	r2, pc, r0
    736c:	19540800 	ldmdbne	r4, {fp}^
    7370:	0c010000 	stceq	0, cr0, [r1], {-0}
    7374:	00000179 	andeq	r0, r0, r9, ror r1
    7378:	7fb09103 	svcvc	0x00b09103
    737c:	00198f08 	andseq	r8, r9, r8, lsl #30
    7380:	790d0100 	stmdbvc	sp, {r8}
    7384:	02000001 	andeq	r0, r0, #1
    7388:	00095091 	muleq	r9, r1, r0
    738c:	4f000000 	svcmi	0x00000000
    7390:	fd000005 	stc2	0, cr0, [r0, #-20]	; 0xffffffec
    7394:	0a000000 	beq	739c <round_k+0x154>
    7398:	75025201 	strvc	r5, [r2, #-513]	; 0x201
    739c:	51010a00 	tstpl	r1, r0, lsl #20
    73a0:	0a007602 	beq	24bb0 <_etext+0x1d698>
    73a4:	7d025001 	stcvc	0, cr5, [r2, #-4]
    73a8:	00090000 	andeq	r0, r9, r0
    73ac:	6a000000 	bvs	73b4 <round_k+0x16c>
    73b0:	17000005 	strne	r0, [r0, -r5]
    73b4:	0a000001 	beq	73c0 <round_k+0x178>
    73b8:	7d025101 	stfvcs	f5, [r2, #-4]
    73bc:	50010a00 	andpl	r0, r1, r0, lsl #20
    73c0:	00509102 	subseq	r9, r0, r2, lsl #2
    73c4:	00000009 	andeq	r0, r0, r9
    73c8:	00058000 	andeq	r8, r5, r0
    73cc:	00013700 	andeq	r3, r1, r0, lsl #14
    73d0:	52010a00 	andpl	r0, r1, #0, 20
    73d4:	0a007502 	beq	247e4 <_etext+0x1d2cc>
    73d8:	76025101 	strvc	r5, [r2], -r1, lsl #2
    73dc:	50010a00 	andpl	r0, r1, r0, lsl #20
    73e0:	00007d02 	andeq	r7, r0, r2, lsl #26
    73e4:	00000009 	andeq	r0, r0, r9
    73e8:	00059b00 	andeq	r9, r5, r0, lsl #22
    73ec:	00015700 	andeq	r5, r1, r0, lsl #14
    73f0:	52010a00 	andpl	r0, r1, #0, 20
    73f4:	0a509102 	beq	142b804 <_etext+0x14242ec>
    73f8:	7d025101 	stfvcs	f5, [r2, #-4]
    73fc:	50010a00 	andpl	r0, r1, r0, lsl #20
    7400:	00007402 	andeq	r7, r0, r2, lsl #8
    7404:	0000000b 	andeq	r0, r0, fp
    7408:	0005b600 	andeq	fp, r5, r0, lsl #12
    740c:	50010a00 	andpl	r0, r1, r0, lsl #20
    7410:	00007402 	andeq	r7, r0, r2, lsl #8
    7414:	76040c00 	strvc	r0, [r4], -r0, lsl #24
    7418:	0c000000 	stceq	0, cr0, [r0], {-0}
    741c:	00017404 	andeq	r7, r1, r4, lsl #8
    7420:	00760d00 	rsbseq	r0, r6, r0, lsl #26
    7424:	760e0000 	strvc	r0, [lr], -r0
    7428:	89000000 	stmdbhi	r0, {}	; <UNPREDICTABLE>
    742c:	0f000001 	svceq	0x00000001
    7430:	00000081 	andeq	r0, r0, r1, lsl #1
    7434:	6910001f 	ldmdbvs	r0, {r0, r1, r2, r3, r4}
    7438:	01000019 	tsteq	r0, r9, lsl r0
    743c:	01bc0116 			; <UNDEFINED> instruction: 0x01bc0116
    7440:	65110000 	ldrvs	r0, [r1, #-0]
    7444:	16010079 			; <UNDEFINED> instruction: 0x16010079
    7448:	00000168 	andeq	r0, r0, r8, ror #2
    744c:	00786d11 	rsbseq	r6, r8, r1, lsl sp
    7450:	016e1601 	cmneq	lr, r1, lsl #12
    7454:	6e120000 	cdpvs	0, 1, cr0, cr2, cr0, {0}
    7458:	79180100 	ldmdbvc	r8, {r8}
    745c:	12000001 	andne	r0, r0, #1
    7460:	19010064 	stmdbne	r1, {r2, r5, r6}
    7464:	00000179 	andeq	r0, r0, r9, ror r1
    7468:	197a1300 	ldmdbne	sl!, {r8, r9, ip}^
    746c:	21010000 	mrscs	r0, (UNDEF: 1)
    7470:	00000076 	andeq	r0, r0, r6, ror r0
    7474:	00022f01 	andeq	r2, r2, r1, lsl #30
    7478:	00781100 	rsbseq	r1, r8, r0, lsl #2
    747c:	01682101 	cmneq	r8, r1, lsl #2
    7480:	79110000 	ldmdbvc	r1, {}	; <UNPREDICTABLE>
    7484:	6e210100 	sufvss	f0, f1, f0
    7488:	14000001 	strne	r0, [r0], #-1
    748c:	000015e6 	andeq	r1, r0, r6, ror #11
    7490:	00682101 	rsbeq	r2, r8, r1, lsl #2
    7494:	64150000 	ldrvs	r0, [r5], #-0
    7498:	2f230100 	svccs	0x00230100
    749c:	20000002 	andcs	r0, r0, r2
    74a0:	135978a3 	cmpne	r9, #10682368	; 0xa30000
    74a4:	75eb4dca 	strbvc	r4, [fp, #3530]!	; 0xdca
    74a8:	4141d8ab 	smlaltbmi	sp, r1, fp, r8
    74ac:	00700a4d 	rsbseq	r0, r0, sp, asr #20
    74b0:	7779e898 			; <UNDEFINED> instruction: 0x7779e898
    74b4:	8cc74079 	stclhi	0, cr4, [r7], {121}	; 0x79
    74b8:	2b6ffe73 	blcs	1c06e8c <_etext+0x1bff974>
    74bc:	52036cee 	andpl	r6, r3, #60928	; 0xee00
    74c0:	01006112 	tsteq	r0, r2, lsl r1
    74c4:	0001792a 	andeq	r7, r1, sl, lsr #18
    74c8:	00621200 	rsbeq	r1, r2, r0, lsl #4
    74cc:	01792b01 	cmneq	r9, r1, lsl #22
    74d0:	63120000 	tstvs	r2, #0
    74d4:	792c0100 	stmdbvc	ip!, {r8}
    74d8:	00000001 	andeq	r0, r0, r1
    74dc:	0001790d 	andeq	r7, r1, sp, lsl #18
    74e0:	19801600 	stmibne	r0, {r9, sl, ip}
    74e4:	4b010000 	blmi	474ec <_etext+0x3ffd4>
    74e8:	00000076 	andeq	r0, r0, r6, ror r0
    74ec:	00000000 	andeq	r0, r0, r0
    74f0:	000000d4 	ldrdeq	r0, [r0], -r4
    74f4:	053f9c01 	ldreq	r9, [pc, #-3073]!	; 68fb <_svfiprintf_r+0x97>
    74f8:	65070000 	strvs	r0, [r7, #-0]
    74fc:	4b010078 	blmi	476e4 <_etext+0x401cc>
    7500:	00000168 	andeq	r0, r0, r8, ror #2
    7504:	00004f57 	andeq	r4, r0, r7, asr pc
    7508:	00796507 	rsbseq	r6, r9, r7, lsl #10
    750c:	01684b01 	cmneq	r8, r1, lsl #22
    7510:	4f830000 	svcmi	0x00830000
    7514:	6d070000 	stcvs	0, cr0, [r7, #-0]
    7518:	4c010078 	stcmi	0, cr0, [r1], {120}	; 0x78
    751c:	0000016e 	andeq	r0, r0, lr, ror #2
    7520:	00004faf 	andeq	r4, r0, pc, lsr #31
    7524:	0015e606 	andseq	lr, r5, r6, lsl #12
    7528:	684c0100 	stmdavs	ip, {r8}^
    752c:	db000000 	blle	7534 <_etext+0x1c>
    7530:	1200004f 	andne	r0, r0, #79	; 0x4f
    7534:	01006b6f 	tsteq	r0, pc, ror #22
    7538:	0000764e 	andeq	r7, r0, lr, asr #12
    753c:	01891700 	orreq	r1, r9, r0, lsl #14
    7540:	00000000 	andeq	r0, r0, r0
    7544:	08880000 	stmeq	r8, {}	; <UNPREDICTABLE>
    7548:	50010000 	andpl	r0, r1, r0
    754c:	00000347 	andeq	r0, r0, r7, asr #6
    7550:	00019f18 	andeq	r9, r1, r8, lsl pc
    7554:	00500700 	subseq	r0, r0, r0, lsl #14
    7558:	01951800 	orrseq	r1, r5, r0, lsl #16
    755c:	50330000 	eorspl	r0, r3, r0
    7560:	88190000 	ldmdahi	r9, {}	; <UNPREDICTABLE>
    7564:	1a000008 	bne	758c <_etext+0x74>
    7568:	000001a9 	andeq	r0, r0, r9, lsr #3
    756c:	7fa89103 	svcvc	0x00a89103
    7570:	0001b21a 	andeq	fp, r1, sl, lsl r2
    7574:	48910200 	ldmmi	r1, {r9}
    7578:	00000009 	andeq	r0, r0, r9
    757c:	00058000 	andeq	r8, r5, r0
    7580:	0002ec00 	andeq	lr, r2, r0, lsl #24
    7584:	52010a00 	andpl	r0, r1, #0, 20
    7588:	0a007602 	beq	24d98 <_etext+0x1d880>
    758c:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    7590:	50010a00 	andpl	r0, r1, r0, lsl #20
    7594:	7fa89103 	svcvc	0x00a89103
    7598:	00000900 	andeq	r0, r0, r0, lsl #18
    759c:	056a0000 	strbeq	r0, [sl, #-0]!
    75a0:	03070000 	movweq	r0, #28672	; 0x7000
    75a4:	010a0000 	mrseq	r0, (UNDEF: 10)
    75a8:	a8910351 	ldmge	r1, {r0, r4, r6, r8, r9}
    75ac:	50010a7f 	andpl	r0, r1, pc, ror sl
    75b0:	00489102 	subeq	r9, r8, r2, lsl #2
    75b4:	00000009 	andeq	r0, r0, r9
    75b8:	00054f00 	andeq	r4, r5, r0, lsl #30
    75bc:	00032800 	andeq	r2, r3, r0, lsl #16
    75c0:	52010a00 	andpl	r0, r1, #0, 20
    75c4:	0a007602 	beq	24dd4 <_etext+0x1d8bc>
    75c8:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    75cc:	50010a00 	andpl	r0, r1, r0, lsl #20
    75d0:	7fa89103 	svcvc	0x00a89103
    75d4:	00000b00 	andeq	r0, r0, r0, lsl #22
    75d8:	059b0000 	ldreq	r0, [fp]
    75dc:	010a0000 	mrseq	r0, (UNDEF: 10)
    75e0:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    75e4:	0351010a 	cmpeq	r1, #-2147483646	; 0x80000002
    75e8:	0a7fa891 	beq	1ff1834 <_etext+0x1fea31c>
    75ec:	74025001 	strvc	r5, [r2], #-1
    75f0:	00000000 	andeq	r0, r0, r0
    75f4:	0001bc1b 	andeq	fp, r1, fp, lsl ip
    75f8:	00000000 	andeq	r0, r0, r0
    75fc:	00008000 	andeq	r8, r0, r0
    7600:	1a510100 	bne	1447a08 <_etext+0x14404f0>
    7604:	18000005 	stmdane	r0, {r0, r2}
    7608:	000001de 	ldrdeq	r0, [r0], -lr
    760c:	0000505f 	andeq	r5, r0, pc, asr r0
    7610:	0001d518 	andeq	sp, r1, r8, lsl r5
    7614:	00508000 	subseq	r8, r0, r0
    7618:	01cc1800 	biceq	r1, ip, r0, lsl #16
    761c:	50a10000 	adcpl	r0, r1, r0
    7620:	001c0000 	andseq	r0, ip, r0
    7624:	80000000 	andhi	r0, r0, r0
    7628:	1a000000 	bne	7630 <_etext+0x118>
    762c:	00000213 	andeq	r0, r0, r3, lsl r2
    7630:	7f889103 	svcvc	0x00889103
    7634:	00021c1a 	andeq	r1, r2, sl, lsl ip
    7638:	a8910300 	ldmge	r1, {r8, r9}
    763c:	02251a7f 	eoreq	r1, r5, #520192	; 0x7f000
    7640:	91020000 	mrsls	r0, (UNDEF: 2)
    7644:	01e91a48 	mvneq	r1, r8, asr #20
    7648:	03050000 	movweq	r0, #20480	; 0x5000
    764c:	00000000 	andeq	r0, r0, r0
    7650:	00000009 	andeq	r0, r0, r9
    7654:	00059b00 	andeq	r9, r5, r0, lsl #22
    7658:	0003c300 	andeq	ip, r3, r0, lsl #6
    765c:	52010a00 	andpl	r0, r1, #0, 20
    7660:	0a007402 	beq	24670 <_etext+0x1d158>
    7664:	74025101 	strvc	r5, [r2], #-257	; 0x101
    7668:	50010a00 	andpl	r0, r1, r0, lsl #20
    766c:	00489102 	subeq	r9, r8, r2, lsl #2
    7670:	00000009 	andeq	r0, r0, r9
    7674:	00059b00 	andeq	r9, r5, r0, lsl #22
    7678:	0003e700 	andeq	lr, r3, r0, lsl #14
    767c:	52010a00 	andpl	r0, r1, #0, 20
    7680:	00000305 	andeq	r0, r0, r5, lsl #6
    7684:	010a0000 	mrseq	r0, (UNDEF: 10)
    7688:	48910251 	ldmmi	r1, {r0, r4, r6, r9}
    768c:	0350010a 	cmpeq	r0, #-2147483646	; 0x80000002
    7690:	007fa891 			; <UNDEFINED> instruction: 0x007fa891
    7694:	00000009 	andeq	r0, r0, r9
    7698:	00058000 	andeq	r8, r5, r0
    769c:	00040800 	andeq	r0, r4, r0, lsl #16
    76a0:	52010a00 	andpl	r0, r1, #0, 20
    76a4:	0a007602 	beq	24eb4 <_etext+0x1d99c>
    76a8:	91035101 	tstls	r3, r1, lsl #2
    76ac:	010a7fa8 	smlatbeq	sl, r8, pc, r7	; <UNPREDICTABLE>
    76b0:	007d0250 	rsbseq	r0, sp, r0, asr r2
    76b4:	00000900 	andeq	r0, r0, r0, lsl #18
    76b8:	056a0000 	strbeq	r0, [sl, #-0]!
    76bc:	04230000 	strteq	r0, [r3], #-0
    76c0:	010a0000 	mrseq	r0, (UNDEF: 10)
    76c4:	007d0251 	rsbseq	r0, sp, r1, asr r2
    76c8:	0350010a 	cmpeq	r0, #-2147483646	; 0x80000002
    76cc:	007fa891 			; <UNDEFINED> instruction: 0x007fa891
    76d0:	00000009 	andeq	r0, r0, r9
    76d4:	00054f00 	andeq	r4, r5, r0, lsl #30
    76d8:	00044300 	andeq	r4, r4, r0, lsl #6
    76dc:	52010a00 	andpl	r0, r1, #0, 20
    76e0:	0a007602 	beq	24ef0 <_etext+0x1d9d8>
    76e4:	91025101 	tstls	r2, r1, lsl #2
    76e8:	50010a48 	andpl	r0, r1, r8, asr #20
    76ec:	00007d02 	andeq	r7, r0, r2, lsl #26
    76f0:	00000009 	andeq	r0, r0, r9
    76f4:	00059b00 	andeq	r9, r5, r0, lsl #22
    76f8:	00046400 	andeq	r6, r4, r0, lsl #8
    76fc:	52010a00 	andpl	r0, r1, #0, 20
    7700:	7fa89103 	svcvc	0x00a89103
    7704:	0251010a 	subseq	r0, r1, #-2147483646	; 0x80000002
    7708:	010a007d 	tsteq	sl, sp, ror r0
    770c:	48910250 	ldmmi	r1, {r4, r6, r9}
    7710:	00000900 	andeq	r0, r0, r0, lsl #18
    7714:	05c70000 	strbeq	r0, [r7]
    7718:	047e0000 	ldrbteq	r0, [lr], #-0
    771c:	010a0000 	mrseq	r0, (UNDEF: 10)
    7720:	48910251 	ldmmi	r1, {r0, r4, r6, r9}
    7724:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    7728:	0900007d 	stmdbeq	r0, {r0, r2, r3, r4, r5, r6}
    772c:	00000000 	andeq	r0, r0, r0
    7730:	000005dd 	ldrdeq	r0, [r0], -sp
    7734:	00000499 	muleq	r0, r9, r4
    7738:	0251010a 	subseq	r0, r1, #-2147483646	; 0x80000002
    773c:	010a007d 	tsteq	sl, sp, ror r0
    7740:	a8910350 	ldmge	r1, {r4, r6, r8, r9}
    7744:	0009007f 	andeq	r0, r9, pc, ror r0
    7748:	f3000000 	vhadd.u8	d0, d0, d0
    774c:	ba000005 	blt	7768 <_etext+0x250>
    7750:	0a000004 	beq	7768 <_etext+0x250>
    7754:	91035201 	tstls	r3, r1, lsl #4
    7758:	010a7fa8 	smlatbeq	sl, r8, pc, r7	; <UNPREDICTABLE>
    775c:	007d0251 	rsbseq	r0, sp, r1, asr r2
    7760:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    7764:	09000075 	stmdbeq	r0, {r0, r2, r4, r5, r6}
    7768:	00000000 	andeq	r0, r0, r0
    776c:	0000059b 	muleq	r0, fp, r5
    7770:	000004da 	ldrdeq	r0, [r0], -sl
    7774:	0252010a 	subseq	r0, r2, #-2147483646	; 0x80000002
    7778:	010a0075 	tsteq	sl, r5, ror r0
    777c:	00750251 	rsbseq	r0, r5, r1, asr r2
    7780:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    7784:	0900007d 	stmdbeq	r0, {r0, r2, r3, r4, r5, r6}
    7788:	00000000 	andeq	r0, r0, r0
    778c:	000005b6 			; <UNDEFINED> instruction: 0x000005b6
    7790:	000004ee 	andeq	r0, r0, lr, ror #9
    7794:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    7798:	0900007d 	stmdbeq	r0, {r0, r2, r3, r4, r5, r6}
    779c:	00000000 	andeq	r0, r0, r0
    77a0:	000005b6 			; <UNDEFINED> instruction: 0x000005b6
    77a4:	00000502 	andeq	r0, r0, r2, lsl #10
    77a8:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    77ac:	0b004891 	bleq	199f8 <_etext+0x124e0>
    77b0:	00000000 	andeq	r0, r0, r0
    77b4:	00000613 	andeq	r0, r0, r3, lsl r6
    77b8:	0251010a 	subseq	r0, r1, #-2147483646	; 0x80000002
    77bc:	010a4891 			; <UNDEFINED> instruction: 0x010a4891
    77c0:	007d0250 	rsbseq	r0, sp, r0, asr r2
    77c4:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    77c8:	00000000 	andeq	r0, r0, r0
    77cc:	000005b6 			; <UNDEFINED> instruction: 0x000005b6
    77d0:	0000052e 	andeq	r0, r0, lr, lsr #10
    77d4:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    77d8:	0b000075 	bleq	79b4 <_etext+0x49c>
    77dc:	00000000 	andeq	r0, r0, r0
    77e0:	000005b6 			; <UNDEFINED> instruction: 0x000005b6
    77e4:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    77e8:	00000074 	andeq	r0, r0, r4, ror r0
    77ec:	0014971d 	andseq	r9, r4, sp, lsl r7
    77f0:	4a1c0400 	bmi	7087f8 <_etext+0x7012e0>
    77f4:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
    77f8:	00000179 	andeq	r0, r0, r9, ror r1
    77fc:	0015521e 	andseq	r5, r5, lr, lsl r2
    7800:	6a3b0400 	bvs	ec8808 <_etext+0xec12f0>
    7804:	1f000005 	svcne	0x00000005
    7808:	00000168 	andeq	r0, r0, r8, ror #2
    780c:	00016e1f 	andeq	r6, r1, pc, lsl lr
    7810:	016e1f00 	cmneq	lr, r0, lsl #30
    7814:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    7818:	00001588 	andeq	r1, r0, r8, lsl #11
    781c:	05805104 	streq	r5, [r0, #260]	; 0x104
    7820:	681f0000 	ldmdavs	pc, {}	; <UNPREDICTABLE>
    7824:	1f000001 	svcne	0x00000001
    7828:	0000016e 	andeq	r0, r0, lr, ror #2
    782c:	147a1e00 	ldrbtne	r1, [sl], #-3584	; 0xe00
    7830:	3a040000 	bcc	107838 <_etext+0x100320>
    7834:	0000059b 	muleq	r0, fp, r5
    7838:	0001681f 	andeq	r6, r1, pc, lsl r8
    783c:	016e1f00 	cmneq	lr, r0, lsl #30
    7840:	6e1f0000 	cdpvs	0, 1, cr0, cr15, cr0, {0}
    7844:	00000001 	andeq	r0, r0, r1
    7848:	0015731e 	andseq	r7, r5, lr, lsl r3
    784c:	b6440400 	strblt	r0, [r4], -r0, lsl #8
    7850:	1f000005 	svcne	0x00000005
    7854:	00000168 	andeq	r0, r0, r8, ror #2
    7858:	00016e1f 	andeq	r6, r1, pc, lsl lr
    785c:	016e1f00 	cmneq	lr, r0, lsl #30
    7860:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    7864:	00001562 	andeq	r1, r0, r2, ror #10
    7868:	05c72804 	strbeq	r2, [r7, #2052]	; 0x804
    786c:	681f0000 	ldmdavs	pc, {}	; <UNPREDICTABLE>
    7870:	00000001 	andeq	r0, r0, r1
    7874:	0016681e 	andseq	r6, r6, lr, lsl r8
    7878:	dd5a0400 	cfldrdle	mvd0, [sl, #-0]
    787c:	1f000005 	svcne	0x00000005
    7880:	00000168 	andeq	r0, r0, r8, ror #2
    7884:	00016e1f 	andeq	r6, r1, pc, lsl lr
    7888:	741e0000 	ldrvc	r0, [lr], #-0
    788c:	04000016 	streq	r0, [r0], #-22
    7890:	0005f33e 	andeq	pc, r5, lr, lsr r3	; <UNPREDICTABLE>
    7894:	01681f00 	cmneq	r8, r0, lsl #30
    7898:	6e1f0000 	cdpvs	0, 1, cr0, cr15, cr0, {0}
    789c:	00000001 	andeq	r0, r0, r1
    78a0:	00159d1e 	andseq	r9, r5, lr, lsl sp
    78a4:	13330400 	teqne	r3, #0, 8
    78a8:	1f000006 	svcne	0x00000006
    78ac:	00000168 	andeq	r0, r0, r8, ror #2
    78b0:	00016e1f 	andeq	r6, r1, pc, lsl lr
    78b4:	016e1f00 	cmneq	lr, r0, lsl #30
    78b8:	761f0000 	ldrvc	r0, [pc], -r0
    78bc:	00000000 	andeq	r0, r0, r0
    78c0:	0015c220 	andseq	ip, r5, r0, lsr #4
    78c4:	762d0400 	strtvc	r0, [sp], -r0, lsl #8
    78c8:	1f000000 	svcne	0x00000000
    78cc:	0000016e 	andeq	r0, r0, lr, ror #2
    78d0:	00016e1f 	andeq	r6, r1, pc, lsl lr
    78d4:	ac000000 	stcge	0, cr0, [r0], {-0}
    78d8:	04000005 	streq	r0, [r0], #-5
    78dc:	001b7900 	andseq	r7, fp, r0, lsl #18
    78e0:	b4010400 	strlt	r0, [r1], #-1024	; 0x400
    78e4:	01000014 	tsteq	r0, r4, lsl r0
    78e8:	000019bf 			; <UNDEFINED> instruction: 0x000019bf
    78ec:	00000893 	muleq	r0, r3, r8
    78f0:	00000930 	andeq	r0, r0, r0, lsr r9
    78f4:	00000000 	andeq	r0, r0, r0
    78f8:	00002376 	andeq	r2, r0, r6, ror r3
    78fc:	69050402 	stmdbvs	r5, {r1, sl}
    7900:	0300746e 	movweq	r7, #1134	; 0x46e
    7904:	02570704 	subseq	r0, r7, #4, 14	; 0x100000
    7908:	01030000 	mrseq	r0, (UNDEF: 3)
    790c:	00081a06 	andeq	r1, r8, r6, lsl #20
    7910:	08010300 	stmdaeq	r1, {r8, r9}
    7914:	00000818 	andeq	r0, r0, r8, lsl r8
    7918:	fc050203 	stc2	2, cr0, [r5], {3}
    791c:	03000006 	movweq	r0, #6
    7920:	09490702 	stmdbeq	r9, {r1, r8, r9, sl}^
    7924:	04030000 	streq	r0, [r3], #-0
    7928:	0004da05 	andeq	sp, r4, r5, lsl #20
    792c:	07040300 	streq	r0, [r4, -r0, lsl #6]
    7930:	00000252 	andeq	r0, r0, r2, asr r2
    7934:	d5050803 	strle	r0, [r5, #-2051]	; 0x803
    7938:	03000004 	movweq	r0, #4
    793c:	024d0708 	subeq	r0, sp, #8, 14	; 0x200000
    7940:	04030000 	streq	r0, [r3], #-0
    7944:	00078b07 	andeq	r8, r7, r7, lsl #22
    7948:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    794c:	00003a04 	andeq	r3, r0, r4, lsl #20
    7950:	08010300 	stmdaeq	r1, {r8, r9}
    7954:	00000821 	andeq	r0, r0, r1, lsr #16
    7958:	0c026806 	stceq	8, cr6, [r2], {6}
    795c:	000000ae 	andeq	r0, r0, lr, lsr #1
    7960:	00191707 	andseq	r1, r9, r7, lsl #14
    7964:	ae0e0200 	cdpge	2, 0, cr0, cr14, cr0, {0}
    7968:	00000000 	andeq	r0, r0, r0
    796c:	0017c707 	andseq	ip, r7, r7, lsl #14
    7970:	be0f0200 	cdplt	2, 0, cr0, cr15, cr0, {0}
    7974:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    7978:	00046c07 	andeq	r6, r4, r7, lsl #24
    797c:	ce100200 	cdpgt	2, 1, cr0, cr0, cr0, {0}
    7980:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    7984:	00560800 	subseq	r0, r6, r0, lsl #16
    7988:	00be0000 	adcseq	r0, lr, r0
    798c:	6b090000 	blvs	247994 <_etext+0x24047c>
    7990:	01000000 	mrseq	r0, (UNDEF: 0)
    7994:	00560800 	subseq	r0, r6, r0, lsl #16
    7998:	00ce0000 	sbceq	r0, lr, r0
    799c:	6b090000 	blvs	2479a4 <_etext+0x24048c>
    79a0:	07000000 	streq	r0, [r0, -r0]
    79a4:	003a0800 	eorseq	r0, sl, r0, lsl #16
    79a8:	00de0000 	sbcseq	r0, lr, r0
    79ac:	6b090000 	blvs	2479b4 <_etext+0x24049c>
    79b0:	3f000000 	svccc	0x00000000
    79b4:	13a50a00 			; <UNDEFINED> instruction: 0x13a50a00
    79b8:	12020000 	andne	r0, r2, #0
    79bc:	00000081 	andeq	r0, r0, r1, lsl #1
    79c0:	0019dd0b 	andseq	sp, r9, fp, lsl #26
    79c4:	01c10100 	biceq	r0, r1, r0, lsl #2
    79c8:	0000012d 	andeq	r0, r0, sp, lsr #2
    79cc:	7874630c 	ldmdavc	r4!, {r2, r3, r8, r9, sp, lr}^
    79d0:	2dc10100 	stfcse	f0, [r1]
    79d4:	0d000001 	stceq	0, cr0, [r0, #-4]
    79d8:	000011e8 	andeq	r1, r0, r8, ror #3
    79dc:	0074c101 	rsbseq	ip, r4, r1, lsl #2
    79e0:	4e0d0000 	cdpmi	0, 0, cr0, cr13, cr0, {0}
    79e4:	01000013 	tsteq	r0, r3, lsl r0
    79e8:	000056c1 	andeq	r5, r0, r1, asr #13
    79ec:	199d0e00 	ldmibne	sp, {r9, sl, fp}
    79f0:	c3010000 	movwgt	r0, #4096	; 0x1000
    79f4:	00000056 	andeq	r0, r0, r6, asr r0
    79f8:	0019a20e 	andseq	sl, r9, lr, lsl #4
    79fc:	56c30100 	strbpl	r0, [r3], r0, lsl #2
    7a00:	00000000 	andeq	r0, r0, r0
    7a04:	00de0405 	sbcseq	r0, lr, r5, lsl #8
    7a08:	350f0000 	strcc	r0, [pc, #-0]	; 7a10 <_etext+0x4f8>
    7a0c:	01000013 	tsteq	r0, r3, lsl r0
    7a10:	002fdc2f 	eoreq	sp, pc, pc, lsr #24
    7a14:	00005800 	andeq	r5, r0, r0, lsl #16
    7a18:	569c0100 	ldrpl	r0, [ip], r0, lsl #2
    7a1c:	10000001 	andne	r0, r0, r1
    7a20:	00787463 	rsbseq	r7, r8, r3, ror #8
    7a24:	012d2f01 	teqeq	sp, r1, lsl #30
    7a28:	50010000 	andpl	r0, r1, r0
    7a2c:	19ce0f00 	stmibne	lr, {r8, r9, sl, fp}^
    7a30:	3e010000 	cdpcc	0, 0, cr0, cr1, cr0, {0}
    7a34:	00003034 	andeq	r3, r0, r4, lsr r0
    7a38:	00001f64 	andeq	r1, r0, r4, ror #30
    7a3c:	021d9c01 	andseq	r9, sp, #256	; 0x100
    7a40:	63110000 	tstvs	r1, #0
    7a44:	01007874 	tsteq	r0, r4, ror r8
    7a48:	00012d3e 	andeq	r2, r1, lr, lsr sp
    7a4c:	0050c200 	subseq	ip, r0, r0, lsl #4
    7a50:	0e8b1200 	cdpeq	2, 8, cr1, cr11, cr0, {0}
    7a54:	3e010000 	cdpcc	0, 0, cr0, cr1, cr0, {0}
    7a58:	00000074 	andeq	r0, r0, r4, ror r0
    7a5c:	00005119 	andeq	r5, r0, r9, lsl r1
    7a60:	0019eb13 	andseq	lr, r9, r3, lsl fp
    7a64:	56400100 	strbpl	r0, [r0], -r0, lsl #2
    7a68:	3a000000 	bcc	7a70 <_etext+0x558>
    7a6c:	13000051 	movwne	r0, #81	; 0x51
    7a70:	000019f1 	strdeq	r1, [r0], -r1	; <UNPREDICTABLE>
    7a74:	00564001 	subseq	r4, r6, r1
    7a78:	53ac0000 			; <UNDEFINED> instruction: 0x53ac0000
    7a7c:	57140000 	ldrpl	r0, [r4, -r0]
    7a80:	1d400100 	stfnee	f0, [r0, #-0]
    7a84:	56000002 	strpl	r0, [r0], -r2
    7a88:	14000060 	strne	r0, [r0], #-96	; 0x60
    7a8c:	41010041 	tstmi	r1, r1, asr #32
    7a90:	00000056 	andeq	r0, r0, r6, asr r0
    7a94:	0000693b 	andeq	r6, r0, fp, lsr r9
    7a98:	01004214 	tsteq	r0, r4, lsl r2
    7a9c:	00005641 	andeq	r5, r0, r1, asr #12
    7aa0:	0069be00 	rsbeq	fp, r9, r0, lsl #28
    7aa4:	00431400 	subeq	r1, r3, r0, lsl #8
    7aa8:	00564101 	subseq	r4, r6, r1, lsl #2
    7aac:	6a200000 	bvs	807ab4 <_etext+0x80059c>
    7ab0:	44140000 	ldrmi	r0, [r4], #-0
    7ab4:	56410100 	strbpl	r0, [r1], -r0, lsl #2
    7ab8:	75000000 	strvc	r0, [r0, #-0]
    7abc:	1400006a 	strne	r0, [r0], #-106	; 0x6a
    7ac0:	41010045 	tstmi	r1, r5, asr #32
    7ac4:	00000056 	andeq	r0, r0, r6, asr r0
    7ac8:	00006aca 	andeq	r6, r0, sl, asr #21
    7acc:	01004614 	tsteq	r0, r4, lsl r6
    7ad0:	00005641 	andeq	r5, r0, r1, asr #12
    7ad4:	006b4b00 	rsbeq	r4, fp, r0, lsl #22
    7ad8:	00471400 	subeq	r1, r7, r0, lsl #8
    7adc:	00564101 	subseq	r4, r6, r1, lsl #2
    7ae0:	6bc30000 	blvs	ff0c7ae8 <BootRAM+0xe038289>
    7ae4:	48140000 	ldmdami	r4, {}	; <UNPREDICTABLE>
    7ae8:	56410100 	strbpl	r0, [r1], -r0, lsl #2
    7aec:	3b000000 	blcc	7af4 <_etext+0x5dc>
    7af0:	0000006c 	andeq	r0, r0, ip, rrx
    7af4:	00005608 	andeq	r5, r0, r8, lsl #12
    7af8:	00022d00 	andeq	r2, r2, r0, lsl #26
    7afc:	006b0900 	rsbeq	r0, fp, r0, lsl #18
    7b00:	003f0000 	eorseq	r0, pc, r0
    7b04:	0000e915 	andeq	lr, r0, r5, lsl r9
    7b08:	004f9800 	subeq	r9, pc, r0, lsl #16
    7b0c:	00008e00 	andeq	r8, r0, r0, lsl #28
    7b10:	f29c0100 	vaddw.s16	q0, q6, d0
    7b14:	16000002 	strne	r0, [r0], -r2
    7b18:	000000f5 	strdeq	r0, [r0], -r5
    7b1c:	00006cbe 			; <UNDEFINED> instruction: 0x00006cbe
    7b20:	00010016 	andeq	r0, r1, r6, lsl r0
    7b24:	006d1600 	rsbeq	r1, sp, r0, lsl #12
    7b28:	010b1600 	tsteq	fp, r0, lsl #12
    7b2c:	6d740000 	ldclvs	0, cr0, [r4, #-0]
    7b30:	16170000 	ldrne	r0, [r7], -r0
    7b34:	17000001 	strne	r0, [r0, -r1]
    7b38:	00000121 	andeq	r0, r0, r1, lsr #2
    7b3c:	0008c018 	andeq	ip, r8, r8, lsl r0
    7b40:	010b1600 	tsteq	fp, r0, lsl #12
    7b44:	6dd20000 	ldclvs	0, cr0, [r2]
    7b48:	00160000 	andseq	r0, r6, r0
    7b4c:	2a000001 	bcs	7b58 <_etext+0x640>
    7b50:	1600006e 	strne	r0, [r0], -lr, rrx
    7b54:	000000f5 	strdeq	r0, [r0], -r5
    7b58:	00006e74 	andeq	r6, r0, r4, ror lr
    7b5c:	0008c018 	andeq	ip, r8, r8, lsl r0
    7b60:	01161900 	tsteq	r6, r0, lsl #18
    7b64:	6ecc0000 	cdpvs	0, 12, cr0, cr12, cr0, {0}
    7b68:	21190000 	tstcs	r9, r0
    7b6c:	0d000001 	stceq	0, cr0, [r0, #-4]
    7b70:	1a00006f 	bne	7d34 <_etext+0x81c>
    7b74:	00004fcc 	andeq	r4, r0, ip, asr #31
    7b78:	00000156 	andeq	r0, r0, r6, asr r1
    7b7c:	000002b6 			; <UNDEFINED> instruction: 0x000002b6
    7b80:	0251011b 	subseq	r0, r1, #-1073741818	; 0xc0000006
    7b84:	011b0074 	tsteq	fp, r4, ror r0
    7b88:	00760250 	rsbseq	r0, r6, r0, asr r2
    7b8c:	50041c00 	andpl	r1, r4, r0, lsl #24
    7b90:	058b0000 	streq	r0, [fp]
    7b94:	121a0000 	andsne	r0, sl, #0
    7b98:	8b000050 	blhi	7ce0 <_etext+0x7c8>
    7b9c:	d9000005 	stmdble	r0, {r0, r2}
    7ba0:	1b000002 	blne	7bb0 <_etext+0x698>
    7ba4:	74025201 	strvc	r5, [r2], #-513	; 0x201
    7ba8:	51011b00 	tstpl	r1, r0, lsl #22
    7bac:	00007802 	andeq	r7, r0, r2, lsl #16
    7bb0:	00501c1d 	subseq	r1, r0, sp, lsl ip
    7bb4:	00015600 	andeq	r5, r1, r0, lsl #12
    7bb8:	51011b00 	tstpl	r1, r0, lsl #22
    7bbc:	1b287602 	blne	a253cc <_etext+0xa1deb4>
    7bc0:	76025001 	strvc	r5, [r2], -r1
    7bc4:	00000000 	andeq	r0, r0, r0
    7bc8:	19a70f00 	stmibne	r7!, {r8, r9, sl, fp}
    7bcc:	f0010000 			; <UNDEFINED> instruction: 0xf0010000
    7bd0:	00005028 	andeq	r5, r0, r8, lsr #32
    7bd4:	00000218 	andeq	r0, r0, r8, lsl r2
    7bd8:	054b9c01 	strbeq	r9, [fp, #-3073]	; 0xc01
    7bdc:	63110000 	tstvs	r1, #0
    7be0:	01007874 	tsteq	r0, r4, ror r8
    7be4:	00012df0 	strdeq	r2, [r1], -r0
    7be8:	006f4500 	rsbeq	r4, pc, r0, lsl #10
    7bec:	1a061200 	bne	18c3f4 <_etext+0x184edc>
    7bf0:	f0010000 			; <UNDEFINED> instruction: 0xf0010000
    7bf4:	00000074 	andeq	r0, r0, r4, ror r0
    7bf8:	00006f63 	andeq	r6, r0, r3, ror #30
    7bfc:	001a0d13 	andseq	r0, sl, r3, lsl sp
    7c00:	56f20100 	ldrbtpl	r0, [r2], r0, lsl #2
    7c04:	ad000000 	stcge	0, cr0, [r0, #-0]
    7c08:	1300006f 	movwne	r0, #111	; 0x6f
    7c0c:	000019b5 			; <UNDEFINED> instruction: 0x000019b5
    7c10:	0056f201 	subseq	pc, r6, r1, lsl #4
    7c14:	6fe10000 	svcvs	0x00e10000
    7c18:	ba130000 	blt	4c7c20 <_etext+0x4c0708>
    7c1c:	01000019 	tsteq	r0, r9, lsl r0
    7c20:	000056f3 	strdeq	r5, [r0], -r3
    7c24:	00700a00 	rsbseq	r0, r0, r0, lsl #20
    7c28:	6f6c1400 	svcvs	0x006c1400
    7c2c:	f3010077 	vqadd.u8	q0, <illegal reg q0.5>, <illegal reg q11.5>
    7c30:	00000056 	andeq	r0, r0, r6, asr r0
    7c34:	00007033 	andeq	r7, r0, r3, lsr r0
    7c38:	0019961e 	andseq	r9, r9, lr, lsl r6
    7c3c:	4bf40100 	blmi	ffd08044 <BootRAM+0xec787e5>
    7c40:	02000005 	andeq	r0, r0, #5
    7c44:	e91f5091 	ldmdb	pc, {r0, r4, r7, ip, lr}	; <UNPREDICTABLE>
    7c48:	50000000 	andpl	r0, r0, r0
    7c4c:	d8000050 	stmdale	r0, {r4, r6}
    7c50:	01000008 	tsteq	r0, r8
    7c54:	045b0100 	ldrbeq	r0, [fp], #-256	; 0x100
    7c58:	0b160000 	bleq	587c60 <_etext+0x580748>
    7c5c:	e1000001 	tst	r0, r1
    7c60:	2000006f 	andcs	r0, r0, pc, rrx
    7c64:	00000100 	andeq	r0, r0, r0, lsl #2
    7c68:	02c40306 	sbceq	r0, r4, #402653184	; 0x18000000
    7c6c:	209f2000 	addscs	r2, pc, r0
    7c70:	000000f5 	strdeq	r0, [r0], -r5
    7c74:	d8185401 	ldmdale	r8, {r0, sl, ip, lr}
    7c78:	17000008 	strne	r0, [r0, -r8]
    7c7c:	00000116 	andeq	r0, r0, r6, lsl r1
    7c80:	00012117 	andeq	r2, r1, r7, lsl r1
    7c84:	08d81800 	ldmeq	r8, {fp, ip}^
    7c88:	0b160000 	bleq	587c90 <_etext+0x580778>
    7c8c:	5c000001 	stcpl	0, cr0, [r0], {1}
    7c90:	16000070 			; <UNDEFINED> instruction: 0x16000070
    7c94:	00000100 	andeq	r0, r0, r0, lsl #2
    7c98:	000070bf 	strheq	r7, [r0], -pc	; <UNPREDICTABLE>
    7c9c:	0000f520 	andeq	pc, r0, r0, lsr #10
    7ca0:	18540100 	ldmdane	r4, {r8}^
    7ca4:	000008d8 	ldrdeq	r0, [r0], -r8
    7ca8:	00011619 	andeq	r1, r1, r9, lsl r6
    7cac:	00711800 	rsbseq	r1, r1, r0, lsl #16
    7cb0:	01211900 	teqeq	r1, r0, lsl #18
    7cb4:	71590000 	cmpvc	r9, r0
    7cb8:	b61a0000 	ldrlt	r0, [sl], -r0
    7cbc:	8b000050 	blhi	7e04 <_etext+0x8ec>
    7cc0:	02000005 	andeq	r0, r0, #5
    7cc4:	1b000004 	blne	7cdc <_etext+0x7c4>
    7cc8:	79025101 	stmdbvc	r2, {r0, r8, ip, lr}
    7ccc:	50011b00 	andpl	r1, r1, r0, lsl #22
    7cd0:	76007407 	strvc	r7, [r0], -r7, lsl #8
    7cd4:	28232200 	stmdacs	r3!, {r9, sp}
    7cd8:	519c1a00 	orrspl	r1, ip, r0, lsl #20
    7cdc:	058b0000 	streq	r0, [fp]
    7ce0:	04270000 	strteq	r0, [r7], #-0
    7ce4:	011b0000 	tsteq	fp, r0
    7ce8:	00770252 	rsbseq	r0, r7, r2, asr r2
    7cec:	0251011b 	subseq	r0, r1, #-1073741818	; 0xc0000006
    7cf0:	011b0079 	tsteq	fp, r9, ror r0
    7cf4:	00740750 	rsbseq	r0, r4, r0, asr r7
    7cf8:	23220076 	teqcs	r2, #118	; 0x76
    7cfc:	ac1a0028 	ldcge	0, cr0, [sl], {40}	; 0x28
    7d00:	56000051 			; <UNDEFINED> instruction: 0x56000051
    7d04:	41000001 	tstmi	r0, r1
    7d08:	1b000004 	blne	7d20 <_etext+0x808>
    7d0c:	74025101 	strvc	r5, [r2], #-257	; 0x101
    7d10:	50011b28 	andpl	r1, r1, r8, lsr #22
    7d14:	00007402 	andeq	r7, r0, r2, lsl #8
    7d18:	0051c01d 	subseq	ip, r1, sp, lsl r0
    7d1c:	00015600 	andeq	r5, r1, r0, lsl #12
    7d20:	51011b00 	tstpl	r1, r0, lsl #22
    7d24:	1b007602 	blne	25534 <_etext+0x1e01c>
    7d28:	74025001 	strvc	r5, [r2], #-1
    7d2c:	00000000 	andeq	r0, r0, r0
    7d30:	e9210000 	stmdb	r1!, {}	; <UNPREDICTABLE>
    7d34:	b6000000 	strlt	r0, [r0], -r0
    7d38:	10000050 	andne	r0, r0, r0, asr r0
    7d3c:	01000009 	tsteq	r0, r9
    7d40:	0b160101 	bleq	58814c <_etext+0x580c34>
    7d44:	b7000001 	strlt	r0, [r0, -r1]
    7d48:	16000071 			; <UNDEFINED> instruction: 0x16000071
    7d4c:	00000100 	andeq	r0, r0, r0, lsl #2
    7d50:	000071e3 	andeq	r7, r0, r3, ror #3
    7d54:	0000f516 	andeq	pc, r0, r6, lsl r5	; <UNPREDICTABLE>
    7d58:	00721900 	rsbseq	r1, r2, r0, lsl #18
    7d5c:	09101800 	ldmdbeq	r0, {fp, ip}
    7d60:	16170000 	ldrne	r0, [r7], -r0
    7d64:	17000001 	strne	r0, [r0, -r1]
    7d68:	00000121 	andeq	r0, r0, r1, lsr #2
    7d6c:	00091018 	andeq	r1, r9, r8, lsl r0
    7d70:	010b1600 	tsteq	fp, r0, lsl #12
    7d74:	72420000 	subvc	r0, r2, #0
    7d78:	00160000 	andseq	r0, r6, r0
    7d7c:	91000001 	tstls	r0, r1
    7d80:	16000072 			; <UNDEFINED> instruction: 0x16000072
    7d84:	000000f5 	strdeq	r0, [r0], -r5
    7d88:	00007219 	andeq	r7, r0, r9, lsl r2
    7d8c:	00091018 	andeq	r1, r9, r8, lsl r0
    7d90:	01161900 	tsteq	r6, r0, lsl #18
    7d94:	72d00000 	sbcsvc	r0, r0, #0
    7d98:	21190000 	tstcs	r9, r0
    7d9c:	06000001 	streq	r0, [r0], -r1
    7da0:	1a000073 	bne	7f74 <_etext+0xa5c>
    7da4:	000050f0 	strdeq	r5, [r0], -r0
    7da8:	0000058b 	andeq	r0, r0, fp, lsl #11
    7dac:	000004f1 	strdeq	r0, [r0], -r1
    7db0:	0252011b 	subseq	r0, r2, #-1073741818	; 0xc0000006
    7db4:	011b0076 	tsteq	fp, r6, ror r0
    7db8:	00790251 	rsbseq	r0, r9, r1, asr r2
    7dbc:	0750011b 	smmlaeq	r0, fp, r1, r0
    7dc0:	00780074 	rsbseq	r0, r8, r4, ror r0
    7dc4:	00282322 	eoreq	r2, r8, r2, lsr #6
    7dc8:	0051f01a 	subseq	pc, r1, sl, lsl r0	; <UNPREDICTABLE>
    7dcc:	00058b00 	andeq	r8, r5, r0, lsl #22
    7dd0:	00051600 	andeq	r1, r5, r0, lsl #12
    7dd4:	52011b00 	andpl	r1, r1, #0, 22
    7dd8:	1b007902 	blne	261e8 <_etext+0x1ecd0>
    7ddc:	7d025101 	stfvcs	f5, [r2, #-4]
    7de0:	50011b00 	andpl	r1, r1, r0, lsl #22
    7de4:	78007407 	stmdavc	r0, {r0, r1, r2, sl, ip, sp, lr}
    7de8:	28232200 	stmdacs	r3!, {r9, sp}
    7dec:	52021a00 	andpl	r1, r2, #0, 20
    7df0:	01560000 	cmpeq	r6, r0
    7df4:	05300000 	ldreq	r0, [r0, #-0]!
    7df8:	011b0000 	tsteq	fp, r0
    7dfc:	28740251 	ldmdacs	r4!, {r0, r4, r6, r9}^
    7e00:	0250011b 	subseq	r0, r0, #-1073741818	; 0xc0000006
    7e04:	1d000074 	stcne	0, cr0, [r0, #-464]	; 0xfffffe30
    7e08:	00005212 	andeq	r5, r0, r2, lsl r2
    7e0c:	00000156 	andeq	r0, r0, r6, asr r1
    7e10:	0251011b 	subseq	r0, r1, #-1073741818	; 0xc0000006
    7e14:	011b0077 	tsteq	fp, r7, ror r0
    7e18:	00740250 	rsbseq	r0, r4, r0, asr r2
    7e1c:	00000000 	andeq	r0, r0, r0
    7e20:	3a080000 	bcc	207e28 <_etext+0x200910>
    7e24:	5b000000 	blpl	7e2c <_etext+0x914>
    7e28:	09000005 	stmdbeq	r0, {r0, r2}
    7e2c:	0000006b 	andeq	r0, r0, fp, rrx
    7e30:	f71e0007 			; <UNDEFINED> instruction: 0xf71e0007
    7e34:	01000019 	tsteq	r0, r9, lsl r0
    7e38:	0000cee8 	andeq	ip, r0, r8, ror #29
    7e3c:	c4030500 	strgt	r0, [r3], #-1280	; 0x500
    7e40:	08200002 	stmdaeq	r0!, {r1}
    7e44:	0000002c 	andeq	r0, r0, ip, lsr #32
    7e48:	0000057c 	andeq	r0, r0, ip, ror r5
    7e4c:	00006b09 	andeq	r6, r0, r9, lsl #22
    7e50:	22003f00 	andcs	r3, r0, #0, 30
    7e54:	1201006b 	andne	r0, r1, #107	; 0x6b
    7e58:	0000056c 	andeq	r0, r0, ip, ror #10
    7e5c:	03040305 	movweq	r0, #17157	; 0x4305
    7e60:	d2232000 	eorle	r2, r3, #0
    7e64:	72000015 	andvc	r0, r0, #21
    7e68:	a8000000 	stmdage	r0, {}	; <UNPREDICTABLE>
    7e6c:	24000005 	strcs	r0, [r0], #-5
    7e70:	00000072 	andeq	r0, r0, r2, ror r0
    7e74:	0005a824 	andeq	sl, r5, r4, lsr #16
    7e78:	006b2400 	rsbeq	r2, fp, r0, lsl #8
    7e7c:	05000000 	streq	r0, [r0, #-0]
    7e80:	0005ae04 	andeq	sl, r5, r4, lsl #28
    7e84:	7f002500 	svcvc	0x00002500
    7e88:	04000007 	streq	r0, [r0], #-7
    7e8c:	001d5900 	andseq	r5, sp, r0, lsl #18
    7e90:	b4010400 	strlt	r0, [r1], #-1024	; 0x400
    7e94:	01000014 	tsteq	r0, r4, lsl r0
    7e98:	00001a46 	andeq	r1, r0, r6, asr #20
    7e9c:	00000893 	muleq	r0, r3, r8
    7ea0:	00000ba8 	andeq	r0, r0, r8, lsr #23
    7ea4:	00000000 	andeq	r0, r0, r0
    7ea8:	00002b7f 	andeq	r2, r0, pc, ror fp
    7eac:	4d070802 	stcmi	8, cr0, [r7, #-8]
    7eb0:	02000002 	andeq	r0, r0, #2
    7eb4:	08180801 	ldmdaeq	r8, {r0, fp}
    7eb8:	04020000 	streq	r0, [r2], #-0
    7ebc:	00025707 	andeq	r5, r2, r7, lsl #14
    7ec0:	06010200 	streq	r0, [r1], -r0, lsl #4
    7ec4:	0000081a 	andeq	r0, r0, sl, lsl r8
    7ec8:	000b0103 	andeq	r0, fp, r3, lsl #2
    7ecc:	2c1c0200 	lfmcs	f0, 4, [ip], {-0}
    7ed0:	02000000 	andeq	r0, r0, #0
    7ed4:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
    7ed8:	02020000 	andeq	r0, r2, #0
    7edc:	00094907 	andeq	r4, r9, r7, lsl #18
    7ee0:	05040200 	streq	r0, [r4, #-512]	; 0x200
    7ee4:	000004da 	ldrdeq	r0, [r0], -sl
    7ee8:	52070402 	andpl	r0, r7, #33554432	; 0x2000000
    7eec:	02000002 	andeq	r0, r0, #2
    7ef0:	04d50508 	ldrbeq	r0, [r5], #1288	; 0x508
    7ef4:	51030000 	mrspl	r0, (UNDEF: 3)
    7ef8:	02000017 	andeq	r0, r0, #23
    7efc:	0000254e 	andeq	r2, r0, lr, asr #10
    7f00:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    7f04:	00746e69 	rsbseq	r6, r4, r9, ror #28
    7f08:	000b0303 	andeq	r0, fp, r3, lsl #6
    7f0c:	412a0300 	teqmi	sl, r0, lsl #6
    7f10:	03000000 	movweq	r0, #0
    7f14:	00001753 	andeq	r1, r0, r3, asr r7
    7f18:	006f4e03 	rsbeq	r4, pc, r3, lsl #28
    7f1c:	c7030000 	strgt	r0, [r3, -r0]
    7f20:	0400000a 	streq	r0, [r0], #-10
    7f24:	000033d4 	ldrdeq	r3, [r0], -r4
    7f28:	07040200 	streq	r0, [r4, -r0, lsl #4]
    7f2c:	0000078b 	andeq	r0, r0, fp, lsl #15
    7f30:	01020405 	tsteq	r2, r5, lsl #8
    7f34:	00082108 	andeq	r2, r8, r8, lsl #2
    7f38:	17c00600 	strbne	r0, [r0, r0, lsl #12]
    7f3c:	05400000 	strbeq	r0, [r0, #-0]
    7f40:	0000c914 	andeq	ip, r0, r4, lsl r9
    7f44:	00680700 	rsbeq	r0, r8, r0, lsl #14
    7f48:	00c91505 	sbceq	r1, r9, r5, lsl #10
    7f4c:	00000000 	andeq	r0, r0, r0
    7f50:	00008c08 	andeq	r8, r0, r8, lsl #24
    7f54:	0000d900 	andeq	sp, r0, r0, lsl #18
    7f58:	00a20900 	adceq	r0, r2, r0, lsl #18
    7f5c:	00070000 	andeq	r0, r7, r0
    7f60:	001a380a 	andseq	r3, sl, sl, lsl #16
    7f64:	8c5f0100 	ldfhie	f0, [pc], {-0}
    7f68:	03000000 	movweq	r0, #0
    7f6c:	000000fe 	strdeq	r0, [r0], -lr
    7f70:	0100780b 	tsteq	r0, fp, lsl #16
    7f74:	00008c5f 	andeq	r8, r0, pc, asr ip
    7f78:	18540c00 	ldmdane	r4, {sl, fp}^
    7f7c:	5f010000 	svcpl	0x00010000
    7f80:	0000007a 	andeq	r0, r0, sl, ror r0
    7f84:	1a3e0d00 	bne	f8b38c <_etext+0xf83e74>
    7f88:	4b010000 	blmi	47f90 <_etext+0x40a78>
    7f8c:	00011d03 	andeq	r1, r1, r3, lsl #26
    7f90:	00780b00 	rsbseq	r0, r8, r0, lsl #22
    7f94:	011d4b01 	tsteq	sp, r1, lsl #22
    7f98:	760b0000 	strvc	r0, [fp], -r0
    7f9c:	8c4b0100 	stfhie	f0, [fp], {-0}
    7fa0:	00000000 	andeq	r0, r0, r0
    7fa4:	0081040e 	addeq	r0, r1, lr, lsl #8
    7fa8:	550a0000 	strpl	r0, [sl, #-0]
    7fac:	0100001a 	tsteq	r0, sl, lsl r0
    7fb0:	00008c3b 	andeq	r8, r0, fp, lsr ip
    7fb4:	01460300 	mrseq	r0, SPSR_und
    7fb8:	780b0000 	stmdavc	fp, {}	; <UNPREDICTABLE>
    7fbc:	463b0100 	ldrtmi	r0, [fp], -r0, lsl #2
    7fc0:	0f000001 	svceq	0x00000001
    7fc4:	3d010072 	stccc	0, cr0, [r1, #-456]	; 0xfffffe38
    7fc8:	0000008c 	andeq	r0, r0, ip, lsl #1
    7fcc:	4c040e00 	stcmi	14, cr0, [r4], {-0}
    7fd0:	10000001 	andne	r0, r0, r1
    7fd4:	00000081 	andeq	r0, r0, r1, lsl #1
    7fd8:	0017e711 	andseq	lr, r7, r1, lsl r7
    7fdc:	40640100 	rsbmi	r0, r4, r0, lsl #2
    7fe0:	94000052 	strls	r0, [r0], #-82	; 0x52
    7fe4:	01000004 	tsteq	r0, r4
    7fe8:	0004619c 	muleq	r4, ip, r1
    7fec:	00731200 	rsbseq	r1, r3, r0, lsl #4
    7ff0:	04616401 	strbteq	r6, [r1], #-1025	; 0x401
    7ff4:	735d0000 	cmpvc	sp, #0
    7ff8:	62120000 	andsvs	r0, r2, #0
    7ffc:	01006b6c 	tsteq	r0, ip, ror #22
    8000:	00014664 	andeq	r4, r1, r4, ror #12
    8004:	00738a00 	rsbseq	r8, r3, r0, lsl #20
    8008:	00771300 	rsbseq	r1, r7, r0, lsl #6
    800c:	04676601 	strbteq	r6, [r7], #-1537	; 0x601
    8010:	91030000 	mrsls	r0, (UNDEF: 3)
    8014:	61147ee0 	tstvs	r4, r0, ror #29
    8018:	8c670100 	stfhie	f0, [r7], #-0
    801c:	a8000000 	stmdage	r0, {}	; <UNPREDICTABLE>
    8020:	14000073 	strne	r0, [r0], #-115	; 0x73
    8024:	67010062 	strvs	r0, [r1, -r2, rrx]
    8028:	0000008c 	andeq	r0, r0, ip, lsl #1
    802c:	00007408 	andeq	r7, r0, r8, lsl #8
    8030:	01006314 	tsteq	r0, r4, lsl r3
    8034:	00008c67 	andeq	r8, r0, r7, ror #24
    8038:	00744a00 	rsbseq	r4, r4, r0, lsl #20
    803c:	00641400 	rsbeq	r1, r4, r0, lsl #8
    8040:	008c6701 	addeq	r6, ip, r1, lsl #14
    8044:	74930000 	ldrvc	r0, [r3], #0
    8048:	65140000 	ldrvs	r0, [r4, #-0]
    804c:	8c670100 	stfhie	f0, [r7], #-0
    8050:	f7000000 			; <UNDEFINED> instruction: 0xf7000000
    8054:	14000074 	strne	r0, [r0], #-116	; 0x74
    8058:	67010066 	strvs	r0, [r1, -r6, rrx]
    805c:	0000008c 	andeq	r0, r0, ip, lsl #1
    8060:	0000754b 	andeq	r7, r0, fp, asr #10
    8064:	01006714 	tsteq	r0, r4, lsl r7
    8068:	00008c67 	andeq	r8, r0, r7, ror #24
    806c:	00758c00 	rsbseq	r8, r5, r0, lsl #24
    8070:	00681400 	rsbeq	r1, r8, r0, lsl #8
    8074:	008c6701 	addeq	r6, ip, r1, lsl #14
    8078:	75d40000 	ldrbvc	r0, [r4]
    807c:	69140000 	ldmdbvs	r4, {}	; <UNPREDICTABLE>
    8080:	7a680100 	bvc	1a08488 <_etext+0x1a00f70>
    8084:	20000000 	andcs	r0, r0, r0
    8088:	15000076 	strne	r0, [r0, #-118]	; 0x76
    808c:	00000123 	andeq	r0, r0, r3, lsr #2
    8090:	00005250 	andeq	r5, r0, r0, asr r2
    8094:	00000958 	andeq	r0, r0, r8, asr r9
    8098:	02306b01 	eorseq	r6, r0, #1024	; 0x400
    809c:	33160000 	tstcc	r6, #0
    80a0:	63000001 	movwvs	r0, #1
    80a4:	17000076 	smlsdxne	r0, r6, r0, r0
    80a8:	00000958 	andeq	r0, r0, r8, asr r9
    80ac:	00013c18 	andeq	r3, r1, r8, lsl ip
    80b0:	0076de00 	rsbseq	sp, r6, r0, lsl #28
    80b4:	19000000 	stmdbne	r0, {}	; <UNPREDICTABLE>
    80b8:	0000539c 	muleq	r0, ip, r3
    80bc:	00000262 	andeq	r0, r0, r2, ror #4
    80c0:	00697714 	rsbeq	r7, r9, r4, lsl r7
    80c4:	04777b01 	ldrbteq	r7, [r7], #-2817	; 0xb01
    80c8:	77ba0000 	ldrvc	r0, [sl, r0]!
    80cc:	1d1a0000 	ldcne	0, cr0, [sl, #-0]
    80d0:	0100001a 	tsteq	r0, sl, lsl r0
    80d4:	0004777c 	andeq	r7, r4, ip, ror r7
    80d8:	0077cf00 	rsbseq	ip, r7, r0, lsl #30
    80dc:	69771400 	ldmdbvs	r7!, {sl, ip}^
    80e0:	7d010032 	stcvc	0, cr0, [r1, #-200]	; 0xffffff38
    80e4:	00000477 	andeq	r0, r0, r7, ror r4
    80e8:	00007829 	andeq	r7, r0, r9, lsr #16
    80ec:	37697714 			; <UNDEFINED> instruction: 0x37697714
    80f0:	777e0100 	ldrbvc	r0, [lr, -r0, lsl #2]!
    80f4:	6d000004 	stcvs	0, cr0, [r0, #-16]
    80f8:	14000078 	strne	r0, [r0], #-120	; 0x78
    80fc:	01003073 	tsteq	r0, r3, ror r0
    8100:	0004777f 	andeq	r7, r4, pc, ror r7
    8104:	0078b500 	rsbseq	fp, r8, r0, lsl #10
    8108:	31731400 	cmncc	r3, r0, lsl #8
    810c:	77810100 	strvc	r0, [r1, r0, lsl #2]
    8110:	f1000004 	cps	#4
    8114:	14000079 	strne	r0, [r0], #-121	; 0x79
    8118:	01003053 	qaddeq	r3, r3, r0
    811c:	00047785 	andeq	r7, r4, r5, lsl #15
    8120:	007ada00 	rsbseq	sp, sl, r0, lsl #20
    8124:	31531400 	cmpcc	r3, r0, lsl #8
    8128:	77860100 	strvc	r0, [r6, r0, lsl #2]
    812c:	9f000004 	svcls	0x00000004
    8130:	1400007b 	strne	r0, [r0], #-123	; 0x7b
    8134:	01006863 	tsteq	r0, r3, ror #16
    8138:	00047787 	andeq	r7, r4, r7, lsl #15
    813c:	007c6100 	rsbseq	r6, ip, r0, lsl #2
    8140:	19eb1a00 	stmibne	fp!, {r9, fp, ip}^
    8144:	88010000 	stmdahi	r1, {}	; <UNPREDICTABLE>
    8148:	00000477 	andeq	r0, r0, r7, ror r4
    814c:	00007cab 	andeq	r7, r0, fp, lsr #25
    8150:	6a616d14 	bvs	18635a8 <_etext+0x185c090>
    8154:	77890100 	strvc	r0, [r9, r0, lsl #2]
    8158:	c3000004 	movwgt	r0, #4
    815c:	1a00007c 	bne	8354 <_etext+0xe3c>
    8160:	000019f1 	strdeq	r1, [r0], -r1	; <UNPREDICTABLE>
    8164:	04778a01 	ldrbteq	r8, [r7], #-2561	; 0xa01
    8168:	7d1f0000 	ldcvc	0, cr0, [pc, #-0]	; 8170 <_etext+0xc58>
    816c:	d9150000 	ldmdble	r5, {}	; <UNPREDICTABLE>
    8170:	d4000000 	strle	r0, [r0], #-0
    8174:	70000053 	andvc	r0, r0, r3, asr r0
    8178:	01000009 	tsteq	r0, r9
    817c:	00030d86 	andeq	r0, r3, r6, lsl #27
    8180:	00f21600 	rscseq	r1, r2, r0, lsl #12
    8184:	7d470000 	stclvc	0, cr0, [r7, #-0]
    8188:	e9160000 	ldmdb	r6, {}	; <UNPREDICTABLE>
    818c:	67000000 	strvs	r0, [r0, -r0]
    8190:	0000007d 	andeq	r0, r0, sp, ror r0
    8194:	0000d915 	andeq	sp, r0, r5, lsl r9
    8198:	0053de00 	subseq	sp, r3, r0, lsl #28
    819c:	00099800 	andeq	r9, r9, r0, lsl #16
    81a0:	33860100 	orrcc	r0, r6, #0, 2
    81a4:	16000003 	strne	r0, [r0], -r3
    81a8:	000000f2 	strdeq	r0, [r0], -r2
    81ac:	00007d9c 	muleq	r0, ip, sp
    81b0:	0000e916 	andeq	lr, r0, r6, lsl r9
    81b4:	007d6700 	rsbseq	r6, sp, r0, lsl #14
    81b8:	d9150000 	ldmdble	r5, {}	; <UNPREDICTABLE>
    81bc:	10000000 	andne	r0, r0, r0
    81c0:	c0000054 	andgt	r0, r0, r4, asr r0
    81c4:	01000009 	tsteq	r0, r9
    81c8:	00035986 	andeq	r5, r3, r6, lsl #19
    81cc:	00f21600 	rscseq	r1, r2, r0, lsl #12
    81d0:	7dbc0000 	ldcvc	0, cr0, [ip]
    81d4:	e9160000 	ldmdb	r6, {}	; <UNPREDICTABLE>
    81d8:	67000000 	strvs	r0, [r0, -r0]
    81dc:	0000007d 	andeq	r0, r0, sp, ror r0
    81e0:	0000d915 	andeq	sp, r0, r5, lsl r9
    81e4:	00541400 	subseq	r1, r4, r0, lsl #8
    81e8:	0009f800 	andeq	pc, r9, r0, lsl #16
    81ec:	7f800100 	svcvc	0x00800100
    81f0:	16000003 	strne	r0, [r0], -r3
    81f4:	000000f2 	strdeq	r0, [r0], -r2
    81f8:	00007dde 	ldrdeq	r7, [r0], -lr
    81fc:	0000e916 	andeq	lr, r0, r6, lsl r9
    8200:	0077cf00 	rsbseq	ip, r7, r0, lsl #30
    8204:	d9150000 	ldmdble	r5, {}	; <UNPREDICTABLE>
    8208:	2c000000 	stccs	0, cr0, [r0], {-0}
    820c:	30000054 	andcc	r0, r0, r4, asr r0
    8210:	0100000a 	tsteq	r0, sl
    8214:	0003a580 	andeq	sl, r3, r0, lsl #11
    8218:	00f21600 	rscseq	r1, r2, r0, lsl #12
    821c:	7dfe0000 	ldclvc	0, cr0, [lr]
    8220:	e9160000 	ldmdb	r6, {}	; <UNPREDICTABLE>
    8224:	cf000000 	svcgt	0x00000000
    8228:	00000077 	andeq	r0, r0, r7, ror r0
    822c:	0000d915 	andeq	sp, r0, r5, lsl r9
    8230:	00547800 	subseq	r7, r4, r0, lsl #16
    8234:	000a6000 	andeq	r6, sl, r0
    8238:	cb820100 	blgt	fe088640 <BootRAM+0xcff8de1>
    823c:	16000003 	strne	r0, [r0], -r3
    8240:	000000f2 	strdeq	r0, [r0], -r2
    8244:	00007e1e 	andeq	r7, r0, lr, lsl lr
    8248:	0000e916 	andeq	lr, r0, r6, lsl r9
    824c:	00782900 	rsbseq	r2, r8, r0, lsl #18
    8250:	d9150000 	ldmdble	r5, {}	; <UNPREDICTABLE>
    8254:	80000000 	andhi	r0, r0, r0
    8258:	78000054 	stmdavc	r0, {r2, r4, r6}
    825c:	0100000a 	tsteq	r0, sl
    8260:	0003f185 	andeq	pc, r3, r5, lsl #3
    8264:	00f21600 	rscseq	r1, r2, r0, lsl #12
    8268:	7e3e0000 	cdpvc	0, 3, cr0, cr14, cr0, {0}
    826c:	e9160000 	ldmdb	r6, {}	; <UNPREDICTABLE>
    8270:	60000000 	andvs	r0, r0, r0
    8274:	0000007e 	andeq	r0, r0, lr, ror r0
    8278:	0000d915 	andeq	sp, r0, r5, lsl r9
    827c:	00548a00 	subseq	r8, r4, r0, lsl #20
    8280:	000aa000 	andeq	sl, sl, r0
    8284:	17850100 	strne	r0, [r5, r0, lsl #2]
    8288:	16000004 	strne	r0, [r0], -r4
    828c:	000000f2 	strdeq	r0, [r0], -r2
    8290:	00007e95 	muleq	r0, r5, lr
    8294:	0000e916 	andeq	lr, r0, r6, lsl r9
    8298:	007e6000 	rsbseq	r6, lr, r0
    829c:	d9150000 	ldmdble	r5, {}	; <UNPREDICTABLE>
    82a0:	ec000000 	stc	0, cr0, [r0], {-0}
    82a4:	c8000054 	stmdagt	r0, {r2, r4, r6}
    82a8:	0100000a 	tsteq	r0, sl
    82ac:	00043d82 	andeq	r3, r4, r2, lsl #27
    82b0:	00f21600 	rscseq	r1, r2, r0, lsl #12
    82b4:	7eb50000 	cdpvc	0, 11, cr0, cr5, cr0, {0}
    82b8:	e9160000 	ldmdb	r6, {}	; <UNPREDICTABLE>
    82bc:	29000000 	stmdbcs	r0, {}	; <UNPREDICTABLE>
    82c0:	00000078 	andeq	r0, r0, r8, ror r0
    82c4:	0000d91b 	andeq	sp, r0, fp, lsl r9
    82c8:	00555600 	subseq	r5, r5, r0, lsl #12
    82cc:	000ae800 	andeq	lr, sl, r0, lsl #16
    82d0:	16850100 	strne	r0, [r5], r0, lsl #2
    82d4:	000000f2 	strdeq	r0, [r0], -r2
    82d8:	00007ed7 	ldrdeq	r7, [r0], -r7	; <UNPREDICTABLE>
    82dc:	0000e916 	andeq	lr, r0, r6, lsl r9
    82e0:	007e6000 	rsbseq	r6, lr, r0
    82e4:	00000000 	andeq	r0, r0, r0
    82e8:	00b2040e 	adcseq	r0, r2, lr, lsl #8
    82ec:	8c080000 	stchi	0, cr0, [r8], {-0}
    82f0:	77000000 	strvc	r0, [r0, -r0]
    82f4:	09000004 	stmdbeq	r0, {r2}
    82f8:	000000a2 	andeq	r0, r0, r2, lsr #1
    82fc:	8c10000f 	ldchi	0, cr0, [r0], {15}
    8300:	11000000 	mrsne	r0, (UNDEF: 0)
    8304:	000016c7 	andeq	r1, r0, r7, asr #13
    8308:	56d4a501 	ldrbpl	sl, [r4], r1, lsl #10
    830c:	00880000 	addeq	r0, r8, r0
    8310:	9c010000 	stcls	0, cr0, [r1], {-0}
    8314:	0000058f 	andeq	r0, r0, pc, lsl #11
    8318:	01007312 	tsteq	r0, r2, lsl r3
    831c:	000461a5 	andeq	r6, r4, r5, lsr #3
    8320:	007ef900 	rsbseq	pc, lr, r0, lsl #18
    8324:	6c621200 	sfmvs	f1, 2, [r2], #-0
    8328:	a501006b 	strge	r0, [r1, #-107]	; 0x6b
    832c:	00000146 	andeq	r0, r0, r6, asr #2
    8330:	00007f17 	andeq	r7, r0, r7, lsl pc
    8334:	001a121c 	andseq	r1, sl, ip, lsl r2
    8338:	97a60100 	strls	r0, [r6, r0, lsl #2]!
    833c:	35000000 	strcc	r0, [r0, #-0]
    8340:	1d00007f 	stcne	0, cr0, [r0, #-508]	; 0xfffffe04
    8344:	00001a33 	andeq	r1, r0, r3, lsr sl
    8348:	058fa801 	streq	sl, [pc, #2049]	; 8b51 <_etext+0x1639>
    834c:	91030000 	mrsls	r0, (UNDEF: 3)
    8350:	221a7ee0 	andscs	r7, sl, #224, 28	; 0xe00
    8354:	0100001a 	tsteq	r0, sl, lsl r0
    8358:	00059fa9 	andeq	r9, r5, r9, lsr #31
    835c:	007f6c00 	rsbseq	r6, pc, r0, lsl #24
    8360:	00fe1500 	rscseq	r1, lr, r0, lsl #10
    8364:	56f80000 	ldrbtpl	r0, [r8], r0
    8368:	0b200000 	bleq	808370 <_etext+0x800e58>
    836c:	b5010000 	strlt	r0, [r1, #-0]
    8370:	00000500 	andeq	r0, r0, r0, lsl #10
    8374:	00011316 	andeq	r1, r1, r6, lsl r3
    8378:	007fab00 	rsbseq	sl, pc, r0, lsl #22
    837c:	010a1600 	tsteq	sl, r0, lsl #12
    8380:	7fd80000 	svcvc	0x00d80000
    8384:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    8388:	000056ec 	andeq	r5, r0, ip, ror #13
    838c:	00000741 	andeq	r0, r0, r1, asr #14
    8390:	0000051f 	andeq	r0, r0, pc, lsl r5
    8394:	0252011f 	subseq	r0, r2, #-1073741817	; 0xc0000007
    8398:	011f0075 	tsteq	pc, r5, ror r0	; <UNPREDICTABLE>
    839c:	1f300151 	svcne	0x00300151
    83a0:	7d025001 	stcvc	0, cr5, [r2, #-4]
    83a4:	2a1e0000 	bcs	7883ac <_etext+0x780e94>
    83a8:	51000057 	qaddpl	r0, r7, r0
    83ac:	39000001 	stmdbcc	r0, {r0}
    83b0:	1f000005 	svcne	0x00000005
    83b4:	7d025101 	stfvcs	f5, [r2, #-4]
    83b8:	50011f00 	andpl	r1, r1, r0, lsl #30
    83bc:	00007a02 	andeq	r7, r0, r2, lsl #20
    83c0:	00573a1e 	subseq	r3, r7, lr, lsl sl
    83c4:	00075e00 	andeq	r5, r7, r0, lsl #28
    83c8:	00055900 	andeq	r5, r5, r0, lsl #18
    83cc:	52011f00 	andpl	r1, r1, #0, 30
    83d0:	1f007602 	svcne	0x00007602
    83d4:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    83d8:	50011f00 	andpl	r1, r1, r0, lsl #30
    83dc:	00007d02 	andeq	r7, r0, r2, lsl #26
    83e0:	0057501e 	subseq	r5, r7, lr, lsl r0
    83e4:	00015100 	andeq	r5, r1, r0, lsl #2
    83e8:	00057300 	andeq	r7, r5, r0, lsl #6
    83ec:	51011f00 	tstpl	r1, r0, lsl #30
    83f0:	1f007d02 	svcne	0x00007d02
    83f4:	7a025001 	bvc	9c400 <_etext+0x94ee8>
    83f8:	5a200000 	bpl	808400 <_etext+0x800ee8>
    83fc:	41000057 	qaddmi	r0, r7, r0
    8400:	1f000007 	svcne	0x00000007
    8404:	75025201 	strvc	r5, [r2, #-513]	; 0x201
    8408:	51011f00 	tstpl	r1, r0, lsl #30
    840c:	011f3001 	tsteq	pc, r1
    8410:	007d0250 	rsbseq	r0, sp, r0, asr r2
    8414:	81080000 	mrshi	r0, (UNDEF: 8)
    8418:	9f000000 	svcls	0x00000000
    841c:	09000005 	stmdbeq	r0, {r0, r2}
    8420:	000000a2 	andeq	r0, r0, r2, lsr #1
    8424:	9710007f 			; <UNDEFINED> instruction: 0x9710007f
    8428:	11000000 	mrsne	r0, (UNDEF: 0)
    842c:	00001713 	andeq	r1, r0, r3, lsl r7
    8430:	575cb901 	ldrbpl	fp, [ip, -r1, lsl #18]
    8434:	02960000 	addseq	r0, r6, #0
    8438:	9c010000 	stcls	0, cr0, [r1], {-0}
    843c:	000006ef 	andeq	r0, r0, pc, ror #13
    8440:	01007312 	tsteq	r0, r2, lsl r3
    8444:	0006efb9 			; <UNDEFINED> instruction: 0x0006efb9
    8448:	00803b00 	addeq	r3, r0, r0, lsl #22
    844c:	0c341c00 	ldceq	12, cr1, [r4], #-0
    8450:	b9010000 	stmdblt	r1, {}	; <UNPREDICTABLE>
    8454:	0000011d 	andeq	r0, r0, sp, lsl r1
    8458:	0000805a 	andeq	r8, r0, sl, asr r0
    845c:	001a2c1c 	andseq	r2, sl, ip, lsl ip
    8460:	33ba0100 			; <UNDEFINED> instruction: 0x33ba0100
    8464:	9d000000 	stcls	0, cr0, [r0, #-0]
    8468:	12000080 	andne	r0, r0, #128	; 0x80
    846c:	006e656c 	rsbeq	r6, lr, ip, ror #10
    8470:	0033ba01 	eorseq	fp, r3, r1, lsl #20
    8474:	80be0000 	adcshi	r0, lr, r0
    8478:	69140000 	ldmdbvs	r4, {}	; <UNPREDICTABLE>
    847c:	7abc0100 	bvc	fef08884 <BootRAM+0xde79025>
    8480:	33000000 	movwcc	r0, #0
    8484:	15000081 	strne	r0, [r0, #-129]	; 0x81
    8488:	000000fe 	strdeq	r0, [r0], -lr
    848c:	000057b6 			; <UNDEFINED> instruction: 0x000057b6
    8490:	00000b38 	andeq	r0, r0, r8, lsr fp
    8494:	0626d801 	strteq	sp, [r6], -r1, lsl #16
    8498:	13160000 	tstne	r6, #0
    849c:	57000001 	strpl	r0, [r0, -r1]
    84a0:	16000081 	strne	r0, [r0], -r1, lsl #1
    84a4:	0000010a 	andeq	r0, r0, sl, lsl #2
    84a8:	000081cd 	andeq	r8, r0, sp, asr #3
    84ac:	58682100 	stmdapl	r8!, {r8, sp}^
    84b0:	00e20000 	rsceq	r0, r2, r0
    84b4:	06900000 	ldreq	r0, [r0], r0
    84b8:	74130000 	ldrvc	r0, [r3], #-0
    84bc:	0100706d 	tsteq	r0, sp, rrx
    84c0:	0006faca 	andeq	pc, r6, sl, asr #21
    84c4:	50910200 	addspl	r0, r1, r0, lsl #4
    84c8:	01006314 	tsteq	r0, r4, lsl r3
    84cc:	000033cb 	andeq	r3, r0, fp, asr #7
    84d0:	00823b00 	addeq	r3, r2, r0, lsl #22
    84d4:	00fe1500 	rscseq	r1, lr, r0, lsl #10
    84d8:	58720000 	ldmdapl	r2!, {}^	; <UNPREDICTABLE>
    84dc:	0b580000 	bleq	16084e4 <_etext+0x1600fcc>
    84e0:	d0010000 	andle	r0, r1, r0
    84e4:	00000670 	andeq	r0, r0, r0, ror r6
    84e8:	00011322 	andeq	r1, r1, r2, lsr #6
    84ec:	010a1600 	tsteq	sl, r0, lsl #12
    84f0:	824e0000 	subhi	r0, lr, #0
    84f4:	20000000 	andcs	r0, r0, r0
    84f8:	00005938 	andeq	r5, r0, r8, lsr r9
    84fc:	0000075e 	andeq	r0, r0, lr, asr r7
    8500:	0951011f 	ldmdbeq	r1, {r0, r1, r2, r3, r4, r8}^
    8504:	44910091 	ldrmi	r0, [r1], #145	; 0x91
    8508:	30082206 	andcc	r2, r8, r6, lsl #4
    850c:	50011f1c 	andpl	r1, r1, ip, lsl pc
    8510:	7fac9104 	svcvc	0x00ac9104
    8514:	19000006 	stmdbne	r0, {r1, r2}
    8518:	0000594a 	andeq	r5, r0, sl, asr #18
    851c:	000000a2 	andeq	r0, r0, r2, lsr #1
    8520:	706d7413 	rsbvc	r7, sp, r3, lsl r4
    8524:	fadf0100 	blx	ff7c892c <BootRAM+0xe7390cd>
    8528:	02000006 	andeq	r0, r0, #6
    852c:	fe155091 	mrc2	0, 0, r5, cr5, cr1, {4}
    8530:	5a000000 	bpl	8538 <_etext+0x1020>
    8534:	88000059 	stmdahi	r0, {r0, r3, r4, r6}
    8538:	0100000b 	tsteq	r0, fp
    853c:	0006cde1 	andeq	ip, r6, r1, ror #27
    8540:	01131600 	tsteq	r3, r0, lsl #12
    8544:	82630000 	rsbhi	r0, r3, #0
    8548:	0a160000 	beq	588550 <_etext+0x581038>
    854c:	e0000001 	and	r0, r0, r1
    8550:	00000082 	andeq	r0, r0, r2, lsl #1
    8554:	0059ec20 	subseq	lr, r9, r0, lsr #24
    8558:	00075e00 	andeq	r5, r7, r0, lsl #28
    855c:	52011f00 	andpl	r1, r1, #0, 30
    8560:	7fa49104 	svcvc	0x00a49104
    8564:	51011f06 	tstpl	r1, r6, lsl #30
    8568:	1f509102 	svcne	0x00509102
    856c:	91045001 	tstls	r4, r1
    8570:	00067fac 	andeq	r7, r6, ip, lsr #31
    8574:	040e0000 	streq	r0, [lr], #-0
    8578:	000006f5 	strdeq	r0, [r0], -r5
    857c:	0000b210 	andeq	fp, r0, r0, lsl r2
    8580:	00810800 	addeq	r0, r1, r0, lsl #16
    8584:	070a0000 	streq	r0, [sl, -r0]
    8588:	a2090000 	andge	r0, r9, #0
    858c:	07000000 	streq	r0, [r0, -r0]
    8590:	008c0800 	addeq	r0, ip, r0, lsl #16
    8594:	071a0000 	ldreq	r0, [sl, -r0]
    8598:	a2090000 	andge	r0, r9, #0
    859c:	4f000000 	svcmi	0x00000000
    85a0:	1a5c1d00 	bne	170f9a8 <_etext+0x1708490>
    85a4:	10010000 	andne	r0, r1, r0
    85a8:	0000072b 	andeq	r0, r0, fp, lsr #14
    85ac:	72480305 	subvc	r0, r8, #335544320	; 0x14000000
    85b0:	0a100000 	beq	4085b8 <_etext+0x4010a0>
    85b4:	23000007 	movwcs	r0, #7
    85b8:	000016fe 	strdeq	r1, [r0], -lr
    85bc:	06f50901 	ldrbteq	r0, [r5], r1, lsl #18
    85c0:	03050000 	movweq	r0, #20480	; 0x5000
    85c4:	00007208 	andeq	r7, r0, r8, lsl #4
    85c8:	000fff24 	andeq	pc, pc, r4, lsr #30
    85cc:	0000a900 	andeq	sl, r0, r0, lsl #18
    85d0:	00075e00 	andeq	r5, r7, r0, lsl #28
    85d4:	00a92500 	adceq	r2, r9, r0, lsl #10
    85d8:	7a250000 	bvc	9485e0 <_etext+0x9410c8>
    85dc:	25000000 	strcs	r0, [r0, #-0]
    85e0:	000000a2 	andeq	r0, r0, r2, lsr #1
    85e4:	15d22400 	ldrbne	r2, [r2, #1024]	; 0x400
    85e8:	00a90000 	adceq	r0, r9, r0
    85ec:	077b0000 	ldrbeq	r0, [fp, -r0]!
    85f0:	a9250000 	stmdbge	r5!, {}	; <UNPREDICTABLE>
    85f4:	25000000 	strcs	r0, [r0, #-0]
    85f8:	0000077b 	andeq	r0, r0, fp, ror r7
    85fc:	0000a225 	andeq	sl, r0, r5, lsr #4
    8600:	040e0000 	streq	r0, [lr], #-0
    8604:	00000781 	andeq	r0, r0, r1, lsl #15
    8608:	08170026 	ldmdaeq	r7, {r1, r2, r5}
    860c:	00040000 	andeq	r0, r4, r0
    8610:	00001f3e 	andeq	r1, r0, lr, lsr pc
    8614:	06390104 	ldrteq	r0, [r9], -r4, lsl #2
    8618:	64010000 	strvs	r0, [r1], #-0
    861c:	9300001a 	movwls	r0, #26
    8620:	c8000008 	stmdagt	r0, {r3}
    8624:	0000000b 	andeq	r0, r0, fp
    8628:	b3000000 	movwlt	r0, #0
    862c:	02000030 	andeq	r0, r0, #48	; 0x30
    8630:	00000ac7 	andeq	r0, r0, r7, asr #21
    8634:	0030d402 	eorseq	sp, r0, r2, lsl #8
    8638:	04030000 	streq	r0, [r3], #-0
    863c:	00025707 	andeq	r5, r2, r7, lsl #14
    8640:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    8644:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    8648:	01030074 	tsteq	r3, r4, ror r0
    864c:	00081a06 	andeq	r1, r8, r6, lsl #20
    8650:	0b010200 	bleq	48e58 <_etext+0x41940>
    8654:	1c030000 	stcne	0, cr0, [r3], {-0}
    8658:	00000052 	andeq	r0, r0, r2, asr r0
    865c:	18080103 	stmdane	r8, {r0, r1, r8}
    8660:	03000008 	movweq	r0, #8
    8664:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
    8668:	02030000 	andeq	r0, r3, #0
    866c:	00094907 	andeq	r4, r9, r7, lsl #18
    8670:	05040300 	streq	r0, [r4, #-768]	; 0x300
    8674:	000004da 	ldrdeq	r0, [r0], -sl
    8678:	000ace02 	andeq	ip, sl, r2, lsl #28
    867c:	79380300 	ldmdbvc	r8!, {r8, r9}
    8680:	03000000 	movweq	r0, #0
    8684:	02520704 	subseq	r0, r2, #4, 14	; 0x100000
    8688:	08030000 	stmdaeq	r3, {}	; <UNPREDICTABLE>
    868c:	0004d505 	andeq	sp, r4, r5, lsl #10
    8690:	07080300 	streq	r0, [r8, -r0, lsl #6]
    8694:	0000024d 	andeq	r0, r0, sp, asr #4
    8698:	8b070403 	blhi	1c96ac <_etext+0x1c2194>
    869c:	06000007 	streq	r0, [r0], -r7
    86a0:	00005204 	andeq	r5, r0, r4, lsl #4
    86a4:	08010300 	stmdaeq	r1, {r8, r9}
    86a8:	00000821 	andeq	r0, r0, r1, lsr #16
    86ac:	000b0302 	andeq	r0, fp, r2, lsl #6
    86b0:	472a0400 	strmi	r0, [sl, -r0, lsl #8]!
    86b4:	02000000 	andeq	r0, r0, #0
    86b8:	00000ad0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    86bc:	006e4204 	rsbeq	r4, lr, r4, lsl #4
    86c0:	75070000 	strvc	r0, [r7, #-0]
    86c4:	05003233 	streq	r3, [r0, #-563]	; 0x233
    86c8:	00007927 	andeq	r7, r0, r7, lsr #18
    86cc:	035a0200 	cmpeq	sl, #0, 4
    86d0:	2f050000 	svccs	0x00050000
    86d4:	000000ce 	andeq	r0, r0, lr, asr #1
    86d8:	00007908 	andeq	r7, r0, r8, lsl #18
    86dc:	05010900 	streq	r0, [r1, #-2304]	; 0x900
    86e0:	0000e837 	andeq	lr, r0, r7, lsr r8
    86e4:	07530a00 	ldrbeq	r0, [r3, -r0, lsl #20]
    86e8:	0a000000 	beq	86f0 <_etext+0x11d8>
    86ec:	000001a7 	andeq	r0, r0, r7, lsr #3
    86f0:	2d020001 	stccs	0, cr0, [r2, #-4]
    86f4:	05000005 	streq	r0, [r0, #-5]
    86f8:	0000d337 	andeq	sp, r0, r7, lsr r3
    86fc:	06680b00 	strbteq	r0, [r8], -r0, lsl #22
    8700:	0001200c 	andeq	r2, r1, ip
    8704:	19170c00 	ldmdbne	r7, {sl, fp}
    8708:	0e060000 	cdpeq	0, 0, cr0, cr6, cr0, {0}
    870c:	00000120 	andeq	r0, r0, r0, lsr #2
    8710:	17c70c00 	strbne	r0, [r7, r0, lsl #24]
    8714:	0f060000 	svceq	0x00060000
    8718:	00000130 	andeq	r0, r0, r0, lsr r1
    871c:	046c0c08 	strbteq	r0, [ip], #-3080	; 0xc08
    8720:	10060000 	andne	r0, r6, r0
    8724:	00000140 	andeq	r0, r0, r0, asr #2
    8728:	790d0028 	stmdbvc	sp, {r3, r5}
    872c:	30000000 	andcc	r0, r0, r0
    8730:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    8734:	0000008e 	andeq	r0, r0, lr, lsl #1
    8738:	790d0001 	stmdbvc	sp, {r0}
    873c:	40000000 	andmi	r0, r0, r0
    8740:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    8744:	0000008e 	andeq	r0, r0, lr, lsl #1
    8748:	520d0007 	andpl	r0, sp, #7
    874c:	50000000 	andpl	r0, r0, r0
    8750:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    8754:	0000008e 	andeq	r0, r0, lr, lsl #1
    8758:	a502003f 	strge	r0, [r2, #-63]	; 0x3f
    875c:	06000013 			; <UNDEFINED> instruction: 0x06000013
    8760:	0000f312 	andeq	pc, r0, r2, lsl r3	; <UNPREDICTABLE>
    8764:	0aab0f00 	beq	feacc36c <BootRAM+0xda3cb0d>
    8768:	07140000 	ldreq	r0, [r4, -r0]
    876c:	0001b00d 	andeq	fp, r1, sp
    8770:	0b0b0c00 	bleq	2cb778 <_etext+0x2c4260>
    8774:	0e070000 	cdpeq	0, 0, cr0, cr7, cr0, {0}
    8778:	000000ad 	andeq	r0, r0, sp, lsr #1
    877c:	0bc20c00 	bleq	ff08b784 <BootRAM+0xdffbf25>
    8780:	10070000 	andne	r0, r7, r0
    8784:	000000ad 	andeq	r0, r0, sp, lsr #1
    8788:	0b730c04 	bleq	1ccb7a0 <_etext+0x1cc4288>
    878c:	11070000 	mrsne	r0, (UNDEF: 7)
    8790:	000000ad 	andeq	r0, r0, sp, lsr #1
    8794:	0c070c08 	stceq	12, cr0, [r7], {8}
    8798:	13070000 	movwne	r0, #28672	; 0x7000
    879c:	000000ad 	andeq	r0, r0, sp, lsr #1
    87a0:	0b950c0c 	bleq	fe54b7d8 <BootRAM+0xd4bbf79>
    87a4:	14070000 	strne	r0, [r7], #-0
    87a8:	000000ad 	andeq	r0, r0, sp, lsr #1
    87ac:	0af00c10 	beq	ffc0b7f4 <BootRAM+0xeb7bf95>
    87b0:	15070000 	strne	r0, [r7, #-0]
    87b4:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
    87b8:	a20d0014 	andge	r0, sp, #20
    87bc:	bf000000 	svclt	0x00000000
    87c0:	10000001 	andne	r0, r0, r1
    87c4:	0000008e 	andeq	r0, r0, lr, lsl #1
    87c8:	0aac0200 	beq	feb08fd0 <BootRAM+0xda79771>
    87cc:	16070000 	strne	r0, [r7], -r0
    87d0:	0000015b 	andeq	r0, r0, fp, asr r1
    87d4:	000b130f 	andeq	r1, fp, pc, lsl #6
    87d8:	18071400 	stmdane	r7, {sl, ip}
    87dc:	00000213 	andeq	r0, r0, r3, lsl r2
    87e0:	000bd80c 	andeq	sp, fp, ip, lsl #16
    87e4:	13190700 	tstne	r9, #0, 14
    87e8:	00000002 	andeq	r0, r0, r2
    87ec:	000b5b0c 	andeq	r5, fp, ip, lsl #22
    87f0:	ad1a0700 	ldcge	7, cr0, [sl, #-0]
    87f4:	04000000 	streq	r0, [r0], #-0
    87f8:	000b8b0c 	andeq	r8, fp, ip, lsl #22
    87fc:	251f0700 	ldrcs	r0, [pc, #-1792]	; 8104 <_etext+0xbec>
    8800:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8804:	000b270c 	andeq	r2, fp, ip, lsl #14
    8808:	39210700 	stmdbcc	r1!, {r8, r9, sl}
    880c:	0c000000 	stceq	0, cr0, [r0], {-0}
    8810:	000c160c 	andeq	r1, ip, ip, lsl #12
    8814:	39220700 	stmdbcc	r2!, {r8, r9, sl}
    8818:	10000000 	andne	r0, r0, r0
    881c:	bf040600 	svclt	0x00040600
    8820:	02000001 	andeq	r0, r0, #1
    8824:	00000b14 	andeq	r0, r0, r4, lsl fp
    8828:	01ca2307 	biceq	r2, sl, r7, lsl #6
    882c:	39020000 	stmdbcc	r2, {}	; <UNPREDICTABLE>
    8830:	0700000c 	streq	r0, [r0, -ip]
    8834:	00022f26 	andeq	r2, r2, r6, lsr #30
    8838:	ca040600 	bgt	10a040 <_etext+0x102b28>
    883c:	0f000001 	svceq	0x00000001
    8840:	00001b47 	andeq	r1, r0, r7, asr #22
    8844:	72370710 	eorsvc	r0, r7, #16, 14	; 0x400000
    8848:	0c000002 	stceq	0, cr0, [r0], {2}
    884c:	00001a94 	muleq	r0, r4, sl
    8850:	00ad3807 	adceq	r3, sp, r7, lsl #16
    8854:	0c000000 	stceq	0, cr0, [r0], {-0}
    8858:	00001a18 	andeq	r1, r0, r8, lsl sl
    885c:	00ad3907 	adceq	r3, sp, r7, lsl #18
    8860:	0c040000 	stceq	0, cr0, [r4], {-0}
    8864:	00001aa1 	andeq	r1, r0, r1, lsr #21
    8868:	00ad3a07 	adceq	r3, sp, r7, lsl #20
    886c:	0c080000 	stceq	0, cr0, [r8], {-0}
    8870:	00001ab3 			; <UNDEFINED> instruction: 0x00001ab3
    8874:	00ad3b07 	adceq	r3, sp, r7, lsl #22
    8878:	000c0000 	andeq	r0, ip, r0
    887c:	001b4702 	andseq	r4, fp, r2, lsl #14
    8880:	353c0700 	ldrcc	r0, [ip, #-1792]!	; 0x700
    8884:	0f000002 	svceq	0x00000002
    8888:	00001ad9 	ldrdeq	r1, [r0], -r9
    888c:	a23e0744 	eorsge	r0, lr, #68, 14	; 0x1100000
    8890:	0c000002 	stceq	0, cr0, [r0], {2}
    8894:	00001ab3 			; <UNDEFINED> instruction: 0x00001ab3
    8898:	00ad3f07 	adceq	r3, sp, r7, lsl #30
    889c:	0c000000 	stceq	0, cr0, [r0], {-0}
    88a0:	00001b2e 	andeq	r1, r0, lr, lsr #22
    88a4:	02a24007 	adceq	r4, r2, #7
    88a8:	00040000 	andeq	r0, r4, r0
    88ac:	0000a20d 	andeq	sl, r0, sp, lsl #4
    88b0:	0002b200 	andeq	fp, r2, r0, lsl #4
    88b4:	008e0e00 	addeq	r0, lr, r0, lsl #28
    88b8:	003f0000 	eorseq	r0, pc, r0
    88bc:	001ad902 	andseq	sp, sl, r2, lsl #18
    88c0:	7d410700 	stclvc	7, cr0, [r1, #-0]
    88c4:	0f000002 	svceq	0x00000002
    88c8:	00001a84 	andeq	r1, r0, r4, lsl #21
    88cc:	e2440754 	sub	r0, r4, #84, 14	; 0x1500000
    88d0:	0c000002 	stceq	0, cr0, [r0], {2}
    88d4:	00001a6c 	andeq	r1, r0, ip, ror #20
    88d8:	02724507 	rsbseq	r4, r2, #29360128	; 0x1c00000
    88dc:	0c000000 	stceq	0, cr0, [r0], {-0}
    88e0:	00001aca 	andeq	r1, r0, sl, asr #21
    88e4:	02b24607 	adcseq	r4, r2, #7340032	; 0x700000
    88e8:	00100000 	andseq	r0, r0, r0
    88ec:	001a8402 	andseq	r8, sl, r2, lsl #8
    88f0:	bd470700 	stcllt	7, cr0, [r7, #-0]
    88f4:	06000002 	streq	r0, [r0], -r2
    88f8:	0002e204 	andeq	lr, r2, r4, lsl #4
    88fc:	1b3d1100 	blne	f4cd04 <_etext+0xf457ec>
    8900:	26010000 	strcs	r0, [r1], -r0
    8904:	000059f4 	strdeq	r5, [r0], -r4
    8908:	00000044 	andeq	r0, r0, r4, asr #32
    890c:	038f9c01 	orreq	r9, pc, #256	; 0x100
    8910:	fc120000 	ldc2	0, cr0, [r2], {-0}
    8914:	d9000059 	stmdble	r0, {r0, r3, r4, r6}
    8918:	1f000006 	svcne	0x00000006
    891c:	13000003 	movwne	r0, #3
    8920:	0c055001 	stceq	0, cr5, [r5], {1}
    8924:	08008000 	stmdaeq	r0, {pc}
    8928:	5a021200 	bpl	8d130 <_etext+0x85c18>
    892c:	06d90000 	ldrbeq	r0, [r9], r0
    8930:	03360000 	teqeq	r6, #0
    8934:	01130000 	tsteq	r3, r0
    8938:	000c0550 	andeq	r0, ip, r0, asr r5
    893c:	00080084 	andeq	r0, r8, r4, lsl #1
    8940:	005a0812 	subseq	r0, sl, r2, lsl r8
    8944:	0006d900 	andeq	sp, r6, r0, lsl #18
    8948:	00034d00 	andeq	r4, r3, r0, lsl #26
    894c:	50011300 	andpl	r1, r1, r0, lsl #6
    8950:	83200c05 	teqhi	r0, #1280	; 0x500
    8954:	12000800 	andne	r0, r0, #0, 16
    8958:	00005a0e 	andeq	r5, r0, lr, lsl #20
    895c:	000006d9 	ldrdeq	r0, [r0], -r9
    8960:	00000364 	andeq	r0, r0, r4, ror #6
    8964:	05500113 	ldrbeq	r0, [r0, #-275]	; 0x113
    8968:	0084b00c 	addeq	fp, r4, ip
    896c:	14120008 	ldrne	r0, [r2], #-8
    8970:	d900005a 	stmdble	r0, {r1, r3, r4, r6}
    8974:	7b000006 	blvc	8994 <_etext+0x147c>
    8978:	13000003 	movwne	r0, #3
    897c:	0c055001 	stceq	0, cr5, [r5], {1}
    8980:	08008640 	stmdaeq	r0, {r6, r9, sl, pc}
    8984:	5a1e1400 	bpl	78d98c <_etext+0x786474>
    8988:	06d90000 	ldrbeq	r0, [r9], r0
    898c:	01130000 	tsteq	r3, r0
    8990:	d00c0550 	andle	r0, ip, r0, asr r5
    8994:	00080087 	andeq	r0, r8, r7, lsl #1
    8998:	0b2e1500 	bleq	b8dda0 <_etext+0xb86888>
    899c:	30010000 	andcc	r0, r1, r0
    89a0:	00000039 	andeq	r0, r0, r9, lsr r0
    89a4:	00005a38 	andeq	r5, r0, r8, lsr sl
    89a8:	00000184 	andeq	r0, r0, r4, lsl #3
    89ac:	06479c01 	strbeq	r9, [r7], -r1, lsl #24
    89b0:	7a160000 	bvc	5889b8 <_etext+0x5814a0>
    89b4:	0100001a 	tsteq	r0, sl, lsl r0
    89b8:	00064730 	andeq	r4, r6, r0, lsr r7
    89bc:	00834300 	addeq	r4, r3, r0, lsl #6
    89c0:	1abd1600 	bne	fef4e1c8 <BootRAM+0xdebe969>
    89c4:	30010000 	andcc	r0, r1, r0
    89c8:	000000c3 	andeq	r0, r0, r3, asr #1
    89cc:	0000836f 	andeq	r8, r0, pc, ror #6
    89d0:	001afb16 	andseq	pc, sl, r6, lsl fp	; <UNPREDICTABLE>
    89d4:	e8300100 	ldmda	r0!, {r8}
    89d8:	9c000000 	stcls	0, cr0, [r0], {-0}
    89dc:	17000083 	strne	r0, [r0, -r3, lsl #1]
    89e0:	00726468 	rsbseq	r6, r2, r8, ror #8
    89e4:	02ed3201 	rsceq	r3, sp, #268435456	; 0x10000000
    89e8:	83bd0000 			; <UNDEFINED> instruction: 0x83bd0000
    89ec:	c7180000 	ldrgt	r0, [r8, -r0]
    89f0:	01000017 	tsteq	r0, r7, lsl r0
    89f4:	00021933 	andeq	r1, r2, r3, lsr r9
    89f8:	8c910300 	ldchi	3, cr0, [r1], {0}
    89fc:	1b1a197d 	blne	68eff8 <_etext+0x687ae0>
    8a00:	34010000 	strcc	r0, [r1], #-0
    8a04:	00000039 	andeq	r0, r0, r9, lsr r0
    8a08:	1aef1a68 	bne	ffbcf3b0 <BootRAM+0xeb3fb51>
    8a0c:	35010000 	strcc	r0, [r1, #-0]
    8a10:	0000064d 	andeq	r0, r0, sp, asr #12
    8a14:	000083e1 	andeq	r8, r0, r1, ror #7
    8a18:	00128018 	andseq	r8, r2, r8, lsl r0
    8a1c:	5f610100 	svcpl	0x00610100
    8a20:	03000006 	movweq	r0, #6
    8a24:	1b7db891 	blne	1f76c70 <_etext+0x1f6f758>
    8a28:	00787463 	rsbseq	r7, r8, r3, ror #8
    8a2c:	01506501 	cmpeq	r0, r1, lsl #10
    8a30:	91030000 	mrsls	r0, (UNDEF: 3)
    8a34:	aa1a7e98 	bge	6a849c <_etext+0x6a0f84>
    8a38:	0100001a 	tsteq	r0, sl, lsl r0
    8a3c:	00003968 	andeq	r3, r0, r8, ror #18
    8a40:	00843500 	addeq	r3, r4, r0, lsl #10
    8a44:	06821c00 	streq	r1, [r2], r0, lsl #24
    8a48:	84490000 	strbhi	r0, [r9], #-0
    8a4c:	151a0000 	ldrne	r0, [sl, #-0]
    8a50:	0100001b 	tsteq	r0, fp, lsl r0
    8a54:	00066f69 	andeq	r6, r6, r9, ror #30
    8a58:	00845d00 	addeq	r5, r4, r0, lsl #26
    8a5c:	00691700 	rsbeq	r1, r9, r0, lsl #14
    8a60:	00396b01 	eorseq	r6, r9, r1, lsl #22
    8a64:	848b0000 	strhi	r0, [fp], #0
    8a68:	9a180000 	bls	608a70 <_etext+0x601558>
    8a6c:	0100001a 	tsteq	r0, sl, lsl r0
    8a70:	0006876c 	andeq	r8, r6, ip, ror #14
    8a74:	84910300 	ldrhi	r0, [r1], #768	; 0x300
    8a78:	1b25187d 	blne	94ec74 <_etext+0x94775c>
    8a7c:	7e010000 	cdpvc	0, 0, cr0, cr1, cr0, {0}
    8a80:	00000697 	muleq	r0, r7, r6
    8a84:	7da09103 	stfvcd	f1, [r0, #12]!
    8a88:	000c2e1d 	andeq	r2, ip, sp, lsl lr
    8a8c:	398e0100 	stmibcc	lr, {r8}
    8a90:	8f000000 	svchi	0x00000000
    8a94:	1e000004 	cdpne	0, 0, cr0, cr0, cr4, {0}
    8a98:	1b121800 	blne	48eaa0 <_etext+0x487588>
    8a9c:	90010000 	andls	r0, r1, r0
    8aa0:	000002a2 	andeq	r0, r0, r2, lsr #5
    8aa4:	7dd89103 	ldfvcp	f1, [r8, #12]
    8aa8:	005a4e12 	subseq	r4, sl, r2, lsl lr
    8aac:	0006ef00 	andeq	lr, r6, r0, lsl #30
    8ab0:	0004bf00 	andeq	fp, r4, r0, lsl #30
    8ab4:	52011300 	andpl	r1, r1, #0, 6
    8ab8:	13680802 	cmnne	r8, #131072	; 0x20000
    8abc:	08025101 	stmdaeq	r2, {r0, r8, ip, lr}
    8ac0:	500113ff 	strdpl	r1, [r1], -pc	; <UNPREDICTABLE>
    8ac4:	7f809103 	svcvc	0x00809103
    8ac8:	5a5a1200 	bpl	168d2d0 <_etext+0x1685db8>
    8acc:	070e0000 	streq	r0, [lr, -r0]
    8ad0:	04da0000 	ldrbeq	r0, [sl], #0
    8ad4:	01130000 	tsteq	r3, r0
    8ad8:	68080252 	stmdavs	r8, {r1, r4, r6, r9}
    8adc:	03500113 	cmpeq	r0, #-1073741820	; 0xc0000004
    8ae0:	007f8091 			; <UNDEFINED> instruction: 0x007f8091
    8ae4:	005a5e1f 	subseq	r5, sl, pc, lsl lr
    8ae8:	00073200 	andeq	r3, r7, r0, lsl #4
    8aec:	5a681200 	bpl	1a0d2f4 <_etext+0x1a05ddc>
    8af0:	073a0000 	ldreq	r0, [sl, -r0]!
    8af4:	05010000 	streq	r0, [r1, #-0]
    8af8:	01130000 	tsteq	r3, r0
    8afc:	13440152 	movtne	r0, #16722	; 0x4152
    8b00:	30015101 	andcc	r5, r1, r1, lsl #2
    8b04:	02500113 	subseq	r0, r0, #-1073741820	; 0xc0000004
    8b08:	1f000076 	svcne	0x00000076
    8b0c:	00005a86 	andeq	r5, r0, r6, lsl #21
    8b10:	000002f3 	strdeq	r0, [r0], -r3
    8b14:	005aa812 	subseq	sl, sl, r2, lsl r8
    8b18:	0006ef00 	andeq	lr, r6, r0, lsl #30
    8b1c:	00052b00 	andeq	r2, r5, r0, lsl #22
    8b20:	52011300 	andpl	r1, r1, #0, 6
    8b24:	13200802 	teqne	r0, #131072	; 0x20000
    8b28:	08025101 	stmdaeq	r2, {r0, r8, ip, lr}
    8b2c:	500113ff 	strdpl	r1, [r1], -pc	; <UNPREDICTABLE>
    8b30:	7db89103 	ldfvcd	f1, [r8, #12]!
    8b34:	5aae1200 	bpl	feb8d33c <BootRAM+0xdafdadd>
    8b38:	07570000 	ldrbeq	r0, [r7, -r0]
    8b3c:	05400000 	strbeq	r0, [r0, #-0]
    8b40:	01130000 	tsteq	r3, r0
    8b44:	98910350 	ldmls	r1, {r4, r6, r8, r9}
    8b48:	ca12007e 	bgt	488d48 <_etext+0x481830>
    8b4c:	6e00005a 	mcrvs	0, 0, r0, cr0, cr10, {2}
    8b50:	54000007 	strpl	r0, [r0], #-7
    8b54:	13000005 	movwne	r0, #5
    8b58:	08025101 	stmdaeq	r2, {r0, r8, ip, lr}
    8b5c:	f2120020 	vhadd.s16	d0, d2, d16
    8b60:	8500005a 	strhi	r0, [r0, #-90]	; 0x5a
    8b64:	7a000007 	bvc	8b88 <_etext+0x1670>
    8b68:	13000005 	movwne	r0, #5
    8b6c:	34015301 	strcc	r5, [r1], #-769	; 0x301
    8b70:	03520113 	cmpeq	r2, #-1073741820	; 0xc0000004
    8b74:	137d8491 	cmnne	sp, #-1862270976	; 0x91000000
    8b78:	34015101 	strcc	r5, [r1], #-257	; 0x101
    8b7c:	03500113 	cmpeq	r0, #-1073741820	; 0xc0000004
    8b80:	007d8891 			; <UNDEFINED> instruction: 0x007d8891
    8b84:	005b1012 	subseq	r1, fp, r2, lsl r0
    8b88:	0007a900 	andeq	sl, r7, r0, lsl #18
    8b8c:	00059400 	andeq	r9, r5, r0, lsl #8
    8b90:	52011300 	andpl	r1, r1, #0, 6
    8b94:	01133401 	tsteq	r3, r1, lsl #8
    8b98:	98910350 	ldmls	r1, {r4, r6, r8, r9}
    8b9c:	1a12007e 	bne	488d9c <_etext+0x481884>
    8ba0:	6e00005b 	mcrvs	0, 0, r0, cr0, cr11, {2}
    8ba4:	a7000007 	strge	r0, [r0, -r7]
    8ba8:	13000005 	movwne	r0, #5
    8bac:	3c015101 	stfccs	f5, [r1], {1}
    8bb0:	5b281200 	blpl	a0d3b8 <_etext+0xa05ea0>
    8bb4:	07a90000 	streq	r0, [r9, r0]!
    8bb8:	05c10000 	strbeq	r0, [r1]
    8bbc:	01130000 	tsteq	r3, r0
    8bc0:	13340152 	teqne	r4, #-2147483628	; 0x80000014
    8bc4:	91035001 	tstls	r3, r1
    8bc8:	12007e98 	andne	r7, r0, #152, 28	; 0x980
    8bcc:	00005b5a 	andeq	r5, r0, sl, asr fp
    8bd0:	000007a9 	andeq	r0, r0, r9, lsr #15
    8bd4:	000005e2 	andeq	r0, r0, r2, ror #11
    8bd8:	01520113 	cmpeq	r2, r3, lsl r1
    8bdc:	51011347 	tstpl	r1, r7, asr #6
    8be0:	7da09103 	stfvcd	f1, [r0, #12]!
    8be4:	03500113 	cmpeq	r0, #-1073741820	; 0xc0000004
    8be8:	007e9891 			; <UNDEFINED> instruction: 0x007e9891
    8bec:	005b6212 	subseq	r6, fp, r2, lsl r2
    8bf0:	0007c400 	andeq	ip, r7, r0, lsl #8
    8bf4:	0005fe00 	andeq	pc, r5, r0, lsl #28
    8bf8:	51011300 	mrspl	r1, SP_irq
    8bfc:	7db89103 	ldfvcd	f1, [r8, #12]!
    8c00:	03500113 	cmpeq	r0, #-1073741820	; 0xc0000004
    8c04:	007e9891 			; <UNDEFINED> instruction: 0x007e9891
    8c08:	005b6c12 	subseq	r6, fp, r2, lsl ip
    8c0c:	0007da00 	andeq	sp, r7, r0, lsl #20
    8c10:	00061300 	andeq	r1, r6, r0, lsl #6
    8c14:	50011300 	andpl	r1, r1, r0, lsl #6
    8c18:	7db89103 	ldfvcd	f1, [r8, #12]!
    8c1c:	5b8c1200 	blpl	fe30d424 <BootRAM+0xd27dbc5>
    8c20:	07eb0000 	strbeq	r0, [fp, r0]!
    8c24:	063d0000 	ldrteq	r0, [sp], -r0
    8c28:	01130000 	tsteq	r3, r0
    8c2c:	20080253 	andcs	r0, r8, r3, asr r2
    8c30:	03520113 	cmpeq	r2, #-1073741820	; 0xc0000004
    8c34:	137db891 	cmnne	sp, #9502720	; 0x910000
    8c38:	03055101 	movweq	r5, #20737	; 0x5101
    8c3c:	20000404 	andcs	r0, r0, r4, lsl #8
    8c40:	02500113 	subseq	r0, r0, #-1073741820	; 0xc0000004
    8c44:	1f005074 	svcne	0x00005074
    8c48:	00005b9c 	muleq	r0, ip, fp
    8c4c:	000002f3 	strdeq	r0, [r0], -r3
    8c50:	24040600 	strcs	r0, [r4], #-1536	; 0x600
    8c54:	0d000002 	stceq	0, cr0, [r0, #-8]
    8c58:	00000052 	andeq	r0, r0, r2, asr r0
    8c5c:	0000065f 	andeq	r0, r0, pc, asr r6
    8c60:	00008e20 	andeq	r8, r0, r0, lsr #28
    8c64:	67080200 	strvs	r0, [r8, -r0, lsl #4]
    8c68:	00520d00 	subseq	r0, r2, r0, lsl #26
    8c6c:	066f0000 	strbteq	r0, [pc], -r0
    8c70:	8e0e0000 	cdphi	0, 0, cr0, cr14, cr0, {0}
    8c74:	1f000000 	svcne	0x00000000
    8c78:	009b0d00 	addseq	r0, fp, r0, lsl #26
    8c7c:	06820000 	streq	r0, [r2], r0
    8c80:	8e210000 	cdphi	0, 2, cr0, cr1, cr0, {0}
    8c84:	3b000000 	blcc	8c8c <_etext+0x1774>
    8c88:	00000004 	andeq	r0, r0, r4
    8c8c:	00008e22 	andeq	r8, r0, r2, lsr #28
    8c90:	009b0d00 	addseq	r0, fp, r0, lsl #26
    8c94:	06970000 	ldreq	r0, [r7], r0
    8c98:	8e0e0000 	cdphi	0, 0, cr0, cr14, cr0, {0}
    8c9c:	03000000 	movweq	r0, #0
    8ca0:	00520d00 	subseq	r0, r2, r0, lsl #26
    8ca4:	06a70000 	strteq	r0, [r7], r0
    8ca8:	8e0e0000 	cdphi	0, 0, cr0, cr14, cr0, {0}
    8cac:	16000000 	strne	r0, [r0], -r0
    8cb0:	00b12300 	adcseq	r2, r1, r0, lsl #6
    8cb4:	2c080000 	stccs	0, cr0, [r8], {-0}
    8cb8:	00000039 	andeq	r0, r0, r9, lsr r0
    8cbc:	04880305 	streq	r0, [r8], #773	; 0x305
    8cc0:	a20d2000 	andge	r2, sp, #0
    8cc4:	c8000000 	stmdagt	r0, {}	; <UNPREDICTABLE>
    8cc8:	0e000006 	cdpeq	0, 0, cr0, cr0, cr6, {0}
    8ccc:	0000008e 	andeq	r0, r0, lr, lsl #1
    8cd0:	d223001f 	eorle	r0, r3, #31
    8cd4:	0100001a 	tsteq	r0, sl, lsl r0
    8cd8:	0006b818 	andeq	fp, r6, r8, lsl r8
    8cdc:	04030500 	streq	r0, [r3], #-1280	; 0x500
    8ce0:	24200004 	strtcs	r0, [r0], #-4
    8ce4:	00000c4b 	andeq	r0, r0, fp, asr #24
    8ce8:	e8013509 	stmda	r1, {r0, r3, r8, sl, ip, sp}
    8cec:	ef000000 	svc	0x00000000
    8cf0:	25000006 	strcs	r0, [r0, #-6]
    8cf4:	000000b8 	strheq	r0, [r0], -r8
    8cf8:	0fff2600 	svceq	0x00ff2600
    8cfc:	190a0000 	stmdbne	sl, {}	; <UNPREDICTABLE>
    8d00:	00000037 	andeq	r0, r0, r7, lsr r0
    8d04:	0000070e 	andeq	r0, r0, lr, lsl #14
    8d08:	00003725 	andeq	r3, r0, r5, lsr #14
    8d0c:	00392500 	eorseq	r2, r9, r0, lsl #10
    8d10:	25250000 	strcs	r0, [r5, #-0]!
    8d14:	00000000 	andeq	r0, r0, r0
    8d18:	0015d227 	andseq	sp, r5, r7, lsr #4
    8d1c:	00003700 	andeq	r3, r0, r0, lsl #14
    8d20:	00072b00 	andeq	r2, r7, r0, lsl #22
    8d24:	00372500 	eorseq	r2, r7, r0, lsl #10
    8d28:	2b250000 	blcs	948d30 <_etext+0x941818>
    8d2c:	25000007 	strcs	r0, [r0, #-7]
    8d30:	0000008e 	andeq	r0, r0, lr, lsl #1
    8d34:	31040600 	tstcc	r4, r0, lsl #12
    8d38:	28000007 	stmdacs	r0, {r0, r1, r2}
    8d3c:	000e7f29 	andeq	r7, lr, r9, lsr #30
    8d40:	01380900 	teqeq	r8, r0, lsl #18
    8d44:	000fff27 	andeq	pc, pc, r7, lsr #30
    8d48:	00003700 	andeq	r3, r0, r0, lsl #14
    8d4c:	00075700 	andeq	r5, r7, r0, lsl #14
    8d50:	00372500 	eorseq	r2, r7, r0, lsl #10
    8d54:	39250000 	stmdbcc	r5!, {}	; <UNPREDICTABLE>
    8d58:	25000000 	strcs	r0, [r0, #-0]
    8d5c:	0000008e 	andeq	r0, r0, lr, lsl #1
    8d60:	13352a00 	teqne	r5, #0, 20
    8d64:	14060000 	strne	r0, [r6], #-0
    8d68:	00000768 	andeq	r0, r0, r8, ror #14
    8d6c:	00076825 	andeq	r6, r7, r5, lsr #16
    8d70:	04060000 	streq	r0, [r6], #-0
    8d74:	00000150 	andeq	r0, r0, r0, asr r1
    8d78:	000d2c2b 	andeq	r2, sp, fp, lsr #24
    8d7c:	01410900 	cmpeq	r1, r0, lsl #18
    8d80:	00000785 	andeq	r0, r0, r5, lsl #15
    8d84:	00009525 	andeq	r9, r0, r5, lsr #10
    8d88:	00252500 	eoreq	r2, r5, r0, lsl #10
    8d8c:	26000000 	strcs	r0, [r0], -r0
    8d90:	00001a73 	andeq	r1, r0, r3, ror sl
    8d94:	00373a0a 	eorseq	r3, r7, sl, lsl #20
    8d98:	07a90000 	streq	r0, [r9, r0]!
    8d9c:	2b250000 	blcs	948da4 <_etext+0x94188c>
    8da0:	25000007 	strcs	r0, [r0, #-7]
    8da4:	00000025 	andeq	r0, r0, r5, lsr #32
    8da8:	00072b25 	andeq	r2, r7, r5, lsr #22
    8dac:	00252500 	eoreq	r2, r5, r0, lsl #10
    8db0:	2a000000 	bcs	8db8 <_etext+0x18a0>
    8db4:	000019dd 	ldrdeq	r1, [r0], -sp
    8db8:	07c41506 	strbeq	r1, [r4, r6, lsl #10]
    8dbc:	68250000 	stmdavs	r5!, {}	; <UNPREDICTABLE>
    8dc0:	25000007 	strcs	r0, [r0, #-7]
    8dc4:	00000095 	muleq	r0, r5, r0
    8dc8:	00007925 	andeq	r7, r0, r5, lsr #18
    8dcc:	a72a0000 	strge	r0, [sl, -r0]!
    8dd0:	06000019 			; <UNDEFINED> instruction: 0x06000019
    8dd4:	0007da16 	andeq	sp, r7, r6, lsl sl
    8dd8:	07682500 	strbeq	r2, [r8, -r0, lsl #10]!
    8ddc:	95250000 	strls	r0, [r5, #-0]!
    8de0:	00000000 	andeq	r0, r0, r0
    8de4:	000c2e1d 	andeq	r2, ip, sp, lsl lr
    8de8:	398e0100 	stmibcc	lr, {r8}
    8dec:	eb000000 	bl	8df4 <_etext+0x18dc>
    8df0:	1e000007 	cdpne	0, 0, cr0, cr0, cr7, {0}
    8df4:	17cd2600 	strbne	r2, [sp, r0, lsl #12]
    8df8:	2f0b0000 	svccs	0x000b0000
    8dfc:	000000a2 	andeq	r0, r0, r2, lsr #1
    8e00:	0000080f 	andeq	r0, r0, pc, lsl #16
    8e04:	00080f25 	andeq	r0, r8, r5, lsr #30
    8e08:	080f2500 	stmdaeq	pc, {r8, sl, sp}	; <UNPREDICTABLE>
    8e0c:	0f250000 	svceq	0x00250000
    8e10:	25000008 	strcs	r0, [r0, #-8]
    8e14:	00000025 	andeq	r0, r0, r5, lsr #32
    8e18:	15040600 	strne	r0, [r4, #-1536]	; 0x600
    8e1c:	22000008 	andcs	r0, r0, #8
    8e20:	000000a2 	andeq	r0, r0, r2, lsr #1
    8e24:	000c8800 	andeq	r8, ip, r0, lsl #16
    8e28:	80000400 	andhi	r0, r0, r0, lsl #8
    8e2c:	04000021 	streq	r0, [r0], #-33	; 0x21
    8e30:	00063901 	andeq	r3, r6, r1, lsl #18
    8e34:	1cc80100 	stfnee	f0, [r8], {0}
    8e38:	08930000 	ldmeq	r3, {}	; <UNPREDICTABLE>
    8e3c:	0c900000 	ldceq	0, cr0, [r0], {0}
    8e40:	00000000 	andeq	r0, r0, r0
    8e44:	32ed0000 	rsccc	r0, sp, #0
    8e48:	04020000 	streq	r0, [r2], #-0
    8e4c:	0004da05 	andeq	sp, r4, r5, lsl #20
    8e50:	05020200 	streq	r0, [r2, #-512]	; 0x200
    8e54:	000006fc 	strdeq	r0, [r0], -ip
    8e58:	1a060102 	bne	189268 <_etext+0x181d50>
    8e5c:	03000008 	movweq	r0, #8
    8e60:	00323375 	eorseq	r3, r2, r5, ror r3
    8e64:	00452402 	subeq	r2, r5, r2, lsl #8
    8e68:	04020000 	streq	r0, [r2], #-0
    8e6c:	00025207 	andeq	r5, r2, r7, lsl #4
    8e70:	31750300 	cmncc	r5, r0, lsl #6
    8e74:	25020036 	strcs	r0, [r2, #-54]	; 0x36
    8e78:	00000057 	andeq	r0, r0, r7, asr r0
    8e7c:	49070202 	stmdbmi	r7, {r1, r9}
    8e80:	03000009 	movweq	r0, #9
    8e84:	02003875 	andeq	r3, r0, #7667712	; 0x750000
    8e88:	00006826 	andeq	r6, r0, r6, lsr #16
    8e8c:	08010200 	stmdaeq	r1, {r9}
    8e90:	00000818 	andeq	r0, r0, r8, lsl r8
    8e94:	001bdb04 	andseq	sp, fp, r4, lsl #22
    8e98:	16030100 	strne	r0, [r3], -r0, lsl #2
    8e9c:	0000008e 	andeq	r0, r0, lr, lsl #1
    8ea0:	001cdb05 	andseq	sp, ip, r5, lsl #22
    8ea4:	a6050000 	strge	r0, [r5], -r0
    8ea8:	0100001b 	tsteq	r0, fp, lsl r0
    8eac:	001c8205 	andseq	r8, ip, r5, lsl #4
    8eb0:	06000200 	streq	r0, [r0], -r0, lsl #4
    8eb4:	00001bdc 	ldrdeq	r1, [r0], -ip
    8eb8:	006f1c03 	rsbeq	r1, pc, r3, lsl #24
    8ebc:	b7070000 	strlt	r0, [r7, -r0]
    8ec0:	0100001d 	tsteq	r0, sp, lsl r0
    8ec4:	00004c9b 	muleq	r0, fp, ip
    8ec8:	00b50100 	adcseq	r0, r5, r0, lsl #2
    8ecc:	cd080000 	stcgt	0, cr0, [r8, #-0]
    8ed0:	0100001e 	tsteq	r0, lr, lsl r0
    8ed4:	00005e9b 	muleq	r0, fp, lr
    8ed8:	0e090000 	cdpeq	0, 0, cr0, cr9, cr0, {0}
    8edc:	0100001e 	tsteq	r0, lr, lsl r0
    8ee0:	00000022 	andeq	r0, r0, r2, lsr #32
    8ee4:	00000c00 	andeq	r0, r0, r0, lsl #24
    8ee8:	d89c0100 	ldmle	ip, {r8}
    8eec:	0a000000 	beq	8ef4 <_etext+0x19dc>
    8ef0:	00001dad 	andeq	r1, r0, sp, lsr #27
    8ef4:	004c2201 	subeq	r2, ip, r1, lsl #4
    8ef8:	50010000 	andpl	r0, r1, r0
    8efc:	1c150b00 	ldcne	11, cr0, [r5], {-0}
    8f00:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    8f04:	0000004c 	andeq	r0, r0, ip, asr #32
    8f08:	00000000 	andeq	r0, r0, r0
    8f0c:	0000000c 	andeq	r0, r0, ip
    8f10:	e8099c01 	stmda	r9, {r0, sl, fp, ip, pc}
    8f14:	0100001b 	tsteq	r0, fp, lsl r0
    8f18:	0000003a 	andeq	r0, r0, sl, lsr r0
    8f1c:	00000c00 	andeq	r0, r0, r0, lsl #24
    8f20:	109c0100 	addsne	r0, ip, r0, lsl #2
    8f24:	0a000001 	beq	8f30 <_etext+0x1a18>
    8f28:	00001dad 	andeq	r1, r0, sp, lsr #27
    8f2c:	004c3a01 	subeq	r3, ip, r1, lsl #20
    8f30:	50010000 	andpl	r0, r1, r0
    8f34:	1da50b00 	stcne	11, cr0, [r5]
    8f38:	46010000 	strmi	r0, [r1], -r0
    8f3c:	0000004c 	andeq	r0, r0, ip, asr #32
    8f40:	00000000 	andeq	r0, r0, r0
    8f44:	0000000c 	andeq	r0, r0, ip
    8f48:	790b9c01 	stmdbvc	fp, {r0, sl, fp, ip, pc}
    8f4c:	0100001e 	tsteq	r0, lr, lsl r0
    8f50:	00004c52 	andeq	r4, r0, r2, asr ip
    8f54:	00000000 	andeq	r0, r0, r0
    8f58:	00000c00 	andeq	r0, r0, r0, lsl #24
    8f5c:	099c0100 	ldmibeq	ip, {r8}
    8f60:	00001ddb 	ldrdeq	r1, [r0], -fp
    8f64:	00005e01 	andeq	r5, r0, r1, lsl #28
    8f68:	000c0000 	andeq	r0, ip, r0
    8f6c:	9c010000 	stcls	0, cr0, [r1], {-0}
    8f70:	0000015d 	andeq	r0, r0, sp, asr r1
    8f74:	001dad0a 	andseq	sl, sp, sl, lsl #26
    8f78:	4c5e0100 	ldfmie	f0, [lr], {-0}
    8f7c:	01000000 	mrseq	r0, (UNDEF: 0)
    8f80:	2e0b0050 	mcrcs	0, 0, r0, cr11, cr0, {2}
    8f84:	0100001c 	tsteq	r0, ip, lsl r0
    8f88:	00004c6a 	andeq	r4, r0, sl, ror #24
    8f8c:	00000000 	andeq	r0, r0, r0
    8f90:	00000c00 	andeq	r0, r0, r0, lsl #24
    8f94:	099c0100 	ldmibeq	ip, {r8}
    8f98:	00001e16 	andeq	r1, r0, r6, lsl lr
    8f9c:	00007601 	andeq	r7, r0, r1, lsl #12
    8fa0:	00100000 	andseq	r0, r0, r0
    8fa4:	9c010000 	stcls	0, cr0, [r1], {-0}
    8fa8:	00000195 	muleq	r0, r5, r1
    8fac:	001dad0a 	andseq	sl, sp, sl, lsl #26
    8fb0:	4c760100 	ldfmie	f0, [r6], #-0
    8fb4:	01000000 	mrseq	r0, (UNDEF: 0)
    8fb8:	9b0b0050 	blls	2c9100 <_etext+0x2c1be8>
    8fbc:	0100001d 	tsteq	r0, sp, lsl r0
    8fc0:	00004c82 	andeq	r4, r0, r2, lsl #25
    8fc4:	00000000 	andeq	r0, r0, r0
    8fc8:	00000c00 	andeq	r0, r0, r0, lsl #24
    8fcc:	099c0100 	ldmibeq	ip, {r8}
    8fd0:	00001ed4 	ldrdeq	r1, [r0], -r4
    8fd4:	00008f01 	andeq	r8, r0, r1, lsl #30
    8fd8:	000e0000 	andeq	r0, lr, r0
    8fdc:	9c010000 	stcls	0, cr0, [r1], {-0}
    8fe0:	000001dc 	ldrdeq	r0, [r0], -ip
    8fe4:	001ecd0c 	andseq	ip, lr, ip, lsl #26
    8fe8:	5e8f0100 	rmfple	f0, f7, f0
    8fec:	ab000000 	blge	8ff4 <_etext+0x1adc>
    8ff0:	0a000084 	beq	9208 <_etext+0x1cf0>
    8ff4:	00001dad 	andeq	r1, r0, sp, lsr #27
    8ff8:	004c8f01 	subeq	r8, ip, r1, lsl #30
    8ffc:	51010000 	mrspl	r0, (UNDEF: 1)
    9000:	00990d00 	addseq	r0, r9, r0, lsl #26
    9004:	00000000 	andeq	r0, r0, r0
    9008:	00100000 	andseq	r0, r0, r0
    900c:	9c010000 	stcls	0, cr0, [r1], {-0}
    9010:	000001f9 	strdeq	r0, [r0], -r9
    9014:	0000a90e 	andeq	sl, r0, lr, lsl #18
    9018:	0084cc00 	addeq	ip, r4, r0, lsl #24
    901c:	78090000 	stmdavc	r9, {}	; <UNPREDICTABLE>
    9020:	0100001c 	tsteq	r0, ip, lsl r0
    9024:	000000a8 	andeq	r0, r0, r8, lsr #1
    9028:	00001c00 	andeq	r1, r0, r0, lsl #24
    902c:	2d9c0100 	ldfcss	f0, [ip]
    9030:	0c000002 	stceq	0, cr0, [r0], {2}
    9034:	00001ecd 	andeq	r1, r0, sp, asr #29
    9038:	005ea801 	subseq	sl, lr, r1, lsl #16
    903c:	84ed0000 	strbthi	r0, [sp], #0
    9040:	c20c0000 	andgt	r0, ip, #0
    9044:	0100001c 	tsteq	r0, ip, lsl r0
    9048:	00004ca8 	andeq	r4, r0, r8, lsr #25
    904c:	00850e00 	addeq	r0, r5, r0, lsl #28
    9050:	4b0f0000 	blmi	3c9058 <_etext+0x3c1b40>
    9054:	0100001d 	tsteq	r0, sp, lsl r0
    9058:	00004cb4 			; <UNDEFINED> instruction: 0x00004cb4
    905c:	00000000 	andeq	r0, r0, r0
    9060:	00001200 	andeq	r1, r0, r0, lsl #4
    9064:	569c0100 	ldrpl	r0, [ip], r0, lsl #2
    9068:	0c000002 	stceq	0, cr0, [r0], {2}
    906c:	00001ecd 	andeq	r1, r0, sp, asr #29
    9070:	005eb401 	subseq	fp, lr, r1, lsl #8
    9074:	852f0000 	strhi	r0, [pc, #-0]!	; 907c <_etext+0x1b64>
    9078:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    907c:	00001ebf 			; <UNDEFINED> instruction: 0x00001ebf
    9080:	5bbcc101 	blpl	fef3948c <BootRAM+0xdea9c2d>
    9084:	002a0000 	eoreq	r0, sl, r0
    9088:	9c010000 	stcls	0, cr0, [r1], {-0}
    908c:	0000029f 	muleq	r0, pc, r2	; <UNPREDICTABLE>
    9090:	001ecd0c 	andseq	ip, lr, ip, lsl #26
    9094:	5ec10100 	polpls	f0, f1, f0
    9098:	50000000 	andpl	r0, r0, r0
    909c:	0a000085 	beq	92b8 <_etext+0x1da0>
    90a0:	00001425 	andeq	r1, r0, r5, lsr #8
    90a4:	004cc101 	subeq	ip, ip, r1, lsl #2
    90a8:	51010000 	mrspl	r0, (UNDEF: 1)
    90ac:	005bbc10 	subseq	fp, fp, r0, lsl ip
    90b0:	00002a00 	andeq	r2, r0, r0, lsl #20
    90b4:	075e1100 	ldrbeq	r1, [lr, -r0, lsl #2]
    90b8:	c3010000 	movwgt	r0, #4096	; 0x1000
    90bc:	0000004c 	andeq	r0, r0, ip, asr #32
    90c0:	00005301 	andeq	r5, r0, r1, lsl #6
    90c4:	001c4b09 	andseq	r4, ip, r9, lsl #22
    90c8:	00ce0100 	sbceq	r0, lr, r0, lsl #2
    90cc:	2a000000 	bcs	90d4 <_etext+0x1bbc>
    90d0:	01000000 	mrseq	r0, (UNDEF: 0)
    90d4:	0002e89c 	muleq	r2, ip, r8
    90d8:	1ecd0c00 	cdpne	12, 12, cr0, cr13, cr0, {0}
    90dc:	ce010000 	cdpgt	0, 0, cr0, cr1, cr0, {0}
    90e0:	0000005e 	andeq	r0, r0, lr, asr r0
    90e4:	00008571 	andeq	r8, r0, r1, ror r5
    90e8:	0014250a 	andseq	r2, r4, sl, lsl #10
    90ec:	4cce0100 	stfmie	f0, [lr], {0}
    90f0:	01000000 	mrseq	r0, (UNDEF: 0)
    90f4:	00001051 	andeq	r1, r0, r1, asr r0
    90f8:	002a0000 	eoreq	r0, sl, r0
    90fc:	5e110000 	cdppl	0, 1, cr0, cr1, cr0, {0}
    9100:	01000007 	tsteq	r0, r7
    9104:	00004cd0 	ldrdeq	r4, [r0], -r0
    9108:	00530100 	subseq	r0, r3, r0, lsl #2
    910c:	1b910900 	blne	fe44b514 <BootRAM+0xd3bbcb5>
    9110:	db010000 	blle	49118 <_etext+0x41c00>
    9114:	00000000 	andeq	r0, r0, r0
    9118:	00000024 	andeq	r0, r0, r4, lsr #32
    911c:	033e9c01 	teqeq	lr, #256	; 0x100
    9120:	cd0c0000 	stcgt	0, cr0, [ip, #-0]
    9124:	0100001e 	tsteq	r0, lr, lsl r0
    9128:	00005edb 	ldrdeq	r5, [r0], -fp
    912c:	00859200 	addeq	r9, r5, r0, lsl #4
    9130:	1cbd0a00 	vpopne	{s0-s-1}
    9134:	db010000 	blle	4913c <_etext+0x41c24>
    9138:	0000005e 	andeq	r0, r0, lr, asr r0
    913c:	91125101 	tstls	r2, r1, lsl #2
    9140:	0100001e 	tsteq	r0, lr, lsl r0
    9144:	00004cdd 	ldrdeq	r4, [r0], -sp
    9148:	00991300 	addseq	r1, r9, r0, lsl #6
    914c:	00000000 	andeq	r0, r0, r0
    9150:	0be00000 	bleq	ff809158 <BootRAM+0xe7798f9>
    9154:	de010000 	cdple	0, 0, cr0, cr1, cr0, {0}
    9158:	0000a90e 	andeq	sl, r0, lr, lsl #18
    915c:	00859200 	addeq	r9, r5, r0, lsl #4
    9160:	0f000000 	svceq	0x00000000
    9164:	00001caf 	andeq	r1, r0, pc, lsr #25
    9168:	004cf001 	subeq	pc, ip, r1
    916c:	00000000 	andeq	r0, r0, r0
    9170:	00120000 	andseq	r0, r2, r0
    9174:	9c010000 	stcls	0, cr0, [r1], {-0}
    9178:	00000367 	andeq	r0, r0, r7, ror #6
    917c:	001ecd0c 	andseq	ip, lr, ip, lsl #26
    9180:	5ef00100 	cdppl	1, 15, cr0, cr0, cr0, {0}
    9184:	b3000000 	movwlt	r0, #0
    9188:	00000085 	andeq	r0, r0, r5, lsl #1
    918c:	001bb20f 	andseq	fp, fp, pc, lsl #4
    9190:	4cfc0100 	ldfmie	f0, [ip]
    9194:	00000000 	andeq	r0, r0, r0
    9198:	12000000 	andne	r0, r0, #0
    919c:	01000000 	mrseq	r0, (UNDEF: 0)
    91a0:	0003909c 	muleq	r3, ip, r0
    91a4:	1ecd0c00 	cdpne	12, 12, cr0, cr13, cr0, {0}
    91a8:	fc010000 	stc2	0, cr0, [r1], {-0}
    91ac:	0000005e 	andeq	r0, r0, lr, asr r0
    91b0:	000085d4 	ldrdeq	r8, [r0], -r4
    91b4:	1b841400 	blne	fe10e1bc <BootRAM+0xd07e95d>
    91b8:	08010000 	stmdaeq	r1, {}	; <UNPREDICTABLE>
    91bc:	00000001 	andeq	r0, r0, r1
    91c0:	00001e00 	andeq	r1, r0, r0, lsl #28
    91c4:	d19c0100 	orrsle	r0, ip, r0, lsl #2
    91c8:	15000003 	strne	r0, [r0, #-3]
    91cc:	00001ecd 	andeq	r1, r0, sp, asr #29
    91d0:	5e010801 	cdppl	8, 0, cr0, cr1, cr1, {0}
    91d4:	f5000000 			; <UNDEFINED> instruction: 0xf5000000
    91d8:	10000085 	andne	r0, r0, r5, lsl #1
    91dc:	00000000 	andeq	r0, r0, r0
    91e0:	0000001e 	andeq	r0, r0, lr, lsl r0
    91e4:	00075e16 	andeq	r5, r7, r6, lsl lr
    91e8:	010a0100 	mrseq	r0, (UNDEF: 26)
    91ec:	0000004c 	andeq	r0, r0, ip, asr #32
    91f0:	00008616 	andeq	r8, r0, r6, lsl r6
    91f4:	7f140000 	svcvc	0x00140000
    91f8:	01000003 	tsteq	r0, r3
    91fc:	5be60114 	blpl	ff989654 <BootRAM+0xe8f9df5>
    9200:	001e0000 	andseq	r0, lr, r0
    9204:	9c010000 	stcls	0, cr0, [r1], {-0}
    9208:	00000412 	andeq	r0, r0, r2, lsl r4
    920c:	001ecd15 	andseq	ip, lr, r5, lsl sp
    9210:	01140100 	tsteq	r4, r0, lsl #2
    9214:	0000005e 	andeq	r0, r0, lr, asr r0
    9218:	00008641 	andeq	r8, r0, r1, asr #12
    921c:	005be610 	subseq	lr, fp, r0, lsl r6
    9220:	00001e00 	andeq	r1, r0, r0, lsl #28
    9224:	075e1600 	ldrbeq	r1, [lr, -r0, lsl #12]
    9228:	16010000 	strne	r0, [r1], -r0
    922c:	00004c01 	andeq	r4, r0, r1, lsl #24
    9230:	00866200 	addeq	r6, r6, r0, lsl #4
    9234:	14000000 	strne	r0, [r0], #-0
    9238:	00001d76 	andeq	r1, r0, r6, ror sp
    923c:	00012001 	andeq	r2, r1, r1
    9240:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    9244:	01000000 	mrseq	r0, (UNDEF: 0)
    9248:	0004399c 	muleq	r4, ip, r9
    924c:	1ecd1500 	cdpne	5, 12, cr1, cr13, cr0, {0}
    9250:	20010000 	andcs	r0, r1, r0
    9254:	00005e01 	andeq	r5, r0, r1, lsl #28
    9258:	00869000 	addeq	r9, r6, r0
    925c:	8e140000 	cdphi	0, 1, cr0, cr4, cr0, {0}
    9260:	0100001d 	tsteq	r0, sp, lsl r0
    9264:	0000012c 	andeq	r0, r0, ip, lsr #2
    9268:	001c0000 	andseq	r0, ip, r0
    926c:	9c010000 	stcls	0, cr0, [r1], {-0}
    9270:	00000460 	andeq	r0, r0, r0, ror #8
    9274:	001ecd15 	andseq	ip, lr, r5, lsl sp
    9278:	012c0100 	teqeq	ip, r0, lsl #2
    927c:	0000005e 	andeq	r0, r0, lr, asr r0
    9280:	000086b1 			; <UNDEFINED> instruction: 0x000086b1
    9284:	07941400 	ldreq	r1, [r4, r0, lsl #8]
    9288:	37010000 	strcc	r0, [r1, -r0]
    928c:	005c0401 	subseq	r0, ip, r1, lsl #8
    9290:	00001c00 	andeq	r1, r0, r0, lsl #24
    9294:	879c0100 	ldrhi	r0, [ip, r0, lsl #2]
    9298:	15000004 	strne	r0, [r0, #-4]
    929c:	00001ecd 	andeq	r1, r0, sp, asr #29
    92a0:	5e013701 	cdppl	7, 0, cr3, cr1, cr1, {0}
    92a4:	d2000000 	andle	r0, r0, #0
    92a8:	00000086 	andeq	r0, r0, r6, lsl #1
    92ac:	001e6a14 	andseq	r6, lr, r4, lsl sl
    92b0:	01420100 	mrseq	r0, (UNDEF: 82)
    92b4:	00000000 	andeq	r0, r0, r0
    92b8:	0000001e 	andeq	r0, r0, lr, lsl r0
    92bc:	04ae9c01 	strteq	r9, [lr], #3073	; 0xc01
    92c0:	cd150000 	ldcgt	0, cr0, [r5, #-0]
    92c4:	0100001e 	tsteq	r0, lr, lsl r0
    92c8:	005e0142 	subseq	r0, lr, r2, asr #2
    92cc:	86f30000 	ldrbthi	r0, [r3], r0
    92d0:	14000000 	strne	r0, [r0], #-0
    92d4:	00001d05 	andeq	r1, r0, r5, lsl #26
    92d8:	00014d01 	andeq	r4, r1, r1, lsl #26
    92dc:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    92e0:	01000000 	mrseq	r0, (UNDEF: 0)
    92e4:	0004d59c 	muleq	r4, ip, r5
    92e8:	1ecd1500 	cdpne	5, 12, cr1, cr13, cr0, {0}
    92ec:	4d010000 	stcmi	0, cr0, [r1, #-0]
    92f0:	00005e01 	andeq	r5, r0, r1, lsl #28
    92f4:	00871400 	addeq	r1, r7, r0, lsl #8
    92f8:	28140000 	ldmdacs	r4, {}	; <UNPREDICTABLE>
    92fc:	0100001d 	tsteq	r0, sp, lsl r0
    9300:	00000158 	andeq	r0, r0, r8, asr r1
    9304:	001c0000 	andseq	r0, ip, r0
    9308:	9c010000 	stcls	0, cr0, [r1], {-0}
    930c:	000004fc 	strdeq	r0, [r0], -ip
    9310:	001ecd15 	andseq	ip, lr, r5, lsl sp
    9314:	01580100 	cmpeq	r8, r0, lsl #2
    9318:	0000005e 	andeq	r0, r0, lr, asr r0
    931c:	00008735 	andeq	r8, r0, r5, lsr r7
    9320:	1b621700 	blne	188ef28 <_etext+0x1887a10>
    9324:	63010000 	movwvs	r0, #4096	; 0x1000
    9328:	00004c01 	andeq	r4, r0, r1, lsl #24
    932c:	00000000 	andeq	r0, r0, r0
    9330:	00001a00 	andeq	r1, r0, r0, lsl #20
    9334:	279c0100 	ldrcs	r0, [ip, r0, lsl #2]
    9338:	15000005 	strne	r0, [r0, #-5]
    933c:	00001ecd 	andeq	r1, r0, sp, asr #29
    9340:	5e016301 	cdppl	3, 0, cr6, cr1, cr1, {0}
    9344:	56000000 	strpl	r0, [r0], -r0
    9348:	00000087 	andeq	r0, r0, r7, lsl #1
    934c:	001c1d17 	andseq	r1, ip, r7, lsl sp
    9350:	016e0100 	cmneq	lr, r0, lsl #2
    9354:	0000004c 	andeq	r0, r0, ip, asr #32
    9358:	00000000 	andeq	r0, r0, r0
    935c:	0000001a 	andeq	r0, r0, sl, lsl r0
    9360:	05529c01 	ldrbeq	r9, [r2, #-3073]	; 0xc01
    9364:	cd150000 	ldcgt	0, cr0, [r5, #-0]
    9368:	0100001e 	tsteq	r0, lr, lsl r0
    936c:	005e016e 	subseq	r0, lr, lr, ror #2
    9370:	87770000 	ldrbhi	r0, [r7, -r0]!
    9374:	14000000 	strne	r0, [r0], #-0
    9378:	00001d55 	andeq	r1, r0, r5, asr sp
    937c:	00017901 	andeq	r7, r1, r1, lsl #18
    9380:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
    9384:	01000000 	mrseq	r0, (UNDEF: 0)
    9388:	0005799c 	muleq	r5, ip, r9
    938c:	1ecd1500 	cdpne	5, 12, cr1, cr13, cr0, {0}
    9390:	79010000 	stmdbvc	r1, {}	; <UNPREDICTABLE>
    9394:	00005e01 	andeq	r5, r0, r1, lsl #28
    9398:	00879800 	addeq	r9, r7, r0, lsl #16
    939c:	2d140000 	ldccs	0, cr0, [r4, #-0]
    93a0:	0100001e 	tsteq	r0, lr, lsl r0
    93a4:	00000184 	andeq	r0, r0, r4, lsl #3
    93a8:	001c0000 	andseq	r0, ip, r0
    93ac:	9c010000 	stcls	0, cr0, [r1], {-0}
    93b0:	000005a0 	andeq	r0, r0, r0, lsr #11
    93b4:	001ecd15 	andseq	ip, lr, r5, lsl sp
    93b8:	01840100 	orreq	r0, r4, r0, lsl #2
    93bc:	0000005e 	andeq	r0, r0, lr, asr r0
    93c0:	000087b9 			; <UNDEFINED> instruction: 0x000087b9
    93c4:	1c591400 	cfldrdne	mvd1, [r9], {-0}
    93c8:	8f010000 	svchi	0x00010000
    93cc:	00000001 	andeq	r0, r0, r1
    93d0:	00002000 	andeq	r2, r0, r0
    93d4:	c79c0100 	ldrgt	r0, [ip, r0, lsl #2]
    93d8:	15000005 	strne	r0, [r0, #-5]
    93dc:	00001ecd 	andeq	r1, r0, sp, asr #29
    93e0:	5e018f01 	cdppl	15, 0, cr8, cr1, cr1, {0}
    93e4:	da000000 	ble	93ec <_etext+0x1ed4>
    93e8:	00000087 	andeq	r0, r0, r7, lsl #1
    93ec:	001bc014 	andseq	ip, fp, r4, lsl r0
    93f0:	019a0100 	orrseq	r0, sl, r0, lsl #2
    93f4:	00000000 	andeq	r0, r0, r0
    93f8:	00000020 	andeq	r0, r0, r0, lsr #32
    93fc:	05ee9c01 	strbeq	r9, [lr, #3073]!	; 0xc01
    9400:	cd150000 	ldcgt	0, cr0, [r5, #-0]
    9404:	0100001e 	tsteq	r0, lr, lsl r0
    9408:	005e019a 			; <UNDEFINED> instruction: 0x005e019a
    940c:	87fb0000 	ldrbhi	r0, [fp, r0]!
    9410:	14000000 	strne	r0, [r0], #-0
    9414:	00001c02 	andeq	r1, r0, r2, lsl #24
    9418:	2001a501 	andcs	sl, r1, r1, lsl #10
    941c:	2000005c 	andcs	r0, r0, ip, asr r0
    9420:	01000000 	mrseq	r0, (UNDEF: 0)
    9424:	0006159c 	muleq	r6, ip, r5
    9428:	1ecd1500 	cdpne	5, 12, cr1, cr13, cr0, {0}
    942c:	a5010000 	strge	r0, [r1, #-0]
    9430:	00005e01 	andeq	r5, r0, r1, lsl #28
    9434:	00881c00 	addeq	r1, r8, r0, lsl #24
    9438:	b2140000 	andslt	r0, r4, #0
    943c:	0100001e 	tsteq	r0, lr, lsl r0
    9440:	5c4001b0 	stfple	f0, [r0], {176}	; 0xb0
    9444:	00200000 	eoreq	r0, r0, r0
    9448:	9c010000 	stcls	0, cr0, [r1], {-0}
    944c:	0000063c 	andeq	r0, r0, ip, lsr r6
    9450:	001ecd15 	andseq	ip, lr, r5, lsl sp
    9454:	01b00100 	lslseq	r0, r0, #2
    9458:	0000005e 	andeq	r0, r0, lr, asr r0
    945c:	0000883d 	andeq	r8, r0, sp, lsr r8
    9460:	1c3e1400 	cfldrsne	mvf1, [lr], #-0
    9464:	bc010000 	stclt	0, cr0, [r1], {-0}
    9468:	00000001 	andeq	r0, r0, r1
    946c:	00001e00 	andeq	r1, r0, r0, lsl #28
    9470:	739c0100 	orrsvc	r0, ip, #0, 2
    9474:	15000006 	strne	r0, [r0, #-6]
    9478:	00001ecd 	andeq	r1, r0, sp, asr #29
    947c:	5e01bc01 	cdppl	12, 0, cr11, cr1, cr1, {0}
    9480:	5e000000 	cdppl	0, 0, cr0, cr0, cr0, {0}
    9484:	15000088 	strne	r0, [r0, #-136]	; 0x88
    9488:	00001c0f 	andeq	r1, r0, pc, lsl #24
    948c:	5e01bc01 	cdppl	12, 0, cr11, cr1, cr1, {0}
    9490:	7f000000 	svcvc	0x00000000
    9494:	00000088 	andeq	r0, r0, r8, lsl #1
    9498:	001bce17 	andseq	ip, fp, r7, lsl lr
    949c:	01c70100 	biceq	r0, r7, r0, lsl #2
    94a0:	0000005e 	andeq	r0, r0, lr, asr r0
    94a4:	00000000 	andeq	r0, r0, r0
    94a8:	00000012 	andeq	r0, r0, r2, lsl r0
    94ac:	069e9c01 	ldreq	r9, [lr], r1, lsl #24
    94b0:	cd150000 	ldcgt	0, cr0, [r5, #-0]
    94b4:	0100001e 	tsteq	r0, lr, lsl r0
    94b8:	005e01c7 	subseq	r0, lr, r7, asr #3
    94bc:	88a00000 	stmiahi	r0!, {}	; <UNPREDICTABLE>
    94c0:	14000000 	strne	r0, [r0], #-0
    94c4:	00001d1c 	andeq	r1, r0, ip, lsl sp
    94c8:	0001d301 	andeq	sp, r1, r1, lsl #6
    94cc:	20000000 	andcs	r0, r0, r0
    94d0:	01000000 	mrseq	r0, (UNDEF: 0)
    94d4:	0006d59c 	muleq	r6, ip, r5
    94d8:	1ecd1500 	cdpne	5, 12, cr1, cr13, cr0, {0}
    94dc:	d3010000 	movwle	r0, #4096	; 0x1000
    94e0:	00005e01 	andeq	r5, r0, r1, lsl #28
    94e4:	0088c100 	addeq	ip, r8, r0, lsl #2
    94e8:	1dc31500 	cfstr64ne	mvdx1, [r3]
    94ec:	d3010000 	movwle	r0, #4096	; 0x1000
    94f0:	00004c01 	andeq	r4, r0, r1, lsl #24
    94f4:	0088e200 	addeq	lr, r8, r0, lsl #4
    94f8:	e0140000 	ands	r0, r4, r0
    94fc:	0100001e 	tsteq	r0, lr, lsl r0
    9500:	000001df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    9504:	00200000 	eoreq	r0, r0, r0
    9508:	9c010000 	stcls	0, cr0, [r1], {-0}
    950c:	0000070c 	andeq	r0, r0, ip, lsl #14
    9510:	001ecd15 	andseq	ip, lr, r5, lsl sp
    9514:	01df0100 	bicseq	r0, pc, r0, lsl #2
    9518:	0000005e 	andeq	r0, r0, lr, asr r0
    951c:	00008903 	andeq	r8, r0, r3, lsl #18
    9520:	001dc315 	andseq	ip, sp, r5, lsl r3
    9524:	01df0100 	bicseq	r0, pc, r0, lsl #2
    9528:	0000004c 	andeq	r0, r0, ip, asr #32
    952c:	00008924 	andeq	r8, r0, r4, lsr #18
    9530:	1ea61700 	cdpne	7, 10, cr1, cr6, cr0, {0}
    9534:	ea010000 	b	4953c <_etext+0x42024>
    9538:	00004c01 	andeq	r4, r0, r1, lsl #24
    953c:	005c6000 	subseq	r6, ip, r0
    9540:	00001c00 	andeq	r1, r0, r0, lsl #24
    9544:	379c0100 	ldrcc	r0, [ip, r0, lsl #2]
    9548:	15000007 	strne	r0, [r0, #-7]
    954c:	00001ecd 	andeq	r1, r0, sp, asr #29
    9550:	5e01ea01 	vmlapl.f32	s28, s2, s2
    9554:	45000000 	strmi	r0, [r0, #-0]
    9558:	00000089 	andeq	r0, r0, r9, lsl #1
    955c:	001c9217 	andseq	r9, ip, r7, lsl r2
    9560:	01f50100 	mvnseq	r0, r0, lsl #2
    9564:	0000004c 	andeq	r0, r0, ip, asr #32
    9568:	00005c7c 	andeq	r5, r0, ip, ror ip
    956c:	0000001c 	andeq	r0, r0, ip, lsl r0
    9570:	07629c01 	strbeq	r9, [r2, -r1, lsl #24]!
    9574:	cd150000 	ldcgt	0, cr0, [r5, #-0]
    9578:	0100001e 	tsteq	r0, lr, lsl r0
    957c:	005e01f5 	ldrsheq	r0, [lr], #-21	; 0xffffffeb
    9580:	89660000 	stmdbhi	r6!, {}^	; <UNPREDICTABLE>
    9584:	14000000 	strne	r0, [r0], #-0
    9588:	00001d81 	andeq	r1, r0, r1, lsl #27
    958c:	98020101 	stmdals	r2, {r0, r8}
    9590:	1c00005c 	stcne	0, cr0, [r0], {92}	; 0x5c
    9594:	01000000 	mrseq	r0, (UNDEF: 0)
    9598:	0007979c 	muleq	r7, ip, r7
    959c:	1ecd1500 	cdpne	5, 12, cr1, cr13, cr0, {0}
    95a0:	01010000 	mrseq	r0, (UNDEF: 1)
    95a4:	00005e02 	andeq	r5, r0, r2, lsl #28
    95a8:	00898700 	addeq	r8, r9, r0, lsl #14
    95ac:	1c371800 	ldcne	8, cr1, [r7], #-0
    95b0:	01010000 	mrseq	r0, (UNDEF: 1)
    95b4:	00004c02 	andeq	r4, r0, r2, lsl #24
    95b8:	00510100 	subseq	r0, r1, r0, lsl #2
    95bc:	001deb14 	andseq	lr, sp, r4, lsl fp
    95c0:	020d0100 	andeq	r0, sp, #0, 2
    95c4:	00000000 	andeq	r0, r0, r0
    95c8:	00000026 	andeq	r0, r0, r6, lsr #32
    95cc:	07e69c01 	strbeq	r9, [r6, r1, lsl #24]!
    95d0:	e4180000 	ldr	r0, [r8], #-0
    95d4:	0100001d 	tsteq	r0, sp, lsl r0
    95d8:	07e6020d 	strbeq	r0, [r6, sp, lsl #4]!
    95dc:	50010000 	andpl	r0, r1, r0
    95e0:	001c3715 	andseq	r3, ip, r5, lsl r7
    95e4:	020d0100 	andeq	r0, sp, #0, 2
    95e8:	0000004c 	andeq	r0, r0, ip, asr #32
    95ec:	000089a8 	andeq	r8, r0, r8, lsr #19
    95f0:	00000010 	andeq	r0, r0, r0, lsl r0
    95f4:	00002600 	andeq	r2, r0, r0, lsl #12
    95f8:	1bf91600 	blne	ffe4ee00 <BootRAM+0xedbf5a1>
    95fc:	0f010000 	svceq	0x00010000
    9600:	00004c02 	andeq	r4, r0, r2, lsl #24
    9604:	0089e200 	addeq	lr, r9, r0, lsl #4
    9608:	19000000 	stmdbne	r0, {}	; <UNPREDICTABLE>
    960c:	00003a04 	andeq	r3, r0, r4, lsl #20
    9610:	099c1400 	ldmibeq	ip, {sl, ip}
    9614:	19010000 	stmdbne	r1, {}	; <UNPREDICTABLE>
    9618:	005cb402 	subseq	fp, ip, r2, lsl #8
    961c:	00004000 	andeq	r4, r0, r0
    9620:	519c0100 	orrspl	r0, ip, r0, lsl #2
    9624:	15000008 	strne	r0, [r0, #-8]
    9628:	00001ecd 	andeq	r1, r0, sp, asr #29
    962c:	5e021901 	cdppl	9, 0, cr1, cr2, cr1, {0}
    9630:	0b000000 	bleq	9638 <_etext+0x2120>
    9634:	1500008a 	strne	r0, [r0, #-138]	; 0x8a
    9638:	00001c37 	andeq	r1, r0, r7, lsr ip
    963c:	4c021901 	stcmi	9, cr1, [r2], {1}
    9640:	2c000000 	stccs	0, cr0, [r0], {-0}
    9644:	1000008a 	andne	r0, r0, sl, lsl #1
    9648:	00005cb4 			; <UNDEFINED> instruction: 0x00005cb4
    964c:	00000040 	andeq	r0, r0, r0, asr #32
    9650:	001de41a 	andseq	lr, sp, sl, lsl r4
    9654:	021b0100 	andseq	r0, fp, #0, 2
    9658:	000007e6 	andeq	r0, r0, r6, ror #15
    965c:	f81b5201 			; <UNDEFINED> instruction: 0xf81b5201
    9660:	1600000b 	strne	r0, [r0], -fp
    9664:	00001bf9 	strdeq	r1, [r0], -r9
    9668:	4c021b01 	stcmi	11, cr1, [r2], {1}
    966c:	4d000000 	stcmi	0, cr0, [r0, #-0]
    9670:	0000008a 	andeq	r0, r0, sl, lsl #1
    9674:	20170000 	andscs	r0, r7, r0
    9678:	0100001e 	tsteq	r0, lr, lsl r0
    967c:	004c0224 	subeq	r0, ip, r4, lsr #4
    9680:	00000000 	andeq	r0, r0, r0
    9684:	00200000 	eoreq	r0, r0, r0
    9688:	9c010000 	stcls	0, cr0, [r1], {-0}
    968c:	0000087c 	andeq	r0, r0, ip, ror r8
    9690:	001ecd15 	andseq	ip, lr, r5, lsl sp
    9694:	02240100 	eoreq	r0, r4, #0, 2
    9698:	0000005e 	andeq	r0, r0, lr, asr r0
    969c:	00008a85 	andeq	r8, r0, r5, lsl #21
    96a0:	1dfb1700 	ldclne	7, cr1, [fp]
    96a4:	2f010000 	svccs	0x00010000
    96a8:	00004c02 	andeq	r4, r0, r2, lsl #24
    96ac:	00000000 	andeq	r0, r0, r0
    96b0:	00002000 	andeq	r2, r0, r0
    96b4:	a79c0100 	ldrge	r0, [ip, r0, lsl #2]
    96b8:	15000008 	strne	r0, [r0, #-8]
    96bc:	00001ecd 	andeq	r1, r0, sp, asr #29
    96c0:	5e022f01 	cdppl	15, 0, cr2, cr2, cr1, {0}
    96c4:	a6000000 	strge	r0, [r0], -r0
    96c8:	0000008a 	andeq	r0, r0, sl, lsl #1
    96cc:	001c6714 	andseq	r6, ip, r4, lsl r7
    96d0:	023c0100 	eorseq	r0, ip, #0, 2
    96d4:	00000000 	andeq	r0, r0, r0
    96d8:	00000038 	andeq	r0, r0, r8, lsr r0
    96dc:	08ee9c01 	stmiaeq	lr!, {r0, sl, fp, ip, pc}^
    96e0:	cd150000 	ldcgt	0, cr0, [r5, #-0]
    96e4:	0100001e 	tsteq	r0, lr, lsl r0
    96e8:	005e023c 	subseq	r0, lr, ip, lsr r2
    96ec:	8ac70000 	bhi	ff1c96f4 <BootRAM+0xe139e95>
    96f0:	60150000 	andsvs	r0, r5, r0
    96f4:	0100001e 	tsteq	r0, lr, lsl r0
    96f8:	004c023c 	subeq	r0, ip, ip, lsr r2
    96fc:	8ae80000 	bhi	ffa09704 <BootRAM+0xe979ea5>
    9700:	f6150000 			; <UNDEFINED> instruction: 0xf6150000
    9704:	0100001c 	tsteq	r0, ip, lsl r0
    9708:	004c023c 	subeq	r0, ip, ip, lsr r2
    970c:	8b090000 	blhi	249714 <_etext+0x2421fc>
    9710:	14000000 	strne	r0, [r0], #-0
    9714:	00001c9e 	muleq	r0, lr, ip
    9718:	00024801 	andeq	r4, r2, r1, lsl #16
    971c:	20000000 	andcs	r0, r0, r0
    9720:	01000000 	mrseq	r0, (UNDEF: 0)
    9724:	0009259c 	muleq	r9, ip, r5
    9728:	1ecd1500 	cdpne	5, 12, cr1, cr13, cr0, {0}
    972c:	48010000 	stmdami	r1, {}	; <UNPREDICTABLE>
    9730:	00005e02 	andeq	r5, r0, r2, lsl #28
    9734:	008b2a00 	addeq	r2, fp, r0, lsl #20
    9738:	1e601500 	cdpne	5, 6, cr1, cr0, cr0, {0}
    973c:	48010000 	stmdami	r1, {}	; <UNPREDICTABLE>
    9740:	00004c02 	andeq	r4, r0, r2, lsl #24
    9744:	008b4b00 	addeq	r4, fp, r0, lsl #22
    9748:	73140000 	tstvc	r4, #0
    974c:	0100001b 	tsteq	r0, fp, lsl r0
    9750:	00000254 	andeq	r0, r0, r4, asr r2
    9754:	00200000 	eoreq	r0, r0, r0
    9758:	9c010000 	stcls	0, cr0, [r1], {-0}
    975c:	0000095c 	andeq	r0, r0, ip, asr r9
    9760:	001ecd15 	andseq	ip, lr, r5, lsl sp
    9764:	02540100 	subseq	r0, r4, #0, 2
    9768:	0000005e 	andeq	r0, r0, lr, asr r0
    976c:	00008b6c 	andeq	r8, r0, ip, ror #22
    9770:	001cf615 	andseq	pc, ip, r5, lsl r6	; <UNPREDICTABLE>
    9774:	02540100 	subseq	r0, r4, #0, 2
    9778:	0000004c 	andeq	r0, r0, ip, asr #32
    977c:	00008b8d 	andeq	r8, r0, sp, lsl #23
    9780:	1e801700 	cdpne	7, 8, cr1, cr0, cr0, {0}
    9784:	5f010000 	svcpl	0x00010000
    9788:	00004c02 	andeq	r4, r0, r2, lsl #24
    978c:	00000000 	andeq	r0, r0, r0
    9790:	00001c00 	andeq	r1, r0, r0, lsl #24
    9794:	879c0100 	ldrhi	r0, [ip, r0, lsl #2]
    9798:	15000009 	strne	r0, [r0, #-9]
    979c:	00001ecd 	andeq	r1, r0, sp, asr #29
    97a0:	5e025f01 	cdppl	15, 0, cr5, cr2, cr1, {0}
    97a4:	ae000000 	cdpge	0, 0, cr0, cr0, cr0, {0}
    97a8:	0000008b 	andeq	r0, r0, fp, lsl #1
    97ac:	001d3a17 	andseq	r3, sp, r7, lsl sl
    97b0:	026a0100 	rsbeq	r0, sl, #0, 2
    97b4:	0000004c 	andeq	r0, r0, ip, asr #32
    97b8:	00000000 	andeq	r0, r0, r0
    97bc:	0000001c 	andeq	r0, r0, ip, lsl r0
    97c0:	09b29c01 	ldmibeq	r2!, {r0, sl, fp, ip, pc}
    97c4:	cd150000 	ldcgt	0, cr0, [r5, #-0]
    97c8:	0100001e 	tsteq	r0, lr, lsl r0
    97cc:	005e026a 	subseq	r0, lr, sl, ror #4
    97d0:	8bcf0000 	blhi	ff3c97d8 <BootRAM+0xe339f79>
    97d4:	14000000 	strne	r0, [r0], #-0
    97d8:	00001d64 	andeq	r1, r0, r4, ror #26
    97dc:	00027601 	andeq	r7, r2, r1, lsl #12
    97e0:	a8000000 	stmdage	r0, {}	; <UNPREDICTABLE>
    97e4:	01000000 	mrseq	r0, (UNDEF: 0)
    97e8:	000a599c 	muleq	sl, ip, r9
    97ec:	1ecd1500 	cdpne	5, 12, cr1, cr13, cr0, {0}
    97f0:	76010000 	strvc	r0, [r1], -r0
    97f4:	00005e02 	andeq	r5, r0, r2, lsl #28
    97f8:	008bf000 	addeq	pc, fp, r0
    97fc:	1cbd1500 	cfldr32ne	mvfx1, [sp]
    9800:	76010000 	strvc	r0, [r1], -r0
    9804:	00005e02 	andeq	r5, r0, r2, lsl #28
    9808:	008c3500 	addeq	r3, ip, r0, lsl #10
    980c:	1c371500 	cfldr32ne	mvfx1, [r7], #-0
    9810:	76010000 	strvc	r0, [r1], -r0
    9814:	00004c02 	andeq	r4, r0, r2, lsl #24
    9818:	008c7a00 	addeq	r7, ip, r0, lsl #20
    981c:	00001c00 	andeq	r1, r0, r0, lsl #24
    9820:	003a0000 	eorseq	r0, sl, r0
    9824:	0a2c0000 	beq	b0982c <_etext+0xb02314>
    9828:	e4160000 	ldr	r0, [r6], #-0
    982c:	0100001d 	tsteq	r0, sp, lsl r0
    9830:	07e60278 			; <UNDEFINED> instruction: 0x07e60278
    9834:	8ca60000 	stchi	0, cr0, [r6]
    9838:	101b0000 	andsne	r0, fp, r0
    983c:	1600000c 	strne	r0, [r0], -ip
    9840:	00001bf9 	strdeq	r1, [r0], -r9
    9844:	4c027801 	stcmi	8, cr7, [r2], {1}
    9848:	c4000000 	strgt	r0, [r0], #-0
    984c:	0000008c 	andeq	r0, r0, ip, lsl #1
    9850:	0c281b00 	stceq	11, cr1, [r8], #-0
    9854:	e4160000 	ldr	r0, [r6], #-0
    9858:	0100001d 	tsteq	r0, sp, lsl r0
    985c:	07e60278 			; <UNDEFINED> instruction: 0x07e60278
    9860:	8cfc0000 	ldclhi	0, cr0, [ip]
    9864:	401b0000 	andsmi	r0, fp, r0
    9868:	1600000c 	strne	r0, [r0], -ip
    986c:	00001bf9 	strdeq	r1, [r0], -r9
    9870:	4c027801 	stcmi	8, cr7, [r2], {1}
    9874:	1a000000 	bne	987c <_etext+0x2364>
    9878:	0000008d 	andeq	r0, r0, sp, lsl #1
    987c:	4e140000 	cdpmi	0, 1, cr0, cr4, cr0, {0}
    9880:	0100001e 	tsteq	r0, lr, lsl r0
    9884:	00000282 	andeq	r0, r0, r2, lsl #5
    9888:	005c0000 	subseq	r0, ip, r0
    988c:	9c010000 	stcls	0, cr0, [r1], {-0}
    9890:	00000ad0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    9894:	001ecd15 	andseq	ip, lr, r5, lsl sp
    9898:	02820100 	addeq	r0, r2, #0, 2
    989c:	0000005e 	andeq	r0, r0, lr, asr r0
    98a0:	00008d52 	andeq	r8, r0, r2, asr sp
    98a4:	001cbd15 	andseq	fp, ip, r5, lsl sp
    98a8:	02820100 	addeq	r0, r2, #0, 2
    98ac:	0000005e 	andeq	r0, r0, lr, asr r0
    98b0:	00008d8c 	andeq	r8, r0, ip, lsl #27
    98b4:	001c3715 	andseq	r3, ip, r5, lsl r7
    98b8:	02820100 	addeq	r0, r2, #0, 2
    98bc:	0000004c 	andeq	r0, r0, ip, asr #32
    98c0:	00008db8 			; <UNDEFINED> instruction: 0x00008db8
    98c4:	00000010 	andeq	r0, r0, r0, lsl r0
    98c8:	00003800 	andeq	r3, r0, r0, lsl #16
    98cc:	1de41600 	stclne	6, cr1, [r4]
    98d0:	84010000 	strhi	r0, [r1], #-0
    98d4:	0007e602 	andeq	lr, r7, r2, lsl #12
    98d8:	008de400 	addeq	lr, sp, r0, lsl #8
    98dc:	0c601b00 	stcleq	11, cr1, [r0], #-0
    98e0:	f9160000 			; <UNDEFINED> instruction: 0xf9160000
    98e4:	0100001b 	tsteq	r0, fp, lsl r0
    98e8:	004c0284 	subeq	r0, ip, r4, lsl #5
    98ec:	8df70000 	ldclhi	0, cr0, [r7]
    98f0:	00000000 	andeq	r0, r0, r0
    98f4:	1eec1400 	cdpne	4, 14, cr1, cr12, cr0, {0}
    98f8:	8e010000 	cdphi	0, 0, cr0, cr1, cr0, {0}
    98fc:	00000002 	andeq	r0, r0, r2
    9900:	00005c00 	andeq	r5, r0, r0, lsl #24
    9904:	479c0100 	ldrmi	r0, [ip, r0, lsl #2]
    9908:	1500000b 	strne	r0, [r0, #-11]
    990c:	00001ecd 	andeq	r1, r0, sp, asr #29
    9910:	5e028e01 	cdppl	14, 0, cr8, cr2, cr1, {0}
    9914:	2f000000 	svccs	0x00000000
    9918:	1500008e 	strne	r0, [r0, #-142]	; 0x8e
    991c:	00001cbd 			; <UNDEFINED> instruction: 0x00001cbd
    9920:	5e028e01 	cdppl	14, 0, cr8, cr2, cr1, {0}
    9924:	69000000 	stmdbvs	r0, {}	; <UNPREDICTABLE>
    9928:	1500008e 	strne	r0, [r0, #-142]	; 0x8e
    992c:	00001c37 	andeq	r1, r0, r7, lsr ip
    9930:	4c028e01 	stcmi	14, cr8, [r2], {1}
    9934:	95000000 	strls	r0, [r0, #-0]
    9938:	1000008e 	andne	r0, r0, lr, lsl #1
    993c:	00000000 	andeq	r0, r0, r0
    9940:	00000038 	andeq	r0, r0, r8, lsr r0
    9944:	001de416 	andseq	lr, sp, r6, lsl r4
    9948:	02900100 	addseq	r0, r0, #0, 2
    994c:	000007e6 	andeq	r0, r0, r6, ror #15
    9950:	00008ec1 	andeq	r8, r0, r1, asr #29
    9954:	000c781b 	andeq	r7, ip, fp, lsl r8
    9958:	1bf91600 	blne	ffe4f160 <BootRAM+0xedbf901>
    995c:	90010000 	andls	r0, r1, r0
    9960:	00004c02 	andeq	r4, r0, r2, lsl #24
    9964:	008ed400 	addeq	sp, lr, r0, lsl #8
    9968:	00000000 	andeq	r0, r0, r0
    996c:	001dc917 	andseq	ip, sp, r7, lsl r9
    9970:	029a0100 	addseq	r0, sl, #0, 2
    9974:	0000004c 	andeq	r0, r0, ip, asr #32
    9978:	00000000 	andeq	r0, r0, r0
    997c:	00000020 	andeq	r0, r0, r0, lsr #32
    9980:	0b729c01 	bleq	1cb098c <_etext+0x1ca9474>
    9984:	cd150000 	ldcgt	0, cr0, [r5, #-0]
    9988:	0100001e 	tsteq	r0, lr, lsl r0
    998c:	005e029a 			; <UNDEFINED> instruction: 0x005e029a
    9990:	8f0c0000 	svchi	0x000c0000
    9994:	17000000 	strne	r0, [r0, -r0]
    9998:	00001e3c 	andeq	r1, r0, ip, lsr lr
    999c:	4c02a601 	stcmi	6, cr10, [r2], {1}
    99a0:	00000000 	andeq	r0, r0, r0
    99a4:	20000000 	andcs	r0, r0, r0
    99a8:	01000000 	mrseq	r0, (UNDEF: 0)
    99ac:	000b9d9c 	muleq	fp, ip, sp
    99b0:	1ecd1500 	cdpne	5, 12, cr1, cr13, cr0, {0}
    99b4:	a6010000 	strge	r0, [r1], -r0
    99b8:	00005e02 	andeq	r5, r0, r2, lsl #28
    99bc:	008f2d00 	addeq	r2, pc, r0, lsl #26
    99c0:	e7170000 	ldr	r0, [r7, -r0]
    99c4:	0100001c 	tsteq	r0, ip, lsl r0
    99c8:	008e02b2 			; <UNDEFINED> instruction: 0x008e02b2
    99cc:	00000000 	andeq	r0, r0, r0
    99d0:	00440000 	subeq	r0, r4, r0
    99d4:	9c010000 	stcls	0, cr0, [r1], {-0}
    99d8:	00000bc8 	andeq	r0, r0, r8, asr #23
    99dc:	001ecd15 	andseq	ip, lr, r5, lsl sp
    99e0:	02b20100 	adcseq	r0, r2, #0, 2
    99e4:	0000005e 	andeq	r0, r0, lr, asr r0
    99e8:	00008f4e 	andeq	r8, r0, lr, asr #30
    99ec:	1b531400 	blne	14ce9f4 <_etext+0x14c74dc>
    99f0:	c3010000 	movwgt	r0, #4096	; 0x1000
    99f4:	00000002 	andeq	r0, r0, r2
    99f8:	00003a00 	andeq	r3, r0, r0, lsl #20
    99fc:	fd9c0100 	ldc2	1, cr0, [ip]
    9a00:	1500000b 	strne	r0, [r0, #-11]
    9a04:	00001ecd 	andeq	r1, r0, sp, asr #29
    9a08:	5e02c301 	cdppl	3, 0, cr12, cr2, cr1, {0}
    9a0c:	6f000000 	svcvs	0x00000000
    9a10:	1800008f 	stmdane	r0, {r0, r1, r2, r3, r7}
    9a14:	00001cbd 			; <UNDEFINED> instruction: 0x00001cbd
    9a18:	5e02c301 	cdppl	3, 0, cr12, cr2, cr1, {0}
    9a1c:	01000000 	mrseq	r0, (UNDEF: 0)
    9a20:	15170051 	ldrne	r0, [r7, #-81]	; 0x51
    9a24:	0100001d 	tsteq	r0, sp, lsl r0
    9a28:	004c02d6 	ldrdeq	r0, [ip], #-38	; 0xffffffda
    9a2c:	00000000 	andeq	r0, r0, r0
    9a30:	00060000 	andeq	r0, r6, r0
    9a34:	9c010000 	stcls	0, cr0, [r1], {-0}
    9a38:	00000c44 	andeq	r0, r0, r4, asr #24
    9a3c:	0068621d 	rsbeq	r6, r8, sp, lsl r2
    9a40:	5e02d601 	cfmadd32pl	mvax0, mvfx13, mvfx2, mvfx1
    9a44:	a9000000 	stmdbge	r0, {}	; <UNPREDICTABLE>
    9a48:	1e00008f 	cdpne	0, 0, cr0, cr0, cr15, {4}
    9a4c:	01006c62 	tsteq	r0, r2, ror #24
    9a50:	005e02d6 	ldrsbeq	r0, [lr], #-38	; 0xffffffda
    9a54:	51010000 	mrspl	r0, (UNDEF: 1)
    9a58:	001c8d16 	andseq	r8, ip, r6, lsl sp
    9a5c:	02d80100 	sbcseq	r0, r8, #0, 2
    9a60:	0000004c 	andeq	r0, r0, ip, asr #32
    9a64:	00008fca 	andeq	r8, r0, sl, asr #31
    9a68:	1bf01f00 	blne	ffc11670 <BootRAM+0xeb81e11>
    9a6c:	e3010000 	movw	r0, #4096	; 0x1000
    9a70:	00004c02 	andeq	r4, r0, r2, lsl #24
    9a74:	00000000 	andeq	r0, r0, r0
    9a78:	00000a00 	andeq	r0, r0, r0, lsl #20
    9a7c:	159c0100 	ldrne	r0, [ip, #256]	; 0x100
    9a80:	00001d00 	andeq	r1, r0, r0, lsl #26
    9a84:	4c02e301 	stcmi	3, cr14, [r2], {1}
    9a88:	03000000 	movweq	r0, #0
    9a8c:	16000090 			; <UNDEFINED> instruction: 0x16000090
    9a90:	00001e08 	andeq	r1, r0, r8, lsl #28
    9a94:	5e02e501 	cfsh32pl	mvfx14, mvfx2, #1
    9a98:	24000000 	strcs	r0, [r0], #-0
    9a9c:	16000090 			; <UNDEFINED> instruction: 0x16000090
    9aa0:	00001c8d 	andeq	r1, r0, sp, lsl #25
    9aa4:	4c02e601 	stcmi	6, cr14, [r2], {1}
    9aa8:	37000000 	strcc	r0, [r0, -r0]
    9aac:	00000090 	muleq	r0, r0, r0
    9ab0:	0001d800 	andeq	sp, r1, r0, lsl #16
    9ab4:	75000400 	strvc	r0, [r0, #-1024]	; 0x400
    9ab8:	04000023 	streq	r0, [r0], #-35	; 0x23
    9abc:	00063901 	andeq	r3, r6, r1, lsl #18
    9ac0:	1f310100 	svcne	0x00310100
    9ac4:	08930000 	ldmeq	r3, {}	; <UNPREDICTABLE>
    9ac8:	0e700000 	cdpeq	0, 7, cr0, cr0, cr0, {0}
    9acc:	00000000 	andeq	r0, r0, r0
    9ad0:	37b80000 	ldrcc	r0, [r8, r0]!
    9ad4:	04020000 	streq	r0, [r2], #-0
    9ad8:	0004da05 	andeq	sp, r4, r5, lsl #20
    9adc:	05020200 	streq	r0, [r2, #-512]	; 0x200
    9ae0:	000006fc 	strdeq	r0, [r0], -ip
    9ae4:	1a060102 	bne	189ef4 <_etext+0x1829dc>
    9ae8:	03000008 	movweq	r0, #8
    9aec:	00323375 	eorseq	r3, r2, r5, ror r3
    9af0:	00452402 	subeq	r2, r5, r2, lsl #8
    9af4:	04020000 	streq	r0, [r2], #-0
    9af8:	00025207 	andeq	r5, r2, r7, lsl #4
    9afc:	31750300 	cmncc	r5, r0, lsl #6
    9b00:	25020036 	strcs	r0, [r2, #-54]	; 0x36
    9b04:	00000057 	andeq	r0, r0, r7, asr r0
    9b08:	49070202 	stmdbmi	r7, {r1, r9}
    9b0c:	03000009 	movweq	r0, #9
    9b10:	02003875 	andeq	r3, r0, #7667712	; 0x750000
    9b14:	00006826 	andeq	r6, r0, r6, lsr #16
    9b18:	08010200 	stmdaeq	r1, {r9}
    9b1c:	00000818 	andeq	r0, r0, r8, lsl r8
    9b20:	6f040504 	svcvs	0x00040504
    9b24:	06000000 	streq	r0, [r0], -r0
    9b28:	00000834 	andeq	r0, r0, r4, lsr r8
    9b2c:	5cf42901 	ldclpl	9, cr2, [r4], #4
    9b30:	01540000 	cmpeq	r4, r0
    9b34:	9c010000 	stcls	0, cr0, [r1], {-0}
    9b38:	0000012a 	andeq	r0, r0, sl, lsr #2
    9b3c:	001f2a07 	andseq	r2, pc, r7, lsl #20
    9b40:	3a2b0100 	bcc	ac9f48 <_etext+0xac2a30>
    9b44:	56000000 	strpl	r0, [r0], -r0
    9b48:	08000090 	stmdaeq	r0, {r4, r7}
    9b4c:	00005d30 	andeq	r5, r0, r0, lsr sp
    9b50:	00000012 	andeq	r0, r0, r2, lsl r0
    9b54:	000000b7 	strheq	r0, [r0], -r7
    9b58:	00075e07 	andeq	r5, r7, r7, lsl #28
    9b5c:	4c3c0100 	ldfmis	f0, [ip], #-0
    9b60:	c6000000 	strgt	r0, [r0], -r0
    9b64:	00000090 	muleq	r0, r0, r0
    9b68:	005d4208 	subseq	r4, sp, r8, lsl #4
    9b6c:	00001200 	andeq	r1, r0, r0, lsl #4
    9b70:	0000d400 	andeq	sp, r0, r0, lsl #8
    9b74:	075e0700 	ldrbeq	r0, [lr, -r0, lsl #14]
    9b78:	3d010000 	stccc	0, cr0, [r1, #-0]
    9b7c:	0000004c 	andeq	r0, r0, ip, asr #32
    9b80:	0000910a 	andeq	r9, r0, sl, lsl #2
    9b84:	5d960800 	ldcpl	8, cr0, [r6]
    9b88:	00220000 	eoreq	r0, r2, r0
    9b8c:	00f10000 	rscseq	r0, r1, r0
    9b90:	5e070000 	cdppl	0, 0, cr0, cr7, cr0, {0}
    9b94:	01000007 	tsteq	r0, r7
    9b98:	00004c72 	andeq	r4, r0, r2, ror ip
    9b9c:	00918400 	addseq	r8, r1, r0, lsl #8
    9ba0:	b8080000 	stmdalt	r8, {}	; <UNPREDICTABLE>
    9ba4:	2000005d 	andcs	r0, r0, sp, asr r0
    9ba8:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    9bac:	07000001 	streq	r0, [r0, -r1]
    9bb0:	0000075e 	andeq	r0, r0, lr, asr r7
    9bb4:	004c7301 	subeq	r7, ip, r1, lsl #6
    9bb8:	91a50000 			; <UNDEFINED> instruction: 0x91a50000
    9bbc:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    9bc0:	00005d6e 	andeq	r5, r0, lr, ror #26
    9bc4:	000001ba 			; <UNDEFINED> instruction: 0x000001ba
    9bc8:	005d8209 	subseq	r8, sp, r9, lsl #4
    9bcc:	0001c500 	andeq	ip, r1, r0, lsl #10
    9bd0:	5d960900 	ldcpl	9, cr0, [r6]
    9bd4:	01d00000 	bicseq	r0, r0, r0
    9bd8:	06000000 	streq	r0, [r0], -r0
    9bdc:	00001efe 	strdeq	r1, [r0], -lr
    9be0:	00009e01 	andeq	r9, r0, r1, lsl #28
    9be4:	00700000 	rsbseq	r0, r0, r0
    9be8:	9c010000 	stcls	0, cr0, [r1], {-0}
    9bec:	0000014f 	andeq	r0, r0, pc, asr #2
    9bf0:	001f2a07 	andseq	r2, pc, r7, lsl #20
    9bf4:	3aa00100 	bcc	fe809ffc <BootRAM+0xd77a79d>
    9bf8:	b8000000 	stmdalt	r0, {}	; <UNPREDICTABLE>
    9bfc:	00000091 	muleq	r0, r1, r0
    9c00:	0008020a 	andeq	r0, r8, sl, lsl #4
    9c04:	022a0300 	eoreq	r0, sl, #0, 6
    9c08:	0000015b 	andeq	r0, r0, fp, asr r1
    9c0c:	00004c0b 	andeq	r4, r0, fp, lsl #24
    9c10:	1f140c00 	svcne	0x00140c00
    9c14:	17010000 	strne	r0, [r1, -r0]
    9c18:	0000004c 	andeq	r0, r0, ip, asr #32
    9c1c:	05760305 	ldrbeq	r0, [r6, #-773]!	; 0x305
    9c20:	1f0c2000 	svcne	0x000c2000
    9c24:	0100001f 	tsteq	r0, pc, lsl r0
    9c28:	00004c18 	andeq	r4, r0, r8, lsl ip
    9c2c:	78030500 	stmdavc	r3, {r8, sl}
    9c30:	0d200005 	stceq	0, cr0, [r0, #-20]!	; 0xffffffec
    9c34:	00001f5c 	andeq	r1, r0, ip, asr pc
    9c38:	005e1d04 	subseq	r1, lr, r4, lsl #26
    9c3c:	700e0000 	andvc	r0, lr, r0
    9c40:	9d000000 	stcls	0, cr0, [r0, #-0]
    9c44:	0f000001 	svceq	0x00000001
    9c48:	0000019d 	muleq	r0, sp, r1
    9c4c:	04020006 	streq	r0, [r2], #-6
    9c50:	00078b07 	andeq	r8, r7, r7, lsl #22
    9c54:	09b30d00 	ldmibeq	r3!, {r8, sl, fp}
    9c58:	1b010000 	blne	49c60 <_etext+0x42748>
    9c5c:	0000018d 	andeq	r0, r0, sp, lsl #3
    9c60:	0009650d 	andeq	r6, r9, sp, lsl #10
    9c64:	8d1c0100 	ldfhis	f0, [ip, #-0]
    9c68:	10000001 	andne	r0, r0, r1
    9c6c:	00001f43 	andeq	r1, r0, r3, asr #30
    9c70:	005edc05 	subseq	sp, lr, r5, lsl #24
    9c74:	05100000 	ldreq	r0, [r0, #-0]
    9c78:	0500001f 	streq	r0, [r0, #-31]
    9c7c:	00005ed9 	ldrdeq	r5, [r0], -r9
    9c80:	1f4f1000 	svcne	0x004f1000
    9c84:	db050000 	blle	149c8c <_etext+0x142774>
    9c88:	0000005e 	andeq	r0, r0, lr, asr r0
    9c8c:	0003f900 	andeq	pc, r3, r0, lsl #18
    9c90:	4f000400 	svcmi	0x00000400
    9c94:	04000024 	streq	r0, [r0], #-36	; 0x24
    9c98:	00063901 	andeq	r3, r6, r1, lsl #18
    9c9c:	1f6e0100 	svcne	0x006e0100
    9ca0:	08930000 	ldmeq	r3, {}	; <UNPREDICTABLE>
    9ca4:	0e880000 	cdpeq	0, 8, cr0, cr8, cr0, {0}
    9ca8:	00000000 	andeq	r0, r0, r0
    9cac:	38700000 	ldmdacc	r0!, {}^	; <UNPREDICTABLE>
    9cb0:	04020000 	streq	r0, [r2], #-0
    9cb4:	0004da05 	andeq	sp, r4, r5, lsl #20
    9cb8:	05020200 	streq	r0, [r2, #-512]	; 0x200
    9cbc:	000006fc 	strdeq	r0, [r0], -ip
    9cc0:	1a060102 	bne	18a0d0 <_etext+0x182bb8>
    9cc4:	02000008 	andeq	r0, r0, #8
    9cc8:	02520704 	subseq	r0, r2, #4, 14	; 0x100000
    9ccc:	75030000 	strvc	r0, [r3, #-0]
    9cd0:	02003631 	andeq	r3, r0, #51380224	; 0x3100000
    9cd4:	00004c25 	andeq	r4, r0, r5, lsr #24
    9cd8:	07020200 	streq	r0, [r2, -r0, lsl #4]
    9cdc:	00000949 	andeq	r0, r0, r9, asr #18
    9ce0:	00387503 	eorseq	r7, r8, r3, lsl #10
    9ce4:	005d2602 	subseq	r2, sp, r2, lsl #12
    9ce8:	01020000 	mrseq	r0, (UNDEF: 2)
    9cec:	00081808 	andeq	r1, r8, r8, lsl #16
    9cf0:	53040400 	movwpl	r0, #17408	; 0x4400
    9cf4:	05000000 	streq	r0, [r0, #-0]
    9cf8:	000007c0 	andeq	r0, r0, r0, asr #15
    9cfc:	8f2d0301 	svchi	0x002d0301
    9d00:	06000000 	streq	r0, [r0], -r0
    9d04:	00000286 	andeq	r0, r0, r6, lsl #5
    9d08:	09a90600 	stmibeq	r9!, {r9, sl}
    9d0c:	06010000 	streq	r0, [r1], -r0
    9d10:	00000130 	andeq	r0, r0, r0, lsr r1
    9d14:	062b0602 	strteq	r0, [fp], -r2, lsl #12
    9d18:	00030000 	andeq	r0, r3, r0
    9d1c:	0007c107 	andeq	ip, r7, r7, lsl #2
    9d20:	6a340300 	bvs	d0a928 <_etext+0xd03410>
    9d24:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    9d28:	000005ff 	strdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    9d2c:	d738030c 	ldrle	r0, [r8, -ip, lsl #6]!
    9d30:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    9d34:	000001d7 	ldrdeq	r0, [r0], -r7
    9d38:	00415003 	subeq	r5, r1, r3
    9d3c:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    9d40:	0000086d 	andeq	r0, r0, sp, ror #16
    9d44:	00415103 	subeq	r5, r1, r3, lsl #2
    9d48:	09020000 	stmdbeq	r2, {}	; <UNPREDICTABLE>
    9d4c:	0000213a 	andeq	r2, r0, sl, lsr r1
    9d50:	00415203 	subeq	r5, r1, r3, lsl #4
    9d54:	09040000 	stmdbeq	r4, {}	; <UNPREDICTABLE>
    9d58:	00000738 	andeq	r0, r0, r8, lsr r7
    9d5c:	00e65303 	rsceq	r5, r6, r3, lsl #6
    9d60:	00080000 	andeq	r0, r8, r0
    9d64:	0000640a 	andeq	r6, r0, sl, lsl #8
    9d68:	0000e600 	andeq	lr, r0, r0, lsl #12
    9d6c:	00410b00 	subeq	r0, r1, r0, lsl #22
    9d70:	04000000 	streq	r0, [r0], #-0
    9d74:	0000d704 	andeq	sp, r0, r4, lsl #14
    9d78:	06000700 	streq	r0, [r0], -r0, lsl #14
    9d7c:	54030000 	strpl	r0, [r3], #-0
    9d80:	0000009a 	muleq	r0, sl, r0
    9d84:	0057420c 	subseq	r4, r7, ip, lsl #4
    9d88:	1b620302 	blne	188a998 <_etext+0x1883480>
    9d8c:	0d000001 	stceq	0, cr0, [r0, #-4]
    9d90:	00306262 	eorseq	r6, r0, r2, ror #4
    9d94:	00536503 	subseq	r6, r3, r3, lsl #10
    9d98:	0d000000 	stceq	0, cr0, [r0, #-0]
    9d9c:	00316262 	eorseq	r6, r1, r2, ror #4
    9da0:	00536603 	subseq	r6, r3, r3, lsl #12
    9da4:	00010000 	andeq	r0, r1, r0
    9da8:	5f03020e 	svcpl	0x0003020e
    9dac:	00000137 	andeq	r0, r0, r7, lsr r1
    9db0:	0300770f 	movweq	r7, #1807	; 0x70f
    9db4:	00004161 	andeq	r4, r0, r1, ror #2
    9db8:	77620f00 	strbvc	r0, [r2, -r0, lsl #30]!
    9dbc:	f7680300 			; <UNDEFINED> instruction: 0xf7680300
    9dc0:	00000000 	andeq	r0, r0, r0
    9dc4:	00093007 	andeq	r3, r9, r7
    9dc8:	1b690300 	blne	1a4a9d0 <_etext+0x1a434b8>
    9dcc:	08000001 	stmdaeq	r0, {r0}
    9dd0:	00000114 	andeq	r0, r0, r4, lsl r1
    9dd4:	d36b031c 	cmnle	fp, #28, 6	; 0x70000000
    9dd8:	09000001 	stmdbeq	r0, {r0}
    9ddc:	00000767 	andeq	r0, r0, r7, ror #14
    9de0:	00536d03 	subseq	r6, r3, r3, lsl #26
    9de4:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    9de8:	00000015 	andeq	r0, r0, r5, lsl r0
    9dec:	00536e03 	subseq	r6, r3, r3, lsl #28
    9df0:	09010000 	stmdbeq	r1, {}	; <UNPREDICTABLE>
    9df4:	00000311 	andeq	r0, r0, r1, lsl r3
    9df8:	01376f03 	teqeq	r7, r3, lsl #30
    9dfc:	09020000 	stmdbeq	r2, {}	; <UNPREDICTABLE>
    9e00:	00000148 	andeq	r0, r0, r8, asr #2
    9e04:	01377003 	teqeq	r7, r3
    9e08:	09040000 	stmdbeq	r4, {}	; <UNPREDICTABLE>
    9e0c:	000004eb 	andeq	r0, r0, fp, ror #9
    9e10:	01377103 	teqeq	r7, r3, lsl #2
    9e14:	09060000 	stmdbeq	r6, {}	; <UNPREDICTABLE>
    9e18:	000006ef 	andeq	r0, r0, pc, ror #13
    9e1c:	00537303 	subseq	r7, r3, r3, lsl #6
    9e20:	09080000 	stmdbeq	r8, {}	; <UNPREDICTABLE>
    9e24:	00000808 	andeq	r0, r0, r8, lsl #16
    9e28:	00537403 	subseq	r7, r3, r3, lsl #8
    9e2c:	09090000 	stmdbeq	r9, {}	; <UNPREDICTABLE>
    9e30:	00000507 	andeq	r0, r0, r7, lsl #10
    9e34:	00537503 	subseq	r7, r3, r3, lsl #10
    9e38:	090a0000 	stmdbeq	sl, {}	; <UNPREDICTABLE>
    9e3c:	0000054f 	andeq	r0, r0, pc, asr #10
    9e40:	00537603 	subseq	r7, r3, r3, lsl #12
    9e44:	090b0000 	stmdbeq	fp, {}	; <UNPREDICTABLE>
    9e48:	000005d6 	ldrdeq	r0, [r0], -r6
    9e4c:	00537703 	subseq	r7, r3, r3, lsl #14
    9e50:	090c0000 	stmdbeq	ip, {}	; <UNPREDICTABLE>
    9e54:	000007c8 	andeq	r0, r0, r8, asr #15
    9e58:	00ec7a03 	rsceq	r7, ip, r3, lsl #20
    9e5c:	00100000 	andseq	r0, r0, r0
    9e60:	00011507 	andeq	r1, r1, r7, lsl #10
    9e64:	427b0300 	rsbsmi	r0, fp, #0, 6
    9e68:	08000001 	stmdaeq	r0, {r0}
    9e6c:	000003a9 	andeq	r0, r0, r9, lsr #7
    9e70:	877d0334 			; <UNDEFINED> instruction: 0x877d0334
    9e74:	09000002 	stmdbeq	r0, {r1}
    9e78:	00000296 	muleq	r0, r6, r2
    9e7c:	02887f03 	addeq	r7, r8, #3, 30
    9e80:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    9e84:	000004b8 			; <UNDEFINED> instruction: 0x000004b8
    9e88:	02888003 	addeq	r8, r8, #3
    9e8c:	09040000 	stmdbeq	r4, {}	; <UNPREDICTABLE>
    9e90:	00000937 	andeq	r0, r0, r7, lsr r9
    9e94:	02888303 	addeq	r8, r8, #201326592	; 0xc000000
    9e98:	09080000 	stmdbeq	r8, {}	; <UNPREDICTABLE>
    9e9c:	00000778 	andeq	r0, r0, r8, ror r7
    9ea0:	02888403 	addeq	r8, r8, #50331648	; 0x3000000
    9ea4:	090c0000 	stmdbeq	ip, {}	; <UNPREDICTABLE>
    9ea8:	000002c3 	andeq	r0, r0, r3, asr #5
    9eac:	029d9603 	addseq	r9, sp, #3145728	; 0x300000
    9eb0:	09100000 	ldmdbeq	r0, {}	; <UNPREDICTABLE>
    9eb4:	0000006d 	andeq	r0, r0, sp, rrx
    9eb8:	029da103 	addseq	sl, sp, #-1073741824	; 0xc0000000
    9ebc:	09140000 	ldmdbeq	r4, {}	; <UNPREDICTABLE>
    9ec0:	000009c5 	andeq	r0, r0, r5, asr #19
    9ec4:	02b7ab03 	adcseq	sl, r7, #3072	; 0xc00
    9ec8:	09180000 	ldmdbeq	r8, {}	; <UNPREDICTABLE>
    9ecc:	000002d7 	ldrdeq	r0, [r0], -r7
    9ed0:	00e6ad03 	rsceq	sl, r6, r3, lsl #26
    9ed4:	091c0000 	ldmdbeq	ip, {}	; <UNPREDICTABLE>
    9ed8:	000003b9 			; <UNDEFINED> instruction: 0x000003b9
    9edc:	00e6ae03 	rsceq	sl, r6, r3, lsl #28
    9ee0:	09200000 	stmdbeq	r0!, {}	; <UNPREDICTABLE>
    9ee4:	000001c3 	andeq	r0, r0, r3, asr #3
    9ee8:	00e6af03 	rsceq	sl, r6, r3, lsl #30
    9eec:	09240000 	stmdbeq	r4!, {}	; <UNPREDICTABLE>
    9ef0:	00000342 	andeq	r0, r0, r2, asr #6
    9ef4:	00e6b003 	rsceq	fp, r6, r3
    9ef8:	09280000 	stmdbeq	r8!, {}	; <UNPREDICTABLE>
    9efc:	00000467 	andeq	r0, r0, r7, ror #8
    9f00:	0064b203 	rsbeq	fp, r4, r3, lsl #4
    9f04:	092c0000 	stmdbeq	ip!, {}	; <UNPREDICTABLE>
    9f08:	00002137 	andeq	r2, r0, r7, lsr r1
    9f0c:	0053b303 	subseq	fp, r3, r3, lsl #6
    9f10:	00300000 	eorseq	r0, r0, r0
    9f14:	87040410 	smladhi	r4, r0, r4, r0
    9f18:	0a000002 	beq	9f28 <_etext+0x2a10>
    9f1c:	0000008f 	andeq	r0, r0, pc, lsl #1
    9f20:	0000029d 	muleq	r0, sp, r2
    9f24:	0000530b 	andeq	r5, r0, fp, lsl #6
    9f28:	04040000 	streq	r0, [r4], #-0
    9f2c:	0000028e 	andeq	r0, r0, lr, lsl #5
    9f30:	00008f0a 	andeq	r8, r0, sl, lsl #30
    9f34:	0002b700 	andeq	fp, r2, r0, lsl #14
    9f38:	00530b00 	subseq	r0, r3, r0, lsl #22
    9f3c:	530b0000 	movwpl	r0, #45056	; 0xb000
    9f40:	00000000 	andeq	r0, r0, r0
    9f44:	02a30404 	adceq	r0, r3, #4, 8	; 0x4000000
    9f48:	aa070000 	bge	1c9f50 <_etext+0x1c2a38>
    9f4c:	03000003 	movweq	r0, #3
    9f50:	0001deb5 			; <UNDEFINED> instruction: 0x0001deb5
    9f54:	008a0800 	addeq	r0, sl, r0, lsl #16
    9f58:	03240000 	teqeq	r4, #0
    9f5c:	000341b7 			; <UNDEFINED> instruction: 0x000341b7
    9f60:	05a00900 	streq	r0, [r0, #2304]!	; 0x900
    9f64:	b9030000 	stmdblt	r3, {}	; <UNPREDICTABLE>
    9f68:	00000288 	andeq	r0, r0, r8, lsl #5
    9f6c:	041d0900 	ldreq	r0, [sp], #-2304	; 0x900
    9f70:	ba030000 	blt	c9f78 <_etext+0xc2a60>
    9f74:	00000288 	andeq	r0, r0, r8, lsl #5
    9f78:	029b0904 	addseq	r0, fp, #4, 18	; 0x10000
    9f7c:	bb030000 	bllt	c9f84 <_etext+0xc2a6c>
    9f80:	00000288 	andeq	r0, r0, r8, lsl #5
    9f84:	04330908 	ldrteq	r0, [r3], #-2312	; 0x908
    9f88:	bc030000 	stclt	0, cr0, [r3], {-0}
    9f8c:	00000288 	andeq	r0, r0, r8, lsl #5
    9f90:	00a2090c 	adceq	r0, r2, ip, lsl #18
    9f94:	bd030000 	stclt	0, cr0, [r3, #-0]
    9f98:	00000288 	andeq	r0, r0, r8, lsl #5
    9f9c:	07410910 	smlaldeq	r0, r1, r0, r9
    9fa0:	be030000 	cdplt	0, 0, cr0, cr3, cr0, {0}
    9fa4:	00000288 	andeq	r0, r0, r8, lsl #5
    9fa8:	08f80914 	ldmeq	r8!, {r2, r4, r8, fp}^
    9fac:	bf030000 	svclt	0x00030000
    9fb0:	00000288 	andeq	r0, r0, r8, lsl #5
    9fb4:	01910918 	orrseq	r0, r1, r8, lsl r9
    9fb8:	c0030000 	andgt	r0, r3, r0
    9fbc:	00000288 	andeq	r0, r0, r8, lsl #5
    9fc0:	02ad091c 	adceq	r0, sp, #28, 18	; 0x70000
    9fc4:	c1030000 	mrsgt	r0, (UNDEF: 3)
    9fc8:	00000288 	andeq	r0, r0, r8, lsl #5
    9fcc:	8b070020 	blhi	1ca054 <_etext+0x1c2b3c>
    9fd0:	03000000 	movweq	r0, #0
    9fd4:	0002c8c3 	andeq	ip, r2, r3, asr #17
    9fd8:	02921100 	addseq	r1, r2, #0, 2
    9fdc:	35010000 	strcc	r0, [r1, #-0]
    9fe0:	00005e48 	andeq	r5, r0, r8, asr #28
    9fe4:	00000038 	andeq	r0, r0, r8, lsr r0
    9fe8:	eb129c01 	bl	4b0ff4 <_etext+0x4a9adc>
    9fec:	03000002 	movweq	r0, #2
    9ff0:	0002bdec 	andeq	fp, r2, ip, ror #27
    9ff4:	1f821200 	svcne	0x00821200
    9ff8:	ed030000 	stc	0, cr0, [r3, #-0]
    9ffc:	00000341 	andeq	r0, r0, r1, asr #6
    a000:	001f9913 	andseq	r9, pc, r3, lsl r9	; <UNPREDICTABLE>
    a004:	d3270100 	teqle	r7, #0, 2
    a008:	05000001 	streq	r0, [r0, #-1]
    a00c:	00058803 	andeq	r8, r5, r3, lsl #16
    a010:	1f5c1320 	svcne	0x005c1320
    a014:	18010000 	stmdane	r1, {}	; <UNPREDICTABLE>
    a018:	00000053 	andeq	r0, r0, r3, asr r0
    a01c:	05840305 	streq	r0, [r4, #773]	; 0x305
    a020:	e8132000 	ldmda	r3, {sp}
    a024:	01000001 	tsteq	r0, r1
    a028:	0003a61d 	andeq	sl, r3, sp, lsl r6
    a02c:	a8030500 	stmdage	r3, {r8, sl}
    a030:	04200005 	strteq	r0, [r0], #-5
    a034:	0001d304 	andeq	sp, r1, r4, lsl #6
    a038:	013e1300 	teqeq	lr, r0, lsl #6
    a03c:	20010000 	andcs	r0, r1, r0
    a040:	000003bd 			; <UNDEFINED> instruction: 0x000003bd
    a044:	05800305 	streq	r0, [r0, #773]	; 0x305
    a048:	04042000 	streq	r2, [r4], #-0
    a04c:	000002bd 			; <UNDEFINED> instruction: 0x000002bd
    a050:	001f8113 	andseq	r8, pc, r3, lsl r1	; <UNPREDICTABLE>
    a054:	d4280100 	strtle	r0, [r8], #-256	; 0x100
    a058:	05000003 	streq	r0, [r0, #-3]
    a05c:	0005a403 	andeq	sl, r5, r3, lsl #8
    a060:	41040420 	tstmi	r4, r0, lsr #8
    a064:	13000003 	movwne	r0, #3
    a068:	00001f64 	andeq	r1, r0, r4, ror #30
    a06c:	00412501 	subeq	r2, r1, r1, lsl #10
    a070:	03050000 	movweq	r0, #20480	; 0x5000
    a074:	2000057c 	andcs	r0, r0, ip, ror r5
    a078:	00051d13 	andeq	r1, r5, r3, lsl sp
    a07c:	41260100 	teqmi	r6, r0, lsl #2
    a080:	05000000 	streq	r0, [r0, #-0]
    a084:	0005ac03 	andeq	sl, r5, r3, lsl #24
    a088:	0de00020 	stcleq	0, cr0, [r0, #128]!	; 0x80
    a08c:	00040000 	andeq	r0, r4, r0
    a090:	00002552 	andeq	r2, r0, r2, asr r5
    a094:	06390104 	ldrteq	r0, [r9], -r4, lsl #2
    a098:	a5010000 	strge	r0, [r1, #-0]
    a09c:	9300001f 	movwls	r0, #31
    a0a0:	d0000008 	andle	r0, r0, r8
    a0a4:	0000000e 	andeq	r0, r0, lr
    a0a8:	d7000000 	strle	r0, [r0, -r0]
    a0ac:	02000038 	andeq	r0, r0, #56	; 0x38
    a0b0:	04da0504 	ldrbeq	r0, [sl], #1284	; 0x504
    a0b4:	02020000 	andeq	r0, r2, #0
    a0b8:	0006fc05 	andeq	pc, r6, r5, lsl #24
    a0bc:	06010200 	streq	r0, [r1], -r0, lsl #4
    a0c0:	0000081a 	andeq	r0, r0, sl, lsl r8
    a0c4:	32337503 	eorscc	r7, r3, #12582912	; 0xc00000
    a0c8:	45240200 	strmi	r0, [r4, #-512]!	; 0x200
    a0cc:	02000000 	andeq	r0, r0, #0
    a0d0:	02520704 	subseq	r0, r2, #4, 14	; 0x100000
    a0d4:	75030000 	strvc	r0, [r3, #-0]
    a0d8:	02003631 	andeq	r3, r0, #51380224	; 0x3100000
    a0dc:	00005725 	andeq	r5, r0, r5, lsr #14
    a0e0:	07020200 	streq	r0, [r2, -r0, lsl #4]
    a0e4:	00000949 	andeq	r0, r0, r9, asr #18
    a0e8:	00387503 	eorseq	r7, r8, r3, lsl #10
    a0ec:	00682602 	rsbeq	r2, r8, r2, lsl #12
    a0f0:	01020000 	mrseq	r0, (UNDEF: 2)
    a0f4:	00081808 	andeq	r1, r8, r8, lsl #16
    a0f8:	035a0400 	cmpeq	sl, #0, 8
    a0fc:	2c020000 	stccs	0, cr0, [r2], {-0}
    a100:	0000007a 	andeq	r0, r0, sl, ror r0
    a104:	00004505 	andeq	r4, r0, r5, lsl #10
    a108:	02010600 	andeq	r0, r1, #0, 12
    a10c:	00009436 	andeq	r9, r0, r6, lsr r4
    a110:	07530700 	ldrbeq	r0, [r3, -r0, lsl #14]
    a114:	07000000 	streq	r0, [r0, -r0]
    a118:	000001a7 	andeq	r0, r0, r7, lsr #3
    a11c:	2d040001 	stccs	0, cr0, [r4, #-4]
    a120:	02000005 	andeq	r0, r0, #5
    a124:	00007f39 	andeq	r7, r0, r9, lsr pc
    a128:	023d0800 	eorseq	r0, sp, #0, 16
    a12c:	03010000 	movweq	r0, #4096	; 0x1000
    a130:	0000c416 	andeq	ip, r0, r6, lsl r4
    a134:	05320700 	ldreq	r0, [r2, #-1792]!	; 0x700
    a138:	07000000 	streq	r0, [r0, -r0]
    a13c:	00000724 	andeq	r0, r0, r4, lsr #14
    a140:	017e0701 	cmneq	lr, r1, lsl #14
    a144:	07020000 	streq	r0, [r2, -r0]
    a148:	00000920 	andeq	r0, r0, r0, lsr #18
    a14c:	8f080003 	svchi	0x00080003
    a150:	01000000 	mrseq	r0, (UNDEF: 0)
    a154:	01251f03 	teqeq	r5, r3, lsl #30
    a158:	17070000 	strne	r0, [r7, -r0]
    a15c:	00000021 	andeq	r0, r0, r1, lsr #32
    a160:	00234607 	eoreq	r4, r3, r7, lsl #12
    a164:	94070100 	strls	r0, [r7], #-256	; 0x100
    a168:	0200000f 	andeq	r0, r0, #15
    a16c:	00212207 	eoreq	r2, r1, r7, lsl #4
    a170:	9e070300 	cdpls	3, 0, cr0, cr7, cr0, {0}
    a174:	0400000f 	streq	r0, [r0], #-15
    a178:	0022d507 	eoreq	sp, r2, r7, lsl #10
    a17c:	05070500 	streq	r0, [r7, #-1280]	; 0x500
    a180:	06000023 	streq	r0, [r0], -r3, lsr #32
    a184:	00218c07 	eoreq	r8, r1, r7, lsl #24
    a188:	eb070700 	bl	1cbd90 <_etext+0x1c4878>
    a18c:	08000021 	stmdaeq	r0, {r0, r5}
    a190:	00223c07 	eoreq	r3, r2, r7, lsl #24
    a194:	ed070900 	stc	9, cr0, [r7, #-0]
    a198:	0a000020 	beq	a220 <_etext+0x2d08>
    a19c:	00219b07 	eoreq	r9, r1, r7, lsl #22
    a1a0:	5e070b00 	vmlapl.f64	d0, d7, d0
    a1a4:	0c000022 	stceq	0, cr0, [r0], {34}	; 0x22
    a1a8:	00216a07 	eoreq	r6, r1, r7, lsl #20
    a1ac:	08000c00 	stmdaeq	r0, {sl, fp}
    a1b0:	0000220c 	andeq	r2, r0, ip, lsl #4
    a1b4:	50320301 	eorspl	r0, r2, r1, lsl #6
    a1b8:	07000001 	streq	r0, [r0, -r1]
    a1bc:	00002057 	andeq	r2, r0, r7, asr r0
    a1c0:	22b60701 	adcscs	r0, r6, #262144	; 0x40000
    a1c4:	07020000 	streq	r0, [r2, -r0]
    a1c8:	00002069 	andeq	r2, r0, r9, rrx
    a1cc:	226d0703 	rsbcs	r0, sp, #786432	; 0xc0000
    a1d0:	07040000 	streq	r0, [r4, -r0]
    a1d4:	000022a2 	andeq	r2, r0, r2, lsr #5
    a1d8:	a9080005 	stmdbge	r8, {r0, r2}
    a1dc:	01000021 	tsteq	r0, r1, lsr #32
    a1e0:	01693c03 	cmneq	r9, r3, lsl #24
    a1e4:	b8070000 	stmdalt	r7, {}	; <UNPREDICTABLE>
    a1e8:	0000001f 	andeq	r0, r0, pc, lsl r0
    a1ec:	00201607 	eoreq	r1, r0, r7, lsl #12
    a1f0:	08000100 	stmdaeq	r0, {r8}
    a1f4:	000021fd 	strdeq	r2, [r0], -sp
    a1f8:	b2160401 	andslt	r0, r6, #16777216	; 0x1000000
    a1fc:	07000001 	streq	r0, [r0, -r1]
    a200:	00002321 	andeq	r2, r0, r1, lsr #6
    a204:	221d0700 	andscs	r0, sp, #0, 14
    a208:	07010000 	streq	r0, [r1, -r0]
    a20c:	000020a1 	andeq	r2, r0, r1, lsr #1
    a210:	23590702 	cmpcs	r9, #524288	; 0x80000
    a214:	07030000 	streq	r0, [r3, -r0]
    a218:	0000209c 	muleq	r0, ip, r0
    a21c:	23540704 	cmpcs	r4, #4, 14	; 0x100000
    a220:	07050000 	streq	r0, [r5, -r0]
    a224:	00002337 	andeq	r2, r0, r7, lsr r3
    a228:	224e0706 	subcs	r0, lr, #1572864	; 0x180000
    a22c:	07070000 	streq	r0, [r7, -r0]
    a230:	0000202b 	andeq	r2, r0, fp, lsr #32
    a234:	20dd0708 	sbcscs	r0, sp, r8, lsl #14
    a238:	00090000 	andeq	r0, r9, r0
    a23c:	00003309 	andeq	r3, r0, r9, lsl #6
    a240:	24040800 	strcs	r0, [r4], #-2048	; 0x800
    a244:	000001d7 	ldrdeq	r0, [r0], -r7
    a248:	0002e00a 	andeq	lr, r2, sl
    a24c:	d7260400 	strle	r0, [r6, -r0, lsl #8]!
    a250:	00000001 	andeq	r0, r0, r1
    a254:	0003f10a 	andeq	pc, r3, sl, lsl #2
    a258:	4c270400 	cfstrsmi	mvf0, [r7], #-0
    a25c:	04000000 	streq	r0, [r0], #-0
    a260:	5e040b00 	vmlapl.f64	d0, d4, d0
    a264:	04000000 	streq	r0, [r0], #-0
    a268:	00000572 	andeq	r0, r0, r2, ror r5
    a26c:	01b22904 			; <UNDEFINED> instruction: 0x01b22904
    a270:	c0080000 	andgt	r0, r8, r0
    a274:	01000007 	tsteq	r0, r7
    a278:	020d2d04 	andeq	r2, sp, #4, 26	; 0x100
    a27c:	86070000 	strhi	r0, [r7], -r0
    a280:	00000002 	andeq	r0, r0, r2
    a284:	0009a907 	andeq	sl, r9, r7, lsl #18
    a288:	30070100 	andcc	r0, r7, r0, lsl #2
    a28c:	02000001 	andeq	r0, r0, #1
    a290:	00062b07 	andeq	r2, r6, r7, lsl #22
    a294:	04000300 	streq	r0, [r0], #-768	; 0x300
    a298:	000007c1 	andeq	r0, r0, r1, asr #15
    a29c:	01e83404 	mvneq	r3, r4, lsl #8
    a2a0:	ff090000 			; <UNDEFINED> instruction: 0xff090000
    a2a4:	0c000005 	stceq	0, cr0, [r0], {5}
    a2a8:	02553804 	subseq	r3, r5, #4, 16	; 0x40000
    a2ac:	d70a0000 	strle	r0, [sl, -r0]
    a2b0:	04000001 	streq	r0, [r0], #-1
    a2b4:	00004c50 	andeq	r4, r0, r0, asr ip
    a2b8:	6d0a0000 	stcvs	0, cr0, [sl, #-0]
    a2bc:	04000008 	streq	r0, [r0], #-8
    a2c0:	00004c51 	andeq	r4, r0, r1, asr ip
    a2c4:	3a0a0200 	bcc	28aacc <_etext+0x2835b4>
    a2c8:	04000021 	streq	r0, [r0], #-33	; 0x21
    a2cc:	00004c52 	andeq	r4, r0, r2, asr ip
    a2d0:	380a0400 	stmdacc	sl, {sl}
    a2d4:	04000007 	streq	r0, [r0], #-7
    a2d8:	00026453 	andeq	r6, r2, r3, asr r4
    a2dc:	0c000800 	stceq	8, cr0, [r0], {-0}
    a2e0:	000001d7 	ldrdeq	r0, [r0], -r7
    a2e4:	00000264 	andeq	r0, r0, r4, ror #4
    a2e8:	00004c0d 	andeq	r4, r0, sp, lsl #24
    a2ec:	040b0000 	streq	r0, [fp], #-0
    a2f0:	00000255 	andeq	r0, r0, r5, asr r2
    a2f4:	00060004 	andeq	r0, r6, r4
    a2f8:	18540400 	ldmdane	r4, {sl}^
    a2fc:	09000002 	stmdbeq	r0, {r1}
    a300:	00000623 	andeq	r0, r0, r3, lsr #12
    a304:	9a580402 	bls	160b314 <_etext+0x1603dfc>
    a308:	0a000002 	beq	a318 <_etext+0x2e00>
    a30c:	00000370 	andeq	r0, r0, r0, ror r3
    a310:	005e5a04 	subseq	r5, lr, r4, lsl #20
    a314:	0a000000 	beq	a31c <_etext+0x2e04>
    a318:	0000058c 	andeq	r0, r0, ip, lsl #11
    a31c:	005e5b04 	subseq	r5, lr, r4, lsl #22
    a320:	00010000 	andeq	r0, r1, r0
    a324:	00062404 	andeq	r2, r6, r4, lsl #8
    a328:	755d0400 	ldrbvc	r0, [sp, #-1024]	; 0x400
    a32c:	0e000002 	cdpeq	0, 0, cr0, cr0, cr2, {0}
    a330:	02005742 	andeq	r5, r0, #17301504	; 0x1080000
    a334:	02c96204 	sbceq	r6, r9, #4, 4	; 0x40000000
    a338:	620f0000 	andvs	r0, pc, #0
    a33c:	04003062 	streq	r3, [r0], #-98	; 0x62
    a340:	00005e65 	andeq	r5, r0, r5, ror #28
    a344:	620f0000 	andvs	r0, pc, #0
    a348:	04003162 	streq	r3, [r0], #-354	; 0x162
    a34c:	00005e66 	andeq	r5, r0, r6, ror #28
    a350:	10000100 	andne	r0, r0, r0, lsl #2
    a354:	e55f0402 	ldrb	r0, [pc, #-1026]	; 9f5a <_etext+0x2a42>
    a358:	11000002 	tstne	r0, r2
    a35c:	61040077 	tstvs	r4, r7, ror r0
    a360:	0000004c 	andeq	r0, r0, ip, asr #32
    a364:	00776211 	rsbseq	r6, r7, r1, lsl r2
    a368:	02a56804 	adceq	r6, r5, #4, 16	; 0x40000
    a36c:	04000000 	streq	r0, [r0], #-0
    a370:	00000930 	andeq	r0, r0, r0, lsr r9
    a374:	02c96904 	sbceq	r6, r9, #4, 18	; 0x10000
    a378:	14090000 	strne	r0, [r9], #-0
    a37c:	1c000001 	stcne	0, cr0, [r0], {1}
    a380:	03816b04 	orreq	r6, r1, #4, 22	; 0x1000
    a384:	670a0000 	strvs	r0, [sl, -r0]
    a388:	04000007 	streq	r0, [r0], #-7
    a38c:	00005e6d 	andeq	r5, r0, sp, ror #28
    a390:	150a0000 	strne	r0, [sl, #-0]
    a394:	04000000 	streq	r0, [r0], #-0
    a398:	00005e6e 	andeq	r5, r0, lr, ror #28
    a39c:	110a0100 	mrsne	r0, (UNDEF: 26)
    a3a0:	04000003 	streq	r0, [r0], #-3
    a3a4:	0002e56f 	andeq	lr, r2, pc, ror #10
    a3a8:	480a0200 	stmdami	sl, {r9}
    a3ac:	04000001 	streq	r0, [r0], #-1
    a3b0:	0002e570 	andeq	lr, r2, r0, ror r5
    a3b4:	eb0a0400 	bl	28b3bc <_etext+0x283ea4>
    a3b8:	04000004 	streq	r0, [r0], #-4
    a3bc:	0002e571 	andeq	lr, r2, r1, ror r5
    a3c0:	ef0a0600 	svc	0x000a0600
    a3c4:	04000006 	streq	r0, [r0], #-6
    a3c8:	00005e73 	andeq	r5, r0, r3, ror lr
    a3cc:	080a0800 	stmdaeq	sl, {fp}
    a3d0:	04000008 	streq	r0, [r0], #-8
    a3d4:	00005e74 	andeq	r5, r0, r4, ror lr
    a3d8:	070a0900 	streq	r0, [sl, -r0, lsl #18]
    a3dc:	04000005 	streq	r0, [r0], #-5
    a3e0:	00005e75 	andeq	r5, r0, r5, ror lr
    a3e4:	4f0a0a00 	svcmi	0x000a0a00
    a3e8:	04000005 	streq	r0, [r0], #-5
    a3ec:	00005e76 	andeq	r5, r0, r6, ror lr
    a3f0:	d60a0b00 	strle	r0, [sl], -r0, lsl #22
    a3f4:	04000005 	streq	r0, [r0], #-5
    a3f8:	00005e77 	andeq	r5, r0, r7, ror lr
    a3fc:	c80a0c00 	stmdagt	sl, {sl, fp}
    a400:	04000007 	streq	r0, [r0], #-7
    a404:	00026a7a 	andeq	r6, r2, sl, ror sl
    a408:	04001000 	streq	r1, [r0], #-0
    a40c:	00000115 	andeq	r0, r0, r5, lsl r1
    a410:	02f07b04 	rscseq	r7, r0, #4, 22	; 0x1000
    a414:	a9090000 	stmdbge	r9, {}	; <UNPREDICTABLE>
    a418:	34000003 	strcc	r0, [r0], #-3
    a41c:	04357d04 	ldrteq	r7, [r5], #-3332	; 0xd04
    a420:	960a0000 	strls	r0, [sl], -r0
    a424:	04000002 	streq	r0, [r0], #-2
    a428:	0004367f 	andeq	r3, r4, pc, ror r6
    a42c:	b80a0000 	stmdalt	sl, {}	; <UNPREDICTABLE>
    a430:	04000004 	streq	r0, [r0], #-4
    a434:	00043680 	andeq	r3, r4, r0, lsl #13
    a438:	370a0400 	strcc	r0, [sl, -r0, lsl #8]
    a43c:	04000009 	streq	r0, [r0], #-9
    a440:	00043683 	andeq	r3, r4, r3, lsl #13
    a444:	780a0800 	stmdavc	sl, {fp}
    a448:	04000007 	streq	r0, [r0], #-7
    a44c:	00043684 	andeq	r3, r4, r4, lsl #13
    a450:	c30a0c00 	movwgt	r0, #44032	; 0xac00
    a454:	04000002 	streq	r0, [r0], #-2
    a458:	00044b96 	muleq	r4, r6, fp
    a45c:	6d0a1000 	stcvs	0, cr1, [sl, #-0]
    a460:	04000000 	streq	r0, [r0], #-0
    a464:	00044ba1 	andeq	r4, r4, r1, lsr #23
    a468:	c50a1400 	strgt	r1, [sl, #-1024]	; 0x400
    a46c:	04000009 	streq	r0, [r0], #-9
    a470:	000465ab 	andeq	r6, r4, fp, lsr #11
    a474:	d70a1800 	strle	r1, [sl, -r0, lsl #16]
    a478:	04000002 	streq	r0, [r0], #-2
    a47c:	000264ad 	andeq	r6, r2, sp, lsr #9
    a480:	b90a1c00 	stmdblt	sl, {sl, fp, ip}
    a484:	04000003 	streq	r0, [r0], #-3
    a488:	000264ae 	andeq	r6, r2, lr, lsr #9
    a48c:	c30a2000 	movwgt	r2, #40960	; 0xa000
    a490:	04000001 	streq	r0, [r0], #-1
    a494:	000264af 	andeq	r6, r2, pc, lsr #9
    a498:	420a2400 	andmi	r2, sl, #0, 8
    a49c:	04000003 	streq	r0, [r0], #-3
    a4a0:	000264b0 			; <UNDEFINED> instruction: 0x000264b0
    a4a4:	670a2800 	strvs	r2, [sl, -r0, lsl #16]
    a4a8:	04000004 	streq	r0, [r0], #-4
    a4ac:	0001d7b2 			; <UNDEFINED> instruction: 0x0001d7b2
    a4b0:	370a2c00 	strcc	r2, [sl, -r0, lsl #24]
    a4b4:	04000021 	streq	r0, [r0], #-33	; 0x21
    a4b8:	00005eb3 			; <UNDEFINED> instruction: 0x00005eb3
    a4bc:	12003000 	andne	r3, r0, #0
    a4c0:	0435040b 	ldrteq	r0, [r5], #-1035	; 0x40b
    a4c4:	0d0c0000 	stceq	0, cr0, [ip, #-0]
    a4c8:	4b000002 	blmi	a4d8 <_etext+0x2fc0>
    a4cc:	0d000004 	stceq	0, cr0, [r0, #-16]
    a4d0:	0000005e 	andeq	r0, r0, lr, asr r0
    a4d4:	3c040b00 	stccc	11, cr0, [r4], {-0}
    a4d8:	0c000004 	stceq	0, cr0, [r0], {4}
    a4dc:	0000020d 	andeq	r0, r0, sp, lsl #4
    a4e0:	00000465 	andeq	r0, r0, r5, ror #8
    a4e4:	00005e0d 	andeq	r5, r0, sp, lsl #28
    a4e8:	005e0d00 	subseq	r0, lr, r0, lsl #26
    a4ec:	0b000000 	bleq	a4f4 <_etext+0x2fdc>
    a4f0:	00045104 	andeq	r5, r4, r4, lsl #2
    a4f4:	03aa0400 			; <UNDEFINED> instruction: 0x03aa0400
    a4f8:	b5040000 	strlt	r0, [r4, #-0]
    a4fc:	0000038c 	andeq	r0, r0, ip, lsl #7
    a500:	00008a09 	andeq	r8, r0, r9, lsl #20
    a504:	b7042400 	strlt	r2, [r4, -r0, lsl #8]
    a508:	000004ef 	andeq	r0, r0, pc, ror #9
    a50c:	0005a00a 	andeq	sl, r5, sl
    a510:	36b90400 	ldrtcc	r0, [r9], r0, lsl #8
    a514:	00000004 	andeq	r0, r0, r4
    a518:	00041d0a 	andeq	r1, r4, sl, lsl #26
    a51c:	36ba0400 	ldrtcc	r0, [sl], r0, lsl #8
    a520:	04000004 	streq	r0, [r0], #-4
    a524:	00029b0a 	andeq	r9, r2, sl, lsl #22
    a528:	36bb0400 	ldrtcc	r0, [fp], r0, lsl #8
    a52c:	08000004 	stmdaeq	r0, {r2}
    a530:	0004330a 	andeq	r3, r4, sl, lsl #6
    a534:	36bc0400 	ldrtcc	r0, [ip], r0, lsl #8
    a538:	0c000004 	stceq	0, cr0, [r0], {4}
    a53c:	0000a20a 	andeq	sl, r0, sl, lsl #4
    a540:	36bd0400 	ldrtcc	r0, [sp], r0, lsl #8
    a544:	10000004 	andne	r0, r0, r4
    a548:	0007410a 	andeq	r4, r7, sl, lsl #2
    a54c:	36be0400 	ldrtcc	r0, [lr], r0, lsl #8
    a550:	14000004 	strne	r0, [r0], #-4
    a554:	0008f80a 	andeq	pc, r8, sl, lsl #16
    a558:	36bf0400 	ldrtcc	r0, [pc], r0, lsl #8
    a55c:	18000004 	stmdane	r0, {r2}
    a560:	0001910a 	andeq	r9, r1, sl, lsl #2
    a564:	36c00400 	strbcc	r0, [r0], r0, lsl #8
    a568:	1c000004 	stcne	0, cr0, [r0], {4}
    a56c:	0002ad0a 	andeq	sl, r2, sl, lsl #26
    a570:	36c10400 	strbcc	r0, [r1], r0, lsl #8
    a574:	20000004 	andcs	r0, r0, r4
    a578:	008b0400 	addeq	r0, fp, r0, lsl #8
    a57c:	c3040000 	movwgt	r0, #16384	; 0x4000
    a580:	00000476 	andeq	r0, r0, r6, ror r4
    a584:	0021bb13 	eoreq	fp, r1, r3, lsl fp
    a588:	d7350100 	ldrle	r0, [r5, -r0, lsl #2]!
    a58c:	80000001 	andhi	r0, r0, r1
    a590:	2400005e 	strcs	r0, [r0], #-94	; 0x5e
    a594:	01000000 	mrseq	r0, (UNDEF: 0)
    a598:	0005239c 	muleq	r5, ip, r3
    a59c:	0c0f1400 	cfstrseq	mvf1, [pc], {-0}
    a5a0:	35010000 	strcc	r0, [r1, #-0]
    a5a4:	0000004c 	andeq	r0, r0, ip, asr #32
    a5a8:	000091fa 	strdeq	r9, [r0], -sl
    a5ac:	21761300 	cmncs	r6, r0, lsl #6
    a5b0:	63010000 	movwvs	r0, #4096	; 0x1000
    a5b4:	000001d7 	ldrdeq	r0, [r0], -r7
    a5b8:	00005ea4 	andeq	r5, r0, r4, lsr #29
    a5bc:	00000024 	andeq	r0, r0, r4, lsr #32
    a5c0:	054c9c01 	strbeq	r9, [ip, #-3073]	; 0xc01
    a5c4:	0f140000 	svceq	0x00140000
    a5c8:	0100000c 	tsteq	r0, ip
    a5cc:	00004c63 	andeq	r4, r0, r3, ror #24
    a5d0:	00921b00 	addseq	r1, r2, r0, lsl #22
    a5d4:	8f130000 	svchi	0x00130000
    a5d8:	01000022 	tsteq	r0, r2, lsr #32
    a5dc:	0001d79b 	muleq	r1, fp, r7
    a5e0:	005ec800 	subseq	ip, lr, r0, lsl #16
    a5e4:	00009000 	andeq	r9, r0, r0
    a5e8:	b69c0100 	ldrlt	r0, [ip], r0, lsl #2
    a5ec:	14000005 	strne	r0, [r0], #-5
    a5f0:	00000c0f 	andeq	r0, r0, pc, lsl #24
    a5f4:	004c9b01 	subeq	r9, ip, r1, lsl #22
    a5f8:	923c0000 	eorsls	r0, ip, #0
    a5fc:	e8150000 	ldmda	r5, {}	; <UNPREDICTABLE>
    a600:	1c00005e 	stcne	0, cr0, [r0], {94}	; 0x5e
    a604:	91000000 	mrsls	r0, (UNDEF: 0)
    a608:	16000005 	strne	r0, [r0], -r5
    a60c:	00000810 	andeq	r0, r0, r0, lsl r8
    a610:	005ea901 	subseq	sl, lr, r1, lsl #18
    a614:	925d0000 	subsls	r0, sp, #0
    a618:	17000000 	strne	r0, [r0, -r0]
    a61c:	00005f0c 	andeq	r5, r0, ip, lsl #30
    a620:	00000030 	andeq	r0, r0, r0, lsr r0
    a624:	0022e116 	eoreq	lr, r2, r6, lsl r1
    a628:	5ec30100 	polpls	f0, f3, f0
    a62c:	71000000 	mrsvc	r0, (UNDEF: 0)
    a630:	18000092 	stmdane	r0, {r1, r4, r7}
    a634:	000022fd 	strdeq	r2, [r0], -sp
    a638:	005ec401 	subseq	ip, lr, r1, lsl #8
    a63c:	00000000 	andeq	r0, r0, r0
    a640:	00200a19 	eoreq	r0, r0, r9, lsl sl
    a644:	01e00100 	mvneq	r0, r0, lsl #2
    a648:	00005f58 	andeq	r5, r0, r8, asr pc
    a64c:	000000a8 	andeq	r0, r0, r8, lsr #1
    a650:	067b9c01 	ldrbteq	r9, [fp], -r1, lsl #24
    a654:	cd1a0000 	ldcgt	0, cr0, [sl, #-0]
    a658:	01000022 	tsteq	r0, r2, lsr #32
    a65c:	067b01e2 	ldrbteq	r0, [fp], -r2, ror #3
    a660:	92a20000 	adcls	r0, r2, #0
    a664:	821a0000 	andshi	r0, sl, #0
    a668:	01000022 	tsteq	r0, r2, lsr #32
    a66c:	003a01e3 	eorseq	r0, sl, r3, ror #3
    a670:	92b70000 	adcsls	r0, r7, #0
    a674:	ef1a0000 	svc	0x001a0000
    a678:	01000006 	tsteq	r0, r6
    a67c:	003a01e4 	eorseq	r0, sl, r4, ror #3
    a680:	92fb0000 	rscsls	r0, fp, #0
    a684:	dc1a0000 	ldcle	0, cr0, [sl], {-0}
    a688:	0100001f 	tsteq	r0, pc, lsl r0
    a68c:	01d701e6 	bicseq	r0, r7, r6, ror #3
    a690:	93460000 	movtls	r0, #24576	; 0x6000
    a694:	0f1a0000 	svceq	0x001a0000
    a698:	0100000c 	tsteq	r0, ip
    a69c:	003a01e7 	eorseq	r0, sl, r7, ror #3
    a6a0:	93640000 	cmnls	r4, #0
    a6a4:	cb1b0000 	blgt	6ca6ac <_etext+0x6c3194>
    a6a8:	01000020 	tsteq	r0, r0, lsr #32
    a6ac:	5fdc0210 	svcpl	0x00dc0210
    a6b0:	aa1c0000 	bge	70a6b8 <_etext+0x7031a0>
    a6b4:	3800005f 	stmdacc	r0, {r0, r1, r2, r3, r4, r6}
    a6b8:	1d000006 	stcne	0, cr0, [r0, #-24]	; 0xffffffe8
    a6bc:	75025001 	strvc	r5, [r2, #-1]
    a6c0:	b21e0000 	andslt	r0, lr, #0
    a6c4:	1c00005f 	stcne	0, cr0, [r0], {95}	; 0x5f
    a6c8:	4b00000d 	blmi	a704 <_etext+0x31ec>
    a6cc:	1d000006 	stcne	0, cr0, [r0, #-24]	; 0xffffffe8
    a6d0:	30015001 	andcc	r5, r1, r1
    a6d4:	5fbc1e00 	svcpl	0x00bc1e00
    a6d8:	0d320000 	ldceq	0, cr0, [r2, #-0]
    a6dc:	06650000 	strbteq	r0, [r5], -r0
    a6e0:	011d0000 	tsteq	sp, r0
    a6e4:	00750252 	rsbseq	r0, r5, r2, asr r2
    a6e8:	0250011d 	subseq	r0, r0, #1073741831	; 0x40000007
    a6ec:	1f000079 	svcne	0x00000079
    a6f0:	00005fc4 	andeq	r5, r0, r4, asr #31
    a6f4:	00000d4d 	andeq	r0, r0, sp, asr #26
    a6f8:	0251011d 	subseq	r0, r1, #1073741831	; 0x40000007
    a6fc:	011d0075 	tsteq	sp, r5, ror r0
    a700:	00300150 	eorseq	r0, r0, r0, asr r1
    a704:	6a040b00 	bvs	10d30c <_etext+0x105df4>
    a708:	20000002 	andcs	r0, r0, r2
    a70c:	00001ff0 	strdeq	r1, [r0], -r0
    a710:	020d4a01 	andeq	r4, sp, #4096	; 0x1000
    a714:	60000000 	andvs	r0, r0, r0
    a718:	00380000 	eorseq	r0, r8, r0
    a71c:	9c010000 	stcls	0, cr0, [r1], {-0}
    a720:	0020b513 	eoreq	fp, r0, r3, lsl r5
    a724:	0d780100 	ldfeqe	f0, [r8, #-0]
    a728:	38000002 	stmdacc	r0, {r1}
    a72c:	48000060 	stmdami	r0, {r5, r6}
    a730:	01000000 	mrseq	r0, (UNDEF: 0)
    a734:	0006be9c 	muleq	r6, ip, lr
    a738:	65522100 	ldrbvs	r2, [r2, #-256]	; 0x100
    a73c:	0d7a0100 	ldfeqe	f0, [sl, #-0]
    a740:	a2000002 	andge	r0, r0, #2
    a744:	00000093 	muleq	r0, r3, r0
    a748:	0021d513 	eoreq	sp, r1, r3, lsl r5
    a74c:	0de90100 	stfeqe	f0, [r9]
    a750:	80000002 	andhi	r0, r0, r2
    a754:	d0000060 	andle	r0, r0, r0, rrx
    a758:	01000000 	mrseq	r0, (UNDEF: 0)
    a75c:	0007969c 	muleq	r7, ip, r6
    a760:	20331600 	eorscs	r1, r3, r0, lsl #12
    a764:	eb010000 	bl	4a76c <_etext+0x43254>
    a768:	0000003a 	andeq	r0, r0, sl, lsr r0
    a76c:	000093c0 	andeq	r9, r0, r0, asr #7
    a770:	00134716 	andseq	r4, r3, r6, lsl r7
    a774:	3aec0100 	bcc	ffb0ab7c <BootRAM+0xea7b31d>
    a778:	f8000000 			; <UNDEFINED> instruction: 0xf8000000
    a77c:	17000093 			; <UNDEFINED> instruction: 0x17000093
    a780:	0000609c 	muleq	r0, ip, r0
    a784:	0000009e 	muleq	r0, lr, r0
    a788:	00214518 	eoreq	r4, r1, r8, lsl r5
    a78c:	96f60100 	ldrbtls	r0, [r6], r0, lsl #2
    a790:	16000007 	strne	r0, [r0], -r7
    a794:	000022e1 	andeq	r2, r0, r1, ror #5
    a798:	003af701 	eorseq	pc, sl, r1, lsl #14
    a79c:	94210000 	strtls	r0, [r1], #-0
    a7a0:	fd160000 	ldc2	0, cr0, [r6, #-0]
    a7a4:	01000022 	tsteq	r0, r2, lsr #32
    a7a8:	00003af8 	strdeq	r3, [r0], -r8
    a7ac:	00944a00 	addseq	r4, r4, r0, lsl #20
    a7b0:	45722100 	ldrbmi	r2, [r2, #-256]!	; 0x100
    a7b4:	f9010050 			; <UNDEFINED> instruction: 0xf9010050
    a7b8:	0000003a 	andeq	r0, r0, sl, lsr r0
    a7bc:	00009421 	andeq	r9, r0, r1, lsr #8
    a7c0:	00611c15 	rsbeq	r1, r1, r5, lsl ip
    a7c4:	00001200 	andeq	r1, r0, r0, lsl #4
    a7c8:	00075400 	andeq	r5, r7, r0, lsl #8
    a7cc:	075e1a00 	ldrbeq	r1, [lr, -r0, lsl #20]
    a7d0:	2f010000 	svccs	0x00010000
    a7d4:	00004c01 	andeq	r4, r0, r1, lsl #24
    a7d8:	00946200 	addseq	r6, r4, r0, lsl #4
    a7dc:	f61e0000 			; <UNDEFINED> instruction: 0xf61e0000
    a7e0:	64000060 	strvs	r0, [r0], #-96	; 0x60
    a7e4:	6800000d 	stmdavs	r0, {r0, r2, r3}
    a7e8:	1d000007 	stcne	0, cr0, [r0, #-28]	; 0xffffffe4
    a7ec:	74025001 	strvc	r5, [r2], #-1
    a7f0:	fe1e0000 	cdp2	0, 1, cr0, cr14, cr0, {0}
    a7f4:	76000060 	strvc	r0, [r0], -r0, rrx
    a7f8:	8200000d 	andhi	r0, r0, #13
    a7fc:	1d000007 	stcne	0, cr0, [r0, #-28]	; 0xffffffe4
    a800:	08025101 	stmdaeq	r2, {r0, r8, ip, lr}
    a804:	50011d30 	andpl	r1, r1, r0, lsr sp
    a808:	00007402 	andeq	r7, r0, r2, lsl #8
    a80c:	00611622 	rsbeq	r1, r1, r2, lsr #12
    a810:	000d8d00 	andeq	r8, sp, r0, lsl #26
    a814:	611c2200 	tstvs	ip, r0, lsl #4
    a818:	0da40000 	stceq	0, cr0, [r4]
    a81c:	00000000 	andeq	r0, r0, r0
    a820:	029a040b 	addseq	r0, sl, #184549376	; 0xb000000
    a824:	fb230000 	blx	8ca82e <_etext+0x8c3316>
    a828:	01000020 	tsteq	r0, r0, lsr #32
    a82c:	020d0142 	andeq	r0, sp, #-2147483632	; 0x80000010
    a830:	61500000 	cmpvs	r0, r0
    a834:	00840000 	addeq	r0, r4, r0
    a838:	9c010000 	stcls	0, cr0, [r1], {-0}
    a83c:	0000082b 	andeq	r0, r0, fp, lsr #16
    a840:	0022fd1a 	eoreq	pc, r2, sl, lsl sp	; <UNPREDICTABLE>
    a844:	01440100 	mrseq	r0, (UNDEF: 84)
    a848:	0000003a 	andeq	r0, r0, sl, lsr r0
    a84c:	00009490 	muleq	r0, r0, r4
    a850:	0022e11a 	eoreq	lr, r2, sl, lsl r1
    a854:	01450100 	mrseq	r0, (UNDEF: 85)
    a858:	0000003a 	andeq	r0, r0, sl, lsr r0
    a85c:	000094b8 			; <UNDEFINED> instruction: 0x000094b8
    a860:	50457224 	subpl	r7, r5, r4, lsr #4
    a864:	01460100 	mrseq	r0, (UNDEF: 86)
    a868:	0000003a 	andeq	r0, r0, sl, lsr r0
    a86c:	000094b8 			; <UNDEFINED> instruction: 0x000094b8
    a870:	0013471a 	andseq	r4, r3, sl, lsl r7
    a874:	01470100 	mrseq	r0, (UNDEF: 87)
    a878:	0000003a 	andeq	r0, r0, sl, lsr r0
    a87c:	000094ed 	andeq	r9, r0, sp, ror #9
    a880:	000e9825 	andeq	r9, lr, r5, lsr #16
    a884:	00081000 	andeq	r1, r8, r0
    a888:	075e1a00 	ldrbeq	r1, [lr, -r0, lsl #20]
    a88c:	63010000 	movwvs	r0, #4096	; 0x1000
    a890:	00004c01 	andeq	r4, r0, r1, lsl #24
    a894:	00950b00 	addseq	r0, r5, r0, lsl #22
    a898:	a8170000 	ldmdage	r7, {}	; <UNPREDICTABLE>
    a89c:	10000061 	andne	r0, r0, r1, rrx
    a8a0:	1a000000 	bne	a8a8 <_etext+0x3390>
    a8a4:	0000075e 	andeq	r0, r0, lr, asr r7
    a8a8:	4c016901 	stcmi	9, cr6, [r1], {1}
    a8ac:	33000000 	movwcc	r0, #0
    a8b0:	00000095 	muleq	r0, r5, r0
    a8b4:	214a2600 	cmpcs	sl, r0, lsl #12
    a8b8:	78010000 	stmdavc	r1, {}	; <UNPREDICTABLE>
    a8bc:	00020d01 	andeq	r0, r2, r1, lsl #26
    a8c0:	0061d400 	rsbeq	sp, r1, r0, lsl #8
    a8c4:	00002400 	andeq	r2, r0, r0, lsl #8
    a8c8:	279c0100 	ldrcs	r0, [ip, r0, lsl #2]
    a8cc:	00000264 	andeq	r0, r0, r4, ror #4
    a8d0:	d7019201 	strle	r9, [r1, -r1, lsl #4]
    a8d4:	f8000001 			; <UNDEFINED> instruction: 0xf8000001
    a8d8:	1c000061 	stcne	0, cr0, [r0], {97}	; 0x61
    a8dc:	01000000 	mrseq	r0, (UNDEF: 0)
    a8e0:	00088c9c 	muleq	r8, ip, ip
    a8e4:	0c0f2800 	stceq	8, cr2, [pc], {-0}
    a8e8:	92010000 	andls	r0, r1, #0
    a8ec:	00004c01 	andeq	r4, r0, r1, lsl #24
    a8f0:	00954c00 	addseq	r4, r5, r0, lsl #24
    a8f4:	21642800 	cmncs	r4, r0, lsl #16
    a8f8:	92010000 	andls	r0, r1, #0
    a8fc:	00088c01 	andeq	r8, r8, r1, lsl #24
    a900:	00956d00 	addseq	r6, r5, r0, lsl #26
    a904:	08711a00 	ldmdaeq	r1!, {r9, fp, ip}^
    a908:	94010000 	strls	r0, [r1], #-0
    a90c:	00003a01 	andeq	r3, r0, r1, lsl #20
    a910:	00959900 	addseq	r9, r5, r0, lsl #18
    a914:	040b0000 	streq	r0, [fp], #-0
    a918:	000001dd 	ldrdeq	r0, [r0], -sp
    a91c:	001fce27 	andseq	ip, pc, r7, lsr #28
    a920:	03c90100 	biceq	r0, r9, #0, 2
    a924:	0000005e 	andeq	r0, r0, lr, asr r0
    a928:	00006214 	andeq	r6, r0, r4, lsl r2
    a92c:	00000040 	andeq	r0, r0, r0, asr #32
    a930:	08bc9c01 	ldmeq	ip!, {r0, sl, fp, ip, pc}
    a934:	221f0000 	andscs	r0, pc, #0
    a938:	8d000062 	stchi	0, cr0, [r0, #-392]	; 0xfffffe78
    a93c:	1d00000d 	stcne	0, cr0, [r0, #-52]	; 0xffffffcc
    a940:	30015001 	andcc	r5, r1, r1
    a944:	41290000 	teqmi	r9, r0
    a948:	01000020 	tsteq	r0, r0, lsr #32
    a94c:	f601021b 			; <UNDEFINED> instruction: 0xf601021b
    a950:	2a000008 	bcs	a978 <_etext+0x3460>
    a954:	00001fc7 	andeq	r1, r0, r7, asr #31
    a958:	0d021d01 	stceq	13, cr1, [r2, #-4]
    a95c:	2a000002 	bcs	a96c <_etext+0x3454>
    a960:	000020e3 	andeq	r2, r0, r3, ror #1
    a964:	3a021e01 	bcc	92170 <_etext+0x8ac58>
    a968:	2a000000 	bcs	a970 <_etext+0x3458>
    a96c:	000006ef 	andeq	r0, r0, pc, ror #13
    a970:	3a021f01 	bcc	9257c <_etext+0x8b064>
    a974:	2b000000 	blcs	a97c <_etext+0x3464>
    a978:	0000203c 	andeq	r2, r0, ip, lsr r0
    a97c:	00028b01 	andeq	r8, r2, r1, lsl #22
    a980:	00204329 	eoreq	r4, r0, r9, lsr #6
    a984:	02970100 	addseq	r0, r7, #0, 2
    a988:	00097801 	andeq	r7, r9, r1, lsl #16
    a98c:	060e2a00 	streq	r2, [lr], -r0, lsl #20
    a990:	99010000 	stmdbls	r1, {}	; <UNPREDICTABLE>
    a994:	00026402 	andeq	r6, r2, r2, lsl #8
    a998:	1fc72a00 	svcne	0x00c72a00
    a99c:	9a010000 	bls	4a9a4 <_etext+0x4348c>
    a9a0:	00020d02 	andeq	r0, r2, r2, lsl #26
    a9a4:	232c2a00 	teqcs	ip, #0, 20
    a9a8:	9b010000 	blls	4a9b0 <_etext+0x43498>
    a9ac:	00003a02 	andeq	r3, r0, r2, lsl #20
    a9b0:	22e12a00 	rsccs	r2, r1, #0, 20
    a9b4:	9d010000 	stcls	0, cr0, [r1, #-0]
    a9b8:	00003a02 	andeq	r3, r0, r2, lsl #20
    a9bc:	1fe72a00 	svcne	0x00e72a00
    a9c0:	9d010000 	stcls	0, cr0, [r1, #-0]
    a9c4:	00003a02 	andeq	r3, r0, r2, lsl #20
    a9c8:	08712a00 	ldmdaeq	r1!, {r9, fp, sp}^
    a9cc:	9e010000 	cdpls	0, 0, cr0, cr1, cr0, {0}
    a9d0:	00003a02 	andeq	r3, r0, r2, lsl #20
    a9d4:	13472a00 	movtne	r2, #31232	; 0x7a00
    a9d8:	9e010000 	cdpls	0, 0, cr0, cr1, cr0, {0}
    a9dc:	00003a02 	andeq	r3, r0, r2, lsl #20
    a9e0:	09692c00 	stmdbeq	r9!, {sl, fp, sp}^
    a9e4:	4f2a0000 	svcmi	0x002a0000
    a9e8:	01000020 	tsteq	r0, r0, lsr #32
    a9ec:	005e02a9 	subseq	r0, lr, r9, lsr #5
    a9f0:	2d000000 	stccs	0, cr0, [r0, #-0]
    a9f4:	0001db2a 	andeq	sp, r1, sl, lsr #22
    a9f8:	03250100 	teqeq	r5, #0, 2
    a9fc:	0000006f 	andeq	r0, r0, pc, rrx
    aa00:	05230000 	streq	r0, [r3, #-0]!
    aa04:	0100001f 	tsteq	r0, pc, lsl r0
    aa08:	005e034c 	subseq	r0, lr, ip, asr #6
    aa0c:	62540000 	subsvs	r0, r4, #0
    aa10:	02dc0000 	sbcseq	r0, ip, #0
    aa14:	9c010000 	stcls	0, cr0, [r1], {-0}
    aa18:	00000ae6 	andeq	r0, r0, r6, ror #21
    aa1c:	4f01042e 	svcmi	0x0001042e
    aa20:	0009b003 	andeq	fp, r9, r3
    aa24:	00622f00 	rsbeq	r2, r2, r0, lsl #30
    aa28:	d7035101 	strle	r5, [r3, -r1, lsl #2]
    aa2c:	2f000001 	svccs	0x00000001
    aa30:	52010077 	andpl	r0, r1, #119	; 0x77
    aa34:	000ae603 	andeq	lr, sl, r3, lsl #12
    aa38:	c81a0000 	ldmdagt	sl, {}	; <UNPREDICTABLE>
    aa3c:	01000022 	tsteq	r0, r2, lsr #32
    aa40:	09920353 	ldmibeq	r2, {r0, r1, r4, r6, r8, r9}
    aa44:	95ca0000 	strbls	r0, [sl]
    aa48:	bc300000 	ldclt	0, cr0, [r0], #-0
    aa4c:	9a000008 	bls	aa74 <_etext+0x355c>
    aa50:	c4000062 	strgt	r0, [r0], #-98	; 0x62
    aa54:	01000000 	mrseq	r0, (UNDEF: 0)
    aa58:	0a400367 	beq	100b7fc <_etext+0x10042e4>
    aa5c:	9a170000 	bls	5caa64 <_etext+0x5c354c>
    aa60:	c4000062 	strgt	r0, [r0], #-98	; 0x62
    aa64:	31000000 	mrscc	r0, (UNDEF: 0)
    aa68:	000008c9 	andeq	r0, r0, r9, asr #17
    aa6c:	000095ed 	andeq	r9, r0, sp, ror #11
    aa70:	0008d531 	andeq	sp, r8, r1, lsr r5
    aa74:	00969600 	addseq	r9, r6, r0, lsl #12
    aa78:	08e13100 	stmiaeq	r1!, {r8, ip, sp}^
    aa7c:	96a90000 	strtls	r0, [r9], r0
    aa80:	ed320000 	ldc	0, cr0, [r2, #-0]
    aa84:	58000008 	stmdapl	r0, {r3}
    aa88:	22000063 	andcs	r0, r0, #99	; 0x63
    aa8c:	000062aa 	andeq	r6, r0, sl, lsr #5
    aa90:	00000681 	andeq	r0, r0, r1, lsl #13
    aa94:	0062e41c 	rsbeq	lr, r2, ip, lsl r4
    aa98:	000a1a00 	andeq	r1, sl, r0, lsl #20
    aa9c:	50011d00 	andpl	r1, r1, r0, lsl #26
    aaa0:	00007402 	andeq	r7, r0, r2, lsl #8
    aaa4:	0062fa22 	rsbeq	pc, r2, r2, lsr #20
    aaa8:	00082b00 	andeq	r2, r8, r0, lsl #22
    aaac:	63162200 	tstvs	r6, #0, 4
    aab0:	06be0000 	ldrteq	r0, [lr], r0
    aab4:	24220000 	strtcs	r0, [r2], #-0
    aab8:	96000063 	strls	r0, [r0], -r3, rrx
    aabc:	22000006 	andcs	r0, r0, #6
    aac0:	00006336 	andeq	r6, r0, r6, lsr r3
    aac4:	0000079c 	muleq	r0, ip, r7
    aac8:	f6330000 			; <UNDEFINED> instruction: 0xf6330000
    aacc:	5e000008 	cdppl	0, 0, cr0, cr0, cr8, {0}
    aad0:	b8000063 	stmdalt	r0, {r0, r1, r5, r6}
    aad4:	0100000e 	tsteq	r0, lr
    aad8:	0adc036c 	beq	ff70b890 <BootRAM+0xe67c031>
    aadc:	b8340000 	ldmdalt	r4!, {}	; <UNPREDICTABLE>
    aae0:	3100000e 	tstcc	r0, lr
    aae4:	00000903 	andeq	r0, r0, r3, lsl #18
    aae8:	000096c8 	andeq	r9, r0, r8, asr #13
    aaec:	00090f31 	andeq	r0, r9, r1, lsr pc
    aaf0:	00975f00 	addseq	r5, r7, r0, lsl #30
    aaf4:	091b3100 	ldmdbeq	fp, {r8, ip, sp}
    aaf8:	979f0000 	ldrls	r0, [pc, r0]
    aafc:	27310000 	ldrcs	r0, [r1, -r0]!
    ab00:	c8000009 	stmdagt	r0, {r0, r3}
    ab04:	31000097 	swpcc	r0, r7, [r0]	; <UNPREDICTABLE>
    ab08:	00000933 	andeq	r0, r0, r3, lsr r9
    ab0c:	000097db 	ldrdeq	r9, [r0], -fp
    ab10:	00093f31 	andeq	r3, r9, r1, lsr pc
    ab14:	0097f600 	addseq	pc, r7, r0, lsl #12
    ab18:	094b3100 	stmdbeq	fp, {r8, ip, sp}^
    ab1c:	98160000 	ldmdals	r6, {}	; <UNPREDICTABLE>
    ab20:	68150000 	ldmdavs	r5, {}	; <UNPREDICTABLE>
    ab24:	2c000063 	stccs	0, cr0, [r0], {99}	; 0x63
    ab28:	af000000 	svcge	0x00000000
    ab2c:	3100000a 	tstcc	r0, sl
    ab30:	0000095c 	andeq	r0, r0, ip, asr r9
    ab34:	00009829 	andeq	r9, r0, r9, lsr #16
    ab38:	649c1500 	ldrvs	r1, [ip], #1280	; 0x500
    ab3c:	00600000 	rsbeq	r0, r0, r0
    ab40:	0ace0000 	beq	ff38ab48 <BootRAM+0xe2fb2e9>
    ab44:	6a350000 	bvs	d4ab4c <_etext+0xd43634>
    ab48:	02000009 	andeq	r0, r0, #9
    ab4c:	fa226c91 	blx	8a5d98 <_etext+0x89e880>
    ab50:	b6000064 	strlt	r0, [r0], -r4, rrx
    ab54:	00000005 	andeq	r0, r0, r5
    ab58:	00645e36 	rsbeq	r5, r4, r6, lsr lr
    ab5c:	50011d00 	andpl	r1, r1, r0, lsl #26
    ab60:	00007402 	andeq	r7, r0, r2, lsl #8
    ab64:	0c220000 	stceq	0, cr0, [r2], #-0
    ab68:	92000065 	andls	r0, r0, #101	; 0x65
    ab6c:	00000008 	andeq	r0, r0, r8
    ab70:	004c040b 	subeq	r0, ip, fp, lsl #8
    ab74:	14290000 	strtne	r0, [r9], #-0
    ab78:	01000023 	tsteq	r0, r3, lsr #32
    ab7c:	2c0101a7 	stfcss	f0, [r1], {167}	; 0xa7
    ab80:	2a00000b 	bcs	abb4 <_etext+0x369c>
    ab84:	000022cd 	andeq	r2, r0, sp, asr #5
    ab88:	7b01a901 	blvc	74f94 <_etext+0x6da7c>
    ab8c:	2a000006 	bcs	abac <_etext+0x3694>
    ab90:	0000208f 	andeq	r2, r0, pc, lsl #1
    ab94:	3a01aa01 	bcc	753a0 <_etext+0x6de88>
    ab98:	2d000000 	stccs	0, cr0, [r0, #-0]
    ab9c:	001fe02a 	andseq	lr, pc, sl, lsr #32
    aba0:	01b00100 	lslseq	r0, r0, #2
    aba4:	000001d7 	ldrdeq	r0, [r0], -r7
    aba8:	000c0f2a 	andeq	r0, ip, sl, lsr #30
    abac:	01b10100 			; <UNDEFINED> instruction: 0x01b10100
    abb0:	0000003a 	andeq	r0, r0, sl, lsr r0
    abb4:	4f230000 	svcmi	0x00230000
    abb8:	0100001f 	tsteq	r0, pc, lsl r0
    abbc:	005e03a0 	subseq	r0, lr, r0, lsr #7
    abc0:	65300000 	ldrvs	r0, [r0, #-0]!
    abc4:	00c80000 	sbceq	r0, r8, r0
    abc8:	9c010000 	stcls	0, cr0, [r1], {-0}
    abcc:	00000bfe 	strdeq	r0, [r0], -lr
    abd0:	0006ef1a 	andeq	lr, r6, sl, lsl pc
    abd4:	03a20100 			; <UNDEFINED> instruction: 0x03a20100
    abd8:	0000003a 	andeq	r0, r0, sl, lsr r0
    abdc:	00009853 	andeq	r9, r0, r3, asr r8
    abe0:	000aec30 	andeq	lr, sl, r0, lsr ip
    abe4:	00654000 	rsbeq	r4, r5, r0
    abe8:	00007e00 	andeq	r7, r0, r0, lsl #28
    abec:	03a60100 			; <UNDEFINED> instruction: 0x03a60100
    abf0:	00000bf4 	strdeq	r0, [r0], -r4
    abf4:	00654017 	rsbeq	r4, r5, r7, lsl r0
    abf8:	00007e00 	andeq	r7, r0, r0, lsl #28
    abfc:	0af93100 	beq	ffe57004 <BootRAM+0xedc77a5>
    ac00:	98a00000 	stmials	r0!, {}	; <UNPREDICTABLE>
    ac04:	05310000 	ldreq	r0, [r1, #-0]!
    ac08:	b500000b 	strlt	r0, [r0, #-11]
    ac0c:	15000098 	strne	r0, [r0, #-152]	; 0x98
    ac10:	00006548 	andeq	r6, r0, r8, asr #10
    ac14:	0000002a 	andeq	r0, r0, sl, lsr #32
    ac18:	00000bde 	ldrdeq	r0, [r0], -lr
    ac1c:	000b1231 	andeq	r1, fp, r1, lsr r2
    ac20:	0098c800 	addseq	ip, r8, r0, lsl #16
    ac24:	0b1e3100 	bleq	79702c <_etext+0x78fb14>
    ac28:	98e60000 	stmials	r6!, {}^	; <UNPREDICTABLE>
    ac2c:	541c0000 	ldrpl	r0, [ip], #-0
    ac30:	b4000065 	strlt	r0, [r0], #-101	; 0x65
    ac34:	1d00000b 	stcne	0, cr0, [r0, #-44]	; 0xffffffd4
    ac38:	76025001 	strvc	r5, [r2], -r1
    ac3c:	681e0000 	ldmdavs	lr, {}	; <UNPREDICTABLE>
    ac40:	b6000065 	strlt	r0, [r0], -r5, rrx
    ac44:	c700000d 	strgt	r0, [r0, -sp]
    ac48:	1d00000b 	stcne	0, cr0, [r0, #-44]	; 0xffffffd4
    ac4c:	30015001 	andcc	r5, r1, r1
    ac50:	65721f00 	ldrbvs	r1, [r2, #-3840]!	; 0xf00
    ac54:	0dcc0000 	stcleq	0, cr0, [ip]
    ac58:	011d0000 	tsteq	sp, r0
    ac5c:	00760252 	rsbseq	r0, r6, r2, asr r2
    ac60:	0250011d 	subseq	r0, r0, #1073741831	; 0x40000007
    ac64:	00000077 	andeq	r0, r0, r7, ror r0
    ac68:	0065861f 	rsbeq	r8, r5, pc, lsl r6
    ac6c:	000d4d00 	andeq	r4, sp, r0, lsl #26
    ac70:	51011d00 	tstpl	r1, r0, lsl #26
    ac74:	011d3001 	tsteq	sp, r1
    ac78:	00300150 	eorseq	r0, r0, r0, asr r1
    ac7c:	de370000 	cdple	0, 3, cr0, cr7, cr0, {0}
    ac80:	92000065 	andls	r0, r0, #101	; 0x65
    ac84:	00000008 	andeq	r0, r0, r8
    ac88:	0002b238 	andeq	fp, r2, r8, lsr r2
    ac8c:	03dd0100 	bicseq	r0, sp, #0, 2
    ac90:	000065f8 	strdeq	r6, [r0], -r8
    ac94:	00000038 	andeq	r0, r0, r8, lsr r0
    ac98:	0c439c01 	mcrreq	12, 0, r9, r3, cr1
    ac9c:	56390000 	ldrtpl	r0, [r9], -r0
    aca0:	01006c61 	tsteq	r0, r1, ror #24
    aca4:	005e03dd 	ldrsbeq	r0, [lr], #-61	; 0xffffffc3
    aca8:	99190000 	ldmdbls	r9, {}	; <UNPREDICTABLE>
    acac:	69240000 	stmdbvs	r4!, {}	; <UNPREDICTABLE>
    acb0:	03df0100 	bicseq	r0, pc, #0, 2
    acb4:	0000003a 	andeq	r0, r0, sl, lsr r0
    acb8:	0000993a 	andeq	r9, r0, sl, lsr r9
    acbc:	50456e24 	subpl	r6, r5, r4, lsr #28
    acc0:	03e00100 	mvneq	r0, #0, 2
    acc4:	0000003a 	andeq	r0, r0, sl, lsr r0
    acc8:	00009959 	andeq	r9, r0, r9, asr r9
    accc:	1f432300 	svcne	0x00432300
    acd0:	78010000 	stmdavc	r1, {}	; <UNPREDICTABLE>
    acd4:	00005e03 	andeq	r5, r0, r3, lsl #28
    acd8:	00663000 	rsbeq	r3, r6, r0
    acdc:	00005c00 	andeq	r5, r0, r0, lsl #24
    ace0:	899c0100 	ldmibhi	ip, {r8}
    ace4:	1a00000c 	bne	ad1c <_etext+0x3804>
    ace8:	000006ef 	andeq	r0, r0, pc, ror #13
    acec:	3a037a01 	bcc	e94f8 <_etext+0xe1fe0>
    acf0:	6c000000 	stcvs	0, cr0, [r0], {-0}
    acf4:	22000099 	andcs	r0, r0, #153	; 0x99
    acf8:	00006644 	andeq	r6, r0, r4, asr #12
    acfc:	000005b6 			; <UNDEFINED> instruction: 0x000005b6
    ad00:	00666022 	rsbeq	r6, r6, r2, lsr #32
    ad04:	000bfe00 	andeq	pc, fp, r0, lsl #28
    ad08:	667e3700 	ldrbtvs	r3, [lr], -r0, lsl #14
    ad0c:	08920000 	ldmeq	r2, {}	; <UNPREDICTABLE>
    ad10:	3a000000 	bcc	ad18 <_etext+0x3800>
    ad14:	000020a9 	andeq	r2, r0, r9, lsr #1
    ad18:	0003f101 	andeq	pc, r3, r1, lsl #2
    ad1c:	02000000 	andeq	r0, r0, #0
    ad20:	01000000 	mrseq	r0, (UNDEF: 0)
    ad24:	02eb3b9c 	rsceq	r3, fp, #156, 22	; 0x27000
    ad28:	ec040000 	stc	0, cr0, [r4], {-0}
    ad2c:	0000046b 	andeq	r0, r0, fp, ror #8
    ad30:	00021a3b 	andeq	r1, r2, fp, lsr sl
    ad34:	9aee0400 	bls	ffb8bd3c <BootRAM+0xeafc4dd>
    ad38:	3b000002 	blcc	ad48 <_etext+0x3830>
    ad3c:	00001f14 	andeq	r1, r0, r4, lsl pc
    ad40:	004cf204 	subeq	pc, ip, r4, lsl #4
    ad44:	1f3b0000 	svcne	0x003b0000
    ad48:	0400001f 	streq	r0, [r0], #-31
    ad4c:	00004cf3 	strdeq	r4, [r0], -r3
    ad50:	01e83b00 	mvneq	r3, r0, lsl #22
    ad54:	22050000 	andcs	r0, r5, #0
    ad58:	00000cd2 	ldrdeq	r0, [r0], -r2
    ad5c:	0381040b 	orreq	r0, r1, #184549376	; 0xb000000
    ad60:	3e3b0000 	cdpcc	0, 3, cr0, cr11, cr0, {0}
    ad64:	05000001 	streq	r0, [r0, #-1]
    ad68:	000ce325 	andeq	lr, ip, r5, lsr #6
    ad6c:	6b040b00 	blvs	10d974 <_etext+0x10645c>
    ad70:	3b000004 	blcc	ad88 <_etext+0x3870>
    ad74:	00001f81 	andeq	r1, r0, r1, lsl #31
    ad78:	0cf42a05 	vldmiaeq	r4!, {s5-s9}
    ad7c:	040b0000 	streq	r0, [fp], #-0
    ad80:	000004ef 	andeq	r0, r0, pc, ror #9
    ad84:	0022f23c 	eoreq	pc, r2, ip, lsr r2	; <UNPREDICTABLE>
    ad88:	e5240100 	str	r0, [r4, #-256]!	; 0x100
    ad8c:	05000002 	streq	r0, [r0, #-2]
    ad90:	0005ae03 	andeq	sl, r5, r3, lsl #28
    ad94:	212e3c20 	teqcs	lr, r0, lsr #24
    ad98:	25010000 	strcs	r0, [r1, #-0]
    ad9c:	00000094 	muleq	r0, r4, r0
    ada0:	0dcc0305 	stcleq	3, cr0, [ip, #20]
    ada4:	a63d2000 	ldrtge	r2, [sp], -r0
    ada8:	0700001e 	smladeq	r0, lr, r0, r0
    adac:	004c0253 	subeq	r0, ip, r3, asr r2
    adb0:	0d320000 	ldceq	0, cr0, [r2, #-0]
    adb4:	5e0d0000 	cdppl	0, 0, cr0, cr13, cr0, {0}
    adb8:	00000000 	andeq	r0, r0, r0
    adbc:	00207b3e 	eoreq	r7, r0, lr, lsr fp
    adc0:	4d190600 	ldcmi	6, cr0, [r9, #-0]
    adc4:	0d00000d 	stceq	0, cr0, [r0, #-52]	; 0xffffffcc
    adc8:	000001d7 	ldrdeq	r0, [r0], -r7
    adcc:	00004c0d 	andeq	r4, r0, sp, lsl #24
    add0:	004c0d00 	subeq	r0, ip, r0, lsl #26
    add4:	3f000000 	svccc	0x00000000
    add8:	00001d81 	andeq	r1, r0, r1, lsl #27
    addc:	64025607 	strvs	r5, [r2], #-1543	; 0x607
    ade0:	0d00000d 	stceq	0, cr0, [r0, #-52]	; 0xffffffcc
    ade4:	0000005e 	andeq	r0, r0, lr, asr r0
    ade8:	00004c0d 	andeq	r4, r0, sp, lsl #24
    adec:	b23f0000 	eorslt	r0, pc, #0
    adf0:	0700001e 	smladeq	r0, lr, r0, r0
    adf4:	0d76024e 	lfmeq	f0, 2, [r6, #-312]!	; 0xfffffec8
    adf8:	5e0d0000 	cdppl	0, 0, cr0, cr13, cr0, {0}
    adfc:	00000000 	andeq	r0, r0, r0
    ae00:	001ebf3f 	andseq	fp, lr, pc, lsr pc
    ae04:	023a0700 	eorseq	r0, sl, #0, 14
    ae08:	00000d8d 	andeq	r0, r0, sp, lsl #27
    ae0c:	00005e0d 	andeq	r5, r0, sp, lsl #28
    ae10:	004c0d00 	subeq	r0, ip, r0, lsl #26
    ae14:	3f000000 	svccc	0x00000000
    ae18:	0000099c 	muleq	r0, ip, r9
    ae1c:	a4025707 	strge	r5, [r2], #-1799	; 0x707
    ae20:	0d00000d 	stceq	0, cr0, [r0, #-52]	; 0xffffffcc
    ae24:	0000005e 	andeq	r0, r0, lr, asr r0
    ae28:	00004c0d 	andeq	r4, r0, sp, lsl #24
    ae2c:	023f0000 	eorseq	r0, pc, #0
    ae30:	0700001c 	smladeq	r0, ip, r0, r0
    ae34:	0db6024d 	lfmeq	f0, 4, [r6, #308]!	; 0x134
    ae38:	5e0d0000 	cdppl	0, 0, cr0, cr13, cr0, {0}
    ae3c:	00000000 	andeq	r0, r0, r0
    ae40:	001c923d 	andseq	r9, ip, sp, lsr r2
    ae44:	02540700 	subseq	r0, r4, #0, 14
    ae48:	0000004c 	andeq	r0, r0, ip, asr #32
    ae4c:	00000dcc 	andeq	r0, r0, ip, asr #27
    ae50:	00005e0d 	andeq	r5, r0, sp, lsl #28
    ae54:	28400000 	stmdacs	r0, {}^	; <UNPREDICTABLE>
    ae58:	06000022 	streq	r0, [r0], -r2, lsr #32
    ae5c:	01d70d1a 	bicseq	r0, r7, sl, lsl sp
    ae60:	4c0d0000 	stcmi	0, cr0, [sp], {-0}
    ae64:	0d000000 	stceq	0, cr0, [r0, #-0]
    ae68:	0000004c 	andeq	r0, r0, ip, asr #32
    ae6c:	01700000 	cmneq	r0, r0
    ae70:	00040000 	andeq	r0, r4, r0
    ae74:	000028f3 	strdeq	r2, [r0], -r3
    ae78:	06390104 	ldrteq	r0, [r9], -r4, lsl #2
    ae7c:	62010000 	andvs	r0, r1, #0
    ae80:	93000023 	movwls	r0, #35	; 0x23
    ae84:	58000008 	stmdapl	r0, {r3}
    ae88:	0000000f 	andeq	r0, r0, pc
    ae8c:	2b000000 	blcs	ae94 <_etext+0x397c>
    ae90:	0200003c 	andeq	r0, r0, #60	; 0x3c
    ae94:	04da0504 	ldrbeq	r0, [sl], #1284	; 0x504
    ae98:	02020000 	andeq	r0, r2, #0
    ae9c:	0006fc05 	andeq	pc, r6, r5, lsl #24
    aea0:	06010200 	streq	r0, [r1], -r0, lsl #4
    aea4:	0000081a 	andeq	r0, r0, sl, lsl r8
    aea8:	32337503 	eorscc	r7, r3, #12582912	; 0xc00000
    aeac:	45240200 	strmi	r0, [r4, #-512]!	; 0x200
    aeb0:	02000000 	andeq	r0, r0, #0
    aeb4:	02520704 	subseq	r0, r2, #4, 14	; 0x100000
    aeb8:	75030000 	strvc	r0, [r3, #-0]
    aebc:	02003631 	andeq	r3, r0, #51380224	; 0x3100000
    aec0:	00005725 	andeq	r5, r0, r5, lsr #14
    aec4:	07020200 	streq	r0, [r2, -r0, lsl #4]
    aec8:	00000949 	andeq	r0, r0, r9, asr #18
    aecc:	00387503 	eorseq	r7, r8, r3, lsl #10
    aed0:	00682602 	rsbeq	r2, r8, r2, lsl #12
    aed4:	01020000 	mrseq	r0, (UNDEF: 2)
    aed8:	00081808 	andeq	r1, r8, r8, lsl #16
    aedc:	5e040400 	cfcpyspl	mvf0, mvf4
    aee0:	05000000 	streq	r0, [r0, #-0]
    aee4:	0000207b 	andeq	r2, r0, fp, ror r0
    aee8:	668c2301 	strvs	r2, [ip], r1, lsl #6
    aeec:	00300000 	eorseq	r0, r0, r0
    aef0:	9c010000 	stcls	0, cr0, [r1], {-0}
    aef4:	000000fd 	strdeq	r0, [r0], -sp
    aef8:	00237c06 	eoreq	r7, r3, r6, lsl #24
    aefc:	6f230100 	svcvs	0x00230100
    af00:	b2000000 	andlt	r0, r0, #0
    af04:	06000099 			; <UNDEFINED> instruction: 0x06000099
    af08:	00002385 	andeq	r2, r0, r5, lsl #7
    af0c:	004c2301 	subeq	r2, ip, r1, lsl #6
    af10:	99f70000 	ldmibls	r7!, {}^	; <UNPREDICTABLE>
    af14:	74060000 	strvc	r0, [r6], #-0
    af18:	01000023 	tsteq	r0, r3, lsr #32
    af1c:	00004c23 	andeq	r4, r0, r3, lsr #24
    af20:	009a1800 	addseq	r1, sl, r0, lsl #16
    af24:	006e0700 	rsbeq	r0, lr, r0, lsl #14
    af28:	003a2501 	eorseq	r2, sl, r1, lsl #10
    af2c:	52010000 	andpl	r0, r1, #0
    af30:	01006908 	tsteq	r0, r8, lsl #18
    af34:	00003a26 	andeq	r3, r0, r6, lsr #20
    af38:	009a3900 	addseq	r3, sl, r0, lsl #18
    af3c:	19eb0900 	stmibne	fp!, {r8, fp}^
    af40:	26010000 	strcs	r0, [r1], -r0
    af44:	0000003a 	andeq	r0, r0, sl, lsr r0
    af48:	00009a98 	muleq	r0, r8, sl
    af4c:	0019f109 	andseq	pc, r9, r9, lsl #2
    af50:	3a260100 	bcc	98b358 <_etext+0x983e40>
    af54:	cf000000 	svcgt	0x00000000
    af58:	0900009a 	stmdbeq	r0, {r1, r3, r4, r7}
    af5c:	00002391 	muleq	r0, r1, r3
    af60:	00fd2701 	rscseq	r2, sp, r1, lsl #14
    af64:	9af30000 	bls	ffccaf6c <BootRAM+0xec3b70d>
    af68:	04000000 	streq	r0, [r0], #-0
    af6c:	00004c04 	andeq	r4, r0, r4, lsl #24
    af70:	22280500 	eorcs	r0, r8, #0, 10
    af74:	3c010000 	stccc	0, cr0, [r1], {-0}
    af78:	000066bc 			; <UNDEFINED> instruction: 0x000066bc
    af7c:	00000024 	andeq	r0, r0, r4, lsr #32
    af80:	016d9c01 	cmneq	sp, r1, lsl #24
    af84:	7c060000 	stcvc	0, cr0, [r6], {-0}
    af88:	01000023 	tsteq	r0, r3, lsr #32
    af8c:	00006f3c 	andeq	r6, r0, ip, lsr pc
    af90:	009b2e00 	addseq	r2, fp, r0, lsl #28
    af94:	23850600 	orrcs	r0, r5, #0, 12
    af98:	3c010000 	stccc	0, cr0, [r1], {-0}
    af9c:	0000004c 	andeq	r0, r0, ip, asr #32
    afa0:	00009b69 	andeq	r9, r0, r9, ror #22
    afa4:	00237406 	eoreq	r7, r3, r6, lsl #8
    afa8:	4c3c0100 	ldfmis	f0, [ip], #-0
    afac:	8a000000 	bhi	afb4 <_etext+0x3a9c>
    afb0:	0700009b 			; <UNDEFINED> instruction: 0x0700009b
    afb4:	3e01006e 	cdpcc	0, 0, cr0, cr1, cr14, {3}
    afb8:	0000003a 	andeq	r0, r0, sl, lsr r0
    afbc:	69085201 	stmdbvs	r8, {r0, r9, ip, lr}
    afc0:	3a3f0100 	bcc	fcb3c8 <_etext+0xfc3eb0>
    afc4:	ab000000 	blge	afcc <_etext+0x3ab4>
    afc8:	0900009b 	stmdbeq	r0, {r0, r1, r3, r4, r7}
    afcc:	00002391 	muleq	r0, r1, r3
    afd0:	016d4001 	cmneq	sp, r1
    afd4:	9c0a0000 	stcls	0, cr0, [sl], {-0}
    afd8:	04000000 	streq	r0, [r0], #-0
    afdc:	00003a04 	andeq	r3, r0, r4, lsl #20
	...

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void NOP_Process(void)
{
       0:	10001101 	andne	r1, r0, r1, lsl #2
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
       4:	03065506 	movweq	r5, #25862	; 0x6506
       8:	25081b08 	strcs	r1, [r8, #-2824]	; 0xb08
       c:	00051308 	andeq	r1, r5, r8, lsl #6
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
      10:	11010000 	mrsne	r0, (UNDEF: 1)
      14:	11061000 	mrsne	r1, (UNDEF: 6)
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
      18:	03011201 	movweq	r1, #4609	; 0x1201
      1c:	25081b08 	strcs	r1, [r8, #-2824]	; 0xb08
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
      20:	00051308 	andeq	r1, r5, r8, lsl #6
      24:	11010000 	mrsne	r0, (UNDEF: 1)
      28:	130e2501 	movwne	r2, #58625	; 0xe501
    if ((wEPVal & EP_CTR_RX) != 0)
      2c:	1b0e030b 	blne	380c60 <_etext+0x379748>
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
      30:	1117550e 	tstne	r7, lr, lsl #10
      34:	00171001 	andseq	r1, r7, r1
      38:	00240200 	eoreq	r0, r4, r0, lsl #4

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
      3c:	0b3e0b0b 	bleq	f82c70 <_etext+0xf7b758>

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
      40:	00000e03 	andeq	r0, r0, r3, lsl #28
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
      44:	0b002403 	bleq	9058 <_etext+0x1b40>
      48:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
      4c:	04000008 	streq	r0, [r0], #-8

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
      50:	0b0b000f 	bleq	2c0094 <_etext+0x2b8b7c>
      54:	00001349 	andeq	r1, r0, r9, asr #6
      58:	27001505 	strcs	r1, [r0, -r5, lsl #10]
      5c:	06000019 			; <UNDEFINED> instruction: 0x06000019
      60:	08030016 	stmdaeq	r3, {r1, r2, r4}
      64:	0b3b0b3a 	bleq	ec2d54 <_etext+0xebb83c>
      68:	00001349 	andeq	r1, r0, r9, asr #6
      6c:	03001607 	movweq	r1, #1543	; 0x607
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPDblBuffCount(u8 bEpNum, u8 bDir, u16 wCount)
{
  _SetEPDblBuffCount(bEpNum, bDir, wCount);
      70:	3b0b3a0e 	blcc	2ce8b0 <_etext+0x2c7398>
      74:	0013490b 	andseq	r4, r3, fp, lsl #18
      78:	00350800 	eorseq	r0, r5, r0, lsl #16
      7c:	00001349 	andeq	r1, r0, r9, asr #6
      80:	0b010409 	bleq	410ac <_etext+0x39b94>
      84:	3b0b3a0b 	blcc	2ce8b8 <_etext+0x2c73a0>
      88:	0013010b 	andseq	r0, r3, fp, lsl #2
      8c:	00280a00 	eoreq	r0, r8, r0, lsl #20
      90:	0d1c0e03 	ldceq	14, cr0, [ip, #-12]
      94:	130b0000 	movwne	r0, #45056	; 0xb000
      98:	3a0b0b01 	bcc	2c2ca4 <_etext+0x2bb78c>
      9c:	010b3b0b 	tsteq	fp, fp, lsl #22
      a0:	0c000013 	stceq	0, cr0, [r0], {19}
      a4:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
      a8:	0b3b0b3a 	bleq	ec2d98 <_etext+0xebb880>

	return f25519_eq(a, c);
      ac:	0b381349 	bleq	e04dd8 <_etext+0xdfd8c0>
      b0:	0d0d0000 	stceq	0, cr0, [sp, #-0]
      b4:	3a080300 	bcc	200cbc <_etext+0x1f97a4>
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
      b8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	f25519_normalize(ey);
      bc:	000b3813 	andeq	r3, fp, r3, lsl r8
      c0:	01040e00 	tsteq	r4, r0, lsl #28

	return ok;
}
      c4:	0b0b0e03 	bleq	2c38d8 <_etext+0x2bc3c0>
      c8:	0b3b0b3a 	bleq	ec2db8 <_etext+0xebb8a0>
      cc:	00001301 	andeq	r1, r0, r1, lsl #6
      d0:	0301130f 	movweq	r1, #4879	; 0x130f
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
      d4:	3a0b0b0e 	bcc	2c2d14 <_etext+0x2bb7fc>
      d8:	010b3b0b 	tsteq	fp, fp, lsl #22
		minusp[i] = c;
      dc:	10000013 	andne	r0, r0, r3, lsl r0
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
      e0:	19270115 	stmdbne	r7!, {r0, r2, r4, r8}
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
      e4:	13011349 	movwne	r1, #4937	; 0x1349

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
      e8:	05110000 	ldreq	r0, [r1, #-0]
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
      ec:	00134900 	andseq	r4, r3, r0, lsl #18
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
      f0:	01131200 	tsteq	r3, r0, lsl #4
      f4:	0b0b0803 	bleq	2c2108 <_etext+0x2babf0>
      f8:	0b3b0b3a 	bleq	ec2de8 <_etext+0xebb8d0>
      fc:	00001301 	andeq	r1, r0, r1, lsl #6
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     100:	0b011713 	bleq	45d54 <_etext+0x3e83c>

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
     104:	3b0b3a0b 	blcc	2ce938 <_etext+0x2c7420>
     108:	0013010b 	andseq	r0, r3, fp, lsl #2
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     10c:	000d1400 	andeq	r1, sp, r0, lsl #8
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
     110:	0b3a0803 	bleq	e82124 <_etext+0xe7ac0c>
     114:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     118:	2e150000 	cdpcs	0, 1, cr0, cr5, cr0, {0}
     11c:	03193f01 	tsteq	r9, #1, 30
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     120:	3b0b3a0e 	blcc	2ce960 <_etext+0x2c7448>
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
     124:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
     128:	010b2013 	tsteq	fp, r3, lsl r0
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
     12c:	16000013 			; <UNDEFINED> instruction: 0x16000013

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
     130:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
	i <<= 3;

	while (x) {
     134:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
     138:	00001349 	andeq	r1, r0, r9, asr #6
     13c:	3f002e17 	svccc	0x00002e17
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
     140:	3a0e0319 	bcc	380dac <_etext+0x379894>
	f25519_mul_c(z3, x1sq, 4);
     144:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     148:	000b2019 	andeq	r2, fp, r9, lsl r0
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	002e1800 	eoreq	r1, lr, r0, lsl #16
     150:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     154:	0b3b0b3a 	bleq	ec2e44 <_etext+0xebb92c>
	f25519_sub(b, x3, z3); /* D */
     158:	01111927 	tsteq	r1, r7, lsr #18
     15c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
	f25519_mul__distinct(da, a, b);
     160:	00194297 	mulseq	r9, r7, r2
     164:	002e1900 	eoreq	r1, lr, r0, lsl #18
     168:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}

	f25519_sub(b, x2, z2);
     16c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     170:	01111927 	tsteq	r1, r7, lsr #18
	f25519_add(a, x3, z3); /* C */
     174:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     178:	00194297 	mulseq	r9, r7, r2
     17c:	012e1a00 	teqeq	lr, r0, lsl #20
	f25519_mul__distinct(cb, a, b);
     180:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     184:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a

	f25519_add(a, da, cb);
     188:	13491927 	movtne	r1, #39207	; 0x9927
     18c:	06120111 			; <UNDEFINED> instruction: 0x06120111
     190:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
	f25519_mul__distinct(b, a, a);
     194:	00130119 	andseq	r0, r3, r9, lsl r1
     198:	00051b00 	andeq	r1, r5, r0, lsl #22
	f25519_mul__distinct(x5, z1, b);
     19c:	0b3a0e03 	bleq	e839b0 <_etext+0xe7c498>
     1a0:	1349053b 	movtne	r0, #38203	; 0x953b
     1a4:	00001702 	andeq	r1, r0, r2, lsl #14

	f25519_sub(a, da, cb);
     1a8:	0300051c 	movweq	r0, #1308	; 0x51c
     1ac:	3b0b3a0e 	blcc	2ce9ec <_etext+0x2c74d4>
	f25519_mul__distinct(b, a, a);
     1b0:	02134905 	andseq	r4, r3, #81920	; 0x14000
     1b4:	1d000018 	stcne	0, cr0, [r0, #-96]	; 0xffffffa0
     1b8:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	0b3a0e03 	bleq	e839d0 <_etext+0xe7c4b8>
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
     1c4:	06120111 			; <UNDEFINED> instruction: 0x06120111

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1c8:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     1cc:	00130119 	andseq	r0, r3, r9, lsl r1
     1d0:	010b1e00 	tsteq	fp, r0, lsl #28
     1d4:	06120111 			; <UNDEFINED> instruction: 0x06120111
		f25519_select(zm1, zm1, zm, bit);
     1d8:	00001301 	andeq	r1, r0, r1, lsl #6
     1dc:	0300341f 	movweq	r3, #1055	; 0x41f
     1e0:	3b0b3a0e 	blcc	2cea20 <_etext+0x2c7508>
		f25519_select(xm, xm, xms, bit);
     1e4:	02134905 	andseq	r4, r3, #81920	; 0x14000
     1e8:	20000017 	andcs	r0, r0, r7, lsl r0
     1ec:	00018289 	andeq	r8, r1, r9, lsl #5
		f25519_select(zm, zm, zms, bit);
     1f0:	13310111 	teqne	r1, #1073741828	; 0x40000004
     1f4:	89210000 	stmdbhi	r1!, {}	; <UNPREDICTABLE>
     1f8:	11010182 	smlabbne	r1, r2, r1, r0
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fc:	01133101 	tsteq	r3, r1, lsl #2
     200:	22000013 	andcs	r0, r0, #19
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     204:	0001828a 	andeq	r8, r1, sl, lsl #5
     208:	42911802 	addsmi	r1, r1, #131072	; 0x20000
	f25519_mul__distinct(result, zm1, xm);
     20c:	23000018 	movwcs	r0, #24
     210:	01018289 	smlabbeq	r1, r9, r2, r8
	f25519_normalize(result);
     214:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
     218:	00133119 	andseq	r3, r3, r9, lsl r1
}
     21c:	82892400 	addhi	r2, r9, #0, 8
     220:	01110101 	tsteq	r1, r1, lsl #2
     224:	05250000 	streq	r0, [r5, #-0]!
     228:	3a080300 	bcc	200e30 <_etext+0x1f9918>
     22c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     230:	00170213 	andseq	r0, r7, r3, lsl r2
     234:	82892600 	addhi	r2, r9, #0, 12
     238:	01110001 	tsteq	r1, r1
     23c:	31194295 			; <UNDEFINED> instruction: 0x31194295
     240:	27000013 	smladcs	r0, r3, r0, r0
     244:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     248:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     24c:	00001349 	andeq	r1, r0, r9, asr #6
     250:	31012e28 	tstcc	r1, r8, lsr #28
     254:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     258:	97184006 	ldrls	r4, [r8, -r6]
     25c:	13011942 	movwne	r1, #6466	; 0x1942
     260:	05290000 	streq	r0, [r9, #-0]!
     264:	02133100 	andseq	r3, r3, #0, 2
     268:	2a000017 	bcs	2cc <GPIO_ReadOutputDataBit>
     26c:	0111010b 	tsteq	r1, fp, lsl #2
     270:	00000612 	andeq	r0, r0, r2, lsl r6
     274:	3f012e2b 	svccc	0x00012e2b
     278:	3a0e0319 	bcc	380ee4 <_etext+0x3799cc>
     27c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     280:	12011119 	andne	r1, r1, #1073741830	; 0x40000006
     284:	97184006 	ldrls	r4, [r8, -r6]
     288:	13011942 	movwne	r1, #6466	; 0x1942
     28c:	342c0000 	strtcc	r0, [ip], #-0
     290:	3a0e0300 	bcc	380e98 <_etext+0x379980>
     294:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     298:	00180213 	andseq	r0, r8, r3, lsl r2
     29c:	011d2d00 	tsteq	sp, r0, lsl #26
     2a0:	01111331 	tsteq	r1, r1, lsr r3
     2a4:	0b580612 	bleq	1601af4 <_etext+0x15fa5dc>
     2a8:	13010b59 	movwne	r0, #7001	; 0x1b59
     2ac:	342e0000 	strtcc	r0, [lr], #-0
     2b0:	3a0e0300 	bcc	380eb8 <_etext+0x3799a0>
     2b4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     2b8:	00170213 	andseq	r0, r7, r3, lsl r2
     2bc:	00052f00 	andeq	r2, r5, r0, lsl #30
     2c0:	0b3a0e03 	bleq	e83ad4 <_etext+0xe7c5bc>
     2c4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     2c8:	00001702 	andeq	r1, r0, r2, lsl #14
     2cc:	3f012e30 	svccc	0x00012e30
     2d0:	3a0e0319 	bcc	380f3c <_etext+0x379a24>
     2d4:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     2d8:	11134919 	tstne	r3, r9, lsl r9
     2dc:	40061201 	andmi	r1, r6, r1, lsl #4
     2e0:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
     2e4:	00001301 	andeq	r1, r0, r1, lsl #6
     2e8:	01828931 	orreq	r8, r2, r1, lsr r9
     2ec:	31011101 	tstcc	r1, r1, lsl #2
     2f0:	32000013 	andcc	r0, r0, #19
     2f4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     2f8:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     2fc:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     300:	2e330000 	cdpcs	0, 3, cr0, cr3, cr0, {0}
     304:	03193f01 	tsteq	r9, #1, 30
     308:	3b0b3a0e 	blcc	2ceb48 <_etext+0x2c7630>
     30c:	11192705 	tstne	r9, r5, lsl #14
     310:	40061201 	andmi	r1, r6, r1, lsl #4
     314:	19429618 	stmdbne	r2, {r3, r4, r9, sl, ip, pc}^
     318:	00001301 	andeq	r1, r0, r1, lsl #6
     31c:	3f002e34 	svccc	0x00002e34
     320:	3a0e0319 	bcc	380f8c <_etext+0x379a74>
     324:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     328:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     32c:	97184006 	ldrls	r4, [r8, -r6]
     330:	00001942 	andeq	r1, r0, r2, asr #18
     334:	03003435 	movweq	r3, #1077	; 0x435
     338:	3b0b3a0e 	blcc	2ceb78 <_etext+0x2c7660>
     33c:	1c13490b 	ldcne	9, cr4, [r3], {11}
     340:	36000006 	strcc	r0, [r0], -r6
     344:	13490026 	movtne	r0, #36902	; 0x9026
     348:	34370000 	ldrtcc	r0, [r7], #-0
     34c:	3a0e0300 	bcc	380f54 <_etext+0x379a3c>
     350:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     354:	02193f13 	andseq	r3, r9, #19, 30	; 0x4c
     358:	38000018 	stmdacc	r0, {r3, r4}
     35c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     360:	0b3b0b3a 	bleq	ec3050 <_etext+0xebbb38>
     364:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
     368:	0000193c 	andeq	r1, r0, ip, lsr r9
     36c:	49010139 	stmdbmi	r1, {r0, r3, r4, r5, r8}
     370:	00130113 	andseq	r0, r3, r3, lsl r1
     374:	00213a00 	eoreq	r3, r1, r0, lsl #20
     378:	0b2f1349 	bleq	bc50a4 <_etext+0xbbdb8c>
     37c:	213b0000 	teqcs	fp, r0
     380:	3c000000 	stccc	0, cr0, [r0], {-0}
     384:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
     388:	0b3a0e03 	bleq	e83b9c <_etext+0xe7c684>
     38c:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     390:	0000193c 	andeq	r1, r0, ip, lsr r9
     394:	3f012e3d 	svccc	0x00012e3d
     398:	3a0e0319 	bcc	381004 <_etext+0x379aec>
     39c:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     3a0:	01193c19 	tsteq	r9, r9, lsl ip
     3a4:	3e000013 	mcrcc	0, 0, r0, cr0, cr3, {0}
     3a8:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     3ac:	0b3a0e03 	bleq	e83bc0 <_etext+0xe7c6a8>
     3b0:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     3b4:	1301193c 	movwne	r1, #6460	; 0x193c
     3b8:	2e3f0000 	cdpcs	0, 3, cr0, cr15, cr0, {0}
     3bc:	03193f00 	tsteq	r9, #0, 30
     3c0:	3b0b3a0e 	blcc	2cec00 <_etext+0x2c76e8>
     3c4:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
     3c8:	00193c13 	andseq	r3, r9, r3, lsl ip
     3cc:	012e4000 	teqeq	lr, r0
     3d0:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     3d4:	0b3b0b3a 	bleq	ec30c4 <_etext+0xebbbac>
     3d8:	13491927 	movtne	r1, #39207	; 0x9927
     3dc:	1301193c 	movwne	r1, #6460	; 0x193c
     3e0:	2e410000 	cdpcs	0, 4, cr0, cr1, cr0, {0}
     3e4:	03193f01 	tsteq	r9, #1, 30
     3e8:	3b0b3a0e 	blcc	2cec28 <_etext+0x2c7710>
     3ec:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
     3f0:	01193c13 	tsteq	r9, r3, lsl ip
     3f4:	42000013 	andmi	r0, r0, #19
     3f8:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
     3fc:	0b3a0e03 	bleq	e83c10 <_etext+0xe7c6f8>
     400:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
     404:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
     408:	01000000 	mrseq	r0, (UNDEF: 0)
     40c:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     410:	0e030b13 	vmoveq.32	d3[0], r0
     414:	17100e1b 			; <UNDEFINED> instruction: 0x17100e1b
     418:	24020000 	strcs	r0, [r2], #-0
     41c:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     420:	0008030b 	andeq	r0, r8, fp, lsl #6
     424:	00240300 	eoreq	r0, r4, r0, lsl #6
     428:	0b3e0b0b 	bleq	f8305c <_etext+0xf7bb44>
     42c:	00000e03 	andeq	r0, r0, r3, lsl #28
     430:	03001604 	movweq	r1, #1540	; 0x604
     434:	3b0b3a08 	blcc	2cec5c <_etext+0x2c7744>
     438:	0013490b 	andseq	r4, r3, fp, lsl #18
     43c:	01130500 	tsteq	r3, r0, lsl #10
     440:	0b0b0e03 	bleq	2c3c54 <_etext+0x2bc73c>
     444:	0b3b0b3a 	bleq	ec3134 <_etext+0xebbc1c>
     448:	00001301 	andeq	r1, r0, r1, lsl #6
     44c:	03000d06 	movweq	r0, #3334	; 0xd06
     450:	3b0b3a0e 	blcc	2cec90 <_etext+0x2c7778>
     454:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     458:	0700000b 	streq	r0, [r0, -fp]
     45c:	0b0b000f 	bleq	2c04a0 <_etext+0x2b8f88>
     460:	00001349 	andeq	r1, r0, r9, asr #6
     464:	03001608 	movweq	r1, #1544	; 0x608
     468:	3b0b3a0e 	blcc	2ceca8 <_etext+0x2c7790>
     46c:	0013490b 	andseq	r4, r3, fp, lsl #18
     470:	00340900 	eorseq	r0, r4, r0, lsl #18
     474:	0b3a0e03 	bleq	e83c88 <_etext+0xe7c770>
     478:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     47c:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
     480:	010a0000 	mrseq	r0, (UNDEF: 10)
     484:	01134901 	tsteq	r3, r1, lsl #18
     488:	0b000013 	bleq	4dc <RCC_GetSYSCLKSource>
     48c:	13490021 	movtne	r0, #36897	; 0x9021
     490:	00000b2f 	andeq	r0, r0, pc, lsr #22
     494:	01110100 	tsteq	r1, r0, lsl #2
     498:	0b130e25 	bleq	4c3d34 <_etext+0x4bc81c>
     49c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     4a0:	01111755 	tsteq	r1, r5, asr r7
     4a4:	00001710 	andeq	r1, r0, r0, lsl r7
     4a8:	03001602 	movweq	r1, #1538	; 0x602
     4ac:	3b0b3a0e 	blcc	2cecec <_etext+0x2c77d4>
     4b0:	0013490b 	andseq	r4, r3, fp, lsl #18
     4b4:	00240300 	eoreq	r0, r4, r0, lsl #6
     4b8:	0b3e0b0b 	bleq	f830ec <_etext+0xf7bbd4>
     4bc:	00000e03 	andeq	r0, r0, r3, lsl #28
     4c0:	0b002404 	bleq	94d8 <_etext+0x1fc0>
     4c4:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     4c8:	05000008 	streq	r0, [r0, #-8]
     4cc:	0b0b000f 	bleq	2c0510 <_etext+0x2b8ff8>
     4d0:	00001349 	andeq	r1, r0, r9, asr #6
     4d4:	49002606 	stmdbmi	r0, {r1, r2, r9, sl, sp}
     4d8:	07000013 	smladeq	r0, r3, r0, r0
     4dc:	08030016 	stmdaeq	r3, {r1, r2, r4}
     4e0:	0b3b0b3a 	bleq	ec31d0 <_etext+0xebbcb8>
     4e4:	00001349 	andeq	r1, r0, r9, asr #6
     4e8:	49003508 	stmdbmi	r0, {r3, r8, sl, ip, sp}
     4ec:	09000013 	stmdbeq	r0, {r0, r1, r4}
     4f0:	0b0b0104 	bleq	2c0908 <_etext+0x2b93f0>
     4f4:	0b3b0b3a 	bleq	ec31e4 <_etext+0xebbccc>
     4f8:	00001301 	andeq	r1, r0, r1, lsl #6
     4fc:	0300280a 	movweq	r2, #2058	; 0x80a
     500:	000d1c0e 	andeq	r1, sp, lr, lsl #24
     504:	01130b00 	tsteq	r3, r0, lsl #22
     508:	0b0b0e03 	bleq	2c3d1c <_etext+0x2bc804>
     50c:	0b3b0b3a 	bleq	ec31fc <_etext+0xebbce4>
     510:	00001301 	andeq	r1, r0, r1, lsl #6
     514:	03000d0c 	movweq	r0, #3340	; 0xd0c
     518:	3b0b3a0e 	blcc	2ced58 <_etext+0x2c7840>
     51c:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     520:	0d00000b 	stceq	0, cr0, [r0, #-44]	; 0xffffffd4
     524:	13490101 	movtne	r0, #37121	; 0x9101
     528:	00001301 	andeq	r1, r0, r1, lsl #6
     52c:	4900210e 	stmdbmi	r0, {r1, r2, r3, r8, sp}
     530:	0f000013 	svceq	0x00000013
     534:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     538:	0b3a0e03 	bleq	e83d4c <_etext+0xe7c834>
     53c:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     540:	06120111 			; <UNDEFINED> instruction: 0x06120111
     544:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     548:	00130119 	andseq	r0, r3, r9, lsl r1
     54c:	00051000 	andeq	r1, r5, r0
     550:	0b3a0e03 	bleq	e83d64 <_etext+0xe7c84c>
     554:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     558:	00001802 	andeq	r1, r0, r2, lsl #16
     55c:	03003411 	movweq	r3, #1041	; 0x411
     560:	3b0b3a08 	blcc	2ced88 <_etext+0x2c7870>
     564:	1c13490b 	ldcne	9, cr4, [r3], {11}
     568:	1200000b 	andne	r0, r0, #11
     56c:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     570:	0b3a0e03 	bleq	e83d84 <_etext+0xe7c86c>
     574:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     578:	06120111 			; <UNDEFINED> instruction: 0x06120111
     57c:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     580:	00130119 	andseq	r0, r3, r9, lsl r1
     584:	00341300 	eorseq	r1, r4, r0, lsl #6
     588:	0b3a0e03 	bleq	e83d9c <_etext+0xe7c884>
     58c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     590:	00001702 	andeq	r1, r0, r2, lsl #14
     594:	03003414 	movweq	r3, #1044	; 0x414
     598:	3b0b3a0e 	blcc	2cedd8 <_etext+0x2c78c0>
     59c:	1c13490b 	ldcne	9, cr4, [r3], {11}
     5a0:	1500000b 	strne	r0, [r0, #-11]
     5a4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     5a8:	0b3b0b3a 	bleq	ec3298 <_etext+0xebbd80>
     5ac:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     5b0:	34160000 	ldrcc	r0, [r6], #-0
     5b4:	3a080300 	bcc	2011bc <_etext+0x1f9ca4>
     5b8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     5bc:	00170213 	andseq	r0, r7, r3, lsl r2
     5c0:	82891700 	addhi	r1, r9, #0, 14
     5c4:	01110001 	tsteq	r1, r1
     5c8:	00001331 	andeq	r1, r0, r1, lsr r3
     5cc:	01828918 	orreq	r8, r2, r8, lsl r9
     5d0:	31011101 	tstcc	r1, r1, lsl #2
     5d4:	00130113 	andseq	r0, r3, r3, lsl r1
     5d8:	828a1900 	addhi	r1, sl, #0, 18
     5dc:	18020001 	stmdane	r2, {r0}
     5e0:	00184291 	mulseq	r8, r1, r2
     5e4:	82891a00 	addhi	r1, r9, #0, 20
     5e8:	01110101 	tsteq	r1, r1, lsl #2
     5ec:	00001331 	andeq	r1, r0, r1, lsr r3
     5f0:	0300341b 	movweq	r3, #1051	; 0x41b
     5f4:	3b0b3a0e 	blcc	2cee34 <_etext+0x2c791c>
     5f8:	3f13490b 	svccc	0x0013490b
     5fc:	00180219 	andseq	r0, r8, r9, lsl r2
     600:	002e1c00 	eoreq	r1, lr, r0, lsl #24
     604:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     608:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     60c:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
     610:	2e1d0000 	cdpcs	0, 1, cr0, cr13, cr0, {0}
     614:	03193f00 	tsteq	r9, #0, 30
     618:	3b0b3a0e 	blcc	2cee58 <_etext+0x2c7940>
     61c:	3c19270b 	ldccc	7, cr2, [r9], {11}
     620:	1e000019 	mcrne	0, 0, r0, cr0, cr9, {0}
     624:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     628:	0b3a0e03 	bleq	e83e3c <_etext+0xe7c924>
     62c:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
     630:	1301193c 	movwne	r1, #6460	; 0x193c
     634:	051f0000 	ldreq	r0, [pc, #-0]	; 63c <RCC_AHBPeriphClockCmd+0x4>
     638:	00134900 	andseq	r4, r3, r0, lsl #18
     63c:	00182000 	andseq	r2, r8, r0
     640:	2e210000 	cdpcs	0, 2, cr0, cr1, cr0, {0}
     644:	03193f01 	tsteq	r9, #1, 30
     648:	3b0b3a0e 	blcc	2cee88 <_etext+0x2c7970>
     64c:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
     650:	01193c13 	tsteq	r9, r3, lsl ip
     654:	22000013 	andcs	r0, r0, #19
     658:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     65c:	0b3a0e03 	bleq	e83e70 <_etext+0xe7c958>
     660:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     664:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
     668:	00001301 	andeq	r1, r0, r1, lsl #6
     66c:	3f012e23 	svccc	0x00012e23
     670:	3a0e0319 	bcc	3812dc <_etext+0x379dc4>
     674:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     678:	01193c13 	tsteq	r9, r3, lsl ip
     67c:	24000013 	strcs	r0, [r0], #-19
     680:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     684:	0b3a0e03 	bleq	e83e98 <_etext+0xe7c980>
     688:	193c0b3b 	ldmdbne	ip!, {r0, r1, r3, r4, r5, r8, r9, fp}
     68c:	00001301 	andeq	r1, r0, r1, lsl #6
     690:	3f012e25 	svccc	0x00012e25
     694:	3a0e0319 	bcc	381300 <_etext+0x379de8>
     698:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     69c:	00193c19 	andseq	r3, r9, r9, lsl ip
     6a0:	11010000 	mrsne	r0, (UNDEF: 1)
     6a4:	130e2501 	movwne	r2, #58625	; 0xe501
     6a8:	1b0e030b 	blne	3812dc <_etext+0x379dc4>
     6ac:	1117550e 	tstne	r7, lr, lsl #10
     6b0:	00171001 	andseq	r1, r7, r1
     6b4:	00160200 	andseq	r0, r6, r0, lsl #4
     6b8:	0b3a0e03 	bleq	e83ecc <_etext+0xe7c9b4>
     6bc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     6c0:	24030000 	strcs	r0, [r3], #-0
     6c4:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     6c8:	000e030b 	andeq	r0, lr, fp, lsl #6
     6cc:	01130400 	tsteq	r3, r0, lsl #8
     6d0:	0b0b0e03 	bleq	2c3ee4 <_etext+0x2bc9cc>
     6d4:	0b3b0b3a 	bleq	ec33c4 <_etext+0xebbeac>
     6d8:	00001301 	andeq	r1, r0, r1, lsl #6
     6dc:	03000d05 	movweq	r0, #3333	; 0xd05
     6e0:	3813490e 	ldmdacc	r3, {r1, r2, r3, r8, fp, lr}
     6e4:	0019340b 	andseq	r3, r9, fp, lsl #8
     6e8:	000f0600 	andeq	r0, pc, r0, lsl #12
     6ec:	00000b0b 	andeq	r0, r0, fp, lsl #22
     6f0:	0b002407 	bleq	9714 <_etext+0x21fc>
     6f4:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     6f8:	08000008 	stmdaeq	r0, {r3}
     6fc:	0b0b000f 	bleq	2c0740 <_etext+0x2b9228>
     700:	00001349 	andeq	r1, r0, r9, asr #6
     704:	27001509 	strcs	r1, [r0, -r9, lsl #10]
     708:	0a000019 	beq	774 <USART_DeInit+0x3c>
     70c:	13490026 	movtne	r0, #36902	; 0x9026
     710:	160b0000 	strne	r0, [fp], -r0
     714:	3a080300 	bcc	20131c <_etext+0x1f9e04>
     718:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     71c:	0c000013 	stceq	0, cr0, [r0], {19}
     720:	13490035 	movtne	r0, #36917	; 0x9035
     724:	040d0000 	streq	r0, [sp], #-0
     728:	3a0b0b01 	bcc	2c3334 <_etext+0x2bbe1c>
     72c:	010b3b0b 	tsteq	fp, fp, lsl #22
     730:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     734:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
     738:	00000d1c 	andeq	r0, r0, ip, lsl sp
     73c:	0b01130f 	bleq	45380 <_etext+0x3de68>
     740:	3b0b3a0b 	blcc	2cef74 <_etext+0x2c7a5c>
     744:	0013010b 	andseq	r0, r3, fp, lsl #2
     748:	000d1000 	andeq	r1, sp, r0
     74c:	0b3a0803 	bleq	e82760 <_etext+0xe7b248>
     750:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     754:	00000b38 	andeq	r0, r0, r8, lsr fp
     758:	03000d11 	movweq	r0, #3345	; 0xd11
     75c:	3b0b3a0e 	blcc	2cef9c <_etext+0x2c7a84>
     760:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     764:	1200000b 	andne	r0, r0, #11
     768:	050b0113 	streq	r0, [fp, #-275]	; 0x113
     76c:	0b3b0b3a 	bleq	ec345c <_etext+0xebbf44>
     770:	00001301 	andeq	r1, r0, r1, lsl #6
     774:	03000d13 	movweq	r0, #3347	; 0xd13
     778:	3b0b3a0e 	blcc	2cefb8 <_etext+0x2c7aa0>
     77c:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     780:	14000005 	strne	r0, [r0], #-5
     784:	0803000d 	stmdaeq	r3, {r0, r2, r3}
     788:	0b3b0b3a 	bleq	ec3478 <_etext+0xebbf60>
     78c:	05381349 	ldreq	r1, [r8, #-841]!	; 0x349
     790:	01150000 	tsteq	r5, r0
     794:	01134901 	tsteq	r3, r1, lsl #18
     798:	16000013 			; <UNDEFINED> instruction: 0x16000013
     79c:	13490021 	movtne	r0, #36897	; 0x9021
     7a0:	00000b2f 	andeq	r0, r0, pc, lsr #22
     7a4:	03000d17 	movweq	r0, #3351	; 0xd17
     7a8:	3b0b3a08 	blcc	2cefd0 <_etext+0x2c7ab8>
     7ac:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
     7b0:	1800000b 	stmdane	r0, {r0, r1, r3}
     7b4:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     7b8:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     7bc:	0b381349 	bleq	e054e8 <_etext+0xdfdfd0>
     7c0:	13190000 	tstne	r9, #0
     7c4:	0b0e0301 	bleq	3813d0 <_etext+0x379eb8>
     7c8:	3b0b3a0b 	blcc	2ceffc <_etext+0x2c7ae4>
     7cc:	00130105 	andseq	r0, r3, r5, lsl #2
     7d0:	012e1a00 	teqeq	lr, r0, lsl #20
     7d4:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     7d8:	0b3b0b3a 	bleq	ec34c8 <_etext+0xebbfb0>
     7dc:	01111927 	tsteq	r1, r7, lsr #18
     7e0:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     7e4:	01194297 			; <UNDEFINED> instruction: 0x01194297
     7e8:	1b000013 	blne	83c <__Stack_Size+0x3c>
     7ec:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     7f0:	0b3b0b3a 	bleq	ec34e0 <_etext+0xebbfc8>
     7f4:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     7f8:	051c0000 	ldreq	r0, [ip, #-0]
     7fc:	3a080300 	bcc	201404 <_etext+0x1f9eec>
     800:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     804:	00170213 	andseq	r0, r7, r3, lsl r2
     808:	012e1d00 	teqeq	lr, r0, lsl #26
     80c:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     810:	0b3b0b3a 	bleq	ec3500 <_etext+0xebbfe8>
     814:	13491927 	movtne	r1, #39207	; 0x9927
     818:	06120111 			; <UNDEFINED> instruction: 0x06120111
     81c:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     820:	00130119 	andseq	r0, r3, r9, lsl r1
     824:	00051e00 	andeq	r1, r5, r0, lsl #28
     828:	0b3a0e03 	bleq	e8403c <_etext+0xe7cb24>
     82c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     830:	00001702 	andeq	r1, r0, r2, lsl #14
     834:	0300341f 	movweq	r3, #1055	; 0x41f
     838:	3b0b3a08 	blcc	2cf060 <_etext+0x2c7b48>
     83c:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     840:	20000017 	andcs	r0, r0, r7, lsl r0
     844:	01018289 	smlabbeq	r1, r9, r2, r8
     848:	13310111 	teqne	r1, #1073741828	; 0x40000004
     84c:	00001301 	andeq	r1, r0, r1, lsl #6
     850:	01828a21 	orreq	r8, r2, r1, lsr #20
     854:	91180200 	tstls	r8, r0, lsl #4
     858:	00001842 	andeq	r1, r0, r2, asr #16
     85c:	01828922 	orreq	r8, r2, r2, lsr #18
     860:	31011101 	tstcc	r1, r1, lsl #2
     864:	23000013 	movwcs	r0, #19
     868:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     86c:	0b3a0e03 	bleq	e84080 <_etext+0xe7cb68>
     870:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
     874:	06120111 			; <UNDEFINED> instruction: 0x06120111
     878:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     87c:	00130119 	andseq	r0, r3, r9, lsl r1
     880:	00052400 	andeq	r2, r5, r0, lsl #8
     884:	0b3a0e03 	bleq	e84098 <_etext+0xe7cb80>
     888:	1349053b 	movtne	r0, #38203	; 0x953b
     88c:	00001802 	andeq	r1, r0, r2, lsl #16
     890:	03000525 	movweq	r0, #1317	; 0x525
     894:	3b0b3a08 	blcc	2cf0bc <_etext+0x2c7ba4>
     898:	02134905 	andseq	r4, r3, #81920	; 0x14000
     89c:	26000018 			; <UNDEFINED> instruction: 0x26000018
     8a0:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     8a4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     8a8:	17021349 	strne	r1, [r2, -r9, asr #6]
     8ac:	05270000 	streq	r0, [r7, #-0]!
     8b0:	3a080300 	bcc	2014b8 <_etext+0x1f9fa0>
     8b4:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     8b8:	00170213 	andseq	r0, r7, r3, lsl r2
     8bc:	00342800 	eorseq	r2, r4, r0, lsl #16
     8c0:	0b3a0e03 	bleq	e840d4 <_etext+0xe7cbbc>
     8c4:	1349053b 	movtne	r0, #38203	; 0x953b
     8c8:	00001802 	andeq	r1, r0, r2, lsl #16
     8cc:	00001829 	andeq	r1, r0, r9, lsr #16
     8d0:	00342a00 	eorseq	r2, r4, r0, lsl #20
     8d4:	0b3a0803 	bleq	e828e8 <_etext+0xe7b3d0>
     8d8:	1349053b 	movtne	r0, #38203	; 0x953b
     8dc:	00001702 	andeq	r1, r0, r2, lsl #14
     8e0:	0300342b 	movweq	r3, #1067	; 0x42b
     8e4:	3b0b3a08 	blcc	2cf10c <_etext+0x2c7bf4>
     8e8:	02134905 	andseq	r4, r3, #81920	; 0x14000
     8ec:	2c000018 	stccs	0, cr0, [r0], {24}
     8f0:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     8f4:	0b3a0e03 	bleq	e84108 <_etext+0xe7cbf0>
     8f8:	1349053b 	movtne	r0, #38203	; 0x953b
     8fc:	1301193c 	movwne	r1, #6460	; 0x193c
     900:	2e2d0000 	cdpcs	0, 2, cr0, cr13, cr0, {0}
     904:	03193f00 	tsteq	r9, #0, 30
     908:	3b0b3a0e 	blcc	2cf148 <_etext+0x2c7c30>
     90c:	11192705 	tstne	r9, r5, lsl #14
     910:	40061201 	andmi	r1, r6, r1, lsl #4
     914:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
     918:	342e0000 	strtcc	r0, [lr], #-0
     91c:	3a0e0300 	bcc	381524 <_etext+0x37a00c>
     920:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     924:	000b1c13 	andeq	r1, fp, r3, lsl ip
     928:	012e2f00 	teqeq	lr, r0, lsl #30
     92c:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     930:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     934:	13491927 	movtne	r1, #39207	; 0x9927
     938:	13010b20 	movwne	r0, #6944	; 0x1b20
     93c:	05300000 	ldreq	r0, [r0, #-0]!
     940:	3a080300 	bcc	201548 <_etext+0x1fa030>
     944:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     948:	31000013 	tstcc	r0, r3, lsl r0
     94c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     950:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     954:	00001349 	andeq	r1, r0, r9, asr #6
     958:	11010b32 	tstne	r1, r2, lsr fp
     95c:	00061201 	andeq	r1, r6, r1, lsl #4
     960:	00343300 	eorseq	r3, r4, r0, lsl #6
     964:	0b3a0e03 	bleq	e84178 <_etext+0xe7cc60>
     968:	1349053b 	movtne	r0, #38203	; 0x953b
     96c:	00001702 	andeq	r1, r0, r2, lsl #14
     970:	3f012e34 	svccc	0x00012e34
     974:	3a0e0319 	bcc	3815e0 <_etext+0x37a0c8>
     978:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     97c:	11134919 	tstne	r3, r9, lsl r9
     980:	40061201 	andmi	r1, r6, r1, lsl #4
     984:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
     988:	00001301 	andeq	r1, r0, r1, lsl #6
     98c:	3f012e35 	svccc	0x00012e35
     990:	3a0e0319 	bcc	3815fc <_etext+0x37a0e4>
     994:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     998:	12011119 	andne	r1, r1, #1073741830	; 0x40000006
     99c:	96184006 	ldrls	r4, [r8], -r6
     9a0:	13011942 	movwne	r1, #6466	; 0x1942
     9a4:	16360000 	ldrtne	r0, [r6], -r0
     9a8:	3a0e0300 	bcc	3815b0 <_etext+0x37a098>
     9ac:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     9b0:	37000013 	smladcc	r0, r3, r0, r0
     9b4:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     9b8:	0b3a0e03 	bleq	e841cc <_etext+0xe7ccb4>
     9bc:	1349053b 	movtne	r0, #38203	; 0x953b
     9c0:	06120111 			; <UNDEFINED> instruction: 0x06120111
     9c4:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     9c8:	00130119 	andseq	r0, r3, r9, lsl r1
     9cc:	00343800 	eorseq	r3, r4, r0, lsl #16
     9d0:	0b3a0e03 	bleq	e841e4 <_etext+0xe7cccc>
     9d4:	1349053b 	movtne	r0, #38203	; 0x953b
     9d8:	00000d1c 	andeq	r0, r0, ip, lsl sp
     9dc:	01828939 	orreq	r8, r2, r9, lsr r9
     9e0:	31011100 	mrscc	r1, (UNDEF: 17)
     9e4:	3a000013 	bcc	a38 <USART_SmartCardNACKCmd>
     9e8:	01018289 	smlabbeq	r1, r9, r2, r8
     9ec:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
     9f0:	00133119 	andseq	r3, r3, r9, lsl r1
     9f4:	012e3b00 	teqeq	lr, r0, lsl #22
     9f8:	01111331 	tsteq	r1, r1, lsr r3
     9fc:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     a00:	01194297 			; <UNDEFINED> instruction: 0x01194297
     a04:	3c000013 	stccc	0, cr0, [r0], {19}
     a08:	13310005 	teqne	r1, #5
     a0c:	00001702 	andeq	r1, r0, r2, lsl #14
     a10:	3100343d 	tstcc	r0, sp, lsr r4
     a14:	00170213 	andseq	r0, r7, r3, lsl r2
     a18:	00343e00 	eorseq	r3, r4, r0, lsl #28
     a1c:	0b3a0e03 	bleq	e84230 <_etext+0xe7cd18>
     a20:	1349053b 	movtne	r0, #38203	; 0x953b
     a24:	0000061c 	andeq	r0, r0, ip, lsl r6
     a28:	0300343f 	movweq	r3, #1087	; 0x43f
     a2c:	3b0b3a0e 	blcc	2cf26c <_etext+0x2c7d54>
     a30:	3f13490b 	svccc	0x0013490b
     a34:	00180219 	andseq	r0, r8, r9, lsl r2
     a38:	012e4000 	teqeq	lr, r0
     a3c:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     a40:	0b3b0b3a 	bleq	ec3730 <_etext+0xebc218>
     a44:	13491927 	movtne	r1, #39207	; 0x9927
     a48:	1301193c 	movwne	r1, #6460	; 0x193c
     a4c:	05410000 	strbeq	r0, [r1, #-0]
     a50:	00134900 	andseq	r4, r3, r0, lsl #18
     a54:	012e4200 	teqeq	lr, r0, lsl #4
     a58:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     a5c:	13491927 	movtne	r1, #39207	; 0x9927
     a60:	193c1934 	ldmdbne	ip!, {r2, r4, r5, r8, fp, ip}
     a64:	00001301 	andeq	r1, r0, r1, lsl #6
     a68:	3f012e43 	svccc	0x00012e43
     a6c:	3a0e0319 	bcc	3816d8 <_etext+0x37a1c0>
     a70:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     a74:	01193c19 	tsteq	r9, r9, lsl ip
     a78:	44000013 	strmi	r0, [r0], #-19
     a7c:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
     a80:	0b3a0e03 	bleq	e84294 <_etext+0xe7cd7c>
     a84:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     a88:	0000193c 	andeq	r1, r0, ip, lsr r9
     a8c:	01110100 	tsteq	r1, r0, lsl #2
     a90:	0b130e25 	bleq	4c432c <_etext+0x4bce14>
     a94:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     a98:	01111755 	tsteq	r1, r5, asr r7
     a9c:	00001710 	andeq	r1, r0, r0, lsl r7
     aa0:	0b002402 	bleq	9ab0 <_etext+0x2598>
     aa4:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     aa8:	0300000e 	movweq	r0, #14
     aac:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     ab0:	0b3b0b3a 	bleq	ec37a0 <_etext+0xebc288>
     ab4:	00001349 	andeq	r1, r0, r9, asr #6
     ab8:	0b002404 	bleq	9ad0 <_etext+0x25b8>
     abc:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     ac0:	05000008 	streq	r0, [r0, #-8]
     ac4:	08030016 	stmdaeq	r3, {r1, r2, r4}
     ac8:	0b3b0b3a 	bleq	ec37b8 <_etext+0xebc2a0>
     acc:	00001349 	andeq	r1, r0, r9, asr #6
     ad0:	49003506 	stmdbmi	r0, {r1, r2, r8, sl, ip, sp}
     ad4:	07000013 	smladeq	r0, r3, r0, r0
     ad8:	0b0b0104 	bleq	2c0ef0 <_etext+0x2b99d8>
     adc:	0b3b0b3a 	bleq	ec37cc <_etext+0xebc2b4>
     ae0:	00001301 	andeq	r1, r0, r1, lsl #6
     ae4:	03002808 	movweq	r2, #2056	; 0x808
     ae8:	000d1c0e 	andeq	r1, sp, lr, lsl #24
     aec:	000f0900 	andeq	r0, pc, r0, lsl #18
     af0:	00000b0b 	andeq	r0, r0, fp, lsl #22
     af4:	0b000f0a 	bleq	4724 <sha256_process+0x16f0>
     af8:	0013490b 	andseq	r4, r3, fp, lsl #18
     afc:	00260b00 	eoreq	r0, r6, r0, lsl #22
     b00:	00001349 	andeq	r1, r0, r9, asr #6
     b04:	0301130c 	movweq	r1, #4876	; 0x130c
     b08:	3a0b0b0e 	bcc	2c3748 <_etext+0x2bc230>
     b0c:	010b3b0b 	tsteq	fp, fp, lsl #22
     b10:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
     b14:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     b18:	0b3b0b3a 	bleq	ec3808 <_etext+0xebc2f0>
     b1c:	0b381349 	bleq	e05848 <_etext+0xdfe330>
     b20:	150e0000 	strne	r0, [lr, #-0]
     b24:	49192701 	ldmdbmi	r9, {r0, r8, r9, sl, sp}
     b28:	00130113 	andseq	r0, r3, r3, lsl r1
     b2c:	00050f00 	andeq	r0, r5, r0, lsl #30
     b30:	00001349 	andeq	r1, r0, r9, asr #6
     b34:	03011310 	movweq	r1, #4880	; 0x1310
     b38:	3a0b0b08 	bcc	2c3760 <_etext+0x2bc248>
     b3c:	010b3b0b 	tsteq	fp, fp, lsl #22
     b40:	11000013 	tstne	r0, r3, lsl r0
     b44:	0803000d 	stmdaeq	r3, {r0, r2, r3}
     b48:	0b3b0b3a 	bleq	ec3838 <_etext+0xebc320>
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	0b381349 	bleq	e05878 <_etext+0xdfe360>
  b	LoopCopyDataInit
     b50:	17120000 	ldrne	r0, [r2, -r0]

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
     b54:	3a0b0b01 	bcc	2c3760 <_etext+0x2bc248>
	str	r3, [r0, r1]
	adds	r1, r1, #4
     b58:	010b3b0b 	tsteq	fp, fp, lsl #22

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
     b5c:	13000013 	movwne	r0, #19
	adds	r2, r0, r1
	cmp	r2, r3
     b60:	0803000d 	stmdaeq	r3, {r0, r2, r3}
	bcc	CopyDataInit
     b64:	0b3b0b3a 	bleq	ec3854 <_etext+0xebc33c>
	ldr	r2, =_sbss
	b	LoopFillZerobss
     b68:	00001349 	andeq	r1, r0, r9, asr #6
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	03010414 	movweq	r0, #5140	; 0x1414
	str	r3, [r2], #4
     b70:	3a0b0b0e 	bcc	2c37b0 <_etext+0x2bc298>

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
     b74:	010b3b0b 	tsteq	fp, fp, lsl #22
	bcc	FillZerobss
     b78:	15000013 	strne	r0, [r0, #-19]
/* Call the application's entry point.*/
	bl	main
     b7c:	08030028 	stmdaeq	r3, {r3, r5}
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	00000d1c 	andeq	r0, r0, ip, lsl sp
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	0b011316 	bleq	457e4 <_etext+0x3e2cc>
	ldr	r3, =_edata
     b88:	3b0b3a0b 	blcc	2cf3bc <_etext+0x2c7ea4>
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	0013010b 	andseq	r0, r3, fp, lsl #2
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	01011700 	tsteq	r1, r0, lsl #14
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	13011349 	movwne	r1, #4937	; 0x1349
}


/* dummy proc */
void nothingProc(void)
{
     b98:	21180000 	tstcs	r8, r0
{
    return;
}

void usbStatusOut(void)
{
     b9c:	2f134900 	svccs	0x00134900
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
     ba0:	1900000b 	stmdbne	r0, {r0, r1, r3}
     ba4:	13490021 	movtne	r0, #36897	; 0x9021
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	2e1a0000 	cdpcs	0, 1, cr0, cr10, cr0, {0}
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	03193f01 	tsteq	r9, #1, 30
     bb0:	3b0b3a0e 	blcc	2cf3f0 <_etext+0x2c7ed8>
        bDeviceState = CONFIGURED;
     bb4:	1119270b 	tstne	r9, fp, lsl #14
     bb8:	40061201 	andmi	r1, r6, r1, lsl #4
     bbc:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
     bc0:	00001301 	andeq	r1, r0, r1, lsl #6
    }
}

void usbGetInterface(void)
{
     bc4:	0182891b 	orreq	r8, r2, fp, lsl r9
{
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	31011101 	tstcc	r1, r1, lsl #2
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	00130113 	andseq	r0, r3, r3, lsl r1
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	828a1c00 	addhi	r1, sl, #0, 24
     bd4:	18020001 	stmdane	r2, {r0}
     bd8:	00184291 	mulseq	r8, r1, r2
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	82891d00 	addhi	r1, r9, #0, 26
    dfuUpdateByReset();
     be0:	01110101 	tsteq	r1, r1, lsl #2

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	31194295 			; <UNDEFINED> instruction: 0x31194295

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be8:	1e000013 	mcrne	0, 0, r0, cr0, cr3, {0}
     bec:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	0b3a0e03 	bleq	e84404 <_etext+0xe7ceec>
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
     bf8:	06120111 			; <UNDEFINED> instruction: 0x06120111

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfc:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     c00:	00130119 	andseq	r0, r3, r9, lsl r1
     c04:	00341f00 	eorseq	r1, r4, r0, lsl #30
     c08:	0b3a0e03 	bleq	e8441c <_etext+0xe7cf04>
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c0c:	1349053b 	movtne	r0, #38203	; 0x953b
     c10:	00001702 	andeq	r1, r0, r2, lsl #14
     c14:	01828920 	orreq	r8, r2, r0, lsr #18
     c18:	31011100 	mrscc	r1, (UNDEF: 17)
     c1c:	21000013 	tstcs	r0, r3, lsl r0

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c20:	00018289 	andeq	r8, r1, r9, lsl #5
     c24:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
     c28:	00133119 	andseq	r3, r3, r9, lsl r1
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	002e2200 	eoreq	r2, lr, r0, lsl #4
     c30:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     c34:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     c38:	01111927 	tsteq	r1, r7, lsr #18
     c3c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^

    Clear_Status_Out(ENDP0);
     c40:	00194297 	mulseq	r9, r7, r2

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c44:	012e2300 	teqeq	lr, r0, lsl #6
     c48:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     c4c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	13491927 	movtne	r1, #39207	; 0x9927
     c54:	06120111 			; <UNDEFINED> instruction: 0x06120111

    bDeviceState = ATTACHED;
     c58:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
     c5c:	00130119 	andseq	r0, r3, r9, lsl r1

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	00052400 	andeq	r2, r5, r0, lsl #8
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c64:	0b3a0e03 	bleq	e84478 <_etext+0xe7cf60>
     c68:	1349053b 	movtne	r0, #38203	; 0x953b
     c6c:	00001702 	andeq	r1, r0, r2, lsl #14
     c70:	03003425 	movweq	r3, #1061	; 0x425
     c74:	3b0b3a08 	blcc	2cf49c <_etext+0x2c7f84>
     c78:	02134905 	andseq	r4, r3, #81920	; 0x14000
     c7c:	26000017 			; <UNDEFINED> instruction: 0x26000017
     c80:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     c88:	00001349 	andeq	r1, r0, r9, asr #6
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8c:	01828927 	orreq	r8, r2, r7, lsr #18
     c90:	31011101 	tstcc	r1, r1, lsl #2
     c94:	28000013 	stmdacs	r0, {r0, r1, r4}
        if (dfuUpdateByRequest()) {
     c98:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     c9c:	0b3a0e03 	bleq	e844b0 <_etext+0xe7cf98>
            // successfull state transition, handle the request
            switch (request) {
     ca0:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     ca4:	01111349 	tsteq	r1, r9, asr #6
     ca8:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     cac:	01194297 			; <UNDEFINED> instruction: 0x01194297
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	29000013 	stmdbcs	r0, {r0, r1, r4}
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
     cb4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
     cb8:	0b3b0b3a 	bleq	ec39a8 <_etext+0xebc490>
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	17021349 	strne	r1, [r2, -r9, asr #6]
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
     cc0:	0b2a0000 	bleq	a80cc8 <_etext+0xa797b0>
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
        (*CopyRoutine)(0);

        return USB_SUCCESS;
     cc8:	00130106 	andseq	r0, r3, r6, lsl #2
    }

    return USB_UNSUPPORT;
     ccc:	00342b00 	eorseq	r2, r4, r0, lsl #22
}
     cd0:	0b3a0e03 	bleq	e844e4 <_etext+0xe7cfcc>
     cd4:	1349053b 	movtne	r0, #38203	; 0x953b
     cd8:	00001802 	andeq	r1, r0, r2, lsl #16
     cdc:	3f002e2c 	svccc	0x00002e2c
     ce0:	3a0e0319 	bcc	38194c <_etext+0x37a434>
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     ce8:	11134919 	tstne	r3, r9, lsl r9
     cec:	40061201 	andmi	r1, r6, r1, lsl #4
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
     cf4:	052d0000 	streq	r0, [sp, #-0]!
     cf8:	3a0e0300 	bcc	381900 <_etext+0x37a3e8>
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     d00:	00180213 	andseq	r0, r8, r3, lsl r2
    if (strIndex > STR_DESC_LEN) {
     d04:	002e2e00 	eoreq	r2, lr, r0, lsl #28
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d08:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     d0c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    }
}
     d10:	01111349 	tsteq	r1, r9, asr #6
     d14:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     d18:	00194297 	mulseq	r9, r7, r2

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
     d1c:	002e2f00 	eoreq	r2, lr, r0, lsl #30
     d20:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     d24:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	06120111 			; <UNDEFINED> instruction: 0x06120111
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2c:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     d30:	30000019 	andcc	r0, r0, r9, lsl r0
     d34:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	0b3b0b3a 	bleq	ec3a28 <_etext+0xebc510>
     d3c:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
            return USB_SUCCESS;
     d40:	21310000 	teqcs	r1, r0
     d44:	2f134900 	svccs	0x00134900
        }
    }
    return USB_UNSUPPORT;
}
     d48:	32000005 	andcc	r0, r0, #5
     d4c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	0b3b0b3a 	bleq	ec3a40 <_etext+0xebc528>
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d54:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	0000193c 	andeq	r1, r0, ip, lsr r9
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5c:	03003433 	movweq	r3, #1075	; 0x433
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d60:	3b0b3a0e 	blcc	2cf5a0 <_etext+0x2c8088>
     d64:	3f13490b 	svccc	0x0013490b
     d68:	00180219 	andseq	r0, r8, r9, lsl r2
     d6c:	00343400 	eorseq	r3, r4, r0, lsl #8
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d70:	0b3a0803 	bleq	e82d84 <_etext+0xe7b86c>
     d74:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     d78:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
     d7c:	2e350000 	cdpcs	0, 3, cr0, cr5, cr0, {0}
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d80:	03193f01 	tsteq	r9, #1, 30
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	3b0b3a0e 	blcc	2cf5c4 <_etext+0x2c80ac>
     d88:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8c:	01193c13 	tsteq	r9, r3, lsl ip
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d90:	36000013 			; <UNDEFINED> instruction: 0x36000013
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d94:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d98:	0b3a0e03 	bleq	e845ac <_etext+0xe7d094>

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	1301193c 	movwne	r1, #6460	; 0x193c
     da4:	2e370000 	cdpcs	0, 3, cr0, cr7, cr0, {0}
     da8:	03193f00 	tsteq	r9, #0, 30
     dac:	3b0b3a0e 	blcc	2cf5ec <_etext+0x2c80d4>
     db0:	3c192705 	ldccc	7, cr2, [r9], {5}
     db4:	38000019 	stmdacc	r0, {r0, r3, r4}
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
     dbc:	0b3a0e03 	bleq	e845d0 <_etext+0xe7d0b8>
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dc0:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	0000193c 	andeq	r1, r0, ip, lsr r9
     dc8:	3f012e39 	svccc	0x00012e39
     dcc:	3a0e0319 	bcc	381a38 <_etext+0x37a520>
     dd0:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	3c134919 	ldccc	9, cr4, [r3], {25}
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd8:	00130119 	andseq	r0, r3, r9, lsl r1
     ddc:	012e3a00 	teqeq	lr, r0, lsl #20

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     de4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     de8:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	00001301 	andeq	r1, r0, r1, lsl #6
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	0000183b 	andeq	r1, r0, fp, lsr r8
        ResumeS.eState = eResumeSetVal;
     df4:	002e3c00 	eoreq	r3, lr, r0, lsl #24

    switch (ResumeS.eState) {
     df8:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     dfc:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     e00:	13491927 	movtne	r1, #39207	; 0x9927
     e04:	0000193c 	andeq	r1, r0, ip, lsr r9
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	01110100 	tsteq	r1, r0, lsl #2
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	0b130e25 	bleq	4c46a8 <_etext+0x4bd190>
        ResumeS.eState = RESUME_START;
     e10:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	01111755 	tsteq	r1, r5, asr r7
        ResumeS.eState = RESUME_WAIT;
     e18:	00001710 	andeq	r1, r0, r0, lsl r7
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	0b002402 	bleq	9e2c <_etext+0x2914>
     e20:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
        if (ResumeS.bESOFcnt == 0)
     e24:	0300000e 	movweq	r0, #14
            ResumeS.eState = RESUME_START;
     e28:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	0b3b0b3a 	bleq	ec3b1c <_etext+0xebc604>
     e30:	00001349 	andeq	r1, r0, r9, asr #6
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e34:	0b002404 	bleq	9e4c <_etext+0x2934>
        ResumeS.eState = RESUME_ON;
     e38:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
        ResumeS.bESOFcnt = 10;
     e3c:	05000008 	streq	r0, [r0, #-8]
        break;
     e40:	0e03012e 	adfeqsp	f0, f3, #0.5
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e44:	0b3b0b3a 	bleq	ec3b34 <_etext+0xebc61c>
     e48:	0b201927 	bleq	8072ec <_etext+0x7ffdd4>
        if (ResumeS.bESOFcnt == 0) {
     e4c:	00001301 	andeq	r1, r0, r1, lsl #6
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	03000506 	movweq	r0, #1286	; 0x506
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	3b0b3a08 	blcc	2cf67c <_etext+0x2c8164>
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e58:	0013490b 	andseq	r4, r3, fp, lsl #18
            ResumeS.eState = RESUME_OFF;
     e5c:	000f0700 	andeq	r0, pc, r0, lsl #14
     e60:	13490b0b 	movtne	r0, #39691	; 0x9b0b
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e64:	26080000 	strcs	r0, [r8], -r0
     e68:	00134900 	andseq	r4, r3, r0, lsl #18
     e6c:	00340900 	eorseq	r0, r4, r0, lsl #18
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	0b3a0803 	bleq	e82e84 <_etext+0xe7b96c>
     e74:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     e78:	010a0000 	mrseq	r0, (UNDEF: 10)
     e7c:	01134901 	tsteq	r3, r1, lsl #18

    _SetCNTR(CNTR_FRES);
     e80:	0b000013 	bleq	ed4 <usbPowerOff+0x1c>
     e84:	13490021 	movtne	r0, #36897	; 0x9021
     e88:	00000b2f 	andeq	r0, r0, pc, lsr #22
     e8c:	0300340c 	movweq	r3, #1036	; 0x40c
    _SetCNTR(0);
    _SetISTR(0);
     e90:	3b0b3a0e 	blcc	2cf6d0 <_etext+0x2c81b8>

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e94:	0013490b 	andseq	r4, r3, fp, lsl #18
    _SetCNTR(wInterrupt_Mask);
     e98:	012e0d00 	teqeq	lr, r0, lsl #26
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9c:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     ea0:	0b3b0b3a 	bleq	ec3b90 <_etext+0xebc678>
#endif
#endif

    return USB_SUCCESS;
}
     ea4:	01111927 	tsteq	r1, r7, lsr #18
     ea8:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     eac:	01194297 			; <UNDEFINED> instruction: 0x01194297
     eb0:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     eb4:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	0b3b0b3a 	bleq	ec3ba8 <_etext+0xebc690>
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	17021349 	strne	r1, [r2, -r9, asr #6]
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
     ec0:	050f0000 	streq	r0, [pc, #-0]	; ec8 <usbPowerOff+0x10>
     ec4:	3a080300 	bcc	201acc <_etext+0x1fa5b4>
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     ecc:	00170213 	andseq	r0, r7, r3, lsl r2
     ed0:	00341000 	eorseq	r1, r4, r0
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	0b3a0803 	bleq	e82ee8 <_etext+0xe7b9d0>
     ed8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     edc:	00001802 	andeq	r1, r0, r2, lsl #16

    return USB_SUCCESS;
}
     ee0:	03003411 	movweq	r3, #1041	; 0x411
     ee4:	3b0b3a08 	blcc	2cf70c <_etext+0x2c81f4>
     ee8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     eec:	12000017 	andne	r0, r0, #23
     ef0:	1331011d 	teqne	r1, #1073741831	; 0x40000007
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	17550152 			; <UNDEFINED> instruction: 0x17550152
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	0b590b58 	bleq	1643c60 <_etext+0x163c748>
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efc:	00001301 	andeq	r1, r0, r1, lsl #6
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	31000513 	tstcc	r0, r3, lsl r5
     f04:	00170213 	andseq	r0, r7, r3, lsl r2
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f08:	010b1400 	tsteq	fp, r0, lsl #8
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	13011755 	movwne	r1, #5973	; 0x1755
     f10:	05150000 	ldreq	r0, [r5, #-0]
    nvicInit(&NVIC_InitStructure);
     f14:	00133100 	andseq	r3, r3, r0, lsl #2
}
     f18:	010b1600 	tsteq	fp, r0, lsl #12

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	00001755 	andeq	r1, r0, r5, asr r7
    dfuInit();
     f20:	31003417 	tstcc	r0, r7, lsl r4

    pInformation->Current_Configuration = 0;
     f24:	00180213 	andseq	r0, r8, r3, lsl r2
     f28:	82891800 	addhi	r1, r9, #0, 16
    usbPowerOn();
     f2c:	01110101 	tsteq	r1, r1, lsl #2

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
     f30:	13011331 	movwne	r1, #4913	; 0x1331
     f34:	8a190000 	bhi	640f3c <_etext+0x639a24>
     f38:	02000182 	andeq	r0, r0, #-2147483616	; 0x80000020
    _SetCNTR(wInterrupt_Mask);
     f3c:	18429118 	stmdane	r2, {r3, r4, r8, ip, pc}^

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f40:	891a0000 	ldmdbhi	sl, {}	; <UNPREDICTABLE>
    bDeviceState = UNCONNECTED;
     f44:	11010182 	smlabbne	r1, r2, r1, r0
     f48:	00133101 	andseq	r3, r3, r1, lsl #2
     f4c:	011d1b00 	tsteq	sp, r0, lsl #22
     f50:	01111331 	tsteq	r1, r1, lsr r3
     f54:	0b580612 	bleq	16027a4 <_etext+0x15fb28c>
     f58:	13010b59 	movwne	r0, #7001	; 0x1b59
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	0b1c0000 	bleq	700f64 <_etext+0x6f9a4c>
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f60:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	1d000006 	stcne	0, cr0, [r0, #-24]	; 0xffffffe8

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f68:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	0b3b0b3a 	bleq	ec3c5c <_etext+0xebc744>
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
    nvicInit(&NVIC_InitStructure);
     f74:	0000193c 	andeq	r1, r0, ip, lsr r9
}
     f78:	0300341e 	movweq	r3, #1054	; 0x41e
     f7c:	3b0b3a0e 	blcc	2cf7bc <_etext+0x2c82a4>

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	3f13490b 	svccc	0x0013490b
    wIstr = _GetISTR();
     f84:	00180219 	andseq	r0, r8, r9, lsl r2

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	012e1f00 	teqeq	lr, r0, lsl #30
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8c:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f90:	0b3b0b3a 	bleq	ec3c80 <_etext+0xebc768>
     f94:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	00001301 	andeq	r1, r0, r1, lsl #6
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	49000520 	stmdbmi	r0, {r5, r8, sl}
     fa0:	21000013 	tstcs	r0, r3, lsl r0
     fa4:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
        _SetISTR((u16)CLR_RESET);
     fa8:	0b3a0e03 	bleq	e847bc <_etext+0xe7d2a4>
        Device_Property.Reset();
     fac:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     fb0:	0000193c 	andeq	r1, r0, ip, lsr r9
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb4:	01110100 	tsteq	r1, r0, lsl #2
     fb8:	0b130e25 	bleq	4c4854 <_etext+0x4bd33c>
        _SetISTR((u16)CLR_ERR);
     fbc:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     fc0:	01111755 	tsteq	r1, r5, asr r7
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc4:	00001710 	andeq	r1, r0, r0, lsl r7
     fc8:	0b002402 	bleq	9fd8 <_etext+0x2ac0>
        _SetISTR((u16)CLR_WKUP);
     fcc:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
        usbResume(RESUME_EXTERNAL);
     fd0:	0300000e 	movweq	r0, #14
     fd4:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd8:	0b3b0b3a 	bleq	ec3cc8 <_etext+0xebc7b0>
     fdc:	00001349 	andeq	r1, r0, r9, asr #6

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	0b002404 	bleq	9ff8 <_etext+0x2ae0>
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     fe8:	05000008 	streq	r0, [r0, #-8]
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fec:	0b0b000f 	bleq	2c1030 <_etext+0x2b9b18>
     ff0:	13060000 	movwne	r0, #24576	; 0x6000
        _SetISTR((u16)CLR_SOF);
     ff4:	0b0e0301 	bleq	381c00 <_etext+0x37a6e8>
     ff8:	3b0b3a0b 	blcc	2cf82c <_etext+0x2c8314>
        bIntPackSOF++;
     ffc:	0013010b 	andseq	r0, r3, fp, lsl #2
    1000:	000d0700 	andeq	r0, sp, r0, lsl #14
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	0b3a0803 	bleq	e83018 <_etext+0xe7bb00>
    1008:	13490b3b 	movtne	r0, #39739	; 0x9b3b
        _SetISTR((u16)CLR_ESOF);
    100c:	00000b38 	andeq	r0, r0, r8, lsr fp
    1010:	49010108 	stmdbmi	r1, {r3, r8}
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    }
#endif

}
    1014:	00130113 	andseq	r0, r3, r3, lsl r1
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	00210900 	eoreq	r0, r1, r0, lsl #18
    101c:	0b2f1349 	bleq	bc5d48 <_etext+0xbbe830>
    1020:	2e0a0000 	cdpcs	0, 0, cr0, cr10, cr0, {0}
    1024:	3a0e0301 	bcc	381c30 <_etext+0x37a718>
    1028:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    102c:	010b2019 	tsteq	fp, r9, lsl r0
    1030:	0b000013 	bleq	1084 <main+0x4c>
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

void print_hash(unsigned char hash[])
{
    1034:	08030005 	stmdaeq	r3, {r0, r2}
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
}

int main() 
{
    1038:	0b3b0b3a 	bleq	ec3d28 <_etext+0xebc810>
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    103c:	00001349 	andeq	r1, r0, r9, asr #6
    setupCLK();
    1040:	0b000f0c 	bleq	4c78 <sha256_process+0x1c44>
    setupLEDAndButton();
    1044:	0013490b 	andseq	r4, r3, fp, lsl #18
    setupUSB();
    1048:	00260d00 	eoreq	r0, r6, r0, lsl #26
    setupFLASH();
    104c:	00001349 	andeq	r1, r0, r9, asr #6
    uartInit();
    1050:	3f012e0e 	svccc	0x00012e0e
    usbReset();
    1054:	3a0e0319 	bcc	381cc0 <_etext+0x37a7a8>
	uart_printf("\nBootloader init...\n");
    1058:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    105c:	12011119 	andne	r1, r1, #1073741830	; 0x40000006

    if (readPin(GPIOB, 15) == 0x0)
    1060:	97184006 	ldrls	r4, [r8, -r6]
    1064:	13011942 	movwne	r1, #6466	; 0x1942
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1068:	050f0000 	streq	r0, [pc, #-0]	; 1070 <main+0x38>
    106c:	3a080300 	bcc	201c74 <_etext+0x1fa75c>
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    1070:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1074:	00170213 	andseq	r0, r7, r3, lsl r2
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
    1078:	011d1000 	tsteq	sp, r0
    107c:	01111331 	tsteq	r1, r1, lsr r3
    1080:	0b580612 	bleq	16028d0 <_etext+0x15fb3b8>
   debug_print("\n", 0);
}

int main() 
{
	bool no_user_jump = FALSE;
    1084:	13010b59 	movwne	r0, #7001	; 0x1b59
    1088:	05110000 	ldreq	r0, [r1, #-0]
    108c:	02133100 	andseq	r3, r3, #0, 2
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1090:	12000017 	andne	r0, r0, #23
			no_user_jump = FALSE;
    1094:	1331011d 	teqne	r1, #1073741831	; 0x40000007
			break;

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    1098:	17550152 			; <UNDEFINED> instruction: 0x17550152
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    109c:	0b590b58 	bleq	1643e04 <_etext+0x163c8ec>
    10a0:	00001301 	andeq	r1, r0, r1, lsl #6
			break;

		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10a4:	31000513 	tstcc	r0, r3, lsl r5
    10a8:	14000013 	strne	r0, [r0], #-19
    10ac:	01018289 	smlabbeq	r1, r9, r2, r8
    10b0:	13310111 	teqne	r1, #1073741828	; 0x40000004
    10b4:	00001301 	andeq	r1, r0, r1, lsl #6

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10b8:	01828a15 	orreq	r8, r2, r5, lsl sl
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10bc:	91180200 	tstls	r8, r0, lsl #4
    10c0:	00001842 	andeq	r1, r0, r2, asr #16
    10c4:	01828916 	orreq	r8, r2, r6, lsl r9
    10c8:	95011101 	strls	r1, [r1, #-257]	; 0x101

		if (dfuUploadStarted()) 
    10cc:	13311942 	teqne	r1, #1081344	; 0x108000
    10d0:	34170000 	ldrcc	r0, [r7], #-0
		{
			uart_printf("DFU finished upload\n");
    10d4:	3a080300 	bcc	201cdc <_etext+0x1fa7c4>
			dfuFinishUpload(); // systemHardReset from DFU once done
    10d8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    10dc:	00180213 	andseq	r0, r8, r3, lsl r2
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10e0:	82891800 	addhi	r1, r9, #0, 16
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10e4:	01110101 	tsteq	r1, r1, lsl #2
    10e8:	00001331 	andeq	r1, r0, r1, lsr r3
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10ec:	03003419 	movweq	r3, #1049	; 0x419
	}
	
	return 0;// Added to please the compiler
    10f0:	3b0b3a0e 	blcc	2cf930 <_etext+0x2c8418>
    10f4:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    10f8:	1a000017 	bne	115c <strobePin+0x10>
    10fc:	13310005 	teqne	r1, #5
    1100:	00001802 	andeq	r1, r0, r2, lsl #16
    1104:	3f012e1b 	svccc	0x00012e1b
    1108:	3a0e0319 	bcc	381d74 <_etext+0x37a85c>
    110c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    1110:	11134919 	tstne	r3, r9, lsl r9
    1114:	40061201 	andmi	r1, r6, r1, lsl #4
    1118:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
    111c:	00001301 	andeq	r1, r0, r1, lsl #6
    1120:	0300051c 	movweq	r0, #1308	; 0x51c
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1124:	3b0b3a0e 	blcc	2cf964 <_etext+0x2c844c>
    1128:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    112c:	1d000017 	stcne	0, cr0, [r0, #-92]	; 0xffffffa4
    1130:	08030034 	stmdaeq	r3, {r2, r4, r5}
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1134:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    1138:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    113c:	2e1e0000 	cdpcs	0, 1, cr0, cr14, cr0, {0}
    1140:	03193f01 	tsteq	r9, #1, 30
        return TRUE;
    } else {
        return FALSE;
    }
}
    1144:	3b0b3a0e 	blcc	2cf984 <_etext+0x2c846c>
    1148:	11192705 	tstne	r9, r5, lsl #14

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    114c:	40061201 	andmi	r1, r6, r1, lsl #4
    1150:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
    1154:	00001301 	andeq	r1, r0, r1, lsl #6
    gpio_write_bit( bank,pin,1-onState);
    1158:	0300051f 	movweq	r0, #1311	; 0x51f
    115c:	3b0b3a0e 	blcc	2cf99c <_etext+0x2c8484>
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	02134905 	andseq	r4, r3, #81920	; 0x14000
    gpio_write_bit( bank,pin,1-onState);
    1164:	20000017 	andcs	r0, r0, r7, lsl r0

    u32 c;
    while (count-- > 0) 
    1168:	08030005 	stmdaeq	r3, {r0, r2}
	{
        for (c = rate; c > 0; c--)
    116c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    1170:	17021349 	strne	r1, [r2, -r9, asr #6]
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1174:	34210000 	strtcc	r0, [r1], #-0
    1178:	3a080300 	bcc	201d80 <_etext+0x1fa868>
    117c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
		
        for (c = rate; c > 0; c--)
    1180:	00170213 	andseq	r0, r7, r3, lsl r2
    1184:	011d2200 	tsteq	sp, r0, lsl #4
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    1188:	01111331 	tsteq	r1, r1, lsr r3
    118c:	0b580612 	bleq	16029dc <_etext+0x15fb4c4>
    1190:	13010559 	movwne	r0, #5465	; 0x1559
    1194:	0b230000 	bleq	8c119c <_etext+0x8b9c84>
    1198:	01175501 	tsteq	r7, r1, lsl #10

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    119c:	24000013 	strcs	r0, [r0], #-19
    11a0:	1331011d 	teqne	r1, #1073741831	; 0x40000007
  USARTx->DR = ch;  
    11a4:	06120111 			; <UNDEFINED> instruction: 0x06120111
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11a8:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xb58
  while(*str != 0)
    11ac:	34250000 	strtcc	r0, [r5], #-0
    11b0:	3a0e0300 	bcc	381db8 <_etext+0x37a8a0>
  {
    UU_PutChar(USARTx, *str);
    11b4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    11b8:	00180213 	andseq	r0, r8, r3, lsl r2
    str++;
  }
}

void vprint(const char *fmt, va_list argp)
{
    11bc:	00342600 	eorseq	r2, r4, r0, lsl #12
    11c0:	0b3a0e03 	bleq	e849d4 <_etext+0xe7d4bc>
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11c4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    11c8:	193c193f 	ldmdbne	ip!, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
    11cc:	34270000 	strtcc	r0, [r7], #-0
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11d0:	3a0e0300 	bcc	381dd8 <_etext+0x37a8c0>
    11d4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}

    }
}
    11d8:	02193f13 	andseq	r3, r9, #19, 30	; 0x4c
    11dc:	28000018 	stmdacs	r0, {r3, r4}
    11e0:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11e4:	0b3a0e03 	bleq	e849f8 <_etext+0xe7d4e0>
    11e8:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    11ec:	1301193c 	movwne	r1, #6460	; 0x193c
    va_list argp;
    va_start(argp, fmt);
    vprint(fmt, argp);
    11f0:	05290000 	streq	r0, [r9, #-0]!
    va_end(argp);
}
    11f4:	00134900 	andseq	r4, r3, r0, lsl #18
    11f8:	012e2a00 	teqeq	lr, r0, lsl #20
    11fc:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}

void hexdump(unsigned char *data, size_t size)
{
    1200:	0b3b0b3a 	bleq	ec3ef0 <_etext+0xebc9d8>
    int i;
    char cs[17];
    memset(cs, 0, 17);
    1204:	13491927 	movtne	r1, #39207	; 0x9927
    1208:	1301193c 	movwne	r1, #6460	; 0x193c
    120c:	2e2b0000 	cdpcs	0, 2, cr0, cr11, cr0, {0}

    for(i = 0; i < size; i++)
    1210:	03193f01 	tsteq	r9, #1, 30
    {
        if(i != 0 && i % 0x10 == 0)
    1214:	4919270e 	ldmdbmi	r9, {r1, r2, r3, r8, r9, sl, sp}
    1218:	3c193413 	cfldrscc	mvf3, [r9], {19}
        {
            debug_print(" |%s|\n", cs);
            memset(cs, 0, 17);
    121c:	00130119 	andseq	r0, r3, r9, lsl r1
    1220:	00262c00 	eoreq	r2, r6, r0, lsl #24
{
    int i;
    char cs[17];
    memset(cs, 0, 17);

    for(i = 0; i < size; i++)
    1224:	01000000 	mrseq	r0, (UNDEF: 0)
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
}
    1228:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}


#endif
void uartInit(void) {
    122c:	0e030b13 	vmoveq.32	d3[0], r0
    1230:	17550e1b 	smmlane	r5, fp, lr, r0
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    1234:	17100111 			; <UNDEFINED> instruction: 0x17100111
    1238:	24020000 	strcs	r0, [r2], #-0
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    123c:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1240:	000e030b 	andeq	r0, lr, fp, lsl #6
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    1244:	00160300 	andseq	r0, r6, r0, lsl #6
    1248:	0b3a0e03 	bleq	e84a5c <_etext+0xe7d544>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    124c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1250:	24040000 	strcs	r0, [r4], #-0
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1254:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1258:	0008030b 	andeq	r0, r8, fp, lsl #6
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    125c:	000f0500 	andeq	r0, pc, r0, lsl #10
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    1260:	00000b0b 	andeq	r0, r0, fp, lsl #22
    1264:	03011306 	movweq	r1, #4870	; 0x1306
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1268:	3a0b0b0e 	bcc	2c3ea8 <_etext+0x2bc990>
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    126c:	010b3b0b 	tsteq	fp, fp, lsl #22
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1270:	07000013 	smladeq	r0, r3, r0, r0
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1274:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1278:	0b3b0b3a 	bleq	ec3f68 <_etext+0xebca50>
    127c:	0b381349 	bleq	e05fa8 <_etext+0xdfea90>
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1280:	01080000 	mrseq	r0, (UNDEF: 8)
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    1284:	01134901 	tsteq	r3, r1, lsl #18
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1288:	09000013 	stmdbeq	r0, {r0, r1, r4}
    USART_InitStructure.USART_Parity = USART_Parity_No;
    128c:	13490021 	movtne	r0, #36897	; 0x9021
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    1290:	00000b2f 	andeq	r0, r0, pc, lsr #22
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1294:	03012e0a 	movweq	r2, #7690	; 0x1e0a
    1298:	3b0b3a0e 	blcc	2cfad8 <_etext+0x2c85c0>
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    129c:	2019270b 	andscs	r2, r9, fp, lsl #14
        
    USART_Init(USART1, &USART_InitStructure);
    12a0:	0013010b 	andseq	r0, r3, fp, lsl #2
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    12a4:	00050b00 	andeq	r0, r5, r0, lsl #22
    12a8:	0b3a0803 	bleq	e832bc <_etext+0xe7bda4>
}
    12ac:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    12b0:	0f0c0000 	svceq	0x000c0000

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    12b4:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
    12b8:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
    12bc:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    12c0:	0b3b0b3a 	bleq	ec3fb0 <_etext+0xebca98>
    12c4:	00001349 	andeq	r1, r0, r9, asr #6
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    12c8:	0300340e 	movweq	r3, #1038	; 0x40e
    12cc:	3b0b3a08 	blcc	2cfaf4 <_etext+0x2c85dc>
    12d0:	0013490b 	andseq	r4, r3, fp, lsl #18
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    12d4:	010b0f00 	tsteq	fp, r0, lsl #30
    12d8:	26100000 	ldrcs	r0, [r0], -r0
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    12dc:	00134900 	andseq	r4, r3, r0, lsl #18
    12e0:	012e1100 	teqeq	lr, r0, lsl #2

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    12e4:	0b3a0803 	bleq	e832f8 <_etext+0xe7bde0>
    12e8:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    12ec:	13010b20 	movwne	r0, #6944	; 0x1b20
    12f0:	2e120000 	cdpcs	0, 1, cr0, cr2, cr0, {0}
    12f4:	03193f01 	tsteq	r9, #1, 30
    12f8:	3b0b3a0e 	blcc	2cfb38 <_etext+0x2c8620>
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    12fc:	1119270b 	tstne	r9, fp, lsl #14
    1300:	40061201 	andmi	r1, r6, r1, lsl #4
    1304:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    1308:	00001301 	andeq	r1, r0, r1, lsl #6
    130c:	03000513 	movweq	r0, #1299	; 0x513

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    1310:	3b0b3a08 	blcc	2cfb38 <_etext+0x2c8620>
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    1314:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1318:	14000017 	strne	r0, [r0], #-23
    131c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    1320:	0b3b0b3a 	bleq	ec4010 <_etext+0xebcaf8>
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    1324:	17021349 	strne	r1, [r2, -r9, asr #6]
    1328:	34150000 	ldrcc	r0, [r5], #-0

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    132c:	3a0e0300 	bcc	381f34 <_etext+0x37aa1c>
    1330:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    1334:	00180213 	andseq	r0, r8, r3, lsl r2
    1338:	011d1600 	tsteq	sp, r0, lsl #12
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    133c:	01521331 	cmpeq	r2, r1, lsr r3
    1340:	0b581755 	bleq	160709c <_etext+0x15ffb84>
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    1344:	13010b59 	movwne	r0, #7001	; 0x1b59
    1348:	05170000 	ldreq	r0, [r7, #-0]
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    134c:	02133100 	andseq	r3, r3, #0, 2
    1350:	18000017 	stmdane	r0, {r0, r1, r2, r4}
    1354:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]
    1358:	34190000 	ldrcc	r0, [r9], #-0

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    135c:	02133100 	andseq	r3, r3, #0, 2
    1360:	1a000018 	bne	13c8 <nvicInit+0x24>
    1364:	01018289 	smlabbeq	r1, r9, r2, r8
    1368:	13310111 	teqne	r1, #1073741828	; 0x40000004
    136c:	00001301 	andeq	r1, r0, r1, lsl #6
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    1370:	01828a1b 	orreq	r8, r2, fp, lsl sl
    1374:	91180200 	tstls	r8, r0, lsl #4
        u32 rwmVal = pRCC->CR;
    1378:	00001842 	andeq	r1, r0, r2, asr #16
        rwmVal |= 0x01;
    137c:	0182891c 	orreq	r8, r2, ip, lsl r9
        pRCC->CR = rwmVal;
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    1380:	31011101 	tstcc	r1, r1, lsl #2
    1384:	1d000013 	stcne	0, cr0, [r0, #-76]	; 0xffffffb4
}   
    1388:	1331011d 	teqne	r1, #1073741831	; 0x40000007
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    138c:	17550152 			; <UNDEFINED> instruction: 0x17550152
void setMspAndJump(u32 usrAddr) {
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    1390:	0b590b58 	bleq	16440f8 <_etext+0x163cbe0>
  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1394:	1d1e0000 	ldcne	0, cr0, [lr, #-0]

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1398:	11133101 	tstne	r3, r1, lsl #2
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    139c:	58061201 	stmdapl	r6, {r0, r9, ip}
    13a0:	010b590b 	tsteq	fp, fp, lsl #18
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    13a4:	1f000013 	svcne	0x00000013
    13a8:	0111010b 	tsteq	r1, fp, lsl #2
    13ac:	00000612 	andeq	r0, r0, r2, lsl r6
    13b0:	03003420 	movweq	r3, #1056	; 0x420
    tmppre = (0x4 - tmppriority);
    13b4:	3b0b3a0e 	blcc	2cfbf4 <_etext+0x2c86dc>
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    13b8:	0013490b 	andseq	r4, r3, fp, lsl #18


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    13bc:	012e2100 	teqeq	lr, r0, lsl #2

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c0:	0b3a0803 	bleq	e833d4 <_etext+0xe7bebc>
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    13c4:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c8:	0b201349 	bleq	8060f4 <_etext+0x7febdc>
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    13cc:	00001301 	andeq	r1, r0, r1, lsl #6
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d0:	3f012e22 	svccc	0x00012e22

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d4:	3a0e0319 	bcc	382040 <_etext+0x37ab28>
    13d8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    13dc:	11134919 	tstne	r3, r9, lsl r9
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    13e0:	40061201 	andmi	r1, r6, r1, lsl #4
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    13e4:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
    tmppriority &= tmpmask;
    13e8:	00001301 	andeq	r1, r0, r1, lsl #6
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    13ec:	03003423 	movweq	r3, #1059	; 0x423

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    13f0:	3b0b3a08 	blcc	2cfc18 <_etext+0x2c8700>
    13f4:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    13f8:	24000018 	strcs	r0, [r0], #-24
    13fc:	08030034 	stmdaeq	r3, {r2, r4, r5}
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    1400:	0b3b0b3a 	bleq	ec40f0 <_etext+0xebcbd8>
    1404:	17021349 	strne	r1, [r2, -r9, asr #6]
    1408:	05250000 	streq	r0, [r5, #-0]!
    140c:	1c133100 	ldfnes	f3, [r3], {-0}
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    1410:	2600000b 	strcs	r0, [r0], -fp
    1414:	13310005 	teqne	r1, #5
    1418:	00001802 	andeq	r1, r0, r2, lsl #16
    rNVIC->ICER[1] = 0xFFFFFFFF;
    141c:	55010b27 	strpl	r0, [r1, #-2855]	; 0xb27
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    1420:	00130117 	andseq	r0, r3, r7, lsl r1
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    1424:	00342800 	eorseq	r2, r4, r0, lsl #16

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    1428:	17021331 	smladxne	r2, r1, r3, r1
    142c:	34290000 	strtcc	r0, [r9], #-0
    1430:	3a0e0300 	bcc	382038 <_etext+0x37ab20>

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    1434:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    1438:	3c193f13 	ldccc	15, cr3, [r9], {19}
    nvicDisableInterrupts();
    143c:	2a000019 	bcs	14a8 <flashWriteWord+0xc>
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    1440:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    1444:	0b3a0e03 	bleq	e84c58 <_etext+0xe7d740>
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    1448:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
}
    144c:	1301193c 	movwne	r1, #6460	; 0x193c
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    1450:	052b0000 	streq	r0, [fp, #-0]!

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1454:	00134900 	andseq	r4, r3, r0, lsl #18
    1458:	012e2c00 	teqeq	lr, r0, lsl #24

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    145c:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    1460:	13491927 	movtne	r1, #39207	; 0x9927
    1464:	193c1934 	ldmdbne	ip!, {r2, r4, r5, r8, fp, ip}
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1468:	00001301 	andeq	r1, r0, r1, lsl #6
    146c:	0000262d 	andeq	r2, r0, sp, lsr #12
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    1470:	012e2e00 	teqeq	lr, r0, lsl #28

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1474:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    1478:	0b3b0b3a 	bleq	ec4168 <_etext+0xebcc50>
    147c:	13491927 	movtne	r1, #39207	; 0x9927
    SET_REG(FLASH_AR, pageAddr);
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    1480:	1301193c 	movwne	r1, #6460	; 0x193c
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1484:	2e2f0000 	cdpcs	0, 2, cr0, cr15, cr0, {0}
    1488:	03193f01 	tsteq	r9, #1, 30

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    148c:	3b0b3a0e 	blcc	2cfccc <_etext+0x2c87b4>

    return TRUE;
}
    1490:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    1494:	00193c13 	andseq	r3, r9, r3, lsl ip
    1498:	11010000 	mrsne	r0, (UNDEF: 1)
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    149c:	130e2501 	movwne	r2, #58625	; 0xe501
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    14a0:	1b0e030b 	blne	3820d4 <_etext+0x37abbc>
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    14a4:	1117550e 	tstne	r7, lr, lsl #10

    u32 rwmVal = GET_REG(FLASH_CR);
    SET_REG(FLASH_CR, FLASH_CR_PG);
    14a8:	00171001 	andseq	r1, r7, r1
    14ac:	00240200 	eoreq	r0, r4, r0, lsl #4

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14b0:	0b3e0b0b 	bleq	f840e4 <_etext+0xf7cbcc>
    14b4:	00000e03 	andeq	r0, r0, r3, lsl #28
    *(flashAddr + 0x01) = (vu16)hhWord;
    14b8:	03001603 	movweq	r1, #1539	; 0x603
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14bc:	3b0b3a0e 	blcc	2cfcfc <_etext+0x2c87e4>
    14c0:	0013490b 	andseq	r4, r3, fp, lsl #18
    *(flashAddr) = (vu16)lhWord;
    14c4:	00240400 	eoreq	r0, r4, r0, lsl #8
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14c8:	0b3e0b0b 	bleq	f840fc <_etext+0xf7cbe4>
    14cc:	00000803 	andeq	r0, r0, r3, lsl #16

    rwmVal &= 0xFFFFFFFE;
    14d0:	0b000f05 	bleq	50ec <sha256_finish+0xc4>
    SET_REG(FLASH_CR, rwmVal);

    /* verify the write */
    if (*(vu32 *)addr != word) {
    14d4:	0600000b 	streq	r0, [r0], -fp
        return FALSE;
    }

    return TRUE;
}
    14d8:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    14dc:	0b3a0e03 	bleq	e84cf0 <_etext+0xe7d7d8>
    14e0:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    14e4:	13010b20 	movwne	r0, #6944	; 0x1b20

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    14e8:	05070000 	streq	r0, [r7, #-0]
    14ec:	3a080300 	bcc	2020f4 <_etext+0x1fabdc>
    14f0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    14f4:	08000013 	stmdaeq	r0, {r0, r1, r4}
    14f8:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    14fc:	0b3b0b3a 	bleq	ec41ec <_etext+0xebccd4>
    1500:	00001349 	andeq	r1, r0, r9, asr #6
    1504:	03003409 	movweq	r3, #1033	; 0x409
    1508:	3b0b3a0e 	blcc	2cfd48 <_etext+0x2c8830>

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    150c:	0013490b 	andseq	r4, r3, fp, lsl #18
	{
		pin-=8;
    1510:	00340a00 	eorseq	r0, r4, r0, lsl #20
	}
	mask = 0x0F << (pin<<2);
    1514:	0b3a0803 	bleq	e83528 <_etext+0xe7c010>
    1518:	13490b3b 	movtne	r0, #39739	; 0x9b3b
	return ~mask;
}	
    151c:	0f0b0000 	svceq	0x000b0000

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    1520:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
    1524:	0c000013 	stceq	0, cr0, [r0], {19}
}
    1528:	13490026 	movtne	r0, #36902	; 0x9026
    152c:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    1530:	3a0e0301 	bcc	38213c <_etext+0x37ac24>
	{
		return 0x800;
    1534:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
	}
	else
	{
		return 0x400;
	}
}
    1538:	010b2019 	tsteq	fp, r9, lsl r0
    153c:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    1540:	1331012e 	teqne	r1, #-2147483637	; 0x8000000b
    1544:	06120111 			; <UNDEFINED> instruction: 0x06120111

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1548:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    154c:	00130119 	andseq	r0, r3, r9, lsl r1

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1550:	00050f00 	andeq	r0, r5, r0, lsl #30
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1554:	17021331 	smladxne	r2, r1, r3, r1
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    1558:	34100000 	ldrcc	r0, [r0], #-0
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    155c:	02133100 	andseq	r3, r3, #0, 2
    1560:	11000017 	tstne	r0, r7, lsl r0
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1564:	01018289 	smlabbeq	r1, r9, r2, r8
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1568:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
    userAppEnd = RAM_END;
    156c:	00133119 	andseq	r3, r3, r9, lsl r1
    1570:	828a1200 	addhi	r1, sl, #0, 4
    userUploadType=DFU_UPLOAD_NONE;
    1574:	18020001 	stmdane	r2, {r0}
    1578:	00184291 	mulseq	r8, r1, r2
    code_copy_lock = WAIT;
    157c:	012e1300 	teqeq	lr, r0, lsl #6
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1580:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    1584:	0b3b0b3a 	bleq	ec4274 <_etext+0xebcd5c>
    1588:	01111927 	tsteq	r1, r7, lsr #18
    memset(input, 0xFF, sizeof(input));
    158c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    1590:	01194297 			; <UNDEFINED> instruction: 0x01194297

    sha256_starts(&ctx);
}
    1594:	14000013 	strne	r0, [r0], #-19
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1598:	08030005 	stmdaeq	r3, {r0, r2}
    159c:	0b3b0b3a 	bleq	ec428c <_etext+0xebcd74>
    15a0:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    15a4:	34150000 	ldrcc	r0, [r5], #-0
    15a8:	3a0e0300 	bcc	3821b0 <_etext+0x37ac98>
    15ac:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    15b0:	00180213 	andseq	r0, r8, r3, lsl r2
    15b4:	00341600 	eorseq	r1, r4, r0, lsl #12
    15b8:	0b3a0803 	bleq	e835cc <_etext+0xe7c0b4>
    15bc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    15c0:	00001702 	andeq	r1, r0, r2, lsl #14
    15c4:	31011d17 	tstcc	r1, r7, lsl sp
    15c8:	55015213 	strpl	r5, [r1, #-531]	; 0x213
    15cc:	590b5817 	stmdbpl	fp, {r0, r1, r2, r4, fp, ip, lr}
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    15d0:	1800000b 	stmdane	r0, {r0, r1, r3}
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    15d4:	13310005 	teqne	r1, #5
    15d8:	00001802 	andeq	r1, r0, r2, lsl #16

    if (startState == appDETACH) {
    15dc:	55010b19 	strpl	r0, [r1, #-2841]	; 0xb19
    15e0:	1a000017 	bne	1644 <dfuCopyDNLOAD>
        dfuAppStatus.bState = dfuIDLE;
    15e4:	13310034 	teqne	r1, #52	; 0x34
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
    15e8:	00001802 	andeq	r1, r0, r2, lsl #16
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    15ec:	4901011b 	stmdbmi	r1, {r0, r1, r3, r4, r8}
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    15f0:	00130113 	andseq	r0, r3, r3, lsl r1
    } else if (startState == appIDLE || startState == dfuIDLE) {
    15f4:	00211c00 	eoreq	r1, r1, r0, lsl #24
    15f8:	0b2f1349 	bleq	bc6324 <_etext+0xbbee0c>
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    15fc:	2e1d0000 	cdpcs	0, 1, cr0, cr13, cr0, {0}
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1600:	03193f01 	tsteq	r9, #1, 30
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    1604:	3b0b3a0e 	blcc	2cfe44 <_etext+0x2c892c>
    1608:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    160c:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    1610:	97184006 	ldrls	r4, [r8, -r6]

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    1614:	13011942 	movwne	r1, #6466	; 0x1942
        pInformation->Ctrl_Info.Usb_wLength = 1;
    1618:	051e0000 	ldreq	r0, [lr, #-0]
    161c:	3a080300 	bcc	202224 <_etext+0x1fad0c>
        return NULL;
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    1620:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    }
}
    1624:	00170213 	andseq	r0, r7, r3, lsl r2
    1628:	010b1f00 	tsteq	fp, r0, lsl #30

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    162c:	0b200000 	bleq	801634 <_etext+0x7fa11c>
        pInformation->Ctrl_Info.Usb_wLength = 6;
    1630:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
    1634:	21000006 	tstcs	r0, r6
        return NULL;
    } else {
        return (u8*)(&dfuAppStatus);
    1638:	08030034 	stmdaeq	r3, {r2, r4, r5}
    }
}
    163c:	0b3b0b3a 	bleq	ec432c <_etext+0xebce14>
    1640:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}


u8 *dfuCopyDNLOAD(u16 length) {
    1644:	1d220000 	stcne	0, cr0, [r2, #-0]
    if (length == 0) {
    1648:	52133101 	andspl	r3, r3, #1073741824	; 0x40000000
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    164c:	58175501 	ldmdapl	r7, {r0, r8, sl, ip, lr}
    1650:	010b590b 	tsteq	fp, fp, lsl #18
        thisBlockLen = pInformation->USBwLengths.w;
    1654:	23000013 	movwcs	r0, #19
        return NULL;
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1658:	1331011d 	teqne	r1, #1073741831	; 0x40000007
    165c:	06120111 			; <UNDEFINED> instruction: 0x06120111
    }
}
    1660:	0b590b58 	bleq	16443c8 <_etext+0x163ceb0>
    1664:	05240000 	streq	r0, [r4, #-0]!
    1668:	00133100 	andseq	r3, r3, r0, lsl #2

u8 *dfuCopyUPLOAD(u16 length) {
    166c:	011d2500 	tsteq	sp, r0, lsl #10
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    1670:	01111331 	tsteq	r1, r1, lsr r3
    1674:	0b580612 	bleq	1602ec4 <_etext+0x15fb9ac>
    1678:	13010b59 	movwne	r0, #7001	; 0x1b59
        return NULL;
    167c:	1d260000 	stcne	0, cr0, [r6, #-0]
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    1680:	11133101 	tstne	r3, r1, lsl #2
    1684:	58061201 	stmdapl	r6, {r0, r9, ip}
    1688:	0105590b 	tsteq	r5, fp, lsl #18
    168c:	27000013 	smladcs	r0, r3, r0, r0
    }
}
    1690:	1331011d 	teqne	r1, #1073741831	; 0x40000007
    1694:	06120111 			; <UNDEFINED> instruction: 0x06120111
    1698:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xb58
    169c:	2e280000 	cdpcs	0, 2, cr0, cr8, cr0, {0}

void dfuCopyBufferToExec() {
    16a0:	03193f01 	tsteq	r9, #1, 30
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    16a4:	3b0b3a0e 	blcc	2cfee4 <_etext+0x2c89cc>
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    16a8:	11192705 	tstne	r9, r5, lsl #14
    16ac:	40061201 	andmi	r1, r6, r1, lsl #4
    16b0:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
    16b4:	00001301 	andeq	r1, r0, r1, lsl #6
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    16b8:	03000529 	movweq	r0, #1321	; 0x529
	}

    flashErasePage((u32)(userSpace));
    16bc:	3b0b3a08 	blcc	2cfee4 <_etext+0x2c89cc>

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16c0:	02134905 	andseq	r4, r3, #81920	; 0x14000
    16c4:	2a000017 	bcs	1728 <dfuUpdateByRequest+0x2c>
    16c8:	08030034 	stmdaeq	r3, {r2, r4, r5}
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    16cc:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    16d0:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    16d4:	892b0000 	stmdbhi	fp!, {}	; <UNPREDICTABLE>
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16d8:	11010182 	smlabbne	r1, r2, r1, r0
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    16dc:	00133101 	andseq	r3, r3, r1, lsl #2
    16e0:	012e2c00 	teqeq	lr, r0, lsl #24
    thisBlockLen = 0;
    16e4:	0b3a0e03 	bleq	e84ef8 <_etext+0xe7d9e0>
    16e8:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
    16ec:	13010b20 	movwne	r0, #6944	; 0x1b20
    16f0:	052d0000 	streq	r0, [sp, #-0]!
    16f4:	3a080300 	bcc	2022fc <_etext+0x1fade4>
    16f8:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    16fc:	2e000013 	mcrcs	0, 0, r0, cr0, cr3, {0}
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    1700:	08030034 	stmdaeq	r3, {r2, r4, r5}
    1704:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a

    u8 startState = dfuAppStatus.bState;
    1708:	00001349 	andeq	r1, r0, r9, asr #6
    170c:	31011d2f 	tstcc	r1, pc, lsr #26
    dfuAppStatus.bStatus = OK;
    1710:	55015213 	strpl	r5, [r1, #-531]	; 0x213
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    1714:	590b5817 	stmdbpl	fp, {r0, r1, r2, r4, fp, ip, lr}

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    1718:	00130105 	andseq	r0, r3, r5, lsl #2
    171c:	00053000 	andeq	r3, r5, r0
            if (pInformation->USBwLengths.w > 0) {
    1720:	0b1c1331 	bleq	7063ec <_etext+0x6feed4>
    1724:	34310000 	ldrtcc	r0, [r1], #-0
                userFirmwareLen = 0;
    1728:	00133100 	andseq	r3, r3, r0, lsl #2
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    172c:	00343200 	eorseq	r3, r4, r0, lsl #4
    1730:	0b3a0e03 	bleq	e84f44 <_etext+0xe7da2c>
    1734:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1738:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    173c:	2e330000 	cdpcs	0, 3, cr0, cr3, cr0, {0}
						userAppAddr = USER_CODE_FLASH0X8002000;
    1740:	03193f01 	tsteq	r9, #1, 30
    1744:	4919270e 	ldmdbmi	r9, {r1, r2, r3, r8, r9, sl, sp}
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    1748:	3c193413 	cfldrscc	mvf3, [r9], {19}
    174c:	34000019 	strcc	r0, [r0], #-25
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    1750:	13490005 	movtne	r0, #36869	; 0x9005
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1754:	01000000 	mrseq	r0, (UNDEF: 0)
						flashUnlock();
    1758:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}

						break;
    175c:	0e030b13 	vmoveq.32	d3[0], r0

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    1760:	17550e1b 	smmlane	r5, fp, lr, r0
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1764:	17100111 			; <UNDEFINED> instruction: 0x17100111
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1768:	24020000 	strcs	r0, [r2], #-0
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    176c:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1770:	000e030b 	andeq	r0, lr, fp, lsl #6
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    1774:	00160300 	andseq	r0, r6, r0, lsl #6
    1778:	0b3a0e03 	bleq	e84f8c <_etext+0xe7da74>
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    177c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1780:	24040000 	strcs	r0, [r4], #-0
    1784:	3e0b0b00 	vmlacc.f64	d0, d11, d0
			
            switch(pInformation->Current_AlternateSetting) {
    1788:	0008030b 	andeq	r0, r8, fp, lsl #6
    178c:	000f0500 	andeq	r0, pc, r0, lsl #10
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1790:	00000b0b 	andeq	r0, r0, fp, lsl #22
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1794:	3f012e06 	svccc	0x00012e06
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1798:	3a0e0319 	bcc	382404 <_etext+0x37aeec>
					userAppEnd = getFlashEnd();
    179c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    17a0:	010b2019 	tsteq	fp, r9, lsl r0

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    17a4:	07000013 	smladeq	r0, r3, r0, r0
					dfuAppStatus.bStatus = errWRITE;
    17a8:	08030005 	stmdaeq	r3, {r0, r2}
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    17ac:	0b3b0b3a 	bleq	ec449c <_etext+0xebcf84>
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17b0:	00001349 	andeq	r1, r0, r9, asr #6
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17b4:	03000508 	movweq	r0, #1288	; 0x508
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    17b8:	3b0b3a0e 	blcc	2cfff8 <_etext+0x2c8ae0>
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17bc:	0013490b 	andseq	r4, r3, fp, lsl #18
    17c0:	00340900 	eorseq	r0, r4, r0, lsl #18
    17c4:	0b3a0e03 	bleq	e84fd8 <_etext+0xe7dac0>

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17c8:	13490b3b 	movtne	r0, #39739	; 0x9b3b
                dfuCopyBufferToExec();
    17cc:	340a0000 	strcc	r0, [sl], #-0
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17d0:	3a080300 	bcc	2023d8 <_etext+0x1faec0>
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    17d4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    17d8:	0b000013 	bleq	182c <dfuUpdateByRequest+0x130>
    17dc:	0b0b000f 	bleq	2c1820 <_etext+0x2ba308>

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    17e0:	00001349 	andeq	r1, r0, r9, asr #6
    17e4:	4900260c 	stmdbmi	r0, {r2, r3, r9, sl, sp}
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17e8:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    17ec:	0e03012e 	adfeqsp	f0, f3, #0.5
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17f0:	0b3b0b3a 	bleq	ec44e0 <_etext+0xebcfc8>
    17f4:	13491927 	movtne	r1, #39207	; 0x9927
    17f8:	13010b20 	movwne	r0, #6944	; 0x1b20
            if (pInformation->USBwLengths.w > 0) {
    17fc:	2e0e0000 	cdpcs	0, 0, cr0, cr14, cr0, {0}
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    1800:	3a0e0301 	bcc	38240c <_etext+0x37aef4>
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    1804:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    1808:	010b2019 	tsteq	fp, r9, lsl r0
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    180c:	0f000013 	svceq	0x00000013
                }
                switch (ret)
    1810:	1331012e 	teqne	r1, #-2147483637	; 0x8000000b
    1814:	06120111 			; <UNDEFINED> instruction: 0x06120111
    1818:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
                {
                    case kImageImageIsTrusted:
                        uart_printf("Uploaded signature verified!\n");
    181c:	00130119 	andseq	r0, r3, r9, lsl r1
                        break;

                    case kImageImageMissingMagic:
                    case kImageImageRejectSignature:
                        uart_printf("Image unverified... wiped memory for clean reset.\n");
    1820:	00051000 	andeq	r1, r5, r0
    1824:	17021331 	smladxne	r2, r1, r3, r1
                        break;

                    default:
                        break;
                }
                flashLock();
    1828:	34110000 	ldrcc	r0, [r1], #-0
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    182c:	02133100 	andseq	r3, r3, #0, 2
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1830:	12000017 	andne	r0, r0, #23
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1834:	01018289 	smlabbeq	r1, r9, r2, r8
    1838:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuMANIFEST_SYNC) {
    183c:	00133119 	andseq	r3, r3, r9, lsl r1
        /* device has received last block, waiting DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1840:	828a1300 	addhi	r1, sl, #0, 6
    1844:	18020001 	stmdane	r2, {r0}
            dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    1848:	00184291 	mulseq	r8, r1, r2
            dfuAppStatus.bStatus = OK;
    184c:	01011400 	tsteq	r1, r0, lsl #8
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1850:	13011349 	movwne	r1, #4937	; 0x1349
    1854:	21150000 	tstcs	r5, r0
            dfuAppStatus.bState  = dfuMANIFEST_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuMANIFEST) {
    1858:	2f134900 	svccs	0x00134900
        /* device is in manifestation phase */

        /* should never receive request while in manifest! */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
        dfuAppStatus.bStatus = OK;
    } else if (startState == dfuMANIFEST_WAIT_RESET) {
    185c:	1600000b 	strne	r0, [r0], -fp
        /* device has programmed new firmware but needs external
           usb reset or power on reset to run the new code */

        /* consider timing out and self-resetting */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    } else if (startState == dfuUPLOAD_IDLE) {
    1860:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
    1864:	0b3a0e03 	bleq	e85078 <_etext+0xe7db60>
    1868:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
            if (pInformation->USBwLengths.w > 0) {
    186c:	06120111 			; <UNDEFINED> instruction: 0x06120111
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1870:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
    1874:	00130119 	andseq	r0, r3, r9, lsl r1
    1878:	00051700 	andeq	r1, r5, r0, lsl #14
    187c:	0b3a0803 	bleq	e83890 <_etext+0xe7c378>
    1880:	13490b3b 	movtne	r0, #39739	; 0x9b3b
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1884:	00001702 	andeq	r1, r0, r2, lsl #14
    1888:	03000518 	movweq	r0, #1304	; 0x518
    188c:	3b0b3a0e 	blcc	2d00cc <_etext+0x2c8bb4>
    1890:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1894:	19000017 	stmdbne	r0, {r0, r1, r2, r4}
    1898:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
                    thisBlockLen = uploadBlockLen;
    189c:	0b3b0b3a 	bleq	ec458c <_etext+0xebd074>
    18a0:	17021349 	strne	r1, [r2, -r9, asr #6]
                    dfuAppStatus.bState  = dfuUPLOAD_IDLE;
                } else {
                    /* if above comparison was just equal, thisBlockLen becomes zero
                    next time when USBWValue has been increased by one */
                    thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
    18a4:	341a0000 	ldrcc	r0, [sl], #-0
    18a8:	3a080300 	bcc	2024b0 <_etext+0x1faf98>
    18ac:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    18b0:	00170213 	andseq	r0, r7, r3, lsl r2
                    
                    /* check for overflow due to USBwValue out of range */
                    if (thisBlockLen >= pInformation->USBwLengths.w) {
    18b4:	011d1b00 	tsteq	sp, r0, lsl #22
    18b8:	01521331 	cmpeq	r2, r1, lsr r3
                        thisBlockLen = 0;
    18bc:	0b581755 	bleq	1607618 <_etext+0x1600100>
                    }
                    
                    dfuAppStatus.bState  = dfuIDLE;
                }
            } else {
                dfuAppStatus.bState  = dfuERROR;
    18c0:	13010b59 	movwne	r0, #7001	; 0x1b59
                dfuAppStatus.bStatus = errNOTDONE;
    18c4:	0b1c0000 	bleq	7018cc <_etext+0x6fa3b4>
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    18c8:	00175501 	andseq	r5, r7, r1, lsl #10
            dfuAppStatus.bState  = dfuIDLE;
    18cc:	011d1d00 	tsteq	sp, r0, lsl #26
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18d0:	01111331 	tsteq	r1, r1, lsr r3
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18d4:	0b580612 	bleq	1603124 <_etext+0x15fbc0c>
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    18d8:	13010b59 	movwne	r0, #7001	; 0x1b59
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuERROR)               {
    18dc:	051e0000 	ldreq	r0, [lr, #-0]
        /* status is in error, awaiting DFU_CLRSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18e0:	00133100 	andseq	r3, r3, r0, lsl #2
    18e4:	010b1f00 	tsteq	fp, r0, lsl #30
    18e8:	06120111 			; <UNDEFINED> instruction: 0x06120111
            /* todo, add routine to wait for last block write to finish */
            dfuAppStatus.bState  = dfuERROR;
    18ec:	0b200000 	bleq	8018f4 <_etext+0x7fa3dc>
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18f0:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
            dfuAppStatus.bState  = dfuERROR;
        } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
    18f4:	00130106 	andseq	r0, r3, r6, lsl #2
            /* todo handle any cleanup we need here */
            dfuAppStatus.bState  = dfuIDLE;
    18f8:	011d2100 	tsteq	sp, r0, lsl #2
            dfuAppStatus.bStatus = OK;
    18fc:	01521331 	cmpeq	r2, r1, lsr r3
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else {
        /* some kind of error... */
        dfuAppStatus.bState  = dfuERROR;
    1900:	0b581755 	bleq	160765c <_etext+0x1600144>
        dfuAppStatus.bStatus = errSTALLEDPKT;
    1904:	00000b59 	andeq	r0, r0, r9, asr fp
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}
    1908:	31003422 	tstcc	r0, r2, lsr #8
    190c:	00180213 	andseq	r0, r8, r3, lsl r2
    1910:	011d2300 	tsteq	sp, r0, lsl #6
    1914:	01111331 	tsteq	r1, r1, lsr r3
    1918:	0b580612 	bleq	1603168 <_etext+0x15fbc50>
    191c:	00000b59 	andeq	r0, r0, r9, asr fp
    1920:	01828924 	orreq	r8, r2, r4, lsr #18
    1924:	31011101 	tstcc	r1, r1, lsl #2
    1928:	25000013 	strcs	r0, [r0, #-19]
    192c:	08030034 	stmdaeq	r3, {r2, r4, r5}
    1930:	0b3b0b3a 	bleq	ec4620 <_etext+0xebd108>
    1934:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    1938:	05260000 	streq	r0, [r6, #-0]!
    193c:	02133100 	andseq	r3, r3, #0, 2
    1940:	27000018 	smladcs	r0, r8, r0, r0
    1944:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    1948:	0b3a0e03 	bleq	e8515c <_etext+0xe7dc44>
    194c:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    dfuAppStatus.bState = newState;
}

bool dfuUploadStarted()
{
    return dfuBusy;
    1950:	01111349 	tsteq	r1, r9, asr #6
}
    1954:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    1958:	01194297 			; <UNDEFINED> instruction: 0x01194297

void dfuFinishUpload() {

    while (1)
	{
		__asm__ __volatile__ ("");
    195c:	28000013 	stmdacs	r0, {r0, r1, r4}
};

/* Conversion to and from projective coordinates */
void ed25519_project(struct ed25519_pt *p,
		     const uint8_t *x, const uint8_t *y)
{
    1960:	08030005 	stmdaeq	r3, {r0, r2}
    1964:	0b3b0b3a 	bleq	ec4654 <_etext+0xebd13c>
    1968:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    196c:	34290000 	strtcc	r0, [r9], #-0
    1970:	3a0e0300 	bcc	382578 <_etext+0x37b060>
    1974:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1978:	00180213 	andseq	r0, r8, r3, lsl r2
    197c:	010b2a00 	tsteq	fp, r0, lsl #20
    1980:	13011755 	movwne	r1, #5973	; 0x1755
    1984:	892b0000 	stmdbhi	fp!, {}	; <UNPREDICTABLE>
    1988:	11010182 	smlabbne	r1, r2, r1, r0
    198c:	01133101 	tsteq	r3, r1, lsl #2
    1990:	2c000013 	stccs	0, cr0, [r0], {19}
    1994:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1998:	0b3b0b3a 	bleq	ec4688 <_etext+0xebd170>
    199c:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
    19a0:	00001802 	andeq	r1, r0, r2, lsl #16
    19a4:	3f012e2d 	svccc	0x00012e2d
    19a8:	270e0319 	smladcs	lr, r9, r3, r0
    19ac:	34134919 	ldrcc	r4, [r3], #-2329	; 0x919
    19b0:	00193c19 	andseq	r3, r9, r9, lsl ip
    19b4:	00052e00 	andeq	r2, r5, r0, lsl #28
    19b8:	00001349 	andeq	r1, r0, r9, asr #6
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
    19bc:	01110100 	tsteq	r1, r0, lsl #2
	f25519_mul__distinct(p->t, x, y);
    19c0:	0b130e25 	bleq	4c525c <_etext+0x4bdd44>
    19c4:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
}
    19c8:	01111755 	tsteq	r1, r5, asr r7
		     const uint8_t *x, const uint8_t *y)
{
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
	f25519_mul__distinct(p->t, x, y);
    19cc:	00001710 	andeq	r1, r0, r0, lsl r7
}

void ed25519_unproject(uint8_t *x, uint8_t *y,
		       const struct ed25519_pt *p)
{
    19d0:	0b002402 	bleq	a9e0 <_etext+0x34c8>
    19d4:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    19d8:	0300000e 	movweq	r0, #14
	uint8_t z1[F25519_SIZE];

	f25519_inv__distinct(z1, p->z);
    19dc:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    19e0:	0b3b0b3a 	bleq	ec46d0 <_etext+0xebd1b8>
	f25519_mul__distinct(x, p->x, z1);
    19e4:	00001349 	andeq	r1, r0, r9, asr #6
    19e8:	0b002404 	bleq	aa00 <_etext+0x34e8>
    19ec:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
	f25519_mul__distinct(y, p->y, z1);
    19f0:	05000008 	streq	r0, [r0, #-8]
    19f4:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    19f8:	0b3a0e03 	bleq	e8520c <_etext+0xe7dcf4>

	f25519_normalize(x);
    19fc:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
	f25519_normalize(y);
    1a00:	06120111 			; <UNDEFINED> instruction: 0x06120111
    1a04:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
}
    1a08:	00130119 	andseq	r0, r3, r9, lsl r1
	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
};

void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y)
{
    1a0c:	00050600 	andeq	r0, r5, r0, lsl #12
    1a10:	0b3a0e03 	bleq	e85224 <_etext+0xe7dd0c>
    1a14:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1a18:	00001702 	andeq	r1, r0, r2, lsl #14
    1a1c:	03000507 	movweq	r0, #1287	; 0x507
    1a20:	3b0b3a08 	blcc	2d0248 <_etext+0x2c8d30>
    1a24:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1a28:	08000017 	stmdaeq	r0, {r0, r1, r2, r4}
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
    1a2c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1a30:	0b3b0b3a 	bleq	ec4720 <_etext+0xebd208>
    1a34:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    1a38:	89090000 	stmdbhi	r9, {}	; <UNPREDICTABLE>
    1a3c:	11010182 	smlabbne	r1, r2, r1, r0
    1a40:	01133101 	tsteq	r3, r1, lsl #2
    1a44:	0a000013 	beq	1a98 <ed25519_try_unpack+0x2c>
    1a48:	0001828a 	andeq	r8, r1, sl, lsl #5
    1a4c:	42911802 	addsmi	r1, r1, #131072	; 0x20000
    1a50:	0b000018 	bleq	1ab8 <ed25519_try_unpack+0x4c>
	parity = (tmp[0] & 1) << 7;
    1a54:	01018289 	smlabbeq	r1, r9, r2, r8

	f25519_copy(c, y);
	f25519_normalize(c);
    1a58:	13310111 	teqne	r1, #1073741828	; 0x40000004
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1a5c:	0f0c0000 	svceq	0x000c0000
    1a60:	490b0b00 	stmdbmi	fp, {r8, r9, fp}

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1a64:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
}
    1a68:	13490026 	movtne	r0, #36902	; 0x9026

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1a6c:	010e0000 	mrseq	r0, (UNDEF: 14)
    1a70:	01134901 	tsteq	r3, r1, lsl #18
    1a74:	0f000013 	svceq	0x00000013
    1a78:	13490021 	movtne	r0, #36897	; 0x9021
	const int parity = comp[31] >> 7;
    1a7c:	00000b2f 	andeq	r0, r0, pc, lsr #22
    1a80:	03012e10 	movweq	r2, #7696	; 0x1e10
    1a84:	3b0b3a0e 	blcc	2d02c4 <_etext+0x2c8dac>
    1a88:	2019270b 	andscs	r2, r9, fp, lsl #14
    1a8c:	0013010b 	andseq	r0, r3, fp, lsl #2
    1a90:	00051100 	andeq	r1, r5, r0, lsl #2
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1a94:	0b3a0803 	bleq	e83aa8 <_etext+0xe7c590>
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1a98:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1a9c:	34120000 	ldrcc	r0, [r2], #-0
    1aa0:	3a080300 	bcc	2026a8 <_etext+0x1fb190>
    1aa4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1aa8:	13000013 	movwne	r0, #19
	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
	f25519_add(a, b, f25519_one);
    1aac:	0e03012e 	adfeqsp	f0, f3, #0.5
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1ab0:	0b3b0b3a 	bleq	ec47a0 <_etext+0xebd288>

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
    1ab4:	13491927 	movtne	r1, #39207	; 0x9927
    1ab8:	13010b20 	movwne	r0, #6944	; 0x1b20
	f25519_add(a, b, f25519_one);
    1abc:	05140000 	ldreq	r0, [r4, #-0]
    1ac0:	3a0e0300 	bcc	3826c8 <_etext+0x37b1b0>
    1ac4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	f25519_inv__distinct(b, a);
    1ac8:	15000013 	strne	r0, [r0, #-19]
    1acc:	08030034 	stmdaeq	r3, {r2, r4, r5}

	/* Compute a = y^2-1 */
	f25519_sub(a, c, f25519_one);
    1ad0:	0b3b0b3a 	bleq	ec47c0 <_etext+0xebd2a8>
    1ad4:	0a1c1349 	beq	706800 <_etext+0x6ff2e8>

	/* Compute c = a*b = (y^2-1)/(1-dy^2) */
	f25519_mul__distinct(c, a, b);
    1ad8:	2e160000 	cdpcs	0, 1, cr0, cr6, cr0, {0}
    1adc:	03193f01 	tsteq	r9, #1, 30
    1ae0:	3b0b3a0e 	blcc	2d0320 <_etext+0x2c8e08>

	/* Compute a, b = +/-sqrt(c), if c is square */
	f25519_sqrt(a, c);
    1ae4:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    1ae8:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
	f25519_neg(b, a);
    1aec:	97184006 	ldrls	r4, [r8, -r6]
    1af0:	13011942 	movwne	r1, #6466	; 0x1942

	/* Select one of them, based on the compressed parity bit */
	f25519_select(x, a, b, (a[0] ^ parity) & 1);
    1af4:	1d170000 	ldcne	0, cr0, [r7, #-0]
    1af8:	52133101 	andspl	r3, r3, #1073741824	; 0x40000000
    1afc:	58175501 	ldmdapl	r7, {r0, r8, sl, ip, lr}
    1b00:	010b590b 	tsteq	fp, fp, lsl #18
    1b04:	18000013 	stmdane	r0, {r0, r1, r4}

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
    1b08:	13310005 	teqne	r1, #5
    1b0c:	00001702 	andeq	r1, r0, r2, lsl #14
    1b10:	55010b19 	strpl	r0, [r1, #-2841]	; 0xb19
	f25519_normalize(a);
    1b14:	1a000017 	bne	1b78 <ed25519_add+0x44>
	f25519_normalize(c);
    1b18:	13310034 	teqne	r1, #52	; 0x34
    1b1c:	00001802 	andeq	r1, r0, r2, lsl #16

	return f25519_eq(a, c);
    1b20:	31011d1b 	tstcc	r1, fp, lsl sp
    1b24:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
}
    1b28:	590b5806 	stmdbpl	fp, {r1, r2, fp, ip, lr}
    1b2c:	0013010b 	andseq	r0, r3, fp, lsl #2
    1b30:	010b1c00 	tsteq	fp, r0, lsl #24
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1b34:	06120111 			; <UNDEFINED> instruction: 0x06120111
    1b38:	341d0000 	ldrcc	r0, [sp], #-0
    1b3c:	3a0e0300 	bcc	382744 <_etext+0x37b22c>
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b40:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1b44:	3c193f13 	ldccc	15, cr3, [r9], {19}
    1b48:	1e000019 	mcrne	0, 0, r0, cr0, cr9, {0}
	f25519_sub(d, p2->y, p2->x);
    1b4c:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b50:	0b3a0e03 	bleq	e85364 <_etext+0xe7de4c>
	f25519_sub(d, p2->y, p2->x);
    1b54:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    1b58:	1301193c 	movwne	r1, #6460	; 0x193c
	f25519_mul__distinct(a, c, d);
    1b5c:	051f0000 	ldreq	r0, [pc, #-0]	; 1b64 <ed25519_add+0x30>
    1b60:	00134900 	andseq	r4, r3, r0, lsl #18
    1b64:	012e2000 	teqeq	lr, r0

	/* B = (Y1+X1)(Y2+X2) */
	f25519_add(c, p1->y, p1->x);
    1b68:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    1b6c:	0b3b0b3a 	bleq	ec485c <_etext+0xebd344>
	f25519_add(d, p2->y, p2->x);
    1b70:	13491927 	movtne	r1, #39207	; 0x9927
    1b74:	0000193c 	andeq	r1, r0, ip, lsr r9
    1b78:	01110100 	tsteq	r1, r0, lsl #2
	f25519_mul__distinct(b, c, d);
    1b7c:	0b130e25 	bleq	4c5418 <_etext+0x4bdf00>
    1b80:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}

	/* C = T1 k T2 */
	f25519_mul__distinct(d, p1->t, p2->t);
    1b84:	01111755 	tsteq	r1, r5, asr r7
    1b88:	00001710 	andeq	r1, r0, r0, lsl r7
    1b8c:	0b002402 	bleq	ab9c <_etext+0x3684>
    1b90:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
	f25519_mul__distinct(c, d, ed25519_k);
    1b94:	03000008 	movweq	r0, #8
    1b98:	0b0b0024 	bleq	2c1c30 <_etext+0x2ba718>

	/* D = Z1 2 Z2 */
	f25519_mul__distinct(d, p1->z, p2->z);
    1b9c:	0e030b3e 	vmoveq.16	d3[0], r0
    1ba0:	0f040000 	svceq	0x00040000
    1ba4:	000b0b00 	andeq	r0, fp, r0, lsl #22
    1ba8:	000f0500 	andeq	r0, pc, r0, lsl #10
	f25519_add(d, d, d);
    1bac:	13490b0b 	movtne	r0, #39691	; 0x9b0b
    1bb0:	13060000 	movwne	r0, #24576	; 0x6000

	/* E = B - A */
	f25519_sub(e, b, a);
    1bb4:	3a0b0b01 	bcc	2c47c0 <_etext+0x2bd2a8>
    1bb8:	010b3b0b 	tsteq	fp, fp, lsl #22
    1bbc:	07000013 	smladeq	r0, r3, r0, r0

	/* F = D - C */
	f25519_sub(f, d, c);
    1bc0:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    1bc4:	0b3b0b3a 	bleq	ec48b4 <_etext+0xebd39c>

	/* G = D + C */
	f25519_add(g, d, c);
    1bc8:	0b381349 	bleq	e068f4 <_etext+0xdff3dc>
    1bcc:	01080000 	mrseq	r0, (UNDEF: 8)
    1bd0:	01134901 	tsteq	r3, r1, lsl #18

	/* H = B + A */
	f25519_add(h, b, a);
    1bd4:	09000013 	stmdbeq	r0, {r0, r1, r4}
    1bd8:	13490021 	movtne	r0, #36897	; 0x9021

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1bdc:	00000b2f 	andeq	r0, r0, pc, lsr #22
    1be0:	0300160a 	movweq	r1, #1546	; 0x60a
    1be4:	3b0b3a0e 	blcc	2d0424 <_etext+0x2c8f0c>

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1be8:	0013490b 	andseq	r4, r3, fp, lsl #18
    1bec:	012e0b00 	teqeq	lr, r0, lsl #22
    1bf0:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1bf4:	0b3b0b3a 	bleq	ec48e4 <_etext+0xebd3cc>
    1bf8:	0b201927 	bleq	80809c <_etext+0x800b84>
    1bfc:	00001301 	andeq	r1, r0, r1, lsl #6

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1c00:	0300050c 	movweq	r0, #1292	; 0x50c
    1c04:	3b0b3a08 	blcc	2d042c <_etext+0x2c8f14>
    1c08:	0013490b 	andseq	r4, r3, fp, lsl #18
}
    1c0c:	00050d00 	andeq	r0, r5, r0, lsl #26
    1c10:	0b3a0e03 	bleq	e85424 <_etext+0xe7df0c>

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1c14:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1c18:	340e0000 	strcc	r0, [lr], #-0

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1c1c:	3a0e0300 	bcc	382824 <_etext+0x37b30c>
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1c20:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1c24:	0f000013 	svceq	0x00000013

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1c28:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    1c2c:	0b3a0e03 	bleq	e85440 <_etext+0xe7df28>
    1c30:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}

	/* C = 2 Z1^2 */
	f25519_mul__distinct(c, p->z, p->z);
    1c34:	06120111 			; <UNDEFINED> instruction: 0x06120111
    1c38:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
    1c3c:	00130119 	andseq	r0, r3, r9, lsl r1
	f25519_add(c, c, c);
    1c40:	00051000 	andeq	r1, r5, r0
    1c44:	0b3a0803 	bleq	e83c58 <_etext+0xe7c740>

	/* D = a A (alter sign) */
	/* E = (X1+Y1)^2-A-B */
	f25519_add(f, p->x, p->y);
    1c48:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1c4c:	00001802 	andeq	r1, r0, r2, lsl #16
    1c50:	03000511 	movweq	r0, #1297	; 0x511
	f25519_mul__distinct(e, f, f);
    1c54:	3b0b3a08 	blcc	2d047c <_etext+0x2c8f64>
    1c58:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
	f25519_sub(e, e, a);
    1c5c:	12000017 	andne	r0, r0, #23
    1c60:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    1c64:	0b3b0b3a 	bleq	ec4954 <_etext+0xebd43c>
	f25519_sub(e, e, b);
    1c68:	17021349 	strne	r1, [r2, -r9, asr #6]
    1c6c:	34130000 	ldrcc	r0, [r3], #-0

	/* G = D + B */
	f25519_sub(g, b, a);
    1c70:	3a0e0300 	bcc	382878 <_etext+0x37b360>
    1c74:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1c78:	00170213 	andseq	r0, r7, r3, lsl r2

	/* F = G - C */
	f25519_sub(f, g, c);
    1c7c:	00341400 	eorseq	r1, r4, r0, lsl #8
    1c80:	0b3a0803 	bleq	e83c94 <_etext+0xe7c77c>

	/* H = D - B */
	f25519_neg(h, b);
    1c84:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1c88:	00001702 	andeq	r1, r0, r2, lsl #14
	f25519_sub(h, h, a);
    1c8c:	31012e15 	tstcc	r1, r5, lsl lr
    1c90:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    1c94:	97184006 	ldrls	r4, [r8, -r6]

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1c98:	13011942 	movwne	r1, #6466	; 0x1942
    1c9c:	05160000 	ldreq	r0, [r6, #-0]

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1ca0:	02133100 	andseq	r3, r3, #0, 2
    1ca4:	17000017 	smladne	r0, r7, r0, r0
    1ca8:	13310034 	teqne	r1, #52	; 0x34

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1cac:	0b180000 	bleq	601cb4 <_etext+0x5fa79c>
    1cb0:	00175501 	andseq	r5, r7, r1, lsl #10
    1cb4:	00341900 	eorseq	r1, r4, r0, lsl #18

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1cb8:	17021331 	smladxne	r2, r1, r3, r1
    1cbc:	891a0000 	ldmdbhi	sl, {}	; <UNPREDICTABLE>
    1cc0:	11010182 	smlabbne	r1, r2, r1, r0
}
    1cc4:	01133101 	tsteq	r3, r1, lsl #2

void ed25519_smult(struct ed25519_pt *r_out, const struct ed25519_pt *p,
		   const uint8_t *e)
{
    1cc8:	1b000013 	blne	1d1c <ed25519_smult+0x54>
    1ccc:	0001828a 	andeq	r8, r1, sl, lsl #5
    1cd0:	42911802 	addsmi	r1, r1, #131072	; 0x20000
    1cd4:	1c000018 	stcne	0, cr0, [r0], {24}
    1cd8:	00018289 	andeq	r8, r1, r9, lsl #5
    1cdc:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1ce0:	00133119 	andseq	r3, r3, r9, lsl r1
    1ce4:	82891d00 	addhi	r1, r9, #0, 26
    1ce8:	01110101 	tsteq	r1, r1, lsl #2
		struct ed25519_pt s;

		ed25519_double(&r, &r);
    1cec:	00001331 	andeq	r1, r0, r1, lsr r3
    1cf0:	0300341e 	movweq	r3, #1054	; 0x41e
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1cf4:	3b0b3a0e 	blcc	2d0534 <_etext+0x2c901c>
		struct ed25519_pt s;

		ed25519_double(&r, &r);
		ed25519_add(&s, &r, p);
    1cf8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1cfc:	1f000018 	svcne	0x00000018

		f25519_select(r.x, r.x, s.x, bit);
    1d00:	1331011d 	teqne	r1, #1073741831	; 0x40000007
    1d04:	17550152 			; <UNDEFINED> instruction: 0x17550152
    1d08:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xb58
		f25519_select(r.y, r.y, s.y, bit);
    1d0c:	00001301 	andeq	r1, r0, r1, lsl #6
    1d10:	31000520 	tstcc	r0, r0, lsr #10
    1d14:	00180213 	andseq	r0, r8, r3, lsl r2
		f25519_select(r.z, r.z, s.z, bit);
    1d18:	011d2100 	tsteq	sp, r0, lsl #2
    1d1c:	01521331 	cmpeq	r2, r1, lsr r3
    1d20:	0b581755 	bleq	1607a7c <_etext+0x1600564>
		f25519_select(r.t, r.t, s.t, bit);
    1d24:	00000559 	andeq	r0, r0, r9, asr r5
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d28:	03003422 	movweq	r3, #1058	; 0x422
		ed25519_add(&s, &r, p);

		f25519_select(r.x, r.x, s.x, bit);
		f25519_select(r.y, r.y, s.y, bit);
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
    1d2c:	3b0b3a08 	blcc	2d0554 <_etext+0x2c903c>
    1d30:	3f13490b 	svccc	0x0013490b
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d34:	00180219 	andseq	r0, r8, r9, lsl r2
    1d38:	012e2300 	teqeq	lr, r0, lsl #6
    1d3c:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
	}

	ed25519_copy(r_out, &r);
}
    1d40:	13491927 	movtne	r1, #39207	; 0x9927
    1d44:	193c1934 	ldmdbne	ip!, {r2, r4, r5, r8, fp, ip}
    1d48:	00001301 	andeq	r1, r0, r1, lsl #6
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1d4c:	49000524 	stmdbmi	r0, {r2, r5, r8, sl}
    1d50:	25000013 	strcs	r0, [r0, #-19]
    1d54:	00000026 	andeq	r0, r0, r6, lsr #32
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d58:	01110100 	tsteq	r1, r0, lsl #2
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1d5c:	0b130e25 	bleq	4c55f8 <_etext+0x4be0e0>
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d60:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    1d64:	01111755 	tsteq	r1, r5, asr r7
    1d68:	00001710 	andeq	r1, r0, r0, lsl r7
    1d6c:	0b002402 	bleq	ad7c <_etext+0x3864>
	memcpy(block + 32, a, 32);
    1d70:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    1d74:	0300000e 	movweq	r0, #14
    1d78:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    1d7c:	0b3b0b3a 	bleq	ec4a6c <_etext+0xebd554>
    1d80:	00001349 	andeq	r1, r0, r9, asr #6
    1d84:	0b002404 	bleq	ad9c <_etext+0x3884>
    1d88:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    1d8c:	05000008 	streq	r0, [r0, #-8]
    1d90:	0b0b000f 	bleq	2c1dd4 <_etext+0x2ba8bc>
    1d94:	13060000 	movwne	r0, #24576	; 0x6000
    1d98:	0b0e0301 	bleq	3829a4 <_etext+0x37b48c>
    1d9c:	3b0b3a0b 	blcc	2d05d0 <_etext+0x2c90b8>
{
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
    1da0:	0013010b 	andseq	r0, r3, fp, lsl #2
    1da4:	000d0700 	andeq	r0, sp, r0, lsl #14
    1da8:	0b3a0803 	bleq	e83dbc <_etext+0xe7c8a4>
		memcpy(init_block + prefix_size, message, len);
		sha512_final(&s, init_block, len + prefix_size);
	} else {
		size_t i;

		memcpy(init_block + prefix_size, message,
    1dac:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1db0:	00000b38 	andeq	r0, r0, r8, lsr fp
    1db4:	49010108 	stmdbmi	r1, {r3, r8}
    1db8:	00130113 	andseq	r0, r3, r3, lsl r1
    1dbc:	00210900 	eoreq	r0, r1, r0, lsl #18
    1dc0:	0b2f1349 	bleq	bc6aec <_etext+0xbbf5d4>
    1dc4:	2e0a0000 	cdpcs	0, 0, cr0, cr10, cr0, {0}
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);
    1dc8:	3a0e0301 	bcc	3829d4 <_etext+0x37b4bc>
    1dcc:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dd0:	20134919 	andscs	r4, r3, r9, lsl r9
    1dd4:	0013010b 	andseq	r0, r3, fp, lsl #2
    1dd8:	00050b00 	andeq	r0, r5, r0, lsl #22
    1ddc:	0b3a0803 	bleq	e83df0 <_etext+0xe7c8d8>
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1de0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
		     i + SHA512_BLOCK_SIZE <= len;
    1de4:	050c0000 	streq	r0, [ip, #-0]
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1de8:	3a0e0300 	bcc	3829f0 <_etext+0x37b4d8>

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dec:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
    1df0:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
    1df4:	0e03012e 	adfeqsp	f0, f3, #0.5
    1df8:	0b3b0b3a 	bleq	ec4ae8 <_etext+0xebd5d0>
    1dfc:	0b201927 	bleq	8082a0 <_etext+0x800d88>
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
		memcpy(init_block + prefix_size, message, len);
    1e00:	00001301 	andeq	r1, r0, r1, lsl #6
    1e04:	0b000f0e 	bleq	5a44 <imageCheckFromAddress+0xc>
    1e08:	0013490b 	andseq	r4, r3, fp, lsl #18
		sha512_final(&s, init_block, len + prefix_size);
    1e0c:	00340f00 	eorseq	r0, r4, r0, lsl #30
    1e10:	0b3a0803 	bleq	e83e24 <_etext+0xe7c90c>
    1e14:	13490b3b 	movtne	r0, #39739	; 0x9b3b
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
	}

	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
    1e18:	26100000 	ldrcs	r0, [r0], -r0
    1e1c:	00134900 	andseq	r4, r3, r0, lsl #18
    1e20:	012e1100 	teqeq	lr, r0, lsl #2
	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
    1e24:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    1e28:	0b3b0b3a 	bleq	ec4b18 <_etext+0xebd600>
    1e2c:	01111927 	tsteq	r1, r7, lsr #18

static void sm_pack(uint8_t *r, const uint8_t *k)
{
	struct ed25519_pt p;

	ed25519_smult(&p, &ed25519_base, k);
    1e30:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    1e34:	01194297 			; <UNDEFINED> instruction: 0x01194297
    1e38:	12000013 	andne	r0, r0, #19
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1e3c:	08030005 	stmdaeq	r3, {r0, r2}
    1e40:	0b3b0b3a 	bleq	ec4b30 <_etext+0xebd618>
	ed25519_pack(packed, x, y);
    1e44:	17021349 	strne	r1, [r2, -r9, asr #6]
    1e48:	34130000 	ldrcc	r0, [r3], #-0
    1e4c:	3a080300 	bcc	202a54 <_etext+0x1fb53c>

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e50:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1e54:	00180213 	andseq	r0, r8, r3, lsl r2

	ed25519_project(p, x, y);
    1e58:	00341400 	eorseq	r1, r4, r0, lsl #8
    1e5c:	0b3a0803 	bleq	e83e70 <_etext+0xe7c958>
    1e60:	13490b3b 	movtne	r0, #39739	; 0x9b3b
	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
    1e64:	00001702 	andeq	r1, r0, r2, lsl #14
    1e68:	31011d15 	tstcc	r1, r5, lsl sp
    1e6c:	55015213 	strpl	r5, [r1, #-531]	; 0x213

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e70:	590b5817 	stmdbpl	fp, {r0, r1, r2, r4, fp, ip, lr}
    1e74:	0013010b 	andseq	r0, r3, fp, lsl #2

	ed25519_project(p, x, y);
    1e78:	00051600 	andeq	r1, r5, r0, lsl #12
    1e7c:	17021331 	smladxne	r2, r1, r3, r1
    1e80:	0b170000 	bleq	5c1e88 <_etext+0x5ba970>

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
    1e84:	00175501 	andseq	r5, r7, r1, lsl #10
    1e88:	00341800 	eorseq	r1, r4, r0, lsl #16
    1e8c:	17021331 	smladxne	r2, r1, r3, r1
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1e90:	0b190000 	bleq	641e98 <_etext+0x63a980>
    1e94:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
	ed25519_pack(packed, x, y);
    1e98:	1a000006 	bne	1eb8 <edsign_verify+0x16c>
    1e9c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1ea0:	0b3b0b3a 	bleq	ec4b90 <_etext+0xebd678>
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
    1ea4:	17021349 	strne	r1, [r2, -r9, asr #6]
    1ea8:	1d1b0000 	ldcne	0, cr0, [fp, #-0]
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
    1eac:	52133101 	andspl	r3, r3, #1073741824	; 0x40000000
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
}
    1eb0:	58175501 	ldmdapl	r7, {r0, r8, sl, ip, lr}
    1eb4:	000b590b 	andeq	r5, fp, fp, lsl #18

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1eb8:	00051c00 	andeq	r1, r5, r0, lsl #24
    1ebc:	0b3a0e03 	bleq	e856d0 <_etext+0xe7e1b8>
    1ec0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1ec4:	00001702 	andeq	r1, r0, r2, lsl #14

const uint8_t f25519_zero[F25519_SIZE] = {0};
const uint8_t f25519_one[F25519_SIZE] = {1};

void f25519_load(uint8_t *x, uint32_t c)
{
    1ec8:	0300341d 	movweq	r3, #1053	; 0x41d
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
		c >>= 8;
    1ecc:	3b0b3a0e 	blcc	2d070c <_etext+0x2c91f4>
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    1ed0:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1ed4:	1e000018 	mcrne	0, 0, r0, cr0, cr8, {0}
    1ed8:	01018289 	smlabbeq	r1, r9, r2, r8
    1edc:	13310111 	teqne	r1, #1073741828	; 0x40000004
		c >>= 8;
	}

	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}
    1ee0:	00001301 	andeq	r1, r0, r1, lsl #6
    1ee4:	01828a1f 	orreq	r8, r2, pc, lsl sl

void f25519_normalize(uint8_t *x)
{
    1ee8:	91180200 	tstls	r8, r0, lsl #4
    1eec:	00001842 	andeq	r1, r0, r2, asr #16
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1ef0:	01828920 	orreq	r8, r2, r0, lsr #18
	x[31] &= 127;
    1ef4:	31011101 	tstcc	r1, r1, lsl #2

	for (i = 0; i < F25519_SIZE; i++) {
    1ef8:	21000013 	tstcs	r0, r3, lsl r0
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1efc:	0111010b 	tsteq	r1, fp, lsl #2
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
		c += x[i];
    1f00:	13010612 	movwne	r0, #5650	; 0x1612
		x[i] = c;
    1f04:	05220000 	streq	r0, [r2, #-0]!

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1f08:	00133100 	andseq	r3, r3, r0, lsl #2
		c += x[i];
		x[i] = c;
		c >>= 8;
    1f0c:	00342300 	eorseq	r2, r4, r0, lsl #6

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1f10:	0b3a0e03 	bleq	e85724 <_etext+0xe7e20c>
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += x[i];
    1f14:	13490b3b 	movtne	r0, #39739	; 0x9b3b
		minusp[i] = c;
    1f18:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1f1c:	2e240000 	cdpcs	0, 2, cr0, cr4, cr0, {0}
		c += x[i];
		minusp[i] = c;
		c >>= 8;
    1f20:	03193f01 	tsteq	r9, #1, 30
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1f24:	4919270e 	ldmdbmi	r9, {r1, r2, r3, r8, r9, sl, sp}
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1f28:	3c193413 	cfldrscc	mvf3, [r9], {19}
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1f2c:	00130119 	andseq	r0, r3, r9, lsl r1

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1f30:	00052500 	andeq	r2, r5, r0, lsl #10
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;
    1f34:	00001349 	andeq	r1, r0, r9, asr #6

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1f38:	00002626 	andeq	r2, r0, r6, lsr #12
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    1f3c:	11010000 	mrsne	r0, (UNDEF: 1)
    1f40:	130e2501 	movwne	r2, #58625	; 0xe501
    1f44:	1b0e030b 	blne	382b78 <_etext+0x37b660>
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1f48:	1117550e 	tstne	r7, lr, lsl #10
    1f4c:	00171001 	andseq	r1, r7, r1
	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;

	/* Load x-p if no underflow */
	f25519_select(x, minusp, x, (c >> 15) & 1);
}
    1f50:	00160200 	andseq	r0, r6, r0, lsl #4
    1f54:	0b3a0e03 	bleq	e85768 <_etext+0xe7e250>

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
    1f58:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1f5c:	24030000 	strcs	r0, [r3], #-0
    1f60:	3e0b0b00 	vmlacc.f64	d0, d11, d0
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    1f64:	000e030b 	andeq	r0, lr, fp, lsl #6
    1f68:	000f0400 	andeq	r0, pc, r0, lsl #8
    1f6c:	00000b0b 	andeq	r0, r0, fp, lsl #22
    1f70:	0b002405 	bleq	af8c <_etext+0x3a74>
    1f74:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    1f78:	06000008 	streq	r0, [r0], -r8
    1f7c:	0b0b000f 	bleq	2c1fc0 <_etext+0x2baaa8>
    1f80:	00001349 	andeq	r1, r0, r9, asr #6
    1f84:	03001607 	movweq	r1, #1543	; 0x607
    1f88:	3b0b3a08 	blcc	2d07b0 <_etext+0x2c9298>
    1f8c:	0013490b 	andseq	r4, r3, fp, lsl #18
    1f90:	00350800 	eorseq	r0, r5, r0, lsl #16
    1f94:	00001349 	andeq	r1, r0, r9, asr #6
    1f98:	0b010409 	bleq	42fc4 <_etext+0x3baac>
    1f9c:	3b0b3a0b 	blcc	2d07d0 <_etext+0x2c92b8>
    1fa0:	0013010b 	andseq	r0, r3, fp, lsl #2
    1fa4:	00280a00 	eoreq	r0, r8, r0, lsl #20
    1fa8:	0d1c0e03 	ldceq	14, cr0, [ip, #-12]
    1fac:	130b0000 	movwne	r0, #45056	; 0xb000
    1fb0:	3a0b0b01 	bcc	2c4bbc <_etext+0x2bd6a4>
    1fb4:	010b3b0b 	tsteq	fp, fp, lsl #22
    1fb8:	0c000013 	stceq	0, cr0, [r0], {19}
    1fbc:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    1fc0:	0b3b0b3a 	bleq	ec4cb0 <_etext+0xebd798>

	sum |= (sum >> 4);
    1fc4:	0b381349 	bleq	e06cf0 <_etext+0xdff7d8>
	sum |= (sum >> 2);
    1fc8:	010d0000 	mrseq	r0, (UNDEF: 13)
	sum |= (sum >> 1);
    1fcc:	01134901 	tsteq	r3, r1, lsl #18

	return (sum ^ 1) & 1;
    1fd0:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
}
    1fd4:	13490021 	movtne	r0, #36897	; 0x9021
    1fd8:	00000b2f 	andeq	r0, r0, pc, lsr #22
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fdc:	0301130f 	movweq	r1, #4879	; 0x130f
		sum |= x[i] ^ y[i];
    1fe0:	3a0b0b0e 	bcc	2c4c20 <_etext+0x2bd708>
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fe4:	010b3b0b 	tsteq	fp, fp, lsl #22
    1fe8:	10000013 	andne	r0, r0, r3, lsl r0
		sum |= x[i] ^ y[i];
    1fec:	13490021 	movtne	r0, #36897	; 0x9021
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1ff0:	2e110000 	cdpcs	0, 1, cr0, cr1, cr0, {0}
}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
    1ff4:	03193f01 	tsteq	r9, #1, 30
    1ff8:	3b0b3a0e 	blcc	2d0838 <_etext+0x2c9320>
    1ffc:	1201110b 	andne	r1, r1, #-1073741822	; 0xc0000002
    2000:	97184006 	ldrls	r4, [r8, -r6]
    2004:	13011942 	movwne	r1, #6466	; 0x1942
    2008:	89120000 	ldmdbhi	r2, {}	; <UNPREDICTABLE>
    200c:	11010182 	smlabbne	r1, r2, r1, r0
    2010:	01133101 	tsteq	r3, r1, lsl #2
    2014:	13000013 	movwne	r0, #19
	const uint8_t mask = -condition;
    2018:	0001828a 	andeq	r8, r1, sl, lsl #5
    201c:	42911802 	addsmi	r1, r1, #131072	; 0x20000
    2020:	14000018 	strne	r0, [r0], #-24
    2024:	01018289 	smlabbeq	r1, r9, r2, r8
    2028:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
    202c:	00133119 	andseq	r3, r3, r9, lsl r1
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    2030:	012e1500 	teqeq	lr, r0, lsl #10
    2034:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    2038:	0b3b0b3a 	bleq	ec4d28 <_etext+0xebd810>
    203c:	13491927 	movtne	r1, #39207	; 0x9927
    2040:	06120111 			; <UNDEFINED> instruction: 0x06120111
    2044:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
    2048:	00130119 	andseq	r0, r3, r9, lsl r1
    204c:	00051600 	andeq	r1, r5, r0, lsl #12
    2050:	0b3a0e03 	bleq	e85864 <_etext+0xe7e34c>
    2054:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2058:	00001702 	andeq	r1, r0, r2, lsl #14
    205c:	03003417 	movweq	r3, #1047	; 0x417
    2060:	3b0b3a08 	blcc	2d0888 <_etext+0x2c9370>
    2064:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    2068:	18000017 	stmdane	r0, {r0, r1, r2, r4}
    206c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    2070:	0b3b0b3a 	bleq	ec4d60 <_etext+0xebd848>
    2074:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    2078:	34190000 	ldrcc	r0, [r9], #-0
    207c:	3a0e0300 	bcc	382c84 <_etext+0x37b76c>
    2080:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    2084:	000b1c13 	andeq	r1, fp, r3, lsl ip
    2088:	00341a00 	eorseq	r1, r4, r0, lsl #20
    208c:	0b3a0e03 	bleq	e858a0 <_etext+0xe7e388>
    2090:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2094:	00001702 	andeq	r1, r0, r2, lsl #14
    2098:	0300341b 	movweq	r3, #1051	; 0x41b
}
    209c:	3b0b3a08 	blcc	2d08c4 <_etext+0x2c93ac>
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    20a0:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    20a4:	1c000018 	stcne	0, cr0, [r0], {24}
    20a8:	19340034 	ldmdbne	r4!, {r2, r4, r5}
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    20ac:	17021349 	strne	r1, [r2, -r9, asr #6]
    20b0:	2e1d0000 	cdpcs	0, 1, cr0, cr13, cr0, {0}
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}
    20b4:	03193f01 	tsteq	r9, #1, 30
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    20b8:	3b0b3a0e 	blcc	2d08f8 <_etext+0x2c93e0>
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}

void f25519_add(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint16_t c = 0;
    20bc:	3c13490b 	ldccc	9, cr4, [r3], {11}
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
    20c0:	00130119 	andseq	r0, r3, r9, lsl r1
    20c4:	00181e00 	andseq	r1, r8, r0, lsl #28
		r[i] = c;
    20c8:	891f0000 	ldmdbhi	pc, {}	; <UNPREDICTABLE>
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    20cc:	11000182 	smlabbne	r0, r2, r1, r0
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;
    20d0:	00133101 	andseq	r3, r3, r1, lsl #2
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20d4:	00212000 	eoreq	r2, r1, r0
	c = (c >> 7) * 19;
    20d8:	182f1349 	stmdane	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20dc:	21210000 	teqcs	r1, r0
	c = (c >> 7) * 19;
    20e0:	2f134900 	svccs	0x00134900
    20e4:	22000013 	andcs	r0, r0, #19

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    20e8:	13490026 	movtne	r0, #36902	; 0x9026
    20ec:	34230000 	strtcc	r0, [r3], #-0

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    20f0:	3a0e0300 	bcc	382cf8 <_etext+0x37b7e0>
		c += r[i];
		r[i] = c;
		c >>= 8;
    20f4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    20f8:	02193f13 	andseq	r3, r9, #19, 30	; 0x4c
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    20fc:	24000018 	strcs	r0, [r0], #-24

void f25519_sub(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2100:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
    2104:	0b3a0e03 	bleq	e85918 <_etext+0xe7e400>
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2108:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
    210c:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
    2110:	00001301 	andeq	r1, r0, r1, lsl #6
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2114:	49000525 	stmdbmi	r0, {r0, r2, r5, r8, sl}
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2118:	26000013 			; <UNDEFINED> instruction: 0x26000013
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    211c:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2120:	0b3a0e03 	bleq	e85934 <_etext+0xe7e41c>
    2124:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2128:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
    212c:	00001301 	andeq	r1, r0, r1, lsl #6
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2130:	3f012e27 	svccc	0x00012e27
	c = (c >> 7) * 19;
    2134:	270e0319 	smladcs	lr, r9, r3, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2138:	34134919 	ldrcc	r4, [r3], #-2329	; 0x919
		r[i] = c;
    213c:	01193c19 	tsteq	r9, r9, lsl ip

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2140:	28000013 	stmdacs	r0, {r0, r1, r4}
		c += r[i];
		r[i] = c;
		c >>= 8;
    2144:	00000026 	andeq	r0, r0, r6, lsr #32
	}
}
    2148:	3f002e29 	svccc	0x00002e29

void f25519_neg(uint8_t *r, const uint8_t *a)
{
    214c:	3a0e0319 	bcc	382db8 <_etext+0x37b8a0>
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
    2150:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 - ((uint32_t)a[i]);
    2154:	00193c19 	andseq	r3, r9, r9, lsl ip
    2158:	012e2a00 	teqeq	lr, r0, lsl #20
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    215c:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
    2160:	0b3b0b3a 	bleq	ec4e50 <_etext+0xebd938>
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2164:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2168:	00001301 	andeq	r1, r0, r1, lsl #6
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;
    216c:	3f012e2b 	svccc	0x00012e2b
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    2170:	3a0e0319 	bcc	382ddc <_etext+0x37b8c4>
	c = (c >> 7) * 19;
    2174:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    2178:	01193c19 	tsteq	r9, r9, lsl ip

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    217c:	00000013 	andeq	r0, r0, r3, lsl r0
		r[i] = c;
    2180:	25011101 	strcs	r1, [r1, #-257]	; 0x101

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2184:	030b130e 	movweq	r1, #45838	; 0xb30e
		c += r[i];
		r[i] = c;
		c >>= 8;
    2188:	550e1b0e 	strpl	r1, [lr, #-2830]	; 0xb0e
	}
}
    218c:	10011117 	andne	r1, r1, r7, lsl r1
    2190:	02000017 	andeq	r0, r0, #23

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2194:	0b0b0024 	bleq	2c222c <_etext+0x2bad14>
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2198:	0e030b3e 	vmoveq.16	d3[0], r0
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    219c:	16030000 	strne	r0, [r3], -r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    21a0:	3a080300 	bcc	202da8 <_etext+0x1fb890>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    21a4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
		for (j = 0; j <= i; j++)
    21a8:	04000013 	streq	r0, [r0], #-19
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    21ac:	0e030104 	adfeqs	f0, f3, f4

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    21b0:	0b3a0b0b 	bleq	e84de4 <_etext+0xe7d8cc>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    21b4:	13010b3b 	movwne	r0, #6971	; 0x1b3b

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    21b8:	28050000 	stmdacs	r5, {}	; <UNPREDICTABLE>
    21bc:	1c0e0300 	stcne	3, cr0, [lr], {-0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21c0:	0600000d 	streq	r0, [r0], -sp
    21c4:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
    21c8:	0b3b0b3a 	bleq	ec4eb8 <_etext+0xebd9a0>
    21cc:	00001349 	andeq	r1, r0, r9, asr #6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    21d0:	3f012e07 	svccc	0x00012e07
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    21d4:	3a0e0319 	bcc	382e40 <_etext+0x37b928>
    21d8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21dc:	20134919 	andscs	r4, r3, r9, lsl r9
			c += ((uint32_t)a[j]) *
    21e0:	0013010b 	andseq	r0, r3, fp, lsl #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    21e4:	00050800 	andeq	r0, r5, r0, lsl #16
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    21e8:	0b3a0e03 	bleq	e859fc <_etext+0xe7e4e4>
    21ec:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    21f0:	2e090000 	cdpcs	0, 0, cr0, cr9, cr0, {0}

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    21f4:	03193f01 	tsteq	r9, #1, 30
    21f8:	3b0b3a0e 	blcc	2d0a38 <_etext+0x2c9520>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    21fc:	1119270b 	tstne	r9, fp, lsl #14
	c = (c >> 7) * 19;
    2200:	40061201 	andmi	r1, r6, r1, lsl #4

	for (i = 0; i < F25519_SIZE; i++) {
    2204:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
		c += r[i];
    2208:	00001301 	andeq	r1, r0, r1, lsl #6
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    220c:	0300050a 	movweq	r0, #1290	; 0x50a
		c += r[i];
		r[i] = c;
		c >>= 8;
    2210:	3b0b3a0e 	blcc	2d0a50 <_etext+0x2c9538>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2214:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    2218:	0b000018 	bleq	2280 <f25519_inv__distinct+0x64>
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    221c:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2220:	0b3a0e03 	bleq	e85a34 <_etext+0xe7e51c>
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    2224:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2228:	01111349 	tsteq	r1, r9, asr #6
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    222c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2230:	00194297 	mulseq	r9, r7, r2
    2234:	00050c00 	andeq	r0, r5, r0, lsl #24

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2238:	0b3a0e03 	bleq	e85a4c <_etext+0xe7e534>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    223c:	13490b3b 	movtne	r0, #39739	; 0x9b3b

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2240:	00001702 	andeq	r1, r0, r2, lsl #14
    2244:	31012e0d 	tstcc	r1, sp, lsl #28
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2248:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    224c:	97184006 	ldrls	r4, [r8, -r6]
    2250:	13011942 	movwne	r1, #6466	; 0x1942
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2254:	050e0000 	streq	r0, [lr, #-0]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2258:	02133100 	andseq	r3, r3, #0, 2
    225c:	0f000017 	svceq	0x00000017

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2260:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) *
    2264:	0b3a0e03 	bleq	e85a78 <_etext+0xe7e560>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2268:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    226c:	01111349 	tsteq	r1, r9, asr #6
    2270:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2274:	01194297 			; <UNDEFINED> instruction: 0x01194297
	c = (c >> 7) * 19;
    2278:	10000013 	andne	r0, r0, r3, lsl r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    227c:	0111010b 	tsteq	r1, fp, lsl #2
	c = (c >> 7) * 19;
    2280:	00000612 	andeq	r0, r0, r2, lsl r6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2284:	03003411 	movweq	r3, #1041	; 0x411
    2288:	3b0b3a0e 	blcc	2d0ac8 <_etext+0x2c95b0>
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    228c:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
		r[i] = c;
    2290:	12000018 	andne	r0, r0, #24
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2294:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
		c += r[i];
		r[i] = c;
		c >>= 8;
    2298:	0b3b0b3a 	bleq	ec4f88 <_etext+0xebda70>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    229c:	00001349 	andeq	r1, r0, r9, asr #6
    22a0:	31011d13 	tstcc	r1, r3, lsl sp
    22a4:	55015213 	strpl	r5, [r1, #-531]	; 0x213
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22a8:	590b5817 	stmdbpl	fp, {r0, r1, r2, r4, fp, ip, lr}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    22ac:	1400000b 	strne	r0, [r0], #-11
		for (j = 0; j <= i; j++)
    22b0:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22b4:	0b3a0e03 	bleq	e85ac8 <_etext+0xe7e5b0>
    22b8:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22bc:	06120111 			; <UNDEFINED> instruction: 0x06120111
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22c0:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22c4:	00130119 	andseq	r0, r3, r9, lsl r1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22c8:	00051500 	andeq	r1, r5, r0, lsl #10
    22cc:	0b3a0e03 	bleq	e85ae0 <_etext+0xe7e5c8>
    22d0:	1349053b 	movtne	r0, #38203	; 0x953b
    22d4:	00001702 	andeq	r1, r0, r2, lsl #14
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    22d8:	03003416 	movweq	r3, #1046	; 0x416
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22dc:	3b0b3a0e 	blcc	2d0b1c <_etext+0x2c9604>
    22e0:	02134905 	andseq	r4, r3, #81920	; 0x14000
    22e4:	17000017 	smladne	r0, r7, r0, r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22e8:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    22ec:	0b3a0e03 	bleq	e85b00 <_etext+0xe7e5e8>
    22f0:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    22f4:	01111349 	tsteq	r1, r9, asr #6
    22f8:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22fc:	01194297 			; <UNDEFINED> instruction: 0x01194297
	c = (c >> 7) * 19;
    2300:	18000013 	stmdane	r0, {r0, r1, r4}

	for (i = 0; i < F25519_SIZE; i++) {
    2304:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
		c += r[i];
    2308:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    230c:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
		c += r[i];
		r[i] = c;
		c >>= 8;
    2310:	0f190000 	svceq	0x00190000
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2314:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
    2318:	1a000013 	bne	236c <f25519_inv__distinct+0x150>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    231c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2320:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    2324:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2328:	0b1b0000 	bleq	6c2330 <_etext+0x6bae18>
		for (j = 0; j <= i; j++)
    232c:	00175501 	andseq	r5, r7, r1, lsl #10
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2330:	010b1c00 	tsteq	fp, r0, lsl #24
    2334:	06120111 			; <UNDEFINED> instruction: 0x06120111

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2338:	00001301 	andeq	r1, r0, r1, lsl #6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    233c:	0300051d 	movweq	r0, #1309	; 0x51d

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2340:	3b0b3a08 	blcc	2d0b68 <_etext+0x2c9650>
    2344:	02134905 	andseq	r4, r3, #81920	; 0x14000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2348:	1e000017 	mcrne	0, 0, r0, cr0, cr7, {0}
    234c:	08030005 	stmdaeq	r3, {r0, r2}
    2350:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    2354:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2358:	2e1f0000 	cdpcs	0, 1, cr0, cr15, cr0, {0}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    235c:	03193f01 	tsteq	r9, #1, 30
    2360:	3b0b3a0e 	blcc	2d0ba0 <_etext+0x2c9688>

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2364:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
			c += ((uint32_t)a[j]) *
    2368:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    236c:	97184006 	ldrls	r4, [r8, -r6]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2370:	00001942 	andeq	r1, r0, r2, asr #18
    2374:	01110100 	tsteq	r1, r0, lsl #2
    2378:	0b130e25 	bleq	4c5c14 <_etext+0x4be6fc>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    237c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
	c = (c >> 7) * 19;
    2380:	01111755 	tsteq	r1, r5, asr r7
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2384:	00001710 	andeq	r1, r0, r0, lsl r7
	c = (c >> 7) * 19;
    2388:	0b002402 	bleq	b398 <_etext+0x3e80>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    238c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
	c = (c >> 7) * 19;
    2390:	0300000e 	movweq	r0, #14

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2394:	08030016 	stmdaeq	r3, {r1, r2, r4}
		r[i] = c;
    2398:	0b3b0b3a 	bleq	ec5088 <_etext+0xebdb70>
		c >>= 8;
    239c:	00001349 	andeq	r1, r0, r9, asr #6
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23a0:	27001504 	strcs	r1, [r0, -r4, lsl #10]
    23a4:	05000019 	streq	r0, [r0, #-25]
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    23a8:	0b0b000f 	bleq	2c23ec <_etext+0x2baed4>
    23ac:	00001349 	andeq	r1, r0, r9, asr #6
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23b0:	3f012e06 	svccc	0x00012e06
    23b4:	3a0e0319 	bcc	383020 <_etext+0x37bb08>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23b8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23bc:	12011119 	andne	r1, r1, #1073741830	; 0x40000006

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23c0:	96184006 	ldrls	r4, [r8], -r6
    23c4:	13011942 	movwne	r1, #6466	; 0x1942
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23c8:	34070000 	strcc	r0, [r7], #-0
    23cc:	3a0e0300 	bcc	382fd4 <_etext+0x37babc>
    23d0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    23d4:	00170213 	andseq	r0, r7, r3, lsl r2
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    23d8:	010b0800 	tsteq	fp, r0, lsl #16
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    23dc:	06120111 			; <UNDEFINED> instruction: 0x06120111
    23e0:	00001301 	andeq	r1, r0, r1, lsl #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23e4:	01828909 	orreq	r8, r2, r9, lsl #18
			c += ((uint32_t)a[j]) *
    23e8:	31011100 	mrscc	r1, (UNDEF: 17)
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    23ec:	0a000013 	beq	2440 <f25519_inv__distinct+0x224>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    23f0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    23f4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    23f8:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    23fc:	0000193c 	andeq	r1, r0, ip, lsr r9
    2400:	4900350b 	stmdbmi	r0, {r0, r1, r3, r8, sl, ip, sp}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2404:	0c000013 	stceq	0, cr0, [r0], {19}
	c = (c >> 7) * 19;
    2408:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}

	for (i = 0; i < F25519_SIZE; i++) {
    240c:	0b3b0b3a 	bleq	ec50fc <_etext+0xebdbe4>
		c += r[i];
    2410:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2414:	00001802 	andeq	r1, r0, r2, lsl #16
		c += r[i];
		r[i] = c;
		c >>= 8;
    2418:	0300340d 	movweq	r3, #1037	; 0x40d
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    241c:	3b0b3a0e 	blcc	2d0c5c <_etext+0x2c9744>
	/* 1 1 */
	f25519_mul__distinct(s, x, x);
	f25519_mul__distinct(r, s, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    2420:	3f13490b 	svccc	0x0013490b
    2424:	00193c19 	andseq	r3, r9, r9, lsl ip
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2428:	01010e00 	tsteq	r1, r0, lsl #28
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    242c:	13011349 	movwne	r1, #4937	; 0x1349
    2430:	210f0000 	mrscs	r0, CPSR
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2434:	2f134900 	svccs	0x00134900
    2438:	1000000b 	andne	r0, r0, fp

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    243c:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2440:	0b3a0e03 	bleq	e85c54 <_etext+0xe7e73c>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2444:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    2448:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    244c:	01000000 	mrseq	r0, (UNDEF: 0)
    2450:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    2454:	0e030b13 	vmoveq.32	d3[0], r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2458:	17550e1b 	smmlane	r5, fp, lr, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    245c:	17100111 			; <UNDEFINED> instruction: 0x17100111
    2460:	24020000 	strcs	r0, [r2], #-0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2464:	3e0b0b00 	vmlacc.f64	d0, d11, d0
			c += ((uint32_t)a[j]) *
    2468:	000e030b 	andeq	r0, lr, fp, lsl #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    246c:	00160300 	andseq	r0, r6, r0, lsl #6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2470:	0b3a0803 	bleq	e84484 <_etext+0xe7cf6c>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2474:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2478:	0f040000 	svceq	0x00040000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    247c:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
	c = (c >> 7) * 19;
    2480:	05000013 	streq	r0, [r0, #-19]
    2484:	0e030104 	adfeqs	f0, f3, f4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2488:	0b3a0b0b 	bleq	e850bc <_etext+0xe7dba4>
	c = (c >> 7) * 19;
    248c:	13010b3b 	movwne	r0, #6971	; 0x1b3b
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2490:	28060000 	stmdacs	r6, {}	; <UNPREDICTABLE>
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2494:	1c0e0300 	stcne	3, cr0, [lr], {-0}
		r[i] = c;
    2498:	0700000d 	streq	r0, [r0, -sp]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    249c:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
		c += r[i];
		r[i] = c;
		c >>= 8;
    24a0:	0b3b0b3a 	bleq	ec5190 <_etext+0xebdc78>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24a4:	00001349 	andeq	r1, r0, r9, asr #6
    24a8:	03011308 	movweq	r1, #4872	; 0x1308
    24ac:	3a0b0b0e 	bcc	2c50ec <_etext+0x2bdbd4>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24b0:	010b3b0b 	tsteq	fp, fp, lsl #22
    24b4:	09000013 	stmdbeq	r0, {r0, r1, r4}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    24b8:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24bc:	0b3b0b3a 	bleq	ec51ac <_etext+0xebdc94>
    24c0:	0b381349 	bleq	e071ec <_etext+0xdffcd4>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24c4:	150a0000 	strne	r0, [sl, #-0]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24c8:	49192701 	ldmdbmi	r9, {r0, r8, r9, sl, sp}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24cc:	00130113 	andseq	r0, r3, r3, lsl r1
    24d0:	00050b00 	andeq	r0, r5, r0, lsl #22
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24d4:	00001349 	andeq	r1, r0, r9, asr #6
    24d8:	0301130c 	movweq	r1, #4876	; 0x130c
    24dc:	3a0b0b08 	bcc	2c5104 <_etext+0x2bdbec>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    24e0:	010b3b0b 	tsteq	fp, fp, lsl #22
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24e4:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
    24e8:	0803000d 	stmdaeq	r3, {r0, r2, r3}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24ec:	0b3b0b3a 	bleq	ec51dc <_etext+0xebdcc4>
			c += ((uint32_t)a[j]) *
    24f0:	0b381349 	bleq	e0721c <_etext+0xdffd04>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    24f4:	170e0000 	strne	r0, [lr, -r0]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    24f8:	3a0b0b01 	bcc	2c5104 <_etext+0x2bdbec>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    24fc:	010b3b0b 	tsteq	fp, fp, lsl #22
	c = (c >> 7) * 19;
    2500:	0f000013 	svceq	0x00000013
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2504:	0803000d 	stmdaeq	r3, {r0, r2, r3}
	c = (c >> 7) * 19;
    2508:	0b3b0b3a 	bleq	ec51f8 <_etext+0xebdce0>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    250c:	00001349 	andeq	r1, r0, r9, asr #6
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2510:	27001510 	smladcs	r0, r0, r5, r1
		r[i] = c;
    2514:	11000019 	tstne	r0, r9, lsl r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2518:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
		c += r[i];
		r[i] = c;
		c >>= 8;
    251c:	0b3a0e03 	bleq	e85d30 <_etext+0xe7e818>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2520:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2524:	06120111 			; <UNDEFINED> instruction: 0x06120111
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2528:	42961840 	addsmi	r1, r6, #64, 16	; 0x400000
		for (j = 0; j <= i; j++)
    252c:	12000019 	andne	r0, r0, #25
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2530:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    2534:	0b3b0b3a 	bleq	ec5224 <_etext+0xebdd0c>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2538:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    253c:	0000193c 	andeq	r1, r0, ip, lsr r9

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2540:	03003413 	movweq	r3, #1043	; 0x413
    2544:	3b0b3a0e 	blcc	2d0d84 <_etext+0x2c986c>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2548:	3f13490b 	svccc	0x0013490b
    254c:	00180219 	andseq	r0, r8, r9, lsl r2
    2550:	11010000 	mrsne	r0, (UNDEF: 1)
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2554:	130e2501 	movwne	r2, #58625	; 0xe501
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2558:	1b0e030b 	blne	38318c <_etext+0x37bc74>
    255c:	1117550e 	tstne	r7, lr, lsl #10

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2560:	00171001 	andseq	r1, r7, r1
			c += ((uint32_t)a[j]) *
    2564:	00240200 	eoreq	r0, r4, r0, lsl #4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2568:	0b3e0b0b 	bleq	f8519c <_etext+0xf7dc84>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    256c:	00000e03 	andeq	r0, r0, r3, lsl #28
    2570:	03001603 	movweq	r1, #1539	; 0x603
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2574:	3b0b3a08 	blcc	2d0d9c <_etext+0x2c9884>
	c = (c >> 7) * 19;
    2578:	0013490b 	andseq	r4, r3, fp, lsl #18
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    257c:	00160400 	andseq	r0, r6, r0, lsl #8
	c = (c >> 7) * 19;
    2580:	0b3a0e03 	bleq	e85d94 <_etext+0xe7e87c>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2584:	13490b3b 	movtne	r0, #39739	; 0x9b3b
	c = (c >> 7) * 19;
    2588:	35050000 	strcc	r0, [r5, #-0]

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    258c:	00134900 	andseq	r4, r3, r0, lsl #18
		r[i] = c;
    2590:	01040600 	tsteq	r4, r0, lsl #12
		c >>= 8;
    2594:	0b3a0b0b 	bleq	e851c8 <_etext+0xe7dcb0>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2598:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    259c:	28070000 	stmdacs	r7, {}	; <UNPREDICTABLE>
    25a0:	1c0e0300 	stcne	3, cr0, [lr], {-0}
    25a4:	0800000d 	stmdaeq	r0, {r0, r2, r3}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25a8:	0e030104 	adfeqs	f0, f3, f4
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    25ac:	0b3a0b0b 	bleq	e851e0 <_etext+0xe7dcc8>
		for (j = 0; j <= i; j++)
    25b0:	13010b3b 	movwne	r0, #6971	; 0x1b3b
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25b4:	13090000 	movwne	r0, #36864	; 0x9000
    25b8:	0b0e0301 	bleq	3831c4 <_etext+0x37bcac>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25bc:	3b0b3a0b 	blcc	2d0df0 <_etext+0x2c98d8>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25c0:	0013010b 	andseq	r0, r3, fp, lsl #2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25c4:	000d0a00 	andeq	r0, sp, r0, lsl #20
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25c8:	0b3a0e03 	bleq	e85ddc <_etext+0xe7e8c4>
    25cc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    25d0:	00000b38 	andeq	r0, r0, r8, lsr fp
    25d4:	0b000f0b 	bleq	6208 <Standard_GetDescriptorData+0x10>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    25d8:	0013490b 	andseq	r4, r3, fp, lsl #18
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25dc:	01150c00 	tsteq	r5, r0, lsl #24
    25e0:	13491927 	movtne	r1, #39207	; 0x9927
    25e4:	00001301 	andeq	r1, r0, r1, lsl #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25e8:	4900050d 	stmdbmi	r0, {r0, r2, r3, r8, sl}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    25ec:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
    25f0:	08030113 	stmdaeq	r3, {r0, r1, r4, r8}

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    25f4:	0b3a0b0b 	bleq	e85228 <_etext+0xe7dd10>
    25f8:	13010b3b 	movwne	r0, #6971	; 0x1b3b
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25fc:	0d0f0000 	stceq	0, cr0, [pc, #-0]	; 2604 <f25519_inv__distinct+0x3e8>
	c = (c >> 7) * 19;
    2600:	3a080300 	bcc	203208 <_etext+0x1fbcf0>

	for (i = 0; i < F25519_SIZE; i++) {
    2604:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
		c += r[i];
    2608:	000b3813 	andeq	r3, fp, r3, lsl r8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    260c:	01171000 	tsteq	r7, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    2610:	0b3a0b0b 	bleq	e85244 <_etext+0xe7dd2c>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2614:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    2618:	0d110000 	ldceq	0, cr0, [r1, #-0]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    261c:	3a080300 	bcc	203224 <_etext+0x1fbd0c>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2620:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2624:	12000013 	andne	r0, r0, #19
    2628:	19270015 	stmdbne	r7!, {r0, r2, r4}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    262c:	2e130000 	cdpcs	0, 1, cr0, cr3, cr0, {0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2630:	03193f01 	tsteq	r9, #1, 30

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2634:	3b0b3a0e 	blcc	2d0e74 <_etext+0x2c995c>
    2638:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    263c:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    2640:	96184006 	ldrls	r4, [r8], -r6
    2644:	13011942 	movwne	r1, #6466	; 0x1942
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2648:	05140000 	ldreq	r0, [r4, #-0]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    264c:	3a0e0300 	bcc	383254 <_etext+0x37bd3c>
    2650:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2654:	00170213 	andseq	r0, r7, r3, lsl r2
			c += ((uint32_t)a[j]) *
    2658:	010b1500 	tsteq	fp, r0, lsl #10

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    265c:	06120111 			; <UNDEFINED> instruction: 0x06120111
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2660:	00001301 	andeq	r1, r0, r1, lsl #6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2664:	03003416 	movweq	r3, #1046	; 0x416
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2668:	3b0b3a0e 	blcc	2d0ea8 <_etext+0x2c9990>
	c = (c >> 7) * 19;
    266c:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    2670:	17000017 	smladne	r0, r7, r0, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2674:	0111010b 	tsteq	r1, fp, lsl #2
	c = (c >> 7) * 19;
    2678:	00000612 	andeq	r0, r0, r2, lsl r6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    267c:	03003418 	movweq	r3, #1048	; 0x418
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2680:	3b0b3a0e 	blcc	2d0ec0 <_etext+0x2c99a8>
		r[i] = c;
    2684:	0013490b 	andseq	r4, r3, fp, lsl #18
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2688:	012e1900 	teqeq	lr, r0, lsl #18
		c += r[i];
		r[i] = c;
		c >>= 8;
    268c:	0b3a0e03 	bleq	e85ea0 <_etext+0xe7e988>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2690:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
    2694:	06120111 			; <UNDEFINED> instruction: 0x06120111
    2698:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    269c:	00130119 	andseq	r0, r3, r9, lsl r1
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    26a0:	00341a00 	eorseq	r1, r4, r0, lsl #20
		for (j = 0; j <= i; j++)
    26a4:	0b3a0e03 	bleq	e85eb8 <_etext+0xe7e9a0>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26a8:	1349053b 	movtne	r0, #38203	; 0x953b
    26ac:	00001702 	andeq	r1, r0, r2, lsl #14

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26b0:	03000a1b 	movweq	r0, #2587	; 0xa1b
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26b4:	3b0b3a0e 	blcc	2d0ef4 <_etext+0x2c99dc>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26b8:	00011105 	andeq	r1, r1, r5, lsl #2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26bc:	82891c00 	addhi	r1, r9, #0, 24
    26c0:	01110101 	tsteq	r1, r1, lsl #2
    26c4:	00001301 	andeq	r1, r0, r1, lsl #6
    26c8:	01828a1d 	orreq	r8, r2, sp, lsl sl
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    26cc:	91180200 	tstls	r8, r0, lsl #4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26d0:	00001842 	andeq	r1, r0, r2, asr #16
    26d4:	0182891e 	orreq	r8, r2, lr, lsl r9
    26d8:	31011101 	tstcc	r1, r1, lsl #2

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26dc:	00130113 	andseq	r0, r3, r3, lsl r1
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    26e0:	82891f00 	addhi	r1, r9, #0, 30
    26e4:	01110101 	tsteq	r1, r1, lsl #2

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    26e8:	00001331 	andeq	r1, r0, r1, lsr r3
    26ec:	3f002e20 	svccc	0x00002e20
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26f0:	3a0e0319 	bcc	38335c <_etext+0x37be44>
	c = (c >> 7) * 19;
    26f4:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]

	for (i = 0; i < F25519_SIZE; i++) {
    26f8:	11134919 	tstne	r3, r9, lsl r9
		c += r[i];
    26fc:	40061201 	andmi	r1, r6, r1, lsl #4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2700:	19429618 	stmdbne	r2, {r3, r4, r9, sl, ip, pc}^
		c += r[i];
		r[i] = c;
		c >>= 8;
    2704:	34210000 	strtcc	r0, [r1], #-0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2708:	3a080300 	bcc	203310 <_etext+0x1fbdf8>
    270c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2710:	00170213 	andseq	r0, r7, r3, lsl r2
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2714:	82892200 	addhi	r2, r9, #0, 4
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2718:	01110001 	tsteq	r1, r1
    271c:	00001331 	andeq	r1, r0, r1, lsr r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2720:	3f012e23 	svccc	0x00012e23
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2724:	3a0e0319 	bcc	383390 <_etext+0x37be78>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2728:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    272c:	11134919 	tstne	r3, r9, lsl r9
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2730:	40061201 	andmi	r1, r6, r1, lsl #4
    2734:	19429618 	stmdbne	r2, {r3, r4, r9, sl, ip, pc}^
    2738:	00001301 	andeq	r1, r0, r1, lsl #6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    273c:	03003424 	movweq	r3, #1060	; 0x424
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2740:	3b0b3a08 	blcc	2d0f68 <_etext+0x2c9a50>
    2744:	02134905 	andseq	r4, r3, #81920	; 0x14000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2748:	25000017 	strcs	r0, [r0, #-23]
			c += ((uint32_t)a[j]) *
    274c:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2750:	00001301 	andeq	r1, r0, r1, lsl #6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2754:	3f002e26 	svccc	0x00002e26
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2758:	3a0e0319 	bcc	3833c4 <_etext+0x37beac>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    275c:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
	c = (c >> 7) * 19;
    2760:	11134919 	tstne	r3, r9, lsl r9
    2764:	40061201 	andmi	r1, r6, r1, lsl #4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2768:	19429618 	stmdbne	r2, {r3, r4, r9, sl, ip, pc}^
	c = (c >> 7) * 19;
    276c:	2e270000 	cdpcs	0, 2, cr0, cr7, cr0, {0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2770:	03193f01 	tsteq	r9, #1, 30
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2774:	3b0b3a0e 	blcc	2d0fb4 <_etext+0x2c9a9c>
		r[i] = c;
    2778:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    277c:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
		c += r[i];
		r[i] = c;
		c >>= 8;
    2780:	97184006 	ldrls	r4, [r8, -r6]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2784:	13011942 	movwne	r1, #6466	; 0x1942
    2788:	05280000 	streq	r0, [r8, #-0]!
    278c:	3a0e0300 	bcc	383394 <_etext+0x37be7c>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2790:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2794:	00170213 	andseq	r0, r7, r3, lsl r2
		for (j = 0; j <= i; j++)
    2798:	012e2900 	teqeq	lr, r0, lsl #18
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    279c:	0b3a0e03 	bleq	e85fb0 <_etext+0xe7ea98>
    27a0:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27a4:	13010b20 	movwne	r0, #6944	; 0x1b20
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27a8:	342a0000 	strtcc	r0, [sl], #-0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27ac:	3a0e0300 	bcc	3833b4 <_etext+0x37be9c>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27b0:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    27b4:	2b000013 	blcs	2808 <f25519_sqrt>
    27b8:	0e03000a 	cdpeq	0, 0, cr0, cr3, cr10, {0}
    27bc:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    27c0:	0b2c0000 	bleq	b027c8 <_etext+0xafb2b0>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27c4:	00130101 	andseq	r0, r3, r1, lsl #2
    27c8:	010b2d00 	tsteq	fp, r0, lsl #26
    27cc:	172e0000 	strne	r0, [lr, -r0]!

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27d0:	3a0b0b01 	bcc	2c53dc <_etext+0x2bdec4>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    27d4:	01053b0b 	tsteq	r5, fp, lsl #22
    27d8:	2f000013 	svccs	0x00000013

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    27dc:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    27e0:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    27e4:	00001349 	andeq	r1, r0, r9, asr #6
	c = (c >> 7) * 19;
    27e8:	31011d30 	tstcc	r1, r0, lsr sp

	for (i = 0; i < F25519_SIZE; i++) {
    27ec:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
		c += r[i];
    27f0:	590b5806 	stmdbpl	fp, {r1, r2, fp, ip, lr}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27f4:	00130105 	andseq	r0, r3, r5, lsl #2
		c += r[i];
		r[i] = c;
		c >>= 8;
    27f8:	00343100 	eorseq	r3, r4, r0, lsl #2
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27fc:	17021331 	smladxne	r2, r1, r3, r1
	f25519_mul__distinct(r, s, x);

	/* 1 */
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}
    2800:	0a320000 	beq	c82808 <_etext+0xc7b2f0>
    2804:	11133100 	tstne	r3, r0, lsl #2
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    2808:	33000001 	movwcc	r0, #1
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    280c:	1331011d 	teqne	r1, #1073741831	; 0x40000007
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    2810:	17550152 			; <UNDEFINED> instruction: 0x17550152
	f25519_copy(r, tmp);
}

void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
    2814:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xb58
    2818:	00001301 	andeq	r1, r0, r1, lsl #6
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += b * ((uint32_t)a[i]);
    281c:	55010b34 	strpl	r0, [r1, #-2868]	; 0xb34
    2820:	35000017 	strcc	r0, [r0, #-23]
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2824:	13310034 	teqne	r1, #52	; 0x34
    2828:	00001802 	andeq	r1, r0, r2, lsl #16
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    282c:	01828936 	orreq	r8, r2, r6, lsr r9
    2830:	00011101 	andeq	r1, r1, r1, lsl #2
	c >>= 7;
	c *= 19;
    2834:	82893700 	addhi	r3, r9, #0, 14
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    2838:	01110001 	tsteq	r1, r1
	c >>= 7;
	c *= 19;
    283c:	31194295 			; <UNDEFINED> instruction: 0x31194295
    2840:	38000013 	stmdacc	r0, {r0, r1, r4}

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2844:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
		r[i] = c;
    2848:	0b3a0e03 	bleq	e8605c <_etext+0xe7eb44>

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    284c:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
		c += r[i];
		r[i] = c;
		c >>= 8;
    2850:	06120111 			; <UNDEFINED> instruction: 0x06120111

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2854:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
    2858:	00130119 	andseq	r0, r3, r9, lsl r1
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    285c:	00053900 	andeq	r3, r5, r0, lsl #18
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2860:	0b3a0803 	bleq	e84874 <_etext+0xe7d35c>
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2864:	1349053b 	movtne	r0, #38203	; 0x953b
    2868:	00001702 	andeq	r1, r0, r2, lsl #14

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    286c:	3f002e3a 	svccc	0x00002e3a
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2870:	3a0e0319 	bcc	3834dc <_etext+0x37bfc4>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2874:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    2878:	12011119 	andne	r1, r1, #1073741830	; 0x40000006
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    287c:	97184006 	ldrls	r4, [r8, -r6]
    2880:	00001942 	andeq	r1, r0, r2, asr #18
    2884:	0300343b 	movweq	r3, #1083	; 0x43b
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2888:	3b0b3a0e 	blcc	2d10c8 <_etext+0x2c9bb0>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    288c:	3f13490b 	svccc	0x0013490b
    2890:	00193c19 	andseq	r3, r9, r9, lsl ip
    2894:	00343c00 	eorseq	r3, r4, r0, lsl #24

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2898:	0b3a0e03 	bleq	e860ac <_etext+0xe7eb94>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    289c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28a0:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28a4:	2e3d0000 	cdpcs	0, 3, cr0, cr13, cr0, {0}
	c = (c >> 7) * 19;
    28a8:	03193f01 	tsteq	r9, #1, 30
    28ac:	3b0b3a0e 	blcc	2d10ec <_etext+0x2c9bd4>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28b0:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
	c = (c >> 7) * 19;
    28b4:	01193c13 	tsteq	r9, r3, lsl ip
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28b8:	3e000013 	mcrcc	0, 0, r0, cr0, cr3, {0}
	c = (c >> 7) * 19;
    28bc:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    28c0:	0b3a0e03 	bleq	e860d4 <_etext+0xe7ebbc>
		r[i] = c;
    28c4:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
		c >>= 8;
    28c8:	1301193c 	movwne	r1, #6460	; 0x193c
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28cc:	2e3f0000 	cdpcs	0, 3, cr0, cr15, cr0, {0}
    28d0:	03193f01 	tsteq	r9, #1, 30
    28d4:	3b0b3a0e 	blcc	2d1114 <_etext+0x2c9bfc>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    28d8:	3c192705 	ldccc	7, cr2, [r9], {5}
		for (j = 0; j <= i; j++)
    28dc:	00130119 	andseq	r0, r3, r9, lsl r1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    28e0:	012e4000 	teqeq	lr, r0
    28e4:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    28e8:	0b3b0b3a 	bleq	ec55d8 <_etext+0xebe0c0>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    28ec:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    28f0:	01000000 	mrseq	r0, (UNDEF: 0)

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    28f4:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    28f8:	0e030b13 	vmoveq.32	d3[0], r0
    28fc:	17550e1b 	smmlane	r5, fp, lr, r0
    2900:	17100111 			; <UNDEFINED> instruction: 0x17100111
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2904:	24020000 	strcs	r0, [r2], #-0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2908:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    290c:	000e030b 	andeq	r0, lr, fp, lsl #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2910:	00160300 	andseq	r0, r6, r0, lsl #6
			c += ((uint32_t)a[j]) *
    2914:	0b3a0803 	bleq	e84928 <_etext+0xe7d410>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2918:	13490b3b 	movtne	r0, #39739	; 0x9b3b
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    291c:	0f040000 	svceq	0x00040000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2920:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
	c = (c >> 7) * 19;
    2924:	05000013 	streq	r0, [r0, #-19]
    2928:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    292c:	0b3a0e03 	bleq	e86140 <_etext+0xe7ec28>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2930:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
	c = (c >> 7) * 19;
    2934:	06120111 			; <UNDEFINED> instruction: 0x06120111
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2938:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
    293c:	00130119 	andseq	r0, r3, r9, lsl r1
	c = (c >> 7) * 19;
    2940:	00050600 	andeq	r0, r5, r0, lsl #12

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2944:	0b3a0e03 	bleq	e86158 <_etext+0xe7ec40>
		r[i] = c;
    2948:	13490b3b 	movtne	r0, #39739	; 0x9b3b
		c >>= 8;
    294c:	00001702 	andeq	r1, r0, r2, lsl #14
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2950:	03003407 	movweq	r3, #1031	; 0x407
    2954:	3b0b3a08 	blcc	2d117c <_etext+0x2c9c64>
    2958:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    295c:	08000018 	stmdaeq	r0, {r3, r4}

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2960:	08030034 	stmdaeq	r3, {r2, r4, r5}
    2964:	0b3b0b3a 	bleq	ec5654 <_etext+0xebe13c>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2968:	17021349 	strne	r1, [r2, -r9, asr #6]
		for (j = 0; j <= i; j++)
    296c:	34090000 	strcc	r0, [r9], #-0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2970:	3a0e0300 	bcc	383578 <_etext+0x37c060>
    2974:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2978:	00170213 	andseq	r0, r7, r3, lsl r2
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	00000071 	andeq	r0, r0, r1, ror r0
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
       4:	00310002 	eorseq	r0, r1, r2
       8:	01020000 	mrseq	r0, (UNDEF: 2)
       c:	000d0efb 	strdeq	r0, [sp], -fp
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
      10:	01010101 	tsteq	r1, r1, lsl #2
      14:	01000000 	mrseq	r0, (UNDEF: 0)
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
      18:	73010000 	movwvc	r0, #4096	; 0x1000
      1c:	32336d74 	eorscc	r6, r3, #116, 26	; 0x1d00
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
      20:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
      24:	5f630000 	svcpl	0x00630000
      28:	796c6e6f 	stmdbvc	ip!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    if ((wEPVal & EP_CTR_RX) != 0)
      2c:	6174735f 	cmnvs	r4, pc, asr r3
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
      30:	70757472 	rsbsvc	r7, r5, r2, ror r4
      34:	0100732e 	tsteq	r0, lr, lsr #6
      38:	00000000 	andeq	r0, r0, r0

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
      3c:	0b4c0205 	bleq	1300858 <_etext+0x12f9340>

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
      40:	c1030000 	mrsgt	r0, (UNDEF: 3)
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
      44:	31210100 	teqcc	r1, r0, lsl #2
      48:	23212121 	teqcs	r1, #1073741832	; 0x40000008
      4c:	21212121 	teqcs	r1, r1, lsr #2

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
      50:	2131212f 	teqcs	r1, pc, lsr #2
      54:	30212131 	eorcc	r2, r1, r1, lsr r1
      58:	2068032f 	rsbcs	r0, r8, pc, lsr #6
      5c:	36322f34 	shasxcc	r2, r2, r4
      60:	01000202 	tsteq	r0, r2, lsl #4
      64:	02050001 	andeq	r0, r5, #1
      68:	00000b94 	muleq	r0, r4, fp
      6c:	0100eb03 	tsteq	r0, r3, lsl #22
      70:	01000202 	tsteq	r0, r2, lsl #4
      74:	0000a201 	andeq	sl, r0, r1, lsl #4
      78:	33000200 	movwcc	r0, #512	; 0x200
      7c:	02000000 	andeq	r0, r0, #0
      80:	0d0efb01 	vstreq	d15, [lr, #-4]
      84:	01010100 	mrseq	r0, (UNDEF: 17)
      88:	00000001 	andeq	r0, r0, r1
      8c:	01000001 	tsteq	r0, r1
      90:	74732f2e 	ldrbtvc	r2, [r3], #-3886	; 0xf2e
      94:	5f32336d 	svcpl	0x0032336d
      98:	0062696c 	rsbeq	r6, r2, ip, ror #18
      9c:	726f6300 	rsbvc	r6, pc, #0, 6
      a0:	6d786574 	cfldr64vs	mvdx6, [r8, #-464]!	; 0xfffffe30
      a4:	616d5f33 	cmnvs	sp, r3, lsr pc
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
      a8:	2e6f7263 	cdpcs	2, 6, cr7, cr15, cr3, {3}

	return f25519_eq(a, c);
      ac:	00010053 	andeq	r0, r1, r3, asr r0
      b0:	05000000 	streq	r0, [r0, #-0]
      b4:	00000002 	andeq	r0, r0, r2
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
      b8:	01370300 	teqeq	r7, r0, lsl #6
	f25519_normalize(ey);
      bc:	200b0321 	andcs	r0, fp, r1, lsr #6
      c0:	200b0321 	andcs	r0, fp, r1, lsr #6

	return ok;
}
      c4:	200b0321 	andcs	r0, fp, r1, lsr #6
      c8:	200b032f 	andcs	r0, fp, pc, lsr #6
      cc:	200b032f 	andcs	r0, fp, pc, lsr #6
      d0:	200b032f 	andcs	r0, fp, pc, lsr #6
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
      d4:	200b0321 	andcs	r0, fp, r1, lsr #6
      d8:	200b032f 	andcs	r0, fp, pc, lsr #6
		minusp[i] = c;
      dc:	0a032f2f 	beq	cbda0 <_etext+0xc4888>
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
      e0:	0b032f20 	bleq	cbd68 <_etext+0xc4850>
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
      e4:	0b032f20 	bleq	cbd6c <_etext+0xc4854>

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
      e8:	0b032f20 	bleq	cbd70 <_etext+0xc4858>
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
      ec:	0b032f20 	bleq	cbd74 <_etext+0xc485c>
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
      f0:	0b032120 	bleq	c8578 <_etext+0xc1060>
      f4:	0b032120 	bleq	c857c <_etext+0xc1064>
      f8:	0b032f20 	bleq	cbd80 <_etext+0xc4868>
      fc:	0b032120 	bleq	c8584 <_etext+0xc106c>
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     100:	0b032120 	bleq	c8588 <_etext+0xc1070>

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
     104:	0b032f20 	bleq	cbd8c <_etext+0xc4874>
     108:	0b032f20 	bleq	cbd90 <_etext+0xc4878>
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     10c:	0a032f20 	beq	cbd94 <_etext+0xc487c>
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
     110:	0b032120 	bleq	c8598 <_etext+0xc1080>
     114:	01022120 	tsteq	r2, r0, lsr #2
     118:	a7010100 	strge	r0, [r1, -r0, lsl #2]
     11c:	02000003 	andeq	r0, r0, #3
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     120:	0000be00 	andeq	fp, r0, r0, lsl #28
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
     124:	fb010200 	blx	4092e <_etext+0x39416>
     128:	01000d0e 	tsteq	r0, lr, lsl #26
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
     12c:	00010101 	andeq	r0, r1, r1, lsl #2

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
     130:	00010000 	andeq	r0, r1, r0
	i <<= 3;

	while (x) {
     134:	2f2e0100 	svccs	0x002e0100
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
     138:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
     13c:	696c5f32 	stmdbvs	ip!, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
     140:	2f2e0062 	svccs	0x002e0062
	f25519_mul_c(z3, x1sq, 4);
     144:	5f627375 	svcpl	0x00627375
     148:	0062696c 	rsbeq	r6, r2, ip, ror #18
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	62737500 	rsbsvs	r7, r3, #0, 10
     150:	0000632e 	andeq	r6, r0, lr, lsr #6
     154:	74730000 	ldrbtvc	r0, [r3], #-0
	f25519_sub(b, x3, z3); /* D */
     158:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
     15c:	5f783031 	svcpl	0x00783031
	f25519_mul__distinct(da, a, b);
     160:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0x974
     164:	0100682e 	tsteq	r0, lr, lsr #16
     168:	61680000 	cmnvs	r8, r0

	f25519_sub(b, x2, z2);
     16c:	61776472 	cmnvs	r7, r2, ror r4
     170:	682e6572 	stmdavs	lr!, {r1, r4, r5, r6, r8, sl, sp, lr}
	f25519_add(a, x3, z3); /* C */
     174:	00000000 	andeq	r0, r0, r0
     178:	5f627375 	svcpl	0x00627375
     17c:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xf63
	f25519_mul__distinct(cb, a, b);
     180:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
     184:	73750000 	cmnvc	r5, #0

	f25519_add(a, da, cb);
     188:	65645f62 	strbvs	r5, [r4, #-3938]!	; 0xf62
     18c:	00682e66 	rsbeq	r2, r8, r6, ror #28
     190:	75000002 	strvc	r0, [r0, #-2]
	f25519_mul__distinct(b, a, a);
     194:	682e6273 	stmdavs	lr!, {r0, r1, r4, r5, r6, r9, sp, lr}
     198:	00000000 	andeq	r0, r0, r0
	f25519_mul__distinct(x5, z1, b);
     19c:	5f627375 	svcpl	0x00627375
     1a0:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
     1a4:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000

	f25519_sub(a, da, cb);
     1a8:	73750000 	cmnvc	r5, #0
     1ac:	65645f62 	strbvs	r5, [r4, #-3938]!	; 0xf62
	f25519_mul__distinct(b, a, a);
     1b0:	69726373 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, r8, r9, sp, lr}^
     1b4:	726f7470 	rsbvc	r7, pc, #112, 8	; 0x70000000
     1b8:	0000682e 	andeq	r6, r0, lr, lsr #16

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	66640000 	strbtvs	r0, [r4], -r0
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	00682e75 	rsbeq	r2, r8, r5, ror lr
     1c4:	75000000 	strvc	r0, [r0, #-0]

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1c8:	725f6273 	subsvc	r6, pc, #805306375	; 0x30000007
     1cc:	2e736765 	cdpcs	7, 7, cr6, cr3, cr5, {3}
     1d0:	00020068 	andeq	r0, r2, r8, rrx
     1d4:	62737500 	rsbsvs	r7, r3, #0, 10
		f25519_select(zm1, zm1, zm, bit);
     1d8:	746e695f 	strbtvc	r6, [lr], #-2399	; 0x95f
     1dc:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
     1e0:	00000000 	andeq	r0, r0, r0
		f25519_select(xm, xm, xms, bit);
     1e4:	0b980205 	bleq	fe600a00 <BootRAM+0xd5711a1>
     1e8:	a7030000 	strge	r0, [r3, -r0]
     1ec:	01020101 	tsteq	r2, r1, lsl #2
		f25519_select(zm, zm, zms, bit);
     1f0:	00010100 	andeq	r0, r1, r0, lsl #2
     1f4:	0b9a0205 	bleq	fe680a10 <BootRAM+0xd5f11b1>
     1f8:	d7030000 	strle	r0, [r3, -r0]
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fc:	01020102 	tsteq	r2, r2, lsl #2
     200:	00010100 	andeq	r0, r1, r0, lsl #2
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     204:	0b9c0205 	bleq	fe700a20 <BootRAM+0xd6711c1>
     208:	dc030000 	stcle	0, cr0, [r3], {-0}
	f25519_mul__distinct(result, zm1, xm);
     20c:	01020102 	tsteq	r2, r2, lsl #2
     210:	00010100 	andeq	r0, r1, r0, lsl #2
	f25519_normalize(result);
     214:	0b9e0205 	bleq	fe780a30 <BootRAM+0xd6f11d1>
     218:	93030000 	movwls	r0, #12288	; 0x3000
}
     21c:	24150103 	ldrcs	r0, [r5], #-259	; 0x103
     220:	01000402 	tsteq	r0, r2, lsl #8
     224:	02050001 	andeq	r0, r5, #1
     228:	00000ba8 	andeq	r0, r0, r8, lsr #23
     22c:	0103bf03 	tsteq	r3, r3, lsl #30
     230:	01000102 	tsteq	r0, r2, lsl #2
     234:	02050001 	andeq	r0, r5, #1
     238:	00000bac 	andeq	r0, r0, ip, lsr #23
     23c:	0103c403 	tsteq	r3, r3, lsl #8
     240:	08024b13 	stmdaeq	r2, {r0, r1, r4, r8, r9, fp, lr}
     244:	00010100 	andeq	r0, r1, r0, lsl #2
     248:	0bc40205 	bleq	ff100a64 <BootRAM+0xe071205>
     24c:	cb030000 	blgt	c0254 <_etext+0xb8d3c>
     250:	01020103 	tsteq	r2, r3, lsl #2
     254:	00010100 	andeq	r0, r1, r0, lsl #2
     258:	0bc60205 	bleq	ff180a74 <BootRAM+0xe0f1215>
     25c:	d0030000 	andle	r0, r3, r0
     260:	01020103 	tsteq	r2, r3, lsl #2
     264:	00010100 	andeq	r0, r1, r0, lsl #2
     268:	0bc80205 	bleq	ff200a84 <BootRAM+0xe171225>
     26c:	d5030000 	strle	r0, [r3, #-0]
     270:	01020103 	tsteq	r2, r3, lsl #2
     274:	00010100 	andeq	r0, r1, r0, lsl #2
     278:	0bca0205 	bleq	ff280a94 <BootRAM+0xe1f1235>
     27c:	da030000 	ble	c0284 <_etext+0xb8d6c>
     280:	01020103 	tsteq	r2, r3, lsl #2
     284:	00010100 	andeq	r0, r1, r0, lsl #2
     288:	0bcc0205 	bleq	ff300aa4 <BootRAM+0xe271245>
     28c:	df030000 	svcle	0x00030000
     290:	01020103 	tsteq	r2, r3, lsl #2
     294:	00010100 	andeq	r0, r1, r0, lsl #2
     298:	0bce0205 	bleq	ff380ab4 <BootRAM+0xe2f1255>
     29c:	e4030000 	str	r0, [r3], #-0
     2a0:	01020103 	tsteq	r2, r3, lsl #2
     2a4:	00010100 	andeq	r0, r1, r0, lsl #2
     2a8:	0bd00205 	bleq	ff400ac4 <BootRAM+0xe371265>
     2ac:	e9030000 	stmdb	r3, {}	; <UNPREDICTABLE>
     2b0:	02130103 	andseq	r0, r3, #-1073741824	; 0xc0000000
     2b4:	01010006 	tsteq	r1, r6
     2b8:	dc020500 	cfstr32le	mvfx0, [r2], {-0}
     2bc:	0300000b 	movweq	r0, #11
     2c0:	210102bd 			; <UNDEFINED> instruction: 0x210102bd
     2c4:	2f1f2130 	svccs	0x001f2130
     2c8:	0b03211f 	bleq	c874c <_etext+0xc1234>
     2cc:	20750320 	rsbscs	r0, r5, r0, lsr #6
     2d0:	231d2322 	tstcs	sp, #-2013265920	; 0x88000000
     2d4:	92759291 	rsbsls	r9, r5, #268435465	; 0x10000009
     2d8:	2f3e7630 	svccs	0x003e7630
     2dc:	08212c21 	stmdaeq	r1!, {r0, r5, sl, fp, sp}
     2e0:	00010100 	andeq	r0, r1, r0, lsl #2
     2e4:	0c840205 	sfmeq	f0, 4, [r4], {5}
     2e8:	e0030000 	and	r0, r3, r0
     2ec:	1b250102 	blne	9406fc <_etext+0x9391e4>
     2f0:	8a3e7525 	bhi	f9d78c <_etext+0xf96274>
     2f4:	03212221 	teqeq	r1, #268435458	; 0x10000002
     2f8:	03312076 	teqeq	r1, #118	; 0x76
     2fc:	21212010 	teqcs	r1, r0, lsl r0
     300:	2221211e 	eorcs	r2, r1, #-2147483641	; 0x80000007
     304:	0b022131 	bleq	887d0 <_etext+0x812b8>
     308:	00010100 	andeq	r0, r1, r0, lsl #2
     30c:	0ce40205 	sfmeq	f0, 2, [r4], #20
     310:	9d030000 	stcls	0, cr0, [r3, #-0]
     314:	02130103 	andseq	r0, r3, #-1073741824	; 0xc0000000
     318:	01010006 	tsteq	r1, r6
     31c:	f0020500 			; <UNDEFINED> instruction: 0xf0020500
     320:	0300000c 	movweq	r0, #12
     324:	130103a2 	movwne	r0, #5026	; 0x13a2
     328:	01000602 	tsteq	r0, r2, lsl #12
     32c:	02050001 	andeq	r0, r5, #1
     330:	00000cfc 	strdeq	r0, [r0], -ip
     334:	0103a703 	tsteq	r3, r3, lsl #14
     338:	5a313d13 	bpl	c4f78c <_etext+0xc48274>
     33c:	01000602 	tsteq	r0, r2, lsl #12
     340:	02050001 	andeq	r0, r5, #1
     344:	00000d1c 	andeq	r0, r0, ip, lsl sp
     348:	0103b103 	tsteq	r3, r3, lsl #2
     34c:	00060213 	andeq	r0, r6, r3, lsl r2
     350:	05000101 	streq	r0, [r0, #-257]	; 0x101
     354:	000d2802 	andeq	r2, sp, r2, lsl #16
     358:	03880300 	orreq	r0, r8, #0, 6
     35c:	3d762101 	ldfcce	f2, [r6, #-4]!
     360:	0402214d 	streq	r2, [r2], #-333	; 0x14d
     364:	00010100 	andeq	r0, r1, r0, lsl #2
     368:	0d500205 	lfmeq	f0, 2, [r0, #-20]	; 0xffffffec
     36c:	ec030000 	stc	0, cr0, [r3], {-0}
     370:	18030100 	stmdane	r3, {r8}
     374:	2f1f3d20 	svccs	0x001f3d20
     378:	0402008a 	streq	r0, [r2], #-138	; 0x8a
     37c:	062e0602 	strteq	r0, [lr], -r2, lsl #12
     380:	211f3d6d 	tstcs	pc, sp, ror #26
     384:	302f2d21 	eorcc	r2, pc, r1, lsr #26
     388:	2016032f 	andscs	r0, r6, pc, lsr #6
     38c:	022e6d03 	eoreq	r6, lr, #3, 26	; 0xc0
     390:	0101000c 	tsteq	r1, ip
     394:	00020500 	andeq	r0, r2, r0, lsl #10
     398:	03000000 	movweq	r0, #0
     39c:	140101ad 	strne	r0, [r1], #-429	; 0x1ad
     3a0:	01000202 	tsteq	r0, r2, lsl #4
     3a4:	02050001 	andeq	r0, r5, #1
     3a8:	00000db8 			; <UNDEFINED> instruction: 0x00000db8
     3ac:	0101b303 	tsteq	r1, r3, lsl #6
     3b0:	023f3e14 	eorseq	r3, pc, #20, 28	; 0x140
     3b4:	01010008 	tsteq	r1, r8
     3b8:	d4020500 	strle	r0, [r2], #-1280	; 0x500
     3bc:	0300000d 	movweq	r0, #13
     3c0:	160101be 			; <UNDEFINED> instruction: 0x160101be
     3c4:	31222c22 	teqcc	r2, r2, lsr #24
     3c8:	01000602 	tsteq	r0, r2, lsl #12
     3cc:	02050001 	andeq	r0, r5, #1
     3d0:	00000dec 	andeq	r0, r0, ip, ror #27
     3d4:	0101cb03 	tsteq	r1, r3, lsl #22
     3d8:	84302131 	ldrthi	r2, [r0], #-305	; 0x131
     3dc:	2f312f40 	svccs	0x00312f40
     3e0:	312f4b31 	teqcc	pc, r1, lsr fp	; <UNPREDICTABLE>
     3e4:	2f2f3d3e 	svccs	0x002f3d3e
     3e8:	222f4b22 	eorcs	r4, pc, #34816	; 0x8800
     3ec:	502f222c 	eorpl	r2, pc, ip, lsr #4
     3f0:	01000702 	tsteq	r0, r2, lsl #14
     3f4:	02050001 	andeq	r0, r5, #1
     3f8:	00000e70 	andeq	r0, r0, r0, ror lr
     3fc:	0101fc03 	tsteq	r1, r3, lsl #24
     400:	24221e14 	strtcs	r1, [r2], #-3604	; 0xe14
     404:	1f4b3e1c 	svcne	0x004b3e1c
     408:	21211c24 	teqcs	r1, r4, lsr #24
     40c:	4f273d22 	svcmi	0x00273d22
     410:	01000b02 	tsteq	r0, r2, lsl #22
     414:	02050001 	andeq	r0, r5, #1
     418:	00000eb8 			; <UNDEFINED> instruction: 0x00000eb8
     41c:	01029303 	tsteq	r2, r3, lsl #6
     420:	21212d13 	teqcs	r1, r3, lsl sp
     424:	2e0c033d 	mcrcs	3, 0, r0, cr12, cr13, {1}
     428:	4d1d235d 	ldcmi	3, cr2, [sp, #-372]	; 0xfffffe8c
     42c:	01000a02 	tsteq	r0, r2, lsl #20
     430:	02050001 	andeq	r0, r5, #1
     434:	00000ef4 	strdeq	r0, [r0], -r4
     438:	0101a003 	tsteq	r1, r3
     43c:	00020213 	andeq	r0, r2, r3, lsl r2
     440:	05000101 	streq	r0, [r0, #-257]	; 0x101
     444:	000ef802 	andeq	pc, lr, r2, lsl #16
     448:	03f00300 	mvnseq	r0, #0, 6
     44c:	3d3d2301 	ldccc	3, cr2, [sp, #-4]!
     450:	2f3d1f30 	svccs	0x003d1f30
     454:	01000302 	tsteq	r0, r2, lsl #6
     458:	02050001 	andeq	r0, r5, #1
     45c:	00000f1c 	andeq	r0, r0, ip, lsl pc
     460:	0102ad03 	tsteq	r2, r3, lsl #26
     464:	304b3021 	subcc	r3, fp, r1, lsr #32
     468:	3d211f21 	stccc	15, cr1, [r1, #-132]!	; 0xffffff7c
     46c:	0d022f31 	stceq	15, cr2, [r2, #-196]	; 0xffffff3c
     470:	00010100 	andeq	r0, r1, r0, lsl #2
     474:	0f5c0205 	svceq	0x005c0205
     478:	fb030000 	blx	c0482 <_etext+0xb8f6a>
     47c:	40220103 	eormi	r0, r2, r3, lsl #2
     480:	2f2f3d1d 	svccs	0x002f3d1d
     484:	0003022f 	andeq	r0, r3, pc, lsr #4
     488:	05000101 	streq	r0, [r0, #-257]	; 0x101
     48c:	000f8002 	andeq	r8, pc, r2
     490:	04850300 	streq	r0, [r5], #768	; 0x300
     494:	1b412101 	blne	10488a0 <_etext+0x1041388>
     498:	59335b33 	ldmdbpl	r3!, {r0, r1, r4, r5, r8, r9, fp, ip, lr}
     49c:	3c0d033d 	stccc	3, cr0, [sp], {61}	; 0x3d
     4a0:	3d4b504b 	stclcc	0, cr5, [fp, #-300]	; 0xfffffed4
     4a4:	42345c42 	eorsmi	r5, r4, #16896	; 0x4200
     4a8:	4b5e3d59 	blmi	178fa14 <_etext+0x17884fc>
     4ac:	022a243f 	eoreq	r2, sl, #1056964608	; 0x3f000000
     4b0:	0101000e 	tsteq	r1, lr
     4b4:	00020500 	andeq	r0, r2, r0, lsl #10
     4b8:	03000000 	movweq	r0, #0
     4bc:	130104d5 	movwne	r0, #5333	; 0x14d5
     4c0:	0004022f 	andeq	r0, r4, pc, lsr #4
     4c4:	006e0101 	rsbeq	r0, lr, r1, lsl #2
     4c8:	00020000 	andeq	r0, r2, r0
     4cc:	00000068 	andeq	r0, r0, r8, rrx
     4d0:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
     4d4:	0101000d 	tsteq	r1, sp
     4d8:	00000101 	andeq	r0, r0, r1, lsl #2
     4dc:	00000100 	andeq	r0, r0, r0, lsl #2
     4e0:	732f2e01 	teqvc	pc, #1, 28
     4e4:	32336d74 	eorscc	r6, r3, #116, 26	; 0x1d00
     4e8:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
     4ec:	752f2e00 	strvc	r2, [pc, #-3584]!	; fffff6f4 <BootRAM+0xef6fe95>
     4f0:	6c5f6273 	lfmvs	f6, 2, [pc], {115}	; 0x73
     4f4:	00006269 	andeq	r6, r0, r9, ror #4
     4f8:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
     4fc:	30316632 	eorscc	r6, r1, r2, lsr r6
     500:	79745f78 	ldmdbvc	r4!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
     504:	682e6570 	stmdavs	lr!, {r4, r5, r6, r8, sl, sp, lr}
     508:	00000100 	andeq	r0, r0, r0, lsl #2
     50c:	5f627375 	svcpl	0x00627375
     510:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xf63
     514:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
     518:	73750000 	cmnvc	r5, #0
     51c:	00682e62 	rsbeq	r2, r8, r2, ror #28
     520:	75000000 	strvc	r0, [r0, #-0]
     524:	645f6273 	ldrbvs	r6, [pc], #-627	; 52c <RCC_ITConfig+0x4>
     528:	72637365 	rsbvc	r7, r3, #-1811939327	; 0x94000001
     52c:	6f747069 	svcvs	0x00747069
     530:	00632e72 	rsbeq	r2, r3, r2, ror lr
     534:	00000000 	andeq	r0, r0, r0
     538:	000001ea 	andeq	r0, r0, sl, ror #3
     53c:	01970002 	orrseq	r0, r7, r2
     540:	01020000 	mrseq	r0, (UNDEF: 2)
     544:	000d0efb 	strdeq	r0, [sp], -fp
     548:	01010101 	tsteq	r1, r1, lsl #2
     54c:	01000000 	mrseq	r0, (UNDEF: 0)
     550:	63010000 	movwvs	r0, #4096	; 0x1000
     554:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
     558:	6172676f 	cmnvs	r2, pc, ror #14
     55c:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
     560:	2073656c 	rsbscs	r6, r3, ip, ror #10
     564:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
     568:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
     56c:	6f742075 	svcvs	0x00742075
     570:	20736c6f 	rsbscs	r6, r3, pc, ror #24
     574:	206d7261 	rsbcs	r7, sp, r1, ror #4
     578:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
     57c:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
     580:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
     584:	31303220 	teqcc	r0, r0, lsr #4
     588:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
     58c:	5c62696c 	stclpl	9, cr6, [r2], #-432	; 0xfffffe50
     590:	5c636367 	stclpl	3, cr6, [r3], #-412	; 0xfffffe64
     594:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     598:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
     59c:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     5a0:	2e345c69 	cdpcs	12, 3, cr5, cr4, cr9, {3}
     5a4:	5c342e38 	ldcpl	14, cr2, [r4], #-224	; 0xffffff20
     5a8:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
     5ac:	00656475 	rsbeq	r6, r5, r5, ror r4
     5b0:	705c3a63 	subsvc	r3, ip, r3, ror #20
     5b4:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
     5b8:	66206d61 	strtvs	r6, [r0], -r1, ror #26
     5bc:	73656c69 	cmnvc	r5, #26880	; 0x6900
     5c0:	38782820 	ldmdacc	r8!, {r5, fp, sp}^
     5c4:	675c2936 	smmlarvs	ip, r6, r9, r2
     5c8:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
     5cc:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
     5d0:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80
     5d4:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000
     5d8:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
     5dc:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}
     5e0:	30322038 	eorscc	r2, r2, r8, lsr r0
     5e4:	33713431 	cmncc	r1, #822083584	; 0x31000000
     5e8:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
     5ec:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     5f0:	61652d65 	cmnvs	r5, r5, ror #26
     5f4:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^
     5f8:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
     5fc:	6d5c6564 	cfldr64vs	mvdx6, [ip, #-400]	; 0xfffffe70
     600:	69686361 	stmdbvs	r8!, {r0, r5, r6, r8, r9, sp, lr}^
     604:	6300656e 	movwvs	r6, #1390	; 0x56e
     608:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
     60c:	6172676f 	cmnvs	r2, pc, ror #14
     610:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
     614:	2073656c 	rsbscs	r6, r3, ip, ror #10
     618:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
     61c:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
     620:	6f742075 	svcvs	0x00742075
     624:	20736c6f 	rsbscs	r6, r3, pc, ror #24
     628:	206d7261 	rsbcs	r7, sp, r1, ror #4
     62c:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
     630:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
     634:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
     638:	31303220 	teqcc	r0, r0, lsr #4
     63c:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
     640:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     644:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
     648:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     64c:	6e695c69 	cdpvs	12, 6, cr5, cr9, cr9, {3}
     650:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
     654:	2f2e0065 	svccs	0x002e0065
     658:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
     65c:	696c5f32 	stmdbvs	ip!, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
     660:	6d000062 	stcvs	0, cr0, [r0, #-392]	; 0xfffffe78
     664:	2e6e6961 	cdpcs	9, 6, cr6, cr14, cr1, {3}
     668:	00000063 	andeq	r0, r0, r3, rrx
     66c:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
     670:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
     674:	00010068 	andeq	r0, r1, r8, rrx
     678:	65645f00 	strbvs	r5, [r4, #-3840]!	; 0xf00
     67c:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
     680:	79745f74 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
     684:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
     688:	00020068 	andeq	r0, r2, r8, rrx
     68c:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
     690:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
     694:	00030068 	andeq	r0, r3, r8, rrx
     698:	6d747300 	ldclvs	3, cr7, [r4, #-0]
     69c:	31663233 	cmncc	r6, r3, lsr r2
     6a0:	745f7830 	ldrbvc	r7, [pc], #-2096	; 6a8 <RCC_APB1PeriphResetCmd+0x10>
     6a4:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
     6a8:	00040068 	andeq	r0, r4, r8, rrx
     6ac:	616d6900 	cmnvs	sp, r0, lsl #18
     6b0:	682e6567 	stmdavs	lr!, {r0, r1, r2, r5, r6, r8, sl, sp, lr}
     6b4:	00000000 	andeq	r0, r0, r0
     6b8:	64726168 	ldrbtvs	r6, [r2], #-360	; 0x168
     6bc:	65726177 	ldrbvs	r6, [r2, #-375]!	; 0x177
     6c0:	0000682e 	andeq	r6, r0, lr, lsr #16
     6c4:	73750000 	cmnvc	r5, #0
     6c8:	00682e62 	rsbeq	r2, r8, r2, ror #28
     6cc:	64000000 	strvs	r0, [r0], #-0
     6d0:	682e7566 	stmdavs	lr!, {r1, r2, r5, r6, r8, sl, ip, sp, lr}
     6d4:	00000000 	andeq	r0, r0, r0
     6d8:	02050000 	andeq	r0, r5, #0
     6dc:	00001034 	andeq	r1, r0, r4, lsr r0
     6e0:	02013d03 	andeq	r3, r1, #3, 26	; 0xc0
     6e4:	01010001 	tsteq	r1, r1
     6e8:	38020500 	stmdacc	r2, {r8, sl}
     6ec:	03000010 	movweq	r0, #16
     6f0:	010100c5 	smlabteq	r1, r5, r0, r0
     6f4:	2f2f2f32 	svccs	0x002f2f32
     6f8:	2f2f2f2f 	svccs	0x002f2f2f
     6fc:	5b3f5d3e 	blpl	fd7bfc <_etext+0xfd06e4>
     700:	03666903 	cmneq	r6, #49152	; 0xc000
     704:	213d581a 	teqcs	sp, sl, lsl r8
     708:	263d3323 	ldrtcs	r3, [sp], -r3, lsr #6
     70c:	01040200 	mrseq	r0, R12_usr
     710:	3e923193 	mrccc	1, 4, r3, cr2, cr3, {4}
     714:	0402003d 	streq	r0, [r2], #-61	; 0x3d
     718:	4a780302 	bmi	1e01328 <_etext+0x1df9e10>
     71c:	3d2e0e03 	stccc	14, cr0, [lr, #-12]!
     720:	001a0240 	andseq	r0, sl, r0, asr #4
     724:	04d30101 	ldrbeq	r0, [r3], #257	; 0x101
     728:	00020000 	andeq	r0, r2, r0
     72c:	000001ac 	andeq	r0, r0, ip, lsr #3
     730:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
     734:	0101000d 	tsteq	r1, sp
     738:	00000101 	andeq	r0, r0, r1, lsl #2
     73c:	00000100 	andeq	r0, r0, r0, lsl #2
     740:	5c3a6301 	ldcpl	3, cr6, [sl], #-4
     744:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
     748:	206d6172 	rsbcs	r6, sp, r2, ror r1
     74c:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966
     750:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
     754:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20
     758:	20756e67 	rsbscs	r6, r5, r7, ror #28
     75c:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; 594 <RCC_RTCCLKConfig+0x8>
     760:	72612073 	rsbvc	r2, r1, #115	; 0x73
     764:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c
     768:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
     76c:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465
     770:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
     774:	71343130 	teqvc	r4, r0, lsr r1
     778:	696c5c33 	stmdbvs	ip!, {r0, r1, r4, r5, sl, fp, ip, lr}^
     77c:	63675c62 	cmnvs	r7, #25088	; 0x6200
     780:	72615c63 	rsbvc	r5, r1, #25344	; 0x6300
     784:	6f6e2d6d 	svcvs	0x006e2d6d
     788:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
     78c:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c
     790:	2e382e34 	mrccs	14, 1, r2, cr8, cr4, {1}
     794:	6e695c34 	mcrvs	12, 3, r5, cr9, cr4, {1}
     798:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
     79c:	3a630065 	bcc	18c0938 <_etext+0x18b9420>
     7a0:	6f72705c 	svcvs	0x0072705c
     7a4:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64
     7a8:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
     7ac:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
     7b0:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
     7b4:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
     7b8:	6f6f7420 	svcvs	0x006f7420
     7bc:	6120736c 	teqvs	r0, ip, ror #6
     7c0:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
     7c4:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
     7c8:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
     7cc:	20382e34 	eorscs	r2, r8, r4, lsr lr
     7d0:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
     7d4:	615c3371 	cmpvs	ip, r1, ror r3
     7d8:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
     7dc:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
     7e0:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     7e4:	636e695c 	cmnvs	lr, #92, 18	; 0x170000
     7e8:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
     7ec:	63616d5c 	cmnvs	r1, #92, 26	; 0x1700
     7f0:	656e6968 	strbvs	r6, [lr, #-2408]!	; 0x968
     7f4:	5c3a6300 	ldcpl	3, cr6, [sl], #-0
     7f8:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
     7fc:	206d6172 	rsbcs	r6, sp, r2, ror r1
     800:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966
     804:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
     808:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20
     80c:	20756e67 	rsbscs	r6, r5, r7, ror #28
     810:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; 648 <RCC_AHBPeriphClockCmd+0x10>
     814:	72612073 	rsbvc	r2, r1, #115	; 0x73
     818:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c
     81c:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
     820:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465
     824:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
     828:	71343130 	teqvc	r4, r0, lsr r1
     82c:	72615c33 	rsbvc	r5, r1, #13056	; 0x3300
     830:	6f6e2d6d 	svcvs	0x006e2d6d
     834:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
     838:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c
     83c:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
     840:	00656475 	rsbeq	r6, r5, r5, ror r4
     844:	74732f2e 	ldrbtvc	r2, [r3], #-3886	; 0xf2e
     848:	5f32336d 	svcpl	0x0032336d
     84c:	0062696c 	rsbeq	r6, r2, ip, ror #18
     850:	72616800 	rsbvc	r6, r1, #0, 16
     854:	72617764 	rsbvc	r7, r1, #100, 14	; 0x1900000
     858:	00632e65 	rsbeq	r2, r3, r5, ror #28
     85c:	73000000 	movwvc	r0, #0
     860:	65646474 	strbvs	r6, [r4, #-1140]!	; 0x474
     864:	00682e66 	rsbeq	r2, r8, r6, ror #28
     868:	73000001 	movwvc	r0, #1
     86c:	72616474 	rsbvc	r6, r1, #116, 8	; 0x74000000
     870:	00682e67 	rsbeq	r2, r8, r7, ror #28
     874:	5f000001 	svcpl	0x00000001
     878:	61666564 	cmnvs	r6, r4, ror #10
     87c:	5f746c75 	svcpl	0x00746c75
     880:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0x974
     884:	00682e73 	rsbeq	r2, r8, r3, ror lr
     888:	73000002 	movwvc	r0, #2
     88c:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
     890:	00682e74 	rsbeq	r2, r8, r4, ror lr
     894:	73000003 	movwvc	r0, #3
     898:	32336d74 	eorscc	r6, r3, #116, 26	; 0x1d00
     89c:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
     8a0:	7079745f 	rsbsvc	r7, r9, pc, asr r4
     8a4:	00682e65 	rsbeq	r2, r8, r5, ror #28
     8a8:	68000004 	stmdavs	r0, {r2}
     8ac:	77647261 	strbvc	r7, [r4, -r1, ror #4]!
     8b0:	2e657261 	cdpcs	2, 6, cr7, cr5, cr1, {3}
     8b4:	00000068 	andeq	r0, r0, r8, rrx
     8b8:	75623c00 	strbvc	r3, [r2, #-3072]!	; 0xc00
     8bc:	2d746c69 	ldclcs	12, cr6, [r4, #-420]!	; 0xfffffe5c
     8c0:	003e6e69 	eorseq	r6, lr, r9, ror #28
     8c4:	73000000 	movwvc	r0, #0
     8c8:	6f696474 	svcvs	0x00696474
     8cc:	0300682e 	movweq	r6, #2094	; 0x82e
     8d0:	73750000 	cmnvc	r5, #0
     8d4:	00682e62 	rsbeq	r2, r8, r2, ror #28
     8d8:	00000000 	andeq	r0, r0, r0
     8dc:	24020500 	strcs	r0, [r2], #-1280	; 0x500
     8e0:	03000011 	movweq	r0, #17
     8e4:	3b140139 	blcc	500dd0 <_etext+0x4f98b8>
     8e8:	0004024b 	andeq	r0, r4, fp, asr #4
     8ec:	05000101 	streq	r0, [r0, #-257]	; 0x101
     8f0:	00113a02 	andseq	r3, r1, r2, lsl #20
     8f4:	013e0300 	teqeq	lr, r0, lsl #6
     8f8:	04025d14 	streq	r5, [r2], #-3348	; 0xd14
     8fc:	00010100 	andeq	r0, r1, r0, lsl #2
     900:	114c0205 	cmpne	ip, r5, lsl #4
     904:	c8030000 	stmdagt	r3, {}	; <UNPREDICTABLE>
     908:	3d2e0100 	stfccs	f0, [lr, #-0]
     90c:	02003d49 	andeq	r3, r0, #4672	; 0x1240
     910:	06310104 	ldrteq	r0, [r1], -r4, lsl #2
     914:	04020020 	streq	r0, [r2], #-32
     918:	00220601 	eoreq	r0, r2, r1, lsl #12
     91c:	22020402 	andcs	r0, r2, #33554432	; 0x2000000
     920:	02040200 	andeq	r0, r4, #0, 4
     924:	005a331e 	subseq	r3, sl, lr, lsl r3
     928:	06010402 	streq	r0, [r1], -r2, lsl #8
     92c:	04020020 	streq	r0, [r2], #-32
     930:	00220602 	eoreq	r0, r2, r2, lsl #12
     934:	1e020402 	cdpne	4, 0, cr0, cr2, cr2, {0}
     938:	000a0232 	andeq	r0, sl, r2, lsr r2
     93c:	05000101 	streq	r0, [r0, #-257]	; 0x101
     940:	00119c02 	andseq	r9, r1, r2, lsl #24
     944:	029f0300 	addseq	r0, pc, #0, 6
     948:	04020001 	streq	r0, [r2], #-1
     94c:	023d1301 	eorseq	r1, sp, #67108864	; 0x4000000
     950:	01010002 	tsteq	r1, r2
     954:	a6020500 	strge	r0, [r2], -r0, lsl #10
     958:	03000011 	movweq	r0, #17
     95c:	200102a5 	andcs	r0, r1, r5, lsr #5
     960:	01040200 	mrseq	r0, R12_usr
     964:	024d3e2f 	subeq	r3, sp, #752	; 0x2f0
     968:	01010001 	tsteq	r1, r1
     96c:	bc020500 	cfstr32lt	mvfx0, [r2], {-0}
     970:	03000011 	movweq	r0, #17
     974:	3c0102ae 	sfmcc	f0, 4, [r1], {174}	; 0xae
     978:	024d6822 	subeq	r6, sp, #2228224	; 0x220000
     97c:	01010006 	tsteq	r1, r6
     980:	e4020500 	str	r0, [r2], #-1280	; 0x500
     984:	03000011 	movweq	r0, #17
     988:	2e0102b8 	mcrcs	2, 0, r0, cr1, cr8, {5}
     98c:	0230213e 	eorseq	r2, r0, #-2147483633	; 0x8000000f
     990:	01010005 	tsteq	r1, r5
     994:	fe020500 	cdp2	5, 0, cr0, cr2, cr0, {0}
     998:	03000011 	movweq	r0, #17
     99c:	2e0102c0 	cdpcs	2, 0, cr0, cr1, cr0, {6}
     9a0:	02005a23 	andeq	r5, r0, #143360	; 0x23000
     9a4:	20060104 	andcs	r0, r6, r4, lsl #2
     9a8:	02003006 	andeq	r3, r0, #6
     9ac:	20060104 	andcs	r0, r6, r4, lsl #2
     9b0:	03453f06 	movteq	r3, #24326	; 0x5f06
     9b4:	02022e1c 	andeq	r2, r2, #28, 28	; 0x1c0
     9b8:	00010100 	andeq	r0, r1, r0, lsl #2
     9bc:	122c0205 	eorne	r0, ip, #1342177280	; 0x50000000
     9c0:	e5030000 	str	r0, [r3, #-0]
     9c4:	03270102 	teqeq	r7, #-2147483648	; 0x80000000
     9c8:	59262079 	stmdbpl	r6!, {r0, r3, r4, r5, r6, sp}
     9cc:	1f3e4b4e 	svcne	0x003e4b4e
     9d0:	312f1f21 	teqcc	pc, r1, lsr #30
     9d4:	2f3b214b 	svccs	0x003b214b
     9d8:	7a034331 	bvc	d16a4 <_etext+0xca18c>
     9dc:	2f2f3d2e 	svccs	0x002f3d2e
     9e0:	1e221e31 	mcrne	14, 1, r1, cr2, cr1, {1}
     9e4:	024b3130 	subeq	r3, fp, #48, 2
     9e8:	01010005 	tsteq	r1, r5
     9ec:	b4020500 	strlt	r0, [r2], #-1280	; 0x500
     9f0:	03000012 	movweq	r0, #18
     9f4:	13010388 	movwne	r0, #5000	; 0x1388
     9f8:	4b4b1f21 	blmi	12c8684 <_etext+0x12c116c>
     9fc:	024c4b67 	subeq	r4, ip, #105472	; 0x19c00
     a00:	0101000c 	tsteq	r1, ip
     a04:	fc020500 	stc2	5, cr0, [r2], {-0}
     a08:	03000012 	movweq	r0, #18
     a0c:	15010392 	strne	r0, [r1, #-914]	; 0x392
     a10:	01040200 	mrseq	r0, R12_usr
     a14:	85424d59 	strbhi	r4, [r2, #-3417]	; 0xd59
     a18:	01040200 	mrseq	r0, R12_usr
     a1c:	4a0b0351 	bmi	2c1768 <_etext+0x2ba250>
     a20:	01040200 	mrseq	r0, R12_usr
     a24:	024b3e4b 	subeq	r3, fp, #1200	; 0x4b0
     a28:	01010009 	tsteq	r1, r9
     a2c:	5c020500 	cfstr32pl	mvfx0, [r2], {-0}
     a30:	03000013 	movweq	r0, #19
     a34:	130103bc 	movwne	r0, #5052	; 0x13bc
     a38:	01000a02 	tsteq	r0, r2, lsl #20
     a3c:	02050001 	andeq	r0, r5, #1
     a40:	00001370 	andeq	r1, r0, r0, ror r3
     a44:	0103c003 	tsteq	r3, r3
     a48:	2f214b14 	svccs	0x00214b14
     a4c:	01040200 	mrseq	r0, R12_usr
     a50:	03023d24 	movweq	r3, #11556	; 0x2d24
     a54:	00010100 	andeq	r0, r1, r0, lsl #2
     a58:	00000205 	andeq	r0, r0, r5, lsl #4
     a5c:	ce030000 	cdpgt	0, 0, cr0, cr3, cr0, {0}
     a60:	3f200103 	svccc	0x00200103
     a64:	02021908 	andeq	r1, r2, #8, 18	; 0x20000
     a68:	00010100 	andeq	r0, r1, r0, lsl #2
     a6c:	00000205 	andeq	r0, r0, r5, lsl #4
     a70:	da030000 	ble	c0a78 <_etext+0xb9560>
     a74:	cf030103 	svcgt	0x00030103
     a78:	02020100 	andeq	r0, r2, #0, 2
     a7c:	00010100 	andeq	r0, r1, r0, lsl #2
     a80:	138c0205 	orrne	r0, ip, #1342177280	; 0x50000000
     a84:	ab030000 	blge	c0a8c <_etext+0xb9574>
     a88:	09030104 	stmdbeq	r3, {r2, r8}
     a8c:	20770301 	rsbscs	r0, r7, r1, lsl #6
     a90:	1f232425 	svcne	0x00232425
     a94:	00050231 	andeq	r0, r5, r1, lsr r2
     a98:	05000101 	streq	r0, [r0, #-257]	; 0x101
     a9c:	00000002 	andeq	r0, r0, r2
     aa0:	04d20300 	ldrbeq	r0, [r2], #768	; 0x300
     aa4:	695b1401 	ldmdbvs	fp, {r0, sl, ip}^
     aa8:	00090231 	andeq	r0, r9, r1, lsr r2
     aac:	05000101 	streq	r0, [r0, #-257]	; 0x101
     ab0:	00000002 	andeq	r0, r0, r2
     ab4:	04e10300 	strbteq	r0, [r1], #768	; 0x300
     ab8:	2c222401 	cfstrscs	mvf2, [r2], #-4
     abc:	31368b5a 	teqcc	r6, sl, asr fp
     ac0:	024d3e26 	subeq	r3, sp, #608	; 0x260
     ac4:	01010006 	tsteq	r1, r6
     ac8:	a4020500 	strge	r0, [r2], #-1280	; 0x500
     acc:	03000013 	movweq	r0, #19
     ad0:	030104fa 	movweq	r0, #5370	; 0x14fa
     ad4:	7403010c 	strvc	r0, [r3], #-268	; 0x10c
     ad8:	200c0320 	andcs	r0, ip, r0, lsr #6
     adc:	313d1c24 	teqcc	sp, r4, lsr #24
     ae0:	1d23312c 	stfnes	f3, [r3, #-176]!	; 0xffffff50
     ae4:	1d243b31 	fstmdbxne	r4!, {d3-d26}	;@ Deprecated
     ae8:	2f307323 	svccs	0x00307323
     aec:	21312221 	teqcs	r1, r1, lsr #4
     af0:	0249211f 	subeq	r2, r9, #-1073741817	; 0xc0000007
     af4:	01010009 	tsteq	r1, r9
     af8:	10020500 	andne	r0, r2, r0, lsl #10
     afc:	03000014 	movweq	r0, #20
     b00:	1401059d 	strne	r0, [r1], #-1437	; 0x59d
     b04:	302f2f59 	eorcc	r2, pc, r9, asr pc	; <UNPREDICTABLE>
     b08:	01000702 	tsteq	r0, r2, lsl #14
     b0c:	02050001 	andeq	r0, r5, #1
     b10:	00001434 	andeq	r1, r0, r4, lsr r4
     b14:	0104bd03 	tsteq	r4, r3, lsl #26
     b18:	312f2720 	teqcc	pc, r0, lsr #14
     b1c:	2d213032 	stccs	0, cr3, [r1, #-200]!	; 0xffffff38
     b20:	01000202 	tsteq	r0, r2, lsl #4
     b24:	02050001 	andeq	r0, r5, #1
     b28:	00001454 	andeq	r1, r0, r4, asr r4
     b2c:	0105a703 	tsteq	r5, r3, lsl #14
     b30:	04020016 	streq	r0, [r2], #-22
     b34:	07024001 	streq	r4, [r2, -r1]
     b38:	00010100 	andeq	r0, r1, r0, lsl #2
     b3c:	14680205 	strbtne	r0, [r8], #-517	; 0x205
     b40:	b3030000 	movwlt	r0, #12288	; 0x3000
     b44:	1f130105 	svcne	0x00130105
     b48:	02002221 	andeq	r2, r0, #268435458	; 0x10000002
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	67300104 	ldrvs	r0, [r0, -r4, lsl #2]!
  b	LoopCopyDataInit
     b50:	04020021 	streq	r0, [r2], #-33	; 0x21

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
     b54:	234f2f01 	movtcs	r2, #65281	; 0xff01
	str	r3, [r0, r1]
	adds	r1, r1, #4
     b58:	01000702 	tsteq	r0, r2, lsl #14

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
     b5c:	02050001 	andeq	r0, r5, #1
	adds	r2, r0, r1
	cmp	r2, r3
     b60:	00000000 	andeq	r0, r0, r0
	bcc	CopyDataInit
     b64:	0105c403 	tsteq	r5, r3, lsl #8
	ldr	r2, =_sbss
	b	LoopFillZerobss
     b68:	0402002e 	streq	r0, [r2], #-46	; 0x2e
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	b14b2f01 	cmplt	fp, r1, lsl #30
	str	r3, [r2], #4
     b70:	00040221 	andeq	r0, r4, r1, lsr #4

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
     b74:	05000101 	streq	r0, [r0, #-257]	; 0x101
	bcc	FillZerobss
     b78:	00149c02 	andseq	r9, r4, r2, lsl #24
/* Call the application's entry point.*/
	bl	main
     b7c:	05ce0300 	strbeq	r0, [lr, #768]	; 0x300
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	302f2201 	eorcc	r2, pc, r1, lsl #4
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	00211f21 	eoreq	r1, r1, r1, lsr #30
	ldr	r3, =_edata
     b88:	24010402 	strcs	r0, [r1], #-1026	; 0x402
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	0402004b 	streq	r0, [r2], #-75	; 0x4b
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	003d3d01 	eorseq	r3, sp, r1, lsl #26
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	3d010402 	cfstrscc	mvf0, [r1, #-8]
}


/* dummy proc */
void nothingProc(void)
{
     b98:	25232f3e 	strcs	r2, [r3, #-3902]!	; 0xf3e
{
    return;
}

void usbStatusOut(void)
{
     b9c:	01000902 	tsteq	r0, r2, lsl #18
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
     ba0:	02050001 	andeq	r0, r5, #1
     ba4:	000014e8 	andeq	r1, r0, r8, ror #9
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	0105e903 	tsteq	r5, r3, lsl #18
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	00060216 	andeq	r0, r6, r6, lsl r2
     bb0:	05000101 	streq	r0, [r0, #-257]	; 0x101
        bDeviceState = CONFIGURED;
     bb4:	0014f402 	andseq	pc, r4, r2, lsl #8
     bb8:	05f00300 	ldrbeq	r0, [r0, #768]!	; 0x300
     bbc:	023d1401 	eorseq	r1, sp, #16777216	; 0x1000000
     bc0:	01010009 	tsteq	r1, r9
    }
}

void usbGetInterface(void)
{
     bc4:	0c020500 	cfstr32eq	mvfx0, [r2], {-0}
{
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	03000015 	movweq	r0, #21
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	140105f9 	strne	r0, [r1], #-1529	; 0x5f9
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	024c3022 	subeq	r3, ip, #34	; 0x22
     bd4:	01010002 	tsteq	r1, r2
     bd8:	20020500 	andcs	r0, r2, r0, lsl #10
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	03000015 	movweq	r0, #21
    dfuUpdateByReset();
     be0:	14010685 	strne	r0, [r1], #-1669	; 0x685

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	0004024b 	andeq	r0, r4, fp, asr #4

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be8:	05000101 	streq	r0, [r0, #-257]	; 0x101
     bec:	00153002 	andseq	r3, r5, r2
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	068b0300 	streq	r0, [fp], r0, lsl #6
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	26301501 	ldrtcs	r1, [r0], -r1, lsl #10
     bf8:	01000902 	tsteq	r0, r2, lsl #18

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfc:	0003b801 	andeq	fp, r3, r1, lsl #16
     c00:	dc000200 	sfmle	f0, 4, [r0], {-0}
     c04:	02000001 	andeq	r0, r0, #1
     c08:	0d0efb01 	vstreq	d15, [lr, #-4]
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c0c:	01010100 	mrseq	r0, (UNDEF: 17)
     c10:	00000001 	andeq	r0, r0, r1
     c14:	01000001 	tsteq	r0, r1
     c18:	705c3a63 	subsvc	r3, ip, r3, ror #20
     c1c:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c20:	66206d61 	strtvs	r6, [r0], -r1, ror #26
     c24:	73656c69 	cmnvc	r5, #26880	; 0x6900
     c28:	38782820 	ldmdacc	r8!, {r5, fp, sp}^
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	675c2936 	smmlarvs	ip, r6, r9, r2
     c30:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
     c34:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
     c38:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80
     c3c:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000

    Clear_Status_Out(ENDP0);
     c40:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c44:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}
     c48:	30322038 	eorscc	r2, r2, r8, lsr r0
     c4c:	33713431 	cmncc	r1, #822083584	; 0x31000000
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
     c54:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}

    bDeviceState = ATTACHED;
     c58:	61652d65 	cmnvs	r5, r5, ror #26
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
     c5c:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c64:	6d5c6564 	cfldr64vs	mvdx6, [ip, #-400]	; 0xfffffe70
     c68:	69686361 	stmdbvs	r8!, {r0, r5, r6, r8, r9, sp, lr}^
     c6c:	6300656e 	movwvs	r6, #1390	; 0x56e
     c70:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
     c74:	6172676f 	cmnvs	r2, pc, ror #14
     c78:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
     c7c:	2073656c 	rsbscs	r6, r3, ip, ror #10
     c80:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
     c88:	6f742075 	svcvs	0x00742075
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8c:	20736c6f 	rsbscs	r6, r3, pc, ror #24
     c90:	206d7261 	rsbcs	r7, sp, r1, ror #4
     c94:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
        if (dfuUpdateByRequest()) {
     c98:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
     c9c:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
            // successfull state transition, handle the request
            switch (request) {
     ca0:	31303220 	teqcc	r0, r0, lsr #4
     ca4:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
     ca8:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     cac:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
     cb4:	6e695c69 	cdpvs	12, 6, cr5, cr9, cr9, {3}
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
     cb8:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	2f2e0065 	svccs	0x002e0065
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
     cc0:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	696c5f32 	stmdbvs	ip!, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
        (*CopyRoutine)(0);

        return USB_SUCCESS;
     cc8:	3a630062 	bcc	18c0e58 <_etext+0x18b9940>
    }

    return USB_UNSUPPORT;
     ccc:	6f72705c 	svcvs	0x0072705c
}
     cd0:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64
     cd4:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
     cd8:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
     cdc:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
     ce0:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	6f6f7420 	svcvs	0x006f7420
     ce8:	6120736c 	teqvs	r0, ip, ror #6
     cec:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
     cf4:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
     cf8:	20382e34 	eorscs	r2, r8, r4, lsr lr
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
     d00:	6c5c3371 	mrrcvs	3, 7, r3, ip, cr1
    if (strIndex > STR_DESC_LEN) {
     d04:	675c6269 	ldrbvs	r6, [ip, -r9, ror #4]
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d08:	615c6363 	cmpvs	ip, r3, ror #6
     d0c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    }
}
     d10:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
     d14:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
     d18:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
     d1c:	695c342e 	ldmdbvs	ip, {r1, r2, r3, r5, sl, ip, sp}^
     d20:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
     d24:	2e006564 	cfsh32cs	mvfx6, mvfx0, #52

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	6273752f 	rsbsvs	r7, r3, #197132288	; 0xbc00000
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2c:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
     d30:	322f2e00 	eorcc	r2, pc, #0, 28
     d34:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	66640000 	strbtvs	r0, [r4], -r0
     d3c:	00632e75 	rsbeq	r2, r3, r5, ror lr
            return USB_SUCCESS;
     d40:	5f000000 	svcpl	0x00000000
     d44:	61666564 	cmnvs	r6, r4, ror #10
        }
    }
    return USB_UNSUPPORT;
}
     d48:	5f746c75 	svcpl	0x00746c75
     d4c:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0x974

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	00682e73 	rsbeq	r2, r8, r3, ror lr
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d54:	73000001 	movwvc	r0, #1
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5c:	00682e74 	rsbeq	r2, r8, r4, ror lr
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d60:	73000002 	movwvc	r0, #2
     d64:	32336d74 	eorscc	r6, r3, #116, 26	; 0x1d00
     d68:	78303166 	ldmdavc	r0!, {r1, r2, r5, r6, r8, ip, sp}
     d6c:	7079745f 	rsbsvc	r7, r9, pc, asr r4
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d70:	00682e65 	rsbeq	r2, r8, r5, ror #28
     d74:	73000003 	movwvc	r0, #3
     d78:	65646474 	strbvs	r6, [r4, #-1140]!	; 0x474
     d7c:	00682e66 	rsbeq	r2, r8, r6, ror #28
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d80:	75000004 	strvc	r0, [r0, #-4]
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	635f6273 	cmpvs	pc, #805306375	; 0x30000007
     d88:	2e65726f 	cdpcs	2, 6, cr7, cr5, cr15, {3}
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8c:	00050068 	andeq	r0, r5, r8, rrx
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d90:	75666400 	strbvc	r6, [r6, #-1024]!	; 0x400
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d94:	0000682e 	andeq	r6, r0, lr, lsr #16
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d98:	68730000 	ldmdavs	r3!, {}^	; <UNPREDICTABLE>

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	0600682e 	streq	r6, [r0], -lr, lsr #16
     da4:	6d690000 	stclvs	0, cr0, [r9, #-0]
     da8:	2e656761 	cdpcs	7, 6, cr6, cr5, cr1, {3}
     dac:	00000068 	andeq	r0, r0, r8, rrx
     db0:	62737500 	rsbsvs	r7, r3, #0, 10
     db4:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	00682e74 	rsbeq	r2, r8, r4, ror lr
     dbc:	75000005 	strvc	r0, [r0, #-5]
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dc0:	682e6273 	stmdavs	lr!, {r0, r1, r4, r5, r6, r9, sp, lr}

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	00000000 	andeq	r0, r0, r0
     dc8:	64726168 	ldrbtvs	r6, [r2], #-360	; 0x168
     dcc:	65726177 	ldrbvs	r6, [r2, #-375]!	; 0x177
     dd0:	0000682e 	andeq	r6, r0, lr, lsr #16
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	74730000 	ldrbtvc	r0, [r3], #-0
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd8:	676e6972 			; <UNDEFINED> instruction: 0x676e6972
     ddc:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	00000000 	andeq	r0, r0, r0
     de4:	15480205 	strbne	r0, [r8, #-517]	; 0x205
     de8:	3c030000 	stccc	0, cr0, [r3], {-0}
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	251f1301 	ldrcs	r1, [pc, #-769]	; af3 <USART_GetITStatus+0x3>
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	21212f1c 	teqcs	r1, ip, lsl pc
        ResumeS.eState = eResumeSetVal;
     df4:	22212121 	eorcs	r2, r1, #1073741832	; 0x40000008

    switch (ResumeS.eState) {
     df8:	0326211e 	teqeq	r6, #-2147483641	; 0x80000007
     dfc:	2f21207a 	svccs	0x0021207a
     e00:	211f214b 	tstcs	pc, fp, asr #2
     e04:	211f212f 	tstcs	pc, pc, lsr #2
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	022d5b3d 	eoreq	r5, sp, #62464	; 0xf400
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	0101001c 	tsteq	r1, ip, lsl r0
        ResumeS.eState = RESUME_START;
     e10:	d0020500 	andle	r0, r2, r0, lsl #10
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	03000015 	movweq	r0, #21
        ResumeS.eState = RESUME_WAIT;
     e18:	21010387 	smlabbcs	r1, r7, r3, r0
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	1f211f21 	svcne	0x00211f21
     e20:	21221e23 	teqcs	r2, r3, lsr #28
        if (ResumeS.bESOFcnt == 0)
     e24:	0d03222f 	sfmeq	f2, 4, [r3, #-188]	; 0xffffff44
            ResumeS.eState = RESUME_START;
     e28:	2e74032e 	cdpcs	3, 7, cr0, cr4, cr14, {1}
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	242f422f 	strtcs	r4, [pc], #-559	; e34 <usbResume+0x48>
     e30:	0008022c 	andeq	r0, r8, ip, lsr #4
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e34:	05000101 	streq	r0, [r0, #-257]	; 0x101
        ResumeS.eState = RESUME_ON;
     e38:	00000002 	andeq	r0, r0, r2
        ResumeS.bESOFcnt = 10;
     e3c:	039e0300 	orrseq	r0, lr, #0, 6
        break;
     e40:	00010201 	andeq	r0, r1, r1, lsl #4
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e44:	05000101 	streq	r0, [r0, #-257]	; 0x101
     e48:	00161402 	andseq	r1, r6, r2, lsl #8
        if (ResumeS.bESOFcnt == 0) {
     e4c:	03a10300 			; <UNDEFINED> instruction: 0x03a10300
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	4b211301 	blmi	845a5c <_etext+0x83e544>
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	05022222 	streq	r2, [r2, #-546]	; 0x222
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e58:	00010100 	andeq	r0, r1, r0, lsl #2
            ResumeS.eState = RESUME_OFF;
     e5c:	162c0205 	strtne	r0, [ip], -r5, lsl #4
     e60:	aa030000 	bge	c0e68 <_etext+0xb9950>
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e64:	21130103 	tstcs	r3, r3, lsl #2
     e68:	0222224b 	eoreq	r2, r2, #-1342177276	; 0xb0000004
     e6c:	01010005 	tsteq	r1, r5
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	44020500 	strmi	r0, [r2], #-1280	; 0x500
     e74:	03000016 	movweq	r0, #22
     e78:	220103b4 	andcs	r0, r1, #180, 6	; 0xd0000002
     e7c:	2f4b211f 	svccs	0x004b211f

    _SetCNTR(CNTR_FRES);
     e80:	07023e22 	streq	r3, [r2, -r2, lsr #28]
     e84:	00010100 	andeq	r0, r1, r0, lsl #2
     e88:	166c0205 	strbtne	r0, [ip], -r5, lsl #4
     e8c:	be030000 	cdplt	0, 0, cr0, cr3, cr0, {0}
    _SetCNTR(0);
    _SetISTR(0);
     e90:	21210103 	teqcs	r1, r3, lsl #2

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e94:	02842267 	addeq	r2, r4, #1879048198	; 0x70000006
    _SetCNTR(wInterrupt_Mask);
     e98:	01010009 	tsteq	r1, r9
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9c:	a0020500 	andge	r0, r2, r0, lsl #10
     ea0:	03000016 	movweq	r0, #22
#endif
#endif

    return USB_SUCCESS;
}
     ea4:	030103c7 	movweq	r0, #5063	; 0x13c7
     ea8:	1f3d2013 	svcne	0x003d2013
     eac:	3e315b21 	vaddcc.f64	d5, d1, d17
     eb0:	01040200 	mrseq	r0, R12_usr
     eb4:	02002006 	andeq	r2, r0, #6

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	5d060204 	sfmpl	f0, 4, [r6, #-16]
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	02040200 	andeq	r0, r4, #0, 4
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
     ec0:	02593653 	subseq	r3, r9, #87031808	; 0x5300000
     ec4:	0101000c 	tsteq	r1, ip
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec8:	fc020500 	stc2	5, cr0, [r2], {-0}
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     ecc:	03000016 	movweq	r0, #22
     ed0:	310100d0 	ldrdcc	r0, [r1, -r0]
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	21301e22 	teqcs	r0, r2, lsr #28
     ed8:	241c251f 	ldrcs	r2, [ip], #-1311	; 0x51f
     edc:	4b592222 	blmi	164976c <_etext+0x1642254>

    return USB_SUCCESS;
}
     ee0:	1f211f30 	svcne	0x00211f30
     ee4:	3c180321 	ldccc	3, cr0, [r8], {33}	; 0x21
     ee8:	4a71033d 	bmi	1c41be4 <_etext+0x1c3a6cc>
     eec:	3c11033d 	ldccc	3, cr0, [r1], {61}	; 0x3d
     ef0:	0324302f 	teqeq	r4, #47	; 0x2f
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	322f3c09 	eorcc	r3, pc, #2304	; 0x900
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	03684d3d 	cmneq	r8, #3904	; 0xf40
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efc:	2529580d 	strcs	r5, [r9, #-2061]!	; 0x80d
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	2f264b2f 	svccs	0x00264b2f
     f04:	35303131 	ldrcc	r3, [r0, #-305]!	; 0x131
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f08:	581d0330 	ldmdapl	sp, {r4, r5, r8, r9}
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	30343f2f 	eorscc	r3, r4, pc, lsr #30
     f10:	21211f4d 	teqcs	r1, sp, asr #30
    nvicInit(&NVIC_InitStructure);
     f14:	2f593040 	svccs	0x00593040
}
     f18:	20200331 	eorcs	r0, r0, r1, lsr r3

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	032e6003 	teqeq	lr, #3
    dfuInit();
     f20:	77302020 	ldrvc	r2, [r0, -r0, lsr #32]!

    pInformation->Current_Configuration = 0;
     f24:	303e4233 	eorscc	r4, lr, r3, lsr r2
     f28:	59304330 	ldmdbpl	r0!, {r4, r5, r8, r9, lr}
    usbPowerOn();
     f2c:	34422f2f 	strbcc	r2, [r2], #-3887	; 0xf2f

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
     f30:	30593034 	subscc	r3, r9, r4, lsr r0
     f34:	1f3d1f3d 	svcne	0x003d1f3d
     f38:	774fc921 	strbvc	ip, [pc, -r1, lsr #18]
    _SetCNTR(wInterrupt_Mask);
     f3c:	302f424b 	eorcc	r4, pc, fp, asr #4

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f40:	2f302f2f 	svccs	0x00302f2f
    bDeviceState = UNCONNECTED;
     f44:	2f5a3033 	svccs	0x005a3033
     f48:	352f3030 	strcc	r3, [pc, #-48]!	; f20 <usbInit+0x4>
     f4c:	0221312f 	eoreq	r3, r1, #-1073741813	; 0xc000000b
     f50:	01010024 	tsteq	r1, r4, lsr #32
     f54:	00020500 	andeq	r0, r2, r0, lsl #10
     f58:	03000000 	movweq	r0, #0
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	130103f0 	movwne	r0, #5104	; 0x13f0
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f60:	0004022f 	andeq	r0, r4, pc, lsr #4
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	05000101 	streq	r0, [r0, #-257]	; 0x101

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f68:	00000002 	andeq	r0, r0, r2
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	03f50300 	mvnseq	r0, #0, 6
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	06021301 	streq	r1, [r2], -r1, lsl #6
    nvicInit(&NVIC_InitStructure);
     f74:	00010100 	andeq	r0, r1, r0, lsl #2
}
     f78:	19500205 	ldmdbne	r0, {r0, r2, r9}^
     f7c:	fa030000 	blx	c0f84 <_etext+0xb9a6c>

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	2f130103 	svccs	0x00130103
    wIstr = _GetISTR();
     f84:	01000402 	tsteq	r0, r2, lsl #8

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	02050001 	andeq	r0, r5, #1
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8c:	00000000 	andeq	r0, r0, r0

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f90:	0103ff03 	tsteq	r3, r3, lsl #30
     f94:	02002f13 	andeq	r2, r0, #19, 30	; 0x4c
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	2e060104 	adfcss	f0, f6, f4
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	02210666 	eoreq	r0, r1, #106954752	; 0x6600000
     fa0:	01010003 	tsteq	r1, r3
     fa4:	5c020500 	cfstr32pl	mvfx0, [r2], {-0}
        _SetISTR((u16)CLR_RESET);
     fa8:	03000019 	movweq	r0, #25
        Device_Property.Reset();
     fac:	00010484 	andeq	r0, r1, r4, lsl #9
     fb0:	16010402 	strne	r0, [r1], -r2, lsl #8
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb4:	01000102 	tsteq	r0, r2, lsl #2
     fb8:	00024f01 	andeq	r4, r2, r1, lsl #30
        _SetISTR((u16)CLR_ERR);
     fbc:	f7000200 			; <UNDEFINED> instruction: 0xf7000200
     fc0:	02000000 	andeq	r0, r0, #0
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc4:	0d0efb01 	vstreq	d15, [lr, #-4]
     fc8:	01010100 	mrseq	r0, (UNDEF: 17)
        _SetISTR((u16)CLR_WKUP);
     fcc:	00000001 	andeq	r0, r0, r1
        usbResume(RESUME_EXTERNAL);
     fd0:	01000001 	tsteq	r0, r1
     fd4:	31353532 	teqcc	r5, r2, lsr r5
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd8:	3a630039 	bcc	18c10c4 <_etext+0x18b9bac>
     fdc:	6f72705c 	svcvs	0x0072705c

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
     fe8:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fec:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
     ff0:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
        _SetISTR((u16)CLR_SOF);
     ff4:	6f6f7420 	svcvs	0x006f7420
     ff8:	6120736c 	teqvs	r0, ip, ror #6
        bIntPackSOF++;
     ffc:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
    1000:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
    1008:	20382e34 	eorscs	r2, r8, r4, lsr lr
        _SetISTR((u16)CLR_ESOF);
    100c:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
    1010:	615c3371 	cmpvs	ip, r1, ror r3
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    }
#endif

}
    1014:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    101c:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    1020:	636e695c 	cmnvs	lr, #92, 18	; 0x170000
    1024:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
    1028:	63616d5c 	cmnvs	r1, #92, 26	; 0x1700
    102c:	656e6968 	strbvs	r6, [lr, #-2408]!	; 0x968
    1030:	5c3a6300 	ldcpl	3, cr6, [sl], #-0
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

void print_hash(unsigned char hash[])
{
    1034:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
}

int main() 
{
    1038:	206d6172 	rsbcs	r6, sp, r2, ror r1
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    103c:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966
    setupCLK();
    1040:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
    setupLEDAndButton();
    1044:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20
    setupUSB();
    1048:	20756e67 	rsbscs	r6, r5, r7, ror #28
    setupFLASH();
    104c:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; e84 <usbPowerOn+0x14>
    uartInit();
    1050:	72612073 	rsbvc	r2, r1, #115	; 0x73
    usbReset();
    1054:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c
	uart_printf("\nBootloader init...\n");
    1058:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
    105c:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465

    if (readPin(GPIOB, 15) == 0x0)
    1060:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
    1064:	71343130 	teqvc	r4, r0, lsr r1
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1068:	72615c33 	rsbvc	r5, r1, #13056	; 0x3300
    106c:	6f6e2d6d 	svcvs	0x006e2d6d
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    1070:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
    1074:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
    1078:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
    107c:	00656475 	rsbeq	r6, r5, r5, ror r4
    1080:	35326300 	ldrcc	r6, [r2, #-768]!	; 0x300
   debug_print("\n", 0);
}

int main() 
{
	bool no_user_jump = FALSE;
    1084:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}
    1088:	00010063 	andeq	r0, r1, r3, rrx
    108c:	35326600 	ldrcc	r6, [r2, #-1536]!	; 0x600
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1090:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}
			no_user_jump = FALSE;
    1094:	00010068 	andeq	r0, r1, r8, rrx
			break;

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    1098:	65645f00 	strbvs	r5, [r4, #-3840]!	; 0xf00
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    109c:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
    10a0:	79745f74 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
			break;

		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10a4:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
    10a8:	00020068 	andeq	r0, r2, r8, rrx
    10ac:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
    10b0:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    10b4:	00030068 	andeq	r0, r3, r8, rrx

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10b8:	05000000 	streq	r0, [r0, #-0]
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10bc:	00000002 	andeq	r0, r0, r2
    10c0:	00d30300 	sbcseq	r0, r3, r0, lsl #6
    10c4:	03020401 	movweq	r0, #9217	; 0x2401
    10c8:	01044a50 	tsteq	r4, r0, asr sl

		if (dfuUploadStarted()) 
    10cc:	04203003 	strteq	r3, [r0], #-3
    10d0:	2e500302 	cdpcs	3, 5, cr0, cr0, cr2, {0}
		{
			uart_printf("DFU finished upload\n");
    10d4:	33030104 	movwcc	r0, #12548	; 0x3104
			dfuFinishUpload(); // systemHardReset from DFU once done
    10d8:	0302043c 	movweq	r0, #9276	; 0x243c
    10dc:	01043c4d 	tsteq	r4, sp, asr #24
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10e0:	23203303 	teqcs	r0, #201326592	; 0xc000000
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10e4:	7e75691d 	mrcvc	9, 3, r6, cr5, cr13, {0}
    10e8:	0302043f 	movweq	r0, #9279	; 0x243f
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10ec:	01042e4a 	tsteq	r4, sl, asr #28
	}
	
	return 0;// Added to please the compiler
    10f0:	04663e03 	strbteq	r3, [r6], #-3587	; 0xe03
    10f4:	20420302 	subcs	r0, r2, r2, lsl #6
    10f8:	02000104 	andeq	r0, r0, #4, 2
    10fc:	3f030204 	svccc	0x00030204
    1100:	0402002e 	streq	r0, [r2], #-46	; 0x2e
    1104:	2e5f0302 	cdpcs	3, 5, cr0, cr15, cr2, {0}
    1108:	02040200 	andeq	r0, r4, #0, 4
    110c:	00202103 	eoreq	r2, r0, r3, lsl #2
    1110:	03020402 	movweq	r0, #9218	; 0x2402
    1114:	02002e5f 	andeq	r2, r0, #1520	; 0x5f0
    1118:	21030204 	tstcs	r3, r4, lsl #4
    111c:	0402002e 	streq	r0, [r2], #-46	; 0x2e
    1120:	205f0302 	subscs	r0, pc, r2, lsl #6
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1124:	02040200 	andeq	r0, r4, #0, 4
    1128:	0402002f 	streq	r0, [r2], #-47	; 0x2f
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    112c:	02005902 	andeq	r5, r0, #32768	; 0x8000
    1130:	005a0204 	subseq	r0, sl, r4, lsl #4
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1134:	59020402 	stmdbpl	r2, {r1, sl}
    1138:	02040200 	andeq	r0, r4, #0, 4
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    113c:	04020059 	streq	r0, [r2], #-89	; 0x59
    1140:	02005a02 	andeq	r5, r0, #8192	; 0x2000
        return TRUE;
    } else {
        return FALSE;
    }
}
    1144:	00590204 	subseq	r0, r9, r4, lsl #4
    1148:	59020402 	stmdbpl	r2, {r1, sl}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    114c:	02040200 	andeq	r0, r4, #0, 4
    1150:	0402005a 	streq	r0, [r2], #-90	; 0x5a
    1154:	02005902 	andeq	r5, r0, #32768	; 0x8000
    gpio_write_bit( bank,pin,1-onState);
    1158:	00590204 	subseq	r0, r9, r4, lsl #4
    115c:	03020402 	movweq	r0, #9218	; 0x2402
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	0200584b 	andeq	r5, r0, #4915200	; 0x4b0000
    gpio_write_bit( bank,pin,1-onState);
    1164:	00590204 	subseq	r0, r9, r4, lsl #4

    u32 c;
    while (count-- > 0) 
    1168:	59020402 	stmdbpl	r2, {r1, sl}
	{
        for (c = rate; c > 0; c--)
    116c:	02040200 	andeq	r0, r4, #0, 4
    1170:	0402005a 	streq	r0, [r2], #-90	; 0x5a
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1174:	02005902 	andeq	r5, r0, #32768	; 0x8000
    1178:	005a0204 	subseq	r0, sl, r4, lsl #4
    117c:	59020402 	stmdbpl	r2, {r1, sl}
		
        for (c = rate; c > 0; c--)
    1180:	02040200 	andeq	r0, r4, #0, 4
    1184:	04020059 	streq	r0, [r2], #-89	; 0x59
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    1188:	02005902 	andeq	r5, r0, #32768	; 0x8000
    118c:	00590204 	subseq	r0, r9, r4, lsl #4
    1190:	03020402 	movweq	r0, #9218	; 0x2402
    1194:	0200581c 	andeq	r5, r0, #28, 16	; 0x1c0000
    1198:	00590204 	subseq	r0, r9, r4, lsl #4

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    119c:	59020402 	stmdbpl	r2, {r1, sl}
    11a0:	02040200 	andeq	r0, r4, #0, 4
  USARTx->DR = ch;  
    11a4:	0402005a 	streq	r0, [r2], #-90	; 0x5a
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11a8:	02005902 	andeq	r5, r0, #32768	; 0x8000
  while(*str != 0)
    11ac:	00590204 	subseq	r0, r9, r4, lsl #4
    11b0:	5a020402 	bpl	821c0 <_etext+0x7aca8>
  {
    UU_PutChar(USARTx, *str);
    11b4:	02040200 	andeq	r0, r4, #0, 4
    11b8:	04020059 	streq	r0, [r2], #-89	; 0x59
    str++;
  }
}

void vprint(const char *fmt, va_list argp)
{
    11bc:	02005902 	andeq	r5, r0, #32768	; 0x8000
    11c0:	005a0204 	subseq	r0, sl, r4, lsl #4
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11c4:	59020402 	stmdbpl	r2, {r1, sl}
    11c8:	02040200 	andeq	r0, r4, #0, 4
    11cc:	00581403 	subseq	r1, r8, r3, lsl #8
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11d0:	03020402 	movweq	r0, #9218	; 0x2402
    11d4:	02002e6d 	andeq	r2, r0, #1744	; 0x6d0

    }
}
    11d8:	22030204 	andcs	r0, r3, #4, 4	; 0x40000000
    11dc:	04020058 	streq	r0, [r2], #-88	; 0x58
    11e0:	02007502 	andeq	r7, r0, #8388608	; 0x800000

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11e4:	00670204 	rsbeq	r0, r7, r4, lsl #4
    11e8:	67020402 	strvs	r0, [r2, -r2, lsl #8]
    11ec:	02040200 	andeq	r0, r4, #0, 4
    va_list argp;
    va_start(argp, fmt);
    vprint(fmt, argp);
    11f0:	002e6d03 	eoreq	r6, lr, r3, lsl #26
    va_end(argp);
}
    11f4:	03020402 	movweq	r0, #9218	; 0x2402
    11f8:	02002013 	andeq	r2, r0, #19
    11fc:	6d030204 	sfmvs	f0, 4, [r3, #-16]

void hexdump(unsigned char *data, size_t size)
{
    1200:	3c17034a 	ldccc	3, cr0, [r7], {74}	; 0x4a
    int i;
    char cs[17];
    memset(cs, 0, 17);
    1204:	023d594b 	eorseq	r5, sp, #1228800	; 0x12c000
    1208:	01010007 	tsteq	r1, r7
    120c:	0000029e 	muleq	r0, lr, r2

    for(i = 0; i < size; i++)
    1210:	01050002 	tsteq	r5, r2
    {
        if(i != 0 && i % 0x10 == 0)
    1214:	01020000 	mrseq	r0, (UNDEF: 2)
    1218:	000d0efb 	strdeq	r0, [sp], -fp
        {
            debug_print(" |%s|\n", cs);
            memset(cs, 0, 17);
    121c:	01010101 	tsteq	r1, r1, lsl #2
    1220:	01000000 	mrseq	r0, (UNDEF: 0)
{
    int i;
    char cs[17];
    memset(cs, 0, 17);

    for(i = 0; i < size; i++)
    1224:	32010000 	andcc	r0, r1, #0
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
}
    1228:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}


#endif
void uartInit(void) {
    122c:	5c3a6300 	ldcpl	3, cr6, [sl], #-0
    1230:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    1234:	206d6172 	rsbcs	r6, sp, r2, ror r1
    1238:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    123c:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
    1240:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    1244:	20756e67 	rsbscs	r6, r5, r7, ror #28
    1248:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; 1080 <main+0x48>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    124c:	72612073 	rsbvc	r2, r1, #115	; 0x73
    1250:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1254:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
    1258:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    125c:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    1260:	71343130 	teqvc	r4, r0, lsr r1
    1264:	72615c33 	rsbvc	r5, r1, #13056	; 0x3300
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1268:	6f6e2d6d 	svcvs	0x006e2d6d
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    126c:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1270:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1274:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1278:	5c656475 	cfstrdpl	mvd6, [r5], #-468	; 0xfffffe2c
    127c:	6863616d 	stmdavs	r3!, {r0, r2, r3, r5, r6, r8, sp, lr}^
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1280:	00656e69 	rsbeq	r6, r5, r9, ror #28
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    1284:	705c3a63 	subsvc	r3, ip, r3, ror #20
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1288:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
    USART_InitStructure.USART_Parity = USART_Parity_No;
    128c:	66206d61 	strtvs	r6, [r0], -r1, ror #26
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    1290:	73656c69 	cmnvc	r5, #26880	; 0x6900
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1294:	38782820 	ldmdacc	r8!, {r5, fp, sp}^
    1298:	675c2936 	smmlarvs	ip, r6, r9, r2
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    129c:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
        
    USART_Init(USART1, &USART_InitStructure);
    12a0:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    12a4:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80
    12a8:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000
}
    12ac:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
    12b0:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    12b4:	30322038 	eorscc	r2, r2, r8, lsr r0
    12b8:	33713431 	cmncc	r1, #822083584	; 0x31000000
    12bc:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    12c0:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    12c4:	61652d65 	cmnvs	r5, r5, ror #26
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    12c8:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^
    12cc:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    12d0:	00006564 	andeq	r6, r0, r4, ror #10
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    12d4:	35326465 	ldrcc	r6, [r2, #-1125]!	; 0x465
    12d8:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    12dc:	00010063 	andeq	r0, r1, r3, rrx
    12e0:	35326600 	ldrcc	r6, [r2, #-1536]!	; 0x600

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    12e4:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}
    12e8:	00010068 	andeq	r0, r1, r8, rrx
    12ec:	32646500 	rsbcc	r6, r4, #0, 10
    12f0:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    12f4:	0100682e 	tsteq	r0, lr, lsr #16
    12f8:	645f0000 	ldrbvs	r0, [pc], #-0	; 1300 <setupCLK+0x4>
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    12fc:	75616665 	strbvc	r6, [r1, #-1637]!	; 0x665
    1300:	745f746c 	ldrbvc	r7, [pc], #-1132	; 1308 <setupCLK+0xc>
    1304:	73657079 	cmnvc	r5, #121	; 0x79
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    1308:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    130c:	74730000 	ldrbtvc	r0, [r3], #-0

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    1310:	746e6964 	strbtvc	r6, [lr], #-2404	; 0x964
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    1314:	0300682e 	movweq	r6, #2094	; 0x82e
    1318:	00000000 	andeq	r0, r0, r0
    131c:	19600205 	stmdbne	r0!, {r0, r2, r9}^
    1320:	33030000 	movwcc	r0, #12288	; 0x3000
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    1324:	02042001 	andeq	r2, r4, #1
    1328:	04207003 	strteq	r7, [r0], #-3

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    132c:	08100301 	ldmdaeq	r0, {r0, r8, r9}
    1330:	03020474 	movweq	r0, #9332	; 0x2474
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    1334:	01042070 	tsteq	r4, r0, ror r0
    1338:	04ac1003 	strteq	r1, [ip], #3
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    133c:	20700302 	rsbscs	r0, r0, r2, lsl #6
    1340:	13030104 	movwne	r0, #12548	; 0x3104
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    1344:	0302042e 	movweq	r0, #9262	; 0x242e
    1348:	0104206d 	tsteq	r4, sp, rrx
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    134c:	3d3c1303 	ldccc	3, cr1, [ip, #-12]!
    1350:	02022d4b 	andeq	r2, r2, #4800	; 0x12c0
    1354:	00010100 	andeq	r0, r1, r0, lsl #2
    1358:	19d00205 	ldmibne	r0, {r0, r2, r9}^

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    135c:	3c030000 	stccc	0, cr0, [r3], {-0}
    1360:	593f2e01 	ldmdbpl	pc!, {r0, r9, sl, fp, sp}	; <UNPREDICTABLE>
    1364:	3d3d6859 	ldccc	8, cr6, [sp, #-356]!	; 0xfffffe9c
    1368:	01000202 	tsteq	r0, r2, lsl #4
    136c:	02050001 	andeq	r0, r5, #1
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    1370:	00001a0c 	andeq	r1, r0, ip, lsl #20
    1374:	0100de03 	tsteq	r0, r3, lsl #28
        u32 rwmVal = pRCC->CR;
    1378:	45030204 	strmi	r0, [r3, #-516]	; 0x204
        rwmVal |= 0x01;
    137c:	03010458 	movweq	r0, #5208	; 0x1458
        pRCC->CR = rwmVal;
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    1380:	04ac00c0 	strteq	r0, [ip], #192	; 0xc0
    1384:	3c400302 	mcrrcc	3, 0, r0, r0, cr2
}   
    1388:	c4030104 	strgt	r0, [r3], #-260	; 0x104
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    138c:	311df200 	tstcc	sp, r0, lsl #4
void setMspAndJump(u32 usrAddr) {
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    1390:	241c242b 	ldrcs	r2, [ip], #-1067	; 0x42b
  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1394:	0002022f 	andeq	r0, r2, pc, lsr #4

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1398:	05000101 	streq	r0, [r0, #-257]	; 0x101
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    139c:	001a6c02 	andseq	r6, sl, r2, lsl #24
    13a0:	00ec0300 	rsceq	r0, ip, r0, lsl #6
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    13a4:	03020401 	movweq	r0, #9217	; 0x2401
    13a8:	042e7fb7 	strteq	r7, [lr], #-4023	; 0xfb7
    13ac:	00c90301 	sbceq	r0, r9, r1, lsl #6
    13b0:	02042158 	andeq	r2, r4, #88, 2
    tmppre = (0x4 - tmppriority);
    13b4:	2e7fb603 	cdpcs	6, 7, cr11, cr15, cr3, {0}
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    13b8:	c9030104 	stmdbgt	r3, {r2, r8}


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    13bc:	04289e00 	strteq	r9, [r8], #-3584	; 0xe00

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c0:	7faf0302 	svcvc	0x00af0302
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    13c4:	0301042e 	movweq	r0, #5166	; 0x142e

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c8:	282e00c9 	stmdacs	lr!, {r0, r3, r6, r7}
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    13cc:	04207803 	strteq	r7, [r0], #-2051	; 0x803
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d0:	7fb70302 	svcvc	0x00b70302

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d4:	03010420 	movweq	r0, #5152	; 0x1420
    13d8:	243c00d4 	ldrtcs	r0, [ip], #-212	; 0xd4
    13dc:	5959311c 	ldmdbpl	r9, {r2, r3, r4, r8, ip, sp}^
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    13e0:	4b5b5b4d 	blmi	16d811c <_etext+0x16d0c04>
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    13e4:	3d59af4d 	ldclcc	15, cr10, [r9, #-308]	; 0xfffffecc
    tmppriority &= tmpmask;
    13e8:	07024b3e 	smladxeq	r2, lr, fp, r4
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    13ec:	00010100 	andeq	r0, r1, r0, lsl #2

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    13f0:	1b340205 	blne	d01c0c <_etext+0xcfa6f4>
    13f4:	9d030000 	stcls	0, cr0, [r3, #-0]
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    13f8:	034a0101 	movteq	r0, #41217	; 0xa101
    13fc:	6103201f 	tstvs	r3, pc, lsl r0
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    1400:	201f032e 	andscs	r0, pc, lr, lsr #6
    1404:	592f2d3d 	stmdbpl	pc!, {r0, r2, r3, r4, r5, r8, sl, fp, sp}	; <UNPREDICTABLE>
    1408:	5b59595b 	blpl	165797c <_etext+0x1650464>
    140c:	5b755b75 	blpl	1d581e8 <_etext+0x1d50cd0>
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    1410:	5b5b5b5b 	blpl	16d8184 <_etext+0x16d0c6c>
    1414:	6769695b 			; <UNDEFINED> instruction: 0x6769695b
    1418:	01000502 	tsteq	r0, r2, lsl #10
    rNVIC->ICER[1] = 0xFFFFFFFF;
    141c:	02050001 	andeq	r0, r5, #1
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    1420:	00001c14 	andeq	r1, r0, r4, lsl ip
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    1424:	0101e703 	tsteq	r1, r3, lsl #14

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    1428:	201e032e 	andscs	r0, lr, lr, lsr #6
    142c:	2e65032b 	cdpcs	3, 6, cr0, cr5, cr11, {1}
    1430:	31201b03 	teqcc	r0, r3, lsl #22

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    1434:	595c675b 	ldmdbpl	ip, {r0, r1, r3, r4, r6, r8, r9, sl, sp, lr}^
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    1438:	5b5b5959 	blpl	16d79a4 <_etext+0x16d048c>
    nvicDisableInterrupts();
    143c:	5b5b4b5b 	blpl	16d41b0 <_etext+0x16ccc98>
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    1440:	02676969 	rsbeq	r6, r7, #1720320	; 0x1a4000
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    1444:	01010002 	tsteq	r1, r2
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    1448:	c8020500 	stmdagt	r2, {r8, sl}
}
    144c:	0300001c 	movweq	r0, #28
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    1450:	3c0102ab 	sfmcc	f0, 4, [r1], {171}	; 0xab

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1454:	9d030304 	stcls	3, cr0, [r3, #-16]
    1458:	01043c7e 	tsteq	r4, lr, ror ip

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    145c:	5801e903 	stmdapl	r1, {r0, r1, r8, fp, sp, lr, pc}
    1460:	02040200 	andeq	r0, r4, #0, 4
    1464:	04020021 	streq	r0, [r2], #-33	; 0x21
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1468:	02005b02 	andeq	r5, r0, #2048	; 0x800
    146c:	00470204 	subeq	r0, r7, r4, lsl #4
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    1470:	32020402 	andcc	r0, r2, #33554432	; 0x2000000

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1474:	02040200 	andeq	r0, r4, #0, 4
    1478:	0402005a 	streq	r0, [r2], #-90	; 0x5a
    147c:	02006702 	andeq	r6, r0, #524288	; 0x80000
    SET_REG(FLASH_AR, pageAddr);
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    1480:	00670204 	rsbeq	r0, r7, r4, lsl #4
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1484:	67020402 	strvs	r0, [r2, -r2, lsl #8]
    1488:	02040200 	andeq	r0, r4, #0, 4

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    148c:	002e7603 	eoreq	r7, lr, r3, lsl #12

    return TRUE;
}
    1490:	03020402 	movweq	r0, #9218	; 0x2402
    1494:	0200200a 	andeq	r2, r0, #10
    1498:	76030204 	strvc	r0, [r3], -r4, lsl #4
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    149c:	0303044a 	movweq	r0, #13386	; 0x344a
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    14a0:	042e7e97 	strteq	r7, [lr], #-3735	; 0xe97
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    14a4:	01f70301 	mvnseq	r0, r1, lsl #6

    u32 rwmVal = GET_REG(FLASH_CR);
    SET_REG(FLASH_CR, FLASH_CR_PG);
    14a8:	00060258 	andeq	r0, r6, r8, asr r2
    14ac:	026a0101 	rsbeq	r0, sl, #1073741824	; 0x40000000

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14b0:	00020000 	andeq	r0, r2, r0
    14b4:	00000185 	andeq	r0, r0, r5, lsl #3
    *(flashAddr + 0x01) = (vu16)hhWord;
    14b8:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14bc:	0101000d 	tsteq	r1, sp
    14c0:	00000101 	andeq	r0, r0, r1, lsl #2
    *(flashAddr) = (vu16)lhWord;
    14c4:	00000100 	andeq	r0, r0, r0, lsl #2
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14c8:	35353201 	ldrcc	r3, [r5, #-513]!	; 0x201
    14cc:	63003931 	movwvs	r3, #2353	; 0x931

    rwmVal &= 0xFFFFFFFE;
    14d0:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
    SET_REG(FLASH_CR, rwmVal);

    /* verify the write */
    if (*(vu32 *)addr != word) {
    14d4:	6172676f 	cmnvs	r2, pc, ror #14
        return FALSE;
    }

    return TRUE;
}
    14d8:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
    14dc:	2073656c 	rsbscs	r6, r3, ip, ror #10
    14e0:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
    14e4:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    14e8:	6f742075 	svcvs	0x00742075
    14ec:	20736c6f 	rsbscs	r6, r3, pc, ror #24
    14f0:	206d7261 	rsbcs	r7, sp, r1, ror #4
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    14f4:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
    14f8:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    14fc:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    1500:	31303220 	teqcc	r0, r0, lsr #4
    1504:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
    1508:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    150c:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
	{
		pin-=8;
    1510:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
	}
	mask = 0x0F << (pin<<2);
    1514:	6e695c69 	cdpvs	12, 6, cr5, cr9, cr9, {3}
    1518:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
	return ~mask;
}	
    151c:	616d5c65 	cmnvs	sp, r5, ror #24

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    1520:	6e696863 	cdpvs	8, 6, cr6, cr9, cr3, {3}
    1524:	3a630065 	bcc	18c16c0 <_etext+0x18ba1a8>
}
    1528:	6f72705c 	svcvs	0x0072705c
    152c:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    1530:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
	{
		return 0x800;
    1534:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
	}
	else
	{
		return 0x400;
	}
}
    1538:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
    153c:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
    1540:	6f6f7420 	svcvs	0x006f7420
    1544:	6120736c 	teqvs	r0, ip, ror #6

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1548:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    154c:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1550:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1554:	20382e34 	eorscs	r2, r8, r4, lsr lr
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    1558:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    155c:	615c3371 	cmpvs	ip, r1, ror r3
    1560:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1564:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1568:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    userAppEnd = RAM_END;
    156c:	636e695c 	cmnvs	lr, #92, 18	; 0x170000
    1570:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
    userUploadType=DFU_UPLOAD_NONE;
    1574:	5c3a6300 	ldcpl	3, cr6, [sl], #-0
    1578:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
    code_copy_lock = WAIT;
    157c:	206d6172 	rsbcs	r6, sp, r2, ror r1
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1580:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966
    1584:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
    1588:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20
    memset(input, 0xFF, sizeof(input));
    158c:	20756e67 	rsbscs	r6, r5, r7, ror #28
    1590:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; 13c8 <nvicInit+0x24>

    sha256_starts(&ctx);
}
    1594:	72612073 	rsbvc	r2, r1, #115	; 0x73
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1598:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c
    159c:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
    15a0:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465
    15a4:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
    15a8:	71343130 	teqvc	r4, r0, lsr r1
    15ac:	696c5c33 	stmdbvs	ip!, {r0, r1, r4, r5, sl, fp, ip, lr}^
    15b0:	63675c62 	cmnvs	r7, #25088	; 0x6200
    15b4:	72615c63 	rsbvc	r5, r1, #25344	; 0x6300
    15b8:	6f6e2d6d 	svcvs	0x006e2d6d
    15bc:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
    15c0:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c
    15c4:	2e382e34 	mrccs	14, 1, r2, cr8, cr4, {1}
    15c8:	6e695c34 	mcrvs	12, 3, r5, cr9, cr4, {1}
    15cc:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    15d0:	65000065 	strvs	r0, [r0, #-101]	; 0x65
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    15d4:	67697364 	strbvs	r7, [r9, -r4, ror #6]!
    15d8:	00632e6e 	rsbeq	r2, r3, lr, ror #28

    if (startState == appDETACH) {
    15dc:	73000001 	movwvc	r0, #1
    15e0:	31356168 	teqcc	r5, r8, ror #2
        dfuAppStatus.bState = dfuIDLE;
    15e4:	00682e32 	rsbeq	r2, r8, r2, lsr lr
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
    15e8:	65000001 	strvs	r0, [r0, #-1]
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    15ec:	35353264 	ldrcc	r3, [r5, #-612]!	; 0x264
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    15f0:	682e3931 	stmdavs	lr!, {r0, r4, r5, r8, fp, ip, sp}
    } else if (startState == appIDLE || startState == dfuIDLE) {
    15f4:	00000100 	andeq	r0, r0, r0, lsl #2
    15f8:	6665645f 			; <UNDEFINED> instruction: 0x6665645f
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    15fc:	746c7561 	strbtvc	r7, [ip], #-1377	; 0x561
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1600:	7079745f 	rsbsvc	r7, r9, pc, asr r4
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    1604:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
    1608:	00000200 	andeq	r0, r0, r0, lsl #4
    160c:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    1610:	682e746e 	stmdavs	lr!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    1614:	00000300 	andeq	r0, r0, r0, lsl #6
        pInformation->Ctrl_Info.Usb_wLength = 1;
    1618:	64647473 	strbtvs	r7, [r4], #-1139	; 0x473
    161c:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}
        return NULL;
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    1620:	00000400 	andeq	r0, r0, r0, lsl #8
    }
}
    1624:	69727066 	ldmdbvs	r2!, {r1, r2, r5, r6, ip, sp, lr}^
    1628:	682e656d 	stmdavs	lr!, {r0, r2, r3, r5, r6, r8, sl, sp, lr}

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    162c:	00000100 	andeq	r0, r0, r0, lsl #2
        pInformation->Ctrl_Info.Usb_wLength = 6;
    1630:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
    1634:	682e3931 	stmdavs	lr!, {r0, r4, r5, r8, fp, ip, sp}
        return NULL;
    } else {
        return (u8*)(&dfuAppStatus);
    1638:	00000100 	andeq	r0, r0, r0, lsl #2
    }
}
    163c:	02050000 	andeq	r0, r5, #0
    1640:	00000000 	andeq	r0, r0, r0


u8 *dfuCopyDNLOAD(u16 length) {
    1644:	04013a03 	streq	r3, [r1], #-2563	; 0xa03
    if (length == 0) {
    1648:	20630302 	rsbcs	r0, r3, r2, lsl #6
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    164c:	1d030104 	stfnes	f0, [r3, #-16]
    1650:	03020420 	movweq	r0, #9248	; 0x2420
        thisBlockLen = pInformation->USBwLengths.w;
    1654:	01042063 	tsteq	r4, r3, rrx
        return NULL;
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1658:	04201d03 	strteq	r1, [r0], #-3331	; 0xd03
    165c:	2e630302 	cdpcs	3, 6, cr0, cr3, cr2, {0}
    }
}
    1660:	599a0104 	ldmibpl	sl, {r2, r8}
    1664:	26030304 	strcs	r0, [r3], -r4, lsl #6
    1668:	2d2f2d66 	stccs	13, cr2, [pc, #-408]!	; 14d8 <flashWriteWord+0x3c>

u8 *dfuCopyUPLOAD(u16 length) {
    166c:	76030104 	strvc	r0, [r3], -r4, lsl #2
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    1670:	0303042e 	movweq	r0, #13358	; 0x342e
    1674:	01042e0c 	tsteq	r4, ip, lsl #28
    1678:	042e7403 	strteq	r7, [lr], #-1027	; 0x403
        return NULL;
    167c:	200a0303 	andcs	r0, sl, r3, lsl #6
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    1680:	03010430 	movweq	r0, #5168	; 0x1430
    1684:	78032e74 	stmdavc	r3, {r2, r4, r5, r6, r9, sl, fp, sp}
    1688:	1103592e 	tstne	r3, lr, lsr #18
    168c:	00060258 	andeq	r0, r6, r8, asr r2
    }
}
    1690:	05000101 	streq	r0, [r0, #-257]	; 0x101
    1694:	001d4c02 	andseq	r4, sp, r2, lsl #24
    1698:	018d0300 	orreq	r0, sp, r0, lsl #6
    169c:	58600301 	stmdapl	r0!, {r0, r8, r9}^

void dfuCopyBufferToExec() {
    16a0:	032e2003 	teqeq	lr, #3
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    16a4:	2d832e60 	stccs	14, cr2, [r3, #384]	; 0x180
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    16a8:	03020421 	movweq	r0, #9249	; 0x2421
    16ac:	044a7faf 	strbeq	r7, [sl], #-4015	; 0xfaf
    16b0:	00d10301 	sbcseq	r0, r1, r1, lsl #6
    16b4:	03020420 	movweq	r0, #9248	; 0x2420
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    16b8:	04667faf 	strbteq	r7, [r6], #-4015	; 0xfaf
	}

    flashErasePage((u32)(userSpace));
    16bc:	00d10301 	sbcseq	r0, r1, r1, lsl #6

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16c0:	03020420 	movweq	r0, #9248	; 0x2420
    16c4:	042e7faf 	strteq	r7, [lr], #-4015	; 0xfaf
    16c8:	822c0301 	eorhi	r0, ip, #67108864	; 0x4000000
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    16cc:	54030204 	strpl	r0, [r3], #-516	; 0x204
    16d0:	0301042e 	movweq	r0, #5166	; 0x142e
    16d4:	e6262e2c 	strt	r2, [r6], -ip, lsr #28
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16d8:	3d1f3d4c 	ldccc	13, cr3, [pc, #-304]	; 15b0 <dfuInit+0x68>
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    16dc:	2b302c22 	blcs	c0c76c <_etext+0xc05254>
    16e0:	82720333 	rsbshi	r0, r2, #-872415232	; 0xcc000000
    thisBlockLen = 0;
    16e4:	66100359 			; <UNDEFINED> instruction: 0x66100359
    16e8:	66590367 	ldrbvs	r0, [r9], -r7, ror #6
    16ec:	59667803 	stmdbpl	r6!, {r0, r1, fp, ip, sp, lr}^
    16f0:	5a587403 	bpl	161e704 <_etext+0x16171ec>
    16f4:	f903221e 			; <UNDEFINED> instruction: 0xf903221e
    16f8:	85034a00 	strhi	r4, [r3, #-2560]	; 0xa00
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    16fc:	1e5a587f 	mrcne	8, 2, r5, cr10, cr15, {3}
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    1700:	00fb0322 	rscseq	r0, fp, r2, lsr #6
    1704:	7f8e034a 	svcvc	0x008e034a

    u8 startState = dfuAppStatus.bState;
    1708:	f5035958 			; <UNDEFINED> instruction: 0xf5035958
    170c:	79035800 	stmdbvc	r3, {fp, ip, lr}
    dfuAppStatus.bStatus = OK;
    1710:	0334224a 	teqeq	r4, #-1610612732	; 0xa0000004
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    1714:	024a7faf 	subeq	r7, sl, #700	; 0x2bc

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    1718:	01010008 	tsteq	r1, r8
    171c:	00000702 	andeq	r0, r0, r2, lsl #14
            if (pInformation->USBwLengths.w > 0) {
    1720:	00f70002 	rscseq	r0, r7, r2
    1724:	01020000 	mrseq	r0, (UNDEF: 2)
                userFirmwareLen = 0;
    1728:	000d0efb 	strdeq	r0, [sp], -fp
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    172c:	01010101 	tsteq	r1, r1, lsl #2
    1730:	01000000 	mrseq	r0, (UNDEF: 0)
    1734:	32010000 	andcc	r0, r1, #0
    1738:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    173c:	5c3a6300 	ldcpl	3, cr6, [sl], #-0
						userAppAddr = USER_CODE_FLASH0X8002000;
    1740:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
    1744:	206d6172 	rsbcs	r6, sp, r2, ror r1
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    1748:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966
    174c:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    1750:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1754:	20756e67 	rsbscs	r6, r5, r7, ror #28
						flashUnlock();
    1758:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; 1590 <dfuInit+0x48>

						break;
    175c:	72612073 	rsbvc	r2, r1, #115	; 0x73

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    1760:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1764:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1768:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    176c:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
    1770:	71343130 	teqvc	r4, r0, lsr r1
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    1774:	72615c33 	rsbvc	r5, r1, #13056	; 0x3300
    1778:	6f6e2d6d 	svcvs	0x006e2d6d
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    177c:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
    1780:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c
    1784:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
			
            switch(pInformation->Current_AlternateSetting) {
    1788:	5c656475 	cfstrdpl	mvd6, [r5], #-468	; 0xfffffe2c
    178c:	6863616d 	stmdavs	r3!, {r0, r2, r3, r5, r6, r8, sp, lr}^
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1790:	00656e69 	rsbeq	r6, r5, r9, ror #28
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1794:	705c3a63 	subsvc	r3, ip, r3, ror #20
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1798:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
					userAppEnd = getFlashEnd();
    179c:	66206d61 	strtvs	r6, [r0], -r1, ror #26
    17a0:	73656c69 	cmnvc	r5, #26880	; 0x6900

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    17a4:	38782820 	ldmdacc	r8!, {r5, fp, sp}^
					dfuAppStatus.bStatus = errWRITE;
    17a8:	675c2936 	smmlarvs	ip, r6, r9, r2
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    17ac:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17b0:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17b4:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    17b8:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17bc:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
    17c0:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}
    17c4:	30322038 	eorscc	r2, r2, r8, lsr r0

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17c8:	33713431 	cmncc	r1, #822083584	; 0x31000000
                dfuCopyBufferToExec();
    17cc:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17d0:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    17d4:	61652d65 	cmnvs	r5, r5, ror #26
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    17d8:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^
    17dc:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    17e0:	00006564 	andeq	r6, r0, r4, ror #10
    17e4:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17e8:	632e3931 	teqvs	lr, #802816	; 0xc4000
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    17ec:	00000100 	andeq	r0, r0, r0, lsl #2
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17f0:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
    17f4:	682e3931 	stmdavs	lr!, {r0, r4, r5, r8, fp, ip, sp}
    17f8:	00000100 	andeq	r0, r0, r0, lsl #2
            if (pInformation->USBwLengths.w > 0) {
    17fc:	6665645f 			; <UNDEFINED> instruction: 0x6665645f
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    1800:	746c7561 	strbtvc	r7, [ip], #-1377	; 0x561
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    1804:	7079745f 	rsbsvc	r7, r9, pc, asr r4
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    1808:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    180c:	00000200 	andeq	r0, r0, r0, lsl #4
                }
                switch (ret)
    1810:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    1814:	682e746e 	stmdavs	lr!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
    1818:	00000300 	andeq	r0, r0, r0, lsl #6
                {
                    case kImageImageIsTrusted:
                        uart_printf("Uploaded signature verified!\n");
    181c:	02050000 	andeq	r0, r5, #0
                        break;

                    case kImageImageMissingMagic:
                    case kImageImageRejectSignature:
                        uart_printf("Image unverified... wiped memory for clean reset.\n");
    1820:	00001ec8 	andeq	r1, r0, r8, asr #29
    1824:	25010c03 	strcs	r0, [r1, #-3075]	; 0xc03
                        break;

                    default:
                        break;
                }
                flashLock();
    1828:	04027a3b 	streq	r7, [r2], #-2619	; 0xa3b
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    182c:	00010100 	andeq	r0, r1, r0, lsl #2
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1830:	1ee80205 	cdpne	2, 14, cr0, cr8, cr5, {0}
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1834:	19030000 	stmdbne	r3, {}	; <UNPREDICTABLE>
    1838:	7a032601 	bvc	cb044 <_etext+0xc3b2c>
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuMANIFEST_SYNC) {
    183c:	2d2f2620 	stccs	6, cr2, [pc, #-128]!	; 17c4 <dfuUpdateByRequest+0xc8>
        /* device has received last block, waiting DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1840:	001f1e23 	andseq	r1, pc, r3, lsr #28
    1844:	32020402 	andcc	r0, r2, #33554432	; 0x2000000
            dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    1848:	02040200 	andeq	r0, r4, #0, 4
            dfuAppStatus.bStatus = OK;
    184c:	0402002f 	streq	r0, [r2], #-47	; 0x2f
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1850:	02001e02 	andeq	r1, r0, #2, 28
    1854:	00310204 	eorseq	r0, r1, r4, lsl #4
            dfuAppStatus.bState  = dfuMANIFEST_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuMANIFEST) {
    1858:	2b020402 	blcs	82868 <_etext+0x7b350>
        /* device is in manifestation phase */

        /* should never receive request while in manifest! */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
        dfuAppStatus.bStatus = OK;
    } else if (startState == dfuMANIFEST_WAIT_RESET) {
    185c:	02002006 	andeq	r2, r0, #6
        /* device has programmed new firmware but needs external
           usb reset or power on reset to run the new code */

        /* consider timing out and self-resetting */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    } else if (startState == dfuUPLOAD_IDLE) {
    1860:	03060204 	movweq	r0, #25092	; 0x6204
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
    1864:	02002e0d 	andeq	r2, r0, #13, 28	; 0xd0
    1868:	002f0204 	eoreq	r0, pc, r4, lsl #4
            if (pInformation->USBwLengths.w > 0) {
    186c:	2c020402 	cfstrscs	mvf0, [r2], {2}
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1870:	02040200 	andeq	r0, r4, #0, 4
    1874:	04020031 	streq	r0, [r2], #-49	; 0x31
    1878:	03262b02 	teqeq	r6, #2048	; 0x800
    187c:	6303201d 	movwvs	r2, #12317	; 0x301d
    1880:	3c1a0320 	ldccc	3, cr0, [sl], {32}
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1884:	032e6703 	teqeq	lr, #786432	; 0xc0000
    1888:	73242e19 	teqvc	r4, #400	; 0x190
    188c:	023c6803 	eorseq	r6, ip, #196608	; 0x30000
    1890:	01010004 	tsteq	r1, r4
    1894:	58020500 	stmdapl	r2, {r8, sl}
    1898:	0300001f 	movweq	r0, #31
                    thisBlockLen = uploadBlockLen;
    189c:	025d013c 	subseq	r0, sp, #60, 2
    18a0:	2f2f1431 	svccs	0x002f1431
                    dfuAppStatus.bState  = dfuUPLOAD_IDLE;
                } else {
                    /* if above comparison was just equal, thisBlockLen becomes zero
                    next time when USBWValue has been increased by one */
                    thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
    18a4:	78032f30 	stmdavc	r3, {r4, r5, r8, r9, sl, fp, sp}
    18a8:	2d241d4a 	stccs	13, cr1, [r4, #-296]!	; 0xfffffed8
    18ac:	2d211f21 	stccs	15, cr1, [r1, #-132]!	; 0xffffff7c
    18b0:	01000202 	tsteq	r0, r2, lsl #4
                    
                    /* check for overflow due to USBwValue out of range */
                    if (thisBlockLen >= pInformation->USBwLengths.w) {
    18b4:	02050001 	andeq	r0, r5, #1
    18b8:	00001ff4 	strdeq	r1, [r0], -r4
                        thisBlockLen = 0;
    18bc:	0100cd03 	tsteq	r0, r3, lsl #26
                    }
                    
                    dfuAppStatus.bState  = dfuIDLE;
                }
            } else {
                dfuAppStatus.bState  = dfuERROR;
    18c0:	02be1308 	adcseq	r1, lr, #8, 6	; 0x20000000
                dfuAppStatus.bStatus = errNOTDONE;
    18c4:	4b1f1332 	blmi	7c6594 <_etext+0x7bf07c>
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    18c8:	3e65211e 	mcrcc	1, 3, r2, cr5, cr14, {0}
            dfuAppStatus.bState  = dfuIDLE;
    18cc:	01000202 	tsteq	r0, r2, lsl #4
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18d0:	02050001 	andeq	r0, r5, #1
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18d4:	000020b8 	strheq	r2, [r0], -r8
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    18d8:	0100d603 	tsteq	r0, r3, lsl #12
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuERROR)               {
    18dc:	00211b17 	eoreq	r1, r1, r7, lsl fp
        /* status is in error, awaiting DFU_CLRSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18e0:	26020402 	strcs	r0, [r2], -r2, lsl #8
    18e4:	02040200 	andeq	r0, r4, #0, 4
    18e8:	04020059 	streq	r0, [r2], #-89	; 0x59
            /* todo, add routine to wait for last block write to finish */
            dfuAppStatus.bState  = dfuERROR;
    18ec:	2d441d02 	stclcs	13, cr1, [r4, #-8]
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18f0:	2d2f2d21 	stccs	13, cr2, [pc, #-132]!	; 1874 <dfuUpdateByRequest+0x178>
            dfuAppStatus.bState  = dfuERROR;
        } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
    18f4:	02002221 	andeq	r2, r0, #268435458	; 0x10000002
            /* todo handle any cleanup we need here */
            dfuAppStatus.bState  = dfuIDLE;
    18f8:	00210204 	eoreq	r0, r1, r4, lsl #4
            dfuAppStatus.bStatus = OK;
    18fc:	3d020402 	cfstrscc	mvf0, [r2, #-8]
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else {
        /* some kind of error... */
        dfuAppStatus.bState  = dfuERROR;
    1900:	02040200 	andeq	r0, r4, #0, 4
        dfuAppStatus.bStatus = errSTALLEDPKT;
    1904:	0402001e 	streq	r0, [r2], #-30
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}
    1908:	02003102 	andeq	r3, r0, #-2147483648	; 0x80000000
    190c:	252b0204 	strcs	r0, [fp, #-516]!	; 0x204
    1910:	01000202 	tsteq	r0, r2, lsl #4
    1914:	02050001 	andeq	r0, r5, #1
    1918:	00002100 	andeq	r2, r0, r0, lsl #2
    191c:	0100ed03 	tsteq	r0, r3, lsl #26
    1920:	02001f26 	andeq	r1, r0, #38, 30	; 0x98
    1924:	00220204 	eoreq	r0, r2, r4, lsl #4
    1928:	67020402 	strvs	r0, [r2, -r2, lsl #8]
    192c:	02040200 	andeq	r0, r4, #0, 4
    1930:	0402001e 	streq	r0, [r2], #-30
    1934:	02003102 	andeq	r3, r0, #-2147483648	; 0x80000000
    1938:	262b0204 	strtcs	r0, [fp], -r4, lsl #4
    193c:	3b301c32 	blcc	c08a0c <_etext+0xc014f4>
    1940:	0402003d 	streq	r0, [r2], #-61	; 0x3d
    1944:	02003102 	andeq	r3, r0, #-2147483648	; 0x80000000
    1948:	002f0204 	eoreq	r0, pc, r4, lsl #4
    194c:	1e020402 	cdpne	4, 0, cr0, cr2, cr2, {0}
    dfuAppStatus.bState = newState;
}

bool dfuUploadStarted()
{
    return dfuBusy;
    1950:	02040200 	andeq	r0, r4, #0, 4
}
    1954:	04020031 	streq	r0, [r2], #-49	; 0x31
    1958:	02252b02 	eoreq	r2, r5, #2048	; 0x800

void dfuFinishUpload() {

    while (1)
	{
		__asm__ __volatile__ ("");
    195c:	01010002 	tsteq	r1, r2
};

/* Conversion to and from projective coordinates */
void ed25519_project(struct ed25519_pt *p,
		     const uint8_t *x, const uint8_t *y)
{
    1960:	4c020500 	cfstr32mi	mvfx0, [r2], {-0}
    1964:	03000021 	movweq	r0, #33	; 0x21
    1968:	26010185 	strcs	r0, [r1], -r5, lsl #3
    196c:	0402001f 	streq	r0, [r2], #-31
    1970:	02002202 	andeq	r2, r0, #536870912	; 0x20000000
    1974:	004b0204 	subeq	r0, fp, r4, lsl #4
    1978:	1e020402 	cdpne	4, 0, cr0, cr2, cr2, {0}
    197c:	02040200 	andeq	r0, r4, #0, 4
    1980:	04020031 	streq	r0, [r2], #-49	; 0x31
    1984:	24262b02 	strtcs	r2, [r6], #-2818	; 0xb02
    1988:	2f1f221c 	svccs	0x001f221c
    198c:	0200212d 	andeq	r2, r0, #1073741835	; 0x4000000b
    1990:	00310204 	eorseq	r0, r1, r4, lsl #4
    1994:	2f020402 	svccs	0x00020402
    1998:	02040200 	andeq	r0, r4, #0, 4
    199c:	0402001e 	streq	r0, [r2], #-30
    19a0:	02003102 	andeq	r3, r0, #-2147483648	; 0x80000000
    19a4:	252b0204 	strcs	r0, [fp, #-516]!	; 0x204
    19a8:	01000302 	tsteq	r0, r2, lsl #6
    19ac:	02050001 	andeq	r0, r5, #1
    19b0:	00002194 	muleq	r0, r4, r1
    19b4:	01019d03 	tsteq	r1, r3, lsl #26
    19b8:	0b032b32 	bleq	cc688 <_etext+0xc5170>
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
    19bc:	003d2920 	eorseq	r2, sp, r0, lsr #18
	f25519_mul__distinct(p->t, x, y);
    19c0:	21020402 	tstcs	r2, r2, lsl #8
    19c4:	02040200 	andeq	r0, r4, #0, 4
}
    19c8:	0402003b 	streq	r0, [r2], #-59	; 0x3b
		     const uint8_t *x, const uint8_t *y)
{
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
	f25519_mul__distinct(p->t, x, y);
    19cc:	02002f02 	andeq	r2, r0, #2, 30
}

void ed25519_unproject(uint8_t *x, uint8_t *y,
		       const struct ed25519_pt *p)
{
    19d0:	002d0204 	eoreq	r0, sp, r4, lsl #4
    19d4:	4d010402 	cfstrsmi	mvf0, [r1, #-8]
    19d8:	02040200 	andeq	r0, r4, #0, 4
	uint8_t z1[F25519_SIZE];

	f25519_inv__distinct(z1, p->z);
    19dc:	04020076 	streq	r0, [r2], #-118	; 0x76
    19e0:	02002d02 	andeq	r2, r0, #2, 26	; 0x80
	f25519_mul__distinct(x, p->x, z1);
    19e4:	00490204 	subeq	r0, r9, r4, lsl #4
    19e8:	2f020402 	svccs	0x00020402
    19ec:	02040200 	andeq	r0, r4, #0, 4
	f25519_mul__distinct(y, p->y, z1);
    19f0:	7503242d 	strvc	r2, [r3, #-1069]	; 0x42d
    19f4:	580e032e 	stmdapl	lr, {r1, r2, r3, r5, r8, r9}
    19f8:	2d2f3b21 	fstmdbxcs	pc!, {d3-d18}	;@ Deprecated

	f25519_normalize(x);
    19fc:	04020023 	streq	r0, [r2], #-35	; 0x23
	f25519_normalize(y);
    1a00:	02002102 	andeq	r2, r0, #-2147483648	; 0x80000000
    1a04:	002f0204 	eoreq	r0, pc, r4, lsl #4
}
    1a08:	1e020402 	cdpne	4, 0, cr0, cr2, cr2, {0}
	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
};

void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y)
{
    1a0c:	02040200 	andeq	r0, r4, #0, 4
    1a10:	04020031 	streq	r0, [r2], #-49	; 0x31
    1a14:	02252b02 	eoreq	r2, r5, #2048	; 0x800
    1a18:	01010003 	tsteq	r1, r3
    1a1c:	00020500 	andeq	r0, r2, r0, lsl #10
    1a20:	03000000 	movweq	r0, #0
    1a24:	030101ba 	movweq	r0, #4538	; 0x11ba
    1a28:	19032e67 	stmdbne	r3, {r0, r1, r2, r5, r6, r9, sl, fp, sp}
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
    1a2c:	2e64032e 	cdpcs	3, 6, cr0, cr4, cr14, {1}
    1a30:	1b200b03 	blne	804644 <_etext+0x7fd12c>
    1a34:	2f3b213d 	svccs	0x003b213d
    1a38:	2d764d2d 	ldclcs	13, cr4, [r6, #-180]!	; 0xffffff4c
    1a3c:	242d2f49 	strtcs	r2, [sp], #-3913	; 0xf49
    1a40:	032e7503 	teqeq	lr, #12582912	; 0xc00000
    1a44:	3b2f580e 	blcc	bd7a84 <_etext+0xbd056c>
    1a48:	2f4e2d2f 	svccs	0x004e2d2f
    1a4c:	042b232c 	strteq	r2, [fp], #-812	; 0x32c
    1a50:	7ef10302 	cdpvc	3, 15, cr0, cr1, cr2, {0}
	parity = (tmp[0] & 1) << 7;
    1a54:	03010420 	movweq	r0, #5152	; 0x1420

	f25519_copy(c, y);
	f25519_normalize(c);
    1a58:	2e08019c 	mcrcs	1, 0, r0, cr8, cr12, {4}
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1a5c:	01000402 	tsteq	r0, r2, lsl #8
    1a60:	02050001 	andeq	r0, r5, #1

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1a64:	00000000 	andeq	r0, r0, r0
}
    1a68:	0101c203 	tsteq	r1, r3, lsl #4

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1a6c:	00211c16 	eoreq	r1, r1, r6, lsl ip
    1a70:	25020402 	strcs	r0, [r2, #-1026]	; 0x402
    1a74:	02040200 	andeq	r0, r4, #0, 4
    1a78:	04020059 	streq	r0, [r2], #-89	; 0x59
	const int parity = comp[31] >> 7;
    1a7c:	21421d02 	cmpcs	r2, r2, lsl #26
    1a80:	222c301f 	eorcs	r3, ip, #31
    1a84:	04020030 	streq	r0, [r2], #-48	; 0x30
    1a88:	02002102 	andeq	r2, r0, #-2147483648	; 0x80000000
    1a8c:	002f0204 	eoreq	r0, pc, r4, lsl #4
    1a90:	1e020402 	cdpne	4, 0, cr0, cr2, cr2, {0}
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1a94:	02040200 	andeq	r0, r4, #0, 4
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1a98:	04020031 	streq	r0, [r2], #-49	; 0x31
    1a9c:	02252b02 	eoreq	r2, r5, #2048	; 0x800
    1aa0:	01010002 	tsteq	r1, r2
    1aa4:	1c020500 	cfstr32ne	mvfx0, [r2], {-0}
    1aa8:	03000022 	movweq	r0, #34	; 0x22
	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
	f25519_add(a, b, f25519_one);
    1aac:	030101d8 	movweq	r0, #4568	; 0x11d8
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1ab0:	37032e49 	strcc	r2, [r3, -r9, asr #28]

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
    1ab4:	20460320 	subcs	r0, r6, r0, lsr #6
    1ab8:	29200b03 	stmdbcs	r0!, {r0, r1, r8, r9, fp}
	f25519_add(a, b, f25519_one);
    1abc:	2f3b212f 	svccs	0x003b212f
    1ac0:	2d684d2d 	stclcs	13, cr4, [r8, #-180]!	; 0xffffff4c
    1ac4:	242d2f49 	strtcs	r2, [sp], #-3913	; 0xf49
	f25519_inv__distinct(b, a);
    1ac8:	032e7503 	teqeq	lr, #12582912	; 0xc00000
    1acc:	3b2f3c0e 	blcc	bd0b0c <_etext+0xbc95f4>

	/* Compute a = y^2-1 */
	f25519_sub(a, c, f25519_one);
    1ad0:	233d2d2f 	teqcs	sp, #3008	; 0xbc0
    1ad4:	2b232c2f 	blcs	8ccb98 <_etext+0x8c5680>

	/* Compute c = a*b = (y^2-1)/(1-dy^2) */
	f25519_mul__distinct(c, a, b);
    1ad8:	29747703 	ldmdbcs	r4!, {r0, r1, r8, r9, sl, ip, sp, lr}^
    1adc:	2f49212f 	svccs	0x0049212f
    1ae0:	2d763f2d 	ldclcs	15, cr3, [r6, #-180]!	; 0xffffff4c

	/* Compute a, b = +/-sqrt(c), if c is square */
	f25519_sqrt(a, c);
    1ae4:	242d2149 	strtcs	r2, [sp], #-329	; 0x149
    1ae8:	03207503 	teqeq	r0, #12582912	; 0xc00000
	f25519_neg(b, a);
    1aec:	3b213c0e 	blcc	850b2c <_etext+0x849614>
    1af0:	21232d2f 	teqcs	r3, pc, lsr #26

	/* Select one of them, based on the compressed parity bit */
	f25519_select(x, a, b, (a[0] ^ parity) & 1);
    1af4:	2b311e2f 	blcs	c493b8 <_etext+0xc41ea0>
    1af8:	033c7703 	teqeq	ip, #786432	; 0xc0000
    1afc:	72033c09 	andvc	r3, r3, #2304	; 0x900
    1b00:	49213d3c 	stmdbmi	r1!, {r2, r3, r4, r5, r8, sl, fp, ip, sp}
    1b04:	844d2d2f 	strbhi	r2, [sp], #-3375	; 0xd2f

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
    1b08:	2d2f492d 	stccs	9, cr4, [pc, #-180]!	; 1a5c <ed25519_pack+0x50>
    1b0c:	2e750324 	cdpcs	3, 7, cr0, cr5, cr4, {1}
    1b10:	2f580e03 	svccs	0x00580e03
	f25519_normalize(a);
    1b14:	2f2d2f3b 	svccs	0x002d2f3b
	f25519_normalize(c);
    1b18:	232c2f23 	teqcs	ip, #35, 30	; 0x8c
    1b1c:	4a72032b 	bmi	1c827d0 <_etext+0x1c7b2b8>

	return f25519_eq(a, c);
    1b20:	2f49213d 	svccs	0x0049213d
    1b24:	2d923f2d 	ldccs	15, cr3, [r2, #180]	; 0xb4
}
    1b28:	242d2149 	strtcs	r2, [sp], #-329	; 0x149
    1b2c:	032e7503 	teqeq	lr, #12582912	; 0xc00000
    1b30:	3b21580e 	blcc	857b70 <_etext+0x850658>
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1b34:	21232d2f 	teqcs	r3, pc, lsr #26
    1b38:	2b311e2f 	blcs	c493fc <_etext+0xc41ee4>
    1b3c:	02040200 	andeq	r0, r4, #0, 4
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b40:	06203f03 	strteq	r3, [r0], -r3, lsl #30
    1b44:	b803064a 	stmdalt	r3, {r1, r3, r6, r9, sl}
    1b48:	3d29207f 	stccc	0, cr2, [r9, #-508]!	; 0xfffffe04
	f25519_sub(d, p2->y, p2->x);
    1b4c:	2d2f3b21 	fstmdbxcs	pc!, {d3-d18}	;@ Deprecated
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b50:	492d764d 	pushmi	{r0, r2, r3, r6, r9, sl, ip, sp, lr}
	f25519_sub(d, p2->y, p2->x);
    1b54:	03242d2f 	teqeq	r4, #3008	; 0xbc0
    1b58:	0e032e75 	mcreq	14, 0, r2, cr3, cr5, {3}
	f25519_mul__distinct(a, c, d);
    1b5c:	2f3b2f58 	svccs	0x003b2f58
    1b60:	2f232f2d 	svccs	0x00232f2d
    1b64:	032b232c 	teqeq	fp, #44, 6	; 0xb0000000

	/* B = (Y1+X1)(Y2+X2) */
	f25519_add(c, p1->y, p1->x);
    1b68:	2f377477 	svccs	0x00377477
    1b6c:	2d2f4921 	stccs	9, cr4, [pc, #-132]!	; 1af0 <ed25519_try_unpack+0x84>
	f25519_add(d, p2->y, p2->x);
    1b70:	492d763f 	pushmi	{r0, r1, r2, r3, r4, r5, r9, sl, ip, sp, lr}
    1b74:	03242d21 	teqeq	r4, #2112	; 0x840
    1b78:	0e032075 	mcreq	0, 0, r2, cr3, cr5, {3}
	f25519_mul__distinct(b, c, d);
    1b7c:	2f3b213c 	svccs	0x003b213c
    1b80:	2f21232d 	svccs	0x0021232d

	/* C = T1 k T2 */
	f25519_mul__distinct(d, p1->t, p2->t);
    1b84:	032b311e 	teqeq	fp, #-2147483641	; 0x80000007
    1b88:	2f293c77 	svccs	0x00293c77
    1b8c:	2d2f4921 	stccs	9, cr4, [pc, #-132]!	; 1b10 <ed25519_try_unpack+0xa4>
    1b90:	492d684d 	pushmi	{r0, r2, r3, r6, fp, sp, lr}
	f25519_mul__distinct(c, d, ed25519_k);
    1b94:	03242d2f 	teqeq	r4, #3008	; 0xbc0
    1b98:	0e032e75 	mcreq	14, 0, r2, cr3, cr5, {3}

	/* D = Z1 2 Z2 */
	f25519_mul__distinct(d, p1->z, p2->z);
    1b9c:	2f3b2f3c 	svccs	0x003b2f3c
    1ba0:	2f232f2d 	svccs	0x00232f2d
    1ba4:	032b232c 	teqeq	fp, #44, 6	; 0xb0000000
    1ba8:	2f377477 	svccs	0x00377477
	f25519_add(d, d, d);
    1bac:	2d2f4921 	stccs	9, cr4, [pc, #-132]!	; 1b30 <ed25519_try_unpack+0xc4>
    1bb0:	492d763f 	pushmi	{r0, r1, r2, r3, r4, r5, r9, sl, ip, sp, lr}

	/* E = B - A */
	f25519_sub(e, b, a);
    1bb4:	03242d21 	teqeq	r4, #2112	; 0x840
    1bb8:	0e032075 	mcreq	0, 0, r2, cr3, cr5, {3}
    1bbc:	2f3b213c 	svccs	0x003b213c

	/* F = D - C */
	f25519_sub(f, d, c);
    1bc0:	2f21232d 	svccs	0x0021232d
    1bc4:	032b311e 	teqeq	fp, #-2147483641	; 0x80000007

	/* G = D + C */
	f25519_add(g, d, c);
    1bc8:	2f293c77 	svccs	0x00293c77
    1bcc:	2d2f4921 	stccs	9, cr4, [pc, #-132]!	; 1b50 <ed25519_add+0x1c>
    1bd0:	492d684d 	pushmi	{r0, r2, r3, r6, fp, sp, lr}

	/* H = B + A */
	f25519_add(h, b, a);
    1bd4:	03242d2f 	teqeq	r4, #3008	; 0xbc0
    1bd8:	0e032e75 	mcreq	14, 0, r2, cr3, cr5, {3}

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1bdc:	2f3b2f3c 	svccs	0x003b2f3c
    1be0:	2f232f2d 	svccs	0x00232f2d
    1be4:	032b232c 	teqeq	fp, #44, 6	; 0xb0000000

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1be8:	2f297477 	svccs	0x00297477
    1bec:	2d2f4921 	stccs	9, cr4, [pc, #-132]!	; 1b70 <ed25519_add+0x3c>
    1bf0:	492d763f 	pushmi	{r0, r1, r2, r3, r4, r5, r9, sl, ip, sp, lr}

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1bf4:	03242d21 	teqeq	r4, #2112	; 0x840
    1bf8:	0e032075 	mcreq	0, 0, r2, cr3, cr5, {3}
    1bfc:	2f3b213c 	svccs	0x003b213c

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1c00:	2f21232d 	svccs	0x0021232d
    1c04:	032b311e 	teqeq	fp, #-2147483641	; 0x80000007
    1c08:	2f293c77 	svccs	0x00293c77
}
    1c0c:	2d2f4921 	stccs	9, cr4, [pc, #-132]!	; 1b90 <ed25519_add+0x5c>
    1c10:	492d684d 	pushmi	{r0, r2, r3, r6, fp, sp, lr}

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1c14:	03242d2f 	teqeq	r4, #3008	; 0xbc0
    1c18:	0e032e75 	mcreq	14, 0, r2, cr3, cr5, {3}

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1c1c:	2f3b2f3c 	svccs	0x003b2f3c
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1c20:	2f232f2d 	svccs	0x00232f2d
    1c24:	032b232c 	teqeq	fp, #44, 6	; 0xb0000000

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1c28:	2f297477 	svccs	0x00297477
    1c2c:	2d2f4921 	stccs	9, cr4, [pc, #-132]!	; 1bb0 <ed25519_add+0x7c>
    1c30:	492d763f 	pushmi	{r0, r1, r2, r3, r4, r5, r9, sl, ip, sp, lr}

	/* C = 2 Z1^2 */
	f25519_mul__distinct(c, p->z, p->z);
    1c34:	03242d21 	teqeq	r4, #2112	; 0x840
    1c38:	0e032075 	mcreq	0, 0, r2, cr3, cr5, {3}
    1c3c:	2f3b213c 	svccs	0x003b213c
	f25519_add(c, c, c);
    1c40:	2f21232d 	svccs	0x0021232d
    1c44:	032b311e 	teqeq	fp, #-2147483641	; 0x80000007

	/* D = a A (alter sign) */
	/* E = (X1+Y1)^2-A-B */
	f25519_add(f, p->x, p->y);
    1c48:	022000d5 	eoreq	r0, r0, #213	; 0xd5
    1c4c:	01010004 	tsteq	r1, r4
    1c50:	00020500 	andeq	r0, r2, r0, lsl #10
	f25519_mul__distinct(e, f, f);
    1c54:	03000000 	movweq	r0, #0
    1c58:	2e01028a 	cdpcs	2, 0, cr0, cr1, cr10, {4}
	f25519_sub(e, e, a);
    1c5c:	03020423 	movweq	r0, #9251	; 0x2423
    1c60:	043c7e96 	ldrteq	r7, [ip], #-3734	; 0xe96
    1c64:	01ec0301 	mvneq	r0, r1, lsl #6
	f25519_sub(e, e, b);
    1c68:	000202ac 	andeq	r0, r2, ip, lsr #5
    1c6c:	05000101 	streq	r0, [r0, #-257]	; 0x101

	/* G = D + B */
	f25519_sub(g, b, a);
    1c70:	00280802 	eoreq	r0, r8, r2, lsl #16
    1c74:	02b00300 	adcseq	r0, r0, #0, 6
    1c78:	7f960301 	svcvc	0x00960301

	/* F = G - C */
	f25519_sub(f, g, c);
    1c7c:	00ea032e 	rsceq	r0, sl, lr, lsr #6
    1c80:	93032020 	movwls	r2, #12320	; 0x3020

	/* H = D - B */
	f25519_neg(h, b);
    1c84:	4b412e7f 	blmi	104d688 <_etext+0x1046170>
    1c88:	1f2f421d 	svcne	0x002f421d
	f25519_sub(h, h, a);
    1c8c:	4d302c30 	ldcmi	12, cr2, [r0, #-192]!	; 0xffffff40
    1c90:	2b232c2f 	blcs	8ccd54 <_etext+0x8c583c>
    1c94:	1b585903 	blne	16180a8 <_etext+0x1610b90>

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1c98:	2f49212f 	svccs	0x0049212f
    1c9c:	2d683f2d 	stclcs	15, cr3, [r8, #-180]!	; 0xffffff4c

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1ca0:	242d2149 	strtcs	r2, [sp], #-329	; 0x149
    1ca4:	032e7503 	teqeq	lr, #12582912	; 0xc00000
    1ca8:	3b2f3c0e 	blcc	bd0ce8 <_etext+0xbc97d0>

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1cac:	233d2d2f 	teqcs	sp, #3008	; 0xbc0
    1cb0:	2b232c2f 	blcs	8ccd74 <_etext+0x8c585c>
    1cb4:	1b587703 	blne	161f8c8 <_etext+0x16183b0>

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1cb8:	2f65212f 	svccs	0x0065212f
    1cbc:	2d683f2d 	stclcs	15, cr3, [r8, #-180]!	; 0xffffff4c
    1cc0:	242d2149 	strtcs	r2, [sp], #-329	; 0x149
}
    1cc4:	03207503 	teqeq	r0, #12582912	; 0xc00000

void ed25519_smult(struct ed25519_pt *r_out, const struct ed25519_pt *p,
		   const uint8_t *e)
{
    1cc8:	572f3c0e 	strpl	r3, [pc, -lr, lsl #24]!
    1ccc:	314b2d2f 	cmpcc	fp, pc, lsr #26
    1cd0:	2b232c2f 	blcs	8ccd94 <_etext+0x8c587c>
    1cd4:	43587703 	cmpmi	r8, #786432	; 0xc0000
    1cd8:	3d3c7403 	cfldrscc	mvf7, [ip, #-12]!
    1cdc:	2d2f4921 	stccs	9, cr4, [pc, #-132]!	; 1c60 <ed25519_double+0x4c>
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1ce0:	492d843f 	pushmi	{r0, r1, r2, r3, r4, r5, sl, pc}
    1ce4:	03242d21 	teqeq	r4, #2112	; 0x840
    1ce8:	0e034a75 	mcreq	10, 0, r4, cr3, cr5, {3}
		struct ed25519_pt s;

		ed25519_double(&r, &r);
    1cec:	2f3b2f58 	svccs	0x003b2f58
    1cf0:	3d232f2d 	stccc	15, cr2, [r3, #-180]!	; 0xffffff4c
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1cf4:	032b232c 	teqeq	fp, #44, 6	; 0xb0000000
		struct ed25519_pt s;

		ed25519_double(&r, &r);
		ed25519_add(&s, &r, p);
    1cf8:	213d4a72 	teqcs	sp, r2, ror sl
    1cfc:	3f2d2f65 	svccc	0x002d2f65

		f25519_select(r.x, r.x, s.x, bit);
    1d00:	21492d84 	smlalbbcs	r2, r9, r4, sp
    1d04:	7503242d 	strvc	r2, [r3, #-1069]	; 0x42d
    1d08:	580e032e 	stmdapl	lr, {r1, r2, r3, r5, r8, r9}
		f25519_select(r.y, r.y, s.y, bit);
    1d0c:	2d2f3b2f 	fstmdbxcs	pc!, {d3-d25}	;@ Deprecated
    1d10:	303b232f 	eorscc	r2, fp, pc, lsr #6
    1d14:	032b232c 	teqeq	fp, #44, 6	; 0xb0000000
		f25519_select(r.z, r.z, s.z, bit);
    1d18:	032000f0 	teqeq	r0, #240	; 0xf0
    1d1c:	1b907f87 	blne	fe421b40 <BootRAM+0xd3922e1>
    1d20:	2f49212f 	svccs	0x0049212f
		f25519_select(r.t, r.t, s.t, bit);
    1d24:	2d683f2d 	stclcs	15, cr3, [r8, #-180]!	; 0xffffff4c
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d28:	242d2149 	strtcs	r2, [sp], #-329	; 0x149
		ed25519_add(&s, &r, p);

		f25519_select(r.x, r.x, s.x, bit);
		f25519_select(r.y, r.y, s.y, bit);
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
    1d2c:	034a7503 	movteq	r7, #42243	; 0xa503
    1d30:	3b2f3c0e 	blcc	bd0d70 <_etext+0xbc9858>
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d34:	232f2d2f 	teqcs	pc, #3008	; 0xbc0
    1d38:	2b232c2f 	blcs	8ccdfc <_etext+0x8c58e4>
    1d3c:	29587703 	ldmdbcs	r8, {r0, r1, r8, r9, sl, ip, sp, lr}^
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
	}

	ed25519_copy(r_out, &r);
}
    1d40:	2f65212f 	svccs	0x0065212f
    1d44:	2d683f2d 	stclcs	15, cr3, [r8, #-180]!	; 0xffffff4c
    1d48:	242d2149 	strtcs	r2, [sp], #-329	; 0x149
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1d4c:	03207503 	teqeq	r0, #12582912	; 0xc00000
    1d50:	3b2f3c0e 	blcc	bd0d90 <_etext+0xbc9878>
    1d54:	232f2d2f 	teqcs	pc, #3008	; 0xbc0
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d58:	232c222d 	teqcs	ip, #-805306366	; 0xd0000002
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1d5c:	5877032b 	ldmdapl	r7!, {r0, r1, r3, r5, r8, r9}^
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d60:	49212f1b 	stmdbmi	r1!, {r0, r1, r3, r4, r8, r9, sl, fp, sp}
    1d64:	683f2d2f 	ldmdavs	pc!, {r0, r1, r2, r3, r5, r8, sl, fp, sp}	; <UNPREDICTABLE>
    1d68:	2d21492d 	stccs	9, cr4, [r1, #-180]!	; 0xffffff4c
    1d6c:	2e750324 	cdpcs	3, 7, cr0, cr5, cr4, {1}
	memcpy(block + 32, a, 32);
    1d70:	2f3c0e03 	svccs	0x003c0e03
    1d74:	2f2d2f3b 	svccs	0x002d2f3b
    1d78:	232c2f23 	teqcs	ip, #35, 30	; 0x8c
    1d7c:	5877032b 	ldmdapl	r7!, {r0, r1, r3, r5, r8, r9}^
    1d80:	65212f29 	strvs	r2, [r1, #-3881]!	; 0xf29
    1d84:	683f2d2f 	ldmdavs	pc!, {r0, r1, r2, r3, r5, r8, sl, fp, sp}	; <UNPREDICTABLE>
    1d88:	2d21492d 	stccs	9, cr4, [r1, #-180]!	; 0xffffff4c
    1d8c:	20750324 	rsbscs	r0, r5, r4, lsr #6
    1d90:	2f3c0e03 	svccs	0x003c0e03
    1d94:	2f2d4b3b 	svccs	0x002d4b3b
    1d98:	232c2f23 	teqcs	ip, #35, 30	; 0x8c
    1d9c:	5877032b 	ldmdapl	r7!, {r0, r1, r3, r5, r8, r9}^
{
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
    1da0:	49212f1b 	stmdbmi	r1!, {r0, r1, r3, r4, r8, r9, sl, fp, sp}
    1da4:	683f2d2f 	ldmdavs	pc!, {r0, r1, r2, r3, r5, r8, sl, fp, sp}	; <UNPREDICTABLE>
    1da8:	2d21492d 	stccs	9, cr4, [r1, #-180]!	; 0xffffff4c
		memcpy(init_block + prefix_size, message, len);
		sha512_final(&s, init_block, len + prefix_size);
	} else {
		size_t i;

		memcpy(init_block + prefix_size, message,
    1dac:	20750324 	rsbscs	r0, r5, r4, lsr #6
    1db0:	2f3c0e03 	svccs	0x003c0e03
    1db4:	2f2d2f3b 	svccs	0x002d2f3b
    1db8:	232c2f23 	teqcs	ip, #35, 30	; 0x8c
    1dbc:	7ede032b 	cdpvc	3, 13, cr0, cr14, cr11, {1}
    1dc0:	00e4032e 	rsceq	r0, r4, lr, lsr #6
    1dc4:	311e679e 			; <UNDEFINED> instruction: 0x311e679e
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);
    1dc8:	1e4c262b 	cdpne	6, 4, cr2, cr12, cr11, {1}
    1dcc:	314b3b30 	cmpcc	fp, r0, lsr fp

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dd0:	2b232c2f 	blcs	8cce94 <_etext+0x8c597c>
    1dd4:	032e2c03 	teqeq	lr, #768	; 0x300
    1dd8:	2c032e54 	stccs	14, cr2, [r3], {84}	; 0x54
    1ddc:	213d1b3c 	teqcs	sp, ip, lsr fp
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1de0:	3f2d2f65 	svccc	0x002d2f65
		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
		     i + SHA512_BLOCK_SIZE <= len;
    1de4:	21492d68 	cmpcs	r9, r8, ror #26
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1de8:	7503242d 	strvc	r2, [r3, #-1069]	; 0x42d

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dec:	3c0e0320 	stccc	3, cr0, [lr], {32}
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
    1df0:	2d2f3b2f 	fstmdbxcs	pc!, {d3-d25}	;@ Deprecated
    1df4:	2c2f232f 	stccs	3, cr2, [pc], #-188	; 1d40 <ed25519_smult+0x78>
    1df8:	77032b23 	strvc	r2, [r3, -r3, lsr #22]
    1dfc:	212f2958 	teqcs	pc, r8, asr r9	; <UNPREDICTABLE>
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
		memcpy(init_block + prefix_size, message, len);
    1e00:	3f2d2f3b 	svccc	0x002d2f3b
    1e04:	21492d68 	cmpcs	r9, r8, ror #26
    1e08:	7503242d 	strvc	r2, [r3, #-1069]	; 0x42d
		sha512_final(&s, init_block, len + prefix_size);
    1e0c:	3c0f032e 	stccc	3, cr0, [pc], {46}	; 0x2e
    1e10:	4d49211f 	stfmie	f2, [r9, #-124]	; 0xffffff84
    1e14:	311e2f2f 	tstcc	lr, pc, lsr #30
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
	}

	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
    1e18:	0191032b 	orrseq	r0, r1, fp, lsr #6
    1e1c:	00040220 	andeq	r0, r4, r0, lsr #4
    1e20:	03fa0101 	mvnseq	r0, #1073741824	; 0x40000000
	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
    1e24:	00020000 	andeq	r0, r2, r0
    1e28:	00000160 	andeq	r0, r0, r0, ror #2
    1e2c:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}

static void sm_pack(uint8_t *r, const uint8_t *k)
{
	struct ed25519_pt p;

	ed25519_smult(&p, &ed25519_base, k);
    1e30:	0101000d 	tsteq	r1, sp
    1e34:	00000101 	andeq	r0, r0, r1, lsl #2
    1e38:	00000100 	andeq	r0, r0, r0, lsl #2
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1e3c:	35353201 	ldrcc	r3, [r5, #-513]!	; 0x201
    1e40:	63003931 	movwvs	r3, #2353	; 0x931
	ed25519_pack(packed, x, y);
    1e44:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
    1e48:	6172676f 	cmnvs	r2, pc, ror #14
    1e4c:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e50:	2073656c 	rsbscs	r6, r3, ip, ror #10
    1e54:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16

	ed25519_project(p, x, y);
    1e58:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
    1e5c:	6f742075 	svcvs	0x00742075
    1e60:	20736c6f 	rsbscs	r6, r3, pc, ror #24
	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
    1e64:	206d7261 	rsbcs	r7, sp, r1, ror #4
    1e68:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
    1e6c:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e70:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    1e74:	31303220 	teqcc	r0, r0, lsr #4

	ed25519_project(p, x, y);
    1e78:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
    1e7c:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    1e80:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
    1e84:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    1e88:	6e695c69 	cdpvs	12, 6, cr5, cr9, cr9, {3}
    1e8c:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1e90:	616d5c65 	cmnvs	sp, r5, ror #24
    1e94:	6e696863 	cdpvs	8, 6, cr6, cr9, cr3, {3}
	ed25519_pack(packed, x, y);
    1e98:	3a630065 	bcc	18c2034 <_etext+0x18bab1c>
    1e9c:	6f72705c 	svcvs	0x0072705c
    1ea0:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
    1ea4:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
    1ea8:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
    1eac:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
}
    1eb0:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
    1eb4:	6f6f7420 	svcvs	0x006f7420

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1eb8:	6120736c 	teqvs	r0, ip, ror #6
    1ebc:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
    1ec0:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
    1ec4:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70

const uint8_t f25519_zero[F25519_SIZE] = {0};
const uint8_t f25519_one[F25519_SIZE] = {1};

void f25519_load(uint8_t *x, uint32_t c)
{
    1ec8:	20382e34 	eorscs	r2, r8, r4, lsr lr
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
		c >>= 8;
    1ecc:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    1ed0:	615c3371 	cmpvs	ip, r1, ror r3
    1ed4:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    1ed8:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    1edc:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
		c >>= 8;
	}

	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}
    1ee0:	636e695c 	cmnvs	lr, #92, 18	; 0x170000
    1ee4:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c

void f25519_normalize(uint8_t *x)
{
    1ee8:	5c3a6300 	ldcpl	3, cr6, [sl], #-0
    1eec:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1ef0:	206d6172 	rsbcs	r6, sp, r2, ror r1
	x[31] &= 127;
    1ef4:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966

	for (i = 0; i < F25519_SIZE; i++) {
    1ef8:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1efc:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
		c += x[i];
    1f00:	20756e67 	rsbscs	r6, r5, r7, ror #28
		x[i] = c;
    1f04:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; 1d3c <ed25519_smult+0x74>

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1f08:	72612073 	rsbvc	r2, r1, #115	; 0x73
		c += x[i];
		x[i] = c;
		c >>= 8;
    1f0c:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1f10:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += x[i];
    1f14:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465
		minusp[i] = c;
    1f18:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1f1c:	71343130 	teqvc	r4, r0, lsr r1
		c += x[i];
		minusp[i] = c;
		c >>= 8;
    1f20:	696c5c33 	stmdbvs	ip!, {r0, r1, r4, r5, sl, fp, ip, lr}^
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1f24:	63675c62 	cmnvs	r7, #25088	; 0x6200
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1f28:	72615c63 	rsbvc	r5, r1, #25344	; 0x6300
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1f2c:	6f6e2d6d 	svcvs	0x006e2d6d

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1f30:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;
    1f34:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1f38:	2e382e34 	mrccs	14, 1, r2, cr8, cr4, {1}
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    1f3c:	6e695c34 	mcrvs	12, 3, r5, cr9, cr4, {1}
    1f40:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
    1f44:	66000065 	strvs	r0, [r0], -r5, rrx
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1f48:	6d697270 	sfmvs	f7, 2, [r9, #-448]!	; 0xfffffe40
    1f4c:	00632e65 	rsbeq	r2, r3, r5, ror #28
	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;

	/* Load x-p if no underflow */
	f25519_select(x, minusp, x, (c >> 15) & 1);
}
    1f50:	66000001 	strvs	r0, [r0], -r1
    1f54:	6d697270 	sfmvs	f7, 2, [r9, #-448]!	; 0xfffffe40

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
    1f58:	00682e65 	rsbeq	r2, r8, r5, ror #28
    1f5c:	5f000001 	svcpl	0x00000001
    1f60:	61666564 	cmnvs	r6, r4, ror #10
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    1f64:	5f746c75 	svcpl	0x00746c75
    1f68:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0x974
    1f6c:	00682e73 	rsbeq	r2, r8, r3, ror lr
    1f70:	73000002 	movwvc	r0, #2
    1f74:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
    1f78:	00682e74 	rsbeq	r2, r8, r4, ror lr
    1f7c:	73000003 	movwvc	r0, #3
    1f80:	65646474 	strbvs	r6, [r4, #-1140]!	; 0x474
    1f84:	00682e66 	rsbeq	r2, r8, r6, ror #28
    1f88:	00000004 	andeq	r0, r0, r4
    1f8c:	00020500 	andeq	r0, r2, r0, lsl #10
    1f90:	03000000 	movweq	r0, #0
    1f94:	250100c9 	strcs	r0, [r1, #-201]	; 0xc9
    1f98:	04027a3b 	streq	r7, [r2], #-2619	; 0xa3b
    1f9c:	00010100 	andeq	r0, r1, r0, lsl #2
    1fa0:	2e3c0205 	cdpcs	2, 3, cr0, cr12, cr5, {0}
    1fa4:	dd030000 	stcle	0, cr0, [r3, #-0]
    1fa8:	034a0100 	movteq	r0, #41216	; 0xa100
    1fac:	40673c4f 	rsbmi	r3, r7, pc, asr #24
    1fb0:	032c2222 	teqeq	ip, #536870914	; 0x20000002
    1fb4:	79032e2b 	stmdbvc	r3, {r0, r1, r3, r5, r9, sl, fp, sp}
    1fb8:	5a33522e 	bpl	cd6878 <_etext+0xccf360>
    1fbc:	00342d29 	eorseq	r2, r4, r9, lsr #26
    1fc0:	02020402 	andeq	r0, r2, #33554432	; 0x2000000

	sum |= (sum >> 4);
    1fc4:	9e061322 	cdpls	3, 0, cr1, cr6, cr2, {1}
	sum |= (sum >> 2);
    1fc8:	2d3d4906 	ldccs	9, cr4, [sp, #-24]!	; 0xffffffe8
	sum |= (sum >> 1);
    1fcc:	1f3d3b21 	svcne	0x003d3b21

	return (sum ^ 1) & 1;
    1fd0:	59036821 	stmdbpl	r3, {r0, r5, fp, sp, lr}
}
    1fd4:	311e4b3c 	tstcc	lr, ip, lsr fp
    1fd8:	202a032b 	eorcs	r0, sl, fp, lsr #6
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fdc:	040200bd 	streq	r0, [r2], #-189	; 0xbd
		sum |= x[i] ^ y[i];
    1fe0:	02003d02 	andeq	r3, r0, #2, 26	; 0x80
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fe4:	4f030204 	svcmi	0x00030204
    1fe8:	04020066 	streq	r0, [r2], #-102	; 0x66
		sum |= x[i] ^ y[i];
    1fec:	20310302 	eorscs	r0, r1, r2, lsl #6
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1ff0:	02040200 	andeq	r0, r4, #0, 4
}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
    1ff4:	212e5203 	teqcs	lr, r3, lsl #4
    1ff8:	2b311e3d 	blcs	c498f4 <_etext+0xc423dc>
    1ffc:	02040200 	andeq	r0, r4, #0, 4
    2000:	00203103 	eoreq	r3, r0, r3, lsl #2
    2004:	03020402 	movweq	r0, #9218	; 0x2402
    2008:	00207fa8 	eoreq	r7, r0, r8, lsr #31
    200c:	03020402 	movweq	r0, #9218	; 0x2402
    2010:	002000d8 	ldrdeq	r0, [r0], -r8	; <UNPREDICTABLE>
    2014:	03020402 	movweq	r0, #9218	; 0x2402
	const uint8_t mask = -condition;
    2018:	212e7fab 	teqcs	lr, fp, lsr #31
    201c:	2b312c59 	blcs	c4d188 <_etext+0xc45c70>
    2020:	2000f503 	andcs	pc, r0, r3, lsl #10
    2024:	03732131 	cmneq	r3, #1073741836	; 0x4000000c
    2028:	03433c59 	movteq	r3, #15449	; 0x3c59
    202c:	313c7fbb 			; <UNDEFINED> instruction: 0x313c7fbb
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    2030:	3c35031e 	ldccc	3, cr0, [r5], #-120	; 0xffffff88
    2034:	4d032d21 	stcmi	13, cr2, [r3, #-132]	; 0xffffff7c
    2038:	0003024a 	andeq	r0, r3, sl, asr #4
    203c:	05000101 	streq	r0, [r0, #-257]	; 0x101
    2040:	00000002 	andeq	r0, r0, r2
    2044:	00f80300 	rscseq	r0, r8, r0, lsl #6
    2048:	04312e01 	ldrteq	r2, [r1], #-3585	; 0xe01
    204c:	7fac0302 	svcvc	0x00ac0302
    2050:	03010458 	movweq	r0, #5208	; 0x1458
    2054:	02ac00d6 	adceq	r0, ip, #214	; 0xd6
    2058:	01010002 	tsteq	r1, r2
    205c:	00020500 	andeq	r0, r2, r0, lsl #10
    2060:	03000000 	movweq	r0, #0
    2064:	5d010180 	stfpls	f0, [r1, #-512]	; 0xfffffe00
    2068:	2f143102 	svccs	0x00143102
    206c:	032f302f 	teqeq	pc, #47	; 0x2f
    2070:	241d4a78 	ldrcs	r4, [sp], #-2680	; 0xa78
    2074:	211f212d 	tstcs	pc, sp, lsr #2
    2078:	0002022d 	andeq	r0, r2, sp, lsr #4
    207c:	05000101 	streq	r0, [r0, #-257]	; 0x101
    2080:	00000002 	andeq	r0, r0, r2
    2084:	01910300 	orrseq	r0, r1, r0, lsl #6
    2088:	be130801 	cdplt	8, 1, cr0, cr3, cr1, {0}
    208c:	1f133202 	svcne	0x00133202
    2090:	65211e4b 	strvs	r1, [r1, #-3659]!	; 0xe4b
    2094:	0002023e 	andeq	r0, r2, lr, lsr r2
    2098:	05000101 	streq	r0, [r0, #-257]	; 0x101
}
    209c:	00000002 	andeq	r0, r0, r2
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    20a0:	019a0300 	orrseq	r0, sl, r0, lsl #6
    20a4:	7ef30301 	cdpvc	3, 15, cr0, cr3, cr1, {0}
    20a8:	018d0320 	orreq	r0, sp, r0, lsr #6
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    20ac:	7ef60320 	cdpvc	3, 15, cr0, cr6, cr0, {1}
    20b0:	1e4b2120 	dvfneep	f2, f3, f0
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}
    20b4:	0e032b31 	vmoveq.16	d3[0], r2
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    20b8:	312c593c 	teqcc	ip, ip, lsr r9
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}

void f25519_add(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint16_t c = 0;
    20bc:	00f5032b 	rscseq	r0, r5, fp, lsr #6
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
    20c0:	73213120 	teqvc	r1, #32, 2
    20c4:	00030244 	andeq	r0, r3, r4, asr #4
		r[i] = c;
    20c8:	05000101 	streq	r0, [r0, #-257]	; 0x101
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    20cc:	00000002 	andeq	r0, r0, r2
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;
    20d0:	01a00300 	lsleq	r0, r0, #6
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20d4:	7eed0301 	cdpvc	3, 14, cr0, cr13, cr1, {0}
	c = (c >> 7) * 19;
    20d8:	01930320 	orrseq	r0, r3, r0, lsr #6
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20dc:	7ef00320 	cdpvc	3, 15, cr0, cr0, cr0, {1}
	c = (c >> 7) * 19;
    20e0:	1e4b2120 	dvfneep	f2, f3, f0
    20e4:	0e032b31 	vmoveq.16	d3[0], r2

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    20e8:	312c593c 	teqcc	ip, ip, lsr r9
    20ec:	00f5032b 	rscseq	r0, r5, fp, lsr #6

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    20f0:	73213120 	teqvc	r1, #32, 2
		c += r[i];
		r[i] = c;
		c >>= 8;
    20f4:	3c7f8503 	cfldr64cc	mvdx8, [pc], #-12	; 20f0 <f25519_add+0x38>

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    20f8:	2c592123 	ldfcse	f2, [r9], {35}	; 0x23
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    20fc:	f5032b31 			; <UNDEFINED> instruction: 0xf5032b31

void f25519_sub(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2100:	21312000 	teqcs	r1, r0
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
    2104:	3c0f0373 	stccc	3, cr0, [pc], {115}	; 0x73
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2108:	01000302 	tsteq	r0, r2, lsl #6
    210c:	02050001 	andeq	r0, r5, #1
    2110:	00000000 	andeq	r0, r0, r0
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2114:	0101a803 	tsteq	r1, r3, lsl #16
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2118:	312b234a 	teqcc	fp, sl, asr #6
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    211c:	2e7f8103 	expcse	f0, f3
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2120:	22224067 	eorcs	r4, r2, #103	; 0x67
    2124:	00fa032c 	rscseq	r0, sl, ip, lsr #6
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2128:	04020020 	streq	r0, [r2], #-32
    212c:	02004b02 	andeq	r4, r0, #2048	; 0x800
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2130:	90030204 	andls	r0, r3, r4, lsl #4
	c = (c >> 7) * 19;
    2134:	0200827f 	andeq	r8, r0, #-268435449	; 0xf0000007

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2138:	f0030204 			; <UNDEFINED> instruction: 0xf0030204
		r[i] = c;
    213c:	02002000 	andeq	r2, r0, #0

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2140:	93030204 	movwls	r0, #12804	; 0x3204
		c += r[i];
		r[i] = c;
		c >>= 8;
    2144:	3d212e7f 	stccc	14, cr2, [r1, #-508]!	; 0xfffffe04
	}
}
    2148:	032b311e 	teqeq	fp, #-2147483641	; 0x80000007

void f25519_neg(uint8_t *r, const uint8_t *a)
{
    214c:	1e593c5d 	mrcne	12, 2, r3, cr9, cr13, {2}
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
    2150:	f5032b31 			; <UNDEFINED> instruction: 0xf5032b31
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 - ((uint32_t)a[i]);
    2154:	21312000 	teqcs	r1, r0
    2158:	03020465 	movweq	r0, #9317	; 0x2465
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    215c:	043c7f92 	ldrteq	r7, [ip], #-3986	; 0xf92
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
    2160:	9e660301 	cdpls	3, 6, cr0, cr6, cr1, {0}
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2164:	1a030204 	bne	c297c <_etext+0xbb464>

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2168:	0301042e 	movweq	r0, #5166	; 0x142e
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;
    216c:	67212069 	strvs	r2, [r1, -r9, rrx]!
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    2170:	032b312c 	teqeq	fp, #44, 2
	c = (c >> 7) * 19;
    2174:	1e673c0e 	cdpne	12, 6, cr3, cr7, cr14, {0}
    2178:	f5032b31 			; <UNDEFINED> instruction: 0xf5032b31

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    217c:	21312000 	teqcs	r1, r0
		r[i] = c;
    2180:	214d3981 	smlalbbcs	r3, sp, r1, r9

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2184:	04020081 	streq	r0, [r2], #-129	; 0x81
		c += r[i];
		r[i] = c;
		c >>= 8;
    2188:	3c180302 	ldccc	3, cr0, [r8], {2}
	}
}
    218c:	033c0c03 	teqeq	ip, #768	; 0x300
    2190:	313c7ef7 			; <UNDEFINED> instruction: 0x313c7ef7

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2194:	0003022c 	andeq	r0, r3, ip, lsr #4
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2198:	05000101 	streq	r0, [r0, #-257]	; 0x101
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    219c:	00000002 	andeq	r0, r0, r2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    21a0:	01bc0300 			; <UNDEFINED> instruction: 0x01bc0300
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    21a4:	03020401 	movweq	r0, #9217	; 0x2401
		for (j = 0; j <= i; j++)
    21a8:	043c7eeb 	ldrteq	r7, [ip], #-3819	; 0xeeb
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    21ac:	01950301 	orrseq	r0, r5, r1, lsl #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    21b0:	02042020 	andeq	r2, r4, #32
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    21b4:	2e7eeb03 	vaddcs.f64	d30, d14, d3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    21b8:	9c030104 	stflss	f0, [r3], {4}
    21bc:	02049001 	andeq	r9, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21c0:	207ee403 	rsbscs	lr, lr, r3, lsl #8
    21c4:	97030104 	strls	r0, [r3, -r4, lsl #2]
    21c8:	02002001 	andeq	r2, r0, #1
    21cc:	00260204 	eoreq	r0, r6, r4, lsl #4
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    21d0:	3d020402 	cfstrscc	mvf0, [r2, #-8]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    21d4:	02040200 	andeq	r0, r4, #0, 4
    21d8:	0402002c 	streq	r0, [r2], #-44	; 0x2c

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21dc:	02003102 	andeq	r3, r0, #-2147483648	; 0x80000000
			c += ((uint32_t)a[j]) *
    21e0:	032b0204 	teqeq	fp, #4, 4	; 0x40000000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    21e4:	a3207f8a 	teqge	r0, #552	; 0x228
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    21e8:	3d2e5a03 	vstmdbcc	lr!, {s10-s12}
    21ec:	2c222240 	sfmcs	f2, 4, [r2], #-256	; 0xffffff00
    21f0:	20019903 	andcs	r9, r1, r3, lsl #18

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    21f4:	db030204 	blle	c2a0c <_etext+0xbb4f4>
    21f8:	01043c7e 	tsteq	r4, lr, ror ip
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    21fc:	2001a503 	andcs	sl, r1, r3, lsl #10
	c = (c >> 7) * 19;
    2200:	db030204 	blle	c2a18 <_etext+0xbb500>

	for (i = 0; i < F25519_SIZE; i++) {
    2204:	01042e7e 	tsteq	r4, lr, ror lr
		c += r[i];
    2208:	9e01a503 	cfsh32ls	mvfx10, mvfx1, #3
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    220c:	03ad6823 			; <UNDEFINED> instruction: 0x03ad6823
		c += r[i];
		r[i] = c;
		c >>= 8;
    2210:	0a03667a 	beq	dbc00 <_etext+0xd46e8>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2214:	7eda033c 	mrcvc	3, 6, r0, cr10, cr12, {1}
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    2218:	022c313c 	eoreq	r3, ip, #60, 2
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    221c:	01010003 	tsteq	r1, r3
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2220:	00000152 	andeq	r0, r0, r2, asr r1
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    2224:	00fb0002 	rscseq	r0, fp, r2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2228:	01020000 	mrseq	r0, (UNDEF: 2)
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    222c:	000d0efb 	strdeq	r0, [sp], -fp
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2230:	01010101 	tsteq	r1, r1, lsl #2
    2234:	01000000 	mrseq	r0, (UNDEF: 0)

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2238:	32010000 	andcc	r0, r1, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    223c:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2240:	5c3a6300 	ldcpl	3, cr6, [sl], #-0
    2244:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2248:	206d6172 	rsbcs	r6, sp, r2, ror r1
    224c:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966
    2250:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2254:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2258:	20756e67 	rsbscs	r6, r5, r7, ror #28
    225c:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; 2094 <f25519_select+0xa0>

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2260:	72612073 	rsbvc	r2, r1, #115	; 0x73
			c += ((uint32_t)a[j]) *
    2264:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2268:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    226c:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465
    2270:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2274:	71343130 	teqvc	r4, r0, lsr r1
	c = (c >> 7) * 19;
    2278:	72615c33 	rsbvc	r5, r1, #13056	; 0x3300
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    227c:	6f6e2d6d 	svcvs	0x006e2d6d
	c = (c >> 7) * 19;
    2280:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2284:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c
    2288:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    228c:	5c656475 	cfstrdpl	mvd6, [r5], #-468	; 0xfffffe2c
		r[i] = c;
    2290:	6863616d 	stmdavs	r3!, {r0, r2, r3, r5, r6, r8, sp, lr}^
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2294:	00656e69 	rsbeq	r6, r5, r9, ror #28
		c += r[i];
		r[i] = c;
		c >>= 8;
    2298:	705c3a63 	subsvc	r3, ip, r3, ror #20
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    229c:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
    22a0:	66206d61 	strtvs	r6, [r0], -r1, ror #26
    22a4:	73656c69 	cmnvc	r5, #26880	; 0x6900
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22a8:	38782820 	ldmdacc	r8!, {r5, fp, sp}^
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    22ac:	675c2936 	smmlarvs	ip, r6, r9, r2
		for (j = 0; j <= i; j++)
    22b0:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22b4:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
    22b8:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22bc:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22c0:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22c4:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22c8:	30322038 	eorscc	r2, r2, r8, lsr r0
    22cc:	33713431 	cmncc	r1, #822083584	; 0x31000000
    22d0:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
    22d4:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    22d8:	61652d65 	cmnvs	r5, r5, ror #26
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22dc:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^
    22e0:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    22e4:	00006564 	andeq	r6, r0, r4, ror #10

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22e8:	70726f6d 	rsbsvc	r6, r2, sp, ror #30
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    22ec:	35353268 	ldrcc	r3, [r5, #-616]!	; 0x268
    22f0:	632e3931 	teqvs	lr, #802816	; 0xc4000

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    22f4:	00000100 	andeq	r0, r0, r0, lsl #2
    22f8:	6665645f 			; <UNDEFINED> instruction: 0x6665645f
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22fc:	746c7561 	strbtvc	r7, [ip], #-1377	; 0x561
	c = (c >> 7) * 19;
    2300:	7079745f 	rsbsvc	r7, r9, pc, asr r4

	for (i = 0; i < F25519_SIZE; i++) {
    2304:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
		c += r[i];
    2308:	00000200 	andeq	r0, r0, r0, lsl #4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    230c:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
		c += r[i];
		r[i] = c;
		c >>= 8;
    2310:	682e746e 	stmdavs	lr!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2314:	00000300 	andeq	r0, r0, r0, lsl #6
    2318:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    231c:	682e3931 	stmdavs	lr!, {r0, r4, r5, r8, fp, ip, sp}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2320:	00000100 	andeq	r0, r0, r0, lsl #2
    2324:	02050000 	andeq	r0, r5, #0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2328:	00000000 	andeq	r0, r0, r0
		for (j = 0; j <= i; j++)
    232c:	24010a03 	strcs	r0, [r1], #-2563	; 0xa03
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2330:	1c24201c 	stcne	0, cr2, [r4], #-112	; 0xffffff90
    2334:	594b4b24 	stmdbpl	fp, {r2, r5, r8, r9, fp, lr}^

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2338:	05023d59 	streq	r3, [r2, #-3417]	; 0xd59
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    233c:	00010100 	andeq	r0, r1, r0, lsl #2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2340:	00000205 	andeq	r0, r0, r5, lsl #4
    2344:	cc030000 	stcgt	0, cr0, [r3], {-0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2348:	4e030100 	adfmis	f0, f3, f0
    234c:	2032032e 	eorscs	r0, r2, lr, lsr #6
    2350:	3c4e0320 	mcrrcc	3, 2, r0, lr, cr0
    2354:	033c3203 	teqeq	ip, #805306368	; 0x30000000
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2358:	4b2f204e 	blmi	bca498 <_etext+0xbc2f80>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    235c:	58110359 	ldmdapl	r1, {r0, r3, r4, r6, r8, r9}
    2360:	4d59595b 	ldclmi	9, cr5, [r9, #-364]	; 0xfffffe94

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2364:	4d4b5b5b 	vstrmi	d21, [fp, #-364]	; 0xfffffe94
			c += ((uint32_t)a[j]) *
    2368:	3e3d59af 	cdpcc	9, 3, cr5, cr13, cr15, {5}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    236c:	3d580b03 	vldrcc	d16, [r8, #-12]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2370:	0009023f 	andeq	r0, r9, pc, lsr r2
    2374:	08050101 	stmdaeq	r5, {r0, r8}
    2378:	00020000 	andeq	r0, r2, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    237c:	00000031 	andeq	r0, r0, r1, lsr r0
	c = (c >> 7) * 19;
    2380:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2384:	0101000d 	tsteq	r1, sp
	c = (c >> 7) * 19;
    2388:	00000101 	andeq	r0, r0, r1, lsl #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    238c:	00000100 	andeq	r0, r0, r0, lsl #2
	c = (c >> 7) * 19;
    2390:	35353201 	ldrcc	r3, [r5, #-513]!	; 0x201

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2394:	00003931 	andeq	r3, r0, r1, lsr r9
		r[i] = c;
    2398:	32616873 	rsbcc	r6, r1, #7536640	; 0x730000
		c >>= 8;
    239c:	632e3635 	teqvs	lr, #55574528	; 0x3500000
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23a0:	00000100 	andeq	r0, r0, r0, lsl #2
    23a4:	32616873 	rsbcc	r6, r1, #7536640	; 0x730000
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    23a8:	682e3635 	stmdavs	lr!, {r0, r2, r4, r5, r9, sl, ip, sp}
    23ac:	00000100 	andeq	r0, r0, r0, lsl #2
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23b0:	02050000 	andeq	r0, r5, #0
    23b4:	00002fdc 	ldrdeq	r2, [r0], -ip

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23b8:	33012f03 	movwcc	r2, #7939	; 0x1f03
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23bc:	2121302d 	teqcs	r1, sp, lsr #32

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23c0:	03212121 	teqeq	r1, #1073741832	; 0x40000008
    23c4:	30232076 	eorcc	r2, r3, r6, ror r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23c8:	1c212121 	stfnes	f2, [r1], #-132	; 0xffffff7c
    23cc:	76032133 			; <UNDEFINED> instruction: 0x76032133
    23d0:	0a032120 	beq	ca858 <_etext+0xc3340>
    23d4:	00130220 	andseq	r0, r3, r0, lsr #4
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    23d8:	05000101 	streq	r0, [r0, #-257]	; 0x101
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    23dc:	00303402 	eorseq	r3, r0, r2, lsl #8
    23e0:	013e0300 	teqeq	lr, r0, lsl #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23e4:	2034033c 	eorscs	r0, r4, ip, lsr r3
			c += ((uint32_t)a[j]) *
    23e8:	0322211e 	teqeq	r2, #-2147483641	; 0x80000007
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    23ec:	22242079 	eorcs	r2, r4, #121	; 0x79
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    23f0:	7803241f 	stmdavc	r3, {r0, r1, r2, r3, r4, sl, sp}
    23f4:	7903262e 	stmdbvc	r3, {r1, r2, r3, r5, r9, sl, sp}
    23f8:	1c1f2620 	ldcne	6, cr2, [pc], {32}

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    23fc:	0322271f 	teqeq	r2, #8126464	; 0x7c0000
    2400:	27213c78 			; <UNDEFINED> instruction: 0x27213c78
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2404:	03747903 	cmneq	r4, #49152	; 0xc000
	c = (c >> 7) * 19;
    2408:	33032054 	movwcc	r2, #12372	; 0x3054

	for (i = 0; i < F25519_SIZE; i++) {
    240c:	664d0320 	strbvs	r0, [sp], -r0, lsr #6
		c += r[i];
    2410:	032e2c03 	teqeq	lr, #768	; 0x300
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2414:	33032054 	movwcc	r2, #12372	; 0x3054
		c += r[i];
		r[i] = c;
		c >>= 8;
    2418:	664d032e 	strbvs	r0, [sp], -lr, lsr #6
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    241c:	03743303 	cmneq	r4, #201326592	; 0xc000000
	/* 1 1 */
	f25519_mul__distinct(s, x, x);
	f25519_mul__distinct(r, s, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    2420:	33034a4d 	movwcc	r4, #14925	; 0x3a4d
    2424:	4a4e032e 	bmi	13830e4 <_etext+0x137bbcc>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2428:	032e3203 	teqeq	lr, #805306368	; 0x30000000
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    242c:	031f2e4e 	tsteq	pc, #1248	; 0x4e0
    2430:	03262e2d 	teqeq	r6, #720	; 0x2d0
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2434:	0326207a 	teqeq	r6, #122	; 0x7a
    2438:	3203204e 	andcc	r2, r3, #78	; 0x4e

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    243c:	2e4e033c 	mcrcs	3, 2, r0, cr14, cr12, {1}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2440:	263c2c03 	ldrtcs	r2, [ip], -r3, lsl #24

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2444:	03204e03 	teqeq	r0, #3, 28	; 0x30
    2448:	2f1f2e33 	svccs	0x001f2e33
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    244c:	204e031f 	subcs	r0, lr, pc, lsl r3
    2450:	032e3203 	teqeq	lr, #805306368	; 0x30000000
    2454:	33033c4e 	movwcc	r3, #15438	; 0x3c4e
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2458:	084e0320 	stmdaeq	lr, {r5, r8, r9}^
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    245c:	2032039e 	mlascs	r2, lr, r3, r0
    2460:	03664e03 	cmneq	r6, #3, 28	; 0x30

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2464:	4e032032 	mcrmi	0, 0, r2, cr3, cr2, {1}
			c += ((uint32_t)a[j]) *
    2468:	2032032e 	eorscs	r0, r2, lr, lsr #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    246c:	03204e03 	teqeq	r0, #3, 28	; 0x30
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2470:	032f2032 	teqeq	pc, #50	; 0x32
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2474:	3203204d 	andcc	r2, r3, #77	; 0x4d
    2478:	4d03214a 	stfmis	f2, [r3, #-296]	; 0xfffffed8
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    247c:	3c33032e 	ldccc	3, cr0, [r3], #-184	; 0xffffff48
	c = (c >> 7) * 19;
    2480:	2e084e03 	cdpcs	14, 0, cr4, cr8, cr3, {0}
    2484:	03203203 	teqeq	r0, #805306368	; 0x30000000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2488:	3203664e 	andcc	r6, r3, #81788928	; 0x4e00000
	c = (c >> 7) * 19;
    248c:	664e0320 	strbvs	r0, [lr], -r0, lsr #6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2490:	032e3203 	teqeq	lr, #805306368	; 0x30000000
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2494:	32034a4e 	andcc	r4, r3, #319488	; 0x4e000
		r[i] = c;
    2498:	204e033c 	subcs	r0, lr, ip, lsr r3
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    249c:	03203203 	teqeq	r0, #805306368	; 0x30000000
		c += r[i];
		r[i] = c;
		c >>= 8;
    24a0:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24a4:	3c4f032e 	mcrrcc	3, 2, r0, pc, cr14
    24a8:	03203203 	teqeq	r0, #805306368	; 0x30000000
    24ac:	3303204d 	movwcc	r2, #12365	; 0x304d
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24b0:	204e0320 	subcs	r0, lr, r0, lsr #6
    24b4:	03203203 	teqeq	r0, #805306368	; 0x30000000
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    24b8:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24bc:	584e0320 	stmdapl	lr, {r5, r8, r9}^
    24c0:	032e3203 	teqeq	lr, #805306368	; 0x30000000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24c4:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24c8:	ba4e032e 	blt	1383188 <_etext+0x137bc70>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24cc:	032e3203 	teqeq	lr, #805306368	; 0x30000000
    24d0:	3203904e 	andcc	r9, r3, #78	; 0x4e
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24d4:	2e4e032e 	cdpcs	3, 4, cr0, cr14, cr14, {1}
    24d8:	034a3203 	movteq	r3, #41475	; 0xa203
    24dc:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    24e0:	3c4e0320 	mcrrcc	3, 2, r0, lr, cr0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24e4:	032e3203 	teqeq	lr, #805306368	; 0x30000000
    24e8:	3203204f 	andcc	r2, r3, #79	; 0x4f

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24ec:	4f032d20 	svcmi	0x00032d20
			c += ((uint32_t)a[j]) *
    24f0:	33031f2e 	movwcc	r1, #16174	; 0x3f2e
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    24f4:	584e032e 	stmdapl	lr, {r1, r2, r3, r5, r8, r9}^
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    24f8:	03203103 	teqeq	r0, #-1073741824	; 0xc0000000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    24fc:	3203204f 	andcc	r2, r3, #79	; 0x4f
	c = (c >> 7) * 19;
    2500:	03212d20 	teqeq	r1, #32, 26	; 0x800
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2504:	3203e44e 	andcc	lr, r3, #1308622848	; 0x4e000000
	c = (c >> 7) * 19;
    2508:	584e0320 	stmdapl	lr, {r5, r8, r9}^
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    250c:	03203203 	teqeq	r0, #805306368	; 0x30000000
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2510:	32034a4e 	andcc	r4, r3, #319488	; 0x4e000
		r[i] = c;
    2514:	4a4e032e 	bmi	13831d4 <_etext+0x137bcbc>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2518:	034a3203 	movteq	r3, #41475	; 0xa203
		c += r[i];
		r[i] = c;
		c >>= 8;
    251c:	3203204e 	andcc	r2, r3, #78	; 0x4e
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2520:	2e4e0320 	cdpcs	3, 4, cr0, cr14, cr0, {1}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2524:	1f2e3303 	svcne	0x002e3303
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2528:	2f2e4e03 	svccs	0x002e4e03
		for (j = 0; j <= i; j++)
    252c:	03203203 	teqeq	r0, #805306368	; 0x30000000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2530:	3203204e 	andcc	r2, r3, #78	; 0x4e
    2534:	032fab20 	teqeq	pc, #32, 22	; 0x8000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2538:	3203584e 	andcc	r5, r3, #5111808	; 0x4e0000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    253c:	664e032e 	strbvs	r0, [lr], -lr, lsr #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2540:	032e3203 	teqeq	lr, #805306368	; 0x30000000
    2544:	3203204e 	andcc	r2, r3, #78	; 0x4e
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2548:	4a4e0366 	bmi	13832e8 <_etext+0x137bdd0>
    254c:	754a3203 	strbvc	r3, [sl, #-515]	; 0x203
    2550:	211f3d3b 	tstcs	pc, fp, lsr sp	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2554:	204f032d 	subcs	r0, pc, sp, lsr #6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2558:	2f2e3103 	svccs	0x002e3103
    255c:	03744e03 	cmneq	r4, #3, 28	; 0x30

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2560:	03212e31 	teqeq	r1, #784	; 0x310
			c += ((uint32_t)a[j]) *
    2564:	3203584e 	andcc	r5, r3, #5111808	; 0x4e0000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2568:	664e032e 	strbvs	r0, [lr], -lr, lsr #6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    256c:	032e3203 	teqeq	lr, #805306368	; 0x30000000
    2570:	3203204e 	andcc	r2, r3, #78	; 0x4e
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2574:	664e0358 			; <UNDEFINED> instruction: 0x664e0358
	c = (c >> 7) * 19;
    2578:	032e3203 	teqeq	lr, #805306368	; 0x30000000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    257c:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
	c = (c >> 7) * 19;
    2580:	3b672008 	blcc	19ca5a8 <_etext+0x19c3090>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2584:	2d211f21 	stccs	15, cr1, [r1, #-132]!	; 0xffffff7c
	c = (c >> 7) * 19;
    2588:	033c4f03 	teqeq	ip, #3, 30

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    258c:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
		r[i] = c;
    2590:	2e320382 	cdpcs	3, 3, cr0, cr2, cr2, {4}
		c >>= 8;
    2594:	03664e03 	cmneq	r6, #3, 28	; 0x30
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2598:	4e033c32 	mcrmi	12, 0, r3, cr3, cr2, {1}
    259c:	3c3203ba 	ldccc	3, cr0, [r2], #-744	; 0xfffffd18
    25a0:	034a4e03 	movteq	r4, #44547	; 0xae03
    25a4:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25a8:	2032032e 	eorscs	r0, r2, lr, lsr #6
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    25ac:	032e4e03 	teqeq	lr, #3, 28	; 0x30
		for (j = 0; j <= i; j++)
    25b0:	034b2e32 	movteq	r2, #48690	; 0xbe32
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25b4:	32033c4e 	andcc	r3, r3, #19968	; 0x4e00
    25b8:	204d032e 	subcs	r0, sp, lr, lsr #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25bc:	33032d2f 	movwcc	r2, #15663	; 0x3d2f
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25c0:	084e032e 	stmdaeq	lr, {r1, r2, r3, r5, r8, r9}^

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25c4:	3c320320 	ldccc	3, cr0, [r2], #-128	; 0xffffff80
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25c8:	03904e03 	orrseq	r4, r0, #3, 28	; 0x30
    25cc:	4e033c32 	mcrmi	12, 0, r3, cr3, cr2, {1}
    25d0:	2e32034a 	cdpcs	3, 3, cr0, cr2, cr10, {2}
    25d4:	032e4e03 	teqeq	lr, #3, 28	; 0x30
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    25d8:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25dc:	20320320 	eorscs	r0, r2, r0, lsr #6
    25e0:	4e031f21 	cdpmi	15, 0, cr1, cr3, cr1, {1}
    25e4:	2e32032e 	cdpcs	3, 3, cr0, cr2, cr14, {1}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25e8:	03211f3d 	teqeq	r1, #61, 30	; 0xf4
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    25ec:	032d3c4e 	teqeq	sp, #19968	; 0x4e00
    25f0:	4e032033 	mcrmi	0, 0, r2, cr3, cr3, {1}

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    25f4:	2e320358 	mrccs	3, 1, r0, cr2, cr8, {2}
    25f8:	03584e03 	cmpeq	r8, #3, 28	; 0x30
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25fc:	4e032032 	mcrmi	0, 0, r2, cr3, cr2, {1}
	c = (c >> 7) * 19;
    2600:	2e320382 	cdpcs	3, 3, cr0, cr2, cr2, {4}

	for (i = 0; i < F25519_SIZE; i++) {
    2604:	03744e03 	cmneq	r4, #3, 28	; 0x30
		c += r[i];
    2608:	4e033c32 	mcrmi	12, 0, r3, cr3, cr2, {1}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    260c:	2e320358 	mrccs	3, 1, r0, cr2, cr8, {2}
		c += r[i];
		r[i] = c;
		c >>= 8;
    2610:	03204e03 	teqeq	r0, #3, 28	; 0x30
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2614:	1f213c32 	svcne	0x00213c32
    2618:	4e031f21 	cdpmi	15, 0, cr1, cr3, cr1, {1}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    261c:	2e330320 	cdpcs	3, 3, cr0, cr3, cr0, {1}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2620:	211f2f3b 	tstcs	pc, fp, lsr pc	; <UNPREDICTABLE>
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2624:	03584e03 	cmpeq	r8, #3, 28	; 0x30
    2628:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    262c:	4a320366 	bmi	c833cc <_etext+0xc7beb4>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2630:	034a4d03 	movteq	r4, #44291	; 0xad03

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2634:	4e032e33 	mcrmi	14, 0, r2, cr3, cr3, {1}
    2638:	2e320374 	mrccs	3, 1, r0, cr2, cr4, {3}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    263c:	034a4e03 	movteq	r4, #44547	; 0xae03
    2640:	4e033c32 	mcrmi	12, 0, r3, cr3, cr2, {1}
    2644:	2e32034a 	cdpcs	3, 3, cr0, cr2, cr10, {2}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2648:	032e4e03 	teqeq	lr, #3, 28	; 0x30
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    264c:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
    2650:	2033032e 	eorscs	r0, r3, lr, lsr #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2654:	3c4e031f 	mcrrcc	3, 1, r0, lr, cr15
			c += ((uint32_t)a[j]) *
    2658:	032e3303 	teqeq	lr, #201326592	; 0xc000000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    265c:	3303584d 	movwcc	r5, #14413	; 0x384d
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2660:	664e032e 	strbvs	r0, [lr], -lr, lsr #6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2664:	032e3203 	teqeq	lr, #805306368	; 0x30000000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2668:	3203584e 	andcc	r5, r3, #5111808	; 0x4e0000
	c = (c >> 7) * 19;
    266c:	9e4e033c 	mcrls	3, 2, r0, cr14, cr12, {1}
    2670:	034a3203 	movteq	r3, #41475	; 0xa203
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2674:	32034a4e 	andcc	r4, r3, #319488	; 0x4e000
	c = (c >> 7) * 19;
    2678:	4a4e0320 	bmi	1383300 <_etext+0x137bde8>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    267c:	034a3203 	movteq	r3, #41475	; 0xa203
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2680:	3203204e 	andcc	r2, r3, #78	; 0x4e
		r[i] = c;
    2684:	031f2120 	tsteq	pc, #32, 2
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2688:	3203204e 	andcc	r2, r3, #78	; 0x4e
		c += r[i];
		r[i] = c;
		c >>= 8;
    268c:	211f2f2e 	tstcs	pc, lr, lsr #30
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2690:	03584e03 	cmpeq	r8, #3, 28	; 0x30
    2694:	4d032e32 	stcmi	14, cr2, [r3, #-200]	; 0xffffff38
    2698:	2e33033c 	mrccs	3, 1, r0, cr3, cr12, {1}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    269c:	034a4e03 	movteq	r4, #44547	; 0xae03
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    26a0:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
		for (j = 0; j <= i; j++)
    26a4:	2032034a 	eorscs	r0, r2, sl, asr #6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26a8:	032e4e03 	teqeq	lr, #3, 28	; 0x30
    26ac:	4e034a32 	mcrmi	10, 0, r4, cr3, cr2, {1}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26b0:	4a320358 	bmi	c83418 <_etext+0xc7bf00>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26b4:	03744e03 	cmneq	r4, #3, 28	; 0x30

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26b8:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26bc:	2032032e 	eorscs	r0, r2, lr, lsr #6
    26c0:	744e033d 	strbvc	r0, [lr], #-829	; 0x33d
    26c4:	032e3203 	teqeq	lr, #805306368	; 0x30000000
    26c8:	3203584e 	andcc	r5, r3, #5111808	; 0x4e0000
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    26cc:	2e4e032e 	cdpcs	3, 4, cr0, cr14, cr14, {1}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26d0:	03203203 	teqeq	r0, #805306368	; 0x30000000
    26d4:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
    26d8:	3c4e032e 	mcrrcc	3, 2, r0, lr, cr14

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26dc:	034a3203 	movteq	r3, #41475	; 0xa203
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    26e0:	32034a4e 	andcc	r4, r3, #319488	; 0x4e000
    26e4:	744e0320 	strbvc	r0, [lr], #-800	; 0x320

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    26e8:	032e3203 	teqeq	lr, #805306368	; 0x30000000
    26ec:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26f0:	211f3d20 	tstcs	pc, r0, lsr #26
	c = (c >> 7) * 19;
    26f4:	03e44e03 	mvneq	r4, #3, 28	; 0x30

	for (i = 0; i < F25519_SIZE; i++) {
    26f8:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
		c += r[i];
    26fc:	2e320358 	mrccs	3, 1, r0, cr2, cr8, {2}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2700:	032e4e03 	teqeq	lr, #3, 28	; 0x30
		c += r[i];
		r[i] = c;
		c >>= 8;
    2704:	4e032032 	mcrmi	0, 0, r2, cr3, cr2, {1}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2708:	4a32032e 	bmi	c833c8 <_etext+0xc7beb0>
    270c:	033c4e03 	teqeq	ip, #3, 28	; 0x30
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2710:	032f3c32 	teqeq	pc, #12800	; 0x3200
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2714:	3203204d 	andcc	r2, r3, #77	; 0x4d
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2718:	0367082e 	cmneq	r7, #3014656	; 0x2e0000
    271c:	3203204d 	andcc	r2, r3, #77	; 0x4d

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2720:	3b213d2e 	blcc	851be0 <_etext+0x84a6c8>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2724:	1f2f1f2f 	svcne	0x002f1f2f

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2728:	2d4b2d75 	stclcs	13, cr2, [fp, #-468]	; 0xfffffe2c
    272c:	2d2f1f59 	stccs	15, cr1, [pc, #-356]!	; 25d0 <f25519_inv__distinct+0x3b4>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2730:	2d216567 	cfstr32cs	mvfx6, [r1, #-412]!	; 0xfffffe64
    2734:	59211f21 	stmdbpl	r1!, {r0, r5, r8, r9, sl, fp, ip}
    2738:	4b2d592d 	blmi	b58bf4 <_etext+0xb516dc>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    273c:	9f2d2f1f 	svcls	0x002d2f1f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2740:	2f2d2f2d 	svccs	0x002d2f2d
    2744:	21492f1f 	cmpcs	r9, pc, lsl pc

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2748:	213b219d 			; <UNDEFINED> instruction: 0x213b219d
			c += ((uint32_t)a[j]) *
    274c:	1f3d2d91 	svcne	0x003d2d91

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2750:	1f2f1f83 	svcne	0x002f1f83
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2754:	ff212d83 			; <UNDEFINED> instruction: 0xff212d83
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2758:	59211f21 	stmdbpl	r1!, {r0, r5, r8, r9, sl, fp, ip}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    275c:	2f2d4b2d 	svccs	0x002d4b2d
	c = (c >> 7) * 19;
    2760:	912d2f1f 	teqls	sp, pc, lsl pc
    2764:	212d2f2d 	teqcs	sp, sp, lsr #30
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2768:	21492f1f 	cmpcs	r9, pc, lsl pc
	c = (c >> 7) * 19;
    276c:	2181219d 			; <UNDEFINED> instruction: 0x2181219d
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2770:	1f2f1f21 	svcne	0x002f1f21
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2774:	1f2f1fad 	svcne	0x002f1fad
		r[i] = c;
    2778:	08211f83 	stmdaeq	r1!, {r0, r1, r7, r8, r9, sl, fp, ip}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    277c:	3d2d2249 	sfmcc	f2, 4, [sp, #-292]!	; 0xfffffedc
		c += r[i];
		r[i] = c;
		c >>= 8;
    2780:	21213b1f 	teqcs	r1, pc, lsl fp
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2784:	2f1f2f1f 	svccs	0x001f2f1f
    2788:	2f2dbb1f 	svccs	0x002dbb1f
    278c:	21492f2d 	cmpcs	r9, sp, lsr #30
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2790:	211f218f 	tstcs	pc, pc, lsl #3
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2794:	2d592d75 	ldclcs	13, cr2, [r9, #-468]	; 0xfffffe2c
		for (j = 0; j <= i; j++)
    2798:	2d2f1f4b 	stccs	15, cr1, [pc, #-300]!	; 2674 <f25519_inv__distinct+0x458>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    279c:	2d2f2d75 	stccs	13, cr2, [pc, #-468]!	; 25d0 <f25519_inv__distinct+0x3b4>
    27a0:	492f1f21 	stmdbmi	pc!, {r0, r5, r8, r9, sl, fp, ip}	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27a4:	2f2fe321 	svccs	0x002fe321
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27a8:	3d2d591f 	stccc	9, cr5, [sp, #-124]!	; 0xffffff84

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27ac:	4b2d3d2d 	blmi	b51c68 <_etext+0xb4a750>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27b0:	913b4b2d 	teqls	fp, sp, lsr #22
    27b4:	1f212f8f 	svcne	0x00212f8f
    27b8:	2d2f4983 	stccs	9, cr4, [pc, #-524]!	; 25b4 <f25519_inv__distinct+0x398>
    27bc:	1f833b21 	svcne	0x00833b21
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    27c0:	08671f83 	stmdaeq	r7!, {r0, r1, r7, r8, r9, sl, fp, ip}^
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27c4:	2d2f2fe3 	stccs	15, cr2, [pc, #-908]!	; 2440 <f25519_inv__distinct+0x224>
    27c8:	2d212d4b 	stccs	13, cr2, [r1, #-300]!	; 0xfffffed4
    27cc:	2d2f1f3d 	stccs	15, cr1, [pc, #-244]!	; 26e0 <f25519_inv__distinct+0x4c4>

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27d0:	2d591f4b 	ldclcs	15, cr1, [r9, #-300]	; 0xfffffed4
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    27d4:	212cd783 	smlawbcs	ip, r3, r7, sp
    27d8:	3b21213b 	blcc	84accc <_etext+0x8437b4>

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    27dc:	2d214921 	stccs	9, cr4, [r1, #-132]!	; 0xffffff7c
    27e0:	1f831f91 	svcne	0x00831f91
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    27e4:	212fb967 	teqcs	pc, r7, ror #18
	c = (c >> 7) * 19;
    27e8:	3d2d3d1f 	stccc	13, cr3, [sp, #-124]!	; 0xffffff84

	for (i = 0; i < F25519_SIZE; i++) {
    27ec:	752d2f3b 	strvc	r2, [sp, #-3899]!	; 0xf3b
		c += r[i];
    27f0:	671f911f 			; <UNDEFINED> instruction: 0x671f911f
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27f4:	2d212f57 	stccs	15, cr2, [r1, #-348]!	; 0xfffffea4
		c += r[i];
		r[i] = c;
		c >>= 8;
    27f8:	2d212d83 	stccs	13, cr2, [r1, #-524]!	; 0xfffffdf4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27fc:	1f212d21 	svcne	0x00212d21
	f25519_mul__distinct(r, s, x);

	/* 1 */
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}
    2800:	1f752d21 	svcne	0x00752d21
    2804:	ab671f9f 	blge	19ca688 <_etext+0x19c3170>
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    2808:	2f213b2f 	svccs	0x00213b2f
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    280c:	212d591f 	teqcs	sp, pc, lsl r9
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    2810:	2f2d213b 	svccs	0x002d213b
	f25519_copy(r, tmp);
}

void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
    2814:	831f672d 	tsthi	pc, #11796480	; 0xb40000
    2818:	3d9d671f 	ldccc	7, cr6, [sp, #124]	; 0x7c
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += b * ((uint32_t)a[i]);
    281c:	2d671f21 	stclcs	15, cr1, [r7, #-132]!	; 0xffffff7c
    2820:	3b212d21 	blcc	84dcac <_etext+0x846794>
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2824:	2d831f91 	stccs	15, cr1, [r3, #580]	; 0x244
    2828:	1f308f67 	svcne	0x00308f67
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    282c:	2d214991 	stccs	9, cr4, [r1, #-580]!	; 0xfffffdbc
    2830:	1f833b21 	svcne	0x00833b21
	c >>= 7;
	c *= 19;
    2834:	8f672d83 	svchi	0x00672d83
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    2838:	3d1f212f 	ldfccs	f2, [pc, #-188]	; 2784 <f25519_inv__distinct+0x568>
	c >>= 7;
	c *= 19;
    283c:	3d1f2f2d 	ldccc	15, cr2, [pc, #-180]	; 2790 <f25519_inv__distinct+0x574>
    2840:	752d4b3b 	strvc	r4, [sp, #-2875]!	; 0xb3b

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2844:	4b1f751f 	blmi	7dfcc8 <_etext+0x7d87b0>
		r[i] = c;
    2848:	591f30b9 	ldmdbpl	pc, {r0, r3, r4, r5, r7, ip, sp}	; <UNPREDICTABLE>

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    284c:	2d2f3b08 	vstmdbcs	pc!, {d3-d6}
		c += r[i];
		r[i] = c;
		c >>= 8;
    2850:	3b212d21 	blcc	84dcdc <_etext+0x8467c4>

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2854:	2d831f83 	stccs	15, cr1, [r3, #524]	; 0x20c
    2858:	1f1fbb67 	svcne	0x001fbb67
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    285c:	21212d21 	teqcs	r1, r1, lsr #26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2860:	212d4b2d 	teqcs	sp, sp, lsr #22
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2864:	831f9149 	tsthi	pc, #1073741842	; 0x40000012
    2868:	2fab672d 	svccs	0x00ab672d

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    286c:	2d3d2d2f 	ldccs	13, cr2, [sp, #-188]!	; 0xffffff44
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2870:	492f2d3d 	stmdbmi	pc!, {r0, r2, r3, r4, r5, r8, sl, fp, sp}	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2874:	2d831f91 	stccs	15, cr1, [r3, #580]	; 0x244
    2878:	212f5767 	teqcs	pc, r7, ror #14
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    287c:	4b2d751f 	blmi	b5fd00 <_etext+0xb587e8>
    2880:	913b212d 	teqls	fp, sp, lsr #2
    2884:	672d9f1f 			; <UNDEFINED> instruction: 0x672d9f1f
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2888:	2d2f2fd5 	stccs	15, cr2, [pc, #-852]!	; 253c <f25519_inv__distinct+0x320>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    288c:	3b212d59 	blcc	84ddf8 <_etext+0x8468e0>
    2890:	2d2f2d21 	stccs	13, cr2, [pc, #-132]!	; 2814 <f25519_sqrt+0xc>
    2894:	2d831f67 	stccs	15, cr1, [r3, #412]	; 0x19c

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2898:	212cbb67 	teqcs	ip, r7, ror #22
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    289c:	2d2f212d 	stfcss	f2, [pc, #-180]!	; 27f0 <f25519_inv__distinct+0x5d4>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28a0:	1f3d2d75 	svcne	0x003d2d75
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28a4:	3b832d2f 	blcc	fe0cdd68 <BootRAM+0xd03e509>
	c = (c >> 7) * 19;
    28a8:	2d30f191 	ldfcsd	f7, [r0, #-580]!	; 0xfffffdbc
    28ac:	1f212d75 	svcne	0x00212d75
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28b0:	2d2f4921 	stccs	9, cr4, [pc, #-132]!	; 2834 <f25519_sqrt+0x2c>
	c = (c >> 7) * 19;
    28b4:	2d831f67 	stccs	15, cr1, [r3, #412]	; 0x19c
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28b8:	492dbb67 	pushmi	{r0, r1, r2, r5, r6, r8, r9, fp, ip, sp, pc}
	c = (c >> 7) * 19;
    28bc:	21212d21 	teqcs	r1, r1, lsr #26

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    28c0:	212d4b2d 	teqcs	sp, sp, lsr #22
		r[i] = c;
    28c4:	672d212d 	strvs	r2, [sp, -sp, lsr #2]!
		c >>= 8;
    28c8:	672d9f1f 			; <UNDEFINED> instruction: 0x672d9f1f
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28cc:	2d2f2f9d 	stccs	15, cr2, [pc, #-628]!	; 2660 <f25519_inv__distinct+0x444>
    28d0:	2d212d59 	stccs	13, cr2, [r1, #-356]!	; 0xfffffe9c
    28d4:	1f754959 	svcne	0x00754959
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    28d8:	2d592d67 	ldclcs	13, cr2, [r9, #-412]	; 0xfffffe64
		for (j = 0; j <= i; j++)
    28dc:	3b2f2d2f 	blcc	bcdda0 <_etext+0xbc6888>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    28e0:	082d213d 	stmdaeq	sp!, {r0, r2, r3, r4, r5, r8, sp}
    28e4:	2d214991 	stccs	9, cr4, [r1, #-580]!	; 0xfffffdbc
    28e8:	2d211f21 	stccs	15, cr1, [r1, #-132]!	; 0xffffff7c

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    28ec:	2d9f1f75 	ldccs	15, cr1, [pc, #468]	; 2ac8 <f25519_sqrt+0x2c0>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    28f0:	2d30ab67 	fldmdbxcs	r0!, {d10-d60}	;@ Deprecated

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    28f4:	2d3d2d2f 	ldccs	13, cr2, [sp, #-188]!	; 0xffffff44
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    28f8:	2d671f3d 	stclcs	15, cr1, [r7, #-244]!	; 0xffffff0c
    28fc:	1f752d2f 	svcne	0x00752d2f
    2900:	9d4b2d67 	stclls	13, cr2, [fp, #-412]	; 0xfffffe64
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2904:	592d3d2f 	pushpl	{r0, r1, r2, r3, r5, r8, sl, fp, ip, sp}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2908:	212d2149 	teqcs	sp, r9, asr #2
    290c:	831f833b 	tsthi	pc, #-335544320	; 0xec000000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2910:	2fab672d 	svccs	0x00ab672d
			c += ((uint32_t)a[j]) *
    2914:	2d3d1f21 	ldccs	15, cr1, [sp, #-132]!	; 0xffffff7c
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2918:	3b212d4b 	blcc	84de4c <_etext+0x846934>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    291c:	2d9f1f75 	ldccs	15, cr1, [pc, #468]	; 2af8 <f25519_sqrt+0x2f0>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2920:	2f2fab67 	svccs	0x002fab67
	c = (c >> 7) * 19;
    2924:	3d2d3d2d 	stccc	13, cr3, [sp, #-180]!	; 0xffffff4c
    2928:	4b2d2f2d 	blmi	b4e5e4 <_etext+0xb470cc>
    292c:	831f752d 	tsthi	pc, #188743680	; 0xb400000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2930:	2f654b2d 	svccs	0x00654b2d
	c = (c >> 7) * 19;
    2934:	2d751f21 	ldclcs	15, cr1, [r5, #-132]!	; 0xffffff7c
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2938:	3b212d4b 	blcc	84de6c <_etext+0x846954>
    293c:	2d9f1f91 	ldccs	15, cr1, [pc, #580]	; 2b88 <f25519_sqrt+0x380>
	c = (c >> 7) * 19;
    2940:	2f2fab67 	svccs	0x002fab67

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2944:	212d3d2d 	teqcs	sp, sp, lsr #26
		r[i] = c;
    2948:	2f2d2f2d 	svccs	0x002d2f2d
		c >>= 8;
    294c:	831f9149 	tsthi	pc, #1073741842	; 0x40000012
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2950:	2cad672d 	stccs	7, cr6, [sp], #180	; 0xb4
    2954:	3d2d4b2f 	fstmdbxcc	sp!, {d4-d26}	;@ Deprecated
    2958:	212d2f2d 	teqcs	sp, sp, lsr #30
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    295c:	672d212d 	strvs	r2, [sp, -sp, lsr #2]!

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2960:	672d9f1f 			; <UNDEFINED> instruction: 0x672d9f1f
    2964:	2d212f9d 	stccs	15, cr2, [r1, #-628]!	; 0xfffffd8c
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2968:	1f212d21 	svcne	0x00212d21
		for (j = 0; j <= i; j++)
    296c:	1f2f492f 	svcne	0x002f492f
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2970:	2d2f1f75 	stccs	15, cr1, [pc, #-468]!	; 27a4 <f25519_inv__distinct+0x588>
    2974:	2dad1f2f 	stccs	15, cr1, [sp, #188]!	; 0xbc

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2978:	57212d2f 	strpl	r2, [r1, -pc, lsr #26]!
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    297c:	212d4b21 	teqcs	sp, r1, lsr #22

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2980:	2157082d 	cmpcs	r7, sp, lsr #16
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2984:	1f212d21 	svcne	0x00212d21
    2988:	3b4b2d2f 	blcc	12cde4c <_etext+0x12c6934>
    298c:	adf31f75 	ldclge	15, cr1, [r3, #468]!	; 0x1d4
    2990:	2d2d212d 	stfcss	f2, [sp, #-180]!	; 0xffffff4c
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2994:	2f2d4b2f 	svccs	0x002d4b2f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2998:	673b3d3b 			; <UNDEFINED> instruction: 0x673b3d3b
    299c:	2f2dad49 	svccs	0x002dad49

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29a0:	2157212d 	cmpcs	r7, sp, lsr #2
			c += ((uint32_t)a[j]) *
    29a4:	2d212d4b 	stccs	13, cr2, [r1, #-300]!	; 0xfffffed4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    29a8:	2d21212d 	stfcss	f2, [r1, #-180]!	; 0xffffff4c
    29ac:	492f1f21 	stmdbmi	pc!, {r0, r5, r8, r9, sl, fp, ip}	; <UNPREDICTABLE>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    29b0:	1f751f21 	svcne	0x00751f21
    29b4:	1f2f2d21 	svcne	0x002f2d21
    29b8:	2d2f2d9f 	stccs	13, cr2, [pc, #-636]!	; 2744 <f25519_inv__distinct+0x528>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29bc:	4b215721 	blmi	858648 <_etext+0x851130>
	c = (c >> 7) * 19;
    29c0:	2d2d212d 	stfcss	f2, [sp, #-180]!	; 0xffffff4c
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29c4:	2f2d5921 	svccs	0x002d5921
	c = (c >> 7) * 19;
    29c8:	673b3d3b 			; <UNDEFINED> instruction: 0x673b3d3b
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29cc:	2f2dad49 	svccs	0x002dad49
	c = (c >> 7) * 19;
    29d0:	2157212d 	cmpcs	r7, sp, lsr #2

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    29d4:	211f2249 	tstcs	pc, r9, asr #4
		r[i] = c;
    29d8:	211f4b2d 	tstcs	pc, sp, lsr #22
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    29dc:	4b2d4b3b 	blmi	b556d0 <_etext+0xb4e1b8>
		c += r[i];
		r[i] = c;
		c >>= 8;
    29e0:	211f2f1f 	tstcs	pc, pc, lsl pc	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    29e4:	ad1f2f2d 	ldcge	15, cr2, [pc, #-180]	; 2938 <f25519_sqrt+0x130>
    29e8:	212d2f2d 	teqcs	sp, sp, lsr #30
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    29ec:	2f2d2157 	svccs	0x002d2157
		for (j = 0; j <= i; j++)
    29f0:	2f212c21 	svccs	0x00212c21
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    29f4:	3d2d212d 	stfccs	f2, [sp, #-180]!	; 0xffffff4c
    29f8:	4b2d212d 	blmi	b4aeb4 <_etext+0xb4399c>
    29fc:	1f21081f 	svcne	0x0021081f

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a00:	1f21493d 	svcne	0x0021493d
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a04:	753d3b21 	ldrvc	r3, [sp, #-2849]!	; 0xb21

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a08:	673b832d 	ldrvs	r8, [fp, -sp, lsr #6]!
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a0c:	672d9173 			; <UNDEFINED> instruction: 0x672d9173
    2a10:	2d2d223b 	sfmcs	f2, 4, [sp, #-236]!	; 0xffffff14
    2a14:	2f2d9121 	svccs	0x002d9121
    2a18:	752d912d 	strvc	r9, [sp, #-301]!	; 0x12d
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2a1c:	832d672d 	teqhi	sp, #11796480	; 0xb40000
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a20:	3d492f2d 	stclcc	15, cr2, [r9, #-180]	; 0xffffff4c
    2a24:	2157212d 	cmpcs	r7, sp, lsr #2

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a28:	1e212f1f 	mcrne	15, 1, r2, cr1, cr15, {0}
			c += ((uint32_t)a[j]) *
    2a2c:	4b2d2f21 	blmi	b4e6b8 <_etext+0xb471a0>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2a30:	082d212d 	stmdaeq	sp!, {r0, r2, r3, r5, r8, sp}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2a34:	3b2f2d75 	blcc	bce010 <_etext+0xbc6af8>
    2a38:	3bad3bc9 	blcc	feb51964 <BootRAM+0xdac2105>
    2a3c:	492f2d2f 	stmdbmi	pc!, {r0, r1, r2, r3, r5, r8, sl, fp, sp}	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a40:	2f2d1f22 	svccs	0x002d1f22
	c = (c >> 7) * 19;
    2a44:	bb2d3e1f 	bllt	b522c8 <_etext+0xb4adb0>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a48:	672d2f2d 	strvs	r2, [sp, -sp, lsr #30]!
	c = (c >> 7) * 19;
    2a4c:	d72d2f1f 			; <UNDEFINED> instruction: 0xd72d2f1f
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a50:	3d2d2f1f 	stccc	15, cr2, [sp, #-124]!	; 0xffffff84
	c = (c >> 7) * 19;
    2a54:	2149211f 	cmpcs	r9, pc, lsl r1

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2a58:	2d2f2f3b 	stccs	15, cr2, [pc, #-236]!	; 2974 <f25519_sqrt+0x16c>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a5c:	1e4b2d3d 	mcrne	13, 2, r2, cr11, cr13, {1}
		c += r[i];
		r[i] = c;
    2a60:	211f2d22 	tstcs	pc, r2, lsr #26
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a64:	2d3d1fbb 	ldccs	15, cr1, [sp, #-748]!	; 0xfffffd14
		c += r[i];
		r[i] = c;
		c >>= 8;
    2a68:	3b67572f 	blcc	19d872c <_etext+0x19d1214>
	/* 1 1 */
	f25519_mul__distinct(r, x, x);
	f25519_mul__distinct(s, r, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    2a6c:	1f2f3b4b 	svcne	0x002f3b4b
    2a70:	1f301f21 	svcne	0x00301f21
    2a74:	1fd72d21 	svcne	0x00d72d21
    2a78:	2d4b2d4b 	stclcs	13, cr2, [fp, #-300]	; 0xfffffed4
    2a7c:	3b2f1f2f 	blcc	bca740 <_etext+0xbc3228>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2a80:	1f2f1f59 	svcne	0x002f1f59
		for (j = 0; j <= i; j++)
    2a84:	2d212d21 	stccs	13, cr2, [r1, #-132]!	; 0xffffff7c
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a88:	9f1fc92f 	svcls	0x001fc92f
    2a8c:	9f1f672d 	svcls	0x001f672d

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a90:	2fe32f49 	svccs	0x00e32f49
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a94:	212d213b 	teqcs	sp, fp, lsr r1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a98:	c8080903 	stmdagt	r8, {r0, r1, r8, fp}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a9c:	03207703 	teqeq	r0, #786432	; 0xc0000
    2aa0:	1b1c2e09 	blne	70e2cc <_etext+0x706db4>
    2aa4:	78032333 	stmdavc	r3, {r0, r1, r4, r5, r8, r9, sp}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2aa8:	1c1c3620 	ldcne	6, cr3, [ip], {32}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2aac:	2f1f1f24 	svccs	0x001f1f24
    2ab0:	1f251b24 	svcne	0x00251b24

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ab4:	2b2f311c 	blcs	bcef2c <_etext+0xbc7a14>
			c += ((uint32_t)a[j]) *
    2ab8:	2f322b32 	svccs	0x00322b32
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2abc:	000f022f 	andeq	r0, pc, pc, lsr #4
    2ac0:	05000101 	streq	r0, [r0, #-257]	; 0x101
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2ac4:	004f9802 	subeq	r9, pc, r2, lsl #16
    2ac8:	01c10300 	biceq	r0, r1, r0, lsl #6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2acc:	311d3101 	tstcc	sp, r1, lsl #2
	c = (c >> 7) * 19;
    2ad0:	1d232322 	stcne	3, cr2, [r3, #-136]!	; 0xffffff78
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2ad4:	3e21341d 	mcrcc	4, 1, r3, cr1, cr13, {0}
	c = (c >> 7) * 19;
    2ad8:	4c200a03 	stcmi	10, cr0, [r0], #-12
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2adc:	243a1f21 	ldrtcs	r1, [sl], #-3873	; 0xf21
	c = (c >> 7) * 19;
    2ae0:	6703972a 	strvs	r9, [r3, -sl, lsr #14]

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2ae4:	1303363c 	movwne	r3, #13884	; 0x363c
		r[i] = c;
    2ae8:	032b5b2e 	teqeq	fp, #47104	; 0xb800
		c >>= 8;
    2aec:	59762e6f 	ldmdbpl	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp}^
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2af0:	2e0b0321 	cdpcs	3, 0, cr0, cr11, cr1, {1}
    2af4:	01000202 	tsteq	r0, r2, lsl #4
    2af8:	02050001 	andeq	r0, r5, #1
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2afc:	00005028 	andeq	r5, r0, r8, lsr #32
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2b00:	0101f003 	tsteq	r1, r3
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b04:	03252f34 	teqeq	r5, #52, 30	; 0xd0
    2b08:	0a032e74 	beq	ce4e0 <_etext+0xc6fc8>
    2b0c:	311d3120 	tstcc	sp, r0, lsr #2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b10:	25587303 	ldrbcs	r7, [r8, #-771]	; 0x303
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b14:	03205403 	teqeq	r0, #50331648	; 0x3000000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b18:	5703202c 	strpl	r2, [r3, -ip, lsr #32]
    2b1c:	202d032e 	eorcs	r0, sp, lr, lsr #6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b20:	4a530367 	bmi	14c38c4 <_etext+0x14bc3ac>
    2b24:	032e2303 	teqeq	lr, #201326592	; 0xc000000
    2b28:	03832009 	orreq	r2, r3, #9
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2b2c:	3024664f 	eorcc	r6, r4, pc, asr #12
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b30:	363c7803 	ldrtcc	r7, [ip], -r3, lsl #16
    2b34:	22581103 	subscs	r1, r8, #-1073741824	; 0xc0000000
    2b38:	23666403 	cmncs	r6, #50331648	; 0x3000000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b3c:	341d1d31 	ldrcc	r1, [sp], #-3377	; 0xd31
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2b40:	78033e21 	stmdavc	r3, {r0, r5, r9, sl, fp, ip, sp}
    2b44:	0351363c 	cmpeq	r1, #60, 12	; 0x3c00000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b48:	20032e0c 	andcs	r2, r3, ip, lsl #28
	c = (c >> 7) * 19;
    2b4c:	91919174 	orrsls	r9, r1, r4, ror r1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b50:	9f919191 	svcls	0x00919191
	c = (c >> 7) * 19;
    2b54:	3c47039f 	mcrrcc	3, 9, r0, r7, cr15
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b58:	1e2f3d92 	mcrne	13, 1, r3, cr15, cr2, {4}
	c = (c >> 7) * 19;
    2b5c:	1f215a34 	svcne	0x00215a34

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2b60:	032a243a 	teqeq	sl, #973078528	; 0x3a000000
		r[i] = c;
    2b64:	773eac76 			; <UNDEFINED> instruction: 0x773eac76
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b68:	1e3e1e2f 	cdpne	14, 3, cr1, cr14, cr15, {1}
		c += r[i];
		r[i] = c;
		c >>= 8;
    2b6c:	21262a34 	teqcs	r6, r4, lsr sl
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b70:	2a243a1f 	bcs	9113f4 <_etext+0x909edc>
    2b74:	03433f55 	movteq	r3, #16213	; 0x3f55
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b78:	06023c76 			; <UNDEFINED> instruction: 0x06023c76
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2b7c:	30010100 	andcc	r0, r1, r0, lsl #2
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b80:	02000005 	andeq	r0, r0, #5
    2b84:	00016000 	andeq	r6, r1, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b88:	fb010200 	blx	43392 <_etext+0x3be7a>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b8c:	01000d0e 	tsteq	r0, lr, lsl #26

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b90:	00010101 	andeq	r0, r1, r1, lsl #2
    2b94:	00010000 	andeq	r0, r1, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b98:	35320100 	ldrcc	r0, [r2, #-256]!	; 0x100
    2b9c:	00393135 	eorseq	r3, r9, r5, lsr r1
    2ba0:	705c3a63 	subsvc	r3, ip, r3, ror #20
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2ba4:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ba8:	66206d61 	strtvs	r6, [r0], -r1, ror #26
    2bac:	73656c69 	cmnvc	r5, #26880	; 0x6900
    2bb0:	38782820 	ldmdacc	r8!, {r5, fp, sp}^

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2bb4:	675c2936 	smmlarvs	ip, r6, r9, r2
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2bb8:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2bbc:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bc0:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80
	c = (c >> 7) * 19;
    2bc4:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000
    2bc8:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bcc:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}
	c = (c >> 7) * 19;
    2bd0:	30322038 	eorscc	r2, r2, r8, lsr r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bd4:	33713431 	cmncc	r1, #822083584	; 0x31000000
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2bd8:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
		r[i] = c;
    2bdc:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2be0:	61652d65 	cmnvs	r5, r5, ror #26
		c += r[i];
		r[i] = c;
		c >>= 8;
    2be4:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2be8:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    2bec:	6d5c6564 	cfldr64vs	mvdx6, [ip, #-400]	; 0xfffffe70
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2bf0:	69686361 	stmdbvs	r8!, {r0, r5, r6, r8, r9, sp, lr}^
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2bf4:	6300656e 	movwvs	r6, #1390	; 0x56e
		for (j = 0; j <= i; j++)
    2bf8:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2bfc:	6172676f 	cmnvs	r2, pc, ror #14
    2c00:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
    2c04:	2073656c 	rsbscs	r6, r3, ip, ror #10

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c08:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c0c:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c10:	6f742075 	svcvs	0x00742075
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c14:	20736c6f 	rsbscs	r6, r3, pc, ror #24
    2c18:	206d7261 	rsbcs	r7, sp, r1, ror #4
    2c1c:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2c20:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c24:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    2c28:	31303220 	teqcc	r0, r0, lsr #4

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c2c:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
			c += ((uint32_t)a[j]) *
    2c30:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2c34:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2c38:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c3c:	6e695c69 	cdpvs	12, 6, cr5, cr9, cr9, {3}
	c = (c >> 7) * 19;
    2c40:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
    2c44:	3a630065 	bcc	18c2de0 <_etext+0x18bb8c8>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c48:	6f72705c 	svcvs	0x0072705c
    2c4c:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64
	c = (c >> 7) * 19;
    2c50:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c54:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2c58:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
		r[i] = c;
    2c5c:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c60:	6f6f7420 	svcvs	0x006f7420
		c += r[i];
		r[i] = c;
		c >>= 8;
    2c64:	6120736c 	teqvs	r0, ip, ror #6
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c68:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
    2c6c:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c70:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2c74:	20382e34 	eorscs	r2, r8, r4, lsr lr
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c78:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
    2c7c:	6c5c3371 	mrrcvs	3, 7, r3, ip, cr1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c80:	675c6269 	ldrbvs	r6, [ip, -r9, ror #4]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c84:	615c6363 	cmpvs	ip, r3, ror #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c88:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    2c8c:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c90:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    2c94:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    2c98:	695c342e 	ldmdbvs	ip, {r1, r2, r3, r5, sl, ip, sp}^
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2c9c:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ca0:	00006564 	andeq	r6, r0, r4, ror #10
    2ca4:	35616873 	strbcc	r6, [r1, #-2163]!	; 0x873
    2ca8:	632e3231 	teqvs	lr, #268435459	; 0x10000003

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cac:	00000100 	andeq	r0, r0, r0, lsl #2
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2cb0:	6665645f 			; <UNDEFINED> instruction: 0x6665645f
    2cb4:	746c7561 	strbtvc	r7, [ip], #-1377	; 0x561
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cb8:	7079745f 	rsbsvc	r7, r9, pc, asr r4
	c = (c >> 7) * 19;
    2cbc:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cc0:	00000200 	andeq	r0, r0, r0, lsl #4
	c = (c >> 7) * 19;
    2cc4:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cc8:	682e746e 	stmdavs	lr!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
	c = (c >> 7) * 19;
    2ccc:	00000300 	andeq	r0, r0, r0, lsl #6

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2cd0:	64647473 	strbtvs	r7, [r4], #-1139	; 0x473
		r[i] = c;
    2cd4:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}
		c >>= 8;
    2cd8:	00000400 	andeq	r0, r0, r0, lsl #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2cdc:	35616873 	strbcc	r6, [r1, #-2163]!	; 0x873
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    2ce0:	682e3231 	stmdavs	lr!, {r0, r4, r5, r9, ip, sp}
    2ce4:	00000100 	andeq	r0, r0, r0, lsl #2
    2ce8:	02050000 	andeq	r0, r5, #0
    2cec:	00005240 	andeq	r5, r0, r0, asr #4
    2cf0:	0100e403 	tsteq	r0, r3, lsl #8
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2cf4:	585a033c 	ldmdapl	sl, {r2, r3, r4, r5, r8, r9}^
    2cf8:	f3839f21 			; <UNDEFINED> instruction: 0xf3839f21
    2cfc:	bbbb1308 	bllt	feec7924 <BootRAM+0xde380c5>
		r[i] = c;
    2d00:	03662603 	cmneq	r6, #3145728	; 0x300000
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2d04:	2403205a 	strcs	r2, [r3], #-90	; 0x5a
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2d08:	272d212e 	strcs	r2, [sp, -lr, lsr #2]!
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2d0c:	212d1f21 	teqcs	sp, r1, lsr #30
    2d10:	332f2c2f 	teqcc	pc, #12032	; 0x2f00
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2d14:	2f46321c 	svccs	0x0046321c
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2d18:	207a0323 	rsbscs	r0, sl, r3, lsr #6
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2d1c:	322b2b26 	eorcc	r2, fp, #38912	; 0x9800
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2d20:	2f1c222f 	svccs	0x001c222f
    2d24:	03324631 	teqeq	r2, #51380224	; 0x3100000
	c = (c >> 7) * 19;
    2d28:	09032079 	stmdbeq	r3, {r0, r3, r4, r5, r6, sp}

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2d2c:	1f2f2a20 	svcne	0x002f2a20
		r[i] = c;
    2d30:	2b21494c 	blcs	855268 <_etext+0x84dd50>

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d34:	032f3b4d 	teqeq	pc, #78848	; 0x13400
		c += r[i];
		r[i] = c;
		c >>= 8;
    2d38:	6a085819 	bvs	218da4 <_etext+0x21188c>

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d3c:	02040200 	andeq	r0, r4, #0, 4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d40:	002e6703 	eoreq	r6, lr, r3, lsl #14

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d44:	03020402 	movweq	r0, #9218	; 0x2402
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d48:	02003c66 	andeq	r3, r0, #26112	; 0x6600
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2d4c:	1b030204 	blne	c3564 <_etext+0xbc04c>
		for (j = 0; j <= i; j++)
    2d50:	040200ba 	streq	r0, [r2], #-186	; 0xba
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d54:	2e650302 	cdpcs	3, 6, cr0, cr5, cr2, {0}
    2d58:	02040200 	andeq	r0, r4, #0, 4
    2d5c:	002e1b03 	eoreq	r1, lr, r3, lsl #22

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d60:	03020402 	movweq	r0, #9218	; 0x2402
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d64:	02002e65 	andeq	r2, r0, #1616	; 0x650

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d68:	1b030204 	blne	c3580 <_etext+0xbc068>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d6c:	0402003c 	streq	r0, [r2], #-60	; 0x3c
    2d70:	2e650302 	cdpcs	3, 6, cr0, cr5, cr2, {0}
    2d74:	02040200 	andeq	r0, r4, #0, 4
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2d78:	002e1b03 	eoreq	r1, lr, r3, lsl #22
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d7c:	03020402 	movweq	r0, #9218	; 0x2402
    2d80:	02002e65 	andeq	r2, r0, #1616	; 0x650

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d84:	1f030204 	svcne	0x00030204
			c += ((uint32_t)a[j]) *
    2d88:	04020020 	streq	r0, [r2], #-32
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2d8c:	02001c02 	andeq	r1, r0, #512	; 0x200
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2d90:	65030204 	strvs	r0, [r3, #-516]	; 0x204
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d94:	04020020 	streq	r0, [r2], #-32
	c = (c >> 7) * 19;
    2d98:	3c1f0302 	ldccc	3, cr0, [pc], {2}
    2d9c:	02040200 	andeq	r0, r4, #0, 4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2da0:	002e6103 	eoreq	r6, lr, r3, lsl #2
	c = (c >> 7) * 19;
    2da4:	03020402 	movweq	r0, #9218	; 0x2402
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2da8:	0200661f 	andeq	r6, r0, #32505856	; 0x1f00000
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2dac:	61030204 	tstvs	r3, r4, lsl #4
		r[i] = c;
    2db0:	04020020 	streq	r0, [r2], #-32
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2db4:	3c1c0302 	ldccc	3, cr0, [ip], {2}
		c += r[i];
		r[i] = c;
		c >>= 8;
    2db8:	02040200 	andeq	r0, r4, #0, 4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2dbc:	003c6403 	eorseq	r6, ip, r3, lsl #8
    2dc0:	03020402 	movweq	r0, #9218	; 0x2402
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2dc4:	0200581c 	andeq	r5, r0, #28, 16	; 0x1c0000
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2dc8:	64030204 	strvs	r0, [r3], #-516	; 0x204
		for (j = 0; j <= i; j++)
    2dcc:	0402002e 	streq	r0, [r2], #-46	; 0x2e
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2dd0:	2e1f0302 	cdpcs	3, 1, cr0, cr15, cr2, {0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2dd4:	02040200 	andeq	r0, r4, #0, 4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2dd8:	00206103 	eoreq	r6, r0, r3, lsl #2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2ddc:	03020402 	movweq	r0, #9218	; 0x2402
    2de0:	0200581c 	andeq	r5, r0, #28, 16	; 0x1c0000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2de4:	00330204 	eorseq	r0, r3, r4, lsl #4
    2de8:	2c020402 	cfstrscs	mvf0, [r2], {2}
    2dec:	02040200 	andeq	r0, r4, #0, 4
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2df0:	00206103 	eoreq	r6, r0, r3, lsl #2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2df4:	03020402 	movweq	r0, #9218	; 0x2402
    2df8:	02004a1f 	andeq	r4, r0, #126976	; 0x1f000
    2dfc:	005a0204 	subseq	r0, sl, r4, lsl #4

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e00:	1e020402 	cdpne	4, 0, cr0, cr2, cr2, {0}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2e04:	02040200 	andeq	r0, r4, #0, 4
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2e08:	04020022 	streq	r0, [r2], #-34	; 0x22

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2e0c:	3c5f0302 	mrrccc	3, 0, r0, pc, cr2	; <UNPREDICTABLE>
    2e10:	02040200 	andeq	r0, r4, #0, 4
    2e14:	00d61e03 	sbcseq	r1, r6, r3, lsl #28
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e18:	6d020402 	cfstrsvs	mvf0, [r2, #-8]
    2e1c:	02040200 	andeq	r0, r4, #0, 4
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e20:	0402002a 	streq	r0, [r2], #-42	; 0x2a
		c += r[i];
    2e24:	02003202 	andeq	r3, r0, #536870912	; 0x20000000
		r[i] = c;
    2e28:	11030204 	tstne	r3, r4, lsl #4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e2c:	040200ba 	streq	r0, [r2], #-186	; 0xba
		c += r[i];
		r[i] = c;
		c >>= 8;
    2e30:	2e670302 	cdpcs	3, 6, cr0, cr7, cr2, {0}
	f25519_sub(i, i, y);

	/* r = avi */
	f25519_mul__distinct(x, v, a);
	f25519_mul__distinct(r, x, i);
}
    2e34:	02040200 	andeq	r0, r4, #0, 4
    2e38:	00581903 	subseq	r1, r8, r3, lsl #18
}

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
    2e3c:	03020402 	movweq	r0, #9218	; 0x2402
    2e40:	0200ac4a 	andeq	sl, r0, #18944	; 0x4a00
    2e44:	36030204 	strcc	r0, [r3], -r4, lsl #4
    2e48:	04020082 	streq	r0, [r2], #-130	; 0x82
static int prime_msb(const uint8_t *p)
{
	int i;
	uint8_t x;

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
    2e4c:	204a0302 	subcs	r0, sl, r2, lsl #6
    2e50:	02040200 	andeq	r0, r4, #0, 4
    2e54:	002e3603 	eoreq	r3, lr, r3, lsl #12
		if (p[i])
    2e58:	03020402 	movweq	r0, #9218	; 0x2402
			break;

	x = p[i];
	i <<= 3;
    2e5c:	02002e4a 	andeq	r2, r0, #1184	; 0x4a0

	while (x) {
		x >>= 1;
		i++;
    2e60:	21030204 	tstcs	r3, r4, lsl #4
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    2e64:	0402002e 	streq	r0, [r2], #-46	; 0x2e

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
    2e68:	02006502 	andeq	r6, r0, #8388608	; 0x800000
		x[i] = 0;
}

static inline int min_int(int a, int b)
{
	return a < b ? a : b;
    2e6c:	16030204 	strne	r0, [r3], -r4, lsl #4
    2e70:	0402003c 	streq	r0, [r2], #-60	; 0x3c
void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
    2e74:	206a0302 	rsbcs	r0, sl, r2, lsl #6
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);
    2e78:	02040200 	andeq	r0, r4, #0, 4
    2e7c:	002e1603 	eoreq	r1, lr, r3, lsl #12
    2e80:	03020402 	movweq	r0, #9218	; 0x2402

	for (i = 0; i < preload_bytes; i++)
    2e84:	02004a70 	andeq	r4, r0, #112, 20	; 0x70000
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
    2e88:	5a030204 	bpl	c36a0 <_etext+0xbc188>
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
    2e8c:	040200d6 	streq	r0, [r2], #-214	; 0xd6
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2e90:	2e270302 	cdpcs	3, 2, cr0, cr7, cr2, {0}
    2e94:	02040200 	andeq	r0, r4, #0, 4
    2e98:	002e5903 	eoreq	r5, lr, r3, lsl #18
    2e9c:	03020402 	movweq	r0, #9218	; 0x2402
    2ea0:	02002e27 	andeq	r2, r0, #624	; 0x270
    2ea4:	59030204 	stmdbpl	r3, {r2, r9}
    2ea8:	0402003c 	streq	r0, [r2], #-60	; 0x3c
    2eac:	20270302 	eorcs	r0, r7, r2, lsl #6
    2eb0:	02040200 	andeq	r0, r4, #0, 4
    2eb4:	002e5903 	eoreq	r5, lr, r3, lsl #18
    2eb8:	03020402 	movweq	r0, #9218	; 0x2402
    2ebc:	02002e27 	andeq	r2, r0, #624	; 0x270
    2ec0:	59030204 	stmdbpl	r3, {r2, r9}
    2ec4:	0402003c 	streq	r0, [r2], #-60	; 0x3c
    2ec8:	4a280302 	bmi	a03ad8 <_etext+0x9fc5c0>
    2ecc:	02040200 	andeq	r0, r4, #0, 4
    2ed0:	002e5803 	eoreq	r5, lr, r3, lsl #16
		n[i] = x[len - preload_bytes + i];
    2ed4:	03020402 	movweq	r0, #9218	; 0x2402
    2ed8:	02003c27 	andeq	r3, r0, #9984	; 0x2700
    2edc:	002f0204 	eoreq	r0, pc, r4, lsl #4
    2ee0:	03020402 	movweq	r0, #9218	; 0x2402
    2ee4:	02002e58 	andeq	r2, r0, #88, 28	; 0x580
    2ee8:	28030204 	stmdacs	r3, {r2, r9}
    2eec:	0402002e 	streq	r0, [r2], #-46	; 0x2e
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2ef0:	2e580302 	cdpcs	3, 5, cr0, cr8, cr2, {0}
		n[i] = x[len - preload_bytes + i];
    2ef4:	02040200 	andeq	r0, r4, #0, 4
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2ef8:	003c2803 	eorseq	r2, ip, r3, lsl #16
		n[i] = x[len - preload_bytes + i];
    2efc:	03020402 	movweq	r0, #9218	; 0x2402
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f00:	02002058 	andeq	r2, r0, #88	; 0x58
    2f04:	24030204 	strcs	r0, [r3], #-516	; 0x204
    2f08:	0402003c 	streq	r0, [r2], #-60	; 0x3c
		n[i] = x[len - preload_bytes + i];
    2f0c:	ba120302 	blt	483b1c <_etext+0x47c604>
    2f10:	02040200 	andeq	r0, r4, #0, 4
    2f14:	002e7103 	eoreq	r7, lr, r3, lsl #2

	if (preload_bits) {
    2f18:	03020402 	movweq	r0, #9218	; 0x2402
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c |= ((uint16_t)x[i]) << n;
    2f1c:	02002e0f 	andeq	r2, r0, #15, 28	; 0xf0
    2f20:	71030204 	tstvc	r3, r4, lsl #4
		x[i] = c;
    2f24:	0402002e 	streq	r0, [r2], #-46	; 0x2e
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f28:	02004b02 	andeq	r4, r0, #2048	; 0x800
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    2f2c:	002d0204 	eoreq	r0, sp, r4, lsl #4
	for (i = 0; i < preload_bytes; i++)
		n[i] = x[len - preload_bytes + i];

	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
    2f30:	3d020402 	cfstrscc	mvf0, [r2, #-8]
    2f34:	02040200 	andeq	r0, r4, #0, 4
    2f38:	0402009d 	streq	r0, [r2], #-157	; 0x9d
    2f3c:	02005a02 	andeq	r5, r0, #8192	; 0x2000
    2f40:	005e0204 	subseq	r0, lr, r4, lsl #4
    2f44:	5c020402 	cfstrspl	mvf0, [r2], {2}
	}

	for (i = rbits - 1; i >= 0; i--) {
    2f48:	02040200 	andeq	r0, r4, #0, 4
    2f4c:	033c6503 	teqeq	ip, #12582912	; 0xc00000
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;
    2f50:	6759f222 	ldrbvs	pc, [r9, -r2, lsr #4]	; <UNPREDICTABLE>
    2f54:	2b2f3180 	blcs	bcf55c <_etext+0xbc8044>
    2f58:	1f3e5930 	svcne	0x003e5930
    2f5c:	2f312b67 	svccs	0x00312b67
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f60:	207a032d 	rsbscs	r0, sl, sp, lsr #6
		c |= ((uint16_t)x[i]) << n;
    2f64:	2c7d2f34 	ldclcs	15, cr2, [sp], #-208	; 0xffffff30
		x[i] = c;
    2f68:	302f2b31 	eorcc	r2, pc, r1, lsr fp	; <UNPREDICTABLE>
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f6c:	2f2f312c 	svccs	0x002f312c
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    2f70:	06022f2f 	streq	r2, [r2], -pc, lsr #30

	for (i = rbits - 1; i >= 0; i--) {
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;

		shift_n_bits(n, 1);
		n[0] |= bit;
    2f74:	00010100 	andeq	r0, r1, r0, lsl #2
    2f78:	56d40205 	ldrbpl	r0, [r4], r5, lsl #4
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f7c:	a6030000 	strge	r0, [r3], -r0
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
    2f80:	1f2f0101 	svcne	0x002f0101
    2f84:	3e5b3d20 	cdpcc	13, 5, cr3, cr11, cr0, {1}
		minusp[i] = c;
    2f88:	7f9a0336 	svcvc	0x009a0336
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f8c:	241e2220 	ldrcs	r2, [lr], #-544	; 0x220
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
    2f90:	2e00e303 	cdpcs	3, 0, cr14, cr0, cr3, {0}
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f94:	2e7f9803 	cdpcs	8, 7, cr9, cr15, cr3, {0}

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    2f98:	30303030 	eorscc	r3, r0, r0, lsr r0
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    2f9c:	03303030 	teqeq	r0, #48	; 0x30
    2fa0:	2f2e00da 	svccs	0x002e00da
    2fa4:	593c7503 	ldmdbpl	ip!, {r0, r1, r8, sl, ip, sp, lr}
    2fa8:	21301e3e 	teqcs	r0, lr, lsr lr
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
    2fac:	0006024b 	andeq	r0, r6, fp, asr #4
	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
	}

	for (i = rbits - 1; i >= 0; i--) {
    2fb0:	05000101 	streq	r0, [r0, #-257]	; 0x101
    2fb4:	00575c02 	subseq	r5, r7, r2, lsl #24

		shift_n_bits(n, 1);
		n[0] |= bit;
		raw_try_sub(n, modulus);
	}
}
    2fb8:	01ba0300 			; <UNDEFINED> instruction: 0x01ba0300

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
    2fbc:	201d3101 	andscs	r3, sp, r1, lsl #2
	i <<= 3;

	while (x) {
    2fc0:	245c2331 	ldrbcs	r2, [ip], #-817	; 0x331
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
    2fc4:	02002438 	andeq	r2, r0, #56, 8	; 0x38000000
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fc8:	0e030104 	adfeqs	f0, f3, f4
		n[i] = x[len - preload_bytes + i];
    2fcc:	1208062e 	andne	r0, r8, #48234496	; 0x2e00000
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fd0:	f7034b06 			; <UNDEFINED> instruction: 0xf7034b06
    2fd4:	0384587e 	orreq	r5, r4, #8257536	; 0x7e0000
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    2fd8:	03200187 	teqeq	r0, #-1073741791	; 0xc0000021
    (b)[(i) + 2] = (uint8) ( (n) >>  8 );       \
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    2fdc:	3e207ef9 	mcrcc	14, 1, r7, cr0, cr9, {7}
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    2fe0:	46302248 	ldrtmi	r2, [r0], -r8, asr #4
void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    2fe4:	3e301e26 	cdpcc	14, 3, cr1, cr0, cr6, {1}
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    2fe8:	74770368 	ldrbtvc	r0, [r7], #-872	; 0x368
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    2fec:	032e0903 	teqeq	lr, #49152	; 0xc000
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    2ff0:	0a032e77 	beq	ce9d4 <_etext+0xc74bc>
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    2ff4:	2e720320 	cdpcs	3, 7, cr0, cr2, cr0, {1}
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    2ff8:	032e0c03 	teqeq	lr, #768	; 0x300
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    2ffc:	0a032e74 	beq	ce9d4 <_etext+0xc74bc>
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    3000:	2a1e1e20 	bcs	78a888 <_etext+0x783370>
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    3004:	20018703 	andcs	r8, r1, r3, lsl #14
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
    3008:	207f8503 	rsbscs	r8, pc, r3, lsl #10
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;
    300c:	2e00fb03 	vmlacs.f64	d15, d0, d3
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
}
    3010:	03423508 	movteq	r3, #9480	; 0x2508
    3014:	ff033c6c 			; <UNDEFINED> instruction: 0xff033c6c
    3018:	5a4c587e 	bpl	1319218 <_etext+0x1311d00>
    301c:	322c302c 	eorcc	r3, ip, #44	; 0x2c
    3020:	322c4c2c 	eorcc	r4, ip, #44, 24	; 0x2c00
    3024:	7703302c 	strvc	r3, [r3, -ip, lsr #32]
    3028:	2e0b034a 	cdpcs	3, 0, cr0, cr11, cr10, {2}
    302c:	75033446 	strvc	r3, [r3, #-1094]	; 0x446
    3030:	352c343c 	strcc	r3, [ip, #-1084]!	; 0x43c

void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    3034:	032e7a03 	teqeq	lr, #12288	; 0x3000
    3038:	032e00f6 	teqeq	lr, #246	; 0xf6
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    303c:	302e7f87 	eorcc	r7, lr, r7, lsl #31
    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    3040:	76034230 			; <UNDEFINED> instruction: 0x76034230
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3044:	2d31342e 	cfldrscs	mvf3, [r1, #-184]!	; 0xffffff48
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    3048:	2e00f603 	cfmadd32cs	mvax0, mvfx15, mvfx0, mvfx3
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    304c:	7f8b0321 	svcvc	0x008b0321
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    3050:	00ef0320 	rsceq	r0, pc, r0, lsr #6
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3054:	7f910320 	svcvc	0x00910320
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    3058:	00f40358 	rscseq	r0, r4, r8, asr r3
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    305c:	3d1f302e 	ldccc	0, cr3, [pc, #-184]	; 2fac <fprime_from_bytes+0x170>
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3060:	7f8a031f 	svcvc	0x008a031f
    3064:	00f6033c 	rscseq	r0, r6, ip, lsr r3
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3068:	312b302e 	teqcc	fp, lr, lsr #32
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    306c:	3c11032b 	ldccc	3, cr0, [r1], {43}	; 0x2b
    3070:	827eee03 	rsbshi	lr, lr, #3, 28	; 0x30
    3074:	4c302c5a 	ldcmi	12, cr2, [r0], #-360	; 0xfffffe98
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3078:	5a4c4c68 	bpl	1316220 <_etext+0x130ed08>
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    307c:	032e7303 	teqeq	lr, #201326592	; 0xc000000
    3080:	03302e0b 	teqeq	r0, #11, 28	; 0xb0
    3084:	0a034a73 	beq	d5a58 <_etext+0xce540>
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3088:	302c322e 	eorcc	r3, ip, lr, lsr #4
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    308c:	77032d1e 	smladvc	r3, lr, sp, r2
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3090:	2e0b032e 	cdpcs	3, 0, cr0, cr11, cr14, {1}
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3094:	302e7703 	eorcc	r7, lr, r3, lsl #14
    3098:	018c0330 	orreq	r0, ip, r0, lsr r3
    309c:	7efa032e 	cdpvc	3, 15, cr0, cr10, cr14, {1}
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    30a0:	01860320 	orreq	r0, r6, r0, lsr #6
    30a4:	7ef9032e 	cdpvc	3, 15, cr0, cr9, cr14, {1}
    30a8:	01870320 	orreq	r0, r7, r0, lsr #6
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30ac:	0302302e 	movweq	r3, #8238	; 0x202e
    30b0:	36010100 	strcc	r0, [r1], -r0, lsl #2
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    30b4:	02000002 	andeq	r0, r0, #2
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30b8:	0001bb00 	andeq	fp, r1, r0, lsl #22
    30bc:	fb010200 	blx	438c6 <_etext+0x3c3ae>
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30c0:	01000d0e 	tsteq	r0, lr, lsl #26
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30c4:	00010101 	andeq	r0, r1, r1, lsl #2
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30c8:	00010000 	andeq	r0, r1, r0
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    30cc:	3a630100 	bcc	18c34d4 <_etext+0x18bbfbc>
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30d0:	6f72705c 	svcvs	0x0072705c
    30d4:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30d8:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30dc:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30e0:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
    30e4:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30e8:	6f6f7420 	svcvs	0x006f7420
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30ec:	6120736c 	teqvs	r0, ip, ror #6
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30f0:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    30f4:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30f8:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30fc:	20382e34 	eorscs	r2, r8, r4, lsr lr
    3100:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    3104:	6c5c3371 	mrrcvs	3, 7, r3, ip, cr1
    3108:	675c6269 	ldrbvs	r6, [ip, -r9, ror #4]
    310c:	615c6363 	cmpvs	ip, r3, ror #6
    3110:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    3114:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    3118:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    311c:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    3120:	695c342e 	ldmdbvs	ip, {r1, r2, r3, r5, sl, ip, sp}^
    3124:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    3128:	63006564 	movwvs	r6, #1380	; 0x564
    312c:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
    3130:	6172676f 	cmnvs	r2, pc, ror #14
    3134:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
    3138:	2073656c 	rsbscs	r6, r3, ip, ror #10
    313c:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
    3140:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
    3144:	6f742075 	svcvs	0x00742075
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3148:	20736c6f 	rsbscs	r6, r3, pc, ror #24
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    314c:	206d7261 	rsbcs	r7, sp, r1, ror #4
    3150:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
    3154:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3158:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    315c:	31303220 	teqcc	r0, r0, lsr #4
    3160:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3164:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3168:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
    316c:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3170:	6e695c69 	cdpvs	12, 6, cr5, cr9, cr9, {3}
    3174:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
    3178:	616d5c65 	cmnvs	sp, r5, ror #24
    317c:	6e696863 	cdpvs	8, 6, cr6, cr9, cr3, {3}
    3180:	3a630065 	bcc	18c331c <_etext+0x18bbe04>
    3184:	6f72705c 	svcvs	0x0072705c
    3188:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64
    318c:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
    3190:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3194:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3198:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
    319c:	6f6f7420 	svcvs	0x006f7420
    31a0:	6120736c 	teqvs	r0, ip, ror #6
    31a4:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
    31a8:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
    31ac:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31b0:	20382e34 	eorscs	r2, r8, r4, lsr lr
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31b4:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
    31b8:	615c3371 	cmpvs	ip, r1, ror r3
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31bc:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    31c0:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    31c4:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31c8:	636e695c 	cmnvs	lr, #92, 18	; 0x170000
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31cc:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31d0:	732f2e00 	teqvc	pc, #0, 28

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31d4:	32336d74 	eorscc	r6, r3, #116, 26	; 0x1d00
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31d8:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
    GET_UINT32( W[4],  data, 16 );
    31dc:	322f2e00 	eorcc	r2, pc, #0, 28
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31e0:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    31e4:	6d690000 	stclvs	0, cr0, [r9, #-0]
    31e8:	2e656761 	cdpcs	7, 6, cr6, cr5, cr1, {3}
    31ec:	00000063 	andeq	r0, r0, r3, rrx

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31f0:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31f4:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31f8:	00010068 	andeq	r0, r1, r8, rrx
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31fc:	65645f00 	strbvs	r5, [r4, #-3840]!	; 0xf00
    3200:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
    3204:	79745f74 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    3208:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
    320c:	00020068 	andeq	r0, r2, r8, rrx
    3210:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3214:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3218:	00030068 	andeq	r0, r3, r8, rrx
    321c:	6d747300 	ldclvs	3, cr7, [r4, #-0]
    3220:	31663233 	cmncc	r6, r3, lsr r2
    3224:	745f7830 	ldrbvc	r7, [pc], #-2096	; 322c <sha256_process+0x1f8>

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3228:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    322c:	00040068 	andeq	r0, r4, r8, rrx

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3230:	61687300 	cmnvs	r8, r0, lsl #6
    3234:	2e363532 	mrccs	5, 1, r3, cr6, cr2, {1}
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3238:	00050068 	andeq	r0, r5, r8, rrx

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    323c:	616d6900 	cmnvs	sp, r0, lsl #18
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3240:	682e6567 	stmdavs	lr!, {r0, r1, r2, r5, r6, r8, sl, sp, lr}

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3244:	00000000 	andeq	r0, r0, r0
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3248:	2e627375 	mcrcs	3, 3, r7, cr2, cr5, {3}
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    324c:	00000068 	andeq	r0, r0, r8, rrx
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3250:	72616800 	rsbvc	r6, r1, #0, 16
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3254:	72617764 	rsbvc	r7, r1, #100, 14	; 0x1900000

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3258:	00682e65 	rsbeq	r2, r8, r5, ror #28

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    325c:	73000000 	movwvc	r0, #0
    3260:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3264:	00682e67 	rsbeq	r2, r8, r7, ror #28
    3268:	65000003 	strvs	r0, [r0, #-3]

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    326c:	67697364 	strbvs	r7, [r9, -r4, ror #6]!
    3270:	00682e6e 	rsbeq	r2, r8, lr, ror #28
    3274:	00000005 	andeq	r0, r0, r5
    3278:	f4020500 	vst3.8	{d0,d2,d4}, [r2], r0
    327c:	03000059 	movweq	r0, #89	; 0x59
    3280:	3d220125 	stfccs	f0, [r2, #-148]!	; 0xffffff6c
    3284:	3e3d3d3d 	mrccc	13, 1, r3, cr13, cr13, {1}
    3288:	0010022d 	andseq	r0, r0, sp, lsr #4
    328c:	05000101 	streq	r0, [r0, #-257]	; 0x101
    3290:	005a3802 	subseq	r3, sl, r2, lsl #16
    3294:	01300300 	teqeq	r0, r0, lsl #6
    3298:	251b333c 	ldrcs	r3, [fp, #-828]	; 0x33c
    329c:	2f591e4d 	svccs	0x00591e4d
    32a0:	03580c03 	cmpeq	r8, #768	; 0x300
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32a4:	2f4d4a0a 	svccs	0x004d4a0a

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32a8:	3021303e 	eorcc	r3, r1, lr, lsr r0
    32ac:	331b2532 	tstcc	fp, #209715200	; 0xc800000
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32b0:	401c251b 	andsmi	r2, ip, fp, lsl r5
    32b4:	211f4331 	tstcs	pc, r1, lsr r3	; <UNPREDICTABLE>

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32b8:	002c832d 	eoreq	r8, ip, sp, lsr #6
    32bc:	24010402 	strcs	r0, [r1], #-1026	; 0x402
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32c0:	1f213d76 	svcne	0x00213d76
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32c4:	00211f21 	eoreq	r1, r1, r1, lsr #30

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32c8:	06010402 	streq	r0, [r1], -r2, lsl #8
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32cc:	68840658 	stmvs	r4, {r3, r4, r6, r9, sl}
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32d0:	03672259 	cmneq	r7, #-1879048187	; 0x90000005
    32d4:	1fc92e0c 	svcne	0x00c92e0c
    32d8:	1d4e4f59 	stclne	15, cr4, [lr, #-356]	; 0xfffffe9c
    32dc:	a0311d23 	eorsge	r1, r1, r3, lsr #26
    32e0:	303e2f75 	eorscc	r2, lr, r5, ror pc
    32e4:	25213121 	strcs	r3, [r1, #-289]!	; 0x121
    32e8:	01000b02 	tsteq	r0, r2, lsl #22

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32ec:	0004c701 	andeq	ip, r4, r1, lsl #14
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32f0:	45000200 	strmi	r0, [r0, #-512]	; 0x200
    32f4:	02000000 	andeq	r0, r0, #0
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    32f8:	0d0efb01 	vstreq	d15, [lr, #-4]
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32fc:	01010100 	mrseq	r0, (UNDEF: 17)
    3300:	00000001 	andeq	r0, r0, r1
    3304:	01000001 	tsteq	r0, r1
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    3308:	5f627375 	svcpl	0x00627375
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    330c:	0062696c 	rsbeq	r6, r2, ip, ror #18
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    3310:	62737500 	rsbsvs	r7, r3, #0, 10
    3314:	6765725f 			; <UNDEFINED> instruction: 0x6765725f
    3318:	00632e73 	rsbeq	r2, r3, r3, ror lr
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    331c:	75000001 	strvc	r0, [r0, #-1]
    3320:	745f6273 	ldrbvc	r6, [pc], #-627	; 3328 <sha256_process+0x2f4>
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    3324:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
    3328:	00010068 	andeq	r0, r1, r8, rrx
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    332c:	62737500 	rsbsvs	r7, r3, #0, 10
    3330:	6765725f 			; <UNDEFINED> instruction: 0x6765725f
    3334:	00682e73 	rsbeq	r2, r8, r3, ror lr
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3338:	00000001 	andeq	r0, r0, r1
    333c:	00020500 	andeq	r0, r2, r0, lsl #10
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3340:	03000000 	movweq	r0, #0
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3344:	02130122 	andseq	r0, r3, #-2147483640	; 0x80000008
    3348:	01010006 	tsteq	r1, r6
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    334c:	00020500 	andeq	r0, r2, r0, lsl #10
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3350:	03000000 	movweq	r0, #0
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3354:	2f13012e 	svccs	0x0013012e
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3358:	01000402 	tsteq	r0, r2, lsl #8
    335c:	02050001 	andeq	r0, r5, #1
    3360:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3364:	13013a03 	movwne	r3, #6659	; 0x1a03
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3368:	01000602 	tsteq	r0, r2, lsl #12
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    336c:	02050001 	andeq	r0, r5, #1
    3370:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3374:	0100c603 	tsteq	r0, r3, lsl #12
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3378:	04022f13 	streq	r2, [r2], #-3859	; 0xf13
    337c:	00010100 	andeq	r0, r1, r0, lsl #2
    3380:	00000205 	andeq	r0, r0, r5, lsl #4
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3384:	d2030000 	andle	r0, r3, #0
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3388:	2f130100 	svccs	0x00130100
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    338c:	01000402 	tsteq	r0, r2, lsl #8
    3390:	02050001 	andeq	r0, r5, #1
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3394:	00000000 	andeq	r0, r0, r0
    3398:	0100de03 	tsteq	r0, r3, lsl #28
    339c:	00060213 	andeq	r0, r6, r3, lsl r2
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    33a0:	05000101 	streq	r0, [r0, #-257]	; 0x101
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33a4:	00000002 	andeq	r0, r0, r2
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    33a8:	00ea0300 	rsceq	r0, sl, r0, lsl #6
    33ac:	022f1301 	eoreq	r1, pc, #67108864	; 0x4000000
    33b0:	01010004 	tsteq	r1, r4
    33b4:	00020500 	andeq	r0, r2, r0, lsl #10
    33b8:	03000000 	movweq	r0, #0
    33bc:	130100f6 	movwne	r0, #4342	; 0x10f6
    33c0:	01000802 	tsteq	r0, r2, lsl #16
    33c4:	02050001 	andeq	r0, r5, #1
    33c8:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33cc:	01018203 	tsteq	r1, r3, lsl #4
    33d0:	04022f13 	streq	r2, [r2], #-3859	; 0xf13
    33d4:	00010100 	andeq	r0, r1, r0, lsl #2
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    33d8:	00000205 	andeq	r0, r0, r5, lsl #4
    33dc:	8f030000 	svchi	0x00030000
    33e0:	02130101 	andseq	r0, r3, #1073741824	; 0x40000000
    33e4:	01010007 	tsteq	r1, r7
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33e8:	00020500 	andeq	r0, r2, r0, lsl #10
    33ec:	03000000 	movweq	r0, #0
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    33f0:	1301019b 	movwne	r0, #4507	; 0x119b
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    33f4:	00020267 	andeq	r0, r2, r7, ror #4
    33f8:	05000101 	streq	r0, [r0, #-257]	; 0x101
    33fc:	00000002 	andeq	r0, r0, r2
    3400:	01a80300 			; <UNDEFINED> instruction: 0x01a80300
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3404:	0e021301 	cdpeq	3, 0, cr1, cr2, cr1, {0}
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3408:	00010100 	andeq	r0, r1, r0, lsl #2
    340c:	00000205 	andeq	r0, r0, r5, lsl #4
    3410:	b4030000 	strlt	r0, [r3], #-0
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3414:	67130101 	ldrvs	r0, [r3, -r1, lsl #2]
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3418:	01000302 	tsteq	r0, r2, lsl #6
    341c:	02050001 	andeq	r0, r5, #1
    3420:	00005bbc 			; <UNDEFINED> instruction: 0x00005bbc
    3424:	0101c103 	tsteq	r1, r3, lsl #2
    3428:	00150213 	andseq	r0, r5, r3, lsl r2
    342c:	05000101 	streq	r0, [r0, #-257]	; 0x101
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3430:	00000002 	andeq	r0, r0, r2
    3434:	01ce0300 	biceq	r0, lr, r0, lsl #6
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3438:	15021301 	strne	r1, [r2, #-769]	; 0x301
    343c:	00010100 	andeq	r0, r1, r0, lsl #2
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3440:	00000205 	andeq	r0, r0, r5, lsl #4
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3444:	db030000 	blle	c344c <_etext+0xbbf34>
    3448:	41030101 	tstmi	r3, r1, lsl #2
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    344c:	00c20301 	sbceq	r0, r2, r1, lsl #6
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3450:	7fbe0358 	svcvc	0x00be0358
    3454:	00c20320 	sbceq	r0, r2, r0, lsr #6
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3458:	303e2220 	eorscc	r2, lr, r0, lsr #4
    345c:	01000502 	tsteq	r0, r2, lsl #10
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3460:	02050001 	andeq	r0, r5, #1
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3464:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[9],  data, 36 );
    3468:	0101f003 	tsteq	r1, r3
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    346c:	03026713 	movweq	r6, #10003	; 0x2713
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3470:	00010100 	andeq	r0, r1, r0, lsl #2
    3474:	00000205 	andeq	r0, r0, r5, lsl #4
    3478:	fc030000 	stc2	0, cr0, [r3], {-0}
    347c:	67130101 	ldrvs	r0, [r3, -r1, lsl #2]
    3480:	01000302 	tsteq	r0, r2, lsl #6
    3484:	02050001 	andeq	r0, r5, #1
    3488:	00000000 	andeq	r0, r0, r0
    348c:	01028803 	tsteq	r2, r3, lsl #16
    3490:	000f0213 	andeq	r0, pc, r3, lsl r2	; <UNPREDICTABLE>
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3494:	05000101 	streq	r0, [r0, #-257]	; 0x101
    3498:	005be602 	subseq	lr, fp, r2, lsl #12
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    349c:	02940300 	addseq	r0, r4, #0, 6
    34a0:	0f021301 	svceq	0x00021301
    34a4:	00010100 	andeq	r0, r1, r0, lsl #2
    34a8:	00000205 	andeq	r0, r0, r5, lsl #4
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34ac:	a0030000 	andge	r0, r3, r0
    34b0:	02130102 	andseq	r0, r3, #-2147483648	; 0x80000000
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34b4:	0101000f 	tsteq	r1, pc
    34b8:	00020500 	andeq	r0, r2, r0, lsl #10
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34bc:	03000000 	movweq	r0, #0
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34c0:	130102ac 	movwne	r0, #4780	; 0x12ac
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34c4:	01000e02 	tsteq	r0, r2, lsl #28
    34c8:	02050001 	andeq	r0, r5, #1
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34cc:	00005c04 	andeq	r5, r0, r4, lsl #24
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34d0:	0102b703 	tsteq	r2, r3, lsl #14
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34d4:	000e0213 	andeq	r0, lr, r3, lsl r2
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34d8:	05000101 	streq	r0, [r0, #-257]	; 0x101
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34dc:	00000002 	andeq	r0, r0, r2
    34e0:	02c20300 	sbceq	r0, r2, #0, 6
    34e4:	0f021301 	svceq	0x00021301
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    34e8:	00010100 	andeq	r0, r1, r0, lsl #2
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34ec:	00000205 	andeq	r0, r0, r5, lsl #4
    34f0:	cd030000 	stcgt	0, cr0, [r3, #-0]
    34f4:	02130102 	andseq	r0, r3, #-2147483648	; 0x80000000
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    34f8:	0101000f 	tsteq	r1, pc
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34fc:	00020500 	andeq	r0, r2, r0, lsl #10
    3500:	03000000 	movweq	r0, #0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3504:	130102d8 	movwne	r0, #4824	; 0x12d8
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3508:	01000e02 	tsteq	r0, r2, lsl #28
    350c:	02050001 	andeq	r0, r5, #1
    3510:	00000000 	andeq	r0, r0, r0
    3514:	0102e303 	tsteq	r2, r3, lsl #6
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3518:	05028313 	streq	r8, [r2, #-787]	; 0x313
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    351c:	00010100 	andeq	r0, r1, r0, lsl #2
    3520:	00000205 	andeq	r0, r0, r5, lsl #4
    3524:	ee030000 	cdp	0, 0, cr0, cr3, cr0, {0}
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3528:	83130102 	tsthi	r3, #-2147483648	; 0x80000000
    352c:	01000502 	tsteq	r0, r2, lsl #10
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3530:	02050001 	andeq	r0, r5, #1
    3534:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3538:	0102f903 	tsteq	r2, r3, lsl #18
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    353c:	000c0213 	andeq	r0, ip, r3, lsl r2
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3540:	05000101 	streq	r0, [r0, #-257]	; 0x101
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3544:	00000002 	andeq	r0, r0, r2
    3548:	03840300 	orreq	r0, r4, #0, 6
    354c:	0e021301 	cdpeq	3, 0, cr1, cr2, cr1, {0}
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3550:	00010100 	andeq	r0, r1, r0, lsl #2
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3554:	00000205 	andeq	r0, r0, r5, lsl #4
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3558:	8f030000 	svchi	0x00030000
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    355c:	02130103 	andseq	r0, r3, #-1073741824	; 0xc0000000
    3560:	01010010 	tsteq	r1, r0, lsl r0
    3564:	00020500 	andeq	r0, r2, r0, lsl #10
    3568:	03000000 	movweq	r0, #0
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    356c:	1301039a 	movwne	r0, #5018	; 0x139a
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3570:	01001002 	tsteq	r0, r2
    3574:	02050001 	andeq	r0, r5, #1
    3578:	00005c20 	andeq	r5, r0, r0, lsr #24
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    357c:	0103a503 	tsteq	r3, r3, lsl #10
    3580:	04020013 	streq	r0, [r2], #-19
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3584:	02820601 	addeq	r0, r2, #1048576	; 0x100000
    3588:	01010008 	tsteq	r1, r8
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    358c:	40020500 	andmi	r0, r2, r0, lsl #10
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3590:	0300005c 	movweq	r0, #92	; 0x5c
    3594:	130103b0 	movwne	r0, #5040	; 0x13b0
    3598:	01040200 	mrseq	r0, R12_usr
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    359c:	08028206 	stmdaeq	r2, {r1, r2, r9, pc}
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35a0:	00010100 	andeq	r0, r1, r0, lsl #2
    35a4:	00000205 	andeq	r0, r0, r5, lsl #4
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35a8:	bc030000 	stclt	0, cr0, [r3], {-0}
    35ac:	02130103 	andseq	r0, r3, #-1073741824	; 0xc0000000
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35b0:	0101000f 	tsteq	r1, pc
    35b4:	00020500 	andeq	r0, r2, r0, lsl #10
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35b8:	03000000 	movweq	r0, #0
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35bc:	130103c7 	movwne	r0, #5063	; 0x13c7
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35c0:	00030267 	andeq	r0, r3, r7, ror #4
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35c4:	05000101 	streq	r0, [r0, #-257]	; 0x101
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35c8:	00000002 	andeq	r0, r0, r2
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35cc:	03d30300 	bicseq	r0, r3, #0, 6
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35d0:	10021301 	andne	r1, r2, r1, lsl #6
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35d4:	00010100 	andeq	r0, r1, r0, lsl #2
    35d8:	00000205 	andeq	r0, r0, r5, lsl #4
    35dc:	df030000 	svcle	0x00030000
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35e0:	02130103 	andseq	r0, r3, #-1073741824	; 0xc0000000
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35e4:	01010010 	tsteq	r1, r0, lsl r0
    35e8:	60020500 	andvs	r0, r2, r0, lsl #10
    35ec:	0300005c 	movweq	r0, #92	; 0x5c
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    35f0:	130103ea 	movwne	r0, #5098	; 0x13ea
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35f4:	0004029f 	muleq	r4, pc, r2	; <UNPREDICTABLE>
    35f8:	05000101 	streq	r0, [r0, #-257]	; 0x101
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    35fc:	005c7c02 	subseq	r7, ip, r2, lsl #24
    3600:	03f50300 	mvnseq	r0, #0, 6
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3604:	02831301 	addeq	r1, r3, #67108864	; 0x4000000
    3608:	01010006 	tsteq	r1, r6
    360c:	98020500 	stmdals	r2, {r8, sl}
    3610:	0300005c 	movweq	r0, #92	; 0x5c
    3614:	13010481 	movwne	r0, #5249	; 0x1481
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3618:	01000e02 	tsteq	r0, r2, lsl #28
    361c:	02050001 	andeq	r0, r5, #1
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3620:	00000000 	andeq	r0, r0, r0
    3624:	01048d03 	tsteq	r4, r3, lsl #26
    3628:	04020013 	streq	r0, [r2], #-19
    362c:	002e0601 	eoreq	r0, lr, r1, lsl #12
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3630:	9e020402 	cdpls	4, 0, cr0, cr2, cr2, {0}
    3634:	01000702 	tsteq	r0, r2, lsl #14
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3638:	02050001 	andeq	r0, r5, #1
    363c:	00005cb4 			; <UNDEFINED> instruction: 0x00005cb4
    3640:	01049903 	tsteq	r4, r3, lsl #18
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3644:	04020013 	streq	r0, [r2], #-19
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3648:	00ac0601 	adceq	r0, ip, r1, lsl #12
    364c:	9e020402 	cdpls	4, 0, cr0, cr2, cr2, {0}
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3650:	01000b02 	tsteq	r0, r2, lsl #22
    3654:	02050001 	andeq	r0, r5, #1
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3658:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    365c:	0104a403 	tsteq	r4, r3, lsl #8
    3660:	07029113 	smladeq	r2, r3, r1, r9
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3664:	00010100 	andeq	r0, r1, r0, lsl #2
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3668:	00000205 	andeq	r0, r0, r5, lsl #4
    366c:	af030000 	svcge	0x00030000
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3670:	91130104 	tstls	r3, r4, lsl #2
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3674:	01000702 	tsteq	r0, r2, lsl #14
    3678:	02050001 	andeq	r0, r5, #1
    367c:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3680:	0104bc03 	tsteq	r4, r3, lsl #24
    3684:	001b0221 	andseq	r0, fp, r1, lsr #4
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3688:	05000101 	streq	r0, [r0, #-257]	; 0x101
    368c:	00000002 	andeq	r0, r0, r2
    3690:	04c80300 	strbeq	r0, [r8], #768	; 0x300
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3694:	10021301 	andne	r1, r2, r1, lsl #6
    3698:	00010100 	andeq	r0, r1, r0, lsl #2
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    369c:	00000205 	andeq	r0, r0, r5, lsl #4
    36a0:	d4030000 	strle	r0, [r3], #-0
    36a4:	02130104 	andseq	r0, r3, #4, 2
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    36a8:	01010010 	tsteq	r1, r0, lsl r0
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36ac:	00020500 	andeq	r0, r2, r0, lsl #10
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    36b0:	03000000 	movweq	r0, #0
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36b4:	130104df 	movwne	r0, #5343	; 0x14df
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36b8:	0004029f 	muleq	r4, pc, r2	; <UNPREDICTABLE>
    36bc:	05000101 	streq	r0, [r0, #-257]	; 0x101
    36c0:	00000002 	andeq	r0, r0, r2
    36c4:	04ea0300 	strbteq	r0, [sl], #768	; 0x300
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36c8:	02831301 	addeq	r1, r3, #67108864	; 0x4000000
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36cc:	01010006 	tsteq	r1, r6
    36d0:	00020500 	andeq	r0, r2, r0, lsl #10
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36d4:	03000000 	movweq	r0, #0
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36d8:	130104f6 	movwne	r0, #5366	; 0x14f6
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36dc:	0200211f 	andeq	r2, r0, #-1073741817	; 0xc0000007
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36e0:	20060104 	andcs	r0, r6, r4, lsl #2
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36e4:	02040200 	andeq	r0, r4, #0, 4
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36e8:	02005808 	andeq	r5, r0, #8, 16	; 0x80000
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36ec:	00f20104 	rscseq	r0, r2, r4, lsl #2
    36f0:	9e020402 	cdpls	4, 0, cr0, cr2, cr2, {0}
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36f4:	01040200 	mrseq	r0, R12_usr
    36f8:	0402002e 	streq	r0, [r2], #-46	; 0x2e
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36fc:	02120802 	andseq	r0, r2, #131072	; 0x20000
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3700:	0101000e 	tsteq	r1, lr
    3704:	00020500 	andeq	r0, r2, r0, lsl #10
    3708:	03000000 	movweq	r0, #0
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    370c:	13010582 	movwne	r0, #5506	; 0x1582
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3710:	01040200 	mrseq	r0, R12_usr
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3714:	02002e06 	andeq	r2, r0, #6, 28	; 0x60
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3718:	4a080204 	bmi	203f30 <_etext+0x1fca18>
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    371c:	01040200 	mrseq	r0, R12_usr
    3720:	000e0290 	muleq	lr, r0, r2
    3724:	05000101 	streq	r0, [r0, #-257]	; 0x101
    3728:	00000002 	andeq	r0, r0, r2
    372c:	058e0300 	streq	r0, [lr, #768]	; 0x300
    3730:	02001301 	andeq	r1, r0, #67108864	; 0x4000000
    3734:	2e060104 	adfcss	f0, f6, f4
    3738:	02040200 	andeq	r0, r4, #0, 4
    373c:	02004a08 	andeq	r4, r0, #8, 20	; 0x8000
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3740:	02900104 	addseq	r0, r0, #4, 2
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3744:	0101000e 	tsteq	r1, lr
    3748:	00020500 	andeq	r0, r2, r0, lsl #10
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    374c:	03000000 	movweq	r0, #0
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3750:	1301059a 	movwne	r0, #5530	; 0x159a
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3754:	00070291 	muleq	r7, r1, r2
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3758:	05000101 	streq	r0, [r0, #-257]	; 0x101
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    375c:	00000002 	andeq	r0, r0, r2
    3760:	05a60300 	streq	r0, [r6, #768]!	; 0x300
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3764:	02911301 	addseq	r1, r1, #67108864	; 0x4000000
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3768:	01010007 	tsteq	r1, r7
    376c:	00020500 	andeq	r0, r2, r0, lsl #10
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3770:	03000000 	movweq	r0, #0
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3774:	130105b2 	movwne	r0, #5554	; 0x15b2
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3778:	25489fbc 	strbcs	r9, [r8, #-4028]	; 0xfbc
    377c:	01000702 	tsteq	r0, r2, lsl #14
    3780:	02050001 	andeq	r0, r5, #1
    3784:	00000000 	andeq	r0, r0, r0
    3788:	0105c303 	tsteq	r5, r3, lsl #6
    378c:	30bc3013 	adcscc	r3, ip, r3, lsl r0
    3790:	01000d02 	tsteq	r0, r2, lsl #26
    3794:	02050001 	andeq	r0, r5, #1
    3798:	00000000 	andeq	r0, r0, r0
    379c:	0105d603 	tsteq	r5, r3, lsl #12
    37a0:	00030216 	andeq	r0, r3, r6, lsl r2
    37a4:	05000101 	streq	r0, [r0, #-257]	; 0x101
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    37a8:	00000002 	andeq	r0, r0, r2
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37ac:	05e30300 	strbeq	r0, [r3, #768]!	; 0x300
    37b0:	02301601 	eorseq	r1, r0, #1048576	; 0x100000
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37b4:	01010003 	tsteq	r1, r3
    37b8:	000000b4 	strheq	r0, [r0], -r4
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37bc:	00600002 	rsbeq	r0, r0, r2
    37c0:	01020000 	mrseq	r0, (UNDEF: 2)
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37c4:	000d0efb 	strdeq	r0, [sp], -fp
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37c8:	01010101 	tsteq	r1, r1, lsl #2
    37cc:	01000000 	mrseq	r0, (UNDEF: 0)
    37d0:	75010000 	strvc	r0, [r1, #-0]
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37d4:	6c5f6273 	lfmvs	f6, 2, [pc], {115}	; 0x73
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37d8:	00006269 	andeq	r6, r0, r9, ror #4
    37dc:	5f627375 	svcpl	0x00627375
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37e0:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37e4:	00010063 	andeq	r0, r1, r3, rrx
    37e8:	62737500 	rsbsvs	r7, r3, #0, 10
    37ec:	7079745f 	rsbsvc	r7, r9, pc, asr r4
    37f0:	00682e65 	rsbeq	r2, r8, r5, ror #28
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37f4:	75000001 	strvc	r0, [r0, #-1]
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37f8:	725f6273 	subsvc	r6, pc, #805306375	; 0x30000007
    37fc:	2e736765 	cdpcs	7, 7, cr6, cr3, cr5, {3}
    3800:	00010068 	andeq	r0, r1, r8, rrx
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3804:	62737500 	rsbsvs	r7, r3, #0, 10
    3808:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    380c:	00682e74 	rsbeq	r2, r8, r4, ror lr
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3810:	75000001 	strvc	r0, [r0, #-1]
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3814:	635f6273 	cmpvs	pc, #805306375	; 0x30000007
    3818:	2e65726f 	cdpcs	2, 6, cr7, cr5, cr15, {3}
    381c:	00010068 	andeq	r0, r1, r8, rrx
    3820:	05000000 	streq	r0, [r0, #-0]
    3824:	005cf402 	subseq	pc, ip, r2, lsl #8
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3828:	01290300 	teqeq	r9, r0, lsl #6
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    382c:	593e8423 	ldmdbpl	lr!, {r0, r1, r5, sl, pc}
    3830:	3d1f3d36 	ldccc	13, cr3, [pc, #-216]	; 3760 <sha256_process+0x72c>
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3834:	0395914b 	orrseq	r9, r5, #-1073741806	; 0xc0000012
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3838:	30213c17 	eorcc	r3, r1, r7, lsl ip
    383c:	59304259 	ldmdbpl	r0!, {r0, r3, r4, r6, r9, lr}
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3840:	30593043 	subscc	r3, r9, r3, asr #32
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3844:	03f31308 	mvnseq	r1, #8, 6	; 0x20000000
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3848:	31672009 	cmncc	r7, r9
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    384c:	933f5c5b 	teqls	pc, #23296	; 0x5b00
    3850:	1602311d 			; <UNDEFINED> instruction: 0x1602311d
    3854:	00010100 	andeq	r0, r1, r0, lsl #2
    3858:	00000205 	andeq	r0, r0, r5, lsl #4
    385c:	9e030000 	cdpls	0, 0, cr0, cr3, cr0, {0}
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3860:	76230101 	strtvc	r0, [r3], -r1, lsl #2
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3864:	31675a3e 	cmncc	r7, lr, lsr sl
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3868:	5b313f5b 	blpl	c535dc <_etext+0xc4c0c4>
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    386c:	01010008 	tsteq	r1, r8
    3870:	00000063 	andeq	r0, r0, r3, rrx
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3874:	00450002 	subeq	r0, r5, r2
    3878:	01020000 	mrseq	r0, (UNDEF: 2)
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    387c:	000d0efb 	strdeq	r0, [sp], -fp
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3880:	01010101 	tsteq	r1, r1, lsl #2
    3884:	01000000 	mrseq	r0, (UNDEF: 0)
    3888:	75010000 	strvc	r0, [r1, #-0]
    388c:	6c5f6273 	lfmvs	f6, 2, [pc], {115}	; 0x73
    3890:	00006269 	andeq	r6, r0, r9, ror #4
    3894:	5f627375 	svcpl	0x00627375
    3898:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
    389c:	0100632e 	tsteq	r0, lr, lsr #6
    38a0:	73750000 	cmnvc	r5, #0
    38a4:	79745f62 	ldmdbvc	r4!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    38a8:	682e6570 	stmdavs	lr!, {r4, r5, r6, r8, sl, sp, lr}
    38ac:	00000100 	andeq	r0, r0, r0, lsl #2
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38b0:	5f627375 	svcpl	0x00627375
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38b4:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xf63
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38b8:	0100682e 	tsteq	r0, lr, lsr #16
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38bc:	00000000 	andeq	r0, r0, r0
    38c0:	5e480205 	cdppl	2, 4, cr0, cr8, cr5, {0}
    38c4:	35030000 	strcc	r0, [r3, #-0]
    38c8:	1d312101 	ldfnes	f2, [r1, #-4]!
    38cc:	233d2f21 	teqcs	sp, #33, 30	; 0x84
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38d0:	0f02231d 	svceq	0x0002231d
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38d4:	50010100 	andpl	r0, r1, r0, lsl #2
    38d8:	02000003 	andeq	r0, r0, #3
    38dc:	00007b00 	andeq	r7, r0, r0, lsl #22
    38e0:	fb010200 	blx	440ea <_etext+0x3cbd2>
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38e4:	01000d0e 	tsteq	r0, lr, lsl #26
    38e8:	00010101 	andeq	r0, r1, r1, lsl #2
    38ec:	00010000 	andeq	r0, r1, r0
    38f0:	73750100 	cmnvc	r5, #0, 2
    38f4:	696c5f62 	stmdbvs	ip!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    38f8:	75000062 	strvc	r0, [r0, #-98]	; 0x62
    38fc:	635f6273 	cmpvs	pc, #805306375	; 0x30000007
    3900:	2e65726f 	cdpcs	2, 6, cr7, cr5, cr15, {3}
    3904:	00010063 	andeq	r0, r1, r3, rrx
    3908:	62737500 	rsbsvs	r7, r3, #0, 10
    390c:	7079745f 	rsbsvc	r7, r9, pc, asr r4
    3910:	00682e65 	rsbeq	r2, r8, r5, ror #28
    3914:	75000001 	strvc	r0, [r0, #-1]
    3918:	645f6273 	ldrbvs	r6, [pc], #-627	; 3920 <sha256_process+0x8ec>
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    391c:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3920:	00000100 	andeq	r0, r0, r0, lsl #2
    3924:	5f627375 	svcpl	0x00627375
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3928:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xf63
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    392c:	0100682e 	tsteq	r0, lr, lsr #16
    3930:	73750000 	cmnvc	r5, #0
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3934:	6e695f62 	cdpvs	15, 6, cr5, cr9, cr2, {3}
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3938:	682e7469 	stmdavs	lr!, {r0, r3, r5, r6, sl, ip, sp, lr}
    393c:	00000100 	andeq	r0, r0, r0, lsl #2
    3940:	5f627375 	svcpl	0x00627375
    3944:	2e6d656d 	cdpcs	5, 6, cr6, cr13, cr13, {3}
    3948:	00010068 	andeq	r0, r1, r8, rrx
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    394c:	62737500 	rsbsvs	r7, r3, #0, 10
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3950:	6765725f 			; <UNDEFINED> instruction: 0x6765725f
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3954:	00682e73 	rsbeq	r2, r8, r3, ror lr
    3958:	00000001 	andeq	r0, r0, r1
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    395c:	80020500 	andhi	r0, r2, r0, lsl #10
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3960:	0300005e 	movweq	r0, #94	; 0x5e
    3964:	222f0135 	eorcs	r0, pc, #1073741837	; 0x4000000d
    3968:	2f4b223e 	svccs	0x004b223e
    396c:	01000502 	tsteq	r0, r2, lsl #10
    3970:	02050001 	andeq	r0, r5, #1
    3974:	00005ea4 	andeq	r5, r0, r4, lsr #29
    3978:	0100e303 	tsteq	r0, r3, lsl #6
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    397c:	223e222f 	eorscs	r2, lr, #-268435454	; 0xf0000002
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3980:	05022f4b 	streq	r2, [r2, #-3915]	; 0xf4b
    3984:	00010100 	andeq	r0, r1, r0, lsl #2
    3988:	5ec80205 	cdppl	2, 12, cr0, cr8, cr5, {0}
    398c:	9b030000 	blls	c3994 <_etext+0xbc47c>
    3990:	222f0101 	eorcs	r0, pc, #1073741824	; 0x40000000
    3994:	1d23233d 	stcne	3, cr2, [r3, #-244]!	; 0xffffff0c
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3998:	22235b31 	eorcs	r5, r3, #50176	; 0xc400
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    399c:	404e3040 	submi	r3, lr, r0, asr #32
    39a0:	40223133 	eormi	r3, r2, r3, lsr r1
    39a4:	231d3147 	tstcs	sp, #-1073741807	; 0xc0000011
    39a8:	0b03424c 	bleq	d42e0 <_etext+0xccdc8>
    39ac:	60034b58 	andvs	r4, r3, r8, asr fp
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39b0:	2021032e 	eorcs	r0, r1, lr, lsr #6
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39b4:	01000702 	tsteq	r0, r2, lsl #14
    39b8:	02050001 	andeq	r0, r5, #1
    39bc:	00005f58 	andeq	r5, r0, r8, asr pc
    39c0:	0103e003 	tsteq	r3, r3
    39c4:	2f2f1f13 	svccs	0x002f1f13
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39c8:	02003321 	andeq	r3, r0, #-2080374784	; 0x84000000
    39cc:	20060104 	andcs	r0, r6, r4, lsl #2
    39d0:	924d3006 	subls	r3, sp, #6
    39d4:	21352d34 	teqcs	r5, r4, lsr sp
    39d8:	4c847651 	stcmi	6, cr7, [r4], {81}	; 0x51
    39dc:	2f2f2a24 	svccs	0x002f2a24
    39e0:	23231d30 	teqcs	r3, #48, 26	; 0xc00
    39e4:	01001202 	tsteq	r0, r2, lsl #4
    39e8:	02050001 	andeq	r0, r5, #1
    39ec:	00006000 	andeq	r6, r0, r0
    39f0:	0100ca03 	tsteq	r0, r3, lsl #20
    39f4:	591f2122 	ldmdbpl	pc, {r1, r5, r8, sp}	; <UNPREDICTABLE>
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    39f8:	4b21302f 	blmi	84fabc <_etext+0x8485a4>
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39fc:	08022232 	stmdaeq	r2, {r1, r4, r5, r9, sp}
    3a00:	00010100 	andeq	r0, r1, r0, lsl #2
    3a04:	60380205 	eorsvs	r0, r8, r5, lsl #4
    3a08:	f8030000 			; <UNDEFINED> instruction: 0xf8030000
    3a0c:	84240100 	strthi	r0, [r4], #-256	; 0x100
    3a10:	0402003e 	streq	r0, [r2], #-62	; 0x3e
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a14:	06200601 	strteq	r0, [r0], -r1, lsl #12
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a18:	224b342f 	subcs	r3, fp, #788529152	; 0x2f000000
    3a1c:	252f2f1e 	strcs	r2, [pc, #-3870]!	; 2b06 <f25519_sqrt+0x2fe>
    3a20:	00070221 	andeq	r0, r7, r1, lsr #4
    3a24:	05000101 	streq	r0, [r0, #-257]	; 0x101
    3a28:	00608002 	rsbeq	r8, r0, r2
    3a2c:	01e90300 	mvneq	r0, r0, lsl #6
    3a30:	3e402101 	dvfccs	f2, f0, f1
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a34:	3d35224b 	lfmcc	f2, 4, [r5, #-300]!	; 0xfffffed4
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a38:	200f0342 	andcs	r0, pc, r2, asr #6
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a3c:	43207203 	teqmi	r0, #805306368	; 0x30000000
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a40:	2075035f 	rsbscs	r0, r5, pc, asr r3
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a44:	00314032 	eorseq	r4, r1, r2, lsr r0
    3a48:	06010402 	streq	r0, [r1], -r2, lsl #8
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a4c:	032f062e 	teqeq	pc, #48234496	; 0x2e00000
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a50:	23472e09 	movtcs	r2, #32265	; 0x7e09
    3a54:	4b4c231d 	blmi	130c6d0 <_etext+0x13051b8>
    3a58:	6b235a5e 	blvs	8da3d8 <_etext+0x8d2ec0>
    3a5c:	314b942f 	cmpcc	fp, pc, lsr #8
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a60:	000a0221 	andeq	r0, sl, r1, lsr #4
    3a64:	05000101 	streq	r0, [r0, #-257]	; 0x101
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a68:	00615002 	rsbeq	r5, r1, r2
    3a6c:	02c20300 	sbceq	r0, r2, #0, 6
    3a70:	0f032601 	svceq	0x00032601
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a74:	20710320 	rsbscs	r0, r1, r0, lsr #6
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a78:	03200f03 	teqeq	r0, #3, 30
    3a7c:	43212071 	teqmi	r1, #113	; 0x71
    3a80:	31403254 	cmpcc	r0, r4, asr r2
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a84:	0402002f 	streq	r0, [r2], #-47	; 0x2f
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a88:	062e0601 	strteq	r0, [lr], -r1, lsl #12
    3a8c:	2e090321 	cdpcs	3, 0, cr0, cr9, cr1, {1}
    3a90:	231d3147 	tstcs	sp, #-1073741807	; 0xc0000011
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a94:	034b8588 	movteq	r8, #46472	; 0xb588
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a98:	12032e6f 	andne	r2, r3, #1776	; 0x6f0
    3a9c:	00070220 	andeq	r0, r7, r0, lsr #4
    3aa0:	05000101 	streq	r0, [r0, #-257]	; 0x101
    3aa4:	0061d402 	rsbeq	sp, r1, r2, lsl #8
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3aa8:	02f80300 	rscseq	r0, r8, #0, 6
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3aac:	4c672101 	stfmie	f2, [r7], #-4
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ab0:	01000702 	tsteq	r0, r2, lsl #14
    3ab4:	02050001 	andeq	r0, r5, #1
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ab8:	000061f8 	strdeq	r6, [r0], -r8
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3abc:	01039203 	tsteq	r3, r3, lsl #4
    3ac0:	3d223d15 	stccc	13, cr3, [r2, #-84]!	; 0xffffffac
    3ac4:	04022f23 	streq	r2, [r2], #-3875	; 0xf23
    3ac8:	00010100 	andeq	r0, r1, r0, lsl #2
    3acc:	62140205 	andsvs	r0, r4, #1342177280	; 0x50000000
    3ad0:	c9030000 	stmdbgt	r3, {}	; <UNPREDICTABLE>
    3ad4:	68210107 	stmdavs	r1!, {r0, r1, r2, r8}
    3ad8:	02404b5a 	subeq	r4, r0, #92160	; 0x16800
    3adc:	0101000d 	tsteq	r1, sp
    3ae0:	54020500 	strpl	r0, [r2], #-1280	; 0x500
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ae4:	03000062 	movweq	r0, #98	; 0x62
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ae8:	280106cc 	stmdacs	r1, {r2, r3, r6, r7, r9, sl}
    3aec:	563e2c3e 			; <UNDEFINED> instruction: 0x563e2c3e
    3af0:	30302f5c 	eorscc	r2, r0, ip, asr pc
    3af4:	032f3130 	teqeq	pc, #48, 2
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3af8:	4e4a7dbd 	mcrmi	13, 2, r7, cr10, cr13, {5}
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3afc:	4f304030 	svcmi	0x00304030
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b00:	033d3d29 	teqeq	sp, #2624	; 0xa40
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b04:	03304a0c 	teqeq	r0, #12, 20	; 0xc000
    3b08:	03593c3c 	cmpeq	r9, #60, 24	; 0x3c00
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b0c:	3e3d3c44 	cdpcc	12, 3, cr3, cr13, cr4, {2}
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b10:	3d3d3044 	ldccc	0, cr3, [sp, #-272]!	; 0xfffffef0
    3b14:	3c0b033e 	stccc	3, cr0, [fp], {62}	; 0x3e
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b18:	31413031 	cmpcc	r1, r1, lsr r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b1c:	09033033 	stmdbeq	r3, {r0, r1, r4, r5, ip, sp}
    3b20:	2e0a032e 	cdpcs	3, 0, cr0, cr10, cr14, {1}
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b24:	75039c36 	strvc	r9, [r3, #-3126]	; 0xc36
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b28:	2010032e 	andscs	r0, r0, lr, lsr #6
    3b2c:	303c1903 	eorscc	r1, ip, r3, lsl #18
    3b30:	3e302f3e 	mrccc	15, 1, r2, cr0, cr14, {1}
    3b34:	3d303e30 	ldccc	14, cr3, [r0, #-192]!	; 0xffffff40
    3b38:	695a4230 	ldmdbvs	sl, {r4, r5, r9, lr}^
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b3c:	75305e4b 	ldrvc	r5, [r0, #-3659]!	; 0xe4b
    3b40:	0e03306d 	cdpeq	0, 0, cr3, cr3, cr13, {3}
    3b44:	20720320 	rsbscs	r0, r2, r0, lsr #6
    3b48:	75035f43 	strvc	r5, [r3, #-3907]	; 0xf43
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b4c:	31403220 	cmpcc	r0, r0, lsr #4
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b50:	3c090359 	stccc	3, cr0, [r9], {89}	; 0x59
    3b54:	59305030 	ldmdbpl	r0!, {r4, r5, ip, lr}
    3b58:	2289674b 	addcs	r6, r9, #19660800	; 0x12c0000
    3b5c:	322f233d 	eorcc	r2, pc, #-201326592	; 0xf4000000
    3b60:	69413067 	stmdbvs	r1, {r0, r1, r2, r5, r6, ip, sp}^
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b64:	4d413f31 	stclmi	15, cr3, [r1, #-196]	; 0xffffff3c
    3b68:	23084c31 	movwcs	r4, #35889	; 0x8c31
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b6c:	5a305a30 	bpl	c1a434 <_etext+0xc12f1c>
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b70:	2f404b40 	svccs	0x00404b40
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b74:	2f4a2f03 	svccs	0x004a2f03
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b78:	2e7ed603 	cdpcs	6, 7, cr13, cr14, cr3, {0}
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b7c:	032e2c03 	teqeq	lr, #768	; 0x300
    3b80:	0c022e0b 	stceq	14, cr2, [r2], {11}
    3b84:	00010100 	andeq	r0, r1, r0, lsl #2
    3b88:	65300205 	ldrvs	r0, [r0, #-517]!	; 0x205
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b8c:	a0030000 	andge	r0, r3, r0
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b90:	3e210107 	sufccs	f0, f1, f7
    3b94:	01040200 	mrseq	r0, R12_usr
    3b98:	03062e06 	movweq	r2, #28166	; 0x6e06
    3b9c:	1e2e7c8a 	cdpne	12, 2, cr7, cr14, cr10, {4}
    3ba0:	59263322 	stmdbpl	r6!, {r1, r5, r8, r9, ip, sp}
    3ba4:	222f211f 	eorcs	r2, pc, #-1073741817	; 0xc0000007
    3ba8:	3077301e 	rsbscc	r3, r7, lr, lsl r0
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bac:	1f2f1f21 	svcne	0x002f1f21
    3bb0:	4c3f2f21 	ldcmi	15, cr2, [pc], #-132	; 3b34 <sha256_process+0xb00>
    3bb4:	3d4e2240 	sfmcc	f2, 2, [lr, #-256]	; 0xffffff00
    3bb8:	9e03d303 	cdpls	3, 0, cr13, cr3, cr3, {0}
    3bbc:	0351303f 	cmpeq	r1, #63	; 0x3f
    3bc0:	2d312009 	ldccs	0, cr2, [r1, #-36]!	; 0xffffffdc
    3bc4:	01000f02 	tsteq	r0, r2, lsl #30
    3bc8:	02050001 	andeq	r0, r5, #1
    3bcc:	000065f8 	strdeq	r6, [r0], -r8
    3bd0:	0107dd03 	tsteq	r7, r3, lsl #26
    3bd4:	02003122 	andeq	r3, r0, #-2147483640	; 0x80000008
    3bd8:	20060104 	andcs	r0, r6, r4, lsl #2
    3bdc:	02040200 	andeq	r0, r4, #0, 4
    3be0:	02007606 	andeq	r7, r0, #6291456	; 0x600000
    3be4:	32640204 	rsbcc	r0, r4, #4, 4	; 0x40000000
    3be8:	01000902 	tsteq	r0, r2, lsl #18
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bec:	02050001 	andeq	r0, r5, #1
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bf0:	00006630 	andeq	r6, r0, r0, lsr r6
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3bf4:	0106f803 	tsteq	r6, r3, lsl #16
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bf8:	02003e21 	andeq	r3, r0, #528	; 0x210
    3bfc:	2e060104 	adfcss	f0, f6, f4
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c00:	3f303006 	svccc	0x00303006
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c04:	04020030 	streq	r0, [r2], #-48	; 0x30
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c08:	02003d01 	andeq	r3, r0, #1, 26	; 0x40
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c0c:	311f0104 	tstcc	pc, r4, lsl #2
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c10:	23504c3d 	cmpcs	r0, #15616	; 0x3d00
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c14:	09022d31 	stmdbeq	r2, {r0, r4, r5, r8, sl, fp, sp}
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c18:	00010100 	andeq	r0, r1, r0, lsl #2
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c1c:	00000205 	andeq	r0, r0, r5, lsl #4
    3c20:	f1030000 			; <UNDEFINED> instruction: 0xf1030000
    3c24:	01020107 	tsteq	r2, r7, lsl #2
    3c28:	8f010100 	svchi	0x00010100
    3c2c:	02000000 	andeq	r0, r0, #0
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c30:	00003600 	andeq	r3, r0, r0, lsl #12
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c34:	fb010200 	blx	4443e <_etext+0x3cf26>
    3c38:	01000d0e 	tsteq	r0, lr, lsl #26
    3c3c:	00010101 	andeq	r0, r1, r1, lsl #2
    3c40:	00010000 	andeq	r0, r1, r0
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c44:	73750100 	cmnvc	r5, #0, 2
    3c48:	696c5f62 	stmdbvs	ip!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    3c4c:	75000062 	strvc	r0, [r0, #-98]	; 0x62
    3c50:	6d5f6273 	lfmvs	f6, 2, [pc, #-460]	; 3a8c <sha256_process+0xa58>
    3c54:	632e6d65 	teqvs	lr, #6464	; 0x1940
    3c58:	00000100 	andeq	r0, r0, r0, lsl #2
    3c5c:	5f627375 	svcpl	0x00627375
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c60:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0x974
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c64:	0100682e 	tsteq	r0, lr, lsr #16
    3c68:	00000000 	andeq	r0, r0, r0
    3c6c:	668c0205 	strvs	r0, [ip], r5, lsl #4
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c70:	23030000 	movwcs	r0, #12288	; 0x3000
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c74:	232b2401 	teqcs	fp, #16777216	; 0x1000000
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c78:	0021232b 	eoreq	r2, r1, fp, lsr #6
    3c7c:	06010402 	streq	r0, [r1], -r2, lsl #8
    3c80:	04020020 	streq	r0, [r2], #-32
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c84:	004e0602 	subeq	r0, lr, r2, lsl #12
    3c88:	2c020402 	cfstrscs	mvf0, [r2], {2}
    3c8c:	02040200 	andeq	r0, r4, #0, 4
    3c90:	04020030 	streq	r0, [r2], #-48	; 0x30
    3c94:	024e2f02 	subeq	r2, lr, #2, 30
    3c98:	01010001 	tsteq	r1, r1
    3c9c:	bc020500 	cfstr32lt	mvfx0, [r2], {-0}
    3ca0:	03000066 	movweq	r0, #102	; 0x66
    3ca4:	2b24013c 	blcs	90419c <_etext+0x8fcc84>
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3ca8:	21232b23 	teqcs	r3, r3, lsr #22
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cac:	01040200 	mrseq	r0, R12_usr
    3cb0:	02002006 	andeq	r2, r0, #6
    3cb4:	30060204 	andcc	r0, r6, r4, lsl #4
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cb8:	00010269 	andeq	r0, r1, r9, ror #4
    3cbc:	Address 0x00003cbc is out of bounds.


Disassembly of section .debug_frame:

00000000 <.debug_frame>:
       0:	0000000c 	andeq	r0, r0, ip
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
       4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
       8:	7c020001 	stcvc	0, cr0, [r2], {1}
       c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
      10:	0000000c 	andeq	r0, r0, ip
      14:	00000000 	andeq	r0, r0, r0
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
      18:	00000b98 	muleq	r0, r8, fp
      1c:	00000002 	andeq	r0, r0, r2
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
      20:	0000000c 	andeq	r0, r0, ip
      24:	00000000 	andeq	r0, r0, r0
      28:	00000b9a 	muleq	r0, sl, fp
    if ((wEPVal & EP_CTR_RX) != 0)
      2c:	00000002 	andeq	r0, r0, r2
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
      30:	0000000c 	andeq	r0, r0, ip
      34:	00000000 	andeq	r0, r0, r0
      38:	00000b9c 	muleq	r0, ip, fp

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
      3c:	00000002 	andeq	r0, r0, r2

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
      40:	0000000c 	andeq	r0, r0, ip
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
      44:	00000000 	andeq	r0, r0, r0
      48:	00000b9e 	muleq	r0, lr, fp
      4c:	0000000a 	andeq	r0, r0, sl

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
      50:	0000000c 	andeq	r0, r0, ip
      54:	00000000 	andeq	r0, r0, r0
      58:	00000ba8 	andeq	r0, r0, r8, lsr #23
      5c:	00000002 	andeq	r0, r0, r2
      60:	0000000c 	andeq	r0, r0, ip
      64:	00000000 	andeq	r0, r0, r0
      68:	00000bac 	andeq	r0, r0, ip, lsr #23
      6c:	00000018 	andeq	r0, r0, r8, lsl r0
      70:	0000000c 	andeq	r0, r0, ip
      74:	00000000 	andeq	r0, r0, r0
      78:	00000bc4 	andeq	r0, r0, r4, asr #23
      7c:	00000002 	andeq	r0, r0, r2
      80:	0000000c 	andeq	r0, r0, ip
      84:	00000000 	andeq	r0, r0, r0
      88:	00000bc6 	andeq	r0, r0, r6, asr #23
      8c:	00000002 	andeq	r0, r0, r2
      90:	0000000c 	andeq	r0, r0, ip
      94:	00000000 	andeq	r0, r0, r0
      98:	00000bc8 	andeq	r0, r0, r8, asr #23
      9c:	00000002 	andeq	r0, r0, r2
      a0:	0000000c 	andeq	r0, r0, ip
      a4:	00000000 	andeq	r0, r0, r0
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
      a8:	00000bca 	andeq	r0, r0, sl, asr #23

	return f25519_eq(a, c);
      ac:	00000002 	andeq	r0, r0, r2
      b0:	0000000c 	andeq	r0, r0, ip
      b4:	00000000 	andeq	r0, r0, r0
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
      b8:	00000bcc 	andeq	r0, r0, ip, asr #23
	f25519_normalize(ey);
      bc:	00000002 	andeq	r0, r0, r2
      c0:	0000000c 	andeq	r0, r0, ip

	return ok;
}
      c4:	00000000 	andeq	r0, r0, r0
      c8:	00000bce 	andeq	r0, r0, lr, asr #23
      cc:	00000002 	andeq	r0, r0, r2
      d0:	0000000c 	andeq	r0, r0, ip
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
      d4:	00000000 	andeq	r0, r0, r0
      d8:	00000bd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
		minusp[i] = c;
      dc:	0000000c 	andeq	r0, r0, ip
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
      e0:	00000018 	andeq	r0, r0, r8, lsl r0
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
      e4:	00000000 	andeq	r0, r0, r0

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
      e8:	00000bdc 	ldrdeq	r0, [r0], -ip
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
      ec:	000000a8 	andeq	r0, r0, r8, lsr #1
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
      f0:	40080e41 	andmi	r0, r8, r1, asr #28
      f4:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
      f8:	00000001 	andeq	r0, r0, r1
      fc:	0000001c 	andeq	r0, r0, ip, lsl r0
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     100:	00000000 	andeq	r0, r0, r0

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
     104:	00000c84 	andeq	r0, r0, r4, lsl #25
     108:	00000060 	andeq	r0, r0, r0, rrx
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     10c:	40100e41 	andsmi	r0, r0, r1, asr #28
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
     110:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
     114:	02854003 	addeq	r4, r5, #3
     118:	00018e40 	andeq	r8, r1, r0, asr #28
     11c:	0000000c 	andeq	r0, r0, ip
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     120:	00000000 	andeq	r0, r0, r0
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
     124:	00000ce4 	andeq	r0, r0, r4, ror #25
     128:	0000000c 	andeq	r0, r0, ip
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
     12c:	0000000c 	andeq	r0, r0, ip

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
     130:	00000000 	andeq	r0, r0, r0
	i <<= 3;

	while (x) {
     134:	00000cf0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
     138:	0000000c 	andeq	r0, r0, ip
     13c:	0000000c 	andeq	r0, r0, ip
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
     140:	00000000 	andeq	r0, r0, r0
	f25519_mul_c(z3, x1sq, 4);
     144:	00000cfc 	strdeq	r0, [r0], -ip
     148:	00000020 	andeq	r0, r0, r0, lsr #32
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	0000000c 	andeq	r0, r0, ip
     150:	00000000 	andeq	r0, r0, r0
     154:	00000d1c 	andeq	r0, r0, ip, lsl sp
	f25519_sub(b, x3, z3); /* D */
     158:	0000000c 	andeq	r0, r0, ip
     15c:	00000018 	andeq	r0, r0, r8, lsl r0
	f25519_mul__distinct(da, a, b);
     160:	00000000 	andeq	r0, r0, r0
     164:	00000d28 	andeq	r0, r0, r8, lsr #26
     168:	00000028 	andeq	r0, r0, r8, lsr #32

	f25519_sub(b, x2, z2);
     16c:	40080e41 	andmi	r0, r8, r1, asr #28
     170:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
	f25519_add(a, x3, z3); /* C */
     174:	00000001 	andeq	r0, r0, r1
     178:	00000024 	andeq	r0, r0, r4, lsr #32
     17c:	00000000 	andeq	r0, r0, r0
	f25519_mul__distinct(cb, a, b);
     180:	00000d50 	andeq	r0, r0, r0, asr sp
     184:	00000068 	andeq	r0, r0, r8, rrx

	f25519_add(a, da, cb);
     188:	40180e41 	andsmi	r0, r8, r1, asr #28
     18c:	81400680 	smlalbbhi	r0, r0, r0, r6	; <UNPREDICTABLE>
     190:	04824005 	streq	r4, [r2], #5
	f25519_mul__distinct(b, a, a);
     194:	40038440 	andmi	r8, r3, r0, asr #8
     198:	8e400285 	cdphi	2, 4, cr0, cr0, cr5, {4}
	f25519_mul__distinct(x5, z1, b);
     19c:	00000001 	andeq	r0, r0, r1
     1a0:	0000000c 	andeq	r0, r0, ip
	...

	f25519_sub(a, da, cb);
     1ac:	00000004 	andeq	r0, r0, r4
	f25519_mul__distinct(b, a, a);
     1b0:	0000000c 	andeq	r0, r0, ip
     1b4:	00000000 	andeq	r0, r0, r0
     1b8:	00000db8 			; <UNDEFINED> instruction: 0x00000db8

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	0000001c 	andeq	r0, r0, ip, lsl r0
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	0000000c 	andeq	r0, r0, ip
     1c4:	00000000 	andeq	r0, r0, r0

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1c8:	00000dd4 	ldrdeq	r0, [r0], -r4
     1cc:	00000018 	andeq	r0, r0, r8, lsl r0
     1d0:	00000018 	andeq	r0, r0, r8, lsl r0
     1d4:	00000000 	andeq	r0, r0, r0
		f25519_select(zm1, zm1, zm, bit);
     1d8:	00000dec 	andeq	r0, r0, ip, ror #27
     1dc:	00000084 	andeq	r0, r0, r4, lsl #1
     1e0:	40080e41 	andmi	r0, r8, r1, asr #28
		f25519_select(xm, xm, xms, bit);
     1e4:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
     1e8:	00000001 	andeq	r0, r0, r1
     1ec:	00000018 	andeq	r0, r0, r8, lsl r0
		f25519_select(zm, zm, zms, bit);
     1f0:	00000000 	andeq	r0, r0, r0
     1f4:	00000e70 	andeq	r0, r0, r0, ror lr
     1f8:	00000048 	andeq	r0, r0, r8, asr #32
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fc:	40080e42 	andmi	r0, r8, r2, asr #28
     200:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     204:	00000001 	andeq	r0, r0, r1
     208:	00000018 	andeq	r0, r0, r8, lsl r0
	f25519_mul__distinct(result, zm1, xm);
     20c:	00000000 	andeq	r0, r0, r0
     210:	00000eb8 			; <UNDEFINED> instruction: 0x00000eb8
	f25519_normalize(result);
     214:	0000003c 	andeq	r0, r0, ip, lsr r0
     218:	40080e43 	andmi	r0, r8, r3, asr #28
}
     21c:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
     220:	00000001 	andeq	r0, r0, r1
     224:	0000000c 	andeq	r0, r0, ip
     228:	00000000 	andeq	r0, r0, r0
     22c:	00000ef4 	strdeq	r0, [r0], -r4
     230:	00000004 	andeq	r0, r0, r4
     234:	0000001c 	andeq	r0, r0, ip, lsl r0
     238:	00000000 	andeq	r0, r0, r0
     23c:	00000ef8 	strdeq	r0, [r0], -r8
     240:	00000024 	andeq	r0, r0, r4, lsr #32
     244:	40100e41 	andsmi	r0, r0, r1, asr #28
     248:	81400480 	smlalbbhi	r0, r0, r0, r4	; <UNPREDICTABLE>
     24c:	02824003 	addeq	r4, r2, #3
     250:	00018e40 	andeq	r8, r1, r0, asr #28
     254:	00000018 	andeq	r0, r0, r8, lsl r0
     258:	00000000 	andeq	r0, r0, r0
     25c:	00000f1c 	andeq	r0, r0, ip, lsl pc
     260:	00000040 	andeq	r0, r0, r0, asr #32
     264:	40080e41 	andmi	r0, r8, r1, asr #28
     268:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
     26c:	00000001 	andeq	r0, r0, r1
     270:	0000001c 	andeq	r0, r0, ip, lsl r0
     274:	00000000 	andeq	r0, r0, r0
     278:	00000f5c 	andeq	r0, r0, ip, asr pc
     27c:	00000022 	andeq	r0, r0, r2, lsr #32
     280:	40100e41 	andsmi	r0, r0, r1, asr #28
     284:	81400480 	smlalbbhi	r0, r0, r0, r4	; <UNPREDICTABLE>
     288:	02824003 	addeq	r4, r2, #3
     28c:	00018e40 	andeq	r8, r1, r0, asr #28
     290:	0000001c 	andeq	r0, r0, ip, lsl r0
     294:	00000000 	andeq	r0, r0, r0
     298:	00000f80 	andeq	r0, r0, r0, lsl #31
     29c:	000000b4 	strheq	r0, [r0], -r4
     2a0:	40100e41 	andsmi	r0, r0, r1, asr #28
     2a4:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     2a8:	02864003 	addeq	r4, r6, #3
     2ac:	00018e40 	andeq	r8, r1, r0, asr #28
     2b0:	0000000c 	andeq	r0, r0, ip
	...
     2bc:	0000000c 	andeq	r0, r0, ip
     2c0:	0000000c 	andeq	r0, r0, ip
     2c4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     2c8:	7c020001 	stcvc	0, cr0, [r2], {1}
     2cc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     2d0:	0000000c 	andeq	r0, r0, ip
     2d4:	000002c0 	andeq	r0, r0, r0, asr #5
     2d8:	00001034 	andeq	r1, r0, r4, lsr r0
     2dc:	00000002 	andeq	r0, r0, r2
     2e0:	0000001c 	andeq	r0, r0, ip, lsl r0
     2e4:	000002c0 	andeq	r0, r0, r0, asr #5
     2e8:	00001038 	andeq	r1, r0, r8, lsr r0
     2ec:	000000ec 	andeq	r0, r0, ip, ror #1
     2f0:	400c0e41 	andmi	r0, ip, r1, asr #28
     2f4:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     2f8:	018e4002 	orreq	r4, lr, r2
     2fc:	00200e41 	eoreq	r0, r0, r1, asr #28
     300:	0000000c 	andeq	r0, r0, ip
     304:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     308:	7c020001 	stcvc	0, cr0, [r2], {1}
     30c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     310:	0000000c 	andeq	r0, r0, ip
     314:	00000300 	andeq	r0, r0, r0, lsl #6
     318:	00001124 	andeq	r1, r0, r4, lsr #2
     31c:	00000016 	andeq	r0, r0, r6, lsl r0
     320:	0000000c 	andeq	r0, r0, ip
     324:	00000300 	andeq	r0, r0, r0, lsl #6
     328:	0000113a 	andeq	r1, r0, sl, lsr r1
     32c:	00000012 	andeq	r0, r0, r2, lsl r0
     330:	00000028 	andeq	r0, r0, r8, lsr #32
     334:	00000300 	andeq	r0, r0, r0, lsl #6
     338:	0000114c 	andeq	r1, r0, ip, asr #2
     33c:	00000050 	andeq	r0, r0, r0, asr r0
     340:	40200e42 	eormi	r0, r0, r2, asr #28
     344:	85400884 	strbhi	r0, [r0, #-2180]	; 0x884
     348:	06864007 	streq	r4, [r6], r7
     34c:	40058740 	andmi	r8, r5, r0, asr #14
     350:	89400488 	stmdbhi	r0, {r3, r7, sl}^
     354:	028a4003 	addeq	r4, sl, #3
     358:	00018e40 	andeq	r8, r1, r0, asr #28
     35c:	0000000c 	andeq	r0, r0, ip
     360:	00000300 	andeq	r0, r0, r0, lsl #6
     364:	0000119c 	muleq	r0, ip, r1
     368:	0000000a 	andeq	r0, r0, sl
     36c:	0000001c 	andeq	r0, r0, ip, lsl r0
     370:	00000300 	andeq	r0, r0, r0, lsl #6
     374:	000011a6 	andeq	r1, r0, r6, lsr #3
     378:	00000016 	andeq	r0, r0, r6, lsl r0
     37c:	40100e41 	andsmi	r0, r0, r1, asr #28
     380:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
     384:	02854003 	addeq	r4, r5, #3
     388:	00018e40 	andeq	r8, r1, r0, asr #28
     38c:	00000018 	andeq	r0, r0, r8, lsl r0
     390:	00000300 	andeq	r0, r0, r0, lsl #6
     394:	000011bc 			; <UNDEFINED> instruction: 0x000011bc
     398:	00000028 	andeq	r0, r0, r8, lsr #32
     39c:	40040e41 	andmi	r0, r4, r1, asr #28
     3a0:	0e42018e 	dvfeqd	f0, f2, #0.5
     3a4:	000001d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     3a8:	0000002c 	andeq	r0, r0, ip, lsr #32
     3ac:	00000300 	andeq	r0, r0, r0, lsl #6
     3b0:	000011e4 	andeq	r1, r0, r4, ror #3
     3b4:	0000001a 	andeq	r0, r0, sl, lsl r0
     3b8:	40100e41 	andsmi	r0, r0, r1, asr #28
     3bc:	81400480 	smlalbbhi	r0, r0, r0, r4	; <UNPREDICTABLE>
     3c0:	02824003 	addeq	r4, r2, #3
     3c4:	41018340 	tstmi	r1, r0, asr #6
     3c8:	8040200e 	subhi	r2, r0, lr
     3cc:	07814008 	streq	r4, [r1, r8]
     3d0:	40068240 	andmi	r8, r6, r0, asr #4
     3d4:	0000058e 	andeq	r0, r0, lr, lsl #11
     3d8:	0000001c 	andeq	r0, r0, ip, lsl r0
     3dc:	00000300 	andeq	r0, r0, r0, lsl #6
     3e0:	000011fe 	strdeq	r1, [r0], -lr
     3e4:	0000002e 	andeq	r0, r0, lr, lsr #32
     3e8:	400c0e41 	andmi	r0, ip, r1, asr #28
     3ec:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     3f0:	018e4002 	orreq	r4, lr, r2
     3f4:	00280e41 	eoreq	r0, r8, r1, asr #28
     3f8:	00000018 	andeq	r0, r0, r8, lsl r0
     3fc:	00000300 	andeq	r0, r0, r0, lsl #6
     400:	0000122c 	andeq	r1, r0, ip, lsr #4
     404:	00000088 	andeq	r0, r0, r8, lsl #1
     408:	40080e41 	andmi	r0, r8, r1, asr #28
     40c:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
     410:	200e4201 	andcs	r4, lr, r1, lsl #4
     414:	0000000c 	andeq	r0, r0, ip
     418:	00000300 	andeq	r0, r0, r0, lsl #6
     41c:	000012b4 			; <UNDEFINED> instruction: 0x000012b4
     420:	00000048 	andeq	r0, r0, r8, asr #32
     424:	0000000c 	andeq	r0, r0, ip
     428:	00000300 	andeq	r0, r0, r0, lsl #6
     42c:	000012fc 	strdeq	r1, [r0], -ip
     430:	00000060 	andeq	r0, r0, r0, rrx
     434:	0000000c 	andeq	r0, r0, ip
     438:	00000300 	andeq	r0, r0, r0, lsl #6
     43c:	0000135c 	andeq	r1, r0, ip, asr r3
     440:	00000014 	andeq	r0, r0, r4, lsl r0
     444:	0000000c 	andeq	r0, r0, ip
     448:	00000300 	andeq	r0, r0, r0, lsl #6
     44c:	00001370 	andeq	r1, r0, r0, ror r3
     450:	0000001c 	andeq	r0, r0, ip, lsl r0
     454:	00000024 	andeq	r0, r0, r4, lsr #32
     458:	00000300 	andeq	r0, r0, r0, lsl #6
     45c:	00000000 	andeq	r0, r0, r0
     460:	0000002e 	andeq	r0, r0, lr, lsr #32
     464:	40180e41 	andsmi	r0, r8, r1, asr #28
     468:	81400680 	smlalbbhi	r0, r0, r0, r6	; <UNPREDICTABLE>
     46c:	04824005 	streq	r4, [r2], #5
     470:	40038440 	andmi	r8, r3, r0, asr #8
     474:	8e400285 	cdphi	2, 4, cr0, cr0, cr5, {4}
     478:	00000001 	andeq	r0, r0, r1
     47c:	0000000c 	andeq	r0, r0, ip
     480:	00000300 	andeq	r0, r0, r0, lsl #6
     484:	00000000 	andeq	r0, r0, r0
     488:	00000004 	andeq	r0, r0, r4
     48c:	00000018 	andeq	r0, r0, r8, lsl r0
     490:	00000300 	andeq	r0, r0, r0, lsl #6
     494:	0000138c 	andeq	r1, r0, ip, lsl #7
     498:	00000018 	andeq	r0, r0, r8, lsl r0
     49c:	40080e42 	andmi	r0, r8, r2, asr #28
     4a0:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
     4a4:	00000001 	andeq	r0, r0, r1
     4a8:	0000000c 	andeq	r0, r0, ip
     4ac:	00000300 	andeq	r0, r0, r0, lsl #6
     4b0:	00000000 	andeq	r0, r0, r0
     4b4:	0000002c 	andeq	r0, r0, ip, lsr #32
     4b8:	0000001c 	andeq	r0, r0, ip, lsl r0
     4bc:	00000300 	andeq	r0, r0, r0, lsl #6
     4c0:	00000000 	andeq	r0, r0, r0
     4c4:	00000048 	andeq	r0, r0, r8, asr #32
     4c8:	40100e41 	andsmi	r0, r0, r1, asr #28
     4cc:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
     4d0:	02854003 	addeq	r4, r5, #3
     4d4:	00018e40 	andeq	r8, r1, r0, asr #28
     4d8:	00000018 	andeq	r0, r0, r8, lsl r0
     4dc:	00000300 	andeq	r0, r0, r0, lsl #6
     4e0:	000013a4 	andeq	r1, r0, r4, lsr #7
     4e4:	0000006c 	andeq	r0, r0, ip, rrx
     4e8:	400c0e42 	andmi	r0, ip, r2, asr #28
     4ec:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     4f0:	018e4002 	orreq	r4, lr, r2
     4f4:	0000000c 	andeq	r0, r0, ip
     4f8:	00000300 	andeq	r0, r0, r0, lsl #6
     4fc:	00001410 	andeq	r1, r0, r0, lsl r4
     500:	00000024 	andeq	r0, r0, r4, lsr #32
     504:	00000018 	andeq	r0, r0, r8, lsl r0
     508:	00000300 	andeq	r0, r0, r0, lsl #6
     50c:	00001434 	andeq	r1, r0, r4, lsr r4
     510:	0000001e 	andeq	r0, r0, lr, lsl r0
     514:	40080e41 	andmi	r0, r8, r1, asr #28
     518:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
     51c:	00000001 	andeq	r0, r0, r1
     520:	0000000c 	andeq	r0, r0, ip
     524:	00000300 	andeq	r0, r0, r0, lsl #6
     528:	00001454 	andeq	r1, r0, r4, asr r4
     52c:	00000014 	andeq	r0, r0, r4, lsl r0
     530:	00000018 	andeq	r0, r0, r8, lsl r0
     534:	00000300 	andeq	r0, r0, r0, lsl #6
     538:	00001468 	andeq	r1, r0, r8, ror #8
     53c:	00000034 	andeq	r0, r0, r4, lsr r0
     540:	40080e42 	andmi	r0, r8, r2, asr #28
     544:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
     548:	00000001 	andeq	r0, r0, r1
     54c:	0000001c 	andeq	r0, r0, ip, lsl r0
     550:	00000300 	andeq	r0, r0, r0, lsl #6
     554:	00000000 	andeq	r0, r0, r0
     558:	00000030 	andeq	r0, r0, r0, lsr r0
     55c:	40100e42 	andsmi	r0, r0, r2, asr #28
     560:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
     564:	02854003 	addeq	r4, r5, #3
     568:	00018e40 	andeq	r8, r1, r0, asr #28
     56c:	00000024 	andeq	r0, r0, r4, lsr #32
     570:	00000300 	andeq	r0, r0, r0, lsl #6
     574:	0000149c 	muleq	r0, ip, r4
     578:	0000004c 	andeq	r0, r0, ip, asr #32
     57c:	40180e41 	andsmi	r0, r8, r1, asr #28
     580:	81400680 	smlalbbhi	r0, r0, r0, r6	; <UNPREDICTABLE>
     584:	04824005 	streq	r4, [r2], #5
     588:	40038440 	andmi	r8, r3, r0, asr #8
     58c:	8e400285 	cdphi	2, 4, cr0, cr0, cr5, {4}
     590:	00000001 	andeq	r0, r0, r1
     594:	0000000c 	andeq	r0, r0, ip
     598:	00000300 	andeq	r0, r0, r0, lsl #6
     59c:	000014e8 	andeq	r1, r0, r8, ror #9
     5a0:	0000000c 	andeq	r0, r0, ip
     5a4:	0000000c 	andeq	r0, r0, ip
     5a8:	00000300 	andeq	r0, r0, r0, lsl #6
     5ac:	000014f4 	strdeq	r1, [r0], -r4
     5b0:	00000018 	andeq	r0, r0, r8, lsl r0
     5b4:	0000000c 	andeq	r0, r0, ip
     5b8:	00000300 	andeq	r0, r0, r0, lsl #6
     5bc:	0000150c 	andeq	r1, r0, ip, lsl #10
     5c0:	00000012 	andeq	r0, r0, r2, lsl r0
     5c4:	0000000c 	andeq	r0, r0, ip
     5c8:	00000300 	andeq	r0, r0, r0, lsl #6
     5cc:	00001520 	andeq	r1, r0, r0, lsr #10
     5d0:	00000010 	andeq	r0, r0, r0, lsl r0
     5d4:	0000000c 	andeq	r0, r0, ip
     5d8:	00000300 	andeq	r0, r0, r0, lsl #6
     5dc:	00001530 	andeq	r1, r0, r0, lsr r5
     5e0:	00000018 	andeq	r0, r0, r8, lsl r0
     5e4:	0000000c 	andeq	r0, r0, ip
     5e8:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     5ec:	7c020001 	stcvc	0, cr0, [r2], {1}
     5f0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     5f4:	00000018 	andeq	r0, r0, r8, lsl r0
     5f8:	000005e4 	andeq	r0, r0, r4, ror #11
     5fc:	00001548 	andeq	r1, r0, r8, asr #10
     600:	00000088 	andeq	r0, r0, r8, lsl #1
     604:	40080e42 	andmi	r0, r8, r2, asr #28
     608:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
     60c:	00000001 	andeq	r0, r0, r1
     610:	00000018 	andeq	r0, r0, r8, lsl r0
     614:	000005e4 	andeq	r0, r0, r4, ror #11
     618:	000015d0 	ldrdeq	r1, [r0], -r0
     61c:	00000044 	andeq	r0, r0, r4, asr #32
     620:	40080e41 	andmi	r0, r8, r1, asr #28
     624:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
     628:	00000001 	andeq	r0, r0, r1
     62c:	0000000c 	andeq	r0, r0, ip
     630:	000005e4 	andeq	r0, r0, r4, ror #11
     634:	00000000 	andeq	r0, r0, r0
     638:	00000002 	andeq	r0, r0, r2
     63c:	0000000c 	andeq	r0, r0, ip
     640:	000005e4 	andeq	r0, r0, r4, ror #11
     644:	00001614 	andeq	r1, r0, r4, lsl r6
     648:	00000018 	andeq	r0, r0, r8, lsl r0
     64c:	0000000c 	andeq	r0, r0, ip
     650:	000005e4 	andeq	r0, r0, r4, ror #11
     654:	0000162c 	andeq	r1, r0, ip, lsr #12
     658:	00000018 	andeq	r0, r0, r8, lsl r0
     65c:	0000000c 	andeq	r0, r0, ip
     660:	000005e4 	andeq	r0, r0, r4, ror #11
     664:	00001644 	andeq	r1, r0, r4, asr #12
     668:	00000028 	andeq	r0, r0, r8, lsr #32
     66c:	0000000c 	andeq	r0, r0, ip
     670:	000005e4 	andeq	r0, r0, r4, ror #11
     674:	0000166c 	andeq	r1, r0, ip, ror #12
     678:	00000034 	andeq	r0, r0, r4, lsr r0
     67c:	0000001c 	andeq	r0, r0, ip, lsl r0
     680:	000005e4 	andeq	r0, r0, r4, ror #11
     684:	000016a0 	andeq	r1, r0, r0, lsr #13
     688:	0000005c 	andeq	r0, r0, ip, asr r0
     68c:	40100e41 	andsmi	r0, r0, r1, asr #28
     690:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     694:	02864003 	addeq	r4, r6, #3
     698:	00018e40 	andeq	r8, r1, r0, asr #28
     69c:	00000028 	andeq	r0, r0, r8, lsr #32
     6a0:	000005e4 	andeq	r0, r0, r4, ror #11
     6a4:	000016fc 	strdeq	r1, [r0], -ip
     6a8:	00000254 	andeq	r0, r0, r4, asr r2
     6ac:	40200e42 	eormi	r0, r0, r2, asr #28
     6b0:	81400880 	smlalbbhi	r0, r0, r0, r8	; <UNPREDICTABLE>
     6b4:	06844007 	streq	r4, [r4], r7
     6b8:	40058540 	andmi	r8, r5, r0, asr #10
     6bc:	87400486 	strbhi	r0, [r0, -r6, lsl #9]
     6c0:	02884003 	addeq	r4, r8, #3
     6c4:	00018e40 	andeq	r8, r1, r0, asr #28
     6c8:	0000000c 	andeq	r0, r0, ip
     6cc:	000005e4 	andeq	r0, r0, r4, ror #11
     6d0:	00000000 	andeq	r0, r0, r0
     6d4:	0000000c 	andeq	r0, r0, ip
     6d8:	0000000c 	andeq	r0, r0, ip
     6dc:	000005e4 	andeq	r0, r0, r4, ror #11
     6e0:	00000000 	andeq	r0, r0, r0
     6e4:	0000000c 	andeq	r0, r0, ip
     6e8:	0000000c 	andeq	r0, r0, ip
     6ec:	000005e4 	andeq	r0, r0, r4, ror #11
     6f0:	00001950 	andeq	r1, r0, r0, asr r9
     6f4:	0000000c 	andeq	r0, r0, ip
     6f8:	0000000c 	andeq	r0, r0, ip
     6fc:	000005e4 	andeq	r0, r0, r4, ror #11
     700:	00000000 	andeq	r0, r0, r0
     704:	0000001c 	andeq	r0, r0, ip, lsl r0
     708:	0000000c 	andeq	r0, r0, ip
     70c:	000005e4 	andeq	r0, r0, r4, ror #11
     710:	0000195c 	andeq	r1, r0, ip, asr r9
     714:	00000002 	andeq	r0, r0, r2
     718:	0000000c 	andeq	r0, r0, ip
     71c:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     720:	7c020001 	stcvc	0, cr0, [r2], {1}
     724:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     728:	00000028 	andeq	r0, r0, r8, lsr #32
     72c:	00000718 	andeq	r0, r0, r8, lsl r7
     730:	00000000 	andeq	r0, r0, r0
     734:	00000228 	andeq	r0, r0, r8, lsr #4
     738:	40180e42 	andsmi	r0, r8, r2, asr #28
     73c:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     740:	04864005 	streq	r4, [r6], #5
     744:	40038740 	andmi	r8, r3, r0, asr #14
     748:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
     74c:	d80e4201 	stmdale	lr, {r0, r9, lr}
     750:	00000002 	andeq	r0, r0, r2
     754:	0000000c 	andeq	r0, r0, ip
     758:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     75c:	7c020001 	stcvc	0, cr0, [r2], {1}
     760:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     764:	00000024 	andeq	r0, r0, r4, lsr #32
     768:	00000754 	andeq	r0, r0, r4, asr r7
     76c:	00001960 	andeq	r1, r0, r0, ror #18
     770:	00000070 	andeq	r0, r0, r0, ror r0
     774:	40180e41 	andsmi	r0, r8, r1, asr #28
     778:	84400683 	strbhi	r0, [r0], #-1667	; 0x683
     77c:	04854005 	streq	r4, [r5], #5
     780:	40038640 	andmi	r8, r3, r0, asr #12
     784:	8e400287 	cdphi	2, 4, cr0, cr0, cr7, {4}
     788:	00000001 	andeq	r0, r0, r1
     78c:	00000020 	andeq	r0, r0, r0, lsr #32
     790:	00000754 	andeq	r0, r0, r4, asr r7
     794:	000019d0 	ldrdeq	r1, [r0], -r0
     798:	0000003a 	andeq	r0, r0, sl, lsr r0
     79c:	40100e41 	andsmi	r0, r0, r1, asr #28
     7a0:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     7a4:	02864003 	addeq	r4, r6, #3
     7a8:	41018e40 	tstmi	r1, r0, asr #28
     7ac:	0000300e 	andeq	r3, r0, lr
     7b0:	00000024 	andeq	r0, r0, r4, lsr #32
     7b4:	00000754 	andeq	r0, r0, r4, asr r7
     7b8:	00001a0c 	andeq	r1, r0, ip, lsl #20
     7bc:	0000005e 	andeq	r0, r0, lr, asr r0
     7c0:	40140e41 	andsmi	r0, r4, r1, asr #28
     7c4:	85400584 	strbhi	r0, [r0, #-1412]	; 0x584
     7c8:	03864004 	orreq	r4, r6, #4
     7cc:	40028740 	andmi	r8, r2, r0, asr #14
     7d0:	0e44018e 	dvfeqd	f0, f4, #0.5
     7d4:	00000038 	andeq	r0, r0, r8, lsr r0
     7d8:	00000024 	andeq	r0, r0, r4, lsr #32
     7dc:	00000754 	andeq	r0, r0, r4, asr r7
     7e0:	00001a6c 	andeq	r1, r0, ip, ror #20
     7e4:	000000c8 	andeq	r0, r0, r8, asr #1
     7e8:	40180e42 	andsmi	r0, r8, r2, asr #28
     7ec:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     7f0:	04864005 	streq	r4, [r6], #5
     7f4:	40038740 	andmi	r8, r3, r0, asr #14
     7f8:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
     7fc:	780e5301 	stmdavc	lr, {r0, r8, r9, ip, lr}
     800:	00000028 	andeq	r0, r0, r8, lsr #32
     804:	00000754 	andeq	r0, r0, r4, asr r7
     808:	00001b34 	andeq	r1, r0, r4, lsr fp
     80c:	000000e0 	andeq	r0, r0, r0, ror #1
     810:	40180e42 	andsmi	r0, r8, r2, asr #28
     814:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     818:	04864005 	streq	r4, [r6], #5
     81c:	40038740 	andmi	r8, r3, r0, asr #14
     820:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
     824:	980e4201 	stmdals	lr, {r0, r9, lr}
     828:	00000002 	andeq	r0, r0, r2
     82c:	00000020 	andeq	r0, r0, r0, lsr #32
     830:	00000754 	andeq	r0, r0, r4, asr r7
     834:	00001c14 	andeq	r1, r0, r4, lsl ip
     838:	000000b4 	strheq	r0, [r0], -r4
     83c:	40100e41 	andsmi	r0, r0, r1, asr #28
     840:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     844:	02864003 	addeq	r4, r6, #3
     848:	41018e40 	tstmi	r1, r0, asr #28
     84c:	0001f00e 	andeq	pc, r1, lr
     850:	00000028 	andeq	r0, r0, r8, lsr #32
     854:	00000754 	andeq	r0, r0, r4, asr r7
     858:	00001cc8 	andeq	r1, r0, r8, asr #25
     85c:	00000084 	andeq	r0, r0, r4, lsl #1
     860:	40180e42 	andsmi	r0, r8, r2, asr #28
     864:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     868:	04864005 	streq	r4, [r6], #5
     86c:	40038740 	andmi	r8, r3, r0, asr #14
     870:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
     874:	980e4101 	stmdals	lr, {r0, r8, lr}
     878:	00000002 	andeq	r0, r0, r2
     87c:	0000000c 	andeq	r0, r0, ip
     880:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     884:	7c020001 	stcvc	0, cr0, [r2], {1}
     888:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     88c:	00000024 	andeq	r0, r0, r4, lsr #32
     890:	0000087c 	andeq	r0, r0, ip, ror r8
     894:	00000000 	andeq	r0, r0, r0
     898:	0000007c 	andeq	r0, r0, ip, ror r0
     89c:	40140e41 	andsmi	r0, r4, r1, asr #28
     8a0:	85400584 	strbhi	r0, [r0, #-1412]	; 0x584
     8a4:	03864004 	orreq	r4, r6, #4
     8a8:	40028740 	andmi	r8, r2, r0, asr #14
     8ac:	0e42018e 	dvfeqd	f0, f2, #0.5
     8b0:	00000298 	muleq	r0, r8, r2
     8b4:	00000028 	andeq	r0, r0, r8, lsr #32
     8b8:	0000087c 	andeq	r0, r0, ip, ror r8
     8bc:	00001d4c 	andeq	r1, r0, ip, asr #26
     8c0:	0000017c 	andeq	r0, r0, ip, ror r1
     8c4:	401c0e42 	andsmi	r0, ip, r2, asr #28
     8c8:	85400784 	strbhi	r0, [r0, #-1924]	; 0x784
     8cc:	05864006 	streq	r4, [r6, #6]
     8d0:	40048740 	andmi	r8, r4, r0, asr #14
     8d4:	89400388 	stmdbhi	r0, {r3, r7, r8, r9}^
     8d8:	018e4002 	orreq	r4, lr, r2
     8dc:	03c00e43 	biceq	r0, r0, #1072	; 0x430
     8e0:	0000000c 	andeq	r0, r0, ip
     8e4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     8e8:	7c020001 	stcvc	0, cr0, [r2], {1}
     8ec:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     8f0:	00000014 	andeq	r0, r0, r4, lsl r0
     8f4:	000008e0 	andeq	r0, r0, r0, ror #17
     8f8:	00001ec8 	andeq	r1, r0, r8, asr #29
     8fc:	0000001e 	andeq	r0, r0, lr, lsl r0
     900:	40040e41 	andmi	r0, r4, r1, asr #28
     904:	00000184 	andeq	r0, r0, r4, lsl #3
     908:	00000018 	andeq	r0, r0, r8, lsl r0
     90c:	000008e0 	andeq	r0, r0, r0, ror #17
     910:	00001ee8 	andeq	r1, r0, r8, ror #29
     914:	0000006e 	andeq	r0, r0, lr, rrx
     918:	40040e41 	andmi	r0, r4, r1, asr #28
     91c:	0e420184 	dvfeqd	f0, f2, f4
     920:	00000028 	andeq	r0, r0, r8, lsr #32
     924:	0000001c 	andeq	r0, r0, ip, lsl r0
     928:	000008e0 	andeq	r0, r0, r0, ror #17
     92c:	00001f58 	andeq	r1, r0, r8, asr pc
     930:	0000009a 	muleq	r0, sl, r0
     934:	40100e44 	andsmi	r0, r0, r4, asr #28
     938:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     93c:	02864003 	addeq	r4, r6, #3
     940:	00018740 	andeq	r8, r1, r0, asr #14
     944:	0000001c 	andeq	r0, r0, ip, lsl r0
     948:	000008e0 	andeq	r0, r0, r0, ror #17
     94c:	00001ff4 	strdeq	r1, [r0], -r4
     950:	000000c2 	andeq	r0, r0, r2, asr #1
     954:	40100e41 	andsmi	r0, r0, r1, asr #28
     958:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     95c:	02864003 	addeq	r4, r6, #3
     960:	00018740 	andeq	r8, r1, r0, asr #14
     964:	00000018 	andeq	r0, r0, r8, lsl r0
     968:	000008e0 	andeq	r0, r0, r0, ror #17
     96c:	000020b8 	strheq	r2, [r0], -r8
     970:	00000046 	andeq	r0, r0, r6, asr #32
     974:	400c0e42 	andmi	r0, ip, r2, asr #28
     978:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     97c:	01864002 	orreq	r4, r6, r2
     980:	00000018 	andeq	r0, r0, r8, lsl r0
     984:	000008e0 	andeq	r0, r0, r0, ror #17
     988:	00002100 	andeq	r2, r0, r0, lsl #2
     98c:	0000004c 	andeq	r0, r0, ip, asr #32
     990:	400c0e41 	andmi	r0, ip, r1, asr #28
     994:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     998:	01864002 	orreq	r4, r6, r2
     99c:	00000014 	andeq	r0, r0, r4, lsl r0
     9a0:	000008e0 	andeq	r0, r0, r0, ror #17
     9a4:	0000214c 	andeq	r2, r0, ip, asr #2
     9a8:	00000046 	andeq	r0, r0, r6, asr #32
     9ac:	40040e41 	andmi	r0, r4, r1, asr #28
     9b0:	00000184 	andeq	r0, r0, r4, lsl #3
     9b4:	00000024 	andeq	r0, r0, r4, lsr #32
     9b8:	000008e0 	andeq	r0, r0, r0, ror #17
     9bc:	00002194 	muleq	r0, r4, r1
     9c0:	00000088 	andeq	r0, r0, r8, lsl #1
     9c4:	40180e42 	andsmi	r0, r8, r2, asr #28
     9c8:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     9cc:	04864005 	streq	r4, [r6], #5
     9d0:	40038740 	andmi	r8, r3, r0, asr #14
     9d4:	89400288 	stmdbhi	r0, {r3, r7, r9}^
     9d8:	00000001 	andeq	r0, r0, r1
     9dc:	00000024 	andeq	r0, r0, r4, lsr #32
     9e0:	000008e0 	andeq	r0, r0, r0, ror #17
     9e4:	00000000 	andeq	r0, r0, r0
     9e8:	000000b8 	strheq	r0, [r0], -r8
     9ec:	40180e42 	andsmi	r0, r8, r2, asr #28
     9f0:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     9f4:	04864005 	streq	r4, [r6], #5
     9f8:	40038740 	andmi	r8, r3, r0, asr #14
     9fc:	89400288 	stmdbhi	r0, {r3, r7, r9}^
     a00:	380e4401 	stmdacc	lr, {r0, sl, lr}
     a04:	00000018 	andeq	r0, r0, r8, lsl r0
     a08:	000008e0 	andeq	r0, r0, r0, ror #17
     a0c:	00000000 	andeq	r0, r0, r0
     a10:	00000040 	andeq	r0, r0, r0, asr #32
     a14:	40080e42 	andmi	r0, r8, r2, asr #28
     a18:	85400284 	strbhi	r0, [r0, #-644]	; 0x284
     a1c:	00000001 	andeq	r0, r0, r1
     a20:	0000002c 	andeq	r0, r0, ip, lsr #32
     a24:	000008e0 	andeq	r0, r0, r0, ror #17
     a28:	0000221c 	andeq	r2, r0, ip, lsl r2
     a2c:	000005ea 	andeq	r0, r0, sl, ror #11
     a30:	40200e42 	eormi	r0, r0, r2, asr #28
     a34:	85400884 	strbhi	r0, [r0, #-2180]	; 0x884
     a38:	06864007 	streq	r4, [r6], r7
     a3c:	40058740 	andmi	r8, r5, r0, asr #14
     a40:	89400488 	stmdbhi	r0, {r3, r7, sl}^
     a44:	028a4003 	addeq	r4, sl, #3
     a48:	42018b40 	andmi	r8, r1, #64, 22	; 0x10000
     a4c:	0000400e 	andeq	r4, r0, lr
     a50:	0000001c 	andeq	r0, r0, ip, lsl r0
     a54:	000008e0 	andeq	r0, r0, r0, ror #17
     a58:	00000000 	andeq	r0, r0, r0
     a5c:	00000026 	andeq	r0, r0, r6, lsr #32
     a60:	400c0e41 	andmi	r0, ip, r1, asr #28
     a64:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     a68:	018e4002 	orreq	r4, lr, r2
     a6c:	00300e41 	eorseq	r0, r0, r1, asr #28
     a70:	0000002c 	andeq	r0, r0, ip, lsr #32
     a74:	000008e0 	andeq	r0, r0, r0, ror #17
     a78:	00002808 	andeq	r2, r0, r8, lsl #16
     a7c:	00000634 	andeq	r0, r0, r4, lsr r6
     a80:	40200e42 	eormi	r0, r0, r2, asr #28
     a84:	85400884 	strbhi	r0, [r0, #-2180]	; 0x884
     a88:	06864007 	streq	r4, [r6], r7
     a8c:	40058740 	andmi	r8, r5, r0, asr #14
     a90:	89400488 	stmdbhi	r0, {r3, r7, sl}^
     a94:	028a4003 	addeq	r4, sl, #3
     a98:	42018b40 	andmi	r8, r1, #64, 22	; 0x10000
     a9c:	0001b00e 	andeq	fp, r1, lr
     aa0:	0000000c 	andeq	r0, r0, ip
     aa4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     aa8:	7c020001 	stcvc	0, cr0, [r2], {1}
     aac:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     ab0:	00000014 	andeq	r0, r0, r4, lsl r0
     ab4:	00000aa0 	andeq	r0, r0, r0, lsr #21
     ab8:	00000000 	andeq	r0, r0, r0
     abc:	0000001e 	andeq	r0, r0, lr, lsl r0
     ac0:	40040e41 	andmi	r0, r4, r1, asr #28
     ac4:	00000184 	andeq	r0, r0, r4, lsl #3
     ac8:	00000030 	andeq	r0, r0, r0, lsr r0
     acc:	00000aa0 	andeq	r0, r0, r0, lsr #21
     ad0:	00002e3c 	andeq	r2, r0, ip, lsr lr
     ad4:	000001a0 	andeq	r0, r0, r0, lsr #3
     ad8:	40240e42 	eormi	r0, r4, r2, asr #28
     adc:	85400984 	strbhi	r0, [r0, #-2436]	; 0x984
     ae0:	07864008 	streq	r4, [r6, r8]
     ae4:	40068740 	andmi	r8, r6, r0, asr #14
     ae8:	89400588 	stmdbhi	r0, {r3, r7, r8, sl}^
     aec:	038a4004 	orreq	r4, sl, #4
     af0:	40028b40 	andmi	r8, r2, r0, asr #22
     af4:	0e42018e 	dvfeqd	f0, f2, #0.5
     af8:	00000050 	andeq	r0, r0, r0, asr r0
     afc:	0000001c 	andeq	r0, r0, ip, lsl r0
     b00:	00000aa0 	andeq	r0, r0, r0, lsr #21
     b04:	00000000 	andeq	r0, r0, r0
     b08:	0000002c 	andeq	r0, r0, ip, lsr #32
     b0c:	400c0e41 	andmi	r0, ip, r1, asr #28
     b10:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     b14:	018e4002 	orreq	r4, lr, r2
     b18:	00300e41 	eorseq	r0, r0, r1, asr #28
     b1c:	0000001c 	andeq	r0, r0, ip, lsl r0
     b20:	00000aa0 	andeq	r0, r0, r0, lsr #21
     b24:	00000000 	andeq	r0, r0, r0
     b28:	0000009a 	muleq	r0, sl, r0
     b2c:	40100e44 	andsmi	r0, r0, r4, asr #28
     b30:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     b34:	02864003 	addeq	r4, r6, #3
     b38:	00018740 	andeq	r8, r1, r0, asr #14
     b3c:	0000001c 	andeq	r0, r0, ip, lsl r0
     b40:	00000aa0 	andeq	r0, r0, r0, lsr #21
     b44:	00000000 	andeq	r0, r0, r0
     b48:	000000c2 	andeq	r0, r0, r2, asr #1
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	40100e41 	andsmi	r0, r0, r1, asr #28
  b	LoopCopyDataInit
     b50:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
     b54:	02864003 	addeq	r4, r6, #3
	str	r3, [r0, r1]
	adds	r1, r1, #4
     b58:	00018740 	andeq	r8, r1, r0, asr #14

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
     b5c:	0000001c 	andeq	r0, r0, ip, lsl r0
	adds	r2, r0, r1
	cmp	r2, r3
     b60:	00000aa0 	andeq	r0, r0, r0, lsr #21
	bcc	CopyDataInit
     b64:	00000000 	andeq	r0, r0, r0
	ldr	r2, =_sbss
	b	LoopFillZerobss
     b68:	00000058 	andeq	r0, r0, r8, asr r0
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	400c0e41 	andmi	r0, ip, r1, asr #28
	str	r3, [r2], #4
     b70:	85400384 	strbhi	r0, [r0, #-900]	; 0x384

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
     b74:	01864002 	orreq	r4, r6, r2
	bcc	FillZerobss
     b78:	00300e42 	eorseq	r0, r0, r2, asr #28
/* Call the application's entry point.*/
	bl	main
     b7c:	0000001c 	andeq	r0, r0, ip, lsl r0
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	00000aa0 	andeq	r0, r0, r0, lsr #21
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	00000000 	andeq	r0, r0, r0
	ldr	r3, =_edata
     b88:	0000008e 	andeq	r0, r0, lr, lsl #1
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	400c0e41 	andmi	r0, ip, r1, asr #28
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	01864002 	orreq	r4, r6, r2
}


/* dummy proc */
void nothingProc(void)
{
     b98:	00300e42 	eorseq	r0, r0, r2, asr #28
{
    return;
}

void usbStatusOut(void)
{
     b9c:	00000030 	andeq	r0, r0, r0, lsr r0
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
     ba0:	00000aa0 	andeq	r0, r0, r0, lsr #21
     ba4:	00000000 	andeq	r0, r0, r0
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	0000013e 	andeq	r0, r0, lr, lsr r1
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	40240e42 	eormi	r0, r4, r2, asr #28
     bb0:	85400984 	strbhi	r0, [r0, #-2436]	; 0x984
        bDeviceState = CONFIGURED;
     bb4:	07864008 	streq	r4, [r6, r8]
     bb8:	40068740 	andmi	r8, r6, r0, asr #14
     bbc:	89400588 	stmdbhi	r0, {r3, r7, r8, sl}^
     bc0:	038a4004 	orreq	r4, sl, #4
    }
}

void usbGetInterface(void)
{
     bc4:	40028b40 	andmi	r8, r2, r0, asr #22
{
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	0e42018e 	dvfeqd	f0, f2, #0.5
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	00000068 	andeq	r0, r0, r8, rrx
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	00000024 	andeq	r0, r0, r4, lsr #32
     bd4:	00000aa0 	andeq	r0, r0, r0, lsr #21
     bd8:	00000000 	andeq	r0, r0, r0
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	000000d2 	ldrdeq	r0, [r0], -r2
    dfuUpdateByReset();
     be0:	40180e42 	andsmi	r0, r8, r2, asr #28

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be8:	04864005 	streq	r4, [r6], #5
     bec:	40038740 	andmi	r8, r3, r0, asr #14
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	580e4301 	stmdapl	lr, {r0, r8, r9, lr}
     bf8:	0000000c 	andeq	r0, r0, ip

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfc:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     c00:	7c020001 	stcvc	0, cr0, [r2], {1}
     c04:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     c08:	00000020 	andeq	r0, r0, r0, lsr #32
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c0c:	00000bf8 	strdeq	r0, [r0], -r8
     c10:	00000000 	andeq	r0, r0, r0
     c14:	00000040 	andeq	r0, r0, r0, asr #32
     c18:	40100e41 	andsmi	r0, r0, r1, asr #28
     c1c:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c20:	02864003 	addeq	r4, r6, #3
     c24:	42018e40 	andmi	r8, r1, #64, 28	; 0x400
     c28:	0000500e 	andeq	r5, r0, lr
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	00000024 	andeq	r0, r0, r4, lsr #32
     c30:	00000bf8 	strdeq	r0, [r0], -r8
     c34:	00000000 	andeq	r0, r0, r0
     c38:	000000d4 	ldrdeq	r0, [r0], -r4
     c3c:	40180e42 	andsmi	r0, r8, r2, asr #28

    Clear_Status_Out(ENDP0);
     c40:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c44:	04864005 	streq	r4, [r6], #5
     c48:	40038740 	andmi	r8, r3, r0, asr #14
     c4c:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	780e4201 	stmdavc	lr, {r0, r9, lr}
     c54:	0000000c 	andeq	r0, r0, ip

    bDeviceState = ATTACHED;
     c58:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
     c5c:	7c020001 	stcvc	0, cr0, [r2], {1}

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c64:	00000020 	andeq	r0, r0, r0, lsr #32
     c68:	00000c54 	andeq	r0, r0, r4, asr ip
     c6c:	00002fdc 	ldrdeq	r2, [r0], -ip
     c70:	00000058 	andeq	r0, r0, r8, asr r0
     c74:	40140e42 	andsmi	r0, r4, r2, asr #28
     c78:	85400584 	strbhi	r0, [r0, #-1412]	; 0x584
     c7c:	03864004 	orreq	r4, r6, #4
     c80:	40028740 	andmi	r8, r2, r0, asr #14
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	00000188 	andeq	r0, r0, r8, lsl #3
     c88:	0000002c 	andeq	r0, r0, ip, lsr #32
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8c:	00000c54 	andeq	r0, r0, r4, asr ip
     c90:	00003034 	andeq	r3, r0, r4, lsr r0
     c94:	00001f64 	andeq	r1, r0, r4, ror #30
        if (dfuUpdateByRequest()) {
     c98:	40200e42 	eormi	r0, r0, r2, asr #28
     c9c:	85400884 	strbhi	r0, [r0, #-2180]	; 0x884
            // successfull state transition, handle the request
            switch (request) {
     ca0:	06864007 	streq	r4, [r6], r7
     ca4:	40058740 	andmi	r8, r5, r0, asr #14
     ca8:	89400488 	stmdbhi	r0, {r3, r7, sl}^
     cac:	028a4003 	addeq	r4, sl, #3
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	41018b40 	tstmi	r1, r0, asr #22
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
     cb4:	0001900e 	andeq	r9, r1, lr
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
     cb8:	00000024 	andeq	r0, r0, r4, lsr #32
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	00000c54 	andeq	r0, r0, r4, asr ip
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
     cc0:	00004f98 	muleq	r0, r8, pc	; <UNPREDICTABLE>
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	0000008e 	andeq	r0, r0, lr, lsl #1
        (*CopyRoutine)(0);

        return USB_SUCCESS;
     cc8:	40180e42 	andsmi	r0, r8, r2, asr #28
    }

    return USB_UNSUPPORT;
     ccc:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
}
     cd0:	04864005 	streq	r4, [r6], #5
     cd4:	40038740 	andmi	r8, r3, r0, asr #14
     cd8:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
     cdc:	00000001 	andeq	r0, r0, r1
     ce0:	00000030 	andeq	r0, r0, r0, lsr r0
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	00000c54 	andeq	r0, r0, r4, asr ip
     ce8:	00005028 	andeq	r5, r0, r8, lsr #32
     cec:	00000218 	andeq	r0, r0, r8, lsl r2
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	40240e42 	eormi	r0, r4, r2, asr #28
     cf4:	85400984 	strbhi	r0, [r0, #-2436]	; 0x984
     cf8:	07864008 	streq	r4, [r6, r8]
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	40068740 	andmi	r8, r6, r0, asr #14
     d00:	89400588 	stmdbhi	r0, {r3, r7, r8, sl}^
    if (strIndex > STR_DESC_LEN) {
     d04:	038a4004 	orreq	r4, sl, #4
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d08:	40028b40 	andmi	r8, r2, r0, asr #22
     d0c:	0e46018e 	dvfeqd	f0, f6, #0.5
    }
}
     d10:	00000030 	andeq	r0, r0, r0, lsr r0
     d14:	0000000c 	andeq	r0, r0, ip
     d18:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
     d1c:	7c020001 	stcvc	0, cr0, [r2], {1}
     d20:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     d24:	0000002c 	andeq	r0, r0, ip, lsr #32

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	00000d14 	andeq	r0, r0, r4, lsl sp
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2c:	00005240 	andeq	r5, r0, r0, asr #4
     d30:	00000494 	muleq	r0, r4, r4
     d34:	40200e42 	eormi	r0, r0, r2, asr #28
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	85400884 	strbhi	r0, [r0, #-2180]	; 0x884
     d3c:	06864007 	streq	r4, [r6], r7
            return USB_SUCCESS;
     d40:	40058740 	andmi	r8, r5, r0, asr #14
     d44:	89400488 	stmdbhi	r0, {r3, r7, sl}^
        }
    }
    return USB_UNSUPPORT;
}
     d48:	028a4003 	addeq	r4, sl, #3
     d4c:	41018b40 	tstmi	r1, r0, asr #22

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	0003b00e 	andeq	fp, r3, lr
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d54:	0000002c 	andeq	r0, r0, ip, lsr #32
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	00000d14 	andeq	r0, r0, r4, lsl sp
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5c:	000056d4 	ldrdeq	r5, [r0], -r4
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d60:	00000088 	andeq	r0, r0, r8, lsl #1
     d64:	40200e42 	eormi	r0, r0, r2, asr #28
     d68:	85400884 	strbhi	r0, [r0, #-2180]	; 0x884
     d6c:	06864007 	streq	r4, [r6], r7
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d70:	40058740 	andmi	r8, r5, r0, asr #14
     d74:	89400488 	stmdbhi	r0, {r3, r7, sl}^
     d78:	028a4003 	addeq	r4, sl, #3
     d7c:	42018e40 	andmi	r8, r1, #64, 28	; 0x400
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d80:	0001a00e 	andeq	sl, r1, lr
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	00000030 	andeq	r0, r0, r0, lsr r0
     d88:	00000d14 	andeq	r0, r0, r4, lsl sp
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8c:	0000575c 	andeq	r5, r0, ip, asr r7
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d90:	00000296 	muleq	r0, r6, r2
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d94:	40240e42 	eormi	r0, r4, r2, asr #28
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d98:	85400984 	strbhi	r0, [r0, #-2436]	; 0x984

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	07864008 	streq	r4, [r6, r8]
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	40068740 	andmi	r8, r6, r0, asr #14
     da4:	89400588 	stmdbhi	r0, {r3, r7, r8, sl}^
     da8:	038a4004 	orreq	r4, sl, #4
     dac:	40028b40 	andmi	r8, r2, r0, asr #22
     db0:	0e42018e 	dvfeqd	f0, f2, #0.5
     db4:	00000190 	muleq	r0, r0, r1
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	0000000c 	andeq	r0, r0, ip
     dbc:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dc0:	7c020001 	stcvc	0, cr0, [r2], {1}

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     dc8:	00000018 	andeq	r0, r0, r8, lsl r0
     dcc:	00000db8 			; <UNDEFINED> instruction: 0x00000db8
     dd0:	000059f4 	strdeq	r5, [r0], -r4
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	00000044 	andeq	r0, r0, r4, asr #32
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd8:	40080e41 	andmi	r0, r8, r1, asr #28
     ddc:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	00000001 	andeq	r0, r0, r1
     de4:	00000028 	andeq	r0, r0, r8, lsr #32
     de8:	00000db8 			; <UNDEFINED> instruction: 0x00000db8
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	00005a38 	andeq	r5, r0, r8, lsr sl
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	00000184 	andeq	r0, r0, r4, lsl #3
        ResumeS.eState = eResumeSetVal;
     df4:	40180e42 	andsmi	r0, r8, r2, asr #28

    switch (ResumeS.eState) {
     df8:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     dfc:	04864005 	streq	r4, [r6], #5
     e00:	40038740 	andmi	r8, r3, r0, asr #14
     e04:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	880e4101 	stmdahi	lr, {r0, r8, lr}
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	00000003 	andeq	r0, r0, r3
        ResumeS.eState = RESUME_START;
     e10:	0000000c 	andeq	r0, r0, ip
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
        ResumeS.eState = RESUME_WAIT;
     e18:	7c020001 	stcvc	0, cr0, [r2], {1}
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     e20:	0000000c 	andeq	r0, r0, ip
        if (ResumeS.bESOFcnt == 0)
     e24:	00000e10 	andeq	r0, r0, r0, lsl lr
            ResumeS.eState = RESUME_START;
     e28:	00000000 	andeq	r0, r0, r0
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	0000000c 	andeq	r0, r0, ip
     e30:	0000000c 	andeq	r0, r0, ip
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e34:	00000e10 	andeq	r0, r0, r0, lsl lr
        ResumeS.eState = RESUME_ON;
     e38:	00000000 	andeq	r0, r0, r0
        ResumeS.bESOFcnt = 10;
     e3c:	0000000c 	andeq	r0, r0, ip
        break;
     e40:	0000000c 	andeq	r0, r0, ip
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e44:	00000e10 	andeq	r0, r0, r0, lsl lr
     e48:	00000000 	andeq	r0, r0, r0
        if (ResumeS.bESOFcnt == 0) {
     e4c:	0000000c 	andeq	r0, r0, ip
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	0000000c 	andeq	r0, r0, ip
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	00000e10 	andeq	r0, r0, r0, lsl lr
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e58:	00000000 	andeq	r0, r0, r0
            ResumeS.eState = RESUME_OFF;
     e5c:	0000000c 	andeq	r0, r0, ip
     e60:	0000000c 	andeq	r0, r0, ip
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e64:	00000e10 	andeq	r0, r0, r0, lsl lr
     e68:	00000000 	andeq	r0, r0, r0
     e6c:	0000000c 	andeq	r0, r0, ip
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	0000000c 	andeq	r0, r0, ip
     e74:	00000e10 	andeq	r0, r0, r0, lsl lr
     e78:	00000000 	andeq	r0, r0, r0
     e7c:	0000000c 	andeq	r0, r0, ip

    _SetCNTR(CNTR_FRES);
     e80:	0000000c 	andeq	r0, r0, ip
     e84:	00000e10 	andeq	r0, r0, r0, lsl lr
     e88:	00000000 	andeq	r0, r0, r0
     e8c:	0000000c 	andeq	r0, r0, ip
    _SetCNTR(0);
    _SetISTR(0);
     e90:	0000000c 	andeq	r0, r0, ip

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e94:	00000e10 	andeq	r0, r0, r0, lsl lr
    _SetCNTR(wInterrupt_Mask);
     e98:	00000000 	andeq	r0, r0, r0
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9c:	00000010 	andeq	r0, r0, r0, lsl r0
     ea0:	0000000c 	andeq	r0, r0, ip
#endif
#endif

    return USB_SUCCESS;
}
     ea4:	00000e10 	andeq	r0, r0, r0, lsl lr
     ea8:	00000000 	andeq	r0, r0, r0
     eac:	0000000c 	andeq	r0, r0, ip
     eb0:	0000000c 	andeq	r0, r0, ip
     eb4:	00000e10 	andeq	r0, r0, r0, lsl lr

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	00000000 	andeq	r0, r0, r0
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	0000000e 	andeq	r0, r0, lr
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
     ec0:	0000000c 	andeq	r0, r0, ip
     ec4:	00000e10 	andeq	r0, r0, r0, lsl lr
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec8:	00000000 	andeq	r0, r0, r0
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     ecc:	00000010 	andeq	r0, r0, r0, lsl r0
     ed0:	0000000c 	andeq	r0, r0, ip
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	00000e10 	andeq	r0, r0, r0, lsl lr
     ed8:	00000000 	andeq	r0, r0, r0
     edc:	0000001c 	andeq	r0, r0, ip, lsl r0

    return USB_SUCCESS;
}
     ee0:	0000000c 	andeq	r0, r0, ip
     ee4:	00000e10 	andeq	r0, r0, r0, lsl lr
     ee8:	00000000 	andeq	r0, r0, r0
     eec:	00000012 	andeq	r0, r0, r2, lsl r0
     ef0:	0000000c 	andeq	r0, r0, ip
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	00000e10 	andeq	r0, r0, r0, lsl lr
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	00005bbc 			; <UNDEFINED> instruction: 0x00005bbc
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efc:	0000002a 	andeq	r0, r0, sl, lsr #32
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	0000000c 	andeq	r0, r0, ip
     f04:	00000e10 	andeq	r0, r0, r0, lsl lr
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f08:	00000000 	andeq	r0, r0, r0
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	0000002a 	andeq	r0, r0, sl, lsr #32
     f10:	0000000c 	andeq	r0, r0, ip
    nvicInit(&NVIC_InitStructure);
     f14:	00000e10 	andeq	r0, r0, r0, lsl lr
}
     f18:	00000000 	andeq	r0, r0, r0

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	00000024 	andeq	r0, r0, r4, lsr #32
    dfuInit();
     f20:	0000000c 	andeq	r0, r0, ip

    pInformation->Current_Configuration = 0;
     f24:	00000e10 	andeq	r0, r0, r0, lsl lr
     f28:	00000000 	andeq	r0, r0, r0
    usbPowerOn();
     f2c:	00000012 	andeq	r0, r0, r2, lsl r0

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
     f30:	0000000c 	andeq	r0, r0, ip
     f34:	00000e10 	andeq	r0, r0, r0, lsl lr
     f38:	00000000 	andeq	r0, r0, r0
    _SetCNTR(wInterrupt_Mask);
     f3c:	00000012 	andeq	r0, r0, r2, lsl r0

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f40:	0000000c 	andeq	r0, r0, ip
    bDeviceState = UNCONNECTED;
     f44:	00000e10 	andeq	r0, r0, r0, lsl lr
     f48:	00000000 	andeq	r0, r0, r0
     f4c:	0000001e 	andeq	r0, r0, lr, lsl r0
     f50:	0000000c 	andeq	r0, r0, ip
     f54:	00000e10 	andeq	r0, r0, r0, lsl lr
     f58:	00005be6 	andeq	r5, r0, r6, ror #23
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	0000001e 	andeq	r0, r0, lr, lsl r0
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f60:	0000000c 	andeq	r0, r0, ip
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	00000e10 	andeq	r0, r0, r0, lsl lr

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f68:	00000000 	andeq	r0, r0, r0
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	0000001e 	andeq	r0, r0, lr, lsl r0
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	0000000c 	andeq	r0, r0, ip
    nvicInit(&NVIC_InitStructure);
     f74:	00000e10 	andeq	r0, r0, r0, lsl lr
}
     f78:	00000000 	andeq	r0, r0, r0
     f7c:	0000001c 	andeq	r0, r0, ip, lsl r0

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	0000000c 	andeq	r0, r0, ip
    wIstr = _GetISTR();
     f84:	00000e10 	andeq	r0, r0, r0, lsl lr

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	00005c04 	andeq	r5, r0, r4, lsl #24
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8c:	0000001c 	andeq	r0, r0, ip, lsl r0

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f90:	0000000c 	andeq	r0, r0, ip
     f94:	00000e10 	andeq	r0, r0, r0, lsl lr
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	00000000 	andeq	r0, r0, r0
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	0000001e 	andeq	r0, r0, lr, lsl r0
     fa0:	0000000c 	andeq	r0, r0, ip
     fa4:	00000e10 	andeq	r0, r0, r0, lsl lr
        _SetISTR((u16)CLR_RESET);
     fa8:	00000000 	andeq	r0, r0, r0
        Device_Property.Reset();
     fac:	0000001e 	andeq	r0, r0, lr, lsl r0
     fb0:	0000000c 	andeq	r0, r0, ip
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb4:	00000e10 	andeq	r0, r0, r0, lsl lr
     fb8:	00000000 	andeq	r0, r0, r0
        _SetISTR((u16)CLR_ERR);
     fbc:	0000001c 	andeq	r0, r0, ip, lsl r0
     fc0:	0000000c 	andeq	r0, r0, ip
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc4:	00000e10 	andeq	r0, r0, r0, lsl lr
     fc8:	00000000 	andeq	r0, r0, r0
        _SetISTR((u16)CLR_WKUP);
     fcc:	0000001a 	andeq	r0, r0, sl, lsl r0
        usbResume(RESUME_EXTERNAL);
     fd0:	0000000c 	andeq	r0, r0, ip
     fd4:	00000e10 	andeq	r0, r0, r0, lsl lr
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd8:	00000000 	andeq	r0, r0, r0
     fdc:	0000001a 	andeq	r0, r0, sl, lsl r0

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	0000000c 	andeq	r0, r0, ip
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	00000e10 	andeq	r0, r0, r0, lsl lr
     fe8:	00000000 	andeq	r0, r0, r0
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fec:	00000018 	andeq	r0, r0, r8, lsl r0
     ff0:	0000000c 	andeq	r0, r0, ip
        _SetISTR((u16)CLR_SOF);
     ff4:	00000e10 	andeq	r0, r0, r0, lsl lr
     ff8:	00000000 	andeq	r0, r0, r0
        bIntPackSOF++;
     ffc:	0000001c 	andeq	r0, r0, ip, lsl r0
    1000:	0000000c 	andeq	r0, r0, ip
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	00000e10 	andeq	r0, r0, r0, lsl lr
    1008:	00000000 	andeq	r0, r0, r0
        _SetISTR((u16)CLR_ESOF);
    100c:	00000020 	andeq	r0, r0, r0, lsr #32
    1010:	0000000c 	andeq	r0, r0, ip
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    }
#endif

}
    1014:	00000e10 	andeq	r0, r0, r0, lsl lr
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	00000000 	andeq	r0, r0, r0
    101c:	00000020 	andeq	r0, r0, r0, lsr #32
    1020:	0000000c 	andeq	r0, r0, ip
    1024:	00000e10 	andeq	r0, r0, r0, lsl lr
    1028:	00005c20 	andeq	r5, r0, r0, lsr #24
    102c:	00000020 	andeq	r0, r0, r0, lsr #32
    1030:	0000000c 	andeq	r0, r0, ip
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

void print_hash(unsigned char hash[])
{
    1034:	00000e10 	andeq	r0, r0, r0, lsl lr
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
}

int main() 
{
    1038:	00005c40 	andeq	r5, r0, r0, asr #24
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    103c:	00000020 	andeq	r0, r0, r0, lsr #32
    setupCLK();
    1040:	0000000c 	andeq	r0, r0, ip
    setupLEDAndButton();
    1044:	00000e10 	andeq	r0, r0, r0, lsl lr
    setupUSB();
    1048:	00000000 	andeq	r0, r0, r0
    setupFLASH();
    104c:	0000001e 	andeq	r0, r0, lr, lsl r0
    uartInit();
    1050:	0000000c 	andeq	r0, r0, ip
    usbReset();
    1054:	00000e10 	andeq	r0, r0, r0, lsl lr
	uart_printf("\nBootloader init...\n");
    1058:	00000000 	andeq	r0, r0, r0
    105c:	00000012 	andeq	r0, r0, r2, lsl r0

    if (readPin(GPIOB, 15) == 0x0)
    1060:	0000000c 	andeq	r0, r0, ip
    1064:	00000e10 	andeq	r0, r0, r0, lsl lr
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1068:	00000000 	andeq	r0, r0, r0
    106c:	00000020 	andeq	r0, r0, r0, lsr #32
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    1070:	0000000c 	andeq	r0, r0, ip
    1074:	00000e10 	andeq	r0, r0, r0, lsl lr
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
    1078:	00000000 	andeq	r0, r0, r0
    107c:	00000020 	andeq	r0, r0, r0, lsr #32
    1080:	0000000c 	andeq	r0, r0, ip
   debug_print("\n", 0);
}

int main() 
{
	bool no_user_jump = FALSE;
    1084:	00000e10 	andeq	r0, r0, r0, lsl lr
    1088:	00005c60 	andeq	r5, r0, r0, ror #24
    108c:	0000001c 	andeq	r0, r0, ip, lsl r0
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1090:	0000000c 	andeq	r0, r0, ip
			no_user_jump = FALSE;
    1094:	00000e10 	andeq	r0, r0, r0, lsl lr
			break;

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    1098:	00005c7c 	andeq	r5, r0, ip, ror ip
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    109c:	0000001c 	andeq	r0, r0, ip, lsl r0
    10a0:	0000000c 	andeq	r0, r0, ip
			break;

		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10a4:	00000e10 	andeq	r0, r0, r0, lsl lr
    10a8:	00005c98 	muleq	r0, r8, ip
    10ac:	0000001c 	andeq	r0, r0, ip, lsl r0
    10b0:	0000000c 	andeq	r0, r0, ip
    10b4:	00000e10 	andeq	r0, r0, r0, lsl lr

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10b8:	00000000 	andeq	r0, r0, r0
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10bc:	00000026 	andeq	r0, r0, r6, lsr #32
    10c0:	0000000c 	andeq	r0, r0, ip
    10c4:	00000e10 	andeq	r0, r0, r0, lsl lr
    10c8:	00005cb4 			; <UNDEFINED> instruction: 0x00005cb4

		if (dfuUploadStarted()) 
    10cc:	00000040 	andeq	r0, r0, r0, asr #32
    10d0:	0000000c 	andeq	r0, r0, ip
		{
			uart_printf("DFU finished upload\n");
    10d4:	00000e10 	andeq	r0, r0, r0, lsl lr
			dfuFinishUpload(); // systemHardReset from DFU once done
    10d8:	00000000 	andeq	r0, r0, r0
    10dc:	00000020 	andeq	r0, r0, r0, lsr #32
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10e0:	0000000c 	andeq	r0, r0, ip
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10e4:	00000e10 	andeq	r0, r0, r0, lsl lr
    10e8:	00000000 	andeq	r0, r0, r0
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10ec:	00000020 	andeq	r0, r0, r0, lsr #32
	}
	
	return 0;// Added to please the compiler
    10f0:	00000018 	andeq	r0, r0, r8, lsl r0
    10f4:	00000e10 	andeq	r0, r0, r0, lsl lr
    10f8:	00000000 	andeq	r0, r0, r0
    10fc:	00000038 	andeq	r0, r0, r8, lsr r0
    1100:	40080e41 	andmi	r0, r8, r1, asr #28
    1104:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
    1108:	00000001 	andeq	r0, r0, r1
    110c:	0000000c 	andeq	r0, r0, ip
    1110:	00000e10 	andeq	r0, r0, r0, lsl lr
    1114:	00000000 	andeq	r0, r0, r0
    1118:	00000020 	andeq	r0, r0, r0, lsr #32
    111c:	0000000c 	andeq	r0, r0, ip
    1120:	00000e10 	andeq	r0, r0, r0, lsl lr
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1124:	00000000 	andeq	r0, r0, r0
    1128:	00000020 	andeq	r0, r0, r0, lsr #32
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    112c:	0000000c 	andeq	r0, r0, ip
    1130:	00000e10 	andeq	r0, r0, r0, lsl lr
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1134:	00000000 	andeq	r0, r0, r0
    1138:	0000001c 	andeq	r0, r0, ip, lsl r0
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    113c:	0000000c 	andeq	r0, r0, ip
    1140:	00000e10 	andeq	r0, r0, r0, lsl lr
        return TRUE;
    } else {
        return FALSE;
    }
}
    1144:	00000000 	andeq	r0, r0, r0
    1148:	0000001c 	andeq	r0, r0, ip, lsl r0

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    114c:	00000018 	andeq	r0, r0, r8, lsl r0
    1150:	00000e10 	andeq	r0, r0, r0, lsl lr
    1154:	00000000 	andeq	r0, r0, r0
    gpio_write_bit( bank,pin,1-onState);
    1158:	000000a8 	andeq	r0, r0, r8, lsr #1
    115c:	40080e42 	andmi	r0, r8, r2, asr #28
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
    gpio_write_bit( bank,pin,1-onState);
    1164:	00000001 	andeq	r0, r0, r1

    u32 c;
    while (count-- > 0) 
    1168:	0000000c 	andeq	r0, r0, ip
	{
        for (c = rate; c > 0; c--)
    116c:	00000e10 	andeq	r0, r0, r0, lsl lr
    1170:	00000000 	andeq	r0, r0, r0
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1174:	0000005c 	andeq	r0, r0, ip, asr r0
    1178:	0000000c 	andeq	r0, r0, ip
    117c:	00000e10 	andeq	r0, r0, r0, lsl lr
		
        for (c = rate; c > 0; c--)
    1180:	00000000 	andeq	r0, r0, r0
    1184:	0000005c 	andeq	r0, r0, ip, asr r0
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    1188:	0000000c 	andeq	r0, r0, ip
    118c:	00000e10 	andeq	r0, r0, r0, lsl lr
    1190:	00000000 	andeq	r0, r0, r0
    1194:	00000020 	andeq	r0, r0, r0, lsr #32
    1198:	0000000c 	andeq	r0, r0, ip

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    119c:	00000e10 	andeq	r0, r0, r0, lsl lr
    11a0:	00000000 	andeq	r0, r0, r0
  USARTx->DR = ch;  
    11a4:	00000020 	andeq	r0, r0, r0, lsr #32
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11a8:	0000000c 	andeq	r0, r0, ip
  while(*str != 0)
    11ac:	00000e10 	andeq	r0, r0, r0, lsl lr
    11b0:	00000000 	andeq	r0, r0, r0
  {
    UU_PutChar(USARTx, *str);
    11b4:	00000044 	andeq	r0, r0, r4, asr #32
    11b8:	0000000c 	andeq	r0, r0, ip
    str++;
  }
}

void vprint(const char *fmt, va_list argp)
{
    11bc:	00000e10 	andeq	r0, r0, r0, lsl lr
    11c0:	00000000 	andeq	r0, r0, r0
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11c4:	0000003a 	andeq	r0, r0, sl, lsr r0
    11c8:	0000000c 	andeq	r0, r0, ip
    11cc:	00000e10 	andeq	r0, r0, r0, lsl lr
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11d0:	00000000 	andeq	r0, r0, r0
    11d4:	00000006 	andeq	r0, r0, r6

    }
}
    11d8:	0000000c 	andeq	r0, r0, ip
    11dc:	00000e10 	andeq	r0, r0, r0, lsl lr
    11e0:	00000000 	andeq	r0, r0, r0

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11e4:	0000000a 	andeq	r0, r0, sl
    11e8:	0000000c 	andeq	r0, r0, ip
    11ec:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    va_list argp;
    va_start(argp, fmt);
    vprint(fmt, argp);
    11f0:	7c020001 	stcvc	0, cr0, [r2], {1}
    va_end(argp);
}
    11f4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    11f8:	0000001c 	andeq	r0, r0, ip, lsl r0
    11fc:	000011e8 	andeq	r1, r0, r8, ror #3

void hexdump(unsigned char *data, size_t size)
{
    1200:	00005cf4 	strdeq	r5, [r0], -r4
    int i;
    char cs[17];
    memset(cs, 0, 17);
    1204:	00000154 	andeq	r0, r0, r4, asr r1
    1208:	40100e41 	andsmi	r0, r0, r1, asr #28
    120c:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484

    for(i = 0; i < size; i++)
    1210:	02864003 	addeq	r4, r6, #3
    {
        if(i != 0 && i % 0x10 == 0)
    1214:	00018e40 	andeq	r8, r1, r0, asr #28
    1218:	00000018 	andeq	r0, r0, r8, lsl r0
        {
            debug_print(" |%s|\n", cs);
            memset(cs, 0, 17);
    121c:	000011e8 	andeq	r1, r0, r8, ror #3
    1220:	00000000 	andeq	r0, r0, r0
{
    int i;
    char cs[17];
    memset(cs, 0, 17);

    for(i = 0; i < size; i++)
    1224:	00000070 	andeq	r0, r0, r0, ror r0
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
}
    1228:	40080e41 	andmi	r0, r8, r1, asr #28


#endif
void uartInit(void) {
    122c:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
    1230:	00000001 	andeq	r0, r0, r1
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    1234:	0000000c 	andeq	r0, r0, ip
    1238:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    123c:	7c020001 	stcvc	0, cr0, [r2], {1}
    1240:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    1244:	00000018 	andeq	r0, r0, r8, lsl r0
    1248:	00001234 	andeq	r1, r0, r4, lsr r2
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    124c:	00005e48 	andeq	r5, r0, r8, asr #28
    1250:	00000038 	andeq	r0, r0, r8, lsr r0
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1254:	40080e41 	andmi	r0, r8, r1, asr #28
    1258:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    125c:	00000001 	andeq	r0, r0, r1
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    1260:	0000000c 	andeq	r0, r0, ip
    1264:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1268:	7c020001 	stcvc	0, cr0, [r2], {1}
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    126c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1270:	00000018 	andeq	r0, r0, r8, lsl r0
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1274:	00001260 	andeq	r1, r0, r0, ror #4
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1278:	00005e80 	andeq	r5, r0, r0, lsl #29
    127c:	00000024 	andeq	r0, r0, r4, lsr #32
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1280:	40080e41 	andmi	r0, r8, r1, asr #28
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    1284:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1288:	00000001 	andeq	r0, r0, r1
    USART_InitStructure.USART_Parity = USART_Parity_No;
    128c:	00000018 	andeq	r0, r0, r8, lsl r0
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    1290:	00001260 	andeq	r1, r0, r0, ror #4
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1294:	00005ea4 	andeq	r5, r0, r4, lsr #29
    1298:	00000024 	andeq	r0, r0, r4, lsr #32
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    129c:	40080e41 	andmi	r0, r8, r1, asr #28
        
    USART_Init(USART1, &USART_InitStructure);
    12a0:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    12a4:	00000001 	andeq	r0, r0, r1
    12a8:	00000018 	andeq	r0, r0, r8, lsl r0
}
    12ac:	00001260 	andeq	r1, r0, r0, ror #4
    12b0:	00005ec8 	andeq	r5, r0, r8, asr #29

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    12b4:	00000090 	muleq	r0, r0, r0
    12b8:	40080e41 	andmi	r0, r8, r1, asr #28
    12bc:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    12c0:	00000001 	andeq	r0, r0, r1
    12c4:	00000028 	andeq	r0, r0, r8, lsr #32
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    12c8:	00001260 	andeq	r1, r0, r0, ror #4
    12cc:	00005f58 	andeq	r5, r0, r8, asr pc
    12d0:	000000a8 	andeq	r0, r0, r8, lsr #1
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    12d4:	40200e43 	eormi	r0, r0, r3, asr #28
    12d8:	84400883 	strbhi	r0, [r0], #-2179	; 0x883
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    12dc:	06854007 	streq	r4, [r5], r7
    12e0:	40058640 	andmi	r8, r5, r0, asr #12

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    12e4:	88400487 	stmdahi	r0, {r0, r1, r2, r7, sl}^
    12e8:	02894003 	addeq	r4, r9, #3
    12ec:	00018e40 	andeq	r8, r1, r0, asr #28
    12f0:	00000018 	andeq	r0, r0, r8, lsl r0
    12f4:	00001260 	andeq	r1, r0, r0, ror #4
    12f8:	00006000 	andeq	r6, r0, r0
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    12fc:	00000038 	andeq	r0, r0, r8, lsr r0
    1300:	40080e41 	andmi	r0, r8, r1, asr #28
    1304:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    1308:	00000001 	andeq	r0, r0, r1
    130c:	0000001c 	andeq	r0, r0, ip, lsl r0

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    1310:	00001260 	andeq	r1, r0, r0, ror #4
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    1314:	00006038 	andeq	r6, r0, r8, lsr r0
    1318:	00000048 	andeq	r0, r0, r8, asr #32
    131c:	40100e41 	andsmi	r0, r0, r1, asr #28
    1320:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    1324:	02854003 	addeq	r4, r5, #3
    1328:	00018e40 	andeq	r8, r1, r0, asr #28

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    132c:	0000001c 	andeq	r0, r0, ip, lsl r0
    1330:	00001260 	andeq	r1, r0, r0, ror #4
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    1334:	00006080 	andeq	r6, r0, r0, lsl #1
    1338:	000000d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    133c:	40100e41 	andsmi	r0, r0, r1, asr #28
    1340:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    1344:	02854003 	addeq	r4, r5, #3
    1348:	00018e40 	andeq	r8, r1, r0, asr #28
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    134c:	0000001c 	andeq	r0, r0, ip, lsl r0
    1350:	00001260 	andeq	r1, r0, r0, ror #4
    1354:	00006150 	andeq	r6, r0, r0, asr r1
    1358:	00000084 	andeq	r0, r0, r4, lsl #1

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    135c:	40100e41 	andsmi	r0, r0, r1, asr #28
    1360:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
    1364:	02854003 	addeq	r4, r5, #3
    1368:	00018e40 	andeq	r8, r1, r0, asr #28
    136c:	00000018 	andeq	r0, r0, r8, lsl r0
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    1370:	00001260 	andeq	r1, r0, r0, ror #4
    1374:	000061d4 	ldrdeq	r6, [r0], -r4
        u32 rwmVal = pRCC->CR;
    1378:	00000024 	andeq	r0, r0, r4, lsr #32
        rwmVal |= 0x01;
    137c:	40080e41 	andmi	r0, r8, r1, asr #28
        pRCC->CR = rwmVal;
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    1380:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
    1384:	00000001 	andeq	r0, r0, r1
}   
    1388:	0000000c 	andeq	r0, r0, ip
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    138c:	00001260 	andeq	r1, r0, r0, ror #4
void setMspAndJump(u32 usrAddr) {
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    1390:	000061f8 	strdeq	r6, [r0], -r8
  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1394:	0000001c 	andeq	r0, r0, ip, lsl r0

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1398:	00000018 	andeq	r0, r0, r8, lsl r0
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    139c:	00001260 	andeq	r1, r0, r0, ror #4
    13a0:	00006214 	andeq	r6, r0, r4, lsl r2
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    13a4:	00000040 	andeq	r0, r0, r0, asr #32
    13a8:	40080e41 	andmi	r0, r8, r1, asr #28
    13ac:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
    13b0:	00000001 	andeq	r0, r0, r1
    tmppre = (0x4 - tmppriority);
    13b4:	00000024 	andeq	r0, r0, r4, lsr #32
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    13b8:	00001260 	andeq	r1, r0, r0, ror #4


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    13bc:	00006254 	andeq	r6, r0, r4, asr r2

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c0:	000002dc 	ldrdeq	r0, [r0], -ip
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    13c4:	40180e41 	andsmi	r0, r8, r1, asr #28

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c8:	81400680 	smlalbbhi	r0, r0, r0, r6	; <UNPREDICTABLE>
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    13cc:	04844005 	streq	r4, [r4], #5
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d0:	40038540 	andmi	r8, r3, r0, asr #10

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d4:	8e400286 	cdphi	2, 4, cr0, cr0, cr6, {4}
    13d8:	00000001 	andeq	r0, r0, r1
    13dc:	00000024 	andeq	r0, r0, r4, lsr #32
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    13e0:	00001260 	andeq	r1, r0, r0, ror #4
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    13e4:	00006530 	andeq	r6, r0, r0, lsr r5
    tmppriority &= tmpmask;
    13e8:	000000c8 	andeq	r0, r0, r8, asr #1
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    13ec:	40180e41 	andsmi	r0, r8, r1, asr #28

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    13f0:	84400683 	strbhi	r0, [r0], #-1667	; 0x683
    13f4:	04854005 	streq	r4, [r5], #5
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    13f8:	40038640 	andmi	r8, r3, r0, asr #12
    13fc:	8e400287 	cdphi	2, 4, cr0, cr0, cr7, {4}
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    1400:	00000001 	andeq	r0, r0, r1
    1404:	00000018 	andeq	r0, r0, r8, lsl r0
    1408:	00001260 	andeq	r1, r0, r0, ror #4
    140c:	000065f8 	strdeq	r6, [r0], -r8
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    1410:	00000038 	andeq	r0, r0, r8, lsr r0
    1414:	400c0e41 	andmi	r0, ip, r1, asr #28
    1418:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
    rNVIC->ICER[1] = 0xFFFFFFFF;
    141c:	018e4002 	orreq	r4, lr, r2
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    1420:	00000018 	andeq	r0, r0, r8, lsl r0
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    1424:	00001260 	andeq	r1, r0, r0, ror #4

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    1428:	00006630 	andeq	r6, r0, r0, lsr r6
    142c:	0000005c 	andeq	r0, r0, ip, asr r0
    1430:	40080e41 	andmi	r0, r8, r1, asr #28

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    1434:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    1438:	00000001 	andeq	r0, r0, r1
    nvicDisableInterrupts();
    143c:	0000000c 	andeq	r0, r0, ip
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    1440:	00001260 	andeq	r1, r0, r0, ror #4
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    1444:	00000000 	andeq	r0, r0, r0
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    1448:	00000002 	andeq	r0, r0, r2
}
    144c:	0000000c 	andeq	r0, r0, ip
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    1450:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1454:	7c020001 	stcvc	0, cr0, [r2], {1}
    1458:	000d0c0e 	andeq	r0, sp, lr, lsl #24

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    145c:	00000018 	andeq	r0, r0, r8, lsl r0
    1460:	0000144c 	andeq	r1, r0, ip, asr #8
    1464:	0000668c 	andeq	r6, r0, ip, lsl #13
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1468:	00000030 	andeq	r0, r0, r0, lsr r0
    146c:	400c0e41 	andmi	r0, ip, r1, asr #28
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    1470:	85400384 	strbhi	r0, [r0, #-900]	; 0x384

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1474:	018e4002 	orreq	r4, lr, r2
    1478:	00000018 	andeq	r0, r0, r8, lsl r0
    147c:	0000144c 	andeq	r1, r0, ip, asr #8
    SET_REG(FLASH_AR, pageAddr);
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    1480:	000066bc 			; <UNDEFINED> instruction: 0x000066bc
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1484:	00000024 	andeq	r0, r0, r4, lsr #32
    1488:	40080e41 	andmi	r0, r8, r1, asr #28

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    148c:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}

    return TRUE;
}
    1490:	00000001 	andeq	r0, r0, r1
    1494:	0000000c 	andeq	r0, r0, ip
    1498:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    149c:	7c020001 	stcvc	0, cr0, [r2], {1}
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    14a0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    14a4:	00000014 	andeq	r0, r0, r4, lsl r0

    u32 rwmVal = GET_REG(FLASH_CR);
    SET_REG(FLASH_CR, FLASH_CR_PG);
    14a8:	00001494 	muleq	r0, r4, r4
    14ac:	000066e0 	andeq	r6, r0, r0, ror #13

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14b0:	00000012 	andeq	r0, r0, r2, lsl r0
    14b4:	84080e41 	strhi	r0, [r8], #-3649	; 0xe41
    *(flashAddr + 0x01) = (vu16)hhWord;
    14b8:	00018e02 	andeq	r8, r1, r2, lsl #28
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14bc:	0000000c 	andeq	r0, r0, ip
    14c0:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    *(flashAddr) = (vu16)lhWord;
    14c4:	7c020001 	stcvc	0, cr0, [r2], {1}
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14c8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    14cc:	00000020 	andeq	r0, r0, r0, lsr #32

    rwmVal &= 0xFFFFFFFE;
    14d0:	000014bc 			; <UNDEFINED> instruction: 0x000014bc
    SET_REG(FLASH_CR, rwmVal);

    /* verify the write */
    if (*(vu32 *)addr != word) {
    14d4:	000066f2 	strdeq	r6, [r0], -r2
        return FALSE;
    }

    return TRUE;
}
    14d8:	0000003c 	andeq	r0, r0, ip, lsr r0
    14dc:	83200e42 	teqhi	r0, #1056	; 0x420
    14e0:	85078408 	strhi	r8, [r7, #-1032]	; 0x408
    14e4:	87058606 	strhi	r8, [r5, -r6, lsl #12]

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    14e8:	89038804 	stmdbhi	r3, {r2, fp, pc}
    14ec:	00018e02 	andeq	r8, r1, r2, lsl #28
    14f0:	0000000c 	andeq	r0, r0, ip
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    14f4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    14f8:	7c020001 	stcvc	0, cr0, [r2], {1}
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    14fc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    1500:	0000000c 	andeq	r0, r0, ip
    1504:	000014f0 	strdeq	r1, [r0], -r0
    1508:	0000672e 	andeq	r6, r0, lr, lsr #14

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    150c:	00000010 	andeq	r0, r0, r0, lsl r0
	{
		pin-=8;
    1510:	0000000c 	andeq	r0, r0, ip
	}
	mask = 0x0F << (pin<<2);
    1514:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    1518:	7c020001 	stcvc	0, cr0, [r2], {1}
	return ~mask;
}	
    151c:	000d0c0e 	andeq	r0, sp, lr, lsl #24

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    1520:	00000018 	andeq	r0, r0, r8, lsl r0
    1524:	00001510 	andeq	r1, r0, r0, lsl r5
}
    1528:	0000673e 	andeq	r6, r0, lr, lsr r7
    152c:	00000030 	andeq	r0, r0, r0, lsr r0

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    1530:	84080e41 	strhi	r0, [r8], #-3649	; 0xe41
	{
		return 0x800;
    1534:	41018e02 	tstmi	r1, r2, lsl #28
	}
	else
	{
		return 0x400;
	}
}
    1538:	0000700e 	andeq	r7, r0, lr
    153c:	00000018 	andeq	r0, r0, r8, lsl r0
    1540:	00001510 	andeq	r1, r0, r0, lsl r5
    1544:	00006770 	andeq	r6, r0, r0, ror r7

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1548:	0000001c 	andeq	r0, r0, ip, lsl r0
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    154c:	840c0e41 	strhi	r0, [ip], #-3649	; 0xe41

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1550:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1554:	00000001 	andeq	r0, r0, r1
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    1558:	0000000c 	andeq	r0, r0, ip
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    155c:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    1560:	7c020001 	stcvc	0, cr0, [r2], {1}
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1564:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1568:	00000018 	andeq	r0, r0, r8, lsl r0
    userAppEnd = RAM_END;
    156c:	00001558 	andeq	r1, r0, r8, asr r5
    1570:	0000678c 	andeq	r6, r0, ip, lsl #15
    userUploadType=DFU_UPLOAD_NONE;
    1574:	0000001e 	andeq	r0, r0, lr, lsl r0
    1578:	840c0e41 	strhi	r0, [ip], #-3649	; 0xe41
    code_copy_lock = WAIT;
    157c:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1580:	00000001 	andeq	r0, r0, r1
    1584:	0000000c 	andeq	r0, r0, ip
    1588:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    memset(input, 0xFF, sizeof(input));
    158c:	7c020001 	stcvc	0, cr0, [r2], {1}
    1590:	000d0c0e 	andeq	r0, sp, lr, lsl #24

    sha256_starts(&ctx);
}
    1594:	00000020 	andeq	r0, r0, r0, lsr #32
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1598:	00001584 	andeq	r1, r0, r4, lsl #11
    159c:	000067aa 	andeq	r6, r0, sl, lsr #15
    15a0:	000000b8 	strheq	r0, [r0], -r8
    15a4:	84200e42 	strthi	r0, [r0], #-3650	; 0xe42
    15a8:	86078508 	strhi	r8, [r7], -r8, lsl #10
    15ac:	88058706 	stmdahi	r5, {r1, r2, r8, r9, sl, pc}
    15b0:	8a038904 	bhi	e39c8 <_etext+0xdc4b0>
    15b4:	00018e02 	andeq	r8, r1, r2, lsl #28
    15b8:	00000028 	andeq	r0, r0, r8, lsr #32
    15bc:	00001584 	andeq	r1, r0, r4, lsl #11
    15c0:	00000000 	andeq	r0, r0, r0
    15c4:	000000f2 	strdeq	r0, [r0], -r2
    15c8:	80300e42 	eorshi	r0, r0, r2, asr #28
    15cc:	820b810c 	andhi	r8, fp, #12, 2
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    15d0:	8509840a 	strhi	r8, [r9, #-1034]	; 0x40a
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    15d4:	87078608 	strhi	r8, [r7, -r8, lsl #12]
    15d8:	89058806 	stmdbhi	r5, {r1, r2, fp, pc}

    if (startState == appDETACH) {
    15dc:	8b038a04 	blhi	e3df4 <_etext+0xdc8dc>
    15e0:	00018e02 	andeq	r8, r1, r2, lsl #28
        dfuAppStatus.bState = dfuIDLE;
    15e4:	00000024 	andeq	r0, r0, r4, lsr #32
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
    15e8:	00001584 	andeq	r1, r0, r4, lsl #11
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    15ec:	00006864 	andeq	r6, r0, r4, ror #16
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    15f0:	000001d8 	ldrdeq	r0, [r0], -r8
    } else if (startState == appIDLE || startState == dfuIDLE) {
    15f4:	841c0e42 	ldrhi	r0, [ip], #-3650	; 0xe42
    15f8:	86068507 	strhi	r8, [r6], -r7, lsl #10
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    15fc:	88048705 	stmdahi	r4, {r0, r2, r8, r9, sl, pc}
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1600:	8e028903 	cdphi	9, 0, cr8, cr2, cr3, {0}
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    1604:	900e4101 	andls	r4, lr, r1, lsl #2
    1608:	00000001 	andeq	r0, r0, r1
    160c:	0000000c 	andeq	r0, r0, ip
    1610:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    1614:	7c020001 	stcvc	0, cr0, [r2], {1}
        pInformation->Ctrl_Info.Usb_wLength = 1;
    1618:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    161c:	00000020 	andeq	r0, r0, r0, lsr #32
        return NULL;
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    1620:	0000160c 	andeq	r1, r0, ip, lsl #12
    }
}
    1624:	00006a3c 	andeq	r6, r0, ip, lsr sl
    1628:	000000e4 	andeq	r0, r0, r4, ror #1

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    162c:	83200e42 	teqhi	r0, #1056	; 0x420
        pInformation->Ctrl_Info.Usb_wLength = 6;
    1630:	85078408 	strhi	r8, [r7, #-1032]	; 0x408
    1634:	87058606 	strhi	r8, [r5, -r6, lsl #12]
        return NULL;
    } else {
        return (u8*)(&dfuAppStatus);
    1638:	89038804 	stmdbhi	r3, {r2, fp, pc}
    }
}
    163c:	00018e02 	andeq	r8, r1, r2, lsl #28
    1640:	00000028 	andeq	r0, r0, r8, lsr #32


u8 *dfuCopyDNLOAD(u16 length) {
    1644:	0000160c 	andeq	r1, r0, ip, lsl #12
    if (length == 0) {
    1648:	00006b20 	andeq	r6, r0, r0, lsr #22
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    164c:	00000228 	andeq	r0, r0, r8, lsr #4
    1650:	80300e42 	eorshi	r0, r0, r2, asr #28
        thisBlockLen = pInformation->USBwLengths.w;
    1654:	820b810c 	andhi	r8, fp, #12, 2
        return NULL;
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1658:	8409830a 	strhi	r8, [r9], #-778	; 0x30a
    165c:	86078508 	strhi	r8, [r7], -r8, lsl #10
    }
}
    1660:	88058706 	stmdahi	r5, {r1, r2, r8, r9, sl, pc}
    1664:	8a038904 	bhi	e3a7c <_etext+0xdc564>
    1668:	00018e02 	andeq	r8, r1, r2, lsl #28

u8 *dfuCopyUPLOAD(u16 length) {
    166c:	0000000c 	andeq	r0, r0, ip
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    1670:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    1674:	7c020001 	stcvc	0, cr0, [r2], {1}
    1678:	000d0c0e 	andeq	r0, sp, lr, lsl #24
        return NULL;
    167c:	00000014 	andeq	r0, r0, r4, lsl r0
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    1680:	0000166c 	andeq	r1, r0, ip, ror #12
    1684:	00006d48 	andeq	r6, r0, r8, asr #26
    1688:	0000001c 	andeq	r0, r0, ip, lsl r0
    168c:	84080e41 	strhi	r0, [r8], #-3649	; 0xe41
    }
}
    1690:	00018e02 	andeq	r8, r1, r2, lsl #28
    1694:	0000000c 	andeq	r0, r0, ip
    1698:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    169c:	7c020001 	stcvc	0, cr0, [r2], {1}

void dfuCopyBufferToExec() {
    16a0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    16a4:	00000018 	andeq	r0, r0, r8, lsl r0
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    16a8:	00001694 	muleq	r0, r4, r6
    16ac:	00006d64 	andeq	r6, r0, r4, ror #26
    16b0:	00000036 	andeq	r0, r0, r6, lsr r0
    16b4:	84100e42 	ldrhi	r0, [r0], #-3650	; 0xe42
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    16b8:	86038504 	strhi	r8, [r3], -r4, lsl #10
	}

    flashErasePage((u32)(userSpace));
    16bc:	00018e02 	andeq	r8, r1, r2, lsl #28

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16c0:	0000000c 	andeq	r0, r0, ip
    16c4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    16c8:	7c020001 	stcvc	0, cr0, [r2], {1}
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    16cc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    16d0:	00000018 	andeq	r0, r0, r8, lsl r0
    16d4:	000016c0 	andeq	r1, r0, r0, asr #13
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16d8:	00006d9c 	muleq	r0, ip, sp
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    16dc:	00000088 	andeq	r0, r0, r8, lsl #1
    16e0:	840c0e41 	strhi	r0, [ip], #-3649	; 0xe41
    thisBlockLen = 0;
    16e4:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
    16e8:	00000001 	andeq	r0, r0, r1
    16ec:	0000000c 	andeq	r0, r0, ip
    16f0:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    16f4:	7c020001 	stcvc	0, cr0, [r2], {1}
    16f8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    16fc:	00000018 	andeq	r0, r0, r8, lsl r0
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    1700:	000016ec 	andeq	r1, r0, ip, ror #13
    1704:	00006e24 	andeq	r6, r0, r4, lsr #28

    u8 startState = dfuAppStatus.bState;
    1708:	000000a8 	andeq	r0, r0, r8, lsr #1
    170c:	84100e41 	ldrhi	r0, [r0], #-3649	; 0xe41
    dfuAppStatus.bStatus = OK;
    1710:	86038504 	strhi	r8, [r3], -r4, lsl #10
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    1714:	00018e02 	andeq	r8, r1, r2, lsl #28

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    1718:	0000000c 	andeq	r0, r0, ip
    171c:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
            if (pInformation->USBwLengths.w > 0) {
    1720:	7c020001 	stcvc	0, cr0, [r2], {1}
    1724:	000d0c0e 	andeq	r0, sp, lr, lsl #24
                userFirmwareLen = 0;
    1728:	0000001c 	andeq	r0, r0, ip, lsl r0
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    172c:	00001718 	andeq	r1, r0, r8, lsl r7
    1730:	00006ecc 	andeq	r6, r0, ip, asr #29
    1734:	0000004c 	andeq	r0, r0, ip, asr #32
    1738:	83180e41 	tsthi	r8, #1040	; 0x410
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    173c:	85058406 	strhi	r8, [r5, #-1030]	; 0x406
						userAppAddr = USER_CODE_FLASH0X8002000;
    1740:	87038604 	strhi	r8, [r3, -r4, lsl #12]
    1744:	00018e02 	andeq	r8, r1, r2, lsl #28
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    1748:	0000000c 	andeq	r0, r0, ip
    174c:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    1750:	7c020001 	stcvc	0, cr0, [r2], {1}
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1754:	000d0c0e 	andeq	r0, sp, lr, lsl #24
						flashUnlock();
    1758:	00000018 	andeq	r0, r0, r8, lsl r0

						break;
    175c:	00001748 	andeq	r1, r0, r8, asr #14

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    1760:	00006f18 	andeq	r6, r0, r8, lsl pc
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1764:	00000020 	andeq	r0, r0, r0, lsr #32
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1768:	83100e41 	tsthi	r0, #1040	; 0x410
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    176c:	85038404 	strhi	r8, [r3, #-1028]	; 0x404
    1770:	00018e02 	andeq	r8, r1, r2, lsl #28
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    1774:	0000000c 	andeq	r0, r0, ip
    1778:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    177c:	7c020001 	stcvc	0, cr0, [r2], {1}
    1780:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    1784:	0000000c 	andeq	r0, r0, ip
			
            switch(pInformation->Current_AlternateSetting) {
    1788:	00001774 	andeq	r1, r0, r4, ror r7
    178c:	00006f38 	andeq	r6, r0, r8, lsr pc
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1790:	00000010 	andeq	r0, r0, r0, lsl r0
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1794:	0000000c 	andeq	r0, r0, ip
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1798:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
					userAppEnd = getFlashEnd();
    179c:	7c020001 	stcvc	0, cr0, [r2], {1}
    17a0:	000d0c0e 	andeq	r0, sp, lr, lsl #24

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    17a4:	0000000c 	andeq	r0, r0, ip
					dfuAppStatus.bStatus = errWRITE;
    17a8:	00001794 	muleq	r0, r4, r7
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    17ac:	00006f48 	andeq	r6, r0, r8, asr #30
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17b0:	00000012 	andeq	r0, r0, r2, lsl r0
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17b4:	0000000c 	andeq	r0, r0, ip
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    17b8:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17bc:	7c020001 	stcvc	0, cr0, [r2], {1}
    17c0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    17c4:	00000018 	andeq	r0, r0, r8, lsl r0

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17c8:	000017b4 			; <UNDEFINED> instruction: 0x000017b4
                dfuCopyBufferToExec();
    17cc:	00000000 	andeq	r0, r0, r0
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17d0:	0000001a 	andeq	r0, r0, sl, lsl r0
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    17d4:	83100e41 	tsthi	r0, #1040	; 0x410
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    17d8:	85038404 	strhi	r8, [r3, #-1028]	; 0x404
    17dc:	00018e02 	andeq	r8, r1, r2, lsl #28

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    17e0:	00000018 	andeq	r0, r0, r8, lsl r0
    17e4:	000017b4 			; <UNDEFINED> instruction: 0x000017b4
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17e8:	00000000 	andeq	r0, r0, r0
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    17ec:	000000bc 	strheq	r0, [r0], -ip
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17f0:	84100e42 	ldrhi	r0, [r0], #-3650	; 0xe42
    17f4:	86038504 	strhi	r8, [r3], -r4, lsl #10
    17f8:	00018e02 	andeq	r8, r1, r2, lsl #28
            if (pInformation->USBwLengths.w > 0) {
    17fc:	0000000c 	andeq	r0, r0, ip
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    1800:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    1804:	7c020001 	stcvc	0, cr0, [r2], {1}
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    1808:	000d0c0e 	andeq	r0, sp, lr, lsl #24
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    180c:	0000000c 	andeq	r0, r0, ip
                }
                switch (ret)
    1810:	000017fc 	strdeq	r1, [r0], -ip
    1814:	00006f5c 	andeq	r6, r0, ip, asr pc
    1818:	00000034 	andeq	r0, r0, r4, lsr r0

Disassembly of section .debug_str:

00000000 <.debug_str>:
       0:	31425041 	cmpcc	r2, r1, asr #32
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
       4:	00524e45 	subseq	r4, r2, r5, asr #28
       8:	55534552 	ldrbpl	r4, [r3, #-1362]	; 0x552
       c:	4c5f454d 	cfldr64mi	mvdx4, [pc], {77}	; 0x4d
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
      10:	52455441 	subpl	r5, r5, #1090519040	; 0x41000000
      14:	42535500 	subsmi	r5, r3, #0, 10
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
      18:	71655262 	cmnvc	r5, r2, ror #4
      1c:	74736575 	ldrbtvc	r6, [r3], #-1397	; 0x575
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
      20:	72747300 	rsbsvc	r7, r4, #0, 6
      24:	65646e49 	strbvs	r6, [r4, #-3657]!	; 0xe49
      28:	50410078 	subpl	r0, r1, r8, ror r0
    if ((wEPVal & EP_CTR_RX) != 0)
      2c:	53523242 	cmppl	r2, #536870916	; 0x20000004
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
      30:	4f005254 	svcmi	0x00005254
      34:	6544656e 	strbvs	r6, [r4, #-1390]	; 0x56e
      38:	69726373 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, r8, r9, sp, lr}^

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
      3c:	726f7470 	rsbvc	r7, pc, #112, 8	; 0x70000000

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
      40:	5f387500 	svcpl	0x00387500
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
      44:	43627375 	cmnmi	r2, #-738197503	; 0xd4000001
      48:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
      4c:	73654467 	cmnvc	r5, #1728053248	; 0x67000000

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
      50:	70697263 	rsbvc	r7, r9, r3, ror #4
      54:	44726f74 	ldrbtmi	r6, [r2], #-3956	; 0xf74
      58:	75005546 	strvc	r5, [r0, #-1350]	; 0x546
      5c:	6e496273 	mcrvs	2, 2, r6, cr9, cr3, {3}
      60:	69007469 	stmdbvs	r0, {r0, r3, r5, r6, sl, ip, sp, lr}
      64:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
      68:	65636166 	strbvs	r6, [r3, #-358]!	; 0x166
      6c:	616c4300 	cmnvs	ip, r0, lsl #6
      70:	4e5f7373 	mrcmi	3, 2, r7, cr15, cr3, {3}
      74:	7461446f 	strbtvc	r4, [r1], #-1135	; 0x46f
      78:	65535f61 	ldrbvs	r5, [r3, #-3937]	; 0xf61
      7c:	00707574 	rsbseq	r7, r0, r4, ror r5
      80:	44627375 	strbtmi	r7, [r2], #-885	; 0x375
      84:	53496273 	movtpl	r6, #37491	; 0x9273
      88:	555f0052 	ldrbpl	r0, [pc, #-82]	; 3e <g_pfnVectors+0x3e>
      8c:	5f524553 	svcpl	0x00524553
      90:	4e415453 	mcrmi	4, 2, r5, cr1, cr3, {2}
      94:	44524144 	ldrbmi	r4, [r2], #-324	; 0x144
      98:	5145525f 	cmppl	r5, pc, asr r2
      9c:	54534555 	ldrbpl	r4, [r3], #-1365	; 0x555
      a0:	73550053 	cmpvc	r5, #83	; 0x53
      a4:	475f7265 	ldrbmi	r7, [pc, -r5, ror #4]
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
      a8:	74537465 	ldrbvc	r7, [r3], #-1125	; 0x465

	return f25519_eq(a, c);
      ac:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
      b0:	72547700 	subsvc	r7, r4, #0, 14
      b4:	66736e61 	ldrbtvs	r6, [r3], -r1, ror #28
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
      b8:	69537265 	ldmdbvs	r3, {r0, r2, r5, r6, r9, ip, sp, lr}^
	f25519_normalize(ey);
      bc:	5500657a 	strpl	r6, [r0, #-1402]	; 0x57a
      c0:	4c5f4253 	lfmmi	f4, 2, [pc], {83}	; 0x53

	return ok;
}
      c4:	41435f50 	cmpmi	r3, r0, asr pc
      c8:	525f314e 	subspl	r3, pc, #-2147483629	; 0x80000013
      cc:	495f3058 	ldmdbmi	pc, {r3, r4, r6, ip, sp}^	; <UNPREDICTABLE>
      d0:	61485152 	cmpvs	r8, r2, asr r1
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
      d4:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
      d8:	73750072 	cmnvc	r5, #114	; 0x72
		minusp[i] = c;
      dc:	74654762 	strbtvc	r4, [r5], #-1890	; 0x762
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
      e0:	65746e49 	ldrbvs	r6, [r4, #-3657]!	; 0xe49
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
      e4:	63616672 	cmnvs	r1, #119537664	; 0x7200000

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
      e8:	74655365 	strbtvc	r5, [r5], #-869	; 0x365
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
      ec:	676e6974 			; <UNDEFINED> instruction: 0x676e6974
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
      f0:	50424100 	subpl	r4, r2, r0, lsl #2
      f4:	54535231 	ldrbpl	r5, [r3], #-561	; 0x231
      f8:	525f0052 	subspl	r0, pc, #82	; 0x52
      fc:	4d555345 	ldclmi	3, cr5, [r5, #-276]	; 0xfffffeec
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     100:	54535f45 	ldrbpl	r5, [r3], #-3909	; 0xf45

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
     104:	00455441 	subeq	r5, r5, r1, asr #8
     108:	68746f6e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     10c:	50676e69 	rsbpl	r6, r7, r9, ror #28
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
     110:	00636f72 	rsbeq	r6, r3, r2, ror pc
     114:	5645445f 			; <UNDEFINED> instruction: 0x5645445f
     118:	5f454349 	svcpl	0x00454349
     11c:	4f464e49 	svcmi	0x00464e49
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     120:	62737500 	rsbsvs	r7, r3, #0, 10
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
     124:	61446f4e 	cmpvs	r4, lr, asr #30
     128:	65536174 	ldrbvs	r6, [r3, #-372]	; 0x174
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
     12c:	00707574 	rsbseq	r7, r0, r4, ror r5

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
     130:	5f425355 	svcpl	0x00425355
	i <<= 3;

	while (x) {
     134:	55534e55 	ldrbpl	r4, [r3, #-3669]	; 0xe55
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
     138:	524f5050 	subpl	r5, pc, #80	; 0x50
     13c:	50700054 	rsbspl	r0, r0, r4, asr r0
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
     140:	65706f72 	ldrbvs	r6, [r0, #-3954]!	; 0xf72
	f25519_mul_c(z3, x1sq, 4);
     144:	00797472 	rsbseq	r7, r9, r2, ror r4
     148:	77425355 	smlsldvc	r5, r2, r5, r3
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	65646e49 	strbvs	r6, [r4, #-3657]!	; 0xe49
     150:	75007378 	strvc	r7, [r0, #-888]	; 0x378
     154:	65536273 	ldrbvs	r6, [r3, #-627]	; 0x273
	f25519_sub(b, x3, z3); /* D */
     158:	6e6f4374 	mcrvs	3, 3, r4, cr15, cr4, {3}
     15c:	75676966 	strbvc	r6, [r7, #-2406]!	; 0x966
	f25519_mul__distinct(da, a, b);
     160:	69746172 	ldmdbvs	r4!, {r1, r4, r5, r6, r8, sp, lr}^
     164:	52006e6f 	andpl	r6, r0, #1776	; 0x6f0
     168:	4d555345 	ldclmi	3, cr5, [r5, #-276]	; 0xfffffeec

	f25519_sub(b, x2, z2);
     16c:	41575f45 	cmpmi	r7, r5, asr #30
     170:	61005449 	tstvs	r0, r9, asr #8
	f25519_add(a, x3, z3); /* C */
     174:	6553746c 	ldrbvs	r7, [r3, #-1132]	; 0x46c
     178:	6e697474 	mcrvs	4, 3, r7, cr9, cr4, {3}
     17c:	4e450067 	cdpmi	0, 4, cr0, cr5, cr7, {3}
	f25519_mul__distinct(cb, a, b);
     180:	494f5044 	stmdbmi	pc, {r2, r6, ip, lr}^	; <UNPREDICTABLE>
     184:	525f544e 	subspl	r5, pc, #1308622848	; 0x4e000000

	f25519_add(a, da, cb);
     188:	50494345 	subpl	r4, r9, r5, asr #6
     18c:	544e4549 	strbpl	r4, [lr], #-1353	; 0x549
     190:	65735500 	ldrbvs	r5, [r3, #-1280]!	; 0x500
	f25519_mul__distinct(b, a, a);
     194:	65535f72 	ldrbvs	r5, [r3, #-3954]	; 0xf72
     198:	76654474 			; <UNDEFINED> instruction: 0x76654474
	f25519_mul__distinct(x5, z1, b);
     19c:	46656369 	strbtmi	r6, [r5], -r9, ror #6
     1a0:	75746165 	ldrbvc	r6, [r4, #-357]!	; 0x165
     1a4:	54006572 	strpl	r6, [r0], #-1394	; 0x572

	f25519_sub(a, da, cb);
     1a8:	00455552 	subeq	r5, r5, r2, asr r5
     1ac:	53627375 	cmnpl	r2, #-738197503	; 0xd4000001
	f25519_mul__distinct(b, a, a);
     1b0:	65447465 	strbvs	r7, [r4, #-1125]	; 0x465
     1b4:	65636976 	strbvs	r6, [r3, #-2422]!	; 0x976
     1b8:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	00737365 	rsbseq	r7, r3, r5, ror #6
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	47627375 			; <UNDEFINED> instruction: 0x47627375
     1c4:	74537465 	ldrbvc	r7, [r3], #-1125	; 0x465

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1c8:	676e6972 			; <UNDEFINED> instruction: 0x676e6972
     1cc:	63736544 	cmnvs	r3, #68, 10	; 0x11000000
     1d0:	74706972 	ldrbtvc	r6, [r0], #-2418	; 0x972
     1d4:	5500726f 	strpl	r7, [r0, #-623]	; 0x26f
		f25519_select(zm1, zm1, zm, bit);
     1d8:	775f6273 			; <UNDEFINED> instruction: 0x775f6273
     1dc:	676e654c 	strbvs	r6, [lr, -ip, asr #10]!
     1e0:	76006874 			; <UNDEFINED> instruction: 0x76006874
		f25519_select(xm, xm, xms, bit);
     1e4:	00363175 	eorseq	r3, r6, r5, ror r1
     1e8:	666e4970 			; <UNDEFINED> instruction: 0x666e4970
     1ec:	616d726f 	cmnvs	sp, pc, ror #4
		f25519_select(zm, zm, zms, bit);
     1f0:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
     1f4:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
     1f8:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fc:	79547469 	ldmdbvc	r4, {r0, r3, r5, r6, sl, ip, sp, lr}^
     200:	65446570 	strbvs	r6, [r4, #-1392]	; 0x570
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     204:	73750066 	cmnvc	r5, #102	; 0x66
     208:	74654762 	strbtvc	r4, [r5], #-1890	; 0x762
	f25519_mul__distinct(result, zm1, xm);
     20c:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
     210:	72756769 	rsbsvc	r6, r5, #27525120	; 0x1a40000
	f25519_normalize(result);
     214:	6f697461 	svcvs	0x00697461
     218:	6544006e 	strbvs	r0, [r4, #-110]	; 0x6e
}
     21c:	65636976 	strbvs	r6, [r3, #-2422]!	; 0x976
     220:	6261545f 	rsbvs	r5, r1, #1593835520	; 0x5f000000
     224:	7500656c 	strvc	r6, [r0, #-1388]	; 0x56c
     228:	65536273 	ldrbvs	r6, [r3, #-627]	; 0x273
     22c:	646e4574 	strbtvs	r4, [lr], #-1396	; 0x574
     230:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
     234:	61654674 	smcvs	21604	; 0x5464
     238:	65727574 	ldrbvs	r7, [r2, #-1396]!	; 0x574
     23c:	45525f00 	ldrbmi	r5, [r2, #-3840]	; 0xf00
     240:	49504943 	ldmdbmi	r0, {r0, r1, r6, r8, fp, lr}^
     244:	5f544e45 	svcpl	0x00544e45
     248:	45505954 	ldrbmi	r5, [r0, #-2388]	; 0x954
     24c:	6e6f6c00 	cdpvs	12, 6, cr6, cr15, cr0, {0}
     250:	6f6c2067 	svcvs	0x006c2067
     254:	7520676e 	strvc	r6, [r0, #-1902]!	; 0x76e
     258:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
     25c:	2064656e 	rsbcs	r6, r4, lr, ror #10
     260:	00746e69 	rsbseq	r6, r4, r9, ror #28
     264:	6e617453 	mcrvs	4, 3, r7, cr1, cr3, {2}
     268:	64726164 	ldrbtvs	r6, [r2], #-356	; 0x164
     26c:	7465475f 	strbtvc	r4, [r5], #-1887	; 0x75f
     270:	63736544 	cmnvs	r3, #68, 10	; 0x11000000
     274:	74706972 	ldrbtvc	r6, [r0], #-2418	; 0x972
     278:	6144726f 	cmpvs	r4, pc, ror #4
     27c:	63006174 	movwvs	r6, #372	; 0x174
     280:	73614d72 	cmnvc	r1, #7296	; 0x1c80
     284:	5355006b 	cmppl	r5, #107	; 0x6b
     288:	55535f42 	ldrbpl	r5, [r3, #-3906]	; 0xf42
     28c:	53454343 	movtpl	r4, #21315	; 0x5343
     290:	53550053 	cmppl	r5, #83	; 0x53
     294:	6e495f42 	cdpvs	15, 4, cr5, cr9, cr2, {2}
     298:	55007469 	strpl	r7, [r0, #-1129]	; 0x469
     29c:	5f726573 	svcpl	0x00726573
     2a0:	49746547 	ldmdbmi	r4!, {r0, r1, r2, r6, r8, sl, sp, lr}^
     2a4:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
     2a8:	65636166 	strbvs	r6, [r3, #-358]!	; 0x166
     2ac:	65735500 	ldrbvs	r5, [r3, #-1280]!	; 0x500
     2b0:	65535f72 	ldrbvs	r5, [r3, #-3954]	; 0xf72
     2b4:	76654474 			; <UNDEFINED> instruction: 0x76654474
     2b8:	41656369 	cmnmi	r5, r9, ror #6
     2bc:	65726464 	ldrbvs	r6, [r2, #-1124]!	; 0x464
     2c0:	43007373 	movwmi	r7, #883	; 0x373
     2c4:	7373616c 	cmnvc	r3, #108, 2
     2c8:	7461445f 	strbtvc	r4, [r1], #-1119	; 0x45f
     2cc:	65535f61 	ldrbvs	r5, [r3, #-3937]	; 0xf61
     2d0:	00707574 	rsbseq	r7, r0, r4, ror r5
     2d4:	47627375 			; <UNDEFINED> instruction: 0x47627375
     2d8:	65447465 	strbvs	r7, [r4, #-1125]	; 0x465
     2dc:	65636976 	strbvs	r6, [r3, #-2422]!	; 0x976
     2e0:	63736544 	cmnvs	r3, #68, 10	; 0x11000000
     2e4:	74706972 	ldrbtvc	r6, [r0], #-2418	; 0x972
     2e8:	4400726f 	strmi	r7, [r0], #-623	; 0x26f
     2ec:	63697665 	cmnvs	r9, #105906176	; 0x6500000
     2f0:	72505f65 	subsvc	r5, r0, #404	; 0x194
     2f4:	7265706f 	rsbvc	r7, r5, #111	; 0x6f
     2f8:	62007974 	andvs	r7, r0, #116, 18	; 0x1d0000
     2fc:	69766544 	ldmdbvs	r6!, {r2, r6, r8, sl, sp, lr}^
     300:	74536563 	ldrbvc	r6, [r3], #-1379	; 0x563
     304:	00657461 	rsbeq	r7, r5, r1, ror #8
     308:	4f534562 	svcmi	0x00534562
     30c:	746e6346 	strbtvc	r6, [lr], #-838	; 0x346
     310:	42535500 	subsmi	r5, r3, #0, 10
     314:	6c615677 	stclvs	6, cr5, [r1], #-476	; 0xfffffe24
     318:	00736575 	rsbseq	r6, r3, r5, ror r5
     31c:	55534552 	ldrbpl	r4, [r3, #-1362]	; 0x552
     320:	455f454d 	ldrbmi	r4, [pc, #-1357]	; fffffddb <BootRAM+0xef7057c>
     324:	00464f53 	subeq	r4, r6, r3, asr pc
     328:	41627375 	smcmi	10037	; 0x2735
     32c:	6e497070 	mcrvs	0, 2, r7, cr9, cr0, {3}
     330:	52007469 	andpl	r7, r0, #1761607680	; 0x69000000
     334:	545f4343 	ldrbpl	r4, [pc], #-835	; 33c <GPIO_PinRemapConfig+0x8>
     338:	44657079 	strbtmi	r7, [r5], #-121	; 0x79
     33c:	75006665 	strvc	r6, [r0, #-1637]	; 0x665
     340:	65476273 	strbvs	r6, [r7, #-627]	; 0x273
     344:	6e754674 	mrcvs	6, 3, r4, cr5, cr4, {3}
     348:	6f697463 	svcvs	0x00697463
     34c:	446c616e 	strbtmi	r6, [ip], #-366	; 0x16e
     350:	72637365 	rsbvc	r7, r3, #-1811939327	; 0x94000001
     354:	6f747069 	svcvs	0x00747069
     358:	75760072 	ldrbvc	r0, [r6, #-114]!	; 0x72
     35c:	67003233 	smladxvs	r0, r3, r2, r3
     360:	6c467465 	cfstrdvs	mvd7, [r6], {101}	; 0x65
     364:	50687361 	rsbpl	r7, r8, r1, ror #6
     368:	53656761 	cmnpl	r5, #25427968	; 0x1840000
     36c:	00657a69 	rsbeq	r7, r5, r9, ror #20
     370:	61746f54 	cmnvs	r4, r4, asr pc
     374:	6e455f6c 	cdpvs	15, 4, cr5, cr5, cr12, {3}
     378:	696f7064 	stmdbvs	pc!, {r2, r5, r6, ip, sp, lr}^	; <UNPREDICTABLE>
     37c:	5300746e 	movwpl	r7, #1134	; 0x46e
     380:	50457465 	subpl	r7, r5, r5, ror #8
     384:	61567852 	cmpvs	r6, r2, asr r8
     388:	0064696c 	rsbeq	r6, r4, ip, ror #18
     38c:	55534552 	ldrbpl	r4, [r3, #-1362]	; 0x552
     390:	4f5f454d 	svcmi	0x005f454d
     394:	564e004e 	strbpl	r0, [lr], -lr, asr #32
     398:	495f4349 	ldmdbmi	pc, {r0, r3, r6, r8, r9, lr}^	; <UNPREDICTABLE>
     39c:	68435152 	stmdavs	r3, {r1, r4, r6, r8, ip, lr}^
     3a0:	656e6e61 	strbvs	r6, [lr, #-3681]!	; 0xe61
     3a4:	646d436c 	strbtvs	r4, [sp], #-876	; 0x36c
     3a8:	45445f00 	strbmi	r5, [r4, #-3840]	; 0xf00
     3ac:	45434956 	strbmi	r4, [r3, #-2390]	; 0x956
     3b0:	4f52505f 	svcmi	0x0052505f
     3b4:	73750050 	cmnvc	r5, #80	; 0x50
     3b8:	74654762 	strbtvc	r4, [r5], #-1890	; 0x762
     3bc:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
     3c0:	65446769 	strbvs	r6, [r4, #-1897]	; 0x769
     3c4:	69726373 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, r8, r9, sp, lr}^
     3c8:	726f7470 	rsbvc	r7, pc, #112, 8	; 0x70000000
     3cc:	44444100 	strbmi	r4, [r4], #-256	; 0x100
     3d0:	53534552 	cmppl	r3, #343932928	; 0x14800000
     3d4:	75004445 	strvc	r4, [r0, #-1093]	; 0x445
     3d8:	74536273 	ldrbvc	r6, [r3], #-627	; 0x273
     3dc:	676e6972 			; <UNDEFINED> instruction: 0x676e6972
     3e0:	63736544 	cmnvs	r3, #68, 10	; 0x11000000
     3e4:	74706972 	ldrbtvc	r6, [r0], #-2418	; 0x972
     3e8:	7500726f 	strvc	r7, [r0, #-623]	; 0x26f
     3ec:	632e6273 	teqvs	lr, #805306375	; 0x30000007
     3f0:	73654400 	cmnvc	r5, #0, 8
     3f4:	70697263 	rsbvc	r7, r9, r3, ror #4
     3f8:	5f726f74 	svcpl	0x00726f74
     3fc:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
     400:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
     404:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
     408:	74537469 	ldrbvc	r7, [r3], #-1129	; 0x469
     40c:	74637572 	strbtvc	r7, [r3], #-1394	; 0x572
     410:	00657275 	rsbeq	r7, r5, r5, ror r2
     414:	5f434352 	svcpl	0x00434352
     418:	746f6c42 	strbtvc	r6, [pc], #-3138	; 420 <RCC_HSEConfig+0x8>
     41c:	65735500 	ldrbvs	r5, [r3, #-1280]!	; 0x500
     420:	65535f72 	ldrbvs	r5, [r3, #-3954]	; 0xf72
     424:	6e6f4374 	mcrvs	3, 3, r4, cr15, cr4, {3}
     428:	75676966 	strbvc	r6, [r7, #-2406]!	; 0x966
     42c:	69746172 	ldmdbvs	r4!, {r1, r4, r5, r6, r8, sp, lr}^
     430:	55006e6f 	strpl	r6, [r0, #-3695]	; 0xe6f
     434:	5f726573 	svcpl	0x00726573
     438:	49746553 	ldmdbmi	r4!, {r0, r1, r4, r6, r8, sl, sp, lr}^
     43c:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
     440:	65636166 	strbvs	r6, [r3, #-358]!	; 0x166
     444:	42484100 	submi	r4, r8, #0, 2
     448:	00524e45 	subseq	r4, r2, r5, asr #28
     44c:	50627375 	rsbpl	r7, r2, r5, ror r3
     450:	7265776f 	rsbvc	r7, r5, #29097984	; 0x1bc0000
     454:	52006e4f 	andpl	r6, r0, #1264	; 0x4f0
     458:	4d555345 	ldclmi	3, cr5, [r5, #-276]	; 0xfffffeec
     45c:	4e495f45 	cdpmi	15, 4, cr5, cr9, cr5, {2}
     460:	4e524554 	mrcmi	5, 2, r4, cr2, cr4, {2}
     464:	52004c41 	andpl	r4, r0, #16640	; 0x4100
     468:	5f504578 	svcpl	0x00504578
     46c:	66667562 	strbtvs	r7, [r6], -r2, ror #10
     470:	75007265 	strvc	r7, [r0, #-613]	; 0x265
     474:	6e456273 	mcrvs	2, 2, r6, cr5, cr3, {3}
     478:	52534962 	subspl	r4, r3, #1605632	; 0x188000
     47c:	62737500 	rsbsvs	r7, r3, #0, 10
     480:	75736552 	ldrbvc	r6, [r3, #-1362]!	; 0x552
     484:	6400656d 	strvs	r6, [r0], #-1389	; 0x56d
     488:	70557566 	subsvc	r7, r5, r6, ror #10
     48c:	65746164 	ldrbvs	r6, [r4, #-356]!	; 0x164
     490:	65527942 	ldrbvs	r7, [r2, #-2370]	; 0x942
     494:	73657571 	cmnvc	r5, #473956352	; 0x1c400000
     498:	73750074 	cmnvc	r5, #116	; 0x74
     49c:	61745362 	cmnvs	r4, r2, ror #6
     4a0:	4f737574 	svcmi	0x00737574
     4a4:	75007475 	strvc	r7, [r0, #-1141]	; 0x475
     4a8:	65526273 	ldrbvs	r6, [r2, #-627]	; 0x273
     4ac:	656d7573 	strbvs	r7, [sp, #-1395]!	; 0x573
     4b0:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
     4b4:	62737500 	rsbsvs	r7, r3, #0, 10
     4b8:	65736552 	ldrbvs	r6, [r3, #-1362]!	; 0x552
     4bc:	73750074 	cmnvc	r5, #116	; 0x74
     4c0:	61745362 	cmnvs	r4, r2, ror #6
     4c4:	49737574 	ldmdbmi	r3!, {r2, r4, r5, r6, r8, sl, ip, sp, lr}^
     4c8:	4552006e 	ldrbmi	r0, [r2, #-110]	; 0x6e
     4cc:	454d5553 	strbmi	r5, [sp, #-1363]	; 0x553
     4d0:	46464f5f 			; <UNDEFINED> instruction: 0x46464f5f
     4d4:	6e6f6c00 	cdpvs	12, 6, cr6, cr15, cr0, {0}
     4d8:	6f6c2067 	svcvs	0x006c2067
     4dc:	6920676e 	stmdbvs	r0!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
     4e0:	5000746e 	andpl	r7, r0, lr, ror #8
     4e4:	5245574f 	subpl	r5, r5, #20709376	; 0x13c0000
     4e8:	55004445 	strpl	r4, [r0, #-1093]	; 0x445
     4ec:	4c774253 	lfmmi	f4, 2, [r7], #-332	; 0xfffffeb4
     4f0:	74676e65 	strbtvc	r6, [r7], #-3685	; 0xe65
     4f4:	75007368 	strvc	r7, [r0, #-872]	; 0x368
     4f8:	65536273 	ldrbvs	r6, [r3, #-627]	; 0x273
     4fc:	746e4974 	strbtvc	r4, [lr], #-2420	; 0x974
     500:	61667265 	cmnvs	r6, r5, ror #4
     504:	43006563 	movwmi	r6, #1379	; 0x563
     508:	65727275 	ldrbvs	r7, [r2, #-629]!	; 0x275
     50c:	435f746e 	cmpmi	pc, #1845493760	; 0x6e000000
     510:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
     514:	61727567 	cmnvs	r2, r7, ror #10
     518:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
     51c:	6e497700 	cdpvs	7, 4, cr7, cr9, cr0, {0}
     520:	72726574 	rsbsvc	r6, r2, #116, 10	; 0x1d000000
     524:	5f747075 	svcpl	0x00747075
     528:	6b73614d 	blvs	1cd8a64 <_etext+0x1cd154c>
     52c:	6f6f6200 	svcvs	0x006f6200
     530:	4544006c 	strbmi	r0, [r4, #-108]	; 0x6c
     534:	45434956 	strbmi	r4, [r3, #-2390]	; 0x956
     538:	4345525f 	movtmi	r5, #21087	; 0x525f
     53c:	45495049 	strbmi	r5, [r9, #-73]	; 0x49
     540:	7500544e 	strvc	r5, [r0, #-1102]	; 0x44e
     544:	65476273 	strbvs	r6, [r7, #-627]	; 0x273
     548:	61745374 	cmnvs	r4, r4, ror r3
     54c:	43006574 	movwmi	r6, #1396	; 0x574
     550:	65727275 	ldrbvs	r7, [r2, #-629]!	; 0x275
     554:	495f746e 	ldmdbmi	pc, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^	; <UNPREDICTABLE>
     558:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
     55c:	65636166 	strbvs	r6, [r3, #-358]!	; 0x166
     560:	4e437700 	cdpmi	7, 4, cr7, cr3, cr0, {0}
     564:	75005254 	strvc	r5, [r0, #-596]	; 0x254
     568:	73446273 	movtvc	r6, #17011	; 0x4273
     56c:	73754262 	cmnvc	r5, #536870918	; 0x20000006
     570:	4e4f5000 	cdpmi	0, 4, cr5, cr15, cr0, {0}
     574:	45445f45 	strbmi	r5, [r4, #-3909]	; 0xf45
     578:	49524353 	ldmdbmi	r2, {r0, r1, r4, r6, r8, r9, lr}^
     57c:	524f5450 	subpl	r5, pc, #80, 8	; 0x50000000
     580:	62737500 	rsbsvs	r7, r3, #0, 10
     584:	70737553 	rsbsvc	r7, r3, r3, asr r5
     588:	00646e65 	rsbeq	r6, r4, r5, ror #28
     58c:	61746f54 	cmnvs	r4, r4, asr pc
     590:	6f435f6c 	svcvs	0x00435f6c
     594:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
     598:	74617275 	strbtvc	r7, [r1], #-629	; 0x275
     59c:	006e6f69 	rsbeq	r6, lr, r9, ror #30
     5a0:	72657355 	rsbvc	r7, r5, #1409286145	; 0x54000001
     5a4:	7465475f 	strbtvc	r4, [r5], #-1887	; 0x75f
     5a8:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
     5ac:	72756769 	rsbsvc	r6, r5, #27525120	; 0x1a40000
     5b0:	6f697461 	svcvs	0x00697461
     5b4:	564e006e 	strbpl	r0, [lr], -lr, rrx
     5b8:	495f4349 	ldmdbmi	pc, {r0, r3, r6, r8, r9, lr}^	; <UNPREDICTABLE>
     5bc:	68435152 	stmdavs	r3, {r1, r4, r6, r8, ip, lr}^
     5c0:	656e6e61 	strbvs	r6, [lr, #-3681]!	; 0xe61
     5c4:	4552006c 	ldrbmi	r0, [r2, #-108]	; 0x6c
     5c8:	454d5553 	strbmi	r5, [sp, #-1363]	; 0x553
     5cc:	5458455f 	ldrbpl	r4, [r8], #-1375	; 0x55f
     5d0:	414e5245 	cmpmi	lr, r5, asr #4
     5d4:	7543004c 	strbvc	r0, [r3, #-76]	; 0x4c
     5d8:	6e657272 	mcrvs	2, 3, r7, cr5, cr2, {3}
     5dc:	6c415f74 	mcrrvs	15, 7, r5, r1, cr4
     5e0:	6e726574 	mrcvs	5, 3, r6, cr2, cr4, {3}
     5e4:	53657461 	cmnpl	r5, #1627389952	; 0x61000000
     5e8:	69747465 	ldmdbvs	r4!, {r0, r2, r5, r6, sl, ip, sp, lr}^
     5ec:	4100676e 	tstmi	r0, lr, ror #14
     5f0:	45324250 	ldrmi	r4, [r2, #-592]!	; 0x250
     5f4:	7200524e 	andvc	r5, r0, #-536870908	; 0xe0000004
     5f8:	65757165 	ldrbvs	r7, [r5, #-357]!	; 0x165
     5fc:	5f007473 	svcpl	0x00007473
     600:	50444e45 	subpl	r4, r4, r5, asr #28
     604:	544e494f 	strbpl	r4, [lr], #-2383	; 0x94f
     608:	464e495f 			; <UNDEFINED> instruction: 0x464e495f
     60c:	6f43004f 	svcvs	0x0043004f
     610:	6f527970 	svcvs	0x00527970
     614:	6e697475 	mcrvs	4, 3, r7, cr9, cr5, {3}
     618:	43520065 	cmpmi	r2, #101	; 0x65
     61c:	44425f43 	strbmi	r5, [r2], #-3907	; 0xf43
     620:	5f005243 	svcpl	0x00005243
     624:	49564544 	ldmdbmi	r6, {r2, r6, r8, sl, lr}^
     628:	55004543 	strpl	r4, [r0, #-1347]	; 0x543
     62c:	4e5f4253 	mrcmi	2, 2, r4, cr15, cr3, {2}
     630:	525f544f 	subspl	r5, pc, #1325400064	; 0x4f000000
     634:	59444145 	stmdbpl	r4, {r0, r2, r6, r8, lr}^
     638:	554e4700 	strbpl	r4, [lr, #-1792]	; 0x700
     63c:	34204320 	strtcc	r4, [r0], #-800	; 0x320
     640:	342e382e 	strtcc	r3, [lr], #-2094	; 0x82e
     644:	31303220 	teqcc	r0, r0, lsr #4
     648:	32373034 	eorscc	r3, r7, #52	; 0x34
     64c:	72282035 	eorvc	r2, r8, #53	; 0x35
     650:	61656c65 	cmnvs	r5, r5, ror #24
     654:	20296573 	eorcs	r6, r9, r3, ror r5
     658:	4d52415b 	ldfmie	f4, [r2, #-364]	; 0xfffffe94
     65c:	626d652f 	rsbvs	r6, sp, #197132288	; 0xbc00000
     660:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
     664:	5f342d64 	svcpl	0x00342d64
     668:	72622d38 	rsbvc	r2, r2, #56, 26	; 0xe00
     66c:	68636e61 	stmdavs	r3!, {r0, r5, r6, r9, sl, fp, sp, lr}^
     670:	76657220 	strbtvc	r7, [r5], -r0, lsr #4
     674:	6f697369 	svcvs	0x00697369
     678:	3132206e 	teqcc	r2, lr, rrx
     67c:	37343133 			; <UNDEFINED> instruction: 0x37343133
     680:	6d2d205d 	stcvs	0, cr2, [sp, #-372]!	; 0xfffffe8c
     684:	6d756874 	ldclvs	8, cr6, [r5, #-464]!	; 0xfffffe30
     688:	6d2d2062 	stcvs	0, cr2, [sp, #-392]!	; 0xfffffe78
     68c:	3d757063 	ldclcc	0, cr7, [r5, #-396]!	; 0xfffffe74
     690:	74726f63 	ldrbtvc	r6, [r2], #-3939	; 0xf63
     694:	6d2d7865 	stcvs	8, cr7, [sp, #-404]!	; 0xfffffe6c
     698:	6d2d2033 	stcvs	0, cr2, [sp, #-204]!	; 0xffffff34
     69c:	6d756874 	ldclvs	8, cr6, [r5, #-464]!	; 0xfffffe30
     6a0:	6e692d62 	cdpvs	13, 6, cr2, cr9, cr2, {3}
     6a4:	77726574 			; <UNDEFINED> instruction: 0x77726574
     6a8:	206b726f 	rsbcs	r7, fp, pc, ror #4
     6ac:	2d20672d 	stccs	7, cr6, [r0, #-180]!	; 0xffffff4c
     6b0:	2d20734f 	stccs	3, cr7, [r0, #-316]!	; 0xfffffec4
     6b4:	6e756666 	cdpvs	6, 7, cr6, cr5, cr6, {3}
     6b8:	6f697463 	svcvs	0x00697463
     6bc:	65732d6e 	ldrbvs	r2, [r3, #-3438]!	; 0xd6e
     6c0:	6f697463 	svcvs	0x00697463
     6c4:	2d20736e 	stccs	3, cr7, [r0, #-440]!	; 0xfffffe48
     6c8:	74616466 	strbtvc	r6, [r1], #-1126	; 0x466
     6cc:	65732d61 	ldrbvs	r2, [r3, #-3425]!	; 0xd61
     6d0:	6f697463 	svcvs	0x00697463
     6d4:	6200736e 	andvs	r7, r0, #-1207959551	; 0xb8000001
     6d8:	50746e49 	rsbspl	r6, r4, r9, asr #28
     6dc:	536b6361 	cmnpl	fp, #-2080374783	; 0x84000001
     6e0:	7500464f 	strvc	r4, [r0, #-1615]	; 0x64f
     6e4:	6f506273 	svcvs	0x00506273
     6e8:	4f726577 	svcmi	0x00726577
     6ec:	43006666 	movwmi	r6, #1638	; 0x666
     6f0:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
     6f4:	74536c6f 	ldrbvc	r6, [r3], #-3183	; 0xc6f
     6f8:	00657461 	rsbeq	r7, r5, r1, ror #8
     6fc:	726f6873 	rsbvc	r6, pc, #7536640	; 0x730000
     700:	6e692074 	mcrvs	0, 3, r2, cr9, cr4, {3}
     704:	73750074 	cmnvc	r5, #116	; 0x74
     708:	74654762 	strbtvc	r4, [r5], #-1890	; 0x762
     70c:	65746e49 	ldrbvs	r6, [r4, #-3657]!	; 0xe49
     710:	63616672 	cmnvs	r1, #119537664	; 0x7200000
     714:	65520065 	ldrbvs	r0, [r2, #-101]	; 0x65
     718:	656d7573 	strbvs	r7, [sp, #-1395]!	; 0x573
     71c:	65640053 	strbvs	r0, [r4, #-83]!	; 0x53
     720:	0079616c 	rsbseq	r6, r9, ip, ror #2
     724:	45544e49 	ldrbmi	r4, [r4, #-3657]	; 0xe49
     728:	43414652 	movtmi	r4, #5714	; 0x1652
     72c:	45525f45 	ldrbmi	r5, [r2, #-3909]	; 0xf45
     730:	49504943 	ldmdbmi	r0, {r0, r1, r6, r8, fp, lr}^
     734:	00544e45 	subseq	r4, r4, r5, asr #28
     738:	79706f43 	ldmdbvc	r0!, {r0, r1, r6, r8, r9, sl, fp, sp, lr}^
     73c:	61746144 	cmnvs	r4, r4, asr #2
     740:	65735500 	ldrbvs	r5, [r3, #-1280]!	; 0x500
     744:	6c435f72 	mcrrvs	15, 7, r5, r3, cr2
     748:	46726165 	ldrbtmi	r6, [r2], -r5, ror #2
     74c:	75746165 	ldrbvc	r6, [r4, #-357]!	; 0x165
     750:	46006572 			; <UNDEFINED> instruction: 0x46006572
     754:	45534c41 	ldrbmi	r4, [r3, #-3137]	; 0xc41
     758:	47464300 	strbmi	r4, [r6, -r0, lsl #6]
     75c:	775f0052 			; <UNDEFINED> instruction: 0x775f0052
     760:	56676552 			; <UNDEFINED> instruction: 0x56676552
     764:	55006c61 	strpl	r6, [r0, #-3169]	; 0xc61
     768:	6d624253 	sfmvs	f4, 2, [r2, #-332]!	; 0xfffffeb4
     76c:	75716552 	ldrbvc	r6, [r1, #-1362]!	; 0x552
     770:	54747365 	ldrbtpl	r7, [r4], #-869	; 0x365
     774:	00657079 	rsbeq	r7, r5, r9, ror r0
     778:	636f7250 	cmnvs	pc, #80, 4
     77c:	5f737365 	svcpl	0x00737365
     780:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
     784:	4f5f7375 	svcmi	0x005f7375
     788:	73005455 	movwvc	r5, #1109	; 0x455
     78c:	74657a69 	strbtvc	r7, [r5], #-2665	; 0xa69
     790:	00657079 	rsbeq	r7, r5, r9, ror r0
     794:	61656c43 	cmnvs	r5, r3, asr #24
     798:	74535f72 	ldrbvc	r5, [r3], #-3954	; 0xf72
     79c:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
     7a0:	74754f5f 	ldrbtvc	r4, [r5], #-3935	; 0xf5f
     7a4:	5f387500 	svcpl	0x00387500
     7a8:	46627375 			; <UNDEFINED> instruction: 0x46627375
     7ac:	74636e75 	strbtvc	r6, [r3], #-3701	; 0xe75
     7b0:	616e6f69 	cmnvs	lr, r9, ror #30
     7b4:	7365446c 	cmnvc	r5, #108, 8	; 0x6c000000
     7b8:	70697263 	rsbvc	r7, r9, r3, ror #4
     7bc:	00726f74 	rsbseq	r6, r2, r4, ror pc
     7c0:	5345525f 	movtpl	r5, #21087	; 0x525f
     7c4:	00544c55 	subseq	r4, r4, r5, asr ip
     7c8:	6c727443 	cfldrdvs	mvd7, [r2], #-268	; 0xfffffef4
     7cc:	666e495f 			; <UNDEFINED> instruction: 0x666e495f
     7d0:	6573006f 	ldrbvs	r0, [r3, #-111]!	; 0x6f
     7d4:	55707574 	ldrbpl	r7, [r0, #-1396]!	; 0x574
     7d8:	67004253 	smlsdvs	r0, r3, r2, r4
     7dc:	5f6f6970 	svcpl	0x006f6970
     7e0:	74697277 	strbtvc	r7, [r9], #-631	; 0x277
     7e4:	69625f65 	stmdbvs	r2!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
     7e8:	73750074 	cmnvc	r5, #116	; 0x74
     7ec:	74614462 	strbtvc	r4, [r1], #-1122	; 0x462
     7f0:	74655361 	strbtvc	r5, [r5], #-865	; 0x361
     7f4:	43007075 	movwmi	r7, #117	; 0x75
     7f8:	49464e4f 	stmdbmi	r6, {r0, r1, r2, r3, r6, r9, sl, fp, lr}^
     7fc:	45525547 	ldrbmi	r5, [r2, #-1351]	; 0x547
     800:	49770044 	ldmdbmi	r7!, {r2, r6}^
     804:	00727473 	rsbseq	r7, r2, r3, ror r4
     808:	72727543 	rsbsvc	r7, r2, #281018368	; 0x10c00000
     80c:	5f746e65 	svcpl	0x00746e65
     810:	74616546 	strbtvc	r6, [r1], #-1350	; 0x546
     814:	00657275 	rsbeq	r7, r5, r5, ror r2
     818:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
     81c:	64656e67 	strbtvs	r6, [r5], #-3687	; 0xe67
     820:	61686320 	cmnvs	r8, r0, lsr #6
     824:	52650072 	rsbpl	r0, r5, #114	; 0x72
     828:	6d757365 	ldclvs	3, cr7, [r5, #-404]!	; 0xfffffe6c
     82c:	74655365 	strbtvc	r5, [r5], #-869	; 0x365
     830:	006c6156 	rsbeq	r6, ip, r6, asr r1
     834:	5f525443 	svcpl	0x00525443
     838:	6400504c 	strvs	r5, [r0], #-76	; 0x4c
     83c:	70557566 	subsvc	r7, r5, r6, ror #10
     840:	65746164 	ldrbvs	r6, [r4, #-356]!	; 0x164
     844:	65527942 	ldrbvs	r7, [r2, #-2370]	; 0x942
     848:	00746573 	rsbseq	r6, r4, r3, ror r5
     84c:	47627375 			; <UNDEFINED> instruction: 0x47627375
     850:	74537465 	ldrbvc	r7, [r3], #-1125	; 0x465
     854:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
     858:	62737500 	rsbsvs	r7, r3, #0, 10
     85c:	44746553 	ldrbtmi	r6, [r4], #-1363	; 0x553
     860:	63697665 	cmnvs	r9, #105906176	; 0x6500000
     864:	61654665 	cmnvs	r5, r5, ror #12
     868:	65727574 	ldrbvs	r7, [r2, #-1396]!	; 0x574
     86c:	62735500 	rsbsvs	r5, r3, #0, 10
     870:	664f775f 			; <UNDEFINED> instruction: 0x664f775f
     874:	74657366 	strbtvc	r7, [r5], #-870	; 0x366
     878:	45445f00 	strbmi	r5, [r4, #-3840]	; 0xf00
     87c:	45434956 	strbmi	r4, [r3, #-2390]	; 0x956
     880:	4154535f 	cmpmi	r4, pc, asr r3
     884:	55004554 	strpl	r4, [r0, #-1364]	; 0x554
     888:	4e4f434e 	cdpmi	3, 4, cr4, cr15, cr14, {2}
     88c:	5443454e 	strbpl	r4, [r3], #-1358	; 0x54e
     890:	43004445 	movwmi	r4, #1093	; 0x445
     894:	73555c3a 	cmpvc	r5, #14848	; 0x3a00
     898:	5c737265 	lfmpl	f7, 2, [r3], #-404	; 0xfffffe6c
     89c:	66696168 	strbtvs	r6, [r9], -r8, ror #2
     8a0:	68637369 	stmdavs	r3!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}^
     8a4:	7365445c 	cmnvc	r5, #92, 8	; 0x5c000000
     8a8:	706f746b 	rsbvc	r7, pc, fp, ror #8
     8ac:	636e655c 	cmnvs	lr, #92, 10	; 0x17000000
     8b0:	6576616c 	ldrbvs	r6, [r6, #-364]!	; 0x16c
     8b4:	6f72705f 	svcvs	0x0072705f
     8b8:	7463656a 	strbtvc	r6, [r3], #-1386	; 0x56a
     8bc:	6f6f625c 	svcvs	0x006f625c
     8c0:	616f6c74 	smcvs	63172	; 0xf6c4
     8c4:	5c726564 	cfldr64pl	mvdx6, [r2], #-400	; 0xfffffe70
     8c8:	334d5453 	movtcc	r5, #54355	; 0xd453
     8cc:	00314632 	eorseq	r4, r1, r2, lsr r6
     8d0:	55534552 	ldrbpl	r4, [r3, #-1362]	; 0x552
     8d4:	535f454d 	cmppl	pc, #322961408	; 0x13400000
     8d8:	54524154 	ldrbpl	r4, [r2], #-340	; 0x154
     8dc:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
     8e0:	52495f43 	subpl	r5, r9, #268	; 0x10c
     8e4:	61684351 	cmnvs	r8, r1, asr r3
     8e8:	6c656e6e 	stclvs	14, cr6, [r5], #-440	; 0xfffffe48
     8ec:	50627553 	rsbpl	r7, r2, r3, asr r5
     8f0:	726f6972 	rsbvc	r6, pc, #1867776	; 0x1c8000
     8f4:	00797469 	rsbseq	r7, r9, r9, ror #8
     8f8:	72657355 	rsbvc	r7, r5, #1409286145	; 0x54000001
     8fc:	7465535f 	strbtvc	r5, [r5], #-863	; 0x35f
     900:	50646e45 	rsbpl	r6, r4, r5, asr #28
     904:	746e696f 	strbtvc	r6, [lr], #-2415	; 0x96f
     908:	74616546 	strbtvc	r6, [r1], #-1350	; 0x546
     90c:	00657275 	rsbeq	r7, r5, r5, ror r2
     910:	43627375 	cmnmi	r2, #-738197503	; 0xd4000001
     914:	7261656c 	rsbvc	r6, r1, #108, 10	; 0x1b000000
     918:	74616546 	strbtvc	r6, [r1], #-1350	; 0x546
     91c:	00657275 	rsbeq	r7, r5, r5, ror r2
     920:	4548544f 	strbmi	r5, [r8, #-1103]	; 0x44f
     924:	45525f52 	ldrbmi	r5, [r2, #-3922]	; 0xf52
     928:	49504943 	ldmdbmi	r0, {r0, r1, r6, r8, fp, lr}^
     92c:	00544e45 	subseq	r4, r4, r5, asr #28
     930:	5f363175 	svcpl	0x00363175
     934:	50003875 	andpl	r3, r0, r5, ror r8
     938:	65636f72 	strbvs	r6, [r3, #-3954]!	; 0xf72
     93c:	535f7373 	cmppl	pc, #-872415231	; 0xcc000001
     940:	75746174 	ldrbvc	r6, [r4, #-372]!	; 0x174
     944:	4e495f73 	mcrmi	15, 2, r5, cr9, cr3, {3}
     948:	6f687300 	svcvs	0x00687300
     94c:	75207472 	strvc	r7, [r0, #-1138]!	; 0x472
     950:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
     954:	2064656e 	rsbcs	r6, r4, lr, ror #10
     958:	00746e69 	rsbseq	r6, r4, r9, ror #28
     95c:	41545441 	cmpmi	r4, r1, asr #8
     960:	44454843 	strbmi	r4, [r5], #-2115	; 0x843
     964:	70457000 	subvc	r7, r5, r0
     968:	5f746e49 	svcpl	0x00746e49
     96c:	0054554f 	subseq	r5, r4, pc, asr #10
     970:	4349564e 	movtmi	r5, #38478	; 0x964e
     974:	5152495f 	cmppl	r2, pc, asr r9
     978:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
     97c:	506c656e 	rsbpl	r6, ip, lr, ror #10
     980:	6d656572 	cfstr64vs	mvdx6, [r5, #-456]!	; 0xfffffe38
     984:	6f697470 	svcvs	0x00697470
     988:	6972506e 	ldmdbvs	r2!, {r1, r2, r3, r5, r6, ip, lr}^
     98c:	7469726f 	strbtvc	r7, [r9], #-623	; 0x26f
     990:	55530079 	ldrbpl	r0, [r3, #-121]	; 0x79
     994:	4e455053 	mcrmi	0, 2, r5, cr5, cr3, {2}
     998:	00444544 	subeq	r4, r4, r4, asr #10
     99c:	45746553 	ldrbmi	r6, [r4, #-1363]!	; 0x553
     9a0:	43785250 	cmnmi	r8, #80, 4
     9a4:	746e756f 	strbtvc	r7, [lr], #-1391	; 0x56f
     9a8:	42535500 	subsmi	r5, r3, #0, 10
     9ac:	5252455f 	subspl	r4, r2, #398458880	; 0x17c00000
     9b0:	7000524f 	andvc	r5, r0, pc, asr #4
     9b4:	6e497045 	cdpvs	0, 4, cr7, cr9, cr5, {2}
     9b8:	4e495f74 	mcrmi	15, 2, r5, cr9, cr4, {3}
     9bc:	75666400 	strbvc	r6, [r6, #-1024]!	; 0x400
     9c0:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
     9c4:	616c4300 	cmnvs	ip, r0, lsl #6
     9c8:	475f7373 			; <UNDEFINED> instruction: 0x475f7373
     9cc:	495f7465 	ldmdbmi	pc, {r0, r2, r5, r6, sl, ip, sp, lr}^	; <UNPREDICTABLE>
     9d0:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
     9d4:	65636166 	strbvs	r6, [r3, #-358]!	; 0x166
     9d8:	7465535f 	strbtvc	r5, [r5], #-863	; 0x35f
     9dc:	676e6974 			; <UNDEFINED> instruction: 0x676e6974
     9e0:	69766e00 	ldmdbvs	r6!, {r9, sl, fp, sp, lr}^
     9e4:	696e4963 	stmdbvs	lr!, {r0, r1, r5, r6, r8, fp, lr}^
     9e8:	38750074 	ldmdacc	r5!, {r2, r4, r5, r6}^
     9ec:	6273755f 	rsbsvs	r7, r3, #398458880	; 0x17c00000
     9f0:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
     9f4:	6556676e 	ldrbvs	r6, [r6, #-1902]	; 0x76e
     9f8:	726f646e 	rsbvc	r6, pc, #1845493760	; 0x6e000000
     9fc:	5f387500 	svcpl	0x00387500
     a00:	53627375 	cmnpl	r2, #-738197503	; 0xd4000001
     a04:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
     a08:	746e4967 	strbtvc	r4, [lr], #-2407	; 0x967
     a0c:	61667265 	cmnvs	r6, r5, ror #4
     a10:	75006563 	strvc	r6, [r0, #-1379]	; 0x563
     a14:	73755f38 	cmnvc	r5, #56, 30	; 0xe0
     a18:	72745362 	rsbsvc	r5, r4, #-2013265919	; 0x88000001
     a1c:	41676e69 	cmnmi	r7, r9, ror #28
     a20:	0031746c 	eorseq	r7, r1, ip, ror #8
     a24:	755f3875 	ldrbvc	r3, [pc, #-2165]	; 1b7 <_Minimum_Stack_Size+0xb7>
     a28:	65446273 	strbvs	r6, [r4, #-627]	; 0x273
     a2c:	65636976 	strbvs	r6, [r3, #-2422]!	; 0x976
     a30:	63736544 	cmnvs	r3, #68, 10	; 0x11000000
     a34:	74706972 	ldrbtvc	r6, [r0], #-2418	; 0x972
     a38:	4644726f 	strbmi	r7, [r4], -pc, ror #4
     a3c:	38750055 	ldmdacc	r5!, {r0, r2, r4, r6}^
     a40:	6273755f 	rsbsvs	r7, r3, #398458880	; 0x17c00000
     a44:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
     a48:	6c41676e 	mcrrvs	7, 6, r6, r1, cr14
     a4c:	75003274 	strvc	r3, [r0, #-628]	; 0x274
     a50:	73755f38 	cmnvc	r5, #56, 30	; 0xe0
     a54:	72745362 	rsbsvc	r5, r4, #-2013265919	; 0x88000001
     a58:	53676e69 	cmnpl	r7, #1680	; 0x690
     a5c:	61697265 	cmnvs	r9, r5, ror #4
     a60:	3875006c 	ldmdacc	r5!, {r2, r3, r5, r6}^
     a64:	6273755f 	rsbsvs	r7, r3, #398458880	; 0x17c00000
     a68:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
     a6c:	6c41676e 	mcrrvs	7, 6, r6, r1, cr14
     a70:	75003074 	strvc	r3, [r0, #-116]	; 0x74
     a74:	73755f38 	cmnvc	r5, #56, 30	; 0xe0
     a78:	72745362 	rsbsvc	r5, r4, #-2013265919	; 0x88000001
     a7c:	50676e69 	rsbpl	r6, r7, r9, ror #28
     a80:	75646f72 	strbvc	r6, [r4, #-3954]!	; 0xf72
     a84:	75007463 	strvc	r7, [r0, #-1123]	; 0x463
     a88:	73755f38 	cmnvc	r5, #56, 30	; 0xe0
     a8c:	72745362 	rsbsvc	r5, r4, #-2013265919	; 0x88000001
     a90:	4c676e69 	stclmi	14, cr6, [r7], #-420	; 0xfffffe5c
     a94:	49676e61 	stmdbmi	r7!, {r0, r5, r6, r9, sl, fp, sp, lr}^
     a98:	73750064 	cmnvc	r5, #100	; 0x64
     a9c:	65645f62 	strbvs	r5, [r4, #-3938]!	; 0xf62
     aa0:	69726373 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, r8, r9, sp, lr}^
     aa4:	726f7470 	rsbvc	r7, pc, #112, 8	; 0x70000000
     aa8:	5f00632e 	svcpl	0x0000632e
     aac:	67616d49 	strbvs	r6, [r1, -r9, asr #26]!
     ab0:	6a624f65 	bvs	189484c <_etext+0x188d334>
     ab4:	48746365 	ldmdami	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
     ab8:	65646165 	strbvs	r6, [r4, #-357]!	; 0x165
     abc:	65730072 	ldrbvs	r0, [r3, #-114]!	; 0x72
     ac0:	43707574 	cmnmi	r0, #116, 10	; 0x1d000000
     ac4:	73004b4c 	movwvc	r4, #2892	; 0xb4c
     ac8:	5f657a69 	svcpl	0x00657a69
     acc:	5f5f0074 	svcpl	0x005f0074
     ad0:	746e6975 	strbtvc	r6, [lr], #-2421	; 0x975
     ad4:	745f3233 	ldrbvc	r3, [pc], #-563	; adc <USART_GetFlagStatus>
     ad8:	73797300 	cmnvc	r9, #0, 6
     adc:	526d6574 	rsbpl	r6, sp, #116, 10	; 0x1d000000
     ae0:	74657365 	strbtvc	r7, [r5], #-869	; 0x365
     ae4:	74657300 	strbtvc	r7, [r5], #-768	; 0x300
     ae8:	4c467075 	mcrrmi	0, 7, r7, r6, cr5
     aec:	00485341 	subeq	r5, r8, r1, asr #6
     af0:	75426869 	strbvc	r6, [r2, #-2153]	; 0x869
     af4:	72656666 	rsbvc	r6, r5, #106954752	; 0x6600000
     af8:	61657200 	cmnvs	r5, r0, lsl #4
     afc:	6e695064 	cdpvs	0, 6, cr5, cr9, cr4, {3}
     b00:	755f5f00 	ldrbvc	r5, [pc, #-3840]	; fffffc08 <BootRAM+0xef703a9>
     b04:	38746e69 	ldmdacc	r4!, {r0, r3, r5, r6, r9, sl, fp, sp, lr}^
     b08:	6900745f 	stmdbvs	r0, {r0, r1, r2, r3, r4, r6, sl, ip, sp, lr}
     b0c:	67614d68 	strbvs	r4, [r1, -r8, ror #26]!
     b10:	5f006369 	svcpl	0x00006369
     b14:	67616d49 	strbvs	r6, [r1, -r9, asr #26]!
     b18:	746e4965 	strbtvc	r4, [lr], #-2405	; 0x965
     b1c:	616e7265 	cmnvs	lr, r5, ror #4
     b20:	6174536c 	cmnvs	r4, ip, ror #6
     b24:	63006574 	movwvs	r6, #1396	; 0x574
     b28:	6f737275 	svcvs	0x00737275
     b2c:	6d690072 	stclvs	0, cr0, [r9, #-456]!	; 0xfffffe38
     b30:	43656761 	cmnmi	r5, #25427968	; 0x1840000
     b34:	6b636568 	blvs	18da0dc <_etext+0x18d2bc4>
     b38:	6d6f7246 	sfmvs	f7, 2, [pc, #-280]!	; a28 <USART_SmartCardCmd+0xc>
     b3c:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
     b40:	00737365 	rsbseq	r7, r3, r5, ror #6
     b44:	6f727473 	svcvs	0x00727473
     b48:	69506562 	ldmdbvs	r0, {r1, r5, r6, r8, sl, sp, lr}^
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	6f6e006e 	svcvs	0x006e006e
  b	LoopCopyDataInit
     b50:	6573755f 	ldrbvs	r7, [r3, #-1375]!	; 0x55f

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
     b54:	756a5f72 	strbvc	r5, [sl, #-3954]!	; 0xf72
	str	r3, [r0, r1]
	adds	r1, r1, #4
     b58:	6600706d 	strvs	r7, [r0], -sp, rrx

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
     b5c:	7367616c 	cmnvc	r7, #108, 2
	adds	r2, r0, r1
	cmp	r2, r3
     b60:	74657300 	strbtvc	r7, [r5], #-768	; 0x300
	bcc	CopyDataInit
     b64:	454c7075 	strbmi	r7, [ip, #-117]	; 0x75
	ldr	r2, =_sbss
	b	LoopFillZerobss
     b68:	646e4144 	strbtvs	r4, [lr], #-324	; 0x144
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	74747542 	ldrbtvc	r7, [r4], #-1346	; 0x542
	str	r3, [r2], #4
     b70:	69006e6f 	stmdbvs	r0, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
     b74:	66754268 	ldrbtvs	r4, [r5], -r8, ror #4
	bcc	FillZerobss
     b78:	4c726566 	cfldr64mi	mvdx6, [r2], #-408	; 0xfffffe68
/* Call the application's entry point.*/
	bl	main
     b7c:	74676e65 	strbtvc	r6, [r7], #-3685	; 0xe65
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	61750068 	cmnvs	r5, r8, rrx
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	6e497472 	mcrvs	4, 2, r7, cr9, cr2, {3}
	ldr	r3, =_edata
     b88:	61007469 	tstvs	r0, r9, ror #8
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	636f6c6c 	cmnvs	pc, #108, 24	; 0x6c00
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	54686900 	strbtpl	r6, [r8], #-2304	; 0x900
}


/* dummy proc */
void nothingProc(void)
{
     b98:	00657079 	rsbeq	r7, r5, r9, ror r0
{
    return;
}

void usbStatusOut(void)
{
     b9c:	6e69616d 	powvsez	f6, f1, #5.0
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
     ba0:	6e6f6400 	cdpvs	4, 6, cr6, cr15, cr0, {0}
     ba4:	61775f74 	cmnvs	r7, r4, ror pc
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	64007469 	strvs	r7, [r0], #-1129	; 0x469
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	79616c65 	stmdbvc	r1!, {r0, r2, r5, r6, sl, fp, sp, lr}^
     bb0:	756f635f 	strbvc	r6, [pc, #-863]!	; 859 <__Stack_Size+0x59>
        bDeviceState = CONFIGURED;
     bb4:	6a00746e 	bvs	1dd74 <_etext+0x1685c>
     bb8:	54706d75 	ldrbtpl	r6, [r0], #-3445	; 0xd75
     bbc:	6573556f 	ldrbvs	r5, [r3, #-1391]!	; 0x56f
     bc0:	68690072 	stmdavs	r9!, {r1, r4, r5, r6}^
    }
}

void usbGetInterface(void)
{
     bc4:	70696b53 	rsbvc	r6, r9, r3, asr fp
{
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	74736944 	ldrbtvc	r6, [r3], #-2372	; 0x944
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	65636e61 	strbvs	r6, [r3, #-3681]!	; 0xe61
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	69616d00 	stmdbvs	r1!, {r8, sl, fp, sp, lr}^
     bd4:	00632e6e 	rsbeq	r2, r3, lr, ror #28
     bd8:	67616d69 	strbvs	r6, [r1, -r9, ror #26]!
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	66640065 	strbtvs	r0, [r4], -r5, rrx
    dfuUpdateByReset();
     be0:	6c705575 	cfldr64vs	mvdx5, [r0], #-468	; 0xfffffe2c

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	5364616f 	cmnpl	r4, #-1073741797	; 0xc000001b

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be8:	74726174 	ldrbtvc	r6, [r2], #-372	; 0x174
     bec:	69006465 	stmdbvs	r0, {r0, r2, r5, r6, sl, sp, lr}
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	6567616d 	strbvs	r6, [r7, #-365]!	; 0x16d
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	646e6148 	strbtvs	r6, [lr], #-328	; 0x148
     bf8:	7500656c 	strvc	r6, [r0, #-1388]	; 0x56c

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfc:	5f747261 	svcpl	0x00747261
     c00:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     c04:	69006674 	stmdbvs	r0, {r2, r4, r5, r6, r9, sl, sp, lr}
     c08:	67695368 	strbvs	r5, [r9, -r8, ror #6]!
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c0c:	4c64656e 	cfstr64mi	mvdx6, [r4], #-440	; 0xfffffe48
     c10:	74676e65 	strbtvc	r6, [r7], #-3685	; 0xe65
     c14:	616c0068 	cmnvs	ip, r8, rrx
     c18:	61547473 	cmpvs	r4, r3, ror r4
     c1c:	66640067 	strbtvs	r0, [r4], -r7, rrx

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c20:	6e694675 	mcrvs	6, 3, r4, cr9, cr5, {3}
     c24:	55687369 	strbpl	r7, [r8, #-873]!	; 0x369
     c28:	616f6c70 	smcvs	63168	; 0xf6c0
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	72700064 	rsbsvc	r0, r0, #100	; 0x64
     c30:	5f746e69 	svcpl	0x00746e69
     c34:	68736168 	ldmdavs	r3!, {r3, r5, r6, r8, sp, lr}^
     c38:	616d4900 	cmnvs	sp, r0, lsl #18
     c3c:	624f6567 	subvs	r6, pc, #432013312	; 0x19c00000

    Clear_Status_Out(ENDP0);
     c40:	7463656a 	strbtvc	r6, [r3], #-1386	; 0x56a

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c44:	646e6148 	strbtvs	r6, [lr], #-328	; 0x148
     c48:	6600656c 	strvs	r6, [r0], -ip, ror #10
     c4c:	6873616c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, sp, lr}^
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	73617245 	cmnvc	r1, #1342177284	; 0x50000004
     c54:	67615065 	strbvs	r5, [r1, -r5, rrx]!

    bDeviceState = ATTACHED;
     c58:	53420065 	movtpl	r0, #8293	; 0x2065
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
     c5c:	47005252 	smlsdmi	r0, r2, r2, r5

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	5f4f4950 	svcpl	0x004f4950
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c64:	65646f4d 	strbvs	r6, [r4, #-3917]!	; 0xf4d
     c68:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
     c6c:	69505f4f 	ldmdbvs	r0, {r0, r1, r2, r3, r6, r8, r9, sl, fp, ip, lr}^
     c70:	7973006e 	ldmdbvc	r3!, {r1, r2, r3, r5, r6}^
     c74:	6d657473 	cfstrdvs	mvd7, [r5, #-460]!	; 0xfffffe34
     c78:	64726148 	ldrbtvs	r6, [r2], #-328	; 0x148
     c7c:	65736552 	ldrbvs	r6, [r3, #-1362]!	; 0x552
     c80:	6b620074 	blvs	1880e58 <_etext+0x1879940>
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	57303170 			; <UNDEFINED> instruction: 0x57303170
     c88:	65746972 	ldrbvs	r6, [r4, #-2418]!	; 0x972
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8c:	564e7200 	strbpl	r7, [lr], -r0, lsl #4
     c90:	46004349 	strmi	r4, [r0], -r9, asr #6
     c94:	74636e75 	strbtvc	r6, [r3], #-3701	; 0xe75
        if (dfuUpdateByRequest()) {
     c98:	616e6f69 	cmnvs	lr, r9, ror #30
     c9c:	6174536c 	cmnvs	r4, ip, ror #6
            // successfull state transition, handle the request
            switch (request) {
     ca0:	63006574 	movwvs	r6, #1396	; 0x574
     ca4:	6b636568 	blvs	18da24c <_etext+0x18d2d34>
     ca8:	43646e41 	cmnmi	r4, #1040	; 0x410
     cac:	7261656c 	rsbvc	r6, r1, #108, 10	; 0x1b000000
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	746f6f42 	strbtvc	r6, [pc], #-3906	; cb8 <usbDataSetup+0x34>
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
     cb4:	64616f6c 	strbtvs	r6, [r1], #-3948	; 0xf6c
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
     cb8:	6c467265 	sfmvs	f7, 2, [r6], {101}	; 0x65
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	44006761 	strmi	r6, [r0], #-1889	; 0x761
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
     cc0:	00525346 	subseq	r5, r2, r6, asr #6
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	6369766e 	cmnvs	r9, #115343360	; 0x6e00000
        (*CopyRoutine)(0);

        return USB_SUCCESS;
     cc8:	61736944 	cmnvs	r3, r4, asr #18
    }

    return USB_UNSUPPORT;
     ccc:	49656c62 	stmdbmi	r5!, {r1, r5, r6, sl, fp, sp, lr}^
}
     cd0:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
     cd4:	74707572 	ldrbtvc	r7, [r0], #-1394	; 0x572
     cd8:	53550073 	cmppl	r5, #115	; 0x73
     cdc:	5f545241 	svcpl	0x00545241
     ce0:	64726f57 	ldrbtvs	r6, [r2], #-3927	; 0xf57
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	676e654c 	strbvs	r6, [lr, -ip, asr #10]!
     ce8:	68006874 	stmdavs	r0, {r2, r4, r5, r6, fp, sp, lr}
     cec:	77647261 	strbvc	r7, [r4, -r1, ror #4]!
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	2e657261 	cdpcs	2, 6, cr7, cr5, cr1, {3}
     cf4:	53550063 	cmppl	r5, #99	; 0x63
     cf8:	5f545241 	svcpl	0x00545241
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	706f7453 	rsbvc	r7, pc, r3, asr r4	; <UNPREDICTABLE>
     d00:	73746942 	cmnvc	r4, #1081344	; 0x108000
    if (strIndex > STR_DESC_LEN) {
     d04:	72777000 	rsbsvc	r7, r7, #0
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d08:	6765725f 			; <UNDEFINED> instruction: 0x6765725f
     d0c:	70616d5f 	rsbvc	r6, r1, pc, asr sp
    }
}
     d10:	70737600 	rsbsvc	r7, r3, r0, lsl #12
     d14:	746e6972 	strbtvc	r6, [lr], #-2418	; 0x972
     d18:	50470066 	subpl	r0, r7, r6, rrx

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
     d1c:	495f4f49 	ldmdbmi	pc, {r0, r3, r6, r8, r9, sl, fp, lr}^	; <UNPREDICTABLE>
     d20:	0074696e 	rsbseq	r6, r4, lr, ror #18
     d24:	6d706d74 	ldclvs	13, cr6, [r0, #-464]!	; 0xfffffe30

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	006b7361 	rsbeq	r7, fp, r1, ror #6
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2c:	64786568 	ldrbtvs	r6, [r8], #-1384	; 0x568
     d30:	00706d75 	rsbseq	r6, r0, r5, ror sp
     d34:	4f495047 	svcmi	0x00495047
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	6570535f 	ldrbvs	r5, [r0, #-863]!	; 0x35f
     d3c:	325f6465 	subscc	r6, pc, #1694498816	; 0x65000000
            return USB_SUCCESS;
     d40:	007a484d 	rsbseq	r4, sl, sp, asr #16
     d44:	52505447 	subspl	r5, r0, #1191182336	; 0x47000000
        }
    }
    return USB_UNSUPPORT;
}
     d48:	536e6f00 	cmnpl	lr, #0, 30
     d4c:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0x174

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	41535500 	cmpmi	r3, r0, lsl #10
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d54:	425f5452 	subsmi	r5, pc, #1375731712	; 0x52000000
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	52647561 	rsbpl	r7, r4, #406847488	; 0x18400000
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5c:	00657461 	rsbeq	r7, r5, r1, ror #8
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d60:	63656863 	cmnvs	r5, #6488064	; 0x630000
     d64:	6573556b 	ldrbvs	r5, [r3, #-1387]!	; 0x56b
     d68:	646f4372 	strbtvs	r4, [pc], #-882	; d70 <setupUSB+0x20>
     d6c:	53490065 	movtpl	r0, #36965	; 0x9065
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d70:	52005245 	andpl	r5, r0, #1342177284	; 0x50000004
     d74:	56524553 			; <UNDEFINED> instruction: 0x56524553
     d78:	00314445 	eorseq	r4, r1, r5, asr #8
     d7c:	4f495047 	svcmi	0x00495047
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d80:	6570535f 	ldrbvs	r5, [r0, #-863]!	; 0x35f
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	315f6465 	cmpcc	pc, r5, ror #8
     d88:	7a484d30 	bvc	1214250 <_etext+0x120cd38>
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8c:	706b6200 	rsbvc	r6, fp, r0, lsl #4
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d90:	6765725f 			; <UNDEFINED> instruction: 0x6765725f
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d94:	70616d5f 	rsbvc	r6, r1, pc, asr sp
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d98:	64697500 	strbtvs	r7, [r9], #-1280	; 0x500

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	6165725f 	cmnvs	r5, pc, asr r2
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	53550064 	cmppl	r5, #100	; 0x64
     da4:	5f545241 	svcpl	0x00545241
     da8:	69726150 	ldmdbvs	r2!, {r4, r6, r8, sp, lr}^
     dac:	5f007974 	svcpl	0x00007974
     db0:	6e69755f 	mcrvs	5, 3, r7, cr9, cr15, {2}
     db4:	5f363174 	svcpl	0x00363174
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	53550074 	cmppl	r5, #116	; 0x74
     dbc:	5f545241 	svcpl	0x00545241
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dc0:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
     dc8:	6f4d5f4f 	svcvs	0x004d5f4f
     dcc:	495f6564 	ldmdbmi	pc, {r2, r5, r6, r8, sl, sp, lr}^	; <UNPREDICTABLE>
     dd0:	76004450 			; <UNDEFINED> instruction: 0x76004450
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	65756c61 	ldrbvs	r6, [r5, #-3169]!	; 0xc61
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd8:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
     ddc:	6f4d5f4f 	svcvs	0x004d5f4f

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	495f6564 	ldmdbmi	pc, {r2, r5, r6, r8, sl, sp, lr}^	; <UNPREDICTABLE>
     de4:	5f005550 	svcpl	0x00005550
     de8:	756e675f 	strbvc	r6, [lr, #-1887]!	; 0x75f
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	61765f63 	cmnvs	r6, r3, ror #30
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	73696c5f 	cmnvc	r9, #24320	; 0x5f00
        ResumeS.eState = eResumeSetVal;
     df4:	50430074 	subpl	r0, r3, r4, ror r0

    switch (ResumeS.eState) {
     df8:	00444955 	subeq	r4, r4, r5, asr r9
     dfc:	72706d74 	rsbsvc	r6, r0, #116, 26	; 0x1d00
     e00:	53006765 	movwpl	r6, #1893	; 0x765
     e04:	00525048 	subseq	r5, r2, r8, asr #32
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	52534641 	subspl	r4, r3, #68157440	; 0x4100000
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	41535500 	cmpmi	r3, r0, lsl #10
        ResumeS.eState = RESUME_START;
     e10:	545f5452 	ldrbpl	r5, [pc], #-1106	; e18 <usbResume+0x2c>
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	44657079 	strbtmi	r7, [r5], #-121	; 0x79
        ResumeS.eState = RESUME_WAIT;
     e18:	41006665 	tstmi	r0, r5, ror #12
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	52314250 	eorspl	r4, r1, #80, 4
     e20:	00525453 	subseq	r5, r2, r3, asr r4
        if (ResumeS.bESOFcnt == 0)
     e24:	52534648 	subspl	r4, r3, #72, 12	; 0x4800000
            ResumeS.eState = RESUME_START;
     e28:	616c6600 	cmnvs	ip, r0, lsl #12
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	72576873 	subsvc	r6, r7, #7536640	; 0x730000
     e30:	57657469 	strbpl	r7, [r5, -r9, ror #8]!
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e34:	0064726f 	rsbeq	r7, r4, pc, ror #4
        ResumeS.eState = RESUME_ON;
     e38:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
        ResumeS.bESOFcnt = 10;
     e3c:	6e495f54 	mcrvs	15, 2, r5, cr9, cr4, {2}
        break;
     e40:	74537469 	ldrbvc	r7, [r3], #-1129	; 0x469
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e44:	74637572 	strbtvc	r7, [r3], #-1394	; 0x572
     e48:	00657275 	rsbeq	r7, r5, r5, ror r2
        if (ResumeS.bESOFcnt == 0) {
     e4c:	4f495047 	svcmi	0x00495047
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	646f4d5f 	strbtvs	r4, [pc], #-3423	; e58 <usbResume+0x6c>
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	754f5f65 	strbvc	r5, [pc, #-3941]	; fffffef7 <BootRAM+0xef70698>
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e58:	50505f74 	subspl	r5, r0, r4, ror pc
            ResumeS.eState = RESUME_OFF;
     e5c:	74617200 	strbtvc	r7, [r1], #-512	; 0x200
     e60:	49440065 	stmdbmi	r4, {r0, r2, r5, r6}^
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e64:	4c424153 	stfmie	f4, [r2], {83}	; 0x53
     e68:	49410045 	stmdbmi	r1, {r0, r2, r6}^
     e6c:	00524352 	subseq	r4, r2, r2, asr r3
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	636e7566 	cmnvs	lr, #427819008	; 0x19800000
     e74:	00727450 	rsbseq	r7, r2, r0, asr r4
     e78:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
     e7c:	6600676e 	strvs	r6, [r0], -lr, ror #14

    _SetCNTR(CNTR_FRES);
     e80:	6873616c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, sp, lr}^
     e84:	6f6c6e55 	svcvs	0x006c6e55
     e88:	64006b63 	strvs	r6, [r0], #-2915	; 0xb63
     e8c:	00617461 	rsbeq	r7, r1, r1, ror #8
    _SetCNTR(0);
    _SetISTR(0);
     e90:	70706d74 	rsbsvc	r6, r0, r4, ror sp

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e94:	55006572 	strpl	r6, [r0, #-1394]	; 0x572
    _SetCNTR(wInterrupt_Mask);
     e98:	54524153 	ldrbpl	r4, [r2], #-339	; 0x153
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9c:	646f4d5f 	strbtvs	r4, [pc], #-3423	; ea4 <usbPowerOn+0x34>
     ea0:	77720065 	ldrbvc	r0, [r2, -r5, rrx]!
#endif
#endif

    return USB_SUCCESS;
}
     ea4:	6c61566d 	stclvs	6, cr5, [r1], #-436	; 0xfffffe4c
     ea8:	616c6600 	cmnvs	ip, r0, lsl #12
     eac:	74655367 	strbtvc	r5, [r5], #-871	; 0x367
     eb0:	72737500 	rsbsvc	r7, r3, #0, 10
     eb4:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	43485300 	movtmi	r5, #33536	; 0x8300
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	55005253 	strpl	r5, [r0, #-595]	; 0x253
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
     ec0:	54524153 	ldrbpl	r4, [r2], #-339	; 0x153
     ec4:	7261485f 	rsbvc	r4, r1, #6225920	; 0x5f0000
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec8:	72617764 	rsbvc	r7, r1, #100, 14	; 0x1900000
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     ecc:	6f6c4665 	svcvs	0x006c4665
     ed0:	6e6f4377 	mcrvs	3, 3, r4, cr15, cr7, {3}
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	6c6f7274 	sfmvs	f7, 2, [pc], #-464	; d0c <usbGetStringDescriptor+0x10>
     ed8:	53464300 	movtpl	r4, #25344	; 0x6300
     edc:	55550052 	ldrbpl	r0, [r5, #-82]	; 0x52

    return USB_SUCCESS;
}
     ee0:	7475505f 	ldrbtvc	r5, [r5], #-95	; 0x5f
     ee4:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
     ee8:	5f00676e 	svcpl	0x0000676e
     eec:	0070615f 	rsbseq	r6, r0, pc, asr r1
     ef0:	4d727375 	ldclmi	3, cr7, [r2, #-468]!	; 0xfffffe2c
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	006e6961 	rsbeq	r6, lr, r1, ror #18
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	46746567 	ldrbtmi	r6, [r4], -r7, ror #10
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efc:	6873616c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, sp, lr}^
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	00646e45 	rsbeq	r6, r4, r5, asr #28
     f04:	73616c66 	cmnvc	r1, #26112	; 0x6600
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f08:	7a695368 	bvc	1a55cb0 <_etext+0x1a4e798>
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	50470065 	subpl	r0, r7, r5, rrx
     f10:	495f4f49 	ldmdbmi	pc, {r0, r3, r6, r8, r9, sl, fp, lr}^	; <UNPREDICTABLE>
    nvicInit(&NVIC_InitStructure);
     f14:	5374696e 	cmnpl	r4, #1802240	; 0x1b8000
}
     f18:	63757274 	cmnvs	r5, #116, 4	; 0x40000007

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	65727574 	ldrbvs	r7, [r2, #-1396]!	; 0x574
    dfuInit();
     f20:	31524400 	cmpcc	r2, r0, lsl #8

    pInformation->Current_Configuration = 0;
     f24:	43490030 	movtmi	r0, #36912	; 0x9030
     f28:	52005250 	andpl	r5, r0, #80, 4
    usbPowerOn();
     f2c:	525f4343 	subspl	r4, pc, #201326593	; 0xc000001

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
     f30:	74536765 	ldrbvc	r6, [r3], #-1893	; 0x765
     f34:	74637572 	strbtvc	r7, [r3], #-1394	; 0x572
     f38:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    _SetCNTR(wInterrupt_Mask);
     f3c:	6f4d5f4f 	svcvs	0x004d5f4f

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f40:	415f6564 	cmpmi	pc, r4, ror #10
    bDeviceState = UNCONNECTED;
     f44:	444f5f46 	strbmi	r5, [pc], #-3910	; f4c <usbInit+0x30>
     f48:	43537200 	cmpmi	r3, #0, 4
     f4c:	72610042 	rsbvc	r0, r1, #66	; 0x42
     f50:	75007067 	strvc	r7, [r0, #-103]	; 0x67
     f54:	0064695f 	rsbeq	r6, r4, pc, asr r9
     f58:	73616c66 	cmnvc	r1, #26112	; 0x6600
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	61724568 	cmnvs	r2, r8, ror #10
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f60:	61506573 	cmpvs	r0, r3, ror r5
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	00736567 	rsbseq	r6, r3, r7, ror #10

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f68:	69727076 	ldmdbvs	r2!, {r1, r2, r4, r5, r6, ip, sp, lr}^
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	5500746e 	strpl	r7, [r0, #-1134]	; 0x46e
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	54524153 	ldrbpl	r4, [r2], #-339	; 0x153
    nvicInit(&NVIC_InitStructure);
     f74:	4d4d0078 	stclmi	0, cr0, [sp, #-480]	; 0xfffffe20
}
     f78:	00524146 	subseq	r4, r2, r6, asr #2
     f7c:	4f495047 	svcmi	0x00495047

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	646f4d5f 	strbtvs	r4, [pc], #-3423	; f88 <USB_LP_CAN1_RX0_IRQHandler+0x8>
    wIstr = _GetISTR();
     f84:	49415f65 	stmdbmi	r1, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	4552004e 	ldrbmi	r0, [r2, #-78]	; 0x4e
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8c:	56524553 			; <UNDEFINED> instruction: 0x56524553

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f90:	00304445 	eorseq	r4, r0, r5, asr #8
     f94:	45534552 	ldrbmi	r4, [r3, #-1362]	; 0x552
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	44455652 	strbmi	r5, [r5], #-1618	; 0x652
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	45520031 	ldrbmi	r0, [r2, #-49]	; 0x31
     fa0:	56524553 			; <UNDEFINED> instruction: 0x56524553
     fa4:	00324445 	eorseq	r4, r2, r5, asr #8
        _SetISTR((u16)CLR_RESET);
     fa8:	45534552 	ldrbmi	r4, [r3, #-1362]	; 0x552
        Device_Property.Reset();
     fac:	44455652 	strbmi	r5, [r5], #-1618	; 0x652
     fb0:	45520033 	ldrbmi	r0, [r2, #-51]	; 0x33
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb4:	56524553 			; <UNDEFINED> instruction: 0x56524553
     fb8:	00344445 	eorseq	r4, r4, r5, asr #8
        _SetISTR((u16)CLR_ERR);
     fbc:	45534552 	ldrbmi	r4, [r3, #-1362]	; 0x552
     fc0:	44455652 	strbmi	r5, [r5], #-1618	; 0x652
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc4:	45520035 	ldrbmi	r0, [r2, #-53]	; 0x35
     fc8:	56524553 			; <UNDEFINED> instruction: 0x56524553
        _SetISTR((u16)CLR_WKUP);
     fcc:	00364445 	eorseq	r4, r6, r5, asr #8
        usbResume(RESUME_EXTERNAL);
     fd0:	45534552 	ldrbmi	r4, [r3, #-1362]	; 0x552
     fd4:	44455652 	strbmi	r5, [r5], #-1618	; 0x652
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd8:	45520038 	ldrbmi	r0, [r2, #-56]	; 0x38
     fdc:	56524553 			; <UNDEFINED> instruction: 0x56524553

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	00394445 	eorseq	r4, r9, r5, asr #8
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	4f495047 	svcmi	0x00495047
     fe8:	646f4d5f 	strbtvs	r4, [pc], #-3423	; ff0 <USB_LP_CAN1_RX0_IRQHandler+0x70>
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fec:	46415f65 	strbmi	r5, [r1], -r5, ror #30
     ff0:	0050505f 	subseq	r5, r0, pc, asr r0
        _SetISTR((u16)CLR_SOF);
     ff4:	4f495047 	svcmi	0x00495047
     ff8:	6570535f 	ldrbvs	r5, [r0, #-863]!	; 0x35f
        bIntPackSOF++;
     ffc:	6d006465 	cfstrsvs	mvf6, [r0, #-404]	; 0xfffffe6c
    1000:	65736d65 	ldrbvs	r6, [r3, #-3429]!	; 0xd65
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	55550074 	ldrbpl	r0, [r5, #-116]	; 0x74
    1008:	7475505f 	ldrbtvc	r5, [r5], #-95	; 0x5f
        _SetISTR((u16)CLR_ESOF);
    100c:	72616843 	rsbvc	r6, r1, #4390912	; 0x430000
    1010:	616c6600 	cmnvs	ip, r0, lsl #12
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    }
#endif

}
    1014:	6f4c6873 	svcvs	0x004c6873
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	77006b63 	strvc	r6, [r0, -r3, ror #22]
    101c:	0064726f 	rsbeq	r7, r4, pc, ror #4
    1020:	3266666f 	rsbcc	r6, r6, #116391936	; 0x6f00000
    1024:	74657300 	strbtvc	r7, [r5], #-768	; 0x300
    1028:	4170734d 	cmnmi	r0, sp, asr #6
    102c:	754a646e 	strbvc	r6, [sl, #-1134]	; 0x46e
    1030:	4200706d 	andmi	r7, r0, #109	; 0x6d
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

void print_hash(unsigned char hash[])
{
    1034:	00524146 	subseq	r4, r2, r6, asr #2
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
}

int main() 
{
    1038:	4f495047 	svcmi	0x00495047
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    103c:	7079545f 	rsbsvc	r5, r9, pc, asr r4
    setupCLK();
    1040:	66654465 	strbtvs	r4, [r5], -r5, ror #8
    setupLEDAndButton();
    1044:	4f545600 	svcmi	0x00545600
    setupUSB();
    1048:	50470052 	subpl	r0, r7, r2, asr r0
    setupFLASH();
    104c:	6f4d4f49 	svcvs	0x004d4f49
    uartInit();
    1050:	545f6564 	ldrbpl	r6, [pc], #-1380	; 1058 <main+0x20>
    usbReset();
    1054:	44657079 	strbtmi	r7, [r5], #-121	; 0x79
	uart_printf("\nBootloader init...\n");
    1058:	4e006665 	cfmadd32mi	mvax3, mvfx6, mvfx0, mvfx5
    105c:	5f434956 	svcpl	0x00434956

    if (readPin(GPIOB, 15) == 0x0)
    1060:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
    1064:	00666544 	rsbeq	r6, r6, r4, asr #10
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1068:	73706d74 	cmnvc	r0, #116, 26	; 0x1d00
    106c:	5f006275 	svcpl	0x00006275
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    1070:	5f61765f 	svcpl	0x0061765f
    1074:	7473696c 	ldrbtvc	r6, [r3], #-2412	; 0x96c
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
    1078:	414e4500 	cmpmi	lr, r0, lsl #10
    107c:	00454c42 	subeq	r4, r5, r2, asr #24
    1080:	52534349 	subspl	r4, r3, #603979777	; 0x24000001
   debug_print("\n", 0);
}

int main() 
{
	bool no_user_jump = FALSE;
    1084:	66666f00 	strbtvs	r6, [r6], -r0, lsl #30
    1088:	43530030 	cmpmi	r3, #48	; 0x30
    108c:	79545f42 	ldmdbvc	r4, {r1, r6, r8, r9, sl, fp, ip, lr}^
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1090:	65446570 	strbvs	r6, [r4, #-1392]	; 0x570
			no_user_jump = FALSE;
    1094:	666f0066 	strbtvs	r0, [pc], -r6, rrx
			break;

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    1098:	6f003466 	svcvs	0x00003466
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    109c:	00386666 	eorseq	r6, r8, r6, ror #12
    10a0:	4f495047 	svcmi	0x00495047
			break;

		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10a4:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    10a8:	70795474 	rsbsvc	r5, r9, r4, ror r4
    10ac:	66654465 	strbtvs	r4, [r5], -r5, ror #8
    10b0:	616c6600 	cmnvs	ip, r0, lsl #12
    10b4:	64416873 	strbvs	r6, [r1], #-2163	; 0x873

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10b8:	4e007264 	cdpmi	2, 0, cr7, cr0, cr4, {3}
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10bc:	5f434956 	svcpl	0x00434956
    10c0:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
    10c4:	75727453 	ldrbvc	r7, [r2, #-1107]!	; 0x453
    10c8:	47007463 	strmi	r7, [r0, -r3, ror #8]

		if (dfuUploadStarted()) 
    10cc:	5f4f4950 	svcpl	0x004f4950
    10d0:	65657053 	strbvs	r7, [r5, #-83]!	; 0x53
		{
			uart_printf("DFU finished upload\n");
    10d4:	30355f64 	eorscc	r5, r5, r4, ror #30
			dfuFinishUpload(); // systemHardReset from DFU once done
    10d8:	007a484d 	rsbseq	r4, sl, sp, asr #16
    10dc:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10e0:	6d435f54 	stclvs	15, cr5, [r3, #-336]	; 0xfffffeb0
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10e4:	50470064 	subpl	r0, r7, r4, rrx
    10e8:	4d5f4f49 	ldclmi	15, cr4, [pc, #-292]	; fcc <USB_LP_CAN1_RX0_IRQHandler+0x4c>
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10ec:	5f65646f 	svcpl	0x0065646f
	}
	
	return 0;// Added to please the compiler
    10f0:	5f74754f 	svcpl	0x0074754f
    10f4:	5200444f 	andpl	r4, r0, #1325400064	; 0x4f000000
    10f8:	52455345 	subpl	r5, r5, #335544321	; 0x14000001
    10fc:	31444556 	cmpcc	r4, r6, asr r5
    1100:	45520030 	ldrbmi	r0, [r2, #-48]	; 0x30
    1104:	56524553 			; <UNDEFINED> instruction: 0x56524553
    1108:	31314445 	teqcc	r1, r5, asr #8
    110c:	45434900 	strbmi	r4, [r3, #-2304]	; 0x900
    1110:	64610052 	strbtvs	r0, [r1], #-82	; 0x52
    1114:	55007264 	strpl	r7, [r0, #-612]	; 0x264
    1118:	54524153 	ldrbpl	r4, [r2], #-339	; 0x153
    111c:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    1120:	70795474 	rsbsvc	r5, r9, r4, ror r4
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1124:	66654465 	strbtvs	r4, [r5], -r5, ror #8
    1128:	42414900 	submi	r4, r1, #0, 18
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    112c:	75760052 	ldrbvc	r0, [r6, #-82]!	; 0x52
    1130:	00323363 	eorseq	r3, r2, r3, ror #6
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1134:	5f434352 	svcpl	0x00434352
    1138:	32425041 	subcc	r5, r2, #65	; 0x41
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    113c:	69726550 	ldmdbvs	r2!, {r4, r6, r8, sl, sp, lr}^
    1140:	6c436870 	mcrrvs	8, 7, r6, r3, cr0
        return TRUE;
    } else {
        return FALSE;
    }
}
    1144:	436b636f 	cmnmi	fp, #-1140850687	; 0xbc000001
    1148:	5200646d 	andpl	r6, r0, #1828716544	; 0x6d000000

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    114c:	52434354 	subpl	r4, r3, #84, 6	; 0x50000001
    1150:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    1154:	6570534f 	ldrbvs	r5, [r0, #-847]!	; 0x34f
    gpio_write_bit( bank,pin,1-onState);
    1158:	545f6465 	ldrbpl	r6, [pc], #-1125	; 1160 <strobePin+0x14>
    115c:	44657079 	strbtmi	r7, [r5], #-121	; 0x79
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	62006665 	andvs	r6, r0, #105906176	; 0x6500000
    gpio_write_bit( bank,pin,1-onState);
    1164:	006b6e61 	rsbeq	r6, fp, r1, ror #28

    u32 c;
    while (count-- > 0) 
    1168:	65676170 	strbvs	r6, [r7, #-368]!	; 0x170
	{
        for (c = rate; c > 0; c--)
    116c:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
    1170:	57686c00 	strbpl	r6, [r8, -r0, lsl #24]!
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1174:	0064726f 	rsbeq	r7, r4, pc, ror #4
    1178:	52505349 	subspl	r5, r0, #603979777	; 0x24000001
    117c:	6d756a00 	vldmdbvs	r5!, {s13-s12}
		
        for (c = rate; c > 0; c--)
    1180:	64644170 	strbtvs	r4, [r4], #-368	; 0x170
    1184:	50470072 	subpl	r0, r7, r2, ror r0
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    1188:	4d5f4f49 	ldclmi	15, cr4, [pc, #-292]	; 106c <main+0x34>
    118c:	5f65646f 	svcpl	0x0065646f
    1190:	465f4e49 	ldrbmi	r4, [pc], -r9, asr #28
    1194:	54414f4c 	strbpl	r4, [r1], #-3916	; 0xf4c
    1198:	00474e49 	subeq	r4, r7, r9, asr #28

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    119c:	45534552 	ldrbmi	r4, [r3, #-1362]	; 0x552
    11a0:	44455652 	strbmi	r5, [r5], #-1618	; 0x652
  USARTx->DR = ch;  
    11a4:	68680037 	stmdavs	r8!, {r0, r1, r2, r4, r5}^
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11a8:	64726f57 	ldrbtvs	r6, [r2], #-3927	; 0xf57
  while(*str != 0)
    11ac:	706d7400 	rsbvc	r7, sp, r0, lsl #8
    11b0:	6f697270 	svcvs	0x00697270
  {
    UU_PutChar(USARTx, *str);
    11b4:	79746972 	ldmdbvc	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    11b8:	61745300 	cmnvs	r4, r0, lsl #6
    str++;
  }
}

void vprint(const char *fmt, va_list argp)
{
    11bc:	70557472 	subsvc	r7, r5, r2, ror r4
    11c0:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11c4:	00726574 	rsbseq	r6, r2, r4, ror r5
    11c8:	524b434c 	subpl	r4, fp, #76, 6	; 0x30000001
    11cc:	55464400 	strbpl	r4, [r6, #-1024]	; 0x400
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11d0:	4c50555f 	cfldr64mi	mvdx5, [r0], {95}	; 0x5f
    11d4:	5f44414f 	svcpl	0x0044414f

    }
}
    11d8:	53414c46 	movtpl	r4, #7238	; 0x1c46
    11dc:	58305f48 	ldmdapl	r0!, {r3, r6, r8, r9, sl, fp, ip, lr}
    11e0:	37303038 			; <UNDEFINED> instruction: 0x37303038

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11e4:	00303030 	eorseq	r3, r0, r0, lsr r0
    11e8:	75706e69 	ldrbvc	r6, [r0, #-3689]!	; 0xe69
    11ec:	74730074 	ldrbtvc	r0, [r3], #-116	; 0x74
    va_list argp;
    va_start(argp, fmt);
    vprint(fmt, argp);
    11f0:	53747261 	cmnpl	r4, #268435462	; 0x10000006
    va_end(argp);
}
    11f4:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0x174
    11f8:	65737500 	ldrbvs	r7, [r3, #-1280]!	; 0x500
    11fc:	70704172 	rsbsvc	r4, r0, r2, ror r1

void hexdump(unsigned char *data, size_t size)
{
    1200:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
    int i;
    char cs[17];
    memset(cs, 0, 17);
    1204:	55464400 	strbpl	r4, [r6, #-1024]	; 0x400
    1208:	4c50555f 	cfldr64mi	mvdx5, [r0], {95}	; 0x5f
    120c:	5f44414f 	svcpl	0x0044414f

    for(i = 0; i < size; i++)
    1210:	53414c46 	movtpl	r4, #7238	; 0x1c46
    {
        if(i != 0 && i % 0x10 == 0)
    1214:	58305f48 	ldmdapl	r0!, {r3, r6, r8, r9, sl, fp, ip, lr}
    1218:	32303038 	eorscc	r3, r0, #56	; 0x38
        {
            debug_print(" |%s|\n", cs);
            memset(cs, 0, 17);
    121c:	00303030 	eorseq	r3, r0, r0, lsr r0
    1220:	53756664 	cmnpl	r5, #100, 12	; 0x6400000
{
    int i;
    char cs[17];
    memset(cs, 0, 17);

    for(i = 0; i < size; i++)
    1224:	74537465 	ldrbvc	r7, [r3], #-1125	; 0x465
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
}
    1228:	00657461 	rsbeq	r7, r5, r1, ror #8


#endif
void uartInit(void) {
    122c:	55756664 	ldrbpl	r6, [r5, #-1636]!	; 0x664
    1230:	616f6c70 	smcvs	63168	; 0xf6c0
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    1234:	70795464 	rsbsvc	r5, r9, r4, ror #8
    1238:	745f7365 	ldrbvc	r7, [pc], #-869	; 1240 <uartInit+0x14>
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    123c:	75666400 	strbvc	r6, [r6, #-1024]!	; 0x400
    1240:	6f6c7055 	svcvs	0x006c7055
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    1244:	6f446461 	svcvs	0x00446461
    1248:	4400656e 	strmi	r6, [r0], #-1390	; 0x56e
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    124c:	555f5546 	ldrbpl	r5, [pc, #-1350]	; d0e <usbGetStringDescriptor+0x12>
    1250:	414f4c50 	cmpmi	pc, r0, asr ip	; <UNPREDICTABLE>
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1254:	41525f44 	cmpmi	r2, r4, asr #30
    1258:	6572004d 	ldrbvs	r0, [r2, #-77]!	; 0x4d
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    125c:	75427663 	strbvc	r7, [r2, #-1635]	; 0x663
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    1260:	72656666 	rsbvc	r6, r5, #106954752	; 0x6600000
    1264:	75666400 	strbvc	r6, [r6, #-1024]!	; 0x400
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1268:	79706f43 	ldmdbvc	r0!, {r0, r1, r6, r8, r9, sl, fp, sp, lr}^
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    126c:	4f4c5055 	svcmi	0x004c5055
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1270:	74004441 	strvc	r4, [r0], #-1089	; 0x441
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1274:	42736968 	rsbsmi	r6, r3, #104, 18	; 0x1a0000
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1278:	6b636f6c 	blvs	18dd030 <_etext+0x18d5b18>
    127c:	006e654c 	rsbeq	r6, lr, ip, asr #10
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1280:	32616873 	rsbcc	r6, r1, #7536640	; 0x730000
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    1284:	75733635 	ldrbvc	r3, [r3, #-1589]!	; 0x635
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1288:	6664006d 	strbtvs	r0, [r4], -sp, rrx
    USART_InitStructure.USART_Parity = USART_Parity_No;
    128c:	64705575 	ldrbtvs	r5, [r0], #-1397	; 0x575
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    1290:	42657461 	rsbmi	r7, r5, #1627389952	; 0x61000000
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1294:	6d695479 	cfstrdvs	mvd5, [r9, #-484]!	; 0xfffffe1c
    1298:	74756f65 	ldrbtvc	r6, [r5], #-3941	; 0xf65
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    129c:	75666400 	strbvc	r6, [r6, #-1024]!	; 0x400
        
    USART_Init(USART1, &USART_InitStructure);
    12a0:	79737542 	ldmdbvc	r3!, {r1, r6, r8, sl, ip, sp, lr}^
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    12a4:	4c505f00 	mrrcmi	15, 0, r5, r0, cr0
    12a8:	4400544f 	strmi	r5, [r0], #-1103	; 0x44f
}
    12ac:	555f5546 	ldrbpl	r5, [pc, #-1350]	; d6e <setupUSB+0x1e>
    12b0:	414f4c50 	cmpmi	pc, r0, asr ip	; <UNPREDICTABLE>

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    12b4:	4c465f44 	mcrrmi	15, 4, r5, r6, cr4
    12b8:	5f485341 	svcpl	0x00485341
    12bc:	30385830 	eorscc	r5, r8, r0, lsr r8
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    12c0:	30303630 	eorscc	r3, r0, r0, lsr r6
    12c4:	66640030 			; <UNDEFINED> instruction: 0x66640030
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    12c8:	00632e75 	rsbeq	r2, r3, r5, ror lr
    12cc:	72657375 	rsbvc	r7, r5, #-738197503	; 0xd4000001
    12d0:	63617053 	cmnvs	r1, #83	; 0x53
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    12d4:	53690065 	cmnpl	r9, #101	; 0x65
    12d8:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    12dc:	70750067 	rsbsvc	r0, r5, r7, rrx
    12e0:	64616f6c 	strbtvs	r6, [r1], #-3948	; 0xf6c

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    12e4:	636f6c42 	cmnvs	pc, #16896	; 0x4200
    12e8:	6e654c6b 	cdpvs	12, 6, cr4, cr5, cr11, {3}
    12ec:	55464400 	strbpl	r4, [r6, #-1024]	; 0x400
    12f0:	4c50555f 	cfldr64mi	mvdx5, [r0], {95}	; 0x5f
    12f4:	5f44414f 	svcpl	0x0044414f
    12f8:	53414c46 	movtpl	r4, #7238	; 0x1c46
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    12fc:	58305f48 	ldmdapl	r0!, {r3, r6, r8, r9, sl, fp, ip, lr}
    1300:	38303038 	ldmdacc	r0!, {r3, r4, r5, ip, sp}
    1304:	00303030 	eorseq	r3, r0, r0, lsr r0
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    1308:	5f554644 	svcpl	0x00554644
    130c:	4f4c5055 	svcmi	0x004c5055

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    1310:	4e5f4441 	cdpmi	4, 5, cr4, cr15, cr1, {2}
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    1314:	00454e4f 	subeq	r4, r5, pc, asr #28
    1318:	72657375 	rsbvc	r7, r5, #-738197503	; 0xd4000001
    131c:	6d726946 	ldclvs	9, cr6, [r2, #-280]!	; 0xfffffee8
    1320:	65726177 	ldrbvs	r6, [r2, #-375]!	; 0x177
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    1324:	006e654c 	rsbeq	r6, lr, ip, asr #10
    1328:	41756664 	cmnmi	r5, r4, ror #12

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    132c:	74537070 	ldrbvc	r7, [r3], #-112	; 0x70
    1330:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    1334:	61687300 	cmnvs	r8, r0, lsl #6
    1338:	5f363532 	svcpl	0x00363532
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    133c:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    1340:	5f007374 	svcpl	0x00007374
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    1344:	53554644 	cmppl	r5, #68, 12	; 0x4400000
    1348:	75746174 	ldrbvc	r6, [r4, #-372]!	; 0x174
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    134c:	656c0073 	strbvs	r0, [ip, #-115]!	; 0x73
    1350:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
    1354:	75666400 	strbvc	r6, [r6, #-1024]!	; 0x400
    1358:	79706f43 	ldmdbvc	r0!, {r0, r1, r6, r8, r9, sl, fp, sp, lr}^

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    135c:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
    1360:	53620065 	cmnpl	r2, #101	; 0x65
    1364:	75746174 	ldrbvc	r6, [r4, #-372]!	; 0x174
    1368:	66640073 			; <UNDEFINED> instruction: 0x66640073
    136c:	706f4375 	rsbvc	r4, pc, r5, ror r3	; <UNPREDICTABLE>
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    1370:	4c4e4479 	cfstrdmi	mvd4, [lr], {121}	; 0x79
    1374:	0044414f 	subeq	r4, r4, pc, asr #2
        u32 rwmVal = pRCC->CR;
    1378:	6f507762 	svcvs	0x00507762
        rwmVal |= 0x01;
    137c:	69546c6c 	ldmdbvs	r4, {r2, r3, r5, r6, sl, fp, sp, lr}^
        pRCC->CR = rwmVal;
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    1380:	756f656d 	strbvc	r6, [pc, #-1389]!	; e1b <usbResume+0x2f>
    1384:	62003074 	andvs	r3, r0, #116	; 0x74
}   
    1388:	6c6f5077 	stclvs	0, cr5, [pc], #-476	; 11b4 <UU_PutString+0xe>
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    138c:	6d69546c 	cfstrdvs	mvd5, [r9, #-432]!	; 0xfffffe50
void setMspAndJump(u32 usrAddr) {
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    1390:	74756f65 	ldrbtvc	r6, [r5], #-3941	; 0xf65
  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1394:	77620031 			; <UNDEFINED> instruction: 0x77620031

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1398:	6c6c6f50 	stclvs	15, cr6, [ip], #-320	; 0xfffffec0
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    139c:	656d6954 	strbvs	r6, [sp, #-2388]!	; 0x954
    13a0:	3274756f 	rsbscc	r7, r4, #465567744	; 0x1bc00000
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    13a4:	61687300 	cmnvs	r8, r0, lsl #6
    13a8:	5f363532 	svcpl	0x00363532
    13ac:	746e6f63 	strbtvc	r6, [lr], #-3939	; 0xf63
    13b0:	00747865 	rsbseq	r7, r4, r5, ror #16
    tmppre = (0x4 - tmppriority);
    13b4:	49474542 	stmdbmi	r7, {r1, r6, r8, sl, lr}^
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    13b8:	4e494e4e 	cdpmi	14, 4, cr4, cr9, cr14, {2}


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    13bc:	66640047 	strbtvs	r0, [r4], -r7, asr #32

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c0:	706f4375 	rsbvc	r4, pc, r5, ror r3	; <UNPREDICTABLE>
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    13c4:	61745379 	cmnvs	r4, r9, ror r3

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c8:	00737574 	rsbseq	r7, r3, r4, ror r5
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    13cc:	65646f63 	strbvs	r6, [r4, #-3939]!	; 0xf63
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d0:	706f635f 	rsbvc	r6, pc, pc, asr r3	; <UNPREDICTABLE>

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d4:	6f6c5f79 	svcvs	0x006c5f79
    13d8:	44006b63 	strmi	r6, [r0], #-2915	; 0xb63
    13dc:	555f5546 	ldrbpl	r5, [pc, #-1350]	; e9e <usbPowerOn+0x2e>
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    13e0:	414f4c50 	cmpmi	pc, r0, asr ip	; <UNPREDICTABLE>
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    13e4:	4c465f44 	mcrrmi	15, 4, r5, r6, cr4
    tmppriority &= tmpmask;
    13e8:	5f485341 	svcpl	0x00485341
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    13ec:	30385830 	eorscc	r5, r8, r0, lsr r8

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    13f0:	30303530 	eorscc	r3, r0, r0, lsr r5
    13f4:	66640030 			; <UNDEFINED> instruction: 0x66640030
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    13f8:	74654775 	strbtvc	r4, [r5], #-1909	; 0x775
    13fc:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    1400:	73750065 	cmnvc	r5, #101	; 0x65
    1404:	70417265 	subvc	r7, r1, r5, ror #4
    1408:	646e4570 	strbtvs	r4, [lr], #-1392	; 0x570
    140c:	44494d00 	strbmi	r4, [r9], #-3328	; 0xd00
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    1410:	00454c44 	subeq	r4, r5, r4, asr #24
    1414:	72657375 	rsbvc	r7, r5, #-738197503	; 0xd4000001
    1418:	6f6c7055 	svcvs	0x006c7055
    rNVIC->ICER[1] = 0xFFFFFFFF;
    141c:	79546461 	ldmdbvc	r4, {r0, r5, r6, sl, sp, lr}^
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    1420:	6e006570 	cfrshl64vs	mvdx0, mvdx0, r6
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    1424:	74537765 	ldrbvc	r7, [r3], #-1893	; 0x765

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    1428:	00657461 	rsbeq	r7, r5, r1, ror #8
    142c:	43756664 	cmnmi	r5, #100, 12	; 0x6400000
    1430:	4279706f 	rsbsmi	r7, r9, #111	; 0x6f

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    1434:	65666675 	strbvs	r6, [r6, #-1653]!	; 0x675
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    1438:	456f5472 	strbmi	r5, [pc, #-1138]!	; fce <USB_LP_CAN1_RX0_IRQHandler+0x4e>
    nvicDisableInterrupts();
    143c:	00636578 	rsbeq	r6, r3, r8, ror r5
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    1440:	61745362 	cmnvs	r4, r2, ror #6
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    1444:	32006574 	andcc	r6, r0, #116, 10	; 0x1d000000
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    1448:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
}
    144c:	3532632f 	ldrcc	r6, [r2, #-815]!	; 0x32f
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    1450:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1454:	63780063 	cmnvs	r8, #99	; 0x63
    1458:	756f645f 	strbvc	r6, [pc, #-1119]!	; 1001 <USB_LP_CAN1_RX0_IRQHandler+0x81>

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    145c:	00656c62 	rsbeq	r6, r5, r2, ror #24
    1460:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
    1464:	635f3931 	cmpvs	pc, #802816	; 0xc4000
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1468:	0079706f 	rsbseq	r7, r9, pc, rrx
    146c:	35353263 	ldrcc	r3, [r5, #-611]!	; 0x263
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    1470:	625f3931 	subsvs	r3, pc, #802816	; 0xc4000

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1474:	5f657361 	svcpl	0x00657361
    1478:	32660078 	rsbcc	r0, r6, #120	; 0x78
    147c:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    SET_REG(FLASH_AR, pageAddr);
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    1480:	6464615f 	strbtvs	r6, [r4], #-351	; 0x15f
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1484:	35326600 	ldrcc	r6, [r2, #-1536]!	; 0x600
    1488:	5f393135 	svcpl	0x00393135

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    148c:	5f6c756d 	svcpl	0x006c756d

    return TRUE;
}
    1490:	31780063 	cmncc	r8, r3, rrx
    1494:	66007173 			; <UNDEFINED> instruction: 0x66007173
    1498:	31353532 	teqcc	r5, r2, lsr r5
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    149c:	6e6f5f39 	mcrvs	15, 3, r5, cr15, cr9, {1}
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    14a0:	317a0065 	cmncc	sl, r5, rrx
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    14a4:	63007173 	movwvs	r7, #371	; 0x173

    u32 rwmVal = GET_REG(FLASH_CR);
    SET_REG(FLASH_CR, FLASH_CR_PG);
    14a8:	31353532 	teqcc	r5, r2, lsr r5
    14ac:	6d735f39 	ldclvs	15, cr5, [r3, #-228]!	; 0xffffff1c

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14b0:	00746c75 	rsbseq	r6, r4, r5, ror ip
    14b4:	20554e47 	subscs	r4, r5, r7, asr #28
    *(flashAddr + 0x01) = (vu16)hhWord;
    14b8:	2e342043 	cdpcs	0, 3, cr2, cr4, cr3, {2}
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14bc:	20342e38 	eorscs	r2, r4, r8, lsr lr
    14c0:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
    *(flashAddr) = (vu16)lhWord;
    14c4:	35323730 	ldrcc	r3, [r2, #-1840]!	; 0x730
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14c8:	65722820 	ldrbvs	r2, [r2, #-2080]!	; 0x820
    14cc:	7361656c 	cmnvc	r1, #108, 10	; 0x1b000000

    rwmVal &= 0xFFFFFFFE;
    14d0:	5b202965 	blpl	80ba6c <_etext+0x804554>
    SET_REG(FLASH_CR, rwmVal);

    /* verify the write */
    if (*(vu32 *)addr != word) {
    14d4:	2f4d5241 	svccs	0x004d5241
        return FALSE;
    }

    return TRUE;
}
    14d8:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
    14dc:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
    14e0:	385f342d 	ldmdacc	pc, {r0, r2, r3, r5, sl, ip, sp}^	; <UNPREDICTABLE>
    14e4:	6172622d 	cmnvs	r2, sp, lsr #4

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    14e8:	2068636e 	rsbcs	r6, r8, lr, ror #6
    14ec:	69766572 	ldmdbvs	r6!, {r1, r4, r5, r6, r8, sl, sp, lr}^
    14f0:	6e6f6973 	mcrvs	9, 3, r6, cr15, cr3, {3}
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    14f4:	33313220 	teqcc	r1, #32, 4
    14f8:	5d373431 	cfldrspl	mvf3, [r7, #-196]!	; 0xffffff3c
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    14fc:	746d2d20 	strbtvc	r2, [sp], #-3360	; 0xd20
    1500:	626d7568 	rsbvs	r7, sp, #104, 10	; 0x1a000000
    1504:	636d2d20 	cmnvs	sp, #32, 26	; 0x800
    1508:	633d7570 	teqvs	sp, #112, 10	; 0x1c000000

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    150c:	6574726f 	ldrbvs	r7, [r4, #-623]!	; 0x26f
	{
		pin-=8;
    1510:	336d2d78 	cmncc	sp, #120, 26	; 0x1e00
	}
	mask = 0x0F << (pin<<2);
    1514:	746d2d20 	strbtvc	r2, [sp], #-3360	; 0xd20
    1518:	626d7568 	rsbvs	r7, sp, #104, 10	; 0x1a000000
	return ~mask;
}	
    151c:	746e692d 	strbtvc	r6, [lr], #-2349	; 0x92d

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    1520:	6f777265 	svcvs	0x00777265
    1524:	2d206b72 	vstmdbcs	r0!, {d6-<overflow reg d62>}
}
    1528:	4f2d2067 	svcmi	0x002d2067
    152c:	662d2033 			; <UNDEFINED> instruction: 0x662d2033

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    1530:	636e7566 	cmnvs	lr, #427819008	; 0x19800000
	{
		return 0x800;
    1534:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
	}
	else
	{
		return 0x400;
	}
}
    1538:	6365732d 	cmnvs	r5, #-1275068416	; 0xb4000000
    153c:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
    1540:	662d2073 			; <UNDEFINED> instruction: 0x662d2073
    1544:	61746164 	cmnvs	r4, r4, ror #2

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1548:	6365732d 	cmnvs	r5, #-1275068416	; 0xb4000000
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    154c:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1550:	32660073 	rsbcc	r0, r6, #115	; 0x73
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1554:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    1558:	6275735f 	rsbsvs	r7, r5, #2080374785	; 0x7c000001
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    155c:	7a317800 	bvc	c5f564 <_etext+0xc5804c>
    1560:	32660031 	rsbcc	r0, r6, #49	; 0x31
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1564:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1568:	726f6e5f 	rsbvc	r6, pc, #1520	; 0x5f0
    userAppEnd = RAM_END;
    156c:	696c616d 	stmdbvs	ip!, {r0, r2, r3, r5, r6, r8, sp, lr}^
    1570:	6600657a 			; <UNDEFINED> instruction: 0x6600657a
    userUploadType=DFU_UPLOAD_NONE;
    1574:	31353532 	teqcc	r5, r2, lsr r5
    1578:	756d5f39 	strbvc	r5, [sp, #-3897]!	; 0xf39
    code_copy_lock = WAIT;
    157c:	645f5f6c 	ldrbvs	r5, [pc], #-3948	; 1584 <dfuInit+0x3c>
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1580:	69747369 	ldmdbvs	r4!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}^
    1584:	0074636e 	rsbseq	r6, r4, lr, ror #6
    1588:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
    memset(input, 0xFF, sizeof(input));
    158c:	695f3931 	ldmdbvs	pc, {r0, r4, r5, r8, fp, ip, sp}^	; <UNPREDICTABLE>
    1590:	5f5f766e 	svcpl	0x005f766e

    sha256_starts(&ctx);
}
    1594:	74736964 	ldrbtvc	r6, [r3], #-2404	; 0x964
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1598:	74636e69 	strbtvc	r6, [r3], #-3689	; 0xe69
    159c:	35326600 	ldrcc	r6, [r2, #-1536]!	; 0x600
    15a0:	5f393135 	svcpl	0x00393135
    15a4:	656c6573 	strbvs	r6, [ip, #-1395]!	; 0x573
    15a8:	72007463 	andvc	r7, r0, #1660944384	; 0x63000000
    15ac:	6c757365 	ldclvs	3, cr7, [r5], #-404	; 0xfffffe6c
    15b0:	63780074 	cmnvs	r8, #116	; 0x74
    15b4:	6669645f 			; <UNDEFINED> instruction: 0x6669645f
    15b8:	64646166 	strbtvs	r6, [r4], #-358	; 0x166
    15bc:	6d6f6300 	stclvs	3, cr6, [pc, #-0]	; 15c4 <dfuInit+0x7c>
    15c0:	32660070 	rsbcc	r0, r6, #112	; 0x70
    15c4:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    15c8:	0071655f 	rsbseq	r6, r1, pc, asr r5
    15cc:	756f5f72 	strbvc	r5, [pc, #-3954]!	; 662 <RCC_APB2PeriphClockCmd+0x12>
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    15d0:	656d0074 	strbvs	r0, [sp, #-116]!	; 0x74
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    15d4:	7970636d 	ldmdbvc	r0!, {r0, r2, r3, r5, r6, r8, r9, sp, lr}^
    15d8:	32646500 	rsbcc	r6, r4, #0, 10

    if (startState == appDETACH) {
    15dc:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    15e0:	6361705f 	cmnvs	r1, #95	; 0x5f
        dfuAppStatus.bState = dfuIDLE;
    15e4:	6170006b 	cmnvs	r0, fp, rrx
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
    15e8:	79746972 	ldmdbvc	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    15ec:	32646500 	rsbcc	r6, r4, #0, 10
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    15f0:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    } else if (startState == appIDLE || startState == dfuIDLE) {
    15f4:	6464615f 	strbtvs	r6, [r4], #-351	; 0x15f
    15f8:	32646500 	rsbcc	r6, r4, #0, 10
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    15fc:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1600:	7972745f 	ldmdbvc	r2!, {r0, r1, r2, r3, r4, r6, sl, ip, sp, lr}^
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    1604:	706e755f 	rsbvc	r7, lr, pc, asr r5
    1608:	006b6361 	rsbeq	r6, fp, r1, ror #6
    160c:	35326465 	ldrcc	r6, [r2, #-1125]!	; 0x465
    1610:	5f393135 	svcpl	0x00393135

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    1614:	6a6f7270 	bvs	1bddfdc <_etext+0x1bd6ac4>
        pInformation->Ctrl_Info.Usb_wLength = 1;
    1618:	00746365 	rsbseq	r6, r4, r5, ror #6
    161c:	31353532 	teqcc	r5, r2, lsr r5
        return NULL;
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    1620:	64652f39 	strbtvs	r2, [r5], #-3897	; 0xf39
    }
}
    1624:	31353532 	teqcc	r5, r2, lsr r5
    1628:	00632e39 	rsbeq	r2, r3, r9, lsr lr

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    162c:	35326465 	ldrcc	r6, [r2, #-1125]!	; 0x465
        pInformation->Ctrl_Info.Usb_wLength = 6;
    1630:	5f393135 	svcpl	0x00393135
    1634:	6c756d73 	ldclvs	13, cr6, [r5], #-460	; 0xfffffe34
        return NULL;
    } else {
        return (u8*)(&dfuAppStatus);
    1638:	32660074 	rsbcc	r0, r6, #116	; 0x74
    }
}
    163c:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    1640:	616f6c5f 	cmnvs	pc, pc, asr ip	; <UNPREDICTABLE>


u8 *dfuCopyDNLOAD(u16 length) {
    1644:	64650064 	strbtvs	r0, [r5], #-100	; 0x64
    if (length == 0) {
    1648:	31353532 	teqcc	r5, r2, lsr r5
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    164c:	6e755f39 	mrcvs	15, 3, r5, cr5, cr9, {1}
    1650:	6a6f7270 	bvs	1bde018 <_etext+0x1bd6b00>
        thisBlockLen = pInformation->USBwLengths.w;
    1654:	00746365 	rsbseq	r6, r4, r5, ror #6
        return NULL;
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1658:	35326465 	ldrcc	r6, [r2, #-1125]!	; 0x465
    165c:	5f393135 	svcpl	0x00393135
    }
}
    1660:	7475656e 	ldrbtvc	r6, [r5], #-1390	; 0x56e
    1664:	006c6172 	rsbeq	r6, ip, r2, ror r1
    1668:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266

u8 *dfuCopyUPLOAD(u16 length) {
    166c:	735f3931 	cmpvc	pc, #802816	; 0xc4000
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    1670:	00747271 	rsbseq	r7, r4, r1, ror r2
    1674:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
    1678:	6e5f3931 	mrcvs	9, 2, r3, cr15, cr1, {1}
        return NULL;
    167c:	65006765 	strvs	r6, [r0, #-1893]	; 0x765
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    1680:	35353264 	ldrcc	r3, [r5, #-612]!	; 0x264
    1684:	645f3931 	ldrbvs	r3, [pc], #-2353	; 168c <dfuCopyUPLOAD+0x20>
    1688:	6c62756f 	cfstr64vs	mvdx7, [r2], #-444	; 0xfffffe44
    168c:	64650065 	strbtvs	r0, [r5], #-101	; 0x65
    }
}
    1690:	31353532 	teqcc	r5, r2, lsr r5
    1694:	74705f39 	ldrbtvc	r5, [r0], #-3897	; 0xf39
    1698:	32646500 	rsbcc	r6, r4, #0, 10
    169c:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}

void dfuCopyBufferToExec() {
    16a0:	7361625f 	cmnvc	r1, #-268435451	; 0xf0000005
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    16a4:	64650065 	strbtvs	r0, [r5], #-101	; 0x65
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    16a8:	31353532 	teqcc	r5, r2, lsr r5
    16ac:	6f635f39 	svcvs	0x00635f39
    16b0:	65007970 	strvs	r7, [r0, #-2416]	; 0x970
    16b4:	35353264 	ldrcc	r3, [r5, #-612]!	; 0x264
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    16b8:	645f3931 	ldrbvs	r3, [pc], #-2353	; 16c0 <dfuCopyBufferToExec+0x20>
	}

    flashErasePage((u32)(userSpace));
    16bc:	32646500 	rsbcc	r6, r4, #0, 10

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16c0:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    16c4:	73006b5f 	movwvc	r6, #2911	; 0xb5f
    16c8:	31356168 	teqcc	r5, r8, ror #2
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    16cc:	69665f32 	stmdbvs	r6!, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
    16d0:	006c616e 	rsbeq	r6, ip, lr, ror #2
    16d4:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16d8:	6f6c625f 	svcvs	0x006c625f
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    16dc:	32006b63 	andcc	r6, r0, #101376	; 0x18c00
    16e0:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    thisBlockLen = 0;
    16e4:	7364652f 	cmnvc	r4, #197132288	; 0xbc00000
    16e8:	2e6e6769 	cdpcs	7, 6, cr6, cr14, cr9, {3}
    16ec:	64650063 	strbtvs	r0, [r5], #-99	; 0x63
    16f0:	31353532 	teqcc	r5, r2, lsr r5
    16f4:	72705f39 	rsbsvc	r5, r0, #57, 30	; 0xe4
    16f8:	72617065 	rsbvc	r7, r1, #101	; 0x65
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    16fc:	68730065 	ldmdavs	r3!, {r0, r2, r5, r6}^
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    1700:	32313561 	eorscc	r3, r1, #406847488	; 0x18400000
    1704:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^

    u8 startState = dfuAppStatus.bState;
    1708:	6c616974 	stclvs	9, cr6, [r1], #-464	; 0xfffffe30
    170c:	6174735f 	cmnvs	r4, pc, asr r3
    dfuAppStatus.bStatus = OK;
    1710:	73006574 	movwvc	r6, #1396	; 0x574
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    1714:	31356168 	teqcc	r5, r8, ror #2

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    1718:	65675f32 	strbvs	r5, [r7, #-3890]!	; 0xf32
    171c:	69730074 	ldmdbvs	r3!, {r2, r4, r5, r6}^
            if (pInformation->USBwLengths.w > 0) {
    1720:	74616e67 	strbtvc	r6, [r1], #-3687	; 0xe67
    1724:	00657275 	rsbeq	r7, r5, r5, ror r2
                userFirmwareLen = 0;
    1728:	61707865 	cmnvs	r0, r5, ror #16
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    172c:	6b5f646e 	blvs	17da8ec <_etext+0x17d33d4>
    1730:	6f007965 	svcvs	0x00007965
    1734:	665f7475 			; <UNDEFINED> instruction: 0x665f7475
    1738:	65730070 	ldrbvs	r0, [r3, #-112]!	; 0x70
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    173c:	74657263 	strbtvc	r7, [r5], #-611	; 0x263
						userAppAddr = USER_CODE_FLASH0X8002000;
    1740:	70786500 	rsbsvc	r6, r8, r0, lsl #10
    1744:	65646e61 	strbvs	r6, [r4, #-3681]!	; 0xe61
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    1748:	61700064 	cmnvs	r0, r4, rrx
    174c:	64656b63 	strbtvs	r6, [r5], #-2915	; 0xb63
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    1750:	755f5f00 	ldrbvc	r5, [pc, #-3840]	; 858 <__Stack_Size+0x58>
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1754:	36746e69 	ldrbtcc	r6, [r4], -r9, ror #28
						flashUnlock();
    1758:	00745f34 	rsbseq	r5, r4, r4, lsr pc

						break;
    175c:	66657270 			; <UNDEFINED> instruction: 0x66657270

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    1760:	735f7869 	cmpvc	pc, #6881280	; 0x690000
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1764:	00657a69 	rsbeq	r7, r5, r9, ror #20
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1768:	35326465 	ldrcc	r6, [r2, #-1125]!	; 0x465
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    176c:	5f393135 	svcpl	0x00393135
    1770:	6564726f 	strbvs	r7, [r4, #-623]!	; 0x26f
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    1774:	70660072 	rsbvc	r0, r6, r2, ror r0
    1778:	656d6972 	strbvs	r6, [sp, #-2418]!	; 0x972
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    177c:	6f72665f 	svcvs	0x0072665f
    1780:	79625f6d 	stmdbvc	r2!, {r0, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    1784:	00736574 	rsbseq	r6, r3, r4, ror r5
			
            switch(pInformation->Current_AlternateSetting) {
    1788:	68736168 	ldmdavs	r3!, {r3, r5, r6, r8, sp, lr}^
    178c:	73656d5f 	cmnvc	r5, #6080	; 0x17c0
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1790:	65676173 	strbvs	r6, [r7, #-371]!	; 0x173
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1794:	73616800 	cmnvc	r1, #0, 16
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1798:	69775f68 	ldmdbvs	r7!, {r3, r5, r6, r8, r9, sl, fp, ip, lr}^
					userAppEnd = getFlashEnd();
    179c:	705f6874 	subsvc	r6, pc, r4, ror r8	; <UNPREDICTABLE>
    17a0:	69666572 	stmdbvs	r6!, {r1, r4, r5, r6, r8, sl, sp, lr}^

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    17a4:	64650078 	strbtvs	r0, [r5], #-120	; 0x78
					dfuAppStatus.bStatus = errWRITE;
    17a8:	6e676973 	mcrvs	9, 3, r6, cr7, cr3, {3}
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    17ac:	6365735f 	cmnvs	r5, #2080374785	; 0x7c000001
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17b0:	5f6f745f 	svcpl	0x006f745f
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17b4:	00627570 	rsbeq	r7, r2, r0, ror r5
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    17b8:	705f6d73 	subsvc	r6, pc, r3, ror sp	; <UNPREDICTABLE>
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17bc:	006b6361 	rsbeq	r6, fp, r1, ror #6
    17c0:	35616873 	strbcc	r6, [r1, #-2163]!	; 0x873
    17c4:	735f3231 	cmpvc	pc, #268435459	; 0x10000003

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17c8:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0x174
                dfuCopyBufferToExec();
    17cc:	73646500 	cmnvc	r4, #0, 10
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17d0:	5f6e6769 	svcpl	0x006e6769
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    17d4:	69726576 	ldmdbvs	r2!, {r1, r2, r4, r5, r6, r8, sl, sp, lr}^
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    17d8:	73007966 	movwvc	r7, #2406	; 0x966
    17dc:	31356168 	teqcc	r5, r8, ror #2

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    17e0:	6e695f32 	mcrvs	15, 3, r5, cr9, cr2, {1}
    17e4:	73007469 	movwvc	r7, #1129	; 0x469
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17e8:	31356168 	teqcc	r5, r8, ror #2
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    17ec:	6c625f32 	stclvs	15, cr5, [r2], #-200	; 0xffffff38
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17f0:	006b636f 	rsbeq	r6, fp, pc, ror #6
    17f4:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
    17f8:	7a5f3931 	bvc	17cfcc4 <_etext+0x17c87ac>
            if (pInformation->USBwLengths.w > 0) {
    17fc:	006f7265 	rsbeq	r7, pc, r5, ror #4
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    1800:	32707865 	rsbscc	r7, r0, #6619136	; 0x650000
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    1804:	00333235 	eorseq	r3, r3, r5, lsr r2
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    1808:	31353532 	teqcc	r5, r2, lsr r5
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    180c:	32662f39 	rsbcc	r2, r6, #57, 30	; 0xe4
                }
                switch (ret)
    1810:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    1814:	6600632e 	strvs	r6, [r0], -lr, lsr #6
    1818:	31353532 	teqcc	r5, r2, lsr r5
                {
                    case kImageImageIsTrusted:
                        uart_printf("Uploaded signature verified!\n");
    181c:	6e695f39 	mcrvs	15, 3, r5, cr9, cr9, {1}
                        break;

                    case kImageImageMissingMagic:
                    case kImageImageRejectSignature:
                        uart_printf("Image unverified... wiped memory for clean reset.\n");
    1820:	32660076 	rsbcc	r0, r6, #118	; 0x76
    1824:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
                        break;

                    default:
                        break;
                }
                flashLock();
    1828:	6c756d5f 	ldclvs	13, cr6, [r5], #-380	; 0xfffffe84
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    182c:	6e6f6300 	cdpvs	3, 6, cr6, cr15, cr0, {0}
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1830:	69746964 	ldmdbvs	r4!, {r2, r5, r6, r8, fp, sp, lr}^
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1834:	6d006e6f 	stcvs	14, cr6, [r0, #-444]	; 0xfffffe44
    1838:	73756e69 	cmnvc	r5, #1680	; 0x690
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuMANIFEST_SYNC) {
    183c:	72700070 	rsbsvc	r0, r0, #112	; 0x70
        /* device has received last block, waiting DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1840:	616f6c65 	cmnvs	pc, r5, ror #24
    1844:	79625f64 	stmdbvc	r2!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
            dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    1848:	00736574 	rsbseq	r6, r3, r4, ror r5
            dfuAppStatus.bStatus = OK;
    184c:	6c657270 	sfmvs	f7, 2, [r5], #-448	; 0xfffffe40
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1850:	5f64616f 	svcpl	0x0064616f
    1854:	73746962 	cmnvc	r4, #1605632	; 0x188000
            dfuAppStatus.bState  = dfuMANIFEST_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuMANIFEST) {
    1858:	72706600 	rsbsvc	r6, r0, #0, 12
        /* device is in manifestation phase */

        /* should never receive request while in manifest! */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
        dfuAppStatus.bStatus = OK;
    } else if (startState == dfuMANIFEST_WAIT_RESET) {
    185c:	5f656d69 	svcpl	0x00656d69
        /* device has programmed new firmware but needs external
           usb reset or power on reset to run the new code */

        /* consider timing out and self-resetting */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    } else if (startState == dfuUPLOAD_IDLE) {
    1860:	00766e69 	rsbseq	r6, r6, r9, ror #28
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
    1864:	74696272 	strbtvc	r6, [r9], #-626	; 0x272
    1868:	6c700073 	ldclvs	0, cr0, [r0], #-460	; 0xfffffe34
            if (pInformation->USBwLengths.w > 0) {
    186c:	00617375 	rsbeq	r7, r1, r5, ror r3
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1870:	66696873 			; <UNDEFINED> instruction: 0x66696873
    1874:	5f6e5f74 	svcpl	0x006e5f74
    1878:	73746962 	cmnvc	r4, #1605632	; 0x188000
    187c:	72706600 	rsbsvc	r6, r0, #0, 12
    1880:	5f656d69 	svcpl	0x00656d69
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1884:	656c6573 	strbvs	r6, [ip, #-1395]!	; 0x573
    1888:	66007463 	strvs	r7, [r0], -r3, ror #8
    188c:	6d697270 	sfmvs	f7, 2, [r9, #-448]!	; 0xfffffe40
    1890:	75735f65 	ldrbvc	r5, [r3, #-3941]!	; 0xf65
    1894:	70660062 	rsbvc	r0, r6, r2, rrx
    1898:	656d6972 	strbvs	r6, [sp, #-2418]!	; 0x972
                    thisBlockLen = uploadBlockLen;
    189c:	6464615f 	strbtvs	r6, [r4], #-351	; 0x15f
    18a0:	6e696d00 	cdpvs	13, 6, cr6, cr9, cr0, {0}
                    dfuAppStatus.bState  = dfuUPLOAD_IDLE;
                } else {
                    /* if above comparison was just equal, thisBlockLen becomes zero
                    next time when USBWValue has been increased by one */
                    thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
    18a4:	746e695f 	strbtvc	r6, [lr], #-2399	; 0x95f
    18a8:	646f6d00 	strbtvs	r6, [pc], #-3328	; 18b0 <dfuUpdateByRequest+0x1b4>
    18ac:	73756c75 	cmnvc	r5, #29952	; 0x7500
    18b0:	72706600 	rsbsvc	r6, r0, #0, 12
                    
                    /* check for overflow due to USBwValue out of range */
                    if (thisBlockLen >= pInformation->USBwLengths.w) {
    18b4:	5f656d69 	svcpl	0x00656d69
    18b8:	006c756d 	rsbeq	r7, ip, sp, ror #10
                        thisBlockLen = 0;
    18bc:	69727066 	ldmdbvs	r2!, {r1, r2, r5, r6, ip, sp, lr}^
                    }
                    
                    dfuAppStatus.bState  = dfuIDLE;
                }
            } else {
                dfuAppStatus.bState  = dfuERROR;
    18c0:	7a5f656d 	bvc	17dae7c <_etext+0x17d3964>
                dfuAppStatus.bStatus = errNOTDONE;
    18c4:	006f7265 	rsbeq	r7, pc, r5, ror #4
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    18c8:	5f776172 	svcpl	0x00776172
            dfuAppStatus.bState  = dfuIDLE;
    18cc:	5f797274 	svcpl	0x00797274
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18d0:	00627573 	rsbeq	r7, r2, r3, ror r5
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18d4:	6d697270 	sfmvs	f7, 2, [r9, #-448]!	; 0xfffffe40
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    18d8:	736d5f65 	cmnvc	sp, #404	; 0x194
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuERROR)               {
    18dc:	70660062 	rsbvc	r0, r6, r2, rrx
        /* status is in error, awaiting DFU_CLRSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18e0:	656d6972 	strbvs	r6, [sp, #-2418]!	; 0x972
    18e4:	0071655f 	rsbseq	r6, r1, pc, asr r5
    18e8:	69727066 	ldmdbvs	r2!, {r1, r2, r5, r6, ip, sp, lr}^
            /* todo, add routine to wait for last block write to finish */
            dfuAppStatus.bState  = dfuERROR;
    18ec:	6c5f656d 	cfldr64vs	mvdx6, [pc], {109}	; 0x6d
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18f0:	0064616f 	rsbeq	r6, r4, pc, ror #2
            dfuAppStatus.bState  = dfuERROR;
        } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
    18f4:	69727066 	ldmdbvs	r2!, {r1, r2, r5, r6, ip, sp, lr}^
            /* todo handle any cleanup we need here */
            dfuAppStatus.bState  = dfuIDLE;
    18f8:	635f656d 	cmpvs	pc, #457179136	; 0x1b400000
            dfuAppStatus.bStatus = OK;
    18fc:	0079706f 	rsbseq	r7, r9, pc, rrx
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else {
        /* some kind of error... */
        dfuAppStatus.bState  = dfuERROR;
    1900:	31353532 	teqcc	r5, r2, lsr r5
        dfuAppStatus.bStatus = errSTALLEDPKT;
    1904:	70662f39 	rsbvc	r2, r6, r9, lsr pc
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}
    1908:	656d6972 	strbvs	r6, [sp, #-2418]!	; 0x972
    190c:	7000632e 	andvc	r6, r0, lr, lsr #6
    1910:	6f6c6572 	svcvs	0x006c6572
    1914:	745f6461 	ldrbvc	r6, [pc], #-1121	; 191c <dfuUpdateByRequest+0x220>
    1918:	6c61746f 	cfstrdvs	mvd7, [r1], #-444	; 0xfffffe44
    191c:	72706600 	rsbsvc	r6, r0, #0, 12
    1920:	5f656d69 	svcpl	0x00656d69
    1924:	6d726f6e 	ldclvs	15, cr6, [r2, #-440]!	; 0xfffffe48
    1928:	7a696c61 	bvc	1a5cab4 <_etext+0x1a5559c>
    192c:	61720065 	cmnvs	r2, r5, rrx
    1930:	64615f77 	strbtvs	r5, [r1], #-3959	; 0xf77
    1934:	70660064 	rsbvc	r0, r6, r4, rrx
    1938:	656d6972 	strbvs	r6, [sp, #-2418]!	; 0x972
    193c:	656e6f5f 	strbvs	r6, [lr, #-3935]!	; 0xf5f
    1940:	35353200 	ldrcc	r3, [r5, #-512]!	; 0x200
    1944:	6d2f3931 	stcvs	9, cr3, [pc, #-196]!	; 1888 <dfuUpdateByRequest+0x18c>
    1948:	6870726f 	ldmdavs	r0!, {r0, r1, r2, r3, r5, r6, r9, ip, sp, lr}^
    194c:	31353532 	teqcc	r5, r2, lsr r5
    dfuAppStatus.bState = newState;
}

bool dfuUploadStarted()
{
    return dfuBusy;
    1950:	00632e39 	rsbeq	r2, r3, r9, lsr lr
}
    1954:	756c7079 	strbvc	r7, [ip, #-121]!	; 0x79
    1958:	6f6d0073 	svcvs	0x006d0073

void dfuFinishUpload() {

    while (1)
	{
		__asm__ __volatile__ ("");
    195c:	32687072 	rsbcc	r7, r8, #114	; 0x72
};

/* Conversion to and from projective coordinates */
void ed25519_project(struct ed25519_pt *p,
		     const uint8_t *x, const uint8_t *y)
{
    1960:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    1964:	6d32655f 	cfldr32vs	mvfx6, [r2, #-380]!	; 0xfffffe84
    1968:	32786d00 	rsbscc	r6, r8, #0, 26
    196c:	6d007965 	stcvs	9, cr7, [r0, #-404]	; 0xfffffe6c
    1970:	67746e6f 	ldrbvs	r6, [r4, -pc, ror #28]!
    1974:	72656d6f 	rsbvc	r6, r5, #7104	; 0x1bc0
    1978:	79650079 	stmdbvc	r5!, {r0, r3, r4, r5, r6}^
    197c:	00786532 	rsbseq	r6, r8, r2, lsr r5
    1980:	70726f6d 	rsbsvc	r6, r2, sp, ror #30
    1984:	35353268 	ldrcc	r3, [r5, #-616]!	; 0x268
    1988:	6d5f3931 	ldclvs	9, cr3, [pc, #-196]	; 18cc <dfuUpdateByRequest+0x1d0>
    198c:	79006532 	stmdbvc	r0, {r1, r4, r5, r8, sl, sp, lr}
    1990:	756e696d 	strbvc	r6, [lr, #-2413]!	; 0x96d
    1994:	736d0073 	cmnvc	sp, #115	; 0x73
    1998:	6e656c67 	cdpvs	12, 6, cr6, cr5, cr7, {3}
    199c:	66656c00 	strbtvs	r6, [r5], -r0, lsl #24
    19a0:	69660074 	stmdbvs	r6!, {r2, r4, r5, r6}^
    19a4:	73006c6c 	movwvc	r6, #3180	; 0xc6c
    19a8:	35326168 	ldrcc	r6, [r2, #-360]!	; 0x168
    19ac:	69665f36 	stmdbvs	r6!, {r1, r2, r4, r5, r8, r9, sl, fp, ip, lr}^
    19b0:	6873696e 	ldmdavs	r3!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
    19b4:	64617000 	strbtvs	r7, [r1], #-0
    19b8:	6968006e 	stmdbvs	r8!, {r1, r2, r3, r5, r6}^
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
    19bc:	32006867 	andcc	r6, r0, #6750208	; 0x670000
	f25519_mul__distinct(p->t, x, y);
    19c0:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    19c4:	6168732f 	cmnvs	r8, pc, lsr #6
}
    19c8:	2e363532 	mrccs	5, 1, r3, cr6, cr2, {1}
		     const uint8_t *x, const uint8_t *y)
{
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
	f25519_mul__distinct(p->t, x, y);
    19cc:	68730063 	ldmdavs	r3!, {r0, r1, r5, r6}^
}

void ed25519_unproject(uint8_t *x, uint8_t *y,
		       const struct ed25519_pt *p)
{
    19d0:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
    19d4:	6f72705f 	svcvs	0x0072705f
    19d8:	73736563 	cmnvc	r3, #415236096	; 0x18c00000
	uint8_t z1[F25519_SIZE];

	f25519_inv__distinct(z1, p->z);
    19dc:	61687300 	cmnvs	r8, r0, lsl #6
    19e0:	5f363532 	svcpl	0x00363532
	f25519_mul__distinct(x, p->x, z1);
    19e4:	61647075 	smcvs	18181	; 0x4705
    19e8:	74006574 	strvc	r6, [r0], #-1396	; 0x574
    19ec:	31706d65 	cmncc	r0, r5, ror #26
	f25519_mul__distinct(y, p->y, z1);
    19f0:	6d657400 	cfstrdvs	mvd7, [r5, #-0]
    19f4:	73003270 	movwvc	r3, #624	; 0x270
    19f8:	35326168 	ldrcc	r6, [r2, #-360]!	; 0x168

	f25519_normalize(x);
    19fc:	61705f36 	cmnvs	r0, r6, lsr pc
	f25519_normalize(y);
    1a00:	6e696464 	cdpvs	4, 6, cr6, cr9, cr4, {3}
    1a04:	69640067 	stmdbvs	r4!, {r0, r1, r2, r5, r6}^
}
    1a08:	74736567 	ldrbtvc	r6, [r3], #-1383	; 0x567
	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
};

void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y)
{
    1a0c:	73616c00 	cmnvc	r1, #0, 24
    1a10:	6f740074 	svcvs	0x00740074
    1a14:	5f6c6174 	svcpl	0x006c6174
    1a18:	657a6973 	ldrbvs	r6, [sl, #-2419]!	; 0x973
    1a1c:	31697700 	cmncc	r9, r0, lsl #14
    1a20:	616c0035 	cmnvs	ip, r5, lsr r0
    1a24:	735f7473 	cmpvc	pc, #1929379840	; 0x73000000
    1a28:	00657a69 	rsbeq	r7, r5, r9, ror #20
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
    1a2c:	7366666f 	cmnvc	r6, #116391936	; 0x6f00000
    1a30:	74007465 	strvc	r7, [r0], #-1125	; 0x465
    1a34:	00706d65 	rsbseq	r6, r0, r5, ror #26
    1a38:	36746f72 	uhsub16cc	r6, r4, r2
    1a3c:	74730034 	ldrbtvc	r0, [r3], #-52	; 0x34
    1a40:	3665726f 	strbtcc	r7, [r5], -pc, ror #4
    1a44:	35320034 	ldrcc	r0, [r2, #-52]!	; 0x34
    1a48:	2f393135 	svccs	0x00393135
    1a4c:	35616873 	strbcc	r6, [r1, #-2163]!	; 0x873
    1a50:	632e3231 	teqvs	lr, #268435459	; 0x10000003
	parity = (tmp[0] & 1) << 7;
    1a54:	616f6c00 	cmnvs	pc, r0, lsl #24

	f25519_copy(c, y);
	f25519_normalize(c);
    1a58:	00343664 	eorseq	r3, r4, r4, ror #12
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1a5c:	6e756f72 	mrcvs	15, 3, r6, cr5, cr2, {3}
    1a60:	006b5f64 	rsbeq	r5, fp, r4, ror #30

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1a64:	67616d69 	strbvs	r6, [r1, -r9, ror #26]!
}
    1a68:	00632e65 	rsbeq	r2, r3, r5, ror #28

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1a6c:	64616568 	strbtvs	r6, [r1], #-1384	; 0x568
    1a70:	6d007265 	sfmvs	f7, 4, [r0, #-404]	; 0xfffffe6c
    1a74:	656d6d65 	strbvs	r6, [sp, #-3429]!	; 0xd65
    1a78:	656e006d 	strbvs	r0, [lr, #-109]!	; 0x6d
	const int parity = comp[31] >> 7;
    1a7c:	6e614877 	mcrvs	8, 3, r4, cr1, cr7, {3}
    1a80:	00656c64 	rsbeq	r6, r5, r4, ror #24
    1a84:	67616d49 	strbvs	r6, [r1, -r9, asr #26]!
    1a88:	6f6f5265 	svcvs	0x006f5265
    1a8c:	61654874 	smcvs	21636	; 0x5484
    1a90:	00726564 	rsbseq	r6, r2, r4, ror #10
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1a94:	6967616d 	stmdbvs	r7!, {r0, r2, r3, r5, r6, r8, sp, lr}^
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1a98:	6d630063 	stclvs	0, cr0, [r3, #-396]!	; 0xfffffe74
    1a9c:	646e4570 	strbtvs	r4, [lr], #-1392	; 0x570
    1aa0:	74616400 	strbtvc	r6, [r1], #-1024	; 0x400
    1aa4:	7a695361 	bvc	1a56830 <_etext+0x1a4f318>
    1aa8:	75620065 	strbvc	r0, [r2, #-101]!	; 0x65
	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
	f25519_add(a, b, f25519_one);
    1aac:	69536666 	ldmdbvs	r3, {r1, r2, r5, r6, r9, sl, sp, lr}^
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1ab0:	6900657a 	stmdbvs	r0, {r1, r3, r4, r5, r6, r8, sl, sp, lr}

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
    1ab4:	6567616d 	strbvs	r6, [r7, #-365]!	; 0x16d
    1ab8:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
	f25519_add(a, b, f25519_one);
    1abc:	616c6600 	cmnvs	ip, r0, lsl #12
    1ac0:	64416873 	strbvs	r6, [r1], #-2163	; 0x873
    1ac4:	73657264 	cmnvc	r5, #100, 4	; 0x40000006
	f25519_inv__distinct(b, a);
    1ac8:	69730073 	ldmdbvs	r3!, {r0, r1, r4, r5, r6}^
    1acc:	6e696e67 	cdpvs	14, 6, cr6, cr9, cr7, {3}

	/* Compute a = y^2-1 */
	f25519_sub(a, c, f25519_one);
    1ad0:	6f720067 	svcvs	0x00720067
    1ad4:	4143746f 	cmpmi	r3, pc, ror #8

	/* Compute c = a*b = (y^2-1)/(1-dy^2) */
	f25519_mul__distinct(c, a, b);
    1ad8:	616d4900 	cmnvs	sp, r0, lsl #18
    1adc:	69536567 	ldmdbvs	r3, {r0, r1, r2, r5, r6, r8, sl, sp, lr}^
    1ae0:	6e696e67 	cdpvs	14, 6, cr6, cr9, cr7, {3}

	/* Compute a, b = +/-sqrt(c), if c is square */
	f25519_sqrt(a, c);
    1ae4:	74784567 	ldrbtvc	r4, [r8], #-1383	; 0x567
    1ae8:	69736e65 	ldmdbvs	r3!, {r0, r2, r5, r6, r9, sl, fp, sp, lr}^
	f25519_neg(b, a);
    1aec:	69006e6f 	stmdbvs	r0, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}
    1af0:	6567616d 	strbvs	r6, [r7, #-365]!	; 0x16d

	/* Select one of them, based on the compressed parity bit */
	f25519_select(x, a, b, (a[0] ^ parity) & 1);
    1af4:	66667542 	strbtvs	r7, [r6], -r2, asr #10
    1af8:	73007265 	movwvc	r7, #613	; 0x265
    1afc:	6c756f68 	ldclvs	15, cr6, [r5], #-416	; 0xfffffe60
    1b00:	61724564 	cmnvs	r2, r4, ror #10
    1b04:	6c466573 	cfstr64vs	mvdx6, [r6], {115}	; 0x73

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
    1b08:	4f687361 	svcmi	0x00687361
    1b0c:	6961466e 	stmdbvs	r1!, {r1, r2, r3, r5, r6, r9, sl, lr}^
    1b10:	6973006c 	ldmdbvs	r3!, {r2, r3, r5, r6}^
	f25519_normalize(a);
    1b14:	66756267 	ldrbtvs	r6, [r5], -r7, ror #4
	f25519_normalize(c);
    1b18:	75620066 	strbvc	r0, [r2, #-102]!	; 0x66
    1b1c:	72656666 	rsbvc	r6, r5, #106954752	; 0x6600000

	return f25519_eq(a, c);
    1b20:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
    1b24:	696e7500 	stmdbvs	lr!, {r8, sl, ip, sp, lr}^
}
    1b28:	49657571 	stmdbmi	r5!, {r0, r4, r5, r6, r8, sl, ip, sp, lr}^
    1b2c:	6d690044 	stclvs	0, cr0, [r9, #-272]!	; 0xfffffef0
    1b30:	53656761 	cmnpl	r5, #25427968	; 0x1840000
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1b34:	616e6769 	cmnvs	lr, r9, ror #14
    1b38:	65727574 	ldrbvs	r7, [r2, #-1396]!	; 0x574
    1b3c:	69616600 	stmdbvs	r1!, {r9, sl, sp, lr}^
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b40:	6172456c 	cmnvs	r2, ip, ror #10
    1b44:	49006573 	stmdbmi	r0, {r0, r1, r4, r5, r6, r8, sl, sp, lr}
    1b48:	6567616d 	strbvs	r6, [r7, #-365]!	; 0x16d
	f25519_sub(d, p2->y, p2->x);
    1b4c:	64616548 	strbtvs	r6, [r1], #-1352	; 0x548
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b50:	46007265 	strmi	r7, [r0], -r5, ror #4
	f25519_sub(d, p2->y, p2->x);
    1b54:	55656572 	strbpl	r6, [r5, #-1394]!	; 0x572
    1b58:	42726573 	rsbsmi	r6, r2, #482344960	; 0x1cc00000
	f25519_mul__distinct(a, c, d);
    1b5c:	65666675 	strbvs	r6, [r6, #-1653]!	; 0x675
    1b60:	65470072 	strbvs	r0, [r7, #-114]	; 0x72
    1b64:	53785474 	cmnpl	r8, #116, 8	; 0x74000000

	/* B = (Y1+X1)(Y2+X2) */
	f25519_add(c, p1->y, p1->x);
    1b68:	6c6c6174 	stfvse	f6, [ip], #-464	; 0xfffffe30
    1b6c:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
	f25519_add(d, p2->y, p2->x);
    1b70:	53007375 	movwpl	r7, #885	; 0x375
    1b74:	50457465 	subpl	r7, r5, r5, ror #8
    1b78:	426c6244 	rsbmi	r6, ip, #68, 4	; 0x40000004
	f25519_mul__distinct(b, c, d);
    1b7c:	41316675 	teqmi	r1, r5, ror r6
    1b80:	00726464 	rsbseq	r6, r2, r4, ror #8

	/* C = T1 k T2 */
	f25519_mul__distinct(d, p1->t, p2->t);
    1b84:	45746553 	ldrbmi	r6, [r4, #-1363]!	; 0x553
    1b88:	56785450 			; <UNDEFINED> instruction: 0x56785450
    1b8c:	64696c61 	strbtvs	r6, [r9], #-3169	; 0xc61
    1b90:	74655300 	strbtvc	r5, [r5], #-768	; 0x300
	f25519_mul__distinct(c, d, ed25519_k);
    1b94:	42756f44 	rsbsmi	r6, r5, #68, 30	; 0x110
    1b98:	7542656c 	strbvc	r6, [r2, #-1388]	; 0x56c

	/* D = Z1 2 Z2 */
	f25519_mul__distinct(d, p1->z, p2->z);
    1b9c:	50456666 	subpl	r6, r5, r6, ror #12
    1ba0:	6c617453 	cfstrdvs	mvd7, [r1], #-332	; 0xfffffeb4
    1ba4:	5045006c 	subpl	r0, r5, ip, rrx
    1ba8:	5542445f 	strbpl	r4, [r2, #-1119]	; 0x45f
	f25519_add(d, d, d);
    1bac:	554f5f46 	strbpl	r5, [pc, #-3910]	; c6e <usbReset+0x92>
    1bb0:	65470054 	strbvs	r0, [r7, #-84]	; 0x54

	/* E = B - A */
	f25519_sub(e, b, a);
    1bb4:	52504574 	subspl	r4, r0, #116, 10	; 0x1d000000
    1bb8:	61745378 	cmnvs	r4, r8, ror r3
    1bbc:	00737574 	rsbseq	r7, r3, r4, ror r5

	/* F = D - C */
	f25519_sub(f, d, c);
    1bc0:	67676f54 			; <UNDEFINED> instruction: 0x67676f54
    1bc4:	5444656c 	strbpl	r6, [r4], #-1388	; 0x56c

	/* G = D + C */
	f25519_add(g, d, c);
    1bc8:	545f474f 	ldrbpl	r4, [pc], #-1871	; 1bd0 <ed25519_add+0x9c>
    1bcc:	65470058 	strbvs	r0, [r7, #-88]	; 0x58
    1bd0:	41504574 	cmpmi	r0, r4, ror r5

	/* H = B + A */
	f25519_add(h, b, a);
    1bd4:	65726464 	ldrbvs	r6, [r2, #-1124]!	; 0x464
    1bd8:	5f007373 	svcpl	0x00007373

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1bdc:	445f5045 	ldrbmi	r5, [pc], #-69	; 1be4 <ed25519_add+0xb0>
    1be0:	5f465542 	svcpl	0x00465542
    1be4:	00524944 	subseq	r4, r2, r4, asr #18

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1be8:	49746553 	ldmdbmi	r4!, {r0, r1, r4, r6, r8, sl, sp, lr}^
    1bec:	00525453 	subseq	r5, r2, r3, asr r4
    1bf0:	65747942 	ldrbvs	r7, [r4, #-2370]!	; 0x942

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1bf4:	70617753 	rsbvc	r7, r1, r3, asr r7
    1bf8:	424e7700 	submi	r7, lr, #0, 14
    1bfc:	6b636f6c 	blvs	18dd9b4 <_etext+0x18d649c>

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1c00:	6c430073 	mcrrvs	0, 7, r0, r3, cr3
    1c04:	44726165 	ldrbtmi	r6, [r2], #-357	; 0x165
    1c08:	5f474f54 	svcpl	0x00474f54
}
    1c0c:	62005852 	andvs	r5, r0, #5373952	; 0x520000
    1c10:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1c14:	74654700 	strbtvc	r4, [r5], #-1792	; 0x700
    1c18:	52544e43 	subspl	r4, r4, #1072	; 0x430

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1c1c:	74654700 	strbtvc	r4, [r5], #-1792	; 0x700
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1c20:	74537852 	ldrbvc	r7, [r3], #-2130	; 0x852
    1c24:	536c6c61 	cmnpl	ip, #24832	; 0x6100

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1c28:	75746174 	ldrbvc	r6, [r4, #-372]!	; 0x174
    1c2c:	65470073 	strbvs	r0, [r7, #-115]	; 0x73
    1c30:	44414474 	strbmi	r4, [r1], #-1140	; 0x474

	/* C = 2 Z1^2 */
	f25519_mul__distinct(c, p->z, p->z);
    1c34:	77005244 	strvc	r5, [r0, -r4, asr #4]
    1c38:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    1c3c:	65530074 	ldrbvs	r0, [r3, #-116]	; 0x74
	f25519_add(c, c, c);
    1c40:	41504574 	cmpmi	r0, r4, ror r5
    1c44:	65726464 	ldrbvs	r6, [r2, #-1124]!	; 0x464

	/* D = a A (alter sign) */
	/* E = (X1+Y1)^2-A-B */
	f25519_add(f, p->x, p->y);
    1c48:	53007373 	movwpl	r7, #883	; 0x373
    1c4c:	50457465 	subpl	r7, r5, r5, ror #8
    1c50:	74537852 	ldrbvc	r7, [r3], #-2130	; 0x852
	f25519_mul__distinct(e, f, f);
    1c54:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    1c58:	676f5400 	strbvs	r5, [pc, -r0, lsl #8]!
	f25519_sub(e, e, a);
    1c5c:	44656c67 	strbtmi	r6, [r5], #-3175	; 0xc67
    1c60:	5f474f54 	svcpl	0x00474f54
    1c64:	53005852 	movwpl	r5, #2130	; 0x852
	f25519_sub(e, e, b);
    1c68:	50457465 	subpl	r7, r5, r5, ror #8
    1c6c:	426c6244 	rsbmi	r6, ip, #68, 4	; 0x40000004

	/* G = D + B */
	f25519_sub(g, b, a);
    1c70:	41666675 	smcmi	26213	; 0x6665
    1c74:	00726464 	rsbseq	r6, r2, r4, ror #8
    1c78:	45746553 	ldrbmi	r6, [r4, #-1363]!	; 0x553

	/* F = G - C */
	f25519_sub(f, g, c);
    1c7c:	70795450 	rsbsvc	r5, r9, r0, asr r4
    1c80:	50450065 	subpl	r0, r5, r5, rrx

	/* H = D - B */
	f25519_neg(h, b);
    1c84:	5542445f 	strbpl	r4, [r2, #-1119]	; 0x45f
    1c88:	4e495f46 	cdpmi	15, 4, cr5, cr9, cr6, {2}
	f25519_sub(h, h, a);
    1c8c:	65527700 	ldrbvs	r7, [r2, #-1792]	; 0x700
    1c90:	65470074 	strbvs	r0, [r7, #-116]	; 0x74
    1c94:	52504574 	subspl	r4, r0, #116, 10	; 0x1d000000

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1c98:	64644178 	strbtvs	r4, [r4], #-376	; 0x178
    1c9c:	65530072 	ldrbvs	r0, [r3, #-114]	; 0x72

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1ca0:	44504574 	ldrbmi	r4, [r0], #-1396	; 0x574
    1ca4:	75426c62 	strbvc	r6, [r2, #-3170]	; 0xc62
    1ca8:	64413066 	strbvs	r3, [r1], #-102	; 0x66

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1cac:	47007264 	strmi	r7, [r0, -r4, ror #4]
    1cb0:	50457465 	subpl	r7, r5, r5, ror #8
    1cb4:	74537854 	ldrbvc	r7, [r3], #-2132	; 0x854

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1cb8:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    1cbc:	69446200 	stmdbvs	r4, {r9, sp, lr}^
    1cc0:	54770072 	ldrbtpl	r0, [r7], #-114	; 0x72
}
    1cc4:	00657079 	rsbeq	r7, r5, r9, ror r0

void ed25519_smult(struct ed25519_pt *r_out, const struct ed25519_pt *p,
		   const uint8_t *e)
{
    1cc8:	5f627375 	svcpl	0x00627375
    1ccc:	2f62696c 	svccs	0x0062696c
    1cd0:	5f627375 	svcpl	0x00627375
    1cd4:	73676572 	cmnvc	r7, #478150656	; 0x1c800000
    1cd8:	4500632e 	strmi	r6, [r0, #-814]	; 0x32e
    1cdc:	42445f50 	submi	r5, r4, #80, 30	; 0x140
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1ce0:	455f4655 	ldrbmi	r4, [pc, #-1621]	; 1693 <dfuCopyUPLOAD+0x27>
    1ce4:	47005252 	smlsdmi	r0, r2, r2, r5
    1ce8:	50457465 	subpl	r7, r5, r5, ror #8
		struct ed25519_pt s;

		ed25519_double(&r, &r);
    1cec:	426c6244 	rsbmi	r6, ip, #68, 4	; 0x40000004
    1cf0:	69446675 	stmdbvs	r4, {r0, r2, r4, r5, r6, r9, sl, sp, lr}^
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1cf4:	42770072 	rsbsmi	r0, r7, #114	; 0x72
		struct ed25519_pt s;

		ed25519_double(&r, &r);
		ed25519_add(&s, &r, p);
    1cf8:	41316675 	teqmi	r1, r5, ror r6
    1cfc:	00726464 	rsbseq	r6, r2, r4, ror #8

		f25519_select(r.x, r.x, s.x, bit);
    1d00:	57775377 			; <UNDEFINED> instruction: 0x57775377
    1d04:	74655300 	strbtvc	r5, [r5], #-768	; 0x300
    1d08:	6f445045 	svcvs	0x00445045
		f25519_select(r.y, r.y, s.y, bit);
    1d0c:	656c6275 	strbvs	r6, [ip, #-629]!	; 0x275
    1d10:	66667542 	strbtvs	r7, [r6], -r2, asr #10
    1d14:	576f5400 	strbpl	r5, [pc, -r0, lsl #8]!
		f25519_select(r.z, r.z, s.z, bit);
    1d18:	0064726f 	rsbeq	r7, r4, pc, ror #4
    1d1c:	45746553 	ldrbmi	r6, [r4, #-1363]!	; 0x553
    1d20:	41785450 	cmnmi	r8, r0, asr r4
		f25519_select(r.t, r.t, s.t, bit);
    1d24:	00726464 	rsbseq	r6, r2, r4, ror #8
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d28:	61656c43 	cmnvs	r5, r3, asr #24
		ed25519_add(&s, &r, p);

		f25519_select(r.x, r.x, s.x, bit);
		f25519_select(r.y, r.y, s.y, bit);
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
    1d2c:	44504572 	ldrbmi	r4, [r0], #-1394	; 0x572
    1d30:	6c62756f 	cfstr64vs	mvdx7, [r2], #-444	; 0xfffffe44
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d34:	66754265 	ldrbtvs	r4, [r5], -r5, ror #4
    1d38:	65470066 	strbvs	r0, [r7, #-102]	; 0x66
    1d3c:	44504574 	ldrbmi	r4, [r0], #-1396	; 0x574
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
	}

	ed25519_copy(r_out, &r);
}
    1d40:	75426c62 	strbvc	r6, [r2, #-3170]	; 0xc62
    1d44:	64413166 	strbvs	r3, [r1], #-358	; 0x166
    1d48:	47007264 	strmi	r7, [r0, -r4, ror #4]
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1d4c:	50457465 	subpl	r7, r5, r5, ror #8
    1d50:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
    1d54:	656c4300 	strbvs	r4, [ip, #-768]!	; 0x300
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d58:	50457261 	subpl	r7, r5, r1, ror #4
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1d5c:	5254435f 	subspl	r4, r4, #2080374785	; 0x7c000001
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d60:	0058525f 	subseq	r5, r8, pc, asr r2
    1d64:	45746553 	ldrbmi	r6, [r4, #-1363]!	; 0x553
    1d68:	6c624450 	cfstrdvs	mvd4, [r2], #-320	; 0xfffffec0
    1d6c:	66667542 	strbtvs	r7, [r6], -r2, asr #10
	memcpy(block + 32, a, 32);
    1d70:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    1d74:	65530074 	ldrbvs	r0, [r3, #-116]	; 0x74
    1d78:	5f504574 	svcpl	0x00504574
    1d7c:	444e494b 	strbmi	r4, [lr], #-2379	; 0x94b
    1d80:	74655300 	strbtvc	r5, [r5], #-768	; 0x300
    1d84:	78545045 	ldmdavc	r4, {r0, r2, r6, ip, lr}^
    1d88:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    1d8c:	6c430074 	mcrrvs	0, 7, r0, r3, cr4
    1d90:	45726165 	ldrbmi	r6, [r2, #-357]!	; 0x165
    1d94:	494b5f50 	stmdbmi	fp, {r4, r6, r8, r9, sl, fp, ip, lr}^
    1d98:	4700444e 	strmi	r4, [r0, -lr, asr #8]
    1d9c:	54427465 	strbpl	r7, [r2], #-1125	; 0x465
{
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
    1da0:	454c4241 	strbmi	r4, [ip, #-577]	; 0x241
    1da4:	74654700 	strbtvc	r4, [r5], #-1792	; 0x700
    1da8:	52545349 	subspl	r5, r4, #603979777	; 0x24000001
		memcpy(init_block + prefix_size, message, len);
		sha512_final(&s, init_block, len + prefix_size);
	} else {
		size_t i;

		memcpy(init_block + prefix_size, message,
    1dac:	65527700 	ldrbvs	r7, [r2, #-1792]	; 0x700
    1db0:	6c615667 	stclvs	6, cr5, [r1], #-412	; 0xfffffe64
    1db4:	47006575 	smlsdxmi	r0, r5, r5, r6
    1db8:	4e457465 	cdpmi	4, 4, cr7, cr5, cr5, {3}
    1dbc:	494f5044 	stmdbmi	pc, {r2, r6, ip, lr}^	; <UNPREDICTABLE>
    1dc0:	7700544e 	strvc	r5, [r0, -lr, asr #8]
    1dc4:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);
    1dc8:	74654700 	strbtvc	r4, [r5], #-1792	; 0x700
    1dcc:	62445045 	subvs	r5, r4, #69	; 0x45

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dd0:	6675426c 	ldrbtvs	r4, [r5], -ip, ror #4
    1dd4:	756f4330 	strbvc	r4, [pc, #-816]!	; 1aac <ed25519_try_unpack+0x40>
    1dd8:	5300746e 	movwpl	r7, #1134	; 0x46e
    1ddc:	41447465 	cmpmi	r4, r5, ror #8
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1de0:	00524444 	subseq	r4, r2, r4, asr #8
		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
		     i + SHA512_BLOCK_SIZE <= len;
    1de4:	52776470 	rsbspl	r6, r7, #112, 8	; 0x70000000
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1de8:	53006765 	movwpl	r6, #1893	; 0x765

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dec:	50457465 	subpl	r7, r5, r5, ror #8
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
    1df0:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    1df4:	52785274 	rsbspl	r5, r8, #116, 4	; 0x40000007
    1df8:	47006765 	strmi	r6, [r0, -r5, ror #14]
    1dfc:	50457465 	subpl	r7, r5, r5, ror #8
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
		memcpy(init_block + prefix_size, message, len);
    1e00:	6f437852 	svcvs	0x00437852
    1e04:	00746e75 	rsbseq	r6, r4, r5, ror lr
    1e08:	6d655462 	cfstrdvs	mvd5, [r5, #-392]!	; 0xfffffe78
		sha512_final(&s, init_block, len + prefix_size);
    1e0c:	65530070 	ldrbvs	r0, [r3, #-112]	; 0x70
    1e10:	544e4374 	strbpl	r4, [lr], #-884	; 0x374
    1e14:	65530052 	ldrbvs	r0, [r3, #-82]	; 0x52
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
	}

	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
    1e18:	41544274 	cmpmi	r4, r4, ror r2
    1e1c:	00454c42 	subeq	r4, r5, r2, asr #24
    1e20:	45746547 	ldrbmi	r6, [r4, #-1351]!	; 0x547
	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
    1e24:	43785450 	cmnmi	r8, #80, 8	; 0x50000000
    1e28:	746e756f 	strbtvc	r7, [lr], #-1391	; 0x56f
    1e2c:	656c4300 	strbvs	r4, [ip, #-768]!	; 0x300

static void sm_pack(uint8_t *r, const uint8_t *k)
{
	struct ed25519_pt p;

	ed25519_smult(&p, &ed25519_base, k);
    1e30:	50457261 	subpl	r7, r5, r1, ror #4
    1e34:	5254435f 	subspl	r4, r4, #2080374785	; 0x7c000001
    1e38:	0058545f 	subseq	r5, r8, pc, asr r4
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1e3c:	45746547 	ldrbmi	r6, [r4, #-1351]!	; 0x547
    1e40:	6c624450 	cfstrdvs	mvd4, [r2], #-320	; 0xfffffec0
	ed25519_pack(packed, x, y);
    1e44:	31667542 	cmncc	r6, r2, asr #10
    1e48:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
    1e4c:	65530074 	ldrbvs	r0, [r3, #-116]	; 0x74

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e50:	44504574 	ldrbmi	r4, [r0], #-1396	; 0x574
    1e54:	75426c62 	strbvc	r6, [r2, #-3170]	; 0xc62

	ed25519_project(p, x, y);
    1e58:	6f433066 	svcvs	0x00433066
    1e5c:	00746e75 	rsbseq	r6, r4, r5, ror lr
    1e60:	66754277 			; <UNDEFINED> instruction: 0x66754277
	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
    1e64:	64644130 	strbtvs	r4, [r4], #-304	; 0x130
    1e68:	65530072 	ldrbvs	r0, [r3, #-114]	; 0x72
    1e6c:	74535f74 	ldrbvc	r5, [r3], #-3956	; 0xf74

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e70:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    1e74:	74754f5f 	ldrbtvc	r4, [r5], #-3935	; 0xf5f

	ed25519_project(p, x, y);
    1e78:	74654700 	strbtvc	r4, [r5], #-1792	; 0x700
    1e7c:	00524e46 	subseq	r4, r2, r6, asr #28
    1e80:	45746547 	ldrbmi	r6, [r4, #-1351]!	; 0x547

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
    1e84:	6c624450 	cfstrdvs	mvd4, [r2], #-320	; 0xfffffec0
    1e88:	30667542 	rsbcc	r7, r6, r2, asr #10
    1e8c:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1e90:	646e4500 	strbtvs	r4, [lr], #-1280	; 0x500
    1e94:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
	ed25519_pack(packed, x, y);
    1e98:	54445f74 	strbpl	r5, [r4], #-3956	; 0xf74
    1e9c:	535f474f 	cmppl	pc, #20709376	; 0x13c0000
    1ea0:	75746174 	ldrbvc	r6, [r4, #-372]!	; 0x174
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
    1ea4:	65470073 	strbvs	r0, [r7, #-115]	; 0x73
    1ea8:	54504574 	ldrbpl	r4, [r0], #-1396	; 0x574
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
    1eac:	64644178 	strbtvs	r4, [r4], #-376	; 0x178
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
}
    1eb0:	6c430072 	mcrrvs	0, 7, r0, r3, cr2
    1eb4:	44726165 	ldrbtmi	r6, [r2], #-357	; 0x165

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1eb8:	5f474f54 	svcpl	0x00474f54
    1ebc:	53005854 	movwpl	r5, #2132	; 0x854
    1ec0:	50457465 	subpl	r7, r5, r5, ror #8
    1ec4:	74537854 	ldrbvc	r7, [r3], #-2132	; 0x854

const uint8_t f25519_zero[F25519_SIZE] = {0};
const uint8_t f25519_one[F25519_SIZE] = {1};

void f25519_load(uint8_t *x, uint32_t c)
{
    1ec8:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
		c >>= 8;
    1ecc:	70456200 	subvc	r6, r5, r0, lsl #4
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    1ed0:	006d754e 	rsbeq	r7, sp, lr, asr #10
    1ed4:	45746553 	ldrbmi	r6, [r4, #-1363]!	; 0x553
    1ed8:	4f50444e 	svcmi	0x0050444e
    1edc:	00544e49 	subseq	r4, r4, r9, asr #28
		c >>= 8;
	}

	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}
    1ee0:	45746553 	ldrbmi	r6, [r4, #-1363]!	; 0x553
    1ee4:	41785250 	cmnmi	r8, r0, asr r2

void f25519_normalize(uint8_t *x)
{
    1ee8:	00726464 	rsbseq	r6, r2, r4, ror #8
    1eec:	45746553 	ldrbmi	r6, [r4, #-1363]!	; 0x553
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1ef0:	6c624450 	cfstrdvs	mvd4, [r2], #-320	; 0xfffffec0
	x[31] &= 127;
    1ef4:	31667542 	cmncc	r6, r2, asr #10

	for (i = 0; i < F25519_SIZE; i++) {
    1ef8:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1efc:	54430074 	strbpl	r0, [r3], #-116	; 0x74
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
		c += x[i];
    1f00:	50485f52 	subpl	r5, r8, r2, asr pc
		x[i] = c;
    1f04:	74655300 	strbtvc	r5, [r5], #-768	; 0x300

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1f08:	5f307075 	svcpl	0x00307075
		c += x[i];
		x[i] = c;
		c >>= 8;
    1f0c:	636f7250 	cmnvs	pc, #80, 4

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1f10:	00737365 	rsbseq	r7, r3, r5, ror #6
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += x[i];
    1f14:	65766153 	ldrbvs	r6, [r6, #-339]!	; 0x153
		minusp[i] = c;
    1f18:	61745352 	cmnvs	r4, r2, asr r3
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1f1c:	53006574 	movwpl	r6, #1396	; 0x574
		c += x[i];
		minusp[i] = c;
		c >>= 8;
    1f20:	54657661 	strbtpl	r7, [r5], #-1633	; 0x661
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1f24:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1f28:	45770065 	ldrbmi	r0, [r7, #-101]!	; 0x65
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1f2c:	6c615650 	stclvs	6, cr5, [r1], #-320	; 0xfffffec0

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1f30:	62737500 	rsbsvs	r7, r3, #0, 10
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;
    1f34:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1f38:	6273752f 	rsbsvs	r7, r3, #197132288	; 0xbc00000
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    1f3c:	746e695f 	strbtvc	r6, [lr], #-2399	; 0x95f
    1f40:	4900632e 	stmdbmi	r0, {r1, r2, r3, r5, r8, r9, sp, lr}
    1f44:	505f306e 	subspl	r3, pc, lr, rrx
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1f48:	65636f72 	strbvs	r6, [r3, #-3954]!	; 0xf72
    1f4c:	4f007373 	svcmi	0x00007373
	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;

	/* Load x-p if no underflow */
	f25519_select(x, minusp, x, (c >> 15) & 1);
}
    1f50:	5f307475 	svcpl	0x00307475
    1f54:	636f7250 	cmnvs	pc, #80, 4

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
    1f58:	00737365 	rsbseq	r7, r3, r5, ror #6
    1f5c:	6e695045 	cdpvs	0, 6, cr5, cr9, cr5, {2}
    1f60:	00786564 	rsbseq	r6, r8, r4, ror #10
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    1f64:	65766153 	ldrbvs	r6, [r6, #-339]!	; 0x153
    1f68:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
    1f6c:	73750065 	cmnvc	r5, #101	; 0x65
    1f70:	696c5f62 	stmdbvs	ip!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    1f74:	73752f62 	cmnvc	r5, #392	; 0x188
    1f78:	6e695f62 	cdpvs	15, 6, cr5, cr9, cr2, {3}
    1f7c:	632e7469 	teqvs	lr, #1761607680	; 0x69000000
    1f80:	73557000 	cmpvc	r5, #0
    1f84:	535f7265 	cmppl	pc, #1342177286	; 0x50000006
    1f88:	646e6174 	strbtvs	r6, [lr], #-372	; 0x174
    1f8c:	5f647261 	svcpl	0x00647261
    1f90:	75716552 	ldrbvc	r6, [r1, #-1362]!	; 0x552
    1f94:	73747365 	cmnvc	r4, #-1811939327	; 0x94000001
    1f98:	76654400 	strbtvc	r4, [r5], -r0, lsl #8
    1f9c:	5f656369 	svcpl	0x00656369
    1fa0:	6f666e49 	svcvs	0x00666e49
    1fa4:	62737500 	rsbsvs	r7, r3, #0, 10
    1fa8:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
    1fac:	6273752f 	rsbsvs	r7, r3, #197132288	; 0xbc00000
    1fb0:	726f635f 	rsbvc	r6, pc, #2080374785	; 0x7c000001
    1fb4:	00632e65 	rsbeq	r2, r3, r5, ror #28
    1fb8:	50444e45 	subpl	r4, r4, r5, asr #28
    1fbc:	544e494f 	strbpl	r4, [lr], #-2383	; 0x94f
    1fc0:	4154535f 	cmpmi	r4, pc, asr r3

	sum |= (sum >> 4);
    1fc4:	52004c4c 	andpl	r4, r0, #76, 24	; 0x4c00
	sum |= (sum >> 2);
    1fc8:	6c757365 	ldclvs	3, cr7, [r5], #-404	; 0xfffffe6c
	sum |= (sum >> 1);
    1fcc:	6f500074 	svcvs	0x00500074

	return (sum ^ 1) & 1;
    1fd0:	5f307473 	svcpl	0x00307473
}
    1fd4:	636f7250 	cmnvs	pc, #80, 4
    1fd8:	00737365 	rsbseq	r7, r3, r5, ror #6
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fdc:	61746144 	cmnvs	r4, r4, asr #2
		sum |= x[i] ^ y[i];
    1fe0:	66667542 	strbtvs	r7, [r6], -r2, asr #10
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fe4:	52007265 	andpl	r7, r0, #1342177286	; 0x50000006
    1fe8:	72657365 	rsbvc	r7, r5, #-1811939327	; 0x94000001
		sum |= x[i] ^ y[i];
    1fec:	00646576 	rsbeq	r6, r4, r6, ror r5
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1ff0:	6e617453 	mcrvs	4, 3, r7, cr1, cr3, {2}
}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
    1ff4:	64726164 	ldrbtvs	r6, [r2], #-356	; 0x164
    1ff8:	7465535f 	strbtvc	r5, [r5], #-863	; 0x35f
    1ffc:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
    2000:	72756769 	rsbsvc	r6, r5, #27525120	; 0x1a40000
    2004:	6f697461 	svcvs	0x00697461
    2008:	6144006e 	cmpvs	r4, lr, rrx
    200c:	74536174 	ldrbvc	r6, [r3], #-372	; 0x174
    2010:	49656761 	stmdbmi	r5!, {r0, r5, r6, r8, r9, sl, sp, lr}^
    2014:	4544006e 	strbmi	r0, [r4, #-110]	; 0x6e
	const uint8_t mask = -condition;
    2018:	45434956 	strbmi	r4, [r3, #-2390]	; 0x956
    201c:	4d45525f 	sfmmi	f5, 2, [r5, #-380]	; 0xfffffe84
    2020:	5f45544f 	svcpl	0x0045544f
    2024:	454b4157 	strbmi	r4, [fp, #-343]	; 0x157
    2028:	53005055 	movwpl	r5, #85	; 0x55
    202c:	4c4c4154 	stfmie	f4, [ip], {84}	; 0x54
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    2030:	54004445 	strpl	r4, [r0], #-1093	; 0x445
    2034:	5f657079 	svcpl	0x00657079
    2038:	00636552 	rsbeq	r6, r3, r2, asr r5
    203c:	74697865 	strbtvc	r7, [r9], #-2149	; 0x865
    2040:	446f4e5f 	strbtmi	r4, [pc], #-3679	; 2048 <f25519_select+0x54>
    2044:	5f617461 	svcpl	0x00617461
    2048:	75746553 	ldrbvc	r6, [r4, #-1363]!	; 0x553
    204c:	77003070 	smlsdxvc	r0, r0, r0, r3
    2050:	756c6156 	strbvc	r6, [ip, #-342]!	; 0x156
    2054:	44003165 	strmi	r3, [r0], #-357	; 0x165
    2058:	43495645 	movtmi	r5, #38469	; 0x9645
    205c:	45445f45 	strbmi	r5, [r4, #-3909]	; 0xf45
    2060:	49524353 	ldmdbmi	r2, {r0, r1, r4, r6, r8, r9, lr}^
    2064:	524f5450 	subpl	r5, pc, #80, 8	; 0x50000000
    2068:	52545300 	subspl	r5, r4, #0, 6
    206c:	5f474e49 	svcpl	0x00474e49
    2070:	43534544 	cmpmi	r3, #68, 10	; 0x11000000
    2074:	54504952 	ldrbpl	r4, [r0], #-2386	; 0x952
    2078:	5500524f 	strpl	r5, [r0, #-591]	; 0x24f
    207c:	54726573 	ldrbtpl	r6, [r2], #-1395	; 0x573
    2080:	414d506f 	cmpmi	sp, pc, rrx
    2084:	66667542 	strbtvs	r7, [r6], -r2, asr #10
    2088:	6f437265 	svcvs	0x00437265
    208c:	73007970 	movwvc	r7, #2416	; 0x970
    2090:	5f657661 	svcpl	0x00657661
    2094:	6e654c72 	mcrvs	12, 3, r4, cr5, cr2, {3}
    2098:	00687467 	rsbeq	r7, r8, r7, ror #8
}
    209c:	5453414c 	ldrbpl	r4, [r3], #-332	; 0x14c
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    20a0:	5f4e495f 	svcpl	0x004e495f
    20a4:	41544144 	cmpmi	r4, r4, asr #2
    20a8:	504f4e00 	subpl	r4, pc, r0, lsl #28
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    20ac:	6f72505f 	svcvs	0x0072505f
    20b0:	73736563 	cmnvc	r3, #415236096	; 0x18c00000
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}
    20b4:	61745300 	cmnvs	r4, r0, lsl #6
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    20b8:	7261646e 	rsbvc	r6, r1, #1845493760	; 0x6e000000
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}

void f25519_add(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint16_t c = 0;
    20bc:	65535f64 	ldrbvs	r5, [r3, #-3940]	; 0xf64
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
    20c0:	746e4974 	strbtvc	r4, [lr], #-2420	; 0x974
    20c4:	61667265 	cmnvs	r6, r5, ror #4
		r[i] = c;
    20c8:	45006563 	strmi	r6, [r0, #-1379]	; 0x563
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    20cc:	63657078 	cmnvs	r5, #120	; 0x78
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;
    20d0:	74535f74 	ldrbvc	r5, [r3], #-3956	; 0xf74
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20d4:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
	c = (c >> 7) * 19;
    20d8:	74754f5f 	ldrbtvc	r4, [r5], #-3935	; 0xf5f
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20dc:	55415000 	strbpl	r5, [r1, #-0]
	c = (c >> 7) * 19;
    20e0:	52004553 	andpl	r4, r0, #348127232	; 0x14c00000
    20e4:	65757165 	ldrbvs	r7, [r5, #-357]!	; 0x165

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    20e8:	6f4e7473 	svcvs	0x004e7473
    20ec:	54454700 	strbpl	r4, [r5], #-1792	; 0x700

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    20f0:	544e495f 	strbpl	r4, [lr], #-2399	; 0x95f
		c += r[i];
		r[i] = c;
		c >>= 8;
    20f4:	41465245 	cmpmi	r6, r5, asr #4

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    20f8:	53004543 	movwpl	r4, #1347	; 0x543
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    20fc:	646e6174 	strbtvs	r6, [lr], #-372	; 0x174

void f25519_sub(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2100:	5f647261 	svcpl	0x00647261
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
    2104:	45746553 	ldrbmi	r6, [r4, #-1363]!	; 0x553
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2108:	6f50646e 	svcvs	0x0050646e
    210c:	46746e69 	ldrbtmi	r6, [r4], -r9, ror #28
    2110:	75746165 	ldrbvc	r6, [r4, #-357]!	; 0x165
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2114:	47006572 	smlsdxmi	r0, r2, r5, r6
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2118:	535f5445 	cmppl	pc, #1157627904	; 0x45000000
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    211c:	55544154 	ldrbpl	r4, [r4, #-340]	; 0x154
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2120:	45530053 	ldrbmi	r0, [r3, #-83]	; 0x53
    2124:	45465f54 	strbmi	r5, [r6, #-3924]	; 0xf54
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2128:	52555441 	subspl	r5, r5, #1090519040	; 0x41000000
    212c:	61440045 	cmpvs	r4, r5, asr #32
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2130:	4d5f6174 	ldfmie	f6, [pc, #-464]	; 1f68 <f25519_eq+0x10>
	c = (c >> 7) * 19;
    2134:	4d5f6c75 	ldclmi	12, cr6, [pc, #-468]	; 1f68 <f25519_eq+0x10>

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2138:	61507861 	cmpvs	r0, r1, ror #16
		r[i] = c;
    213c:	74656b63 	strbtvc	r6, [r5], #-2915	; 0xb63

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2140:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
		c += r[i];
		r[i] = c;
		c >>= 8;
    2144:	65447000 	strbvs	r7, [r4, #-0]
	}
}
    2148:	74530076 	ldrbvc	r0, [r3], #-118	; 0x76

void f25519_neg(uint8_t *r, const uint8_t *a)
{
    214c:	61646e61 	cmnvs	r4, r1, ror #28
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
    2150:	535f6472 	cmppl	pc, #1912602624	; 0x72000000
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 - ((uint32_t)a[i]);
    2154:	65447465 	strbvs	r7, [r4, #-1125]	; 0x465
    2158:	65636976 	strbvs	r6, [r3, #-2422]!	; 0x976
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    215c:	74616546 	strbtvc	r6, [r1], #-1350	; 0x546
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
    2160:	00657275 	rsbeq	r7, r5, r5, ror r2
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2164:	73654470 	cmnvc	r5, #112, 8	; 0x70000000

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2168:	59530063 	ldmdbpl	r3, {r0, r1, r5, r6}^
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;
    216c:	5f48434e 	svcpl	0x0048434e
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    2170:	4d415246 	sfmmi	f5, 2, [r1, #-280]	; 0xfffffee8
	c = (c >> 7) * 19;
    2174:	74530045 	ldrbvc	r0, [r3], #-69	; 0x45
    2178:	61646e61 	cmnvs	r4, r1, ror #28

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    217c:	475f6472 			; <UNDEFINED> instruction: 0x475f6472
		r[i] = c;
    2180:	6e497465 	cdpvs	4, 4, cr7, cr9, cr5, {3}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2184:	66726574 			; <UNDEFINED> instruction: 0x66726574
		c += r[i];
		r[i] = c;
		c >>= 8;
    2188:	00656361 	rsbeq	r6, r5, r1, ror #6
	}
}
    218c:	5f544553 	svcpl	0x00544553
    2190:	43534544 	cmpmi	r3, #68, 10	; 0x11000000

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2194:	54504952 	ldrbpl	r4, [r0], #-2386	; 0x952
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2198:	5300524f 	movwpl	r5, #591	; 0x24f
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    219c:	495f5445 	ldmdbmi	pc, {r0, r2, r6, sl, ip, lr}^	; <UNPREDICTABLE>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    21a0:	5245544e 	subpl	r5, r5, #1308622848	; 0x4e000000
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    21a4:	45434146 	strbmi	r4, [r3, #-326]	; 0x146
		for (j = 0; j <= i; j++)
    21a8:	45465f00 	strbmi	r5, [r6, #-3840]	; 0xf00
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    21ac:	52555441 	subspl	r5, r5, #1090519040	; 0x41000000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    21b0:	45535f45 	ldrbmi	r5, [r3, #-3909]	; 0xf45
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    21b4:	5443454c 	strbpl	r4, [r3], #-1356	; 0x54c

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    21b8:	5300524f 	movwpl	r5, #591	; 0x24f
    21bc:	646e6174 	strbtvs	r6, [lr], #-372	; 0x174
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21c0:	5f647261 	svcpl	0x00647261
    21c4:	43746547 	cmnmi	r4, #297795584	; 0x11c00000
    21c8:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    21cc:	61727567 	cmnvs	r2, r7, ror #10
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    21d0:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    21d4:	61745300 	cmnvs	r4, r0, lsl #6
    21d8:	7261646e 	rsbvc	r6, r1, #1845493760	; 0x6e000000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21dc:	6c435f64 	mcrrvs	15, 6, r5, r3, cr4
			c += ((uint32_t)a[j]) *
    21e0:	46726165 	ldrbtmi	r6, [r2], -r5, ror #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    21e4:	75746165 	ldrbvc	r6, [r4, #-357]!	; 0x165
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    21e8:	47006572 	smlsdxmi	r0, r2, r5, r6
    21ec:	435f5445 	cmpmi	pc, #1157627904	; 0x45000000
    21f0:	49464e4f 	stmdbmi	r6, {r0, r1, r2, r3, r6, r9, sl, fp, lr}^

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    21f4:	41525547 	cmpmi	r2, r7, asr #10
    21f8:	4e4f4954 	mcrmi	9, 2, r4, cr15, cr4, {2}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    21fc:	4f435f00 	svcmi	0x00435f00
	c = (c >> 7) * 19;
    2200:	4f52544e 	svcmi	0x0052544e

	for (i = 0; i < F25519_SIZE; i++) {
    2204:	54535f4c 	ldrbpl	r5, [r3], #-3916	; 0xf4c
		c += r[i];
    2208:	00455441 	subeq	r5, r5, r1, asr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    220c:	5345445f 	movtpl	r4, #21599	; 0x545f
		c += r[i];
		r[i] = c;
		c >>= 8;
    2210:	50495243 	subpl	r5, r9, r3, asr #4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2214:	5f524f54 	svcpl	0x00524f54
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    2218:	45505954 	ldrbmi	r5, [r0, #-2388]	; 0x954
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    221c:	54455300 	strbpl	r5, [r5], #-768	; 0x300
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2220:	474e4954 	smlsldmi	r4, lr, r4, r9
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    2224:	0050555f 	subseq	r5, r0, pc, asr r5
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2228:	54414d50 	strbpl	r4, [r1], #-3408	; 0xd50
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    222c:	6573556f 	ldrbvs	r5, [r3, #-1391]!	; 0x56f
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2230:	66754272 			; <UNDEFINED> instruction: 0x66754272
    2234:	43726566 	cmnmi	r2, #427819008	; 0x19800000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2238:	0079706f 	rsbseq	r7, r9, pc, rrx
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    223c:	5f544553 	svcpl	0x00544553

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2240:	464e4f43 	strbmi	r4, [lr], -r3, asr #30
    2244:	52554749 	subspl	r4, r5, #19136512	; 0x1240000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2248:	4f495441 	svcmi	0x00495441
    224c:	4157004e 	cmpmi	r7, lr, asr #32
    2250:	535f5449 	cmppl	pc, #1224736768	; 0x49000000
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2254:	55544154 	ldrbpl	r4, [r4, #-340]	; 0x154
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2258:	554f5f53 	strbpl	r5, [pc, #-3923]	; 130d <setupCLK+0x11>
    225c:	4f540054 	svcmi	0x00540054

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2260:	5f4c4154 	svcpl	0x004c4154
			c += ((uint32_t)a[j]) *
    2264:	51455273 	hvcpl	21795	; 0x5523
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2268:	54534555 	ldrbpl	r4, [r3], #-1365	; 0x555
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    226c:	544e4900 	strbpl	r4, [lr], #-2304	; 0x900
    2270:	41465245 	cmpmi	r6, r5, asr #4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2274:	445f4543 	ldrbmi	r4, [pc], #-1347	; 227c <f25519_inv__distinct+0x60>
	c = (c >> 7) * 19;
    2278:	52435345 	subpl	r5, r3, #335544321	; 0x14000001
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    227c:	4f545049 	svcmi	0x00545049
	c = (c >> 7) * 19;
    2280:	61730052 	cmnvs	r3, r2, asr r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2284:	775f6576 			; <UNDEFINED> instruction: 0x775f6576
    2288:	676e654c 	strbvs	r6, [lr, -ip, asr #10]!
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    228c:	53006874 	movwpl	r6, #2164	; 0x874
		r[i] = c;
    2290:	646e6174 	strbtvs	r6, [lr], #-372	; 0x174
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2294:	5f647261 	svcpl	0x00647261
		c += r[i];
		r[i] = c;
		c >>= 8;
    2298:	53746547 	cmnpl	r4, #297795584	; 0x11c00000
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    229c:	75746174 	ldrbvc	r6, [r4, #-372]!	; 0x174
    22a0:	4e450073 	mcrmi	0, 2, r0, cr5, cr3, {3}
    22a4:	494f5044 	stmdbmi	pc, {r2, r6, ip, lr}^	; <UNPREDICTABLE>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22a8:	445f544e 	ldrbmi	r5, [pc], #-1102	; 22b0 <f25519_inv__distinct+0x94>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    22ac:	52435345 	subpl	r5, r3, #335544321	; 0x14000001
		for (j = 0; j <= i; j++)
    22b0:	4f545049 	svcmi	0x00545049
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22b4:	4f430052 	svcmi	0x00430052
    22b8:	4749464e 	strbmi	r4, [r9, -lr, asr #12]

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22bc:	5345445f 	movtpl	r4, #21599	; 0x545f
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22c0:	50495243 	subpl	r5, r9, r3, asr #4

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22c4:	00524f54 	subseq	r4, r2, r4, asr pc
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22c8:	66754270 			; <UNDEFINED> instruction: 0x66754270
    22cc:	50457000 	subpl	r7, r5, r0
    22d0:	6f666e69 	svcvs	0x00666e69
    22d4:	54455300 	strbpl	r5, [r5], #-768	; 0x300
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    22d8:	4444415f 	strbmi	r4, [r4], #-351	; 0x15f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22dc:	53534552 	cmppl	r3, #343932928	; 0x14800000
    22e0:	6c655200 	sfmvs	f5, 2, [r5], #-0
    22e4:	64657461 	strbtvs	r7, [r5], #-1121	; 0x461

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22e8:	646e455f 	strbtvs	r4, [lr], #-1375	; 0x55f
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    22ec:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
    22f0:	74530074 	ldrbvc	r0, [r3], #-116	; 0x74

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    22f4:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    22f8:	6f666e49 	svcvs	0x00666e49
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22fc:	6e497700 	cdpvs	7, 4, cr7, cr9, cr0, {0}
	c = (c >> 7) * 19;
    2300:	30786564 	rsbscc	r6, r8, r4, ror #10

	for (i = 0; i < F25519_SIZE; i++) {
    2304:	54454700 	strbpl	r4, [r5], #-1792	; 0x700
		c += r[i];
    2308:	5345445f 	movtpl	r4, #21599	; 0x545f
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    230c:	50495243 	subpl	r5, r9, r3, asr #4
		c += r[i];
		r[i] = c;
		c >>= 8;
    2310:	00524f54 	subseq	r4, r2, r4, asr pc
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2314:	61746144 	cmnvs	r4, r4, asr #2
    2318:	67617453 			; <UNDEFINED> instruction: 0x67617453
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    231c:	74754f65 	ldrbtvc	r4, [r5], #-3941	; 0xf65
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2320:	49415700 	stmdbmi	r1, {r8, r9, sl, ip, lr}^
    2324:	45535f54 	ldrbmi	r5, [r3, #-3924]	; 0xf54
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2328:	00505554 	subseq	r5, r0, r4, asr r5
		for (j = 0; j <= i; j++)
    232c:	75716552 	ldrbvc	r6, [r1, #-1362]!	; 0x552
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2330:	5f747365 	svcpl	0x00747365
    2334:	57006f4e 	strpl	r6, [r0, -lr, asr #30]

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2338:	5f544941 	svcpl	0x00544941
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    233c:	54415453 	strbpl	r5, [r1], #-1107	; 0x453

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2340:	495f5355 	ldmdbmi	pc, {r0, r2, r4, r6, r8, r9, ip, lr}^	; <UNPREDICTABLE>
    2344:	4c43004e 	mcrrmi	0, 4, r0, r3, cr14
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2348:	5f524145 	svcpl	0x00524145
    234c:	54414546 	strbpl	r4, [r1], #-1350	; 0x546
    2350:	00455255 	subeq	r5, r5, r5, asr r2
    2354:	5453414c 	ldrbpl	r4, [r3], #-332	; 0x14c
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2358:	54554f5f 	ldrbpl	r4, [r5], #-3935	; 0xf5f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    235c:	5441445f 	strbpl	r4, [r1], #-1119	; 0x45f
    2360:	73750041 	cmnvc	r5, #65	; 0x41

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2364:	696c5f62 	stmdbvs	ip!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
			c += ((uint32_t)a[j]) *
    2368:	73752f62 	cmnvc	r5, #392	; 0x188
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    236c:	656d5f62 	strbvs	r5, [sp, #-3938]!	; 0xf62
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2370:	00632e6d 	rsbeq	r2, r3, sp, ror #28
    2374:	79424e77 	stmdbvc	r2, {r0, r1, r2, r4, r5, r6, r9, sl, fp, lr}^
    2378:	00736574 	rsbseq	r6, r3, r4, ror r5
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    237c:	73556270 	cmpvc	r5, #112, 4
	c = (c >> 7) * 19;
    2380:	66754272 			; <UNDEFINED> instruction: 0x66754272
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2384:	4d507700 	ldclmi	7, cr7, [r0, #-0]
	c = (c >> 7) * 19;
    2388:	66754241 	ldrbtvs	r4, [r5], -r1, asr #4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    238c:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
	c = (c >> 7) * 19;
    2390:	77647000 	strbvc	r7, [r4, -r0]!

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2394:	006c6156 	rsbeq	r6, ip, r6, asr r1

Disassembly of section .debug_loc:

00000000 <.debug_loc>:
       0:	00000b9e 	muleq	r0, lr, fp
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
       4:	00000ba6 	andeq	r0, r0, r6, lsr #23
       8:	a6500001 	ldrbge	r0, [r0], -r1
       c:	a800000b 	stmdage	r0, {r0, r1, r3}
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
      10:	0400000b 	streq	r0, [r0], #-11
      14:	5001f300 	andpl	pc, r1, r0, lsl #6
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
      18:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
      1c:	00000000 	andeq	r0, r0, r0
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
      20:	000c1800 	andeq	r1, ip, r0, lsl #16
      24:	000c1c00 	andeq	r1, ip, r0, lsl #24
      28:	71000500 	tstvc	r0, r0, lsl #10
    if ((wEPVal & EP_CTR_RX) != 0)
      2c:	9f274000 	svcls	0x00274000
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
      30:	00000c1c 	andeq	r0, r0, ip, lsl ip
      34:	00000c20 	andeq	r0, r0, r0, lsr #24
      38:	00710007 	rsbseq	r0, r1, r7

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
      3c:	27402740 	strbcs	r2, [r0, -r0, asr #14]

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
      40:	000c209f 	muleq	ip, pc, r0	; <UNPREDICTABLE>
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
      44:	000c2200 	andeq	r2, ip, r0, lsl #4
      48:	73000800 	movwvc	r0, #2048	; 0x800
      4c:	27400600 	strbcs	r0, [r0, -r0, lsl #12]

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
      50:	229f2740 	addscs	r2, pc, #64, 14	; 0x1000000
      54:	4100000c 	tstmi	r0, ip
      58:	0b00000c 	bleq	90 <g_pfnVectors+0x90>
      5c:	5c000c00 	stcpl	12, cr0, [r0], {-0}
      60:	40064000 	andmi	r4, r6, r0
      64:	9f274027 	svcls	0x00274027
	...
      70:	00000c84 	andeq	r0, r0, r4, lsl #25
      74:	00000c9b 	muleq	r0, fp, ip
      78:	9b500001 	blls	1400084 <_etext+0x13f8b6c>
      7c:	e400000c 	str	r0, [r0], #-12
      80:	0400000c 	streq	r0, [r0], #-12
      84:	5001f300 	andpl	pc, r1, r0, lsl #6
      88:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
      8c:	00000000 	andeq	r0, r0, r0
      90:	000c8400 	andeq	r8, ip, r0, lsl #8
      94:	000cae00 	andeq	sl, ip, r0, lsl #28
      98:	30000200 	andcc	r0, r0, r0, lsl #4
      9c:	000cb69f 	muleq	ip, pc, r6	; <UNPREDICTABLE>
      a0:	000cbc00 	andeq	fp, ip, r0, lsl #24
      a4:	30000200 	andcc	r0, r0, r0, lsl #4
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
      a8:	000cbc9f 	muleq	ip, pc, ip	; <UNPREDICTABLE>

	return f25519_eq(a, c);
      ac:	000cc700 	andeq	ip, ip, r0, lsl #14
      b0:	53000100 	movwpl	r0, #256	; 0x100
      b4:	00000ccc 	andeq	r0, r0, ip, asr #25
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
      b8:	00000ce4 	andeq	r0, r0, r4, ror #25
	f25519_normalize(ey);
      bc:	9f300002 	svcls	0x00300002
	...

	return ok;
}
      c8:	00000ce4 	andeq	r0, r0, r4, ror #25
      cc:	00000ce9 	andeq	r0, r0, r9, ror #25
      d0:	e9500001 	ldmdb	r0, {r0}^
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
      d4:	f000000c 			; <UNDEFINED> instruction: 0xf000000c
      d8:	0400000c 	streq	r0, [r0], #-12
		minusp[i] = c;
      dc:	5001f300 	andpl	pc, r1, r0, lsl #6
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
      e0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
      e4:	00000000 	andeq	r0, r0, r0

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
      e8:	000cf000 	andeq	pc, ip, r0
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
      ec:	000cf500 	andeq	pc, ip, r0, lsl #10
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
      f0:	50000100 	andpl	r0, r0, r0, lsl #2
      f4:	00000cf5 	strdeq	r0, [r0], -r5
      f8:	00000cfc 	strdeq	r0, [r0], -ip
      fc:	01f30004 	mvnseq	r0, r4
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     100:	00009f50 	andeq	r9, r0, r0, asr pc

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
     104:	00000000 	andeq	r0, r0, r0
     108:	0cfc0000 	ldcleq	0, cr0, [ip]
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     10c:	0d0f0000 	stceq	0, cr0, [pc, #-0]	; 114 <_Minimum_Stack_Size+0x14>
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
     110:	00010000 	andeq	r0, r1, r0
     114:	000d0f50 	andeq	r0, sp, r0, asr pc
     118:	000d1000 	andeq	r1, sp, r0
     11c:	f3000400 	vshl.u8	d0, d0, d0
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     120:	109f5001 	addsne	r5, pc, r1
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
     124:	1200000d 	andne	r0, r0, #13
     128:	0100000d 	tsteq	r0, sp
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
     12c:	0d125000 	ldceq	0, cr5, [r2, #-0]

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
     130:	0d1c0000 	ldceq	0, cr0, [ip, #-0]
	i <<= 3;

	while (x) {
     134:	00040000 	andeq	r0, r4, r0
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
     138:	9f5001f3 	svcls	0x005001f3
	...

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
	f25519_mul_c(z3, x1sq, 4);
     144:	00000d1c 	andeq	r0, r0, ip, lsl sp
     148:	00000d21 	andeq	r0, r0, r1, lsr #26
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	21500001 	cmpcs	r0, r1
     150:	2800000d 	stmdacs	r0, {r0, r2, r3}
     154:	0400000d 	streq	r0, [r0], #-13
	f25519_sub(b, x3, z3); /* D */
     158:	5001f300 	andpl	pc, r1, r0, lsl #6
     15c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	f25519_mul__distinct(da, a, b);
     160:	00000000 	andeq	r0, r0, r0
     164:	000d2800 	andeq	r2, sp, r0, lsl #16
     168:	000d3b00 	andeq	r3, sp, r0, lsl #22

	f25519_sub(b, x2, z2);
     16c:	50000100 	andpl	r0, r0, r0, lsl #2
     170:	00000d3b 	andeq	r0, r0, fp, lsr sp
	f25519_add(a, x3, z3); /* C */
     174:	00000d46 	andeq	r0, r0, r6, asr #26
     178:	01f30004 	mvnseq	r0, r4
     17c:	0d469f50 	stcleq	15, cr9, [r6, #-320]	; 0xfffffec0
	f25519_mul__distinct(cb, a, b);
     180:	0d480000 	stcleq	0, cr0, [r8, #-0]
     184:	00010000 	andeq	r0, r1, r0

	f25519_add(a, da, cb);
     188:	000d4850 	andeq	r4, sp, r0, asr r8
     18c:	000d5000 	andeq	r5, sp, r0
     190:	f3000400 	vshl.u8	d0, d0, d0
	f25519_mul__distinct(b, a, a);
     194:	009f5001 	addseq	r5, pc, r1
     198:	00000000 	andeq	r0, r0, r0
	f25519_mul__distinct(x5, z1, b);
     19c:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
     1a0:	4600000d 	strmi	r0, [r0], -sp
     1a4:	0400000d 	streq	r0, [r0], #-13

	f25519_sub(a, da, cb);
     1a8:	5001f300 	andpl	pc, r1, r0, lsl #6
     1ac:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	f25519_mul__distinct(b, a, a);
     1b0:	00000000 	andeq	r0, r0, r0
     1b4:	000dbe00 	andeq	fp, sp, r0, lsl #28
     1b8:	000dc200 	andeq	ip, sp, r0, lsl #4

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	72000500 	andvc	r0, r0, #0, 10
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	9f213c00 	svcls	0x00213c00
	...

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1cc:	00000dec 	andeq	r0, r0, ip, ror #27
     1d0:	00000e09 	andeq	r0, r0, r9, lsl #28
     1d4:	09500001 	ldmdbeq	r0, {r0}^
		f25519_select(zm1, zm1, zm, bit);
     1d8:	0c00000e 	stceq	0, cr0, [r0], {14}
     1dc:	0400000e 	streq	r0, [r0], #-14
     1e0:	5001f300 	andpl	pc, r1, r0, lsl #6
		f25519_select(xm, xm, xms, bit);
     1e4:	000e0c9f 	muleq	lr, pc, ip	; <UNPREDICTABLE>
     1e8:	000e0f00 	andeq	r0, lr, r0, lsl #30
     1ec:	50000100 	andpl	r0, r0, r0, lsl #2
		f25519_select(zm, zm, zms, bit);
     1f0:	00000e0f 	andeq	r0, r0, pc, lsl #28
     1f4:	00000e14 	andeq	r0, r0, r4, lsl lr
     1f8:	01f30004 	mvnseq	r0, r4
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fc:	0e149f50 	mrceq	15, 0, r9, cr4, cr0, {2}
     200:	0e620000 	cdpeq	0, 6, cr0, cr2, cr0, {0}
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     204:	00010000 	andeq	r0, r1, r0
     208:	000e6250 	andeq	r6, lr, r0, asr r2
	f25519_mul__distinct(result, zm1, xm);
     20c:	000e7000 	andeq	r7, lr, r0
     210:	f3000400 	vshl.u8	d0, d0, d0
	f25519_normalize(result);
     214:	009f5001 	addseq	r5, pc, r1
     218:	00000000 	andeq	r0, r0, r0
}
     21c:	32000000 	andcc	r0, r0, #0
     220:	3600000e 	strcc	r0, [r0], -lr
     224:	0500000e 	streq	r0, [r0, #-14]
     228:	40007200 	andmi	r7, r0, r0, lsl #4
     22c:	0e569f21 	cdpeq	15, 5, cr9, cr6, cr1, {1}
     230:	0e5c0000 	cdpeq	0, 5, cr0, cr12, cr0, {0}
     234:	00060000 	andeq	r0, r6, r0
     238:	ef090071 	svc	0x00090071
     23c:	00009f1a 	andeq	r9, r0, sl, lsl pc
     240:	00000000 	andeq	r0, r0, r0
     244:	10380000 	eorsne	r0, r8, r0
     248:	10680000 	rsbne	r0, r8, r0
     24c:	00020000 	andeq	r0, r2, r0
     250:	10689f30 	rsbne	r9, r8, r0, lsr pc
     254:	106a0000 	rsbne	r0, sl, r0
     258:	00070000 	andeq	r0, r7, r0
     25c:	24480070 	strbcs	r0, [r8], #-112	; 0x70
     260:	6a9f2930 	bvs	fe7ca728 <BootRAM+0xd73aec9>
     264:	88000010 	stmdahi	r0, {r4}
     268:	07000010 	smladeq	r0, r0, r0, r0
     26c:	48007400 	stmdami	r0, {sl, ip, sp, lr}
     270:	9f293024 	svcls	0x00293024
     274:	0000108e 	andeq	r1, r0, lr, lsl #1
     278:	00001094 	muleq	r0, r4, r0
     27c:	00740007 	rsbseq	r0, r4, r7
     280:	29302448 	ldmdbcs	r0!, {r3, r6, sl, sp}
     284:	0010949f 	mulseq	r0, pc, r4	; <UNPREDICTABLE>
     288:	00109800 	andseq	r9, r0, r0, lsl #16
     28c:	30000200 	andcc	r0, r0, r0, lsl #4
     290:	0010989f 	mulseq	r0, pc, r8	; <UNPREDICTABLE>
     294:	0010a200 	andseq	sl, r0, r0, lsl #4
     298:	74000700 	strvc	r0, [r0], #-1792	; 0x700
     29c:	30244800 	eorcc	r4, r4, r0, lsl #16
     2a0:	10a29f29 	adcne	r9, r2, r9, lsr #30
     2a4:	10a40000 	adcne	r0, r4, r0
     2a8:	00020000 	andeq	r0, r2, r0
     2ac:	10a49f31 	adcne	r9, r4, r1, lsr pc
     2b0:	10f60000 	rscsne	r0, r6, r0
     2b4:	00010000 	andeq	r0, r1, r0
     2b8:	0010f654 	andseq	pc, r0, r4, asr r6	; <UNPREDICTABLE>
     2bc:	00112400 	andseq	r2, r1, r0, lsl #8
     2c0:	50000100 	andpl	r0, r0, r0, lsl #2
	...
     2cc:	00001078 	andeq	r1, r0, r8, ror r0
     2d0:	00001090 	muleq	r0, r0, r0
     2d4:	98500001 	ldmdals	r0, {r0}^
     2d8:	9a000010 	bls	320 <GPIO_EventOutputConfig+0x18>
     2dc:	01000010 	tsteq	r0, r0, lsl r0
     2e0:	109c5000 	addsne	r5, ip, r0
     2e4:	109e0000 	addsne	r0, lr, r0
     2e8:	00010000 	andeq	r0, r1, r0
     2ec:	00000050 	andeq	r0, r0, r0, asr r0
     2f0:	00000000 	andeq	r0, r0, r0
     2f4:	0010b600 	andseq	fp, r0, r0, lsl #12
     2f8:	0010de00 	andseq	sp, r0, r0, lsl #28
     2fc:	75000300 	strvc	r0, [r0, #-768]	; 0x300
     300:	10de9f01 	sbcsne	r9, lr, r1, lsl #30
     304:	10e00000 	rscne	r0, r0, r0
     308:	00010000 	andeq	r0, r1, r0
     30c:	0010e055 	andseq	lr, r0, r5, asr r0
     310:	0010f600 	andseq	pc, r0, r0, lsl #12
     314:	75000300 	strvc	r0, [r0, #-768]	; 0x300
     318:	00009f01 	andeq	r9, r0, r1, lsl #30
     31c:	00000000 	andeq	r0, r0, r0
     320:	11240000 	teqne	r4, r0
     324:	112a0000 	teqne	sl, r0
     328:	00010000 	andeq	r0, r1, r0
     32c:	00112a51 	andseq	r2, r1, r1, asr sl
     330:	00113a00 	andseq	r3, r1, r0, lsl #20
     334:	f3000400 	vshl.u8	d0, d0, d0
     338:	009f5101 	addseq	r5, pc, r1, lsl #2
     33c:	00000000 	andeq	r0, r0, r0
     340:	24000000 	strcs	r0, [r0], #-0
     344:	24000011 	strcs	r0, [r0], #-17
     348:	01000011 	tsteq	r0, r1, lsl r0
     34c:	11245200 	teqne	r4, r0, lsl #4
     350:	112e0000 	teqne	lr, r0
     354:	00070000 	andeq	r0, r7, r0
     358:	24480072 	strbcs	r0, [r8], #-114	; 0x72
     35c:	2e9f2930 	mrccs	9, 4, r2, cr15, cr0, {1}
     360:	3a000011 	bcc	3ac <GPIO_EXTILineConfig+0xc>
     364:	08000011 	stmdaeq	r0, {r0, r4}
     368:	5201f300 	andpl	pc, r1, #0, 6
     36c:	29302448 	ldmdbcs	r0!, {r3, r6, sl, sp}
     370:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     374:	00000000 	andeq	r0, r0, r0
     378:	00113a00 	andseq	r3, r1, r0, lsl #20
     37c:	00114a00 	andseq	r4, r1, r0, lsl #20
     380:	50000100 	andpl	r0, r0, r0, lsl #2
     384:	0000114a 	andeq	r1, r0, sl, asr #2
     388:	0000114c 	andeq	r1, r0, ip, asr #2
     38c:	01f30004 	mvnseq	r0, r4
     390:	00009f50 	andeq	r9, r0, r0, asr pc
     394:	00000000 	andeq	r0, r0, r0
     398:	113a0000 	teqne	sl, r0
     39c:	11400000 	mrsne	r0, (UNDEF: 64)
     3a0:	00010000 	andeq	r0, r1, r0
     3a4:	00114051 	andseq	r4, r1, r1, asr r0
     3a8:	00114c00 	andseq	r4, r1, r0, lsl #24
     3ac:	f3000400 	vshl.u8	d0, d0, d0
     3b0:	009f5101 	addseq	r5, pc, r1, lsl #2
     3b4:	00000000 	andeq	r0, r0, r0
     3b8:	4c000000 	stcmi	0, cr0, [r0], {-0}
     3bc:	67000011 	smladvs	r0, r1, r0, r0
     3c0:	01000011 	tsteq	r0, r1, lsl r0
     3c4:	11675000 	cmnne	r7, r0
     3c8:	119c0000 	orrsne	r0, ip, r0
     3cc:	00010000 	andeq	r0, r1, r0
     3d0:	00000058 	andeq	r0, r0, r8, asr r0
     3d4:	00000000 	andeq	r0, r0, r0
     3d8:	00114c00 	andseq	r4, r1, r0, lsl #24
     3dc:	00116700 	andseq	r6, r1, r0, lsl #14
     3e0:	51000100 	mrspl	r0, (UNDEF: 16)
     3e4:	00001167 	andeq	r1, r0, r7, ror #2
     3e8:	0000119c 	muleq	r0, ip, r1
     3ec:	01f30004 	mvnseq	r0, r4
     3f0:	00009f51 	andeq	r9, r0, r1, asr pc
     3f4:	00000000 	andeq	r0, r0, r0
     3f8:	114c0000 	mrsne	r0, (UNDEF: 76)
     3fc:	115e0000 	cmpne	lr, r0
     400:	00010000 	andeq	r0, r1, r0
     404:	00115e52 	andseq	r5, r1, r2, asr lr
     408:	00116800 	andseq	r6, r1, r0, lsl #16
     40c:	f3000400 	vshl.u8	d0, d0, d0
     410:	689f5201 	ldmvs	pc, {r0, r9, ip, lr}	; <UNPREDICTABLE>
     414:	90000011 	andls	r0, r0, r1, lsl r0
     418:	03000011 	movweq	r0, #17
     41c:	9f7f7400 	svcls	0x007f7400
     420:	00001190 	muleq	r0, r0, r1
     424:	00001196 	muleq	r0, r6, r1
     428:	00740003 	rsbseq	r0, r4, r3
     42c:	0011989f 	mulseq	r1, pc, r8	; <UNPREDICTABLE>
     430:	00119c00 	andseq	r9, r1, r0, lsl #24
     434:	74000300 	strvc	r0, [r0], #-768	; 0x300
     438:	00009f7f 	andeq	r9, r0, pc, ror pc
     43c:	00000000 	andeq	r0, r0, r0
     440:	114c0000 	mrsne	r0, (UNDEF: 76)
     444:	11670000 	cmnne	r7, r0
     448:	00010000 	andeq	r0, r1, r0
     44c:	00116753 	andseq	r6, r1, r3, asr r7
     450:	00119c00 	andseq	r9, r1, r0, lsl #24
     454:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
     460:	0000116c 	andeq	r1, r0, ip, ror #2
     464:	0000117e 	andeq	r1, r0, lr, ror r1
     468:	7e550001 	cdpvc	0, 5, cr0, cr5, cr1, {0}
     46c:	80000011 	andhi	r0, r0, r1, lsl r0
     470:	01000011 	tsteq	r0, r1, lsl r0
     474:	11805600 	orrne	r5, r0, r0, lsl #12
     478:	11980000 	orrsne	r0, r8, r0
     47c:	00010000 	andeq	r0, r1, r0
     480:	00000055 	andeq	r0, r0, r5, asr r0
     484:	00000000 	andeq	r0, r0, r0
     488:	0011a600 	andseq	sl, r1, r0, lsl #12
     48c:	0011ac00 	andseq	sl, r1, r0, lsl #24
     490:	50000100 	andpl	r0, r0, r0, lsl #2
     494:	000011ac 	andeq	r1, r0, ip, lsr #3
     498:	000011bc 			; <UNDEFINED> instruction: 0x000011bc
     49c:	00550001 	subseq	r0, r5, r1
     4a0:	00000000 	andeq	r0, r0, r0
     4a4:	a6000000 	strge	r0, [r0], -r0
     4a8:	ac000011 	stcge	0, cr0, [r0], {17}
     4ac:	01000011 	tsteq	r0, r1, lsl r0
     4b0:	11ac5100 			; <UNDEFINED> instruction: 0x11ac5100
     4b4:	11b00000 	movsne	r0, r0
     4b8:	00030000 	andeq	r0, r3, r0
     4bc:	b09f0174 	addslt	r0, pc, r4, ror r1	; <UNPREDICTABLE>
     4c0:	b8000011 	stmdalt	r0, {r0, r4}
     4c4:	01000011 	tsteq	r0, r1, lsl r0
     4c8:	11b85400 			; <UNDEFINED> instruction: 0x11b85400
     4cc:	11ba0000 			; <UNDEFINED> instruction: 0x11ba0000
     4d0:	00030000 	andeq	r0, r3, r0
     4d4:	ba9f0174 	blt	fe7c0aac <BootRAM+0xd73124d>
     4d8:	bc000011 	stclt	0, cr0, [r0], {17}
     4dc:	01000011 	tsteq	r0, r1, lsl r0
     4e0:	00005400 	andeq	r5, r0, r0, lsl #8
     4e4:	00000000 	andeq	r0, r0, r0
     4e8:	11bc0000 			; <UNDEFINED> instruction: 0x11bc0000
     4ec:	11c60000 	bicne	r0, r6, r0
     4f0:	00010000 	andeq	r0, r1, r0
     4f4:	0011c650 	andseq	ip, r1, r0, asr r6
     4f8:	0011cb00 	andseq	ip, r1, r0, lsl #22
     4fc:	53000100 	movwpl	r0, #256	; 0x100
     500:	000011cb 	andeq	r1, r0, fp, asr #3
     504:	000011e4 	andeq	r1, r0, r4, ror #3
     508:	01f30004 	mvnseq	r0, r4
     50c:	00009f50 	andeq	r9, r0, r0, asr pc
     510:	00000000 	andeq	r0, r0, r0
     514:	11bc0000 			; <UNDEFINED> instruction: 0x11bc0000
     518:	11c80000 	bicne	r0, r8, r0
     51c:	00010000 	andeq	r0, r1, r0
     520:	00000051 	andeq	r0, r0, r1, asr r0
     524:	00000000 	andeq	r0, r0, r0
     528:	0011fe00 	andseq	pc, r1, r0, lsl #28
     52c:	00120600 	andseq	r0, r2, r0, lsl #12
     530:	50000100 	andpl	r0, r0, r0, lsl #2
     534:	00001206 	andeq	r1, r0, r6, lsl #4
     538:	0000122c 	andeq	r1, r0, ip, lsr #4
     53c:	01f30004 	mvnseq	r0, r4
     540:	00009f50 	andeq	r9, r0, r0, asr pc
     544:	00000000 	andeq	r0, r0, r0
     548:	11fe0000 	mvnsne	r0, r0
     54c:	12080000 	andne	r0, r8, #0
     550:	00010000 	andeq	r0, r1, r0
     554:	00120851 	andseq	r0, r2, r1, asr r8
     558:	00122c00 	andseq	r2, r2, r0, lsl #24
     55c:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
     568:	0000120e 	andeq	r1, r0, lr, lsl #4
     56c:	00001210 	andeq	r1, r0, r0, lsl r2
     570:	9f300002 	svcls	0x00300002
     574:	00001210 	andeq	r1, r0, r0, lsl r2
     578:	0000122c 	andeq	r1, r0, ip, lsr #4
     57c:	00540001 	subseq	r0, r4, r1
     580:	00000000 	andeq	r0, r0, r0
     584:	7a000000 	bvc	58c <RCC_RTCCLKConfig>
     588:	80000013 	andhi	r0, r0, r3, lsl r0
     58c:	01000013 	tsteq	r0, r3, lsl r0
     590:	00005200 	andeq	r5, r0, r0, lsl #4
	...
     5a0:	00010000 	andeq	r0, r1, r0
     5a4:	00000050 	andeq	r0, r0, r0, asr r0
     5a8:	00000000 	andeq	r0, r0, r0
     5ac:	f3000400 	vshl.u8	d0, d0, d0
     5b0:	009f5001 	addseq	r5, pc, r1
	...
     5c0:	01000000 	mrseq	r0, (UNDEF: 0)
     5c4:	00005000 	andeq	r5, r0, r0
     5c8:	00000000 	andeq	r0, r0, r0
     5cc:	00040000 	andeq	r0, r4, r0
     5d0:	9f5001f3 	svcls	0x005001f3
	...
     5dc:	0000138c 	andeq	r1, r0, ip, lsl #7
     5e0:	0000139b 	muleq	r0, fp, r3
     5e4:	9b500001 	blls	14005f0 <_etext+0x13f90d8>
     5e8:	a4000013 	strge	r0, [r0], #-19
     5ec:	04000013 	streq	r0, [r0], #-19
     5f0:	5001f300 	andpl	pc, r1, r0, lsl #6
     5f4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     5f8:	00000000 	andeq	r0, r0, r0
     5fc:	00139200 	andseq	r9, r3, r0, lsl #4
     600:	00139b00 	andseq	r9, r3, r0, lsl #22
     604:	53000100 	movwpl	r0, #256	; 0x100
	...
     618:	9f300002 	svcls	0x00300002
	...
     624:	00540001 	subseq	r0, r4, r1
     628:	00000000 	andeq	r0, r0, r0
     62c:	a4000000 	strge	r0, [r0], #-0
     630:	b2000013 	andlt	r0, r0, #19
     634:	02000013 	andeq	r0, r0, #19
     638:	b29f3000 	addslt	r3, pc, #0
     63c:	ba000013 	blt	690 <RCC_APB2PeriphResetCmd+0x10>
     640:	01000013 	tsteq	r0, r3, lsl r0
     644:	13ba5300 			; <UNDEFINED> instruction: 0x13ba5300
     648:	13c60000 	bicne	r0, r6, #0
     64c:	00010000 	andeq	r0, r1, r0
     650:	0013c652 	andseq	ip, r3, r2, asr r6
     654:	0013e800 	andseq	lr, r3, r0, lsl #16
     658:	54000100 	strpl	r0, [r0], #-256	; 0x100
     65c:	000013e8 	andeq	r1, r0, r8, ror #7
     660:	000013ea 	andeq	r1, r0, sl, ror #7
     664:	00740006 	rsbseq	r0, r4, r6
     668:	9f1a0072 	svcls	0x001a0072
     66c:	000013ea 	andeq	r1, r0, sl, ror #7
     670:	000013ec 	andeq	r1, r0, ip, ror #7
     674:	ec520001 	mrrc	0, 0, r0, r2, cr1
     678:	f0000013 			; <UNDEFINED> instruction: 0xf0000013
     67c:	12000013 	andne	r0, r0, #19
     680:	70ff0800 	rscsvc	r0, pc, r0, lsl #16
     684:	33019400 	movwcc	r9, #5120	; 0x1400
     688:	1aff081a 	bne	fffc26f8 <BootRAM+0xef32e99>
     68c:	74242433 	strtvc	r2, [r4], #-1075	; 0x433
     690:	009f1a00 	addseq	r1, pc, r0, lsl #20
     694:	00000000 	andeq	r0, r0, r0
     698:	a4000000 	strge	r0, [r0], #-0
     69c:	e4000013 	str	r0, [r0], #-19
     6a0:	02000013 	andeq	r0, r0, #19
     6a4:	e49f3000 	ldr	r3, [pc], #0	; 6ac <RCC_APB1PeriphResetCmd+0x14>
     6a8:	e8000013 	stmda	r0, {r0, r1, r4}
     6ac:	01000013 	tsteq	r0, r3, lsl r0
     6b0:	13e85500 	mvnne	r5, #0, 10
     6b4:	13ec0000 	mvnne	r0, #0
     6b8:	00010000 	andeq	r0, r1, r0
     6bc:	0013ec51 	andseq	lr, r3, r1, asr ip
     6c0:	0013f400 	andseq	pc, r3, r0, lsl #8
     6c4:	52000100 	andpl	r0, r0, #0, 2
	...
     6d0:	000013a4 	andeq	r1, r0, r4, lsr #7
     6d4:	000013e4 	andeq	r1, r0, r4, ror #7
     6d8:	9f300002 	svcls	0x00300002
     6dc:	000013e4 	andeq	r1, r0, r4, ror #7
     6e0:	000013ea 	andeq	r1, r0, sl, ror #7
     6e4:	ea520001 	b	14806f0 <_etext+0x14791d8>
     6e8:	f0000013 			; <UNDEFINED> instruction: 0xf0000013
     6ec:	0f000013 	svceq	0x00000013
     6f0:	70ff0800 	rscsvc	r0, pc, r0, lsl #16
     6f4:	33019400 	movwcc	r9, #5120	; 0x1400
     6f8:	1aff081a 	bne	fffc2768 <BootRAM+0xef32f09>
     6fc:	9f242433 	svcls	0x00242433
	...
     708:	000013a4 	andeq	r1, r0, r4, lsr #7
     70c:	000013b2 			; <UNDEFINED> instruction: 0x000013b2
     710:	9f300002 	svcls	0x00300002
     714:	000013b2 			; <UNDEFINED> instruction: 0x000013b2
     718:	000013b6 			; <UNDEFINED> instruction: 0x000013b6
     71c:	73340005 	teqvc	r4, #5
     720:	b69f1c00 	ldrlt	r1, [pc], r0, lsl #24
     724:	ba000013 	blt	778 <USART_DeInit+0x40>
     728:	01000013 	tsteq	r0, r3, lsl r0
     72c:	13ba5200 			; <UNDEFINED> instruction: 0x13ba5200
     730:	13c20000 	bicne	r0, r2, #0
     734:	00050000 	andeq	r0, r5, r0
     738:	1c007334 	stcne	3, cr7, [r0], {52}	; 0x34
     73c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     740:	00000000 	andeq	r0, r0, r0
     744:	0013a400 	andseq	sl, r3, r0, lsl #8
     748:	0013b200 	andseq	fp, r3, r0, lsl #4
     74c:	3f000200 	svccc	0x00000200
     750:	0013b29f 	mulseq	r3, pc, r2	; <UNPREDICTABLE>
     754:	0013be00 	andseq	fp, r3, r0, lsl #28
     758:	3f000500 	svccc	0x00000500
     75c:	9f250073 	svcls	0x00250073
     760:	000013be 			; <UNDEFINED> instruction: 0x000013be
     764:	000013c4 	andeq	r1, r0, r4, asr #7
     768:	00540001 	subseq	r0, r4, r1
     76c:	00000000 	andeq	r0, r0, r0
     770:	34000000 	strcc	r0, [r0], #-0
     774:	3b000014 	blcc	7cc <USART_DeInit+0x94>
     778:	01000014 	tsteq	r0, r4, lsl r0
     77c:	143b5000 	ldrtne	r5, [fp], #-0
     780:	144e0000 	strbne	r0, [lr], #-0
     784:	00010000 	andeq	r0, r1, r0
     788:	00144e54 	andseq	r4, r4, r4, asr lr
     78c:	00145100 	andseq	r5, r4, r0, lsl #2
     790:	50000100 	andpl	r0, r0, r0, lsl #2
     794:	00001451 	andeq	r1, r0, r1, asr r4
     798:	00001452 	andeq	r1, r0, r2, asr r4
     79c:	01f30004 	mvnseq	r0, r4
     7a0:	00009f50 	andeq	r9, r0, r0, asr pc
     7a4:	00000000 	andeq	r0, r0, r0
     7a8:	14680000 	strbtne	r0, [r8], #-0
     7ac:	14900000 	ldrne	r0, [r0], #0
     7b0:	00010000 	andeq	r0, r1, r0
     7b4:	00149050 	andseq	r9, r4, r0, asr r0
     7b8:	00149c00 	andseq	r9, r4, r0, lsl #24
     7bc:	f3000400 	vshl.u8	d0, d0, d0
     7c0:	009f5001 	addseq	r5, pc, r1
     7c4:	00000000 	andeq	r0, r0, r0
     7c8:	6e000000 	cdpvs	0, 0, cr0, cr0, cr0, {0}
     7cc:	8c000014 	stchi	0, cr0, [r0], {20}
     7d0:	02000014 	andeq	r0, r0, #20
     7d4:	8c9f3200 	lfmhi	f3, 4, [pc], {0}
     7d8:	9c000014 	stcls	0, cr0, [r0], {20}
     7dc:	02000014 	andeq	r0, r0, #20
     7e0:	009f3000 	addseq	r3, pc, r0
	...
     7f0:	01000000 	mrseq	r0, (UNDEF: 0)
     7f4:	00005000 	andeq	r5, r0, r0
     7f8:	00000000 	andeq	r0, r0, r0
     7fc:	00010000 	andeq	r0, r1, r0
     800:	00000055 	andeq	r0, r0, r5, asr r0
     804:	00000000 	andeq	r0, r0, r0
     808:	f3000400 	vshl.u8	d0, d0, d0
     80c:	009f5001 	addseq	r5, pc, r1
	...
     81c:	01000000 	mrseq	r0, (UNDEF: 0)
     820:	00005100 	andeq	r5, r0, r0, lsl #2
     824:	00000000 	andeq	r0, r0, r0
     828:	00040000 	andeq	r0, r4, r0
     82c:	9f5101f3 	svcls	0x005101f3
	...
     838:	00540001 	subseq	r0, r4, r1
     83c:	00000000 	andeq	r0, r0, r0
     840:	03000000 	movweq	r0, #0
     844:	9f017400 	svcls	0x00017400
	...
     850:	00540001 	subseq	r0, r4, r1
     854:	00000000 	andeq	r0, r0, r0
     858:	9c000000 	stcls	0, cr0, [r0], {-0}
     85c:	d6000014 			; <UNDEFINED> instruction: 0xd6000014
     860:	01000014 	tsteq	r0, r4, lsl r0
     864:	14d65000 	ldrbne	r5, [r6], #0
     868:	14e80000 	strbtne	r0, [r8], #0
     86c:	00040000 	andeq	r0, r4, r0
     870:	9f5001f3 	svcls	0x005001f3
	...
     87c:	000014ac 	andeq	r1, r0, ip, lsr #9
     880:	000014d2 	ldrdeq	r1, [r0], -r2
     884:	d2540001 	subsle	r0, r4, #1
     888:	e8000014 	stmda	r0, {r2, r4}
     88c:	01000014 	tsteq	r0, r4, lsl r0
     890:	00005200 	andeq	r5, r0, r0, lsl #4
     894:	00000000 	andeq	r0, r0, r0
     898:	150c0000 	strne	r0, [ip, #-0]
     89c:	15120000 	ldrne	r0, [r2, #-0]
     8a0:	00010000 	andeq	r0, r1, r0
     8a4:	00151250 	andseq	r1, r5, r0, asr r2
     8a8:	00151600 	andseq	r1, r5, r0, lsl #12
     8ac:	50000100 	andpl	r0, r0, r0, lsl #2
	...
     8b8:	00001512 	andeq	r1, r0, r2, lsl r5
     8bc:	00001516 	andeq	r1, r0, r6, lsl r5
     8c0:	703f0007 	eorsvc	r0, pc, r7
     8c4:	24243200 	strtcs	r3, [r4], #-512	; 0x200
     8c8:	00151a9f 	mulseq	r5, pc, sl	; <UNPREDICTABLE>
     8cc:	00151c00 	andseq	r1, r5, r0, lsl #24
     8d0:	50000100 	andpl	r0, r0, r0, lsl #2
     8d4:	0000151c 	andeq	r1, r0, ip, lsl r5
     8d8:	0000151e 	andeq	r1, r0, lr, lsl r5
     8dc:	00700004 	rsbseq	r0, r0, r4
     8e0:	00009f20 	andeq	r9, r0, r0, lsr #30
     8e4:	00000000 	andeq	r0, r0, r0
     8e8:	15dc0000 	ldrbne	r0, [ip]
     8ec:	15e40000 	strbne	r0, [r4, #0]!
     8f0:	00010000 	andeq	r0, r1, r0
     8f4:	0015f451 	andseq	pc, r5, r1, asr r4	; <UNPREDICTABLE>
     8f8:	0015fc00 	andseq	pc, r5, r0, lsl #24
     8fc:	51000100 	mrspl	r0, (UNDEF: 16)
     900:	00001608 	andeq	r1, r0, r8, lsl #12
     904:	00001614 	andeq	r1, r0, r4, lsl r6
     908:	00510001 	subseq	r0, r1, r1
     90c:	00000000 	andeq	r0, r0, r0
     910:	14000000 	strne	r0, [r0], #-0
     914:	22000016 	andcs	r0, r0, #22
     918:	01000016 	tsteq	r0, r6, lsl r0
     91c:	16225000 	strtne	r5, [r2], -r0
     920:	162c0000 	strtne	r0, [ip], -r0
     924:	00040000 	andeq	r0, r4, r0
     928:	9f5001f3 	svcls	0x005001f3
	...
     934:	0000162c 	andeq	r1, r0, ip, lsr #12
     938:	0000163a 	andeq	r1, r0, sl, lsr r6
     93c:	3a500001 	bcc	1400948 <_etext+0x13f9430>
     940:	44000016 	strmi	r0, [r0], #-22
     944:	04000016 	streq	r0, [r0], #-22
     948:	5001f300 	andpl	pc, r1, r0, lsl #6
     94c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     950:	00000000 	andeq	r0, r0, r0
     954:	00164400 	andseq	r4, r6, r0, lsl #8
     958:	00165c00 	andseq	r5, r6, r0, lsl #24
     95c:	50000100 	andpl	r0, r0, r0, lsl #2
     960:	0000165c 	andeq	r1, r0, ip, asr r6
     964:	0000166c 	andeq	r1, r0, ip, ror #12
     968:	01f30004 	mvnseq	r0, r4
     96c:	00009f50 	andeq	r9, r0, r0, asr pc
     970:	00000000 	andeq	r0, r0, r0
     974:	166c0000 	strbtne	r0, [ip], -r0
     978:	16880000 	strne	r0, [r8], r0
     97c:	00010000 	andeq	r0, r1, r0
     980:	00168850 	andseq	r8, r6, r0, asr r8
     984:	0016a000 	andseq	sl, r6, r0
     988:	f3000400 	vshl.u8	d0, d0, d0
     98c:	009f5001 	addseq	r5, pc, r1
     990:	00000000 	andeq	r0, r0, r0
     994:	c0000000 	andgt	r0, r0, r0
     998:	c2000016 	andgt	r0, r0, #22
     99c:	02000016 	andeq	r0, r0, #22
     9a0:	c29f3000 	addsgt	r3, pc, #0
     9a4:	ea000016 	b	a04 <USART_SetGuardTime+0x10>
     9a8:	01000016 	tsteq	r0, r6, lsl r0
     9ac:	00005500 	andeq	r5, r0, r0, lsl #10
     9b0:	00000000 	andeq	r0, r0, r0
     9b4:	170e0000 	strne	r0, [lr, -r0]
     9b8:	17220000 	strne	r0, [r2, -r0]!
     9bc:	00010000 	andeq	r0, r1, r0
     9c0:	00176453 	andseq	r6, r7, r3, asr r4
     9c4:	00176a00 	andseq	r6, r7, r0, lsl #20
     9c8:	53000100 	movwpl	r0, #256	; 0x100
     9cc:	000017ac 	andeq	r1, r0, ip, lsr #15
     9d0:	000017c8 	andeq	r1, r0, r8, asr #15
     9d4:	d0530001 	subsle	r0, r3, r1
     9d8:	e2000017 	and	r0, r0, #23
     9dc:	01000017 	tsteq	r0, r7, lsl r0
     9e0:	17ec5300 	strbne	r5, [ip, r0, lsl #6]!
     9e4:	17f20000 	ldrbne	r0, [r2, r0]!
     9e8:	00010000 	andeq	r0, r1, r0
     9ec:	00183a53 	andseq	r3, r8, r3, asr sl
     9f0:	00184a00 	andseq	r4, r8, r0, lsl #20
     9f4:	53000100 	movwpl	r0, #256	; 0x100
     9f8:	00001850 	andeq	r1, r0, r0, asr r8
     9fc:	00001864 	andeq	r1, r0, r4, ror #16
     a00:	dc530001 	mrrcle	0, 0, r0, r3, cr1
     a04:	e2000018 	and	r0, r0, #24
     a08:	01000018 	tsteq	r0, r8, lsl r0
     a0c:	00005300 	andeq	r5, r0, r0, lsl #6
     a10:	00000000 	andeq	r0, r0, r0
     a14:	180e0000 	stmdane	lr, {}	; <UNPREDICTABLE>
     a18:	181e0000 	ldmdane	lr, {}	; <UNPREDICTABLE>
     a1c:	00010000 	andeq	r0, r1, r0
     a20:	00182050 	andseq	r2, r8, r0, asr r0
     a24:	00182200 	andseq	r2, r8, r0, lsl #4
     a28:	50000100 	andpl	r0, r0, r0, lsl #2
	...
     a3c:	00500001 	subseq	r0, r0, r1
     a40:	00000000 	andeq	r0, r0, r0
     a44:	01000000 	mrseq	r0, (UNDEF: 0)
     a48:	00005800 	andeq	r5, r0, r0, lsl #16
     a4c:	00000000 	andeq	r0, r0, r0
     a50:	00040000 	andeq	r0, r4, r0
     a54:	9f5001f3 	svcls	0x005001f3
	...
     a68:	00510001 	subseq	r0, r1, r1
     a6c:	00000000 	andeq	r0, r0, r0
     a70:	01000000 	mrseq	r0, (UNDEF: 0)
     a74:	00005600 	andeq	r5, r0, r0, lsl #12
     a78:	00000000 	andeq	r0, r0, r0
     a7c:	00040000 	andeq	r0, r4, r0
     a80:	9f5101f3 	svcls	0x005101f3
	...
     a94:	00520001 	subseq	r0, r2, r1
     a98:	00000000 	andeq	r0, r0, r0
     a9c:	01000000 	mrseq	r0, (UNDEF: 0)
     aa0:	00005700 	andeq	r5, r0, r0, lsl #14
     aa4:	00000000 	andeq	r0, r0, r0
     aa8:	00040000 	andeq	r0, r4, r0
     aac:	9f5201f3 	svcls	0x005201f3
	...
     ac0:	00540001 	subseq	r0, r4, r1
     ac4:	00000000 	andeq	r0, r0, r0
     ac8:	03000000 	movweq	r0, #0
     acc:	9f017400 	svcls	0x00017400
	...
     ad8:	00540001 	subseq	r0, r4, r1
	...
     ae8:	01000000 	mrseq	r0, (UNDEF: 0)
     aec:	00005600 	andeq	r5, r0, r0, lsl #12
     af0:	00000000 	andeq	r0, r0, r0
     af4:	00040000 	andeq	r0, r4, r0
     af8:	9f5101f3 	svcls	0x005101f3
	...
     b0c:	005d0001 	subseq	r0, sp, r1
     b10:	00000000 	andeq	r0, r0, r0
     b14:	04000000 	streq	r0, [r0], #-0
     b18:	7da89100 	stfvcd	f1, [r8]
     b1c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     b20:	00000000 	andeq	r0, r0, r0
     b24:	7d000400 	cfstrsvc	mvf0, [r0, #-0]
     b28:	009f7da8 	addseq	r7, pc, r8, lsr #27
	...
     b38:	01000000 	mrseq	r0, (UNDEF: 0)
     b3c:	00005500 	andeq	r5, r0, r0, lsl #10
	...
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	00040000 	andeq	r0, r4, r0
  b	LoopCopyDataInit
     b50:	9f7e8891 	svcls	0x007e8891
	...
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
     b5c:	00500001 	subseq	r0, r0, r1
	adds	r2, r0, r1
	cmp	r2, r3
     b60:	00000000 	andeq	r0, r0, r0
	bcc	CopyDataInit
     b64:	04000000 	streq	r0, [r0], #-0
	ldr	r2, =_sbss
	b	LoopFillZerobss
     b68:	7e889100 	sinvce	f1, f0
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	str	r3, [r2], #4
     b70:	00000000 	andeq	r0, r0, r0

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
     b74:	50000100 	andpl	r0, r0, r0, lsl #2
	...
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	88910004 	ldmhi	r1, {r2}
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	00009f7e 	andeq	r9, r0, lr, ror pc
	ldr	r3, =_edata
     b88:	00000000 	andeq	r0, r0, r0
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	00010000 	andeq	r0, r1, r0
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	00000051 	andeq	r0, r0, r1, asr r0
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	00000000 	andeq	r0, r0, r0
}


/* dummy proc */
void nothingProc(void)
{
     b98:	91000400 	tstls	r0, r0, lsl #8
{
    return;
}

void usbStatusOut(void)
{
     b9c:	009f7e88 	addseq	r7, pc, r8, lsl #29
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
     ba0:	00000000 	andeq	r0, r0, r0
     ba4:	04000000 	streq	r0, [r0], #-0
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	7e887d00 	cdpvc	13, 8, cr7, cr8, cr0, {0}
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
        bDeviceState = CONFIGURED;
     bbc:	91000400 	tstls	r0, r0, lsl #8
     bc0:	009f7de8 	addseq	r7, pc, r8, ror #27
    }
}

void usbGetInterface(void)
{
     bc4:	00000000 	andeq	r0, r0, r0
{
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	01000000 	mrseq	r0, (UNDEF: 0)
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	00005100 	andeq	r5, r0, r0, lsl #2
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	00000000 	andeq	r0, r0, r0
     bd4:	00040000 	andeq	r0, r4, r0
     bd8:	9f7de891 	svcls	0x007de891
	...
void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	00500001 	subseq	r0, r0, r1

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be8:	00000000 	andeq	r0, r0, r0
     bec:	04000000 	streq	r0, [r0], #-0
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	7de89100 	stfvcp	f1, [r8]
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     bf8:	00000000 	andeq	r0, r0, r0

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfc:	7d000400 	cfstrsvc	mvf0, [r0, #-0]
     c00:	009f7de8 	addseq	r7, pc, r8, ror #27
	...
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c10:	04000000 	streq	r0, [r0], #-0
     c14:	7dc89100 	stfvcp	f1, [r8]
     c18:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     c1c:	00000000 	andeq	r0, r0, r0

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c20:	52000100 	andpl	r0, r0, #0, 2
	...
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	c8910004 	ldmgt	r1, {r2}
     c30:	00009f7d 	andeq	r9, r0, sp, ror pc
     c34:	00000000 	andeq	r0, r0, r0
     c38:	00010000 	andeq	r0, r1, r0
     c3c:	00000050 	andeq	r0, r0, r0, asr r0

    Clear_Status_Out(ENDP0);
     c40:	00000000 	andeq	r0, r0, r0

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c44:	91000400 	tstls	r0, r0, lsl #8
     c48:	009f7dc8 	addseq	r7, pc, r8, asr #27
     c4c:	00000000 	andeq	r0, r0, r0
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	01000000 	mrseq	r0, (UNDEF: 0)
     c54:	00005100 	andeq	r5, r0, r0, lsl #2

    bDeviceState = ATTACHED;
     c58:	00000000 	andeq	r0, r0, r0
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
     c5c:	00040000 	andeq	r0, r4, r0

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	9f7dc891 	svcls	0x007dc891
	...
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c6c:	c87d0004 	ldmdagt	sp!, {r2}^
     c70:	00009f7d 	andeq	r9, r0, sp, ror pc
	...
     c80:	00010000 	andeq	r0, r1, r0
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	0000005d 	andeq	r0, r0, sp, asr r0
     c88:	00000000 	andeq	r0, r0, r0
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8c:	91000400 	tstls	r0, r0, lsl #8
     c90:	009f7da8 	addseq	r7, pc, r8, lsr #27
     c94:	00000000 	andeq	r0, r0, r0
        if (dfuUpdateByRequest()) {
     c98:	04000000 	streq	r0, [r0], #-0
     c9c:	7da87d00 	stcvc	13, cr7, [r8]
            // successfull state transition, handle the request
            switch (request) {
     ca0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	01f30004 	mvnseq	r0, r4
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
     cc0:	00009f51 	andeq	r9, r0, r1, asr pc
	...

        return USB_SUCCESS;
    }

    return USB_UNSUPPORT;
}
     cd0:	00040000 	andeq	r0, r4, r0
     cd4:	9f7ec891 	svcls	0x007ec891
	...
     ce0:	00500001 	subseq	r0, r0, r1
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	00000000 	andeq	r0, r0, r0
     ce8:	04000000 	streq	r0, [r0], #-0
     cec:	7ec89100 	acsvce	f1, f0
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     cf4:	00000000 	andeq	r0, r0, r0
     cf8:	52000100 	andpl	r0, r0, #0, 2
	...
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
    if (strIndex > STR_DESC_LEN) {
     d04:	c8910004 	ldmgt	r1, {r2}
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d08:	00009f7e 	andeq	r9, r0, lr, ror pc
     d0c:	00000000 	andeq	r0, r0, r0
    }
}
     d10:	00040000 	andeq	r0, r4, r0
     d14:	9f7ec87d 	svcls	0x007ec87d
	...

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	a8910004 	ldmge	r1, {r2}
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2c:	00009f7e 	andeq	r9, r0, lr, ror pc
     d30:	00000000 	andeq	r0, r0, r0
     d34:	00010000 	andeq	r0, r1, r0
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	00000052 	andeq	r0, r0, r2, asr r0
     d3c:	00000000 	andeq	r0, r0, r0
            return USB_SUCCESS;
     d40:	91000400 	tstls	r0, r0, lsl #8
     d44:	009f7ea8 	addseq	r7, pc, r8, lsr #29
        }
    }
    return USB_UNSUPPORT;
}
     d48:	00000000 	andeq	r0, r0, r0
     d4c:	04000000 	streq	r0, [r0], #-0

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	7ea87d00 	cdpvc	13, 10, cr7, cr8, cr0, {0}
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d54:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	00000000 	andeq	r0, r0, r0
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5c:	00196000 	andseq	r6, r9, r0
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d60:	0019b400 	andseq	fp, r9, r0, lsl #8
     d64:	50000100 	andpl	r0, r0, r0, lsl #2
     d68:	000019b4 			; <UNDEFINED> instruction: 0x000019b4
     d6c:	000019cc 	andeq	r1, r0, ip, asr #19
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d70:	cc540001 	mrrcgt	0, 0, r0, r4, cr1
     d74:	cf000019 	svcgt	0x00000019
     d78:	03000019 	movweq	r0, #25
     d7c:	9f407000 	svcls	0x00407000
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d80:	000019cf 	andeq	r1, r0, pc, asr #19
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	000019d0 	ldrdeq	r1, [r0], -r0
     d88:	01f30004 	mvnseq	r0, r4
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8c:	00009f50 	andeq	r9, r0, r0, asr pc
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d90:	00000000 	andeq	r0, r0, r0
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d94:	19600000 	stmdbne	r0!, {}^	; <UNPREDICTABLE>
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d98:	196e0000 	stmdbne	lr!, {}^	; <UNPREDICTABLE>

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	00010000 	andeq	r0, r1, r0
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	00196e51 	andseq	r6, r9, r1, asr lr
     da4:	0019cc00 	andseq	ip, r9, r0, lsl #24
     da8:	55000100 	strpl	r0, [r0, #-256]	; 0x100
     dac:	000019cc 	andeq	r1, r0, ip, asr #19
     db0:	000019cf 	andeq	r1, r0, pc, asr #19
     db4:	cf510001 	svcgt	0x00510001
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	d0000019 	andle	r0, r0, r9, lsl r0
     dbc:	04000019 	streq	r0, [r0], #-25
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dc0:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     dc8:	00000000 	andeq	r0, r0, r0
     dcc:	00196000 	andseq	r6, r9, r0
     dd0:	00199800 	andseq	r9, r9, r0, lsl #16
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	52000100 	andpl	r0, r0, #0, 2
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd8:	00001998 	muleq	r0, r8, r9
     ddc:	000019cc 	andeq	r1, r0, ip, asr #19

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	cc560001 	mrrcgt	0, 0, r0, r6, cr1
     de4:	cf000019 	svcgt	0x00000019
     de8:	01000019 	tsteq	r0, r9, lsl r0
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	19cf5200 	stmibne	pc, {r9, ip, lr}^	; <UNPREDICTABLE>
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	19d00000 	ldmibne	r0, {}^	; <UNPREDICTABLE>
        ResumeS.eState = eResumeSetVal;
     df4:	00040000 	andeq	r0, r4, r0

    switch (ResumeS.eState) {
     df8:	9f5201f3 	svcls	0x005201f3
	...
     e04:	000019ae 	andeq	r1, r0, lr, lsr #19
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	000019cc 	andeq	r1, r0, ip, asr #19
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	cc550001 	mrrcgt	0, 0, r0, r5, cr1
        ResumeS.eState = RESUME_START;
     e10:	cf000019 	svcgt	0x00000019
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	01000019 	tsteq	r0, r9, lsl r0
        ResumeS.eState = RESUME_WAIT;
     e18:	19cf5100 	stmibne	pc, {r8, ip, lr}^	; <UNPREDICTABLE>
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	19d00000 	ldmibne	r0, {}^	; <UNPREDICTABLE>
     e20:	00040000 	andeq	r0, r4, r0
        if (ResumeS.bESOFcnt == 0)
     e24:	9f5101f3 	svcls	0x005101f3
	...
            ResumeS.eState = RESUME_START;
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e30:	000019ae 	andeq	r1, r0, lr, lsr #19
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e34:	000019b4 			; <UNDEFINED> instruction: 0x000019b4
        ResumeS.eState = RESUME_ON;
     e38:	b4500001 	ldrblt	r0, [r0], #-1
        ResumeS.bESOFcnt = 10;
     e3c:	cc000019 	stcgt	0, cr0, [r0], {25}
        break;
     e40:	01000019 	tsteq	r0, r9, lsl r0
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e44:	19cc5400 	stmibne	ip, {sl, ip, lr}^
     e48:	19cf0000 	stmibne	pc, {}^	; <UNPREDICTABLE>
        if (ResumeS.bESOFcnt == 0) {
     e4c:	00030000 	andeq	r0, r3, r0
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	cf9f4070 	svcgt	0x009f4070
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	d0000019 	andle	r0, r0, r9, lsl r0
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e58:	04000019 	streq	r0, [r0], #-25
            ResumeS.eState = RESUME_OFF;
     e5c:	5001f300 	andpl	pc, r1, r0, lsl #6
     e60:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e64:	00000000 	andeq	r0, r0, r0
     e68:	0019ae00 	andseq	sl, r9, r0, lsl #28
     e6c:	0019b400 	andseq	fp, r9, r0, lsl #8
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	70000300 	andvc	r0, r0, r0, lsl #6
     e74:	19b49f20 	ldmibne	r4!, {r5, r8, r9, sl, fp, ip, pc}
     e78:	19cc0000 	stmibne	ip, {}^	; <UNPREDICTABLE>
     e7c:	00030000 	andeq	r0, r3, r0

    _SetCNTR(CNTR_FRES);
     e80:	cc9f2074 	ldcgt	0, cr2, [pc], {116}	; 0x74
     e84:	cf000019 	svcgt	0x00000019
     e88:	03000019 	movweq	r0, #25
     e8c:	9f607000 	svcls	0x00607000
    _SetCNTR(0);
    _SetISTR(0);
     e90:	000019cf 	andeq	r1, r0, pc, asr #19

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e94:	000019d0 	ldrdeq	r1, [r0], -r0
    _SetCNTR(wInterrupt_Mask);
     e98:	01f30006 	mvnseq	r0, r6
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9c:	9f202350 	svcls	0x00202350
	...
#endif
#endif

    return USB_SUCCESS;
}
     ea8:	000019d0 	ldrdeq	r1, [r0], -r0
     eac:	000019dc 	ldrdeq	r1, [r0], -ip
     eb0:	dc500001 	mrrcle	0, 0, r0, r0, cr1	; <UNPREDICTABLE>
     eb4:	0a000019 	beq	f20 <usbInit+0x4>

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	0100001a 	tsteq	r0, sl, lsl r0
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	00005600 	andeq	r5, r0, r0, lsl #12
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
     ec0:	00000000 	andeq	r0, r0, r0
     ec4:	19d00000 	ldmibne	r0, {}^	; <UNPREDICTABLE>
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec8:	19e00000 	stmibne	r0!, {}^	; <UNPREDICTABLE>
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     ecc:	00010000 	andeq	r0, r1, r0
     ed0:	0019e051 	andseq	lr, r9, r1, asr r0
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	001a0a00 	andseq	r0, sl, r0, lsl #20
     ed8:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...

    return USB_SUCCESS;
}
     ee4:	000019d0 	ldrdeq	r1, [r0], -r0
     ee8:	000019e3 	andeq	r1, r0, r3, ror #19
     eec:	e3520001 	cmp	r2, #1
     ef0:	0a000019 	beq	f5c <usbDsbISR>
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	0100001a 	tsteq	r0, sl, lsl r0
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	00005400 	andeq	r5, r0, r0, lsl #8
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efc:	00000000 	andeq	r0, r0, r0
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	1a0c0000 	bne	300f08 <_etext+0x2f99f0>
     f04:	1a180000 	bne	600f0c <_etext+0x5f99f4>
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f08:	00010000 	andeq	r0, r1, r0
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	001a1850 	andseq	r1, sl, r0, asr r8
     f10:	001a6a00 	andseq	r6, sl, r0, lsl #20
    nvicInit(&NVIC_InitStructure);
     f14:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    return USB_SUCCESS;
}

void usbInit(void)
{
    dfuInit();
     f20:	00001a0c 	andeq	r1, r0, ip, lsl #20

    pInformation->Current_Configuration = 0;
     f24:	00001a1e 	andeq	r1, r0, lr, lsl sl
     f28:	1e510001 	cdpne	0, 5, cr0, cr1, cr1, {0}
    usbPowerOn();
     f2c:	6a00001a 	bvs	f9c <USB_LP_CAN1_RX0_IRQHandler+0x1c>

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
     f30:	0100001a 	tsteq	r0, sl, lsl r0
     f34:	00005700 	andeq	r5, r0, r0, lsl #14
     f38:	00000000 	andeq	r0, r0, r0
    _SetCNTR(wInterrupt_Mask);
     f3c:	1a0c0000 	bne	300f44 <_etext+0x2f9a2c>

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f40:	1a1a0000 	bne	680f48 <_etext+0x679a30>
    bDeviceState = UNCONNECTED;
     f44:	00010000 	andeq	r0, r1, r0
     f48:	001a1a52 	andseq	r1, sl, r2, asr sl
     f4c:	001a6a00 	andseq	r6, sl, r0, lsl #20
     f50:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	00001a62 	andeq	r1, r0, r2, ror #20
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f60:	00001a64 	andeq	r1, r0, r4, ror #20
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	00540001 	subseq	r0, r4, r1

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f68:	00000000 	andeq	r0, r0, r0
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	16000000 	strne	r0, [r0], -r0
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	1e00001a 	mcrne	0, 0, r0, cr0, cr10, {0}
    nvicInit(&NVIC_InitStructure);
     f74:	0100001a 	tsteq	r0, sl, lsl r0
}
     f78:	1a1e5100 	bne	795380 <_etext+0x78de68>
     f7c:	1a6a0000 	bne	1a80f84 <_etext+0x1a79a6c>

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	00010000 	andeq	r0, r1, r0
    wIstr = _GetISTR();
     f84:	00000057 	andeq	r0, r0, r7, asr r0

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	00000000 	andeq	r0, r0, r0
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8c:	001a1600 	andseq	r1, sl, r0, lsl #12

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f90:	001a6800 	andseq	r6, sl, r0, lsl #16
     f94:	5d000100 	stfpls	f0, [r0, #-0]
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	00001a68 	andeq	r1, r0, r8, ror #20
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	00001a6a 	andeq	r1, r0, sl, ror #20
     fa0:	48910003 	ldmmi	r1, {r0, r1}
     fa4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
        _SetISTR((u16)CLR_RESET);
     fa8:	00000000 	andeq	r0, r0, r0
        Device_Property.Reset();
     fac:	001a6c00 	andseq	r6, sl, r0, lsl #24
     fb0:	001aac00 	andseq	sl, sl, r0, lsl #24
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb4:	50000100 	andpl	r0, r0, r0, lsl #2
     fb8:	00001aac 	andeq	r1, r0, ip, lsr #21
        _SetISTR((u16)CLR_ERR);
     fbc:	00001b2c 	andeq	r1, r0, ip, lsr #22
     fc0:	2c540001 	mrrccs	0, 0, r0, r4, cr1
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc4:	3400001b 	strcc	r0, [r0], #-27
     fc8:	0400001b 	streq	r0, [r0], #-27
        _SetISTR((u16)CLR_WKUP);
     fcc:	5001f300 	andpl	pc, r1, r0, lsl #6
        usbResume(RESUME_EXTERNAL);
     fd0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     fd4:	00000000 	andeq	r0, r0, r0
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd8:	001a6c00 	andseq	r6, sl, r0, lsl #24
     fdc:	001ab100 	andseq	fp, sl, r0, lsl #2

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	51000100 	mrspl	r0, (UNDEF: 16)
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	00001ab1 			; <UNDEFINED> instruction: 0x00001ab1
     fe8:	00001b34 	andeq	r1, r0, r4, lsr fp
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fec:	01f30004 	mvnseq	r0, r4
     ff0:	00009f51 	andeq	r9, r0, r1, asr pc
        _SetISTR((u16)CLR_SOF);
     ff4:	00000000 	andeq	r0, r0, r0
     ff8:	1a6c0000 	bne	1b01000 <_etext+0x1af9ae8>
        bIntPackSOF++;
     ffc:	1aa40000 	bne	fe901004 <BootRAM+0xd8717a5>
    1000:	00010000 	andeq	r0, r1, r0
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	001aa452 	andseq	sl, sl, r2, asr r4
    1008:	001b3400 	andseq	r3, fp, r0, lsl #8
        _SetISTR((u16)CLR_ESOF);
    100c:	f3000400 	vshl.u8	d0, d0, d0
    1010:	009f5201 	addseq	r5, pc, r1, lsl #4
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    }
#endif

}
    1014:	00000000 	andeq	r0, r0, r0
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	80000000 	andhi	r0, r0, r0
    101c:	2c00001a 	stccs	0, cr0, [r0], {26}
    1020:	0800001b 	stmdaeq	r0, {r0, r1, r3, r4}
    1024:	37007800 	strcc	r7, [r0, -r0, lsl #16]
    1028:	1aff0825 	bne	fffc30c4 <BootRAM+0xef33865>
    102c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    1030:	00000000 	andeq	r0, r0, r0
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

void print_hash(unsigned char hash[])
{
    1034:	001a8000 	andseq	r8, sl, r0
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
}

int main() 
{
    1038:	001aa400 	andseq	sl, sl, r0, lsl #8
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    103c:	52000100 	andpl	r0, r0, #0, 2
    setupCLK();
    1040:	00001aa4 	andeq	r1, r0, r4, lsr #21
    setupLEDAndButton();
    1044:	00001b34 	andeq	r1, r0, r4, lsr fp
    setupUSB();
    1048:	01f30004 	mvnseq	r0, r4
    setupFLASH();
    104c:	00009f52 	andeq	r9, r0, r2, asr pc
    uartInit();
    1050:	00000000 	andeq	r0, r0, r0
    usbReset();
    1054:	1a800000 	bne	fe00105c <BootRAM+0xcf717fd>
	uart_printf("\nBootloader init...\n");
    1058:	1ab10000 	bne	fec41060 <BootRAM+0xdbb1801>
    105c:	00010000 	andeq	r0, r1, r0

    if (readPin(GPIOB, 15) == 0x0)
    1060:	001ab151 	andseq	fp, sl, r1, asr r1
    1064:	001b3400 	andseq	r3, fp, r0, lsl #8
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1068:	f3000400 	vshl.u8	d0, d0, d0
    106c:	009f5101 	addseq	r5, pc, r1, lsl #2
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    1070:	00000000 	andeq	r0, r0, r0
    1074:	34000000 	strcc	r0, [r0], #-0
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
    1078:	4a00001b 	bmi	10ec <main+0xb4>
    107c:	0100001b 	tsteq	r0, fp, lsl r0
    1080:	1b4a5000 	blne	1295088 <_etext+0x128db70>
   debug_print("\n", 0);
}

int main() 
{
	bool no_user_jump = FALSE;
    1084:	1c100000 	ldcne	0, cr0, [r0], {-0}
    1088:	00010000 	andeq	r0, r1, r0
    108c:	001c1056 	andseq	r1, ip, r6, asr r0
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1090:	001c1400 	andseq	r1, ip, r0, lsl #8
			no_user_jump = FALSE;
    1094:	f3000400 	vshl.u8	d0, d0, d0
			break;

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    1098:	009f5001 	addseq	r5, pc, r1
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    109c:	00000000 	andeq	r0, r0, r0
    10a0:	34000000 	strcc	r0, [r0], #-0
			break;

		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10a4:	4600001b 			; <UNDEFINED> instruction: 0x4600001b
    10a8:	0100001b 	tsteq	r0, fp, lsl r0
    10ac:	1b465100 	blne	11954b4 <_etext+0x118df9c>
    10b0:	1c100000 	ldcne	0, cr0, [r0], {-0}
    10b4:	00010000 	andeq	r0, r1, r0

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10b8:	001c1055 	andseq	r1, ip, r5, asr r0
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10bc:	001c1400 	andseq	r1, ip, r0, lsl #8
    10c0:	f3000400 	vshl.u8	d0, d0, d0
    10c4:	009f5101 	addseq	r5, pc, r1, lsl #2
    10c8:	00000000 	andeq	r0, r0, r0

		if (dfuUploadStarted()) 
    10cc:	34000000 	strcc	r0, [r0], #-0
    10d0:	4800001b 	stmdami	r0, {r0, r1, r3, r4}
		{
			uart_printf("DFU finished upload\n");
    10d4:	0100001b 	tsteq	r0, fp, lsl r0
			dfuFinishUpload(); // systemHardReset from DFU once done
    10d8:	1b485200 	blne	12158e0 <_etext+0x120e3c8>
    10dc:	1c100000 	ldcne	0, cr0, [r0], {-0}
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10e0:	00010000 	andeq	r0, r1, r0
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10e4:	001c1054 	andseq	r1, ip, r4, asr r0
    10e8:	001c1400 	andseq	r1, ip, r0, lsl #8
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10ec:	f3000400 	vshl.u8	d0, d0, d0
	}
	
	return 0;// Added to please the compiler
    10f0:	009f5201 	addseq	r5, pc, r1, lsl #4
    10f4:	00000000 	andeq	r0, r0, r0
    10f8:	14000000 	strne	r0, [r0], #-0
    10fc:	2200001c 	andcs	r0, r0, #28
    1100:	0100001c 	tsteq	r0, ip, lsl r0
    1104:	1c225000 	stcne	0, cr5, [r2], #-0
    1108:	1cc80000 	stclne	0, cr0, [r8], {0}
    110c:	00010000 	andeq	r0, r1, r0
    1110:	00000054 	andeq	r0, r0, r4, asr r0
    1114:	00000000 	andeq	r0, r0, r0
    1118:	001c1400 	andseq	r1, ip, r0, lsl #8
    111c:	001c2700 	andseq	r2, ip, r0, lsl #14
    1120:	51000100 	mrspl	r0, (UNDEF: 16)
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1124:	00001c27 	andeq	r1, r0, r7, lsr #24
    1128:	00001cc8 	andeq	r1, r0, r8, asr #25
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    112c:	00550001 	subseq	r0, r5, r1
    1130:	00000000 	andeq	r0, r0, r0
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1134:	c8000000 	stmdagt	r0, {}	; <UNPREDICTABLE>
    1138:	d600001c 			; <UNDEFINED> instruction: 0xd600001c
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    113c:	0100001c 	tsteq	r0, ip, lsl r0
    1140:	1cd65000 	ldclne	0, cr5, [r6], {0}
        return TRUE;
    } else {
        return FALSE;
    }
}
    1144:	1d460000 	stclne	0, cr0, [r6, #-0]
    1148:	00010000 	andeq	r0, r1, r0

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    114c:	001d4658 	andseq	r4, sp, r8, asr r6
    1150:	001d4c00 	andseq	r4, sp, r0, lsl #24
    1154:	f3000400 	vshl.u8	d0, d0, d0
    gpio_write_bit( bank,pin,1-onState);
    1158:	009f5001 	addseq	r5, pc, r1
    115c:	00000000 	andeq	r0, r0, r0
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	c8000000 	stmdagt	r0, {}	; <UNPREDICTABLE>
    gpio_write_bit( bank,pin,1-onState);
    1164:	d800001c 	stmdale	r0, {r2, r3, r4}

    u32 c;
    while (count-- > 0) 
    1168:	0100001c 	tsteq	r0, ip, lsl r0
	{
        for (c = rate; c > 0; c--)
    116c:	1cd85100 	ldfnee	f5, [r8], {0}
    1170:	1d460000 	stclne	0, cr0, [r6, #-0]
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1174:	00010000 	andeq	r0, r1, r0
    1178:	001d4657 	andseq	r4, sp, r7, asr r6
    117c:	001d4c00 	andseq	r4, sp, r0, lsl #24
		
        for (c = rate; c > 0; c--)
    1180:	f3000400 	vshl.u8	d0, d0, d0
    1184:	009f5101 	addseq	r5, pc, r1, lsl #2
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    1188:	00000000 	andeq	r0, r0, r0
    118c:	c8000000 	stmdagt	r0, {}	; <UNPREDICTABLE>
    1190:	da00001c 	ble	1208 <hexdump+0xa>
    1194:	0100001c 	tsteq	r0, ip, lsl r0
    1198:	1cda5200 	lfmne	f5, 2, [sl], {0}

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    119c:	1d460000 	stclne	0, cr0, [r6, #-0]
    11a0:	00010000 	andeq	r0, r1, r0
  USARTx->DR = ch;  
    11a4:	001d4656 	andseq	r4, sp, r6, asr r6
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11a8:	001d4c00 	andseq	r4, sp, r0, lsl #24
  while(*str != 0)
    11ac:	f3000400 	vshl.u8	d0, d0, d0
    11b0:	009f5201 	addseq	r5, pc, r1, lsl #4
  {
    UU_PutChar(USARTx, *str);
    11b4:	00000000 	andeq	r0, r0, r0
    11b8:	de000000 	cdple	0, 0, cr0, cr0, cr0, {0}
    str++;
  }
}

void vprint(const char *fmt, va_list argp)
{
    11bc:	e000001c 	and	r0, r0, ip, lsl r0
    11c0:	0300001c 	movweq	r0, #28
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11c4:	9fff0800 	svcls	0x00ff0800
    11c8:	00001ce0 	andeq	r1, r0, r0, ror #25
    11cc:	00001d2a 	andeq	r1, r0, sl, lsr #26
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11d0:	2a540001 	bcs	15011dc <_etext+0x14f9cc4>
    11d4:	3200001d 	andcc	r0, r0, #29

    }
}
    11d8:	0300001d 	movweq	r0, #29
    11dc:	9f017400 	svcls	0x00017400
    11e0:	00001d32 	andeq	r1, r0, r2, lsr sp

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11e4:	00001d46 	andeq	r1, r0, r6, asr #26
    11e8:	00540001 	subseq	r0, r4, r1
    11ec:	00000000 	andeq	r0, r0, r0
    va_list argp;
    va_start(argp, fmt);
    vprint(fmt, argp);
    11f0:	ce000000 	cdpgt	0, 0, cr0, cr0, cr0, {0}
    va_end(argp);
}
    11f4:	4200001c 	andmi	r0, r0, #28
    11f8:	0100001d 	tsteq	r0, sp, lsl r0
    11fc:	1d425d00 	stclne	13, cr5, [r2, #-0]

void hexdump(unsigned char *data, size_t size)
{
    1200:	1d460000 	stclne	0, cr0, [r6, #-0]
    int i;
    char cs[17];
    memset(cs, 0, 17);
    1204:	00040000 	andeq	r0, r4, r0
    1208:	9f7de891 	svcls	0x007de891
    120c:	00001d46 	andeq	r1, r0, r6, asr #26

    for(i = 0; i < size; i++)
    1210:	00001d4c 	andeq	r1, r0, ip, asr #26
    {
        if(i != 0 && i % 0x10 == 0)
    1214:	e87d0004 	ldmda	sp!, {r2}^
    1218:	00009f7d 	andeq	r9, r0, sp, ror pc
        {
            debug_print(" |%s|\n", cs);
            memset(cs, 0, 17);
    121c:	00000000 	andeq	r0, r0, r0
    1220:	1cf60000 	ldclne	0, cr0, [r6]
{
    int i;
    char cs[17];
    memset(cs, 0, 17);

    for(i = 0; i < size; i++)
    1224:	1d460000 	stclne	0, cr0, [r6, #-0]
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
}
    1228:	00010000 	andeq	r0, r1, r0


#endif
void uartInit(void) {
    122c:	00000055 	andeq	r0, r0, r5, asr r0
    1230:	00000000 	andeq	r0, r0, r0
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    1234:	001d3600 	andseq	r3, sp, r0, lsl #12
    1238:	001d4200 	andseq	r4, sp, r0, lsl #4
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    123c:	5d000100 	stfpls	f0, [r0, #-0]
    1240:	00001d42 	andeq	r1, r0, r2, asr #26
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    1244:	00001d46 	andeq	r1, r0, r6, asr #26
    1248:	e8910004 	ldm	r1, {r2}
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    124c:	1d469f7d 	stclne	15, cr9, [r6, #-500]	; 0xfffffe0c
    1250:	1d4c0000 	stclne	0, cr0, [ip, #-0]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1254:	00040000 	andeq	r0, r4, r0
    1258:	9f7de87d 	svcls	0x007de87d
	...
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    1264:	00001d36 	andeq	r1, r0, r6, lsr sp
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1268:	00001d46 	andeq	r1, r0, r6, asr #26
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    126c:	46580001 	ldrbmi	r0, [r8], -r1
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1270:	4c00001d 	stcmi	0, cr0, [r0], {29}
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1274:	0400001d 	streq	r0, [r0], #-29
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1278:	5001f300 	andpl	pc, r1, r0, lsl #6
    127c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    128c:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1298:	00560001 	subseq	r0, r6, r1
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    129c:	00000000 	andeq	r0, r0, r0
        
    USART_Init(USART1, &USART_InitStructure);
    12a0:	04000000 	streq	r0, [r0], #-0
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    12a4:	5001f300 	andpl	pc, r1, r0, lsl #6
    12a8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
}

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    12b8:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    12c4:	00570001 	subseq	r0, r7, r1
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    12c8:	00000000 	andeq	r0, r0, r0
    12cc:	04000000 	streq	r0, [r0], #-0
    12d0:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    12d4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    12e4:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    12f0:	00570001 	subseq	r0, r7, r1
    12f4:	00000000 	andeq	r0, r0, r0
    12f8:	04000000 	streq	r0, [r0], #-0
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    12fc:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    1300:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    1310:	91000400 	tstls	r0, r0, lsl #8
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    1314:	009f7ea8 	addseq	r7, pc, r8, lsr #29
    1318:	00000000 	andeq	r0, r0, r0
    131c:	01000000 	mrseq	r0, (UNDEF: 0)
    1320:	00005100 	andeq	r5, r0, r0, lsl #2
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    1324:	00000000 	andeq	r0, r0, r0
    1328:	00040000 	andeq	r0, r4, r0

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    132c:	9f7ea891 	svcls	0x007ea891
	...
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    1338:	00520001 	subseq	r0, r2, r1
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    133c:	00000000 	andeq	r0, r0, r0
    1340:	04000000 	streq	r0, [r0], #-0
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    1344:	7ea89100 	tanvce	f1, f0
    1348:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    134c:	00000000 	andeq	r0, r0, r0
    1350:	7d000400 	cfstrsvc	mvf0, [r0, #-0]
    1354:	009f7ea8 	addseq	r7, pc, r8, lsr #29
	...

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    1364:	01000000 	mrseq	r0, (UNDEF: 0)
    1368:	00005400 	andeq	r5, r0, r0, lsl #8
    136c:	00000000 	andeq	r0, r0, r0
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    1370:	00030000 	andeq	r0, r3, r0
    1374:	009f7074 	addseq	r7, pc, r4, ror r0	; <UNPREDICTABLE>
        u32 rwmVal = pRCC->CR;
    1378:	00000000 	andeq	r0, r0, r0
        rwmVal |= 0x01;
    137c:	03000000 	movweq	r0, #0
        pRCC->CR = rwmVal;
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    1380:	9f607400 	svcls	0x00607400
	...
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    138c:	50740003 	rsbspl	r0, r4, r3
void setMspAndJump(u32 usrAddr) {
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    1390:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1394:	00000000 	andeq	r0, r0, r0

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1398:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    13a4:	50740003 	rsbspl	r0, r4, r3
    13a8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    13ac:	00000000 	andeq	r0, r0, r0
    13b0:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    13bc:	50740003 	rsbspl	r0, r4, r3

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    13c4:	00000000 	andeq	r0, r0, r0

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13c8:	91000400 	tstls	r0, r0, lsl #8
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    13cc:	009f7ee8 	addseq	r7, pc, r8, ror #29
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d0:	00000000 	andeq	r0, r0, r0

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    13d4:	01000000 	mrseq	r0, (UNDEF: 0)
    13d8:	00005000 	andeq	r5, r0, r0
    13dc:	00000000 	andeq	r0, r0, r0
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    13e0:	00040000 	andeq	r0, r4, r0
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    13e4:	9f7ee891 	svcls	0x007ee891
	...
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    13f0:	00520001 	subseq	r0, r2, r1
    13f4:	00000000 	andeq	r0, r0, r0
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    13f8:	04000000 	streq	r0, [r0], #-0
    13fc:	7ee89100 	urdvce	f1, f0
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    1400:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    1404:	00000000 	andeq	r0, r0, r0
    1408:	7d000400 	cfstrsvc	mvf0, [r0, #-0]
    140c:	009f7ee8 	addseq	r7, pc, r8, ror #29
	...
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    rNVIC->ICER[1] = 0xFFFFFFFF;
    141c:	04000000 	streq	r0, [r0], #-0
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    1420:	7ea89100 	tanvce	f1, f0
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    1424:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    1428:	00000000 	andeq	r0, r0, r0
    142c:	52000100 	andpl	r0, r0, #0, 2
	...
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    1438:	a8910004 	ldmge	r1, {r2}
    nvicDisableInterrupts();
    143c:	00009f7e 	andeq	r9, r0, lr, ror pc
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    1440:	00000000 	andeq	r0, r0, r0
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    1444:	00040000 	andeq	r0, r4, r0
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    1448:	9f7ea87d 	svcls	0x007ea87d
	...
    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    145c:	00520001 	subseq	r0, r2, r1
    1460:	00000000 	andeq	r0, r0, r0
    1464:	04000000 	streq	r0, [r0], #-0
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1468:	7ea89100 	tanvce	f1, f0
    146c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    1470:	00000000 	andeq	r0, r0, r0

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1474:	7d000400 	cfstrsvc	mvf0, [r0, #-0]
    1478:	009f7ea8 	addseq	r7, pc, r8, lsr #29
	...
    SET_REG(FLASH_AR, pageAddr);
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1488:	01000000 	mrseq	r0, (UNDEF: 0)

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    148c:	00005600 	andeq	r5, r0, r0, lsl #12

    return TRUE;
}
    1490:	00000000 	andeq	r0, r0, r0
    1494:	00040000 	andeq	r0, r4, r0
    1498:	9f5001f3 	svcls	0x005001f3
	...
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;

    u32 rwmVal = GET_REG(FLASH_CR);
    SET_REG(FLASH_CR, FLASH_CR_PG);
    14ac:	e8910004 	ldm	r1, {r2}

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14b0:	00009f7e 	andeq	r9, r0, lr, ror pc
    14b4:	00000000 	andeq	r0, r0, r0
    *(flashAddr + 0x01) = (vu16)hhWord;
    14b8:	00010000 	andeq	r0, r1, r0
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14bc:	00000052 	andeq	r0, r0, r2, asr r0
    14c0:	00000000 	andeq	r0, r0, r0
    *(flashAddr) = (vu16)lhWord;
    14c4:	91000400 	tstls	r0, r0, lsl #8
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    14c8:	009f7ee8 	addseq	r7, pc, r8, ror #29
    14cc:	00000000 	andeq	r0, r0, r0

    rwmVal &= 0xFFFFFFFE;
    14d0:	04000000 	streq	r0, [r0], #-0
    SET_REG(FLASH_CR, rwmVal);

    /* verify the write */
    if (*(vu32 *)addr != word) {
    14d4:	7ee87d00 	cdpvc	13, 14, cr7, cr8, cr0, {0}
        return FALSE;
    }

    return TRUE;
}
    14d8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    14e8:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    14f4:	01f30004 	mvnseq	r0, r4
    14f8:	00009f50 	andeq	r9, r0, r0, asr pc
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    14fc:	00000000 	andeq	r0, r0, r0
    1500:	1d4c0000 	stclne	0, cr0, [ip, #-0]
    1504:	1d580000 	ldclne	0, cr0, [r8, #-0]
    1508:	00010000 	andeq	r0, r1, r0

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    150c:	001d5850 	andseq	r5, sp, r0, asr r8
	{
		pin-=8;
    1510:	001ec800 	andseq	ip, lr, r0, lsl #16
	}
	mask = 0x0F << (pin<<2);
    1514:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    1520:	00001d4c 	andeq	r1, r0, ip, asr #26
    1524:	00001d5a 	andeq	r1, r0, sl, asr sp
}
    1528:	5a510001 	bpl	1441534 <_etext+0x143a01c>
    152c:	c800001d 	stmdagt	r0, {r0, r2, r3, r4}

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    1530:	0100001e 	tsteq	r0, lr, lsl r0
	{
		return 0x800;
    1534:	00005700 	andeq	r5, r0, r0, lsl #14
	}
	else
	{
		return 0x400;
	}
}
    1538:	00000000 	andeq	r0, r0, r0
    153c:	1d4c0000 	stclne	0, cr0, [ip, #-0]
    1540:	1d620000 	stclne	0, cr0, [r2, #-0]
    1544:	00010000 	andeq	r0, r1, r0

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1548:	001d6252 	andseq	r6, sp, r2, asr r2
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    154c:	001ec800 	andseq	ip, lr, r0, lsl #16

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    1550:	59000100 	stmdbpl	r0, {r8}
	...
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    155c:	00001d4c 	andeq	r1, r0, ip, asr #26
    1560:	00001d60 	andeq	r1, r0, r0, ror #26
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1564:	60530001 	subsvs	r0, r3, r1
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1568:	c800001d 	stmdagt	r0, {r0, r2, r3, r4}
    userAppEnd = RAM_END;
    156c:	0100001e 	tsteq	r0, lr, lsl r0
    1570:	00005800 	andeq	r5, r0, r0, lsl #16
    userUploadType=DFU_UPLOAD_NONE;
    1574:	00000000 	andeq	r0, r0, r0
    1578:	1d4c0000 	stclne	0, cr0, [ip, #-0]
    code_copy_lock = WAIT;
    157c:	1e640000 	cdpne	0, 6, cr0, cr4, cr0, {0}
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1580:	00020000 	andeq	r0, r2, r0
    1584:	1e649f31 	mcrne	15, 3, r9, cr4, cr1, {1}
    1588:	1e840000 	cdpne	0, 8, cr0, cr4, cr0, {0}
    memset(input, 0xFF, sizeof(input));
    158c:	00050000 	andeq	r0, r5, r0
    1590:	1a310075 	bne	c4176c <_etext+0xc3a254>

    sha256_starts(&ctx);
}
    1594:	001e849f 	mulseq	lr, pc, r4	; <UNPREDICTABLE>
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1598:	001eb800 	andseq	fp, lr, r0, lsl #16
    159c:	75000800 	strvc	r0, [r0, #-2048]	; 0x800
    15a0:	1a007400 	bne	1e5a8 <_etext+0x17090>
    15a4:	b89f1a31 	ldmlt	pc, {r0, r4, r5, r9, fp, ip}	; <UNPREDICTABLE>
    15a8:	c800001e 	stmdagt	r0, {r1, r2, r3, r4}
    15ac:	0200001e 	andeq	r0, r0, #30
    15b0:	009f3100 	addseq	r3, pc, r0, lsl #2
    15b4:	00000000 	andeq	r0, r0, r0
    15b8:	5e000000 	cdppl	0, 0, cr0, cr0, cr0, {0}
    15bc:	6000001d 	andvs	r0, r0, sp, lsl r0
    15c0:	0100001d 	tsteq	r0, sp, lsl r0
    15c4:	1d605300 	stclne	3, cr5, [r0, #-0]
    15c8:	1ec80000 	cdpne	0, 12, cr0, cr8, cr0, {0}
    15cc:	00010000 	andeq	r0, r1, r0
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    15d0:	00000058 	andeq	r0, r0, r8, asr r0
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    15d4:	00000000 	andeq	r0, r0, r0
    15d8:	001d5e00 	andseq	r5, sp, r0, lsl #28

    if (startState == appDETACH) {
    15dc:	001d6200 	andseq	r6, sp, r0, lsl #4
    15e0:	52000100 	andpl	r0, r0, #0, 2
        dfuAppStatus.bState = dfuIDLE;
    15e4:	00001d62 	andeq	r1, r0, r2, ror #26
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
    15e8:	00001ec8 	andeq	r1, r0, r8, asr #29
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    15ec:	00590001 	subseq	r0, r9, r1
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    15f0:	00000000 	andeq	r0, r0, r0
    } else if (startState == appIDLE || startState == dfuIDLE) {
    15f4:	56000000 	strpl	r0, [r0], -r0
    15f8:	5a00001d 	bpl	1674 <dfuCopyUPLOAD+0x8>
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    15fc:	0100001d 	tsteq	r0, sp, lsl r0
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1600:	1d5a5100 	ldfnee	f5, [sl, #-0]
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    1604:	1ec80000 	cdpne	0, 12, cr0, cr8, cr0, {0}
    1608:	00010000 	andeq	r0, r1, r0
    160c:	00000057 	andeq	r0, r0, r7, asr r0
    1610:	00000000 	andeq	r0, r0, r0

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    1614:	001d5600 	andseq	r5, sp, r0, lsl #12
        pInformation->Ctrl_Info.Usb_wLength = 1;
    1618:	001d5800 	andseq	r5, sp, r0, lsl #16
    161c:	50000100 	andpl	r0, r0, r0, lsl #2
        return NULL;
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    1620:	00001d58 	andeq	r1, r0, r8, asr sp
    }
}
    1624:	00001ec8 	andeq	r1, r0, r8, asr #29
    1628:	00560001 	subseq	r0, r6, r1

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    162c:	00000000 	andeq	r0, r0, r0
        pInformation->Ctrl_Info.Usb_wLength = 6;
    1630:	56000000 	strpl	r0, [r0], -r0
    1634:	2600001d 			; <UNDEFINED> instruction: 0x2600001d
        return NULL;
    } else {
        return (u8*)(&dfuAppStatus);
    1638:	0400001e 	streq	r0, [r0], #-30
    }
}
    163c:	7d809100 	stfvcd	f1, [r0]
    1640:	001e269f 	mulseq	lr, pc, r6	; <UNPREDICTABLE>


u8 *dfuCopyDNLOAD(u16 length) {
    1644:	001e2d00 	andseq	r2, lr, r0, lsl #26
    if (length == 0) {
    1648:	50000100 	andpl	r0, r0, r0, lsl #2
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    164c:	00001e2d 	andeq	r1, r0, sp, lsr #28
    1650:	00001e6a 	andeq	r1, r0, sl, ror #28
        thisBlockLen = pInformation->USBwLengths.w;
    1654:	80910004 	addshi	r0, r1, r4
        return NULL;
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1658:	1e6a9f7d 	mcrne	15, 3, r9, cr10, cr13, {3}
    165c:	1e6d0000 	cdpne	0, 6, cr0, cr13, cr0, {0}
    }
}
    1660:	00010000 	andeq	r0, r1, r0
    1664:	001e6d52 	andseq	r6, lr, r2, asr sp
    1668:	001ec800 	andseq	ip, lr, r0, lsl #16

u8 *dfuCopyUPLOAD(u16 length) {
    166c:	91000400 	tstls	r0, r0, lsl #8
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    1670:	009f7d80 	addseq	r7, pc, r0, lsl #27
    1674:	00000000 	andeq	r0, r0, r0
    1678:	90000000 	andls	r0, r0, r0
        return NULL;
    167c:	cc00001d 	stcgt	0, cr0, [r0], {29}
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    1680:	0400001d 	streq	r0, [r0], #-29
    1684:	7ee09100 	urdvcs	f1, f0
    1688:	001dcc9f 	mulseq	sp, pc, ip	; <UNPREDICTABLE>
    168c:	001dcf00 	andseq	ip, sp, r0, lsl #30
    }
}
    1690:	51000100 	mrspl	r0, (UNDEF: 16)
    1694:	00001dcf 	andeq	r1, r0, pc, asr #27
    1698:	00001e0e 	andeq	r1, r0, lr, lsl #28
    169c:	e0910004 	adds	r0, r1, r4

void dfuCopyBufferToExec() {
    16a0:	1e0e9f7e 	mcrne	15, 0, r9, cr14, cr14, {3}
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    16a4:	1e150000 	cdpne	0, 1, cr0, cr5, cr0, {0}
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    16a8:	00010000 	andeq	r0, r1, r0
    16ac:	001e1551 	andseq	r1, lr, r1, asr r5
    16b0:	001e1a00 	andseq	r1, lr, r0, lsl #20
    16b4:	91000400 	tstls	r0, r0, lsl #8
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    16b8:	1a9f7ee0 	bne	fe7e1240 <BootRAM+0xd7519e1>
	}

    flashErasePage((u32)(userSpace));
    16bc:	2100001e 	tstcs	r0, lr, lsl r0

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16c0:	0100001e 	tsteq	r0, lr, lsl r0
    16c4:	1e215100 	sufnes	f5, f1, f0
    16c8:	1e280000 	cdpne	0, 2, cr0, cr8, cr0, {0}
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    16cc:	00040000 	andeq	r0, r4, r0
    16d0:	9f7ee091 	svcls	0x007ee091
    16d4:	00001e28 	andeq	r1, r0, r8, lsr #28
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    16d8:	00001e2d 	andeq	r1, r0, sp, lsr #28
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    16dc:	2d510001 	ldclcs	0, cr0, [r1, #-4]
    16e0:	3000001e 	andcc	r0, r0, lr, lsl r0
    thisBlockLen = 0;
    16e4:	0400001e 	streq	r0, [r0], #-30
    16e8:	7ee09100 	urdvcs	f1, f0
    16ec:	001e309f 	mulseq	lr, pc, r0	; <UNPREDICTABLE>
    16f0:	001e3900 	andseq	r3, lr, r0, lsl #18
    16f4:	50000100 	andpl	r0, r0, r0, lsl #2
    16f8:	00001e39 	andeq	r1, r0, r9, lsr lr
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    16fc:	00001e40 	andeq	r1, r0, r0, asr #28
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    1700:	e0910004 	adds	r0, r1, r4
    1704:	1e409f7e 	mcrne	15, 2, r9, cr0, cr14, {3}

    u8 startState = dfuAppStatus.bState;
    1708:	1e430000 	cdpne	0, 4, cr0, cr3, cr0, {0}
    170c:	00010000 	andeq	r0, r1, r0
    dfuAppStatus.bStatus = OK;
    1710:	001e4352 	andseq	r4, lr, r2, asr r3
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    1714:	001e5000 	andseq	r5, lr, r0

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    1718:	91000400 	tstls	r0, r0, lsl #8
    171c:	509f7ee0 	addspl	r7, pc, r0, ror #29
            if (pInformation->USBwLengths.w > 0) {
    1720:	5700001e 	smladpl	r0, lr, r0, r0
    1724:	0100001e 	tsteq	r0, lr, lsl r0
                userFirmwareLen = 0;
    1728:	1e575100 	rdfnes	f5, f7, f0
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    172c:	1e5e0000 	cdpne	0, 5, cr0, cr14, cr0, {0}
    1730:	00040000 	andeq	r0, r4, r0
    1734:	9f7ee091 	svcls	0x007ee091
    1738:	00001e5e 	andeq	r1, r0, lr, asr lr
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    173c:	00001e63 	andeq	r1, r0, r3, ror #28
						userAppAddr = USER_CODE_FLASH0X8002000;
    1740:	63520001 	cmpvs	r2, #1
    1744:	8000001e 	andhi	r0, r0, lr, lsl r0
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    1748:	0400001e 	streq	r0, [r0], #-30
    174c:	7ee09100 	urdvcs	f1, f0
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    1750:	001e809f 	mulseq	lr, pc, r0	; <UNPREDICTABLE>
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1754:	001e8300 	andseq	r8, lr, r0, lsl #6
						flashUnlock();
    1758:	50000100 	andpl	r0, r0, r0, lsl #2

						break;
    175c:	00001e83 	andeq	r1, r0, r3, lsl #29

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    1760:	00001e8a 	andeq	r1, r0, sl, lsl #29
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1764:	e0910004 	adds	r0, r1, r4
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1768:	1e8a9f7e 	mcrne	15, 4, r9, cr10, cr14, {3}
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    176c:	1e8d0000 	cdpne	0, 8, cr0, cr13, cr0, {0}
    1770:	00010000 	andeq	r0, r1, r0
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    1774:	001e8d52 	andseq	r8, lr, r2, asr sp
    1778:	001ec800 	andseq	ip, lr, r0, lsl #16
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    177c:	91000400 	tstls	r0, r0, lsl #8
    1780:	009f7ee0 	addseq	r7, pc, r0, ror #29
    1784:	00000000 	andeq	r0, r0, r0
			
            switch(pInformation->Current_AlternateSetting) {
    1788:	90000000 	andls	r0, r0, r0
    178c:	2600001d 			; <UNDEFINED> instruction: 0x2600001d
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1790:	0400001e 	streq	r0, [r0], #-30
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1794:	7d809100 	stfvcd	f1, [r0]
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1798:	001e269f 	mulseq	lr, pc, r6	; <UNPREDICTABLE>
					userAppEnd = getFlashEnd();
    179c:	001e2d00 	andseq	r2, lr, r0, lsl #26
    17a0:	50000100 	andpl	r0, r0, r0, lsl #2

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    17a4:	00001e2d 	andeq	r1, r0, sp, lsr #28
					dfuAppStatus.bStatus = errWRITE;
    17a8:	00001e6a 	andeq	r1, r0, sl, ror #28
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    17ac:	80910004 	addshi	r0, r1, r4
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17b0:	1e6a9f7d 	mcrne	15, 3, r9, cr10, cr13, {3}
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17b4:	1e6d0000 	cdpne	0, 6, cr0, cr13, cr0, {0}
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    17b8:	00010000 	andeq	r0, r1, r0
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    17bc:	001e6d52 	andseq	r6, lr, r2, asr sp
    17c0:	001ec800 	andseq	ip, lr, r0, lsl #16
    17c4:	91000400 	tstls	r0, r0, lsl #8

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17c8:	009f7d80 	addseq	r7, pc, r0, lsl #27
                dfuCopyBufferToExec();
    17cc:	00000000 	andeq	r0, r0, r0
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    17d0:	90000000 	andls	r0, r0, r0
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    17d4:	9400001d 	strls	r0, [r0], #-29
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    17d8:	0100001d 	tsteq	r0, sp, lsl r0
    17dc:	1d945400 	cfldrsne	mvf5, [r4]

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    17e0:	1d980000 	ldcne	0, cr0, [r8]
    17e4:	00030000 	andeq	r0, r3, r0
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    17e8:	989f7074 	ldmls	pc, {r2, r4, r5, r6, ip, sp, lr}	; <UNPREDICTABLE>
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    17ec:	9c00001d 	stcls	0, cr0, [r0], {29}
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17f0:	0300001d 	movweq	r0, #29
    17f4:	9f607400 	svcls	0x00607400
    17f8:	00001d9c 	muleq	r0, ip, sp
            if (pInformation->USBwLengths.w > 0) {
    17fc:	00001dac 	andeq	r1, r0, ip, lsr #27
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    1800:	50740003 	rsbspl	r0, r4, r3
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    1804:	001dac9f 	mulseq	sp, pc, ip	; <UNPREDICTABLE>
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    1808:	001dca00 	andseq	ip, sp, r0, lsl #20
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
    180c:	91000400 	tstls	r0, r0, lsl #8
                }
                switch (ret)
    1810:	ca9f7de0 	bgt	fe7e0f98 <BootRAM+0xd751739>
    1814:	cf00001d 	svcgt	0x0000001d
    1818:	0100001d 	tsteq	r0, sp, lsl r0
                {
                    case kImageImageIsTrusted:
                        uart_printf("Uploaded signature verified!\n");
    181c:	1dcf5000 	stclne	0, cr5, [pc]	; 1824 <dfuUpdateByRequest+0x128>
                        break;

                    case kImageImageMissingMagic:
                    case kImageImageRejectSignature:
                        uart_printf("Image unverified... wiped memory for clean reset.\n");
    1820:	1de40000 	stclne	0, cr0, [r4]
    1824:	00040000 	andeq	r0, r4, r0
                        break;

                    default:
                        break;
                }
                flashLock();
    1828:	9f7de091 	svcls	0x007de091
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    182c:	00001de4 	andeq	r1, r0, r4, ror #27
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1830:	00001deb 	andeq	r1, r0, fp, ror #27
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1834:	eb500001 	bl	1401840 <_etext+0x13fa328>
    1838:	fa00001d 	blx	18b4 <dfuUpdateByRequest+0x1b8>
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuMANIFEST_SYNC) {
    183c:	0400001d 	streq	r0, [r0], #-29
        /* device has received last block, waiting DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1840:	7de09100 	stfvcp	f1, [r0]
    1844:	001dfa9f 	mulseq	sp, pc, sl	; <UNPREDICTABLE>
            dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    1848:	001dfd00 	andseq	pc, sp, r0, lsl #26
            dfuAppStatus.bStatus = OK;
    184c:	50000100 	andpl	r0, r0, r0, lsl #2
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1850:	00001dfd 	strdeq	r1, [r0], -sp
    1854:	00001e0c 	andeq	r1, r0, ip, lsl #28
            dfuAppStatus.bState  = dfuMANIFEST_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuMANIFEST) {
    1858:	e0910004 	adds	r0, r1, r4
        /* device is in manifestation phase */

        /* should never receive request while in manifest! */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
        dfuAppStatus.bStatus = OK;
    } else if (startState == dfuMANIFEST_WAIT_RESET) {
    185c:	1e0c9f7d 	mcrne	15, 0, r9, cr12, cr13, {3}
        /* device has programmed new firmware but needs external
           usb reset or power on reset to run the new code */

        /* consider timing out and self-resetting */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    } else if (startState == dfuUPLOAD_IDLE) {
    1860:	1e150000 	cdpne	0, 1, cr0, cr5, cr0, {0}
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
    1864:	00010000 	andeq	r0, r1, r0
    1868:	001e1550 	andseq	r1, lr, r0, asr r5
            if (pInformation->USBwLengths.w > 0) {
    186c:	001e1600 	andseq	r1, lr, r0, lsl #12
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1870:	74000300 	strvc	r0, [r0], #-768	; 0x300
    1874:	1e169f50 	mrcne	15, 0, r9, cr6, cr0, {2}
    1878:	1e180000 	cdpne	0, 1, cr0, cr8, cr0, {0}
    187c:	00040000 	andeq	r0, r4, r0
    1880:	9f7de091 	svcls	0x007de091
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1884:	00001e18 	andeq	r1, r0, r8, lsl lr
    1888:	00001e21 	andeq	r1, r0, r1, lsr #28
    188c:	21500001 	cmpcs	r0, r1
    1890:	3e00001e 	mcrcc	0, 0, r0, cr0, cr14, {0}
    1894:	0400001e 	streq	r0, [r0], #-30
    1898:	7de09100 	stfvcp	f1, [r0]
                    thisBlockLen = uploadBlockLen;
    189c:	001e3e9f 	mulseq	lr, pc, lr	; <UNPREDICTABLE>
    18a0:	001e4300 	andseq	r4, lr, r0, lsl #6
                    dfuAppStatus.bState  = dfuUPLOAD_IDLE;
                } else {
                    /* if above comparison was just equal, thisBlockLen becomes zero
                    next time when USBWValue has been increased by one */
                    thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
    18a4:	51000100 	mrspl	r0, (UNDEF: 16)
    18a8:	00001e43 	andeq	r1, r0, r3, asr #28
    18ac:	00001e4a 	andeq	r1, r0, sl, asr #28
    18b0:	e0910004 	adds	r0, r1, r4
                    
                    /* check for overflow due to USBwValue out of range */
                    if (thisBlockLen >= pInformation->USBwLengths.w) {
    18b4:	1e4a9f7d 	mcrne	15, 2, r9, cr10, cr13, {3}
    18b8:	1e4d0000 	cdpne	0, 4, cr0, cr13, cr0, {0}
                        thisBlockLen = 0;
    18bc:	00010000 	andeq	r0, r1, r0
                    }
                    
                    dfuAppStatus.bState  = dfuIDLE;
                }
            } else {
                dfuAppStatus.bState  = dfuERROR;
    18c0:	001e4d52 	andseq	r4, lr, r2, asr sp
                dfuAppStatus.bStatus = errNOTDONE;
    18c4:	001e6000 	andseq	r6, lr, r0
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    18c8:	91000400 	tstls	r0, r0, lsl #8
            dfuAppStatus.bState  = dfuIDLE;
    18cc:	609f7de0 	addsvs	r7, pc, r0, ror #27
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18d0:	6300001e 	movwvs	r0, #30
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18d4:	0100001e 	tsteq	r0, lr, lsl r0
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    18d8:	1e635000 	cdpne	0, 6, cr5, cr3, cr0, {0}
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuERROR)               {
    18dc:	1e660000 	cdpne	0, 6, cr0, cr6, cr0, {0}
        /* status is in error, awaiting DFU_CLRSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18e0:	00040000 	andeq	r0, r4, r0
    18e4:	9f7de091 	svcls	0x007de091
    18e8:	00001e66 	andeq	r1, r0, r6, ror #28
            /* todo, add routine to wait for last block write to finish */
            dfuAppStatus.bState  = dfuERROR;
    18ec:	00001e6d 	andeq	r1, r0, sp, ror #28
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18f0:	6d500001 	ldclvs	0, cr0, [r0, #-4]
            dfuAppStatus.bState  = dfuERROR;
        } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
    18f4:	8600001e 			; <UNDEFINED> instruction: 0x8600001e
            /* todo handle any cleanup we need here */
            dfuAppStatus.bState  = dfuIDLE;
    18f8:	0400001e 	streq	r0, [r0], #-30
            dfuAppStatus.bStatus = OK;
    18fc:	7de09100 	stfvcp	f1, [r0]
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else {
        /* some kind of error... */
        dfuAppStatus.bState  = dfuERROR;
    1900:	001e869f 	mulseq	lr, pc, r6	; <UNPREDICTABLE>
        dfuAppStatus.bStatus = errSTALLEDPKT;
    1904:	001e8d00 	andseq	r8, lr, r0, lsl #26
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}
    1908:	50000100 	andpl	r0, r0, r0, lsl #2
    190c:	00001e8d 	andeq	r1, r0, sp, lsl #29
    1910:	00001e94 	muleq	r0, r4, lr
    1914:	e0910004 	adds	r0, r1, r4
    1918:	1e949f7d 	mrcne	15, 4, r9, cr4, cr13, {3}
    191c:	1e970000 	cdpne	0, 9, cr0, cr7, cr0, {0}
    1920:	00010000 	andeq	r0, r1, r0
    1924:	001e9752 	andseq	r9, lr, r2, asr r7
    1928:	001ec800 	andseq	ip, lr, r0, lsl #16
    192c:	91000400 	tstls	r0, r0, lsl #8
    1930:	009f7de0 	addseq	r7, pc, r0, ror #27
    1934:	00000000 	andeq	r0, r0, r0
    1938:	d0000000 	andle	r0, r0, r0
    193c:	dc00001d 	stcle	0, cr0, [r0], {29}
    1940:	0300001d 	movweq	r0, #29
    1944:	9f400800 	svcls	0x00400800
    1948:	00001ddc 	ldrdeq	r1, [r0], -ip
    194c:	00001de0 	andeq	r1, r0, r0, ror #27
    dfuAppStatus.bState = newState;
}

bool dfuUploadStarted()
{
    return dfuBusy;
    1950:	e0540001 	subs	r0, r4, r1
}
    1954:	e200001d 	and	r0, r0, #29
    1958:	0100001d 	tsteq	r0, sp, lsl r0

void dfuFinishUpload() {

    while (1)
	{
		__asm__ __volatile__ ("");
    195c:	1dec5100 	stfnee	f5, [ip]
};

/* Conversion to and from projective coordinates */
void ed25519_project(struct ed25519_pt *p,
		     const uint8_t *x, const uint8_t *y)
{
    1960:	1df00000 	ldclne	0, cr0, [r0]
    1964:	00010000 	andeq	r0, r1, r0
    1968:	001eb854 	andseq	fp, lr, r4, asr r8
    196c:	001ec800 	andseq	ip, lr, r0, lsl #16
    1970:	08000300 	stmdaeq	r0, {r8, r9}
    1974:	00009f40 	andeq	r9, r0, r0, asr #30
    1978:	00000000 	andeq	r0, r0, r0
    197c:	1e2e0000 	cdpne	0, 2, cr0, cr14, cr0, {0}
    1980:	1e340000 	cdpne	0, 3, cr0, cr4, cr0, {0}
    1984:	00030000 	andeq	r0, r3, r0
    1988:	349f2076 	ldrcc	r2, [pc], #118	; 1990 <ed25519_project+0x30>
    198c:	3900001e 	stmdbcc	r0, {r1, r2, r3, r4}
    1990:	0100001e 	tsteq	r0, lr, lsl r0
    1994:	1e395200 	cdpne	2, 3, cr5, cr9, cr0, {0}
    1998:	1eb80000 	cdpne	0, 11, cr0, cr8, cr0, {0}
    199c:	00030000 	andeq	r0, r3, r0
    19a0:	009f2076 	addseq	r2, pc, r6, ror r0	; <UNPREDICTABLE>
    19a4:	00000000 	andeq	r0, r0, r0
    19a8:	2e000000 	cdpcs	0, 0, cr0, cr0, cr0, {0}
    19ac:	b400001e 	strlt	r0, [r0], #-30
    19b0:	0100001e 	tsteq	r0, lr, lsl r0
    19b4:	1eb45d00 	cdpne	13, 11, cr5, cr4, cr0, {0}
    19b8:	1eb80000 	cdpne	0, 11, cr0, cr8, cr0, {0}
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
    19bc:	00040000 	andeq	r0, r4, r0
	f25519_mul__distinct(p->t, x, y);
    19c0:	9f7cc091 	svcls	0x007cc091
	...
    19cc:	00001e3a 	andeq	r1, r0, sl, lsr lr
}

void ed25519_unproject(uint8_t *x, uint8_t *y,
		       const struct ed25519_pt *p)
{
    19d0:	00001e40 	andeq	r1, r0, r0, asr #28
    19d4:	e0910004 	adds	r0, r1, r4
    19d8:	1e409f7e 	mcrne	15, 2, r9, cr0, cr14, {3}
	uint8_t z1[F25519_SIZE];

	f25519_inv__distinct(z1, p->z);
    19dc:	1e430000 	cdpne	0, 4, cr0, cr3, cr0, {0}
    19e0:	00010000 	andeq	r0, r1, r0
	f25519_mul__distinct(x, p->x, z1);
    19e4:	001e4352 	andseq	r4, lr, r2, asr r3
    19e8:	001e5000 	andseq	r5, lr, r0
    19ec:	91000400 	tstls	r0, r0, lsl #8
	f25519_mul__distinct(y, p->y, z1);
    19f0:	509f7ee0 	addspl	r7, pc, r0, ror #29
    19f4:	5700001e 	smladpl	r0, lr, r0, r0
    19f8:	0100001e 	tsteq	r0, lr, lsl r0

	f25519_normalize(x);
    19fc:	1e575100 	rdfnes	f5, f7, f0
	f25519_normalize(y);
    1a00:	1e5e0000 	cdpne	0, 5, cr0, cr14, cr0, {0}
    1a04:	00040000 	andeq	r0, r4, r0
}
    1a08:	9f7ee091 	svcls	0x007ee091
	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
};

void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y)
{
    1a0c:	00001e5e 	andeq	r1, r0, lr, asr lr
    1a10:	00001e63 	andeq	r1, r0, r3, ror #28
    1a14:	63520001 	cmpvs	r2, #1
    1a18:	8000001e 	andhi	r0, r0, lr, lsl r0
    1a1c:	0400001e 	streq	r0, [r0], #-30
    1a20:	7ee09100 	urdvcs	f1, f0
    1a24:	001e809f 	mulseq	lr, pc, r0	; <UNPREDICTABLE>
    1a28:	001e8300 	andseq	r8, lr, r0, lsl #6
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
    1a2c:	50000100 	andpl	r0, r0, r0, lsl #2
    1a30:	00001e83 	andeq	r1, r0, r3, lsl #29
    1a34:	00001e8a 	andeq	r1, r0, sl, lsl #29
    1a38:	e0910004 	adds	r0, r1, r4
    1a3c:	1e8a9f7e 	mcrne	15, 4, r9, cr10, cr14, {3}
    1a40:	1e8d0000 	cdpne	0, 8, cr0, cr13, cr0, {0}
    1a44:	00010000 	andeq	r0, r1, r0
    1a48:	001e8d52 	andseq	r8, lr, r2, asr sp
    1a4c:	001eb800 	andseq	fp, lr, r0, lsl #16
    1a50:	91000400 	tstls	r0, r0, lsl #8
	parity = (tmp[0] & 1) << 7;
    1a54:	009f7ee0 	addseq	r7, pc, r0, ror #29

	f25519_copy(c, y);
	f25519_normalize(c);
    1a58:	00000000 	andeq	r0, r0, r0
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1a5c:	3a000000 	bcc	1a64 <ed25519_pack+0x58>
    1a60:	b400001e 	strlt	r0, [r0], #-30

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1a64:	0100001e 	tsteq	r0, lr, lsl r0
}
    1a68:	1eb45d00 	cdpne	13, 11, cr5, cr4, cr0, {0}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1a6c:	1eb80000 	cdpne	0, 11, cr0, cr8, cr0, {0}
    1a70:	00040000 	andeq	r0, r4, r0
    1a74:	9f7cc091 	svcls	0x007cc091
	...
    1a80:	00001e4e 	andeq	r1, r0, lr, asr #28
    1a84:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    1a88:	00570001 	subseq	r0, r7, r1
    1a8c:	00000000 	andeq	r0, r0, r0
    1a90:	4e000000 	cdpmi	0, 0, cr0, cr0, cr0, {0}
    1a94:	6000001e 	andvs	r0, r0, lr, lsl r0
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1a98:	0400001e 	streq	r0, [r0], #-30
    1a9c:	7de09100 	stfvcp	f1, [r0]
    1aa0:	001e609f 	mulseq	lr, pc, r0	; <UNPREDICTABLE>
    1aa4:	001e6300 	andseq	r6, lr, r0, lsl #6
    1aa8:	50000100 	andpl	r0, r0, r0, lsl #2
	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
	f25519_add(a, b, f25519_one);
    1aac:	00001e63 	andeq	r1, r0, r3, ror #28
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1ab0:	00001e66 	andeq	r1, r0, r6, ror #28

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
    1ab4:	e0910004 	adds	r0, r1, r4
    1ab8:	1e669f7d 	mcrne	15, 3, r9, cr6, cr13, {3}
	f25519_add(a, b, f25519_one);
    1abc:	1e6d0000 	cdpne	0, 6, cr0, cr13, cr0, {0}
    1ac0:	00010000 	andeq	r0, r1, r0
    1ac4:	001e6d50 	andseq	r6, lr, r0, asr sp
	f25519_inv__distinct(b, a);
    1ac8:	001e8600 	andseq	r8, lr, r0, lsl #12
    1acc:	91000400 	tstls	r0, r0, lsl #8

	/* Compute a = y^2-1 */
	f25519_sub(a, c, f25519_one);
    1ad0:	869f7de0 	ldrhi	r7, [pc], r0, ror #27
    1ad4:	8d00001e 	stchi	0, cr0, [r0, #-120]	; 0xffffff88

	/* Compute c = a*b = (y^2-1)/(1-dy^2) */
	f25519_mul__distinct(c, a, b);
    1ad8:	0100001e 	tsteq	r0, lr, lsl r0
    1adc:	1e8d5000 	cdpne	0, 8, cr5, cr13, cr0, {0}
    1ae0:	1e940000 	cdpne	0, 9, cr0, cr4, cr0, {0}

	/* Compute a, b = +/-sqrt(c), if c is square */
	f25519_sqrt(a, c);
    1ae4:	00040000 	andeq	r0, r4, r0
    1ae8:	9f7de091 	svcls	0x007de091
	f25519_neg(b, a);
    1aec:	00001e94 	muleq	r0, r4, lr
    1af0:	00001e97 	muleq	r0, r7, lr

	/* Select one of them, based on the compressed parity bit */
	f25519_select(x, a, b, (a[0] ^ parity) & 1);
    1af4:	97520001 	ldrbls	r0, [r2, -r1]
    1af8:	b800001e 	stmdalt	r0, {r1, r2, r3, r4}
    1afc:	0400001e 	streq	r0, [r0], #-30
    1b00:	7de09100 	stfvcp	f1, [r0]
    1b04:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
    1b08:	00000000 	andeq	r0, r0, r0
    1b0c:	001e5c00 	andseq	r5, lr, r0, lsl #24
    1b10:	001e6000 	andseq	r6, lr, r0
	f25519_normalize(a);
    1b14:	50000100 	andpl	r0, r0, r0, lsl #2
	f25519_normalize(c);
    1b18:	00001e60 	andeq	r1, r0, r0, ror #28
    1b1c:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8

	return f25519_eq(a, c);
    1b20:	00550001 	subseq	r0, r5, r1
    1b24:	00000000 	andeq	r0, r0, r0
}
    1b28:	6e000000 	cdpvs	0, 0, cr0, cr0, cr0, {0}
    1b2c:	b800001e 	stmdalt	r0, {r1, r2, r3, r4}
    1b30:	0100001e 	tsteq	r0, lr, lsl r0
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1b34:	00005600 	andeq	r5, r0, r0, lsl #12
    1b38:	00000000 	andeq	r0, r0, r0
    1b3c:	1e6e0000 	cdpne	0, 6, cr0, cr14, cr0, {0}
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b40:	1e800000 	cdpne	0, 8, cr0, cr0, cr0, {0}
    1b44:	00040000 	andeq	r0, r4, r0
    1b48:	9f7ee091 	svcls	0x007ee091
	f25519_sub(d, p2->y, p2->x);
    1b4c:	00001e80 	andeq	r1, r0, r0, lsl #29
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1b50:	00001e83 	andeq	r1, r0, r3, lsl #29
	f25519_sub(d, p2->y, p2->x);
    1b54:	83500001 	cmphi	r0, #1
    1b58:	8a00001e 	bhi	1bd8 <ed25519_add+0xa4>
	f25519_mul__distinct(a, c, d);
    1b5c:	0400001e 	streq	r0, [r0], #-30
    1b60:	7ee09100 	urdvcs	f1, f0
    1b64:	001e8a9f 	mulseq	lr, pc, sl	; <UNPREDICTABLE>

	/* B = (Y1+X1)(Y2+X2) */
	f25519_add(c, p1->y, p1->x);
    1b68:	001e8d00 	andseq	r8, lr, r0, lsl #26
    1b6c:	52000100 	andpl	r0, r0, #0, 2
	f25519_add(d, p2->y, p2->x);
    1b70:	00001e8d 	andeq	r1, r0, sp, lsl #29
    1b74:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    1b78:	e0910004 	adds	r0, r1, r4
	f25519_mul__distinct(b, c, d);
    1b7c:	00009f7e 	andeq	r9, r0, lr, ror pc
    1b80:	00000000 	andeq	r0, r0, r0

	/* C = T1 k T2 */
	f25519_mul__distinct(d, p1->t, p2->t);
    1b84:	1e7c0000 	cdpne	0, 7, cr0, cr12, cr0, {0}
    1b88:	1e800000 	cdpne	0, 8, cr0, cr0, cr0, {0}
    1b8c:	00010000 	andeq	r0, r1, r0
    1b90:	001e8050 	andseq	r8, lr, r0, asr r0
	f25519_mul__distinct(c, d, ed25519_k);
    1b94:	001eb800 	andseq	fp, lr, r0, lsl #16
    1b98:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...

	/* D = Z1 2 Z2 */
	f25519_mul__distinct(d, p1->z, p2->z);
    1ba4:	00001e8e 	andeq	r1, r0, lr, lsl #29
    1ba8:	00001e94 	muleq	r0, r4, lr
	f25519_add(d, d, d);
    1bac:	e0910004 	adds	r0, r1, r4
    1bb0:	1e949f7d 	mrcne	15, 4, r9, cr4, cr13, {3}

	/* E = B - A */
	f25519_sub(e, b, a);
    1bb4:	1e970000 	cdpne	0, 9, cr0, cr7, cr0, {0}
    1bb8:	00010000 	andeq	r0, r1, r0
    1bbc:	001e9752 	andseq	r9, lr, r2, asr r7

	/* F = D - C */
	f25519_sub(f, d, c);
    1bc0:	001eb800 	andseq	fp, lr, r0, lsl #16
    1bc4:	91000400 	tstls	r0, r0, lsl #8

	/* G = D + C */
	f25519_add(g, d, c);
    1bc8:	009f7de0 	addseq	r7, pc, r0, ror #27
    1bcc:	00000000 	andeq	r0, r0, r0
    1bd0:	8e000000 	cdphi	0, 0, cr0, cr0, cr0, {0}

	/* H = B + A */
	f25519_add(h, b, a);
    1bd4:	9e00001e 	mcrls	0, 0, r0, cr0, cr14, {0}
    1bd8:	0400001e 	streq	r0, [r0], #-30

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1bdc:	7ce09100 	stfvcp	f1, [r0]
    1be0:	001e9e9f 	mulseq	lr, pc, lr	; <UNPREDICTABLE>
    1be4:	001ea100 	andseq	sl, lr, r0, lsl #2

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1be8:	50000100 	andpl	r0, r0, r0, lsl #2
    1bec:	00001ea1 	andeq	r1, r0, r1, lsr #29
    1bf0:	00001ea6 	andeq	r1, r0, r6, lsr #29

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1bf4:	e0910004 	adds	r0, r1, r4
    1bf8:	1ea69f7c 	mcrne	15, 5, r9, cr6, cr12, {3}
    1bfc:	1ea90000 	cdpne	0, 10, cr0, cr9, cr0, {0}

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1c00:	00010000 	andeq	r0, r1, r0
    1c04:	001ea951 	andseq	sl, lr, r1, asr r9
    1c08:	001eb800 	andseq	fp, lr, r0, lsl #16
}
    1c0c:	91000400 	tstls	r0, r0, lsl #8
    1c10:	009f7ce0 	addseq	r7, pc, r0, ror #25

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1c14:	00000000 	andeq	r0, r0, r0
    1c18:	c8000000 	stmdagt	r0, {}	; <UNPREDICTABLE>

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1c1c:	dc00001e 	stcle	0, cr0, [r0], {30}
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1c20:	0100001e 	tsteq	r0, lr, lsl r0
    1c24:	1edc5000 	cdpne	0, 13, cr5, cr12, cr0, {0}

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1c28:	1ee50000 	cdpne	0, 14, cr0, cr5, cr0, {0}
    1c2c:	00030000 	andeq	r0, r3, r0
    1c30:	e59f7c70 	ldr	r7, [pc, #3184]	; 28a8 <f25519_sqrt+0xa0>

	/* C = 2 Z1^2 */
	f25519_mul__distinct(c, p->z, p->z);
    1c34:	e600001e 			; <UNDEFINED> instruction: 0xe600001e
    1c38:	0400001e 	streq	r0, [r0], #-30
    1c3c:	5001f300 	andpl	pc, r1, r0, lsl #6
	f25519_add(c, c, c);
    1c40:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    1c44:	00000000 	andeq	r0, r0, r0

	/* D = a A (alter sign) */
	/* E = (X1+Y1)^2-A-B */
	f25519_add(f, p->x, p->y);
    1c48:	001ec800 	andseq	ip, lr, r0, lsl #16
    1c4c:	001ece00 	andseq	ip, lr, r0, lsl #28
    1c50:	51000100 	mrspl	r0, (UNDEF: 16)
	f25519_mul__distinct(e, f, f);
    1c54:	00001ece 	andeq	r1, r0, lr, asr #29
    1c58:	00001ed4 	ldrdeq	r1, [r0], -r4
	f25519_sub(e, e, a);
    1c5c:	d4520001 	ldrble	r0, [r2], #-1
    1c60:	d800001e 	stmdale	r0, {r1, r2, r3, r4}
    1c64:	0500001e 	streq	r0, [r0, #-30]
	f25519_sub(e, e, b);
    1c68:	38007200 	stmdacc	r0, {r9, ip, sp, lr}
    1c6c:	1ed89f25 	cdpne	15, 13, cr9, cr8, cr5, {1}

	/* G = D + B */
	f25519_sub(g, b, a);
    1c70:	1ede0000 	cdpne	0, 13, cr0, cr14, cr0, {0}
    1c74:	00070000 	andeq	r0, r7, r0
    1c78:	25380072 	ldrcs	r0, [r8, #-114]!	; 0x72

	/* F = G - C */
	f25519_sub(f, g, c);
    1c7c:	de9f2538 	mrcle	5, 4, r2, cr15, cr8, {1}
    1c80:	e600001e 			; <UNDEFINED> instruction: 0xe600001e

	/* H = D - B */
	f25519_neg(h, b);
    1c84:	0a00001e 	beq	1d04 <ed25519_smult+0x3c>
    1c88:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
	f25519_sub(h, h, a);
    1c8c:	25382540 	ldrcs	r2, [r8, #-1344]!	; 0x540
    1c90:	009f2538 	addseq	r2, pc, r8, lsr r5	; <UNPREDICTABLE>
    1c94:	00000000 	andeq	r0, r0, r0

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1c98:	c8000000 	stmdagt	r0, {}	; <UNPREDICTABLE>
    1c9c:	ce00001e 	mcrgt	0, 0, r0, cr0, cr14, {0}

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1ca0:	0200001e 	andeq	r0, r0, #30
    1ca4:	ce9f3000 	cdpgt	0, 9, cr3, cr15, cr0, {0}
    1ca8:	d400001e 	strle	r0, [r0], #-30

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1cac:	0200001e 	andeq	r0, r0, #30
    1cb0:	d49f3200 	ldrle	r3, [pc], #512	; 1cb8 <ed25519_double+0xa4>
    1cb4:	d800001e 	stmdale	r0, {r1, r2, r3, r4}

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1cb8:	0200001e 	andeq	r0, r0, #30
    1cbc:	d89f3300 	ldmle	pc, {r8, r9, ip, sp}	; <UNPREDICTABLE>
    1cc0:	e600001e 			; <UNDEFINED> instruction: 0xe600001e
}
    1cc4:	0200001e 	andeq	r0, r0, #30

void ed25519_smult(struct ed25519_pt *r_out, const struct ed25519_pt *p,
		   const uint8_t *e)
{
    1cc8:	009f3400 	addseq	r3, pc, r0, lsl #8
	...
    1cd4:	2e00001f 	mcrcs	0, 0, r0, cr0, cr15, {0}
    1cd8:	0100001f 	tsteq	r0, pc, lsl r0
    1cdc:	1f305200 	svcne	0x00305200
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1ce0:	1f3a0000 	svcne	0x003a0000
    1ce4:	00010000 	andeq	r0, r1, r0
    1ce8:	00000052 	andeq	r0, r0, r2, asr r0
		struct ed25519_pt s;

		ed25519_double(&r, &r);
    1cec:	00000000 	andeq	r0, r0, r0
    1cf0:	001f0000 	andseq	r0, pc, r0
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1cf4:	001f0800 	andseq	r0, pc, r0, lsl #16
		struct ed25519_pt s;

		ed25519_double(&r, &r);
		ed25519_add(&s, &r, p);
    1cf8:	53000100 	movwpl	r0, #256	; 0x100
    1cfc:	00001f08 	andeq	r1, r0, r8, lsl #30

		f25519_select(r.x, r.x, s.x, bit);
    1d00:	00001f0e 	andeq	r1, r0, lr, lsl #30
    1d04:	7f730003 	svcvc	0x00730003
    1d08:	001f0e9f 	mulseq	pc, pc, lr	; <UNPREDICTABLE>
		f25519_select(r.y, r.y, s.y, bit);
    1d0c:	001f1200 	andseq	r1, pc, r0, lsl #4
    1d10:	53000100 	movwpl	r0, #256	; 0x100
    1d14:	00001f14 	andeq	r1, r0, r4, lsl pc
		f25519_select(r.z, r.z, s.z, bit);
    1d18:	00001f1e 	andeq	r1, r0, lr, lsl pc
    1d1c:	1e530001 	cdpne	0, 5, cr0, cr3, cr1, {0}
    1d20:	2400001f 	strcs	r0, [r0], #-31
		f25519_select(r.t, r.t, s.t, bit);
    1d24:	0300001f 	movweq	r0, #31
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d28:	9f7f7300 	svcls	0x007f7300
		ed25519_add(&s, &r, p);

		f25519_select(r.x, r.x, s.x, bit);
		f25519_select(r.y, r.y, s.y, bit);
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
    1d2c:	00001f24 	andeq	r1, r0, r4, lsr #30
    1d30:	00001f2a 	andeq	r1, r0, sl, lsr #30
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d34:	00530001 	subseq	r0, r3, r1
    1d38:	00000000 	andeq	r0, r0, r0
    1d3c:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
	}

	ed25519_copy(r_out, &r);
}
    1d40:	3a00001f 	bcc	1dc4 <edsign_verify+0x78>
    1d44:	0500001f 	streq	r0, [r0, #-31]
    1d48:	3f007200 	svccc	0x00007200
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1d4c:	00009f25 	andeq	r9, r0, r5, lsr #30
    1d50:	00000000 	andeq	r0, r0, r0
    1d54:	1f380000 	svcne	0x00380000
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d58:	1f500000 	svcne	0x00500000
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1d5c:	00010000 	andeq	r0, r1, r0
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1d60:	001f505d 	andseq	r5, pc, sp, asr r0	; <UNPREDICTABLE>
    1d64:	001f5600 	andseq	r5, pc, r0, lsl #12
    1d68:	91000300 	mrsls	r0, LR_irq
    1d6c:	00009f58 	andeq	r9, r0, r8, asr pc
	memcpy(block + 32, a, 32);
    1d70:	00000000 	andeq	r0, r0, r0
    1d74:	1f3a0000 	svcne	0x003a0000
    1d78:	1f540000 	svcne	0x00540000
    1d7c:	00010000 	andeq	r0, r1, r0
    1d80:	00000054 	andeq	r0, r0, r4, asr r0
    1d84:	00000000 	andeq	r0, r0, r0
    1d88:	001f5800 	andseq	r5, pc, r0, lsl #16
    1d8c:	001fa200 	andseq	sl, pc, r0, lsl #4
    1d90:	50000100 	andpl	r0, r0, r0, lsl #2
    1d94:	00001fa2 	andeq	r1, r0, r2, lsr #31
    1d98:	00001fdc 	ldrdeq	r1, [r0], -ip
    1d9c:	01f30004 	mvnseq	r0, r4
{
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
    1da0:	1fdc9f50 	svcne	0x00dc9f50
    1da4:	1ff20000 	svcne	0x00f20000
    1da8:	00010000 	andeq	r0, r1, r0
		memcpy(init_block + prefix_size, message, len);
		sha512_final(&s, init_block, len + prefix_size);
	} else {
		size_t i;

		memcpy(init_block + prefix_size, message,
    1dac:	00000050 	andeq	r0, r0, r0, asr r0
    1db0:	00000000 	andeq	r0, r0, r0
    1db4:	001f5800 	andseq	r5, pc, r0, lsl #16
    1db8:	001fa400 	andseq	sl, pc, r0, lsl #8
    1dbc:	51000100 	mrspl	r0, (UNDEF: 16)
    1dc0:	00001fa4 	andeq	r1, r0, r4, lsr #31
    1dc4:	00001fdc 	ldrdeq	r1, [r0], -ip
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);
    1dc8:	01f30004 	mvnseq	r0, r4
    1dcc:	1fdc9f51 	svcne	0x00dc9f51

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dd0:	1ff20000 	svcne	0x00f20000
    1dd4:	00010000 	andeq	r0, r1, r0
    1dd8:	00000051 	andeq	r0, r0, r1, asr r0
    1ddc:	00000000 	andeq	r0, r0, r0
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1de0:	001f5800 	andseq	r5, pc, r0, lsl #16
		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
		     i + SHA512_BLOCK_SIZE <= len;
    1de4:	001f6200 	andseq	r6, pc, r0, lsl #4
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1de8:	30000200 	andcc	r0, r0, r0, lsl #4

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1dec:	001fc89f 	mulseq	pc, pc, r8	; <UNPREDICTABLE>
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
    1df0:	001fcc00 	andseq	ip, pc, r0, lsl #24
    1df4:	52000100 	andpl	r0, r0, #0, 2
    1df8:	00001fcc 	andeq	r1, r0, ip, asr #31
    1dfc:	00001fd0 	ldrdeq	r1, [r0], -r0
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
		memcpy(init_block + prefix_size, message, len);
    1e00:	00720008 	rsbseq	r0, r2, r8
    1e04:	00722531 	rsbseq	r2, r2, r1, lsr r5
    1e08:	1fdc9f21 	svcne	0x00dc9f21
		sha512_final(&s, init_block, len + prefix_size);
    1e0c:	1fe00000 	svcne	0x00e00000
    1e10:	00020000 	andeq	r0, r2, r0
    1e14:	1fe09f30 	svcne	0x00e09f30
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
	}

	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
    1e18:	1ff20000 	svcne	0x00f20000
    1e1c:	00010000 	andeq	r0, r1, r0
    1e20:	00000052 	andeq	r0, r0, r2, asr r0
	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
    1e24:	00000000 	andeq	r0, r0, r0
    1e28:	001f5800 	andseq	r5, pc, r0, lsl #16
    1e2c:	001f6200 	andseq	r6, pc, r0, lsl #4

static void sm_pack(uint8_t *r, const uint8_t *k)
{
	struct ed25519_pt p;

	ed25519_smult(&p, &ed25519_base, k);
    1e30:	30000200 	andcc	r0, r0, r0, lsl #4
    1e34:	001fdc9f 	mulseq	pc, pc, ip	; <UNPREDICTABLE>
    1e38:	001fe000 	andseq	lr, pc, r0
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1e3c:	30000200 	andcc	r0, r0, r0, lsl #4
    1e40:	001fe09f 	mulseq	pc, pc, r0	; <UNPREDICTABLE>
	ed25519_pack(packed, x, y);
    1e44:	001fe600 	andseq	lr, pc, r0, lsl #12
    1e48:	53000100 	movwpl	r0, #256	; 0x100
    1e4c:	00001fe6 	andeq	r1, r0, r6, ror #31

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e50:	00001fee 	andeq	r1, r0, lr, ror #31
    1e54:	7f730003 	svcvc	0x00730003

	ed25519_project(p, x, y);
    1e58:	001fee9f 	mulseq	pc, pc, lr	; <UNPREDICTABLE>
    1e5c:	001ff200 	andseq	pc, pc, r0, lsl #4
    1e60:	53000100 	movwpl	r0, #256	; 0x100
	...
	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
    1e6c:	00001ff4 	strdeq	r1, [r0], -r4

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1e70:	00002090 	muleq	r0, r0, r0
    1e74:	90510001 	subsls	r0, r1, r1

	ed25519_project(p, x, y);
    1e78:	9e000020 	cdpls	0, 0, cr0, cr0, cr0, {1}
    1e7c:	04000020 	streq	r0, [r0], #-32
    1e80:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
    1e84:	00209e9f 	mlaeq	r0, pc, lr, r9	; <UNPREDICTABLE>
    1e88:	0020b600 	eoreq	fp, r0, r0, lsl #12
    1e8c:	51000100 	mrspl	r0, (UNDEF: 16)
	...
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
	ed25519_pack(packed, x, y);
    1e98:	00001ff4 	strdeq	r1, [r0], -r4
    1e9c:	00002092 	muleq	r0, r2, r0
    1ea0:	92520001 	subsls	r0, r2, #1
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
    1ea4:	9e000020 	cdpls	0, 0, cr0, cr0, cr0, {1}
    1ea8:	04000020 	streq	r0, [r0], #-32
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
    1eac:	5201f300 	andpl	pc, r1, #0, 6
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
}
    1eb0:	00209e9f 	mlaeq	r0, pc, lr, r9	; <UNPREDICTABLE>
    1eb4:	0020b600 	eoreq	fp, r0, r0, lsl #12

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1eb8:	52000100 	andpl	r0, r0, #0, 2
	...
    1ec4:	00001ff4 	strdeq	r1, [r0], -r4

const uint8_t f25519_zero[F25519_SIZE] = {0};
const uint8_t f25519_one[F25519_SIZE] = {1};

void f25519_load(uint8_t *x, uint32_t c)
{
    1ec8:	00002018 	andeq	r2, r0, r8, lsl r0
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
		c >>= 8;
    1ecc:	18530001 	ldmdane	r3, {r0}^
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    1ed0:	b6000020 	strlt	r0, [r0], -r0, lsr #32
    1ed4:	04000020 	streq	r0, [r0], #-32
    1ed8:	5301f300 	movwpl	pc, #4864	; 0x1300	; <UNPREDICTABLE>
    1edc:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
		c >>= 8;
	}

	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}
    1ee0:	00000000 	andeq	r0, r0, r0
    1ee4:	00201c00 	eoreq	r1, r0, r0, lsl #24

void f25519_normalize(uint8_t *x)
{
    1ee8:	00202200 	eoreq	r2, r0, r0, lsl #4
    1eec:	53000100 	movwpl	r0, #256	; 0x100
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1ef0:	00002022 	andeq	r2, r0, r2, lsr #32
	x[31] &= 127;
    1ef4:	00002094 	muleq	r0, r4, r0

	for (i = 0; i < F25519_SIZE; i++) {
    1ef8:	9e560001 	cdpls	0, 5, cr0, cr6, cr1, {0}
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1efc:	b4000020 	strlt	r0, [r0], #-32
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
		c += x[i];
    1f00:	01000020 	tsteq	r0, r0, lsr #32
		x[i] = c;
    1f04:	00005600 	andeq	r5, r0, r0, lsl #12

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1f08:	00000000 	andeq	r0, r0, r0
		c += x[i];
		x[i] = c;
		c >>= 8;
    1f0c:	201c0000 	andscs	r0, ip, r0

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1f10:	203e0000 	eorscs	r0, lr, r0
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += x[i];
    1f14:	00020000 	andeq	r0, r2, r0
		minusp[i] = c;
    1f18:	209e9f30 	addscs	r9, lr, r0, lsr pc
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1f1c:	20a00000 	adccs	r0, r0, r0
		c += x[i];
		minusp[i] = c;
		c >>= 8;
    1f20:	00020000 	andeq	r0, r2, r0
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1f24:	20a09f30 	adccs	r9, r0, r0, lsr pc
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1f28:	20b60000 	adcscs	r0, r6, r0
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1f2c:	00010000 	andeq	r0, r1, r0

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1f30:	00000053 	andeq	r0, r0, r3, asr r0
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;
    1f34:	00000000 	andeq	r0, r0, r0

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1f38:	0020b800 	eoreq	fp, r0, r0, lsl #16
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    1f3c:	0020e800 	eoreq	lr, r0, r0, lsl #16
    1f40:	51000100 	mrspl	r0, (UNDEF: 16)
    1f44:	000020e8 	andeq	r2, r0, r8, ror #1
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1f48:	000020fe 	strdeq	r2, [r0], -lr
    1f4c:	01f30004 	mvnseq	r0, r4
	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;

	/* Load x-p if no underflow */
	f25519_select(x, minusp, x, (c >> 15) & 1);
}
    1f50:	00009f51 	andeq	r9, r0, r1, asr pc
    1f54:	00000000 	andeq	r0, r0, r0

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
    1f58:	20b80000 	adcscs	r0, r8, r0
    1f5c:	20da0000 	sbcscs	r0, sl, r0
    1f60:	00010000 	andeq	r0, r1, r0
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    1f64:	0020da52 	eoreq	sp, r0, r2, asr sl
    1f68:	0020fe00 	eoreq	pc, r0, r0, lsl #28
    1f6c:	f3000400 	vshl.u8	d0, d0, d0
    1f70:	009f5201 	addseq	r5, pc, r1, lsl #4
    1f74:	00000000 	andeq	r0, r0, r0
    1f78:	b8000000 	stmdalt	r0, {}	; <UNPREDICTABLE>
    1f7c:	be000020 	cdplt	0, 0, cr0, cr0, cr0, {1}
    1f80:	02000020 	andeq	r0, r0, #32
    1f84:	be9f3000 	cdplt	0, 9, cr3, cr15, cr0, {0}
    1f88:	c8000020 	stmdagt	r0, {r5}
    1f8c:	05000020 	streq	r0, [r0, #-32]
    1f90:	38007400 	stmdacc	r0, {sl, ip, sp, lr}
    1f94:	20c89f25 	sbccs	r9, r8, r5, lsr #30
    1f98:	20d40000 	sbcscs	r0, r4, r0
    1f9c:	00010000 	andeq	r0, r1, r0
    1fa0:	0020e654 	eoreq	lr, r0, r4, asr r6
    1fa4:	0020ec00 	eoreq	lr, r0, r0, lsl #24
    1fa8:	52000100 	andpl	r0, r0, #0, 2
    1fac:	000020ee 	andeq	r2, r0, lr, ror #1
    1fb0:	000020fe 	strdeq	r2, [r0], -lr
    1fb4:	00520001 	subseq	r0, r2, r1
    1fb8:	00000000 	andeq	r0, r0, r0
    1fbc:	b8000000 	stmdalt	r0, {}	; <UNPREDICTABLE>
    1fc0:	be000020 	cdplt	0, 0, cr0, cr0, cr0, {1}

	sum |= (sum >> 4);
    1fc4:	02000020 	andeq	r0, r0, #32
	sum |= (sum >> 2);
    1fc8:	be9f3000 	cdplt	0, 9, cr3, cr15, cr0, {0}
	sum |= (sum >> 1);
    1fcc:	d6000020 	strle	r0, [r0], -r0, lsr #32

	return (sum ^ 1) & 1;
    1fd0:	01000020 	tsteq	r0, r0, lsr #32
}
    1fd4:	20e65300 	rsccs	r5, r6, r0, lsl #6
    1fd8:	20e80000 	rsccs	r0, r8, r0
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fdc:	00020000 	andeq	r0, r2, r0
		sum |= x[i] ^ y[i];
    1fe0:	20e89f30 	rsccs	r9, r8, r0, lsr pc
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fe4:	20f20000 	rscscs	r0, r2, r0
    1fe8:	00010000 	andeq	r0, r1, r0
		sum |= x[i] ^ y[i];
    1fec:	0020f253 	eoreq	pc, r0, r3, asr r2	; <UNPREDICTABLE>
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1ff0:	0020f800 	eoreq	pc, r0, r0, lsl #16
}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
    1ff4:	73000300 	movwvc	r0, #768	; 0x300
    1ff8:	20f89f7f 	rscscs	r9, r8, pc, ror pc
    1ffc:	20fe0000 	rscscs	r0, lr, r0
    2000:	00010000 	andeq	r0, r1, r0
    2004:	00000053 	andeq	r0, r0, r3, asr r0
    2008:	00000000 	andeq	r0, r0, r0
    200c:	00210000 	eoreq	r0, r1, r0
    2010:	00212000 	eoreq	r2, r1, r0
    2014:	51000100 	mrspl	r0, (UNDEF: 16)
	const uint8_t mask = -condition;
    2018:	00002120 	andeq	r2, r0, r0, lsr #2
    201c:	0000214c 	andeq	r2, r0, ip, asr #2
    2020:	01f30004 	mvnseq	r0, r4
    2024:	00009f51 	andeq	r9, r0, r1, asr pc
    2028:	00000000 	andeq	r0, r0, r0
    202c:	21000000 	mrscs	r0, (UNDEF: 0)
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    2030:	21220000 	teqcs	r2, r0
    2034:	00010000 	andeq	r0, r1, r0
    2038:	00212252 	eoreq	r2, r1, r2, asr r2
    203c:	00214c00 	eoreq	r4, r1, r0, lsl #24
    2040:	f3000400 	vshl.u8	d0, d0, d0
    2044:	009f5201 	addseq	r5, pc, r1, lsl #4
	...
    2050:	06000021 	streq	r0, [r0], -r1, lsr #32
    2054:	03000021 	movweq	r0, #33	; 0x21
    2058:	9fda0800 	svcls	0x00da0800
    205c:	00002106 	andeq	r2, r0, r6, lsl #2
    2060:	00002132 	andeq	r2, r0, r2, lsr r1
    2064:	38540001 	ldmdacc	r4, {r0}^
    2068:	4c000021 	stcmi	0, cr0, [r0], {33}	; 0x21
    206c:	01000021 	tsteq	r0, r1, lsr #32
    2070:	00005200 	andeq	r5, r0, r0, lsl #4
    2074:	00000000 	andeq	r0, r0, r0
    2078:	21000000 	mrscs	r0, (UNDEF: 0)
    207c:	21060000 	mrscs	r0, (UNDEF: 6)
    2080:	00020000 	andeq	r0, r2, r0
    2084:	21069f30 	tstcs	r6, r0, lsr pc
    2088:	21160000 	tstcs	r6, r0
    208c:	00010000 	andeq	r0, r1, r0
    2090:	00211653 	eoreq	r1, r1, r3, asr r6
    2094:	00211c00 	eoreq	r1, r1, r0, lsl #24
    2098:	73000300 	movwvc	r0, #768	; 0x300
}
    209c:	211c9f7f 	tstcs	ip, pc, ror pc
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    20a0:	21240000 	teqcs	r4, r0
    20a4:	00010000 	andeq	r0, r1, r0
    20a8:	00213853 	eoreq	r3, r1, r3, asr r8
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    20ac:	00214000 	eoreq	r4, r1, r0
    20b0:	53000100 	movwpl	r0, #256	; 0x100
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}
    20b4:	00002140 	andeq	r2, r0, r0, asr #2
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    20b8:	00002146 	andeq	r2, r0, r6, asr #2
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}

void f25519_add(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint16_t c = 0;
    20bc:	7f730003 	svcvc	0x00730003
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
    20c0:	0021469f 	mlaeq	r1, pc, r6, r4	; <UNPREDICTABLE>
    20c4:	00214c00 	eoreq	r4, r1, r0, lsl #24
		r[i] = c;
    20c8:	53000100 	movwpl	r0, #256	; 0x100
	...
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20d4:	0000214c 	andeq	r2, r0, ip, asr #2
	c = (c >> 7) * 19;
    20d8:	00002168 	andeq	r2, r0, r8, ror #2
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    20dc:	68510001 	ldmdavs	r1, {r0}^
	c = (c >> 7) * 19;
    20e0:	92000021 	andls	r0, r0, #33	; 0x21
    20e4:	04000021 	streq	r0, [r0], #-33	; 0x21

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    20e8:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    20ec:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    20f0:	00000000 	andeq	r0, r0, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    20f4:	00214c00 	eoreq	r4, r1, r0, lsl #24

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    20f8:	00215200 	eoreq	r5, r1, r0, lsl #4
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    20fc:	08000300 	stmdaeq	r0, {r8, r9}

void f25519_sub(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2100:	21529fda 	ldrsbcs	r9, [r2, #-250]	; 0xffffff06
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
    2104:	21760000 	cmncs	r6, r0
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2108:	00010000 	andeq	r0, r1, r0
    210c:	00217c52 	eoreq	r7, r1, r2, asr ip
    2110:	00219200 	eoreq	r9, r1, r0, lsl #4
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2114:	52000100 	andpl	r0, r0, #0, 2
	...
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2120:	0000214c 	andeq	r2, r0, ip, asr #2
    2124:	00002152 	andeq	r2, r0, r2, asr r1
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2128:	9f300002 	svcls	0x00300002
    212c:	00002152 	andeq	r2, r0, r2, asr r1
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2130:	0000215e 	andeq	r2, r0, lr, asr r1
	c = (c >> 7) * 19;
    2134:	5e530001 	cdppl	0, 5, cr0, cr3, cr1, {0}

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2138:	64000021 	strvs	r0, [r0], #-33	; 0x21
		r[i] = c;
    213c:	03000021 	movweq	r0, #33	; 0x21

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2140:	9f7f7300 	svcls	0x007f7300
		c += r[i];
		r[i] = c;
		c >>= 8;
    2144:	00002164 	andeq	r2, r0, r4, ror #2
	}
}
    2148:	0000216a 	andeq	r2, r0, sl, ror #2

void f25519_neg(uint8_t *r, const uint8_t *a)
{
    214c:	7c530001 	mrrcvc	0, 0, r0, r3, cr1
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
    2150:	84000021 	strhi	r0, [r0], #-33	; 0x21
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 - ((uint32_t)a[i]);
    2154:	01000021 	tsteq	r0, r1, lsr #32
    2158:	21845300 	orrcs	r5, r4, r0, lsl #6
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    215c:	218a0000 	orrcs	r0, sl, r0
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
    2160:	00030000 	andeq	r0, r3, r0
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2164:	8a9f7f73 	bhi	fe7e1f38 <BootRAM+0xd7526d9>

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2168:	92000021 	andls	r0, r0, #33	; 0x21
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;
    216c:	01000021 	tsteq	r0, r1, lsr #32
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    2170:	00005300 	andeq	r5, r0, r0, lsl #6
	c = (c >> 7) * 19;
    2174:	00000000 	andeq	r0, r0, r0
    2178:	21940000 	orrscs	r0, r4, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    217c:	21f40000 	mvnscs	r0, r0
		r[i] = c;
    2180:	00010000 	andeq	r0, r1, r0

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2184:	0021f451 	eoreq	pc, r1, r1, asr r4	; <UNPREDICTABLE>
		c += r[i];
		r[i] = c;
		c >>= 8;
    2188:	00221c00 	eoreq	r1, r2, r0, lsl #24
	}
}
    218c:	f3000400 	vshl.u8	d0, d0, d0
    2190:	009f5101 	addseq	r5, pc, r1, lsl #2

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2194:	00000000 	andeq	r0, r0, r0
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2198:	94000000 	strls	r0, [r0], #-0
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    219c:	fa000021 	blx	2228 <f25519_inv__distinct+0xc>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    21a0:	01000021 	tsteq	r0, r1, lsr #32
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    21a4:	21fa5200 	mvnscs	r5, r0, lsl #4
		for (j = 0; j <= i; j++)
    21a8:	221c0000 	andscs	r0, ip, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    21ac:	00040000 	andeq	r0, r4, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    21b0:	9f5201f3 	svcls	0x005201f3
	...
    21bc:	00002194 	muleq	r0, r4, r1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21c0:	000021a2 	andeq	r2, r0, r2, lsr #3
    21c4:	9f300002 	svcls	0x00300002
    21c8:	000021a2 	andeq	r2, r0, r2, lsr #3
    21cc:	000021f6 	strdeq	r2, [r0], -r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    21d0:	02530001 	subseq	r0, r3, #1
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    21d4:	1c000022 	stcne	0, cr0, [r0], {34}	; 0x22
    21d8:	01000022 	tsteq	r0, r2, lsr #32

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    21dc:	00005200 	andeq	r5, r0, r0, lsl #4
			c += ((uint32_t)a[j]) *
    21e0:	00000000 	andeq	r0, r0, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    21e4:	21940000 	orrscs	r0, r4, r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    21e8:	21a20000 			; <UNDEFINED> instruction: 0x21a20000
    21ec:	00020000 	andeq	r0, r2, r0
    21f0:	21a29f30 			; <UNDEFINED> instruction: 0x21a29f30

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    21f4:	22020000 	andcs	r0, r2, #0
    21f8:	00010000 	andeq	r0, r1, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    21fc:	00220258 	eoreq	r0, r2, r8, asr r2
	c = (c >> 7) * 19;
    2200:	00220600 	eoreq	r0, r2, r0, lsl #12

	for (i = 0; i < F25519_SIZE; i++) {
    2204:	30000200 	andcc	r0, r0, r0, lsl #4
		c += r[i];
    2208:	0022069f 	mlaeq	r2, pc, r6, r0	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    220c:	00220e00 	eoreq	r0, r2, r0, lsl #28
		c += r[i];
		r[i] = c;
		c >>= 8;
    2210:	53000100 	movwpl	r0, #256	; 0x100
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2214:	0000220e 	andeq	r2, r0, lr, lsl #4
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    2218:	00002214 	andeq	r2, r0, r4, lsl r2
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    221c:	7f730003 	svcvc	0x00730003
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2220:	0022149f 	mlaeq	r2, pc, r4, r1	; <UNPREDICTABLE>
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    2224:	00221c00 	eoreq	r1, r2, r0, lsl #24
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2228:	53000100 	movwpl	r0, #256	; 0x100
	...
	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2234:	000021a4 	andeq	r2, r0, r4, lsr #3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2238:	000021aa 	andeq	r2, r0, sl, lsr #3
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    223c:	9f300002 	svcls	0x00300002

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2240:	000021aa 	andeq	r2, r0, sl, lsr #3
    2244:	000021b2 			; <UNDEFINED> instruction: 0x000021b2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2248:	b2540001 	subslt	r0, r4, #1
    224c:	b8000021 	stmdalt	r0, {r0, r5}
    2250:	03000021 	movweq	r0, #33	; 0x21
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2254:	9f7f7400 	svcls	0x007f7400
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2258:	000021b8 			; <UNDEFINED> instruction: 0x000021b8
    225c:	000021dc 	ldrdeq	r2, [r0], -ip

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2260:	dc540001 	mrrcle	0, 0, r0, r4, cr1
			c += ((uint32_t)a[j]) *
    2264:	e2000021 	and	r0, r0, #33	; 0x21
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2268:	03000021 	movweq	r0, #33	; 0x21
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    226c:	9f7f7400 	svcls	0x007f7400
    2270:	000021e2 	andeq	r2, r0, r2, ror #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2274:	0000221a 	andeq	r2, r0, sl, lsl r2
	c = (c >> 7) * 19;
    2278:	00540001 	subseq	r0, r4, r1
	...
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2288:	01000000 	mrseq	r0, (UNDEF: 0)
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    228c:	00005000 	andeq	r5, r0, r0
		r[i] = c;
    2290:	00000000 	andeq	r0, r0, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2294:	00010000 	andeq	r0, r1, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    2298:	00000058 	andeq	r0, r0, r8, asr r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    229c:	00000000 	andeq	r0, r0, r0
    22a0:	f3000400 	vshl.u8	d0, d0, d0
    22a4:	009f5001 	addseq	r5, pc, r1
	...
	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22b4:	01000000 	mrseq	r0, (UNDEF: 0)
    22b8:	00005100 	andeq	r5, r0, r0, lsl #2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22bc:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22c0:	00040000 	andeq	r0, r4, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22c4:	9f5101f3 	svcls	0x005101f3
	...
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    22d8:	00520001 	subseq	r0, r2, r1
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22dc:	00000000 	andeq	r0, r0, r0
    22e0:	04000000 	streq	r0, [r0], #-0
    22e4:	5201f300 	andpl	pc, r1, #0, 6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22e8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    22f8:	52000100 	andpl	r0, r0, #0, 2
	...

	for (i = 0; i < F25519_SIZE; i++) {
    2304:	01f30004 	mvnseq	r0, r4
		c += r[i];
    2308:	00009f52 	andeq	r9, r0, r2, asr pc
	...
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2318:	00010000 	andeq	r0, r1, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    231c:	00000051 	andeq	r0, r0, r1, asr r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2320:	00000000 	andeq	r0, r0, r0
    2324:	f3000400 	vshl.u8	d0, d0, d0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2328:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
		for (j = 0; j <= i; j++)
    2338:	01000000 	mrseq	r0, (UNDEF: 0)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    233c:	00005d00 	andeq	r5, r0, r0, lsl #26

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2340:	00000000 	andeq	r0, r0, r0
    2344:	00030000 	andeq	r0, r3, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2348:	009f6074 	addseq	r6, pc, r4, ror r0	; <UNPREDICTABLE>
    234c:	00000000 	andeq	r0, r0, r0
    2350:	03000000 	movweq	r0, #0
    2354:	9f487d00 	svcls	0x00487d00
	...
			c += ((uint32_t)a[j]) *
    2368:	9f300002 	svcls	0x00300002
	...
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2374:	00530001 	subseq	r0, r3, r1
    2378:	00000000 	andeq	r0, r0, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    237c:	01000000 	mrseq	r0, (UNDEF: 0)
	c = (c >> 7) * 19;
    2380:	00005200 	andeq	r5, r0, r0, lsl #4
	...
    2390:	00020000 	andeq	r0, r2, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2394:	00009f30 	andeq	r9, r0, r0, lsr pc
		r[i] = c;
    2398:	00000000 	andeq	r0, r0, r0
		c >>= 8;
    239c:	00010000 	andeq	r0, r1, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23a0:	00000059 	andeq	r0, r0, r9, asr r0
    23a4:	00000000 	andeq	r0, r0, r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    23a8:	30000200 	andcc	r0, r0, r0, lsl #4
    23ac:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23b0:	00000000 	andeq	r0, r0, r0
    23b4:	73000800 	movwvc	r0, #2048	; 0x800

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23b8:	1c009100 	stfned	f1, [r0], {-0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23bc:	009f3823 	addseq	r3, pc, r3, lsr #16

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23c0:	00000000 	andeq	r0, r0, r0
    23c4:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23c8:	91007300 	mrsls	r7, LR_irq
    23cc:	37231c00 	strcc	r1, [r3, -r0, lsl #24]!
    23d0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    23d4:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    23d8:	73000800 	movwvc	r0, #2048	; 0x800
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    23dc:	1c009100 	stfned	f1, [r0], {-0}
    23e0:	009f3823 	addseq	r3, pc, r3, lsr #16
	...
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    23f0:	02000000 	andeq	r0, r0, #0
    23f4:	009f3000 	addseq	r3, pc, r0
    23f8:	00000000 	andeq	r0, r0, r0

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    23fc:	01000000 	mrseq	r0, (UNDEF: 0)
    2400:	00005400 	andeq	r5, r0, r0, lsl #8
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2404:	00000000 	andeq	r0, r0, r0
	c = (c >> 7) * 19;
    2408:	00030000 	andeq	r0, r3, r0

	for (i = 0; i < F25519_SIZE; i++) {
    240c:	009f7f74 	addseq	r7, pc, r4, ror pc	; <UNPREDICTABLE>
		c += r[i];
    2410:	00000000 	andeq	r0, r0, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2414:	01000000 	mrseq	r0, (UNDEF: 0)
		c += r[i];
		r[i] = c;
		c >>= 8;
    2418:	00005400 	andeq	r5, r0, r0, lsl #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    241c:	00000000 	andeq	r0, r0, r0
	/* 1 1 */
	f25519_mul__distinct(s, x, x);
	f25519_mul__distinct(r, s, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    2420:	00030000 	andeq	r0, r3, r0
    2424:	009f7f74 	addseq	r7, pc, r4, ror pc	; <UNPREDICTABLE>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2428:	00000000 	andeq	r0, r0, r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    242c:	01000000 	mrseq	r0, (UNDEF: 0)
    2430:	00005400 	andeq	r5, r0, r0, lsl #8
	...
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2440:	00010000 	andeq	r0, r1, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2444:	0000005d 	andeq	r0, r0, sp, asr r0
    2448:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    244c:	74000300 	strvc	r0, [r0], #-768	; 0x300
    2450:	00009f60 	andeq	r9, r0, r0, ror #30
    2454:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2458:	00030000 	andeq	r0, r3, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    245c:	009f487d 	addseq	r4, pc, sp, ror r8	; <UNPREDICTABLE>
	...

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    246c:	01000000 	mrseq	r0, (UNDEF: 0)
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2470:	00005800 	andeq	r5, r0, r0, lsl #16
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2474:	00000000 	andeq	r0, r0, r0
    2478:	00040000 	andeq	r0, r4, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    247c:	9f5001f3 	svcls	0x005001f3
	...
    2490:	00520001 	subseq	r0, r2, r1
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2494:	00000000 	andeq	r0, r0, r0
		r[i] = c;
    2498:	04000000 	streq	r0, [r0], #-0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    249c:	5201f300 	andpl	pc, r1, #0, 6
		c += r[i];
		r[i] = c;
		c >>= 8;
    24a0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24b0:	30000200 	andcc	r0, r0, r0, lsl #4
    24b4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    24b8:	00000000 	andeq	r0, r0, r0
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24bc:	74000500 	strvc	r0, [r0], #-1280	; 0x500
    24c0:	9f253800 	svcls	0x00253800
	...

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24cc:	00540001 	subseq	r0, r4, r1
	...
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24dc:	02000000 	andeq	r0, r0, #0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    24e0:	009f3000 	addseq	r3, pc, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24e4:	00000000 	andeq	r0, r0, r0
    24e8:	01000000 	mrseq	r0, (UNDEF: 0)

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24ec:	00005300 	andeq	r5, r0, r0, lsl #6
			c += ((uint32_t)a[j]) *
    24f0:	00000000 	andeq	r0, r0, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    24f4:	00020000 	andeq	r0, r2, r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    24f8:	00009f30 	andeq	r9, r0, r0, lsr pc
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    24fc:	00000000 	andeq	r0, r0, r0
	c = (c >> 7) * 19;
    2500:	00010000 	andeq	r0, r1, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2504:	00000053 	andeq	r0, r0, r3, asr r0
	c = (c >> 7) * 19;
    2508:	00000000 	andeq	r0, r0, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    250c:	73000300 	movwvc	r0, #768	; 0x300
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2510:	00009f7f 	andeq	r9, r0, pc, ror pc
		r[i] = c;
    2514:	00000000 	andeq	r0, r0, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2518:	00010000 	andeq	r0, r1, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    251c:	00000053 	andeq	r0, r0, r3, asr r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2520:	00000000 	andeq	r0, r0, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2524:	00221c00 	eoreq	r1, r2, r0, lsl #24
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2528:	0027dc00 	eoreq	sp, r7, r0, lsl #24
		for (j = 0; j <= i; j++)
    252c:	51000100 	mrspl	r0, (UNDEF: 16)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2530:	000027dc 	ldrdeq	r2, [r0], -ip
    2534:	00002806 	andeq	r2, r0, r6, lsl #16

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2538:	01f30004 	mvnseq	r0, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    253c:	00009f51 	andeq	r9, r0, r1, asr pc

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2540:	00000000 	andeq	r0, r0, r0
    2544:	22240000 	eorcs	r0, r4, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2548:	27dc0000 	ldrbcs	r0, [ip, r0]
    254c:	00010000 	andeq	r0, r1, r0
    2550:	0027dc51 	eoreq	sp, r7, r1, asr ip
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2554:	00280600 	eoreq	r0, r8, r0, lsl #12
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2558:	f3000400 	vshl.u8	d0, d0, d0
    255c:	009f5101 	addseq	r5, pc, r1, lsl #2

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2560:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) *
    2564:	24000000 	strcs	r0, [r0], #-0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2568:	00000022 	andeq	r0, r0, r2, lsr #32
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    256c:	01000028 	tsteq	r0, r8, lsr #32
    2570:	28005d00 	stmdacs	r0, {r8, sl, fp, ip, lr}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2574:	28040000 	stmdacs	r4, {}	; <UNPREDICTABLE>
	c = (c >> 7) * 19;
    2578:	00030000 	andeq	r0, r3, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    257c:	049f4091 	ldreq	r4, [pc], #145	; 2584 <f25519_inv__distinct+0x368>
	c = (c >> 7) * 19;
    2580:	06000028 	streq	r0, [r0], -r8, lsr #32
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2584:	03000028 	movweq	r0, #40	; 0x28
	c = (c >> 7) * 19;
    2588:	9f407d00 	svcls	0x00407d00
	...

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
		r[i] = c;
		c >>= 8;
    2594:	00002224 	andeq	r2, r0, r4, lsr #4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2598:	0000222a 	andeq	r2, r0, sl, lsr #4
    259c:	9f300002 	svcls	0x00300002
    25a0:	0000222a 	andeq	r2, r0, sl, lsr #4
    25a4:	00002278 	andeq	r2, r0, r8, ror r2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25a8:	84530001 	ldrbhi	r0, [r3], #-1
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    25ac:	a2000022 	andge	r0, r0, #34	; 0x22
		for (j = 0; j <= i; j++)
    25b0:	01000022 	tsteq	r0, r2, lsr #32
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25b4:	00005200 	andeq	r5, r0, r0, lsl #4
    25b8:	00000000 	andeq	r0, r0, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25bc:	22240000 	eorcs	r0, r4, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25c0:	222a0000 	eorcs	r0, sl, #0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25c4:	00020000 	andeq	r0, r2, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25c8:	222a9f30 	eorcs	r9, sl, #48, 30	; 0xc0
    25cc:	22840000 	addcs	r0, r4, #0
    25d0:	00010000 	andeq	r0, r1, r0
    25d4:	00228456 	eoreq	r8, r2, r6, asr r4
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    25d8:	00228c00 	eoreq	r8, r2, r0, lsl #24
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25dc:	30000200 	andcc	r0, r0, r0, lsl #4
    25e0:	00228c9f 	mlaeq	r2, pc, ip, r8	; <UNPREDICTABLE>
    25e4:	00229400 	eoreq	r9, r2, r0, lsl #8

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25e8:	73000800 	movwvc	r0, #2048	; 0x800
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    25ec:	1c009100 	stfned	f1, [r0], {-0}
    25f0:	949f4023 	ldrls	r4, [pc], #35	; 25f8 <f25519_inv__distinct+0x3dc>

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    25f4:	9a000022 	bls	2684 <f25519_inv__distinct+0x468>
    25f8:	08000022 	stmdaeq	r0, {r1, r5}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25fc:	91007300 	mrsls	r7, LR_irq
	c = (c >> 7) * 19;
    2600:	3f231c00 	svccc	0x00231c00

	for (i = 0; i < F25519_SIZE; i++) {
    2604:	00229a9f 	mlaeq	r2, pc, sl, r9	; <UNPREDICTABLE>
		c += r[i];
    2608:	0022a400 	eoreq	sl, r2, r0, lsl #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    260c:	73000800 	movwvc	r0, #2048	; 0x800
		c += r[i];
		r[i] = c;
		c >>= 8;
    2610:	1c009100 	stfned	f1, [r0], {-0}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2614:	009f4023 	addseq	r4, pc, r3, lsr #32
    2618:	00000000 	andeq	r0, r0, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    261c:	2c000000 	stccs	0, cr0, [r0], {-0}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2620:	30000022 	andcc	r0, r0, r2, lsr #32
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2624:	02000022 	andeq	r0, r0, #34	; 0x22
    2628:	309f3000 	addscc	r3, pc, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    262c:	38000022 	stmdacc	r0, {r1, r5}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2630:	01000022 	tsteq	r0, r2, lsr #32

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2634:	22385200 	eorscs	r5, r8, #0, 4
    2638:	223e0000 	eorscs	r0, lr, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    263c:	00030000 	andeq	r0, r3, r0
    2640:	3e9f7f72 	mrccc	15, 4, r7, cr15, cr2, {3}
    2644:	60000022 	andvs	r0, r0, r2, lsr #32
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2648:	01000022 	tsteq	r0, r2, lsr #32
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    264c:	22605200 	rsbcs	r5, r0, #0, 4
    2650:	22660000 	rsbcs	r0, r6, #0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2654:	00030000 	andeq	r0, r3, r0
			c += ((uint32_t)a[j]) *
    2658:	669f7f72 			; <UNDEFINED> instruction: 0x669f7f72

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    265c:	7c000022 	stcvc	0, cr0, [r0], {34}	; 0x22
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2660:	01000022 	tsteq	r0, r2, lsr #32
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2664:	00005200 	andeq	r5, r0, r0, lsl #4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2668:	00000000 	andeq	r0, r0, r0
	c = (c >> 7) * 19;
    266c:	22ac0000 	adccs	r0, ip, #0
    2670:	22f60000 	rscscs	r0, r6, #0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2674:	00010000 	andeq	r0, r1, r0
	c = (c >> 7) * 19;
    2678:	00230253 	eoreq	r0, r3, r3, asr r2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    267c:	00232000 	eoreq	r2, r3, r0
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2680:	52000100 	andpl	r0, r0, #0, 2
	...
		r[i] = c;
		c >>= 8;
    268c:	000022ac 	andeq	r2, r0, ip, lsr #5
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2690:	00002302 	andeq	r2, r0, r2, lsl #6
    2694:	02550001 	subseq	r0, r5, #1
    2698:	06000023 	streq	r0, [r0], -r3, lsr #32
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    269c:	02000023 	andeq	r0, r0, #35	; 0x23
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    26a0:	069f3000 	ldreq	r3, [pc], r0
		for (j = 0; j <= i; j++)
    26a4:	0e000023 	cdpeq	0, 0, cr0, cr0, cr3, {1}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26a8:	01000023 	tsteq	r0, r3, lsr #32
    26ac:	230e5300 	movwcs	r5, #58112	; 0xe300

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26b0:	23140000 	tstcs	r4, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26b4:	00030000 	andeq	r0, r3, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26b8:	149f7f73 	ldrne	r7, [pc], #3955	; 26c0 <f25519_inv__distinct+0x4a4>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26bc:	20000023 	andcs	r0, r0, r3, lsr #32
    26c0:	01000023 	tsteq	r0, r3, lsr #32
    26c4:	00005300 	andeq	r5, r0, r0, lsl #6
    26c8:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    26cc:	22ae0000 	adccs	r0, lr, #0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26d0:	22b20000 	adcscs	r0, r2, #0
    26d4:	00020000 	andeq	r0, r2, r0
    26d8:	22b29f30 	adcscs	r9, r2, #48, 30	; 0xc0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26dc:	22bc0000 	adcscs	r0, ip, #0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    26e0:	00010000 	andeq	r0, r1, r0
    26e4:	0022bc52 	eoreq	fp, r2, r2, asr ip

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    26e8:	0022c200 	eoreq	ip, r2, r0, lsl #4
    26ec:	72000300 	andvc	r0, r0, #0, 6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26f0:	22c29f7f 	sbccs	r9, r2, #508	; 0x1fc
	c = (c >> 7) * 19;
    26f4:	22c80000 	sbccs	r0, r8, #0

	for (i = 0; i < F25519_SIZE; i++) {
    26f8:	00010000 	andeq	r0, r1, r0
		c += r[i];
    26fc:	0022c852 	eoreq	ip, r2, r2, asr r8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2700:	0022d600 	eoreq	sp, r2, r0, lsl #12
		c += r[i];
		r[i] = c;
		c >>= 8;
    2704:	72000300 	andvc	r0, r0, #0, 6
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2708:	22d69f01 	sbcscs	r9, r6, #1, 30
    270c:	22de0000 	sbcscs	r0, lr, #0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2710:	00080000 	andeq	r0, r8, r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2714:	00910072 	addseq	r0, r1, r2, ror r0
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2718:	9f41231c 	svcls	0x0041231c
    271c:	000022de 	ldrdeq	r2, [r0], -lr

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2720:	000022e8 	andeq	r2, r0, r8, ror #5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2724:	00720008 	rsbseq	r0, r2, r8

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2728:	231c0091 	tstcs	ip, #145	; 0x91
    272c:	22e89f40 	rsccs	r9, r8, #64, 30	; 0x100
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2730:	22ea0000 	rsccs	r0, sl, #0
    2734:	00080000 	andeq	r0, r8, r0
    2738:	00910072 	addseq	r0, r1, r2, ror r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    273c:	9f41231c 	svcls	0x0041231c
	...

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2748:	00002320 	andeq	r2, r0, r0, lsr #6
			c += ((uint32_t)a[j]) *
    274c:	00002326 	andeq	r2, r0, r6, lsr #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2750:	9f300002 	svcls	0x00300002
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2754:	00002326 	andeq	r2, r0, r6, lsr #6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2758:	00002380 	andeq	r2, r0, r0, lsl #7
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    275c:	8c530001 	mrrchi	0, 0, r0, r3, cr1
	c = (c >> 7) * 19;
    2760:	a8000023 	stmdage	r0, {r0, r1, r5}
    2764:	01000023 	tsteq	r0, r3, lsr #32
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2768:	00005200 	andeq	r5, r0, r0, lsl #4
	c = (c >> 7) * 19;
    276c:	00000000 	andeq	r0, r0, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2770:	23200000 	teqcs	r0, #0
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2774:	23260000 	teqcs	r6, #0
		r[i] = c;
    2778:	00020000 	andeq	r0, r2, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    277c:	23269f30 	teqcs	r6, #48, 30	; 0xc0
		c += r[i];
		r[i] = c;
		c >>= 8;
    2780:	238c0000 	orrcs	r0, ip, #0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2784:	00010000 	andeq	r0, r1, r0
    2788:	00238c59 	eoreq	r8, r3, r9, asr ip
    278c:	00239200 	eoreq	r9, r3, r0, lsl #4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2790:	30000200 	andcc	r0, r0, r0, lsl #4
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2794:	0023929f 	mlaeq	r3, pc, r2, r9	; <UNPREDICTABLE>
		for (j = 0; j <= i; j++)
    2798:	00239a00 	eoreq	r9, r3, r0, lsl #20
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    279c:	73000800 	movwvc	r0, #2048	; 0x800
    27a0:	1c009100 	stfned	f1, [r0], {-0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27a4:	9a9f4023 	bls	fe7d2838 <BootRAM+0xd742fd9>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27a8:	a0000023 	andge	r0, r0, r3, lsr #32

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27ac:	08000023 	stmdaeq	r0, {r0, r1, r5}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27b0:	91007300 	mrsls	r7, LR_irq
    27b4:	3f231c00 	svccc	0x00231c00
    27b8:	0023a09f 	mlaeq	r3, pc, r0, sl	; <UNPREDICTABLE>
    27bc:	0023a800 	eoreq	sl, r3, r0, lsl #16
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    27c0:	73000800 	movwvc	r0, #2048	; 0x800
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27c4:	1c009100 	stfned	f1, [r0], {-0}
    27c8:	009f4023 	addseq	r4, pc, r3, lsr #32
    27cc:	00000000 	andeq	r0, r0, r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27d0:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    27d4:	2e000023 	cdpcs	0, 0, cr0, cr0, cr3, {1}
    27d8:	02000023 	andeq	r0, r0, #35	; 0x23

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    27dc:	2e9f3000 	cdpcs	0, 9, cr3, cr15, cr0, {0}
    27e0:	38000023 	stmdacc	r0, {r0, r1, r5}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    27e4:	01000023 	tsteq	r0, r3, lsr #32
	c = (c >> 7) * 19;
    27e8:	23385200 	teqcs	r8, #0, 4

	for (i = 0; i < F25519_SIZE; i++) {
    27ec:	233e0000 	teqcs	lr, #0
		c += r[i];
    27f0:	00030000 	andeq	r0, r3, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27f4:	3e9f7f72 	mrccc	15, 4, r7, cr15, cr2, {3}
		c += r[i];
		r[i] = c;
		c >>= 8;
    27f8:	64000023 	strvs	r0, [r0], #-35	; 0x23
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27fc:	01000023 	tsteq	r0, r3, lsr #32
	f25519_mul__distinct(r, s, x);

	/* 1 */
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}
    2800:	23645200 	cmncs	r4, #0, 4
    2804:	236a0000 	cmncs	sl, #0
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    2808:	00030000 	andeq	r0, r3, r0
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    280c:	6a9f7f72 	bvs	fe7e25dc <BootRAM+0xd752d7d>
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    2810:	84000023 	strhi	r0, [r0], #-35	; 0x23
	f25519_copy(r, tmp);
}

void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
    2814:	01000023 	tsteq	r0, r3, lsr #32
    2818:	00005200 	andeq	r5, r0, r0, lsl #4
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += b * ((uint32_t)a[i]);
    281c:	00000000 	andeq	r0, r0, r0
    2820:	23a80000 			; <UNDEFINED> instruction: 0x23a80000
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2824:	23fe0000 	mvnscs	r0, #0
    2828:	00010000 	andeq	r0, r1, r0
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    282c:	00240a53 	eoreq	r0, r4, r3, asr sl
    2830:	00242c00 	eoreq	r2, r4, r0, lsl #24
	c >>= 7;
	c *= 19;
    2834:	52000100 	andpl	r0, r0, #0, 2
	...
    2840:	000023a8 	andeq	r2, r0, r8, lsr #7

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2844:	0000240a 	andeq	r2, r0, sl, lsl #8
		r[i] = c;
    2848:	0a590001 	beq	1642854 <_etext+0x163b33c>

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    284c:	0e000024 	cdpeq	0, 0, cr0, cr0, cr4, {1}
		c += r[i];
		r[i] = c;
		c >>= 8;
    2850:	02000024 	andeq	r0, r0, #36	; 0x24

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2854:	0e9f3000 	cdpeq	0, 9, cr3, cr15, cr0, {0}
    2858:	16000024 	strne	r0, [r0], -r4, lsr #32
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    285c:	01000024 	tsteq	r0, r4, lsr #32
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2860:	24165300 	ldrcs	r5, [r6], #-768	; 0x300
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2864:	241c0000 	ldrcs	r0, [ip], #-0
    2868:	00030000 	andeq	r0, r3, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    286c:	1c9f7f73 	ldcne	15, cr7, [pc], {115}	; 0x73
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2870:	28000024 	stmdacs	r0, {r2, r5}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2874:	01000024 	tsteq	r0, r4, lsr #32
    2878:	00005300 	andeq	r5, r0, r0, lsl #6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    287c:	00000000 	andeq	r0, r0, r0
    2880:	23aa0000 			; <UNDEFINED> instruction: 0x23aa0000
    2884:	23b00000 	movscs	r0, #0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2888:	00020000 	andeq	r0, r2, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    288c:	23b09f30 	movscs	r9, #48, 30	; 0xc0
    2890:	23ba0000 			; <UNDEFINED> instruction: 0x23ba0000
    2894:	00010000 	andeq	r0, r1, r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2898:	0023ba52 	eoreq	fp, r3, r2, asr sl
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    289c:	0023c000 	eoreq	ip, r3, r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28a0:	72000300 	andvc	r0, r0, #0, 6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28a4:	23c09f7f 	biccs	r9, r0, #508	; 0x1fc
	c = (c >> 7) * 19;
    28a8:	23c60000 	biccs	r0, r6, #0
    28ac:	00010000 	andeq	r0, r1, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28b0:	0023c652 	eoreq	ip, r3, r2, asr r6
	c = (c >> 7) * 19;
    28b4:	0023d800 	eoreq	sp, r3, r0, lsl #16
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    28b8:	72000300 	andvc	r0, r0, #0, 6
	c = (c >> 7) * 19;
    28bc:	23d89f01 	bicscs	r9, r8, #1, 30

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    28c0:	23e00000 	mvncs	r0, #0
		r[i] = c;
    28c4:	00080000 	andeq	r0, r8, r0
		c >>= 8;
    28c8:	00910072 	addseq	r0, r1, r2, ror r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28cc:	9f41231c 	svcls	0x0041231c
    28d0:	000023e0 	andeq	r2, r0, r0, ror #7
    28d4:	000023ea 	andeq	r2, r0, sl, ror #7
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    28d8:	00720008 	rsbseq	r0, r2, r8
		for (j = 0; j <= i; j++)
    28dc:	231c0091 	tstcs	ip, #145	; 0x91
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    28e0:	23ea9f40 	mvncs	r9, #64, 30	; 0x100
    28e4:	23ec0000 	mvncs	r0, #0
    28e8:	00080000 	andeq	r0, r8, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    28ec:	00910072 	addseq	r0, r1, r2, ror r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    28f0:	9f41231c 	svcls	0x0041231c
	...

		for (; j < F25519_SIZE; j++)
    28fc:	0000242c 	andeq	r2, r0, ip, lsr #8
    2900:	00002482 	andeq	r2, r0, r2, lsl #9
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2904:	8e530001 	cdphi	0, 5, cr0, cr3, cr1, {0}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2908:	aa000024 	bge	29a0 <f25519_sqrt+0x198>
    290c:	01000024 	tsteq	r0, r4, lsr #32

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2910:	00005200 	andeq	r5, r0, r0, lsl #4
			c += ((uint32_t)a[j]) *
    2914:	00000000 	andeq	r0, r0, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2918:	242c0000 	strtcs	r0, [ip], #-0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    291c:	248e0000 	strcs	r0, [lr], #0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2920:	00010000 	andeq	r0, r1, r0
	c = (c >> 7) * 19;
    2924:	00248e5c 	eoreq	r8, r4, ip, asr lr
    2928:	00249400 	eoreq	r9, r4, r0, lsl #8
    292c:	30000200 	andcc	r0, r0, r0, lsl #4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2930:	0024949f 	mlaeq	r4, pc, r4, r9	; <UNPREDICTABLE>
	c = (c >> 7) * 19;
    2934:	00249c00 	eoreq	r9, r4, r0, lsl #24
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2938:	73000800 	movwvc	r0, #2048	; 0x800
    293c:	1c009100 	stfned	f1, [r0], {-0}
	c = (c >> 7) * 19;
    2940:	9c9f4023 	ldcls	0, cr4, [pc], {35}	; 0x23

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2944:	a2000024 	andge	r0, r0, #36	; 0x24
		r[i] = c;
    2948:	08000024 	stmdaeq	r0, {r2, r5}
		c >>= 8;
    294c:	91007300 	mrsls	r7, LR_irq
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2950:	3f231c00 	svccc	0x00231c00
    2954:	0024a29f 	mlaeq	r4, pc, r2, sl	; <UNPREDICTABLE>
    2958:	0024ac00 	eoreq	sl, r4, r0, lsl #24
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    295c:	73000800 	movwvc	r0, #2048	; 0x800

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2960:	1c009100 	stfned	f1, [r0], {-0}
    2964:	009f4023 	addseq	r4, pc, r3, lsr #32
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2968:	00000000 	andeq	r0, r0, r0
		for (j = 0; j <= i; j++)
    296c:	2e000000 	cdpcs	0, 0, cr0, cr0, cr0, {0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2970:	34000024 	strcc	r0, [r0], #-36	; 0x24
    2974:	02000024 	andeq	r0, r0, #36	; 0x24

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2978:	349f3000 	ldrcc	r3, [pc], #0	; 2980 <f25519_sqrt+0x178>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    297c:	3c000024 	stccc	0, cr0, [r0], {36}	; 0x24

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2980:	01000024 	tsteq	r0, r4, lsr #32
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2984:	243c5200 	ldrtcs	r5, [ip], #-512	; 0x200
    2988:	24420000 	strbcs	r0, [r2], #-0
    298c:	00030000 	andeq	r0, r3, r0
    2990:	429f7f72 	addsmi	r7, pc, #456	; 0x1c8
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2994:	66000024 	strvs	r0, [r0], -r4, lsr #32
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2998:	01000024 	tsteq	r0, r4, lsr #32
    299c:	24665200 	strbtcs	r5, [r6], #-512	; 0x200

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29a0:	246c0000 	strbtcs	r0, [ip], #-0
			c += ((uint32_t)a[j]) *
    29a4:	00030000 	andeq	r0, r3, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    29a8:	6c9f7f72 	ldcvs	15, cr7, [pc], {114}	; 0x72
    29ac:	86000024 	strhi	r0, [r0], -r4, lsr #32
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    29b0:	01000024 	tsteq	r0, r4, lsr #32
    29b4:	00005200 	andeq	r5, r0, r0, lsl #4
    29b8:	00000000 	andeq	r0, r0, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29bc:	24b40000 	ldrtcs	r0, [r4], #0
	c = (c >> 7) * 19;
    29c0:	25000000 	strcs	r0, [r0, #-0]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29c4:	00010000 	andeq	r0, r1, r0
	c = (c >> 7) * 19;
    29c8:	00250c53 	eoreq	r0, r5, r3, asr ip
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29cc:	00252800 	eoreq	r2, r5, r0, lsl #16
	c = (c >> 7) * 19;
    29d0:	52000100 	andpl	r0, r0, #0, 2
	...

	for (i = 0; i < F25519_SIZE; i++) {
    29dc:	000024b4 			; <UNDEFINED> instruction: 0x000024b4
		c += r[i];
		r[i] = c;
		c >>= 8;
    29e0:	0000250c 	andeq	r2, r0, ip, lsl #10
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    29e4:	0c550001 	mrrceq	0, 0, r0, r5, cr1
    29e8:	10000025 	andne	r0, r0, r5, lsr #32
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    29ec:	02000025 	andeq	r0, r0, #37	; 0x25
		for (j = 0; j <= i; j++)
    29f0:	109f3000 	addsne	r3, pc, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    29f4:	18000025 	stmdane	r0, {r0, r2, r5}
    29f8:	01000025 	tsteq	r0, r5, lsr #32
    29fc:	25185300 	ldrcs	r5, [r8, #-768]	; 0x300

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a00:	251e0000 	ldrcs	r0, [lr, #-0]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a04:	00030000 	andeq	r0, r3, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a08:	1e9f7f73 	mrcne	15, 4, r7, cr15, cr3, {3}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a0c:	24000025 	strcs	r0, [r0], #-37	; 0x25
    2a10:	01000025 	tsteq	r0, r5, lsr #32
    2a14:	00005300 	andeq	r5, r0, r0, lsl #6
    2a18:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2a1c:	24b80000 	ldrtcs	r0, [r8], #0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a20:	24bc0000 	ldrtcs	r0, [ip], #0
    2a24:	00020000 	andeq	r0, r2, r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a28:	24bc9f30 	ldrtcs	r9, [ip], #3888	; 0xf30
			c += ((uint32_t)a[j]) *
    2a2c:	24c60000 	strbcs	r0, [r6], #0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2a30:	00010000 	andeq	r0, r1, r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2a34:	0024c652 	eoreq	ip, r4, r2, asr r6
    2a38:	0024cc00 	eoreq	ip, r4, r0, lsl #24
    2a3c:	72000300 	andvc	r0, r0, #0, 6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a40:	24cc9f7f 	strbcs	r9, [ip], #3967	; 0xf7f
	c = (c >> 7) * 19;
    2a44:	24d20000 	ldrbcs	r0, [r2], #0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a48:	00010000 	andeq	r0, r1, r0
	c = (c >> 7) * 19;
    2a4c:	0024d252 	eoreq	sp, r4, r2, asr r2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a50:	0024e000 	eoreq	lr, r4, r0
	c = (c >> 7) * 19;
    2a54:	72000300 	andvc	r0, r0, #0, 6

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2a58:	24e09f01 	strbtcs	r9, [r0], #3841	; 0xf01
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a5c:	24e80000 	strbtcs	r0, [r8], #0
		c += r[i];
		r[i] = c;
    2a60:	00080000 	andeq	r0, r8, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a64:	00910072 	addseq	r0, r1, r2, ror r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    2a68:	9f41231c 	svcls	0x0041231c
	/* 1 1 */
	f25519_mul__distinct(r, x, x);
	f25519_mul__distinct(s, r, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    2a6c:	000024e8 	andeq	r2, r0, r8, ror #9
    2a70:	000024f2 	strdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    2a74:	00720008 	rsbseq	r0, r2, r8
    2a78:	231c0091 	tstcs	ip, #145	; 0x91
    2a7c:	24f29f40 	ldrbtcs	r9, [r2], #3904	; 0xf40
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2a80:	24f40000 	ldrbtcs	r0, [r4], #0
		for (j = 0; j <= i; j++)
    2a84:	00080000 	andeq	r0, r8, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a88:	00910072 	addseq	r0, r1, r2, ror r0
    2a8c:	9f41231c 	svcls	0x0041231c
	...

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a98:	00002528 	andeq	r2, r0, r8, lsr #10
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a9c:	00002578 	andeq	r2, r0, r8, ror r5
    2aa0:	84530001 	ldrbhi	r0, [r3], #-1
    2aa4:	aa000025 	bge	2b40 <f25519_sqrt+0x338>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2aa8:	01000025 	tsteq	r0, r5, lsr #32
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2aac:	00005200 	andeq	r5, r0, r0, lsl #4
    2ab0:	00000000 	andeq	r0, r0, r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ab4:	25280000 	strcs	r0, [r8, #-0]!
			c += ((uint32_t)a[j]) *
    2ab8:	25840000 	strcs	r0, [r4]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2abc:	00010000 	andeq	r0, r1, r0
    2ac0:	00258456 	eoreq	r8, r5, r6, asr r4
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2ac4:	00258a00 	eoreq	r8, r5, r0, lsl #20
    2ac8:	30000200 	andcc	r0, r0, r0, lsl #4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2acc:	00258a9f 	mlaeq	r5, pc, sl, r8	; <UNPREDICTABLE>
	c = (c >> 7) * 19;
    2ad0:	00259200 	eoreq	r9, r5, r0, lsl #4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2ad4:	73000800 	movwvc	r0, #2048	; 0x800
	c = (c >> 7) * 19;
    2ad8:	1c009100 	stfned	f1, [r0], {-0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2adc:	929f4023 	addsls	r4, pc, #35	; 0x23
	c = (c >> 7) * 19;
    2ae0:	98000025 	stmdals	r0, {r0, r2, r5}

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2ae4:	08000025 	stmdaeq	r0, {r0, r2, r5}
		r[i] = c;
    2ae8:	91007300 	mrsls	r7, LR_irq
		c >>= 8;
    2aec:	3f231c00 	svccc	0x00231c00
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2af0:	0025989f 	mlaeq	r5, pc, r8, r9	; <UNPREDICTABLE>
    2af4:	0025a600 	eoreq	sl, r5, r0, lsl #12
    2af8:	73000800 	movwvc	r0, #2048	; 0x800
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2afc:	1c009100 	stfned	f1, [r0], {-0}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2b00:	009f4023 	addseq	r4, pc, r3, lsr #32
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b04:	00000000 	andeq	r0, r0, r0
    2b08:	2a000000 	bcs	2b10 <f25519_sqrt+0x308>
    2b0c:	2e000025 	cdpcs	0, 0, cr0, cr0, cr5, {1}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b10:	02000025 	andeq	r0, r0, #37	; 0x25
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b14:	2e9f3000 	cdpcs	0, 9, cr3, cr15, cr0, {0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b18:	38000025 	stmdacc	r0, {r0, r2, r5}
    2b1c:	01000025 	tsteq	r0, r5, lsr #32
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b20:	25385200 	ldrcs	r5, [r8, #-512]!	; 0x200
    2b24:	253e0000 	ldrcs	r0, [lr, #-0]!
    2b28:	00030000 	andeq	r0, r3, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2b2c:	3e9f7f72 	mrccc	15, 4, r7, cr15, cr2, {3}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b30:	60000025 	andvs	r0, r0, r5, lsr #32
    2b34:	01000025 	tsteq	r0, r5, lsr #32
    2b38:	25605200 	strbcs	r5, [r0, #-512]!	; 0x200

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b3c:	25660000 	strbcs	r0, [r6, #-0]!
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2b40:	00030000 	andeq	r0, r3, r0
    2b44:	669f7f72 			; <UNDEFINED> instruction: 0x669f7f72
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b48:	7c000025 	stcvc	0, cr0, [r0], {37}	; 0x25
	c = (c >> 7) * 19;
    2b4c:	01000025 	tsteq	r0, r5, lsr #32
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b50:	00005200 	andeq	r5, r0, r0, lsl #4
	c = (c >> 7) * 19;
    2b54:	00000000 	andeq	r0, r0, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b58:	25aa0000 	strcs	r0, [sl, #0]!
	c = (c >> 7) * 19;
    2b5c:	25f60000 	ldrbcs	r0, [r6, #0]!

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2b60:	00010000 	andeq	r0, r1, r0
		r[i] = c;
    2b64:	00260253 	eoreq	r0, r6, r3, asr r2
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b68:	00261e00 	eoreq	r1, r6, r0, lsl #28
		c += r[i];
		r[i] = c;
		c >>= 8;
    2b6c:	52000100 	andpl	r0, r0, #0, 2
	...
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b78:	000025aa 	andeq	r2, r0, sl, lsr #11
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2b7c:	00002602 	andeq	r2, r0, r2, lsl #12
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b80:	02550001 	subseq	r0, r5, #1
    2b84:	06000026 	streq	r0, [r0], -r6, lsr #32

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b88:	02000026 	andeq	r0, r0, #38	; 0x26
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b8c:	069f3000 	ldreq	r3, [pc], r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b90:	0e000026 	cdpeq	0, 0, cr0, cr0, cr6, {1}
    2b94:	01000026 	tsteq	r0, r6, lsr #32
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b98:	260e5300 	strcs	r5, [lr], -r0, lsl #6
    2b9c:	26140000 	ldrcs	r0, [r4], -r0
    2ba0:	00030000 	andeq	r0, r3, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2ba4:	149f7f73 	ldrne	r7, [pc], #3955	; 2bac <f25519_sqrt+0x3a4>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ba8:	1a000026 	bne	2c48 <f25519_sqrt+0x440>
    2bac:	01000026 	tsteq	r0, r6, lsr #32
    2bb0:	00005300 	andeq	r5, r0, r0, lsl #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2bb4:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2bb8:	25ae0000 	strcs	r0, [lr, #0]!
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2bbc:	25b20000 	ldrcs	r0, [r2, #0]!
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bc0:	00020000 	andeq	r0, r2, r0
	c = (c >> 7) * 19;
    2bc4:	25b29f30 	ldrcs	r9, [r2, #3888]!	; 0xf30
    2bc8:	25bc0000 	ldrcs	r0, [ip, #0]!
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bcc:	00010000 	andeq	r0, r1, r0
	c = (c >> 7) * 19;
    2bd0:	0025bc52 	eoreq	fp, r5, r2, asr ip
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bd4:	0025c200 	eoreq	ip, r5, r0, lsl #4
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2bd8:	72000300 	andvc	r0, r0, #0, 6
		r[i] = c;
    2bdc:	25c29f7f 	strbcs	r9, [r2, #3967]	; 0xf7f
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2be0:	25c80000 	strbcs	r0, [r8]
		c += r[i];
		r[i] = c;
		c >>= 8;
    2be4:	00010000 	andeq	r0, r1, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2be8:	0025c852 	eoreq	ip, r5, r2, asr r8
    2bec:	0025d600 	eoreq	sp, r5, r0, lsl #12
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2bf0:	72000300 	andvc	r0, r0, #0, 6
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2bf4:	25d69f01 	ldrbcs	r9, [r6, #3841]	; 0xf01
		for (j = 0; j <= i; j++)
    2bf8:	25de0000 	ldrbcs	r0, [lr]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2bfc:	00080000 	andeq	r0, r8, r0
    2c00:	00910072 	addseq	r0, r1, r2, ror r0
    2c04:	9f41231c 	svcls	0x0041231c

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c08:	000025de 	ldrdeq	r2, [r0], -lr
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c0c:	000025e8 	andeq	r2, r0, r8, ror #11

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c10:	00720008 	rsbseq	r0, r2, r8
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c14:	231c0091 	tstcs	ip, #145	; 0x91
    2c18:	25e89f40 	strbcs	r9, [r8, #3904]!	; 0xf40
    2c1c:	25ea0000 	strbcs	r0, [sl, #0]!
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2c20:	00080000 	andeq	r0, r8, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c24:	00910072 	addseq	r0, r1, r2, ror r0
    2c28:	9f41231c 	svcls	0x0041231c
	...
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2c34:	0000261e 	andeq	r2, r0, lr, lsl r6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2c38:	0000266e 	andeq	r2, r0, lr, ror #12
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c3c:	7a530001 	bvc	14c2c48 <_etext+0x14bb730>
	c = (c >> 7) * 19;
    2c40:	a0000026 	andge	r0, r0, r6, lsr #32
    2c44:	01000026 	tsteq	r0, r6, lsr #32
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c48:	00005200 	andeq	r5, r0, r0, lsl #4
    2c4c:	00000000 	andeq	r0, r0, r0
	c = (c >> 7) * 19;
    2c50:	261e0000 	ldrcs	r0, [lr], -r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c54:	267a0000 	ldrbtcs	r0, [sl], -r0
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2c58:	00010000 	andeq	r0, r1, r0
		r[i] = c;
    2c5c:	00267a56 	eoreq	r7, r6, r6, asr sl
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c60:	00268000 	eoreq	r8, r6, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    2c64:	30000200 	andcc	r0, r0, r0, lsl #4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c68:	0026809f 	mlaeq	r6, pc, r0, r8	; <UNPREDICTABLE>
    2c6c:	00268800 	eoreq	r8, r6, r0, lsl #16
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c70:	73000800 	movwvc	r0, #2048	; 0x800
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2c74:	1c009100 	stfned	f1, [r0], {-0}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c78:	889f4023 	ldmhi	pc, {r0, r1, r5, lr}	; <UNPREDICTABLE>
    2c7c:	8e000026 	cdphi	0, 0, cr0, cr0, cr6, {1}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c80:	08000026 	stmdaeq	r0, {r1, r2, r5}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c84:	91007300 	mrsls	r7, LR_irq

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c88:	3f231c00 	svccc	0x00231c00
    2c8c:	00268e9f 	mlaeq	r6, pc, lr, r8	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c90:	00269c00 	eoreq	r9, r6, r0, lsl #24
    2c94:	73000800 	movwvc	r0, #2048	; 0x800
    2c98:	1c009100 	stfned	f1, [r0], {-0}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2c9c:	009f4023 	addseq	r4, pc, r3, lsr #32
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ca0:	00000000 	andeq	r0, r0, r0
    2ca4:	20000000 	andcs	r0, r0, r0
    2ca8:	24000026 	strcs	r0, [r0], #-38	; 0x26

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cac:	02000026 	andeq	r0, r0, #38	; 0x26
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2cb0:	249f3000 	ldrcs	r3, [pc], #0	; 2cb8 <f25519_sqrt+0x4b0>
    2cb4:	2e000026 	cdpcs	0, 0, cr0, cr0, cr6, {1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cb8:	01000026 	tsteq	r0, r6, lsr #32
	c = (c >> 7) * 19;
    2cbc:	262e5200 	strtcs	r5, [lr], -r0, lsl #4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cc0:	26340000 	ldrtcs	r0, [r4], -r0
	c = (c >> 7) * 19;
    2cc4:	00030000 	andeq	r0, r3, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cc8:	349f7f72 	ldrcc	r7, [pc], #3954	; 2cd0 <f25519_sqrt+0x4c8>
	c = (c >> 7) * 19;
    2ccc:	56000026 	strpl	r0, [r0], -r6, lsr #32

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2cd0:	01000026 	tsteq	r0, r6, lsr #32
		r[i] = c;
    2cd4:	26565200 	ldrbcs	r5, [r6], -r0, lsl #4
		c >>= 8;
    2cd8:	265c0000 	ldrbcs	r0, [ip], -r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2cdc:	00030000 	andeq	r0, r3, r0
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    2ce0:	5c9f7f72 	ldcpl	15, cr7, [pc], {114}	; 0x72
    2ce4:	72000026 	andvc	r0, r0, #38	; 0x26
    2ce8:	01000026 	tsteq	r0, r6, lsr #32
    2cec:	00005200 	andeq	r5, r0, r0, lsl #4
    2cf0:	00000000 	andeq	r0, r0, r0
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2cf4:	26a00000 	strtcs	r0, [r0], r0
    2cf8:	26ea0000 	strbtcs	r0, [sl], r0
    2cfc:	00010000 	andeq	r0, r1, r0
		r[i] = c;
    2d00:	0026f653 	eoreq	pc, r6, r3, asr r6	; <UNPREDICTABLE>
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2d04:	00271200 	eoreq	r1, r7, r0, lsl #4
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2d08:	52000100 	andpl	r0, r0, #0, 2
	...
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2d14:	000026a0 	andeq	r2, r0, r0, lsr #13
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2d18:	000026f6 	strdeq	r2, [r0], -r6
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2d1c:	f6550001 			; <UNDEFINED> instruction: 0xf6550001
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2d20:	fa000026 	blx	2dc0 <f25519_sqrt+0x5b8>
    2d24:	02000026 	andeq	r0, r0, #38	; 0x26
	c = (c >> 7) * 19;
    2d28:	fa9f3000 	blx	fe7ced30 <BootRAM+0xd73f4d1>

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2d2c:	02000026 	andeq	r0, r0, #38	; 0x26
		r[i] = c;
    2d30:	01000027 	tsteq	r0, r7, lsr #32

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d34:	27025300 	strcs	r5, [r2, -r0, lsl #6]
		c += r[i];
		r[i] = c;
		c >>= 8;
    2d38:	27080000 	strcs	r0, [r8, -r0]

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d3c:	00030000 	andeq	r0, r3, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d40:	089f7f73 	ldmeq	pc, {r0, r1, r4, r5, r6, r8, r9, sl, fp, ip, sp, lr}	; <UNPREDICTABLE>

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d44:	0e000027 	cdpeq	0, 0, cr0, cr0, cr7, {1}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d48:	01000027 	tsteq	r0, r7, lsr #32
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2d4c:	00005300 	andeq	r5, r0, r0, lsl #6
		for (j = 0; j <= i; j++)
    2d50:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d54:	26a20000 	strtcs	r0, [r2], r0
    2d58:	26a60000 	strtcs	r0, [r6], r0
    2d5c:	00020000 	andeq	r0, r2, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d60:	26a69f30 	ssat16cs	r9, #7, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d64:	26b00000 	ldrtcs	r0, [r0], r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d68:	00010000 	andeq	r0, r1, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d6c:	0026b052 	eoreq	fp, r6, r2, asr r0
    2d70:	0026b600 	eoreq	fp, r6, r0, lsl #12
    2d74:	72000300 	andvc	r0, r0, #0, 6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2d78:	26b69f7f 			; <UNDEFINED> instruction: 0x26b69f7f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d7c:	26bc0000 	ldrtcs	r0, [ip], r0
    2d80:	00010000 	andeq	r0, r1, r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d84:	0026bc52 	eoreq	fp, r6, r2, asr ip
			c += ((uint32_t)a[j]) *
    2d88:	0026ca00 	eoreq	ip, r6, r0, lsl #20
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2d8c:	72000300 	andvc	r0, r0, #0, 6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2d90:	26ca9f01 	strbcs	r9, [sl], r1, lsl #30
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d94:	26d20000 	ldrbcs	r0, [r2], r0
	c = (c >> 7) * 19;
    2d98:	00080000 	andeq	r0, r8, r0
    2d9c:	00910072 	addseq	r0, r1, r2, ror r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2da0:	9f41231c 	svcls	0x0041231c
	c = (c >> 7) * 19;
    2da4:	000026d2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2da8:	000026dc 	ldrdeq	r2, [r0], -ip
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2dac:	00720008 	rsbseq	r0, r2, r8
		r[i] = c;
    2db0:	231c0091 	tstcs	ip, #145	; 0x91
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2db4:	26dc9f40 	ldrbcs	r9, [ip], r0, asr #30
		c += r[i];
		r[i] = c;
		c >>= 8;
    2db8:	26de0000 	ldrbcs	r0, [lr], r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2dbc:	00080000 	andeq	r0, r8, r0
    2dc0:	00910072 	addseq	r0, r1, r2, ror r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2dc4:	9f41231c 	svcls	0x0041231c
	...
	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2dd0:	00002712 	andeq	r2, r0, r2, lsl r7

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2dd4:	00002762 	andeq	r2, r0, r2, ror #14
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2dd8:	6e530001 	cdpvs	0, 5, cr0, cr3, cr1, {0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2ddc:	8a000027 	bhi	2e80 <fprime_from_bytes+0x44>
    2de0:	01000027 	tsteq	r0, r7, lsr #32
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2de4:	00005200 	andeq	r5, r0, r0, lsl #4
    2de8:	00000000 	andeq	r0, r0, r0
    2dec:	27120000 	ldrcs	r0, [r2, -r0]
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2df0:	276e0000 	strbcs	r0, [lr, -r0]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2df4:	00010000 	andeq	r0, r1, r0
    2df8:	00276e56 	eoreq	r6, r7, r6, asr lr
    2dfc:	00277400 	eoreq	r7, r7, r0, lsl #8

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e00:	30000200 	andcc	r0, r0, r0, lsl #4
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2e04:	0027749f 	mlaeq	r7, pc, r4, r7	; <UNPREDICTABLE>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2e08:	00277c00 	eoreq	r7, r7, r0, lsl #24

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2e0c:	73000800 	movwvc	r0, #2048	; 0x800
    2e10:	1c009100 	stfned	f1, [r0], {-0}
    2e14:	7c9f4023 	ldcvc	0, cr4, [pc], {35}	; 0x23
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e18:	82000027 	andhi	r0, r0, #39	; 0x27
    2e1c:	08000027 	stmdaeq	r0, {r0, r1, r2, r5}
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e20:	91007300 	mrsls	r7, LR_irq
		c += r[i];
    2e24:	3f231c00 	svccc	0x00231c00
		r[i] = c;
    2e28:	0027829f 	mlaeq	r7, pc, r2, r8	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e2c:	00278c00 	eoreq	r8, r7, r0, lsl #24
		c += r[i];
		r[i] = c;
		c >>= 8;
    2e30:	73000800 	movwvc	r0, #2048	; 0x800
	f25519_sub(i, i, y);

	/* r = avi */
	f25519_mul__distinct(x, v, a);
	f25519_mul__distinct(r, x, i);
}
    2e34:	1c009100 	stfned	f1, [r0], {-0}
    2e38:	009f4023 	addseq	r4, pc, r3, lsr #32
}

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
    2e3c:	00000000 	andeq	r0, r0, r0
    2e40:	14000000 	strne	r0, [r0], #-0
    2e44:	18000027 	stmdane	r0, {r0, r1, r2, r5}
    2e48:	02000027 	andeq	r0, r0, #39	; 0x27
static int prime_msb(const uint8_t *p)
{
	int i;
	uint8_t x;

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
    2e4c:	189f3000 	ldmne	pc, {ip, sp}	; <UNPREDICTABLE>
    2e50:	22000027 	andcs	r0, r0, #39	; 0x27
    2e54:	01000027 	tsteq	r0, r7, lsr #32
		if (p[i])
    2e58:	27225200 	strcs	r5, [r2, -r0, lsl #4]!
			break;

	x = p[i];
	i <<= 3;
    2e5c:	27280000 	strcs	r0, [r8, -r0]!

	while (x) {
		x >>= 1;
		i++;
    2e60:	00030000 	andeq	r0, r3, r0
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    2e64:	289f7f72 	ldmcs	pc, {r1, r4, r5, r6, r8, r9, sl, fp, ip, sp, lr}	; <UNPREDICTABLE>

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
    2e68:	4a000027 	bmi	2f0c <fprime_from_bytes+0xd0>
		x[i] = 0;
}

static inline int min_int(int a, int b)
{
	return a < b ? a : b;
    2e6c:	01000027 	tsteq	r0, r7, lsr #32
    2e70:	274a5200 	strbcs	r5, [sl, -r0, lsl #4]
void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
    2e74:	27500000 	ldrbcs	r0, [r0, -r0]
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);
    2e78:	00030000 	andeq	r0, r3, r0
    2e7c:	509f7f72 	addspl	r7, pc, r2, ror pc	; <UNPREDICTABLE>
    2e80:	66000027 	strvs	r0, [r0], -r7, lsr #32

	for (i = 0; i < preload_bytes; i++)
    2e84:	01000027 	tsteq	r0, r7, lsr #32
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
    2e88:	00005200 	andeq	r5, r0, r0, lsl #4
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
    2e8c:	00000000 	andeq	r0, r0, r0
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2e90:	27940000 	ldrcs	r0, [r4, r0]
    2e94:	27de0000 	ldrbcs	r0, [lr, r0]
    2e98:	00010000 	andeq	r0, r1, r0
    2e9c:	0027ea53 	eoreq	lr, r7, r3, asr sl
    2ea0:	00280600 	eoreq	r0, r8, r0, lsl #12
    2ea4:	52000100 	andpl	r0, r0, #0, 2
	...
    2eb0:	00002794 	muleq	r0, r4, r7
    2eb4:	000027ea 	andeq	r2, r0, sl, ror #15
    2eb8:	ea550001 	b	1542ec4 <_etext+0x153b9ac>
    2ebc:	ee000027 	cdp	0, 0, cr0, cr0, cr7, {1}
    2ec0:	02000027 	andeq	r0, r0, #39	; 0x27
    2ec4:	ee9f3000 	cdp	0, 9, cr3, cr15, cr0, {0}
    2ec8:	f6000027 			; <UNDEFINED> instruction: 0xf6000027
    2ecc:	01000027 	tsteq	r0, r7, lsr #32
    2ed0:	27f65300 	ldrbcs	r5, [r6, r0, lsl #6]!
		n[i] = x[len - preload_bytes + i];
    2ed4:	27fc0000 	ldrbcs	r0, [ip, r0]!
    2ed8:	00030000 	andeq	r0, r3, r0
    2edc:	fc9f7f73 	ldc2	15, cr7, [pc], {115}	; 0x73
    2ee0:	06000027 	streq	r0, [r0], -r7, lsr #32
    2ee4:	01000028 	tsteq	r0, r8, lsr #32
    2ee8:	00005300 	andeq	r5, r0, r0, lsl #6
    2eec:	00000000 	andeq	r0, r0, r0
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2ef0:	27960000 	ldrcs	r0, [r6, r0]
		n[i] = x[len - preload_bytes + i];
    2ef4:	279a0000 	ldrcs	r0, [sl, r0]
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2ef8:	00020000 	andeq	r0, r2, r0
		n[i] = x[len - preload_bytes + i];
    2efc:	279a9f30 			; <UNDEFINED> instruction: 0x279a9f30
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f00:	27a40000 	strcs	r0, [r4, r0]!
    2f04:	00010000 	andeq	r0, r1, r0
    2f08:	0027a452 	eoreq	sl, r7, r2, asr r4
		n[i] = x[len - preload_bytes + i];
    2f0c:	0027aa00 	eoreq	sl, r7, r0, lsl #20
    2f10:	72000300 	andvc	r0, r0, #0, 6
    2f14:	27aa9f7f 			; <UNDEFINED> instruction: 0x27aa9f7f

	if (preload_bits) {
    2f18:	27b00000 	ldrcs	r0, [r0, r0]!
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c |= ((uint16_t)x[i]) << n;
    2f1c:	00010000 	andeq	r0, r1, r0
    2f20:	0027b052 	eoreq	fp, r7, r2, asr r0
		x[i] = c;
    2f24:	0027be00 	eoreq	fp, r7, r0, lsl #28
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f28:	72000300 	andvc	r0, r0, #0, 6
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    2f2c:	27be9f01 	ldrcs	r9, [lr, r1, lsl #30]!
	for (i = 0; i < preload_bytes; i++)
		n[i] = x[len - preload_bytes + i];

	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
    2f30:	27c60000 	strbcs	r0, [r6, r0]
    2f34:	00080000 	andeq	r0, r8, r0
    2f38:	00910072 	addseq	r0, r1, r2, ror r0
    2f3c:	9f41231c 	svcls	0x0041231c
    2f40:	000027c6 	andeq	r2, r0, r6, asr #15
    2f44:	000027d0 	ldrdeq	r2, [r0], -r0
	}

	for (i = rbits - 1; i >= 0; i--) {
    2f48:	00720008 	rsbseq	r0, r2, r8
    2f4c:	231c0091 	tstcs	ip, #145	; 0x91
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;
    2f50:	27d09f40 	ldrbcs	r9, [r0, r0, asr #30]
    2f54:	27d20000 	ldrbcs	r0, [r2, r0]
    2f58:	00080000 	andeq	r0, r8, r0
    2f5c:	00910072 	addseq	r0, r1, r2, ror r0
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f60:	9f41231c 	svcls	0x0041231c
	...

	for (i = rbits - 1; i >= 0; i--) {
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;

		shift_n_bits(n, 1);
		n[0] |= bit;
    2f74:	00500001 	subseq	r0, r0, r1
    2f78:	00000000 	andeq	r0, r0, r0
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f7c:	01000000 	mrseq	r0, (UNDEF: 0)
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
    2f80:	00005500 	andeq	r5, r0, r0, lsl #10
	...
		minusp[i] = c;
		c = (c >> 8) & 1;
    2f90:	00010000 	andeq	r0, r1, r0
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2f94:	00000051 	andeq	r0, r0, r1, asr r0

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    2f98:	00000000 	andeq	r0, r0, r0
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    2f9c:	f3000400 	vshl.u8	d0, d0, d0
    2fa0:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
	}

	for (i = rbits - 1; i >= 0; i--) {
    2fb0:	01000000 	mrseq	r0, (UNDEF: 0)
    2fb4:	00005d00 	andeq	r5, r0, r0, lsl #26

		shift_n_bits(n, 1);
		n[0] |= bit;
		raw_try_sub(n, modulus);
	}
}
    2fb8:	00000000 	andeq	r0, r0, r0

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
    2fbc:	00030000 	andeq	r0, r3, r0
	i <<= 3;

	while (x) {
    2fc0:	009f6074 	addseq	r6, pc, r4, ror r0	; <UNPREDICTABLE>
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
    2fc4:	00000000 	andeq	r0, r0, r0
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fc8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
		n[i] = x[len - preload_bytes + i];
    2fcc:	1a000028 	bne	3074 <sha256_process+0x40>
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fd0:	01000028 	tsteq	r0, r8, lsr #32
    2fd4:	281a5000 	ldmdacs	sl, {ip, lr}
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    2fd8:	2e3a0000 	cdpcs	0, 3, cr0, cr10, cr0, {0}
    (b)[(i) + 2] = (uint8) ( (n) >>  8 );       \
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    2fdc:	00030000 	andeq	r0, r3, r0
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    2fe0:	3a7ed891 	bcc	1fb922c <_etext+0x1fb1d14>
void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    2fe4:	3c00002e 	stccc	0, cr0, [r0], {46}	; 0x2e
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    2fe8:	0300002e 	movweq	r0, #46	; 0x2e
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    2fec:	7ed87d00 	cdpvc	13, 13, cr7, cr8, cr0, {0}
	...
void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    2ff8:	00002808 	andeq	r2, r0, r8, lsl #16
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    2ffc:	0000281a 	andeq	r2, r0, sl, lsl r8
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    3000:	1a510001 	bne	144300c <_etext+0x143baf4>
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    3004:	42000028 	andmi	r0, r0, #40	; 0x28
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
    3008:	01000028 	tsteq	r0, r8, lsr #32
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;
    300c:	28425000 	stmdacs	r2, {ip, lr}^
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
}
    3010:	2e3a0000 	cdpcs	0, 3, cr0, cr10, cr0, {0}
    3014:	00030000 	andeq	r0, r3, r0
    3018:	3a7edc91 	bcc	1fba264 <_etext+0x1fb2d4c>
    301c:	3c00002e 	stccc	0, cr0, [r0], {46}	; 0x2e
    3020:	0300002e 	movweq	r0, #46	; 0x2e
    3024:	7edc7d00 	cdpvc	13, 13, cr7, cr12, cr0, {0}
	...
    3030:	00002814 	andeq	r2, r0, r4, lsl r8

void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    3034:	0000281a 	andeq	r2, r0, sl, lsl r8
    3038:	1a510001 	bne	1443044 <_etext+0x143bb2c>
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    303c:	42000028 	andmi	r0, r0, #40	; 0x28
    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    3040:	01000028 	tsteq	r0, r8, lsr #32
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3044:	28425000 	stmdacs	r2, {ip, lr}^
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    3048:	2e3a0000 	cdpcs	0, 3, cr0, cr10, cr0, {0}
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    304c:	00030000 	andeq	r0, r3, r0
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    3050:	3a7edc91 	bcc	1fba29c <_etext+0x1fb2d84>
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3054:	3c00002e 	stccc	0, cr0, [r0], {46}	; 0x2e
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    3058:	0300002e 	movweq	r0, #46	; 0x2e
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    305c:	7edc7d00 	cdpvc	13, 13, cr7, cr12, cr0, {0}
	...
    B = ctx->state[1];
    C = ctx->state[2];
    3068:	00002810 	andeq	r2, r0, r0, lsl r8
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    306c:	00002818 	andeq	r2, r0, r8, lsl r8
    3070:	a0910004 	addsge	r0, r1, r4
    3074:	28189f7f 	ldmdacs	r8, {r0, r1, r2, r3, r4, r5, r6, r8, r9, sl, fp, ip, pc}
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3078:	2e3a0000 	cdpcs	0, 3, cr0, cr10, cr0, {0}
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    307c:	00010000 	andeq	r0, r1, r0
    3080:	002e3a56 	eoreq	r3, lr, r6, asr sl
    3084:	002e3c00 	eoreq	r3, lr, r0, lsl #24
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3088:	7d000400 	cfstrsvc	mvf0, [r0, #-0]
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    308c:	009f7fa0 	addseq	r7, pc, r0, lsr #31
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3090:	00000000 	andeq	r0, r0, r0
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3094:	14000000 	strne	r0, [r0], #-0
    3098:	1a000028 	bne	3140 <sha256_process+0x10c>
    309c:	02000028 	andeq	r0, r0, #40	; 0x28
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    30a0:	1a9f3000 	bne	fe7cf0a8 <BootRAM+0xd73f849>
    30a4:	22000028 	andcs	r0, r0, #40	; 0x28
    30a8:	05000028 	streq	r0, [r0, #-40]	; 0x28
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30ac:	38007200 	stmdacc	r0, {r9, ip, sp, lr}
    30b0:	28229f25 	stmdacs	r2!, {r0, r2, r5, r8, r9, sl, fp, ip, pc}
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    30b4:	285e0000 	ldmdacs	lr, {}^	; <UNPREDICTABLE>
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30b8:	00010000 	andeq	r0, r1, r0
    30bc:	00000052 	andeq	r0, r0, r2, asr r0
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30c0:	00000000 	andeq	r0, r0, r0
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30c4:	00281400 	eoreq	r1, r8, r0, lsl #8
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30c8:	00281a00 	eoreq	r1, r8, r0, lsl #20
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    30cc:	30000200 	andcc	r0, r0, r0, lsl #4
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30d0:	00281a9f 	mlaeq	r8, pc, sl, r1	; <UNPREDICTABLE>
    30d4:	00282e00 	eoreq	r2, r8, r0, lsl #28
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30d8:	53000100 	movwpl	r0, #256	; 0x100
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30dc:	00002840 	andeq	r2, r0, r0, asr #16
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30e0:	00002844 	andeq	r2, r0, r4, asr #16
    30e4:	9f300002 	svcls	0x00300002
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30e8:	00002844 	andeq	r2, r0, r4, asr #16
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30ec:	0000284c 	andeq	r2, r0, ip, asr #16
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30f0:	00730008 	rsbseq	r0, r3, r8
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    30f4:	231c0091 	tstcs	ip, #145	; 0x91
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    30f8:	284c9f60 	stmdacs	ip, {r5, r6, r8, r9, sl, fp, ip, pc}^
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30fc:	28520000 	ldmdacs	r2, {}^	; <UNPREDICTABLE>
    3100:	00080000 	andeq	r0, r8, r0
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    3104:	00910073 	addseq	r0, r1, r3, ror r0
    3108:	9f5f231c 	svcls	0x005f231c
    310c:	00002852 	andeq	r2, r0, r2, asr r8
    3110:	00002858 	andeq	r2, r0, r8, asr r8
    3114:	00730008 	rsbseq	r0, r3, r8
    3118:	231c0091 	tstcs	ip, #145	; 0x91
    311c:	00009f60 	andeq	r9, r0, r0, ror #30
    3120:	00000000 	andeq	r0, r0, r0
    3124:	285e0000 	ldmdacs	lr, {}^	; <UNPREDICTABLE>
    3128:	28aa0000 	stmiacs	sl!, {}	; <UNPREDICTABLE>
    312c:	00010000 	andeq	r0, r1, r0
    3130:	0028b653 	eoreq	fp, r8, r3, asr r6
    3134:	0028d800 	eoreq	sp, r8, r0, lsl #16
    3138:	52000100 	andpl	r0, r0, #0, 2
	...
    3144:	0000285e 	andeq	r2, r0, lr, asr r8
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3148:	000028b6 			; <UNDEFINED> instruction: 0x000028b6
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    314c:	b6540001 	ldrblt	r0, [r4], -r1
    3150:	be000028 	cdplt	0, 0, cr0, cr0, cr8, {1}
    3154:	02000028 	andeq	r0, r0, #40	; 0x28
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3158:	be9f3000 	cdplt	0, 9, cr3, cr15, cr0, {0}
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    315c:	c6000028 	strgt	r0, [r0], -r8, lsr #32
    3160:	09000028 	stmdbeq	r0, {r3, r5}
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3164:	91007300 	mrsls	r7, LR_irq
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3168:	a0231c00 	eorge	r1, r3, r0, lsl #24
    316c:	28c69f01 	stmiacs	r6, {r0, r8, r9, sl, fp, ip, pc}^
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3170:	28cc0000 	stmiacs	ip, {}^	; <UNPREDICTABLE>
    3174:	00090000 	andeq	r0, r9, r0
    3178:	00910073 	addseq	r0, r1, r3, ror r0
    317c:	019f231c 	orrseq	r2, pc, ip, lsl r3	; <UNPREDICTABLE>
    3180:	0028cc9f 	mlaeq	r8, pc, ip, ip	; <UNPREDICTABLE>
    3184:	0028d200 	eoreq	sp, r8, r0, lsl #4
    3188:	73000900 	movwvc	r0, #2304	; 0x900
    318c:	1c009100 	stfned	f1, [r0], {-0}
    3190:	9f01a023 	svcls	0x0001a023
	...
    319c:	00002860 	andeq	r2, r0, r0, ror #16
    31a0:	00002864 	andeq	r2, r0, r4, ror #16
    31a4:	9f300002 	svcls	0x00300002
    31a8:	00002864 	andeq	r2, r0, r4, ror #16
    31ac:	0000286e 	andeq	r2, r0, lr, ror #16
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31b0:	6e520001 	cdpvs	0, 5, cr0, cr2, cr1, {0}
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31b4:	74000028 	strvc	r0, [r0], #-40	; 0x28
    31b8:	03000028 	movweq	r0, #40	; 0x28
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31bc:	9f7f7200 	svcls	0x007f7200
    31c0:	00002874 	andeq	r2, r0, r4, ror r8
    31c4:	0000287a 	andeq	r2, r0, sl, ror r8
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31c8:	7a520001 	bvc	14831d4 <_etext+0x147bcbc>
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31cc:	86000028 	strhi	r0, [r0], -r8, lsr #32
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    31d0:	03000028 	movweq	r0, #40	; 0x28

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31d4:	9f017200 	svcls	0x00017200
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    31d8:	00002886 	andeq	r2, r0, r6, lsl #17
    GET_UINT32( W[4],  data, 16 );
    31dc:	0000288e 	andeq	r2, r0, lr, lsl #17
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31e0:	00720008 	rsbseq	r0, r2, r8
    31e4:	231c0091 	tstcs	ip, #145	; 0x91
    31e8:	288e9f61 	stmcs	lr, {r0, r5, r6, r8, r9, sl, fp, ip, pc}
    31ec:	28980000 	ldmcs	r8, {}	; <UNPREDICTABLE>

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31f0:	00080000 	andeq	r0, r8, r0
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31f4:	00910072 	addseq	r0, r1, r2, ror r0

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    31f8:	9f60231c 	svcls	0x0060231c
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    31fc:	00002898 	muleq	r0, r8, r8
    3200:	0000289a 	muleq	r0, sl, r8
    3204:	00720008 	rsbseq	r0, r2, r8
    3208:	231c0091 	tstcs	ip, #145	; 0x91
    320c:	00009f61 	andeq	r9, r0, r1, ror #30
    3210:	00000000 	andeq	r0, r0, r0

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3214:	28d80000 	ldmcs	r8, {}^	; <UNPREDICTABLE>
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3218:	29260000 	stmdbcs	r6!, {}	; <UNPREDICTABLE>
    321c:	00010000 	andeq	r0, r1, r0
    3220:	00293653 	eoreq	r3, r9, r3, asr r6
    3224:	00296000 	eoreq	r6, r9, r0

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3228:	52000100 	andpl	r0, r0, #0, 2
	...
    3234:	000028d8 	ldrdeq	r2, [r0], -r8
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3238:	00002936 	andeq	r2, r0, r6, lsr r9

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    323c:	36540001 	ldrbcc	r0, [r4], -r1
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3240:	42000029 	andmi	r0, r0, #41	; 0x29

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3244:	02000029 	andeq	r0, r0, #41	; 0x29
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3248:	429f3000 	addsmi	r3, pc, #0
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    324c:	4a000029 	bmi	32f8 <sha256_process+0x2c4>
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3250:	08000029 	stmdaeq	r0, {r0, r3, r5}
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3254:	91007300 	mrsls	r7, LR_irq

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3258:	40231c00 	eormi	r1, r3, r0, lsl #24

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    325c:	00294a9f 	mlaeq	r9, pc, sl, r4	; <UNPREDICTABLE>
    3260:	00295000 	eoreq	r5, r9, r0
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3264:	73000800 	movwvc	r0, #2048	; 0x800
    3268:	1c009100 	stfned	f1, [r0], {-0}

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    326c:	509f3f23 	addspl	r3, pc, r3, lsr #30
    3270:	60000029 	andvs	r0, r0, r9, lsr #32
    3274:	08000029 	stmdaeq	r0, {r0, r3, r5}
    3278:	91007300 	mrsls	r7, LR_irq
    327c:	40231c00 	eormi	r1, r3, r0, lsl #24
    3280:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    3284:	00000000 	andeq	r0, r0, r0
    3288:	0028da00 	eoreq	sp, r8, r0, lsl #20
    328c:	0028de00 	eoreq	sp, r8, r0, lsl #28
    3290:	30000200 	andcc	r0, r0, r0, lsl #4
    3294:	0028de9f 	mlaeq	r8, pc, lr, sp	; <UNPREDICTABLE>
    3298:	0028ec00 	eoreq	lr, r8, r0, lsl #24
    329c:	52000100 	andpl	r0, r0, #0, 2
    32a0:	000028ec 	andeq	r2, r0, ip, ror #17
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32a4:	000028f2 	strdeq	r2, [r0], -r2	; <UNPREDICTABLE>

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32a8:	7f720003 	svcvc	0x00720003
    32ac:	0028f29f 	mlaeq	r8, pc, r2, pc	; <UNPREDICTABLE>
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32b0:	0028f800 	eoreq	pc, r8, r0, lsl #16
    32b4:	52000100 	andpl	r0, r0, #0, 2

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32b8:	000028f8 	strdeq	r2, [r0], -r8
    32bc:	00002904 	andeq	r2, r0, r4, lsl #18
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32c0:	01720003 	cmneq	r2, r3
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32c4:	0029049f 	mlaeq	r9, pc, r4, r0	; <UNPREDICTABLE>

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32c8:	00290c00 	eoreq	r0, r9, r0, lsl #24
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32cc:	72000900 	andvc	r0, r0, #0, 18
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32d0:	1c009100 	stfned	f1, [r0], {-0}
    32d4:	9f01a123 	svcls	0x0001a123
    32d8:	0000290c 	andeq	r2, r0, ip, lsl #18
    32dc:	00002916 	andeq	r2, r0, r6, lsl r9
    32e0:	00720009 	rsbseq	r0, r2, r9
    32e4:	231c0091 	tstcs	ip, #145	; 0x91
    32e8:	169f01a0 	ldrne	r0, [pc], r0, lsr #3

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32ec:	18000029 	stmdane	r0, {r0, r3, r5}
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32f0:	09000029 	stmdbeq	r0, {r0, r3, r5}
    32f4:	91007200 	mrsls	r7, R8_usr
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    32f8:	a1231c00 	teqge	r3, r0, lsl #24
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    32fc:	00009f01 	andeq	r9, r0, r1, lsl #30
    3300:	00000000 	andeq	r0, r0, r0
    3304:	29600000 	stmdbcs	r0!, {}^	; <UNPREDICTABLE>
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    3308:	29660000 	stmdbcs	r6!, {}^	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    330c:	00020000 	andeq	r0, r2, r0
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    3310:	29669f30 	stmdbcs	r6!, {r4, r5, r8, r9, sl, fp, ip, pc}^
    3314:	29c00000 	stmibcs	r0, {}^	; <UNPREDICTABLE>
    3318:	00010000 	andeq	r0, r1, r0
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    331c:	0029cc53 	eoreq	ip, r9, r3, asr ip
    3320:	0029ea00 	eoreq	lr, r9, r0, lsl #20
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    3324:	52000100 	andpl	r0, r0, #0, 2
	...
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3330:	00002960 	andeq	r2, r0, r0, ror #18
    3334:	00002966 	andeq	r2, r0, r6, ror #18
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3338:	9f300002 	svcls	0x00300002
    333c:	00002966 	andeq	r2, r0, r6, ror #18
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3340:	000029cc 	andeq	r2, r0, ip, asr #19
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3344:	cc590001 	mrrcgt	0, 0, r0, r9, cr1
    3348:	d2000029 	andle	r0, r0, #41	; 0x29
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    334c:	02000029 	andeq	r0, r0, #41	; 0x29
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3350:	d29f3000 	addsle	r3, pc, #0
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3354:	dc000029 	stcle	0, cr0, [r0], {41}	; 0x29
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3358:	09000029 	stmdbeq	r0, {r0, r3, r5}
    335c:	91007300 	mrsls	r7, LR_irq
    3360:	a0231c00 	eorge	r1, r3, r0, lsl #24
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3364:	29dc9f01 	ldmibcs	ip, {r0, r8, r9, sl, fp, ip, pc}^
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3368:	29e20000 	stmibcs	r2!, {}^	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    336c:	00090000 	andeq	r0, r9, r0
    3370:	00910073 	addseq	r0, r1, r3, ror r0
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3374:	019f231c 	orrseq	r2, pc, ip, lsl r3	; <UNPREDICTABLE>
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3378:	0029e29f 	mlaeq	r9, pc, r2, lr	; <UNPREDICTABLE>
    337c:	0029ea00 	eoreq	lr, r9, r0, lsl #20
    3380:	73000900 	movwvc	r0, #2304	; 0x900
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3384:	1c009100 	stfned	f1, [r0], {-0}
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3388:	9f01a023 	svcls	0x0001a023
	...
    3394:	00002968 	andeq	r2, r0, r8, ror #18
    3398:	0000296e 	andeq	r2, r0, lr, ror #18
    339c:	9f300002 	svcls	0x00300002
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    33a0:	0000296e 	andeq	r2, r0, lr, ror #18
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33a4:	00002978 	andeq	r2, r0, r8, ror r9
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    33a8:	78520001 	ldmdavc	r2, {r0}^
    33ac:	7e000029 	cdpvc	0, 0, cr0, cr0, cr9, {1}
    33b0:	03000029 	movweq	r0, #41	; 0x29
    33b4:	9f7f7200 	svcls	0x007f7200
    33b8:	0000297e 	andeq	r2, r0, lr, ror r9
    33bc:	00002984 	andeq	r2, r0, r4, lsl #19
    33c0:	84520001 	ldrbhi	r0, [r2], #-1
    33c4:	94000029 	strls	r0, [r0], #-41	; 0x29
    33c8:	03000029 	movweq	r0, #41	; 0x29
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33cc:	9f017200 	svcls	0x00017200
    33d0:	00002994 	muleq	r0, r4, r9
    33d4:	0000299c 	muleq	r0, ip, r9
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    33d8:	00720008 	rsbseq	r0, r2, r8
    33dc:	231c0091 	tstcs	ip, #145	; 0x91
    33e0:	299c9f41 	ldmibcs	ip, {r0, r6, r8, r9, sl, fp, ip, pc}
    33e4:	29a60000 	stmibcs	r6!, {}	; <UNPREDICTABLE>
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33e8:	00080000 	andeq	r0, r8, r0
    33ec:	00910072 	addseq	r0, r1, r2, ror r0
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    33f0:	9f40231c 	svcls	0x0040231c
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    33f4:	000029a6 	andeq	r2, r0, r6, lsr #19
    33f8:	000029a8 	andeq	r2, r0, r8, lsr #19
    33fc:	00720008 	rsbseq	r0, r2, r8
    3400:	231c0091 	tstcs	ip, #145	; 0x91
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3404:	00009f41 	andeq	r9, r0, r1, asr #30
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3408:	00000000 	andeq	r0, r0, r0
    340c:	29ea0000 	stmibcs	sl!, {}^	; <UNPREDICTABLE>
    3410:	2a440000 	bcs	1103418 <_etext+0x10fbf00>
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3414:	00010000 	andeq	r0, r1, r0
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3418:	002a5053 	eoreq	r5, sl, r3, asr r0
    341c:	002a6e00 	eoreq	r6, sl, r0, lsl #28
    3420:	52000100 	andpl	r0, r0, #0, 2
	...
    342c:	000029ea 	andeq	r2, r0, sl, ror #19
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3430:	00002a50 	andeq	r2, r0, r0, asr sl
    3434:	50590001 	subspl	r0, r9, r1
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3438:	5600002a 	strpl	r0, [r0], -sl, lsr #32
    343c:	0200002a 	andeq	r0, r0, #42	; 0x2a
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3440:	569f3000 	ldrpl	r3, [pc], r0
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3444:	6400002a 	strvs	r0, [r0], #-42	; 0x2a
    3448:	0800002a 	stmdaeq	r0, {r1, r3, r5}
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    344c:	91007300 	mrsls	r7, LR_irq
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3450:	40231c00 	eormi	r1, r3, r0, lsl #24
    3454:	002a649f 	mlaeq	sl, pc, r4, r6	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3458:	002a6a00 	eoreq	r6, sl, r0, lsl #20
    345c:	73000800 	movwvc	r0, #2048	; 0x800
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3460:	1c009100 	stfned	f1, [r0], {-0}
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3464:	6a9f3f23 	bvs	fe7d30f8 <BootRAM+0xd743899>
    GET_UINT32( W[9],  data, 36 );
    3468:	7a00002a 	bvc	3518 <sha256_process+0x4e4>
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    346c:	0800002a 	stmdaeq	r0, {r1, r3, r5}
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3470:	91007300 	mrsls	r7, LR_irq
    3474:	40231c00 	eormi	r1, r3, r0, lsl #24
    3478:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    347c:	00000000 	andeq	r0, r0, r0
    3480:	0029ec00 	eoreq	lr, r9, r0, lsl #24
    3484:	0029f200 	eoreq	pc, r9, r0, lsl #4
    3488:	30000200 	andcc	r0, r0, r0, lsl #4
    348c:	0029f29f 	mlaeq	r9, pc, r2, pc	; <UNPREDICTABLE>
    3490:	002a0000 	eoreq	r0, sl, r0
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3494:	52000100 	andpl	r0, r0, #0, 2
    3498:	00002a00 	andeq	r2, r0, r0, lsl #20
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    349c:	00002a06 	andeq	r2, r0, r6, lsl #20
    34a0:	7f720003 	svcvc	0x00720003
    34a4:	002a069f 	mlaeq	sl, pc, r6, r0	; <UNPREDICTABLE>
    34a8:	002a0c00 	eoreq	r0, sl, r0, lsl #24
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34ac:	52000100 	andpl	r0, r0, #0, 2
    34b0:	00002a0c 	andeq	r2, r0, ip, lsl #20
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34b4:	00002a1c 	andeq	r2, r0, ip, lsl sl
    34b8:	01720003 	cmneq	r2, r3
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34bc:	002a1c9f 	mlaeq	sl, pc, ip, r1	; <UNPREDICTABLE>
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34c0:	002a2400 	eoreq	r2, sl, r0, lsl #8
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34c4:	72000900 	andvc	r0, r0, #0, 18
    34c8:	1c009100 	stfned	f1, [r0], {-0}
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34cc:	9f01a123 	svcls	0x0001a123
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34d0:	00002a24 	andeq	r2, r0, r4, lsr #20
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    34d4:	00002a2e 	andeq	r2, r0, lr, lsr #20
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    34d8:	00720009 	rsbseq	r0, r2, r9
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34dc:	231c0091 	tstcs	ip, #145	; 0x91
    34e0:	2e9f01a0 	fmlcs<illegal precision>p	f0, f7, f0
    34e4:	3000002a 	andcc	r0, r0, sl, lsr #32
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    34e8:	0900002a 	stmdbeq	r0, {r1, r3, r5}
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34ec:	91007200 	mrsls	r7, R8_usr
    34f0:	a1231c00 	teqge	r3, r0, lsl #24
    34f4:	00009f01 	andeq	r9, r0, r1, lsl #30
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    34f8:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    34fc:	2a800000 	bcs	fe003504 <BootRAM+0xcf73ca5>
    3500:	2ad00000 	bcs	ff403508 <BootRAM+0xe373ca9>
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3504:	00010000 	andeq	r0, r1, r0
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3508:	002adc53 	eoreq	sp, sl, r3, asr ip
    350c:	002afc00 	eoreq	pc, sl, r0, lsl #24
    3510:	52000100 	andpl	r0, r0, #0, 2
	...
    351c:	00002a80 	andeq	r2, r0, r0, lsl #21
    3520:	00002adc 	ldrdeq	r2, [r0], -ip
    3524:	dc540001 	mrrcle	0, 0, r0, r4, cr1
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3528:	e200002a 	and	r0, r0, #42	; 0x2a
    352c:	0200002a 	andeq	r0, r0, #42	; 0x2a
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3530:	e29f3000 	adds	r3, pc, #0
    3534:	ea00002a 	b	35e4 <sha256_process+0x5b0>
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3538:	0900002a 	stmdbeq	r0, {r1, r3, r5}
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    353c:	91007300 	mrsls	r7, LR_irq
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3540:	a0231c00 	eorge	r1, r3, r0, lsl #24
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3544:	2aea9f01 	bcs	ffaab150 <BootRAM+0xea1b8f1>
    3548:	2af00000 	bcs	ffc03550 <BootRAM+0xeb73cf1>
    354c:	00090000 	andeq	r0, r9, r0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3550:	00910073 	addseq	r0, r1, r3, ror r0
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3554:	019f231c 	orrseq	r2, pc, ip, lsl r3	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3558:	002af09f 	mlaeq	sl, pc, r0, pc	; <UNPREDICTABLE>
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    355c:	002af600 	eoreq	pc, sl, r0, lsl #12
    3560:	73000900 	movwvc	r0, #2304	; 0x900
    3564:	1c009100 	stfned	f1, [r0], {-0}
    3568:	9f01a023 	svcls	0x0001a023
	...
    3574:	00002a82 	andeq	r2, r0, r2, lsl #21
    3578:	00002a86 	andeq	r2, r0, r6, lsl #21
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    357c:	9f300002 	svcls	0x00300002
    3580:	00002a86 	andeq	r2, r0, r6, lsl #21
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3584:	00002a90 	muleq	r0, r0, sl
    3588:	90520001 	subsls	r0, r2, r1
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    358c:	9600002a 	strls	r0, [r0], -sl, lsr #32
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3590:	0300002a 	movweq	r0, #42	; 0x2a
    3594:	9f7f7200 	svcls	0x007f7200
    3598:	00002a96 	muleq	r0, r6, sl
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    359c:	00002a9c 	muleq	r0, ip, sl
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35a0:	9c520001 	mrrcls	0, 0, r0, r2, cr1
    35a4:	a800002a 	stmdage	r0, {r1, r3, r5}
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35a8:	0300002a 	movweq	r0, #42	; 0x2a
    35ac:	9f017200 	svcls	0x00017200
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35b0:	00002aa8 	andeq	r2, r0, r8, lsr #21
    35b4:	00002ab0 			; <UNDEFINED> instruction: 0x00002ab0
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35b8:	00720008 	rsbseq	r0, r2, r8
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35bc:	231c0091 	tstcs	ip, #145	; 0x91
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35c0:	2ab09f41 	bcs	fec2b2cc <BootRAM+0xdb9ba6d>
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35c4:	2aba0000 	bcs	fee835cc <BootRAM+0xddf3d6d>
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35c8:	00080000 	andeq	r0, r8, r0
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35cc:	00910072 	addseq	r0, r1, r2, ror r0
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35d0:	9f40231c 	svcls	0x0040231c
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35d4:	00002aba 			; <UNDEFINED> instruction: 0x00002aba
    35d8:	00002abc 			; <UNDEFINED> instruction: 0x00002abc
    35dc:	00720008 	rsbseq	r0, r2, r8
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    35e0:	231c0091 	tstcs	ip, #145	; 0x91
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35e4:	00009f41 	andeq	r9, r0, r1, asr #30
    35e8:	00000000 	andeq	r0, r0, r0
    35ec:	2afc0000 	bcs	fff035f4 <BootRAM+0xee73d95>
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    35f0:	2b4c0000 	blcs	13035f8 <_etext+0x12fc0e0>
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    35f4:	00010000 	andeq	r0, r1, r0
    35f8:	002b5853 	eoreq	r5, fp, r3, asr r8
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    35fc:	002b7a00 	eoreq	r7, fp, r0, lsl #20
    3600:	52000100 	andpl	r0, r0, #0, 2
	...
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    360c:	00002afc 	strdeq	r2, [r0], -ip
    3610:	00002b58 	andeq	r2, r0, r8, asr fp
    3614:	58540001 	ldmdapl	r4, {r0}^
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3618:	5e00002b 	cdppl	0, 0, cr0, cr0, cr11, {1}
    361c:	0200002b 	andeq	r0, r0, #43	; 0x2b
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3620:	5e9f3000 	cdppl	0, 9, cr3, cr15, cr0, {0}
    3624:	6800002b 	stmdavs	r0, {r0, r1, r3, r5}
    3628:	0800002b 	stmdaeq	r0, {r0, r1, r3, r5}
    362c:	91007300 	mrsls	r7, LR_irq
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3630:	40231c00 	eormi	r1, r3, r0, lsl #24
    3634:	002b689f 	mlaeq	fp, pc, r8, r6	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3638:	002b6e00 	eoreq	r6, fp, r0, lsl #28
    363c:	73000800 	movwvc	r0, #2048	; 0x800
    3640:	1c009100 	stfned	f1, [r0], {-0}
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3644:	6e9f3f23 	cdpvs	15, 9, cr3, cr15, cr3, {1}
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3648:	7400002b 	strvc	r0, [r0], #-43	; 0x2b
    364c:	0800002b 	stmdaeq	r0, {r0, r1, r3, r5}
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3650:	91007300 	mrsls	r7, LR_irq
    3654:	40231c00 	eormi	r1, r3, r0, lsl #24
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3658:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    365c:	00000000 	andeq	r0, r0, r0
    3660:	002b0000 	eoreq	r0, fp, r0
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3664:	002b0400 	eoreq	r0, fp, r0, lsl #8
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3668:	30000200 	andcc	r0, r0, r0, lsl #4
    366c:	002b049f 	mlaeq	fp, pc, r4, r0	; <UNPREDICTABLE>
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3670:	002b1200 	eoreq	r1, fp, r0, lsl #4
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3674:	52000100 	andpl	r0, r0, #0, 2
    3678:	00002b12 	andeq	r2, r0, r2, lsl fp
    367c:	00002b18 	andeq	r2, r0, r8, lsl fp
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3680:	7f720003 	svcvc	0x00720003
    3684:	002b189f 	mlaeq	fp, pc, r8, r1	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3688:	002b1e00 	eoreq	r1, fp, r0, lsl #28
    368c:	52000100 	andpl	r0, r0, #0, 2
    3690:	00002b1e 	andeq	r2, r0, lr, lsl fp
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3694:	00002b2a 	andeq	r2, r0, sl, lsr #22
    3698:	01720003 	cmneq	r2, r3
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    369c:	002b2a9f 	mlaeq	fp, pc, sl, r2	; <UNPREDICTABLE>
    36a0:	002b3200 	eoreq	r3, fp, r0, lsl #4
    36a4:	72000900 	andvc	r0, r0, #0, 18
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    36a8:	1c009100 	stfned	f1, [r0], {-0}
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36ac:	9f01a123 	svcls	0x0001a123
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    36b0:	00002b32 	andeq	r2, r0, r2, lsr fp
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36b4:	00002b3c 	andeq	r2, r0, ip, lsr fp
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36b8:	00720009 	rsbseq	r0, r2, r9
    36bc:	231c0091 	tstcs	ip, #145	; 0x91
    36c0:	3c9f01a0 	ldfccs	f0, [pc], {160}	; 0xa0
    36c4:	3e00002b 	cdpcc	0, 0, cr0, cr0, cr11, {1}
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36c8:	0900002b 	stmdbeq	r0, {r0, r1, r3, r5}
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36cc:	91007200 	mrsls	r7, R8_usr
    36d0:	a1231c00 	teqge	r3, r0, lsl #24
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36d4:	00009f01 	andeq	r9, r0, r1, lsl #30
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36d8:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36dc:	2b7a0000 	blcs	1e836e4 <_etext+0x1e7c1cc>
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36e0:	2bc60000 	blcs	ff1836e8 <BootRAM+0xe0f3e89>
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36e4:	00010000 	andeq	r0, r1, r0
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    36e8:	002bd253 	eoreq	sp, fp, r3, asr r2
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    36ec:	002bf200 	eoreq	pc, fp, r0, lsl #4
    36f0:	52000100 	andpl	r0, r0, #0, 2
	...
    36fc:	00002b7a 	andeq	r2, r0, sl, ror fp
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3700:	00002bd2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    3704:	d2540001 	subsle	r0, r4, #1
    3708:	d800002b 	stmdale	r0, {r0, r1, r3, r5}
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    370c:	0200002b 	andeq	r0, r0, #43	; 0x2b
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3710:	d89f3000 	ldmle	pc, {ip, sp}	; <UNPREDICTABLE>
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3714:	e000002b 	and	r0, r0, fp, lsr #32
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3718:	0900002b 	stmdbeq	r0, {r0, r1, r3, r5}
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    371c:	91007300 	mrsls	r7, LR_irq
    3720:	a0231c00 	eorge	r1, r3, r0, lsl #24
    3724:	2be09f01 	blcs	ff82b330 <BootRAM+0xe79bad1>
    3728:	2be60000 	blcs	ff983730 <BootRAM+0xe8f3ed1>
    372c:	00090000 	andeq	r0, r9, r0
    3730:	00910073 	addseq	r0, r1, r3, ror r0
    3734:	019f231c 	orrseq	r2, pc, ip, lsl r3	; <UNPREDICTABLE>
    3738:	002be69f 	mlaeq	fp, pc, r6, lr	; <UNPREDICTABLE>
    373c:	002bec00 	eoreq	lr, fp, r0, lsl #24
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3740:	73000900 	movwvc	r0, #2304	; 0x900
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3744:	1c009100 	stfned	f1, [r0], {-0}
    3748:	9f01a023 	svcls	0x0001a023
	...
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3754:	00002b7c 	andeq	r2, r0, ip, ror fp
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3758:	00002b80 	andeq	r2, r0, r0, lsl #23
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    375c:	9f300002 	svcls	0x00300002
    3760:	00002b80 	andeq	r2, r0, r0, lsl #23
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3764:	00002b8a 	andeq	r2, r0, sl, lsl #23
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3768:	8a520001 	bhi	1483774 <_etext+0x147c25c>
    376c:	9000002b 	andls	r0, r0, fp, lsr #32
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3770:	0300002b 	movweq	r0, #43	; 0x2b
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3774:	9f7f7200 	svcls	0x007f7200
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3778:	00002b90 	muleq	r0, r0, fp
    377c:	00002b96 	muleq	r0, r6, fp
    3780:	96520001 	ldrbls	r0, [r2], -r1
    3784:	a200002b 	andge	r0, r0, #43	; 0x2b
    3788:	0300002b 	movweq	r0, #43	; 0x2b
    378c:	9f017200 	svcls	0x00017200
    3790:	00002ba2 	andeq	r2, r0, r2, lsr #23
    3794:	00002baa 	andeq	r2, r0, sl, lsr #23
    3798:	00720008 	rsbseq	r0, r2, r8
    379c:	231c0091 	tstcs	ip, #145	; 0x91
    37a0:	2baa9f41 	blcs	feaab4ac <BootRAM+0xda1bc4d>
    37a4:	2bb40000 	blcs	fed037ac <BootRAM+0xdc73f4d>
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    37a8:	00080000 	andeq	r0, r8, r0
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37ac:	00910072 	addseq	r0, r1, r2, ror r0
    37b0:	9f40231c 	svcls	0x0040231c
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37b4:	00002bb4 			; <UNDEFINED> instruction: 0x00002bb4
    37b8:	00002bb6 			; <UNDEFINED> instruction: 0x00002bb6
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37bc:	00720008 	rsbseq	r0, r2, r8
    37c0:	231c0091 	tstcs	ip, #145	; 0x91
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37c4:	00009f41 	andeq	r9, r0, r1, asr #30
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37c8:	00000000 	andeq	r0, r0, r0
    37cc:	2bf20000 	blcs	ffc837d4 <BootRAM+0xebf3f75>
    37d0:	2c420000 	marcs	acc0, r0, r2
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37d4:	00010000 	andeq	r0, r1, r0
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37d8:	002c5253 	eoreq	r5, ip, r3, asr r2
    37dc:	002c7200 	eoreq	r7, ip, r0, lsl #4
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37e0:	52000100 	andpl	r0, r0, #0, 2
	...
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37ec:	00002bf2 	strdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    37f0:	00002c52 	andeq	r2, r0, r2, asr ip
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    37f4:	52540001 	subspl	r0, r4, #1
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    37f8:	5800002c 	stmdapl	r0, {r2, r3, r5}
    37fc:	0200002c 	andeq	r0, r0, #44	; 0x2c
    3800:	589f3000 	ldmpl	pc, {ip, sp}	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3804:	6000002c 	andvs	r0, r0, ip, lsr #32
    3808:	0800002c 	stmdaeq	r0, {r2, r3, r5}
    380c:	91007300 	mrsls	r7, LR_irq
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3810:	40231c00 	eormi	r1, r3, r0, lsl #24
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3814:	002c609f 	mlaeq	ip, pc, r0, r6	; <UNPREDICTABLE>
    3818:	002c6600 	eoreq	r6, ip, r0, lsl #12
    381c:	73000800 	movwvc	r0, #2048	; 0x800
    3820:	1c009100 	stfned	f1, [r0], {-0}
    3824:	669f3f23 	ldrvs	r3, [pc], r3, lsr #30
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3828:	6c00002c 	stcvs	0, cr0, [r0], {44}	; 0x2c
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    382c:	0800002c 	stmdaeq	r0, {r2, r3, r5}
    3830:	91007300 	mrsls	r7, LR_irq
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3834:	40231c00 	eormi	r1, r3, r0, lsl #24
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3838:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    383c:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3840:	002bf600 	eoreq	pc, fp, r0, lsl #12
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3844:	002bfa00 	eoreq	pc, fp, r0, lsl #20
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3848:	30000200 	andcc	r0, r0, r0, lsl #4
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    384c:	002bfa9f 	mlaeq	fp, pc, sl, pc	; <UNPREDICTABLE>
    3850:	002c0800 	eoreq	r0, ip, r0, lsl #16
    3854:	52000100 	andpl	r0, r0, #0, 2
    3858:	00002c08 	andeq	r2, r0, r8, lsl #24
    385c:	00002c0e 	andeq	r2, r0, lr, lsl #24
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3860:	7f720003 	svcvc	0x00720003
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3864:	002c0e9f 	mlaeq	ip, pc, lr, r0	; <UNPREDICTABLE>
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3868:	002c1400 	eoreq	r1, ip, r0, lsl #8
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    386c:	52000100 	andpl	r0, r0, #0, 2
    3870:	00002c14 	andeq	r2, r0, r4, lsl ip
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3874:	00002c20 	andeq	r2, r0, r0, lsr #24
    3878:	01720003 	cmneq	r2, r3
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    387c:	002c209f 	mlaeq	ip, pc, r0, r2	; <UNPREDICTABLE>
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3880:	002c2800 	eoreq	r2, ip, r0, lsl #16
    3884:	72000900 	andvc	r0, r0, #0, 18
    3888:	1c009100 	stfned	f1, [r0], {-0}
    388c:	9f01a123 	svcls	0x0001a123
    3890:	00002c28 	andeq	r2, r0, r8, lsr #24
    3894:	00002c32 	andeq	r2, r0, r2, lsr ip
    3898:	00720009 	rsbseq	r0, r2, r9
    389c:	231c0091 	tstcs	ip, #145	; 0x91
    38a0:	329f01a0 	addscc	r0, pc, #160, 2	; 0x28
    38a4:	3400002c 	strcc	r0, [r0], #-44	; 0x2c
    38a8:	0900002c 	stmdbeq	r0, {r2, r3, r5}
    38ac:	91007200 	mrsls	r7, R8_usr
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38b0:	a1231c00 	teqge	r3, r0, lsl #24
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38b4:	00009f01 	andeq	r9, r0, r1, lsl #30
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38b8:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38bc:	2c720000 	ldclcs	0, cr0, [r2], #-0
    38c0:	2cbc0000 	ldccs	0, cr0, [ip]
    38c4:	00010000 	andeq	r0, r1, r0
    38c8:	002cc853 	eoreq	ip, ip, r3, asr r8
    38cc:	002ce200 	eoreq	lr, ip, r0, lsl #4
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38d0:	52000100 	andpl	r0, r0, #0, 2
	...
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38dc:	00002c72 	andeq	r2, r0, r2, ror ip
    38e0:	00002cc8 	andeq	r2, r0, r8, asr #25
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    38e4:	c8540001 	ldmdagt	r4, {r0}^
    38e8:	ce00002c 	cdpgt	0, 0, cr0, cr0, cr12, {1}
    38ec:	0200002c 	andeq	r0, r0, #44	; 0x2c
    38f0:	ce9f3000 	cdpgt	0, 9, cr3, cr15, cr0, {0}
    38f4:	d600002c 	strle	r0, [r0], -ip, lsr #32
    38f8:	0900002c 	stmdbeq	r0, {r2, r3, r5}
    38fc:	91007300 	mrsls	r7, LR_irq
    3900:	80231c00 	eorhi	r1, r3, r0, lsl #24
    3904:	2cd69f01 	ldclcs	15, cr9, [r6], {1}
    3908:	2cdc0000 	ldclcs	0, cr0, [ip], {0}
    390c:	00080000 	andeq	r0, r8, r0
    3910:	00910073 	addseq	r0, r1, r3, ror r0
    3914:	9f7f231c 	svcls	0x007f231c
    3918:	00002cdc 	ldrdeq	r2, [r0], -ip
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    391c:	00002ce0 	andeq	r2, r0, r0, ror #25
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3920:	00730009 	rsbseq	r0, r3, r9
    3924:	231c0091 	tstcs	ip, #145	; 0x91
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3928:	009f0180 	addseq	r0, pc, r0, lsl #3
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    392c:	00000000 	andeq	r0, r0, r0
    3930:	74000000 	strvc	r0, [r0], #-0
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3934:	7800002c 	stmdavc	r0, {r2, r3, r5}
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3938:	0200002c 	andeq	r0, r0, #44	; 0x2c
    393c:	789f3000 	ldmvc	pc, {ip, sp}	; <UNPREDICTABLE>
    3940:	8200002c 	andhi	r0, r0, #44	; 0x2c
    3944:	0100002c 	tsteq	r0, ip, lsr #32
    3948:	2c825200 	sfmcs	f5, 4, [r2], {0}
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    394c:	2c880000 	stccs	0, cr0, [r8], {0}
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3950:	00030000 	andeq	r0, r3, r0
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3954:	889f7f72 	ldmhi	pc, {r1, r4, r5, r6, r8, r9, sl, fp, ip, sp, lr}	; <UNPREDICTABLE>
    3958:	8e00002c 	cdphi	0, 0, cr0, cr0, cr12, {1}
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    395c:	0100002c 	tsteq	r0, ip, lsr #32
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3960:	2c8e5200 	sfmcs	f5, 4, [lr], {0}
    3964:	2c9a0000 	ldccs	0, cr0, [sl], {0}
    3968:	00030000 	andeq	r0, r3, r0
    396c:	9a9f0172 	bls	fe7c3f3c <BootRAM+0xd7346dd>
    3970:	a200002c 	andge	r0, r0, #44	; 0x2c
    3974:	0800002c 	stmdaeq	r0, {r2, r3, r5}
    3978:	91007200 	mrsls	r7, R8_usr
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    397c:	61231c00 	teqvs	r3, r0, lsl #24
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3980:	002ca29f 	mlaeq	ip, pc, r2, sl	; <UNPREDICTABLE>
    3984:	002cac00 	eoreq	sl, ip, r0, lsl #24
    3988:	72000800 	andvc	r0, r0, #0, 16
    398c:	1c009100 	stfned	f1, [r0], {-0}
    3990:	ac9f6023 	ldcge	0, cr6, [pc], {35}	; 0x23
    3994:	ae00002c 	cdpge	0, 0, cr0, cr0, cr12, {1}
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3998:	0800002c 	stmdaeq	r0, {r2, r3, r5}
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    399c:	91007200 	mrsls	r7, R8_usr
    39a0:	61231c00 	teqvs	r3, r0, lsl #24
    39a4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    39a8:	00000000 	andeq	r0, r0, r0
    39ac:	002cde00 	eoreq	sp, ip, r0, lsl #28
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39b0:	002ce400 	eoreq	lr, ip, r0, lsl #8
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39b4:	33000200 	movwcc	r0, #512	; 0x200
    39b8:	002ce49f 	mlaeq	ip, pc, r4, lr	; <UNPREDICTABLE>
    39bc:	002e3c00 	eoreq	r3, lr, r0, lsl #24
    39c0:	34000200 	strcc	r0, [r0], #-512	; 0x200
    39c4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39c8:	00000000 	andeq	r0, r0, r0
    39cc:	002cf400 	eoreq	pc, ip, r0, lsl #8
    39d0:	002d1a00 	eoreq	r1, sp, r0, lsl #20
    39d4:	52000100 	andpl	r0, r0, #0, 2
    39d8:	00002d1a 	andeq	r2, r0, sl, lsl sp
    39dc:	00002d24 	andeq	r2, r0, r4, lsr #26
    39e0:	2c510001 	mrrccs	0, 0, r0, r1, cr1
    39e4:	4a00002d 	bmi	3aa0 <sha256_process+0xa6c>
    39e8:	0100002d 	tsteq	r0, sp, lsr #32
    39ec:	00005200 	andeq	r5, r0, r0, lsl #4
    39f0:	00000000 	andeq	r0, r0, r0
    39f4:	2cf40000 	ldclcs	0, cr0, [r4]
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    39f8:	2d040000 	stccs	0, cr0, [r4, #-0]
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    39fc:	00010000 	andeq	r0, r1, r0
    3a00:	002d0453 	eoreq	r0, sp, r3, asr r4
    3a04:	002d0a00 	eoreq	r0, sp, r0, lsl #20
    3a08:	73000300 	movwvc	r0, #768	; 0x300
    3a0c:	2d0a9f7f 	stccs	15, cr9, [sl, #-508]	; 0xfffffe04
    3a10:	2d160000 	ldccs	0, cr0, [r6, #-0]
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a14:	00010000 	andeq	r0, r1, r0
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a18:	002d2c53 	eoreq	r2, sp, r3, asr ip
    3a1c:	002d3400 	eoreq	r3, sp, r0, lsl #8
    3a20:	73000900 	movwvc	r0, #2304	; 0x900
    3a24:	1c009100 	stfned	f1, [r0], {-0}
    3a28:	9f018023 	svcls	0x00018023
    3a2c:	00002d34 	andeq	r2, r0, r4, lsr sp
    3a30:	00002d3a 	andeq	r2, r0, sl, lsr sp
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a34:	00730008 	rsbseq	r0, r3, r8
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a38:	231c0091 	tstcs	ip, #145	; 0x91
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a3c:	2d3a9f7f 	ldccs	15, cr9, [sl, #-508]!	; 0xfffffe04
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a40:	2d440000 	stclcs	0, cr0, [r4, #-0]
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a44:	00090000 	andeq	r0, r9, r0
    3a48:	00910073 	addseq	r0, r1, r3, ror r0
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a4c:	0180231c 	orreq	r2, r0, ip, lsl r3
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a50:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    3a54:	00000000 	andeq	r0, r0, r0
    3a58:	002d4a00 	eoreq	r4, sp, r0, lsl #20
    3a5c:	002d9a00 	eoreq	r9, sp, r0, lsl #20
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a60:	53000100 	movwpl	r0, #256	; 0x100
    3a64:	00002da6 	andeq	r2, r0, r6, lsr #27
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a68:	00002dc8 	andeq	r2, r0, r8, asr #27
    3a6c:	00520001 	subseq	r0, r2, r1
    3a70:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a74:	4a000000 	bmi	3a7c <sha256_process+0xa48>
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a78:	a600002d 	strge	r0, [r0], -sp, lsr #32
    3a7c:	0100002d 	tsteq	r0, sp, lsr #32
    3a80:	2da65400 	cfstrscs	mvf5, [r6]
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a84:	2dac0000 	stccs	0, cr0, [ip]
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a88:	00020000 	andeq	r0, r2, r0
    3a8c:	2dac9f30 	stccs	15, cr9, [ip, #192]!	; 0xc0
    3a90:	2db40000 	ldccs	0, cr0, [r4]
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3a94:	00080000 	andeq	r0, r8, r0
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3a98:	00910073 	addseq	r0, r1, r3, ror r0
    3a9c:	9f60231c 	svcls	0x0060231c
    3aa0:	00002db4 			; <UNDEFINED> instruction: 0x00002db4
    3aa4:	00002dba 			; <UNDEFINED> instruction: 0x00002dba
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3aa8:	00730008 	rsbseq	r0, r3, r8
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3aac:	231c0091 	tstcs	ip, #145	; 0x91
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ab0:	2dba9f5f 	ldccs	15, cr9, [sl, #380]!	; 0x17c
    3ab4:	2dc00000 	stclcs	0, cr0, [r0]
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ab8:	00080000 	andeq	r0, r8, r0
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3abc:	00910073 	addseq	r0, r1, r3, ror r0
    3ac0:	9f60231c 	svcls	0x0060231c
	...
    3acc:	00002d4c 	andeq	r2, r0, ip, asr #26
    3ad0:	00002d52 	andeq	r2, r0, r2, asr sp
    3ad4:	9f300002 	svcls	0x00300002
    3ad8:	00002d52 	andeq	r2, r0, r2, asr sp
    3adc:	00002d60 	andeq	r2, r0, r0, ror #26
    3ae0:	60520001 	subsvs	r0, r2, r1
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ae4:	6600002d 	strvs	r0, [r0], -sp, lsr #32
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ae8:	0300002d 	movweq	r0, #45	; 0x2d
    3aec:	9f7f7200 	svcls	0x007f7200
    3af0:	00002d66 	andeq	r2, r0, r6, ror #26
    3af4:	00002d6c 	andeq	r2, r0, ip, ror #26
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3af8:	6c520001 	mrrcvs	0, 0, r0, r2, cr1
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3afc:	7800002d 	stmdavc	r0, {r0, r2, r3, r5}
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b00:	0300002d 	movweq	r0, #45	; 0x2d
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b04:	9f017200 	svcls	0x00017200
    3b08:	00002d78 	andeq	r2, r0, r8, ror sp
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b0c:	00002d80 	andeq	r2, r0, r0, lsl #27
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b10:	00720009 	rsbseq	r0, r2, r9
    3b14:	231c0091 	tstcs	ip, #145	; 0x91
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b18:	809f01a1 	addshi	r0, pc, r1, lsr #3
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b1c:	8a00002d 	bhi	3bd8 <sha256_process+0xba4>
    3b20:	0900002d 	stmdbeq	r0, {r0, r2, r3, r5}
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b24:	91007200 	mrsls	r7, R8_usr
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b28:	a0231c00 	eorge	r1, r3, r0, lsl #24
    3b2c:	2d8a9f01 	stccs	15, cr9, [sl, #4]
    3b30:	2d8c0000 	stccs	0, cr0, [ip]
    3b34:	00090000 	andeq	r0, r9, r0
    3b38:	00910072 	addseq	r0, r1, r2, ror r0
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b3c:	01a1231c 			; <UNDEFINED> instruction: 0x01a1231c
    3b40:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    3b44:	00000000 	andeq	r0, r0, r0
    3b48:	002dc800 	eoreq	ip, sp, r0, lsl #16
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b4c:	002e0e00 	eoreq	r0, lr, r0, lsl #28
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b50:	53000100 	movwpl	r0, #256	; 0x100
    3b54:	00002e18 	andeq	r2, r0, r8, lsl lr
    3b58:	00002e3c 	andeq	r2, r0, ip, lsr lr
    3b5c:	00520001 	subseq	r0, r2, r1
    3b60:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b64:	c8000000 	stmdagt	r0, {}	; <UNPREDICTABLE>
    3b68:	1800002d 	stmdane	r0, {r0, r2, r3, r5}
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b6c:	0100002e 	tsteq	r0, lr, lsr #32
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b70:	2e185000 	cdpcs	0, 1, cr5, cr8, cr0, {0}
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b74:	2e240000 	cdpcs	0, 2, cr0, cr4, cr0, {0}
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b78:	00020000 	andeq	r0, r2, r0
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b7c:	2e249f30 	mcrcs	15, 1, r9, cr4, cr0, {1}
    3b80:	2e2c0000 	cdpcs	0, 2, cr0, cr12, cr0, {0}
    3b84:	00010000 	andeq	r0, r1, r0
    3b88:	002e2c53 	eoreq	r2, lr, r3, asr ip
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3b8c:	002e3200 	eoreq	r3, lr, r0, lsl #4
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b90:	73000300 	movwvc	r0, #768	; 0x300
    3b94:	2e329f7f 	mrccs	15, 1, r9, cr2, cr15, {3}
    3b98:	2e3c0000 	cdpcs	0, 3, cr0, cr12, cr0, {0}
    3b9c:	00010000 	andeq	r0, r1, r0
    3ba0:	00000053 	andeq	r0, r0, r3, asr r0
    3ba4:	00000000 	andeq	r0, r0, r0
    3ba8:	002dca00 	eoreq	ip, sp, r0, lsl #20
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bac:	002dce00 	eoreq	ip, sp, r0, lsl #28
    3bb0:	30000200 	andcc	r0, r0, r0, lsl #4
    3bb4:	002dce9f 	mlaeq	sp, pc, lr, ip	; <UNPREDICTABLE>
    3bb8:	002dd600 	eoreq	sp, sp, r0, lsl #12
    3bbc:	52000100 	andpl	r0, r0, #0, 2
    3bc0:	00002dd6 	ldrdeq	r2, [r0], -r6
    3bc4:	00002ddc 	ldrdeq	r2, [r0], -ip
    3bc8:	7f720003 	svcvc	0x00720003
    3bcc:	002ddc9f 	mlaeq	sp, pc, ip, sp	; <UNPREDICTABLE>
    3bd0:	002de200 	eoreq	lr, sp, r0, lsl #4
    3bd4:	52000100 	andpl	r0, r0, #0, 2
    3bd8:	00002de2 	andeq	r2, r0, r2, ror #27
    3bdc:	00002dee 	andeq	r2, r0, lr, ror #27
    3be0:	01720003 	cmneq	r2, r3
    3be4:	002dee9f 	mlaeq	sp, pc, lr, lr	; <UNPREDICTABLE>
    3be8:	002df600 	eoreq	pc, sp, r0, lsl #12
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bec:	72000800 	andvc	r0, r0, #0, 16
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bf0:	1c009100 	stfned	f1, [r0], {-0}
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3bf4:	f69f6123 			; <UNDEFINED> instruction: 0xf69f6123
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bf8:	0000002d 	andeq	r0, r0, sp, lsr #32
    3bfc:	0800002e 	stmdaeq	r0, {r1, r2, r3, r5}
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c00:	91007200 	mrsls	r7, R8_usr
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c04:	60231c00 	eorvs	r1, r3, r0, lsl #24
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c08:	002e009f 	mlaeq	lr, pc, r0, r0	; <UNPREDICTABLE>
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c0c:	002e0200 	eoreq	r0, lr, r0, lsl #4
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c10:	72000800 	andvc	r0, r0, #0, 16
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c14:	1c009100 	stfned	f1, [r0], {-0}
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c18:	009f6123 	addseq	r6, pc, r3, lsr #2
	...
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c28:	01000000 	mrseq	r0, (UNDEF: 0)
    3c2c:	00005000 	andeq	r5, r0, r0
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c30:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c34:	00030000 	andeq	r0, r3, r0
    3c38:	009f7c70 	addseq	r7, pc, r0, ror ip	; <UNPREDICTABLE>
    3c3c:	00000000 	andeq	r0, r0, r0
    3c40:	04000000 	streq	r0, [r0], #-0
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c44:	5001f300 	andpl	pc, r1, r0, lsl #6
    3c48:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    3c58:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    3c64:	00520001 	subseq	r0, r2, r1
    3c68:	00000000 	andeq	r0, r0, r0
    3c6c:	05000000 	streq	r0, [r0, #-0]
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c70:	38007200 	stmdacc	r0, {r9, ip, sp, lr}
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c74:	00009f25 	andeq	r9, r0, r5, lsr #30
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3c78:	00000000 	andeq	r0, r0, r0
    3c7c:	00070000 	andeq	r0, r7, r0
    3c80:	25380072 	ldrcs	r0, [r8, #-114]!	; 0x72
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3c84:	009f2538 	addseq	r2, pc, r8, lsr r5	; <UNPREDICTABLE>
    3c88:	00000000 	andeq	r0, r0, r0
    3c8c:	0a000000 	beq	3c94 <sha256_process+0xc60>
    3c90:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    3c94:	25382540 	ldrcs	r2, [r8, #-1344]!	; 0x540
    3c98:	009f2538 	addseq	r2, pc, r8, lsr r5	; <UNPREDICTABLE>
	...
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3ca8:	02000000 	andeq	r0, r0, #0
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cac:	009f3000 	addseq	r3, pc, r0
    3cb0:	00000000 	andeq	r0, r0, r0
    3cb4:	02000000 	andeq	r0, r0, #0
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cb8:	009f3200 	addseq	r3, pc, r0, lsl #4
    3cbc:	00000000 	andeq	r0, r0, r0
    3cc0:	02000000 	andeq	r0, r0, #0
    3cc4:	009f3300 	addseq	r3, pc, r0, lsl #6
    3cc8:	00000000 	andeq	r0, r0, r0
    3ccc:	02000000 	andeq	r0, r0, #0
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cd0:	009f3400 	addseq	r3, pc, r0, lsl #8
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3cd4:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cd8:	3c000000 	stccc	0, cr0, [r0], {-0}
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3cdc:	7a00002e 	bvc	3d9c <sha256_process+0xd68>
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3ce0:	0100002e 	tsteq	r0, lr, lsr #32
    3ce4:	2e7a5000 	cdpcs	0, 7, cr5, cr10, cr0, {0}
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3ce8:	2fbc0000 	svccs	0x00bc0000
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cec:	00010000 	andeq	r0, r1, r0
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3cf0:	002fbc54 	eoreq	fp, pc, r4, asr ip	; <UNPREDICTABLE>
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3cf4:	002fc800 	eoreq	ip, pc, r0, lsl #16
    3cf8:	50000100 	andpl	r0, r0, r0, lsl #2
    3cfc:	00002fc8 	andeq	r2, r0, r8, asr #31
    3d00:	00002fd6 	ldrdeq	r2, [r0], -r6
    3d04:	d6540001 	ldrble	r0, [r4], -r1
    3d08:	dc00002f 	stcle	0, cr0, [r0], {47}	; 0x2f
    3d0c:	0100002f 	tsteq	r0, pc, lsr #32
    3d10:	00005000 	andeq	r5, r0, r0
    3d14:	00000000 	andeq	r0, r0, r0
    3d18:	2e3c0000 	cdpcs	0, 3, cr0, cr12, cr0, {0}
    3d1c:	2e7c0000 	cdpcs	0, 7, cr0, cr12, cr0, {0}
    3d20:	00010000 	andeq	r0, r1, r0
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d24:	002e7c51 	eoreq	r7, lr, r1, asr ip
    3d28:	002fbc00 	eoreq	fp, pc, r0, lsl #24
    3d2c:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d30:	00002fbc 			; <UNDEFINED> instruction: 0x00002fbc
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d34:	00002fc8 	andeq	r2, r0, r8, asr #31
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d38:	c8510001 	ldmdagt	r1, {r0}^
    3d3c:	d600002f 	strle	r0, [r0], -pc, lsr #32
    3d40:	0100002f 	tsteq	r0, pc, lsr #32
    3d44:	2fd65700 	svccs	0x00d65700
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d48:	2fdc0000 	svccs	0x00dc0000
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d4c:	00010000 	andeq	r0, r1, r0
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d50:	00000051 	andeq	r0, r0, r1, asr r0
    3d54:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d58:	002e3c00 	eoreq	r3, lr, r0, lsl #24
    3d5c:	002e4c00 	eoreq	r4, lr, r0, lsl #24
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d60:	52000100 	andpl	r0, r0, #0, 2
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d64:	00002e4c 	andeq	r2, r0, ip, asr #28
    3d68:	00002f34 	andeq	r2, r0, r4, lsr pc
    3d6c:	34590001 	ldrbcc	r0, [r9], #-1
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d70:	4800002f 	stmdami	r0, {r0, r1, r2, r3, r5}
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d74:	0300002f 	movweq	r0, #47	; 0x2f
    3d78:	9f017900 	svcls	0x00017900
    3d7c:	00002f48 	andeq	r2, r0, r8, asr #30
    3d80:	00002fbc 			; <UNDEFINED> instruction: 0x00002fbc
    3d84:	01f30004 	mvnseq	r0, r4
    3d88:	2fbc9f52 	svccs	0x00bc9f52
    3d8c:	2fdc0000 	svccs	0x00dc0000
    3d90:	00010000 	andeq	r0, r1, r0
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3d94:	00000059 	andeq	r0, r0, r9, asr r0
    3d98:	00000000 	andeq	r0, r0, r0
    3d9c:	002e3c00 	eoreq	r3, lr, r0, lsl #24
    3da0:	002e4e00 	eoreq	r4, lr, r0, lsl #28
    3da4:	53000100 	movwpl	r0, #256	; 0x100
    3da8:	00002e4e 	andeq	r2, r0, lr, asr #28
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3dac:	00002ed2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3db0:	d2550001 	subsle	r0, r5, #1
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3db4:	1600002e 	strne	r0, [r0], -lr, lsr #32
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3db8:	0300002f 	movweq	r0, #47	; 0x2f
    3dbc:	7fb49100 	svcvc	0x00b49100
    3dc0:	00002f16 	andeq	r2, r0, r6, lsl pc
    3dc4:	00002fbc 			; <UNDEFINED> instruction: 0x00002fbc
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3dc8:	01f30004 	mvnseq	r0, r4
    3dcc:	2fbc9f53 	svccs	0x00bc9f53
    3dd0:	2fdc0000 	svccs	0x00dc0000
    3dd4:	00010000 	andeq	r0, r1, r0
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3dd8:	00000055 	andeq	r0, r0, r5, asr r0
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3ddc:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3de0:	002e7800 	eoreq	r7, lr, r0, lsl #16
    3de4:	002f3800 	eoreq	r3, pc, r0, lsl #16
    3de8:	58000100 	stmdapl	r0, {r8}
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3dec:	00002fc8 	andeq	r2, r0, r8, asr #31
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3df0:	00002fd6 	ldrdeq	r2, [r0], -r6
    3df4:	00580001 	subseq	r0, r8, r1
    3df8:	00000000 	andeq	r0, r0, r0
    3dfc:	8e000000 	cdphi	0, 0, cr0, cr0, cr0, {0}
    3e00:	4000002e 	andmi	r0, r0, lr, lsr #32
    3e04:	0100002f 	tsteq	r0, pc, lsr #32
    3e08:	2fc85600 	svccs	0x00c85600
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e0c:	2fd60000 	svccs	0x00d60000
    3e10:	00010000 	andeq	r0, r1, r0
    3e14:	00000056 	andeq	r0, r0, r6, asr r0
    3e18:	00000000 	andeq	r0, r0, r0
    3e1c:	002e8e00 	eoreq	r8, lr, r0, lsl #28
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e20:	002f4c00 	eoreq	r4, pc, r0, lsl #24
    3e24:	5a000100 	bpl	422c <sha256_process+0x11f8>
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e28:	00002f4c 	andeq	r2, r0, ip, asr #30
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e2c:	00002f4e 	andeq	r2, r0, lr, asr #30
    3e30:	017a0003 	cmneq	sl, r3
    3e34:	002fc89f 	mlaeq	pc, pc, r8, ip	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e38:	002fd600 	eoreq	sp, pc, r0, lsl #12
    3e3c:	5a000100 	bpl	4244 <sha256_process+0x1210>
	...
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e48:	00002e8e 	andeq	r2, r0, lr, lsl #29
    3e4c:	00002ed2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    3e50:	9f300002 	svcls	0x00300002
    3e54:	00002ee6 	andeq	r2, r0, r6, ror #29
    3e58:	00002ef2 	strdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    3e5c:	f25b0001 	vhadd.s16	d16, d11, d1
    3e60:	0800002e 	stmdaeq	r0, {r1, r2, r3, r5}
    3e64:	0100002f 	tsteq	r0, pc, lsr #32
    3e68:	2f085300 	svccs	0x00085300
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e6c:	2f160000 	svccs	0x00160000
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e70:	00090000 	andeq	r0, r9, r0
    3e74:	25320078 	ldrcs	r0, [r2, #-120]!	; 0x78
    3e78:	02232432 	eoreq	r2, r3, #838860800	; 0x32000000
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e7c:	002f489f 	mlaeq	pc, pc, r8, r4	; <UNPREDICTABLE>
    3e80:	002f4c00 	eoreq	r4, pc, r0, lsl #24
    3e84:	7a000300 	bvc	4a8c <sha256_process+0x1a58>
    3e88:	2f4c9f7f 	svccs	0x004c9f7f
    3e8c:	2fb40000 	svccs	0x00b40000
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e90:	00010000 	andeq	r0, r1, r0
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3e94:	002fb45a 	eoreq	fp, pc, sl, asr r4	; <UNPREDICTABLE>
    3e98:	002fb600 	eoreq	fp, pc, r0, lsl #12
    3e9c:	7a000300 	bvc	4aa4 <sha256_process+0x1a70>
    3ea0:	2fc89f01 	svccs	0x00c89f01
    3ea4:	2fca0000 	svccs	0x00ca0000
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3ea8:	00020000 	andeq	r0, r2, r0
    3eac:	2fca9f30 	svccs	0x00ca9f30
    3eb0:	2fd60000 	svccs	0x00d60000
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3eb4:	00010000 	andeq	r0, r1, r0
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3eb8:	00000052 	andeq	r0, r0, r2, asr r0
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ebc:	00000000 	andeq	r0, r0, r0
    3ec0:	002e4a00 	eoreq	r4, lr, r0, lsl #20
    3ec4:	002e4e00 	eoreq	r4, lr, r0, lsl #28
    3ec8:	53000100 	movwpl	r0, #256	; 0x100
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3ecc:	00002e4e 	andeq	r2, r0, lr, asr #28
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ed0:	00002ed2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    3ed4:	d2550001 	subsle	r0, r5, #1
    3ed8:	1600002e 	strne	r0, [r0], -lr, lsr #32
    3edc:	0300002f 	movweq	r0, #47	; 0x2f
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3ee0:	7fb49100 	svcvc	0x00b49100
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ee4:	00002f16 	andeq	r2, r0, r6, lsl pc
    3ee8:	00002fbc 			; <UNDEFINED> instruction: 0x00002fbc
    3eec:	01f30004 	mvnseq	r0, r4
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3ef0:	2fbc9f53 	svccs	0x00bc9f53
    3ef4:	2fdc0000 	svccs	0x00dc0000
    3ef8:	00010000 	andeq	r0, r1, r0
    3efc:	00000055 	andeq	r0, r0, r5, asr r0
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f00:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f04:	002e4a00 	eoreq	r4, lr, r0, lsl #20
    3f08:	002e4e00 	eoreq	r4, lr, r0, lsl #28
    3f0c:	4f000200 	svcmi	0x00000200
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f10:	002e4e9f 	mlaeq	lr, pc, lr, r4	; <UNPREDICTABLE>
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f14:	002e5200 	eoreq	r5, lr, r0, lsl #4
    3f18:	52000100 	andpl	r0, r0, #0, 2
    3f1c:	00002e52 	andeq	r2, r0, r2, asr lr
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f20:	00002e56 	andeq	r2, r0, r6, asr lr
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f24:	01720003 	cmneq	r2, r3
    3f28:	002e569f 	mlaeq	lr, pc, r6, r5	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f2c:	002e6800 	eoreq	r6, lr, r0, lsl #16
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f30:	52000100 	andpl	r0, r0, #0, 2
    3f34:	00002fbc 			; <UNDEFINED> instruction: 0x00002fbc
    3f38:	00002fc0 	andeq	r2, r0, r0, asr #31
    3f3c:	01720003 	cmneq	r2, r3
    3f40:	002fc09f 	mlaeq	pc, pc, r0, ip	; <UNPREDICTABLE>
    3f44:	002fc800 	eoreq	ip, pc, r0, lsl #16
    3f48:	09000300 	stmdbeq	r0, {r8, r9}
    3f4c:	2fd69ff8 	svccs	0x00d69ff8
    3f50:	2fdc0000 	svccs	0x00dc0000
    3f54:	00030000 	andeq	r0, r3, r0
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f58:	009ff809 	addseq	pc, pc, r9, lsl #16
    3f5c:	00000000 	andeq	r0, r0, r0
    3f60:	5c000000 	stcpl	0, cr0, [r0], {-0}
    3f64:	5e00002e 	cdppl	0, 0, cr0, cr0, cr14, {1}
    3f68:	0500002e 	streq	r0, [r0, #-46]	; 0x2e
    3f6c:	72007500 	andvc	r7, r0, #0, 10
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f70:	2e5e2200 	cdpcs	2, 5, cr2, cr14, cr0, {0}
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3f74:	2e600000 	cdpcs	0, 6, cr0, cr0, cr0, {0}
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3f78:	00050000 	andeq	r0, r5, r0
    3f7c:	25310073 	ldrcs	r0, [r1, #-115]!	; 0x73
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3f80:	002fc09f 	mlaeq	pc, pc, r0, ip	; <UNPREDICTABLE>
    3f84:	002fc800 	eoreq	ip, pc, r0, lsl #16
    3f88:	75000200 	strvc	r0, [r0, #-512]	; 0x200
    3f8c:	002fd67f 	eoreq	sp, pc, pc, ror r6	; <UNPREDICTABLE>
    3f90:	002fdc00 	eoreq	sp, pc, r0, lsl #24
    3f94:	75000200 	strvc	r0, [r0, #-512]	; 0x200
    3f98:	0000007f 	andeq	r0, r0, pc, ror r0
    3f9c:	00000000 	andeq	r0, r0, r0
    3fa0:	002e6c00 	eoreq	r6, lr, r0, lsl #24
    3fa4:	002e8a00 	eoreq	r8, lr, r0, lsl #20
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fa8:	5a000100 	bpl	43b0 <sha256_process+0x137c>
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3fac:	00002e8a 	andeq	r2, r0, sl, lsl #29
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fb0:	00002f34 	andeq	r2, r0, r4, lsr pc
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3fb4:	00790005 	rsbseq	r0, r9, r5
    3fb8:	349f2433 	ldrcc	r2, [pc], #1075	; 3fc0 <sha256_process+0xf8c>
    3fbc:	4800002f 	stmdami	r0, {r0, r1, r2, r3, r5}
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fc0:	0500002f 	streq	r0, [r0, #-47]	; 0x2f
    3fc4:	33017900 	movwcc	r7, #6400	; 0x1900
    3fc8:	2f489f24 	svccs	0x00489f24
    3fcc:	2fbc0000 	svccs	0x00bc0000
    3fd0:	00060000 	andeq	r0, r6, r0
    3fd4:	335201f3 	cmpcc	r2, #-1073741764	; 0xc000003c
    3fd8:	2fc89f24 	svccs	0x00c89f24
    3fdc:	2fd60000 	svccs	0x00d60000
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3fe0:	00050000 	andeq	r0, r5, r0
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fe4:	24330079 	ldrtcs	r0, [r3], #-121	; 0x79
    3fe8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    3fec:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    3ff0:	002e6c00 	eoreq	r6, lr, r0, lsl #24
    3ff4:	002e7e00 	eoreq	r7, lr, r0, lsl #28
    3ff8:	52000100 	andpl	r0, r0, #0, 2
	...
    4004:	00002f1c 	andeq	r2, r0, ip, lsl pc
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4008:	00002f22 	andeq	r2, r0, r2, lsr #30
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    400c:	24520001 	ldrbcs	r0, [r2], #-1
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4010:	3c00002f 	stccc	0, cr0, [r0], {47}	; 0x2f
    4014:	0100002f 	tsteq	r0, pc, lsr #32
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4018:	00005200 	andeq	r5, r0, r0, lsl #4
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    401c:	00000000 	andeq	r0, r0, r0
    4020:	2f1c0000 	svccs	0x001c0000
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4024:	2f280000 	svccs	0x00280000
    4028:	00010000 	andeq	r0, r1, r0
    402c:	002f2853 	eoreq	r2, pc, r3, asr r8	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4030:	002f2e00 	eoreq	r2, pc, r0, lsl #28
    4034:	73000300 	movwvc	r0, #768	; 0x300
    4038:	2f2e9f7f 	svccs	0x002e9f7f
    403c:	2f440000 	svccs	0x00440000
    4040:	00010000 	andeq	r0, r1, r0
    4044:	00000053 	andeq	r0, r0, r3, asr r0
    4048:	00000000 	andeq	r0, r0, r0
    404c:	002f6000 	eoreq	r6, pc, r0
    4050:	002f7e00 	eoreq	r7, pc, r0, lsl #28
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4054:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4060:	00002f60 	andeq	r2, r0, r0, ror #30
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4064:	00002fb6 			; <UNDEFINED> instruction: 0x00002fb6
    4068:	9f310002 	svcls	0x00310002
	...
    4074:	00002f60 	andeq	r2, r0, r0, ror #30
    4078:	00002f62 	andeq	r2, r0, r2, ror #30
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    407c:	9f300002 	svcls	0x00300002
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4080:	00002f62 	andeq	r2, r0, r2, ror #30
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4084:	00002f78 	andeq	r2, r0, r8, ror pc
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4088:	00520001 	subseq	r0, r2, r1
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    408c:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4090:	60000000 	andvs	r0, r0, r0
    4094:	6200002f 	andvs	r0, r0, #47	; 0x2f
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4098:	0200002f 	andeq	r0, r0, #47	; 0x2f
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    409c:	629f3000 	addsvs	r3, pc, #0
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40a0:	6c00002f 	stcvs	0, cr0, [r0], {47}	; 0x2f
    40a4:	0100002f 	tsteq	r0, pc, lsr #32
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40a8:	2f6c5300 	svccs	0x006c5300
    40ac:	2f720000 	svccs	0x00720000
    40b0:	00030000 	andeq	r0, r3, r0
    40b4:	729f7f73 	addsvc	r7, pc, #460	; 0x1cc
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40b8:	7600002f 	strvc	r0, [r0], -pc, lsr #32
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40bc:	0100002f 	tsteq	r0, pc, lsr #32
    40c0:	00005300 	andeq	r5, r0, r0, lsl #6
    40c4:	00000000 	andeq	r0, r0, r0
    40c8:	2f7c0000 	svccs	0x007c0000
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40cc:	2fb60000 	svccs	0x00b60000
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40d0:	00010000 	andeq	r0, r1, r0
    40d4:	00000054 	andeq	r0, r0, r4, asr r0
    40d8:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40dc:	002f7c00 	eoreq	r7, pc, r0, lsl #24
    40e0:	002f7e00 	eoreq	r7, pc, r0, lsl #28
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40e4:	30000200 	andcc	r0, r0, r0, lsl #4
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    40e8:	002f7e9f 	mlaeq	pc, pc, lr, r7	; <UNPREDICTABLE>
    40ec:	002f8600 	eoreq	r8, pc, r0, lsl #12
    40f0:	52000100 	andpl	r0, r0, #0, 2
    40f4:	00002f88 	andeq	r2, r0, r8, lsl #31
    40f8:	00002f98 	muleq	r0, r8, pc	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    40fc:	98520001 	ldmdals	r2, {r0}^
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4100:	9a00002f 	bls	41c4 <sha256_process+0x1190>
    4104:	0400002f 	streq	r0, [r0], #-47	; 0x2f
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4108:	1f007200 	svcne	0x00007200
    410c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4110:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4114:	002f7c00 	eoreq	r7, pc, r0, lsl #24
    4118:	002f7e00 	eoreq	r7, pc, r0, lsl #28
    411c:	30000200 	andcc	r0, r0, r0, lsl #4
    4120:	002f7e9f 	mlaeq	pc, pc, lr, r7	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4124:	002f8e00 	eoreq	r8, pc, r0, lsl #28
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4128:	53000100 	movwpl	r0, #256	; 0x100
    412c:	00002f8e 	andeq	r2, r0, lr, lsl #31
    4130:	00002f94 	muleq	r0, r4, pc	; <UNPREDICTABLE>
    4134:	7f730003 	svcvc	0x00730003
    4138:	002f949f 	mlaeq	pc, pc, r4, r9	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    413c:	002f9c00 	eoreq	r9, pc, r0, lsl #24
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4140:	53000100 	movwpl	r0, #256	; 0x100
	...
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    414c:	00002f96 	muleq	r0, r6, pc	; <UNPREDICTABLE>
    4150:	00002f98 	muleq	r0, r8, pc	; <UNPREDICTABLE>
    4154:	98520001 	ldmdals	r2, {r0}^
    4158:	9a00002f 	bls	421c <sha256_process+0x11e8>
    415c:	0400002f 	streq	r0, [r0], #-47	; 0x2f
    4160:	1f007200 	svcne	0x00007200
    4164:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4168:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    416c:	002f9600 	eoreq	r9, pc, r0, lsl #12
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4170:	002fb600 	eoreq	fp, pc, r0, lsl #12
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4174:	5d000100 	stfpls	f0, [r0, #-0]
	...
    4180:	00002f9a 	muleq	r0, sl, pc	; <UNPREDICTABLE>
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4184:	00002fb6 			; <UNDEFINED> instruction: 0x00002fb6
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4188:	00520001 	subseq	r0, r2, r1
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    418c:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4190:	9a000000 	bls	4198 <sha256_process+0x1164>
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4194:	9c00002f 	stcls	0, cr0, [r0], {47}	; 0x2f
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4198:	0200002f 	andeq	r0, r0, #47	; 0x2f
    419c:	9c9f3000 	ldcls	0, cr3, [pc], {0}
    41a0:	b600002f 	strlt	r0, [r0], -pc, lsr #32
    41a4:	0100002f 	tsteq	r0, pc, lsr #32
    41a8:	00005300 	andeq	r5, r0, r0, lsl #6
	...
    41b8:	00010000 	andeq	r0, r1, r0
    41bc:	00000050 	andeq	r0, r0, r0, asr r0
    41c0:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41c4:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    41d0:	00550001 	subseq	r0, r5, r1
	...
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41e0:	01000000 	mrseq	r0, (UNDEF: 0)
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41e4:	00005100 	andeq	r5, r0, r0, lsl #2
    41e8:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    41ec:	00010000 	andeq	r0, r1, r0
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    41f0:	00000053 	andeq	r0, r0, r3, asr r0
    41f4:	00000000 	andeq	r0, r0, r0
    41f8:	f3000400 	vshl.u8	d0, d0, d0
    41fc:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
    420c:	01000000 	mrseq	r0, (UNDEF: 0)
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4210:	00005d00 	andeq	r5, r0, r0, lsl #26
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4214:	00000000 	andeq	r0, r0, r0
    4218:	00030000 	andeq	r0, r3, r0
    421c:	009f6074 	addseq	r6, pc, r4, ror r0	; <UNPREDICTABLE>
	...
    422c:	01000000 	mrseq	r0, (UNDEF: 0)
    4230:	00005000 	andeq	r5, r0, r0
    4234:	00000000 	andeq	r0, r0, r0
    4238:	00040000 	andeq	r0, r4, r0
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    423c:	9f5001f3 	svcls	0x005001f3
	...
    4248:	00500001 	subseq	r0, r0, r1
	...
    4258:	01000000 	mrseq	r0, (UNDEF: 0)
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    425c:	00005100 	andeq	r5, r0, r0, lsl #2
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4260:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4264:	00040000 	andeq	r0, r4, r0
    4268:	9f5101f3 	svcls	0x005101f3
	...
    4274:	00510001 	subseq	r0, r1, r1
	...
    4284:	02000000 	andeq	r0, r0, #0
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4288:	009f3000 	addseq	r3, pc, r0
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    428c:	00000000 	andeq	r0, r0, r0
    4290:	01000000 	mrseq	r0, (UNDEF: 0)
    4294:	00005200 	andeq	r5, r0, r0, lsl #4
    4298:	00000000 	andeq	r0, r0, r0
    429c:	00080000 	andeq	r0, r8, r0
    42a0:	25310072 	ldrcs	r0, [r1, #-114]!	; 0x72
    42a4:	9f210072 	svcls	0x00210072
	...
    42b0:	9f300002 	svcls	0x00300002
	...
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42bc:	00520001 	subseq	r0, r2, r1
	...
    42cc:	02000000 	andeq	r0, r0, #0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    42d0:	009f3000 	addseq	r3, pc, r0
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42d4:	00000000 	andeq	r0, r0, r0
    42d8:	02000000 	andeq	r0, r0, #0
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42dc:	009f3000 	addseq	r3, pc, r0
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42e0:	00000000 	andeq	r0, r0, r0
    42e4:	01000000 	mrseq	r0, (UNDEF: 0)
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    42e8:	00005300 	andeq	r5, r0, r0, lsl #6
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42ec:	00000000 	andeq	r0, r0, r0
    42f0:	00030000 	andeq	r0, r3, r0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    42f4:	009f7f73 	addseq	r7, pc, r3, ror pc	; <UNPREDICTABLE>
    42f8:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    42fc:	01000000 	mrseq	r0, (UNDEF: 0)
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4300:	00005300 	andeq	r5, r0, r0, lsl #6
	...
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4310:	00010000 	andeq	r0, r1, r0
    4314:	00000051 	andeq	r0, r0, r1, asr r0
    4318:	00000000 	andeq	r0, r0, r0
    431c:	f3000400 	vshl.u8	d0, d0, d0
    4320:	009f5101 	addseq	r5, pc, r1, lsl #2
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4324:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4328:	01000000 	mrseq	r0, (UNDEF: 0)
    432c:	00005100 	andeq	r5, r0, r0, lsl #2
	...
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    433c:	00010000 	andeq	r0, r1, r0
    4340:	00000052 	andeq	r0, r0, r2, asr r0
    4344:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4348:	f3000400 	vshl.u8	d0, d0, d0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    434c:	009f5201 	addseq	r5, pc, r1, lsl #4
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4350:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4354:	01000000 	mrseq	r0, (UNDEF: 0)
    4358:	00005200 	andeq	r5, r0, r0, lsl #4
	...
    4368:	00010000 	andeq	r0, r1, r0
    436c:	00000053 	andeq	r0, r0, r3, asr r0
    4370:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4374:	f3000400 	vshl.u8	d0, d0, d0
    4378:	009f5301 	addseq	r5, pc, r1, lsl #6
	...
    4388:	01000000 	mrseq	r0, (UNDEF: 0)
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    438c:	00005300 	andeq	r5, r0, r0, lsl #6
    4390:	00000000 	andeq	r0, r0, r0
    4394:	00010000 	andeq	r0, r1, r0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4398:	00000056 	andeq	r0, r0, r6, asr r0
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    439c:	00000000 	andeq	r0, r0, r0
    43a0:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43b4:	9f300002 	svcls	0x00300002
	...
    43c0:	9f300002 	svcls	0x00300002
	...
    43cc:	00530001 	subseq	r0, r3, r1
	...
    43dc:	01000000 	mrseq	r0, (UNDEF: 0)
    43e0:	00005100 	andeq	r5, r0, r0, lsl #2
    43e4:	00000000 	andeq	r0, r0, r0
    43e8:	00040000 	andeq	r0, r4, r0
    43ec:	9f5101f3 	svcls	0x005101f3
	...
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4400:	00520001 	subseq	r0, r2, r1
    4404:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4408:	04000000 	streq	r0, [r0], #-0
    440c:	5201f300 	andpl	pc, r1, #0, 6
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4410:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    4420:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    442c:	01f30004 	mvnseq	r0, r4
    4430:	00009f51 	andeq	r9, r0, r1, asr pc
	...
    4440:	00020000 	andeq	r0, r2, r0
    4444:	00009f30 	andeq	r9, r0, r0, lsr pc
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4448:	00000000 	andeq	r0, r0, r0
    444c:	00010000 	andeq	r0, r1, r0
    4450:	00000054 	andeq	r0, r0, r4, asr r0
	...
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4460:	30000200 	andcc	r0, r0, r0, lsl #4
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4464:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4468:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    446c:	53000100 	movwpl	r0, #256	; 0x100
	...
    4478:	7f730003 	svcvc	0x00730003
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    447c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4480:	00000000 	andeq	r0, r0, r0
    4484:	53000100 	movwpl	r0, #256	; 0x100
	...
    4498:	00510001 	subseq	r0, r1, r1
    449c:	00000000 	andeq	r0, r0, r0
    44a0:	01000000 	mrseq	r0, (UNDEF: 0)
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44a4:	00005100 	andeq	r5, r0, r0, lsl #2
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44a8:	00000000 	andeq	r0, r0, r0
    44ac:	00040000 	andeq	r0, r4, r0
    44b0:	9f1f0071 	svcls	0x001f0071
	...
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44c4:	00530001 	subseq	r0, r3, r1
    44c8:	00000000 	andeq	r0, r0, r0
    44cc:	03000000 	movweq	r0, #0
    44d0:	9f7f7300 	svcls	0x007f7300
	...
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    44dc:	00530001 	subseq	r0, r3, r1
	...
    44ec:	01000000 	mrseq	r0, (UNDEF: 0)
    44f0:	00005100 	andeq	r5, r0, r0, lsl #2
    44f4:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    44f8:	00040000 	andeq	r0, r4, r0
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    44fc:	9f1f0071 	svcls	0x001f0071
	...
    4510:	005d0001 	subseq	r0, sp, r1
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4514:	00000000 	andeq	r0, r0, r0
    4518:	03000000 	movweq	r0, #0
    451c:	9f509100 	svcls	0x00509100
	...
    4528:	507d0003 	rsbspl	r0, sp, r3
    452c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    453c:	30000200 	andcc	r0, r0, r0, lsl #4
    4540:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4544:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4548:	53000100 	movwpl	r0, #256	; 0x100
	...
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    455c:	00510001 	subseq	r0, r1, r1
    4560:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4564:	04000000 	streq	r0, [r0], #-0
    4568:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    456c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    457c:	52000100 	andpl	r0, r0, #0, 2
	...
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4588:	01f30004 	mvnseq	r0, r4
    458c:	00009f52 	andeq	r9, r0, r2, asr pc
	...
    459c:	00010000 	andeq	r0, r1, r0
    45a0:	00000052 	andeq	r0, r0, r2, asr r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45a4:	00000000 	andeq	r0, r0, r0
    45a8:	f3000400 	vshl.u8	d0, d0, d0
    45ac:	009f5201 	addseq	r5, pc, r1, lsl #4
	...
    45bc:	02000000 	andeq	r0, r0, #0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45c0:	009f3000 	addseq	r3, pc, r0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45c4:	00000000 	andeq	r0, r0, r0
    45c8:	01000000 	mrseq	r0, (UNDEF: 0)
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45cc:	00005400 	andeq	r5, r0, r0, lsl #8
	...
    45dc:	00020000 	andeq	r0, r2, r0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45e0:	00009f30 	andeq	r9, r0, r0, lsr pc
    45e4:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    45e8:	00010000 	andeq	r0, r1, r0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45ec:	00000053 	andeq	r0, r0, r3, asr r0
    45f0:	00000000 	andeq	r0, r0, r0
    45f4:	73000300 	movwvc	r0, #768	; 0x300
    45f8:	00009f7f 	andeq	r9, r0, pc, ror pc
    45fc:	00000000 	andeq	r0, r0, r0
    4600:	00010000 	andeq	r0, r1, r0
    4604:	00000053 	andeq	r0, r0, r3, asr r0
	...
    4614:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4620:	00540001 	subseq	r0, r4, r1
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4624:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4628:	04000000 	streq	r0, [r0], #-0
    462c:	1f007400 	svcne	0x00007400
    4630:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    4640:	53000100 	movwpl	r0, #256	; 0x100
	...
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    464c:	7f730003 	svcvc	0x00730003
    4650:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4654:	00000000 	andeq	r0, r0, r0
    4658:	53000100 	movwpl	r0, #256	; 0x100
	...
    466c:	00540001 	subseq	r0, r4, r1
    4670:	00000000 	andeq	r0, r0, r0
    4674:	04000000 	streq	r0, [r0], #-0
    4678:	1f007400 	svcne	0x00007400
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    467c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    468c:	5d000100 	stfpls	f0, [r0, #-0]
	...
    4698:	50910003 	addspl	r0, r1, r3
    469c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46a0:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46a4:	7d000300 	stcvc	3, cr0, [r0, #-0]
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46a8:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    46b8:	00010000 	andeq	r0, r1, r0
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46bc:	00000054 	andeq	r0, r0, r4, asr r0
	...
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46cc:	30000200 	andcc	r0, r0, r0, lsl #4
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46d0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    46d4:	00000000 	andeq	r0, r0, r0
    46d8:	53000100 	movwpl	r0, #256	; 0x100
	...
    46ec:	00520001 	subseq	r0, r2, r1
    46f0:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    46f4:	04000000 	streq	r0, [r0], #-0
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46f8:	5201f300 	andpl	pc, r1, #0, 6
    46fc:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    470c:	30000200 	andcc	r0, r0, r0, lsl #4
    4710:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4714:	00000000 	andeq	r0, r0, r0
    4718:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    4724:	00510001 	subseq	r0, r1, r1
    4728:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    472c:	04000000 	streq	r0, [r0], #-0
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4730:	1f007100 	svcne	0x00007100
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4734:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    4744:	30000200 	andcc	r0, r0, r0, lsl #4
    4748:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    474c:	00000000 	andeq	r0, r0, r0
    4750:	53000100 	movwpl	r0, #256	; 0x100
	...
    475c:	7f730003 	svcvc	0x00730003
    4760:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4764:	00000000 	andeq	r0, r0, r0
    4768:	53000100 	movwpl	r0, #256	; 0x100
	...
    477c:	00510001 	subseq	r0, r1, r1
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4780:	00000000 	andeq	r0, r0, r0
    4784:	04000000 	streq	r0, [r0], #-0
    4788:	1f007100 	svcne	0x00007100
    478c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    479c:	5d000100 	stfpls	f0, [r0, #-0]
	...
    47a8:	50910003 	addspl	r0, r1, r3
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47ac:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    47b0:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47b4:	7d000300 	stcvc	3, cr0, [r0, #-0]
    47b8:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    47c8:	00020000 	andeq	r0, r2, r0
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47cc:	00009f30 	andeq	r9, r0, r0, lsr pc
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47d0:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47d4:	00010000 	andeq	r0, r1, r0
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47d8:	00000053 	andeq	r0, r0, r3, asr r0
	...
    47e8:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    47f4:	00550001 	subseq	r0, r5, r1
	...
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4804:	01000000 	mrseq	r0, (UNDEF: 0)
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4808:	00005100 	andeq	r5, r0, r0, lsl #2
    480c:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4810:	00010000 	andeq	r0, r1, r0
    4814:	00000058 	andeq	r0, r0, r8, asr r0
	...
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4824:	52000100 	andpl	r0, r0, #0, 2
	...
    4830:	005a0001 	subseq	r0, sl, r1
	...
    4840:	01000000 	mrseq	r0, (UNDEF: 0)
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4844:	00005300 	andeq	r5, r0, r0, lsl #6
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4848:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    484c:	00010000 	andeq	r0, r1, r0
    4850:	00000057 	andeq	r0, r0, r7, asr r0
	...
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4860:	72000300 	andvc	r0, r0, #0, 6
    4864:	00009f7f 	andeq	r9, r0, pc, ror pc
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4868:	00000000 	andeq	r0, r0, r0
    486c:	00010000 	andeq	r0, r1, r0
    4870:	0000005c 	andeq	r0, r0, ip, asr r0
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4874:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4878:	7c000300 	stcvc	3, cr0, [r0], {-0}
    487c:	00009f01 	andeq	r9, r0, r1, lsl #30
	...
    488c:	00020000 	andeq	r0, r2, r0
    4890:	00009f4f 	andeq	r9, r0, pc, asr #30
    4894:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4898:	00010000 	andeq	r0, r1, r0
    489c:	00000052 	andeq	r0, r0, r2, asr r0
    48a0:	00000000 	andeq	r0, r0, r0
    48a4:	72000300 	andvc	r0, r0, #0, 6
    48a8:	00009f01 	andeq	r9, r0, r1, lsl #30
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48ac:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48b0:	00010000 	andeq	r0, r1, r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48b4:	00000052 	andeq	r0, r0, r2, asr r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48b8:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48bc:	72000300 	andvc	r0, r0, #0, 6
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48c0:	00009f01 	andeq	r9, r0, r1, lsl #30
    48c4:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48c8:	00030000 	andeq	r0, r3, r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48cc:	009ff809 	addseq	pc, pc, r9, lsl #16
	...
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48dc:	05000000 	streq	r0, [r0, #-0]
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48e0:	72007700 	andvc	r7, r0, #0, 14
    48e4:	00002200 	andeq	r2, r0, r0, lsl #4
    48e8:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    48ec:	00050000 	andeq	r0, r5, r0
    48f0:	25310073 	ldrcs	r0, [r1, #-115]!	; 0x73
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48f4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    48f8:	00000000 	andeq	r0, r0, r0
    48fc:	77000200 	strvc	r0, [r0, -r0, lsl #4]
    4900:	0000007f 	andeq	r0, r0, pc, ror r0
	...
    4910:	59000100 	stmdbpl	r0, {r8}
	...
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    491c:	00790004 	rsbseq	r0, r9, r4
    4920:	00009f1f 	andeq	r9, r0, pc, lsl pc
	...
    4930:	00020000 	andeq	r0, r2, r0
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4934:	00009f31 	andeq	r9, r0, r1, lsr pc
	...
    4944:	00020000 	andeq	r0, r2, r0
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4948:	00009f30 	andeq	r9, r0, r0, lsr pc
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    494c:	00000000 	andeq	r0, r0, r0
    4950:	00010000 	andeq	r0, r1, r0
    4954:	00000052 	andeq	r0, r0, r2, asr r0
	...
    4964:	30000200 	andcc	r0, r0, r0, lsl #4
    4968:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    496c:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4970:	53000100 	movwpl	r0, #256	; 0x100
	...
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    497c:	7f730003 	svcvc	0x00730003
    4980:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4984:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4988:	53000100 	movwpl	r0, #256	; 0x100
	...
    499c:	00520001 	subseq	r0, r2, r1
    49a0:	00000000 	andeq	r0, r0, r0
    49a4:	01000000 	mrseq	r0, (UNDEF: 0)
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49a8:	00005200 	andeq	r5, r0, r0, lsl #4
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49ac:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49b0:	00040000 	andeq	r0, r4, r0
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49b4:	9f1f0072 	svcls	0x001f0072
	...
    49c8:	00530001 	subseq	r0, r3, r1
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    49cc:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49d0:	03000000 	movweq	r0, #0
    49d4:	9f7f7300 	svcls	0x007f7300
	...
    49e0:	00530001 	subseq	r0, r3, r1
	...
    49f0:	01000000 	mrseq	r0, (UNDEF: 0)
    49f4:	00005200 	andeq	r5, r0, r0, lsl #4
    49f8:	00000000 	andeq	r0, r0, r0
    49fc:	00040000 	andeq	r0, r4, r0
    4a00:	9f1f0072 	svcls	0x001f0072
	...
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a14:	00560001 	subseq	r0, r6, r1
	...
    4a24:	01000000 	mrseq	r0, (UNDEF: 0)
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a28:	00005200 	andeq	r5, r0, r0, lsl #4
	...
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a38:	00020000 	andeq	r0, r2, r0
    4a3c:	00009f30 	andeq	r9, r0, r0, lsr pc
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a40:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a44:	00010000 	andeq	r0, r1, r0
    4a48:	00000053 	andeq	r0, r0, r3, asr r0
	...
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a58:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a6c:	005d0001 	subseq	r0, sp, r1
	...
    4a7c:	01000000 	mrseq	r0, (UNDEF: 0)
    4a80:	00005d00 	andeq	r5, r0, r0, lsl #26
	...
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4a90:	00020000 	andeq	r0, r2, r0
    4a94:	00009f30 	andeq	r9, r0, r0, lsr pc
    4a98:	00000000 	andeq	r0, r0, r0
    4a9c:	00010000 	andeq	r0, r1, r0
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4aa0:	0000005b 	andeq	r0, r0, fp, asr r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4aa4:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4aa8:	53000100 	movwpl	r0, #256	; 0x100
	...
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4ab4:	005b0001 	subseq	r0, fp, r1
	...
    4ac4:	02000000 	andeq	r0, r0, #0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ac8:	009f3000 	addseq	r3, pc, r0
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4acc:	00000000 	andeq	r0, r0, r0
    4ad0:	01000000 	mrseq	r0, (UNDEF: 0)
    4ad4:	00005400 	andeq	r5, r0, r0, lsl #8
    4ad8:	00000000 	andeq	r0, r0, r0
    4adc:	00030000 	andeq	r0, r3, r0
    4ae0:	009f7f74 	addseq	r7, pc, r4, ror pc	; <UNPREDICTABLE>
    4ae4:	00000000 	andeq	r0, r0, r0
    4ae8:	01000000 	mrseq	r0, (UNDEF: 0)
    4aec:	00005400 	andeq	r5, r0, r0, lsl #8
	...
    4afc:	00010000 	andeq	r0, r1, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b00:	00000053 	andeq	r0, r0, r3, asr r0
    4b04:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b08:	53000100 	movwpl	r0, #256	; 0x100
	...
    4b14:	00730004 	rsbseq	r0, r3, r4
    4b18:	00009f1f 	andeq	r9, r0, pc, lsl pc
	...
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b28:	00010000 	andeq	r0, r1, r0
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b2c:	00000054 	andeq	r0, r0, r4, asr r0
    4b30:	00000000 	andeq	r0, r0, r0
    4b34:	74000300 	strvc	r0, [r0], #-768	; 0x300
    4b38:	00009f7f 	andeq	r9, r0, pc, ror pc
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b3c:	00000000 	andeq	r0, r0, r0
    4b40:	00010000 	andeq	r0, r1, r0
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b44:	00000054 	andeq	r0, r0, r4, asr r0
	...
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b54:	53000100 	movwpl	r0, #256	; 0x100
	...
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b60:	00730004 	rsbseq	r0, r3, r4
    4b64:	00009f1f 	andeq	r9, r0, pc, lsl pc
	...
    4b74:	00010000 	andeq	r0, r1, r0
    4b78:	0000005d 	andeq	r0, r0, sp, asr r0
	...
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4b88:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4b9c:	00530001 	subseq	r0, r3, r1
	...
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4bac:	02000000 	andeq	r0, r0, #0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bb0:	009f3000 	addseq	r3, pc, r0
    4bb4:	00000000 	andeq	r0, r0, r0
    4bb8:	01000000 	mrseq	r0, (UNDEF: 0)
    4bbc:	00005200 	andeq	r5, r0, r0, lsl #4
	...
    4bcc:	00010000 	andeq	r0, r1, r0
    4bd0:	00000059 	andeq	r0, r0, r9, asr r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4bd4:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bd8:	79000400 	stmdbvc	r0, {sl}
    4bdc:	009f1f00 	addseq	r1, pc, r0, lsl #30
	...
    4bec:	01000000 	mrseq	r0, (UNDEF: 0)
    4bf0:	00005d00 	andeq	r5, r0, r0, lsl #26
	...
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c00:	00010000 	andeq	r0, r1, r0
    4c04:	00000059 	andeq	r0, r0, r9, asr r0
	...
    4c14:	30000200 	andcc	r0, r0, r0, lsl #4
    4c18:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c1c:	00000000 	andeq	r0, r0, r0
    4c20:	53000100 	movwpl	r0, #256	; 0x100
	...
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c34:	00500001 	subseq	r0, r0, r1
    4c38:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c3c:	01000000 	mrseq	r0, (UNDEF: 0)
    4c40:	00005600 	andeq	r5, r0, r0, lsl #12
	...
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c50:	00010000 	andeq	r0, r1, r0
    4c54:	00000051 	andeq	r0, r0, r1, asr r0
    4c58:	00000000 	andeq	r0, r0, r0
    4c5c:	58000100 	stmdapl	r0, {r8}
	...
    4c70:	00520001 	subseq	r0, r2, r1
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c74:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c78:	01000000 	mrseq	r0, (UNDEF: 0)
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c7c:	00005700 	andeq	r5, r0, r0, lsl #14
	...
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c8c:	00020000 	andeq	r0, r2, r0
    4c90:	00009f32 	andeq	r9, r0, r2, lsr pc
    4c94:	00000000 	andeq	r0, r0, r0
    4c98:	00010000 	andeq	r0, r1, r0
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4c9c:	00000055 	andeq	r0, r0, r5, asr r0
    4ca0:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4ca4:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    4cb0:	00550001 	subseq	r0, r5, r1
	...
    4cc0:	02000000 	andeq	r0, r0, #0
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cc4:	009f3000 	addseq	r3, pc, r0
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cc8:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4ccc:	01000000 	mrseq	r0, (UNDEF: 0)
    4cd0:	00005400 	andeq	r5, r0, r0, lsl #8
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4cd4:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cd8:	00030000 	andeq	r0, r3, r0
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cdc:	009f7f74 	addseq	r7, pc, r4, ror pc	; <UNPREDICTABLE>
    4ce0:	00000000 	andeq	r0, r0, r0
    4ce4:	01000000 	mrseq	r0, (UNDEF: 0)
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4ce8:	00005400 	andeq	r5, r0, r0, lsl #8
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cec:	00000000 	andeq	r0, r0, r0
    4cf0:	00030000 	andeq	r0, r3, r0
    4cf4:	009f7f75 	addseq	r7, pc, r5, ror pc	; <UNPREDICTABLE>
    4cf8:	00000000 	andeq	r0, r0, r0
    4cfc:	01000000 	mrseq	r0, (UNDEF: 0)
    4d00:	00005500 	andeq	r5, r0, r0, lsl #10
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d04:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d08:	00030000 	andeq	r0, r3, r0
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d0c:	009f0175 	addseq	r0, pc, r5, ror r1	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d10:	00000000 	andeq	r0, r0, r0
    4d14:	01000000 	mrseq	r0, (UNDEF: 0)
    4d18:	00005500 	andeq	r5, r0, r0, lsl #10
    4d1c:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d20:	00030000 	andeq	r0, r3, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d24:	009f0175 	addseq	r0, pc, r5, ror r1	; <UNPREDICTABLE>
    4d28:	00000000 	andeq	r0, r0, r0
    4d2c:	01000000 	mrseq	r0, (UNDEF: 0)
    4d30:	00005400 	andeq	r5, r0, r0, lsl #8
	...
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d40:	00010000 	andeq	r0, r1, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d44:	00000052 	andeq	r0, r0, r2, asr r0
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d48:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d4c:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d60:	005d0001 	subseq	r0, sp, r1
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d64:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d68:	04000000 	streq	r0, [r0], #-0
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4d6c:	7fa89100 	svcvc	0x00a89100
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d70:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4d74:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4d78:	5d000100 	stfpls	f0, [r0, #-0]
	...
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d8c:	9f310002 	svcls	0x00310002
	...
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d98:	9f300002 	svcls	0x00300002
	...
    4dac:	9f300002 	svcls	0x00300002
	...
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4db8:	9f310002 	svcls	0x00310002
	...
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dc4:	9f320002 	svcls	0x00320002
	...
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4dd0:	9f330002 	svcls	0x00330002
	...
    4ddc:	9f340002 	svcls	0x00340002
	...
    4df0:	00520001 	subseq	r0, r2, r1
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4df4:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4df8:	03000000 	movweq	r0, #0
    4dfc:	9f017200 	svcls	0x00017200
	...
    4e08:	00520001 	subseq	r0, r2, r1
    4e0c:	00000000 	andeq	r0, r0, r0
    4e10:	01000000 	mrseq	r0, (UNDEF: 0)
    4e14:	00005500 	andeq	r5, r0, r0, lsl #10
    4e18:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e1c:	00030000 	andeq	r0, r3, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e20:	009f0175 	addseq	r0, pc, r5, ror r1	; <UNPREDICTABLE>
    4e24:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e28:	03000000 	movweq	r0, #0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e2c:	9f017200 	svcls	0x00017200
	...
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e38:	f8090003 			; <UNDEFINED> instruction: 0xf8090003
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e3c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e4c:	77000500 	strvc	r0, [r0, -r0, lsl #10]
    4e50:	22007200 	andcs	r7, r0, #0, 4
	...
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e5c:	00730005 	rsbseq	r0, r3, r5
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e60:	009f2531 	addseq	r2, pc, r1, lsr r5	; <UNPREDICTABLE>
    4e64:	00000000 	andeq	r0, r0, r0
    4e68:	02000000 	andeq	r0, r0, #0
    4e6c:	007f7700 	rsbseq	r7, pc, r0, lsl #14
	...
    4e7c:	03000000 	movweq	r0, #0
    4e80:	9f489100 	svcls	0x00489100
	...
    4e8c:	00540001 	subseq	r0, r4, r1
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4e90:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e94:	03000000 	movweq	r0, #0
    4e98:	9f707400 	svcls	0x00707400
	...
    4ea4:	60740003 	rsbsvs	r0, r4, r3
    4ea8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4eac:	00000000 	andeq	r0, r0, r0
    4eb0:	91000300 	mrsls	r0, LR_irq
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4eb4:	00009f48 	andeq	r9, r0, r8, asr #30
    4eb8:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ebc:	00010000 	andeq	r0, r1, r0
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4ec0:	00000051 	andeq	r0, r0, r1, asr r0
    4ec4:	00000000 	andeq	r0, r0, r0
    4ec8:	91000300 	mrsls	r0, LR_irq
    4ecc:	00009f48 	andeq	r9, r0, r8, asr #30
	...
    4edc:	00010000 	andeq	r0, r1, r0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ee0:	00000056 	andeq	r0, r0, r6, asr r0
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4ee4:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ee8:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4efc:	00500001 	subseq	r0, r0, r1
    4f00:	00000000 	andeq	r0, r0, r0
    4f04:	01000000 	mrseq	r0, (UNDEF: 0)
    4f08:	00005400 	andeq	r5, r0, r0, lsl #8
    4f0c:	00000000 	andeq	r0, r0, r0
    4f10:	00040000 	andeq	r0, r4, r0
    4f14:	9f5001f3 	svcls	0x005001f3
	...
    4f28:	00510001 	subseq	r0, r1, r1
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    ctx->state[7] += H;
    4f2c:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f30:	01000000 	mrseq	r0, (UNDEF: 0)

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    4f34:	00005200 	andeq	r5, r0, r0, lsl #4
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f38:	00000000 	andeq	r0, r0, r0
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    4f3c:	00010000 	andeq	r0, r1, r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f40:	00000055 	andeq	r0, r0, r5, asr r0

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    4f44:	00000000 	andeq	r0, r0, r0
    4f48:	f3000400 	vshl.u8	d0, d0, d0
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    4f4c:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
    4f5c:	01000000 	mrseq	r0, (UNDEF: 0)
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    4f60:	00005000 	andeq	r5, r0, r0
    ctx->state[4] += E;
    4f64:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    4f68:	00010000 	andeq	r0, r1, r0
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    4f6c:	00000055 	andeq	r0, r0, r5, asr r0
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    4f70:	00000000 	andeq	r0, r0, r0
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    4f74:	f3000400 	vshl.u8	d0, d0, d0
    ctx->state[7] += H;
    4f78:	009f5001 	addseq	r5, pc, r1
	...
}
    4f88:	01000000 	mrseq	r0, (UNDEF: 0)
    4f8c:	00005100 	andeq	r5, r0, r0, lsl #2
    4f90:	00000000 	andeq	r0, r0, r0
    4f94:	00010000 	andeq	r0, r1, r0

void sha256_update( sha256_context *ctx, uint8 *input, uint32 length )
{
    4f98:	00000054 	andeq	r0, r0, r4, asr r0
    uint32 left, fill;

    if( ! length ) return;
    4f9c:	00000000 	andeq	r0, r0, r0
    ctx->state[6] += G;
    ctx->state[7] += H;
}

void sha256_update( sha256_context *ctx, uint8 *input, uint32 length )
{
    4fa0:	f3000400 	vshl.u8	d0, d0, d0
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    4fa4:	009f5101 	addseq	r5, pc, r1, lsl #2
	...

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;
    4fb4:	01000000 	mrseq	r0, (UNDEF: 0)

    if( left && length >= fill )
    4fb8:	00005200 	andeq	r5, r0, r0, lsl #4
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    4fbc:	00000000 	andeq	r0, r0, r0
    4fc0:	00010000 	andeq	r0, r1, r0
    {
        sha256_process( ctx, input );
        length -= 64;
    4fc4:	00000057 	andeq	r0, r0, r7, asr r0
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    4fc8:	00000000 	andeq	r0, r0, r0
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    4fcc:	f3000400 	vshl.u8	d0, d0, d0
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    4fd0:	009f5201 	addseq	r5, pc, r1, lsl #4
	...
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    4fe0:	01000000 	mrseq	r0, (UNDEF: 0)
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    4fe4:	00005300 	andeq	r5, r0, r0, lsl #6
    4fe8:	00000000 	andeq	r0, r0, r0
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    4fec:	00010000 	andeq	r0, r1, r0
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    4ff0:	00000058 	andeq	r0, r0, r8, asr r0
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    4ff4:	00000000 	andeq	r0, r0, r0
    4ff8:	f3000400 	vshl.u8	d0, d0, d0
                (void *) input, length );
    }
}
    4ffc:	009f5301 	addseq	r5, pc, r1, lsl #6
	...
    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
    500c:	01000000 	mrseq	r0, (UNDEF: 0)
    5010:	00005200 	andeq	r5, r0, r0, lsl #4
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    5014:	00000000 	andeq	r0, r0, r0
    5018:	00010000 	andeq	r0, r1, r0
        length -= fill;
    501c:	00000057 	andeq	r0, r0, r7, asr r0
        input  += fill;
    5020:	00000000 	andeq	r0, r0, r0
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    5024:	f3000400 	vshl.u8	d0, d0, d0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    5028:	009f5201 	addseq	r5, pc, r1, lsl #4
	...
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    5038:	01000000 	mrseq	r0, (UNDEF: 0)

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    503c:	00005100 	andeq	r5, r0, r0, lsl #2
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    5040:	00000000 	andeq	r0, r0, r0

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    5044:	00010000 	andeq	r0, r1, r0
    5048:	00000054 	andeq	r0, r0, r4, asr r0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    504c:	00000000 	andeq	r0, r0, r0
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    5050:	f3000400 	vshl.u8	d0, d0, d0
{
    uint32 last, padn;
    uint32 high, low;
    uint8 msglen[8];

    high = ( ctx->total[0] >> 29 )
    5054:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    5064:	01000000 	mrseq	r0, (UNDEF: 0)
    5068:	00005800 	andeq	r5, r0, r0, lsl #16

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;
    506c:	00000000 	andeq	r0, r0, r0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    5070:	00040000 	andeq	r0, r4, r0

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    5074:	9f5301f3 	svcls	0x005301f3
	...
    PUT_UINT32( low,  msglen, 4 );
    5088:	00540001 	subseq	r0, r4, r1
    508c:	00000000 	andeq	r0, r0, r0

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;
    5090:	04000000 	streq	r0, [r0], #-0

    if( left && length >= fill )
    5094:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    5098:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    50a8:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    {
        memcpy( (void *) (ctx->buffer + left),
    50b4:	01f30004 	mvnseq	r0, r4
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    50b8:	00009f50 	andeq	r9, r0, r0, asr pc
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    50bc:	00000000 	andeq	r0, r0, r0
{
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    50c0:	30340000 	eorscc	r0, r4, r0
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    50c4:	30400000 	subcc	r0, r0, r0
        ctx->total[1]++;
    50c8:	00010000 	andeq	r0, r1, r0

    if( left && length >= fill )
    50cc:	00304050 	eorseq	r4, r0, r0, asr r0
    50d0:	00304a00 	eorseq	r4, r0, r0, lsl #20
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    50d4:	52000100 	andpl	r0, r0, #0, 2
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    50d8:	0000304a 	andeq	r3, r0, sl, asr #32
    50dc:	0000304c 	andeq	r3, r0, ip, asr #32
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    50e0:	4c530001 	mrrcmi	0, 0, r0, r3, cr1
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    50e4:	54000030 	strpl	r0, [r0], #-48	; 0x30
    50e8:	01000030 	tsteq	r0, r0, lsr r0
    50ec:	30545400 	subscc	r5, r4, r0, lsl #8
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    sha256_update( ctx, sha256_padding, padn );
    sha256_update( ctx, msglen, 8 );

    PUT_UINT32( ctx->state[0], digest,  0 );
    50f0:	305c0000 	subscc	r0, ip, r0
    50f4:	00010000 	andeq	r0, r1, r0
    50f8:	00305c50 	eorseq	r5, r0, r0, asr ip
    50fc:	004f8000 	subeq	r8, pc, r0
    5100:	91000200 	mrsls	r0, R8_usr
    PUT_UINT32( ctx->state[1], digest,  4 );
    5104:	004f8054 	subeq	r8, pc, r4, asr r0	; <UNPREDICTABLE>
    5108:	004f9800 	subeq	r9, pc, r0, lsl #16
    510c:	7d000200 	sfmvc	f0, 4, [r0, #-0]
    5110:	00000054 	andeq	r0, r0, r4, asr r0
    PUT_UINT32( ctx->state[2], digest,  8 );
    5114:	00000000 	andeq	r0, r0, r0
    5118:	00303400 	eorseq	r3, r0, r0, lsl #8
    511c:	00377400 	eorseq	r7, r7, r0, lsl #8
    5120:	51000100 	mrspl	r0, (UNDEF: 16)
    5124:	00003774 	andeq	r3, r0, r4, ror r7
    PUT_UINT32( ctx->state[3], digest, 12 );
    5128:	00004f98 	muleq	r0, r8, pc	; <UNPREDICTABLE>
    512c:	01f30004 	mvnseq	r0, r4
    5130:	00009f51 	andeq	r9, r0, r1, asr pc
    5134:	00000000 	andeq	r0, r0, r0
    PUT_UINT32( ctx->state[4], digest, 16 );
    5138:	37b00000 	ldrcc	r0, [r0, r0]!
    513c:	37b80000 	ldrcc	r0, [r8, r0]!
    5140:	00010000 	andeq	r0, r1, r0
    5144:	0037ea5a 	eorseq	lr, r7, sl, asr sl
    5148:	00382200 	eorseq	r2, r8, r0, lsl #4
    PUT_UINT32( ctx->state[5], digest, 20 );
    514c:	5c000100 	stfpls	f0, [r0], {-0}
    5150:	00003852 	andeq	r3, r0, r2, asr r8
    5154:	000038a2 	andeq	r3, r0, r2, lsr #17
    5158:	ca500001 	bgt	1405164 <_etext+0x13fdc4c>
    PUT_UINT32( ctx->state[6], digest, 24 );
    515c:	16000038 			; <UNDEFINED> instruction: 0x16000038
    5160:	01000039 	tsteq	r0, r9, lsr r0
    5164:	39405200 	stmdbcc	r0, {r9, ip, lr}^
    5168:	39940000 	ldmibcc	r4, {}	; <UNPREDICTABLE>
    516c:	00010000 	andeq	r0, r1, r0
    PUT_UINT32( ctx->state[7], digest, 28 );
    5170:	0039b053 	eorseq	fp, r9, r3, asr r0
    5174:	003a1a00 	eorseq	r1, sl, r0, lsl #20
    5178:	50000100 	andpl	r0, r0, r0, lsl #2
    517c:	00003a24 	andeq	r3, r0, r4, lsr #20
    5180:	00003a6e 	andeq	r3, r0, lr, ror #20
    5184:	9c5c0001 	mrrcls	0, 0, r0, ip, cr1
    5188:	ec00003a 	stc	0, cr0, [r0], {58}	; 0x3a
    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
    518c:	0100003a 	tsteq	r0, sl, lsr r0
    5190:	3b205600 	blcc	81a998 <_etext+0x813480>
    5194:	3b540000 	blcc	150519c <_etext+0x14fdc84>
    5198:	00010000 	andeq	r0, r1, r0
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    519c:	003baa57 	eorseq	sl, fp, r7, asr sl
    51a0:	003bf800 	eorseq	pc, fp, r0, lsl #16
        length -= fill;
    51a4:	59000100 	stmdbpl	r0, {r8}

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    51a8:	00003c2a 	andeq	r3, r0, sl, lsr #24
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    51ac:	00003c72 	andeq	r3, r0, r2, ror ip
    51b0:	b4580001 	ldrblt	r0, [r8], #-1
    51b4:	d600003c 			; <UNDEFINED> instruction: 0xd600003c
    {
        sha256_process( ctx, input );
        length -= 64;
    51b8:	0100003c 	tsteq	r0, ip, lsr r0
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    51bc:	3d225700 	stccc	7, cr5, [r2, #-0]
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    51c0:	3d380000 	ldccc	0, cr0, [r8, #-0]
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    51c4:	00010000 	andeq	r0, r1, r0
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    51c8:	003d9258 	eorseq	r9, sp, r8, asr r2
    51cc:	003dbc00 	eorseq	fp, sp, r0, lsl #24
    51d0:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    51d4:	00003e0a 	andeq	r3, r0, sl, lsl #28
    51d8:	00003e2a 	andeq	r3, r0, sl, lsr #28
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    51dc:	7a500001 	bvc	14051e8 <_etext+0x13fdcd0>
    51e0:	9a00003e 	bls	52e0 <sha512_block+0xa0>
    {
        memcpy( (void *) (ctx->buffer + left),
    51e4:	0100003e 	tsteq	r0, lr, lsr r0
    51e8:	3eec5200 	cdpcc	2, 14, cr5, cr12, cr0, {0}
    51ec:	3f080000 	svccc	0x00080000
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
    51f0:	00010000 	andeq	r0, r1, r0
        input  += fill;
    51f4:	003f5653 	eorseq	r5, pc, r3, asr r6	; <UNPREDICTABLE>

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    51f8:	003f7a00 	eorseq	r7, pc, r0, lsl #20
        length -= fill;
        input  += fill;
    51fc:	52000100 	andpl	r0, r0, #0, 2

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    5200:	00003fee 	andeq	r3, r0, lr, ror #31
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5204:	0000401a 	andeq	r4, r0, sl, lsl r0
    {
        sha256_process( ctx, input );
    5208:	62530001 	subsvs	r0, r3, #1
    520c:	82000040 	andhi	r0, r0, #64	; 0x40
    5210:	01000040 	tsteq	r0, r0, asr #32
        length -= 64;
        input  += 64;
    5214:	40d85200 	sbcsmi	r5, r8, r0, lsl #4
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5218:	40ec0000 	rscmi	r0, ip, r0
    521c:	00010000 	andeq	r0, r1, r0
    5220:	00414853 	subeq	r4, r1, r3, asr r8
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    5224:	00417200 	subeq	r7, r1, r0, lsl #4
    }

    while( length >= 64 )
    5228:	59000100 	stmdbpl	r0, {r8}
    522c:	000041c2 	andeq	r4, r0, r2, asr #3
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    5230:	000041f0 	strdeq	r4, [r0], -r0
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    5234:	1e5c0001 	cdpne	0, 5, cr0, cr12, cr1, {0}
    5238:	66000042 	strvs	r0, [r0], -r2, asr #32
    523c:	01000042 	tsteq	r0, r2, asr #32
{
	return (x >> bits) | (x << (64 - bits));
}

void sha512_block(struct sha512_state *s, const uint8_t *blk)
{
    5240:	42b65800 	adcsmi	r5, r6, #0, 16
    5244:	42ea0000 	rscmi	r0, sl, #0
    5248:	00010000 	andeq	r0, r1, r0
    524c:	0043325a 	subeq	r3, r3, sl, asr r2

static inline uint64_t load64(const uint8_t *x)
{
	uint64_t r;

	r = *(x++);
    5250:	00435400 	subeq	r5, r3, r0, lsl #8
	r = (r << 8) | *(x++);
    5254:	5c000100 	stfpls	f0, [r0], {-0}
    5258:	000043a0 	andeq	r4, r0, r0, lsr #7
    525c:	000043c6 	andeq	r4, r0, r6, asr #7
    5260:	445a0001 	ldrbmi	r0, [sl], #-1
    5264:	66000044 	strvs	r0, [r0], -r4, asr #32
	r = (r << 8) | *(x++);
    5268:	01000044 	tsteq	r0, r4, asr #32
    526c:	44bc5400 	ldrtmi	r5, [ip], #1024	; 0x400
    5270:	44dc0000 	ldrbmi	r0, [ip], #0
    5274:	00010000 	andeq	r0, r1, r0
	r = (r << 8) | *(x++);
    5278:	00453051 	subeq	r3, r5, r1, asr r0
    527c:	00455000 	subeq	r5, r5, r0
    5280:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    5284:	000045a0 	andeq	r4, r0, r0, lsr #11
    5288:	000045c0 	andeq	r4, r0, r0, asr #11
    528c:	16530001 	ldrbne	r0, [r3], -r1
    5290:	2c000046 	stccs	0, cr0, [r0], {70}	; 0x46
    5294:	01000046 	tsteq	r0, r6, asr #32
	r = (r << 8) | *(x++);
    5298:	46885700 	strmi	r5, [r8], r0, lsl #14
    529c:	46a80000 	strtmi	r0, [r8], r0
    52a0:	00010000 	andeq	r0, r1, r0
    52a4:	00470256 	subeq	r0, r7, r6, asr r2
    52a8:	00472600 	subeq	r2, r7, r0, lsl #12
    52ac:	59000100 	stmdbpl	r0, {r8}
    52b0:	0000477c 	andeq	r4, r0, ip, ror r7
    52b4:	0000479c 	muleq	r0, ip, r7
	r = (r << 8) | *(x++);
    52b8:	d8580001 	ldmdale	r8, {r0}^
    52bc:	54000047 	strpl	r0, [r0], #-71	; 0x47
    52c0:	01000048 	tsteq	r0, r8, asr #32
    52c4:	48805800 	stmmi	r0, {fp, ip, lr}
    52c8:	48c20000 	stmiami	r2, {}^	; <UNPREDICTABLE>
    52cc:	00010000 	andeq	r0, r1, r0
	r = (r << 8) | *(x++);
    52d0:	0048f654 	subeq	pc, r8, r4, asr r6	; <UNPREDICTABLE>
    52d4:	00494a00 	subeq	r4, r9, r0, lsl #20
    52d8:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    52dc:	00004974 	andeq	r4, r0, r4, ror r9
    52e0:	000049bc 			; <UNDEFINED> instruction: 0x000049bc
    52e4:	f2570001 	vhadd.s16	d16, d7, d1
	r = (r << 8) | *(x++);
    52e8:	2c000049 	stccs	0, cr0, [r0], {73}	; 0x49
    52ec:	0100004a 	tsteq	r0, sl, asr #32
    52f0:	4a6e5300 	bmi	1b99ef8 <_etext+0x1b929e0>
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
		w[i] = load64(blk);
		blk += 8;
    52f4:	4ab00000 	bmi	fec052fc <BootRAM+0xdb75a9d>
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
    52f8:	00010000 	andeq	r0, r1, r0
	uint64_t w[16];
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
		w[i] = load64(blk);
    52fc:	004b0050 	subeq	r0, fp, r0, asr r0
{
	uint64_t w[16];
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
    5300:	004b2000 	subeq	r2, fp, r0
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    5304:	56000100 	strpl	r0, [r0], -r0, lsl #2
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
    5308:	00004b7a 	andeq	r4, r0, sl, ror fp
    530c:	00004b98 	muleq	r0, r8, fp
	c = s->h[2];
    5310:	125c0001 	subsne	r0, ip, #1
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    5314:	3200004c 	andcc	r0, r0, #76	; 0x4c
	b = s->h[1];
    5318:	0100004c 	tsteq	r0, ip, asr #32
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    531c:	4cca5000 	stclmi	0, cr5, [sl], {0}
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    5320:	4cee0000 	stclmi	0, cr0, [lr]
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    5324:	00010000 	andeq	r0, r1, r0
    5328:	004cee58 	subeq	lr, ip, r8, asr lr
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    532c:	004cfe00 	subeq	pc, ip, r0, lsl #28
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    5330:	7a000600 	bvc	6b38 <_printf_i+0x18>
    5334:	22007900 	andcs	r7, r0, #0, 18

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    5338:	004cfe9f 	umaaleq	pc, ip, pc, lr	; <UNPREDICTABLE>
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    533c:	004d3200 	subeq	r3, sp, r0, lsl #4
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
    5340:	74002a00 	strvc	r2, [r0], #-2560	; 0xa00
	f = s->h[5];
    5344:	14144500 	ldrne	r4, [r4], #-1280	; 0x500

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    5348:	231f1724 	tstcs	pc, #36, 14	; 0x900000
	e = s->h[4];
    534c:	74212520 	strtvc	r2, [r1], #-1312	; 0x520
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    5350:	14143600 	ldrne	r3, [r4], #-1536	; 0x600
    5354:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    5358:	27212517 			; <UNDEFINED> instruction: 0x27212517
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    535c:	14370074 	ldrtne	r0, [r7], #-116	; 0x74

	for (i = 0; i < 80; i++) {
    5360:	1f172414 	svcne	0x00172414
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
    5364:	21252023 	teqcs	r5, r3, lsr #32
	g = s->h[6];
    5368:	22007a27 	andcs	r7, r0, #159744	; 0x27000
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
    536c:	004d549f 	umaaleq	r5, sp, pc, r4	; <UNPREDICTABLE>
    5370:	004db600 	subeq	fp, sp, r0, lsl #12
	g = s->h[6];
	h = s->h[7];
    5374:	5a000100 	bpl	577c <sha512_get+0x20>
    5378:	00004de4 	andeq	r4, r0, r4, ror #27
    537c:	00004df0 	strdeq	r4, [r0], -r0
	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
    5380:	4c510001 	mrrcmi	0, 0, r0, r1, cr1
    5384:	6000004e 	andvs	r0, r0, lr, asr #32
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    5388:	0100004e 	tsteq	r0, lr, asr #32
    538c:	4ec05400 	cdpmi	4, 12, cr5, cr0, cr0, {0}
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    5390:	4ef00000 	cdpmi	0, 15, cr0, cr0, cr0, {0}
	h = s->h[7];
    5394:	00010000 	andeq	r0, r1, r0
    5398:	004f4856 	subeq	r4, pc, r6, asr r8	; <UNPREDICTABLE>

		/* Update round state */
		h = g;
		g = f;
		f = e;
		e = d + temp1;
    539c:	004f5a00 	subeq	r5, pc, r0, lsl #20
    53a0:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    53ac:	000037b0 			; <UNDEFINED> instruction: 0x000037b0
    53b0:	000037ea 	andeq	r3, r0, sl, ror #15
    53b4:	00760038 	rsbseq	r0, r6, r8, lsr r0
    53b8:	9121007b 	teqls	r1, fp, ror r0
    53bc:	1a067f94 	bne	1a5214 <_etext+0x19dcfc>
    53c0:	007b0076 	rsbseq	r0, fp, r6, ror r0
    53c4:	0076211a 	rsbseq	r2, r6, sl, lsl r1
    53c8:	1f14143d 	svcne	0x0014143d
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
    53cc:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
    53d0:	00762125 	rsbseq	r2, r6, r5, lsr #2
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    53d4:	1f141432 	svcne	0x00141432
    53d8:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    53dc:	76272125 	strtvc	r2, [r7], -r5, lsr #2
    53e0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    53e4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    53e8:	27212517 			; <UNDEFINED> instruction: 0x27212517
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    53ec:	37ea9f22 	strbcc	r9, [sl, r2, lsr #30]!
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    53f0:	38520000 	ldmdacc	r2, {}^	; <UNPREDICTABLE>
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    53f4:	00360000 	eorseq	r0, r6, r0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    53f8:	00760077 	rsbseq	r0, r6, r7, ror r0
    53fc:	1a007b21 	bne	24088 <_etext+0x1cb70>
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    5400:	00760077 	rsbseq	r0, r6, r7, ror r0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5404:	0077211a 	rsbseq	r2, r7, sl, lsl r1
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    5408:	1f14143d 	svcne	0x0014143d
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    540c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5410:	00772125 	rsbseq	r2, r7, r5, lsr #2
    5414:	1f141432 	svcne	0x00141432
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5418:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    541c:	77272125 	strvc	r2, [r7, -r5, lsr #2]!
    5420:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5424:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5428:	27212517 			; <UNDEFINED> instruction: 0x27212517
    542c:	38529f22 	ldmdacc	r2, {r1, r5, r8, r9, sl, fp, ip, pc}^

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    5430:	38ca0000 	stmiacc	sl, {}^	; <UNPREDICTABLE>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5434:	00360000 	eorseq	r0, r6, r0
    5438:	00770075 	rsbseq	r0, r7, r5, ror r0
    543c:	1a007621 	bne	22cc8 <_etext+0x1b7b0>

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    5440:	00770075 	rsbseq	r0, r7, r5, ror r0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5444:	0075211a 	rsbseq	r2, r5, sl, lsl r1
    5448:	1f14143d 	svcne	0x0014143d
    544c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5450:	00752125 	rsbseq	r2, r5, r5, lsr #2

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    5454:	1f141432 	svcne	0x00141432
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5458:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    545c:	75272125 	strvc	r2, [r7, #-293]!	; 0x125
    5460:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5464:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5468:	27212517 			; <UNDEFINED> instruction: 0x27212517
    546c:	38ca9f22 	stmiacc	sl, {r1, r5, r8, r9, sl, fp, ip, pc}^
    5470:	39400000 	stmdbcc	r0, {}^	; <UNPREDICTABLE>
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5474:	00360000 	eorseq	r0, r6, r0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5478:	00750078 	rsbseq	r0, r5, r8, ror r0
    547c:	1a007721 	bne	23108 <_etext+0x1bbf0>
    5480:	00750078 	rsbseq	r0, r5, r8, ror r0
    5484:	0078211a 	rsbseq	r2, r8, sl, lsl r1
    5488:	1f14143d 	svcne	0x0014143d
    548c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5490:	00782125 	rsbseq	r2, r8, r5, lsr #2
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
    5494:	1f141432 	svcne	0x00141432
    5498:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    549c:	78272125 	stmdavc	r7!, {r0, r2, r5, r8, sp}
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
    54a0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    54a4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
    54a8:	27212517 			; <UNDEFINED> instruction: 0x27212517
    54ac:	39409f22 	stmdbcc	r0, {r1, r5, r8, r9, sl, fp, ip, pc}^
    54b0:	39b00000 	ldmibcc	r0!, {}	; <UNPREDICTABLE>
    54b4:	00360000 	eorseq	r0, r6, r0
    54b8:	0078007a 	rsbseq	r0, r8, sl, ror r0
    54bc:	1a007521 	bne	22948 <_etext+0x1b430>
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    54c0:	0078007a 	rsbseq	r0, r8, sl, ror r0
	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
    54c4:	007a211a 	rsbseq	r2, sl, sl, lsl r1
    54c8:	1f14143d 	svcne	0x0014143d
    54cc:	17242023 	strne	r2, [r4, -r3, lsr #32]!
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    54d0:	007a2125 	rsbseq	r2, sl, r5, lsr #2
    54d4:	1f141432 	svcne	0x00141432
    54d8:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    54dc:	7a272125 	bvc	9cd978 <_etext+0x9c6460>
    54e0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54e4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    54e8:	27212517 			; <UNDEFINED> instruction: 0x27212517
    54ec:	39b09f22 	ldmibcc	r0!, {r1, r5, r8, r9, sl, fp, ip, pc}
    54f0:	3a240000 	bcc	9054f8 <_etext+0x8fdfe0>
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    54f4:	00360000 	eorseq	r0, r6, r0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54f8:	007a0071 	rsbseq	r0, sl, r1, ror r0
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    54fc:	1a007821 	bne	23588 <_etext+0x1c070>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5500:	007a0071 	rsbseq	r0, sl, r1, ror r0
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5504:	0071211a 	rsbseq	r2, r1, sl, lsl r1
    5508:	1f14143d 	svcne	0x0014143d
    550c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
    5510:	00712125 	rsbseq	r2, r1, r5, lsr #2
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    5514:	1f141432 	svcne	0x00141432
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
    5518:	17242023 	strne	r2, [r4, -r3, lsr #32]!
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    551c:	71272125 	teqvc	r7, r5, lsr #2
    5520:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
    5524:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5528:	27212517 			; <UNDEFINED> instruction: 0x27212517
    552c:	3a249f22 	bcc	92d1bc <_etext+0x925ca4>
    5530:	3a9c0000 	bcc	fe705538 <BootRAM+0xd675cd9>
    5534:	00360000 	eorseq	r0, r6, r0
    5538:	00710074 	rsbseq	r0, r1, r4, ror r0
    553c:	1a007a21 	bne	23dc8 <_etext+0x1c8b0>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5540:	00710074 	rsbseq	r0, r1, r4, ror r0

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5544:	0074211a 	rsbseq	r2, r4, sl, lsl r1
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5548:	1f14143d 	svcne	0x0014143d

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    554c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5550:	00742125 	rsbseq	r2, r4, r5, lsr #2

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5554:	1f141432 	svcne	0x00141432
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5558:	17242023 	strne	r2, [r4, -r3, lsr #32]!

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    555c:	74272125 	strtvc	r2, [r7], #-293	; 0x125
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5560:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5564:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5568:	27212517 			; <UNDEFINED> instruction: 0x27212517
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    556c:	3a9c9f22 	bcc	fe72d1fc <BootRAM+0xd69d99d>
    5570:	3b200000 	blcc	805578 <_etext+0x7fe060>

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5574:	00360000 	eorseq	r0, r6, r0
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5578:	00740070 	rsbseq	r0, r4, r0, ror r0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    557c:	1a007121 	bne	21a08 <_etext+0x1a4f0>
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5580:	00740070 	rsbseq	r0, r4, r0, ror r0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5584:	0070211a 	rsbseq	r2, r0, sl, lsl r1
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5588:	1f14143d 	svcne	0x0014143d
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    558c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
    5590:	00702125 	rsbseq	r2, r0, r5, lsr #2
    5594:	1f141432 	svcne	0x00141432
    5598:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    559c:	70272125 	eorvc	r2, r7, r5, lsr #2
    55a0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    55a4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55a8:	27212517 			; <UNDEFINED> instruction: 0x27212517

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55ac:	3b209f22 	blcc	82d23c <_etext+0x825d24>
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55b0:	3baa0000 	blcc	fea855b8 <BootRAM+0xd9f5d59>

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55b4:	00360000 	eorseq	r0, r6, r0
    55b8:	00700072 	rsbseq	r0, r0, r2, ror r0
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    55bc:	1a007421 	bne	22648 <_etext+0x1b130>

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55c0:	00700072 	rsbseq	r0, r0, r2, ror r0
    55c4:	0072211a 	rsbseq	r2, r2, sl, lsl r1
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    55c8:	1f14143d 	svcne	0x0014143d
    55cc:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    55d0:	00722125 	rsbseq	r2, r2, r5, lsr #2
    55d4:	1f141432 	svcne	0x00141432
    55d8:	17242023 	strne	r2, [r4, -r3, lsr #32]!

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55dc:	72272125 	eorvc	r2, r7, #1073741833	; 0x40000009
    55e0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
		const uint64_t temp2 = S0 + maj;
    55e4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    55e8:	27212517 			; <UNDEFINED> instruction: 0x27212517
    55ec:	3baa9f22 	blcc	feaad27c <BootRAM+0xda1da1d>

		/* Update round state */
		h = g;
		g = f;
		f = e;
		e = d + temp1;
    55f0:	3c2a0000 	stccc	0, cr0, [sl], #-0
    55f4:	00360000 	eorseq	r0, r6, r0
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
    55f8:	00720073 	rsbseq	r0, r2, r3, ror r0
    55fc:	1a007021 	bne	21688 <_etext+0x1a170>
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
    5600:	00720073 	rsbseq	r0, r2, r3, ror r0
    5604:	0073211a 	rsbseq	r2, r3, sl, lsl r1
    5608:	1f14143d 	svcne	0x0014143d
    560c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5610:	00732125 	rsbseq	r2, r3, r5, lsr #2
    5614:	1f141432 	svcne	0x00141432
    5618:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    561c:	73272125 	teqvc	r7, #1073741833	; 0x40000009
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5620:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5624:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
	s->h[1] += b;
    5628:	27212517 			; <UNDEFINED> instruction: 0x27212517
    562c:	3c2a9f22 	stccc	15, cr9, [sl], #-136	; 0xffffff78
    5630:	3cb40000 	ldccc	0, cr0, [r4]
	s->h[2] += c;
    5634:	00360000 	eorseq	r0, r6, r0
    5638:	0073007c 	rsbseq	r0, r3, ip, ror r0
    563c:	1a007221 	bne	21ec8 <_etext+0x1a9b0>
    5640:	0073007c 	rsbseq	r0, r3, ip, ror r0
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5644:	007c211a 	rsbseq	r2, ip, sl, lsl r1
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    5648:	1f14143d 	svcne	0x0014143d
	s->h[4] += e;
    564c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
    5650:	007c2125 	rsbseq	r2, ip, r5, lsr #2
	s->h[2] += c;
	s->h[3] += d;
    5654:	1f141432 	svcne	0x00141432
    5658:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    565c:	7c272125 	stfvcs	f2, [r7], #-148	; 0xffffff6c
	s->h[4] += e;
    5660:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
	s->h[5] += f;
	s->h[6] += g;
    5664:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
    5668:	27212517 			; <UNDEFINED> instruction: 0x27212517
    566c:	3cb49f22 	ldccc	15, cr9, [r4], #136	; 0x88
    5670:	3d220000 	stccc	0, cr0, [r2, #-0]
	s->h[6] += g;
    5674:	00360000 	eorseq	r0, r6, r0

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    5678:	007c0076 	rsbseq	r0, ip, r6, ror r0
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    567c:	1a007321 	bne	22308 <_etext+0x1adf0>
	s->h[7] += h;
    5680:	007c0076 	rsbseq	r0, ip, r6, ror r0
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5684:	0076211a 	rsbseq	r2, r6, sl, lsl r1
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    5688:	1f14143d 	svcne	0x0014143d
	s->h[7] += h;
    568c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5690:	00762125 	rsbseq	r2, r6, r5, lsr #2
    5694:	1f141432 	svcne	0x00141432
    5698:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
    569c:	76272125 	strtvc	r2, [r7], -r5, lsr #2
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    56a0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    56a4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    56a8:	27212517 			; <UNDEFINED> instruction: 0x27212517
	s->h[1] += b;
    56ac:	3d229f22 	stccc	15, cr9, [r2, #-136]!	; 0xffffff78
	s->h[2] += c;
	s->h[3] += d;
    56b0:	3d920000 	ldccc	0, cr0, [r2]
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
    56b4:	00360000 	eorseq	r0, r6, r0
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
    56b8:	0076007a 	rsbseq	r0, r6, sl, ror r0
	s->h[5] += f;
    56bc:	1a007c21 	bne	24748 <_etext+0x1d230>
	s->h[6] += g;
    56c0:	0076007a 	rsbseq	r0, r6, sl, ror r0
	s->h[7] += h;
    56c4:	007a211a 	rsbseq	r2, sl, sl, lsl r1
}
    56c8:	1f14143d 	svcne	0x0014143d
    56cc:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    56d0:	007a2125 	rsbseq	r2, sl, r5, lsr #2

void sha512_final(struct sha512_state *s, const uint8_t *blk,
		  size_t total_size)
{
    56d4:	1f141432 	svcne	0x00141432
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
    56d8:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	s->h[7] += h;
}

void sha512_final(struct sha512_state *s, const uint8_t *blk,
		  size_t total_size)
{
    56dc:	7a272125 	bvc	9cdb78 <_etext+0x9c6660>
    56e0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
    56e4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    56e8:	27212517 			; <UNDEFINED> instruction: 0x27212517
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
    56ec:	3d929f22 	ldccc	15, cr9, [r2, #136]	; 0x88
    56f0:	3e0a0000 	cdpcc	0, 0, cr0, cr10, cr0, {0}
		memcpy(temp, blk, last_size);
	temp[last_size] = 0x80;
    56f4:	00360000 	eorseq	r0, r6, r0

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    56f8:	007a0071 	rsbseq	r0, sl, r1, ror r0
    56fc:	1a007621 	bne	22f88 <_etext+0x1ba70>
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5700:	007a0071 	rsbseq	r0, sl, r1, ror r0
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
	sha512_block(s, temp);
    5704:	0071211a 	rsbseq	r2, r1, sl, lsl r1
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5708:	1f14143d 	svcne	0x0014143d
	v >>= 8;
	*(x--) = v;
    570c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	v >>= 8;
	*(x--) = v;
    5710:	00712125 	rsbseq	r2, r1, r5, lsr #2
	v >>= 8;
	*(x--) = v;
    5714:	1f141432 	svcne	0x00141432
	v >>= 8;
	*(x--) = v;
    5718:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	v >>= 8;
	*(x--) = v;
    571c:	71272125 	teqvc	r7, r5, lsr #2
	v >>= 8;
	*(x--) = v;
    5720:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
	v >>= 8;
	*(x--) = v;
    5724:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
	sha512_block(s, temp);
    5728:	27212517 			; <UNDEFINED> instruction: 0x27212517
}
    572c:	3e0a9f22 	cdpcc	15, 0, cr9, cr10, cr2, {1}
{
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
		memcpy(temp, blk, last_size);
    5730:	3e7a0000 	cdpcc	0, 7, cr0, cr10, cr0, {0}
    5734:	00360000 	eorseq	r0, r6, r0
    5738:	00710079 	rsbseq	r0, r1, r9, ror r0
	temp[last_size] = 0x80;
    573c:	1a007a21 	bne	23fc8 <_etext+0x1cab0>

	if (last_size > 111) {
    5740:	00710079 	rsbseq	r0, r1, r9, ror r0
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
		memcpy(temp, blk, last_size);
	temp[last_size] = 0x80;
    5744:	0079211a 	rsbseq	r2, r9, sl, lsl r1

	if (last_size > 111) {
		sha512_block(s, temp);
    5748:	1f14143d 	svcne	0x0014143d
    574c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
		memset(temp, 0, sizeof(temp));
    5750:	00792125 	rsbseq	r2, r9, r5, lsr #2
    5754:	1f141432 	svcne	0x00141432
    5758:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	sha512_block(s, temp);
}

void sha512_get(const struct sha512_state *s, uint8_t *hash,
		unsigned int offset, unsigned int len)
{
    575c:	79272125 	stmdbvc	r7!, {r0, r2, r5, r8, sp}
	int i;

	if (offset > SHA512_BLOCK_SIZE)
    5760:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
	sha512_block(s, temp);
}

void sha512_get(const struct sha512_state *s, uint8_t *hash,
		unsigned int offset, unsigned int len)
{
    5764:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
	int i;

	if (offset > SHA512_BLOCK_SIZE)
    5768:	27212517 			; <UNDEFINED> instruction: 0x27212517
		return;

	if (len > SHA512_BLOCK_SIZE - offset)
    576c:	3e7a9f22 	cdpcc	15, 7, cr9, cr10, cr2, {1}
    5770:	3eec0000 	cdpcc	0, 14, cr0, cr12, cr0, {0}
		len = SHA512_BLOCK_SIZE - offset;

	/* Skip whole words */
	i = offset >> 3;
    5774:	00360000 	eorseq	r0, r6, r0
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
    5778:	0079007c 	rsbseq	r0, r9, ip, ror r0

	if (len > SHA512_BLOCK_SIZE - offset)
		len = SHA512_BLOCK_SIZE - offset;

	/* Skip whole words */
	i = offset >> 3;
    577c:	1a007121 	bne	21c08 <_etext+0x1a6f0>
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
    5780:	0079007c 	rsbseq	r0, r9, ip, ror r0
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    5784:	007c211a 	rsbseq	r2, ip, sl, lsl r1
    5788:	1f14143d 	svcne	0x0014143d
    578c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5790:	007c2125 	rsbseq	r2, ip, r5, lsr #2
    5794:	1f141432 	svcne	0x00141432
    5798:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    579c:	7c272125 	stfvcs	f2, [r7], #-148	; 0xffffff6c
    57a0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    57a4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    57a8:	27212517 			; <UNDEFINED> instruction: 0x27212517
		store64(hash, s->h[i++]);
    57ac:	3eec9f22 	cdpcc	15, 14, cr9, cr12, cr2, {1}
    57b0:	3f560000 	svccc	0x00560000
    57b4:	00360000 	eorseq	r0, r6, r0

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    57b8:	007c0070 	rsbseq	r0, ip, r0, ror r0
    57bc:	1a007921 	bne	23c48 <_etext+0x1c730>
    57c0:	007c0070 	rsbseq	r0, ip, r0, ror r0
    57c4:	0070211a 	rsbseq	r2, r0, sl, lsl r1
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
		store64(hash, s->h[i++]);
    57c8:	1f14143d 	svcne	0x0014143d
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57cc:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	*(x--) = v;
	v >>= 8;
    57d0:	00702125 	rsbseq	r2, r0, r5, lsr #2
    57d4:	1f141432 	svcne	0x00141432
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57d8:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	*(x--) = v;
	v >>= 8;
    57dc:	70272125 	eorvc	r2, r7, r5, lsr #2
	*(x--) = v;
	v >>= 8;
    57e0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    57e4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
	*(x--) = v;
	v >>= 8;
    57e8:	27212517 			; <UNDEFINED> instruction: 0x27212517
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57ec:	3f569f22 	svccc	0x00569f22
	*(x--) = v;
	v >>= 8;
    57f0:	3fee0000 	svccc	0x00ee0000
	*(x--) = v;
	v >>= 8;
    57f4:	00360000 	eorseq	r0, r6, r0
    57f8:	00700076 	rsbseq	r0, r0, r6, ror r0
    57fc:	1a007c21 	bne	24888 <_etext+0x1d370>
	*(x--) = v;
	v >>= 8;
    5800:	00700076 	rsbseq	r0, r0, r6, ror r0
    5804:	0076211a 	rsbseq	r2, r6, sl, lsl r1
    5808:	1f14143d 	svcne	0x0014143d
    580c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5810:	00762125 	rsbseq	r2, r6, r5, lsr #2
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5814:	1f141432 	svcne	0x00141432
	*(x--) = v;
    5818:	17242023 	strne	r2, [r4, -r3, lsr #32]!
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    581c:	76272125 	strtvc	r2, [r7], -r5, lsr #2
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5820:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5824:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5828:	27212517 			; <UNDEFINED> instruction: 0x27212517
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    582c:	3fee9f22 	svccc	0x00ee9f22
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    5830:	40620000 	rsbmi	r0, r2, r0
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5834:	00360000 	eorseq	r0, r6, r0
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    5838:	00760077 	rsbseq	r0, r6, r7, ror r0
    583c:	1a007021 	bne	218c8 <_etext+0x1a3b0>
    5840:	00760077 	rsbseq	r0, r6, r7, ror r0
    5844:	0077211a 	rsbseq	r2, r7, sl, lsl r1
    5848:	1f14143d 	svcne	0x0014143d
    584c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5850:	00772125 	rsbseq	r2, r7, r5, lsr #2
    5854:	1f141432 	svcne	0x00141432
    5858:	17242023 	strne	r2, [r4, -r3, lsr #32]!
		hash += 8;
		len -= 8;
	}

	/* Read out bytes */
	if (len) {
    585c:	77272125 	strvc	r2, [r7, -r5, lsr #2]!
    5860:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
	}
}
    5864:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    5868:	27212517 			; <UNDEFINED> instruction: 0x27212517
    586c:	40629f22 	rsbmi	r9, r2, r2, lsr #30
    5870:	40d80000 	sbcsmi	r0, r8, r0

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5874:	00360000 	eorseq	r0, r6, r0
    5878:	00770075 	rsbseq	r0, r7, r5, ror r0
	*(x--) = v;
	v >>= 8;
    587c:	1a007621 	bne	23108 <_etext+0x1bbf0>
    5880:	00770075 	rsbseq	r0, r7, r5, ror r0
	*(x--) = v;
	v >>= 8;
    5884:	0075211a 	rsbseq	r2, r5, sl, lsl r1
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5888:	1f14143d 	svcne	0x0014143d
	*(x--) = v;
	v >>= 8;
    588c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5890:	00752125 	rsbseq	r2, r5, r5, lsr #2
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5894:	1f141432 	svcne	0x00141432
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5898:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    589c:	75272125 	strvc	r2, [r7, #-293]!	; 0x125
	*(x--) = v;
	v >>= 8;
    58a0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58a4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58a8:	27212517 			; <UNDEFINED> instruction: 0x27212517
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58ac:	40d89f22 	sbcsmi	r9, r8, r2, lsr #30
	*(x--) = v;
	v >>= 8;
    58b0:	41480000 	mrsmi	r0, (UNDEF: 72)
    58b4:	00360000 	eorseq	r0, r6, r0
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    58b8:	00750074 	rsbseq	r0, r5, r4, ror r0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58bc:	1a007721 	bne	23548 <_etext+0x1c030>
    58c0:	00750074 	rsbseq	r0, r5, r4, ror r0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58c4:	0074211a 	rsbseq	r2, r4, sl, lsl r1
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58c8:	1f14143d 	svcne	0x0014143d
    58cc:	17242023 	strne	r2, [r4, -r3, lsr #32]!
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d0:	00742125 	rsbseq	r2, r4, r5, lsr #2
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d4:	1f141432 	svcne	0x00141432
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d8:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58dc:	74272125 	strtvc	r2, [r7], #-293	; 0x125
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58e0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
		uint8_t tmp[8];
		unsigned int c = 8 - offset;
    58e4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58e8:	27212517 			; <UNDEFINED> instruction: 0x27212517
	v >>= 8;
	*(x--) = v;
    58ec:	41489f22 	cmpmi	r8, r2, lsr #30
	v >>= 8;
	*(x--) = v;
    58f0:	41c20000 	bicmi	r0, r2, r0
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58f4:	00360000 	eorseq	r0, r6, r0
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58f8:	00740071 	rsbseq	r0, r4, r1, ror r0
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58fc:	1a007521 	bne	22d88 <_etext+0x1b870>
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5900:	00740071 	rsbseq	r0, r4, r1, ror r0
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5904:	0071211a 	rsbseq	r2, r1, sl, lsl r1
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    5908:	1f14143d 	svcne	0x0014143d
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    590c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
		uint8_t tmp[8];
		unsigned int c = 8 - offset;
    5910:	00712125 	rsbseq	r2, r1, r5, lsr #2
    5914:	1f141432 	svcne	0x00141432
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5918:	17242023 	strne	r2, [r4, -r3, lsr #32]!
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    591c:	71272125 	teqvc	r7, r5, lsr #2
		memcpy(hash, tmp + offset, c);
		len -= c;
    5920:	14144600 	ldrne	r4, [r4], #-1536	; 0x600

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    5924:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
		len -= c;
    5928:	27212517 			; <UNDEFINED> instruction: 0x27212517

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    592c:	41c29f22 	bicmi	r9, r2, r2, lsr #30
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5930:	421e0000 	andsmi	r0, lr, #0

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    5934:	00360000 	eorseq	r0, r6, r0
		len -= c;
		hash += c;
    5938:	00710072 	rsbseq	r0, r1, r2, ror r0
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    593c:	1a007421 	bne	229c8 <_etext+0x1b4b0>
		memcpy(hash, tmp + offset, c);
		len -= c;
		hash += c;
    5940:	00710072 	rsbseq	r0, r1, r2, ror r0
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    5944:	0072211a 	rsbseq	r2, r2, sl, lsl r1
    5948:	1f14143d 	svcne	0x0014143d

	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
    594c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5950:	00722125 	rsbseq	r2, r2, r5, lsr #2
    5954:	1f141432 	svcne	0x00141432
    5958:	17242023 	strne	r2, [r4, -r3, lsr #32]!

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    595c:	72272125 	eorvc	r2, r7, #1073741833	; 0x40000009
    5960:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
	*(x--) = v;
	v >>= 8;
    5964:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5968:	27212517 			; <UNDEFINED> instruction: 0x27212517
	*(x--) = v;
	v >>= 8;
    596c:	421e9f22 	andsmi	r9, lr, #34, 30	; 0x88
    5970:	42b60000 	adcsmi	r0, r6, #0
	*(x--) = v;
	v >>= 8;
    5974:	00360000 	eorseq	r0, r6, r0
    5978:	00720073 	rsbseq	r0, r2, r3, ror r0
    597c:	1a007121 	bne	21e08 <_etext+0x1a8f0>
	*(x--) = v;
	v >>= 8;
    5980:	00720073 	rsbseq	r0, r2, r3, ror r0
    5984:	0073211a 	rsbseq	r2, r3, sl, lsl r1
	*(x--) = v;
	v >>= 8;
    5988:	1f14143d 	svcne	0x0014143d
    598c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	*(x--) = v;
	v >>= 8;
    5990:	00732125 	rsbseq	r2, r3, r5, lsr #2
    5994:	1f141432 	svcne	0x00141432
    5998:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	*(x--) = v;
	v >>= 8;
    599c:	73272125 	teqvc	r7, #1073741833	; 0x40000009
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    59a0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59a4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
	*(x--) = v;
	v >>= 8;
    59a8:	27212517 			; <UNDEFINED> instruction: 0x27212517
    59ac:	42b69f22 	adcsmi	r9, r6, #34, 30	; 0x88
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    59b0:	43320000 	teqmi	r2, #0
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59b4:	00360000 	eorseq	r0, r6, r0
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59b8:	00730070 	rsbseq	r0, r3, r0, ror r0
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59bc:	1a007221 	bne	22248 <_etext+0x1ad30>
    59c0:	00730070 	rsbseq	r0, r3, r0, ror r0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59c4:	0070211a 	rsbseq	r2, r0, sl, lsl r1
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59c8:	1f14143d 	svcne	0x0014143d
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59cc:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59d0:	00702125 	rsbseq	r2, r0, r5, lsr #2
	v >>= 8;
	*(x--) = v;
    59d4:	1f141432 	svcne	0x00141432
	v >>= 8;
	*(x--) = v;
    59d8:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    59dc:	70272125 	eorvc	r2, r7, r5, lsr #2
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59e0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59e4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    59e8:	27212517 			; <UNDEFINED> instruction: 0x27212517
	}
}
    59ec:	43329f22 	teqmi	r2, #34, 30	; 0x88
    59f0:	43a00000 	movmi	r0, #0
    for (i = 0; i < len; i++)
        uart_printf("%02x", data[i]);
    uart_printf("\n");
}

void failErase () {
    59f4:	00360000 	eorseq	r0, r6, r0
	// for whatever reason this only flashes upto 0x08008800
	flashErasePage((u32)(0x08008000));
    59f8:	00700076 	rsbseq	r0, r0, r6, ror r0
	flashErasePage((u32)(0x08008000+1024));
    59fc:	1a007321 	bne	22688 <_etext+0x1b170>
    5a00:	00700076 	rsbseq	r0, r0, r6, ror r0
	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
    5a04:	0076211a 	rsbseq	r2, r6, sl, lsl r1
	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
    5a08:	1f14143d 	svcne	0x0014143d
    5a0c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
    5a10:	00762125 	rsbseq	r2, r6, r5, lsr #2
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
}
    5a14:	1f141432 	svcne	0x00141432
	flashErasePage((u32)(0x08008000));
	flashErasePage((u32)(0x08008000+1024));
	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
    5a18:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5a1c:	76272125 	strtvc	r2, [r7], -r5, lsr #2
    5a20:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5a24:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5a28:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5a2c:	43a09f22 	movmi	r9, #34, 30	; 0x88
    5a30:	44440000 	strbmi	r0, [r4], #-0
    5a34:	00360000 	eorseq	r0, r6, r0
}

int imageCheckFromAddress(ImageObjectHandle *newHandle, vu32 flashAddress, bool shouldEraseFlashOnFail)
{
    5a38:	00760078 	rsbseq	r0, r6, r8, ror r0
    5a3c:	1a007021 	bne	21ac8 <_etext+0x1a5b0>
    5a40:	00760078 	rsbseq	r0, r6, r8, ror r0
    5a44:	0078211a 	rsbseq	r2, r8, sl, lsl r1
	ImageRootHeader		*hdr;
	ImageInternalState		state;
	int bufferSize = 0x28+0x40;
	unsigned char imageBuffer[bufferSize];
    memset(imageBuffer, 0xFF, sizeof(imageBuffer));
    5a48:	1f14143d 	svcne	0x0014143d
    5a4c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
    5a50:	00782125 	rsbseq	r2, r8, r5, lsr #2
    5a54:	1f141432 	svcne	0x00141432
    5a58:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    flashUnlock();
    5a5c:	78272125 	stmdavc	r7!, {r0, r2, r5, r8, sp}
    memset(&state, 0, sizeof(state));
    5a60:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5a64:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
		{
			failErase();
		}
		return(EINVAL);		/* buffer too small to really contain header */
	}
	if ((hdr->header.magic) != kImageHeaderMagic) {
    5a68:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5a6c:	44449f22 	strbmi	r9, [r4], #-3874	; 0xf22
			failErase();
		}
		*newHandle = &state;
		return(kImageImageMissingMagic);		/* magic must match */
	}
	if ((hdr->signing.imageType) != 0x45444f53)
    5a70:	44bc0000 	ldrtmi	r0, [ip], #0
    5a74:	00360000 	eorseq	r0, r6, r0
	{
		debug_print("bad magic 0x%08x expecting 0x%X\n", (hdr->signing.imageType), 0x45444f53);
		state.flags = kImageImageMissingMagic;
    5a78:	0078007c 	rsbseq	r0, r8, ip, ror r0
		if (shouldEraseFlashOnFail)
    5a7c:	1a007621 	bne	23308 <_etext+0x1bdf0>
    5a80:	0078007c 	rsbseq	r0, r8, ip, ror r0
		{
			failErase();
    5a84:	007c211a 	rsbseq	r2, ip, sl, lsl r1
		}
		*newHandle = &state;
		return(kImageImageMissingMagic);		/* magic must match */
    5a88:	1f14143d 	svcne	0x0014143d
	}
	state.flags = kImageImageWasInstantiated;
    5a8c:	17242023 	strne	r2, [r4, -r3, lsr #32]!

	debug_print("dataSize: 0x0%X\n", (0x08008000+(hdr->header.dataSize)));

	state.cursor = (hdr->header.dataSize)+0x200;
    5a90:	007c2125 	rsbseq	r2, ip, r5, lsr #2
    5a94:	1f141432 	svcne	0x00141432
	state.lastTag = -1;

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5a98:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5a9c:	7c272125 	stfvcs	f2, [r7], #-148	; 0xffffff6c
	state.flags = kImageImageWasInstantiated;

	debug_print("dataSize: 0x0%X\n", (0x08008000+(hdr->header.dataSize)));

	state.cursor = (hdr->header.dataSize)+0x200;
	state.lastTag = -1;
    5aa0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5aa4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f

    sha256_context ctx;
    sha256_starts(&ctx);
    5aa8:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5aac:	44bc9f22 	ldrtmi	r9, [ip], #3874	; 0xf22

    int buffSize = 0x4;
    char buff[buffSize];

    int i = 0x84;
    char cmpEnd[4] = {0x01, 0x00, 0x00, 0x00,}; 
    5ab0:	45300000 	ldrmi	r0, [r0, #-0]!
    hexdump((flashAddress+i), 0x20);
    5ab4:	00360000 	eorseq	r0, r6, r0

    int buffSize = 0x4;
    char buff[buffSize];

    int i = 0x84;
    char cmpEnd[4] = {0x01, 0x00, 0x00, 0x00,}; 
    5ab8:	007c0075 	rsbseq	r0, ip, r5, ror r0
    5abc:	1a007821 	bne	23b48 <_etext+0x1c630>
    5ac0:	007c0075 	rsbseq	r0, ip, r5, ror r0
    5ac4:	0075211a 	rsbseq	r2, r5, sl, lsl r1
    hexdump((flashAddress+i), 0x20);
    5ac8:	1f14143d 	svcne	0x0014143d
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), ((hdr->header.dataSize) - 0x40));
    while ((flashAddress+i) <= (flashAddress+state.cursor))
    5acc:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5ad0:	00752125 	rsbseq	r2, r5, r5, lsr #2
    5ad4:	1f141432 	svcne	0x00141432
    5ad8:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    {
      memset(buff, 0xFF, buffSize);
    5adc:	75272125 	strvc	r2, [r7, #-293]!	; 0x125
      memcpy(buff, (unsigned char *)(flashAddress+i), buffSize);
    5ae0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5ae4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5ae8:	27212517 			; <UNDEFINED> instruction: 0x27212517
      if ((memmem(&buff, buffSize, &cmpEnd, buffSize) > 0) && ((flashAddress + hdr->header.dataSize) - 0x40) < (vu32 *)(flashAddress+i)) // our end of image should be somewhere around here
    5aec:	45309f22 	ldrmi	r9, [r0, #-3874]!	; 0xf22
    5af0:	45a00000 	strmi	r0, [r0, #0]!
    5af4:	00360000 	eorseq	r0, r6, r0
    5af8:	00750074 	rsbseq	r0, r5, r4, ror r0
    5afc:	1a007c21 	bne	24b88 <_etext+0x1d670>
    5b00:	00750074 	rsbseq	r0, r5, r4, ror r0
      {
      	sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
    5b04:	0074211a 	rsbseq	r2, r4, sl, lsl r1
    5b08:	1f14143d 	svcne	0x0014143d
    5b0c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
      	debug_print("Hash Finish: %X\n", (flashAddress+i));
      	hexdump((flashAddress+i), 0xC);
    5b10:	00742125 	rsbseq	r2, r4, r5, lsr #2
    5b14:	1f141432 	svcne	0x00141432
    5b18:	17242023 	strne	r2, [r4, -r3, lsr #32]!
      	break;
      }
      sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
    5b1c:	74272125 	strtvc	r2, [r7], #-293	; 0x125
    5b20:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5b24:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
      i += 0x4;
    5b28:	27212517 			; <UNDEFINED> instruction: 0x27212517
	    uid_read(&id);
	    sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
	    sha256_update(&ctx, uniqueID, 0x17);
    } else {
    	// QEMU builds get FF ECIDs
    	memcpy(&uniqueID, (unsigned char*)"FFFFFFFFFFFFFFFFFFFFFFF", 0x17);
    5b2c:	45a09f22 	strmi	r9, [r0, #3874]!	; 0xf22
    5b30:	46160000 	ldrmi	r0, [r6], -r0
    5b34:	00360000 	eorseq	r0, r6, r0
    5b38:	00740072 	rsbseq	r0, r4, r2, ror r0
    5b3c:	1a007521 	bne	22fc8 <_etext+0x1bab0>
    5b40:	00740072 	rsbseq	r0, r4, r2, ror r0
    5b44:	0072211a 	rsbseq	r2, r2, sl, lsl r1
    5b48:	1f14143d 	svcne	0x0014143d
    5b4c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5b50:	00722125 	rsbseq	r2, r2, r5, lsr #2
	    sha256_update(&ctx, uniqueID, 0x17);
    5b54:	1f141432 	svcne	0x00141432
    5b58:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    }

    debug_print("%s\n", uniqueID);
    
    sha256_finish(&ctx, sha256sum);
    5b5c:	72272125 	eorvc	r2, r7, #1073741833	; 0x40000009
    5b60:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    print_hash(sha256sum);
    5b64:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5b68:	27212517 			; <UNDEFINED> instruction: 0x27212517
    // verify signature against recalc hash
    uint8_t sigbuff[0x40];
    memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
    5b6c:	46169f22 	ldrmi	r9, [r6], -r2, lsr #30
    5b70:	46880000 	strmi	r0, [r8], r0
    5b74:	00360000 	eorseq	r0, r6, r0
    5b78:	00720071 	rsbseq	r0, r2, r1, ror r0
    5b7c:	1a007421 	bne	22c08 <_etext+0x1b6f0>

    if (edsign_verify(sigbuff, rootCA, sha256sum, 32) <= 0) {
    5b80:	00720071 	rsbseq	r0, r2, r1, ror r0
    5b84:	0071211a 	rsbseq	r2, r1, sl, lsl r1
    5b88:	1f14143d 	svcne	0x0014143d
    5b8c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    	state.flags = kImageImageRejectSignature;
    5b90:	00712125 	rsbseq	r2, r1, r5, lsr #2
    	if (shouldEraseFlashOnFail)
    5b94:	1f141432 	svcne	0x00141432
		{
			failErase();
    5b98:	17242023 	strne	r2, [r4, -r3, lsr #32]!
		}
    	*newHandle = &state;
    5b9c:	71272125 	teqvc	r7, r5, lsr #2
    	return kImageImageRejectSignature;
    5ba0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    } else {
    	state.flags = kImageImageIsTrusted;
    	*newHandle = &state;
    	return kImageImageIsTrusted;
    5ba4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    }
	
	*newHandle = &state;
	return(0);
}
    5ba8:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5bac:	46889f22 	strmi	r9, [r8], r2, lsr #30
    5bb0:	47020000 	strmi	r0, [r2, -r0]
    5bb4:	00360000 	eorseq	r0, r6, r0
    5bb8:	00710073 	rsbseq	r0, r1, r3, ror r0
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxStatus(u8 bEpNum, u16 wState)
{
  _SetEPTxStatus(bEpNum, wState);
    5bbc:	1a007221 	bne	22448 <_etext+0x1af30>
    5bc0:	00710073 	rsbseq	r0, r1, r3, ror r0
    5bc4:	0073211a 	rsbseq	r2, r3, sl, lsl r1
    5bc8:	1f14143d 	svcne	0x0014143d
    5bcc:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5bd0:	00732125 	rsbseq	r2, r3, r5, lsr #2
    5bd4:	1f141432 	svcne	0x00141432
    5bd8:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5bdc:	73272125 	teqvc	r7, #1073741833	; 0x40000009
    5be0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5be4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxValid(u8 bEpNum)
{
  _SetEPRxStatus(bEpNum, EP_RX_VALID);
    5be8:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5bec:	47029f22 	strmi	r9, [r2, -r2, lsr #30]
    5bf0:	477c0000 	ldrbmi	r0, [ip, -r0]!
    5bf4:	00360000 	eorseq	r0, r6, r0
    5bf8:	00730070 	rsbseq	r0, r3, r0, ror r0
    5bfc:	1a007121 	bne	22088 <_etext+0x1ab70>
    5c00:	00730070 	rsbseq	r0, r3, r0, ror r0
* Output         : None.
* Return         : None.
*******************************************************************************/
void Clear_Status_Out(u8 bEpNum)
{
  _ClearEP_KIND(bEpNum);
    5c04:	0070211a 	rsbseq	r2, r0, sl, lsl r1
    5c08:	1f14143d 	svcne	0x0014143d
    5c0c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5c10:	00702125 	rsbseq	r2, r0, r5, lsr #2
    5c14:	1f141432 	svcne	0x00141432
    5c18:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5c1c:	70272125 	eorvc	r2, r7, r5, lsr #2
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_RX(u8 bEpNum)
{
  _ClearDTOG_RX(bEpNum);
    5c20:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5c24:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5c28:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5c2c:	477c9f22 	ldrbmi	r9, [ip, -r2, lsr #30]!
    5c30:	47d80000 	ldrbmi	r0, [r8, r0]
    5c34:	00360000 	eorseq	r0, r6, r0
    5c38:	00700076 	rsbseq	r0, r0, r6, ror r0
    5c3c:	1a007321 	bne	228c8 <_etext+0x1b3b0>
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_TX(u8 bEpNum)
{
  _ClearDTOG_TX(bEpNum);
    5c40:	00700076 	rsbseq	r0, r0, r6, ror r0
    5c44:	0076211a 	rsbseq	r2, r6, sl, lsl r1
    5c48:	1f14143d 	svcne	0x0014143d
    5c4c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5c50:	00762125 	rsbseq	r2, r6, r5, lsr #2
    5c54:	1f141432 	svcne	0x00141432
    5c58:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5c5c:	76272125 	strtvc	r2, [r7], -r5, lsr #2
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
u16 GetEPTxAddr(u8 bEpNum)
{
  return(_GetEPTxAddr(bEpNum));
    5c60:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5c64:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5c68:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5c6c:	47d89f22 	ldrbmi	r9, [r8, r2, lsr #30]
    5c70:	48800000 	stmmi	r0, {}	; <UNPREDICTABLE>
}
    5c74:	00360000 	eorseq	r0, r6, r0
    5c78:	0076007c 	rsbseq	r0, r6, ip, ror r0
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
u16 GetEPRxAddr(u8 bEpNum)
{
  return(_GetEPRxAddr(bEpNum));
    5c7c:	1a007021 	bne	21d08 <_etext+0x1a7f0>
    5c80:	0076007c 	rsbseq	r0, r6, ip, ror r0
    5c84:	007c211a 	rsbseq	r2, ip, sl, lsl r1
    5c88:	1f14143d 	svcne	0x0014143d
}
    5c8c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5c90:	007c2125 	rsbseq	r2, ip, r5, lsr #2
    5c94:	1f141432 	svcne	0x00141432
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxCount(u8 bEpNum, u16 wCount)
{
  _SetEPTxCount(bEpNum, wCount);
    5c98:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5c9c:	7c272125 	stfvcs	f2, [r7], #-148	; 0xffffff6c
    5ca0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5ca4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5ca8:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5cac:	48809f22 	stmmi	r0, {r1, r5, r8, r9, sl, fp, ip, pc}
    5cb0:	48f60000 	ldmmi	r6!, {}^	; <UNPREDICTABLE>
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxCount(u8 bEpNum, u16 wCount)
{
  _SetEPRxCount(bEpNum, wCount);
    5cb4:	00360000 	eorseq	r0, r6, r0
    5cb8:	007c0075 	rsbseq	r0, ip, r5, ror r0
    5cbc:	1a007621 	bne	23548 <_etext+0x1c030>
    5cc0:	007c0075 	rsbseq	r0, ip, r5, ror r0
    5cc4:	0075211a 	rsbseq	r2, r5, sl, lsl r1
    5cc8:	1f14143d 	svcne	0x0014143d
    5ccc:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5cd0:	00752125 	rsbseq	r2, r5, r5, lsr #2
    5cd4:	1f141432 	svcne	0x00141432
    5cd8:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5cdc:	75272125 	strvc	r2, [r7, #-293]!	; 0x125
    5ce0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5ce4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5ce8:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5cec:	48f69f22 	ldmmi	r6!, {r1, r5, r8, r9, sl, fp, ip, pc}^
    5cf0:	49740000 	ldmdbmi	r4!, {}^	; <UNPREDICTABLE>
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CTR_LP(void)
{
    5cf4:	00360000 	eorseq	r0, r6, r0
  u32 wEPVal = 0;
  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
    5cf8:	00750078 	rsbseq	r0, r5, r8, ror r0
    5cfc:	1a007c21 	bne	24d88 <_etext+0x1d870>
    5d00:	00750078 	rsbseq	r0, r5, r8, ror r0
    5d04:	0078211a 	rsbseq	r2, r8, sl, lsl r1
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
    5d08:	1f14143d 	svcne	0x0014143d
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
    5d0c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5d10:	00782125 	rsbseq	r2, r8, r5, lsr #2
    5d14:	1f141432 	svcne	0x00141432
    if (EPindex == 0)
    5d18:	17242023 	strne	r2, [r4, -r3, lsr #32]!
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */
      SaveRState = _GetEPRxStatus(ENDP0);
    5d1c:	78272125 	stmdavc	r7!, {r0, r2, r5, r8, sp}
      SaveTState = _GetEPTxStatus(ENDP0);
    5d20:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */
      SaveRState = _GetEPRxStatus(ENDP0);
    5d24:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
      SaveTState = _GetEPTxStatus(ENDP0);
    5d28:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5d2c:	49749f22 	ldmdbmi	r4!, {r1, r5, r8, r9, sl, fp, ip, pc}^
      _SetEPRxStatus(ENDP0, EP_RX_NAK);
    5d30:	49f20000 	ldmibmi	r2!, {}^	; <UNPREDICTABLE>
    5d34:	00360000 	eorseq	r0, r6, r0
    5d38:	00780072 	rsbseq	r0, r8, r2, ror r0
    5d3c:	1a007521 	bne	231c8 <_etext+0x1bcb0>
    5d40:	00780072 	rsbseq	r0, r8, r2, ror r0
      _SetEPTxStatus(ENDP0, EP_TX_NAK);
    5d44:	0072211a 	rsbseq	r2, r2, sl, lsl r1
    5d48:	1f14143d 	svcne	0x0014143d
    5d4c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5d50:	00722125 	rsbseq	r2, r2, r5, lsr #2


      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
    5d54:	1f141432 	svcne	0x00141432
    5d58:	17242023 	strne	r2, [r4, -r3, lsr #32]!

        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */

        wEPVal = _GetENDPOINT(ENDP0);
        if ((wEPVal & EP_CTR_TX) != 0)
    5d5c:	72272125 	eorvc	r2, r7, #1073741833	; 0x40000009
        {
          _ClearEP_CTR_TX(ENDP0);
    5d60:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5d64:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5d68:	27212517 			; <UNDEFINED> instruction: 0x27212517
          In0_Process();
    5d6c:	49f29f22 	ldmibmi	r2!, {r1, r5, r8, r9, sl, fp, ip, pc}^
          /* before terminate set Tx & Rx status */
          _SetEPRxStatus(ENDP0, SaveRState);
          _SetEPTxStatus(ENDP0, SaveTState);
          return;
        }
        else if ((wEPVal &EP_SETUP) != 0)
    5d70:	4a6e0000 	bmi	1b85d78 <_etext+0x1b7e860>
        {
          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
    5d74:	00360000 	eorseq	r0, r6, r0
    5d78:	00720071 	rsbseq	r0, r2, r1, ror r0
    5d7c:	1a007821 	bne	23e08 <_etext+0x1c8f0>
          Setup0_Process();
    5d80:	00720071 	rsbseq	r0, r2, r1, ror r0
          _SetEPRxStatus(ENDP0, SaveRState);
          _SetEPTxStatus(ENDP0, SaveTState);
          return;
        }

        else if ((wEPVal & EP_CTR_RX) != 0)
    5d84:	0071211a 	rsbseq	r2, r1, sl, lsl r1
        {
          _ClearEP_CTR_RX(ENDP0);
    5d88:	1f14143d 	svcne	0x0014143d
    5d8c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5d90:	00712125 	rsbseq	r2, r1, r5, lsr #2
          Out0_Process();
    5d94:	1f141432 	svcne	0x00141432
          /* before terminate set Tx & Rx status */
          _SetEPRxStatus(ENDP0, SaveRState);
    5d98:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5d9c:	71272125 	teqvc	r7, r5, lsr #2
    5da0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5da4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5da8:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5dac:	4a6e9f22 	bmi	1bada3c <_etext+0x1ba6524>
    5db0:	4b000000 	blmi	5db8 <CTR_LP+0xc4>
    5db4:	00360000 	eorseq	r0, r6, r0
          _SetEPTxStatus(ENDP0, SaveTState);
    5db8:	00710074 	rsbseq	r0, r1, r4, ror r0
    5dbc:	1a007221 	bne	22648 <_etext+0x1b130>
    5dc0:	00710074 	rsbseq	r0, r1, r4, ror r0
    5dc4:	0074211a 	rsbseq	r2, r4, sl, lsl r1
    5dc8:	1f14143d 	svcne	0x0014143d
    5dcc:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5dd0:	00742125 	rsbseq	r2, r4, r5, lsr #2
    5dd4:	1f141432 	svcne	0x00141432
          return;
    5dd8:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    else
    {
      /* Decode and service non control endpoints interrupt  */

      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
    5ddc:	74272125 	strtvc	r2, [r7], #-293	; 0x125
    5de0:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    5de4:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
      if ((wEPVal & EP_CTR_RX) != 0)
    5de8:	27212517 			; <UNDEFINED> instruction: 0x27212517
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
    5dec:	4b009f22 	blmi	2da7c <_etext+0x26564>
    5df0:	4b7a0000 	blmi	1e85df8 <_etext+0x1e7e8e0>

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
    5df4:	00400000 	subeq	r0, r0, r0
    5df8:	067f9491 			; <UNDEFINED> instruction: 0x067f9491
    5dfc:	71210074 	teqvc	r1, r4, ror r0

      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
    5e00:	94911a00 	ldrls	r1, [r1], #2560	; 0xa00
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
    5e04:	0074067f 	rsbseq	r0, r4, pc, ror r6
    5e08:	9491211a 	ldrls	r2, [r1], #282	; 0x11a
    5e0c:	143d067f 	ldrtne	r0, [sp], #-1663	; 0x67f
    5e10:	20231f14 	eorcs	r1, r3, r4, lsl pc
    5e14:	21251724 	teqcs	r5, r4, lsr #14
    5e18:	067f9491 			; <UNDEFINED> instruction: 0x067f9491

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
    5e1c:	1f141432 	svcne	0x00141432
    5e20:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5e24:	91272125 	teqls	r7, r5, lsr #2
    5e28:	46067f94 			; <UNDEFINED> instruction: 0x46067f94
    5e2c:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5e30:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5e34:	9f222721 	svcls	0x00222721
    5e38:	00004b7a 	andeq	r4, r0, sl, ror fp
    5e3c:	00004c12 	andeq	r4, r0, r2, lsl ip
    5e40:	98910044 	ldmls	r1, {r2, r6}
    5e44:	9491067f 	ldrls	r0, [r1], #1663	; 0x67f
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void USB_Init(void)
{
    5e48:	7421067f 	strtvc	r0, [r1], #-1663	; 0x67f
  pInformation = &Device_Info;
    5e4c:	98911a00 	ldmls	r1, {r9, fp, ip}
    5e50:	9491067f 	ldrls	r0, [r1], #1663	; 0x67f
  pInformation->ControlState = 2;
    5e54:	211a067f 	tstcs	sl, pc, ror r6
  pProperty = &Device_Property;
    5e58:	067f9891 			; <UNDEFINED> instruction: 0x067f9891
  pUser_Standard_Requests = &User_Standard_Requests;
    5e5c:	1f14143d 	svcne	0x0014143d
    5e60:	17242023 	strne	r2, [r4, -r3, lsr #32]!
  /* Initialize devices one by one */

  pProperty->Init();
    5e64:	98912125 	ldmls	r1, {r0, r2, r5, r8, sp}
    5e68:	1432067f 	ldrtne	r0, [r2], #-1663	; 0x67f
    5e6c:	20231f14 	eorcs	r1, r3, r4, lsl pc
    5e70:	21251724 	teqcs	r5, r4, lsr #14
    5e74:	7f989127 	svcvc	0x00989127
    5e78:	14144606 	ldrne	r4, [r4], #-1542	; 0x606
    5e7c:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
* Output         : None.
* Return         : Return 1 , if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
u8 *Standard_GetConfiguration(u16 Length)
{
    5e80:	27212517 			; <UNDEFINED> instruction: 0x27212517
  if (Length == 0)
    5e84:	4c129f22 	ldcmi	15, cr9, [r2], {34}	; 0x22
  {
    pInformation->Ctrl_Info.Usb_wLength =
    5e88:	4cca0000 	stclmi	0, cr0, [sl], {0}
      sizeof(pInformation->Current_Configuration);
    return 0;
    5e8c:	00460000 	subeq	r0, r6, r0
  }
  pUser_Standard_Requests->User_GetConfiguration();
    5e90:	067fa491 			; <UNDEFINED> instruction: 0x067fa491
    5e94:	067f9891 			; <UNDEFINED> instruction: 0x067f9891
  return (u8 *)&pInformation->Current_Configuration;
    5e98:	7f949121 	svcvc	0x00949121
}
    5e9c:	a4911a06 	ldrge	r1, [r1], #2566	; 0xa06
    5ea0:	9891067f 	ldmls	r1, {r0, r1, r2, r3, r4, r5, r6, r9, sl}
* Output         : None.
* Return         : Return 0, if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
u8 *Standard_GetInterface(u16 Length)
{
    5ea4:	211a067f 	tstcs	sl, pc, ror r6
  if (Length == 0)
    5ea8:	067fa491 			; <UNDEFINED> instruction: 0x067fa491
  {
    pInformation->Ctrl_Info.Usb_wLength =
    5eac:	1f14143d 	svcne	0x0014143d
      sizeof(pInformation->Current_AlternateSetting);
    return 0;
    5eb0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
  }
  pUser_Standard_Requests->User_GetInterface();
    5eb4:	a4912125 	ldrge	r2, [r1], #293	; 0x125
    5eb8:	1432067f 	ldrtne	r0, [r2], #-1663	; 0x67f
  return (u8 *)&pInformation->Current_AlternateSetting;
    5ebc:	20231f14 	eorcs	r1, r3, r4, lsl pc
}
    5ec0:	21251724 	teqcs	r5, r4, lsr #14
    5ec4:	7fa49127 	svcvc	0x00a49127
* Output         : None.
* Return         : Return 0, if the request is at end of data block,
*                  or is invalid when "Length" is 0.
*******************************************************************************/
u8 *Standard_GetStatus(u16 Length)
{
    5ec8:	14144606 	ldrne	r4, [r4], #-1542	; 0x606
  if (Length == 0)
    5ecc:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
    5ed0:	27212517 			; <UNDEFINED> instruction: 0x27212517
    return 0;
    5ed4:	4cca9f22 	stclmi	15, cr9, [sl], {34}	; 0x22
  }

  StatusInfo.w = 0;
  /* Reset Status Information */

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    5ed8:	4d540000 	ldclmi	0, cr0, [r4, #-0]
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
    return 0;
  }

  StatusInfo.w = 0;
    5edc:	00460000 	subeq	r0, r6, r0
  /* Reset Status Information */

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    5ee0:	067fa891 			; <UNDEFINED> instruction: 0x067fa891
    5ee4:	067fa491 			; <UNDEFINED> instruction: 0x067fa491
  {
    /*Get Device Status */
    u8 Feature = pInformation->Current_Feature;
    5ee8:	7f989121 	svcvc	0x00989121

    /* Remote Wakeup enabled */
    if (ValBit(Feature, 5))
    {
      SetBit(StatusInfo0, 1);
    5eec:	a8911a06 	ldmge	r1, {r1, r2, r9, fp, ip}
    5ef0:	a491067f 	ldrge	r0, [r1], #1663	; 0x67f
    }

    /* Bus-powered */
    if (ValBit(Feature, 6))
    5ef4:	211a067f 	tstcs	sl, pc, ror r6
    {
      ClrBit(StatusInfo0, 0);
    5ef8:	067fa891 			; <UNDEFINED> instruction: 0x067fa891
    5efc:	1f14143d 	svcne	0x0014143d
    }
    else /* Self-powered */
    {
      SetBit(StatusInfo0, 0);
    5f00:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    5f04:	a8912125 	ldmge	r1, {r0, r2, r5, r8, sp}
  {
    return (u8 *)&StatusInfo;
  }
  /*Get EndPoint Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    5f08:	1432067f 	ldrtne	r0, [r2], #-1663	; 0x67f
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;
    5f0c:	20231f14 	eorcs	r1, r3, r4, lsl pc

    Related_Endpoint = (wIndex0 & 0x0f);
    5f10:	21251724 	teqcs	r5, r4, lsr #14
    if (ValBit(wIndex0, 7))
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5f14:	7fa89127 	svcvc	0x00a89127
    5f18:	14144606 	ldrne	r4, [r4], #-1542	; 0x606
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;

    Related_Endpoint = (wIndex0 & 0x0f);
    if (ValBit(wIndex0, 7))
    5f1c:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5f20:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5f24:	4d549f22 	ldclmi	15, cr9, [r4, #-136]	; 0xffffff78
    5f28:	4de40000 	stclmi	0, cr0, [r4]
      {
        SetBit(StatusInfo0, 0); /* IN Endpoint stalled */
    5f2c:	00460000 	subeq	r0, r6, r0
    5f30:	067f9491 			; <UNDEFINED> instruction: 0x067f9491
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
    5f34:	067fa891 			; <UNDEFINED> instruction: 0x067fa891
    5f38:	7fa49121 	svcvc	0x00a49121
  }
  else
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
    5f3c:	94911a06 	ldrls	r1, [r1], #2566	; 0xa06
    5f40:	a891067f 	ldmge	r1, {r0, r1, r2, r3, r4, r5, r6, r9, sl}
  return (u8 *)&StatusInfo;
    5f44:	211a067f 	tstcs	sl, pc, ror r6
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
  {
    return (u8 *)&StatusInfo;
    5f48:	067f9491 			; <UNDEFINED> instruction: 0x067f9491
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
  return (u8 *)&StatusInfo;
}
    5f4c:	1f14143d 	svcne	0x0014143d
    5f50:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5f54:	94912125 	ldrls	r2, [r1], #293	; 0x125
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
    5f58:	1432067f 	ldrtne	r0, [r2], #-1663	; 0x67f
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
    5f5c:	20231f14 	eorcs	r1, r3, r4, lsl pc
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
    5f60:	21251724 	teqcs	r5, r4, lsr #14
  u32 save_wLength = pEPinfo->Usb_wLength;
  u32 ControlState = pInformation->ControlState;
    5f64:	7f949127 	svcvc	0x00949127

  u8 *DataBuffer;
  u32 Length;

  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
    5f68:	14144606 	ldrne	r4, [r4], #-1542	; 0x606
    5f6c:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
  {
    if(Data_Mul_MaxPacketSize == TRUE)
    5f70:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5f74:	4de49f22 	stclmi	15, cr9, [r4, #136]!	; 0x88
    {
      /* No more data to send and empty packet */
      Send0LengthData();
    5f78:	4e4c0000 	cdpmi	0, 4, cr0, cr12, cr0, {0}
    5f7c:	00460000 	subeq	r0, r6, r0
    5f80:	067fb091 			; <UNDEFINED> instruction: 0x067fb091
    5f84:	067f9491 			; <UNDEFINED> instruction: 0x067f9491
      ControlState = LAST_IN_DATA;
      Data_Mul_MaxPacketSize = FALSE;
    5f88:	7fa89121 	svcvc	0x00a89121
    }
    else
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
      vSetEPTxStatus(EP_TX_STALL);
    5f8c:	b0911a06 	addslt	r1, r1, r6, lsl #20
      Data_Mul_MaxPacketSize = FALSE;
    }
    else
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
    5f90:	9491067f 	ldrls	r0, [r1], #1663	; 0x67f
    }

    goto Expect_Status_Out;
  }

  Length = pEPinfo->PacketSize;
    5f94:	211a067f 	tstcs	sl, pc, ror r6
  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
    5f98:	067fb091 			; <UNDEFINED> instruction: 0x067fb091
    5f9c:	1f14143d 	svcne	0x0014143d
  if (Length > save_wLength)
  {
    Length = save_wLength;
  }

  DataBuffer = (*pEPinfo->CopyData)(Length);
    5fa0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5fa4:	b0912125 	addslt	r2, r1, r5, lsr #2
    5fa8:	1432067f 	ldrtne	r0, [r2], #-1663	; 0x67f

  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
    5fac:	20231f14 	eorcs	r1, r3, r4, lsl pc
    5fb0:	21251724 	teqcs	r5, r4, lsr #14
    5fb4:	7fb09127 	svcvc	0x00b09127
    5fb8:	14144606 	ldrne	r4, [r4], #-1542	; 0x606

  SetEPTxCount(ENDP0, Length);
    5fbc:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5fc0:	27212517 			; <UNDEFINED> instruction: 0x27212517

  pEPinfo->Usb_wLength -= Length;
    5fc4:	4e4c9f22 	cdpmi	15, 4, cr9, cr12, cr2, {1}
  pEPinfo->Usb_wOffset += Length;
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */
    5fc8:	4ec00000 	cdpmi	0, 12, cr0, cr0, cr0, {0}

  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
    5fcc:	003c0000 	eorseq	r0, ip, r0
  pEPinfo->Usb_wOffset += Length;
    5fd0:	b0910073 	addslt	r0, r1, r3, ror r0
  vSetEPTxStatus(EP_TX_VALID);
    5fd4:	9121067f 	teqls	r1, pc, ror r6
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
  pEPinfo->Usb_wOffset += Length;
    5fd8:	1a067f94 	bne	1a5e30 <_etext+0x19e918>
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */

Expect_Status_Out:
  pInformation->ControlState = ControlState;
    5fdc:	b0910073 	addslt	r0, r1, r3, ror r0
    5fe0:	211a067f 	tstcs	sl, pc, ror r6
    5fe4:	143d0073 	ldrtne	r0, [sp], #-115	; 0x73
    5fe8:	20231f14 	eorcs	r1, r3, r4, lsl pc
    5fec:	21251724 	teqcs	r5, r4, lsr #14
    5ff0:	14320073 	ldrtne	r0, [r2], #-115	; 0x73
    5ff4:	20231f14 	eorcs	r1, r3, r4, lsl pc
    5ff8:	21251724 	teqcs	r5, r4, lsr #14
    5ffc:	46007327 	strmi	r7, [r0], -r7, lsr #6
* Output         : None.
* Return         : Return USB_SUCCESS, if the request is performed.
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{
    6000:	231f1414 	tstcs	pc, #20, 8	; 0x14000000

  if ((pInformation->USBwValue0 <=
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
    6004:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{

  if ((pInformation->USBwValue0 <=
    6008:	9f222721 	svcls	0x00222721
    600c:	00004ec0 	andeq	r4, r0, r0, asr #29
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
    6010:	00004f3c 	andeq	r4, r0, ip, lsr pc
      && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
    6014:	00710038 	rsbseq	r0, r1, r8, lsr r0
  {
    pInformation->Current_Configuration = pInformation->USBwValue0;
    6018:	91210073 	teqls	r1, r3, ror r0
    pUser_Standard_Requests->User_SetConfiguration();
    601c:	1a067fb0 	bne	1a5ee4 <_etext+0x19e9cc>
    6020:	00730071 	rsbseq	r0, r3, r1, ror r0
    return USB_SUCCESS;
    6024:	0071211a 	rsbseq	r2, r1, sl, lsl r1
  }
  else
  {
    return USB_UNSUPPORT;
  }
}
    6028:	1f14143d 	svcne	0x0014143d
    602c:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    6030:	00712125 	rsbseq	r2, r1, r5, lsr #2
    6034:	1f141432 	svcne	0x00141432
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetInterface(void)
{
    6038:	17242023 	strne	r2, [r4, -r3, lsr #32]!
  RESULT Re;
  /*Test if the specified Interface and Alternate Setting are supported by
    the application Firmware*/
  Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
    603c:	71272125 	teqvc	r7, r5, lsr #2
    6040:	14144600 	ldrne	r4, [r4], #-1536	; 0x600
    6044:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    6048:	27212517 			; <UNDEFINED> instruction: 0x27212517

  if (pInformation->Current_Configuration != 0)
    604c:	00009f22 	andeq	r9, r0, r2, lsr #30
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
    6050:	00000000 	andeq	r0, r0, r0
    6054:	30ce0000 	sbccc	r0, lr, r0
        || (pInformation->USBwValue1 != 0))
    6058:	31040000 	mrscc	r0, (UNDEF: 4)
    {
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
    605c:	00060000 	andeq	r0, r6, r0
    6060:	93049359 	movwls	r9, #17241	; 0x4359
      pInformation->Current_Interface = pInformation->USBwIndex0;
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
      return USB_SUCCESS;
    6064:	310401fc 	strdcc	r0, [r4, -ip]
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
      pInformation->Current_Interface = pInformation->USBwIndex0;
    6068:	31080000 	mrscc	r0, (UNDEF: 8)
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
    606c:	00090000 	andeq	r0, r9, r0
      return USB_SUCCESS;
    }

  }

  return USB_UNSUPPORT;
    6070:	54049359 	strpl	r9, [r4], #-857	; 0x359
}
    6074:	f8930493 			; <UNDEFINED> instruction: 0xf8930493
    6078:	00310801 	eorseq	r0, r1, r1, lsl #16
    607c:	00311800 	eorseq	r1, r1, r0, lsl #16
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_ClearFeature(void)
{
    6080:	59000b00 	stmdbpl	r0, {r8, r9, fp}
  u32     Type_Rec = Type_Recipient;
    6084:	a4910493 	ldrge	r0, [r1], #1171	; 0x493
  u32     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6088:	9304937f 	movwls	r9, #17279	; 0x437f
    608c:	311801f8 			; <UNDEFINED> instruction: 0x311801f8
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
    6090:	316e0000 	cmncc	lr, r0
    6094:	000c0000 	andeq	r0, ip, r0
    return USB_SUCCESS;
  }
  else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    6098:	04935c91 	ldreq	r5, [r3], #3217	; 0xc91
    DEVICE* pDev;
    u32 Related_Endpoint;
    u32 wIndex0;
    u32 rEP;

    if ((pInformation->USBwValue != ENDPOINT_STALL)
    609c:	937fa491 	cmnls	pc, #-1862270976	; 0x91000000
    60a0:	01f89304 	mvnseq	r9, r4, lsl #6
        || (pInformation->USBwIndex1 != 0))
    60a4:	0000316e 	andeq	r3, r0, lr, ror #2
    {
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    60a8:	0000318c 	andeq	r3, r0, ip, lsl #3
    rEP = wIndex0 & ~0x80;
    60ac:	5c91000f 	ldcpl	0, cr0, [r1], {15}
    60b0:	a4910493 	ldrge	r0, [r1], #1171	; 0x493

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
    60b4:	5404937f 	strpl	r9, [r4], #-895	; 0x37f
    60b8:	f4930493 			; <UNDEFINED> instruction: 0xf4930493
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    60bc:	00318c01 	eorseq	r8, r1, r1, lsl #24
    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    rEP = wIndex0 & ~0x80;
    Related_Endpoint = ENDP0 + rEP;

    if (ValBit(pInformation->USBwIndex0, 7))
    60c0:	00319200 	eorseq	r9, r1, r0, lsl #4
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
    60c4:	91000f00 	tstls	r0, r0, lsl #30
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    60c8:	9104935c 	tstls	r4, ip, asr r3
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    60cc:	04937fa4 	ldreq	r7, [r3], #4004	; 0xfa4
    60d0:	93049357 	movwls	r9, #17239	; 0x4357
        || (pInformation->Current_Configuration == 0))
    60d4:	319201f4 			; <UNDEFINED> instruction: 0x319201f4


    if (wIndex0 & 0x80)
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    60d8:	31da0000 	bicscc	r0, sl, r0
    60dc:	00110000 	andseq	r0, r1, r0
    {
      return USB_UNSUPPORT;
    }


    if (wIndex0 & 0x80)
    60e0:	04935c91 	ldreq	r5, [r3], #3217	; 0xc91
    60e4:	937fa491 	cmnls	pc, #-1862270976	; 0x91000000
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    60e8:	7fa89104 	svcvc	0x00a89104
    60ec:	f4930493 			; <UNDEFINED> instruction: 0xf4930493
      {
        ClearDTOG_TX(Related_Endpoint);
    60f0:	0031da01 	eorseq	sp, r1, r1, lsl #20
    60f4:	0031ea00 	eorseq	lr, r1, r0, lsl #20
        SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
    60f8:	91001400 	tstls	r0, r0, lsl #8
    60fc:	9104935c 	tstls	r4, ip, asr r3
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
    6100:	04937fa4 	ldreq	r7, [r3], #4004	; 0xfa4
    6104:	937fa891 	cmnls	pc, #9502720	; 0x910000
    6108:	04935404 	ldreq	r5, [r3], #1028	; 0x404
      {
        if (Related_Endpoint == ENDP0)
        {
          /* After clear the STALL, enable the default endpoint receiver */
          SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
    610c:	ea01f093 	b	82360 <_etext+0x7ae48>
    6110:	f4000031 	vst4.8	{d0-d3}, [r0 :256], r1
    6114:	14000031 	strne	r0, [r0], #-49	; 0x31
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
        }
        else
        {
          ClearDTOG_RX(Related_Endpoint);
    6118:	935c9100 	cmpls	ip, #0, 2
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
    611c:	7fa49104 	svcvc	0x00a49104
    6120:	a8910493 	ldmge	r1, {r0, r1, r4, r7, sl}
    6124:	5304937f 	movwpl	r9, #17279	; 0x437f
    6128:	f0930493 			; <UNDEFINED> instruction: 0xf0930493
    612c:	0031f401 	eorseq	pc, r1, r1, lsl #8
        }
      }
    }
    pUser_Standard_Requests->User_ClearFeature();
    6130:	00325a00 	eorseq	r5, r2, r0, lsl #20
    6134:	91001600 	tstls	r0, r0, lsl #12
    return USB_SUCCESS;
    6138:	9104935c 	tstls	r4, ip, asr r3
  }

  return USB_UNSUPPORT;
}
    613c:	04937fa4 	ldreq	r7, [r3], #4004	; 0xfa4
    6140:	937fa891 	cmnls	pc, #9502720	; 0x910000
    6144:	7fac9104 	svcvc	0x00ac9104
    6148:	f0930493 			; <UNDEFINED> instruction: 0xf0930493
    614c:	00325a01 	eorseq	r5, r2, r1, lsl #20
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetEndPointFeature(void)
{
    6150:	00326400 	eorseq	r6, r2, r0, lsl #8
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    6154:	91001900 	tstls	r0, r0, lsl #18
    6158:	9104935c 	tstls	r4, ip, asr r3
  u32    Related_Endpoint;
  u32    rEP;
  u32   Status;

  wIndex0 = pInformation->USBwIndex0;
  rEP = wIndex0 & ~0x80;
    615c:	04937fa4 	ldreq	r7, [r3], #4004	; 0xfa4
    6160:	937fa891 	cmnls	pc, #9502720	; 0x910000

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
    6164:	7fac9104 	svcvc	0x00ac9104
    6168:	93580493 	cmpls	r8, #-1828716544	; 0x93000000

  wIndex0 = pInformation->USBwIndex0;
  rEP = wIndex0 & ~0x80;
  Related_Endpoint = ENDP0 + rEP;

  if (ValBit(pInformation->USBwIndex0, 7))
    616c:	01ec9304 	mvneq	r9, r4, lsl #6
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
    6170:	00003264 	andeq	r3, r0, r4, ror #4
    6174:	000032ee 	andeq	r3, r0, lr, ror #5
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
    6178:	5c91001b 	ldcpl	0, cr0, [r1], {27}
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    617c:	a4910493 	ldrge	r0, [r1], #1171	; 0x493
      || pInformation->USBwValue != 0 || Status == 0
    6180:	9104937f 	tstls	r4, pc, ror r3
      || pInformation->Current_Configuration == 0)
    6184:	04937fa8 	ldreq	r7, [r3], #4008	; 0xfa8
  else
  {
    if (wIndex0 & 0x80)
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6188:	937fac91 	cmnls	pc, #37120	; 0x9100
    618c:	7fb09104 	svcvc	0x00b09104
  {
    return USB_UNSUPPORT;
  }
  else
  {
    if (wIndex0 & 0x80)
    6190:	ec930493 	cfldrs	mvf0, [r3], {147}	; 0x93
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6194:	0032ee01 	eorseq	lr, r2, r1, lsl #28
    6198:	00336a00 	eorseq	r6, r3, r0, lsl #20
    619c:	91002000 	mrsls	r2, (UNDEF: 0)
    61a0:	9104935c 	tstls	r4, ip, asr r3
    61a4:	04937fa4 	ldreq	r7, [r3], #4004	; 0xfa4
    }

    else
    {
      /* OUT endpoint */
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    61a8:	937fa891 	cmnls	pc, #9502720	; 0x910000
    61ac:	7fac9104 	svcvc	0x00ac9104
    61b0:	b0910493 	umullslt	r0, r1, r3, r4
    61b4:	9104937f 	tstls	r4, pc, ror r3
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
    61b8:	04937fb4 	ldreq	r7, [r3], #4020	; 0xfb4
    61bc:	6a01e893 	bvs	80410 <_etext+0x78ef8>
  return USB_SUCCESS;
    61c0:	6e000033 	mcrvs	0, 0, r0, cr0, cr3, {1}

  if (Related_Endpoint >= Device_Table.Total_Endpoint
      || pInformation->USBwValue != 0 || Status == 0
      || pInformation->Current_Configuration == 0)
  {
    return USB_UNSUPPORT;
    61c4:	23000033 	movwcs	r0, #51	; 0x33
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
  return USB_SUCCESS;
}
    61c8:	935c9100 	cmpls	ip, #0, 2
    61cc:	7fa49104 	svcvc	0x00a49104
    61d0:	a8910493 	ldmge	r1, {r0, r1, r4, r7, sl}
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetDeviceFeature(void)
{
    61d4:	9104937f 	tstls	r4, pc, ror r3
  SetBit(pInformation->Current_Feature, 5);
    61d8:	04937fac 	ldreq	r7, [r3], #4012	; 0xfac
    61dc:	937fb091 	cmnls	pc, #145	; 0x91
    61e0:	7fb49104 	svcvc	0x00b49104
  pUser_Standard_Requests->User_SetDeviceFeature();
    61e4:	935b0493 	cmpls	fp, #-1828716544	; 0x93000000
    61e8:	01e49304 	mvneq	r9, r4, lsl #6
  return USB_SUCCESS;
}
    61ec:	0000336e 	andeq	r3, r0, lr, ror #6
    61f0:	000033ea 	andeq	r3, r0, sl, ror #7
    61f4:	5c910025 	ldcpl	0, cr0, [r1], {37}	; 0x25
*******************************************************************************/
u8 *Standard_GetDescriptorData(u16 Length, ONE_DESCRIPTOR *pDesc)
{
  u32  wOffset;

  wOffset = pInformation->Ctrl_Info.Usb_wOffset;
    61f8:	a4910493 	ldrge	r0, [r1], #1171	; 0x493
    61fc:	9104937f 	tstls	r4, pc, ror r3
  if (Length == 0)
  {
    pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
    6200:	04937fa8 	ldreq	r7, [r3], #4008	; 0xfa8
    6204:	937fac91 	cmnls	pc, #37120	; 0x9100
    return 0;
  }

  return pDesc->Descriptor + wOffset;
    6208:	7fb09104 	svcvc	0x00b09104
}
    620c:	b4910493 	ldrlt	r0, [r1], #1171	; 0x493
    6210:	9104937f 	tstls	r4, pc, ror r3
* Output         : None.
* Return         : - 0 if the control State is in PAUSE
*                  - 1 if not.
*******************************************************************************/
u8 Post0_Process(void)
{
    6214:	04937fb8 	ldreq	r7, [r3], #4024	; 0xfb8
  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
    6218:	ea01e493 	b	7f46c <_etext+0x77f54>
    621c:	0a000033 	beq	62f0 <Setup0_Process+0x9c>
    6220:	28000034 	stmdacs	r0, {r2, r4, r5}

  if (pInformation->ControlState == STALLED)
    6224:	935c9100 	cmpls	ip, #0, 2
    6228:	7fa49104 	svcvc	0x00a49104
  {
    vSetEPRxStatus(EP_RX_STALL);
    622c:	a8910493 	ldmge	r1, {r0, r1, r4, r7, sl}
    6230:	9104937f 	tstls	r4, pc, ror r3
    vSetEPTxStatus(EP_TX_STALL);
    6234:	04937fac 	ldreq	r7, [r3], #4012	; 0xfac
    6238:	937fb091 	cmnls	pc, #145	; 0x91
  }

  return (pInformation->ControlState == PAUSE);
}
    623c:	7fb49104 	svcvc	0x00b49104
    6240:	b8910493 	ldmlt	r1, {r0, r1, r4, r7, sl}
    6244:	5b04937f 	blpl	12b048 <_etext+0x123b30>
    6248:	e0930493 	umulls	r0, r3, r3, r4
    624c:	00340a01 	eorseq	r0, r4, r1, lsl #20
    6250:	0038e600 	eorseq	lr, r8, r0, lsl #12
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 Setup0_Process(void)
{
    6254:	91002a00 	tstls	r0, r0, lsl #20
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    6258:	9104935c 	tstls	r4, ip, asr r3

  if (pInformation->ControlState != PAUSE)
    625c:	04937fa4 	ldreq	r7, [r3], #4004	; 0xfa4
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    6260:	937fa891 	cmnls	pc, #9502720	; 0x910000
    6264:	7fac9104 	svcvc	0x00ac9104

  if (pInformation->ControlState != PAUSE)
    6268:	b0910493 	umullslt	r0, r1, r3, r4
    626c:	9104937f 	tstls	r4, pc, ror r3
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    6270:	04937fb4 	ldreq	r7, [r3], #4020	; 0xfb4
    6274:	937fb891 	cmnls	pc, #9502720	; 0x910000
    6278:	7fbc9104 	svcvc	0x00bc9104

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
    627c:	e0930493 	umulls	r0, r3, r3, r4
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
    6280:	0038e601 	eorseq	lr, r8, r1, lsl #12
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = *pBuf.w++; /* wValue in Little Endian */
    6284:	00394e00 	eorseq	r4, r9, r0, lsl #28
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = *pBuf.w++; /* wIndex in Little Endian */
    6288:	91005900 	tstls	r0, r0, lsl #18
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwLength = *pBuf.w; /* wLength in Little Endian */
    628c:	f304935c 	vcge.u8	<illegal reg q4.5>, q2, q6
  }

  pInformation->ControlState = SETTING_UP;
    6290:	04235101 	strteq	r5, [r3], #-257	; 0x101
  if (pInformation->USBwLength == 0)
    6294:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6298:	f324481a 	vceq.i32	d4, d4, d10
{
  RESULT Result = USB_UNSUPPORT;
  u32 RequestNo = pInformation->USBbRequest;
  u32 ControlState;

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    629c:	05235101 	streq	r5, [r3, #-257]!	; 0x101
    62a0:	ff080194 			; <UNDEFINED> instruction: 0xff080194
  {
    /* Device Request*/
    /* SET_CONFIGURATION*/
    if (RequestNo == SET_CONFIGURATION)
    62a4:	2124401a 	teqcs	r4, sl, lsl r0
    {
      Result = Standard_SetConfiguration();
    62a8:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    62ac:	08019406 	stmdaeq	r1, {r1, r2, sl, ip, pc}
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
    62b0:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
    62b4:	5101f321 	tstpl	r1, r1, lsr #6
          || (pInformation->USBwIndex != 0)
          || (pInformation->Current_Configuration != 0))
        /* Device Address should be 127 or less*/
      {
        ControlState = STALLED;
    62b8:	01940723 	orrseq	r0, r4, r3, lsr #14
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
    62bc:	211aff08 	tstcs	sl, r8, lsl #30
    62c0:	9104939f 			; <UNDEFINED> instruction: 0x9104939f
          || (pInformation->USBwIndex != 0)
    62c4:	04937fa8 	ldreq	r7, [r3], #4008	; 0xfa8
          || (pInformation->Current_Configuration != 0))
    62c8:	937fac91 	cmnls	pc, #37120	; 0x9100
    62cc:	7fb09104 	svcvc	0x00b09104
      {
        Result = USB_SUCCESS;
      }
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    62d0:	b4910493 	ldrlt	r0, [r1], #1171	; 0x493
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
    62d4:	9104937f 	tstls	r4, pc, ror r3
    62d8:	04937fb8 	ldreq	r7, [r3], #4024	; 0xfb8
  }


  if (Result != USB_SUCCESS)
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    62dc:	937fbc91 	cmnls	pc, #37120	; 0x9100
    62e0:	01e09304 	mvneq	r9, r4, lsl #6
    if (Result == USB_NOT_READY)
    62e4:	0000394e 	andeq	r3, r0, lr, asr #18
    62e8:	000039ca 	andeq	r3, r0, sl, asr #19
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
          && (pInformation->USBwIndex == 0)
    62ec:	5c910088 	ldcpl	0, cr0, [r1], {136}	; 0x88
          && (ValBit(pInformation->Current_Feature, 5)))
    62f0:	01f30493 			; <UNDEFINED> instruction: 0x01f30493
    62f4:	94042351 	strls	r2, [r4], #-849	; 0x351
      {
        Result = Standard_SetDeviceFeature();
    62f8:	1aff0801 	bne	fffc8304 <BootRAM+0xef38aa5>
      {
        Result = USB_UNSUPPORT;
      }
    }
    /*Clear FEATURE for Device */
    else if (RequestNo == CLEAR_FEATURE)
    62fc:	01f32448 	mvnseq	r2, r8, asr #8
    {
      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
    6300:	94052351 	strls	r2, [r5], #-849	; 0x351
    6304:	1aff0801 	bne	fffc8310 <BootRAM+0xef38ab1>
          && pInformation->USBwIndex == 0
    6308:	f3212440 	vshl.u32	q1, q0, <illegal reg q0.5>
          && ValBit(pInformation->Current_Feature, 5))
    630c:	06235101 	strteq	r5, [r3], -r1, lsl #2
    6310:	ff080194 			; <UNDEFINED> instruction: 0xff080194
      {
        Result = Standard_ClearFeature();
    6314:	2124381a 	teqcs	r4, sl, lsl r8
    }

  }

  /* Interface Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    6318:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
  {
    /*SET INTERFACE*/
    if (RequestNo == SET_INTERFACE)
    631c:	08019407 	stmdaeq	r1, {r0, r1, r2, sl, ip, pc}
    {
      Result = Standard_SetInterface();
    6320:	9f211aff 	svcls	0x00211aff
    6324:	01f30493 			; <UNDEFINED> instruction: 0x01f30493
    }
  }

  /* EndPoint Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    6328:	94082351 	strls	r2, [r8], #-849	; 0x351
  {
    /*CLEAR FEATURE for EndPoint*/
    if (RequestNo == CLEAR_FEATURE)
    632c:	1aff0801 	bne	fffc8338 <BootRAM+0xef38ad9>
    {
      Result = Standard_ClearFeature();
    }
    /* SET FEATURE for EndPoint*/
    else if (RequestNo == SET_FEATURE)
    6330:	01f32448 	mvnseq	r2, r8, asr #8
    {
      Result = Standard_SetEndPointFeature();
    6334:	94092351 	strls	r2, [r9], #-849	; 0x351
  {
    Result = USB_UNSUPPORT;
  }


  if (Result != USB_SUCCESS)
    6338:	1aff0801 	bne	fffc8344 <BootRAM+0xef38ae5>
      ControlState = PAUSE;
      goto exit_NoData_Setup0;
    }
  }

  if (Result != USB_SUCCESS)
    633c:	f3212440 	vshl.u32	q1, q0, <illegal reg q0.5>
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();
    6340:	0a235101 	beq	8da74c <_etext+0x8d3234>
    6344:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6348:	2124381a 	teqcs	r4, sl, lsl r8
    634c:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6350:	0801940b 	stmdaeq	r1, {r0, r1, r3, sl, ip, pc}
  {
    ControlState = STALLED;
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
    6354:	9f211aff 	svcls	0x00211aff

  USB_StatusIn();

exit_NoData_Setup0:
  pInformation->ControlState = ControlState;
    6358:	ac910493 	cfldrsge	mvf0, [r1], {147}	; 0x93
    635c:	9104937f 	tstls	r4, pc, ror r3


  CopyRoutine = NULL;
  wOffset = 0;

  if (Request_No == GET_DESCRIPTOR)
    6360:	04937fb0 	ldreq	r7, [r3], #4016	; 0xfb0
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6364:	937fb491 	cmnls	pc, #-1862270976	; 0x91000000
    {
      u8 wValue1 = pInformation->USBwValue1;
    6368:	7fb89104 	svcvc	0x00b89104
      if (wValue1 == DEVICE_DESCRIPTOR)
    636c:	bc910493 	cfldrslt	mvf0, [r1], {147}	; 0x93
      {
        CopyRoutine = pProperty->GetDeviceDescriptor;
    6370:	9304937f 	movwls	r9, #17279	; 0x437f
    6374:	39ca01e0 	stmibcc	sl, {r5, r6, r7, r8}^
      }
      else if (wValue1 == CONFIG_DESCRIPTOR)
    6378:	3a160000 	bcc	586380 <_etext+0x57ee68>
      {
        CopyRoutine = pProperty->GetConfigDescriptor;
    637c:	00b70000 	adcseq	r0, r7, r0
      }
      else if (wValue1 == STRING_DESCRIPTOR)
    6380:	04935c91 	ldreq	r5, [r3], #3217	; 0xc91
      {
        CopyRoutine = pProperty->GetStringDescriptor;
    6384:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6388:	08019404 	stmdaeq	r1, {r2, sl, ip, pc}
      } else if (wValue1 == 0x21) /* added to support functional descriptors */
    638c:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
      {
	CopyRoutine = pProperty->GetFunctionalDescriptor;
    6390:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
      } /* End of GET_DESCRIPTOR */
    }
  }

  /*GET STATUS*/
  else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
    6394:	08019405 	stmdaeq	r1, {r0, r2, sl, ip, pc}
    6398:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    639c:	5101f321 	tstpl	r1, r1, lsr #6
           && (pInformation->USBwLength == 0x0002)
           && (pInformation->USBwIndex1 == 0))
    63a0:	01940623 	orrseq	r0, r4, r3, lsr #12
    63a4:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    63a8:	01f32124 	mvnseq	r2, r4, lsr #2
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    63ac:	94072351 	strls	r2, [r7], #-849	; 0x351
    63b0:	1aff0801 	bne	fffc83bc <BootRAM+0xef38b5d>
        && (pInformation->USBwIndex == 0))
    63b4:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
    63b8:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    {
      CopyRoutine = Standard_GetStatus;
    }

    /* GET STATUS for Interface*/
    else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    63bc:	08019408 	stmdaeq	r1, {r3, sl, ip, pc}
    {
      if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
    63c0:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
    63c4:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    63c8:	08019409 	stmdaeq	r1, {r0, r3, sl, ip, pc}
    63cc:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
          && (pInformation->Current_Configuration != 0))
    63d0:	5101f321 	tstpl	r1, r1, lsr #6
    63d4:	01940a23 	orrseq	r0, r4, r3, lsr #20
    63d8:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
        CopyRoutine = Standard_GetStatus;
      }
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    63dc:	01f32124 	mvnseq	r2, r4, lsr #2
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    63e0:	940b2351 	strls	r2, [fp], #-849	; 0x351
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
    63e4:	1aff0801 	bne	fffc83f0 <BootRAM+0xef38b91>

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
    63e8:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
    63ec:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    63f0:	0801940c 	stmdaeq	r1, {r2, r3, sl, ip, pc}
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
      Reserved = pInformation->USBwIndex0 & 0x70;

      if (ValBit(pInformation->USBwIndex0, 7))
    63f4:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
    63f8:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    63fc:	0801940d 	stmdaeq	r1, {r0, r2, r3, sl, ip, pc}
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
    6400:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    6404:	5101f321 	tstpl	r1, r1, lsr #6
    6408:	01940e23 	orrseq	r0, r4, r3, lsr #28
          && (Status != 0))
    640c:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    6410:	01f32124 	mvnseq	r2, r4, lsr #2
    }

  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
    6414:	940f2351 	strls	r2, [pc], #-849	; 641c <Setup0_Process+0x1c8>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6418:	1aff0801 	bne	fffc8424 <BootRAM+0xef38bc5>
    641c:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
    {
      CopyRoutine = Standard_GetConfiguration;
    }
  }
  /*GET INTERFACE*/
  else if (Request_No == GET_INTERFACE)
    6420:	937fb091 	cmnls	pc, #145	; 0x91
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    6424:	7fb49104 	svcvc	0x00b49104
    6428:	b8910493 	ldmlt	r1, {r0, r1, r4, r7, sl}
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
    642c:	9104937f 	tstls	r4, pc, ror r3
    6430:	04937fbc 	ldreq	r7, [r3], #4028	; 0xfbc
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
    6434:	1601e093 			; <UNDEFINED> instruction: 0x1601e093
    6438:	aa00003a 	bge	6528 <Setup0_Process+0x2d4>
    643c:	e600003a 			; <UNDEFINED> instruction: 0xe600003a
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
    6440:	935c9100 	cmpls	ip, #0, 2
    6444:	5101f304 	tstpl	r1, r4, lsl #6
    6448:	01940423 	orrseq	r0, r4, r3, lsr #8
    644c:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
      CopyRoutine = Standard_GetInterface;
    }

  }

  if (CopyRoutine)
    6450:	5101f324 	tstpl	r1, r4, lsr #6
  {
    pInformation->Ctrl_Info.Usb_wOffset = wOffset;
    6454:	01940523 	orrseq	r0, r4, r3, lsr #10
    pInformation->Ctrl_Info.CopyData = CopyRoutine;
    6458:	401aff08 	andsmi	pc, sl, r8, lsl #30
    /* sb in the original the cast to word was directly */
    /* now the cast is made step by step */
    (*CopyRoutine)(0);
    645c:	01f32124 	mvnseq	r2, r4, lsr #2
    Result = USB_SUCCESS;
    6460:	94062351 	strls	r2, [r6], #-849	; 0x351
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
    6464:	1aff0801 	bne	fffc8470 <BootRAM+0xef38c11>
    6468:	f3212438 	vqshl.u32	d2, d24, d1
    646c:	07235101 	streq	r5, [r3, -r1, lsl #2]!
    if (Result == USB_NOT_READY)
    6470:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    {
      pInformation->ControlState = PAUSE;
    6474:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
      return;
    }
  }

  if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
    6478:	5101f304 	tstpl	r1, r4, lsl #6
    647c:	01940823 	orrseq	r0, r4, r3, lsr #16
    6480:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
  {
    /* Data is not ready, wait it */
    pInformation->ControlState = PAUSE;
    6484:	5101f324 	tstpl	r1, r4, lsr #6
    return;
  }
  if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
    6488:	01940923 	orrseq	r0, r4, r3, lsr #18
    648c:	401aff08 	andsmi	pc, sl, r8, lsl #30
  {
    /* Unsupported request */
    pInformation->ControlState = STALLED;
    6490:	01f32124 	mvnseq	r2, r4, lsr #2
    return;
  }


  if (ValBit(pInformation->USBbmRequestType, 7))
    6494:	940a2351 	strls	r2, [sl], #-849	; 0x351
    6498:	1aff0801 	bne	fffc84a4 <BootRAM+0xef38c45>
  {
    /* Device ==> Host */
    vu32 wLength = pInformation->USBwLength;
    649c:	f3212438 	vqshl.u32	d2, d24, d1

    /* Restrict the data length to be the one host asks */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
    64a0:	0b235101 	bleq	8da8ac <_etext+0x8d3394>
    64a4:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
    64a8:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
    64ac:	5101f304 	tstpl	r1, r4, lsl #6
    64b0:	01940c23 	orrseq	r0, r4, r3, lsr #24
    64b4:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    64b8:	5101f324 	tstpl	r1, r4, lsr #6
    64bc:	01940d23 	orrseq	r0, r4, r3, lsr #26
    64c0:	401aff08 	andsmi	pc, sl, r8, lsl #30
    64c4:	01f32124 	mvnseq	r2, r4, lsr #2
    64c8:	940e2351 	strls	r2, [lr], #-849	; 0x351
    }

    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
    64cc:	1aff0801 	bne	fffc84d8 <BootRAM+0xef38c79>
    {
      if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
    64d0:	f3212438 	vqshl.u32	d2, d24, d1
    64d4:	0f235101 	svceq	0x00235101
    64d8:	ff080194 			; <UNDEFINED> instruction: 0xff080194
      {
        Data_Mul_MaxPacketSize = FALSE;
    64dc:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
      }
      else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
    64e0:	5101f304 	tstpl	r1, r4, lsl #6
    64e4:	01941023 	orrseq	r1, r4, r3, lsr #32
      {
        Data_Mul_MaxPacketSize = TRUE;
    64e8:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    64ec:	5101f324 	tstpl	r1, r4, lsr #6
      }
    }

    pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
    64f0:	01941123 	orrseq	r1, r4, r3, lsr #2
    64f4:	401aff08 	andsmi	pc, sl, r8, lsl #30
    DataStageIn();
    64f8:	01f32124 	mvnseq	r2, r4, lsr #2
  }
  else
  {
    pInformation->ControlState = OUT_DATA;
    64fc:	94122351 	ldrls	r2, [r2], #-849	; 0x351
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
    6500:	1aff0801 	bne	fffc850c <BootRAM+0xef38cad>
    6504:	f3212438 	vqshl.u32	d2, d24, d1
  else
  {
    /* Setup with data stage */
    Data_Setup0();
  }
  return Post0_Process();
    6508:	13235101 	teqne	r3, #1073741824	; 0x40000000
}
    650c:	ff080194 			; <UNDEFINED> instruction: 0xff080194
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
        && (pInformation->USBwIndex == 0))
    {
      CopyRoutine = Standard_GetStatus;
    6510:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    {
      CopyRoutine = Standard_GetConfiguration;
    6514:	7fb49104 	svcvc	0x00b49104
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
    {
      CopyRoutine = Standard_GetInterface;
    6518:	b8910493 	ldmlt	r1, {r0, r1, r4, r7, sl}
    651c:	9104937f 	tstls	r4, pc, ror r3
    6520:	04937fbc 	ldreq	r7, [r3], #4028	; 0xfbc
    6524:	aa01e093 	bge	7e778 <_etext+0x77260>
    6528:	6200003a 	andvs	r0, r0, #58	; 0x3a
    652c:	1500003b 	strne	r0, [r0, #-59]	; 0x3b
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 Out0_Process(void)
{
    6530:	935c9101 	cmpls	ip, #1073741824	; 0x40000000
  u32 ControlState = pInformation->ControlState;
    6534:	5101f304 	tstpl	r1, r4, lsl #6

  if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
    6538:	01940423 	orrseq	r0, r4, r3, lsr #8
    653c:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  u32 save_rLength;

  save_rLength = pEPinfo->Usb_rLength;

  if (pEPinfo->CopyData && save_rLength)
    6540:	5101f324 	tstpl	r1, r4, lsr #6
    6544:	01940523 	orrseq	r0, r4, r3, lsr #10
  {
    u8 *Buffer;
    u32 Length;

    Length = pEPinfo->PacketSize;
    6548:	401aff08 	andsmi	pc, sl, r8, lsl #30
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    654c:	01f32124 	mvnseq	r2, r4, lsr #2
    6550:	94062351 	strls	r2, [r6], #-849	; 0x351
    pEPinfo->Usb_rLength -= Length;
    6554:	1aff0801 	bne	fffc8560 <BootRAM+0xef38d01>
    6558:	f3212438 	vqshl.u32	d2, d24, d1
    pEPinfo->Usb_rOffset += Length;
    655c:	07235101 	streq	r5, [r3, -r1, lsl #2]!
    6560:	ff080194 			; <UNDEFINED> instruction: 0xff080194

    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
    6564:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
    6568:	5101f304 	tstpl	r1, r4, lsl #6
    656c:	01940823 	orrseq	r0, r4, r3, lsr #16
    6570:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
  }

  if (pEPinfo->Usb_rLength != 0)
    6574:	5101f324 	tstpl	r1, r4, lsr #6
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    SetEPTxCount(ENDP0, 0);
    6578:	01940923 	orrseq	r0, r4, r3, lsr #18
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
  }

  if (pEPinfo->Usb_rLength != 0)
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    657c:	401aff08 	andsmi	pc, sl, r8, lsl #30
    6580:	01f32124 	mvnseq	r2, r4, lsr #2
    SetEPTxCount(ENDP0, 0);
    6584:	940a2351 	strls	r2, [sl], #-849	; 0x351
    vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
    6588:	1aff0801 	bne	fffc8594 <BootRAM+0xef38d35>
  }
  /* Set the next State*/
  if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
    658c:	f3212438 	vqshl.u32	d2, d24, d1
    6590:	0b235101 	bleq	8da99c <_etext+0x8d3484>
  {
    pInformation->ControlState = OUT_DATA;
    6594:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6598:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
  }
  else
  {
    if (pEPinfo->Usb_rLength > 0)
    {
      pInformation->ControlState = LAST_OUT_DATA;
    659c:	5101f304 	tstpl	r1, r4, lsl #6
    65a0:	01940c23 	orrseq	r0, r4, r3, lsr #24
    }
    else if (pEPinfo->Usb_rLength == 0)
    {
      pInformation->ControlState = WAIT_STATUS_IN;
    65a4:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    65a8:	5101f324 	tstpl	r1, r4, lsr #6
      USB_StatusIn();
    65ac:	01940d23 	orrseq	r0, r4, r3, lsr #26
    65b0:	401aff08 	andsmi	pc, sl, r8, lsl #30
    65b4:	01f32124 	mvnseq	r2, r4, lsr #2
    65b8:	940e2351 	strls	r2, [lr], #-849	; 0x351
    65bc:	1aff0801 	bne	fffc85c8 <BootRAM+0xef38d69>
  u32 ControlState = pInformation->ControlState;

  if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
  {
    DataStageOut();
    ControlState = pInformation->ControlState; /* may be changed outside the function */
    65c0:	f3212438 	vqshl.u32	d2, d24, d1
  }

  else if (ControlState == WAIT_STATUS_OUT)
    65c4:	0f235101 	svceq	0x00235101
  {
    (*pProperty->Process_Status_OUT)();
    65c8:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    65cc:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
  }

  else if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
  {
    /* host aborts the transfer before finish */
    ControlState = STALLED;
    65d0:	5101f304 	tstpl	r1, r4, lsl #6
  else
  {
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;
    65d4:	01941023 	orrseq	r1, r4, r3, lsr #32

  return Post0_Process();
}
    65d8:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
    65dc:	5101f324 	tstpl	r1, r4, lsr #6
    65e0:	01941123 	orrseq	r1, r4, r3, lsr #2
    65e4:	401aff08 	andsmi	pc, sl, r8, lsl #30
    65e8:	01f32124 	mvnseq	r2, r4, lsr #2
    65ec:	94122351 	ldrls	r2, [r2], #-849	; 0x351
    65f0:	1aff0801 	bne	fffc85fc <BootRAM+0xef38d9d>
    65f4:	f3212438 	vqshl.u32	d2, d24, d1
* Input          : - Val: device adress.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetDeviceAddress(u8 Val)
{
    65f8:	13235101 	teqne	r3, #1073741824	; 0x40000000
  u32 i;
  u32 nEP = Device_Table.Total_Endpoint;
    65fc:	ff080194 			; <UNDEFINED> instruction: 0xff080194

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
    6600:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
    6604:	5101f304 	tstpl	r1, r4, lsl #6
    6608:	01941423 	orrseq	r1, r4, r3, lsr #8
    660c:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
  {
    _SetEPAddress((u8)i, (u8)i);
    6610:	5101f324 	tstpl	r1, r4, lsr #6
    6614:	01941523 	orrseq	r1, r4, r3, lsr #10
    6618:	401aff08 	andsmi	pc, sl, r8, lsl #30
{
  u32 i;
  u32 nEP = Device_Table.Total_Endpoint;

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
    661c:	01f32124 	mvnseq	r2, r4, lsr #2
  {
    _SetEPAddress((u8)i, (u8)i);
  } /* for */
  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
    6620:	94162351 	ldrls	r2, [r6], #-849	; 0x351
    6624:	1aff0801 	bne	fffc8630 <BootRAM+0xef38dd1>
    6628:	f3212438 	vqshl.u32	d2, d24, d1
    662c:	17235101 	strne	r5, [r3, -r1, lsl #2]!
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 In0_Process(void)
{
    6630:	ff080194 			; <UNDEFINED> instruction: 0xff080194
  u32 ControlState = pInformation->ControlState;
    6634:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
    6638:	7fb89104 	svcvc	0x00b89104
    663c:	bc910493 	cfldrslt	mvf0, [r1], {147}	; 0x93
  {
    DataStageIn();
    6640:	9304937f 	movwls	r9, #17279	; 0x437f
    /* ControlState may be changed outside the function */
    ControlState = pInformation->ControlState;
    6644:	3b6201e0 	blcc	1886dcc <_etext+0x187f8b4>
    6648:	3be60000 	blcc	ff986650 <BootRAM+0xe8f6df1>
  }

  else if (ControlState == WAIT_STATUS_IN)
    664c:	01440000 	mrseq	r0, (UNDEF: 68)
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
    6650:	04935c91 	ldreq	r5, [r3], #3217	; 0xc91
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    6654:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    ControlState = pInformation->ControlState;
  }

  else if (ControlState == WAIT_STATUS_IN)
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
    6658:	08019404 	stmdaeq	r1, {r2, sl, ip, pc}
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    {
      SetDeviceAddress(pInformation->USBwValue0);
    665c:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
      pUser_Standard_Requests->User_SetDeviceAddress();
    6660:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6664:	08019405 	stmdaeq	r1, {r0, r2, sl, ip, pc}
    }
    (*pProperty->Process_Status_IN)();
    6668:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    666c:	5101f321 	tstpl	r1, r1, lsr #6
    ControlState = STALLED;
  }

  else
  {
    ControlState = STALLED;
    6670:	01940623 	orrseq	r0, r4, r3, lsr #12
  }

  pInformation->ControlState = ControlState;
    6674:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}

  return Post0_Process();
}
    6678:	01f32124 	mvnseq	r2, r4, lsr #2
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
    667c:	94072351 	strls	r2, [r7], #-849	; 0x351
    6680:	1aff0801 	bne	fffc868c <BootRAM+0xef38e2d>
    6684:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
    6688:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
*                  - wNBytes: no. of bytes to be copied.
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
    668c:	08019408 	stmdaeq	r1, {r3, sl, ip, pc}
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
    6690:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
    6694:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
    6698:	08019409 	stmdaeq	r1, {r0, r3, sl, ip, pc}
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
    669c:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    66a0:	5101f321 	tstpl	r1, r1, lsr #6
    66a4:	01940a23 	orrseq	r0, r4, r3, lsr #20
  {
    temp1 = (u16) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (u16) * pbUsrBuf << 8;
    66a8:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
  {
    temp1 = (u16) * pbUsrBuf;
    66ac:	01f32124 	mvnseq	r2, r4, lsr #2
    pbUsrBuf++;
    temp2 = temp1 | (u16) * pbUsrBuf << 8;
    66b0:	940b2351 	strls	r2, [fp], #-849	; 0x351
    *pdwVal++ = temp2;
    66b4:	1aff0801 	bne	fffc86c0 <BootRAM+0xef38e61>
    66b8:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
*                  - wNBytes     = no. of bytes to be copied.
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
    66bc:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
  u32 n = (wNBytes + 1) >> 1;/* /2*/
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
    66c0:	0801940c 	stmdaeq	r1, {r2, r3, sl, ip, pc}
    66c4:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;/* /2*/
    66c8:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
    66cc:	0801940d 	stmdaeq	r1, {r0, r2, r3, sl, ip, pc}
    66d0:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
  {
    *(u16*)pbUsrBuf++ = *pdwVal++;
    66d4:	5101f321 	tstpl	r1, r1, lsr #6
    66d8:	01940e23 	orrseq	r0, r4, r3, lsr #28
    66dc:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    66e0:	01f32124 	mvnseq	r2, r4, lsr #2
    66e4:	940f2351 	strls	r2, [pc], #-849	; 66ec <memcpy+0xc>
    66e8:	1aff0801 	bne	fffc86f4 <BootRAM+0xef38e95>
    66ec:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
    66f0:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    66f4:	08019410 	stmdaeq	r1, {r4, sl, ip, pc}
    66f8:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
    66fc:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6700:	08019411 	stmdaeq	r1, {r0, r4, sl, ip, pc}
    6704:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    6708:	5101f321 	tstpl	r1, r1, lsr #6
    670c:	01941223 	orrseq	r1, r4, r3, lsr #4
    6710:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    6714:	01f32124 	mvnseq	r2, r4, lsr #2
    6718:	94132351 	ldrls	r2, [r3], #-849	; 0x351
    671c:	1aff0801 	bne	fffc8728 <BootRAM+0xef38ec9>
    6720:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
    6724:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6728:	08019414 	stmdaeq	r1, {r2, r4, sl, ip, pc}
    672c:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
    6730:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6734:	08019415 	stmdaeq	r1, {r0, r2, r4, sl, ip, pc}
    6738:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    673c:	5101f321 	tstpl	r1, r1, lsr #6
    6740:	01941623 	orrseq	r1, r4, r3, lsr #12
    6744:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    6748:	01f32124 	mvnseq	r2, r4, lsr #2
    674c:	94172351 	ldrls	r2, [r7], #-849	; 0x351
    6750:	1aff0801 	bne	fffc875c <BootRAM+0xef38efd>
    6754:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
    6758:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    675c:	08019418 	stmdaeq	r1, {r3, r4, sl, ip, pc}
    6760:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
    6764:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6768:	08019419 	stmdaeq	r1, {r0, r3, r4, sl, ip, pc}
    676c:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    6770:	5101f321 	tstpl	r1, r1, lsr #6
    6774:	01941a23 	orrseq	r1, r4, r3, lsr #20
    6778:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    677c:	01f32124 	mvnseq	r2, r4, lsr #2
    6780:	941b2351 	ldrls	r2, [fp], #-849	; 0x351
    6784:	1aff0801 	bne	fffc8790 <BootRAM+0xef38f31>
    6788:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
    678c:	937fbc91 	cmnls	pc, #37120	; 0x9100
    6790:	01e09304 	mvneq	r9, r4, lsl #6
    6794:	00003be6 	andeq	r3, r0, r6, ror #23
    6798:	00004f5e 	andeq	r4, r0, lr, asr pc
    679c:	5c910173 	ldfpls	f0, [r1], {115}	; 0x73
    67a0:	01f30493 			; <UNDEFINED> instruction: 0x01f30493
    67a4:	94042351 	strls	r2, [r4], #-849	; 0x351
    67a8:	1aff0801 	bne	fffc87b4 <BootRAM+0xef38f55>
    67ac:	01f32448 	mvnseq	r2, r8, asr #8
    67b0:	94052351 	strls	r2, [r5], #-849	; 0x351
    67b4:	1aff0801 	bne	fffc87c0 <BootRAM+0xef38f61>
    67b8:	f3212440 	vshl.u32	q1, q0, <illegal reg q0.5>
    67bc:	06235101 	strteq	r5, [r3], -r1, lsl #2
    67c0:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    67c4:	2124381a 	teqcs	r4, sl, lsl r8
    67c8:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    67cc:	08019407 	stmdaeq	r1, {r0, r1, r2, sl, ip, pc}
    67d0:	9f211aff 	svcls	0x00211aff
    67d4:	01f30493 			; <UNDEFINED> instruction: 0x01f30493
    67d8:	94082351 	strls	r2, [r8], #-849	; 0x351
    67dc:	1aff0801 	bne	fffc87e8 <BootRAM+0xef38f89>
    67e0:	01f32448 	mvnseq	r2, r8, asr #8
    67e4:	94092351 	strls	r2, [r9], #-849	; 0x351
    67e8:	1aff0801 	bne	fffc87f4 <BootRAM+0xef38f95>
    67ec:	f3212440 	vshl.u32	q1, q0, <illegal reg q0.5>
    67f0:	0a235101 	beq	8dabfc <_etext+0x8d36e4>
    67f4:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    67f8:	2124381a 	teqcs	r4, sl, lsl r8
    67fc:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6800:	0801940b 	stmdaeq	r1, {r0, r1, r3, sl, ip, pc}
    6804:	9f211aff 	svcls	0x00211aff
    6808:	01f30493 			; <UNDEFINED> instruction: 0x01f30493
    680c:	940c2351 	strls	r2, [ip], #-849	; 0x351
    6810:	1aff0801 	bne	fffc881c <BootRAM+0xef38fbd>
    6814:	01f32448 	mvnseq	r2, r8, asr #8
    6818:	940d2351 	strls	r2, [sp], #-849	; 0x351
    681c:	1aff0801 	bne	fffc8828 <BootRAM+0xef38fc9>
    6820:	f3212440 	vshl.u32	q1, q0, <illegal reg q0.5>
    6824:	0e235101 	sufeqs	f5, f3, f1
    6828:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    682c:	2124381a 	teqcs	r4, sl, lsl r8
    6830:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6834:	0801940f 	stmdaeq	r1, {r0, r1, r2, r3, sl, ip, pc}
    6838:	9f211aff 	svcls	0x00211aff
    683c:	01f30493 			; <UNDEFINED> instruction: 0x01f30493
    6840:	94102351 	ldrls	r2, [r0], #-849	; 0x351
    6844:	1aff0801 	bne	fffc8850 <BootRAM+0xef38ff1>
    6848:	01f32448 	mvnseq	r2, r8, asr #8
    684c:	94112351 	ldrls	r2, [r1], #-849	; 0x351
    6850:	1aff0801 	bne	fffc885c <BootRAM+0xef38ffd>
    6854:	f3212440 	vshl.u32	q1, q0, <illegal reg q0.5>
    6858:	12235101 	eorne	r5, r3, #1073741824	; 0x40000000
    685c:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6860:	2124381a 	teqcs	r4, sl, lsl r8
    6864:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6868:	08019413 	stmdaeq	r1, {r0, r1, r4, sl, ip, pc}
    686c:	9f211aff 	svcls	0x00211aff
    6870:	01f30493 			; <UNDEFINED> instruction: 0x01f30493
    6874:	94142351 	ldrls	r2, [r4], #-849	; 0x351
    6878:	1aff0801 	bne	fffc8884 <BootRAM+0xef39025>
    687c:	01f32448 	mvnseq	r2, r8, asr #8
    6880:	94152351 	ldrls	r2, [r5], #-849	; 0x351
    6884:	1aff0801 	bne	fffc8890 <BootRAM+0xef39031>
    6888:	f3212440 	vshl.u32	q1, q0, <illegal reg q0.5>
    688c:	16235101 	strtne	r5, [r3], -r1, lsl #2
    6890:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6894:	2124381a 	teqcs	r4, sl, lsl r8
    6898:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    689c:	08019417 	stmdaeq	r1, {r0, r1, r2, r4, sl, ip, pc}
    68a0:	9f211aff 	svcls	0x00211aff
    68a4:	01f30493 			; <UNDEFINED> instruction: 0x01f30493
    68a8:	94182351 	ldrls	r2, [r8], #-849	; 0x351
    68ac:	1aff0801 	bne	fffc88b8 <BootRAM+0xef39059>
    68b0:	01f32448 	mvnseq	r2, r8, asr #8
    68b4:	94192351 	ldrls	r2, [r9], #-849	; 0x351
    68b8:	1aff0801 	bne	fffc88c4 <BootRAM+0xef39065>
    68bc:	f3212440 	vshl.u32	q1, q0, <illegal reg q0.5>
    68c0:	1a235101 	bne	8daccc <_etext+0x8d37b4>
    68c4:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    68c8:	2124381a 	teqcs	r4, sl, lsl r8
    68cc:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    68d0:	0801941b 	stmdaeq	r1, {r0, r1, r3, r4, sl, ip, pc}
    68d4:	9f211aff 	svcls	0x00211aff
    68d8:	01f30493 			; <UNDEFINED> instruction: 0x01f30493
    68dc:	941c2351 	ldrls	r2, [ip], #-849	; 0x351
    68e0:	1aff0801 	bne	fffc88ec <BootRAM+0xef3908d>
    68e4:	01f32448 	mvnseq	r2, r8, asr #8
    68e8:	941d2351 	ldrls	r2, [sp], #-849	; 0x351
    68ec:	1aff0801 	bne	fffc88f8 <BootRAM+0xef39099>
    68f0:	f3212440 	vshl.u32	q1, q0, <illegal reg q0.5>
    68f4:	1e235101 	sufnes	f5, f3, f1
    68f8:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    68fc:	2124381a 	teqcs	r4, sl, lsl r8
    6900:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6904:	0801941f 	stmdaeq	r1, {r0, r1, r2, r3, r4, sl, ip, pc}
    6908:	9f211aff 	svcls	0x00211aff
    690c:	e0930493 	umulls	r0, r3, r3, r4
    6910:	004f5e01 	subeq	r5, pc, r1, lsl #28
    6914:	004f8000 	subeq	r8, pc, r0
    6918:	91000700 	tstls	r0, r0, lsl #14
    691c:	9304935c 	movwls	r9, #17244	; 0x435c
    6920:	4f8001fc 	svcmi	0x008001fc
    6924:	4f980000 	svcmi	0x00980000
    6928:	00070000 	andeq	r0, r7, r0
    692c:	04935c7d 	ldreq	r5, [r3], #3197	; 0xc7d
    6930:	0001fc93 	muleq	r1, r3, ip
    6934:	00000000 	andeq	r0, r0, r0
    6938:	b0000000 	andlt	r0, r0, r0
    693c:	b4000037 	strlt	r0, [r0], #-55	; 0x37
    6940:	01000037 	tsteq	r0, r7, lsr r0
    6944:	381c5400 	ldmdacc	ip, {sl, ip, lr}
    6948:	3b640000 	blcc	1906950 <_etext+0x18ff438>
    694c:	00010000 	andeq	r0, r1, r0
    6950:	003bf055 	eorseq	pc, fp, r5, asr r0	; <UNPREDICTABLE>
    6954:	003dae00 	eorseq	sl, sp, r0, lsl #28
    6958:	5c000100 	stfpls	f0, [r0], {-0}
    695c:	00003dae 	andeq	r3, r0, lr, lsr #27
    6960:	00003f18 	andeq	r3, r0, r8, lsl pc
    6964:	74540001 	ldrbvc	r0, [r4], #-1
    6968:	f800003f 			; <UNDEFINED> instruction: 0xf800003f
    696c:	01000042 	tsteq	r0, r2, asr #32
    6970:	434c5700 	movtmi	r5, #50944	; 0xc700
    6974:	46bc0000 	ldrtmi	r0, [ip], r0
    6978:	00010000 	andeq	r0, r1, r0
    697c:	00472258 	subeq	r2, r7, r8, asr r2
    6980:	004ac000 	subeq	ip, sl, r0
    6984:	56000100 	strpl	r0, [r0], -r0, lsl #2
    6988:	00004b1a 	andeq	r4, r0, sl, lsl fp
    698c:	00004b2c 	andeq	r4, r0, ip, lsr #22
    6990:	2c590001 	mrrccs	0, 0, r0, r9, cr1
    6994:	5600004b 	strpl	r0, [r0], -fp, asr #32
    6998:	0100004b 	tsteq	r0, fp, asr #32
    699c:	4b565a00 	blmi	159d1a4 <_etext+0x1595c8c>
    69a0:	4d8e0000 	stcmi	0, cr0, [lr]
    69a4:	00030000 	andeq	r0, r3, r0
    69a8:	8e7f9891 	mrchi	8, 3, r9, cr15, cr1, {4}
    69ac:	0600004d 	streq	r0, [r0], -sp, asr #32
    69b0:	0100004f 	tsteq	r0, pc, asr #32
    69b4:	00005200 	andeq	r5, r0, r0, lsl #4
    69b8:	00000000 	andeq	r0, r0, r0
    69bc:	37b20000 	ldrcc	r0, [r2, r0]!
    69c0:	3afc0000 	bcc	fff069c8 <BootRAM+0xee77169>
    69c4:	00010000 	andeq	r0, r1, r0
    69c8:	003b5057 	eorseq	r5, fp, r7, asr r0
    69cc:	003eb000 	eorseq	fp, lr, r0
    69d0:	53000100 	movwpl	r0, #256	; 0x100
    69d4:	00003f04 	andeq	r3, r0, r4, lsl #30
    69d8:	00004278 	andeq	r4, r0, r8, ror r2
    69dc:	e4560001 	ldrb	r0, [r6], #-1
    69e0:	4c000042 	stcmi	0, cr0, [r0], {66}	; 0x42
    69e4:	01000046 	tsteq	r0, r6, asr #32
    69e8:	46a45600 	strtmi	r5, [r4], r0, lsl #12
    69ec:	4a3e0000 	bmi	f869f4 <_etext+0xf7f4dc>
    69f0:	00010000 	andeq	r0, r1, r0
    69f4:	004aac50 	subeq	sl, sl, r0, asr ip
    69f8:	004ce400 	subeq	lr, ip, r0, lsl #8
    69fc:	91000300 	mrsls	r0, LR_irq
    6a00:	4ce47f94 	stclmi	15, cr7, [r4], #592	; 0x250
    6a04:	4e920000 	cdpmi	0, 9, cr0, cr2, cr0, {0}
    6a08:	00010000 	andeq	r0, r1, r0
    6a0c:	004ef05c 	subeq	pc, lr, ip, asr r0	; <UNPREDICTABLE>
    6a10:	004f5200 	subeq	r5, pc, r0, lsl #4
    6a14:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    6a20:	000037b0 			; <UNDEFINED> instruction: 0x000037b0
    6a24:	00003a7e 	andeq	r3, r0, lr, ror sl
    6a28:	e6560001 	ldrb	r0, [r6], -r1
    6a2c:	3c00003a 	stccc	0, cr0, [r0], {58}	; 0x3a
    6a30:	0100003e 	tsteq	r0, lr, lsr r0
    6a34:	3e925200 	cdpcc	2, 9, cr5, cr2, cr0, {0}
    6a38:	420a0000 	andmi	r0, sl, #0
    6a3c:	00010000 	andeq	r0, r1, r0
    6a40:	00425e50 	subeq	r5, r2, r0, asr lr
    6a44:	0045d600 	subeq	sp, r5, r0, lsl #12
    6a48:	50000100 	andpl	r0, r0, r0, lsl #2
    6a4c:	00004628 	andeq	r4, r0, r8, lsr #12
    6a50:	000049ca 	andeq	r4, r0, sl, asr #19
    6a54:	2a530001 	bcs	14c6a60 <_etext+0x14bf548>
    6a58:	0000004a 	andeq	r0, r0, sl, asr #32
    6a5c:	0100004e 	tsteq	r0, lr, asr #32
    6a60:	4e5e5400 	cdpmi	4, 5, cr5, cr14, cr0, {0}
    6a64:	4f4a0000 	svcmi	0x004a0000
    6a68:	00010000 	andeq	r0, r1, r0
    6a6c:	00000051 	andeq	r0, r0, r1, asr r0
    6a70:	00000000 	andeq	r0, r0, r0
    6a74:	0037b000 	eorseq	fp, r7, r0
    6a78:	003a0200 	eorseq	r0, sl, r0, lsl #4
    6a7c:	5b000100 	blpl	6e84 <_malloc_r+0x60>
    6a80:	00003a66 	andeq	r3, r0, r6, ror #20
    6a84:	00003dcc 	andeq	r3, r0, ip, asr #27
    6a88:	26500001 	ldrbcs	r0, [r0], -r1
    6a8c:	8200003e 	andhi	r0, r0, #62	; 0x3e
    6a90:	01000041 	tsteq	r0, r1, asr #32
    6a94:	41e85c00 	mvnmi	r5, r0, lsl #24
    6a98:	45680000 	strbmi	r0, [r8, #-0]!
    6a9c:	00010000 	andeq	r0, r1, r0
    6aa0:	0045bc53 	subeq	fp, r5, r3, asr ip
    6aa4:	00494400 	subeq	r4, r9, r0, lsl #8
    6aa8:	51000100 	mrspl	r0, (UNDEF: 16)
    6aac:	000049b8 			; <UNDEFINED> instruction: 0x000049b8
    6ab0:	00004d98 	muleq	r0, r8, sp
    6ab4:	ee510001 	cdp	0, 5, cr0, cr1, cr1, {0}
    6ab8:	3c00004d 	stccc	0, cr0, [r0], {77}	; 0x4d
    6abc:	0100004f 	tsteq	r0, pc, asr #32
    6ac0:	00005300 	andeq	r5, r0, r0, lsl #6
    6ac4:	00000000 	andeq	r0, r0, r0
    6ac8:	37b00000 	ldrcc	r0, [r0, r0]!
    6acc:	38180000 	ldmdacc	r8, {}	; <UNPREDICTABLE>
    6ad0:	00030000 	andeq	r0, r3, r0
    6ad4:	187f9491 	ldmdane	pc!, {r0, r4, r7, sl, ip, pc}^	; <UNPREDICTABLE>
    6ad8:	a4000038 	strge	r0, [r0], #-56	; 0x38
    6adc:	01000039 	tsteq	r0, r9, lsr r0
    6ae0:	3a0c5400 	bcc	31bae8 <_etext+0x3145d0>
    6ae4:	3d5c0000 	ldclcc	0, cr0, [ip, #-0]
    6ae8:	00010000 	andeq	r0, r1, r0
    6aec:	003db654 	eorseq	fp, sp, r4, asr r6
    6af0:	00410c00 	subeq	r0, r1, r0, lsl #24
    6af4:	59000100 	stmdbpl	r0, {r8}
    6af8:	0000416a 	andeq	r4, r0, sl, ror #2
    6afc:	0000450c 	andeq	r4, r0, ip, lsl #10
    6b00:	4c520001 	mrrcmi	0, 0, r0, r2, cr1
    6b04:	d0000045 	andle	r0, r0, r5, asr #32
    6b08:	01000048 	tsteq	r0, r8, asr #32
    6b0c:	493c5200 	ldmdbmi	ip!, {r9, ip, lr}
    6b10:	4cf80000 	ldclmi	0, cr0, [r8]
    6b14:	00010000 	andeq	r0, r1, r0
    6b18:	004d8e52 	subeq	r8, sp, r2, asr lr
    6b1c:	004da800 	subeq	sl, sp, r0, lsl #16
    6b20:	53000100 	movwpl	r0, #256	; 0x100
    6b24:	00004da8 	andeq	r4, r0, r8, lsr #27
    6b28:	00004f48 	andeq	r4, r0, r8, asr #30
    6b2c:	b0910003 	addslt	r0, r1, r3
    6b30:	004f487f 	subeq	r4, pc, pc, ror r8	; <UNPREDICTABLE>
    6b34:	004f5a00 	subeq	r5, pc, r0, lsl #20
    6b38:	91000800 	tstls	r0, r0, lsl #16
    6b3c:	77067fb0 			; <UNDEFINED> instruction: 0x77067fb0
    6b40:	009f2200 	addseq	r2, pc, r0, lsl #4
    6b44:	00000000 	andeq	r0, r0, r0
    6b48:	b0000000 	andlt	r0, r0, r0
    6b4c:	22000037 	andcs	r0, r0, #55	; 0x37
    6b50:	01000039 	tsteq	r0, r9, lsr r0
    6b54:	39905300 	ldmibcc	r0, {r8, r9, ip, lr}
    6b58:	3ce60000 	stclcc	0, cr0, [r6]
    6b5c:	00010000 	andeq	r0, r1, r0
    6b60:	003d3251 	eorseq	r3, sp, r1, asr r2
    6b64:	00409800 	subeq	r9, r0, r0, lsl #16
    6b68:	51000100 	mrspl	r0, (UNDEF: 16)
    6b6c:	000040e8 	andeq	r4, r0, r8, ror #1
    6b70:	00004478 	andeq	r4, r0, r8, ror r4
    6b74:	d6510001 	ldrble	r0, [r1], -r1
    6b78:	4e000044 	cdpmi	0, 0, cr0, cr0, cr4, {2}
    6b7c:	01000048 	tsteq	r0, r8, asr #32
    6b80:	48be5400 	ldmmi	lr!, {sl, ip, lr}
    6b84:	4c7c0000 	ldclmi	0, cr0, [ip], #-0
    6b88:	00010000 	andeq	r0, r1, r0
    6b8c:	004ce658 	subeq	lr, ip, r8, asr r6
    6b90:	004d0a00 	subeq	r0, sp, r0, lsl #20
    6b94:	5b000100 	blpl	6f9c <_sbrk+0x40>
    6b98:	00004d0a 	andeq	r4, r0, sl, lsl #26
    6b9c:	00004d14 	andeq	r4, r0, r4, lsl sp
    6ba0:	14520001 	ldrbne	r0, [r2], #-1
    6ba4:	f000004d 			; <UNDEFINED> instruction: 0xf000004d
    6ba8:	0300004e 	movweq	r0, #78	; 0x4e
    6bac:	7f949100 	svcvc	0x00949100
    6bb0:	00004ef0 	strdeq	r4, [r0], -r0
    6bb4:	00004f58 	andeq	r4, r0, r8, asr pc
    6bb8:	00560001 	subseq	r0, r6, r1
    6bbc:	00000000 	andeq	r0, r0, r0
    6bc0:	b0000000 	andlt	r0, r0, r0
    6bc4:	b4000037 	strlt	r0, [r0], #-55	; 0x37
    6bc8:	01000038 	tsteq	r0, r8, lsr r0
    6bcc:	39105200 	ldmdbcc	r0, {r9, ip, lr}
    6bd0:	3c6e0000 	stclcc	0, cr0, [lr], #-0
    6bd4:	00010000 	andeq	r0, r1, r0
    6bd8:	003cd25a 	eorseq	sp, ip, sl, asr r2
    6bdc:	00402c00 	subeq	r2, r0, r0, lsl #24
    6be0:	5a000100 	bpl	6fe8 <_sbrk+0x8c>
    6be4:	0000407e 	andeq	r4, r0, lr, ror r0
    6be8:	0000440a 	andeq	r4, r0, sl, lsl #8
    6bec:	60540001 	subsvs	r0, r4, r1
    6bf0:	a4000044 	strge	r0, [r0], #-68	; 0x44
    6bf4:	01000047 	tsteq	r0, r7, asr #32
    6bf8:	48465500 	stmdami	r6, {r8, sl, ip, lr}^
    6bfc:	4bca0000 	blmi	ff286c04 <BootRAM+0xe1f73a5>
    6c00:	00010000 	andeq	r0, r1, r0
    6c04:	004c2a55 	subeq	r2, ip, r5, asr sl
    6c08:	004c9000 	subeq	r9, ip, r0
    6c0c:	5a000100 	bpl	7014 <_sbrk+0xb8>
    6c10:	00004c90 	muleq	r0, r0, ip
    6c14:	00004ca2 	andeq	r4, r0, r2, lsr #25
    6c18:	a2500001 	subsge	r0, r0, #1
    6c1c:	5600004c 	strpl	r0, [r0], -ip, asr #32
    6c20:	0300004e 	movweq	r0, #78	; 0x4e
    6c24:	7fa89100 	svcvc	0x00a89100
    6c28:	00004e56 	andeq	r4, r0, r6, asr lr
    6c2c:	00004f44 	andeq	r4, r0, r4, asr #30
    6c30:	00550001 	subseq	r0, r5, r1
    6c34:	00000000 	andeq	r0, r0, r0
    6c38:	b0000000 	andlt	r0, r0, r0
    6c3c:	30000037 	andcc	r0, r0, r7, lsr r0
    6c40:	01000038 	tsteq	r0, r8, lsr r0
    6c44:	389c5000 	ldmcc	ip, {ip, lr}
    6c48:	3c060000 	stccc	0, cr0, [r6], {-0}
    6c4c:	00010000 	andeq	r0, r1, r0
    6c50:	003c6c58 	eorseq	r6, ip, r8, asr ip
    6c54:	003e2400 	eorseq	r2, lr, r0, lsl #8
    6c58:	56000100 	strpl	r0, [r0], -r0, lsl #2
    6c5c:	00003e24 	andeq	r3, r0, r4, lsr #28
    6c60:	00003fbe 			; <UNDEFINED> instruction: 0x00003fbe
    6c64:	145b0001 	ldrbne	r0, [fp], #-1
    6c68:	72000040 	andvc	r0, r0, #64	; 0x40
    6c6c:	01000043 	tsteq	r0, r3, asr #32
    6c70:	43c05500 	bicmi	r5, r0, #0, 10
    6c74:	47460000 	strbmi	r0, [r6, -r0]
    6c78:	00010000 	andeq	r0, r1, r0
    6c7c:	0047965c 	subeq	r9, r7, ip, asr r6
    6c80:	004b3000 	subeq	r3, fp, r0
    6c84:	5c000100 	stfpls	f0, [r0], {-0}
    6c88:	00004b90 	muleq	r0, r0, fp
    6c8c:	00004bee 	andeq	r4, r0, lr, ror #23
    6c90:	ee500001 	cdp	0, 5, cr0, cr0, cr1, {0}
    6c94:	fa00004b 	blx	6dc8 <_free_r+0x2c>
    6c98:	0100004b 	tsteq	r0, fp, asr #32
    6c9c:	4bfa5b00 	blmi	ffe9d8a4 <BootRAM+0xee0e045>
    6ca0:	4dea0000 	stclmi	0, cr0, [sl]
    6ca4:	00030000 	andeq	r0, r3, r0
    6ca8:	ea7fa491 	b	1fefef4 <_etext+0x1fe89dc>
    6cac:	3400004d 	strcc	r0, [r0], #-77	; 0x4d
    6cb0:	0100004f 	tsteq	r0, pc, asr #32
    6cb4:	00005000 	andeq	r5, r0, r0
    6cb8:	00000000 	andeq	r0, r0, r0
    6cbc:	4f980000 	svcmi	0x00980000
    6cc0:	4fba0000 	svcmi	0x00ba0000
    6cc4:	00010000 	andeq	r0, r1, r0
    6cc8:	004fba50 	subeq	fp, pc, r0, asr sl	; <UNPREDICTABLE>
    6ccc:	004fea00 	subeq	lr, pc, r0, lsl #20
    6cd0:	56000100 	strpl	r0, [r0], -r0, lsl #2
    6cd4:	00004fea 	andeq	r4, r0, sl, ror #31
    6cd8:	00004ff2 	strdeq	r4, [r0], -r2
    6cdc:	f2500001 	vhadd.s16	d16, d0, d1
    6ce0:	0000004f 	andeq	r0, r0, pc, asr #32
    6ce4:	01000050 	qaddeq	r0, r0, r0
    6ce8:	50005600 	andpl	r5, r0, r0, lsl #12
    6cec:	50040000 	andpl	r0, r4, r0
    6cf0:	00040000 	andeq	r0, r4, r0
    6cf4:	9f5001f3 	svcls	0x005001f3
    6cf8:	00005004 	andeq	r5, r0, r4
    6cfc:	00005008 	andeq	r5, r0, r8
    6d00:	08500001 	ldmdaeq	r0, {r0}^
    6d04:	26000050 			; <UNDEFINED> instruction: 0x26000050
    6d08:	01000050 	qaddeq	r0, r0, r0
    6d0c:	00005600 	andeq	r5, r0, r0, lsl #12
    6d10:	00000000 	andeq	r0, r0, r0
    6d14:	4f980000 	svcmi	0x00980000
    6d18:	4fba0000 	svcmi	0x00ba0000
    6d1c:	00010000 	andeq	r0, r1, r0
    6d20:	004fba51 	subeq	fp, pc, r1, asr sl	; <UNPREDICTABLE>
    6d24:	004fea00 	subeq	lr, pc, r0, lsl #20
    6d28:	f3000400 	vshl.u8	d0, d0, d0
    6d2c:	ea9f5101 	b	fe7db138 <BootRAM+0xd74b8d9>
    6d30:	f200004f 	vhadd.s8	q0, q0, <illegal reg q7.5>
    6d34:	0100004f 	tsteq	r0, pc, asr #32
    6d38:	4ff25100 	svcmi	0x00f25100
    6d3c:	50040000 	andpl	r0, r4, r0
    6d40:	00040000 	andeq	r0, r4, r0
    6d44:	9f5101f3 	svcls	0x005101f3
    6d48:	00005004 	andeq	r5, r0, r4
    6d4c:	0000500a 	andeq	r5, r0, sl
    6d50:	0a510001 	beq	1446d5c <_etext+0x143f844>
    6d54:	20000050 	andcs	r0, r0, r0, asr r0
    6d58:	01000050 	qaddeq	r0, r0, r0
    6d5c:	50205800 	eorpl	r5, r0, r0, lsl #16
    6d60:	50260000 	eorpl	r0, r6, r0
    6d64:	00040000 	andeq	r0, r4, r0
    6d68:	9f5101f3 	svcls	0x005101f3
	...
    6d74:	00004f98 	muleq	r0, r8, pc	; <UNPREDICTABLE>
    6d78:	00004fa8 	andeq	r4, r0, r8, lsr #31
    6d7c:	a8520001 	ldmdage	r2, {r0}^
    6d80:	ba00004f 	blt	6ec4 <_malloc_r+0xa0>
    6d84:	0100004f 	tsteq	r0, pc, asr #32
    6d88:	4fba5700 	svcmi	0x00ba5700
    6d8c:	4fea0000 	svcmi	0x00ea0000
    6d90:	00040000 	andeq	r0, r4, r0
    6d94:	9f5201f3 	svcls	0x005201f3
    6d98:	00004fea 	andeq	r4, r0, sl, ror #31
    6d9c:	00004ff2 	strdeq	r4, [r0], -r2
    6da0:	f2570001 	vhadd.s16	d16, d7, d1
    6da4:	0400004f 	streq	r0, [r0], #-79	; 0x4f
    6da8:	04000050 	streq	r0, [r0], #-80	; 0x50
    6dac:	5201f300 	andpl	pc, r1, #0, 6
    6db0:	0050049f 			; <UNDEFINED> instruction: 0x0050049f
    6db4:	00501e00 	subseq	r1, r0, r0, lsl #28
    6db8:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    6dbc:	0000501e 	andeq	r5, r0, lr, lsl r0
    6dc0:	00005026 	andeq	r5, r0, r6, lsr #32
    6dc4:	01f30004 	mvnseq	r0, r4
    6dc8:	00009f52 	andeq	r9, r0, r2, asr pc
    6dcc:	00000000 	andeq	r0, r0, r0
    6dd0:	4fa40000 	svcmi	0x00a40000
    6dd4:	4fa80000 	svcmi	0x00a80000
    6dd8:	00010000 	andeq	r0, r1, r0
    6ddc:	004fa852 	subeq	sl, pc, r2, asr r8	; <UNPREDICTABLE>
    6de0:	004fc200 	subeq	ip, pc, r0, lsl #4
    6de4:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    6de8:	00004fc2 	andeq	r4, r0, r2, asr #31
    6dec:	00004fc6 	andeq	r4, r0, r6, asr #31
    6df0:	c6550001 	ldrbgt	r0, [r5], -r1
    6df4:	cc00004f 	stcgt	0, cr0, [r0], {79}	; 0x4f
    6df8:	0400004f 	streq	r0, [r0], #-79	; 0x4f
    6dfc:	00c07500 	sbceq	r7, r0, r0, lsl #10
    6e00:	004fcc9f 	umaaleq	ip, pc, pc, ip	; <UNPREDICTABLE>
    6e04:	004fe400 	subeq	lr, pc, r0, lsl #8
    6e08:	55000100 	strpl	r0, [r0, #-256]	; 0x100
    6e0c:	00004fea 	andeq	r4, r0, sl, ror #31
    6e10:	00004ff2 	strdeq	r4, [r0], -r2
    6e14:	04570001 	ldrbeq	r0, [r7], #-1
    6e18:	22000050 	andcs	r0, r0, #80	; 0x50
    6e1c:	01000050 	qaddeq	r0, r0, r0
    6e20:	00005700 	andeq	r5, r0, r0, lsl #14
    6e24:	00000000 	andeq	r0, r0, r0
    6e28:	4fa40000 	svcmi	0x00a40000
    6e2c:	4fba0000 	svcmi	0x00ba0000
    6e30:	00010000 	andeq	r0, r1, r0
    6e34:	004fba51 	subeq	fp, pc, r1, asr sl	; <UNPREDICTABLE>
    6e38:	004fc200 	subeq	ip, pc, r0, lsl #4
    6e3c:	58000100 	stmdapl	r0, {r8}
    6e40:	00004fc2 	andeq	r4, r0, r2, asr #31
    6e44:	00004fe4 	andeq	r4, r0, r4, ror #31
    6e48:	ea540001 	b	1506e54 <_etext+0x14ff93c>
    6e4c:	f200004f 	vhadd.s8	q0, q0, <illegal reg q7.5>
    6e50:	0100004f 	tsteq	r0, pc, asr #32
    6e54:	50045100 	andpl	r5, r4, r0, lsl #2
    6e58:	500a0000 	andpl	r0, sl, r0
    6e5c:	00010000 	andeq	r0, r1, r0
    6e60:	00500a51 	subseq	r0, r0, r1, asr sl
    6e64:	00502200 	subseq	r2, r0, r0, lsl #4
    6e68:	58000100 	stmdapl	r0, {r8}
	...
    6e74:	00004fa4 	andeq	r4, r0, r4, lsr #31
    6e78:	00004fba 			; <UNDEFINED> instruction: 0x00004fba
    6e7c:	ba500001 	blt	1406e88 <_etext+0x13ff970>
    6e80:	e600004f 	str	r0, [r0], -pc, asr #32
    6e84:	0100004f 	tsteq	r0, pc, asr #32
    6e88:	4fea5600 	svcmi	0x00ea5600
    6e8c:	4ff20000 	svcmi	0x00f20000
    6e90:	00010000 	andeq	r0, r1, r0
    6e94:	004ff250 	subeq	pc, pc, r0, asr r2	; <UNPREDICTABLE>
    6e98:	00500000 	subseq	r0, r0, r0
    6e9c:	56000100 	strpl	r0, [r0], -r0, lsl #2
    6ea0:	00005000 	andeq	r5, r0, r0
    6ea4:	00005004 	andeq	r5, r0, r4
    6ea8:	01f30004 	mvnseq	r0, r4
    6eac:	50049f50 	andpl	r9, r4, r0, asr pc
    6eb0:	50080000 	andpl	r0, r8, r0
    6eb4:	00010000 	andeq	r0, r1, r0
    6eb8:	00500850 	subseq	r0, r0, r0, asr r8
    6ebc:	00502600 	subseq	r2, r0, r0, lsl #12
    6ec0:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    6ecc:	00004fb0 			; <UNDEFINED> instruction: 0x00004fb0
    6ed0:	00004fba 			; <UNDEFINED> instruction: 0x00004fba
    6ed4:	ba530001 	blt	14c6ee0 <_etext+0x14bf9c8>
    6ed8:	e600004f 	str	r0, [r0], -pc, asr #32
    6edc:	0200004f 	andeq	r0, r0, #79	; 0x4f
    6ee0:	ea9f3000 	b	fe7d2ee8 <BootRAM+0xd743689>
    6ee4:	f200004f 	vhadd.s8	q0, q0, <illegal reg q7.5>
    6ee8:	0100004f 	tsteq	r0, pc, asr #32
    6eec:	50045300 	andpl	r5, r4, r0, lsl #6
    6ef0:	50110000 	andspl	r0, r1, r0
    6ef4:	00010000 	andeq	r0, r1, r0
    6ef8:	00502053 	subseq	r2, r0, r3, asr r0
    6efc:	00502600 	subseq	r2, r0, r0, lsl #12
    6f00:	30000200 	andcc	r0, r0, r0, lsl #4
    6f04:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    6f08:	00000000 	andeq	r0, r0, r0
    6f0c:	004fb000 	subeq	fp, pc, r0
    6f10:	004fba00 	subeq	fp, pc, r0, lsl #20
    6f14:	08000600 	stmdaeq	r0, {r9, sl}
    6f18:	1c007340 	stcne	3, cr7, [r0], {64}	; 0x40
    6f1c:	004fea9f 	umaaleq	lr, pc, pc, sl	; <UNPREDICTABLE>
    6f20:	004ff200 	subeq	pc, pc, r0, lsl #4
    6f24:	08000600 	stmdaeq	r0, {r9, sl}
    6f28:	1c007340 	stcne	3, cr7, [r0], {64}	; 0x40
    6f2c:	0050049f 			; <UNDEFINED> instruction: 0x0050049f
    6f30:	00501100 	subseq	r1, r0, r0, lsl #2
    6f34:	08000600 	stmdaeq	r0, {r9, sl}
    6f38:	1c007340 	stcne	3, cr7, [r0], {64}	; 0x40
    6f3c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    6f40:	00000000 	andeq	r0, r0, r0
    6f44:	00502800 	subseq	r2, r0, r0, lsl #16
    6f48:	00505000 	subseq	r5, r0, r0
    6f4c:	50000100 	andpl	r0, r0, r0, lsl #2
    6f50:	00005050 	andeq	r5, r0, r0, asr r0
    6f54:	00005240 	andeq	r5, r0, r0, asr #4
    6f58:	00540001 	subseq	r0, r4, r1
    6f5c:	00000000 	andeq	r0, r0, r0
    6f60:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    6f64:	a8000050 	stmdage	r0, {r4, r6}
    6f68:	01000050 	qaddeq	r0, r0, r0
    6f6c:	50a85100 	adcpl	r5, r8, r0, lsl #2
    6f70:	518a0000 	orrpl	r0, sl, r0
    6f74:	00010000 	andeq	r0, r1, r0
    6f78:	00518a55 	subseq	r8, r1, r5, asr sl
    6f7c:	00519400 	subseq	r9, r1, r0, lsl #8
    6f80:	51000100 	mrspl	r0, (UNDEF: 16)
    6f84:	00005194 	muleq	r0, r4, r1
    6f88:	000051dc 	ldrdeq	r5, [r0], -ip
    6f8c:	dc550001 	mrrcle	0, 0, r0, r5, cr1
    6f90:	e2000051 	and	r0, r0, #81	; 0x51
    6f94:	01000051 	qaddeq	r0, r1, r0
    6f98:	51e25100 	mvnpl	r5, r0, lsl #2
    6f9c:	52400000 	subpl	r0, r0, #0
    6fa0:	00010000 	andeq	r0, r1, r0
    6fa4:	00000055 	andeq	r0, r0, r5, asr r0
    6fa8:	00000000 	andeq	r0, r0, r0
    6fac:	00505600 	subseq	r5, r0, r0, lsl #12
    6fb0:	0050a800 	subseq	sl, r0, r0, lsl #16
    6fb4:	56000100 	strpl	r0, [r0], -r0, lsl #2
    6fb8:	0000518a 	andeq	r5, r0, sl, lsl #3
    6fbc:	000051b6 			; <UNDEFINED> instruction: 0x000051b6
    6fc0:	dc560001 	mrrcle	0, 0, r0, r6, cr1
    6fc4:	e2000051 	and	r0, r0, #81	; 0x51
    6fc8:	01000051 	qaddeq	r0, r1, r0
    6fcc:	52285600 	eorpl	r5, r8, #0, 12
    6fd0:	522c0000 	eorpl	r0, ip, #0
    6fd4:	00010000 	andeq	r0, r1, r0
    6fd8:	00000056 	andeq	r0, r0, r6, asr r0
    6fdc:	00000000 	andeq	r0, r0, r0
    6fe0:	00505600 	subseq	r5, r0, r0, lsl #12
    6fe4:	0050a800 	subseq	sl, r0, r0, lsl #16
    6fe8:	58000100 	stmdapl	r0, {r8}
    6fec:	0000518a 	andeq	r5, r0, sl, lsl #3
    6ff0:	000051a6 	andeq	r5, r0, r6, lsr #3
    6ff4:	dc580001 	mrrcle	0, 0, r0, r8, cr1
    6ff8:	e2000051 	and	r0, r0, #81	; 0x51
    6ffc:	01000051 	qaddeq	r0, r1, r0
    7000:	00005800 	andeq	r5, r0, r0, lsl #16
    7004:	00000000 	andeq	r0, r0, r0
    7008:	50560000 	subspl	r0, r6, r0
    700c:	50a80000 	adcpl	r0, r8, r0
    7010:	00010000 	andeq	r0, r1, r0
    7014:	00518a50 	subseq	r8, r1, r0, asr sl
    7018:	00519200 	subseq	r9, r1, r0, lsl #4
    701c:	50000100 	andpl	r0, r0, r0, lsl #2
    7020:	000051dc 	ldrdeq	r5, [r0], -ip
    7024:	000051e2 	andeq	r5, r0, r2, ror #3
    7028:	00500001 	subseq	r0, r0, r1
    702c:	00000000 	andeq	r0, r0, r0
    7030:	56000000 	strpl	r0, [r0], -r0
    7034:	a8000050 	stmdage	r0, {r4, r6}
    7038:	01000050 	qaddeq	r0, r0, r0
    703c:	518a5200 	orrpl	r5, sl, r0, lsl #4
    7040:	51980000 	orrspl	r0, r8, r0
    7044:	00010000 	andeq	r0, r1, r0
    7048:	0051dc52 	subseq	sp, r1, r2, asr ip
    704c:	0051e200 	subseq	lr, r1, r0, lsl #4
    7050:	52000100 	andpl	r0, r0, #0, 2
	...
    705c:	00005056 	andeq	r5, r0, r6, asr r0
    7060:	000050a8 	andeq	r5, r0, r8, lsr #1
    7064:	8a580001 	bhi	1607070 <_etext+0x15ffb58>
    7068:	a6000051 			; <UNDEFINED> instruction: 0xa6000051
    706c:	01000051 	qaddeq	r0, r1, r0
    7070:	51ac5800 			; <UNDEFINED> instruction: 0x51ac5800
    7074:	51b60000 			; <UNDEFINED> instruction: 0x51b60000
    7078:	00010000 	andeq	r0, r1, r0
    707c:	0051b658 	subseq	fp, r1, r8, asr r6
    7080:	0051ba00 	subseq	fp, r1, r0, lsl #20
    7084:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    7088:	000051ba 			; <UNDEFINED> instruction: 0x000051ba
    708c:	000051c0 	andeq	r5, r0, r0, asr #3
    7090:	c0770004 	rsbsgt	r0, r7, r4
    7094:	51c09f00 	bicpl	r9, r0, r0, lsl #30
    7098:	51dc0000 	bicspl	r0, ip, r0
    709c:	00010000 	andeq	r0, r1, r0
    70a0:	0051dc57 	subseq	sp, r1, r7, asr ip
    70a4:	0051e200 	subseq	lr, r1, r0, lsl #4
    70a8:	58000100 	stmdapl	r0, {r8}
    70ac:	00005228 	andeq	r5, r0, r8, lsr #4
    70b0:	0000522e 	andeq	r5, r0, lr, lsr #4
    70b4:	00580001 	subseq	r0, r8, r1
    70b8:	00000000 	andeq	r0, r0, r0
    70bc:	56000000 	strpl	r0, [r0], -r0
    70c0:	a8000050 	stmdage	r0, {r4, r6}
    70c4:	06000050 			; <UNDEFINED> instruction: 0x06000050
    70c8:	02c40300 	sbceq	r0, r4, #0, 6
    70cc:	8a9f2000 	bhi	fe7cf0d4 <BootRAM+0xd73f875>
    70d0:	ac000051 	stcge	0, cr0, [r0], {81}	; 0x51
    70d4:	06000051 			; <UNDEFINED> instruction: 0x06000051
    70d8:	02c40300 	sbceq	r0, r4, #0, 6
    70dc:	ac9f2000 	ldcge	0, cr2, [pc], {0}
    70e0:	b6000051 			; <UNDEFINED> instruction: 0xb6000051
    70e4:	01000051 	qaddeq	r0, r1, r0
    70e8:	51b65900 			; <UNDEFINED> instruction: 0x51b65900
    70ec:	51da0000 	bicspl	r0, sl, r0
    70f0:	00010000 	andeq	r0, r1, r0
    70f4:	0051dc56 	subseq	sp, r1, r6, asr ip
    70f8:	0051e200 	subseq	lr, r1, r0, lsl #4
    70fc:	03000600 	movweq	r0, #1536	; 0x600
    7100:	200002c4 	andcs	r0, r0, r4, asr #5
    7104:	0052289f 			; <UNDEFINED> instruction: 0x0052289f
    7108:	00522e00 	subseq	r2, r2, r0, lsl #28
    710c:	59000100 	stmdbpl	r0, {r8}
	...
    7118:	00005056 	andeq	r5, r0, r6, asr r0
    711c:	000050a8 	andeq	r5, r0, r8, lsr #1
    7120:	8a560001 	bhi	158712c <_etext+0x157fc14>
    7124:	ac000051 	stcge	0, cr0, [r0], {81}	; 0x51
    7128:	01000051 	qaddeq	r0, r1, r0
    712c:	51ac5600 			; <UNDEFINED> instruction: 0x51ac5600
    7130:	51dc0000 	bicspl	r0, ip, r0
    7134:	00020000 	andeq	r0, r2, r0
    7138:	51dc9f30 	bicspl	r9, ip, r0, lsr pc
    713c:	51e20000 	mvnpl	r0, r0
    7140:	00010000 	andeq	r0, r1, r0
    7144:	00522856 	subseq	r2, r2, r6, asr r8
    7148:	00522e00 	subseq	r2, r2, r0, lsl #28
    714c:	30000200 	andcc	r0, r0, r0, lsl #4
    7150:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    7154:	00000000 	andeq	r0, r0, r0
    7158:	00505600 	subseq	r5, r0, r0, lsl #12
    715c:	00509e00 	subseq	r9, r0, r0, lsl #28
    7160:	08000600 	stmdaeq	r0, {r9, sl}
    7164:	1c007640 	stcne	6, cr7, [r0], {64}	; 0x40
    7168:	00509e9f 			; <UNDEFINED> instruction: 0x00509e9f
    716c:	0050a800 	subseq	sl, r0, r0, lsl #16
    7170:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    7174:	0000518a 	andeq	r5, r0, sl, lsl #3
    7178:	000051ac 	andeq	r5, r0, ip, lsr #3
    717c:	ac570001 	mrrcge	0, 0, r0, r7, cr1
    7180:	b6000051 			; <UNDEFINED> instruction: 0xb6000051
    7184:	06000051 			; <UNDEFINED> instruction: 0x06000051
    7188:	76400800 	strbvc	r0, [r0], -r0, lsl #16
    718c:	dc9f1c00 	ldcle	12, cr1, [pc], {0}
    7190:	e2000051 	and	r0, r0, #81	; 0x51
    7194:	06000051 			; <UNDEFINED> instruction: 0x06000051
    7198:	76400800 	strbvc	r0, [r0], -r0, lsl #16
    719c:	289f1c00 	ldmcs	pc, {sl, fp, ip}	; <UNPREDICTABLE>
    71a0:	2c000052 	stccs	0, cr0, [r0], {82}	; 0x52
    71a4:	06000052 			; <UNDEFINED> instruction: 0x06000052
    71a8:	76400800 	strbvc	r0, [r0], -r0, lsl #16
    71ac:	009f1c00 	addseq	r1, pc, r0, lsl #24
    71b0:	00000000 	andeq	r0, r0, r0
    71b4:	b6000000 	strlt	r0, [r0], -r0
    71b8:	8a000050 	bhi	7300 <round_k+0xb8>
    71bc:	02000051 	andeq	r0, r0, #81	; 0x51
    71c0:	e29f3800 	adds	r3, pc, #0, 16
    71c4:	28000051 	stmdacs	r0, {r0, r4, r6}
    71c8:	02000052 	andeq	r0, r0, #82	; 0x52
    71cc:	2e9f3800 	cdpcs	8, 9, cr3, cr15, cr0, {0}
    71d0:	40000052 	andmi	r0, r0, r2, asr r0
    71d4:	02000052 	andeq	r0, r0, #82	; 0x52
    71d8:	009f3800 	addseq	r3, pc, r0, lsl #16
    71dc:	00000000 	andeq	r0, r0, r0
    71e0:	b6000000 	strlt	r0, [r0], -r0
    71e4:	86000050 			; <UNDEFINED> instruction: 0x86000050
    71e8:	01000051 	qaddeq	r0, r1, r0
    71ec:	51865d00 	orrpl	r5, r6, r0, lsl #26
    71f0:	518a0000 	orrpl	r0, sl, r0
    71f4:	00030000 	andeq	r0, r3, r0
    71f8:	e29f5091 	adds	r5, pc, #145	; 0x91
    71fc:	28000051 	stmdacs	r0, {r0, r4, r6}
    7200:	01000052 	qaddeq	r0, r2, r0
    7204:	522e5d00 	eorpl	r5, lr, #0, 26
    7208:	52400000 	subpl	r0, r0, #0
    720c:	00010000 	andeq	r0, r1, r0
    7210:	0000005d 	andeq	r0, r0, sp, asr r0
    7214:	00000000 	andeq	r0, r0, r0
    7218:	0050b600 	subseq	fp, r0, r0, lsl #12
    721c:	00518a00 	subseq	r8, r1, r0, lsl #20
    7220:	54000100 	strpl	r0, [r0], #-256	; 0x100
    7224:	000051e2 	andeq	r5, r0, r2, ror #3
    7228:	00005228 	andeq	r5, r0, r8, lsr #4
    722c:	2e540001 	cdpcs	0, 5, cr0, cr4, cr1, {0}
    7230:	40000052 	andmi	r0, r0, r2, asr r0
    7234:	01000052 	qaddeq	r0, r2, r0
    7238:	00005400 	andeq	r5, r0, r0, lsl #8
    723c:	00000000 	andeq	r0, r0, r0
    7240:	50b60000 	adcspl	r0, r6, r0
    7244:	50e20000 	rscpl	r0, r2, r0
    7248:	00020000 	andeq	r0, r2, r0
    724c:	51e29f38 	mvnpl	r9, r8, lsr pc
    7250:	52020000 	andpl	r0, r2, #0
    7254:	00020000 	andeq	r0, r2, r0
    7258:	52029f38 	andpl	r9, r2, #56, 30	; 0xe0
    725c:	520c0000 	andpl	r0, ip, #0
    7260:	00010000 	andeq	r0, r1, r0
    7264:	00520c56 	subseq	r0, r2, r6, asr ip
    7268:	00521200 	subseq	r1, r2, r0, lsl #4
    726c:	76000400 	strvc	r0, [r0], -r0, lsl #8
    7270:	129f00c0 	addsne	r0, pc, #192	; 0xc0
    7274:	1e000052 	mcrne	0, 0, r0, cr0, cr2, {2}
    7278:	01000052 	qaddeq	r0, r2, r0
    727c:	522e5600 	eorpl	r5, lr, #0, 12
    7280:	52400000 	subpl	r0, r0, #0
    7284:	00010000 	andeq	r0, r1, r0
    7288:	00000056 	andeq	r0, r0, r6, asr r0
    728c:	00000000 	andeq	r0, r0, r0
    7290:	0050b600 	subseq	fp, r0, r0, lsl #12
    7294:	0050e200 	subseq	lr, r0, r0, lsl #4
    7298:	5d000100 	stfpls	f0, [r0, #-0]
    729c:	000051e2 	andeq	r5, r0, r2, ror #3
    72a0:	00005202 	andeq	r5, r0, r2, lsl #4
    72a4:	025d0001 	subseq	r0, sp, #1
    72a8:	08000052 	stmdaeq	r0, {r1, r4, r6}
    72ac:	01000052 	qaddeq	r0, r2, r0
    72b0:	52085900 	andpl	r5, r8, #0, 18
    72b4:	52280000 	eorpl	r0, r8, #0
    72b8:	00010000 	andeq	r0, r1, r0
    72bc:	00522e57 	subseq	r2, r2, r7, asr lr
    72c0:	00524000 	subseq	r4, r2, r0
    72c4:	59000100 	stmdbpl	r0, {r8}
	...
    72d0:	000050c4 	andeq	r5, r0, r4, asr #1
    72d4:	000050e2 	andeq	r5, r0, r2, ror #1
    72d8:	e2580001 	subs	r0, r8, #1
    72dc:	02000051 	andeq	r0, r0, #81	; 0x51
    72e0:	01000052 	qaddeq	r0, r2, r0
    72e4:	52025800 	andpl	r5, r2, #0, 16
    72e8:	52280000 	eorpl	r0, r8, #0
    72ec:	00020000 	andeq	r0, r2, r0
    72f0:	522e9f30 	eorpl	r9, lr, #48, 30	; 0xc0
    72f4:	52400000 	subpl	r0, r0, #0
    72f8:	00020000 	andeq	r0, r2, r0
    72fc:	00009f30 	andeq	r9, r0, r0, lsr pc
    7300:	00000000 	andeq	r0, r0, r0
    7304:	50c40000 	sbcpl	r0, r4, r0
    7308:	50e20000 	rscpl	r0, r2, r0
    730c:	00060000 	andeq	r0, r6, r0
    7310:	00784008 	rsbseq	r4, r8, r8
    7314:	51e29f1c 	mvnpl	r9, ip, lsl pc
    7318:	52260000 	eorpl	r0, r6, #0
    731c:	00060000 	andeq	r0, r6, r0
    7320:	00784008 	rsbseq	r4, r8, r8
    7324:	52269f1c 	eorpl	r9, r6, #28, 30	; 0x70
    7328:	52280000 	eorpl	r0, r8, #0
    732c:	00060000 	andeq	r0, r6, r0
    7330:	00764808 	rsbseq	r4, r6, r8, lsl #16
    7334:	522e9f1c 	eorpl	r9, lr, #28, 30	; 0x70
    7338:	52380000 	eorspl	r0, r8, #0
    733c:	00060000 	andeq	r0, r6, r0
    7340:	00784008 	rsbseq	r4, r8, r8
    7344:	52389f1c 	eorspl	r9, r8, #28, 30	; 0x70
    7348:	52400000 	subpl	r0, r0, #0
    734c:	00050000 	andeq	r0, r5, r0
    7350:	1c007638 	stcne	6, cr7, [r0], {56}	; 0x38
    7354:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    7358:	00000000 	andeq	r0, r0, r0
    735c:	00524000 	subseq	r4, r2, r0
    7360:	00525000 	subseq	r5, r2, r0
    7364:	50000100 	andpl	r0, r0, r0, lsl #2
    7368:	00005250 	andeq	r5, r0, r0, asr r2
    736c:	000056ce 	andeq	r5, r0, lr, asr #13
    7370:	9c910003 	ldcls	0, cr0, [r1], {3}
    7374:	0056ce7e 	subseq	ip, r6, lr, ror lr
    7378:	0056d400 	subseq	sp, r6, r0, lsl #8
    737c:	7d000300 	stcvc	3, cr0, [r0, #-0]
    7380:	00007e9c 	muleq	r0, ip, lr
    7384:	00000000 	andeq	r0, r0, r0
    7388:	52400000 	subpl	r0, r0, #0
    738c:	52500000 	subspl	r0, r0, #0
    7390:	00010000 	andeq	r0, r1, r0
    7394:	00525051 	subseq	r5, r2, r1, asr r0
    7398:	00531400 	subseq	r1, r3, r0, lsl #8
    739c:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    73a8:	00005340 	andeq	r5, r0, r0, asr #6
    73ac:	00005368 	andeq	r5, r0, r8, ror #6
    73b0:	93500006 	cmpls	r0, #6
    73b4:	04935104 	ldreq	r5, [r3], #260	; 0x104
    73b8:	00005368 	andeq	r5, r0, r8, ror #6
    73bc:	0000537e 	andeq	r5, r0, lr, ror r3
    73c0:	00710002 	rsbseq	r0, r1, r2
    73c4:	0000537e 	andeq	r5, r0, lr, ror r3
    73c8:	0000539c 	muleq	r0, ip, r3
    73cc:	00750002 	rsbseq	r0, r5, r2
    73d0:	0000539c 	muleq	r0, ip, r3
    73d4:	000053ce 	andeq	r5, r0, lr, asr #7
    73d8:	93500006 	cmpls	r0, #6
    73dc:	04935104 	ldreq	r5, [r3], #260	; 0x104
    73e0:	000053ce 	andeq	r5, r0, lr, asr #7
    73e4:	000055fe 	strdeq	r5, [r0], -lr
    73e8:	935a0006 	cmpls	sl, #6
    73ec:	04935b04 	ldreq	r5, [r3], #2820	; 0xb04
    73f0:	000055fe 	strdeq	r5, [r0], -lr
    73f4:	00005610 	andeq	r5, r0, r0, lsl r6
    73f8:	93500006 	cmpls	r0, #6
    73fc:	04935104 	ldreq	r5, [r3], #260	; 0x104
	...
    7408:	00005340 	andeq	r5, r0, r0, asr #6
    740c:	0000539c 	muleq	r0, ip, r3
    7410:	80910003 	addshi	r0, r1, r3
    7414:	00539c7d 	subseq	r9, r3, sp, ror ip
    7418:	0053cc00 	subseq	ip, r3, r0, lsl #24
    741c:	5a000600 	bpl	8c24 <_etext+0x170c>
    7420:	935b0493 	cmpls	fp, #-1828716544	; 0x93000000
    7424:	0053cc04 	subseq	ip, r3, r4, lsl #24
    7428:	0055f800 	subseq	pc, r5, r0, lsl #16
    742c:	91000300 	mrsls	r0, LR_irq
    7430:	55f87d80 	ldrbpl	r7, [r8, #3456]!	; 0xd80
    7434:	56180000 	ldrpl	r0, [r8], -r0
    7438:	00060000 	andeq	r0, r6, r0
    743c:	5b04935a 	blpl	12c1ac <_etext+0x124c94>
    7440:	00000493 	muleq	r0, r3, r4
    7444:	00000000 	andeq	r0, r0, r0
    7448:	53400000 	movtpl	r0, #0
    744c:	539c0000 	orrspl	r0, ip, #0
    7450:	00030000 	andeq	r0, r3, r0
    7454:	9c7d8891 	ldclls	8, cr8, [sp], #-580	; 0xfffffdbc
    7458:	c8000053 	stmdagt	r0, {r0, r1, r4, r6}
    745c:	03000053 	movweq	r0, #83	; 0x53
    7460:	7d809100 	stfvcd	f1, [r0]
    7464:	000053ce 	andeq	r5, r0, lr, asr #7
    7468:	000055f8 	strdeq	r5, [r0], -r8
    746c:	88910003 	ldmhi	r1, {r0, r1}
    7470:	0055f87d 	subseq	pc, r5, sp, ror r8	; <UNPREDICTABLE>
    7474:	0056ce00 	subseq	ip, r6, r0, lsl #28
    7478:	91000300 	mrsls	r0, LR_irq
    747c:	56ce7d80 	strbpl	r7, [lr], r0, lsl #27
    7480:	56d40000 	ldrbpl	r0, [r4], r0
    7484:	00030000 	andeq	r0, r3, r0
    7488:	007d807d 	rsbseq	r8, sp, sp, ror r0
    748c:	00000000 	andeq	r0, r0, r0
    7490:	4c000000 	stcmi	0, cr0, [r0], {-0}
    7494:	5e000053 	mcrpl	0, 0, r0, cr0, cr3, {2}
    7498:	06000053 			; <UNDEFINED> instruction: 0x06000053
    749c:	04935600 	ldreq	r5, [r3], #1536	; 0x600
    74a0:	5e049357 	mcrpl	3, 0, r9, cr4, cr7, {2}
    74a4:	7e000053 	mcrvc	0, 0, r0, cr0, cr3, {2}
    74a8:	02000053 	andeq	r0, r0, #83	; 0x53
    74ac:	7e187100 	mufvce	f7, f0, f0
    74b0:	9c000053 	stcls	0, cr0, [r0], {83}	; 0x53
    74b4:	02000053 	andeq	r0, r0, #83	; 0x53
    74b8:	9c187500 	cfldr32ls	mvfx7, [r8], {-0}
    74bc:	bc000053 	stclt	0, cr0, [r0], {83}	; 0x53
    74c0:	03000053 	movweq	r0, #83	; 0x53
    74c4:	7d889100 	stfvcd	f1, [r8]
    74c8:	000053ce 	andeq	r5, r0, lr, asr #7
    74cc:	000055f8 	strdeq	r5, [r0], -r8
    74d0:	f8910003 			; <UNDEFINED> instruction: 0xf8910003
    74d4:	0055f87d 	subseq	pc, r5, sp, ror r8	; <UNPREDICTABLE>
    74d8:	0056ce00 	subseq	ip, r6, r0, lsl #28
    74dc:	91000300 	mrsls	r0, LR_irq
    74e0:	56ce7d88 	strbpl	r7, [lr], r8, lsl #27
    74e4:	56d40000 	ldrbpl	r0, [r4], r0
    74e8:	00030000 	andeq	r0, r3, r0
    74ec:	007d887d 	rsbseq	r8, sp, sp, ror r8
    74f0:	00000000 	andeq	r0, r0, r0
    74f4:	84000000 	strhi	r0, [r0], #-0
    74f8:	8a000053 	bhi	764c <_etext+0x134>
    74fc:	06000053 			; <UNDEFINED> instruction: 0x06000053
    7500:	04935a00 	ldreq	r5, [r3], #2560	; 0xa00
    7504:	8a04935b 	bhi	12c278 <_etext+0x124d60>
    7508:	9c000053 	stcls	0, cr0, [r0], {83}	; 0x53
    750c:	02000053 	andeq	r0, r0, #83	; 0x53
    7510:	9c207500 	cfstr32ls	mvfx7, [r0], #-0
    7514:	c4000053 	strgt	r0, [r0], #-83	; 0x53
    7518:	06000053 			; <UNDEFINED> instruction: 0x06000053
    751c:	04935200 	ldreq	r5, [r3], #512	; 0x200
    7520:	ce049353 	mcrgt	3, 0, r9, cr4, cr3, {2}
    7524:	f8000053 			; <UNDEFINED> instruction: 0xf8000053
    7528:	06000055 			; <UNDEFINED> instruction: 0x06000055
    752c:	04935800 	ldreq	r5, [r3], #2048	; 0x800
    7530:	f8049359 			; <UNDEFINED> instruction: 0xf8049359
    7534:	0c000055 	stceq	0, cr0, [r0], {85}	; 0x55
    7538:	06000056 			; <UNDEFINED> instruction: 0x06000056
    753c:	04935200 	ldreq	r5, [r3], #512	; 0x200
    7540:	00049353 	andeq	r9, r4, r3, asr r3
    7544:	00000000 	andeq	r0, r0, r0
    7548:	84000000 	strhi	r0, [r0], #-0
    754c:	9c000053 	stcls	0, cr0, [r0], {83}	; 0x53
    7550:	02000053 	andeq	r0, r0, #83	; 0x53
    7554:	9c287500 	cfstr32ls	mvfx7, [r8], #-0
    7558:	c2000053 	andgt	r0, r0, #83	; 0x53
    755c:	06000053 			; <UNDEFINED> instruction: 0x06000053
    7560:	04935800 	ldreq	r5, [r3], #2048	; 0x800
    7564:	c2049359 	andgt	r9, r4, #1677721601	; 0x64000001
    7568:	ee000053 	mcr	0, 0, r0, cr0, cr3, {2}
    756c:	03000055 	movweq	r0, #85	; 0x55
    7570:	7da09100 	stfvcd	f1, [r0]
    7574:	000055ee 	andeq	r5, r0, lr, ror #11
    7578:	00005614 	andeq	r5, r0, r4, lsl r6
    757c:	93580006 	cmpls	r8, #6
    7580:	04935904 	ldreq	r5, [r3], #2308	; 0x904
	...
    758c:	00005384 	andeq	r5, r0, r4, lsl #7
    7590:	0000539c 	muleq	r0, ip, r3
    7594:	30750002 	rsbscc	r0, r5, r2
    7598:	0000539c 	muleq	r0, ip, r3
    759c:	000053c0 	andeq	r5, r0, r0, asr #7
    75a0:	a0910003 	addsge	r0, r1, r3
    75a4:	0053ce7d 	subseq	ip, r3, sp, ror lr
    75a8:	0055ee00 	subseq	lr, r5, r0, lsl #28
    75ac:	91000300 	mrsls	r0, LR_irq
    75b0:	55ee7d98 	strbpl	r7, [lr, #3480]!	; 0xd98
    75b4:	56ce0000 	strbpl	r0, [lr], r0
    75b8:	00030000 	andeq	r0, r3, r0
    75bc:	ce7da091 	mrcgt	0, 3, sl, cr13, cr1, {4}
    75c0:	d4000056 	strle	r0, [r0], #-86	; 0x56
    75c4:	03000056 	movweq	r0, #86	; 0x56
    75c8:	7da07d00 	stcvc	13, cr7, [r0]
	...
    75d4:	00005384 	andeq	r5, r0, r4, lsl #7
    75d8:	0000539c 	muleq	r0, ip, r3
    75dc:	93540006 	cmpls	r4, #6
    75e0:	04935504 	ldreq	r5, [r3], #1284	; 0x504
    75e4:	0000539c 	muleq	r0, ip, r3
    75e8:	000053b8 			; <UNDEFINED> instruction: 0x000053b8
    75ec:	98910003 	ldmls	r1, {r0, r1}
    75f0:	0053ce7d 	subseq	ip, r3, sp, ror lr
    75f4:	0055ee00 	subseq	lr, r5, r0, lsl #28
    75f8:	91000300 	mrsls	r0, LR_irq
    75fc:	55ee7e80 	strbpl	r7, [lr, #3712]!	; 0xe80
    7600:	56ce0000 	strbpl	r0, [lr], r0
    7604:	00030000 	andeq	r0, r3, r0
    7608:	ce7d9891 	mrcgt	8, 3, r9, cr13, cr1, {4}
    760c:	d4000056 	strle	r0, [r0], #-86	; 0x56
    7610:	03000056 	movweq	r0, #86	; 0x56
    7614:	7d987d00 	ldcvc	13, cr7, [r8]
	...
    7620:	00005240 	andeq	r5, r0, r0, asr #4
    7624:	00005250 	andeq	r5, r0, r0, asr r2
    7628:	9f300002 	svcls	0x00300002
    762c:	00005384 	andeq	r5, r0, r4, lsl #7
    7630:	0000539c 	muleq	r0, ip, r3
    7634:	9f300002 	svcls	0x00300002
    7638:	0000539c 	muleq	r0, ip, r3
    763c:	000053f0 	strdeq	r5, [r0], -r0
    7640:	f05c0001 			; <UNDEFINED> instruction: 0xf05c0001
    7644:	fe000053 	mcr2	0, 0, r0, cr0, cr3, {2}
    7648:	03000055 	movweq	r0, #85	; 0x55
    764c:	9f7f7c00 	svcls	0x007f7c00
    7650:	000055fe 	strdeq	r5, [r0], -lr
    7654:	00005688 	andeq	r5, r0, r8, lsl #13
    7658:	005c0001 	subseq	r0, ip, r1
    765c:	00000000 	andeq	r0, r0, r0
    7660:	50000000 	andpl	r0, r0, r0
    7664:	5e000052 	mcrpl	0, 0, r0, cr0, cr2, {2}
    7668:	03000052 	movweq	r0, #82	; 0x52
    766c:	9f017400 	svcls	0x00017400
    7670:	0000525e 	andeq	r5, r0, lr, asr r2
    7674:	0000526e 	andeq	r5, r0, lr, ror #4
    7678:	02740003 	rsbseq	r0, r4, #3
    767c:	00526e9f 			; <UNDEFINED> instruction: 0x00526e9f
    7680:	00528c00 	subseq	r8, r2, r0, lsl #24
    7684:	74000300 	strvc	r0, [r0], #-768	; 0x300
    7688:	528c9f03 	addpl	r9, ip, #3, 30
    768c:	52aa0000 	adcpl	r0, sl, #0
    7690:	00030000 	andeq	r0, r3, r0
    7694:	aa9f0474 	bge	fe7c886c <BootRAM+0xd73900d>
    7698:	c4000052 	strgt	r0, [r0], #-82	; 0x52
    769c:	03000052 	movweq	r0, #82	; 0x52
    76a0:	9f057400 	svcls	0x00057400
    76a4:	000052c4 	andeq	r5, r0, r4, asr #5
    76a8:	000052dc 	ldrdeq	r5, [r0], -ip
    76ac:	06740003 	ldrbteq	r0, [r4], -r3
    76b0:	0052dc9f 			; <UNDEFINED> instruction: 0x0052dc9f
    76b4:	0052f000 	subseq	pc, r2, r0
    76b8:	74000300 	strvc	r0, [r0], #-768	; 0x300
    76bc:	52f09f07 	rscspl	r9, r0, #7, 30
    76c0:	52f60000 	rscspl	r0, r6, #0
    76c4:	00030000 	andeq	r0, r3, r0
    76c8:	f69f0874 			; <UNDEFINED> instruction: 0xf69f0874
    76cc:	14000052 	strne	r0, [r0], #-82	; 0x52
    76d0:	01000053 	qaddeq	r0, r3, r0
    76d4:	00005400 	andeq	r5, r0, r0, lsl #8
    76d8:	00000000 	andeq	r0, r0, r0
    76dc:	52500000 	subspl	r0, r0, #0
    76e0:	525e0000 	subspl	r0, lr, #0
    76e4:	00090000 	andeq	r0, r9, r0
    76e8:	01940074 	orrseq	r0, r4, r4, ror r0
    76ec:	25f72cf7 	ldrbcs	r2, [r7, #3319]!	; 0xcf7
    76f0:	00525e9f 			; <UNDEFINED> instruction: 0x00525e9f
    76f4:	00526e00 	subseq	r6, r2, r0, lsl #28
    76f8:	74001000 	strvc	r1, [r0], #-0
    76fc:	f7019401 			; <UNDEFINED> instruction: 0xf7019401
    7700:	9125f72c 	msrls	SP_abt, ip
    7704:	08f67d90 	ldmeq	r6!, {r4, r7, r8, sl, fp, ip, sp, lr}^
    7708:	6e9f2125 	fmlvsep	f2, f7, f5
    770c:	8c000052 	stchi	0, cr0, [r0], {82}	; 0x52
    7710:	0d000052 	stceq	0, cr0, [r0, #-328]	; 0xfffffeb8
    7714:	94027400 	strls	r7, [r2], #-1024	; 0x400
    7718:	f72cf701 			; <UNDEFINED> instruction: 0xf72cf701
    771c:	2506f525 	strcs	pc, [r6, #-1317]	; 0x525
    7720:	528c9f21 	addpl	r9, ip, #33, 30	; 0x84
    7724:	52aa0000 	adcpl	r0, sl, #0
    7728:	00100000 	andseq	r0, r0, r0
    772c:	01940374 	orrseq	r0, r4, r4, ror r3
    7730:	25f72cf7 	ldrbcs	r2, [r7, #3319]!	; 0xcf7
    7734:	f67d8091 			; <UNDEFINED> instruction: 0xf67d8091
    7738:	9f212508 	svcls	0x00212508
    773c:	000052aa 	andeq	r5, r0, sl, lsr #5
    7740:	000052c4 	andeq	r5, r0, r4, asr #5
    7744:	04740010 	ldrbteq	r0, [r4], #-16
    7748:	2cf70194 	ldfcse	f0, [r7], #592	; 0x250
    774c:	889125f7 	ldmhi	r1, {r0, r1, r2, r4, r5, r6, r7, r8, sl, sp}
    7750:	2508f67d 	strcs	pc, [r8, #-1661]	; 0x67d
    7754:	52c49f21 	sbcpl	r9, r4, #33, 30	; 0x84
    7758:	52dc0000 	sbcspl	r0, ip, #0
    775c:	000d0000 	andeq	r0, sp, r0
    7760:	01940574 	orrseq	r0, r4, r4, ror r5
    7764:	25f72cf7 	ldrbcs	r2, [r7, #3319]!	; 0xcf7
    7768:	21250af5 	strdcs	r0, [r5, -r5]!
    776c:	0052dc9f 			; <UNDEFINED> instruction: 0x0052dc9f
    7770:	0052f000 	subseq	pc, r2, r0
    7774:	74000d00 	strvc	r0, [r0], #-3328	; 0xd00
    7778:	f7019406 			; <UNDEFINED> instruction: 0xf7019406
    777c:	f525f72c 			; <UNDEFINED> instruction: 0xf525f72c
    7780:	9f212508 	svcls	0x00212508
    7784:	000052f0 	strdeq	r5, [r0], -r0
    7788:	000052f6 	strdeq	r5, [r0], -r6
    778c:	0774000d 	ldrbeq	r0, [r4, -sp]!
    7790:	2cf70194 	ldfcse	f0, [r7], #592	; 0x250
    7794:	02f525f7 	rscseq	r2, r5, #1035993088	; 0x3dc00000
    7798:	f69f2125 			; <UNDEFINED> instruction: 0xf69f2125
    779c:	0a000052 	beq	78ec <_etext+0x3d4>
    77a0:	0d000053 	stceq	0, cr0, [r0, #-332]	; 0xfffffeb4
    77a4:	947f7400 	ldrbtls	r7, [pc], #-1024	; 77ac <_etext+0x294>
    77a8:	f72cf701 			; <UNDEFINED> instruction: 0xf72cf701
    77ac:	2502f525 	strcs	pc, [r2, #-1317]	; 0x525
    77b0:	00009f21 	andeq	r9, r0, r1, lsr #30
    77b4:	00000000 	andeq	r0, r0, r0
    77b8:	545a0000 	ldrbpl	r0, [sl], #-0
    77bc:	55b40000 	ldrpl	r0, [r4, #0]!
    77c0:	00030000 	andeq	r0, r3, r0
    77c4:	007f8075 	rsbseq	r8, pc, r5, ror r0	; <UNPREDICTABLE>
    77c8:	00000000 	andeq	r0, r0, r0
    77cc:	5a000000 	bpl	77d4 <_etext+0x2bc>
    77d0:	6c000054 	stcvs	0, cr0, [r0], {84}	; 0x54
    77d4:	06000054 			; <UNDEFINED> instruction: 0x06000054
    77d8:	04935000 	ldreq	r5, [r3], #0
    77dc:	6c049351 	stcvs	3, cr9, [r4], {81}	; 0x51
    77e0:	c6000054 			; <UNDEFINED> instruction: 0xc6000054
    77e4:	0c000054 	stceq	0, cr0, [r0], {84}	; 0x54
    77e8:	7d909100 	ldfvcd	f1, [r0]
    77ec:	91243306 	teqls	r4, r6, lsl #6
    77f0:	a0082200 	andge	r2, r8, r0, lsl #4
    77f4:	0054c61c 	subseq	ip, r4, ip, lsl r6
    77f8:	00550e00 	subseq	r0, r5, r0, lsl #28
    77fc:	91000c00 	tstls	r0, r0, lsl #24
    7800:	33067d90 	movwcc	r7, #28048	; 0x6d90
    7804:	22007724 	andcs	r7, r0, #36, 14	; 0x900000
    7808:	0e1c8008 	cdpeq	0, 1, cr8, cr12, cr8, {0}
    780c:	b4000055 	strlt	r0, [r0], #-85	; 0x55
    7810:	0c000055 	stceq	0, cr0, [r0], {85}	; 0x55
    7814:	7d909100 	ldfvcd	f1, [r0]
    7818:	91243306 	teqls	r4, r6, lsl #6
    781c:	a0082200 	andge	r2, r8, r0, lsl #4
    7820:	0000001c 	andeq	r0, r0, ip, lsl r0
    7824:	00000000 	andeq	r0, r0, r0
    7828:	00545a00 	subseq	r5, r4, r0, lsl #20
    782c:	00550a00 	subseq	r0, r5, r0, lsl #20
    7830:	52000600 	andpl	r0, r0, #0, 12
    7834:	93530493 	cmpls	r3, #-1828716544	; 0x93000000
    7838:	00550a04 	subseq	r0, r5, r4, lsl #20
    783c:	00550e00 	subseq	r0, r5, r0, lsl #28
    7840:	7c000c00 	stcvc	12, cr0, [r0], {-0}
    7844:	331a3f0d 	tstcc	sl, #13, 30	; 0x34
    7848:	22007724 	andcs	r7, r0, #36, 14	; 0x900000
    784c:	0e1c8008 	cdpeq	0, 1, cr8, cr12, cr8, {0}
    7850:	b4000055 	strlt	r0, [r0], #-85	; 0x55
    7854:	0c000055 	stceq	0, cr0, [r0], {85}	; 0x55
    7858:	3f0d7c00 	svccc	0x000d7c00
    785c:	9124331a 	teqls	r4, sl, lsl r3
    7860:	a0082200 	andge	r2, r8, r0, lsl #4
    7864:	0000001c 	andeq	r0, r0, ip, lsl r0
    7868:	00000000 	andeq	r0, r0, r0
    786c:	00545a00 	subseq	r5, r4, r0, lsl #20
    7870:	0054ca00 	subseq	ip, r4, r0, lsl #20
    7874:	7c000c00 	stcvc	12, cr0, [r0], {-0}
    7878:	331a3f08 	tstcc	sl, #8, 30
    787c:	22009124 	andcs	r9, r0, #36, 2
    7880:	ca1ca808 	bgt	7318a8 <_etext+0x72a390>
    7884:	ce000054 	mcrgt	0, 0, r0, cr0, cr4, {2}
    7888:	0a000054 	beq	79e0 <_etext+0x4c8>
    788c:	33007400 	movwcc	r7, #1024	; 0x400
    7890:	22009124 	andcs	r9, r0, #36, 2
    7894:	ce1ca808 	cdpgt	8, 1, cr10, cr12, cr8, {0}
    7898:	b4000054 	strlt	r0, [r0], #-84	; 0x54
    789c:	0c000055 	stceq	0, cr0, [r0], {85}	; 0x55
    78a0:	3f087c00 	svccc	0x00087c00
    78a4:	9124331a 	teqls	r4, sl, lsl r3
    78a8:	a8082200 	stmdage	r8, {r9, sp}
    78ac:	0000001c 	andeq	r0, r0, ip, lsl r0
    78b0:	00000000 	andeq	r0, r0, r0
    78b4:	00545a00 	subseq	r5, r4, r0, lsl #20
    78b8:	00546c00 	subseq	r6, r4, r0, lsl #24
    78bc:	f5002800 			; <UNDEFINED> instruction: 0xf5002800
    78c0:	f7312500 			; <UNDEFINED> instruction: 0xf7312500
    78c4:	1f141425 	svcne	0x00141425
    78c8:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    78cc:	00f52125 	rscseq	r2, r5, r5, lsr #2
    78d0:	25f73725 	ldrbcs	r3, [r7, #1829]!	; 0x725
    78d4:	00f52725 	rscseq	r2, r5, r5, lsr #14
    78d8:	25f73825 	ldrbcs	r3, [r7, #2085]!	; 0x825
    78dc:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    78e0:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    78e4:	6c9f2721 	ldcvs	7, cr2, [pc], {33}	; 0x21
    78e8:	c6000054 			; <UNDEFINED> instruction: 0xc6000054
    78ec:	4c000054 	stcmi	0, cr0, [r0], {84}	; 0x54
    78f0:	7d909100 	ldfvcd	f1, [r0]
    78f4:	91243306 	teqls	r4, r6, lsl #6
    78f8:	a0082200 	andge	r2, r8, r0, lsl #4
    78fc:	2508f61c 	strcs	pc, [r8, #-1564]	; 0x61c
    7900:	1425f731 	strtne	pc, [r5], #-1841	; 0x731
    7904:	40231f14 	eormi	r1, r3, r4, lsl pc
    7908:	21251724 	teqcs	r5, r4, lsr #14
    790c:	067d9091 			; <UNDEFINED> instruction: 0x067d9091
    7910:	00912433 	addseq	r2, r1, r3, lsr r4
    7914:	1ca00822 	stcne	8, cr0, [r0], #136	; 0x88
    7918:	372508f6 			; <UNDEFINED> instruction: 0x372508f6
    791c:	272525f7 			; <UNDEFINED> instruction: 0x272525f7
    7920:	067d9091 			; <UNDEFINED> instruction: 0x067d9091
    7924:	00912433 	addseq	r2, r1, r3, lsr r4
    7928:	1ca00822 	stcne	8, cr0, [r0], #136	; 0x88
    792c:	382508f6 	stmdacc	r5!, {r1, r2, r4, r5, r6, r7, fp}
    7930:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7934:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7938:	27212517 			; <UNDEFINED> instruction: 0x27212517
    793c:	0054c69f 			; <UNDEFINED> instruction: 0x0054c69f
    7940:	00550e00 	subseq	r0, r5, r0, lsl #28
    7944:	91004c00 	tstls	r0, r0, lsl #24
    7948:	33067d90 	movwcc	r7, #28048	; 0x6d90
    794c:	22007724 	andcs	r7, r0, #36, 14	; 0x900000
    7950:	f61c8008 			; <UNDEFINED> instruction: 0xf61c8008
    7954:	f7312508 			; <UNDEFINED> instruction: 0xf7312508
    7958:	1f141425 	svcne	0x00141425
    795c:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    7960:	90912125 	addsls	r2, r1, r5, lsr #2
    7964:	2433067d 	ldrtcs	r0, [r3], #-1661	; 0x67d
    7968:	08220077 	stmdaeq	r2!, {r0, r1, r2, r4, r5, r6}
    796c:	08f61c80 	ldmeq	r6!, {r7, sl, fp, ip}^
    7970:	25f73725 	ldrbcs	r3, [r7, #1829]!	; 0x725
    7974:	90912725 	addsls	r2, r1, r5, lsr #14
    7978:	2433067d 	ldrtcs	r0, [r3], #-1661	; 0x67d
    797c:	08220077 	stmdaeq	r2!, {r0, r1, r2, r4, r5, r6}
    7980:	08f61c80 	ldmeq	r6!, {r7, sl, fp, ip}^
    7984:	25f73825 	ldrbcs	r3, [r7, #2085]!	; 0x825
    7988:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    798c:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    7990:	0e9f2721 	cdpeq	7, 9, cr2, cr15, cr1, {1}
    7994:	b4000055 	strlt	r0, [r0], #-85	; 0x55
    7998:	4c000055 	stcmi	0, cr0, [r0], {85}	; 0x55
    799c:	7d909100 	ldfvcd	f1, [r0]
    79a0:	91243306 	teqls	r4, r6, lsl #6
    79a4:	a0082200 	andge	r2, r8, r0, lsl #4
    79a8:	2508f61c 	strcs	pc, [r8, #-1564]	; 0x61c
    79ac:	1425f731 	strtne	pc, [r5], #-1841	; 0x731
    79b0:	40231f14 	eormi	r1, r3, r4, lsl pc
    79b4:	21251724 	teqcs	r5, r4, lsr #14
    79b8:	067d9091 			; <UNDEFINED> instruction: 0x067d9091
    79bc:	00912433 	addseq	r2, r1, r3, lsr r4
    79c0:	1ca00822 	stcne	8, cr0, [r0], #136	; 0x88
    79c4:	372508f6 			; <UNDEFINED> instruction: 0x372508f6
    79c8:	272525f7 			; <UNDEFINED> instruction: 0x272525f7
    79cc:	067d9091 			; <UNDEFINED> instruction: 0x067d9091
    79d0:	00912433 	addseq	r2, r1, r3, lsr r4
    79d4:	1ca00822 	stcne	8, cr0, [r0], #136	; 0x88
    79d8:	382508f6 	stmdacc	r5!, {r1, r2, r4, r5, r6, r7, fp}
    79dc:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    79e0:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    79e4:	27212517 			; <UNDEFINED> instruction: 0x27212517
    79e8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    79ec:	00000000 	andeq	r0, r0, r0
    79f0:	00545a00 	subseq	r5, r4, r0, lsl #20
    79f4:	00550a00 	subseq	r0, r5, r0, lsl #20
    79f8:	f5002900 			; <UNDEFINED> instruction: 0xf5002900
    79fc:	f7432502 			; <UNDEFINED> instruction: 0xf7432502
    7a00:	1f141425 	svcne	0x00141425
    7a04:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    7a08:	02f52125 	rscseq	r2, r5, #1073741833	; 0x40000009
    7a0c:	25f73625 	ldrbcs	r3, [r7, #1573]!	; 0x625
    7a10:	02f52725 	rscseq	r2, r5, #9699328	; 0x940000
    7a14:	f73d0825 			; <UNDEFINED> instruction: 0xf73d0825
    7a18:	1f141425 	svcne	0x00141425
    7a1c:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    7a20:	9f272125 	svcls	0x00272125
    7a24:	0000550a 	andeq	r5, r0, sl, lsl #10
    7a28:	0000550e 	andeq	r5, r0, lr, lsl #10
    7a2c:	0d7c004d 	ldcleq	0, cr0, [ip, #-308]!	; 0xfffffecc
    7a30:	24331a3f 	ldrtcs	r1, [r3], #-2623	; 0xa3f
    7a34:	08220077 	stmdaeq	r2!, {r0, r1, r2, r4, r5, r6}
    7a38:	08f61c80 	ldmeq	r6!, {r7, sl, fp, ip}^
    7a3c:	25f74325 	ldrbcs	r4, [r7, #805]!	; 0x325
    7a40:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    7a44:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    7a48:	3f0d7c21 	svccc	0x000d7c21
    7a4c:	7724331a 			; <UNDEFINED> instruction: 0x7724331a
    7a50:	80082200 	andhi	r2, r8, r0, lsl #4
    7a54:	2508f61c 	strcs	pc, [r8, #-1564]	; 0x61c
    7a58:	2525f736 	strcs	pc, [r5, #-1846]!	; 0x736
    7a5c:	3f0d7c27 	svccc	0x000d7c27
    7a60:	7724331a 			; <UNDEFINED> instruction: 0x7724331a
    7a64:	80082200 	andhi	r2, r8, r0, lsl #4
    7a68:	2508f61c 	strcs	pc, [r8, #-1564]	; 0x61c
    7a6c:	25f73d08 	ldrbcs	r3, [r7, #3336]!	; 0xd08
    7a70:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    7a74:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    7a78:	0e9f2721 	cdpeq	7, 9, cr2, cr15, cr1, {1}
    7a7c:	b4000055 	strlt	r0, [r0], #-85	; 0x55
    7a80:	4d000055 	stcmi	0, cr0, [r0, #-340]	; 0xfffffeac
    7a84:	3f0d7c00 	svccc	0x000d7c00
    7a88:	9124331a 	teqls	r4, sl, lsl r3
    7a8c:	a0082200 	andge	r2, r8, r0, lsl #4
    7a90:	2508f61c 	strcs	pc, [r8, #-1564]	; 0x61c
    7a94:	1425f743 	strtne	pc, [r5], #-1859	; 0x743
    7a98:	40231f14 	eormi	r1, r3, r4, lsl pc
    7a9c:	21251724 	teqcs	r5, r4, lsr #14
    7aa0:	1a3f0d7c 	bne	fcb098 <_etext+0xfc3b80>
    7aa4:	00912433 	addseq	r2, r1, r3, lsr r4
    7aa8:	1ca00822 	stcne	8, cr0, [r0], #136	; 0x88
    7aac:	362508f6 			; <UNDEFINED> instruction: 0x362508f6
    7ab0:	272525f7 			; <UNDEFINED> instruction: 0x272525f7
    7ab4:	1a3f0d7c 	bne	fcb0ac <_etext+0xfc3b94>
    7ab8:	00912433 	addseq	r2, r1, r3, lsr r4
    7abc:	1ca00822 	stcne	8, cr0, [r0], #136	; 0x88
    7ac0:	082508f6 	stmdaeq	r5!, {r1, r2, r4, r5, r6, r7, fp}
    7ac4:	1425f73d 	strtne	pc, [r5], #-1853	; 0x73d
    7ac8:	40231f14 	eormi	r1, r3, r4, lsl pc
    7acc:	21251724 	teqcs	r5, r4, lsr #14
    7ad0:	00009f27 	andeq	r9, r0, r7, lsr #30
    7ad4:	00000000 	andeq	r0, r0, r0
    7ad8:	539c0000 	orrspl	r0, ip, #0
    7adc:	53cc0000 	bicpl	r0, ip, #0
    7ae0:	00320000 	eorseq	r0, r2, r0
    7ae4:	08250af5 	stmdaeq	r5!, {r0, r2, r4, r5, r6, r7, r9, fp}
    7ae8:	1425f722 	strtne	pc, [r5], #-1826	; 0x722
    7aec:	40231f14 	eormi	r1, r3, r4, lsl pc
    7af0:	21251724 	teqcs	r5, r4, lsr #14
    7af4:	4c250af5 	stcmi	10, cr0, [r5], #-980	; 0xfffffc2c
    7af8:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7afc:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7b00:	27212517 			; <UNDEFINED> instruction: 0x27212517
    7b04:	08250af5 	stmdaeq	r5!, {r0, r2, r4, r5, r6, r7, r9, fp}
    7b08:	1425f727 	strtne	pc, [r5], #-1831	; 0x727
    7b0c:	40231f14 	eormi	r1, r3, r4, lsl pc
    7b10:	21251724 	teqcs	r5, r4, lsr #14
    7b14:	53cc9f27 	bicpl	r9, ip, #39, 30	; 0x9c
    7b18:	53ce0000 	bicpl	r0, lr, #0
    7b1c:	003b0000 	eorseq	r0, fp, r0
    7b20:	f67d8091 			; <UNDEFINED> instruction: 0xf67d8091
    7b24:	22082508 	andcs	r2, r8, #8, 10	; 0x2000000
    7b28:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7b2c:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7b30:	91212517 	teqls	r1, r7, lsl r5
    7b34:	08f67d80 	ldmeq	r6!, {r7, r8, sl, fp, ip, sp, lr}^
    7b38:	25f74c25 	ldrbcs	r4, [r7, #3109]!	; 0xc25
    7b3c:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    7b40:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    7b44:	80912721 	addshi	r2, r1, r1, lsr #14
    7b48:	2508f67d 	strcs	pc, [r8, #-1661]	; 0x67d
    7b4c:	25f72708 	ldrbcs	r2, [r7, #1800]!	; 0x708
    7b50:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    7b54:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    7b58:	5a9f2721 	bpl	fe7d17e4 <BootRAM+0xd741f85>
    7b5c:	18000054 	stmdane	r0, {r2, r4, r6}
    7b60:	32000056 	andcc	r0, r0, #86	; 0x56
    7b64:	250af500 	strcs	pc, [sl, #-1280]	; 0x500
    7b68:	25f72208 	ldrbcs	r2, [r7, #520]!	; 0x208
    7b6c:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    7b70:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    7b74:	250af521 	strcs	pc, [sl, #-1313]	; 0x521
    7b78:	1425f74c 	strtne	pc, [r5], #-1868	; 0x74c
    7b7c:	40231f14 	eormi	r1, r3, r4, lsl pc
    7b80:	21251724 	teqcs	r5, r4, lsr #14
    7b84:	250af527 	strcs	pc, [sl, #-1319]	; 0x527
    7b88:	25f72708 	ldrbcs	r2, [r7, #1800]!	; 0x708
    7b8c:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    7b90:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    7b94:	009f2721 	addseq	r2, pc, r1, lsr #14
    7b98:	00000000 	andeq	r0, r0, r0
    7b9c:	9c000000 	stcls	0, cr0, [r0], {-0}
    7ba0:	c2000053 	andgt	r0, r0, #83	; 0x53
    7ba4:	31000053 	qaddcc	r0, r3, r0
    7ba8:	2508f500 	strcs	pc, [r8, #-1280]	; 0x500
    7bac:	1425f742 	strtne	pc, [r5], #-1858	; 0x742
    7bb0:	40231f14 	eormi	r1, r3, r4, lsl pc
    7bb4:	21251724 	teqcs	r5, r4, lsr #14
    7bb8:	3e2508f5 	mcrcc	8, 1, r0, cr5, cr5, {7}
    7bbc:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7bc0:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7bc4:	27212517 			; <UNDEFINED> instruction: 0x27212517
    7bc8:	082508f5 	stmdaeq	r5!, {r0, r2, r4, r5, r6, r7, fp}
    7bcc:	1425f729 	strtne	pc, [r5], #-1833	; 0x729
    7bd0:	40231f14 	eormi	r1, r3, r4, lsl pc
    7bd4:	21251724 	teqcs	r5, r4, lsr #14
    7bd8:	53c29f27 	bicpl	r9, r2, #39, 30	; 0x9c
    7bdc:	53ce0000 	bicpl	r0, lr, #0
    7be0:	003a0000 	eorseq	r0, sl, r0
    7be4:	f67da091 			; <UNDEFINED> instruction: 0xf67da091
    7be8:	f7422508 			; <UNDEFINED> instruction: 0xf7422508
    7bec:	1f141425 	svcne	0x00141425
    7bf0:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    7bf4:	a0912125 	addsge	r2, r1, r5, lsr #2
    7bf8:	2508f67d 	strcs	pc, [r8, #-1661]	; 0x67d
    7bfc:	1425f73e 	strtne	pc, [r5], #-1854	; 0x73e
    7c00:	40231f14 	eormi	r1, r3, r4, lsl pc
    7c04:	21251724 	teqcs	r5, r4, lsr #14
    7c08:	7da09127 	stfvcd	f1, [r0, #156]!	; 0x9c
    7c0c:	082508f6 	stmdaeq	r5!, {r1, r2, r4, r5, r6, r7, fp}
    7c10:	1425f729 	strtne	pc, [r5], #-1833	; 0x729
    7c14:	40231f14 	eormi	r1, r3, r4, lsl pc
    7c18:	21251724 	teqcs	r5, r4, lsr #14
    7c1c:	545a9f27 	ldrbpl	r9, [sl], #-3879	; 0xf27
    7c20:	56140000 	ldrpl	r0, [r4], -r0
    7c24:	00310000 	eorseq	r0, r1, r0
    7c28:	422508f5 	eormi	r0, r5, #16056320	; 0xf50000
    7c2c:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7c30:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7c34:	f5212517 			; <UNDEFINED> instruction: 0xf5212517
    7c38:	f73e2508 			; <UNDEFINED> instruction: 0xf73e2508
    7c3c:	1f141425 	svcne	0x00141425
    7c40:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    7c44:	f5272125 			; <UNDEFINED> instruction: 0xf5272125
    7c48:	29082508 	stmdbcs	r8, {r3, r8, sl, sp}
    7c4c:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7c50:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7c54:	27212517 			; <UNDEFINED> instruction: 0x27212517
    7c58:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    7c5c:	00000000 	andeq	r0, r0, r0
    7c60:	00539c00 	subseq	r9, r3, r0, lsl #24
    7c64:	0053b800 	subseq	fp, r3, r0, lsl #16
    7c68:	f5001700 			; <UNDEFINED> instruction: 0xf5001700
    7c6c:	91202508 	teqls	r0, r8, lsl #10
    7c70:	08f67d98 	ldmeq	r6!, {r3, r4, r7, r8, sl, fp, ip, sp, lr}^
    7c74:	a0911a25 	addsge	r1, r1, r5, lsr #20
    7c78:	2508f67d 	strcs	pc, [r8, #-1661]	; 0x67d
    7c7c:	1a2508f5 	bne	94a058 <_etext+0x942b40>
    7c80:	545a9f27 	ldrbpl	r9, [sl], #-3879	; 0xf27
    7c84:	56140000 	ldrpl	r0, [r4], -r0
    7c88:	00170000 	andseq	r0, r7, r0
    7c8c:	202508f5 	strdcs	r0, [r5], -r5	; <UNPREDICTABLE>
    7c90:	f67d9891 			; <UNDEFINED> instruction: 0xf67d9891
    7c94:	911a2508 	tstls	sl, r8, lsl #10
    7c98:	08f67da0 	ldmeq	r6!, {r5, r7, r8, sl, fp, ip, sp, lr}^
    7c9c:	2508f525 	strcs	pc, [r8, #-1317]	; 0x525
    7ca0:	009f271a 	addseq	r2, pc, sl, lsl r7	; <UNPREDICTABLE>
    7ca4:	00000000 	andeq	r0, r0, r0
    7ca8:	e4000000 	str	r0, [r0], #-0
    7cac:	fa000055 	blx	7e08 <_etext+0x8f0>
    7cb0:	06000055 			; <UNDEFINED> instruction: 0x06000055
    7cb4:	04935000 	ldreq	r5, [r3], #0
    7cb8:	00049351 	andeq	r9, r4, r1, asr r3
    7cbc:	00000000 	andeq	r0, r0, r0
    7cc0:	9c000000 	stcls	0, cr0, [r0], {-0}
    7cc4:	bc000053 	stclt	0, cr0, [r0], {83}	; 0x53
    7cc8:	20000053 	andcs	r0, r0, r3, asr r0
    7ccc:	7d889100 	stfvcd	f1, [r8]
    7cd0:	912508f6 	strdls	r0, [r5, -r6]!
    7cd4:	08f67d80 	ldmeq	r6!, {r7, r8, sl, fp, ip, sp, lr}^
    7cd8:	0af52725 	beq	ffd51974 <BootRAM+0xecc2115>
    7cdc:	88911a25 	ldmhi	r1, {r0, r2, r5, r9, fp, ip}
    7ce0:	2508f67d 	strcs	pc, [r8, #-1661]	; 0x67d
    7ce4:	f67d8091 			; <UNDEFINED> instruction: 0xf67d8091
    7ce8:	271a2508 	ldrcs	r2, [sl, -r8, lsl #10]
    7cec:	0055e49f 			; <UNDEFINED> instruction: 0x0055e49f
    7cf0:	00561800 	subseq	r1, r6, r0, lsl #16
    7cf4:	91002000 	mrsls	r2, (UNDEF: 0)
    7cf8:	08f67d88 	ldmeq	r6!, {r3, r7, r8, sl, fp, ip, sp, lr}^
    7cfc:	7d809125 	stfvcd	f1, [r0, #148]	; 0x94
    7d00:	272508f6 			; <UNDEFINED> instruction: 0x272508f6
    7d04:	1a250af5 	bne	94a8e0 <_etext+0x9433c8>
    7d08:	f67d8891 			; <UNDEFINED> instruction: 0xf67d8891
    7d0c:	80912508 	addshi	r2, r1, r8, lsl #10
    7d10:	2508f67d 	strcs	pc, [r8, #-1661]	; 0x67d
    7d14:	009f271a 	addseq	r2, pc, sl, lsl r7	; <UNPREDICTABLE>
    7d18:	00000000 	andeq	r0, r0, r0
    7d1c:	9c000000 	stcls	0, cr0, [r0], {-0}
    7d20:	a0000053 	andge	r0, r0, r3, asr r0
    7d24:	06000053 			; <UNDEFINED> instruction: 0x06000053
    7d28:	04935400 	ldreq	r5, [r3], #1024	; 0x400
    7d2c:	ee049355 	mcr	3, 0, r9, cr4, cr5, {2}
    7d30:	08000055 	stmdaeq	r0, {r0, r2, r4, r6}
    7d34:	06000056 			; <UNDEFINED> instruction: 0x06000056
    7d38:	04935400 	ldreq	r5, [r3], #1024	; 0x400
    7d3c:	00049355 	andeq	r9, r4, r5, asr r3
    7d40:	00000000 	andeq	r0, r0, r0
    7d44:	9c000000 	stcls	0, cr0, [r0], {-0}
    7d48:	ce000053 	mcrgt	0, 0, r0, cr0, cr3, {2}
    7d4c:	02000053 	andeq	r0, r0, #83	; 0x53
    7d50:	5a9f4200 	bpl	fe7d8558 <BootRAM+0xd748cf9>
    7d54:	d4000054 	strle	r0, [r0], #-84	; 0x54
    7d58:	02000056 	andeq	r0, r0, #86	; 0x56
    7d5c:	009f4200 	addseq	r4, pc, r0, lsl #4
    7d60:	00000000 	andeq	r0, r0, r0
    7d64:	9c000000 	stcls	0, cr0, [r0], {-0}
    7d68:	c2000053 	andgt	r0, r0, #83	; 0x53
    7d6c:	06000053 			; <UNDEFINED> instruction: 0x06000053
    7d70:	04935800 	ldreq	r5, [r3], #2048	; 0x800
    7d74:	c2049359 	andgt	r9, r4, #1677721601	; 0x64000001
    7d78:	ce000053 	mcrgt	0, 0, r0, cr0, cr3, {2}
    7d7c:	03000053 	movweq	r0, #83	; 0x53
    7d80:	7da09100 	stfvcd	f1, [r0]
    7d84:	0000545a 	andeq	r5, r0, sl, asr r4
    7d88:	00005614 	andeq	r5, r0, r4, lsl r6
    7d8c:	93580006 	cmpls	r8, #6
    7d90:	04935904 	ldreq	r5, [r3], #2308	; 0x904
	...
    7d9c:	0000539c 	muleq	r0, ip, r3
    7da0:	000053ce 	andeq	r5, r0, lr, asr #7
    7da4:	9f3e0002 	svcls	0x003e0002
    7da8:	0000545a 	andeq	r5, r0, sl, asr r4
    7dac:	000056d4 	ldrdeq	r5, [r0], -r4
    7db0:	9f3e0002 	svcls	0x003e0002
	...
    7dbc:	0000539c 	muleq	r0, ip, r3
    7dc0:	000053ce 	andeq	r5, r0, lr, asr #7
    7dc4:	29080003 	stmdbcs	r8, {r0, r1}
    7dc8:	00545a9f 			; <UNDEFINED> instruction: 0x00545a9f
    7dcc:	0056d400 	subseq	sp, r6, r0, lsl #8
    7dd0:	08000300 	stmdaeq	r0, {r8, r9}
    7dd4:	00009f29 	andeq	r9, r0, r9, lsr #30
    7dd8:	00000000 	andeq	r0, r0, r0
    7ddc:	539c0000 	orrspl	r0, ip, #0
    7de0:	53ce0000 	bicpl	r0, lr, #0
    7de4:	00020000 	andeq	r0, r2, r0
    7de8:	545a9f31 	ldrbpl	r9, [sl], #-3889	; 0xf31
    7dec:	56d40000 	ldrbpl	r0, [r4], r0
    7df0:	00020000 	andeq	r0, r2, r0
    7df4:	00009f31 	andeq	r9, r0, r1, lsr pc
    7df8:	00000000 	andeq	r0, r0, r0
    7dfc:	539c0000 	orrspl	r0, ip, #0
    7e00:	53ce0000 	bicpl	r0, lr, #0
    7e04:	00020000 	andeq	r0, r2, r0
    7e08:	545a9f38 	ldrbpl	r9, [sl], #-3896	; 0xf38
    7e0c:	56d40000 	ldrbpl	r0, [r4], r0
    7e10:	00020000 	andeq	r0, r2, r0
    7e14:	00009f38 	andeq	r9, r0, r8, lsr pc
    7e18:	00000000 	andeq	r0, r0, r0
    7e1c:	539c0000 	orrspl	r0, ip, #0
    7e20:	53ce0000 	bicpl	r0, lr, #0
    7e24:	00020000 	andeq	r0, r2, r0
    7e28:	545a9f43 	ldrbpl	r9, [sl], #-3907	; 0xf43
    7e2c:	56d40000 	ldrbpl	r0, [r4], r0
    7e30:	00020000 	andeq	r0, r2, r0
    7e34:	00009f43 	andeq	r9, r0, r3, asr #30
    7e38:	00000000 	andeq	r0, r0, r0
    7e3c:	539c0000 	orrspl	r0, ip, #0
    7e40:	53ce0000 	bicpl	r0, lr, #0
    7e44:	00030000 	andeq	r0, r3, r0
    7e48:	5a9f2208 	bpl	fe7d0670 <BootRAM+0xd740e11>
    7e4c:	d4000054 	strle	r0, [r0], #-84	; 0x54
    7e50:	03000056 	movweq	r0, #86	; 0x56
    7e54:	9f220800 	svcls	0x00220800
	...
    7e60:	0000539c 	muleq	r0, ip, r3
    7e64:	000053cc 	andeq	r5, r0, ip, asr #7
    7e68:	935a0006 	cmpls	sl, #6
    7e6c:	04935b04 	ldreq	r5, [r3], #2820	; 0xb04
    7e70:	000053cc 	andeq	r5, r0, ip, asr #7
    7e74:	000053ce 	andeq	r5, r0, lr, asr #7
    7e78:	80910003 	addshi	r0, r1, r3
    7e7c:	00545a7d 	subseq	r5, r4, sp, ror sl
    7e80:	00561800 	subseq	r1, r6, r0, lsl #16
    7e84:	5a000600 	bpl	968c <_etext+0x2174>
    7e88:	935b0493 	cmpls	fp, #-1828716544	; 0x93000000
    7e8c:	00000004 	andeq	r0, r0, r4
    7e90:	00000000 	andeq	r0, r0, r0
    7e94:	00539c00 	subseq	r9, r3, r0, lsl #24
    7e98:	0053ce00 	subseq	ip, r3, r0, lsl #28
    7e9c:	4c000200 	sfmmi	f0, 4, [r0], {-0}
    7ea0:	00545a9f 			; <UNDEFINED> instruction: 0x00545a9f
    7ea4:	0056d400 	subseq	sp, r6, r0, lsl #8
    7ea8:	4c000200 	sfmmi	f0, 4, [r0], {-0}
    7eac:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    7eb0:	00000000 	andeq	r0, r0, r0
    7eb4:	00539c00 	subseq	r9, r3, r0, lsl #24
    7eb8:	0053ce00 	subseq	ip, r3, r0, lsl #28
    7ebc:	08000300 	stmdaeq	r0, {r8, r9}
    7ec0:	545a9f3d 	ldrbpl	r9, [sl], #-3901	; 0xf3d
    7ec4:	56d40000 	ldrbpl	r0, [r4], r0
    7ec8:	00030000 	andeq	r0, r3, r0
    7ecc:	009f3d08 	addseq	r3, pc, r8, lsl #26
    7ed0:	00000000 	andeq	r0, r0, r0
    7ed4:	9c000000 	stcls	0, cr0, [r0], {-0}
    7ed8:	ce000053 	mcrgt	0, 0, r0, cr0, cr3, {2}
    7edc:	03000053 	movweq	r0, #83	; 0x53
    7ee0:	9f270800 	svcls	0x00270800
    7ee4:	0000545a 	andeq	r5, r0, sl, asr r4
    7ee8:	000056d4 	ldrdeq	r5, [r0], -r4
    7eec:	27080003 	strcs	r0, [r8, -r3]
    7ef0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    7ef4:	00000000 	andeq	r0, r0, r0
    7ef8:	0056d400 	subseq	sp, r6, r0, lsl #8
    7efc:	0056e400 	subseq	lr, r6, r0, lsl #8
    7f00:	50000100 	andpl	r0, r0, r0, lsl #2
    7f04:	000056e4 	andeq	r5, r0, r4, ror #13
    7f08:	0000575c 	andeq	r5, r0, ip, asr r7
    7f0c:	005a0001 	subseq	r0, sl, r1
    7f10:	00000000 	andeq	r0, r0, r0
    7f14:	d4000000 	strle	r0, [r0], #-0
    7f18:	e8000056 	stmda	r0, {r1, r2, r4, r6}
    7f1c:	01000056 	qaddeq	r0, r6, r0
    7f20:	56e85100 	strbtpl	r5, [r8], r0, lsl #2
    7f24:	575c0000 	ldrbpl	r0, [ip, -r0]
    7f28:	00010000 	andeq	r0, r1, r0
    7f2c:	00000057 	andeq	r0, r0, r7, asr r0
    7f30:	00000000 	andeq	r0, r0, r0
    7f34:	0056d400 	subseq	sp, r6, r0, lsl #8
    7f38:	0056e600 	subseq	lr, r6, r0, lsl #12
    7f3c:	52000100 	andpl	r0, r0, #0, 2
    7f40:	000056e6 	andeq	r5, r0, r6, ror #13
    7f44:	000056fa 	strdeq	r5, [r0], -sl
    7f48:	fa540001 	blx	1507f54 <_etext+0x1500a3c>
    7f4c:	30000056 	andcc	r0, r0, r6, asr r0
    7f50:	04000057 	streq	r0, [r0], #-87	; 0x57
    7f54:	5201f300 	andpl	pc, r1, #0, 6
    7f58:	0057309f 			; <UNDEFINED> instruction: 0x0057309f
    7f5c:	00575c00 	subseq	r5, r7, r0, lsl #24
    7f60:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    7f6c:	000056ec 	andeq	r5, r0, ip, ror #13
    7f70:	000056f0 	strdeq	r5, [r0], -r0
    7f74:	00740006 	rsbseq	r0, r4, r6
    7f78:	9f1a7f08 	svcls	0x001a7f08
    7f7c:	000056f0 	strdeq	r5, [r0], -r0
    7f80:	000056fc 	strdeq	r5, [r0], -ip
    7f84:	fc560001 	mrrc2	0, 0, r0, r6, cr1
    7f88:	30000056 	andcc	r0, r0, r6, asr r0
    7f8c:	07000057 	smlsdeq	r0, r7, r0, r0
    7f90:	5201f300 	andpl	pc, r1, #0, 6
    7f94:	9f1a7f08 	svcls	0x001a7f08
    7f98:	00005730 	andeq	r5, r0, r0, lsr r7
    7f9c:	0000575c 	andeq	r5, r0, ip, asr r7
    7fa0:	00560001 	subseq	r0, r6, r1
    7fa4:	00000000 	andeq	r0, r0, r0
    7fa8:	f8000000 			; <UNDEFINED> instruction: 0xf8000000
    7fac:	fe000056 	mcr2	0, 0, r0, cr0, cr6, {2}
    7fb0:	07000056 	smlsdeq	r0, r6, r0, r0
    7fb4:	f7007200 			; <UNDEFINED> instruction: 0xf7007200
    7fb8:	9f25f733 	svcls	0x0025f733
    7fbc:	00005716 	andeq	r5, r0, r6, lsl r7
    7fc0:	00005730 	andeq	r5, r0, r0, lsr r7
    7fc4:	089e000a 	ldmeq	lr, {r1, r3}
	...
    7fd8:	000056f8 	strdeq	r5, [r0], -r8
    7fdc:	000056fe 	strdeq	r5, [r0], -lr
    7fe0:	5e910003 	cdppl	0, 9, cr0, cr1, cr3, {0}
    7fe4:	0056fe9f 			; <UNDEFINED> instruction: 0x0056fe9f
    7fe8:	00571200 	subseq	r1, r7, r0, lsl #4
    7fec:	91000300 	mrsls	r0, LR_irq
    7ff0:	57129f5c 			; <UNDEFINED> instruction: 0x57129f5c
    7ff4:	57160000 	ldrpl	r0, [r6, -r0]
    7ff8:	00030000 	andeq	r0, r3, r0
    7ffc:	169f5b91 			; <UNDEFINED> instruction: 0x169f5b91
    8000:	1a000057 	bne	8164 <_etext+0xc4c>
    8004:	03000057 	movweq	r0, #87	; 0x57
    8008:	9f5a9100 	svcls	0x005a9100
    800c:	0000571a 	andeq	r5, r0, sl, lsl r7
    8010:	0000571e 	andeq	r5, r0, lr, lsl r7
    8014:	59910003 	ldmibpl	r1, {r0, r1}
    8018:	00571e9f 			; <UNDEFINED> instruction: 0x00571e9f
    801c:	00572200 	subseq	r2, r7, r0, lsl #4
    8020:	91000300 	mrsls	r0, LR_irq
    8024:	57229f58 			; <UNDEFINED> instruction: 0x57229f58
    8028:	57300000 	ldrpl	r0, [r0, -r0]!
    802c:	00030000 	andeq	r0, r3, r0
    8030:	009f5791 	umullseq	r5, pc, r1, r7	; <UNPREDICTABLE>
    8034:	00000000 	andeq	r0, r0, r0
    8038:	5c000000 	stcpl	0, cr0, [r0], {-0}
    803c:	76000057 			; <UNDEFINED> instruction: 0x76000057
    8040:	01000057 	qaddeq	r0, r7, r0
    8044:	57765000 	ldrbpl	r5, [r6, -r0]!
    8048:	59f20000 	ldmibpl	r2!, {}^	; <UNPREDICTABLE>
    804c:	00020000 	andeq	r0, r2, r0
    8050:	00004091 	muleq	r0, r1, r0
    8054:	00000000 	andeq	r0, r0, r0
    8058:	575c0000 	ldrbpl	r0, [ip, -r0]
    805c:	576e0000 	strbpl	r0, [lr, -r0]!
    8060:	00010000 	andeq	r0, r1, r0
    8064:	00576e51 	subseq	r6, r7, r1, asr lr
    8068:	0057ac00 	subseq	sl, r7, r0, lsl #24
    806c:	91000300 	mrsls	r0, LR_irq
    8070:	57ac7fac 	strpl	r7, [ip, ip, lsr #31]!
    8074:	58420000 	stmdapl	r2, {}^	; <UNPREDICTABLE>
    8078:	00010000 	andeq	r0, r1, r0
    807c:	00586851 	subseq	r6, r8, r1, asr r8
    8080:	00594400 	subseq	r4, r9, r0, lsl #8
    8084:	91000300 	mrsls	r0, LR_irq
    8088:	59447fac 	stmdbpl	r4, {r2, r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}^
    808c:	594a0000 	stmdbpl	sl, {}^	; <UNPREDICTABLE>
    8090:	00010000 	andeq	r0, r1, r0
    8094:	00000054 	andeq	r0, r0, r4, asr r0
    8098:	00000000 	andeq	r0, r0, r0
    809c:	00575c00 	subseq	r5, r7, r0, lsl #24
    80a0:	00577a00 	subseq	r7, r7, r0, lsl #20
    80a4:	52000100 	andpl	r0, r0, #0, 2
    80a8:	0000577a 	andeq	r5, r0, sl, ror r7
    80ac:	0000577e 	andeq	r5, r0, lr, ror r7
    80b0:	01f30004 	mvnseq	r0, r4
    80b4:	00009f52 	andeq	r9, r0, r2, asr pc
    80b8:	00000000 	andeq	r0, r0, r0
    80bc:	575c0000 	ldrbpl	r0, [ip, -r0]
    80c0:	577c0000 	ldrbpl	r0, [ip, -r0]!
    80c4:	00010000 	andeq	r0, r1, r0
    80c8:	00577c53 	subseq	r7, r7, r3, asr ip
    80cc:	00578200 	subseq	r8, r7, r0, lsl #4
    80d0:	51000100 	mrspl	r0, (UNDEF: 16)
    80d4:	00005782 	andeq	r5, r0, r2, lsl #15
    80d8:	000057ac 	andeq	r5, r0, ip, lsr #15
    80dc:	a4910003 	ldrge	r0, [r1], #3
    80e0:	0058687f 	subseq	r6, r8, pc, ror r8
    80e4:	00587c00 	subseq	r7, r8, r0, lsl #24
    80e8:	51000100 	mrspl	r0, (UNDEF: 16)
    80ec:	0000587c 	andeq	r5, r0, ip, ror r8
    80f0:	0000592a 	andeq	r5, r0, sl, lsr #18
    80f4:	a4910003 	ldrge	r0, [r1], #3
    80f8:	00592a7f 	subseq	r2, r9, pc, ror sl
    80fc:	00593800 	subseq	r3, r9, r0, lsl #16
    8100:	08001b00 	stmdaeq	r0, {r8, r9, fp, ip}
    8104:	5201f380 	andpl	pc, r1, #128, 6
    8108:	4b40121c 	blmi	100c980 <_etext+0x1005468>
    810c:	01f32224 	mvnseq	r2, r4, lsr #4
    8110:	40141653 	andsmi	r1, r4, r3, asr r6
    8114:	2d22244b 	cfstrscs	mvf2, [r2, #-300]!	; 0xfffffed4
    8118:	16000128 	strne	r0, [r0], -r8, lsr #2
    811c:	59389f13 	ldmdbpl	r8!, {r0, r1, r4, r8, r9, sl, fp, ip, pc}
    8120:	594a0000 	stmdbpl	sl, {}^	; <UNPREDICTABLE>
    8124:	00030000 	andeq	r0, r3, r0
    8128:	007fa491 			; <UNDEFINED> instruction: 0x007fa491
    812c:	00000000 	andeq	r0, r0, r0
    8130:	34000000 	strcc	r0, [r0], #-0
    8134:	37000059 	smlsdcc	r0, r9, r0, r0
    8138:	01000059 	qaddeq	r0, r9, r0
    813c:	59375c00 	ldmdbpl	r7!, {sl, fp, ip, lr}
    8140:	59480000 	stmdbpl	r8, {}^	; <UNPREDICTABLE>
    8144:	00070000 	andeq	r0, r7, r0
    8148:	067fa891 			; <UNDEFINED> instruction: 0x067fa891
    814c:	009f0123 	addseq	r0, pc, r3, lsr #2
    8150:	00000000 	andeq	r0, r0, r0
    8154:	b6000000 	strlt	r0, [r0], -r0
    8158:	be000057 	mcrlt	0, 0, r0, cr0, cr7, {2}
    815c:	06000057 			; <UNDEFINED> instruction: 0x06000057
    8160:	04935200 	ldreq	r5, [r3], #512	; 0x200
    8164:	be049353 	mcrlt	3, 0, r9, cr4, cr3, {2}
    8168:	c6000057 			; <UNDEFINED> instruction: 0xc6000057
    816c:	04000057 	streq	r0, [r0], #-87	; 0x57
    8170:	7fb89100 	svcvc	0x00b89100
    8174:	0057c606 	subseq	ip, r7, r6, lsl #12
    8178:	0057e800 	subseq	lr, r7, r0, lsl #16
    817c:	52000600 	andpl	r0, r0, #0, 12
    8180:	93530493 	cmpls	r3, #-1828716544	; 0x93000000
    8184:	0057e804 	subseq	lr, r7, r4, lsl #16
    8188:	0057ee00 	subseq	lr, r7, r0, lsl #28
    818c:	5a000600 	bpl	9994 <_etext+0x247c>
    8190:	935b0493 	cmpls	fp, #-1828716544	; 0x93000000
    8194:	0057ee04 	subseq	lr, r7, r4, lsl #28
    8198:	0057f400 	subseq	pc, r7, r0, lsl #8
    819c:	54000600 	strpl	r0, [r0], #-1536	; 0x600
    81a0:	93550493 	cmpls	r5, #-1828716544	; 0x93000000
    81a4:	0057f404 	subseq	pc, r7, r4, lsl #8
    81a8:	00580000 	subseq	r0, r8, r0
    81ac:	56000600 	strpl	r0, [r0], -r0, lsl #12
    81b0:	93570493 	cmpls	r7, #-1828716544	; 0x93000000
    81b4:	00580004 	subseq	r0, r8, r4
    81b8:	00582400 	subseq	r2, r8, r0, lsl #8
    81bc:	58000600 	stmdapl	r0, {r9, sl}
    81c0:	93590493 	cmpls	r9, #-1828716544	; 0x93000000
    81c4:	00000004 	andeq	r0, r0, r4
    81c8:	00000000 	andeq	r0, r0, r0
    81cc:	0057b600 	subseq	fp, r7, r0, lsl #12
    81d0:	0057c600 	subseq	ip, r7, r0, lsl #12
    81d4:	71000300 	mrsvc	r0, LR_irq
    81d8:	57c69f06 	strbpl	r9, [r6, r6, lsl #30]
    81dc:	57e80000 	strbpl	r0, [r8, r0]!
    81e0:	00030000 	andeq	r0, r3, r0
    81e4:	e89f0571 	ldm	pc, {r0, r4, r5, r6, r8, sl}	; <UNPREDICTABLE>
    81e8:	ee000057 	mcr	0, 0, r0, cr0, cr7, {2}
    81ec:	03000057 	movweq	r0, #87	; 0x57
    81f0:	9f037100 	svcls	0x00037100
    81f4:	000057ee 	andeq	r5, r0, lr, ror #15
    81f8:	000057f4 	strdeq	r5, [r0], -r4
    81fc:	02710003 	rsbseq	r0, r1, #3
    8200:	0057f49f 			; <UNDEFINED> instruction: 0x0057f49f
    8204:	00580000 	subseq	r0, r8, r0
    8208:	71000300 	mrsvc	r0, LR_irq
    820c:	58009f01 	stmdapl	r0, {r0, r8, r9, sl, fp, ip, pc}
    8210:	58240000 	stmdapl	r4!, {}	; <UNPREDICTABLE>
    8214:	00010000 	andeq	r0, r1, r0
    8218:	00582451 	subseq	r2, r8, r1, asr r4
    821c:	00583600 	subseq	r3, r8, r0, lsl #12
    8220:	71000300 	mrsvc	r0, LR_irq
    8224:	58369f7f 	ldmdapl	r6!, {r0, r1, r2, r3, r4, r5, r6, r8, r9, sl, fp, ip, pc}
    8228:	58420000 	stmdapl	r2, {}^	; <UNPREDICTABLE>
    822c:	00030000 	andeq	r0, r3, r0
    8230:	009f7771 	addseq	r7, pc, r1, ror r7	; <UNPREDICTABLE>
    8234:	00000000 	andeq	r0, r0, r0
    8238:	34000000 	strcc	r0, [r0], #-0
    823c:	37000059 	smlsdcc	r0, r9, r0, r0
    8240:	01000059 	qaddeq	r0, r9, r0
    8244:	00005200 	andeq	r5, r0, r0, lsl #4
    8248:	00000000 	andeq	r0, r0, r0
    824c:	59340000 	ldmdbpl	r4!, {}	; <UNPREDICTABLE>
    8250:	594a0000 	stmdbpl	sl, {}^	; <UNPREDICTABLE>
    8254:	00030000 	andeq	r0, r3, r0
    8258:	009f4791 	umullseq	r4, pc, r1, r7	; <UNPREDICTABLE>
    825c:	00000000 	andeq	r0, r0, r0
    8260:	5a000000 	bpl	8268 <_etext+0xd50>
    8264:	6c000059 	stcvs	0, cr0, [r0], {89}	; 0x59
    8268:	06000059 			; <UNDEFINED> instruction: 0x06000059
    826c:	04935000 	ldreq	r5, [r3], #0
    8270:	6c049351 	stcvs	3, cr9, [r4], {81}	; 0x51
    8274:	74000059 	strvc	r0, [r0], #-89	; 0x59
    8278:	06000059 			; <UNDEFINED> instruction: 0x06000059
    827c:	04935a00 	ldreq	r5, [r3], #2560	; 0xa00
    8280:	7404935b 	strvc	r9, [r4], #-859	; 0x35b
    8284:	80000059 	andhi	r0, r0, r9, asr r0
    8288:	06000059 			; <UNDEFINED> instruction: 0x06000059
    828c:	04935800 	ldreq	r5, [r3], #2048	; 0x800
    8290:	80049359 	andhi	r9, r4, r9, asr r3
    8294:	88000059 	stmdahi	r0, {r0, r3, r4, r6}
    8298:	06000059 			; <UNDEFINED> instruction: 0x06000059
    829c:	04935600 	ldreq	r5, [r3], #1536	; 0x600
    82a0:	88049357 	stmdahi	r4, {r0, r1, r2, r4, r6, r8, r9, ip, pc}
    82a4:	90000059 	andls	r0, r0, r9, asr r0
    82a8:	06000059 			; <UNDEFINED> instruction: 0x06000059
    82ac:	04935400 	ldreq	r5, [r3], #1024	; 0x400
    82b0:	90049355 	andls	r9, r4, r5, asr r3
    82b4:	be000059 	mcrlt	0, 0, r0, cr0, cr9, {2}
    82b8:	06000059 			; <UNDEFINED> instruction: 0x06000059
    82bc:	04935000 	ldreq	r5, [r3], #0
    82c0:	c8049351 	stmdagt	r4, {r0, r4, r6, r8, r9, ip, pc}
    82c4:	f2000059 	vqadd.s8	q0, q0, <illegal reg q4.5>
    82c8:	0b000059 	bleq	8434 <_etext+0xf1c>
    82cc:	7f889100 	svcvc	0x00889100
    82d0:	382508f6 	stmdacc	r5!, {r1, r2, r4, r5, r6, r7, fp}
    82d4:	9f2525f7 	svcls	0x002525f7
	...
    82e0:	0000595a 	andeq	r5, r0, sl, asr r9
    82e4:	0000596c 	andeq	r5, r0, ip, ror #18
    82e8:	4e910003 	cdpmi	0, 9, cr0, cr1, cr3, {0}
    82ec:	00596c9f 			; <UNDEFINED> instruction: 0x00596c9f
    82f0:	00597400 	subseq	r7, r9, r0, lsl #8
    82f4:	91000300 	mrsls	r0, LR_irq
    82f8:	59749f4d 	ldmdbpl	r4!, {r0, r2, r3, r6, r8, r9, sl, fp, ip, pc}^
    82fc:	59800000 	stmibpl	r0, {}	; <UNPREDICTABLE>
    8300:	00030000 	andeq	r0, r3, r0
    8304:	809f4c91 	umullshi	r4, pc, r1, ip	; <UNPREDICTABLE>
    8308:	88000059 	stmdahi	r0, {r0, r3, r4, r6}
    830c:	03000059 	movweq	r0, #89	; 0x59
    8310:	9f4b9100 	svcls	0x004b9100
    8314:	00005988 	andeq	r5, r0, r8, lsl #19
    8318:	00005990 	muleq	r0, r0, r9
    831c:	4a910003 	bmi	fe448330 <BootRAM+0xd3b8ad1>
    8320:	0059909f 			; <UNDEFINED> instruction: 0x0059909f
    8324:	0059c800 	subseq	ip, r9, r0, lsl #16
    8328:	91000300 	mrsls	r0, LR_irq
    832c:	59c89f49 	stmibpl	r8, {r0, r3, r6, r8, r9, sl, fp, ip, pc}^
    8330:	59f20000 	ldmibpl	r2!, {}^	; <UNPREDICTABLE>
    8334:	00030000 	andeq	r0, r3, r0
    8338:	009f4791 	umullseq	r4, pc, r1, r7	; <UNPREDICTABLE>
    833c:	00000000 	andeq	r0, r0, r0
    8340:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    8344:	4800005a 	stmdami	r0, {r1, r3, r4, r6}
    8348:	0100005a 	qaddeq	r0, sl, r0
    834c:	5a485000 	bpl	121c354 <_etext+0x1214e3c>
    8350:	5bac0000 	blpl	feb08358 <BootRAM+0xda78af9>
    8354:	00010000 	andeq	r0, r1, r0
    8358:	005bac57 	subseq	sl, fp, r7, asr ip
    835c:	005bbc00 	subseq	fp, fp, r0, lsl #24
    8360:	f3000400 	vshl.u8	d0, d0, d0
    8364:	009f5001 	addseq	r5, pc, r1
    8368:	00000000 	andeq	r0, r0, r0
    836c:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    8370:	4400005a 	strmi	r0, [r0], #-90	; 0x5a
    8374:	0100005a 	qaddeq	r0, sl, r0
    8378:	5a445100 	bpl	111c780 <_etext+0x1115268>
    837c:	5bac0000 	blpl	feb08384 <BootRAM+0xda78b25>
    8380:	00030000 	andeq	r0, r3, r0
    8384:	ac7cfc91 	ldclge	12, cr15, [ip], #-580	; 0xfffffdbc
    8388:	bc00005b 	stclt	0, cr0, [r0], {91}	; 0x5b
    838c:	0300005b 	movweq	r0, #91	; 0x5b
    8390:	7cfc7d00 	ldclvc	13, cr7, [ip]
	...
    839c:	00005a38 	andeq	r5, r0, r8, lsr sl
    83a0:	00005a4a 	andeq	r5, r0, sl, asr #20
    83a4:	4a520001 	bmi	14883b0 <_etext+0x1480e98>
    83a8:	bc00005a 	stclt	0, cr0, [r0], {90}	; 0x5a
    83ac:	0400005b 	streq	r0, [r0], #-91	; 0x5b
    83b0:	5201f300 	andpl	pc, r1, #0, 6
    83b4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    83b8:	00000000 	andeq	r0, r0, r0
    83bc:	005a6800 	subseq	r6, sl, r0, lsl #16
    83c0:	005bac00 	subseq	sl, fp, r0, lsl #24
    83c4:	91000400 	tstls	r0, r0, lsl #8
    83c8:	ac9f7f80 	ldcge	15, cr7, [pc], {128}	; 0x80
    83cc:	bc00005b 	stclt	0, cr0, [r0], {91}	; 0x5b
    83d0:	0400005b 	streq	r0, [r0], #-91	; 0x5b
    83d4:	7f807d00 	svcvc	0x00807d00
    83d8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    83dc:	00000000 	andeq	r0, r0, r0
    83e0:	005a3e00 	subseq	r3, sl, r0, lsl #28
    83e4:	005a4800 	subseq	r4, sl, r0, lsl #16
    83e8:	91000300 	mrsls	r0, LR_irq
    83ec:	5a487f80 	bpl	12281f4 <_etext+0x1220cdc>
    83f0:	5a4d0000 	bpl	13483f8 <_etext+0x1340ee0>
    83f4:	00020000 	andeq	r0, r2, r0
    83f8:	5a4d0070 	bpl	13485c0 <_etext+0x13410a8>
    83fc:	5a560000 	bpl	1588404 <_etext+0x1580eec>
    8400:	00030000 	andeq	r0, r3, r0
    8404:	567f8091 			; <UNDEFINED> instruction: 0x567f8091
    8408:	5900005a 	stmdbpl	r0, {r1, r3, r4, r6}
    840c:	0200005a 	andeq	r0, r0, #90	; 0x5a
    8410:	59007000 	stmdbpl	r0, {ip, sp, lr}
    8414:	ac00005a 	stcge	0, cr0, [r0], {90}	; 0x5a
    8418:	0300005b 	movweq	r0, #91	; 0x5b
    841c:	7f809100 	svcvc	0x00809100
    8420:	00005bac 	andeq	r5, r0, ip, lsr #23
    8424:	00005bbc 			; <UNDEFINED> instruction: 0x00005bbc
    8428:	807d0003 	rsbshi	r0, sp, r3
    842c:	0000007f 	andeq	r0, r0, pc, ror r0
    8430:	00000000 	andeq	r0, r0, r0
    8434:	005aae00 	subseq	sl, sl, r0, lsl #28
    8438:	005ba600 	subseq	sl, fp, r0, lsl #12
    843c:	34000200 	strcc	r0, [r0], #-512	; 0x200
    8440:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8444:	00000000 	andeq	r0, r0, r0
    8448:	005aae00 	subseq	sl, sl, r0, lsl #28
    844c:	005ba600 	subseq	sl, fp, r0, lsl #12
    8450:	33000200 	movwcc	r0, #512	; 0x200
    8454:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8458:	00000000 	andeq	r0, r0, r0
    845c:	005aae00 	subseq	sl, sl, r0, lsl #28
    8460:	005aee00 	subseq	lr, sl, r0, lsl #28
    8464:	91000300 	mrsls	r0, LR_irq
    8468:	5aee7d88 	bpl	ffba7a90 <BootRAM+0xeb18231>
    846c:	5af10000 	bpl	ffc48474 <BootRAM+0xebb8c15>
    8470:	00020000 	andeq	r0, r2, r0
    8474:	5af10070 	bpl	ffc4863c <BootRAM+0xebb8ddd>
    8478:	5ba60000 	blpl	fe988480 <BootRAM+0xd8f8c21>
    847c:	00030000 	andeq	r0, r3, r0
    8480:	007d8891 			; <UNDEFINED> instruction: 0x007d8891
    8484:	00000000 	andeq	r0, r0, r0
    8488:	ae000000 	cdpge	0, 0, cr0, cr0, cr0, {0}
    848c:	cc00005a 	stcgt	0, cr0, [r0], {90}	; 0x5a
    8490:	0300005a 	movweq	r0, #90	; 0x5a
    8494:	9f840800 	svcls	0x00840800
    8498:	00005acc 	andeq	r5, r0, ip, asr #21
    849c:	00005b30 	andeq	r5, r0, r0, lsr fp
    84a0:	00540001 	subseq	r0, r4, r1
	...
    84b0:	01000000 	mrseq	r0, (UNDEF: 0)
    84b4:	00005000 	andeq	r5, r0, r0
    84b8:	00000000 	andeq	r0, r0, r0
    84bc:	00040000 	andeq	r0, r4, r0
    84c0:	9f5001f3 	svcls	0x005001f3
	...
    84d4:	00500001 	subseq	r0, r0, r1
    84d8:	00000000 	andeq	r0, r0, r0
    84dc:	04000000 	streq	r0, [r0], #-0
    84e0:	5001f300 	andpl	pc, r1, r0, lsl #6
    84e4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    84f4:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8500:	01f30004 	mvnseq	r0, r4
    8504:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8514:	00010000 	andeq	r0, r1, r0
    8518:	00000051 	andeq	r0, r0, r1, asr r0
    851c:	00000000 	andeq	r0, r0, r0
    8520:	f3000400 	vshl.u8	d0, d0, d0
    8524:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
    8534:	01000000 	mrseq	r0, (UNDEF: 0)
    8538:	00005000 	andeq	r5, r0, r0
    853c:	00000000 	andeq	r0, r0, r0
    8540:	00040000 	andeq	r0, r4, r0
    8544:	9f5001f3 	svcls	0x005001f3
	...
    8550:	00005bbc 			; <UNDEFINED> instruction: 0x00005bbc
    8554:	00005bbe 			; <UNDEFINED> instruction: 0x00005bbe
    8558:	be500001 	cdplt	0, 5, cr0, cr0, cr1, {0}
    855c:	e600005b 			; <UNDEFINED> instruction: 0xe600005b
    8560:	0400005b 	streq	r0, [r0], #-91	; 0x5b
    8564:	5001f300 	andpl	pc, r1, r0, lsl #6
    8568:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8578:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8584:	01f30004 	mvnseq	r0, r4
    8588:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8598:	00010000 	andeq	r0, r1, r0
    859c:	00000050 	andeq	r0, r0, r0, asr r0
    85a0:	00000000 	andeq	r0, r0, r0
    85a4:	f3000400 	vshl.u8	d0, d0, d0
    85a8:	009f5001 	addseq	r5, pc, r1
	...
    85b8:	01000000 	mrseq	r0, (UNDEF: 0)
    85bc:	00005000 	andeq	r5, r0, r0
    85c0:	00000000 	andeq	r0, r0, r0
    85c4:	00040000 	andeq	r0, r4, r0
    85c8:	9f5001f3 	svcls	0x005001f3
	...
    85dc:	00500001 	subseq	r0, r0, r1
    85e0:	00000000 	andeq	r0, r0, r0
    85e4:	04000000 	streq	r0, [r0], #-0
    85e8:	5001f300 	andpl	pc, r1, r0, lsl #6
    85ec:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    85fc:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8608:	01f30004 	mvnseq	r0, r4
    860c:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    861c:	00060000 	andeq	r0, r6, r0
    8620:	30080073 	andcc	r0, r8, r3, ror r0
    8624:	00009f27 	andeq	r9, r0, r7, lsr #30
    8628:	00000000 	andeq	r0, r0, r0
    862c:	00090000 	andeq	r0, r9, r0
    8630:	30080073 	andcc	r0, r8, r3, ror r0
    8634:	27300827 	ldrcs	r0, [r0, -r7, lsr #16]!
    8638:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    863c:	00000000 	andeq	r0, r0, r0
    8640:	005be600 	subseq	lr, fp, r0, lsl #12
    8644:	005be800 	subseq	lr, fp, r0, lsl #16
    8648:	50000100 	andpl	r0, r0, r0, lsl #2
    864c:	00005be8 	andeq	r5, r0, r8, ror #23
    8650:	00005c04 	andeq	r5, r0, r4, lsl #24
    8654:	01f30004 	mvnseq	r0, r4
    8658:	00009f50 	andeq	r9, r0, r0, asr pc
    865c:	00000000 	andeq	r0, r0, r0
    8660:	5bfc0000 	blpl	fff08668 <BootRAM+0xee78e09>
    8664:	5c000000 	stcpl	0, cr0, [r0], {-0}
    8668:	00070000 	andeq	r0, r7, r0
    866c:	000a0073 	andeq	r0, sl, r3, ror r0
    8670:	009f2730 	addseq	r2, pc, r0, lsr r7	; <UNPREDICTABLE>
    8674:	0400005c 	streq	r0, [r0], #-92	; 0x5c
    8678:	0b00005c 	bleq	87f0 <_etext+0x12d8>
    867c:	0a007300 	beq	25284 <_etext+0x1dd6c>
    8680:	0a273000 	beq	9d4688 <_etext+0x9cd170>
    8684:	9f273000 	svcls	0x00273000
	...
    8698:	00500001 	subseq	r0, r0, r1
    869c:	00000000 	andeq	r0, r0, r0
    86a0:	04000000 	streq	r0, [r0], #-0
    86a4:	5001f300 	andpl	pc, r1, r0, lsl #6
    86a8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    86b8:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    86c4:	01f30004 	mvnseq	r0, r4
    86c8:	00009f50 	andeq	r9, r0, r0, asr pc
    86cc:	00000000 	andeq	r0, r0, r0
    86d0:	5c040000 	stcpl	0, cr0, [r4], {-0}
    86d4:	5c060000 	stcpl	0, cr0, [r6], {-0}
    86d8:	00010000 	andeq	r0, r1, r0
    86dc:	005c0650 	subseq	r0, ip, r0, asr r6
    86e0:	005c2000 	subseq	r2, ip, r0
    86e4:	f3000400 	vshl.u8	d0, d0, d0
    86e8:	009f5001 	addseq	r5, pc, r1
	...
    86f8:	01000000 	mrseq	r0, (UNDEF: 0)
    86fc:	00005000 	andeq	r5, r0, r0
    8700:	00000000 	andeq	r0, r0, r0
    8704:	00040000 	andeq	r0, r4, r0
    8708:	9f5001f3 	svcls	0x005001f3
	...
    871c:	00500001 	subseq	r0, r0, r1
    8720:	00000000 	andeq	r0, r0, r0
    8724:	04000000 	streq	r0, [r0], #-0
    8728:	5001f300 	andpl	pc, r1, r0, lsl #6
    872c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    873c:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8748:	01f30004 	mvnseq	r0, r4
    874c:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    875c:	00010000 	andeq	r0, r1, r0
    8760:	00000050 	andeq	r0, r0, r0, asr r0
    8764:	00000000 	andeq	r0, r0, r0
    8768:	f3000400 	vshl.u8	d0, d0, d0
    876c:	009f5001 	addseq	r5, pc, r1
	...
    877c:	01000000 	mrseq	r0, (UNDEF: 0)
    8780:	00005000 	andeq	r5, r0, r0
    8784:	00000000 	andeq	r0, r0, r0
    8788:	00040000 	andeq	r0, r4, r0
    878c:	9f5001f3 	svcls	0x005001f3
	...
    87a0:	00500001 	subseq	r0, r0, r1
    87a4:	00000000 	andeq	r0, r0, r0
    87a8:	04000000 	streq	r0, [r0], #-0
    87ac:	5001f300 	andpl	pc, r1, r0, lsl #6
    87b0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    87c0:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    87cc:	01f30004 	mvnseq	r0, r4
    87d0:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    87e0:	00010000 	andeq	r0, r1, r0
    87e4:	00000050 	andeq	r0, r0, r0, asr r0
    87e8:	00000000 	andeq	r0, r0, r0
    87ec:	f3000400 	vshl.u8	d0, d0, d0
    87f0:	009f5001 	addseq	r5, pc, r1
	...
    8800:	01000000 	mrseq	r0, (UNDEF: 0)
    8804:	00005000 	andeq	r5, r0, r0
    8808:	00000000 	andeq	r0, r0, r0
    880c:	00040000 	andeq	r0, r4, r0
    8810:	9f5001f3 	svcls	0x005001f3
	...
    881c:	00005c20 	andeq	r5, r0, r0, lsr #24
    8820:	00005c22 	andeq	r5, r0, r2, lsr #24
    8824:	22500001 	subscs	r0, r0, #1
    8828:	4000005c 	andmi	r0, r0, ip, asr r0
    882c:	0400005c 	streq	r0, [r0], #-92	; 0x5c
    8830:	5001f300 	andpl	pc, r1, r0, lsl #6
    8834:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8838:	00000000 	andeq	r0, r0, r0
    883c:	005c4000 	subseq	r4, ip, r0
    8840:	005c4200 	subseq	r4, ip, r0, lsl #4
    8844:	50000100 	andpl	r0, r0, r0, lsl #2
    8848:	00005c42 	andeq	r5, r0, r2, asr #24
    884c:	00005c60 	andeq	r5, r0, r0, ror #24
    8850:	01f30004 	mvnseq	r0, r4
    8854:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8864:	00010000 	andeq	r0, r1, r0
    8868:	00000050 	andeq	r0, r0, r0, asr r0
    886c:	00000000 	andeq	r0, r0, r0
    8870:	f3000400 	vshl.u8	d0, d0, d0
    8874:	009f5001 	addseq	r5, pc, r1
	...
    8884:	01000000 	mrseq	r0, (UNDEF: 0)
    8888:	00005100 	andeq	r5, r0, r0, lsl #2
    888c:	00000000 	andeq	r0, r0, r0
    8890:	00040000 	andeq	r0, r4, r0
    8894:	9f5101f3 	svcls	0x005101f3
	...
    88a8:	00500001 	subseq	r0, r0, r1
    88ac:	00000000 	andeq	r0, r0, r0
    88b0:	04000000 	streq	r0, [r0], #-0
    88b4:	5001f300 	andpl	pc, r1, r0, lsl #6
    88b8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    88c8:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    88d4:	01f30004 	mvnseq	r0, r4
    88d8:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    88e8:	00010000 	andeq	r0, r1, r0
    88ec:	00000051 	andeq	r0, r0, r1, asr r0
    88f0:	00000000 	andeq	r0, r0, r0
    88f4:	f3000400 	vshl.u8	d0, d0, d0
    88f8:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
    8908:	01000000 	mrseq	r0, (UNDEF: 0)
    890c:	00005000 	andeq	r5, r0, r0
    8910:	00000000 	andeq	r0, r0, r0
    8914:	00040000 	andeq	r0, r4, r0
    8918:	9f5001f3 	svcls	0x005001f3
	...
    892c:	00510001 	subseq	r0, r1, r1
    8930:	00000000 	andeq	r0, r0, r0
    8934:	04000000 	streq	r0, [r0], #-0
    8938:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    893c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8940:	00000000 	andeq	r0, r0, r0
    8944:	005c6000 	subseq	r6, ip, r0
    8948:	005c6a00 	subseq	r6, ip, r0, lsl #20
    894c:	50000100 	andpl	r0, r0, r0, lsl #2
    8950:	00005c6a 	andeq	r5, r0, sl, ror #24
    8954:	00005c7c 	andeq	r5, r0, ip, ror ip
    8958:	01f30004 	mvnseq	r0, r4
    895c:	00009f50 	andeq	r9, r0, r0, asr pc
    8960:	00000000 	andeq	r0, r0, r0
    8964:	5c7c0000 	ldclpl	0, cr0, [ip], #-0
    8968:	5c860000 	stcpl	0, cr0, [r6], {0}
    896c:	00010000 	andeq	r0, r1, r0
    8970:	005c8650 	subseq	r8, ip, r0, asr r6
    8974:	005c9800 	subseq	r9, ip, r0, lsl #16
    8978:	f3000400 	vshl.u8	d0, d0, d0
    897c:	009f5001 	addseq	r5, pc, r1
    8980:	00000000 	andeq	r0, r0, r0
    8984:	98000000 	stmdals	r0, {}	; <UNPREDICTABLE>
    8988:	a200005c 	andge	r0, r0, #92	; 0x5c
    898c:	0100005c 	qaddeq	r0, ip, r0
    8990:	5ca25000 	stcpl	0, cr5, [r2]
    8994:	5cb40000 	ldcpl	0, cr0, [r4]
    8998:	00040000 	andeq	r0, r4, r0
    899c:	9f5001f3 	svcls	0x005001f3
	...
    89b0:	00510001 	subseq	r0, r1, r1
    89b4:	00000000 	andeq	r0, r0, r0
    89b8:	04000000 	streq	r0, [r0], #-0
    89bc:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    89c0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    89c4:	00000000 	andeq	r0, r0, r0
    89c8:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    89d4:	01f30004 	mvnseq	r0, r4
    89d8:	00009f51 	andeq	r9, r0, r1, asr pc
	...
    89e8:	00010000 	andeq	r0, r1, r0
    89ec:	00000053 	andeq	r0, r0, r3, asr r0
    89f0:	00000000 	andeq	r0, r0, r0
    89f4:	53000100 	movwpl	r0, #256	; 0x100
	...
    8a00:	00530001 	subseq	r0, r3, r1
    8a04:	00000000 	andeq	r0, r0, r0
    8a08:	b4000000 	strlt	r0, [r0], #-0
    8a0c:	c000005c 	andgt	r0, r0, ip, asr r0
    8a10:	0100005c 	qaddeq	r0, ip, r0
    8a14:	5cc05000 	stclpl	0, cr5, [r0], {0}
    8a18:	5cf40000 	ldclpl	0, cr0, [r4]
    8a1c:	00040000 	andeq	r0, r4, r0
    8a20:	9f5001f3 	svcls	0x005001f3
	...
    8a2c:	00005cb4 			; <UNDEFINED> instruction: 0x00005cb4
    8a30:	00005ce2 	andeq	r5, r0, r2, ror #25
    8a34:	e2510001 	subs	r0, r1, #1
    8a38:	f400005c 	vst4.16	{d0-d3}, [r0 :64], ip
    8a3c:	0400005c 	streq	r0, [r0], #-92	; 0x5c
    8a40:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    8a44:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8a48:	00000000 	andeq	r0, r0, r0
    8a4c:	005ccc00 	subseq	ip, ip, r0, lsl #24
    8a50:	005cd400 	subseq	sp, ip, r0, lsl #8
    8a54:	53000100 	movwpl	r0, #256	; 0x100
    8a58:	00005cd4 	ldrdeq	r5, [r0], -r4
    8a5c:	00005cd6 	ldrdeq	r5, [r0], -r6
    8a60:	00710005 	rsbseq	r0, r1, r5
    8a64:	d69f2535 			; <UNDEFINED> instruction: 0xd69f2535
    8a68:	d800005c 	stmdale	r0, {r2, r3, r4, r6}
    8a6c:	0100005c 	qaddeq	r0, ip, r0
    8a70:	5ce05300 	stclpl	3, cr5, [r0]
    8a74:	5ce80000 	stclpl	0, cr0, [r8]
    8a78:	00010000 	andeq	r0, r1, r0
    8a7c:	00000053 	andeq	r0, r0, r3, asr r0
	...
    8a8c:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8a98:	01f30004 	mvnseq	r0, r4
    8a9c:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8aac:	00010000 	andeq	r0, r1, r0
    8ab0:	00000050 	andeq	r0, r0, r0, asr r0
    8ab4:	00000000 	andeq	r0, r0, r0
    8ab8:	f3000400 	vshl.u8	d0, d0, d0
    8abc:	009f5001 	addseq	r5, pc, r1
	...
    8acc:	01000000 	mrseq	r0, (UNDEF: 0)
    8ad0:	00005000 	andeq	r5, r0, r0
    8ad4:	00000000 	andeq	r0, r0, r0
    8ad8:	00040000 	andeq	r0, r4, r0
    8adc:	9f5001f3 	svcls	0x005001f3
	...
    8af0:	00510001 	subseq	r0, r1, r1
    8af4:	00000000 	andeq	r0, r0, r0
    8af8:	04000000 	streq	r0, [r0], #-0
    8afc:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    8b00:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8b10:	52000100 	andpl	r0, r0, #0, 2
	...
    8b1c:	01f30004 	mvnseq	r0, r4
    8b20:	00009f52 	andeq	r9, r0, r2, asr pc
	...
    8b30:	00010000 	andeq	r0, r1, r0
    8b34:	00000050 	andeq	r0, r0, r0, asr r0
    8b38:	00000000 	andeq	r0, r0, r0
    8b3c:	f3000400 	vshl.u8	d0, d0, d0
    8b40:	009f5001 	addseq	r5, pc, r1
	...
    8b50:	01000000 	mrseq	r0, (UNDEF: 0)
    8b54:	00005100 	andeq	r5, r0, r0, lsl #2
    8b58:	00000000 	andeq	r0, r0, r0
    8b5c:	00040000 	andeq	r0, r4, r0
    8b60:	9f5101f3 	svcls	0x005101f3
	...
    8b74:	00500001 	subseq	r0, r0, r1
    8b78:	00000000 	andeq	r0, r0, r0
    8b7c:	04000000 	streq	r0, [r0], #-0
    8b80:	5001f300 	andpl	pc, r1, r0, lsl #6
    8b84:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8b94:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    8ba0:	01f30004 	mvnseq	r0, r4
    8ba4:	00009f51 	andeq	r9, r0, r1, asr pc
	...
    8bb4:	00010000 	andeq	r0, r1, r0
    8bb8:	00000050 	andeq	r0, r0, r0, asr r0
    8bbc:	00000000 	andeq	r0, r0, r0
    8bc0:	f3000400 	vshl.u8	d0, d0, d0
    8bc4:	009f5001 	addseq	r5, pc, r1
	...
    8bd4:	01000000 	mrseq	r0, (UNDEF: 0)
    8bd8:	00005000 	andeq	r5, r0, r0
    8bdc:	00000000 	andeq	r0, r0, r0
    8be0:	00040000 	andeq	r0, r4, r0
    8be4:	9f5001f3 	svcls	0x005001f3
	...
    8bf8:	00500001 	subseq	r0, r0, r1
    8bfc:	00000000 	andeq	r0, r0, r0
    8c00:	04000000 	streq	r0, [r0], #-0
    8c04:	5001f300 	andpl	pc, r1, r0, lsl #6
    8c08:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8c0c:	00000000 	andeq	r0, r0, r0
    8c10:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8c1c:	01f30004 	mvnseq	r0, r4
    8c20:	00009f50 	andeq	r9, r0, r0, asr pc
    8c24:	00000000 	andeq	r0, r0, r0
    8c28:	00010000 	andeq	r0, r1, r0
    8c2c:	00000050 	andeq	r0, r0, r0, asr r0
	...
    8c3c:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    8c48:	01f30004 	mvnseq	r0, r4
    8c4c:	00009f51 	andeq	r9, r0, r1, asr pc
    8c50:	00000000 	andeq	r0, r0, r0
    8c54:	00010000 	andeq	r0, r1, r0
    8c58:	00000051 	andeq	r0, r0, r1, asr r0
    8c5c:	00000000 	andeq	r0, r0, r0
    8c60:	f3000400 	vshl.u8	d0, d0, d0
    8c64:	009f5101 	addseq	r5, pc, r1, lsl #2
    8c68:	00000000 	andeq	r0, r0, r0
    8c6c:	01000000 	mrseq	r0, (UNDEF: 0)
    8c70:	00005100 	andeq	r5, r0, r0, lsl #2
	...
    8c80:	00010000 	andeq	r0, r1, r0
    8c84:	00000052 	andeq	r0, r0, r2, asr r0
    8c88:	00000000 	andeq	r0, r0, r0
    8c8c:	f3000400 	vshl.u8	d0, d0, d0
    8c90:	009f5201 	addseq	r5, pc, r1, lsl #4
    8c94:	00000000 	andeq	r0, r0, r0
    8c98:	01000000 	mrseq	r0, (UNDEF: 0)
    8c9c:	00005200 	andeq	r5, r0, r0, lsl #4
	...
    8cac:	00010000 	andeq	r0, r1, r0
    8cb0:	00000051 	andeq	r0, r0, r1, asr r0
    8cb4:	00000000 	andeq	r0, r0, r0
    8cb8:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    8ccc:	00530001 	subseq	r0, r3, r1
    8cd0:	00000000 	andeq	r0, r0, r0
    8cd4:	05000000 	streq	r0, [r0, #-0]
    8cd8:	35007200 	strcc	r7, [r0, #-512]	; 0x200
    8cdc:	00009f25 	andeq	r9, r0, r5, lsr #30
    8ce0:	00000000 	andeq	r0, r0, r0
    8ce4:	00010000 	andeq	r0, r1, r0
    8ce8:	00000053 	andeq	r0, r0, r3, asr r0
    8cec:	00000000 	andeq	r0, r0, r0
    8cf0:	53000100 	movwpl	r0, #256	; 0x100
	...
    8d04:	00530001 	subseq	r0, r3, r1
    8d08:	00000000 	andeq	r0, r0, r0
    8d0c:	01000000 	mrseq	r0, (UNDEF: 0)
    8d10:	00005300 	andeq	r5, r0, r0, lsl #6
	...
    8d20:	00010000 	andeq	r0, r1, r0
    8d24:	00000051 	andeq	r0, r0, r1, asr r0
    8d28:	00000000 	andeq	r0, r0, r0
    8d2c:	72000500 	andvc	r0, r0, #0, 10
    8d30:	9f253500 	svcls	0x00253500
	...
    8d3c:	00510001 	subseq	r0, r1, r1
    8d40:	00000000 	andeq	r0, r0, r0
    8d44:	01000000 	mrseq	r0, (UNDEF: 0)
    8d48:	00005100 	andeq	r5, r0, r0, lsl #2
	...
    8d58:	00010000 	andeq	r0, r1, r0
    8d5c:	00000050 	andeq	r0, r0, r0, asr r0
    8d60:	00000000 	andeq	r0, r0, r0
    8d64:	f3000400 	vshl.u8	d0, d0, d0
    8d68:	009f5001 	addseq	r5, pc, r1
    8d6c:	00000000 	andeq	r0, r0, r0
    8d70:	01000000 	mrseq	r0, (UNDEF: 0)
    8d74:	00005000 	andeq	r5, r0, r0
    8d78:	00000000 	andeq	r0, r0, r0
    8d7c:	00040000 	andeq	r0, r4, r0
    8d80:	9f5001f3 	svcls	0x005001f3
	...
    8d94:	00510001 	subseq	r0, r1, r1
    8d98:	00000000 	andeq	r0, r0, r0
    8d9c:	04000000 	streq	r0, [r0], #-0
    8da0:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    8da4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8da8:	00000000 	andeq	r0, r0, r0
    8dac:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    8dc0:	00520001 	subseq	r0, r2, r1
    8dc4:	00000000 	andeq	r0, r0, r0
    8dc8:	04000000 	streq	r0, [r0], #-0
    8dcc:	5201f300 	andpl	pc, r1, #0, 6
    8dd0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8dd4:	00000000 	andeq	r0, r0, r0
    8dd8:	52000100 	andpl	r0, r0, #0, 2
	...
    8dec:	00510001 	subseq	r0, r1, r1
	...
    8dfc:	01000000 	mrseq	r0, (UNDEF: 0)
    8e00:	00005300 	andeq	r5, r0, r0, lsl #6
    8e04:	00000000 	andeq	r0, r0, r0
    8e08:	00050000 	andeq	r0, r5, r0
    8e0c:	25350072 	ldrcs	r0, [r5, #-114]!	; 0x72
    8e10:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8e14:	00000000 	andeq	r0, r0, r0
    8e18:	53000100 	movwpl	r0, #256	; 0x100
	...
    8e24:	00530001 	subseq	r0, r3, r1
	...
    8e34:	01000000 	mrseq	r0, (UNDEF: 0)
    8e38:	00005000 	andeq	r5, r0, r0
    8e3c:	00000000 	andeq	r0, r0, r0
    8e40:	00040000 	andeq	r0, r4, r0
    8e44:	9f5001f3 	svcls	0x005001f3
	...
    8e50:	00500001 	subseq	r0, r0, r1
    8e54:	00000000 	andeq	r0, r0, r0
    8e58:	04000000 	streq	r0, [r0], #-0
    8e5c:	5001f300 	andpl	pc, r1, r0, lsl #6
    8e60:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8e70:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    8e7c:	01f30004 	mvnseq	r0, r4
    8e80:	00009f51 	andeq	r9, r0, r1, asr pc
    8e84:	00000000 	andeq	r0, r0, r0
    8e88:	00010000 	andeq	r0, r1, r0
    8e8c:	00000051 	andeq	r0, r0, r1, asr r0
	...
    8e9c:	52000100 	andpl	r0, r0, #0, 2
	...
    8ea8:	01f30004 	mvnseq	r0, r4
    8eac:	00009f52 	andeq	r9, r0, r2, asr pc
    8eb0:	00000000 	andeq	r0, r0, r0
    8eb4:	00010000 	andeq	r0, r1, r0
    8eb8:	00000052 	andeq	r0, r0, r2, asr r0
	...
    8ec8:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    8edc:	00530001 	subseq	r0, r3, r1
    8ee0:	00000000 	andeq	r0, r0, r0
    8ee4:	05000000 	streq	r0, [r0, #-0]
    8ee8:	35007200 	strcc	r7, [r0, #-512]	; 0x200
    8eec:	00009f25 	andeq	r9, r0, r5, lsr #30
    8ef0:	00000000 	andeq	r0, r0, r0
    8ef4:	00010000 	andeq	r0, r1, r0
    8ef8:	00000053 	andeq	r0, r0, r3, asr r0
    8efc:	00000000 	andeq	r0, r0, r0
    8f00:	53000100 	movwpl	r0, #256	; 0x100
	...
    8f14:	00500001 	subseq	r0, r0, r1
    8f18:	00000000 	andeq	r0, r0, r0
    8f1c:	04000000 	streq	r0, [r0], #-0
    8f20:	5001f300 	andpl	pc, r1, r0, lsl #6
    8f24:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8f34:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8f40:	01f30004 	mvnseq	r0, r4
    8f44:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8f54:	00010000 	andeq	r0, r1, r0
    8f58:	00000050 	andeq	r0, r0, r0, asr r0
    8f5c:	00000000 	andeq	r0, r0, r0
    8f60:	f3000400 	vshl.u8	d0, d0, d0
    8f64:	009f5001 	addseq	r5, pc, r1
	...
    8f74:	01000000 	mrseq	r0, (UNDEF: 0)
    8f78:	00005000 	andeq	r5, r0, r0
    8f7c:	00000000 	andeq	r0, r0, r0
    8f80:	00040000 	andeq	r0, r4, r0
    8f84:	9f5001f3 	svcls	0x005001f3
	...
    8f90:	00500001 	subseq	r0, r0, r1
    8f94:	00000000 	andeq	r0, r0, r0
    8f98:	04000000 	streq	r0, [r0], #-0
    8f9c:	5001f300 	andpl	pc, r1, r0, lsl #6
    8fa0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8fb0:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8fbc:	01f30004 	mvnseq	r0, r4
    8fc0:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8fd0:	000e0000 	andeq	r0, lr, r0
    8fd4:	ff080070 			; <UNDEFINED> instruction: 0xff080070
    8fd8:	7124381a 	teqvc	r4, sl, lsl r8
    8fdc:	1aff0800 	bne	fffcafe4 <BootRAM+0xef3b785>
    8fe0:	00009f21 	andeq	r9, r0, r1, lsr #30
    8fe4:	00000000 	andeq	r0, r0, r0
    8fe8:	000f0000 	andeq	r0, pc, r0
    8fec:	085001f3 	ldmdaeq	r0, {r0, r1, r4, r5, r6, r7, r8}^
    8ff0:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
    8ff4:	ff080071 			; <UNDEFINED> instruction: 0xff080071
    8ff8:	009f211a 	addseq	r2, pc, sl, lsl r1	; <UNPREDICTABLE>
	...
    9008:	01000000 	mrseq	r0, (UNDEF: 0)
    900c:	00005000 	andeq	r5, r0, r0
    9010:	00000000 	andeq	r0, r0, r0
    9014:	00040000 	andeq	r0, r4, r0
    9018:	9f5001f3 	svcls	0x005001f3
	...
    902c:	00500001 	subseq	r0, r0, r1
	...
    903c:	0d000000 	stceq	0, cr0, [r0, #-0]
    9040:	38007000 	stmdacc	r0, {ip, sp, lr}
    9044:	08007025 	stmdaeq	r0, {r0, r2, r5, ip, sp, lr}
    9048:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
    904c:	00009f21 	andeq	r9, r0, r1, lsr #30
    9050:	00000000 	andeq	r0, r0, r0
    9054:	5cf60000 	ldclpl	0, cr0, [r6]
    9058:	5d5c0000 	ldclpl	0, cr0, [ip, #-0]
    905c:	00020000 	andeq	r0, r2, r0
    9060:	5d5c9f30 	ldclpl	15, cr9, [ip, #-192]	; 0xffffff40
    9064:	5d600000 	stclpl	0, cr0, [r0, #-0]
    9068:	00070000 	andeq	r0, r7, r0
    906c:	ff0a0073 			; <UNDEFINED> instruction: 0xff0a0073
    9070:	709f1aff 			; <UNDEFINED> instruction: 0x709f1aff
    9074:	7a00005d 	bvc	91f0 <_etext+0x1cd8>
    9078:	0700005d 	smlsdeq	r0, sp, r0, r0
    907c:	0a007300 	beq	25c84 <_etext+0x1e76c>
    9080:	9f1affff 	svcls	0x001affff
    9084:	00005d84 	andeq	r5, r0, r4, lsl #27
    9088:	00005d8e 	andeq	r5, r0, lr, lsl #27
    908c:	00730007 	rsbseq	r0, r3, r7
    9090:	1affff0a 	bne	8cc0 <_etext+0x17a8>
    9094:	005dda9f 			; <UNDEFINED> instruction: 0x005dda9f
    9098:	005de600 	subseq	lr, sp, r0, lsl #12
    909c:	30000200 	andcc	r0, r0, r0, lsl #4
    90a0:	005de69f 			; <UNDEFINED> instruction: 0x005de69f
    90a4:	005e2600 	subseq	r2, lr, r0, lsl #12
    90a8:	75000700 	strvc	r0, [r0, #-1792]	; 0x700
    90ac:	ffff0a00 			; <UNDEFINED> instruction: 0xffff0a00
    90b0:	5e269f1a 	mcrpl	15, 1, r9, cr6, cr10, {0}
    90b4:	5e480000 	cdppl	0, 4, cr0, cr8, cr0, {0}
    90b8:	00020000 	andeq	r0, r2, r0
    90bc:	00009f30 	andeq	r9, r0, r0, lsr pc
    90c0:	00000000 	andeq	r0, r0, r0
    90c4:	5d3c0000 	ldcpl	0, cr0, [ip, #-0]
    90c8:	5d400000 	stclpl	0, cr0, [r0, #-0]
    90cc:	00070000 	andeq	r0, r7, r0
    90d0:	000a0072 	andeq	r0, sl, r2, ror r0
    90d4:	409f2720 	addsmi	r2, pc, r0, lsr #14
    90d8:	4400005d 	strmi	r0, [r0], #-93	; 0x5d
    90dc:	0b00005d 	bleq	9258 <_etext+0x1d40>
    90e0:	0a007200 	beq	258e8 <_etext+0x1e3d0>
    90e4:	0a272000 	beq	9d10ec <_etext+0x9c9bd4>
    90e8:	9f272000 	svcls	0x00272000
    90ec:	00005d44 	andeq	r5, r0, r4, asr #26
    90f0:	00005d54 	andeq	r5, r0, r4, asr sp
    90f4:	0074000c 	rsbseq	r0, r4, ip
    90f8:	20000a06 	andcs	r0, r0, r6, lsl #20
    90fc:	20000a27 	andcs	r0, r0, r7, lsr #20
    9100:	00009f27 	andeq	r9, r0, r7, lsr #30
    9104:	00000000 	andeq	r0, r0, r0
    9108:	5d4e0000 	stclpl	0, cr0, [lr, #-0]
    910c:	5d520000 	ldclpl	0, cr0, [r2, #-0]
    9110:	00060000 	andeq	r0, r6, r0
    9114:	20080072 	andcs	r0, r8, r2, ror r0
    9118:	5d529f27 	ldclpl	15, cr9, [r2, #-156]	; 0xffffff64
    911c:	5d620000 	stclpl	0, cr0, [r2, #-0]
    9120:	00090000 	andeq	r0, r9, r0
    9124:	20080072 	andcs	r0, r8, r2, ror r0
    9128:	27200827 	strcs	r0, [r0, -r7, lsr #16]!
    912c:	005d629f 			; <UNDEFINED> instruction: 0x005d629f
    9130:	005d6a00 	subseq	r6, sp, r0, lsl #20
    9134:	74000a00 	strvc	r0, [r0], #-2560	; 0xa00
    9138:	20080600 	andcs	r0, r8, r0, lsl #12
    913c:	27200827 	strcs	r0, [r0, -r7, lsr #16]!
    9140:	005d709f 			; <UNDEFINED> instruction: 0x005d709f
    9144:	005d7200 	subseq	r7, sp, r0, lsl #4
    9148:	72000900 	andvc	r0, r0, #0, 18
    914c:	27200800 	strcs	r0, [r0, -r0, lsl #16]!
    9150:	9f272008 	svcls	0x00272008
    9154:	00005d72 	andeq	r5, r0, r2, ror sp
    9158:	00005d7e 	andeq	r5, r0, lr, ror sp
    915c:	0074000a 	rsbseq	r0, r4, sl
    9160:	27200806 	strcs	r0, [r0, -r6, lsl #16]!
    9164:	9f272008 	svcls	0x00272008
    9168:	00005d84 	andeq	r5, r0, r4, lsl #27
    916c:	00005d92 	muleq	r0, r2, sp
    9170:	0074000a 	rsbseq	r0, r4, sl
    9174:	27200806 	strcs	r0, [r0, -r6, lsl #16]!
    9178:	9f272008 	svcls	0x00272008
	...
    9184:	00005da4 	andeq	r5, r0, r4, lsr #27
    9188:	00005dba 			; <UNDEFINED> instruction: 0x00005dba
    918c:	ba530001 	blt	14c9198 <_etext+0x14c1c80>
    9190:	d800005d 	stmdale	r0, {r0, r2, r3, r4, r6}
    9194:	0400005d 	streq	r0, [r0], #-93	; 0x5d
    9198:	06007200 	streq	r7, [r0], -r0, lsl #4
    919c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    91a0:	00000000 	andeq	r0, r0, r0
    91a4:	005dc600 	subseq	ip, sp, r0, lsl #12
    91a8:	005dda00 	subseq	sp, sp, r0, lsl #20
    91ac:	53000100 	movwpl	r0, #256	; 0x100
	...
    91c0:	9f300002 	svcls	0x00300002
	...
    91cc:	00710007 	rsbseq	r0, r1, r7
    91d0:	1affff0a 	bne	8e00 <_etext+0x18e8>
    91d4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    91d8:	00000000 	andeq	r0, r0, r0
    91dc:	71000700 	tstvc	r0, r0, lsl #14
    91e0:	ffff0a00 			; <UNDEFINED> instruction: 0xffff0a00
    91e4:	00009f1a 	andeq	r9, r0, sl, lsl pc
    91e8:	00000000 	andeq	r0, r0, r0
    91ec:	00020000 	andeq	r0, r2, r0
    91f0:	00009f30 	andeq	r9, r0, r0, lsr pc
    91f4:	00000000 	andeq	r0, r0, r0
    91f8:	5e800000 	cdppl	0, 8, cr0, cr0, cr0, {0}
    91fc:	5e950000 	cdppl	0, 9, cr0, cr5, cr0, {0}
    9200:	00010000 	andeq	r0, r1, r0
    9204:	005e9550 	subseq	r9, lr, r0, asr r5
    9208:	005ea400 	subseq	sl, lr, r0, lsl #8
    920c:	f3000400 	vshl.u8	d0, d0, d0
    9210:	009f5001 	addseq	r5, pc, r1
    9214:	00000000 	andeq	r0, r0, r0
    9218:	a4000000 	strge	r0, [r0], #-0
    921c:	b900005e 	stmdblt	r0, {r1, r2, r3, r4, r6}
    9220:	0100005e 	qaddeq	r0, lr, r0
    9224:	5eb95000 	cdppl	0, 11, cr5, cr9, cr0, {0}
    9228:	5ec80000 	cdppl	0, 12, cr0, cr8, cr0, {0}
    922c:	00040000 	andeq	r0, r4, r0
    9230:	9f5001f3 	svcls	0x005001f3
	...
    923c:	00005ec8 	andeq	r5, r0, r8, asr #29
    9240:	00005edc 	ldrdeq	r5, [r0], -ip
    9244:	dc500001 	mrrcle	0, 0, r0, r0, cr1	; <UNPREDICTABLE>
    9248:	5800005e 	stmdapl	r0, {r1, r2, r3, r4, r6}
    924c:	0400005f 	streq	r0, [r0], #-95	; 0x5f
    9250:	5001f300 	andpl	pc, r1, r0, lsl #6
    9254:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    9258:	00000000 	andeq	r0, r0, r0
    925c:	005eea00 	subseq	lr, lr, r0, lsl #20
    9260:	005eec00 	subseq	lr, lr, r0, lsl #24
    9264:	71000200 	mrsvc	r0, R8_usr
    9268:	00000009 	andeq	r0, r0, r9
    926c:	00000000 	andeq	r0, r0, r0
    9270:	005f1200 	subseq	r1, pc, r0, lsl #4
    9274:	005f1400 	subseq	r1, pc, r0, lsl #8
    9278:	52000100 	andpl	r0, r0, #0, 2
    927c:	00005f14 	andeq	r5, r0, r4, lsl pc
    9280:	00005f2e 	andeq	r5, r0, lr, lsr #30
    9284:	00710005 	rsbseq	r0, r1, r5
    9288:	329f1a3f 	addscc	r1, pc, #258048	; 0x3f000
    928c:	3c00005f 	stccc	0, cr0, [r0], {95}	; 0x5f
    9290:	0500005f 	streq	r0, [r0, #-95]	; 0x5f
    9294:	3f007100 	svccc	0x00007100
    9298:	00009f1a 	andeq	r9, r0, sl, lsl pc
    929c:	00000000 	andeq	r0, r0, r0
    92a0:	5f600000 	svcpl	0x00600000
    92a4:	5fe60000 	svcpl	0x00e60000
    92a8:	00030000 	andeq	r0, r3, r0
    92ac:	009f1074 	addseq	r1, pc, r4, ror r0	; <UNPREDICTABLE>
    92b0:	00000000 	andeq	r0, r0, r0
    92b4:	64000000 	strvs	r0, [r0], #-0
    92b8:	8e00005f 	mcrhi	0, 0, r0, cr0, cr15, {2}
    92bc:	0100005f 	qaddeq	r0, pc, r0	; <UNPREDICTABLE>
    92c0:	5f8e5300 	svcpl	0x008e5300
    92c4:	5f940000 	svcpl	0x00940000
    92c8:	00090000 	andeq	r0, r9, r0
    92cc:	02941074 	addseq	r1, r4, #116	; 0x74
    92d0:	1affff0a 	bne	8f00 <_etext+0x19e8>
    92d4:	005f949f 			; <UNDEFINED> instruction: 0x005f949f
    92d8:	005fa800 	subseq	sl, pc, r0, lsl #16
    92dc:	53000100 	movwpl	r0, #256	; 0x100
    92e0:	00005fa8 	andeq	r5, r0, r8, lsr #31
    92e4:	00005fa9 	andeq	r5, r0, r9, lsr #31
    92e8:	10740009 	rsbsne	r0, r4, r9
    92ec:	ff0a0294 			; <UNDEFINED> instruction: 0xff0a0294
    92f0:	009f1aff 			; <UNDEFINED> instruction: 0x009f1aff
    92f4:	00000000 	andeq	r0, r0, r0
    92f8:	66000000 	strvs	r0, [r0], -r0
    92fc:	8800005f 	stmdahi	r0, {r0, r1, r2, r3, r4, r6}
    9300:	0600005f 			; <UNDEFINED> instruction: 0x0600005f
    9304:	08007600 	stmdaeq	r0, {r9, sl, ip, sp, lr}
    9308:	889f1aff 	ldmhi	pc, {r0, r1, r2, r3, r4, r5, r6, r7, r9, fp, ip}	; <UNPREDICTABLE>
    930c:	8c00005f 	stchi	0, cr0, [r0], {95}	; 0x5f
    9310:	0200005f 	andeq	r0, r0, #95	; 0x5f
    9314:	8c9f3400 	cfldrshi	mvf3, [pc], {0}
    9318:	9400005f 	strls	r0, [r0], #-95	; 0x5f
    931c:	0200005f 	andeq	r0, r0, #95	; 0x5f
    9320:	949f3700 	ldrls	r3, [pc], #1792	; 9328 <_etext+0x1e10>
    9324:	9e00005f 	mcrls	0, 0, r0, cr0, cr15, {2}
    9328:	0600005f 			; <UNDEFINED> instruction: 0x0600005f
    932c:	08007600 	stmdaeq	r0, {r9, sl, ip, sp, lr}
    9330:	9e9f1aff 	mrcls	10, 4, r1, cr15, cr15, {7}
    9334:	e600005f 			; <UNDEFINED> instruction: 0xe600005f
    9338:	0100005f 	qaddeq	r0, pc, r0	; <UNPREDICTABLE>
    933c:	00005600 	andeq	r5, r0, r0, lsl #12
    9340:	00000000 	andeq	r0, r0, r0
    9344:	5fac0000 	svcpl	0x00ac0000
    9348:	5fae0000 	svcpl	0x00ae0000
    934c:	00010000 	andeq	r0, r1, r0
    9350:	005fae50 	subseq	sl, pc, r0, asr lr	; <UNPREDICTABLE>
    9354:	005fdc00 	subseq	sp, pc, r0, lsl #24
    9358:	59000100 	stmdbpl	r0, {r8}
	...
    9364:	00005f96 	muleq	r0, r6, pc	; <UNPREDICTABLE>
    9368:	00005f9e 	muleq	r0, lr, pc	; <UNPREDICTABLE>
    936c:	9e550001 	cdpls	0, 5, cr0, cr5, cr1, {0}
    9370:	a400005f 	strge	r0, [r0], #-95	; 0x5f
    9374:	1600005f 			; <UNDEFINED> instruction: 0x1600005f
    9378:	12007500 	andne	r7, r0, #0, 10
    937c:	22244b40 	eorcs	r4, r4, #64, 22	; 0x10000
    9380:	14160073 	ldrne	r0, [r6], #-115	; 0x73
    9384:	22244b40 	eorcs	r4, r4, #64, 22	; 0x10000
    9388:	0001282d 	andeq	r2, r1, sp, lsr #16
    938c:	a49f1316 	ldrge	r1, [pc], #790	; 9394 <_etext+0x1e7c>
    9390:	d200005f 	andle	r0, r0, #95	; 0x5f
    9394:	0100005f 	qaddeq	r0, pc, r0	; <UNPREDICTABLE>
    9398:	00005500 	andeq	r5, r0, r0, lsl #10
    939c:	00000000 	andeq	r0, r0, r0
    93a0:	604a0000 	subvs	r0, sl, r0
    93a4:	60610000 	rsbvs	r0, r1, r0
    93a8:	00010000 	andeq	r0, r1, r0
    93ac:	00607050 	rsbeq	r7, r0, r0, asr r0
    93b0:	00607200 	rsbeq	r7, r0, r0, lsl #4
    93b4:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    93c0:	00006088 	andeq	r6, r0, r8, lsl #1
    93c4:	0000608c 	andeq	r6, r0, ip, lsl #1
    93c8:	00700006 	rsbseq	r0, r0, r6
    93cc:	9f1a7f08 	svcls	0x001a7f08
    93d0:	0000608c 	andeq	r6, r0, ip, lsl #1
    93d4:	000060b0 	strheq	r6, [r0], -r0
    93d8:	b0500001 	subslt	r0, r0, r1
    93dc:	d6000060 	strle	r0, [r0], -r0, rrx
    93e0:	0b000060 	bleq	9568 <_etext+0x2050>
    93e4:	94007300 	strls	r7, [r0], #-768	; 0x300
    93e8:	1a7f0801 	bne	1fcb3f4 <_etext+0x1fc3edc>
    93ec:	9f1aff08 	svcls	0x001aff08
	...
    93f8:	000060c8 	andeq	r6, r0, r8, asr #1
    93fc:	000060f5 	strdeq	r6, [r0], -r5
    9400:	00510001 	subseq	r0, r1, r1
    9404:	12000061 	andne	r0, r0, #97	; 0x61
    9408:	01000061 	tsteq	r0, r1, rrx
    940c:	61185100 	tstvs	r8, r0, lsl #2
    9410:	611b0000 	tstvs	fp, r0
    9414:	00010000 	andeq	r0, r1, r0
    9418:	00000051 	andeq	r0, r0, r1, asr r0
    941c:	00000000 	andeq	r0, r0, r0
    9420:	0060b000 	rsbeq	fp, r0, r0
    9424:	0060f200 	rsbeq	pc, r0, r0, lsl #4
    9428:	50000100 	andpl	r0, r0, r0, lsl #2
    942c:	00006100 	andeq	r6, r0, r0, lsl #2
    9430:	00006115 	andeq	r6, r0, r5, lsl r1
    9434:	18500001 	ldmdane	r0, {r0}^
    9438:	1b000061 	blne	95c4 <_etext+0x20ac>
    943c:	01000061 	tsteq	r0, r1, rrx
    9440:	00005000 	andeq	r5, r0, r0
    9444:	00000000 	andeq	r0, r0, r0
    9448:	60aa0000 	adcvs	r0, sl, r0
    944c:	60e20000 	rscvs	r0, r2, r0
    9450:	00060000 	andeq	r0, r6, r0
    9454:	ff080072 			; <UNDEFINED> instruction: 0xff080072
    9458:	00009f1a 	andeq	r9, r0, sl, lsl pc
    945c:	00000000 	andeq	r0, r0, r0
    9460:	61280000 	teqvs	r8, r0
    9464:	612c0000 	teqvs	ip, r0
    9468:	00070000 	andeq	r0, r7, r0
    946c:	000a0073 	andeq	r0, sl, r3, ror r0
    9470:	2c9f2730 	ldccs	7, cr2, [pc], {48}	; 0x30
    9474:	2e000061 	cdpcs	0, 0, cr0, cr0, cr1, {3}
    9478:	0b000061 	bleq	9604 <_etext+0x20ec>
    947c:	0a007300 	beq	26084 <_etext+0x1eb6c>
    9480:	0a273000 	beq	9d5488 <_etext+0x9cdf70>
    9484:	9f273000 	svcls	0x00273000
	...
    9490:	0000615c 	andeq	r6, r0, ip, asr r1
    9494:	00006196 	muleq	r0, r6, r1
    9498:	00720006 	rsbseq	r0, r2, r6
    949c:	9f1aff08 	svcls	0x001aff08
    94a0:	000061c4 	andeq	r6, r0, r4, asr #3
    94a4:	000061d4 	ldrdeq	r6, [r0], -r4
    94a8:	00720006 	rsbseq	r0, r2, r6
    94ac:	9f1aff08 	svcls	0x001aff08
	...
    94b8:	00006160 	andeq	r6, r0, r0, ror #2
    94bc:	00006180 	andeq	r6, r0, r0, lsl #3
    94c0:	80540001 	subshi	r0, r4, r1
    94c4:	96000061 	strls	r0, [r0], -r1, rrx
    94c8:	07000061 	streq	r0, [r0, -r1, rrx]
    94cc:	0b007200 	bleq	25cd4 <_etext+0x1e7bc>
    94d0:	9f1aff7f 	svcls	0x001aff7f
    94d4:	000061c4 	andeq	r6, r0, r4, asr #3
    94d8:	000061d4 	ldrdeq	r6, [r0], -r4
    94dc:	00720007 	rsbseq	r0, r2, r7
    94e0:	1aff7f0b 	bne	fffe9114 <BootRAM+0xef598b5>
    94e4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    94e8:	00000000 	andeq	r0, r0, r0
    94ec:	00617600 	rsbeq	r7, r1, r0, lsl #12
    94f0:	0061bf00 	rsbeq	fp, r1, r0, lsl #30
    94f4:	50000100 	andpl	r0, r0, r0, lsl #2
    94f8:	000061c4 	andeq	r6, r0, r4, asr #3
    94fc:	000061c6 	andeq	r6, r0, r6, asr #3
    9500:	00500001 	subseq	r0, r0, r1
    9504:	00000000 	andeq	r0, r0, r0
    9508:	a2000000 	andge	r0, r0, #0
    950c:	a6000061 	strge	r0, [r0], -r1, rrx
    9510:	05000061 	streq	r0, [r0, #-97]	; 0x61
    9514:	40007200 	andmi	r7, r0, r0, lsl #4
    9518:	61a69f27 			; <UNDEFINED> instruction: 0x61a69f27
    951c:	61a80000 			; <UNDEFINED> instruction: 0x61a80000
    9520:	00070000 	andeq	r0, r7, r0
    9524:	27400072 	smlsldxcs	r0, r0, r2, r0	; <UNPREDICTABLE>
    9528:	009f2740 	addseq	r2, pc, r0, asr #14
    952c:	00000000 	andeq	r0, r0, r0
    9530:	b2000000 	andlt	r0, r0, #0
    9534:	b6000061 	strlt	r0, [r0], -r1, rrx
    9538:	07000061 	streq	r0, [r0, -r1, rrx]
    953c:	0a007200 	beq	25d44 <_etext+0x1e82c>
    9540:	9f271000 	svcls	0x00271000
	...
    954c:	000061f8 	strdeq	r6, [r0], -r8
    9550:	0000620a 	andeq	r6, r0, sl, lsl #4
    9554:	0a500001 	beq	1409560 <_etext+0x1402048>
    9558:	14000062 	strne	r0, [r0], #-98	; 0x62
    955c:	04000062 	streq	r0, [r0], #-98	; 0x62
    9560:	5001f300 	andpl	pc, r1, r0, lsl #6
    9564:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    9568:	00000000 	andeq	r0, r0, r0
    956c:	0061f800 	rsbeq	pc, r1, r0, lsl #16
    9570:	00620200 	rsbeq	r0, r2, r0, lsl #4
    9574:	51000100 	mrspl	r0, (UNDEF: 16)
    9578:	00006202 	andeq	r6, r0, r2, lsl #4
    957c:	00006208 	andeq	r6, r0, r8, lsl #4
    9580:	01f30004 	mvnseq	r0, r4
    9584:	62089f51 	andvs	r9, r8, #324	; 0x144
    9588:	62140000 	andsvs	r0, r4, #0
    958c:	00010000 	andeq	r0, r1, r0
    9590:	00000051 	andeq	r0, r0, r1, asr r0
    9594:	00000000 	andeq	r0, r0, r0
    9598:	0061fe00 	rsbeq	pc, r1, r0, lsl #28
    959c:	00620400 	rsbeq	r0, r2, r0, lsl #8
    95a0:	53000100 	movwpl	r0, #256	; 0x100
    95a4:	00006204 	andeq	r6, r0, r4, lsl #4
    95a8:	00006208 	andeq	r6, r0, r8, lsl #4
    95ac:	12720009 	rsbsne	r0, r2, #9
    95b0:	ff0a0294 			; <UNDEFINED> instruction: 0xff0a0294
    95b4:	089f1aff 	ldmeq	pc, {r0, r1, r2, r3, r4, r5, r6, r7, r9, fp, ip}	; <UNPREDICTABLE>
    95b8:	14000062 	strne	r0, [r0], #-98	; 0x62
    95bc:	01000062 	tsteq	r0, r2, rrx
    95c0:	00005300 	andeq	r5, r0, r0, lsl #6
    95c4:	00000000 	andeq	r0, r0, r0
    95c8:	62660000 	rsbvs	r0, r6, #0
    95cc:	62700000 	rsbsvs	r0, r0, #0
    95d0:	00110000 	andseq	r0, r1, r0
    95d4:	ff0a0072 			; <UNDEFINED> instruction: 0xff0a0072
    95d8:	24311aff 	ldrtcs	r1, [r1], #-2815	; 0xaff
    95dc:	81c08023 	bichi	r8, r0, r3, lsr #32
    95e0:	939f0480 	orrsls	r0, pc, #128, 8	; 0x80000000
    95e4:	00000004 	andeq	r0, r0, r4
    95e8:	00000000 	andeq	r0, r0, r0
    95ec:	00629a00 	rsbeq	r9, r2, r0, lsl #20
    95f0:	0062aa00 	rsbeq	sl, r2, r0, lsl #20
    95f4:	32000200 	andcc	r0, r0, #0, 4
    95f8:	0062aa9f 	mlseq	r2, pc, sl, sl	; <UNPREDICTABLE>
    95fc:	0062ac00 	rsbeq	sl, r2, r0, lsl #24
    9600:	50000100 	andpl	r0, r0, r0, lsl #2
    9604:	000062ac 	andeq	r6, r0, ip, lsr #5
    9608:	000062b8 			; <UNDEFINED> instruction: 0x000062b8
    960c:	9f320002 	svcls	0x00320002
    9610:	000062bc 			; <UNDEFINED> instruction: 0x000062bc
    9614:	000062da 	ldrdeq	r6, [r0], -sl
    9618:	9f320002 	svcls	0x00320002
    961c:	000062e4 	andeq	r6, r0, r4, ror #5
    9620:	000062ea 	andeq	r6, r0, sl, ror #5
    9624:	ea500001 	b	1409630 <_etext+0x1402118>
    9628:	fa000062 	blx	97b8 <_etext+0x22a0>
    962c:	02000062 	andeq	r0, r0, #98	; 0x62
    9630:	fa9f3200 	blx	fe7d5e38 <BootRAM+0xd7465d9>
    9634:	fc000062 	stc2	0, cr0, [r0], {98}	; 0x62
    9638:	01000062 	tsteq	r0, r2, rrx
    963c:	62fc5000 	rscsvs	r5, ip, #0
    9640:	63160000 	tstvs	r6, #0
    9644:	00020000 	andeq	r0, r2, r0
    9648:	63169f32 	tstvs	r6, #50, 30	; 0xc8
    964c:	63180000 	tstvs	r8, #0
    9650:	00010000 	andeq	r0, r1, r0
    9654:	00631850 	rsbeq	r1, r3, r0, asr r8
    9658:	00632400 	rsbeq	r2, r3, r0, lsl #8
    965c:	32000200 	andcc	r0, r0, #0, 4
    9660:	0063249f 	mlseq	r3, pc, r4, r2	; <UNPREDICTABLE>
    9664:	00632600 	rsbeq	r2, r3, r0, lsl #12
    9668:	50000100 	andpl	r0, r0, r0, lsl #2
    966c:	00006326 	andeq	r6, r0, r6, lsr #6
    9670:	00006336 	andeq	r6, r0, r6, lsr r3
    9674:	9f320002 	svcls	0x00320002
    9678:	00006336 	andeq	r6, r0, r6, lsr r3
    967c:	0000633e 	andeq	r6, r0, lr, lsr r3
    9680:	56500001 	ldrbpl	r0, [r0], -r1
    9684:	58000063 	stmdapl	r0, {r0, r1, r5, r6}
    9688:	01000063 	tsteq	r0, r3, rrx
    968c:	00005000 	andeq	r5, r0, r0
    9690:	00000000 	andeq	r0, r0, r0
    9694:	629a0000 	addsvs	r0, sl, #0
    9698:	635e0000 	cmpvs	lr, #0
    969c:	00010000 	andeq	r0, r1, r0
    96a0:	00000054 	andeq	r0, r0, r4, asr r0
    96a4:	00000000 	andeq	r0, r0, r0
    96a8:	00633e00 	rsbeq	r3, r3, r0, lsl #28
    96ac:	00635600 	rsbeq	r5, r3, r0, lsl #12
    96b0:	36000200 	strcc	r0, [r0], -r0, lsl #4
    96b4:	0063589f 	mlseq	r3, pc, r8, r5	; <UNPREDICTABLE>
    96b8:	00635e00 	rsbeq	r5, r3, r0, lsl #28
    96bc:	53000100 	movwpl	r0, #256	; 0x100
	...
    96c8:	0000635e 	andeq	r6, r0, lr, asr r3
    96cc:	00006374 	andeq	r6, r0, r4, ror r3
    96d0:	9f300002 	svcls	0x00300002
    96d4:	00006374 	andeq	r6, r0, r4, ror r3
    96d8:	00006376 	andeq	r6, r0, r6, ror r3
    96dc:	76530001 	ldrbvc	r0, [r3], -r1
    96e0:	7e000063 	cdpvc	0, 0, cr0, cr0, cr3, {3}
    96e4:	02000063 	andeq	r0, r0, #99	; 0x63
    96e8:	7e9f3000 	cdpvc	0, 9, cr3, cr15, cr0, {0}
    96ec:	80000063 	andhi	r0, r0, r3, rrx
    96f0:	01000063 	tsteq	r0, r3, rrx
    96f4:	63805300 	orrvs	r5, r0, #0, 6
    96f8:	63880000 	orrvs	r0, r8, #0
    96fc:	00020000 	andeq	r0, r2, r0
    9700:	63889f30 	orrvs	r9, r8, #48, 30	; 0xc0
    9704:	638a0000 	orrvs	r0, sl, #0
    9708:	00010000 	andeq	r0, r1, r0
    970c:	00638a53 	rsbeq	r8, r3, r3, asr sl
    9710:	00639200 	rsbeq	r9, r3, r0, lsl #4
    9714:	30000200 	andcc	r0, r0, r0, lsl #4
    9718:	0063929f 	mlseq	r3, pc, r2, r9	; <UNPREDICTABLE>
    971c:	00639400 	rsbeq	r9, r3, r0, lsl #8
    9720:	53000100 	movwpl	r0, #256	; 0x100
    9724:	00006394 	muleq	r0, r4, r3
    9728:	00006450 	andeq	r6, r0, r0, asr r4
    972c:	9f300002 	svcls	0x00300002
    9730:	00006450 	andeq	r6, r0, r0, asr r4
    9734:	0000645d 	andeq	r6, r0, sp, asr r4
    9738:	10530001 	subsne	r0, r3, r1
    973c:	1a000065 	bne	98d8 <_etext+0x23c0>
    9740:	02000065 	andeq	r0, r0, #101	; 0x65
    9744:	1a9f3000 	bne	fe7d574c <BootRAM+0xd745eed>
    9748:	30000065 	andcc	r0, r0, r5, rrx
    974c:	06000065 	streq	r0, [r0], -r5, rrx
    9750:	5ea50300 	cdppl	3, 10, cr0, cr5, cr0, {0}
    9754:	009f0000 	addseq	r0, pc, r0
    9758:	00000000 	andeq	r0, r0, r0
    975c:	5e000000 	cdppl	0, 0, cr0, cr0, cr0, {0}
    9760:	62000064 	andvs	r0, r0, #100	; 0x64
    9764:	02000064 	andeq	r0, r0, #100	; 0x64
    9768:	6e9f3000 	cdpvs	0, 9, cr3, cr15, cr0, {0}
    976c:	84000064 	strhi	r0, [r0], #-100	; 0x64
    9770:	01000064 	tsteq	r0, r4, rrx
    9774:	64885000 	strvs	r5, [r8], #0
    9778:	64900000 	ldrvs	r0, [r0], #0
    977c:	00010000 	andeq	r0, r1, r0
    9780:	00649450 	rsbeq	r9, r4, r0, asr r4
    9784:	0064a200 	rsbeq	sl, r4, r0, lsl #4
    9788:	50000100 	andpl	r0, r0, r0, lsl #2
    978c:	000064fc 	strdeq	r6, [r0], -ip
    9790:	00006508 	andeq	r6, r0, r8, lsl #10
    9794:	00500001 	subseq	r0, r0, r1
    9798:	00000000 	andeq	r0, r0, r0
    979c:	5e000000 	cdppl	0, 0, cr0, cr0, cr0, {0}
    97a0:	56000063 	strpl	r0, [r0], -r3, rrx
    97a4:	01000064 	tsteq	r0, r4, rrx
    97a8:	64625400 	strbtvs	r5, [r2], #-1024	; 0x400
    97ac:	64780000 	ldrbtvs	r0, [r8], #-0
    97b0:	00010000 	andeq	r0, r1, r0
    97b4:	00651054 	rsbeq	r1, r5, r4, asr r0
    97b8:	00653000 	rsbeq	r3, r5, r0
    97bc:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    97c8:	000063e6 	andeq	r6, r0, r6, ror #7
    97cc:	00006412 	andeq	r6, r0, r2, lsl r4
    97d0:	00510001 	subseq	r0, r1, r1
    97d4:	00000000 	andeq	r0, r0, r0
    97d8:	e6000000 	str	r0, [r0], -r0
    97dc:	12000063 	andne	r0, r0, #99	; 0x63
    97e0:	09000064 	stmdbeq	r0, {r2, r5, r6}
    97e4:	08007300 	stmdaeq	r0, {r8, r9, ip, sp, lr}
    97e8:	ff081a70 			; <UNDEFINED> instruction: 0xff081a70
    97ec:	00009f1a 	andeq	r9, r0, sl, lsl pc
    97f0:	00000000 	andeq	r0, r0, r0
    97f4:	635e0000 	cmpvs	lr, #0
    97f8:	65080000 	strvs	r0, [r8, #-0]
    97fc:	00020000 	andeq	r0, r2, r0
    9800:	65109f30 	ldrvs	r9, [r0, #-3888]	; 0xf30
    9804:	65300000 	ldrvs	r0, [r0, #-0]!
    9808:	00020000 	andeq	r0, r2, r0
    980c:	00009f30 	andeq	r9, r0, r0, lsr pc
    9810:	00000000 	andeq	r0, r0, r0
    9814:	63fe0000 	mvnsvs	r0, #0
    9818:	64120000 	ldrvs	r0, [r2], #-0
    981c:	00010000 	andeq	r0, r1, r0
    9820:	00000052 	andeq	r0, r0, r2, asr r0
    9824:	00000000 	andeq	r0, r0, r0
    9828:	00636a00 	rsbeq	r6, r3, r0, lsl #20
    982c:	00636c00 	rsbeq	r6, r3, r0, lsl #24
    9830:	73000200 	movwvc	r0, #512	; 0x200
    9834:	00636c03 	rsbeq	r6, r3, r3, lsl #24
    9838:	00639400 	rsbeq	r9, r3, r0, lsl #8
    983c:	52000100 	andpl	r0, r0, #0, 2
    9840:	00006450 	andeq	r6, r0, r0, asr r4
    9844:	00006452 	andeq	r6, r0, r2, asr r4
    9848:	00520001 	subseq	r0, r2, r1
    984c:	00000000 	andeq	r0, r0, r0
    9850:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    9854:	42000065 	andmi	r0, r0, #101	; 0x65
    9858:	01000065 	tsteq	r0, r5, rrx
    985c:	65425300 	strbvs	r5, [r2, #-768]	; 0x300
    9860:	65530000 	ldrbvs	r0, [r3, #-0]
    9864:	00080000 	andeq	r0, r8, r0
    9868:	01940874 	orrseq	r0, r4, r4, ror r8
    986c:	9f1aff08 	svcls	0x001aff08
    9870:	000065c2 	andeq	r6, r0, r2, asr #11
    9874:	000065ca 	andeq	r6, r0, sl, asr #11
    9878:	ca530001 	bgt	14c9884 <_etext+0x14c236c>
    987c:	cf000065 	svcgt	0x00000065
    9880:	08000065 	stmdaeq	r0, {r0, r2, r5, r6}
    9884:	94087400 	strls	r7, [r8], #-1024	; 0x400
    9888:	1aff0801 	bne	fffcb894 <BootRAM+0xef3c035>
    988c:	0065d29f 	mlseq	r5, pc, r2, sp	; <UNPREDICTABLE>
    9890:	0065da00 	rsbeq	sp, r5, r0, lsl #20
    9894:	53000100 	movwpl	r0, #256	; 0x100
	...
    98a0:	00006540 	andeq	r6, r0, r0, asr #10
    98a4:	000065c4 	andeq	r6, r0, r4, asr #11
    98a8:	10740003 	rsbsne	r0, r4, r3
    98ac:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    98b0:	00000000 	andeq	r0, r0, r0
    98b4:	00654400 	rsbeq	r4, r5, r0, lsl #8
    98b8:	00655300 	rsbeq	r5, r5, r0, lsl #6
    98bc:	52000100 	andpl	r0, r0, #0, 2
	...
    98c8:	00006558 	andeq	r6, r0, r8, asr r5
    98cc:	00006560 	andeq	r6, r0, r0, ror #10
    98d0:	60500001 	subsvs	r0, r0, r1
    98d4:	72000065 	andvc	r0, r0, #101	; 0x65
    98d8:	01000065 	tsteq	r0, r5, rrx
    98dc:	00005700 	andeq	r5, r0, r0, lsl #14
    98e0:	00000000 	andeq	r0, r0, r0
    98e4:	654a0000 	strbvs	r0, [sl, #-0]
    98e8:	65500000 	ldrbvs	r0, [r0, #-0]
    98ec:	00160000 	andseq	r0, r6, r0
    98f0:	40120076 	andsmi	r0, r2, r6, ror r0
    98f4:	7222244b 	eorvc	r2, r2, #1258291200	; 0x4b000000
    98f8:	40141600 	andsmi	r1, r4, r0, lsl #12
    98fc:	2d22244b 	cfstrscs	mvf2, [r2, #-300]!	; 0xfffffed4
    9900:	16000128 	strne	r0, [r0], -r8, lsr #2
    9904:	65509f13 	ldrbvs	r9, [r0, #-3859]	; 0xf13
    9908:	65720000 	ldrbvs	r0, [r2, #-0]!
    990c:	00010000 	andeq	r0, r1, r0
    9910:	00000056 	andeq	r0, r0, r6, asr r0
    9914:	00000000 	andeq	r0, r0, r0
    9918:	0065f800 	rsbeq	pc, r5, r0, lsl #16
    991c:	00662400 	rsbeq	r2, r6, r0, lsl #8
    9920:	50000100 	andpl	r0, r0, r0, lsl #2
    9924:	00006624 	andeq	r6, r0, r4, lsr #12
    9928:	00006630 	andeq	r6, r0, r0, lsr r6
    992c:	01f30004 	mvnseq	r0, r4
    9930:	00009f50 	andeq	r9, r0, r0, asr pc
    9934:	00000000 	andeq	r0, r0, r0
    9938:	65fe0000 	ldrbvs	r0, [lr, #0]!
    993c:	66000000 	strvs	r0, [r0], -r0
    9940:	00020000 	andeq	r0, r2, r0
    9944:	66009f30 			; <UNDEFINED> instruction: 0x66009f30
    9948:	66200000 	strtvs	r0, [r0], -r0
    994c:	00010000 	andeq	r0, r1, r0
    9950:	00000053 	andeq	r0, r0, r3, asr r0
    9954:	00000000 	andeq	r0, r0, r0
    9958:	0065fe00 	rsbeq	pc, r5, r0, lsl #28
    995c:	00662800 	rsbeq	r2, r6, r0, lsl #16
    9960:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    996c:	00006638 	andeq	r6, r0, r8, lsr r6
    9970:	00006643 	andeq	r6, r0, r3, asr #12
    9974:	48520001 	ldmdami	r2, {r0}^
    9978:	4a000066 	bmi	9b18 <_etext+0x2600>
    997c:	01000066 	tsteq	r0, r6, rrx
    9980:	664a5300 	strbvs	r5, [sl], -r0, lsl #6
    9984:	66500000 	ldrbvs	r0, [r0], -r0
    9988:	00010000 	andeq	r0, r1, r0
    998c:	00665052 	rsbeq	r5, r6, r2, asr r0
    9990:	00665f00 	rsbeq	r5, r6, r0, lsl #30
    9994:	73000800 	movwvc	r0, #2048	; 0x800
    9998:	08019408 	stmdaeq	r1, {r3, sl, ip, pc}
    999c:	729f1aff 	addsvc	r1, pc, #1044480	; 0xff000
    99a0:	7d000066 	stcvc	0, cr0, [r0, #-408]	; 0xfffffe68
    99a4:	01000066 	tsteq	r0, r6, rrx
    99a8:	00005300 	andeq	r5, r0, r0, lsl #6
    99ac:	00000000 	andeq	r0, r0, r0
    99b0:	668c0000 	strvs	r0, [ip], r0
    99b4:	66a40000 	strtvs	r0, [r4], r0
    99b8:	00010000 	andeq	r0, r1, r0
    99bc:	0066a450 	rsbeq	sl, r6, r0, asr r4
    99c0:	0066a600 	rsbeq	sl, r6, r0, lsl #12
    99c4:	70000300 	andvc	r0, r0, r0, lsl #6
    99c8:	66a69f7e 			; <UNDEFINED> instruction: 0x66a69f7e
    99cc:	66b60000 	ldrtvs	r0, [r6], r0
    99d0:	00030000 	andeq	r0, r3, r0
    99d4:	b69f7f70 			; <UNDEFINED> instruction: 0xb69f7f70
    99d8:	ba000066 	blt	9b78 <_etext+0x2660>
    99dc:	01000066 	tsteq	r0, r6, rrx
    99e0:	66ba5000 	ldrtvs	r5, [sl], r0
    99e4:	66bc0000 	ldrtvs	r0, [ip], r0
    99e8:	00030000 	andeq	r0, r3, r0
    99ec:	009f7e70 	addseq	r7, pc, r0, ror lr	; <UNPREDICTABLE>
    99f0:	00000000 	andeq	r0, r0, r0
    99f4:	8c000000 	stchi	0, cr0, [r0], {-0}
    99f8:	92000066 	andls	r0, r0, #102	; 0x66
    99fc:	01000066 	tsteq	r0, r6, rrx
    9a00:	66925100 	ldrvs	r5, [r2], r0, lsl #2
    9a04:	66bc0000 	ldrtvs	r0, [ip], r0
    9a08:	00040000 	andeq	r0, r4, r0
    9a0c:	9f5101f3 	svcls	0x005101f3
	...
    9a18:	0000668c 	andeq	r6, r0, ip, lsl #13
    9a1c:	00006694 	muleq	r0, r4, r6
    9a20:	94520001 	ldrbls	r0, [r2], #-1
    9a24:	bc000066 	stclt	0, cr0, [r0], {102}	; 0x66
    9a28:	04000066 	streq	r0, [r0], #-102	; 0x66
    9a2c:	5201f300 	andpl	pc, r1, #0, 6
    9a30:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    9a34:	00000000 	andeq	r0, r0, r0
    9a38:	00669c00 	rsbeq	r9, r6, r0, lsl #24
    9a3c:	00669e00 	rsbeq	r9, r6, r0, lsl #28
    9a40:	52000100 	andpl	r0, r0, #0, 2
    9a44:	0000669e 	muleq	r0, lr, r6
    9a48:	000066b6 			; <UNDEFINED> instruction: 0x000066b6
    9a4c:	01f3000f 	mvnseq	r0, pc
    9a50:	ffff0a52 			; <UNDEFINED> instruction: 0xffff0a52
    9a54:	3101231a 	tstcc	r1, sl, lsl r3
    9a58:	1c007326 	stcne	3, cr7, [r0], {38}	; 0x26
    9a5c:	0066b69f 	mlseq	r6, pc, r6, fp	; <UNPREDICTABLE>
    9a60:	0066b800 	rsbeq	fp, r6, r0, lsl #16
    9a64:	f3001000 	vhadd.u8	d1, d0, d0
    9a68:	ff0a5201 			; <UNDEFINED> instruction: 0xff0a5201
    9a6c:	01231aff 	strdeq	r1, [r3, -pc]!
    9a70:	00732631 	rsbseq	r2, r3, r1, lsr r6
    9a74:	b89f2220 	ldmlt	pc, {r5, r9, sp}	; <UNPREDICTABLE>
    9a78:	bc000066 	stclt	0, cr0, [r0], {102}	; 0x66
    9a7c:	0f000066 	svceq	0x00000066
    9a80:	5201f300 	andpl	pc, r1, #0, 6
    9a84:	1affff0a 	bne	96b4 <_etext+0x219c>
    9a88:	26310123 	ldrtcs	r0, [r1], -r3, lsr #2
    9a8c:	9f1c0073 	svcls	0x001c0073
	...
    9a98:	000066a6 	andeq	r6, r0, r6, lsr #13
    9a9c:	000066ae 	andeq	r6, r0, lr, lsr #13
    9aa0:	7e700008 	cdpvc	0, 7, cr0, cr0, cr8, {0}
    9aa4:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    9aa8:	66ae9f1a 	ssatvs	r9, #15, sl, lsl #30
    9aac:	66b20000 	ldrtvs	r0, [r2], r0
    9ab0:	00010000 	andeq	r0, r1, r0
    9ab4:	0066b254 	rsbeq	fp, r6, r4, asr r2
    9ab8:	0066b600 	rsbeq	fp, r6, r0, lsl #12
    9abc:	70000800 	andvc	r0, r0, r0, lsl #16
    9ac0:	0801947e 	stmdaeq	r1, {r1, r2, r3, r4, r5, r6, sl, ip, pc}
    9ac4:	009f1aff 			; <UNDEFINED> instruction: 0x009f1aff
    9ac8:	00000000 	andeq	r0, r0, r0
    9acc:	a6000000 	strge	r0, [r0], -r0
    9ad0:	b6000066 	strlt	r0, [r0], -r6, rrx
    9ad4:	12000066 	andne	r0, r0, #102	; 0x66
    9ad8:	947f7000 	ldrbtls	r7, [pc], #-0	; 9ae0 <_etext+0x25c8>
    9adc:	1aff0801 	bne	fffcbae8 <BootRAM+0xef3c289>
    9ae0:	7e702438 	mrcvc	4, 3, r2, cr0, cr8, {1}
    9ae4:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    9ae8:	009f211a 	addseq	r2, pc, sl, lsl r1	; <UNPREDICTABLE>
    9aec:	00000000 	andeq	r0, r0, r0
    9af0:	9c000000 	stcls	0, cr0, [r0], {-0}
    9af4:	9e000066 	cdpls	0, 0, cr0, cr0, cr6, {3}
    9af8:	01000066 	tsteq	r0, r6, rrx
    9afc:	66b65100 	ldrtvs	r5, [r6], r0, lsl #2
    9b00:	66b80000 	ldrtvs	r0, [r8], r0
    9b04:	000a0000 	andeq	r0, sl, r0
    9b08:	24320073 	ldrtcs	r0, [r2], #-115	; 0x73
    9b0c:	23220071 	teqcs	r2, #113	; 0x71
    9b10:	66b89f04 	ldrtvs	r9, [r8], r4, lsl #30
    9b14:	66ba0000 	ldrtvs	r0, [sl], r0
    9b18:	000a0000 	andeq	r0, sl, r0
    9b1c:	24327f73 	ldrtcs	r7, [r2], #-3955	; 0xf73
    9b20:	23220071 	teqcs	r2, #113	; 0x71
    9b24:	00009f04 	andeq	r9, r0, r4, lsl #30
    9b28:	00000000 	andeq	r0, r0, r0
    9b2c:	66bc0000 	ldrtvs	r0, [ip], r0
    9b30:	66ce0000 	strbvs	r0, [lr], r0
    9b34:	00010000 	andeq	r0, r1, r0
    9b38:	0066da50 	rsbeq	sp, r6, r0, asr sl
    9b3c:	0066dc00 	rsbeq	sp, r6, r0, lsl #24
    9b40:	73000a00 	movwvc	r0, #2560	; 0xa00
    9b44:	70243100 	eorvc	r3, r4, r0, lsl #2
    9b48:	02232200 	eoreq	r2, r3, #0, 4
    9b4c:	0066dc9f 	mlseq	r6, pc, ip, sp	; <UNPREDICTABLE>
    9b50:	0066de00 	rsbeq	sp, r6, r0, lsl #28
    9b54:	73000a00 	movwvc	r0, #2560	; 0xa00
    9b58:	7024317f 	eorvc	r3, r4, pc, ror r1
    9b5c:	02232200 	eoreq	r2, r3, #0, 4
    9b60:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    9b64:	00000000 	andeq	r0, r0, r0
    9b68:	0066bc00 	rsbeq	fp, r6, r0, lsl #24
    9b6c:	0066c200 	rsbeq	ip, r6, r0, lsl #4
    9b70:	51000100 	mrspl	r0, (UNDEF: 16)
    9b74:	000066c2 	andeq	r6, r0, r2, asr #13
    9b78:	000066e0 	andeq	r6, r0, r0, ror #13
    9b7c:	01f30004 	mvnseq	r0, r4
    9b80:	00009f51 	andeq	r9, r0, r1, asr pc
    9b84:	00000000 	andeq	r0, r0, r0
    9b88:	66bc0000 	ldrtvs	r0, [ip], r0
    9b8c:	66c40000 	strbvs	r0, [r4], r0
    9b90:	00010000 	andeq	r0, r1, r0
    9b94:	0066c452 	rsbeq	ip, r6, r2, asr r4
    9b98:	0066e000 	rsbeq	lr, r6, r0
    9b9c:	f3000400 	vshl.u8	d0, d0, d0
    9ba0:	009f5201 	addseq	r5, pc, r1, lsl #4
    9ba4:	00000000 	andeq	r0, r0, r0
    9ba8:	cc000000 	stcgt	0, cr0, [r0], {-0}
    9bac:	ce000066 	cdpgt	0, 0, cr0, cr0, cr6, {3}
    9bb0:	01000066 	tsteq	r0, r6, rrx
    9bb4:	66ce5200 	strbvs	r5, [lr], r0, lsl #4
    9bb8:	66da0000 	ldrbvs	r0, [sl], r0
    9bbc:	000f0000 	andeq	r0, pc, r0
    9bc0:	0a5201f3 	beq	148a394 <_etext+0x1482e7c>
    9bc4:	231affff 	tstcs	sl, #1020	; 0x3fc
    9bc8:	73263101 	teqvc	r6, #1073741824	; 0x40000000
    9bcc:	da9f1c00 	ble	fe7d0bd4 <BootRAM+0xd741375>
    9bd0:	dc000066 	stcle	0, cr0, [r0], {102}	; 0x66
    9bd4:	10000066 	andne	r0, r0, r6, rrx
    9bd8:	5201f300 	andpl	pc, r1, #0, 6
    9bdc:	1affff0a 	bne	980c <_etext+0x22f4>
    9be0:	26310123 	ldrtcs	r0, [r1], -r3, lsr #2
    9be4:	22200073 	eorcs	r0, r0, #115	; 0x73
    9be8:	0066dc9f 	mlseq	r6, pc, ip, sp	; <UNPREDICTABLE>
    9bec:	0066e000 	rsbeq	lr, r6, r0
    9bf0:	f3000f00 	vpmax.f32	d0, d0, d0
    9bf4:	ff0a5201 			; <UNDEFINED> instruction: 0xff0a5201
    9bf8:	01231aff 	strdeq	r1, [r3, -pc]!
    9bfc:	00732631 	rsbseq	r2, r3, r1, lsr r6
    9c00:	00009f1c 	andeq	r9, r0, ip, lsl pc
    9c04:	00000000 	andeq	r0, r0, r0
    9c08:	66cc0000 	strbvs	r0, [ip], r0
    9c0c:	66ce0000 	strbvs	r0, [lr], r0
    9c10:	00010000 	andeq	r0, r1, r0
    9c14:	0066d251 	rsbeq	sp, r6, r1, asr r2
    9c18:	0066dc00 	rsbeq	sp, r6, r0, lsl #24
    9c1c:	73000a00 	movwvc	r0, #2560	; 0xa00
    9c20:	71243200 	teqvc	r4, r0, lsl #4
    9c24:	04232200 	strteq	r2, [r3], #-512	; 0x200
    9c28:	0066dc9f 	mlseq	r6, pc, ip, sp	; <UNPREDICTABLE>
    9c2c:	0066de00 	rsbeq	sp, r6, r0, lsl #28
    9c30:	73000a00 	movwvc	r0, #2560	; 0xa00
    9c34:	7124327f 	teqvc	r4, pc, ror r2
    9c38:	04232200 	strteq	r2, [r3], #-512	; 0x200
    9c3c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    9c40:	00000000 	andeq	r0, r0, r0
	...

Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void NOP_Process(void)
{
   0:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
   4:	00000000 	andeq	r0, r0, r0
   8:	00000b4c 	andeq	r0, r0, ip, asr #22
   c:	00000b94 	muleq	r0, r4, fp
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
  10:	00000b94 	muleq	r0, r4, fp
  14:	00000b98 	muleq	r0, r8, fp
	...
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
  20:	00000b98 	muleq	r0, r8, fp
  24:	00000b9a 	muleq	r0, sl, fp
  28:	00000b9a 	muleq	r0, sl, fp
    if ((wEPVal & EP_CTR_RX) != 0)
  2c:	00000b9c 	muleq	r0, ip, fp
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
  30:	00000b9c 	muleq	r0, ip, fp
  34:	00000b9e 	muleq	r0, lr, fp
  38:	00000b9e 	muleq	r0, lr, fp

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
  3c:	00000ba8 	andeq	r0, r0, r8, lsr #23

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
  40:	00000ba8 	andeq	r0, r0, r8, lsr #23
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
  44:	00000baa 	andeq	r0, r0, sl, lsr #23
  48:	00000bac 	andeq	r0, r0, ip, lsr #23
  4c:	00000bc4 	andeq	r0, r0, r4, asr #23

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
  50:	00000bc4 	andeq	r0, r0, r4, asr #23
  54:	00000bc6 	andeq	r0, r0, r6, asr #23
  58:	00000bc6 	andeq	r0, r0, r6, asr #23
  5c:	00000bc8 	andeq	r0, r0, r8, asr #23
  60:	00000bc8 	andeq	r0, r0, r8, asr #23
  64:	00000bca 	andeq	r0, r0, sl, asr #23
  68:	00000bca 	andeq	r0, r0, sl, asr #23
  6c:	00000bcc 	andeq	r0, r0, ip, asr #23
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPDblBuffCount(u8 bEpNum, u8 bDir, u16 wCount)
{
  _SetEPDblBuffCount(bEpNum, bDir, wCount);
  70:	00000bcc 	andeq	r0, r0, ip, asr #23
  74:	00000bce 	andeq	r0, r0, lr, asr #23
  78:	00000bce 	andeq	r0, r0, lr, asr #23
  7c:	00000bd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
  80:	00000bd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
  84:	00000bdc 	ldrdeq	r0, [r0], -ip
  88:	00000bdc 	ldrdeq	r0, [r0], -ip
  8c:	00000c84 	andeq	r0, r0, r4, lsl #25
  90:	00000c84 	andeq	r0, r0, r4, lsl #25
  94:	00000ce4 	andeq	r0, r0, r4, ror #25
  98:	00000ce4 	andeq	r0, r0, r4, ror #25
  9c:	00000cf0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
  a0:	00000cf0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
  a4:	00000cfc 	strdeq	r0, [r0], -ip
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
  a8:	00000cfc 	strdeq	r0, [r0], -ip

	return f25519_eq(a, c);
  ac:	00000d1c 	andeq	r0, r0, ip, lsl sp
  b0:	00000d1c 	andeq	r0, r0, ip, lsl sp
  b4:	00000d28 	andeq	r0, r0, r8, lsr #26
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
  b8:	00000d28 	andeq	r0, r0, r8, lsr #26
	f25519_normalize(ey);
  bc:	00000d50 	andeq	r0, r0, r0, asr sp
  c0:	00000d50 	andeq	r0, r0, r0, asr sp

	return ok;
}
  c4:	00000db8 			; <UNDEFINED> instruction: 0x00000db8
  c8:	00000001 	andeq	r0, r0, r1
  cc:	00000001 	andeq	r0, r0, r1
  d0:	00000db8 			; <UNDEFINED> instruction: 0x00000db8
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
  d4:	00000dd4 	ldrdeq	r0, [r0], -r4
  d8:	00000dd4 	ldrdeq	r0, [r0], -r4
		minusp[i] = c;
  dc:	00000dec 	andeq	r0, r0, ip, ror #27
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
  e0:	00000dec 	andeq	r0, r0, ip, ror #27
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
  e4:	00000e70 	andeq	r0, r0, r0, ror lr

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
  e8:	00000e70 	andeq	r0, r0, r0, ror lr
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
  ec:	00000eb8 			; <UNDEFINED> instruction: 0x00000eb8
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
  f0:	00000eb8 			; <UNDEFINED> instruction: 0x00000eb8
  f4:	00000ef4 	strdeq	r0, [r0], -r4
  f8:	00000ef4 	strdeq	r0, [r0], -r4
  fc:	00000ef8 	strdeq	r0, [r0], -r8
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
 100:	00000ef8 	strdeq	r0, [r0], -r8

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
 104:	00000f1c 	andeq	r0, r0, ip, lsl pc
 108:	00000f1c 	andeq	r0, r0, ip, lsl pc
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
 10c:	00000f5c 	andeq	r0, r0, ip, asr pc
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
 110:	00000f5c 	andeq	r0, r0, ip, asr pc
 114:	00000f7e 	andeq	r0, r0, lr, ror pc
 118:	00000f80 	andeq	r0, r0, r0, lsl #31
 11c:	00001034 	andeq	r1, r0, r4, lsr r0
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
 120:	00000001 	andeq	r0, r0, r1
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
 124:	00000001 	andeq	r0, r0, r1
	...

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
 130:	00001034 	andeq	r1, r0, r4, lsr r0
	i <<= 3;

	while (x) {
 134:	00001036 	andeq	r1, r0, r6, lsr r0
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
 138:	00001038 	andeq	r1, r0, r8, lsr r0
 13c:	00001124 	andeq	r1, r0, r4, lsr #2
	...

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
	f25519_mul_c(z3, x1sq, 4);
 148:	00001124 	andeq	r1, r0, r4, lsr #2
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
 14c:	0000113a 	andeq	r1, r0, sl, lsr r1
 150:	0000113a 	andeq	r1, r0, sl, lsr r1
 154:	0000114c 	andeq	r1, r0, ip, asr #2
	f25519_sub(b, x3, z3); /* D */
 158:	0000114c 	andeq	r1, r0, ip, asr #2
 15c:	0000119c 	muleq	r0, ip, r1
	f25519_mul__distinct(da, a, b);
 160:	0000119c 	muleq	r0, ip, r1
 164:	000011a6 	andeq	r1, r0, r6, lsr #3
 168:	000011a6 	andeq	r1, r0, r6, lsr #3

	f25519_sub(b, x2, z2);
 16c:	000011bc 			; <UNDEFINED> instruction: 0x000011bc
 170:	000011bc 			; <UNDEFINED> instruction: 0x000011bc
	f25519_add(a, x3, z3); /* C */
 174:	000011e4 	andeq	r1, r0, r4, ror #3
 178:	000011e4 	andeq	r1, r0, r4, ror #3
 17c:	000011fe 	strdeq	r1, [r0], -lr
	f25519_mul__distinct(cb, a, b);
 180:	000011fe 	strdeq	r1, [r0], -lr
 184:	0000122c 	andeq	r1, r0, ip, lsr #4

	f25519_add(a, da, cb);
 188:	0000122c 	andeq	r1, r0, ip, lsr #4
 18c:	000012b4 			; <UNDEFINED> instruction: 0x000012b4
 190:	000012b4 			; <UNDEFINED> instruction: 0x000012b4
	f25519_mul__distinct(b, a, a);
 194:	000012fc 	strdeq	r1, [r0], -ip
 198:	000012fc 	strdeq	r1, [r0], -ip
	f25519_mul__distinct(x5, z1, b);
 19c:	0000135c 	andeq	r1, r0, ip, asr r3
 1a0:	0000135c 	andeq	r1, r0, ip, asr r3
 1a4:	00001370 	andeq	r1, r0, r0, ror r3

	f25519_sub(a, da, cb);
 1a8:	00001370 	andeq	r1, r0, r0, ror r3
 1ac:	0000138c 	andeq	r1, r0, ip, lsl #7
	f25519_mul__distinct(b, a, a);
 1b0:	00000001 	andeq	r0, r0, r1
 1b4:	00000001 	andeq	r0, r0, r1
 1b8:	00000001 	andeq	r0, r0, r1

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
 1bc:	00000001 	andeq	r0, r0, r1
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
 1c0:	0000138c 	andeq	r1, r0, ip, lsl #7
 1c4:	000013a4 	andeq	r1, r0, r4, lsr #7

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
 1c8:	00000001 	andeq	r0, r0, r1
 1cc:	00000001 	andeq	r0, r0, r1
 1d0:	00000001 	andeq	r0, r0, r1
 1d4:	00000001 	andeq	r0, r0, r1
		f25519_select(zm1, zm1, zm, bit);
 1d8:	000013a4 	andeq	r1, r0, r4, lsr #7
 1dc:	00001410 	andeq	r1, r0, r0, lsl r4
 1e0:	00001410 	andeq	r1, r0, r0, lsl r4
		f25519_select(xm, xm, xms, bit);
 1e4:	00001434 	andeq	r1, r0, r4, lsr r4
 1e8:	00001434 	andeq	r1, r0, r4, lsr r4
 1ec:	00001452 	andeq	r1, r0, r2, asr r4
		f25519_select(zm, zm, zms, bit);
 1f0:	00001454 	andeq	r1, r0, r4, asr r4
 1f4:	00001468 	andeq	r1, r0, r8, ror #8
 1f8:	00001468 	andeq	r1, r0, r8, ror #8
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
 1fc:	0000149c 	muleq	r0, ip, r4
 200:	00000001 	andeq	r0, r0, r1
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
 204:	00000001 	andeq	r0, r0, r1
 208:	0000149c 	muleq	r0, ip, r4
	f25519_mul__distinct(result, zm1, xm);
 20c:	000014e8 	andeq	r1, r0, r8, ror #9
 210:	000014e8 	andeq	r1, r0, r8, ror #9
	f25519_normalize(result);
 214:	000014f4 	strdeq	r1, [r0], -r4
 218:	000014f4 	strdeq	r1, [r0], -r4
}
 21c:	0000150c 	andeq	r1, r0, ip, lsl #10
 220:	0000150c 	andeq	r1, r0, ip, lsl #10
 224:	0000151e 	andeq	r1, r0, lr, lsl r5
 228:	00001520 	andeq	r1, r0, r0, lsr #10
 22c:	00001530 	andeq	r1, r0, r0, lsr r5
 230:	00001530 	andeq	r1, r0, r0, lsr r5
 234:	00001548 	andeq	r1, r0, r8, asr #10
	...
 240:	00001548 	andeq	r1, r0, r8, asr #10
 244:	000015d0 	ldrdeq	r1, [r0], -r0
 248:	000015d0 	ldrdeq	r1, [r0], -r0
 24c:	00001614 	andeq	r1, r0, r4, lsl r6
 250:	00000001 	andeq	r0, r0, r1
 254:	00000001 	andeq	r0, r0, r1
 258:	00001614 	andeq	r1, r0, r4, lsl r6
 25c:	0000162c 	andeq	r1, r0, ip, lsr #12
 260:	0000162c 	andeq	r1, r0, ip, lsr #12
 264:	00001644 	andeq	r1, r0, r4, asr #12
 268:	00001644 	andeq	r1, r0, r4, asr #12
 26c:	0000166c 	andeq	r1, r0, ip, ror #12
 270:	0000166c 	andeq	r1, r0, ip, ror #12
 274:	000016a0 	andeq	r1, r0, r0, lsr #13
 278:	000016a0 	andeq	r1, r0, r0, lsr #13
 27c:	000016fc 	strdeq	r1, [r0], -ip
 280:	000016fc 	strdeq	r1, [r0], -ip
 284:	00001950 	andeq	r1, r0, r0, asr r9
 288:	00000001 	andeq	r0, r0, r1
 28c:	00000001 	andeq	r0, r0, r1
 290:	00000001 	andeq	r0, r0, r1
 294:	00000001 	andeq	r0, r0, r1
 298:	00001950 	andeq	r1, r0, r0, asr r9
 29c:	0000195c 	andeq	r1, r0, ip, asr r9
 2a0:	00000001 	andeq	r0, r0, r1
 2a4:	00000001 	andeq	r0, r0, r1
 2a8:	0000195c 	andeq	r1, r0, ip, asr r9
 2ac:	0000195e 	andeq	r1, r0, lr, asr r9
	...
 2b8:	00000001 	andeq	r0, r0, r1
 2bc:	00000001 	andeq	r0, r0, r1
 2c0:	00000001 	andeq	r0, r0, r1
 2c4:	00000001 	andeq	r0, r0, r1
 2c8:	00000001 	andeq	r0, r0, r1
 2cc:	00000001 	andeq	r0, r0, r1
 2d0:	00000001 	andeq	r0, r0, r1
 2d4:	00000001 	andeq	r0, r0, r1
 2d8:	00000001 	andeq	r0, r0, r1
 2dc:	00000001 	andeq	r0, r0, r1
	...
 2e8:	00000001 	andeq	r0, r0, r1
 2ec:	00000001 	andeq	r0, r0, r1
 2f0:	00000001 	andeq	r0, r0, r1
 2f4:	00000001 	andeq	r0, r0, r1
	...
 300:	00000001 	andeq	r0, r0, r1
 304:	00000001 	andeq	r0, r0, r1
 308:	00000001 	andeq	r0, r0, r1
 30c:	00000001 	andeq	r0, r0, r1
 310:	00000001 	andeq	r0, r0, r1
 314:	00000001 	andeq	r0, r0, r1
	...
 320:	00000001 	andeq	r0, r0, r1
 324:	00000001 	andeq	r0, r0, r1
 328:	00000001 	andeq	r0, r0, r1
 32c:	00000001 	andeq	r0, r0, r1
	...
 338:	00000001 	andeq	r0, r0, r1
 33c:	00000001 	andeq	r0, r0, r1
	...
 348:	0000198c 	andeq	r1, r0, ip, lsl #19
 34c:	00001994 	muleq	r0, r4, r9
 350:	00001996 	muleq	r0, r6, r9
 354:	000019ac 	andeq	r1, r0, ip, lsr #19
 358:	000019ae 	andeq	r1, r0, lr, lsr #19
 35c:	000019b2 			; <UNDEFINED> instruction: 0x000019b2
 360:	000019b4 			; <UNDEFINED> instruction: 0x000019b4
 364:	000019ba 			; <UNDEFINED> instruction: 0x000019ba
	...
 370:	00001a70 	andeq	r1, r0, r0, ror sl
 374:	00001a7a 	andeq	r1, r0, sl, ror sl
 378:	00001a80 	andeq	r1, r0, r0, lsl #21
 37c:	00001a94 	muleq	r0, r4, sl
 380:	00001a9a 	muleq	r0, sl, sl
 384:	00001a9e 	muleq	r0, lr, sl
 388:	00001aa4 	andeq	r1, r0, r4, lsr #21
 38c:	00001aaa 	andeq	r1, r0, sl, lsr #21
	...
 398:	00001ce0 	andeq	r1, r0, r0, ror #25
 39c:	00001d28 	andeq	r1, r0, r8, lsr #26
 3a0:	00001d2a 	andeq	r1, r0, sl, lsr #26
 3a4:	00001d32 	andeq	r1, r0, r2, lsr sp
	...
 3b0:	00001960 	andeq	r1, r0, r0, ror #18
 3b4:	000019d0 	ldrdeq	r1, [r0], -r0
 3b8:	000019d0 	ldrdeq	r1, [r0], -r0
 3bc:	00001a0a 	andeq	r1, r0, sl, lsl #20
 3c0:	00001a0c 	andeq	r1, r0, ip, lsl #20
 3c4:	00001a6a 	andeq	r1, r0, sl, ror #20
 3c8:	00001a6c 	andeq	r1, r0, ip, ror #20
 3cc:	00001b34 	andeq	r1, r0, r4, lsr fp
 3d0:	00001b34 	andeq	r1, r0, r4, lsr fp
 3d4:	00001c14 	andeq	r1, r0, r4, lsl ip
 3d8:	00001c14 	andeq	r1, r0, r4, lsl ip
 3dc:	00001cc8 	andeq	r1, r0, r8, asr #25
 3e0:	00001cc8 	andeq	r1, r0, r8, asr #25
 3e4:	00001d4c 	andeq	r1, r0, ip, asr #26
	...
 3f0:	00000001 	andeq	r0, r0, r1
 3f4:	00000001 	andeq	r0, r0, r1
 3f8:	00000001 	andeq	r0, r0, r1
 3fc:	00000001 	andeq	r0, r0, r1
 400:	00000001 	andeq	r0, r0, r1
 404:	00000001 	andeq	r0, r0, r1
 408:	00000001 	andeq	r0, r0, r1
 40c:	00000001 	andeq	r0, r0, r1
 410:	00000001 	andeq	r0, r0, r1
 414:	00000001 	andeq	r0, r0, r1
	...
 420:	00000001 	andeq	r0, r0, r1
 424:	00000001 	andeq	r0, r0, r1
 428:	00000001 	andeq	r0, r0, r1
 42c:	00000001 	andeq	r0, r0, r1
 430:	00000001 	andeq	r0, r0, r1
 434:	00000001 	andeq	r0, r0, r1
	...
 440:	00000001 	andeq	r0, r0, r1
 444:	00000001 	andeq	r0, r0, r1
 448:	00000001 	andeq	r0, r0, r1
 44c:	00000001 	andeq	r0, r0, r1
 450:	00000001 	andeq	r0, r0, r1
 454:	00000001 	andeq	r0, r0, r1
	...
 460:	00000001 	andeq	r0, r0, r1
 464:	00000001 	andeq	r0, r0, r1
 468:	00000001 	andeq	r0, r0, r1
 46c:	00000001 	andeq	r0, r0, r1
 470:	00000001 	andeq	r0, r0, r1
 474:	00000001 	andeq	r0, r0, r1
	...
 480:	00001d56 	andeq	r1, r0, r6, asr sp
 484:	00001d5a 	andeq	r1, r0, sl, asr sp
 488:	00001d5e 	andeq	r1, r0, lr, asr sp
 48c:	00001e2e 	andeq	r1, r0, lr, lsr #28
 490:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
 494:	00001ec8 	andeq	r1, r0, r8, asr #29
	...
 4a0:	00001d7c 	andeq	r1, r0, ip, ror sp
 4a4:	00001d7e 	andeq	r1, r0, lr, ror sp
 4a8:	00001d8a 	andeq	r1, r0, sl, lsl #27
 4ac:	00001d8c 	andeq	r1, r0, ip, lsl #27
 4b0:	00001d90 	muleq	r0, r0, sp
 4b4:	00001e2e 	andeq	r1, r0, lr, lsr #28
 4b8:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
 4bc:	00001ec8 	andeq	r1, r0, r8, asr #29
	...
 4c8:	00001d7c 	andeq	r1, r0, ip, ror sp
 4cc:	00001d7e 	andeq	r1, r0, lr, ror sp
 4d0:	00001d8a 	andeq	r1, r0, sl, lsl #27
 4d4:	00001d8c 	andeq	r1, r0, ip, lsl #27
 4d8:	00001d90 	muleq	r0, r0, sp
 4dc:	00001da0 	andeq	r1, r0, r0, lsr #27
 4e0:	00001da4 	andeq	r1, r0, r4, lsr #27
 4e4:	00001da8 	andeq	r1, r0, r8, lsr #27
	...
 4f0:	00001daa 	andeq	r1, r0, sl, lsr #27
 4f4:	00001e00 	andeq	r1, r0, r0, lsl #28
 4f8:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
 4fc:	00001ec8 	andeq	r1, r0, r8, asr #29
	...
 508:	00000001 	andeq	r0, r0, r1
 50c:	00000001 	andeq	r0, r0, r1
 510:	00001d4c 	andeq	r1, r0, ip, asr #26
 514:	00001ec8 	andeq	r1, r0, r8, asr #29
	...
 520:	00001f28 	andeq	r1, r0, r8, lsr #30
 524:	00001f2a 	andeq	r1, r0, sl, lsr #30
 528:	00001f30 	andeq	r1, r0, r0, lsr pc
 52c:	00001f34 	andeq	r1, r0, r4, lsr pc
 530:	00001f38 	andeq	r1, r0, r8, lsr pc
 534:	00001f4e 	andeq	r1, r0, lr, asr #30
	...
 540:	00000001 	andeq	r0, r0, r1
 544:	00000001 	andeq	r0, r0, r1
 548:	00000001 	andeq	r0, r0, r1
 54c:	00000001 	andeq	r0, r0, r1
	...
 558:	00002220 	andeq	r2, r0, r0, lsr #4
 55c:	00002222 	andeq	r2, r0, r2, lsr #4
 560:	00002224 	andeq	r2, r0, r4, lsr #4
 564:	000022a8 	andeq	r2, r0, r8, lsr #5
	...
 570:	000022a8 	andeq	r2, r0, r8, lsr #5
 574:	0000231a 	andeq	r2, r0, sl, lsl r3
 578:	00002320 	andeq	r2, r0, r0, lsr #6
 57c:	00002326 	andeq	r2, r0, r6, lsr #6
	...
 588:	0000231a 	andeq	r2, r0, sl, lsl r3
 58c:	00002320 	andeq	r2, r0, r0, lsr #6
 590:	00002326 	andeq	r2, r0, r6, lsr #6
 594:	000023a8 	andeq	r2, r0, r8, lsr #7
	...
 5a0:	0000231a 	andeq	r2, r0, sl, lsl r3
 5a4:	00002320 	andeq	r2, r0, r0, lsr #6
 5a8:	00002326 	andeq	r2, r0, r6, lsr #6
 5ac:	00002370 	andeq	r2, r0, r0, ror r3
	...
 5b8:	0000280c 	andeq	r2, r0, ip, lsl #16
 5bc:	0000280e 	andeq	r2, r0, lr, lsl #16
 5c0:	00002814 	andeq	r2, r0, r4, lsl r8
 5c4:	0000285c 	andeq	r2, r0, ip, asr r8
	...
 5d0:	000028d6 	ldrdeq	r2, [r0], -r6
 5d4:	0000295a 	andeq	r2, r0, sl, asr r9
 5d8:	00002960 	andeq	r2, r0, r0, ror #18
 5dc:	00002966 	andeq	r2, r0, r6, ror #18
	...
 5e8:	0000295a 	andeq	r2, r0, sl, asr r9
 5ec:	00002960 	andeq	r2, r0, r0, ror #18
 5f0:	00002966 	andeq	r2, r0, r6, ror #18
 5f4:	000029ea 	andeq	r2, r0, sl, ror #19
	...
 600:	0000295a 	andeq	r2, r0, sl, asr r9
 604:	00002960 	andeq	r2, r0, r0, ror #18
 608:	00002966 	andeq	r2, r0, r6, ror #18
 60c:	000029b0 			; <UNDEFINED> instruction: 0x000029b0
	...
 618:	00002cf4 	strdeq	r2, [r0], -r4
 61c:	00002d3e 	andeq	r2, r0, lr, lsr sp
 620:	00002d42 	andeq	r2, r0, r2, asr #26
 624:	00002d48 	andeq	r2, r0, r8, asr #26
	...
 630:	00002d3e 	andeq	r2, r0, lr, lsr sp
 634:	00002d42 	andeq	r2, r0, r2, asr #26
 638:	00002d48 	andeq	r2, r0, r8, asr #26
 63c:	00002dc4 	andeq	r2, r0, r4, asr #27
	...
 648:	00002d3e 	andeq	r2, r0, lr, lsr sp
 64c:	00002d42 	andeq	r2, r0, r2, asr #26
 650:	00002d48 	andeq	r2, r0, r8, asr #26
 654:	00002d8e 	andeq	r2, r0, lr, lsl #27
	...
 660:	00001ec8 	andeq	r1, r0, r8, asr #29
 664:	00001ee6 	andeq	r1, r0, r6, ror #29
 668:	00001ee8 	andeq	r1, r0, r8, ror #29
 66c:	00001f56 	andeq	r1, r0, r6, asr pc
 670:	00001f58 	andeq	r1, r0, r8, asr pc
 674:	00001ff2 	strdeq	r1, [r0], -r2
 678:	00001ff4 	strdeq	r1, [r0], -r4
 67c:	000020b6 	strheq	r2, [r0], -r6
 680:	000020b8 	strheq	r2, [r0], -r8
 684:	000020fe 	strdeq	r2, [r0], -lr
 688:	00002100 	andeq	r2, r0, r0, lsl #2
 68c:	0000214c 	andeq	r2, r0, ip, asr #2
 690:	0000214c 	andeq	r2, r0, ip, asr #2
 694:	00002192 	muleq	r0, r2, r1
 698:	00002194 	muleq	r0, r4, r1
 69c:	0000221c 	andeq	r2, r0, ip, lsl r2
 6a0:	00000001 	andeq	r0, r0, r1
 6a4:	00000001 	andeq	r0, r0, r1
 6a8:	00000001 	andeq	r0, r0, r1
 6ac:	00000001 	andeq	r0, r0, r1
 6b0:	0000221c 	andeq	r2, r0, ip, lsl r2
 6b4:	00002806 	andeq	r2, r0, r6, lsl #16
 6b8:	00000001 	andeq	r0, r0, r1
 6bc:	00000001 	andeq	r0, r0, r1
 6c0:	00002808 	andeq	r2, r0, r8, lsl #16
 6c4:	00002e3c 	andeq	r2, r0, ip, lsr lr
	...
 6d0:	00002e4a 	andeq	r2, r0, sl, asr #28
 6d4:	00002e68 	andeq	r2, r0, r8, ror #28
 6d8:	00002fbc 			; <UNDEFINED> instruction: 0x00002fbc
 6dc:	00002fc8 	andeq	r2, r0, r8, asr #31
 6e0:	00002fd6 	ldrdeq	r2, [r0], -r6
 6e4:	00002fdc 	ldrdeq	r2, [r0], -ip
	...
 6f0:	00002f5a 	andeq	r2, r0, sl, asr pc
 6f4:	00002f5c 	andeq	r2, r0, ip, asr pc
 6f8:	00002f60 	andeq	r2, r0, r0, ror #30
 6fc:	00002f74 	andeq	r2, r0, r4, ror pc
	...
 708:	00002f76 	andeq	r2, r0, r6, ror pc
 70c:	00002f78 	andeq	r2, r0, r8, ror pc
 710:	00002f7c 	andeq	r2, r0, ip, ror pc
 714:	00002fb0 			; <UNDEFINED> instruction: 0x00002fb0
	...
 720:	00000001 	andeq	r0, r0, r1
 724:	00000001 	andeq	r0, r0, r1
 728:	00000001 	andeq	r0, r0, r1
 72c:	00000001 	andeq	r0, r0, r1
	...
 738:	00000001 	andeq	r0, r0, r1
 73c:	00000001 	andeq	r0, r0, r1
 740:	00000001 	andeq	r0, r0, r1
 744:	00000001 	andeq	r0, r0, r1
	...
 750:	00000001 	andeq	r0, r0, r1
 754:	00000001 	andeq	r0, r0, r1
 758:	00000001 	andeq	r0, r0, r1
 75c:	00000001 	andeq	r0, r0, r1
	...
 768:	00000001 	andeq	r0, r0, r1
 76c:	00000001 	andeq	r0, r0, r1
 770:	00000001 	andeq	r0, r0, r1
 774:	00000001 	andeq	r0, r0, r1
	...
 780:	00000001 	andeq	r0, r0, r1
 784:	00000001 	andeq	r0, r0, r1
 788:	00000001 	andeq	r0, r0, r1
 78c:	00000001 	andeq	r0, r0, r1
	...
 798:	00000001 	andeq	r0, r0, r1
 79c:	00000001 	andeq	r0, r0, r1
 7a0:	00000001 	andeq	r0, r0, r1
 7a4:	00000001 	andeq	r0, r0, r1
	...
 7b0:	00000001 	andeq	r0, r0, r1
 7b4:	00000001 	andeq	r0, r0, r1
 7b8:	00000001 	andeq	r0, r0, r1
 7bc:	00000001 	andeq	r0, r0, r1
	...
 7c8:	00000001 	andeq	r0, r0, r1
 7cc:	00000001 	andeq	r0, r0, r1
 7d0:	00000001 	andeq	r0, r0, r1
 7d4:	00000001 	andeq	r0, r0, r1
 7d8:	00000001 	andeq	r0, r0, r1
 7dc:	00000001 	andeq	r0, r0, r1
	...
 7e8:	00000001 	andeq	r0, r0, r1
 7ec:	00000001 	andeq	r0, r0, r1
 7f0:	00000001 	andeq	r0, r0, r1
 7f4:	00000001 	andeq	r0, r0, r1
	...
 800:	00000001 	andeq	r0, r0, r1
 804:	00000001 	andeq	r0, r0, r1
 808:	00000001 	andeq	r0, r0, r1
 80c:	00000001 	andeq	r0, r0, r1
 810:	00000001 	andeq	r0, r0, r1
 814:	00000001 	andeq	r0, r0, r1
	...
 820:	00000001 	andeq	r0, r0, r1
 824:	00000001 	andeq	r0, r0, r1
 828:	00000001 	andeq	r0, r0, r1
 82c:	00000001 	andeq	r0, r0, r1
	...
 838:	00000001 	andeq	r0, r0, r1
 83c:	00000001 	andeq	r0, r0, r1
 840:	00002e3c 	andeq	r2, r0, ip, lsr lr
 844:	00002fdc 	ldrdeq	r2, [r0], -ip
 848:	00000001 	andeq	r0, r0, r1
 84c:	00000001 	andeq	r0, r0, r1
 850:	00000001 	andeq	r0, r0, r1
 854:	00000001 	andeq	r0, r0, r1
 858:	00000001 	andeq	r0, r0, r1
 85c:	00000001 	andeq	r0, r0, r1
 860:	00000001 	andeq	r0, r0, r1
 864:	00000001 	andeq	r0, r0, r1
 868:	00000001 	andeq	r0, r0, r1
 86c:	00000001 	andeq	r0, r0, r1
 870:	00000001 	andeq	r0, r0, r1
 874:	00000001 	andeq	r0, r0, r1
 878:	00000001 	andeq	r0, r0, r1
 87c:	00000001 	andeq	r0, r0, r1
	...
 888:	00000001 	andeq	r0, r0, r1
 88c:	00000001 	andeq	r0, r0, r1
 890:	00000001 	andeq	r0, r0, r1
 894:	00000001 	andeq	r0, r0, r1
 898:	00000001 	andeq	r0, r0, r1
 89c:	00000001 	andeq	r0, r0, r1
	...
 8a8:	00000001 	andeq	r0, r0, r1
 8ac:	00000001 	andeq	r0, r0, r1
 8b0:	00000001 	andeq	r0, r0, r1
 8b4:	00000001 	andeq	r0, r0, r1
	...
 8c0:	00004fa4 	andeq	r4, r0, r4, lsr #31
 8c4:	00004ffc 	strdeq	r4, [r0], -ip
 8c8:	00005000 	andeq	r5, r0, r0
 8cc:	00005026 	andeq	r5, r0, r6, lsr #32
	...
 8d8:	00005050 	andeq	r5, r0, r0, asr r0
 8dc:	00005052 	andeq	r5, r0, r2, asr r0
 8e0:	00005056 	andeq	r5, r0, r6, asr r0
 8e4:	00005058 	andeq	r5, r0, r8, asr r0
 8e8:	0000506c 	andeq	r5, r0, ip, rrx
 8ec:	00005070 	andeq	r5, r0, r0, ror r0
 8f0:	0000508e 	andeq	r5, r0, lr, lsl #1
 8f4:	000050b6 	strheq	r5, [r0], -r6
 8f8:	0000518a 	andeq	r5, r0, sl, lsl #3
 8fc:	000051e2 	andeq	r5, r0, r2, ror #3
 900:	00005228 	andeq	r5, r0, r8, lsr #4
 904:	0000522e 	andeq	r5, r0, lr, lsr #4
	...
 910:	000050b6 	strheq	r5, [r0], -r6
 914:	000050f0 	strdeq	r5, [r0], -r0
 918:	000051e2 	andeq	r5, r0, r2, ror #3
 91c:	00005228 	andeq	r5, r0, r8, lsr #4
 920:	0000522e 	andeq	r5, r0, lr, lsr #4
 924:	00005240 	andeq	r5, r0, r0, asr #4
	...
 930:	00002fdc 	ldrdeq	r2, [r0], -ip
 934:	00003034 	andeq	r3, r0, r4, lsr r0
 938:	00003034 	andeq	r3, r0, r4, lsr r0
 93c:	00004f98 	muleq	r0, r8, pc	; <UNPREDICTABLE>
 940:	00004f98 	muleq	r0, r8, pc	; <UNPREDICTABLE>
 944:	00005026 	andeq	r5, r0, r6, lsr #32
 948:	00005028 	andeq	r5, r0, r8, lsr #32
 94c:	00005240 	andeq	r5, r0, r0, asr #4
	...
 958:	00005250 	andeq	r5, r0, r0, asr r2
 95c:	000052f4 	strdeq	r5, [r0], -r4
 960:	000052f6 	strdeq	r5, [r0], -r6
 964:	000052fa 	strdeq	r5, [r0], -sl
	...
 970:	000053d4 	ldrdeq	r5, [r0], -r4
 974:	000053de 	ldrdeq	r5, [r0], -lr
 978:	000053e8 	andeq	r5, r0, r8, ror #7
 97c:	000053ec 	andeq	r5, r0, ip, ror #7
 980:	000053f0 	strdeq	r5, [r0], -r0
 984:	000053f4 	strdeq	r5, [r0], -r4
 988:	000053f8 	strdeq	r5, [r0], -r8
 98c:	000053fa 	strdeq	r5, [r0], -sl
	...
 998:	000053de 	ldrdeq	r5, [r0], -lr
 99c:	000053e8 	andeq	r5, r0, r8, ror #7
 9a0:	000053fa 	strdeq	r5, [r0], -sl
 9a4:	000053fe 	strdeq	r5, [r0], -lr
 9a8:	00005402 	andeq	r5, r0, r2, lsl #8
 9ac:	00005406 	andeq	r5, r0, r6, lsl #8
 9b0:	0000540a 	andeq	r5, r0, sl, lsl #8
 9b4:	0000540c 	andeq	r5, r0, ip, lsl #8
	...
 9c0:	00005410 	andeq	r5, r0, r0, lsl r4
 9c4:	00005414 	andeq	r5, r0, r4, lsl r4
 9c8:	0000541e 	andeq	r5, r0, lr, lsl r4
 9cc:	00005426 	andeq	r5, r0, r6, lsr #8
 9d0:	0000542a 	andeq	r5, r0, sl, lsr #8
 9d4:	0000542c 	andeq	r5, r0, ip, lsr #8
 9d8:	00005434 	andeq	r5, r0, r4, lsr r4
 9dc:	00005438 	andeq	r5, r0, r8, lsr r4
 9e0:	00005442 	andeq	r5, r0, r2, asr #8
 9e4:	00005446 	andeq	r5, r0, r6, asr #8
 9e8:	0000544e 	andeq	r5, r0, lr, asr #8
 9ec:	00005450 	andeq	r5, r0, r0, asr r4
	...
 9f8:	00005414 	andeq	r5, r0, r4, lsl r4
 9fc:	00005416 	andeq	r5, r0, r6, lsl r4
 a00:	0000541a 	andeq	r5, r0, sl, lsl r4
 a04:	0000541e 	andeq	r5, r0, lr, lsl r4
 a08:	00005428 	andeq	r5, r0, r8, lsr #8
 a0c:	0000542a 	andeq	r5, r0, sl, lsr #8
 a10:	0000543c 	andeq	r5, r0, ip, lsr r4
 a14:	0000543e 	andeq	r5, r0, lr, lsr r4
 a18:	00005448 	andeq	r5, r0, r8, asr #8
 a1c:	0000544c 	andeq	r5, r0, ip, asr #8
 a20:	0000545c 	andeq	r5, r0, ip, asr r4
 a24:	0000545e 	andeq	r5, r0, lr, asr r4
	...
 a30:	0000542c 	andeq	r5, r0, ip, lsr #8
 a34:	0000542e 	andeq	r5, r0, lr, lsr #8
 a38:	00005438 	andeq	r5, r0, r8, lsr r4
 a3c:	0000543c 	andeq	r5, r0, ip, lsr r4
 a40:	0000544c 	andeq	r5, r0, ip, asr #8
 a44:	0000544e 	andeq	r5, r0, lr, asr #8
 a48:	00005450 	andeq	r5, r0, r0, asr r4
 a4c:	00005452 	andeq	r5, r0, r2, asr r4
 a50:	0000545e 	andeq	r5, r0, lr, asr r4
 a54:	00005464 	andeq	r5, r0, r4, ror #8
	...
 a60:	00005478 	andeq	r5, r0, r8, ror r4
 a64:	00005480 	andeq	r5, r0, r0, lsl #9
 a68:	000054e4 	andeq	r5, r0, r4, ror #9
 a6c:	000054ec 	andeq	r5, r0, ip, ror #9
	...
 a78:	00005480 	andeq	r5, r0, r0, lsl #9
 a7c:	0000548a 	andeq	r5, r0, sl, lsl #9
 a80:	0000553e 	andeq	r5, r0, lr, lsr r5
 a84:	00005542 	andeq	r5, r0, r2, asr #10
 a88:	00005546 	andeq	r5, r0, r6, asr #10
 a8c:	0000554a 	andeq	r5, r0, sl, asr #10
 a90:	00005550 	andeq	r5, r0, r0, asr r5
 a94:	00005552 	andeq	r5, r0, r2, asr r5
	...
 aa0:	0000548a 	andeq	r5, r0, sl, lsl #9
 aa4:	00005494 	muleq	r0, r4, r4
 aa8:	00005564 	andeq	r5, r0, r4, ror #10
 aac:	00005568 	andeq	r5, r0, r8, ror #10
 ab0:	0000556c 	andeq	r5, r0, ip, ror #10
 ab4:	00005570 	andeq	r5, r0, r0, ror r5
 ab8:	00005582 	andeq	r5, r0, r2, lsl #11
 abc:	00005584 	andeq	r5, r0, r4, lsl #11
	...
 ac8:	000054ec 	andeq	r5, r0, ip, ror #9
 acc:	000054f4 	strdeq	r5, [r0], -r4
 ad0:	000054f6 	strdeq	r5, [r0], -r6
 ad4:	000054fa 	strdeq	r5, [r0], -sl
 ad8:	000054fe 	strdeq	r5, [r0], -lr
 adc:	00005502 	andeq	r5, r0, r2, lsl #10
	...
 ae8:	00005556 	andeq	r5, r0, r6, asr r5
 aec:	0000555a 	andeq	r5, r0, sl, asr r5
 af0:	00005560 	andeq	r5, r0, r0, ror #10
 af4:	00005564 	andeq	r5, r0, r4, ror #10
 af8:	00005570 	andeq	r5, r0, r0, ror r5
 afc:	00005572 	andeq	r5, r0, r2, ror r5
 b00:	0000557a 	andeq	r5, r0, sl, ror r5
 b04:	0000557e 	andeq	r5, r0, lr, ror r5
 b08:	00005584 	andeq	r5, r0, r4, lsl #11
 b0c:	00005588 	andeq	r5, r0, r8, lsl #11
 b10:	0000558a 	andeq	r5, r0, sl, lsl #11
 b14:	00005590 	muleq	r0, r0, r5
	...
 b20:	000056f8 	strdeq	r5, [r0], -r8
 b24:	00005702 	andeq	r5, r0, r2, lsl #14
 b28:	00005706 	andeq	r5, r0, r6, lsl #14
 b2c:	00005726 	andeq	r5, r0, r6, lsr #14
	...
 b38:	000057b6 			; <UNDEFINED> instruction: 0x000057b6
 b3c:	000057c8 	andeq	r5, r0, r8, asr #15
 b40:	000057ca 	andeq	r5, r0, sl, asr #15
 b44:	00005830 	andeq	r5, r0, r0, lsr r8
 b48:	00005832 	andeq	r5, r0, r2, lsr r8
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 b4c:	00005836 	andeq	r5, r0, r6, lsr r8
	...

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4
 b58:	00005872 	andeq	r5, r0, r2, ror r8

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
 b5c:	000058e2 	andeq	r5, r0, r2, ror #17
	adds	r2, r0, r1
	cmp	r2, r3
 b60:	000058e6 	andeq	r5, r0, r6, ror #17
	bcc	CopyDataInit
 b64:	00005908 	andeq	r5, r0, r8, lsl #18
	ldr	r2, =_sbss
	b	LoopFillZerobss
 b68:	0000590c 	andeq	r5, r0, ip, lsl #18
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 b6c:	0000590e 	andeq	r5, r0, lr, lsl #18
	str	r3, [r2], #4
 b70:	00005918 	andeq	r5, r0, r8, lsl r9

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
 b74:	0000591c 	andeq	r5, r0, ip, lsl r9
	bcc	FillZerobss
 b78:	00005930 	andeq	r5, r0, r0, lsr r9
/* Call the application's entry point.*/
	bl	main
 b7c:	00005934 	andeq	r5, r0, r4, lsr r9
	...
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
 b88:	0000595a 	andeq	r5, r0, sl, asr r9
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 b8c:	000059dc 	ldrdeq	r5, [r0], -ip
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 b90:	000059de 	ldrdeq	r5, [r0], -lr
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 b94:	000059e2 	andeq	r5, r0, r2, ror #19
}


/* dummy proc */
void nothingProc(void)
{
 b98:	000059e4 	andeq	r5, r0, r4, ror #19
{
    return;
}

void usbStatusOut(void)
{
 b9c:	000059e8 	andeq	r5, r0, r8, ror #19
	...
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
 ba8:	00005240 	andeq	r5, r0, r0, asr #4
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
 bac:	000056d4 	ldrdeq	r5, [r0], -r4
 bb0:	000056d4 	ldrdeq	r5, [r0], -r4
        bDeviceState = CONFIGURED;
 bb4:	0000575c 	andeq	r5, r0, ip, asr r7
 bb8:	0000575c 	andeq	r5, r0, ip, asr r7
 bbc:	000059f2 	strdeq	r5, [r0], -r2
	...
{
    /* nothing process */
}

void usbGetStatus(void)
{
 bc8:	000059f4 	strdeq	r5, [r0], -r4
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
 bcc:	00005a38 	andeq	r5, r0, r8, lsr sl
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
 bd0:	00005a38 	andeq	r5, r0, r8, lsr sl
 bd4:	00005bbc 			; <UNDEFINED> instruction: 0x00005bbc
	...
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
    dfuUpdateByReset();
 be0:	00000001 	andeq	r0, r0, r1

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 be4:	00000001 	andeq	r0, r0, r1

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
 be8:	00000001 	andeq	r0, r0, r1
 bec:	00000001 	andeq	r0, r0, r1
	...
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
 bf8:	00005cb6 			; <UNDEFINED> instruction: 0x00005cb6

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
 bfc:	00005cb8 			; <UNDEFINED> instruction: 0x00005cb8
 c00:	00005cc8 	andeq	r5, r0, r8, asr #25
 c04:	00005cf4 	strdeq	r5, [r0], -r4
	...
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
 c10:	00000001 	andeq	r0, r0, r1
 c14:	00000001 	andeq	r0, r0, r1
 c18:	00000001 	andeq	r0, r0, r1
 c1c:	00000001 	andeq	r0, r0, r1
	...

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
 c28:	00000001 	andeq	r0, r0, r1
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 c2c:	00000001 	andeq	r0, r0, r1
 c30:	00000001 	andeq	r0, r0, r1
 c34:	00000001 	andeq	r0, r0, r1
	...

    Clear_Status_Out(ENDP0);
 c40:	00000001 	andeq	r0, r0, r1

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 c44:	00000001 	andeq	r0, r0, r1
 c48:	00000001 	andeq	r0, r0, r1
 c4c:	00000001 	andeq	r0, r0, r1
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
 c50:	00000001 	andeq	r0, r0, r1
 c54:	00000001 	andeq	r0, r0, r1
	...

    bDeviceState = ATTACHED;
 c60:	00000001 	andeq	r0, r0, r1
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
 c64:	00000001 	andeq	r0, r0, r1
 c68:	00000001 	andeq	r0, r0, r1
 c6c:	00000001 	andeq	r0, r0, r1
	...
 c78:	00000001 	andeq	r0, r0, r1
 c7c:	00000001 	andeq	r0, r0, r1
 c80:	00000001 	andeq	r0, r0, r1
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
 c84:	00000001 	andeq	r0, r0, r1
	...
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
 c90:	00000001 	andeq	r0, r0, r1
 c94:	00000001 	andeq	r0, r0, r1
        if (dfuUpdateByRequest()) {
 c98:	00000001 	andeq	r0, r0, r1
 c9c:	00000001 	andeq	r0, r0, r1
            // successfull state transition, handle the request
            switch (request) {
 ca0:	00000001 	andeq	r0, r0, r1
 ca4:	00000001 	andeq	r0, r0, r1
 ca8:	00000001 	andeq	r0, r0, r1
 cac:	00000001 	andeq	r0, r0, r1
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
 cb0:	00000001 	andeq	r0, r0, r1
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
 cb4:	00000001 	andeq	r0, r0, r1
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
 cb8:	00000001 	andeq	r0, r0, r1
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
 cbc:	00000001 	andeq	r0, r0, r1
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
 cc0:	00000001 	andeq	r0, r0, r1
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
 cc4:	00000001 	andeq	r0, r0, r1
        (*CopyRoutine)(0);

        return USB_SUCCESS;
 cc8:	00000001 	andeq	r0, r0, r1
    }

    return USB_UNSUPPORT;
 ccc:	00000001 	andeq	r0, r0, r1
}
 cd0:	00000001 	andeq	r0, r0, r1
 cd4:	00000001 	andeq	r0, r0, r1
 cd8:	00000001 	andeq	r0, r0, r1
 cdc:	00000001 	andeq	r0, r0, r1
 ce0:	00000001 	andeq	r0, r0, r1
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
 ce4:	00000001 	andeq	r0, r0, r1
 ce8:	00000001 	andeq	r0, r0, r1
 cec:	00000001 	andeq	r0, r0, r1
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
 cf0:	00000001 	andeq	r0, r0, r1
 cf4:	00000001 	andeq	r0, r0, r1
 cf8:	00005bbc 			; <UNDEFINED> instruction: 0x00005bbc
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
 cfc:	00005be6 	andeq	r5, r0, r6, ror #23
 d00:	00000001 	andeq	r0, r0, r1
    if (strIndex > STR_DESC_LEN) {
 d04:	00000001 	andeq	r0, r0, r1
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
 d08:	00000001 	andeq	r0, r0, r1
 d0c:	00000001 	andeq	r0, r0, r1
    }
}
 d10:	00000001 	andeq	r0, r0, r1
 d14:	00000001 	andeq	r0, r0, r1
 d18:	00000001 	andeq	r0, r0, r1

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
 d1c:	00000001 	andeq	r0, r0, r1
 d20:	00000001 	andeq	r0, r0, r1
 d24:	00000001 	andeq	r0, r0, r1

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
 d28:	00005be6 	andeq	r5, r0, r6, ror #23
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
 d2c:	00005c04 	andeq	r5, r0, r4, lsl #24
 d30:	00000001 	andeq	r0, r0, r1
 d34:	00000001 	andeq	r0, r0, r1
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
 d38:	00000001 	andeq	r0, r0, r1
 d3c:	00000001 	andeq	r0, r0, r1
            return USB_SUCCESS;
 d40:	00005c04 	andeq	r5, r0, r4, lsl #24
 d44:	00005c20 	andeq	r5, r0, r0, lsr #24
        }
    }
    return USB_UNSUPPORT;
}
 d48:	00000001 	andeq	r0, r0, r1
 d4c:	00000001 	andeq	r0, r0, r1

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
 d50:	00000001 	andeq	r0, r0, r1
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 d54:	00000001 	andeq	r0, r0, r1
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 d58:	00000001 	andeq	r0, r0, r1
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 d5c:	00000001 	andeq	r0, r0, r1
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 d60:	00000001 	andeq	r0, r0, r1
 d64:	00000001 	andeq	r0, r0, r1
 d68:	00000001 	andeq	r0, r0, r1
 d6c:	00000001 	andeq	r0, r0, r1
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
 d70:	00000001 	andeq	r0, r0, r1
 d74:	00000001 	andeq	r0, r0, r1
 d78:	00000001 	andeq	r0, r0, r1
 d7c:	00000001 	andeq	r0, r0, r1
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
 d80:	00000001 	andeq	r0, r0, r1
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
 d84:	00000001 	andeq	r0, r0, r1
 d88:	00000001 	andeq	r0, r0, r1
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
 d8c:	00000001 	andeq	r0, r0, r1
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
 d90:	00005c20 	andeq	r5, r0, r0, lsr #24
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
 d94:	00005c40 	andeq	r5, r0, r0, asr #24
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
 d98:	00005c40 	andeq	r5, r0, r0, asr #24

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
 d9c:	00005c60 	andeq	r5, r0, r0, ror #24
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
 da0:	00000001 	andeq	r0, r0, r1
 da4:	00000001 	andeq	r0, r0, r1
 da8:	00000001 	andeq	r0, r0, r1
 dac:	00000001 	andeq	r0, r0, r1
 db0:	00000001 	andeq	r0, r0, r1
 db4:	00000001 	andeq	r0, r0, r1
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
 db8:	00000001 	andeq	r0, r0, r1
 dbc:	00000001 	andeq	r0, r0, r1
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
 dc0:	00005c60 	andeq	r5, r0, r0, ror #24

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
 dc4:	00005c7c 	andeq	r5, r0, ip, ror ip
 dc8:	00005c7c 	andeq	r5, r0, ip, ror ip
 dcc:	00005c98 	muleq	r0, r8, ip
 dd0:	00005c98 	muleq	r0, r8, ip
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
 dd4:	00005cb4 			; <UNDEFINED> instruction: 0x00005cb4
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
 dd8:	00000001 	andeq	r0, r0, r1
 ddc:	00000001 	andeq	r0, r0, r1

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
 de0:	00005cb4 			; <UNDEFINED> instruction: 0x00005cb4
 de4:	00005cf4 	strdeq	r5, [r0], -r4
 de8:	00000001 	andeq	r0, r0, r1
}

void usbResume(RESUME_STATE eResumeSetVal)
{
 dec:	00000001 	andeq	r0, r0, r1
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
 df0:	00000001 	andeq	r0, r0, r1
        ResumeS.eState = eResumeSetVal;
 df4:	00000001 	andeq	r0, r0, r1

    switch (ResumeS.eState) {
 df8:	00000001 	andeq	r0, r0, r1
 dfc:	00000001 	andeq	r0, r0, r1
 e00:	00000001 	andeq	r0, r0, r1
 e04:	00000001 	andeq	r0, r0, r1
    case RESUME_EXTERNAL:
        usbResumeInit();
 e08:	00000001 	andeq	r0, r0, r1
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
 e0c:	00000001 	andeq	r0, r0, r1
        ResumeS.eState = RESUME_START;
 e10:	00000001 	andeq	r0, r0, r1
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
 e14:	00000001 	andeq	r0, r0, r1
        ResumeS.eState = RESUME_WAIT;
 e18:	00000001 	andeq	r0, r0, r1
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
 e1c:	00000001 	andeq	r0, r0, r1
 e20:	00000001 	andeq	r0, r0, r1
        if (ResumeS.bESOFcnt == 0)
 e24:	00000001 	andeq	r0, r0, r1
            ResumeS.eState = RESUME_START;
 e28:	00000001 	andeq	r0, r0, r1
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
 e2c:	00000001 	andeq	r0, r0, r1
 e30:	00000001 	andeq	r0, r0, r1
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
 e34:	00000001 	andeq	r0, r0, r1
        ResumeS.eState = RESUME_ON;
 e38:	00000001 	andeq	r0, r0, r1
        ResumeS.bESOFcnt = 10;
 e3c:	00000001 	andeq	r0, r0, r1
        break;
 e40:	00000001 	andeq	r0, r0, r1
    case RESUME_ON:
        ResumeS.bESOFcnt--;
 e44:	00000001 	andeq	r0, r0, r1
 e48:	00000001 	andeq	r0, r0, r1
        if (ResumeS.bESOFcnt == 0) {
 e4c:	00000001 	andeq	r0, r0, r1
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
 e50:	00000001 	andeq	r0, r0, r1
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
 e54:	00000001 	andeq	r0, r0, r1
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
 e58:	00000001 	andeq	r0, r0, r1
            ResumeS.eState = RESUME_OFF;
 e5c:	00000001 	andeq	r0, r0, r1
 e60:	00000001 	andeq	r0, r0, r1
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
 e64:	00000001 	andeq	r0, r0, r1
	...
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
 e70:	00005cf4 	strdeq	r5, [r0], -r4
 e74:	00005e48 	andeq	r5, r0, r8, asr #28
 e78:	00000001 	andeq	r0, r0, r1
 e7c:	00000001 	andeq	r0, r0, r1
	...

    _SetCNTR(CNTR_FRES);
 e88:	00005e48 	andeq	r5, r0, r8, asr #28
 e8c:	00005e80 	andeq	r5, r0, r0, lsl #29
	...
    _SetCNTR(0);
    _SetISTR(0);

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
    _SetCNTR(wInterrupt_Mask);
 e98:	00006188 	andeq	r6, r0, r8, lsl #3
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 e9c:	00006190 	muleq	r0, r0, r1
 ea0:	00006194 	muleq	r0, r4, r1
#endif
#endif

    return USB_SUCCESS;
}
 ea4:	00006196 	muleq	r0, r6, r1
 ea8:	00006198 	muleq	r0, r8, r1
 eac:	000061a8 	andeq	r6, r0, r8, lsr #3
	...

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
 eb8:	0000635e 	andeq	r6, r0, lr, asr r3
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
 ebc:	00006508 	andeq	r6, r0, r8, lsl #10
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
 ec0:	00006510 	andeq	r6, r0, r0, lsl r5
 ec4:	00006530 	andeq	r6, r0, r0, lsr r5
	...
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 ed0:	00005e80 	andeq	r5, r0, r0, lsl #29
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
 ed4:	00005ea4 	andeq	r5, r0, r4, lsr #29
 ed8:	00005ea4 	andeq	r5, r0, r4, lsr #29
 edc:	00005ec8 	andeq	r5, r0, r8, asr #29

    return USB_SUCCESS;
}
 ee0:	00005ec8 	andeq	r5, r0, r8, asr #29
 ee4:	00005f58 	andeq	r5, r0, r8, asr pc
 ee8:	00005f58 	andeq	r5, r0, r8, asr pc
 eec:	00006000 	andeq	r6, r0, r0
 ef0:	00006000 	andeq	r6, r0, r0
}


void usbDsbBus(void)
{
    usbPowerOff();
 ef4:	00006038 	andeq	r6, r0, r8, lsr r0
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
 ef8:	00006038 	andeq	r6, r0, r8, lsr r0
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
 efc:	00006080 	andeq	r6, r0, r0, lsl #1
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 f00:	00006080 	andeq	r6, r0, r0, lsl #1
 f04:	00006150 	andeq	r6, r0, r0, asr r1
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 f08:	00006150 	andeq	r6, r0, r0, asr r1
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
 f0c:	000061d4 	ldrdeq	r6, [r0], -r4
 f10:	000061d4 	ldrdeq	r6, [r0], -r4
    nvicInit(&NVIC_InitStructure);
 f14:	000061f8 	strdeq	r6, [r0], -r8
}
 f18:	000061f8 	strdeq	r6, [r0], -r8

    return USB_SUCCESS;
}

void usbInit(void)
{
 f1c:	00006214 	andeq	r6, r0, r4, lsl r2
    dfuInit();
 f20:	00006214 	andeq	r6, r0, r4, lsl r2

    pInformation->Current_Configuration = 0;
 f24:	00006254 	andeq	r6, r0, r4, asr r2
 f28:	00006254 	andeq	r6, r0, r4, asr r2
    usbPowerOn();
 f2c:	00006530 	andeq	r6, r0, r0, lsr r5

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
 f30:	00006530 	andeq	r6, r0, r0, lsr r5
 f34:	000065f8 	strdeq	r6, [r0], -r8
 f38:	000065f8 	strdeq	r6, [r0], -r8
    _SetCNTR(wInterrupt_Mask);
 f3c:	00006630 	andeq	r6, r0, r0, lsr r6

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
 f40:	00006630 	andeq	r6, r0, r0, lsr r6
    bDeviceState = UNCONNECTED;
 f44:	0000668c 	andeq	r6, r0, ip, lsl #13
 f48:	00000001 	andeq	r0, r0, r1
 f4c:	00000001 	andeq	r0, r0, r1
	...
 f58:	0000668c 	andeq	r6, r0, ip, lsl #13
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
 f5c:	000066bc 			; <UNDEFINED> instruction: 0x000066bc
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
 f60:	000066bc 			; <UNDEFINED> instruction: 0x000066bc
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
 f64:	000066e0 	andeq	r6, r0, r0, ror #13
	...
