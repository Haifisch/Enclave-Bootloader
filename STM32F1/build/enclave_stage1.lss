
build/enclave_stage1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000000f0  00000000  00000000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00007524  000000f0  000000f0  000080f0  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .data         00000488  20000000  00007614  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          0000012c  20000488  00007a9c  00010488  2**2
                  ALLOC
  4 .bss.bIntPackSOF 00000001  200005b4  00007bc8  00010488  2**0
                  ALLOC
  5 .bss.bDeviceState 00000004  200005b8  00007bcc  00010488  2**2
                  ALLOC
  6 .bss.recvBuffer 00000800  200005bc  00007bd0  00010488  2**2
                  ALLOC
  7 .bss.uploadBlockLen 00000002  20000dbc  000083d0  00010488  2**1
                  ALLOC
  8 .bss.thisBlockLen 00000002  20000dbe  000083d2  00010488  2**1
                  ALLOC
  9 .bss.userFirmwareLen 00000004  20000dc0  000083d4  00010488  2**2
                  ALLOC
 10 .bss.userUploadType 00000001  20000dc4  000083d8  00010488  2**0
                  ALLOC
 11 .bss.dfuAppStatus 00000006  20000dc5  000083d9  00010488  2**0
                  ALLOC
 12 .bss.dfuBusy  00000001  20000dcb  000083df  00010488  2**0
                  ALLOC
 13 .bss.Data_Mul_MaxPacketSize 00000001  20000dcc  000083e0  00010488  2**0
                  ALLOC
 14 .bss.__malloc_sbrk_start 00000004  20000dd0  000083e4  00010488  2**2
                  ALLOC
 15 .bss.__malloc_free_list 00000004  20000dd4  000083e8  00010488  2**2
                  ALLOC
 16 .bss.heap_end.4246 00000004  20000dd8  000083ec  00010488  2**2
                  ALLOC
 17 ._usrstack    00000100  20000ddc  000083f0  00010488  2**0
                  ALLOC
 18 .comment      00000070  00000000  00000000  00010488  2**0
                  CONTENTS, READONLY
 19 .ARM.attributes 0000002f  00000000  00000000  000104f8  2**0
                  CONTENTS, READONLY
 20 .debug_aranges 00000858  00000000  00000000  00010528  2**3
                  CONTENTS, READONLY, DEBUGGING
 21 .debug_info   0000b09d  00000000  00000000  00010d80  2**0
                  CONTENTS, READONLY, DEBUGGING
 22 .debug_abbrev 00002942  00000000  00000000  0001be1d  2**0
                  CONTENTS, READONLY, DEBUGGING
 23 .debug_line   00003d2f  00000000  00000000  0001e75f  2**0
                  CONTENTS, READONLY, DEBUGGING
 24 .debug_frame  000017c4  00000000  00000000  00022490  2**2
                  CONTENTS, READONLY, DEBUGGING
 25 .debug_str    00002383  00000000  00000000  00023c54  2**0
                  CONTENTS, READONLY, DEBUGGING
 26 .debug_loc    00009ccb  00000000  00000000  00025fd7  2**0
                  CONTENTS, READONLY, DEBUGGING
 27 .debug_ranges 00000f68  00000000  00000000  0002fca8  2**3
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .isr_vector:

00000000 <g_pfnVectors>:




.thumb_func
__WFE:
   0:	20005000 	andcs	r5, r0, r0




.thumb_func
__SEV:
   4:	00000b4d 	andeq	r0, r0, sp, asr #22




.thumb_func
__ISB:
   8:	00000b95 	muleq	r0, r5, fp




.thumb_func
__DSB:
   c:	00000b95 	muleq	r0, r5, fp

  10:	00000b95 	muleq	r0, r5, fp




.thumb_func
__DMB:
  14:	00000b95 	muleq	r0, r5, fp




.thumb_func
__SVC:
  18:	00000b95 	muleq	r0, r5, fp
	...



.thumb_func
__MRS_PSP:

  2c:	00000b95 	muleq	r0, r5, fp
  MRS r0, psp
  30:	00000b95 	muleq	r0, r5, fp




.thumb_func
__MSR_PSP:
  34:	00000000 	andeq	r0, r0, r0




.thumb_func
__MRS_MSP:
  38:	00000b95 	muleq	r0, r5, fp

  3c:	00000b95 	muleq	r0, r5, fp




.thumb_func
__MSR_MSP:
  40:	00000b95 	muleq	r0, r5, fp




.thumb_func
__RESETPRIMASK:
  44:	00000b95 	muleq	r0, r5, fp

  48:	00000b95 	muleq	r0, r5, fp



.thumb_func
__SETPRIMASK:

  4c:	00000b95 	muleq	r0, r5, fp



.thumb_func
__READ_PRIMASK:

  50:	00000b95 	muleq	r0, r5, fp




.thumb_func
__RESETFAULTMASK:
  54:	00000b95 	muleq	r0, r5, fp




.thumb_func
__SETFAULTMASK:
  58:	00000b95 	muleq	r0, r5, fp




.thumb_func
__READ_FAULTMASK:
  5c:	00000b95 	muleq	r0, r5, fp




.thumb_func
__BASEPRICONFIG:
  60:	00000b95 	muleq	r0, r5, fp

  64:	00000b95 	muleq	r0, r5, fp




.thumb_func
__GetBASEPRI:
  68:	00000b95 	muleq	r0, r5, fp



.thumb_func
__REV_HalfWord:

  6c:	00000b95 	muleq	r0, r5, fp
  REV16 r0, r0
  70:	00000b95 	muleq	r0, r5, fp



.thumb_func
__REV_Word:

  74:	00000b95 	muleq	r0, r5, fp
  78:	00000b95 	muleq	r0, r5, fp
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
	f25519_sub(b, x3, z3); /* D */
  7c:	00000b95 	muleq	r0, r5, fp
  80:	00000b95 	muleq	r0, r5, fp
	f25519_mul__distinct(da, a, b);
  84:	00000b95 	muleq	r0, r5, fp
  88:	00000b95 	muleq	r0, r5, fp
  8c:	00000b95 	muleq	r0, r5, fp

	f25519_sub(b, x2, z2);
  90:	00000f81 	andeq	r0, r0, r1, lsl #31
  94:	00000b95 	muleq	r0, r5, fp
	f25519_add(a, x3, z3); /* C */
  98:	00000b95 	muleq	r0, r5, fp
  9c:	00000b95 	muleq	r0, r5, fp
  a0:	00000b95 	muleq	r0, r5, fp
	f25519_mul__distinct(cb, a, b);
  a4:	00000b95 	muleq	r0, r5, fp
  a8:	00000b95 	muleq	r0, r5, fp

	f25519_add(a, da, cb);
  ac:	00000b95 	muleq	r0, r5, fp
  b0:	00000b95 	muleq	r0, r5, fp
  b4:	00000b95 	muleq	r0, r5, fp
	f25519_mul__distinct(b, a, a);
  b8:	00000b95 	muleq	r0, r5, fp
  bc:	00000b95 	muleq	r0, r5, fp
	f25519_mul__distinct(x5, z1, b);
  c0:	00000b95 	muleq	r0, r5, fp
  c4:	00000b95 	muleq	r0, r5, fp
  c8:	00000b95 	muleq	r0, r5, fp

	f25519_sub(a, da, cb);
  cc:	00000b95 	muleq	r0, r5, fp
  d0:	00000b95 	muleq	r0, r5, fp
	f25519_mul__distinct(b, a, a);
  d4:	00000b95 	muleq	r0, r5, fp
  d8:	00000b95 	muleq	r0, r5, fp
  dc:	00000b95 	muleq	r0, r5, fp
	f25519_mul__distinct(z5, x1, b);
  e0:	00000b95 	muleq	r0, r5, fp
  e4:	00000b95 	muleq	r0, r5, fp
	uint8_t x1sq[F25519_SIZE];
	uint8_t z1sq[F25519_SIZE];
	uint8_t x1z1[F25519_SIZE];
	uint8_t a[F25519_SIZE];

	f25519_mul__distinct(x1sq, x1, x1);
  e8:	00000b95 	muleq	r0, r5, fp
  ec:	f108f85f 			; <UNDEFINED> instruction: 0xf108f85f

Disassembly of section .text:

000000f0 <GPIO_DeInit>:
      f0:	b508      	push	{r3, lr}
	f25519_mul__distinct(z1sq, z1, z1);
      f2:	4b2f      	ldr	r3, [pc, #188]	; (1b0 <_Minimum_Stack_Size+0xb0>)
      f4:	4298      	cmp	r0, r3
      f6:	d01e      	beq.n	136 <_Minimum_Stack_Size+0x36>
      f8:	4b2e      	ldr	r3, [pc, #184]	; (1b4 <_Minimum_Stack_Size+0xb4>)
      fa:	4298      	cmp	r0, r3
	f25519_mul__distinct(x1z1, x1, z1);
      fc:	d025      	beq.n	14a <_Minimum_Stack_Size+0x4a>
      fe:	4b2e      	ldr	r3, [pc, #184]	; (1b8 <_Minimum_Stack_Size+0xb8>)
     100:	4298      	cmp	r0, r3
     102:	d02c      	beq.n	15e <_Minimum_Stack_Size+0x5e>
     104:	4b2d      	ldr	r3, [pc, #180]	; (1bc <_Minimum_Stack_Size+0xbc>)

	f25519_sub(a, x1sq, z1sq);
     106:	4298      	cmp	r0, r3
     108:	d033      	beq.n	172 <_Minimum_Stack_Size+0x72>
     10a:	4b2d      	ldr	r3, [pc, #180]	; (1c0 <_Minimum_Stack_Size+0xc0>)
     10c:	4298      	cmp	r0, r3
     10e:	d03a      	beq.n	186 <_Minimum_Stack_Size+0x86>
	f25519_mul__distinct(x3, a, a);
     110:	4b2c      	ldr	r3, [pc, #176]	; (1c4 <_Minimum_Stack_Size+0xc4>)
     112:	4298      	cmp	r0, r3
     114:	d041      	beq.n	19a <_Minimum_Stack_Size+0x9a>
     116:	4b2c      	ldr	r3, [pc, #176]	; (1c8 <_Minimum_Stack_Size+0xc8>)
     118:	4298      	cmp	r0, r3

	f25519_mul_c(a, x1z1, 486662);
     11a:	d000      	beq.n	11e <_Minimum_Stack_Size+0x1e>
     11c:	bd08      	pop	{r3, pc}
     11e:	f44f 7080 	mov.w	r0, #256	; 0x100
     122:	2101      	movs	r1, #1
	f25519_add(a, x1sq, a);
     124:	f000 faac 	bl	680 <RCC_APB2PeriphResetCmd>
     128:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     12c:	f44f 7080 	mov.w	r0, #256	; 0x100
	f25519_add(a, z1sq, a);
     130:	2100      	movs	r1, #0
     132:	f000 baa5 	b.w	680 <RCC_APB2PeriphResetCmd>
     136:	2004      	movs	r0, #4
	f25519_mul__distinct(x1sq, x1z1, a);
     138:	2101      	movs	r1, #1
     13a:	f000 faa1 	bl	680 <RCC_APB2PeriphResetCmd>
     13e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	f25519_mul_c(z3, x1sq, 4);
     142:	2004      	movs	r0, #4
     144:	2100      	movs	r1, #0
     146:	f000 ba9b 	b.w	680 <RCC_APB2PeriphResetCmd>
     14a:	2008      	movs	r0, #8
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	2101      	movs	r1, #1
     14e:	f000 fa97 	bl	680 <RCC_APB2PeriphResetCmd>
     152:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	f25519_sub(b, x3, z3); /* D */
     156:	2008      	movs	r0, #8
     158:	2100      	movs	r1, #0
     15a:	f000 ba91 	b.w	680 <RCC_APB2PeriphResetCmd>
     15e:	2010      	movs	r0, #16
	f25519_mul__distinct(da, a, b);
     160:	2101      	movs	r1, #1
     162:	f000 fa8d 	bl	680 <RCC_APB2PeriphResetCmd>
     166:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	f25519_sub(b, x2, z2);
     16a:	2010      	movs	r0, #16
     16c:	2100      	movs	r1, #0
     16e:	f000 ba87 	b.w	680 <RCC_APB2PeriphResetCmd>
     172:	2020      	movs	r0, #32
	f25519_add(a, x3, z3); /* C */
     174:	2101      	movs	r1, #1
     176:	f000 fa83 	bl	680 <RCC_APB2PeriphResetCmd>
     17a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	f25519_mul__distinct(cb, a, b);
     17e:	2020      	movs	r0, #32
     180:	2100      	movs	r1, #0
     182:	f000 ba7d 	b.w	680 <RCC_APB2PeriphResetCmd>
     186:	2040      	movs	r0, #64	; 0x40

	f25519_add(a, da, cb);
     188:	2101      	movs	r1, #1
     18a:	f000 fa79 	bl	680 <RCC_APB2PeriphResetCmd>
     18e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	f25519_mul__distinct(b, a, a);
     192:	2040      	movs	r0, #64	; 0x40
     194:	2100      	movs	r1, #0
     196:	f000 ba73 	b.w	680 <RCC_APB2PeriphResetCmd>
     19a:	2080      	movs	r0, #128	; 0x80
	f25519_mul__distinct(x5, z1, b);
     19c:	2101      	movs	r1, #1
     19e:	f000 fa6f 	bl	680 <RCC_APB2PeriphResetCmd>
     1a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

	f25519_sub(a, da, cb);
     1a6:	2080      	movs	r0, #128	; 0x80
     1a8:	2100      	movs	r1, #0
     1aa:	f000 ba69 	b.w	680 <RCC_APB2PeriphResetCmd>
     1ae:	bf00      	nop
	f25519_mul__distinct(b, a, a);
     1b0:	40010800 	andmi	r0, r1, r0, lsl #16
     1b4:	40010c00 	andmi	r0, r1, r0, lsl #24
     1b8:	40011000 	andmi	r1, r1, r0

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	40011400 	andmi	r1, r1, r0, lsl #8
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	40011800 	andmi	r1, r1, r0, lsl #16
     1c4:	40011c00 	andmi	r1, r1, r0, lsl #24

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1c8:	40012000 	andmi	r2, r1, r0

000001cc <GPIO_AFIODeInit>:
     1cc:	b508      	push	{r3, lr}
     1ce:	2001      	movs	r0, #1
     1d0:	4601      	mov	r1, r0
     1d2:	f000 fa55 	bl	680 <RCC_APB2PeriphResetCmd>
		f25519_select(zm1, zm1, zm, bit);
     1d6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     1da:	2001      	movs	r0, #1
     1dc:	2100      	movs	r1, #0
     1de:	f000 ba4f 	b.w	680 <RCC_APB2PeriphResetCmd>
		f25519_select(xm, xm, xms, bit);
     1e2:	bf00      	nop

000001e4 <GPIO_Init>:
     1e4:	78cb      	ldrb	r3, [r1, #3]
     1e6:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
     1ea:	f003 060f 	and.w	r6, r3, #15
		f25519_select(zm, zm, zms, bit);
     1ee:	06db      	lsls	r3, r3, #27
     1f0:	bf48      	it	mi
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1f2:	788b      	ldrbmi	r3, [r1, #2]
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
		f25519_select(zm1, zm1, zm, bit);
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
     1f4:	880a      	ldrh	r2, [r1, #0]
     1f6:	bf48      	it	mi
     1f8:	431e      	orrmi	r6, r3
     1fa:	f012 0fff 	tst.w	r2, #255	; 0xff
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fe:	d026      	beq.n	24e <GPIO_Init+0x6a>
     200:	6807      	ldr	r7, [r0, #0]
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     202:	2300      	movs	r3, #0
     204:	2501      	movs	r5, #1
     206:	f04f 080f 	mov.w	r8, #15
	f25519_mul__distinct(result, zm1, xm);
     20a:	e003      	b.n	214 <GPIO_Init+0x30>
     20c:	3301      	adds	r3, #1
     20e:	2b08      	cmp	r3, #8
     210:	d01b      	beq.n	24a <GPIO_Init+0x66>
     212:	880a      	ldrh	r2, [r1, #0]
	f25519_normalize(result);
     214:	fa05 f403 	lsl.w	r4, r5, r3
     218:	4022      	ands	r2, r4
}
     21a:	42a2      	cmp	r2, r4
     21c:	d1f6      	bne.n	20c <GPIO_Init+0x28>
     21e:	009c      	lsls	r4, r3, #2
     220:	fa08 f904 	lsl.w	r9, r8, r4
     224:	fa06 f404 	lsl.w	r4, r6, r4
     228:	f891 c003 	ldrb.w	ip, [r1, #3]
     22c:	ea27 0709 	bic.w	r7, r7, r9
     230:	f1bc 0f28 	cmp.w	ip, #40	; 0x28
     234:	ea47 0704 	orr.w	r7, r7, r4
     238:	d034      	beq.n	2a4 <GPIO_Init+0xc0>
     23a:	f1bc 0f48 	cmp.w	ip, #72	; 0x48
     23e:	f103 0301 	add.w	r3, r3, #1
     242:	bf08      	it	eq
     244:	6102      	streq	r2, [r0, #16]
     246:	2b08      	cmp	r3, #8
     248:	d1e3      	bne.n	212 <GPIO_Init+0x2e>
     24a:	6007      	str	r7, [r0, #0]
     24c:	880a      	ldrh	r2, [r1, #0]
     24e:	2aff      	cmp	r2, #255	; 0xff
     250:	d925      	bls.n	29e <GPIO_Init+0xba>
     252:	6847      	ldr	r7, [r0, #4]
     254:	2300      	movs	r3, #0
     256:	2501      	movs	r5, #1
     258:	f04f 0c0f 	mov.w	ip, #15
     25c:	e003      	b.n	266 <GPIO_Init+0x82>
     25e:	3301      	adds	r3, #1
     260:	2b08      	cmp	r3, #8
     262:	d01b      	beq.n	29c <GPIO_Init+0xb8>
     264:	880a      	ldrh	r2, [r1, #0]
     266:	f103 0408 	add.w	r4, r3, #8
     26a:	fa05 f404 	lsl.w	r4, r5, r4
     26e:	4022      	ands	r2, r4
     270:	42a2      	cmp	r2, r4
     272:	d1f4      	bne.n	25e <GPIO_Init+0x7a>
     274:	009c      	lsls	r4, r3, #2
     276:	fa0c f904 	lsl.w	r9, ip, r4
     27a:	fa06 f804 	lsl.w	r8, r6, r4
     27e:	78cc      	ldrb	r4, [r1, #3]
     280:	3301      	adds	r3, #1
     282:	2c28      	cmp	r4, #40	; 0x28
     284:	bf04      	itt	eq
     286:	6142      	streq	r2, [r0, #20]
     288:	78cc      	ldrbeq	r4, [r1, #3]
     28a:	ea27 0709 	bic.w	r7, r7, r9
     28e:	2c48      	cmp	r4, #72	; 0x48
     290:	bf08      	it	eq
     292:	6102      	streq	r2, [r0, #16]
     294:	2b08      	cmp	r3, #8
     296:	ea47 0708 	orr.w	r7, r7, r8
     29a:	d1e3      	bne.n	264 <GPIO_Init+0x80>
     29c:	6047      	str	r7, [r0, #4]
     29e:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
     2a2:	4770      	bx	lr
     2a4:	6142      	str	r2, [r0, #20]
     2a6:	e7b1      	b.n	20c <GPIO_Init+0x28>

000002a8 <GPIO_StructInit>:
     2a8:	f64f 71ff 	movw	r1, #65535	; 0xffff
     2ac:	2202      	movs	r2, #2
     2ae:	2304      	movs	r3, #4
     2b0:	8001      	strh	r1, [r0, #0]
     2b2:	7082      	strb	r2, [r0, #2]
     2b4:	70c3      	strb	r3, [r0, #3]
     2b6:	4770      	bx	lr

000002b8 <GPIO_ReadInputDataBit>:
     2b8:	6883      	ldr	r3, [r0, #8]
     2ba:	4219      	tst	r1, r3
     2bc:	bf0c      	ite	eq
     2be:	2000      	moveq	r0, #0
     2c0:	2001      	movne	r0, #1
     2c2:	4770      	bx	lr

000002c4 <GPIO_ReadInputData>:
     2c4:	6880      	ldr	r0, [r0, #8]
     2c6:	b280      	uxth	r0, r0
     2c8:	4770      	bx	lr
     2ca:	bf00      	nop

000002cc <GPIO_ReadOutputDataBit>:
     2cc:	68c3      	ldr	r3, [r0, #12]
     2ce:	4219      	tst	r1, r3
     2d0:	bf0c      	ite	eq
     2d2:	2000      	moveq	r0, #0
     2d4:	2001      	movne	r0, #1
     2d6:	4770      	bx	lr

000002d8 <GPIO_ReadOutputData>:
     2d8:	68c0      	ldr	r0, [r0, #12]
     2da:	b280      	uxth	r0, r0
     2dc:	4770      	bx	lr
     2de:	bf00      	nop

000002e0 <GPIO_SetBits>:
     2e0:	6101      	str	r1, [r0, #16]
     2e2:	4770      	bx	lr

000002e4 <GPIO_ResetBits>:
     2e4:	6141      	str	r1, [r0, #20]
     2e6:	4770      	bx	lr

000002e8 <GPIO_WriteBit>:
     2e8:	b90a      	cbnz	r2, 2ee <GPIO_WriteBit+0x6>
     2ea:	6141      	str	r1, [r0, #20]
     2ec:	4770      	bx	lr
     2ee:	6101      	str	r1, [r0, #16]
     2f0:	4770      	bx	lr
     2f2:	bf00      	nop

000002f4 <GPIO_Write>:
     2f4:	60c1      	str	r1, [r0, #12]
     2f6:	4770      	bx	lr

000002f8 <GPIO_PinLockConfig>:
     2f8:	f441 3380 	orr.w	r3, r1, #65536	; 0x10000
     2fc:	6183      	str	r3, [r0, #24]
     2fe:	6181      	str	r1, [r0, #24]
     300:	6183      	str	r3, [r0, #24]
     302:	6983      	ldr	r3, [r0, #24]
     304:	6983      	ldr	r3, [r0, #24]
     306:	4770      	bx	lr

00000308 <GPIO_EventOutputConfig>:
     308:	b410      	push	{r4}
     30a:	4b06      	ldr	r3, [pc, #24]	; (324 <GPIO_EventOutputConfig+0x1c>)
     30c:	f64f 7280 	movw	r2, #65408	; 0xff80
     310:	681c      	ldr	r4, [r3, #0]
     312:	4022      	ands	r2, r4
     314:	4311      	orrs	r1, r2
     316:	ea41 1000 	orr.w	r0, r1, r0, lsl #4
     31a:	6018      	str	r0, [r3, #0]
     31c:	f85d 4b04 	ldr.w	r4, [sp], #4
     320:	4770      	bx	lr
     322:	bf00      	nop
     324:	40010000 	andmi	r0, r1, r0

00000328 <GPIO_EventOutputCmd>:
     328:	4b01      	ldr	r3, [pc, #4]	; (330 <GPIO_EventOutputCmd+0x8>)
     32a:	6018      	str	r0, [r3, #0]
     32c:	4770      	bx	lr
     32e:	bf00      	nop
     330:	4220001c 	eormi	r0, r0, #28

00000334 <GPIO_PinRemapConfig>:
     334:	b430      	push	{r4, r5}
     336:	2800      	cmp	r0, #0
     338:	4b18      	ldr	r3, [pc, #96]	; (39c <GPIO_PinRemapConfig+0x68>)
     33a:	f400 1240 	and.w	r2, r0, #3145728	; 0x300000
     33e:	bfb4      	ite	lt
     340:	69db      	ldrlt	r3, [r3, #28]
     342:	685b      	ldrge	r3, [r3, #4]
     344:	f5b2 1f40 	cmp.w	r2, #3145728	; 0x300000
     348:	b284      	uxth	r4, r0
     34a:	d01f      	beq.n	38c <GPIO_PinRemapConfig+0x58>
     34c:	02c2      	lsls	r2, r0, #11
     34e:	d514      	bpl.n	37a <GPIO_PinRemapConfig+0x46>
     350:	f3c0 4203 	ubfx	r2, r0, #16, #4
     354:	2503      	movs	r5, #3
     356:	fa05 f202 	lsl.w	r2, r5, r2
     35a:	ea23 0302 	bic.w	r3, r3, r2
     35e:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
     362:	b119      	cbz	r1, 36c <GPIO_PinRemapConfig+0x38>
     364:	0d42      	lsrs	r2, r0, #21
     366:	0112      	lsls	r2, r2, #4
     368:	4094      	lsls	r4, r2
     36a:	4323      	orrs	r3, r4
     36c:	4a0b      	ldr	r2, [pc, #44]	; (39c <GPIO_PinRemapConfig+0x68>)
     36e:	2800      	cmp	r0, #0
     370:	bfb4      	ite	lt
     372:	61d3      	strlt	r3, [r2, #28]
     374:	6053      	strge	r3, [r2, #4]
     376:	bc30      	pop	{r4, r5}
     378:	4770      	bx	lr
     37a:	0d42      	lsrs	r2, r0, #21
     37c:	0112      	lsls	r2, r2, #4
     37e:	fa04 f202 	lsl.w	r2, r4, r2
     382:	ea23 0302 	bic.w	r3, r3, r2
     386:	f043 6370 	orr.w	r3, r3, #251658240	; 0xf000000
     38a:	e7ea      	b.n	362 <GPIO_PinRemapConfig+0x2e>
     38c:	4a03      	ldr	r2, [pc, #12]	; (39c <GPIO_PinRemapConfig+0x68>)
     38e:	f023 6370 	bic.w	r3, r3, #251658240	; 0xf000000
     392:	6855      	ldr	r5, [r2, #4]
     394:	f025 6570 	bic.w	r5, r5, #251658240	; 0xf000000
     398:	6055      	str	r5, [r2, #4]
     39a:	e7e2      	b.n	362 <GPIO_PinRemapConfig+0x2e>
     39c:	40010000 	andmi	r0, r1, r0

000003a0 <GPIO_EXTILineConfig>:
     3a0:	f001 0303 	and.w	r3, r1, #3
     3a4:	009b      	lsls	r3, r3, #2
     3a6:	220f      	movs	r2, #15
     3a8:	409a      	lsls	r2, r3
     3aa:	fa00 f303 	lsl.w	r3, r0, r3
     3ae:	f001 01fc 	and.w	r1, r1, #252	; 0xfc
     3b2:	f101 4180 	add.w	r1, r1, #1073741824	; 0x40000000
     3b6:	f501 3180 	add.w	r1, r1, #65536	; 0x10000
     3ba:	6888      	ldr	r0, [r1, #8]
     3bc:	ea20 0202 	bic.w	r2, r0, r2
     3c0:	608a      	str	r2, [r1, #8]
     3c2:	688a      	ldr	r2, [r1, #8]
     3c4:	4313      	orrs	r3, r2
     3c6:	608b      	str	r3, [r1, #8]
     3c8:	4770      	bx	lr
     3ca:	bf00      	nop

000003cc <GPIO_ETH_MediaInterfaceConfig>:
     3cc:	4b01      	ldr	r3, [pc, #4]	; (3d4 <GPIO_ETH_MediaInterfaceConfig+0x8>)
     3ce:	6018      	str	r0, [r3, #0]
     3d0:	4770      	bx	lr
     3d2:	bf00      	nop
     3d4:	422000dc 	eormi	r0, r0, #220	; 0xdc

000003d8 <RCC_DeInit>:
     3d8:	4b0d      	ldr	r3, [pc, #52]	; (410 <RCC_DeInit+0x38>)
     3da:	4a0e      	ldr	r2, [pc, #56]	; (414 <RCC_DeInit+0x3c>)
     3dc:	6818      	ldr	r0, [r3, #0]
     3de:	f44f 011f 	mov.w	r1, #10420224	; 0x9f0000
     3e2:	f040 0001 	orr.w	r0, r0, #1
     3e6:	6018      	str	r0, [r3, #0]
     3e8:	6858      	ldr	r0, [r3, #4]
     3ea:	4002      	ands	r2, r0
     3ec:	605a      	str	r2, [r3, #4]
     3ee:	681a      	ldr	r2, [r3, #0]
     3f0:	f022 7284 	bic.w	r2, r2, #17301504	; 0x1080000
     3f4:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
     3f8:	601a      	str	r2, [r3, #0]
     3fa:	681a      	ldr	r2, [r3, #0]
     3fc:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
     400:	601a      	str	r2, [r3, #0]
     402:	685a      	ldr	r2, [r3, #4]
     404:	f422 02fe 	bic.w	r2, r2, #8323072	; 0x7f0000
     408:	605a      	str	r2, [r3, #4]
     40a:	6099      	str	r1, [r3, #8]
     40c:	4770      	bx	lr
     40e:	bf00      	nop
     410:	40021000 	andmi	r1, r2, r0
     414:	f8ff0000 			; <UNDEFINED> instruction: 0xf8ff0000

00000418 <RCC_HSEConfig>:
     418:	4b0c      	ldr	r3, [pc, #48]	; (44c <RCC_HSEConfig+0x34>)
     41a:	f5b0 3f80 	cmp.w	r0, #65536	; 0x10000
     41e:	681a      	ldr	r2, [r3, #0]
     420:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
     424:	601a      	str	r2, [r3, #0]
     426:	681a      	ldr	r2, [r3, #0]
     428:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
     42c:	601a      	str	r2, [r3, #0]
     42e:	d008      	beq.n	442 <RCC_HSEConfig+0x2a>
     430:	f5b0 2f80 	cmp.w	r0, #262144	; 0x40000
     434:	d104      	bne.n	440 <RCC_HSEConfig+0x28>
     436:	681a      	ldr	r2, [r3, #0]
     438:	f442 22a0 	orr.w	r2, r2, #327680	; 0x50000
     43c:	601a      	str	r2, [r3, #0]
     43e:	4770      	bx	lr
     440:	4770      	bx	lr
     442:	681a      	ldr	r2, [r3, #0]
     444:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
     448:	601a      	str	r2, [r3, #0]
     44a:	4770      	bx	lr
     44c:	40021000 	andmi	r1, r2, r0

00000450 <RCC_WaitForHSEStartUp>:
     450:	b082      	sub	sp, #8
     452:	2300      	movs	r3, #0
     454:	4a0b      	ldr	r2, [pc, #44]	; (484 <RCC_WaitForHSEStartUp+0x34>)
     456:	9301      	str	r3, [sp, #4]
     458:	6813      	ldr	r3, [r2, #0]
     45a:	039b      	lsls	r3, r3, #14
     45c:	d40c      	bmi.n	478 <RCC_WaitForHSEStartUp+0x28>
     45e:	9b01      	ldr	r3, [sp, #4]
     460:	3301      	adds	r3, #1
     462:	9301      	str	r3, [sp, #4]
     464:	9b01      	ldr	r3, [sp, #4]
     466:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
     46a:	d1f5      	bne.n	458 <RCC_WaitForHSEStartUp+0x8>
     46c:	4b05      	ldr	r3, [pc, #20]	; (484 <RCC_WaitForHSEStartUp+0x34>)
     46e:	6818      	ldr	r0, [r3, #0]
     470:	f3c0 4040 	ubfx	r0, r0, #17, #1
     474:	b002      	add	sp, #8
     476:	4770      	bx	lr
     478:	9b01      	ldr	r3, [sp, #4]
     47a:	3301      	adds	r3, #1
     47c:	9301      	str	r3, [sp, #4]
     47e:	9b01      	ldr	r3, [sp, #4]
     480:	e7f4      	b.n	46c <RCC_WaitForHSEStartUp+0x1c>
     482:	bf00      	nop
     484:	40021000 	andmi	r1, r2, r0

00000488 <RCC_AdjustHSICalibrationValue>:
     488:	4b03      	ldr	r3, [pc, #12]	; (498 <RCC_AdjustHSICalibrationValue+0x10>)
     48a:	681a      	ldr	r2, [r3, #0]
     48c:	f022 02f8 	bic.w	r2, r2, #248	; 0xf8
     490:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
     494:	6018      	str	r0, [r3, #0]
     496:	4770      	bx	lr
     498:	40021000 	andmi	r1, r2, r0

0000049c <RCC_HSICmd>:
     49c:	4b01      	ldr	r3, [pc, #4]	; (4a4 <RCC_HSICmd+0x8>)
     49e:	6018      	str	r0, [r3, #0]
     4a0:	4770      	bx	lr
     4a2:	bf00      	nop
     4a4:	42420000 	submi	r0, r2, #0

000004a8 <RCC_PLLConfig>:
     4a8:	4b03      	ldr	r3, [pc, #12]	; (4b8 <RCC_PLLConfig+0x10>)
     4aa:	685a      	ldr	r2, [r3, #4]
     4ac:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
     4b0:	4311      	orrs	r1, r2
     4b2:	4308      	orrs	r0, r1
     4b4:	6058      	str	r0, [r3, #4]
     4b6:	4770      	bx	lr
     4b8:	40021000 	andmi	r1, r2, r0

000004bc <RCC_PLLCmd>:
     4bc:	4b01      	ldr	r3, [pc, #4]	; (4c4 <RCC_PLLCmd+0x8>)
     4be:	6018      	str	r0, [r3, #0]
     4c0:	4770      	bx	lr
     4c2:	bf00      	nop
     4c4:	42420060 	submi	r0, r2, #96	; 0x60

000004c8 <RCC_SYSCLKConfig>:
     4c8:	4b03      	ldr	r3, [pc, #12]	; (4d8 <RCC_SYSCLKConfig+0x10>)
     4ca:	685a      	ldr	r2, [r3, #4]
     4cc:	f022 0203 	bic.w	r2, r2, #3
     4d0:	4310      	orrs	r0, r2
     4d2:	6058      	str	r0, [r3, #4]
     4d4:	4770      	bx	lr
     4d6:	bf00      	nop
     4d8:	40021000 	andmi	r1, r2, r0

000004dc <RCC_GetSYSCLKSource>:
     4dc:	4b02      	ldr	r3, [pc, #8]	; (4e8 <RCC_GetSYSCLKSource+0xc>)
     4de:	6858      	ldr	r0, [r3, #4]
     4e0:	f000 000c 	and.w	r0, r0, #12
     4e4:	4770      	bx	lr
     4e6:	bf00      	nop
     4e8:	40021000 	andmi	r1, r2, r0

000004ec <RCC_HCLKConfig>:
     4ec:	4b03      	ldr	r3, [pc, #12]	; (4fc <RCC_HCLKConfig+0x10>)
     4ee:	685a      	ldr	r2, [r3, #4]
     4f0:	f022 02f0 	bic.w	r2, r2, #240	; 0xf0
     4f4:	4310      	orrs	r0, r2
     4f6:	6058      	str	r0, [r3, #4]
     4f8:	4770      	bx	lr
     4fa:	bf00      	nop
     4fc:	40021000 	andmi	r1, r2, r0

00000500 <RCC_PCLK1Config>:
     500:	4b03      	ldr	r3, [pc, #12]	; (510 <RCC_PCLK1Config+0x10>)
     502:	685a      	ldr	r2, [r3, #4]
     504:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
     508:	4310      	orrs	r0, r2
     50a:	6058      	str	r0, [r3, #4]
     50c:	4770      	bx	lr
     50e:	bf00      	nop
     510:	40021000 	andmi	r1, r2, r0

00000514 <RCC_PCLK2Config>:
     514:	4b03      	ldr	r3, [pc, #12]	; (524 <RCC_PCLK2Config+0x10>)
     516:	685a      	ldr	r2, [r3, #4]
     518:	f422 5260 	bic.w	r2, r2, #14336	; 0x3800
     51c:	ea42 00c0 	orr.w	r0, r2, r0, lsl #3
     520:	6058      	str	r0, [r3, #4]
     522:	4770      	bx	lr
     524:	40021000 	andmi	r1, r2, r0

00000528 <RCC_ITConfig>:
     528:	4b04      	ldr	r3, [pc, #16]	; (53c <RCC_ITConfig+0x14>)
     52a:	781a      	ldrb	r2, [r3, #0]
     52c:	b919      	cbnz	r1, 536 <RCC_ITConfig+0xe>
     52e:	ea22 0000 	bic.w	r0, r2, r0
     532:	7018      	strb	r0, [r3, #0]
     534:	4770      	bx	lr
     536:	4310      	orrs	r0, r2
     538:	7018      	strb	r0, [r3, #0]
     53a:	4770      	bx	lr
     53c:	40021009 	andmi	r1, r2, r9

00000540 <RCC_USBCLKConfig>:
     540:	4b01      	ldr	r3, [pc, #4]	; (548 <RCC_USBCLKConfig+0x8>)
     542:	6018      	str	r0, [r3, #0]
     544:	4770      	bx	lr
     546:	bf00      	nop
     548:	424200d8 	submi	r0, r2, #216	; 0xd8

0000054c <RCC_ADCCLKConfig>:
     54c:	4b03      	ldr	r3, [pc, #12]	; (55c <RCC_ADCCLKConfig+0x10>)
     54e:	685a      	ldr	r2, [r3, #4]
     550:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
     554:	4310      	orrs	r0, r2
     556:	6058      	str	r0, [r3, #4]
     558:	4770      	bx	lr
     55a:	bf00      	nop
     55c:	40021000 	andmi	r1, r2, r0

00000560 <RCC_LSEConfig>:
     560:	4b06      	ldr	r3, [pc, #24]	; (57c <RCC_LSEConfig+0x1c>)
     562:	2200      	movs	r2, #0
     564:	2801      	cmp	r0, #1
     566:	701a      	strb	r2, [r3, #0]
     568:	701a      	strb	r2, [r3, #0]
     56a:	d005      	beq.n	578 <RCC_LSEConfig+0x18>
     56c:	2804      	cmp	r0, #4
     56e:	d102      	bne.n	576 <RCC_LSEConfig+0x16>
     570:	2205      	movs	r2, #5
     572:	701a      	strb	r2, [r3, #0]
     574:	4770      	bx	lr
     576:	4770      	bx	lr
     578:	7018      	strb	r0, [r3, #0]
     57a:	4770      	bx	lr
     57c:	40021020 	andmi	r1, r2, r0, lsr #32

00000580 <RCC_LSICmd>:
     580:	4b01      	ldr	r3, [pc, #4]	; (588 <RCC_LSICmd+0x8>)
     582:	6018      	str	r0, [r3, #0]
     584:	4770      	bx	lr
     586:	bf00      	nop
     588:	42420480 	submi	r0, r2, #128, 8	; 0x80000000

0000058c <RCC_RTCCLKConfig>:
     58c:	4b02      	ldr	r3, [pc, #8]	; (598 <RCC_RTCCLKConfig+0xc>)
     58e:	6a1a      	ldr	r2, [r3, #32]
     590:	4310      	orrs	r0, r2
     592:	6218      	str	r0, [r3, #32]
     594:	4770      	bx	lr
     596:	bf00      	nop
     598:	40021000 	andmi	r1, r2, r0

0000059c <RCC_RTCCLKCmd>:
     59c:	4b01      	ldr	r3, [pc, #4]	; (5a4 <RCC_RTCCLKCmd+0x8>)
     59e:	6018      	str	r0, [r3, #0]
     5a0:	4770      	bx	lr
     5a2:	bf00      	nop
     5a4:	4242043c 	submi	r0, r2, #60, 8	; 0x3c000000

000005a8 <RCC_GetClocksFreq>:
     5a8:	b410      	push	{r4}
     5aa:	4a1f      	ldr	r2, [pc, #124]	; (628 <RCC_GetClocksFreq+0x80>)
     5ac:	6853      	ldr	r3, [r2, #4]
     5ae:	f003 030c 	and.w	r3, r3, #12
     5b2:	2b04      	cmp	r3, #4
     5b4:	d001      	beq.n	5ba <RCC_GetClocksFreq+0x12>
     5b6:	2b08      	cmp	r3, #8
     5b8:	d021      	beq.n	5fe <RCC_GetClocksFreq+0x56>
     5ba:	491c      	ldr	r1, [pc, #112]	; (62c <RCC_GetClocksFreq+0x84>)
     5bc:	6001      	str	r1, [r0, #0]
     5be:	4a1a      	ldr	r2, [pc, #104]	; (628 <RCC_GetClocksFreq+0x80>)
     5c0:	4b1b      	ldr	r3, [pc, #108]	; (630 <RCC_GetClocksFreq+0x88>)
     5c2:	6854      	ldr	r4, [r2, #4]
     5c4:	f3c4 1403 	ubfx	r4, r4, #4, #4
     5c8:	5d1c      	ldrb	r4, [r3, r4]
     5ca:	40e1      	lsrs	r1, r4
     5cc:	6041      	str	r1, [r0, #4]
     5ce:	6854      	ldr	r4, [r2, #4]
     5d0:	f3c4 2402 	ubfx	r4, r4, #8, #3
     5d4:	5d1c      	ldrb	r4, [r3, r4]
     5d6:	fa21 f404 	lsr.w	r4, r1, r4
     5da:	6084      	str	r4, [r0, #8]
     5dc:	6854      	ldr	r4, [r2, #4]
     5de:	f3c4 24c2 	ubfx	r4, r4, #11, #3
     5e2:	5d1c      	ldrb	r4, [r3, r4]
     5e4:	40e1      	lsrs	r1, r4
     5e6:	60c1      	str	r1, [r0, #12]
     5e8:	6852      	ldr	r2, [r2, #4]
     5ea:	f85d 4b04 	ldr.w	r4, [sp], #4
     5ee:	f3c2 3281 	ubfx	r2, r2, #14, #2
     5f2:	4413      	add	r3, r2
     5f4:	7c1b      	ldrb	r3, [r3, #16]
     5f6:	fbb1 f1f3 	udiv	r1, r1, r3
     5fa:	6101      	str	r1, [r0, #16]
     5fc:	4770      	bx	lr
     5fe:	6851      	ldr	r1, [r2, #4]
     600:	6853      	ldr	r3, [r2, #4]
     602:	f3c1 4183 	ubfx	r1, r1, #18, #4
     606:	03dc      	lsls	r4, r3, #15
     608:	f101 0102 	add.w	r1, r1, #2
     60c:	d507      	bpl.n	61e <RCC_GetClocksFreq+0x76>
     60e:	6853      	ldr	r3, [r2, #4]
     610:	039b      	lsls	r3, r3, #14
     612:	d404      	bmi.n	61e <RCC_GetClocksFreq+0x76>
     614:	4b05      	ldr	r3, [pc, #20]	; (62c <RCC_GetClocksFreq+0x84>)
     616:	fb03 f101 	mul.w	r1, r3, r1
     61a:	6001      	str	r1, [r0, #0]
     61c:	e7cf      	b.n	5be <RCC_GetClocksFreq+0x16>
     61e:	4b05      	ldr	r3, [pc, #20]	; (634 <RCC_GetClocksFreq+0x8c>)
     620:	fb03 f101 	mul.w	r1, r3, r1
     624:	6001      	str	r1, [r0, #0]
     626:	e7ca      	b.n	5be <RCC_GetClocksFreq+0x16>
     628:	40021000 	andmi	r1, r2, r0
     62c:	007a1200 	rsbseq	r1, sl, r0, lsl #4
     630:	20000000 	andcs	r0, r0, r0
     634:	003d0900 	eorseq	r0, sp, r0, lsl #18

00000638 <RCC_AHBPeriphClockCmd>:
     638:	4b04      	ldr	r3, [pc, #16]	; (64c <RCC_AHBPeriphClockCmd+0x14>)
     63a:	695a      	ldr	r2, [r3, #20]
     63c:	b919      	cbnz	r1, 646 <RCC_AHBPeriphClockCmd+0xe>
     63e:	ea22 0000 	bic.w	r0, r2, r0
     642:	6158      	str	r0, [r3, #20]
     644:	4770      	bx	lr
     646:	4310      	orrs	r0, r2
     648:	6158      	str	r0, [r3, #20]
     64a:	4770      	bx	lr
     64c:	40021000 	andmi	r1, r2, r0

00000650 <RCC_APB2PeriphClockCmd>:
     650:	4b04      	ldr	r3, [pc, #16]	; (664 <RCC_APB2PeriphClockCmd+0x14>)
     652:	699a      	ldr	r2, [r3, #24]
     654:	b919      	cbnz	r1, 65e <RCC_APB2PeriphClockCmd+0xe>
     656:	ea22 0000 	bic.w	r0, r2, r0
     65a:	6198      	str	r0, [r3, #24]
     65c:	4770      	bx	lr
     65e:	4310      	orrs	r0, r2
     660:	6198      	str	r0, [r3, #24]
     662:	4770      	bx	lr
     664:	40021000 	andmi	r1, r2, r0

00000668 <RCC_APB1PeriphClockCmd>:
     668:	4b04      	ldr	r3, [pc, #16]	; (67c <RCC_APB1PeriphClockCmd+0x14>)
     66a:	69da      	ldr	r2, [r3, #28]
     66c:	b919      	cbnz	r1, 676 <RCC_APB1PeriphClockCmd+0xe>
     66e:	ea22 0000 	bic.w	r0, r2, r0
     672:	61d8      	str	r0, [r3, #28]
     674:	4770      	bx	lr
     676:	4310      	orrs	r0, r2
     678:	61d8      	str	r0, [r3, #28]
     67a:	4770      	bx	lr
     67c:	40021000 	andmi	r1, r2, r0

00000680 <RCC_APB2PeriphResetCmd>:
     680:	4b04      	ldr	r3, [pc, #16]	; (694 <RCC_APB2PeriphResetCmd+0x14>)
     682:	68da      	ldr	r2, [r3, #12]
     684:	b919      	cbnz	r1, 68e <RCC_APB2PeriphResetCmd+0xe>
     686:	ea22 0000 	bic.w	r0, r2, r0
     68a:	60d8      	str	r0, [r3, #12]
     68c:	4770      	bx	lr
     68e:	4310      	orrs	r0, r2
     690:	60d8      	str	r0, [r3, #12]
     692:	4770      	bx	lr
     694:	40021000 	andmi	r1, r2, r0

00000698 <RCC_APB1PeriphResetCmd>:
     698:	4b04      	ldr	r3, [pc, #16]	; (6ac <RCC_APB1PeriphResetCmd+0x14>)
     69a:	691a      	ldr	r2, [r3, #16]
     69c:	b919      	cbnz	r1, 6a6 <RCC_APB1PeriphResetCmd+0xe>
     69e:	ea22 0000 	bic.w	r0, r2, r0
     6a2:	6118      	str	r0, [r3, #16]
     6a4:	4770      	bx	lr
     6a6:	4310      	orrs	r0, r2
     6a8:	6118      	str	r0, [r3, #16]
     6aa:	4770      	bx	lr
     6ac:	40021000 	andmi	r1, r2, r0

000006b0 <RCC_BackupResetCmd>:
     6b0:	4b01      	ldr	r3, [pc, #4]	; (6b8 <RCC_BackupResetCmd+0x8>)
     6b2:	6018      	str	r0, [r3, #0]
     6b4:	4770      	bx	lr
     6b6:	bf00      	nop
     6b8:	42420440 	submi	r0, r2, #64, 8	; 0x40000000

000006bc <RCC_ClockSecuritySystemCmd>:
     6bc:	4b01      	ldr	r3, [pc, #4]	; (6c4 <RCC_ClockSecuritySystemCmd+0x8>)
     6be:	6018      	str	r0, [r3, #0]
     6c0:	4770      	bx	lr
     6c2:	bf00      	nop
     6c4:	4242004c 	submi	r0, r2, #76	; 0x4c

000006c8 <RCC_MCOConfig>:
     6c8:	4b01      	ldr	r3, [pc, #4]	; (6d0 <RCC_MCOConfig+0x8>)
     6ca:	7018      	strb	r0, [r3, #0]
     6cc:	4770      	bx	lr
     6ce:	bf00      	nop
     6d0:	40021007 	andmi	r1, r2, r7

000006d4 <RCC_GetFlagStatus>:
     6d4:	0943      	lsrs	r3, r0, #5
     6d6:	2b01      	cmp	r3, #1
     6d8:	d00b      	beq.n	6f2 <RCC_GetFlagStatus+0x1e>
     6da:	2b02      	cmp	r3, #2
     6dc:	4b09      	ldr	r3, [pc, #36]	; (704 <RCC_GetFlagStatus+0x30>)
     6de:	f000 001f 	and.w	r0, r0, #31
     6e2:	bf0c      	ite	eq
     6e4:	6a1b      	ldreq	r3, [r3, #32]
     6e6:	6a5b      	ldrne	r3, [r3, #36]	; 0x24
     6e8:	fa23 f000 	lsr.w	r0, r3, r0
     6ec:	f000 0001 	and.w	r0, r0, #1
     6f0:	4770      	bx	lr
     6f2:	4b04      	ldr	r3, [pc, #16]	; (704 <RCC_GetFlagStatus+0x30>)
     6f4:	f000 001f 	and.w	r0, r0, #31
     6f8:	681b      	ldr	r3, [r3, #0]
     6fa:	fa23 f000 	lsr.w	r0, r3, r0
     6fe:	f000 0001 	and.w	r0, r0, #1
     702:	4770      	bx	lr
     704:	40021000 	andmi	r1, r2, r0

00000708 <RCC_ClearFlag>:
     708:	4b02      	ldr	r3, [pc, #8]	; (714 <RCC_ClearFlag+0xc>)
     70a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
     70c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
     710:	625a      	str	r2, [r3, #36]	; 0x24
     712:	4770      	bx	lr
     714:	40021000 	andmi	r1, r2, r0

00000718 <RCC_GetITStatus>:
     718:	4b03      	ldr	r3, [pc, #12]	; (728 <RCC_GetITStatus+0x10>)
     71a:	689b      	ldr	r3, [r3, #8]
     71c:	4218      	tst	r0, r3
     71e:	bf0c      	ite	eq
     720:	2000      	moveq	r0, #0
     722:	2001      	movne	r0, #1
     724:	4770      	bx	lr
     726:	bf00      	nop
     728:	40021000 	andmi	r1, r2, r0

0000072c <RCC_ClearITPendingBit>:
     72c:	4b01      	ldr	r3, [pc, #4]	; (734 <RCC_ClearITPendingBit+0x8>)
     72e:	7018      	strb	r0, [r3, #0]
     730:	4770      	bx	lr
     732:	bf00      	nop
     734:	4002100a 	andmi	r1, r2, sl

00000738 <USART_DeInit>:
     738:	b508      	push	{r3, lr}
     73a:	4b26      	ldr	r3, [pc, #152]	; (7d4 <USART_DeInit+0x9c>)
     73c:	4298      	cmp	r0, r3
     73e:	d018      	beq.n	772 <USART_DeInit+0x3a>
     740:	4b25      	ldr	r3, [pc, #148]	; (7d8 <USART_DeInit+0xa0>)
     742:	4298      	cmp	r0, r3
     744:	d021      	beq.n	78a <USART_DeInit+0x52>
     746:	4b25      	ldr	r3, [pc, #148]	; (7dc <USART_DeInit+0xa4>)
     748:	4298      	cmp	r0, r3
     74a:	d02a      	beq.n	7a2 <USART_DeInit+0x6a>
     74c:	4b24      	ldr	r3, [pc, #144]	; (7e0 <USART_DeInit+0xa8>)
     74e:	4298      	cmp	r0, r3
     750:	d033      	beq.n	7ba <USART_DeInit+0x82>
     752:	4b24      	ldr	r3, [pc, #144]	; (7e4 <USART_DeInit+0xac>)
     754:	4298      	cmp	r0, r3
     756:	d000      	beq.n	75a <USART_DeInit+0x22>
     758:	bd08      	pop	{r3, pc}
     75a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
     75e:	2101      	movs	r1, #1
     760:	f7ff ff9a 	bl	698 <RCC_APB1PeriphResetCmd>
     764:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     768:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
     76c:	2100      	movs	r1, #0
     76e:	f7ff bf93 	b.w	698 <RCC_APB1PeriphResetCmd>
     772:	f44f 4080 	mov.w	r0, #16384	; 0x4000
     776:	2101      	movs	r1, #1
     778:	f7ff ff82 	bl	680 <RCC_APB2PeriphResetCmd>
     77c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     780:	f44f 4080 	mov.w	r0, #16384	; 0x4000
     784:	2100      	movs	r1, #0
     786:	f7ff bf7b 	b.w	680 <RCC_APB2PeriphResetCmd>
     78a:	f44f 3000 	mov.w	r0, #131072	; 0x20000
     78e:	2101      	movs	r1, #1
     790:	f7ff ff82 	bl	698 <RCC_APB1PeriphResetCmd>
     794:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     798:	f44f 3000 	mov.w	r0, #131072	; 0x20000
     79c:	2100      	movs	r1, #0
     79e:	f7ff bf7b 	b.w	698 <RCC_APB1PeriphResetCmd>
     7a2:	f44f 2080 	mov.w	r0, #262144	; 0x40000
     7a6:	2101      	movs	r1, #1
     7a8:	f7ff ff76 	bl	698 <RCC_APB1PeriphResetCmd>
     7ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     7b0:	f44f 2080 	mov.w	r0, #262144	; 0x40000
     7b4:	2100      	movs	r1, #0
     7b6:	f7ff bf6f 	b.w	698 <RCC_APB1PeriphResetCmd>
     7ba:	f44f 2000 	mov.w	r0, #524288	; 0x80000
     7be:	2101      	movs	r1, #1
     7c0:	f7ff ff6a 	bl	698 <RCC_APB1PeriphResetCmd>
     7c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
     7c8:	f44f 2000 	mov.w	r0, #524288	; 0x80000
     7cc:	2100      	movs	r1, #0
     7ce:	f7ff bf63 	b.w	698 <RCC_APB1PeriphResetCmd>
     7d2:	bf00      	nop
     7d4:	40013800 	andmi	r3, r1, r0, lsl #16
     7d8:	40004400 	andmi	r4, r0, r0, lsl #8
     7dc:	40004800 	andmi	r4, r0, r0, lsl #16
     7e0:	40004c00 	andmi	r4, r0, r0, lsl #24
     7e4:	40005000 	andmi	r5, r0, r0

000007e8 <USART_Init>:
     7e8:	b530      	push	{r4, r5, lr}
     7ea:	8a03      	ldrh	r3, [r0, #16]
     7ec:	88ca      	ldrh	r2, [r1, #6]
     7ee:	b29b      	uxth	r3, r3
     7f0:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
     7f4:	4313      	orrs	r3, r2
     7f6:	8203      	strh	r3, [r0, #16]
     7f8:	8982      	ldrh	r2, [r0, #12]
     7fa:	4604      	mov	r4, r0
     7fc:	890b      	ldrh	r3, [r1, #8]
     7fe:	8888      	ldrh	r0, [r1, #4]
     800:	460d      	mov	r5, r1
     802:	b292      	uxth	r2, r2
     804:	8949      	ldrh	r1, [r1, #10]
     806:	4303      	orrs	r3, r0
     808:	f422 52b0 	bic.w	r2, r2, #5632	; 0x1600
     80c:	430b      	orrs	r3, r1
     80e:	f022 020c 	bic.w	r2, r2, #12
     812:	4313      	orrs	r3, r2
     814:	b29b      	uxth	r3, r3
     816:	81a3      	strh	r3, [r4, #12]
     818:	8aa3      	ldrh	r3, [r4, #20]
     81a:	89aa      	ldrh	r2, [r5, #12]
     81c:	b29b      	uxth	r3, r3
     81e:	f423 7340 	bic.w	r3, r3, #768	; 0x300
     822:	b087      	sub	sp, #28
     824:	4313      	orrs	r3, r2
     826:	82a3      	strh	r3, [r4, #20]
     828:	a801      	add	r0, sp, #4
     82a:	f7ff febd 	bl	5a8 <RCC_GetClocksFreq>
     82e:	89a1      	ldrh	r1, [r4, #12]
     830:	9a04      	ldr	r2, [sp, #16]
     832:	481a      	ldr	r0, [pc, #104]	; (89c <__Stack_Size+0x9c>)
     834:	9b03      	ldr	r3, [sp, #12]
     836:	b209      	sxth	r1, r1
     838:	4284      	cmp	r4, r0
     83a:	bf08      	it	eq
     83c:	4613      	moveq	r3, r2
     83e:	682a      	ldr	r2, [r5, #0]
     840:	2900      	cmp	r1, #0
     842:	eb03 0383 	add.w	r3, r3, r3, lsl #2
     846:	bfb4      	ite	lt
     848:	0052      	lsllt	r2, r2, #1
     84a:	0092      	lslge	r2, r2, #2
     84c:	eb03 0383 	add.w	r3, r3, r3, lsl #2
     850:	4913      	ldr	r1, [pc, #76]	; (8a0 <__Stack_Size+0xa0>)
     852:	fbb3 f3f2 	udiv	r3, r3, r2
     856:	fba1 5203 	umull	r5, r2, r1, r3
     85a:	89a0      	ldrh	r0, [r4, #12]
     85c:	0952      	lsrs	r2, r2, #5
     85e:	b200      	sxth	r0, r0
     860:	2564      	movs	r5, #100	; 0x64
     862:	2800      	cmp	r0, #0
     864:	fb02 3315 	mls	r3, r2, r5, r3
     868:	ea4f 1202 	mov.w	r2, r2, lsl #4
     86c:	db0a      	blt.n	884 <__Stack_Size+0x84>
     86e:	011b      	lsls	r3, r3, #4
     870:	3332      	adds	r3, #50	; 0x32
     872:	fba1 5103 	umull	r5, r1, r1, r3
     876:	f3c1 1143 	ubfx	r1, r1, #5, #4
     87a:	430a      	orrs	r2, r1
     87c:	b292      	uxth	r2, r2
     87e:	8122      	strh	r2, [r4, #8]
     880:	b007      	add	sp, #28
     882:	bd30      	pop	{r4, r5, pc}
     884:	00db      	lsls	r3, r3, #3
     886:	3332      	adds	r3, #50	; 0x32
     888:	fba1 0103 	umull	r0, r1, r1, r3
     88c:	f3c1 1142 	ubfx	r1, r1, #5, #3
     890:	430a      	orrs	r2, r1
     892:	b292      	uxth	r2, r2
     894:	8122      	strh	r2, [r4, #8]
     896:	b007      	add	sp, #28
     898:	bd30      	pop	{r4, r5, pc}
     89a:	bf00      	nop
     89c:	40013800 	andmi	r3, r1, r0, lsl #16
     8a0:	51eb851f 	mvnpl	r8, pc, lsl r5

000008a4 <USART_StructInit>:
     8a4:	2300      	movs	r3, #0
     8a6:	f44f 5116 	mov.w	r1, #9600	; 0x2580
     8aa:	220c      	movs	r2, #12
     8ac:	6001      	str	r1, [r0, #0]
     8ae:	8142      	strh	r2, [r0, #10]
     8b0:	8083      	strh	r3, [r0, #4]
     8b2:	80c3      	strh	r3, [r0, #6]
     8b4:	8103      	strh	r3, [r0, #8]
     8b6:	8183      	strh	r3, [r0, #12]
     8b8:	4770      	bx	lr
     8ba:	bf00      	nop

000008bc <USART_ClockInit>:
     8bc:	b430      	push	{r4, r5}
     8be:	884d      	ldrh	r5, [r1, #2]
     8c0:	880b      	ldrh	r3, [r1, #0]
     8c2:	888c      	ldrh	r4, [r1, #4]
     8c4:	8a02      	ldrh	r2, [r0, #16]
     8c6:	432b      	orrs	r3, r5
     8c8:	88c9      	ldrh	r1, [r1, #6]
     8ca:	4323      	orrs	r3, r4
     8cc:	b292      	uxth	r2, r2
     8ce:	430b      	orrs	r3, r1
     8d0:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
     8d4:	4313      	orrs	r3, r2
     8d6:	b29b      	uxth	r3, r3
     8d8:	8203      	strh	r3, [r0, #16]
     8da:	bc30      	pop	{r4, r5}
     8dc:	4770      	bx	lr
     8de:	bf00      	nop

000008e0 <USART_ClockStructInit>:
     8e0:	2300      	movs	r3, #0
     8e2:	8003      	strh	r3, [r0, #0]
     8e4:	8043      	strh	r3, [r0, #2]
     8e6:	8083      	strh	r3, [r0, #4]
     8e8:	80c3      	strh	r3, [r0, #6]
     8ea:	4770      	bx	lr

000008ec <USART_Cmd>:
     8ec:	8983      	ldrh	r3, [r0, #12]
     8ee:	b929      	cbnz	r1, 8fc <USART_Cmd+0x10>
     8f0:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
     8f4:	041b      	lsls	r3, r3, #16
     8f6:	0c1b      	lsrs	r3, r3, #16
     8f8:	8183      	strh	r3, [r0, #12]
     8fa:	4770      	bx	lr
     8fc:	b29b      	uxth	r3, r3
     8fe:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
     902:	8183      	strh	r3, [r0, #12]
     904:	4770      	bx	lr
     906:	bf00      	nop

00000908 <USART_ITConfig>:
     908:	f001 031f 	and.w	r3, r1, #31
     90c:	b410      	push	{r4}
     90e:	f3c1 1142 	ubfx	r1, r1, #5, #3
     912:	2401      	movs	r4, #1
     914:	42a1      	cmp	r1, r4
     916:	fa04 f303 	lsl.w	r3, r4, r3
     91a:	d010      	beq.n	93e <USART_ITConfig+0x36>
     91c:	2902      	cmp	r1, #2
     91e:	bf0c      	ite	eq
     920:	3010      	addeq	r0, #16
     922:	3014      	addne	r0, #20
     924:	6804      	ldr	r4, [r0, #0]
     926:	b92a      	cbnz	r2, 934 <USART_ITConfig+0x2c>
     928:	ea24 0303 	bic.w	r3, r4, r3
     92c:	6003      	str	r3, [r0, #0]
     92e:	f85d 4b04 	ldr.w	r4, [sp], #4
     932:	4770      	bx	lr
     934:	4323      	orrs	r3, r4
     936:	6003      	str	r3, [r0, #0]
     938:	f85d 4b04 	ldr.w	r4, [sp], #4
     93c:	4770      	bx	lr
     93e:	300c      	adds	r0, #12
     940:	e7f0      	b.n	924 <USART_ITConfig+0x1c>
     942:	bf00      	nop

00000944 <USART_DMACmd>:
     944:	8a83      	ldrh	r3, [r0, #20]
     946:	b29b      	uxth	r3, r3
     948:	b91a      	cbnz	r2, 952 <USART_DMACmd+0xe>
     94a:	ea23 0101 	bic.w	r1, r3, r1
     94e:	8281      	strh	r1, [r0, #20]
     950:	4770      	bx	lr
     952:	4319      	orrs	r1, r3
     954:	8281      	strh	r1, [r0, #20]
     956:	4770      	bx	lr

00000958 <USART_SetAddress>:
     958:	8a03      	ldrh	r3, [r0, #16]
     95a:	f023 030f 	bic.w	r3, r3, #15
     95e:	041b      	lsls	r3, r3, #16
     960:	0c1b      	lsrs	r3, r3, #16
     962:	8203      	strh	r3, [r0, #16]
     964:	8a03      	ldrh	r3, [r0, #16]
     966:	b29b      	uxth	r3, r3
     968:	4319      	orrs	r1, r3
     96a:	8201      	strh	r1, [r0, #16]
     96c:	4770      	bx	lr
     96e:	bf00      	nop

00000970 <USART_WakeUpConfig>:
     970:	8983      	ldrh	r3, [r0, #12]
     972:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
     976:	041b      	lsls	r3, r3, #16
     978:	0c1b      	lsrs	r3, r3, #16
     97a:	8183      	strh	r3, [r0, #12]
     97c:	8983      	ldrh	r3, [r0, #12]
     97e:	b29b      	uxth	r3, r3
     980:	4319      	orrs	r1, r3
     982:	8181      	strh	r1, [r0, #12]
     984:	4770      	bx	lr
     986:	bf00      	nop

00000988 <USART_ReceiverWakeUpCmd>:
     988:	8983      	ldrh	r3, [r0, #12]
     98a:	b929      	cbnz	r1, 998 <USART_ReceiverWakeUpCmd+0x10>
     98c:	f023 0302 	bic.w	r3, r3, #2
     990:	041b      	lsls	r3, r3, #16
     992:	0c1b      	lsrs	r3, r3, #16
     994:	8183      	strh	r3, [r0, #12]
     996:	4770      	bx	lr
     998:	b29b      	uxth	r3, r3
     99a:	f043 0302 	orr.w	r3, r3, #2
     99e:	8183      	strh	r3, [r0, #12]
     9a0:	4770      	bx	lr
     9a2:	bf00      	nop

000009a4 <USART_LINBreakDetectLengthConfig>:
     9a4:	8a03      	ldrh	r3, [r0, #16]
     9a6:	f023 0320 	bic.w	r3, r3, #32
     9aa:	041b      	lsls	r3, r3, #16
     9ac:	0c1b      	lsrs	r3, r3, #16
     9ae:	8203      	strh	r3, [r0, #16]
     9b0:	8a03      	ldrh	r3, [r0, #16]
     9b2:	b29b      	uxth	r3, r3
     9b4:	4319      	orrs	r1, r3
     9b6:	8201      	strh	r1, [r0, #16]
     9b8:	4770      	bx	lr
     9ba:	bf00      	nop

000009bc <USART_LINCmd>:
     9bc:	8a03      	ldrh	r3, [r0, #16]
     9be:	b929      	cbnz	r1, 9cc <USART_LINCmd+0x10>
     9c0:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
     9c4:	041b      	lsls	r3, r3, #16
     9c6:	0c1b      	lsrs	r3, r3, #16
     9c8:	8203      	strh	r3, [r0, #16]
     9ca:	4770      	bx	lr
     9cc:	b29b      	uxth	r3, r3
     9ce:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
     9d2:	8203      	strh	r3, [r0, #16]
     9d4:	4770      	bx	lr
     9d6:	bf00      	nop

000009d8 <USART_SendData>:
     9d8:	f3c1 0108 	ubfx	r1, r1, #0, #9
     9dc:	8081      	strh	r1, [r0, #4]
     9de:	4770      	bx	lr

000009e0 <USART_ReceiveData>:
     9e0:	8880      	ldrh	r0, [r0, #4]
     9e2:	f3c0 0008 	ubfx	r0, r0, #0, #9
     9e6:	4770      	bx	lr

000009e8 <USART_SendBreak>:
     9e8:	8983      	ldrh	r3, [r0, #12]
     9ea:	b29b      	uxth	r3, r3
     9ec:	f043 0301 	orr.w	r3, r3, #1
     9f0:	8183      	strh	r3, [r0, #12]
     9f2:	4770      	bx	lr

000009f4 <USART_SetGuardTime>:
     9f4:	8b03      	ldrh	r3, [r0, #24]
     9f6:	b2db      	uxtb	r3, r3
     9f8:	8303      	strh	r3, [r0, #24]
     9fa:	8b03      	ldrh	r3, [r0, #24]
     9fc:	b29b      	uxth	r3, r3
     9fe:	ea43 2101 	orr.w	r1, r3, r1, lsl #8
     a02:	8301      	strh	r1, [r0, #24]
     a04:	4770      	bx	lr
     a06:	bf00      	nop

00000a08 <USART_SetPrescaler>:
     a08:	8b03      	ldrh	r3, [r0, #24]
     a0a:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
     a0e:	8303      	strh	r3, [r0, #24]
     a10:	8b03      	ldrh	r3, [r0, #24]
     a12:	b29b      	uxth	r3, r3
     a14:	4319      	orrs	r1, r3
     a16:	8301      	strh	r1, [r0, #24]
     a18:	4770      	bx	lr
     a1a:	bf00      	nop

00000a1c <USART_SmartCardCmd>:
     a1c:	8a83      	ldrh	r3, [r0, #20]
     a1e:	b929      	cbnz	r1, a2c <USART_SmartCardCmd+0x10>
     a20:	f023 0320 	bic.w	r3, r3, #32
     a24:	041b      	lsls	r3, r3, #16
     a26:	0c1b      	lsrs	r3, r3, #16
     a28:	8283      	strh	r3, [r0, #20]
     a2a:	4770      	bx	lr
     a2c:	b29b      	uxth	r3, r3
     a2e:	f043 0320 	orr.w	r3, r3, #32
     a32:	8283      	strh	r3, [r0, #20]
     a34:	4770      	bx	lr
     a36:	bf00      	nop

00000a38 <USART_SmartCardNACKCmd>:
     a38:	8a83      	ldrh	r3, [r0, #20]
     a3a:	b929      	cbnz	r1, a48 <USART_SmartCardNACKCmd+0x10>
     a3c:	f023 0310 	bic.w	r3, r3, #16
     a40:	041b      	lsls	r3, r3, #16
     a42:	0c1b      	lsrs	r3, r3, #16
     a44:	8283      	strh	r3, [r0, #20]
     a46:	4770      	bx	lr
     a48:	b29b      	uxth	r3, r3
     a4a:	f043 0310 	orr.w	r3, r3, #16
     a4e:	8283      	strh	r3, [r0, #20]
     a50:	4770      	bx	lr
     a52:	bf00      	nop

00000a54 <USART_HalfDuplexCmd>:
     a54:	8a83      	ldrh	r3, [r0, #20]
     a56:	b929      	cbnz	r1, a64 <USART_HalfDuplexCmd+0x10>
     a58:	f023 0308 	bic.w	r3, r3, #8
     a5c:	041b      	lsls	r3, r3, #16
     a5e:	0c1b      	lsrs	r3, r3, #16
     a60:	8283      	strh	r3, [r0, #20]
     a62:	4770      	bx	lr
     a64:	b29b      	uxth	r3, r3
     a66:	f043 0308 	orr.w	r3, r3, #8
     a6a:	8283      	strh	r3, [r0, #20]
     a6c:	4770      	bx	lr
     a6e:	bf00      	nop

00000a70 <USART_OverSampling8Cmd>:
     a70:	8983      	ldrh	r3, [r0, #12]
     a72:	b919      	cbnz	r1, a7c <USART_OverSampling8Cmd+0xc>
     a74:	f3c3 030e 	ubfx	r3, r3, #0, #15
     a78:	8183      	strh	r3, [r0, #12]
     a7a:	4770      	bx	lr
     a7c:	ea6f 4343 	mvn.w	r3, r3, lsl #17
     a80:	ea6f 4353 	mvn.w	r3, r3, lsr #17
     a84:	b29b      	uxth	r3, r3
     a86:	8183      	strh	r3, [r0, #12]
     a88:	4770      	bx	lr
     a8a:	bf00      	nop

00000a8c <USART_OneBitMethodCmd>:
     a8c:	8a83      	ldrh	r3, [r0, #20]
     a8e:	b929      	cbnz	r1, a9c <USART_OneBitMethodCmd+0x10>
     a90:	f423 6300 	bic.w	r3, r3, #2048	; 0x800
     a94:	041b      	lsls	r3, r3, #16
     a96:	0c1b      	lsrs	r3, r3, #16
     a98:	8283      	strh	r3, [r0, #20]
     a9a:	4770      	bx	lr
     a9c:	b29b      	uxth	r3, r3
     a9e:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
     aa2:	8283      	strh	r3, [r0, #20]
     aa4:	4770      	bx	lr
     aa6:	bf00      	nop

00000aa8 <USART_IrDAConfig>:
     aa8:	8a83      	ldrh	r3, [r0, #20]
     aaa:	f023 0304 	bic.w	r3, r3, #4
     aae:	041b      	lsls	r3, r3, #16
     ab0:	0c1b      	lsrs	r3, r3, #16
     ab2:	8283      	strh	r3, [r0, #20]
     ab4:	8a83      	ldrh	r3, [r0, #20]
     ab6:	b29b      	uxth	r3, r3
     ab8:	4319      	orrs	r1, r3
     aba:	8281      	strh	r1, [r0, #20]
     abc:	4770      	bx	lr
     abe:	bf00      	nop

00000ac0 <USART_IrDACmd>:
     ac0:	8a83      	ldrh	r3, [r0, #20]
     ac2:	b929      	cbnz	r1, ad0 <USART_IrDACmd+0x10>
     ac4:	f023 0302 	bic.w	r3, r3, #2
     ac8:	041b      	lsls	r3, r3, #16
     aca:	0c1b      	lsrs	r3, r3, #16
     acc:	8283      	strh	r3, [r0, #20]
     ace:	4770      	bx	lr
     ad0:	b29b      	uxth	r3, r3
     ad2:	f043 0302 	orr.w	r3, r3, #2
     ad6:	8283      	strh	r3, [r0, #20]
     ad8:	4770      	bx	lr
     ada:	bf00      	nop

00000adc <USART_GetFlagStatus>:
     adc:	8803      	ldrh	r3, [r0, #0]
     ade:	4219      	tst	r1, r3
     ae0:	bf0c      	ite	eq
     ae2:	2000      	moveq	r0, #0
     ae4:	2001      	movne	r0, #1
     ae6:	4770      	bx	lr

00000ae8 <USART_ClearFlag>:
     ae8:	43c9      	mvns	r1, r1
     aea:	b289      	uxth	r1, r1
     aec:	8001      	strh	r1, [r0, #0]
     aee:	4770      	bx	lr

00000af0 <USART_GetITStatus>:
     af0:	b410      	push	{r4}
     af2:	f3c1 1342 	ubfx	r3, r1, #5, #3
     af6:	2401      	movs	r4, #1
     af8:	f001 021f 	and.w	r2, r1, #31
     afc:	42a3      	cmp	r3, r4
     afe:	fa04 f202 	lsl.w	r2, r4, r2
     b02:	d017      	beq.n	b34 <USART_GetITStatus+0x44>
     b04:	2b02      	cmp	r3, #2
     b06:	bf0c      	ite	eq
     b08:	8a03      	ldrheq	r3, [r0, #16]
     b0a:	8a83      	ldrhne	r3, [r0, #20]
     b0c:	b29b      	uxth	r3, r3
     b0e:	4013      	ands	r3, r2
     b10:	8802      	ldrh	r2, [r0, #0]
     b12:	b292      	uxth	r2, r2
     b14:	b153      	cbz	r3, b2c <USART_GetITStatus+0x3c>
     b16:	0a09      	lsrs	r1, r1, #8
     b18:	2301      	movs	r3, #1
     b1a:	fa03 f101 	lsl.w	r1, r3, r1
     b1e:	4211      	tst	r1, r2
     b20:	bf0c      	ite	eq
     b22:	2000      	moveq	r0, #0
     b24:	2001      	movne	r0, #1
     b26:	f85d 4b04 	ldr.w	r4, [sp], #4
     b2a:	4770      	bx	lr
     b2c:	4618      	mov	r0, r3
     b2e:	f85d 4b04 	ldr.w	r4, [sp], #4
     b32:	4770      	bx	lr
     b34:	8983      	ldrh	r3, [r0, #12]
     b36:	b29b      	uxth	r3, r3
     b38:	4013      	ands	r3, r2
     b3a:	e7e9      	b.n	b10 <USART_GetITStatus+0x20>

00000b3c <USART_ClearITPendingBit>:
     b3c:	0a09      	lsrs	r1, r1, #8
     b3e:	2301      	movs	r3, #1
     b40:	408b      	lsls	r3, r1
     b42:	43db      	mvns	r3, r3
     b44:	b29b      	uxth	r3, r3
     b46:	8003      	strh	r3, [r0, #0]
     b48:	4770      	bx	lr
     b4a:	bf00      	nop

00000b4c <Reset_Handler>:
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	2100      	movs	r1, #0
  b	LoopCopyDataInit
     b4e:	f000 b804 	b.w	b5a <LoopCopyDataInit>

00000b52 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
     b52:	4b0b      	ldr	r3, [pc, #44]	; (b80 <LoopFillZerobss+0xe>)
	ldr	r3, [r3, r1]
     b54:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
     b56:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
     b58:	3104      	adds	r1, #4

00000b5a <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
     b5a:	480a      	ldr	r0, [pc, #40]	; (b84 <LoopFillZerobss+0x12>)
	ldr	r3, =_edata
     b5c:	4b0a      	ldr	r3, [pc, #40]	; (b88 <LoopFillZerobss+0x16>)
	adds	r2, r0, r1
     b5e:	1842      	adds	r2, r0, r1
	cmp	r2, r3
     b60:	429a      	cmp	r2, r3
	bcc	CopyDataInit
     b62:	f4ff aff6 	bcc.w	b52 <CopyDataInit>
	ldr	r2, =_sbss
     b66:	4a09      	ldr	r2, [pc, #36]	; (b8c <LoopFillZerobss+0x1a>)
	b	LoopFillZerobss
     b68:	f000 b803 	b.w	b72 <LoopFillZerobss>

00000b6c <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	2300      	movs	r3, #0
	str	r3, [r2], #4
     b6e:	f842 3b04 	str.w	r3, [r2], #4

00000b72 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
     b72:	4b07      	ldr	r3, [pc, #28]	; (b90 <LoopFillZerobss+0x1e>)
	cmp	r2, r3
     b74:	429a      	cmp	r2, r3
	bcc	FillZerobss
     b76:	f4ff aff9 	bcc.w	b6c <FillZerobss>
/* Call the application's entry point.*/
	bl	main
     b7a:	f000 fa5b 	bl	1034 <main>
	bx	lr
     b7e:	4770      	bx	lr
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	00007614 	andeq	r7, r0, r4, lsl r6
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	20000000 	andcs	r0, r0, r0
	ldr	r3, =_edata
     b88:	20000488 	andcs	r0, r0, r8, lsl #9
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	20000488 	andcs	r0, r0, r8, lsl #9
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	200005b4 			; <UNDEFINED> instruction: 0x200005b4

00000b94 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	f7ff bffe 	b.w	b94 <ADC1_2_IRQHandler>

00000b98 <nothingProc>:
}


/* dummy proc */
void nothingProc(void)
{
     b98:	4770      	bx	lr

00000b9a <usbStatusIn>:
    bDeviceState = ATTACHED;
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}

void usbStatusIn(void)
{
     b9a:	4770      	bx	lr

00000b9c <usbStatusOut>:
    return;
}

void usbStatusOut(void)
{
     b9c:	4770      	bx	lr

00000b9e <usbGetInterfaceSetting>:

RESULT usbGetInterfaceSetting(u8 interface, u8 altSetting)
{
    // alt setting 0 -> program RAM, alt setting 1 or higher -> FLASH
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
     b9e:	2803      	cmp	r0, #3
    }

    return USB_SUCCESS;
}
     ba0:	bf8c      	ite	hi
     ba2:	2002      	movhi	r0, #2
     ba4:	2000      	movls	r0, #0
     ba6:	4770      	bx	lr

00000ba8 <usbGetConfiguration>:
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	4770      	bx	lr
	...

00000bac <usbSetConfiguration>:
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	4b03      	ldr	r3, [pc, #12]	; (bbc <usbSetConfiguration+0x10>)
     bae:	681b      	ldr	r3, [r3, #0]
     bb0:	7a9b      	ldrb	r3, [r3, #10]
     bb2:	b113      	cbz	r3, bba <usbSetConfiguration+0xe>
        bDeviceState = CONFIGURED;
     bb4:	4b02      	ldr	r3, [pc, #8]	; (bc0 <usbSetConfiguration+0x14>)
     bb6:	2205      	movs	r2, #5
     bb8:	601a      	str	r2, [r3, #0]
     bba:	4770      	bx	lr
     bbc:	200005a8 	andcs	r0, r0, r8, lsr #11
     bc0:	200005b8 			; <UNDEFINED> instruction: 0x200005b8

00000bc4 <usbGetInterface>:
    }
}

void usbGetInterface(void)
{
     bc4:	4770      	bx	lr

00000bc6 <usbSetInterface>:
    /* nothing process */
}

void usbSetInterface(void)
{
     bc6:	4770      	bx	lr

00000bc8 <usbGetStatus>:
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	4770      	bx	lr

00000bca <usbClearFeature>:
    /* nothing process */
}

void usbClearFeature(void)
{
     bca:	4770      	bx	lr

00000bcc <usbSetEndpointFeature>:
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	4770      	bx	lr

00000bce <usbSetDeviceFeature>:
    /* nothing process */
}

void usbSetDeviceFeature(void)
{
     bce:	4770      	bx	lr

00000bd0 <usbSetDeviceAddress>:
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	4b01      	ldr	r3, [pc, #4]	; (bd8 <usbSetDeviceAddress+0x8>)
     bd2:	2204      	movs	r2, #4
     bd4:	601a      	str	r2, [r3, #0]
     bd6:	4770      	bx	lr
     bd8:	200005b8 			; <UNDEFINED> instruction: 0x200005b8

00000bdc <usbReset>:
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	b510      	push	{r4, lr}
    dfuUpdateByReset();
     bde:	f000 fd4d 	bl	167c <dfuUpdateByReset>

    pInformation->Current_Configuration = 0;
     be2:	4b21      	ldr	r3, [pc, #132]	; (c68 <usbReset+0x8c>)
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	4a21      	ldr	r2, [pc, #132]	; (c6c <usbReset+0x90>)

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be6:	681b      	ldr	r3, [r3, #0]
     be8:	2400      	movs	r4, #0
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     bea:	6812      	ldr	r2, [r2, #0]

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     bec:	729c      	strb	r4, [r3, #10]
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     bee:	79d2      	ldrb	r2, [r2, #7]
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	4620      	mov	r0, r4
void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     bf2:	725a      	strb	r2, [r3, #9]

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	4a1e      	ldr	r2, [pc, #120]	; (c70 <usbReset+0x94>)

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bf6:	4b1f      	ldr	r3, [pc, #124]	; (c74 <usbReset+0x98>)
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf8:	6014      	str	r4, [r2, #0]

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfa:	6819      	ldr	r1, [r3, #0]
     bfc:	f421 41ec 	bic.w	r1, r1, #30208	; 0x7600
     c00:	f021 0170 	bic.w	r1, r1, #112	; 0x70
     c04:	f441 7100 	orr.w	r1, r1, #512	; 0x200
     c08:	b289      	uxth	r1, r1
     c0a:	6019      	str	r1, [r3, #0]
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c0c:	6819      	ldr	r1, [r3, #0]
     c0e:	f421 41e0 	bic.w	r1, r1, #28672	; 0x7000
     c12:	f021 0140 	bic.w	r1, r1, #64	; 0x40
     c16:	b289      	uxth	r1, r1
     c18:	f081 0110 	eor.w	r1, r1, #16
     c1c:	6019      	str	r1, [r3, #0]

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c1e:	6811      	ldr	r1, [r2, #0]
     c20:	4b15      	ldr	r3, [pc, #84]	; (c78 <usbReset+0x9c>)
     c22:	b289      	uxth	r1, r1
     c24:	440b      	add	r3, r1
     c26:	005b      	lsls	r3, r3, #1
     c28:	2140      	movs	r1, #64	; 0x40
     c2a:	6019      	str	r1, [r3, #0]
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	6813      	ldr	r3, [r2, #0]
     c2e:	2280      	movs	r2, #128	; 0x80
     c30:	b29b      	uxth	r3, r3
     c32:	f103 5300 	add.w	r3, r3, #536870912	; 0x20000000
     c36:	f503 5340 	add.w	r3, r3, #12288	; 0x3000
     c3a:	005b      	lsls	r3, r3, #1
     c3c:	601a      	str	r2, [r3, #0]

    Clear_Status_Out(ENDP0);
     c3e:	f005 f821 	bl	5c84 <Clear_Status_Out>

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c42:	4b0e      	ldr	r3, [pc, #56]	; (c7c <usbReset+0xa0>)
     c44:	4620      	mov	r0, r4
     c46:	681b      	ldr	r3, [r3, #0]
     c48:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
     c4c:	f005 f872 	bl	5d34 <SetEPRxCount>
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	4620      	mov	r0, r4
     c52:	f005 f808 	bl	5c66 <SetEPRxValid>

    bDeviceState = ATTACHED;
     c56:	4b0a      	ldr	r3, [pc, #40]	; (c80 <usbReset+0xa4>)
     c58:	2201      	movs	r2, #1
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c5a:	4620      	mov	r0, r4
}
     c5c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	601a      	str	r2, [r3, #0]
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c62:	f005 bd09 	b.w	6678 <SetDeviceAddress>
     c66:	bf00      	nop
     c68:	200005a8 	andcs	r0, r0, r8, lsr #11
     c6c:	200002b4 			; <UNDEFINED> instruction: 0x200002b4
     c70:	40005c50 	andmi	r5, r0, r0, asr ip
     c74:	40005c00 	andmi	r5, r0, r0, lsl #24
     c78:	20003004 	andcs	r3, r0, r4
     c7c:	20000580 	andcs	r0, r0, r0, lsl #11
     c80:	200005b8 			; <UNDEFINED> instruction: 0x200005b8

00000c84 <usbDataSetup>:
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	b538      	push	{r3, r4, r5, lr}
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c86:	4b12      	ldr	r3, [pc, #72]	; (cd0 <usbDataSetup+0x4c>)
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c88:	4605      	mov	r5, r0
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8a:	681a      	ldr	r2, [r3, #0]
     c8c:	461c      	mov	r4, r3
     c8e:	7812      	ldrb	r2, [r2, #0]
     c90:	f002 027f 	and.w	r2, r2, #127	; 0x7f
     c94:	2a21      	cmp	r2, #33	; 0x21
     c96:	d119      	bne.n	ccc <usbDataSetup+0x48>
        if (dfuUpdateByRequest()) {
     c98:	f000 fd86 	bl	17a8 <dfuUpdateByRequest>
     c9c:	b1b0      	cbz	r0, ccc <usbDataSetup+0x48>
            // successfull state transition, handle the request
            switch (request) {
     c9e:	1e68      	subs	r0, r5, #1
     ca0:	2804      	cmp	r0, #4
     ca2:	d813      	bhi.n	ccc <usbDataSetup+0x48>
     ca4:	e8df f000 	tbb	[pc, r0]
     ca8:	12070503 	andne	r0, r7, #12582912	; 0xc00000
     cac:	4b090009 	blmi	240cd8 <_etext+0x2396c4>
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	e004      	b.n	cbc <usbDataSetup+0x38>
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
     cb2:	4b09      	ldr	r3, [pc, #36]	; (cd8 <usbDataSetup+0x54>)
                break;
     cb4:	e002      	b.n	cbc <usbDataSetup+0x38>
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
     cb6:	4b09      	ldr	r3, [pc, #36]	; (cdc <usbDataSetup+0x58>)
     cb8:	e000      	b.n	cbc <usbDataSetup+0x38>
                break;
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
     cba:	4b09      	ldr	r3, [pc, #36]	; (ce0 <usbDataSetup+0x5c>)
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	6822      	ldr	r2, [r4, #0]
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cbe:	2400      	movs	r4, #0
        (*CopyRoutine)(0);
     cc0:	4620      	mov	r0, r4
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cc2:	6193      	str	r3, [r2, #24]
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	8254      	strh	r4, [r2, #18]
        (*CopyRoutine)(0);
     cc6:	4798      	blx	r3

        return USB_SUCCESS;
     cc8:	4620      	mov	r0, r4
     cca:	bd38      	pop	{r3, r4, r5, pc}
    }

    return USB_UNSUPPORT;
     ccc:	2002      	movs	r0, #2
}
     cce:	bd38      	pop	{r3, r4, r5, pc}
     cd0:	200005a8 	andcs	r0, r0, r8, lsr #11
     cd4:	000016f1 	strdeq	r1, [r0], -r1	; <UNPREDICTABLE>
     cd8:	00001719 	andeq	r1, r0, r9, lsl r7
     cdc:	000016d9 	ldrdeq	r1, [r0], -r9
     ce0:	000016c1 	andeq	r1, r0, r1, asr #13

00000ce4 <usbGetDeviceDescriptor>:
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	4901      	ldr	r1, [pc, #4]	; (cec <usbGetDeviceDescriptor+0x8>)
     ce6:	f005 bac7 	b.w	6278 <Standard_GetDescriptorData>
     cea:	bf00      	nop
     cec:	20000158 	andcs	r0, r0, r8, asr r1

00000cf0 <usbGetConfigDescriptor>:
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	4901      	ldr	r1, [pc, #4]	; (cf8 <usbGetConfigDescriptor+0x8>)
     cf2:	f005 bac1 	b.w	6278 <Standard_GetDescriptorData>
     cf6:	bf00      	nop
     cf8:	200002b4 			; <UNDEFINED> instruction: 0x200002b4

00000cfc <usbGetStringDescriptor>:
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	4b05      	ldr	r3, [pc, #20]	; (d14 <usbGetStringDescriptor+0x18>)
     cfe:	681b      	ldr	r3, [r3, #0]
     d00:	789b      	ldrb	r3, [r3, #2]
    if (strIndex > STR_DESC_LEN) {
     d02:	2b07      	cmp	r3, #7
     d04:	d804      	bhi.n	d10 <usbGetStringDescriptor+0x14>
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d06:	4904      	ldr	r1, [pc, #16]	; (d18 <usbGetStringDescriptor+0x1c>)
     d08:	eb01 01c3 	add.w	r1, r1, r3, lsl #3
     d0c:	f005 bab4 	b.w	6278 <Standard_GetDescriptorData>
    }
}
     d10:	2000      	movs	r0, #0
     d12:	4770      	bx	lr
     d14:	200005a8 	andcs	r0, r0, r8, lsr #11
     d18:	200000a8 	andcs	r0, r0, r8, lsr #1

00000d1c <usbGetFunctionalDescriptor>:

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
     d1c:	4901      	ldr	r1, [pc, #4]	; (d24 <usbGetFunctionalDescriptor+0x8>)
     d1e:	f005 baab 	b.w	6278 <Standard_GetDescriptorData>
     d22:	bf00      	nop
     d24:	200000f4 	strdcs	r0, [r0], -r4

00000d28 <usbNoDataSetup>:

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	b508      	push	{r3, lr}
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2a:	4b08      	ldr	r3, [pc, #32]	; (d4c <usbNoDataSetup+0x24>)
     d2c:	681b      	ldr	r3, [r3, #0]
     d2e:	781b      	ldrb	r3, [r3, #0]
     d30:	f003 037f 	and.w	r3, r3, #127	; 0x7f
     d34:	2b21      	cmp	r3, #33	; 0x21
     d36:	d106      	bne.n	d46 <usbNoDataSetup+0x1e>
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	f000 fd36 	bl	17a8 <dfuUpdateByRequest>
     d3c:	2800      	cmp	r0, #0
            return USB_SUCCESS;
     d3e:	bf0c      	ite	eq
     d40:	2002      	moveq	r0, #2
     d42:	2000      	movne	r0, #0
     d44:	bd08      	pop	{r3, pc}
        }
    }
    return USB_UNSUPPORT;
     d46:	2002      	movs	r0, #2
}
     d48:	bd08      	pop	{r3, pc}
     d4a:	bf00      	nop
     d4c:	200005a8 	andcs	r0, r0, r8, lsr #11

00000d50 <setupUSB>:

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	b537      	push	{r0, r1, r2, r4, r5, lr}
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d52:	4814      	ldr	r0, [pc, #80]	; (da4 <setupUSB+0x54>)
     d54:	210c      	movs	r1, #12
     d56:	2200      	movs	r2, #0
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	4c13      	ldr	r4, [pc, #76]	; (da8 <setupUSB+0x58>)
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5a:	f000 f9ed 	bl	1138 <gpio_write_bit>
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d5e:	200c      	movs	r0, #12
     d60:	6825      	ldr	r5, [r4, #0]
     d62:	f000 fc29 	bl	15b8 <crMask>
     d66:	4028      	ands	r0, r5
     d68:	f440 3580 	orr.w	r5, r0, #65536	; 0x10000
     d6c:	6025      	str	r5, [r4, #0]
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d6e:	f44f 7380 	mov.w	r3, #256	; 0x100
     d72:	9301      	str	r3, [sp, #4]
     d74:	9b01      	ldr	r3, [sp, #4]
     d76:	b113      	cbz	r3, d7e <setupUSB+0x2e>
     d78:	9b01      	ldr	r3, [sp, #4]
     d7a:	3b01      	subs	r3, #1
     d7c:	e7f9      	b.n	d72 <setupUSB+0x22>
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d7e:	f000 fc2d 	bl	15dc <getFlashPageSize>
     d82:	4b0a      	ldr	r3, [pc, #40]	; (dac <setupUSB+0x5c>)
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	b2c2      	uxtb	r2, r0
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d86:	6018      	str	r0, [r3, #0]
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d88:	4b09      	ldr	r3, [pc, #36]	; (db0 <setupUSB+0x60>)
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8a:	f3c0 2007 	ubfx	r0, r0, #8, #8
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d8e:	f883 2029 	strb.w	r2, [r3, #41]	; 0x29
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d92:	f883 002a 	strb.w	r0, [r3, #42]	; 0x2a
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d96:	4b07      	ldr	r3, [pc, #28]	; (db4 <setupUSB+0x64>)
     d98:	715a      	strb	r2, [r3, #5]
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
     d9a:	7198      	strb	r0, [r3, #6]

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	f005 f894 	bl	5ec8 <USB_Init>
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	b003      	add	sp, #12
     da2:	bd30      	pop	{r4, r5, pc}
     da4:	40010800 	andmi	r0, r1, r0, lsl #16
     da8:	40010804 	andmi	r0, r1, r4, lsl #16
     dac:	20000488 	andcs	r0, r0, r8, lsl #9
     db0:	20000100 	andcs	r0, r0, r0, lsl #2
     db4:	2000013d 	andcs	r0, r0, sp, lsr r1

00000db8 <usbSuspend>:
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	4b04      	ldr	r3, [pc, #16]	; (dcc <usbSuspend+0x14>)
     dba:	681a      	ldr	r2, [r3, #0]
     dbc:	b292      	uxth	r2, r2
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dbe:	f042 020c 	orr.w	r2, r2, #12
     dc2:	601a      	str	r2, [r3, #0]

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	4b02      	ldr	r3, [pc, #8]	; (dd0 <usbSuspend+0x18>)
     dc6:	2203      	movs	r2, #3
     dc8:	601a      	str	r2, [r3, #0]
     dca:	4770      	bx	lr
     dcc:	40005c40 	andmi	r5, r0, r0, asr #24
     dd0:	200005b8 			; <UNDEFINED> instruction: 0x200005b8

00000dd4 <usbResumeInit>:
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	4b04      	ldr	r3, [pc, #16]	; (de8 <usbResumeInit+0x14>)
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd6:	f64f 72fb 	movw	r2, #65531	; 0xfffb
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dda:	6819      	ldr	r1, [r3, #0]
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     ddc:	400a      	ands	r2, r1
     dde:	601a      	str	r2, [r3, #0]

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	f44f 423f 	mov.w	r2, #48896	; 0xbf00
     de4:	601a      	str	r2, [r3, #0]
     de6:	4770      	bx	lr
     de8:	40005c40 	andmi	r5, r0, r0, asr #24

00000dec <usbResume>:
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	b510      	push	{r4, lr}
     dee:	4c1e      	ldr	r4, [pc, #120]	; (e68 <usbResume+0x7c>)
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	2807      	cmp	r0, #7
        ResumeS.eState = eResumeSetVal;
     df2:	bf18      	it	ne
     df4:	7020      	strbne	r0, [r4, #0]

    switch (ResumeS.eState) {
     df6:	7823      	ldrb	r3, [r4, #0]
     df8:	2b05      	cmp	r3, #5
     dfa:	d832      	bhi.n	e62 <usbResume+0x76>
     dfc:	e8df f003 	tbb	[pc, r3]
     e00:	0e0a0603 	cfmadd32eq	mvax0, mvfx0, mvfx10, mvfx3
     e04:	f7ff2116 			; <UNDEFINED> instruction: 0xf7ff2116
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	ffe5 e02a 	vaddl.u32	q15, d5, d26
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	f7ff ffe2 	bl	dd4 <usbResumeInit>
        ResumeS.eState = RESUME_START;
     e10:	2304      	movs	r3, #4
     e12:	e027      	b.n	e64 <usbResume+0x78>
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	2302      	movs	r3, #2
     e16:	7063      	strb	r3, [r4, #1]
        ResumeS.eState = RESUME_WAIT;
     e18:	2303      	movs	r3, #3
     e1a:	e023      	b.n	e64 <usbResume+0x78>
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	7863      	ldrb	r3, [r4, #1]
     e1e:	3b01      	subs	r3, #1
     e20:	b2db      	uxtb	r3, r3
     e22:	7063      	strb	r3, [r4, #1]
        if (ResumeS.bESOFcnt == 0)
     e24:	7863      	ldrb	r3, [r4, #1]
     e26:	b9f3      	cbnz	r3, e66 <usbResume+0x7a>
            ResumeS.eState = RESUME_START;
     e28:	2204      	movs	r2, #4
     e2a:	e017      	b.n	e5c <usbResume+0x70>
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	4b0f      	ldr	r3, [pc, #60]	; (e6c <usbResume+0x80>)
     e2e:	681a      	ldr	r2, [r3, #0]
     e30:	b292      	uxth	r2, r2
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e32:	f042 0210 	orr.w	r2, r2, #16
     e36:	601a      	str	r2, [r3, #0]
        ResumeS.eState = RESUME_ON;
     e38:	2305      	movs	r3, #5
     e3a:	7023      	strb	r3, [r4, #0]
        ResumeS.bESOFcnt = 10;
     e3c:	230a      	movs	r3, #10
     e3e:	7063      	strb	r3, [r4, #1]
        break;
     e40:	bd10      	pop	{r4, pc}
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e42:	7863      	ldrb	r3, [r4, #1]
     e44:	3b01      	subs	r3, #1
     e46:	b2db      	uxtb	r3, r3
     e48:	7063      	strb	r3, [r4, #1]
        if (ResumeS.bESOFcnt == 0) {
     e4a:	7863      	ldrb	r3, [r4, #1]
     e4c:	b95b      	cbnz	r3, e66 <usbResume+0x7a>
            wCNTR = _GetCNTR();
     e4e:	4a07      	ldr	r2, [pc, #28]	; (e6c <usbResume+0x80>)
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	f64f 73ef 	movw	r3, #65519	; 0xffef
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	6811      	ldr	r1, [r2, #0]
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e56:	400b      	ands	r3, r1
     e58:	6013      	str	r3, [r2, #0]
            ResumeS.eState = RESUME_OFF;
     e5a:	2206      	movs	r2, #6
     e5c:	4b02      	ldr	r3, [pc, #8]	; (e68 <usbResume+0x7c>)
     e5e:	701a      	strb	r2, [r3, #0]
     e60:	bd10      	pop	{r4, pc}
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e62:	2306      	movs	r3, #6
     e64:	7023      	strb	r3, [r4, #0]
     e66:	bd10      	pop	{r4, pc}
     e68:	2000048e 	andcs	r0, r0, lr, lsl #9
     e6c:	40005c40 	andmi	r5, r0, r0, asr #24

00000e70 <usbPowerOn>:
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	4b0d      	ldr	r3, [pc, #52]	; (ea8 <usbPowerOn+0x38>)
        break;
    }
}

RESULT usbPowerOn(void)
{
     e72:	b510      	push	{r4, lr}
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e74:	69da      	ldr	r2, [r3, #28]

    _SetCNTR(CNTR_FRES);
    _SetCNTR(0);
    _SetISTR(0);
     e76:	490d      	ldr	r1, [pc, #52]	; (eac <usbPowerOn+0x3c>)
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e78:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
     e7c:	61da      	str	r2, [r3, #28]

    _SetCNTR(CNTR_FRES);
     e7e:	f5a3 33d9 	sub.w	r3, r3, #111104	; 0x1b200
     e82:	f5a3 73e0 	sub.w	r3, r3, #448	; 0x1c0
    _SetCNTR(0);
     e86:	2400      	movs	r4, #0
RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;

    _SetCNTR(CNTR_FRES);
     e88:	2201      	movs	r2, #1
    _SetCNTR(0);
    _SetISTR(0);

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e8a:	4809      	ldr	r0, [pc, #36]	; (eb0 <usbPowerOn+0x40>)
RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;

    _SetCNTR(CNTR_FRES);
     e8c:	601a      	str	r2, [r3, #0]
    _SetCNTR(0);
     e8e:	601c      	str	r4, [r3, #0]
    _SetISTR(0);
     e90:	600c      	str	r4, [r1, #0]

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e92:	f44f 51e0 	mov.w	r1, #7168	; 0x1c00
     e96:	8001      	strh	r1, [r0, #0]
    _SetCNTR(wInterrupt_Mask);
     e98:	6019      	str	r1, [r3, #0]
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9a:	4806      	ldr	r0, [pc, #24]	; (eb4 <usbPowerOn+0x44>)
     e9c:	210c      	movs	r1, #12
     e9e:	f000 f94b 	bl	1138 <gpio_write_bit>
#endif
#endif

    return USB_SUCCESS;
}
     ea2:	4620      	mov	r0, r4
     ea4:	bd10      	pop	{r4, pc}
     ea6:	bf00      	nop
     ea8:	40021000 	andmi	r1, r2, r0
     eac:	40005c44 	andmi	r5, r0, r4, asr #24
     eb0:	200005ac 	andcs	r0, r0, ip, lsr #11
     eb4:	40010800 	andmi	r0, r1, r0, lsl #16

00000eb8 <usbPowerOff>:

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	4b0a      	ldr	r3, [pc, #40]	; (ee4 <usbPowerOff+0x2c>)
     eba:	2201      	movs	r2, #1
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	b510      	push	{r4, lr}
    _SetCNTR(CNTR_FRES);
     ebe:	601a      	str	r2, [r3, #0]
    _SetISTR(0);
     ec0:	4a09      	ldr	r2, [pc, #36]	; (ee8 <usbPowerOff+0x30>)
     ec2:	2400      	movs	r4, #0
     ec4:	6014      	str	r4, [r2, #0]
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec6:	2203      	movs	r2, #3
     ec8:	601a      	str	r2, [r3, #0]
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     eca:	4808      	ldr	r0, [pc, #32]	; (eec <usbPowerOff+0x34>)
     ecc:	4622      	mov	r2, r4
     ece:	210c      	movs	r1, #12
     ed0:	f000 f932 	bl	1138 <gpio_write_bit>
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	4b06      	ldr	r3, [pc, #24]	; (ef0 <usbPowerOff+0x38>)

    return USB_SUCCESS;
}
     ed6:	4620      	mov	r0, r4
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed8:	69da      	ldr	r2, [r3, #28]
     eda:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
     ede:	61da      	str	r2, [r3, #28]

    return USB_SUCCESS;
}
     ee0:	bd10      	pop	{r4, pc}
     ee2:	bf00      	nop
     ee4:	40005c40 	andmi	r5, r0, r0, asr #24
     ee8:	40005c44 	andmi	r5, r0, r4, asr #24
     eec:	40010800 	andmi	r0, r1, r0, lsl #16
     ef0:	40021000 	andmi	r1, r2, r0

00000ef4 <usbDsbBus>:
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	f7ff bfe0 	b.w	eb8 <usbPowerOff>

00000ef8 <usbEnbISR>:
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	b507      	push	{r0, r1, r2, lr}
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efa:	2314      	movs	r3, #20
     efc:	f88d 3004 	strb.w	r3, [sp, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	2300      	movs	r3, #0
     f02:	f88d 3005 	strb.w	r3, [sp, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f06:	f88d 3006 	strb.w	r3, [sp, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
     f0a:	a801      	add	r0, sp, #4
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	2301      	movs	r3, #1
     f0e:	f88d 3007 	strb.w	r3, [sp, #7]
    nvicInit(&NVIC_InitStructure);
     f12:	f000 fa9d 	bl	1450 <nvicInit>
}
     f16:	b003      	add	sp, #12
     f18:	f85d fb04 	ldr.w	pc, [sp], #4

00000f1c <usbInit>:

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	b510      	push	{r4, lr}
    dfuInit();
     f1e:	f000 fb69 	bl	15f4 <dfuInit>

    pInformation->Current_Configuration = 0;
     f22:	4b09      	ldr	r3, [pc, #36]	; (f48 <usbInit+0x2c>)
     f24:	2400      	movs	r4, #0
     f26:	681b      	ldr	r3, [r3, #0]
     f28:	729c      	strb	r4, [r3, #10]
    usbPowerOn();
     f2a:	f7ff ffa1 	bl	e70 <usbPowerOn>

    _SetISTR(0);
     f2e:	4b07      	ldr	r3, [pc, #28]	; (f4c <usbInit+0x30>)
    wInterrupt_Mask = ISR_MSK;
     f30:	4a07      	ldr	r2, [pc, #28]	; (f50 <usbInit+0x34>)
    dfuInit();

    pInformation->Current_Configuration = 0;
    usbPowerOn();

    _SetISTR(0);
     f32:	601c      	str	r4, [r3, #0]
    wInterrupt_Mask = ISR_MSK;
     f34:	f44f 433f 	mov.w	r3, #48896	; 0xbf00
     f38:	8013      	strh	r3, [r2, #0]
    _SetCNTR(wInterrupt_Mask);
     f3a:	4a06      	ldr	r2, [pc, #24]	; (f54 <usbInit+0x38>)
     f3c:	6013      	str	r3, [r2, #0]

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f3e:	f7ff ffdb 	bl	ef8 <usbEnbISR>
    bDeviceState = UNCONNECTED;
     f42:	4b05      	ldr	r3, [pc, #20]	; (f58 <usbInit+0x3c>)
     f44:	601c      	str	r4, [r3, #0]
     f46:	bd10      	pop	{r4, pc}
     f48:	200005a8 	andcs	r0, r0, r8, lsr #11
     f4c:	40005c44 	andmi	r5, r0, r4, asr #24
     f50:	200005ac 	andcs	r0, r0, ip, lsr #11
     f54:	40005c40 	andmi	r5, r0, r0, asr #24
     f58:	200005b8 			; <UNDEFINED> instruction: 0x200005b8

00000f5c <usbDsbISR>:
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	b507      	push	{r0, r1, r2, lr}
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f5e:	2314      	movs	r3, #20
     f60:	f88d 3004 	strb.w	r3, [sp, #4]
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	a801      	add	r0, sp, #4

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f66:	2300      	movs	r3, #0
     f68:	f88d 3005 	strb.w	r3, [sp, #5]
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	f88d 3006 	strb.w	r3, [sp, #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	f88d 3007 	strb.w	r3, [sp, #7]
    nvicInit(&NVIC_InitStructure);
     f74:	f000 fa6c 	bl	1450 <nvicInit>
}
     f78:	b003      	add	sp, #12
     f7a:	f85d fb04 	ldr.w	pc, [sp], #4
	...

00000f80 <USB_LP_CAN1_RX0_IRQHandler>:

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	b570      	push	{r4, r5, r6, lr}
    wIstr = _GetISTR();
     f82:	4c27      	ldr	r4, [pc, #156]	; (1020 <USB_LP_CAN1_RX0_IRQHandler+0xa0>)
     f84:	4d27      	ldr	r5, [pc, #156]	; (1024 <USB_LP_CAN1_RX0_IRQHandler+0xa4>)
     f86:	6823      	ldr	r3, [r4, #0]

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	4e27      	ldr	r6, [pc, #156]	; (1028 <USB_LP_CAN1_RX0_IRQHandler+0xa8>)
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8a:	b29b      	uxth	r3, r3
     f8c:	802b      	strh	r3, [r5, #0]

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f8e:	882a      	ldrh	r2, [r5, #0]
     f90:	8833      	ldrh	r3, [r6, #0]
     f92:	4013      	ands	r3, r2
     f94:	0418      	lsls	r0, r3, #16
     f96:	d501      	bpl.n	f9c <USB_LP_CAN1_RX0_IRQHandler+0x1c>
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	f004 feec 	bl	5d74 <CTR_LP>
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	882a      	ldrh	r2, [r5, #0]
     f9e:	8833      	ldrh	r3, [r6, #0]
     fa0:	4013      	ands	r3, r2
     fa2:	0559      	lsls	r1, r3, #21
     fa4:	d505      	bpl.n	fb2 <USB_LP_CAN1_RX0_IRQHandler+0x32>
        _SetISTR((u16)CLR_RESET);
     fa6:	f64f 33ff 	movw	r3, #64511	; 0xfbff
     faa:	6023      	str	r3, [r4, #0]
        Device_Property.Reset();
     fac:	4b1f      	ldr	r3, [pc, #124]	; (102c <USB_LP_CAN1_RX0_IRQHandler+0xac>)
     fae:	685b      	ldr	r3, [r3, #4]
     fb0:	4798      	blx	r3
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb2:	882a      	ldrh	r2, [r5, #0]
     fb4:	8833      	ldrh	r3, [r6, #0]
     fb6:	401a      	ands	r2, r3
     fb8:	0492      	lsls	r2, r2, #18
        _SetISTR((u16)CLR_ERR);
     fba:	bf44      	itt	mi
     fbc:	f64d 72ff 	movwmi	r2, #57343	; 0xdfff
     fc0:	6022      	strmi	r2, [r4, #0]
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc2:	882a      	ldrh	r2, [r5, #0]
     fc4:	4013      	ands	r3, r2
     fc6:	04d8      	lsls	r0, r3, #19
     fc8:	d505      	bpl.n	fd6 <USB_LP_CAN1_RX0_IRQHandler+0x56>
        _SetISTR((u16)CLR_WKUP);
     fca:	f64e 73ff 	movw	r3, #61439	; 0xefff
     fce:	6023      	str	r3, [r4, #0]
        usbResume(RESUME_EXTERNAL);
     fd0:	2000      	movs	r0, #0
     fd2:	f7ff ff0b 	bl	dec <usbResume>
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd6:	882a      	ldrh	r2, [r5, #0]
     fd8:	8833      	ldrh	r3, [r6, #0]
     fda:	4013      	ands	r3, r2
     fdc:	0519      	lsls	r1, r3, #20
     fde:	d504      	bpl.n	fea <USB_LP_CAN1_RX0_IRQHandler+0x6a>

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	f7ff feea 	bl	db8 <usbSuspend>
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	f24f 73ff 	movw	r3, #63487	; 0xf7ff
     fe8:	6023      	str	r3, [r4, #0]
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fea:	882a      	ldrh	r2, [r5, #0]
     fec:	8833      	ldrh	r3, [r6, #0]
     fee:	401a      	ands	r2, r3
     ff0:	0592      	lsls	r2, r2, #22
     ff2:	d507      	bpl.n	1004 <USB_LP_CAN1_RX0_IRQHandler+0x84>
        _SetISTR((u16)CLR_SOF);
     ff4:	f64f 52ff 	movw	r2, #65023	; 0xfdff
     ff8:	6022      	str	r2, [r4, #0]
        bIntPackSOF++;
     ffa:	4a0d      	ldr	r2, [pc, #52]	; (1030 <USB_LP_CAN1_RX0_IRQHandler+0xb0>)
     ffc:	7811      	ldrb	r1, [r2, #0]
     ffe:	3101      	adds	r1, #1
    1000:	b2c9      	uxtb	r1, r1
    1002:	7011      	strb	r1, [r2, #0]
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	882a      	ldrh	r2, [r5, #0]
    1006:	4013      	ands	r3, r2
    1008:	05db      	lsls	r3, r3, #23
    100a:	d507      	bpl.n	101c <USB_LP_CAN1_RX0_IRQHandler+0x9c>
        _SetISTR((u16)CLR_ESOF);
    100c:	f64f 63ff 	movw	r3, #65279	; 0xfeff
    1010:	6023      	str	r3, [r4, #0]
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1012:	2007      	movs	r0, #7
    }
#endif

}
    1014:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	f7ff bee8 	b.w	dec <usbResume>
    101c:	bd70      	pop	{r4, r5, r6, pc}
    101e:	bf00      	nop
    1020:	40005c44 	andmi	r5, r0, r4, asr #24
    1024:	2000048c 	andcs	r0, r0, ip, lsl #9
    1028:	200005ac 	andcs	r0, r0, ip, lsr #11
    102c:	20000014 	andcs	r0, r0, r4, lsl r0
    1030:	200005b4 			; <UNDEFINED> instruction: 0x200005b4

00001034 <main>:
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
    1034:	b530      	push	{r4, r5, lr}
    1036:	b085      	sub	sp, #20
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    1038:	f000 f992 	bl	1360 <systemReset>
    setupCLK();
    103c:	f000 f9b4 	bl	13a8 <setupCLK>
    setupLEDAndButton();
    1040:	f000 f9e2 	bl	1408 <setupLEDAndButton>
    setupUSB();
    1044:	f7ff fe84 	bl	d50 <setupUSB>
    setupFLASH();
    1048:	f000 f9e8 	bl	141c <setupFLASH>
    uartInit();
    104c:	f000 f944 	bl	12d8 <uartInit>
    usbReset();
    1050:	f7ff fdc4 	bl	bdc <usbReset>
	uart_printf("\nBootloader init...\n");
    1054:	482b      	ldr	r0, [pc, #172]	; (1104 <main+0xd0>)
    1056:	f000 f8cf 	bl	11f8 <uart_printf>

    if (readPin(GPIOB, 15) == 0x0)
    105a:	210f      	movs	r1, #15
    105c:	482a      	ldr	r0, [pc, #168]	; (1108 <main+0xd4>)
    105e:	f000 f876 	bl	114e <readPin>
    1062:	4604      	mov	r4, r0
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1064:	4829      	ldr	r0, [pc, #164]	; (110c <main+0xd8>)
    1066:	f000 f8c7 	bl	11f8 <uart_printf>
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    106a:	4929      	ldr	r1, [pc, #164]	; (1110 <main+0xdc>)
    106c:	2200      	movs	r2, #0
    106e:	a803      	add	r0, sp, #12
    1070:	f004 fd38 	bl	5ae4 <imageCheckFromAddress>
    1074:	4605      	mov	r5, r0
    
    debug_print("image check ret: %X\n", ret);
    1076:	4629      	mov	r1, r5
    1078:	4826      	ldr	r0, [pc, #152]	; (1114 <main+0xe0>)
	switch (ret)
    107a:	3d02      	subs	r5, #2
	uart_printf("checking chain...\n");
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    
    debug_print("image check ret: %X\n", ret);
    107c:	f000 f8bc 	bl	11f8 <uart_printf>
	switch (ret)
    1080:	2d03      	cmp	r5, #3
    1082:	d803      	bhi.n	108c <main+0x58>
    1084:	e8df f005 	tbb	[pc, r5]
    1088:	100c070e 	andne	r0, ip, lr, lsl #14

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
	bool no_user_jump = FALSE;
    108c:	f1d4 0401 	rsbs	r4, r4, #1
    1090:	bf38      	it	cc
    1092:	2400      	movcc	r4, #0
    1094:	e00c      	b.n	10b0 <main+0x7c>
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1096:	4820      	ldr	r0, [pc, #128]	; (1118 <main+0xe4>)
    1098:	f000 f8ae 	bl	11f8 <uart_printf>
			no_user_jump = FALSE;
    109c:	2400      	movs	r4, #0
			break;
    109e:	e007      	b.n	10b0 <main+0x7c>

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    10a0:	481e      	ldr	r0, [pc, #120]	; (111c <main+0xe8>)
    10a2:	e002      	b.n	10aa <main+0x76>
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    10a4:	481e      	ldr	r0, [pc, #120]	; (1120 <main+0xec>)
    10a6:	e000      	b.n	10aa <main+0x76>
			no_user_jump = TRUE;
			break;

		case kImageImageHashCalcFailed:
			uart_printf("Hash calculation failed... waiting in DFU\n");
    10a8:	481e      	ldr	r0, [pc, #120]	; (1124 <main+0xf0>)
    10aa:	f000 f8a5 	bl	11f8 <uart_printf>
			no_user_jump = TRUE;
    10ae:	2401      	movs	r4, #1
			break;
			
		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10b0:	2300      	movs	r3, #0
    10b2:	9300      	str	r3, [sp, #0]
    10b4:	481c      	ldr	r0, [pc, #112]	; (1128 <main+0xf4>)
    10b6:	210d      	movs	r1, #13
    10b8:	2205      	movs	r2, #5
    10ba:	f44f 23a0 	mov.w	r3, #327680	; 0x50000
    10be:	f000 f84f 	bl	1160 <strobePin>

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10c2:	2500      	movs	r5, #0
    10c4:	2d05      	cmp	r5, #5
    10c6:	dc12      	bgt.n	10ee <main+0xba>
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10c8:	2300      	movs	r3, #0
    10ca:	9300      	str	r3, [sp, #0]
    10cc:	4816      	ldr	r0, [pc, #88]	; (1128 <main+0xf4>)
    10ce:	210d      	movs	r1, #13
    10d0:	2201      	movs	r2, #1
    10d2:	f44f 1380 	mov.w	r3, #1048576	; 0x100000
    10d6:	f000 f843 	bl	1160 <strobePin>

		if (dfuUploadStarted()) 
    10da:	f000 fc8f 	bl	19fc <dfuUploadStarted>
    10de:	b120      	cbz	r0, 10ea <main+0xb6>
		{
			uart_printf("DFU finished upload\n");
    10e0:	4812      	ldr	r0, [pc, #72]	; (112c <main+0xf8>)
    10e2:	f000 f889 	bl	11f8 <uart_printf>
			dfuFinishUpload(); // systemHardReset from DFU once done
    10e6:	f000 fc8f 	bl	1a08 <dfuFinishUpload>
    10ea:	3501      	adds	r5, #1
    10ec:	e7ea      	b.n	10c4 <main+0x90>
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10ee:	2c00      	cmp	r4, #0
    10f0:	d1ea      	bne.n	10c8 <main+0x94>
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10f2:	480f      	ldr	r0, [pc, #60]	; (1130 <main+0xfc>)
    10f4:	f000 f880 	bl	11f8 <uart_printf>
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10f8:	480e      	ldr	r0, [pc, #56]	; (1134 <main+0x100>)
    10fa:	f000 f9f1 	bl	14e0 <jumpToUser>
	}
	
	return 0;// Added to please the compiler
    10fe:	4620      	mov	r0, r4
    1100:	b005      	add	sp, #20
    1102:	bd30      	pop	{r4, r5, pc}
    1104:	00006fb4 			; <UNDEFINED> instruction: 0x00006fb4
    1108:	40010c00 	andmi	r0, r1, r0, lsl #24
    110c:	00006fc9 	andeq	r6, r0, r9, asr #31
    1110:	08008000 	stmdaeq	r0, {pc}
    1114:	00006fdc 	ldrdeq	r6, [r0], -ip
    1118:	00006ff1 	strdeq	r6, [r0], -r1
    111c:	00006ffa 	strdeq	r6, [r0], -sl
    1120:	0000701e 	andeq	r7, r0, lr, lsl r0
    1124:	00007046 	andeq	r7, r0, r6, asr #32
    1128:	40011000 	andmi	r1, r1, r0
    112c:	00007071 	andeq	r7, r0, r1, ror r0
    1130:	00007086 	andeq	r7, r0, r6, lsl #1
    1134:	08008084 	stmdaeq	r0, {r2, r7, pc}

00001138 <gpio_write_bit>:
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1138:	2301      	movs	r3, #1
    113a:	fa03 f101 	lsl.w	r1, r3, r1
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    113e:	f1d2 0201 	rsbs	r2, r2, #1
    1142:	bf38      	it	cc
    1144:	2200      	movcc	r2, #0
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1146:	0113      	lsls	r3, r2, #4
    1148:	4099      	lsls	r1, r3
    114a:	6101      	str	r1, [r0, #16]
    114c:	4770      	bx	lr

0000114e <readPin>:
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    114e:	2201      	movs	r2, #1
    1150:	fa02 f101 	lsl.w	r1, r2, r1
    1154:	6883      	ldr	r3, [r0, #8]
    1156:	420b      	tst	r3, r1
        return TRUE;
    } else {
        return FALSE;
    }
}
    1158:	bf0c      	ite	eq
    115a:	2000      	moveq	r0, #0
    115c:	2001      	movne	r0, #1
    115e:	4770      	bx	lr

00001160 <strobePin>:

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    1164:	f89d a020 	ldrb.w	sl, [sp, #32]
    1168:	4614      	mov	r4, r2
    gpio_write_bit( bank,pin,1-onState);
    116a:	f1ca 0701 	rsb	r7, sl, #1
    116e:	b2ff      	uxtb	r7, r7
    1170:	463a      	mov	r2, r7
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1172:	4680      	mov	r8, r0
    1174:	4689      	mov	r9, r1
    1176:	461e      	mov	r6, r3
    gpio_write_bit( bank,pin,1-onState);
    1178:	f7ff ffde 	bl	1138 <gpio_write_bit>

    u32 c;
    while (count-- > 0) 
    117c:	b1b4      	cbz	r4, 11ac <strobePin+0x4c>
    117e:	4635      	mov	r5, r6
	{
        for (c = rate; c > 0; c--)
    1180:	b115      	cbz	r5, 1188 <strobePin+0x28>
		{
            asm volatile("nop");
    1182:	bf00      	nop
    gpio_write_bit( bank,pin,1-onState);

    u32 c;
    while (count-- > 0) 
	{
        for (c = rate; c > 0; c--)
    1184:	3d01      	subs	r5, #1
    1186:	e7fb      	b.n	1180 <strobePin+0x20>
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1188:	4640      	mov	r0, r8
    118a:	4649      	mov	r1, r9
    118c:	4652      	mov	r2, sl
    118e:	f7ff ffd3 	bl	1138 <gpio_write_bit>
		
        for (c = rate; c > 0; c--)
    1192:	4635      	mov	r5, r6
    1194:	b115      	cbz	r5, 119c <strobePin+0x3c>
		{
            asm volatile("nop");
    1196:	bf00      	nop
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
		
        for (c = rate; c > 0; c--)
    1198:	3d01      	subs	r5, #1
    119a:	e7fb      	b.n	1194 <strobePin+0x34>
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    119c:	4640      	mov	r0, r8
    119e:	4649      	mov	r1, r9
    11a0:	463a      	mov	r2, r7
    11a2:	3c01      	subs	r4, #1
    11a4:	f7ff ffc8 	bl	1138 <gpio_write_bit>
    11a8:	b2e4      	uxtb	r4, r4
    11aa:	e7e7      	b.n	117c <strobePin+0x1c>
    11ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

000011b0 <UU_PutChar>:

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    11b0:	8803      	ldrh	r3, [r0, #0]
    11b2:	061b      	lsls	r3, r3, #24
    11b4:	d5fc      	bpl.n	11b0 <UU_PutChar>
  USARTx->DR = ch;  
    11b6:	8081      	strh	r1, [r0, #4]
    11b8:	4770      	bx	lr

000011ba <UU_PutString>:
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11ba:	b538      	push	{r3, r4, r5, lr}
    11bc:	4605      	mov	r5, r0
    11be:	1e4c      	subs	r4, r1, #1
  while(*str != 0)
    11c0:	f814 1f01 	ldrb.w	r1, [r4, #1]!
    11c4:	b119      	cbz	r1, 11ce <UU_PutString+0x14>
  {
    UU_PutChar(USARTx, *str);
    11c6:	4628      	mov	r0, r5
    11c8:	f7ff fff2 	bl	11b0 <UU_PutChar>
    11cc:	e7f8      	b.n	11c0 <UU_PutString+0x6>
    str++;
  }
}
    11ce:	bd38      	pop	{r3, r4, r5, pc}

000011d0 <vprint>:

void vprint(const char *fmt, va_list argp)
{
    11d0:	b500      	push	{lr}
    11d2:	4603      	mov	r3, r0
    11d4:	b0b3      	sub	sp, #204	; 0xcc
    11d6:	460a      	mov	r2, r1
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11d8:	4668      	mov	r0, sp
    11da:	4619      	mov	r1, r3
    11dc:	f005 faea 	bl	67b4 <vsiprintf>
    11e0:	2800      	cmp	r0, #0
    11e2:	dd03      	ble.n	11ec <vprint+0x1c>
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11e4:	4803      	ldr	r0, [pc, #12]	; (11f4 <vprint+0x24>)
    11e6:	4669      	mov	r1, sp
    11e8:	f7ff ffe7 	bl	11ba <UU_PutString>

    }
}
    11ec:	b033      	add	sp, #204	; 0xcc
    11ee:	f85d fb04 	ldr.w	pc, [sp], #4
    11f2:	bf00      	nop
    11f4:	40013800 	andmi	r3, r1, r0, lsl #16

000011f8 <uart_printf>:

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11f8:	b40f      	push	{r0, r1, r2, r3}
    11fa:	b507      	push	{r0, r1, r2, lr}
    11fc:	a904      	add	r1, sp, #16
    11fe:	f851 0b04 	ldr.w	r0, [r1], #4
    va_list argp;
    va_start(argp, fmt);
    1202:	9101      	str	r1, [sp, #4]
    vprint(fmt, argp);
    1204:	f7ff ffe4 	bl	11d0 <vprint>
    va_end(argp);
}
    1208:	b003      	add	sp, #12
    120a:	f85d eb04 	ldr.w	lr, [sp], #4
    120e:	b004      	add	sp, #16
    1210:	4770      	bx	lr
	...

00001214 <hexdump>:

void hexdump(unsigned char *data, size_t size)
{
    1214:	b5f0      	push	{r4, r5, r6, r7, lr}
    1216:	b087      	sub	sp, #28
    1218:	4606      	mov	r6, r0
    121a:	460f      	mov	r7, r1
    int i;
    char cs[17];
    memset(cs, 0, 17);
    121c:	a801      	add	r0, sp, #4
    121e:	2100      	movs	r1, #0
    1220:	2211      	movs	r2, #17
    1222:	f005 faa6 	bl	6772 <memset>

    for(i = 0; i < size; i++)
    1226:	2400      	movs	r4, #0
    1228:	42bc      	cmp	r4, r7
    122a:	f004 050f 	and.w	r5, r4, #15
    122e:	d021      	beq.n	1274 <hexdump+0x60>
    {
        if(i != 0 && i % 0x10 == 0)
    1230:	b184      	cbz	r4, 1254 <hexdump+0x40>
    1232:	b94d      	cbnz	r5, 1248 <hexdump+0x34>
        {
            debug_print(" |%s|\n", cs);
    1234:	a901      	add	r1, sp, #4
    1236:	481a      	ldr	r0, [pc, #104]	; (12a0 <hexdump+0x8c>)
    1238:	f7ff ffde 	bl	11f8 <uart_printf>
            memset(cs, 0, 17);
    123c:	a801      	add	r0, sp, #4
    123e:	4629      	mov	r1, r5
    1240:	2211      	movs	r2, #17
    1242:	f005 fa96 	bl	6772 <memset>
    1246:	e005      	b.n	1254 <hexdump+0x40>
        }
        else if(i != 0 && i % 0x8 == 0)
    1248:	f014 0107 	ands.w	r1, r4, #7
    124c:	d102      	bne.n	1254 <hexdump+0x40>
        {
            debug_print(" ",0);
    124e:	4815      	ldr	r0, [pc, #84]	; (12a4 <hexdump+0x90>)
    1250:	f7ff ffd2 	bl	11f8 <uart_printf>
        }
        debug_print("%02X ", data[i]);
    1254:	5d31      	ldrb	r1, [r6, r4]
    1256:	4814      	ldr	r0, [pc, #80]	; (12a8 <hexdump+0x94>)
    1258:	f7ff ffce 	bl	11f8 <uart_printf>
        cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
    125c:	5d33      	ldrb	r3, [r6, r4]
{
    int i;
    char cs[17];
    memset(cs, 0, 17);

    for(i = 0; i < size; i++)
    125e:	3401      	adds	r4, #1
        else if(i != 0 && i % 0x8 == 0)
        {
            debug_print(" ",0);
        }
        debug_print("%02X ", data[i]);
        cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
    1260:	f1a3 0220 	sub.w	r2, r3, #32
    1264:	2a5e      	cmp	r2, #94	; 0x5e
    1266:	aa06      	add	r2, sp, #24
    1268:	bf88      	it	hi
    126a:	232e      	movhi	r3, #46	; 0x2e
    126c:	4415      	add	r5, r2
    126e:	f805 3c14 	strb.w	r3, [r5, #-20]
    1272:	e7d9      	b.n	1228 <hexdump+0x14>
    }

    i = i % 0x10;
    if(i != 0)
    1274:	b92d      	cbnz	r5, 1282 <hexdump+0x6e>
        while(i++ < 0x10)
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
    1276:	480a      	ldr	r0, [pc, #40]	; (12a0 <hexdump+0x8c>)
    1278:	a901      	add	r1, sp, #4
    127a:	f7ff ffbd 	bl	11f8 <uart_printf>
}
    127e:	b007      	add	sp, #28
    1280:	bdf0      	pop	{r4, r5, r6, r7, pc}
    }

    i = i % 0x10;
    if(i != 0)
    {
        if(i <= 0x8)
    1282:	2d08      	cmp	r5, #8
    1284:	dc03      	bgt.n	128e <hexdump+0x7a>
        {
            debug_print(" ",0);
    1286:	4807      	ldr	r0, [pc, #28]	; (12a4 <hexdump+0x90>)
    1288:	2100      	movs	r1, #0
    128a:	f7ff ffb5 	bl	11f8 <uart_printf>
        }
        while(i++ < 0x10)
    128e:	2d10      	cmp	r5, #16
    1290:	d0f1      	beq.n	1276 <hexdump+0x62>
        {
            debug_print("   ",0);
    1292:	4806      	ldr	r0, [pc, #24]	; (12ac <hexdump+0x98>)
    1294:	2100      	movs	r1, #0
    1296:	f7ff ffaf 	bl	11f8 <uart_printf>
    129a:	3501      	adds	r5, #1
    129c:	e7f7      	b.n	128e <hexdump+0x7a>
    129e:	bf00      	nop
    12a0:	00007096 	muleq	r0, r6, r0
    12a4:	000070a5 	andeq	r7, r0, r5, lsr #1
    12a8:	0000709d 	muleq	r0, sp, r0
    12ac:	000070a3 	andeq	r7, r0, r3, lsr #1

000012b0 <print_hash>:
    }
    debug_print(" |%s|\n", cs);
}

void print_hash(unsigned char hash[])
{
    12b0:	b538      	push	{r3, r4, r5, lr}
    12b2:	4605      	mov	r5, r0
   int idx;
   for (idx=0; idx < 32; idx++)
    12b4:	2400      	movs	r4, #0
      debug_print("%02x",hash[idx]);
    12b6:	5d29      	ldrb	r1, [r5, r4]
    12b8:	4805      	ldr	r0, [pc, #20]	; (12d0 <print_hash+0x20>)
}

void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
    12ba:	3401      	adds	r4, #1
      debug_print("%02x",hash[idx]);
    12bc:	f7ff ff9c 	bl	11f8 <uart_printf>
}

void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
    12c0:	2c20      	cmp	r4, #32
    12c2:	d1f8      	bne.n	12b6 <print_hash+0x6>
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12c4:	4803      	ldr	r0, [pc, #12]	; (12d4 <print_hash+0x24>)
    12c6:	2100      	movs	r1, #0
}
    12c8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12cc:	f7ff bf94 	b.w	11f8 <uart_printf>
    12d0:	000070a7 	andeq	r7, r0, r7, lsr #1
    12d4:	000070c8 	andeq	r7, r0, r8, asr #1

000012d8 <uartInit>:
}

#endif
void uartInit(void) {
    12d8:	b510      	push	{r4, lr}
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    12da:	4c20      	ldr	r4, [pc, #128]	; (135c <uartInit+0x84>)
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
}

#endif
void uartInit(void) {
    12dc:	b086      	sub	sp, #24
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    12de:	f44f 4080 	mov.w	r0, #16384	; 0x4000
    12e2:	2101      	movs	r1, #1
    12e4:	f7ff f9b4 	bl	650 <RCC_APB2PeriphClockCmd>
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    12e8:	4620      	mov	r0, r4
    12ea:	2101      	movs	r1, #1
    12ec:	f7ff f9b0 	bl	650 <RCC_APB2PeriphClockCmd>
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    12f0:	f44f 7300 	mov.w	r3, #512	; 0x200
    12f4:	f8ad 3004 	strh.w	r3, [sp, #4]
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    12f8:	2303      	movs	r3, #3
    12fa:	f88d 3006 	strb.w	r3, [sp, #6]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    12fe:	4620      	mov	r0, r4
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1300:	2318      	movs	r3, #24
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1302:	a901      	add	r1, sp, #4
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1304:	f88d 3007 	strb.w	r3, [sp, #7]
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1308:	f7fe ff6c 	bl	1e4 <GPIO_Init>
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    130c:	f44f 6380 	mov.w	r3, #1024	; 0x400
    1310:	f8ad 3004 	strh.w	r3, [sp, #4]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1314:	2304      	movs	r3, #4
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1316:	eb0d 0103 	add.w	r1, sp, r3
    131a:	4620      	mov	r0, r4
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    131c:	f88d 3007 	strb.w	r3, [sp, #7]
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1320:	f7fe ff60 	bl	1e4 <GPIO_Init>
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1324:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
    1328:	9302      	str	r3, [sp, #8]
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    132a:	f504 5440 	add.w	r4, r4, #12288	; 0x3000
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    132e:	2300      	movs	r3, #0
    1330:	f8ad 300c 	strh.w	r3, [sp, #12]
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1334:	f8ad 300e 	strh.w	r3, [sp, #14]
    USART_InitStructure.USART_Parity = USART_Parity_No;
    1338:	f8ad 3010 	strh.w	r3, [sp, #16]
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    133c:	f8ad 3014 	strh.w	r3, [sp, #20]
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1340:	a902      	add	r1, sp, #8
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    1342:	230c      	movs	r3, #12
        
    USART_Init(USART1, &USART_InitStructure);
    1344:	4620      	mov	r0, r4
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    1346:	f8ad 3012 	strh.w	r3, [sp, #18]
        
    USART_Init(USART1, &USART_InitStructure);
    134a:	f7ff fa4d 	bl	7e8 <USART_Init>
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    134e:	4620      	mov	r0, r4
    1350:	2101      	movs	r1, #1
    1352:	f7ff facb 	bl	8ec <USART_Cmd>
}
    1356:	b006      	add	sp, #24
    1358:	bd10      	pop	{r4, pc}
    135a:	bf00      	nop
    135c:	40010800 	andmi	r0, r1, r0, lsl #16

00001360 <systemReset>:

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    1360:	4b0d      	ldr	r3, [pc, #52]	; (1398 <systemReset+0x38>)
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    1362:	490e      	ldr	r1, [pc, #56]	; (139c <systemReset+0x3c>)
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
}

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    1364:	681a      	ldr	r2, [r3, #0]
    1366:	f042 0201 	orr.w	r2, r2, #1
    136a:	601a      	str	r2, [r3, #0]
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    136c:	4a0c      	ldr	r2, [pc, #48]	; (13a0 <systemReset+0x40>)
    136e:	6810      	ldr	r0, [r2, #0]
    1370:	4001      	ands	r1, r0
    1372:	6011      	str	r1, [r2, #0]
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    1374:	6819      	ldr	r1, [r3, #0]
    1376:	f021 7184 	bic.w	r1, r1, #17301504	; 0x1080000
    137a:	f421 3180 	bic.w	r1, r1, #65536	; 0x10000
    137e:	6019      	str	r1, [r3, #0]
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    1380:	6819      	ldr	r1, [r3, #0]
    1382:	f421 2180 	bic.w	r1, r1, #262144	; 0x40000
    1386:	6019      	str	r1, [r3, #0]
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    1388:	6813      	ldr	r3, [r2, #0]
    138a:	f423 03fe 	bic.w	r3, r3, #8323072	; 0x7f0000
    138e:	6013      	str	r3, [r2, #0]

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    1390:	4b04      	ldr	r3, [pc, #16]	; (13a4 <systemReset+0x44>)
    1392:	2200      	movs	r2, #0
    1394:	601a      	str	r2, [r3, #0]
    1396:	4770      	bx	lr
    1398:	40021000 	andmi	r1, r2, r0
    139c:	f8ff0000 			; <UNDEFINED> instruction: 0xf8ff0000
    13a0:	40021004 	andmi	r1, r2, r4
    13a4:	40021008 	andmi	r1, r2, r8

000013a8 <setupCLK>:
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    13a8:	4b15      	ldr	r3, [pc, #84]	; (1400 <setupCLK+0x58>)
    13aa:	681a      	ldr	r2, [r3, #0]
    13ac:	f042 1201 	orr.w	r2, r2, #65537	; 0x10001
    13b0:	601a      	str	r2, [r3, #0]
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    13b2:	681a      	ldr	r2, [r3, #0]
    13b4:	4812      	ldr	r0, [pc, #72]	; (1400 <setupCLK+0x58>)
    13b6:	0392      	lsls	r2, r2, #14
    13b8:	d5fb      	bpl.n	13b2 <setupCLK+0xa>

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    13ba:	4a12      	ldr	r2, [pc, #72]	; (1404 <setupCLK+0x5c>)
    13bc:	2112      	movs	r1, #18
    13be:	6011      	str	r1, [r2, #0]
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    13c0:	f6a2 72fc 	subw	r2, r2, #4092	; 0xffc
    13c4:	6811      	ldr	r1, [r2, #0]
    13c6:	f441 11e8 	orr.w	r1, r1, #1900544	; 0x1d0000
    13ca:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
    13ce:	6011      	str	r1, [r2, #0]
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    13d0:	6801      	ldr	r1, [r0, #0]
    13d2:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
    13d6:	6001      	str	r1, [r0, #0]

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    13d8:	6819      	ldr	r1, [r3, #0]
    13da:	f011 7f40 	tst.w	r1, #50331648	; 0x3000000
    13de:	d0fb      	beq.n	13d8 <setupCLK+0x30>
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    13e0:	6811      	ldr	r1, [r2, #0]
    13e2:	f041 0102 	orr.w	r1, r1, #2
    13e6:	6011      	str	r1, [r2, #0]
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    13e8:	6811      	ldr	r1, [r2, #0]
    13ea:	0709      	lsls	r1, r1, #28
    13ec:	d5fc      	bpl.n	13e8 <setupCLK+0x40>
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    13ee:	699a      	ldr	r2, [r3, #24]
    13f0:	f442 72fe 	orr.w	r2, r2, #508	; 0x1fc
    13f4:	619a      	str	r2, [r3, #24]
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    13f6:	69da      	ldr	r2, [r3, #28]
    13f8:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
    13fc:	61da      	str	r2, [r3, #28]
    13fe:	4770      	bx	lr
    1400:	40021000 	andmi	r1, r2, r0
    1404:	40022000 	andmi	r2, r2, r0

00001408 <setupLEDAndButton>:

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    1408:	4b03      	ldr	r3, [pc, #12]	; (1418 <setupLEDAndButton+0x10>)
    140a:	681a      	ldr	r2, [r3, #0]
    140c:	f422 0270 	bic.w	r2, r2, #15728640	; 0xf00000
    1410:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
    1414:	601a      	str	r2, [r3, #0]
    1416:	4770      	bx	lr
    1418:	40011004 	andmi	r1, r1, r4

0000141c <setupFLASH>:
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    141c:	4b05      	ldr	r3, [pc, #20]	; (1434 <setupFLASH+0x18>)
    141e:	681a      	ldr	r2, [r3, #0]
    1420:	07d1      	lsls	r1, r2, #31
    1422:	d403      	bmi.n	142c <setupFLASH+0x10>
        u32 rwmVal = pRCC->CR;
    1424:	681a      	ldr	r2, [r3, #0]
        rwmVal |= 0x01;
    1426:	f042 0201 	orr.w	r2, r2, #1
        pRCC->CR = rwmVal;
    142a:	601a      	str	r2, [r3, #0]
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    142c:	681a      	ldr	r2, [r3, #0]
    142e:	0792      	lsls	r2, r2, #30
    1430:	d5fc      	bpl.n	142c <setupFLASH+0x10>
}   
    1432:	4770      	bx	lr
    1434:	40021000 	andmi	r1, r2, r0

00001438 <setMspAndJump>:
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    1438:	4a04      	ldr	r2, [pc, #16]	; (144c <setMspAndJump+0x14>)
    id->off4 = MMIO32(U_ID + 0x4);
    id->off8 = MMIO32(U_ID + 0x8);
  }
}

void setMspAndJump(u32 usrAddr) {
    143a:	b508      	push	{r3, lr}
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    143c:	6843      	ldr	r3, [r0, #4]

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    143e:	6010      	str	r0, [r2, #0]

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1440:	6802      	ldr	r2, [r0, #0]

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1442:	f382 8808 	msr	MSP, r2
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    1446:	4798      	blx	r3
    1448:	bd08      	pop	{r3, pc}
    144a:	bf00      	nop
    144c:	e000ed08 	and	lr, r0, r8, lsl #26

00001450 <nvicInit>:
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    1450:	4b18      	ldr	r3, [pc, #96]	; (14b4 <nvicInit+0x64>)
		pRCC->APB1ENR &= ~(RCC_APB1ENR_PWR_CLK | RCC_APB1ENR_BKP_CLK);
	}
    return flagSet;
}

void nvicInit(NVIC_InitTypeDef *NVIC_InitStruct) {
    1452:	b530      	push	{r4, r5, lr}
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    1454:	68db      	ldr	r3, [r3, #12]
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    1456:	7844      	ldrb	r4, [r0, #1]
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    1458:	43db      	mvns	r3, r3
    145a:	f3c3 2302 	ubfx	r3, r3, #8, #3
    tmppre = (0x4 - tmppriority);
    145e:	f1c3 0204 	rsb	r2, r3, #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    1462:	fa04 f202 	lsl.w	r2, r4, r2


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    1466:	240f      	movs	r4, #15
    1468:	40dc      	lsrs	r4, r3

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    146a:	7881      	ldrb	r1, [r0, #2]

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    146c:	7803      	ldrb	r3, [r0, #0]
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    146e:	400c      	ands	r4, r1
    1470:	4314      	orrs	r4, r2

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1472:	f003 0103 	and.w	r1, r3, #3
    1476:	00c9      	lsls	r1, r1, #3
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    1478:	0124      	lsls	r4, r4, #4
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    147a:	22ff      	movs	r2, #255	; 0xff

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    147c:	408c      	lsls	r4, r1

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    147e:	408a      	lsls	r2, r1
    1480:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
    1484:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
    1488:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    148c:	f8d3 5300 	ldr.w	r5, [r3, #768]	; 0x300
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    1490:	ea25 0102 	bic.w	r1, r5, r2
    tmppriority &= tmpmask;
    1494:	4022      	ands	r2, r4
    tmpreg |= tmppriority;
    1496:	430a      	orrs	r2, r1

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    1498:	f8c3 2300 	str.w	r2, [r3, #768]	; 0x300

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    149c:	7803      	ldrb	r3, [r0, #0]
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    149e:	2201      	movs	r2, #1
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    14a0:	0959      	lsrs	r1, r3, #5
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    14a2:	f003 031f 	and.w	r3, r3, #31
    14a6:	fa02 f303 	lsl.w	r3, r2, r3
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    14aa:	4a03      	ldr	r2, [pc, #12]	; (14b8 <nvicInit+0x68>)
    14ac:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
    14b0:	bd30      	pop	{r4, r5, pc}
    14b2:	bf00      	nop
    14b4:	e000ed00 	and	lr, r0, r0, lsl #26
    14b8:	e000e100 	and	lr, r0, r0, lsl #2

000014bc <nvicDisableInterrupts>:
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    14bc:	4b07      	ldr	r3, [pc, #28]	; (14dc <nvicDisableInterrupts+0x20>)
    14be:	f04f 32ff 	mov.w	r2, #4294967295
    14c2:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    rNVIC->ICER[1] = 0xFFFFFFFF;
    14c6:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    14ca:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    14ce:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    14d2:	2204      	movs	r2, #4
    14d4:	f843 2cf0 	str.w	r2, [r3, #-240]
    14d8:	4770      	bx	lr
    14da:	bf00      	nop
    14dc:	e000e100 	and	lr, r0, r0, lsl #2

000014e0 <jumpToUser>:

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    14e0:	b510      	push	{r4, lr}
    14e2:	4604      	mov	r4, r0
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    14e4:	f7ff fd3a 	bl	f5c <usbDsbISR>
    nvicDisableInterrupts();
    14e8:	f7ff ffe8 	bl	14bc <nvicDisableInterrupts>
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    14ec:	f7ff fd02 	bl	ef4 <usbDsbBus>
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    14f0:	f7ff ff36 	bl	1360 <systemReset>
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14f4:	4620      	mov	r0, r4
}
    14f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14fa:	f7ff bf9d 	b.w	1438 <setMspAndJump>
	...

00001500 <systemHardReset>:

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1500:	4a02      	ldr	r2, [pc, #8]	; (150c <systemHardReset+0xc>)
    1502:	4b03      	ldr	r3, [pc, #12]	; (1510 <systemHardReset+0x10>)
    1504:	60da      	str	r2, [r3, #12]

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    1506:	bf00      	nop
    1508:	e7fd      	b.n	1506 <systemHardReset+0x6>
    150a:	bf00      	nop
    150c:	05fa0004 	ldrbeq	r0, [sl, #4]!
    1510:	e000ed00 	and	lr, r0, r0, lsl #26

00001514 <flashErasePage>:
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1514:	4b0a      	ldr	r3, [pc, #40]	; (1540 <flashErasePage+0x2c>)
    while (1) {
        asm volatile("nop");
    }
}

bool flashErasePage(u32 pageAddr) {
    1516:	b510      	push	{r4, lr}
    u32 rwmVal = GET_REG(FLASH_CR);
    1518:	681a      	ldr	r2, [r3, #0]
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    151a:	2202      	movs	r2, #2
    151c:	601a      	str	r2, [r3, #0]

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    151e:	4a09      	ldr	r2, [pc, #36]	; (1544 <flashErasePage+0x30>)
    1520:	6811      	ldr	r1, [r2, #0]
    1522:	4614      	mov	r4, r2
    1524:	f011 0f01 	tst.w	r1, #1
    1528:	d1f9      	bne.n	151e <flashErasePage+0xa>
    SET_REG(FLASH_AR, pageAddr);
    152a:	6090      	str	r0, [r2, #8]
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    152c:	2242      	movs	r2, #66	; 0x42
    152e:	601a      	str	r2, [r3, #0]
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1530:	6822      	ldr	r2, [r4, #0]
    1532:	f012 0101 	ands.w	r1, r2, #1
    1536:	d1fb      	bne.n	1530 <flashErasePage+0x1c>

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    1538:	6019      	str	r1, [r3, #0]

    return TRUE;
}
    153a:	2001      	movs	r0, #1
    153c:	bd10      	pop	{r4, pc}
    153e:	bf00      	nop
    1540:	40022010 	andmi	r2, r2, r0, lsl r0
    1544:	4002200c 	andmi	r2, r2, ip

00001548 <flashWriteWord>:
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    1548:	b537      	push	{r0, r1, r2, r4, r5, lr}
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    154a:	b28b      	uxth	r3, r1
    154c:	9300      	str	r3, [sp, #0]
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    154e:	0c0b      	lsrs	r3, r1, #16
    1550:	9301      	str	r3, [sp, #4]

    u32 rwmVal = GET_REG(FLASH_CR);
    1552:	4b0e      	ldr	r3, [pc, #56]	; (158c <flashWriteWord+0x44>)
    SET_REG(FLASH_CR, FLASH_CR_PG);
    1554:	2201      	movs	r2, #1
bool flashWriteWord(u32 addr, u32 word) {
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;

    u32 rwmVal = GET_REG(FLASH_CR);
    1556:	681c      	ldr	r4, [r3, #0]
    SET_REG(FLASH_CR, FLASH_CR_PG);
    1558:	601a      	str	r2, [r3, #0]

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    155a:	4a0d      	ldr	r2, [pc, #52]	; (1590 <flashWriteWord+0x48>)
    155c:	6815      	ldr	r5, [r2, #0]
    155e:	07ed      	lsls	r5, r5, #31
    1560:	d4fb      	bmi.n	155a <flashWriteWord+0x12>
    *(flashAddr + 0x01) = (vu16)hhWord;
    1562:	9d01      	ldr	r5, [sp, #4]
    1564:	b2ad      	uxth	r5, r5
    1566:	8045      	strh	r5, [r0, #2]
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1568:	6815      	ldr	r5, [r2, #0]
    156a:	07ed      	lsls	r5, r5, #31
    156c:	d4fc      	bmi.n	1568 <flashWriteWord+0x20>
    *(flashAddr) = (vu16)lhWord;
    156e:	9d00      	ldr	r5, [sp, #0]
    1570:	b2ad      	uxth	r5, r5
    1572:	8005      	strh	r5, [r0, #0]
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1574:	6815      	ldr	r5, [r2, #0]
    1576:	07ed      	lsls	r5, r5, #31
    1578:	d4fc      	bmi.n	1574 <flashWriteWord+0x2c>

    rwmVal &= 0xFFFFFFFE;
    157a:	f024 0201 	bic.w	r2, r4, #1
    SET_REG(FLASH_CR, rwmVal);
    157e:	601a      	str	r2, [r3, #0]

    /* verify the write */
    if (*(vu32 *)addr != word) {
    1580:	6800      	ldr	r0, [r0, #0]
        return FALSE;
    }

    return TRUE;
}
    1582:	1a43      	subs	r3, r0, r1
    1584:	4258      	negs	r0, r3
    1586:	4158      	adcs	r0, r3
    1588:	b003      	add	sp, #12
    158a:	bd30      	pop	{r4, r5, pc}
    158c:	40022010 	andmi	r2, r2, r0, lsl r0
    1590:	4002200c 	andmi	r2, r2, ip

00001594 <flashLock>:

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    1594:	4b01      	ldr	r3, [pc, #4]	; (159c <flashLock+0x8>)
    1596:	2280      	movs	r2, #128	; 0x80
    1598:	601a      	str	r2, [r3, #0]
    159a:	4770      	bx	lr
    159c:	40022010 	andmi	r2, r2, r0, lsl r0

000015a0 <flashUnlock>:
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    15a0:	4b03      	ldr	r3, [pc, #12]	; (15b0 <flashUnlock+0x10>)
    15a2:	4a04      	ldr	r2, [pc, #16]	; (15b4 <flashUnlock+0x14>)
    15a4:	601a      	str	r2, [r3, #0]
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    15a6:	f102 3288 	add.w	r2, r2, #2290649224	; 0x88888888
    15aa:	601a      	str	r2, [r3, #0]
    15ac:	4770      	bx	lr
    15ae:	bf00      	nop
    15b0:	40022004 	andmi	r2, r2, r4
    15b4:	45670123 	strbmi	r0, [r7, #-291]!	; 0x123

000015b8 <crMask>:

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    15b8:	2807      	cmp	r0, #7
	{
		pin-=8;
    15ba:	bfc8      	it	gt
    15bc:	3808      	subgt	r0, #8
	}
	mask = 0x0F << (pin<<2);
    15be:	230f      	movs	r3, #15
    15c0:	0080      	lsls	r0, r0, #2
    15c2:	fa03 f000 	lsl.w	r0, r3, r0
	return ~mask;
}	
    15c6:	43c0      	mvns	r0, r0
    15c8:	4770      	bx	lr
	...

000015cc <getFlashEnd>:

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    15cc:	4b02      	ldr	r3, [pc, #8]	; (15d8 <getFlashEnd+0xc>)
    15ce:	8818      	ldrh	r0, [r3, #0]
    15d0:	f500 3000 	add.w	r0, r0, #131072	; 0x20000
}
    15d4:	0280      	lsls	r0, r0, #10
    15d6:	4770      	bx	lr
    15d8:	1ffff7e0 	svcne	0x00fff7e0

000015dc <getFlashPageSize>:

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    15dc:	4b04      	ldr	r3, [pc, #16]	; (15f0 <getFlashPageSize+0x14>)
    15de:	881b      	ldrh	r3, [r3, #0]
	{
		return 0x800;
    15e0:	2b81      	cmp	r3, #129	; 0x81
	}
	else
	{
		return 0x400;
	}
}
    15e2:	bf34      	ite	cc
    15e4:	f44f 6080 	movcc.w	r0, #1024	; 0x400
    15e8:	f44f 6000 	movcs.w	r0, #2048	; 0x800
    15ec:	4770      	bx	lr
    15ee:	bf00      	nop
    15f0:	1ffff7e0 	svcne	0x00fff7e0

000015f4 <dfuInit>:

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15f4:	4a15      	ldr	r2, [pc, #84]	; (164c <dfuInit+0x58>)


volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    15f6:	b508      	push	{r3, lr}
    dfuAppStatus.bStatus = OK;
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    15f8:	2102      	movs	r1, #2

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15fa:	2300      	movs	r3, #0
    15fc:	7013      	strb	r3, [r2, #0]
    dfuAppStatus.bwPollTimeout0 = 0x00;
    15fe:	7053      	strb	r3, [r2, #1]
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1600:	7093      	strb	r3, [r2, #2]
    dfuAppStatus.bwPollTimeout2 = 0x00;
    1602:	70d3      	strb	r3, [r2, #3]
    dfuAppStatus.bState = dfuIDLE;
    1604:	7111      	strb	r1, [r2, #4]
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    1606:	7153      	strb	r3, [r2, #5]
    userFirmwareLen = 0;
    1608:	4a11      	ldr	r2, [pc, #68]	; (1650 <dfuInit+0x5c>)
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    160a:	4912      	ldr	r1, [pc, #72]	; (1654 <dfuInit+0x60>)
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    160c:	6013      	str	r3, [r2, #0]
    thisBlockLen = 0;;
    160e:	4a12      	ldr	r2, [pc, #72]	; (1658 <dfuInit+0x64>)
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1610:	4812      	ldr	r0, [pc, #72]	; (165c <dfuInit+0x68>)
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    1612:	8013      	strh	r3, [r2, #0]
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1614:	4a12      	ldr	r2, [pc, #72]	; (1660 <dfuInit+0x6c>)
    1616:	6011      	str	r1, [r2, #0]
    userAppEnd = RAM_END;
    1618:	4a12      	ldr	r2, [pc, #72]	; (1664 <dfuInit+0x70>)
    161a:	f501 4188 	add.w	r1, r1, #17408	; 0x4400
    161e:	6011      	str	r1, [r2, #0]
    userUploadType=DFU_UPLOAD_NONE;
    1620:	4a11      	ldr	r2, [pc, #68]	; (1668 <dfuInit+0x74>)
    code_copy_lock = WAIT;
    1622:	2103      	movs	r1, #3
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    1624:	7013      	strb	r3, [r2, #0]
    code_copy_lock = WAIT;
    1626:	4a11      	ldr	r2, [pc, #68]	; (166c <dfuInit+0x78>)
    1628:	7011      	strb	r1, [r2, #0]
    dfuBusy = FALSE;
    162a:	4a11      	ldr	r2, [pc, #68]	; (1670 <dfuInit+0x7c>)
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    162c:	21ff      	movs	r1, #255	; 0xff
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    162e:	7013      	strb	r3, [r2, #0]
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1630:	2220      	movs	r2, #32
    1632:	f005 f89e 	bl	6772 <memset>
    memset(input, 0xFF, sizeof(input));
    1636:	480f      	ldr	r0, [pc, #60]	; (1674 <dfuInit+0x80>)
    1638:	21ff      	movs	r1, #255	; 0xff
    163a:	225c      	movs	r2, #92	; 0x5c
    163c:	f005 f899 	bl	6772 <memset>

    sha256_starts(&ctx);
}
    1640:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1644:	480c      	ldr	r0, [pc, #48]	; (1678 <dfuInit+0x84>)
    1646:	f001 bd1f 	b.w	3088 <sha256_starts>
    164a:	bf00      	nop
    164c:	20000dc5 	andcs	r0, r0, r5, asr #27
    1650:	20000dc0 	andcs	r0, r0, r0, asr #27
    1654:	20000c00 	andcs	r0, r0, r0, lsl #24
    1658:	20000dbe 			; <UNDEFINED> instruction: 0x20000dbe
    165c:	200004ec 	andcs	r0, r0, ip, ror #9
    1660:	200002c0 	andcs	r0, r0, r0, asr #5
    1664:	200002bc 			; <UNDEFINED> instruction: 0x200002bc
    1668:	20000dc4 	andcs	r0, r0, r4, asr #27
    166c:	20000574 	andcs	r0, r0, r4, ror r5
    1670:	20000dcb 	andcs	r0, r0, fp, asr #27
    1674:	20000490 	mulcs	r0, r0, r4
    1678:	2000050c 	andcs	r0, r0, ip, lsl #10

0000167c <dfuUpdateByReset>:
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    167c:	b508      	push	{r3, lr}
    u8 startState = dfuAppStatus.bState;
    167e:	4b0e      	ldr	r3, [pc, #56]	; (16b8 <dfuUpdateByReset+0x3c>)
    userFirmwareLen = 0;
    1680:	480e      	ldr	r0, [pc, #56]	; (16bc <dfuUpdateByReset+0x40>)

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    u8 startState = dfuAppStatus.bState;
    1682:	7919      	ldrb	r1, [r3, #4]
    userFirmwareLen = 0;
    1684:	2200      	movs	r2, #0

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    u8 startState = dfuAppStatus.bState;
    1686:	b2c9      	uxtb	r1, r1
    userFirmwareLen = 0;

    if (startState == appDETACH) {
    1688:	2901      	cmp	r1, #1
    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    168a:	6002      	str	r2, [r0, #0]

    if (startState == appDETACH) {
    168c:	d108      	bne.n	16a0 <dfuUpdateByReset+0x24>
        dfuAppStatus.bState = dfuIDLE;
    168e:	2102      	movs	r1, #2
    1690:	7119      	strb	r1, [r3, #4]
        dfuAppStatus.bStatus = OK;
    1692:	701a      	strb	r2, [r3, #0]

        nvicDisableInterrupts();
    1694:	f7ff ff12 	bl	14bc <nvicDisableInterrupts>
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1698:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    169c:	f7ff bc2c 	b.w	ef8 <usbEnbISR>
    } else if (startState == appIDLE || startState == dfuIDLE) {
    16a0:	f011 0ffd 	tst.w	r1, #253	; 0xfd
    16a4:	d006      	beq.n	16b4 <dfuUpdateByReset+0x38>
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    16a6:	2102      	movs	r1, #2
    16a8:	7119      	strb	r1, [r3, #4]
        dfuAppStatus.bStatus = OK;
    16aa:	701a      	strb	r2, [r3, #0]

        systemHardReset();
    }
}
    16ac:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    16b0:	f7ff bf26 	b.w	1500 <systemHardReset>
    16b4:	bd08      	pop	{r3, pc}
    16b6:	bf00      	nop
    16b8:	20000dc5 	andcs	r0, r0, r5, asr #27
    16bc:	20000dc0 	andcs	r0, r0, r0, asr #27

000016c0 <dfuCopyState>:

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    16c0:	b920      	cbnz	r0, 16cc <dfuCopyState+0xc>
        pInformation->Ctrl_Info.Usb_wLength = 1;
    16c2:	4b03      	ldr	r3, [pc, #12]	; (16d0 <dfuCopyState+0x10>)
    16c4:	2201      	movs	r2, #1
    16c6:	681b      	ldr	r3, [r3, #0]
    16c8:	821a      	strh	r2, [r3, #16]
        return NULL;
    16ca:	4770      	bx	lr
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    16cc:	4801      	ldr	r0, [pc, #4]	; (16d4 <dfuCopyState+0x14>)
    }
}
    16ce:	4770      	bx	lr
    16d0:	200005a8 	andcs	r0, r0, r8, lsr #11
    16d4:	20000dc9 	andcs	r0, r0, r9, asr #27

000016d8 <dfuCopyStatus>:

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    16d8:	b920      	cbnz	r0, 16e4 <dfuCopyStatus+0xc>
        pInformation->Ctrl_Info.Usb_wLength = 6;
    16da:	4b03      	ldr	r3, [pc, #12]	; (16e8 <dfuCopyStatus+0x10>)
    16dc:	2206      	movs	r2, #6
    16de:	681b      	ldr	r3, [r3, #0]
    16e0:	821a      	strh	r2, [r3, #16]
        return NULL;
    16e2:	4770      	bx	lr
    } else {
        return (u8*)(&dfuAppStatus);
    16e4:	4801      	ldr	r0, [pc, #4]	; (16ec <dfuCopyStatus+0x14>)
    }
}
    16e6:	4770      	bx	lr
    16e8:	200005a8 	andcs	r0, r0, r8, lsr #11
    16ec:	20000dc5 	andcs	r0, r0, r5, asr #27

000016f0 <dfuCopyDNLOAD>:


u8 *dfuCopyDNLOAD(u16 length) {
    16f0:	4b06      	ldr	r3, [pc, #24]	; (170c <dfuCopyDNLOAD+0x1c>)
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    16f2:	681b      	ldr	r3, [r3, #0]
    }
}


u8 *dfuCopyDNLOAD(u16 length) {
    if (length == 0) {
    16f4:	b930      	cbnz	r0, 1704 <dfuCopyDNLOAD+0x14>
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    16f6:	88da      	ldrh	r2, [r3, #6]
    16f8:	8a59      	ldrh	r1, [r3, #18]
    16fa:	1a51      	subs	r1, r2, r1
    16fc:	8219      	strh	r1, [r3, #16]
        thisBlockLen = pInformation->USBwLengths.w;
    16fe:	4b04      	ldr	r3, [pc, #16]	; (1710 <dfuCopyDNLOAD+0x20>)
    1700:	801a      	strh	r2, [r3, #0]
        return NULL;
    1702:	4770      	bx	lr
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1704:	8a5b      	ldrh	r3, [r3, #18]
    1706:	4803      	ldr	r0, [pc, #12]	; (1714 <dfuCopyDNLOAD+0x24>)
    1708:	4418      	add	r0, r3
    }
}
    170a:	4770      	bx	lr
    170c:	200005a8 	andcs	r0, r0, r8, lsr #11
    1710:	20000dbe 			; <UNDEFINED> instruction: 0x20000dbe
    1714:	200005bc 			; <UNDEFINED> instruction: 0x200005bc

00001718 <dfuCopyUPLOAD>:

u8 *dfuCopyUPLOAD(u16 length) {
    1718:	4b08      	ldr	r3, [pc, #32]	; (173c <dfuCopyUPLOAD+0x24>)
    if (length == 0) {
    171a:	b930      	cbnz	r0, 172a <dfuCopyUPLOAD+0x12>
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    171c:	681b      	ldr	r3, [r3, #0]
    171e:	4a08      	ldr	r2, [pc, #32]	; (1740 <dfuCopyUPLOAD+0x28>)
    1720:	8811      	ldrh	r1, [r2, #0]
    1722:	8a5a      	ldrh	r2, [r3, #18]
    1724:	1a8a      	subs	r2, r1, r2
    1726:	821a      	strh	r2, [r3, #16]
        return NULL;
    1728:	4770      	bx	lr
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    172a:	4906      	ldr	r1, [pc, #24]	; (1744 <dfuCopyUPLOAD+0x2c>)
    172c:	4a06      	ldr	r2, [pc, #24]	; (1748 <dfuCopyUPLOAD+0x30>)
    172e:	681b      	ldr	r3, [r3, #0]
    1730:	6812      	ldr	r2, [r2, #0]
    1732:	6808      	ldr	r0, [r1, #0]
    1734:	8a5b      	ldrh	r3, [r3, #18]
    1736:	4410      	add	r0, r2
    1738:	4418      	add	r0, r3
    }
}
    173a:	4770      	bx	lr
    173c:	200005a8 	andcs	r0, r0, r8, lsr #11
    1740:	20000dbe 			; <UNDEFINED> instruction: 0x20000dbe
    1744:	200002c0 	andcs	r0, r0, r0, asr #5
    1748:	20000dc0 	andcs	r0, r0, r0, asr #27

0000174c <dfuCopyBufferToExec>:

void dfuCopyBufferToExec() {
    174c:	b570      	push	{r4, r5, r6, lr}
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    174e:	4b12      	ldr	r3, [pc, #72]	; (1798 <dfuCopyBufferToExec+0x4c>)
    1750:	4e12      	ldr	r6, [pc, #72]	; (179c <dfuCopyBufferToExec+0x50>)
    1752:	781b      	ldrb	r3, [r3, #0]
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    1754:	6834      	ldr	r4, [r6, #0]
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    1756:	2b04      	cmp	r3, #4
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    1758:	f104 6400 	add.w	r4, r4, #134217728	; 0x8000000
    175c:	bf0c      	ite	eq
    175e:	f504 4400 	addeq.w	r4, r4, #32768	; 0x8000
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    1762:	f504 5400 	addne.w	r4, r4, #8192	; 0x2000
	}

    flashErasePage((u32)(userSpace));
    1766:	4620      	mov	r0, r4
    1768:	f7ff fed4 	bl	1514 <flashErasePage>

    for (i = 0; i < thisBlockLen; i = i + 4) {
    176c:	2500      	movs	r5, #0
    176e:	4b0c      	ldr	r3, [pc, #48]	; (17a0 <dfuCopyBufferToExec+0x54>)
    1770:	881a      	ldrh	r2, [r3, #0]
    1772:	b292      	uxth	r2, r2
    1774:	4295      	cmp	r5, r2
    1776:	da06      	bge.n	1786 <dfuCopyBufferToExec+0x3a>
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    1778:	4b0a      	ldr	r3, [pc, #40]	; (17a4 <dfuCopyBufferToExec+0x58>)
    177a:	1960      	adds	r0, r4, r5
    177c:	58e9      	ldr	r1, [r5, r3]
    177e:	f7ff fee3 	bl	1548 <flashWriteWord>
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    1782:	3504      	adds	r5, #4
    1784:	e7f3      	b.n	176e <dfuCopyBufferToExec+0x22>
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    1786:	6831      	ldr	r1, [r6, #0]
    1788:	881a      	ldrh	r2, [r3, #0]
    178a:	b292      	uxth	r2, r2
    178c:	440a      	add	r2, r1
    178e:	6032      	str	r2, [r6, #0]
    thisBlockLen = 0;
    1790:	2200      	movs	r2, #0
    1792:	801a      	strh	r2, [r3, #0]
    1794:	bd70      	pop	{r4, r5, r6, pc}
    1796:	bf00      	nop
    1798:	20000dc4 	andcs	r0, r0, r4, asr #27
    179c:	20000dc0 	andcs	r0, r0, r0, asr #27
    17a0:	20000dbe 			; <UNDEFINED> instruction: 0x20000dbe
    17a4:	200005bc 			; <UNDEFINED> instruction: 0x200005bc

000017a8 <dfuUpdateByRequest>:
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    17a8:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    17ac:	4985      	ldr	r1, [pc, #532]	; (19c4 <dfuUpdateByRequest+0x21c>)

    u8 startState = dfuAppStatus.bState;
    17ae:	4c86      	ldr	r4, [pc, #536]	; (19c8 <dfuUpdateByRequest+0x220>)
}

bool dfuUpdateByRequest(void) {
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    17b0:	2001      	movs	r0, #1
    17b2:	7008      	strb	r0, [r1, #0]

    u8 startState = dfuAppStatus.bState;
    17b4:	7923      	ldrb	r3, [r4, #4]
    dfuAppStatus.bStatus = OK;
    17b6:	2200      	movs	r2, #0
bool dfuUpdateByRequest(void) {
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;

    u8 startState = dfuAppStatus.bState;
    17b8:	b2db      	uxtb	r3, r3
    dfuAppStatus.bStatus = OK;
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
    17ba:	2b02      	cmp	r3, #2
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;

    u8 startState = dfuAppStatus.bState;
    dfuAppStatus.bStatus = OK;
    17bc:	7022      	strb	r2, [r4, #0]
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
    17be:	d151      	bne.n	1864 <dfuUpdateByRequest+0xbc>
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    17c0:	7008      	strb	r0, [r1, #0]

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17c2:	4982      	ldr	r1, [pc, #520]	; (19cc <dfuUpdateByRequest+0x224>)
    17c4:	6809      	ldr	r1, [r1, #0]
    17c6:	7848      	ldrb	r0, [r1, #1]
    17c8:	2801      	cmp	r0, #1
    17ca:	d121      	bne.n	1810 <dfuUpdateByRequest+0x68>
            if (pInformation->USBwLengths.w > 0) {
    17cc:	88cb      	ldrh	r3, [r1, #6]
    17ce:	2b00      	cmp	r3, #0
    17d0:	f000 80cc 	beq.w	196c <dfuUpdateByRequest+0x1c4>
                userFirmwareLen = 0;
    17d4:	4b7e      	ldr	r3, [pc, #504]	; (19d0 <dfuUpdateByRequest+0x228>)
    17d6:	601a      	str	r2, [r3, #0]
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    17d8:	7b0a      	ldrb	r2, [r1, #12]
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop

        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                userFirmwareLen = 0;
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    17da:	2303      	movs	r3, #3
				switch(pInformation->Current_AlternateSetting) {
    17dc:	2a01      	cmp	r2, #1
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop

        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                userFirmwareLen = 0;
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    17de:	7123      	strb	r3, [r4, #4]
				switch(pInformation->Current_AlternateSetting) {
    17e0:	d008      	beq.n	17f4 <dfuUpdateByRequest+0x4c>
    17e2:	2a02      	cmp	r2, #2
    17e4:	d111      	bne.n	180a <dfuUpdateByRequest+0x62>
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    17e6:	4b7b      	ldr	r3, [pc, #492]	; (19d4 <dfuUpdateByRequest+0x22c>)
    17e8:	2206      	movs	r2, #6
    17ea:	701a      	strb	r2, [r3, #0]
						userAppAddr = USER_CODE_FLASH0X8002000;
    17ec:	4a7a      	ldr	r2, [pc, #488]	; (19d8 <dfuUpdateByRequest+0x230>)
    17ee:	4b7b      	ldr	r3, [pc, #492]	; (19dc <dfuUpdateByRequest+0x234>)
    17f0:	601a      	str	r2, [r3, #0]
    17f2:	e005      	b.n	1800 <dfuUpdateByRequest+0x58>
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    17f4:	4a7a      	ldr	r2, [pc, #488]	; (19e0 <dfuUpdateByRequest+0x238>)
    17f6:	4b79      	ldr	r3, [pc, #484]	; (19dc <dfuUpdateByRequest+0x234>)
    17f8:	601a      	str	r2, [r3, #0]
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    17fa:	4b76      	ldr	r3, [pc, #472]	; (19d4 <dfuUpdateByRequest+0x22c>)
    17fc:	2204      	movs	r2, #4
    17fe:	701a      	strb	r2, [r3, #0]
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1800:	f7ff fe0c 	bl	141c <setupFLASH>
						flashUnlock();
    1804:	f7ff fecc 	bl	15a0 <flashUnlock>

						break;
    1808:	e0d3      	b.n	19b2 <dfuUpdateByRequest+0x20a>

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    180a:	220a      	movs	r2, #10
    180c:	7122      	strb	r2, [r4, #4]
    180e:	e0cf      	b.n	19b0 <dfuUpdateByRequest+0x208>
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1810:	2802      	cmp	r0, #2
    1812:	d121      	bne.n	1858 <dfuUpdateByRequest+0xb0>
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1814:	2309      	movs	r3, #9
    1816:	7123      	strb	r3, [r4, #4]
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    1818:	88ca      	ldrh	r2, [r1, #6]
    181a:	4b72      	ldr	r3, [pc, #456]	; (19e4 <dfuUpdateByRequest+0x23c>)
    181c:	801a      	strh	r2, [r3, #0]
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    181e:	8818      	ldrh	r0, [r3, #0]
    1820:	4a71      	ldr	r2, [pc, #452]	; (19e8 <dfuUpdateByRequest+0x240>)
    1822:	b280      	uxth	r0, r0
    1824:	8010      	strh	r0, [r2, #0]
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1826:	881a      	ldrh	r2, [r3, #0]
    1828:	884b      	ldrh	r3, [r1, #2]
    182a:	b292      	uxth	r2, r2
    182c:	435a      	muls	r2, r3
    182e:	4b68      	ldr	r3, [pc, #416]	; (19d0 <dfuUpdateByRequest+0x228>)
    1830:	601a      	str	r2, [r3, #0]
			
            switch(pInformation->Current_AlternateSetting) {
    1832:	7b0b      	ldrb	r3, [r1, #12]
    1834:	2b01      	cmp	r3, #1
    1836:	d003      	beq.n	1840 <dfuUpdateByRequest+0x98>
    1838:	2b02      	cmp	r3, #2
    183a:	d109      	bne.n	1850 <dfuUpdateByRequest+0xa8>
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    183c:	4a66      	ldr	r2, [pc, #408]	; (19d8 <dfuUpdateByRequest+0x230>)
    183e:	e000      	b.n	1842 <dfuUpdateByRequest+0x9a>
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1840:	4a67      	ldr	r2, [pc, #412]	; (19e0 <dfuUpdateByRequest+0x238>)
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1842:	4b66      	ldr	r3, [pc, #408]	; (19dc <dfuUpdateByRequest+0x234>)
    1844:	601a      	str	r2, [r3, #0]
					userAppEnd = getFlashEnd();
    1846:	f7ff fec1 	bl	15cc <getFlashEnd>
    184a:	4b68      	ldr	r3, [pc, #416]	; (19ec <dfuUpdateByRequest+0x244>)
    184c:	6018      	str	r0, [r3, #0]
					break;
    184e:	e0b0      	b.n	19b2 <dfuUpdateByRequest+0x20a>

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    1850:	230a      	movs	r3, #10
    1852:	7123      	strb	r3, [r4, #4]
					dfuAppStatus.bStatus = errWRITE;
    1854:	2303      	movs	r3, #3
    1856:	e0ab      	b.n	19b0 <dfuUpdateByRequest+0x208>
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    1858:	2806      	cmp	r0, #6
    185a:	d04c      	beq.n	18f6 <dfuUpdateByRequest+0x14e>
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    185c:	2803      	cmp	r0, #3
    185e:	d019      	beq.n	1894 <dfuUpdateByRequest+0xec>
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1860:	2805      	cmp	r0, #5
    1862:	e04c      	b.n	18fe <dfuUpdateByRequest+0x156>
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    1864:	2b03      	cmp	r3, #3
    1866:	d10b      	bne.n	1880 <dfuUpdateByRequest+0xd8>
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1868:	4a58      	ldr	r2, [pc, #352]	; (19cc <dfuUpdateByRequest+0x224>)
    186a:	6812      	ldr	r2, [r2, #0]
    186c:	7852      	ldrb	r2, [r2, #1]
    186e:	2a03      	cmp	r2, #3
    1870:	d104      	bne.n	187c <dfuUpdateByRequest+0xd4>

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    1872:	2305      	movs	r3, #5
    1874:	7123      	strb	r3, [r4, #4]
                dfuCopyBufferToExec();
    1876:	f7ff ff69 	bl	174c <dfuCopyBufferToExec>
    187a:	e09a      	b.n	19b2 <dfuUpdateByRequest+0x20a>
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    187c:	2a05      	cmp	r2, #5
    187e:	e03e      	b.n	18fe <dfuUpdateByRequest+0x156>
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    1880:	2b04      	cmp	r3, #4
    1882:	d109      	bne.n	1898 <dfuUpdateByRequest+0xf0>
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    1884:	495a      	ldr	r1, [pc, #360]	; (19f0 <dfuUpdateByRequest+0x248>)
    1886:	7808      	ldrb	r0, [r1, #0]
    1888:	2802      	cmp	r0, #2
    188a:	d103      	bne.n	1894 <dfuUpdateByRequest+0xec>

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    188c:	2303      	movs	r3, #3
        }
    } else if (startState == dfuDNBUSY)              {
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {

            dfuAppStatus.bwPollTimeout0 = 0x00;
    188e:	7062      	strb	r2, [r4, #1]
            code_copy_lock = WAIT;
    1890:	700b      	strb	r3, [r1, #0]
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    1892:	2305      	movs	r3, #5
    1894:	7123      	strb	r3, [r4, #4]
    1896:	e08c      	b.n	19b2 <dfuUpdateByRequest+0x20a>
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    1898:	2b05      	cmp	r3, #5
    189a:	d124      	bne.n	18e6 <dfuUpdateByRequest+0x13e>
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    189c:	4b4b      	ldr	r3, [pc, #300]	; (19cc <dfuUpdateByRequest+0x224>)
    189e:	681a      	ldr	r2, [r3, #0]
    18a0:	7853      	ldrb	r3, [r2, #1]
    18a2:	2b01      	cmp	r3, #1
    18a4:	d118      	bne.n	18d8 <dfuUpdateByRequest+0x130>
            if (pInformation->USBwLengths.w > 0) {
    18a6:	88d2      	ldrh	r2, [r2, #6]
    18a8:	b10a      	cbz	r2, 18ae <dfuUpdateByRequest+0x106>
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    18aa:	2303      	movs	r3, #3
    18ac:	e7f2      	b.n	1894 <dfuUpdateByRequest+0xec>
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    18ae:	2306      	movs	r3, #6
                }*/
                ImageObjectHandle imageHandle;
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    18b0:	a801      	add	r0, sp, #4
    18b2:	494b      	ldr	r1, [pc, #300]	; (19e0 <dfuUpdateByRequest+0x238>)
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    18b4:	7123      	strb	r3, [r4, #4]
                }*/
                ImageObjectHandle imageHandle;
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    18b6:	f004 f915 	bl	5ae4 <imageCheckFromAddress>
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
                }
                switch (ret)
    18ba:	2803      	cmp	r0, #3
    18bc:	d004      	beq.n	18c8 <dfuUpdateByRequest+0x120>
    18be:	2804      	cmp	r0, #4
    18c0:	d004      	beq.n	18cc <dfuUpdateByRequest+0x124>
    18c2:	2802      	cmp	r0, #2
    18c4:	d105      	bne.n	18d2 <dfuUpdateByRequest+0x12a>
    18c6:	e001      	b.n	18cc <dfuUpdateByRequest+0x124>
                {
                    case kImageImageIsTrusted:
                        uart_printf("Uploaded signature verified!\n");
    18c8:	484a      	ldr	r0, [pc, #296]	; (19f4 <dfuUpdateByRequest+0x24c>)
    18ca:	e000      	b.n	18ce <dfuUpdateByRequest+0x126>
                        break;

                    case kImageImageMissingMagic:
                    case kImageImageRejectSignature:
                        uart_printf("Image unverified... wiped memory for clean reset.\n");
    18cc:	484a      	ldr	r0, [pc, #296]	; (19f8 <dfuUpdateByRequest+0x250>)
    18ce:	f7ff fc93 	bl	11f8 <uart_printf>
                        break;

                    default:
                        break;
                }
                flashLock();
    18d2:	f7ff fe5f 	bl	1594 <flashLock>
    18d6:	e06c      	b.n	19b2 <dfuUpdateByRequest+0x20a>
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    18d8:	2b06      	cmp	r3, #6
    18da:	d04d      	beq.n	1978 <dfuUpdateByRequest+0x1d0>
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18dc:	2b03      	cmp	r3, #3
    18de:	d04b      	beq.n	1978 <dfuUpdateByRequest+0x1d0>
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18e0:	2b05      	cmp	r3, #5
    18e2:	d162      	bne.n	19aa <dfuUpdateByRequest+0x202>
    18e4:	e048      	b.n	1978 <dfuUpdateByRequest+0x1d0>
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuMANIFEST_SYNC) {
    18e6:	2b06      	cmp	r3, #6
    18e8:	d10b      	bne.n	1902 <dfuUpdateByRequest+0x15a>
        /* device has received last block, waiting DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18ea:	4938      	ldr	r1, [pc, #224]	; (19cc <dfuUpdateByRequest+0x224>)
    18ec:	6809      	ldr	r1, [r1, #0]
    18ee:	7849      	ldrb	r1, [r1, #1]
    18f0:	2903      	cmp	r1, #3
    18f2:	d103      	bne.n	18fc <dfuUpdateByRequest+0x154>
            dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    18f4:	2308      	movs	r3, #8
    18f6:	7123      	strb	r3, [r4, #4]
            dfuAppStatus.bStatus = OK;
    18f8:	7022      	strb	r2, [r4, #0]
    18fa:	e05a      	b.n	19b2 <dfuUpdateByRequest+0x20a>
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18fc:	2905      	cmp	r1, #5
    18fe:	d154      	bne.n	19aa <dfuUpdateByRequest+0x202>
    1900:	e7c8      	b.n	1894 <dfuUpdateByRequest+0xec>
            dfuAppStatus.bState  = dfuMANIFEST_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuMANIFEST) {
    1902:	2b07      	cmp	r3, #7
    1904:	d0f6      	beq.n	18f4 <dfuUpdateByRequest+0x14c>
        /* device is in manifestation phase */

        /* should never receive request while in manifest! */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
        dfuAppStatus.bStatus = OK;
    } else if (startState == dfuMANIFEST_WAIT_RESET) {
    1906:	2b08      	cmp	r3, #8
    1908:	d0c4      	beq.n	1894 <dfuUpdateByRequest+0xec>
        /* device has programmed new firmware but needs external
           usb reset or power on reset to run the new code */

        /* consider timing out and self-resetting */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    } else if (startState == dfuUPLOAD_IDLE) {
    190a:	2b09      	cmp	r3, #9
    190c:	d13c      	bne.n	1988 <dfuUpdateByRequest+0x1e0>
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
    190e:	4b2f      	ldr	r3, [pc, #188]	; (19cc <dfuUpdateByRequest+0x224>)
    1910:	681a      	ldr	r2, [r3, #0]
    1912:	7853      	ldrb	r3, [r2, #1]
    1914:	2b02      	cmp	r3, #2
    1916:	d12d      	bne.n	1974 <dfuUpdateByRequest+0x1cc>
            if (pInformation->USBwLengths.w > 0) {
    1918:	88d0      	ldrh	r0, [r2, #6]
    191a:	b338      	cbz	r0, 196c <dfuUpdateByRequest+0x1c4>
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    191c:	4931      	ldr	r1, [pc, #196]	; (19e4 <dfuUpdateByRequest+0x23c>)
    191e:	8852      	ldrh	r2, [r2, #2]
    1920:	880b      	ldrh	r3, [r1, #0]
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1922:	4d2e      	ldr	r5, [pc, #184]	; (19dc <dfuUpdateByRequest+0x234>)
    } else if (startState == dfuUPLOAD_IDLE) {
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1924:	b29b      	uxth	r3, r3
    1926:	4353      	muls	r3, r2
    1928:	4a29      	ldr	r2, [pc, #164]	; (19d0 <dfuUpdateByRequest+0x228>)
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    192a:	4e30      	ldr	r6, [pc, #192]	; (19ec <dfuUpdateByRequest+0x244>)
    } else if (startState == dfuUPLOAD_IDLE) {
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    192c:	6013      	str	r3, [r2, #0]
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    192e:	682f      	ldr	r7, [r5, #0]
    1930:	f8d2 8000 	ldr.w	r8, [r2]
    1934:	f8b1 c000 	ldrh.w	ip, [r1]
    1938:	4447      	add	r7, r8
    193a:	6833      	ldr	r3, [r6, #0]
    193c:	fa1f fc8c 	uxth.w	ip, ip
    1940:	4467      	add	r7, ip
    1942:	429f      	cmp	r7, r3
    1944:	4b28      	ldr	r3, [pc, #160]	; (19e8 <dfuUpdateByRequest+0x240>)
    1946:	d803      	bhi.n	1950 <dfuUpdateByRequest+0x1a8>
                    thisBlockLen = uploadBlockLen;
    1948:	880a      	ldrh	r2, [r1, #0]
    194a:	b292      	uxth	r2, r2
    194c:	801a      	strh	r2, [r3, #0]
    194e:	e019      	b.n	1984 <dfuUpdateByRequest+0x1dc>
                    dfuAppStatus.bState  = dfuUPLOAD_IDLE;
                } else {
                    /* if above comparison was just equal, thisBlockLen becomes zero
                    next time when USBWValue has been increased by one */
                    thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
    1950:	6836      	ldr	r6, [r6, #0]
    1952:	682d      	ldr	r5, [r5, #0]
    1954:	6811      	ldr	r1, [r2, #0]
    1956:	1b72      	subs	r2, r6, r5
    1958:	1a52      	subs	r2, r2, r1
    195a:	b292      	uxth	r2, r2
    195c:	801a      	strh	r2, [r3, #0]
                    
                    /* check for overflow due to USBwValue out of range */
                    if (thisBlockLen >= pInformation->USBwLengths.w) {
    195e:	881a      	ldrh	r2, [r3, #0]
    1960:	b292      	uxth	r2, r2
    1962:	4282      	cmp	r2, r0
    1964:	d308      	bcc.n	1978 <dfuUpdateByRequest+0x1d0>
                        thisBlockLen = 0;
    1966:	2200      	movs	r2, #0
    1968:	801a      	strh	r2, [r3, #0]
    196a:	e005      	b.n	1978 <dfuUpdateByRequest+0x1d0>
                    }
                    
                    dfuAppStatus.bState  = dfuIDLE;
                }
            } else {
                dfuAppStatus.bState  = dfuERROR;
    196c:	230a      	movs	r3, #10
    196e:	7123      	strb	r3, [r4, #4]
                dfuAppStatus.bStatus = errNOTDONE;
    1970:	2309      	movs	r3, #9
    1972:	e01d      	b.n	19b0 <dfuUpdateByRequest+0x208>
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    1974:	2b06      	cmp	r3, #6
    1976:	d101      	bne.n	197c <dfuUpdateByRequest+0x1d4>
            dfuAppStatus.bState  = dfuIDLE;
    1978:	2302      	movs	r3, #2
    197a:	e78b      	b.n	1894 <dfuUpdateByRequest+0xec>
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    197c:	2b03      	cmp	r3, #3
    197e:	d001      	beq.n	1984 <dfuUpdateByRequest+0x1dc>
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1980:	2b05      	cmp	r3, #5
    1982:	d112      	bne.n	19aa <dfuUpdateByRequest+0x202>
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1984:	2309      	movs	r3, #9
    1986:	e785      	b.n	1894 <dfuUpdateByRequest+0xec>
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuERROR)               {
    1988:	2b0a      	cmp	r3, #10
    198a:	d10e      	bne.n	19aa <dfuUpdateByRequest+0x202>
        /* status is in error, awaiting DFU_CLRSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    198c:	4b0f      	ldr	r3, [pc, #60]	; (19cc <dfuUpdateByRequest+0x224>)
    198e:	681b      	ldr	r3, [r3, #0]
    1990:	785b      	ldrb	r3, [r3, #1]
    1992:	2b03      	cmp	r3, #3
    1994:	d101      	bne.n	199a <dfuUpdateByRequest+0x1f2>
            /* todo, add routine to wait for last block write to finish */
            dfuAppStatus.bState  = dfuERROR;
    1996:	230a      	movs	r3, #10
    1998:	e77c      	b.n	1894 <dfuUpdateByRequest+0xec>
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    199a:	2b05      	cmp	r3, #5
    199c:	d0fb      	beq.n	1996 <dfuUpdateByRequest+0x1ee>
            dfuAppStatus.bState  = dfuERROR;
        } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
    199e:	2b04      	cmp	r3, #4
    19a0:	d103      	bne.n	19aa <dfuUpdateByRequest+0x202>
            /* todo handle any cleanup we need here */
            dfuAppStatus.bState  = dfuIDLE;
    19a2:	2302      	movs	r3, #2
    19a4:	7123      	strb	r3, [r4, #4]
            dfuAppStatus.bStatus = OK;
    19a6:	2300      	movs	r3, #0
    19a8:	e002      	b.n	19b0 <dfuUpdateByRequest+0x208>
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else {
        /* some kind of error... */
        dfuAppStatus.bState  = dfuERROR;
    19aa:	230a      	movs	r3, #10
    19ac:	7123      	strb	r3, [r4, #4]
        dfuAppStatus.bStatus = errSTALLEDPKT;
    19ae:	230f      	movs	r3, #15
    19b0:	7023      	strb	r3, [r4, #0]
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
    19b2:	7820      	ldrb	r0, [r4, #0]
}
    19b4:	f1d0 0001 	rsbs	r0, r0, #1
    19b8:	bf38      	it	cc
    19ba:	2000      	movcc	r0, #0
    19bc:	b002      	add	sp, #8
    19be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    19c2:	bf00      	nop
    19c4:	20000dcb 	andcs	r0, r0, fp, asr #27
    19c8:	20000dc5 	andcs	r0, r0, r5, asr #27
    19cc:	200005a8 	andcs	r0, r0, r8, lsr #11
    19d0:	20000dc0 	andcs	r0, r0, r0, asr #27
    19d4:	20000dc4 	andcs	r0, r0, r4, asr #27
    19d8:	08002000 	stmdaeq	r0, {sp}
    19dc:	200002c0 	andcs	r0, r0, r0, asr #5
    19e0:	08008000 	stmdaeq	r0, {pc}
    19e4:	20000dbc 			; <UNDEFINED> instruction: 0x20000dbc
    19e8:	20000dbe 			; <UNDEFINED> instruction: 0x20000dbe
    19ec:	200002bc 			; <UNDEFINED> instruction: 0x200002bc
    19f0:	20000574 	andcs	r0, r0, r4, ror r5
    19f4:	000070ac 	andeq	r7, r0, ip, lsr #1
    19f8:	000070ca 	andeq	r7, r0, sl, asr #1

000019fc <dfuUploadStarted>:
    dfuAppStatus.bState = newState;
}

bool dfuUploadStarted()
{
    return dfuBusy;
    19fc:	4b01      	ldr	r3, [pc, #4]	; (1a04 <dfuUploadStarted+0x8>)
    19fe:	7818      	ldrb	r0, [r3, #0]
}
    1a00:	4770      	bx	lr
    1a02:	bf00      	nop
    1a04:	20000dcb 	andcs	r0, r0, fp, asr #27

00001a08 <dfuFinishUpload>:

void dfuFinishUpload() {

    while (1)
	{
		__asm__ __volatile__ ("");
    1a08:	e7fe      	b.n	1a08 <dfuFinishUpload>
	...

00001a0c <ed25519_project>:
};

/* Conversion to and from projective coordinates */
void ed25519_project(struct ed25519_pt *p,
		     const uint8_t *x, const uint8_t *y)
{
    1a0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    1a0e:	460d      	mov	r5, r1
void f25519_load(uint8_t *x, uint32_t c);

/* Copy two points */
static inline void f25519_copy(uint8_t *x, const uint8_t *a)
{
	memcpy(x, a, F25519_SIZE);
    1a10:	f8d1 e000 	ldr.w	lr, [r1]
    1a14:	684f      	ldr	r7, [r1, #4]
    1a16:	68eb      	ldr	r3, [r5, #12]
    1a18:	6889      	ldr	r1, [r1, #8]
    1a1a:	f8c0 e000 	str.w	lr, [r0]
    1a1e:	6047      	str	r7, [r0, #4]
    1a20:	6081      	str	r1, [r0, #8]
    1a22:	60c3      	str	r3, [r0, #12]
    1a24:	f8d5 e010 	ldr.w	lr, [r5, #16]
    1a28:	696f      	ldr	r7, [r5, #20]
    1a2a:	69a9      	ldr	r1, [r5, #24]
    1a2c:	69eb      	ldr	r3, [r5, #28]
    1a2e:	f8c0 e010 	str.w	lr, [r0, #16]
    1a32:	61c3      	str	r3, [r0, #28]
    1a34:	6147      	str	r7, [r0, #20]
    1a36:	6181      	str	r1, [r0, #24]
    1a38:	f8d2 e000 	ldr.w	lr, [r2]
    1a3c:	6857      	ldr	r7, [r2, #4]
    1a3e:	6891      	ldr	r1, [r2, #8]
    1a40:	4616      	mov	r6, r2
    1a42:	68d2      	ldr	r2, [r2, #12]
    1a44:	f8c0 e020 	str.w	lr, [r0, #32]
    1a48:	6247      	str	r7, [r0, #36]	; 0x24
    1a4a:	6281      	str	r1, [r0, #40]	; 0x28
    1a4c:	62c2      	str	r2, [r0, #44]	; 0x2c
    1a4e:	69b1      	ldr	r1, [r6, #24]
    1a50:	69f2      	ldr	r2, [r6, #28]
    1a52:	f8d6 e010 	ldr.w	lr, [r6, #16]
    1a56:	6977      	ldr	r7, [r6, #20]
    1a58:	4604      	mov	r4, r0
    1a5a:	63a1      	str	r1, [r4, #56]	; 0x38
    1a5c:	63e2      	str	r2, [r4, #60]	; 0x3c
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
    1a5e:	3060      	adds	r0, #96	; 0x60
    1a60:	f8c4 e030 	str.w	lr, [r4, #48]	; 0x30
    1a64:	6367      	str	r7, [r4, #52]	; 0x34
    1a66:	2101      	movs	r1, #1
    1a68:	f000 fa84 	bl	1f74 <f25519_load>
	f25519_mul__distinct(p->t, x, y);
    1a6c:	f104 0040 	add.w	r0, r4, #64	; 0x40
    1a70:	4629      	mov	r1, r5
    1a72:	4632      	mov	r2, r6
}
    1a74:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		     const uint8_t *x, const uint8_t *y)
{
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
	f25519_mul__distinct(p->t, x, y);
    1a78:	f000 bbe2 	b.w	2240 <f25519_mul__distinct>

00001a7c <ed25519_unproject>:
}

void ed25519_unproject(uint8_t *x, uint8_t *y,
		       const struct ed25519_pt *p)
{
    1a7c:	b570      	push	{r4, r5, r6, lr}
    1a7e:	b088      	sub	sp, #32
    1a80:	4614      	mov	r4, r2
    1a82:	4606      	mov	r6, r0
    1a84:	460d      	mov	r5, r1
	uint8_t z1[F25519_SIZE];

	f25519_inv__distinct(z1, p->z);
    1a86:	4668      	mov	r0, sp
    1a88:	f102 0160 	add.w	r1, r2, #96	; 0x60
    1a8c:	f000 fc1c 	bl	22c8 <f25519_inv__distinct>
	f25519_mul__distinct(x, p->x, z1);
    1a90:	4630      	mov	r0, r6
    1a92:	4621      	mov	r1, r4
    1a94:	466a      	mov	r2, sp
    1a96:	f000 fbd3 	bl	2240 <f25519_mul__distinct>
	f25519_mul__distinct(y, p->y, z1);
    1a9a:	f104 0120 	add.w	r1, r4, #32
    1a9e:	466a      	mov	r2, sp
    1aa0:	4628      	mov	r0, r5
    1aa2:	f000 fbcd 	bl	2240 <f25519_mul__distinct>

	f25519_normalize(x);
    1aa6:	4630      	mov	r0, r6
    1aa8:	f000 fa74 	bl	1f94 <f25519_normalize>
	f25519_normalize(y);
    1aac:	4628      	mov	r0, r5
    1aae:	f000 fa71 	bl	1f94 <f25519_normalize>
}
    1ab2:	b008      	add	sp, #32
    1ab4:	bd70      	pop	{r4, r5, r6, pc}
    1ab6:	bf00      	nop

00001ab8 <ed25519_pack>:
	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
};

void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y)
{
    1ab8:	b5f0      	push	{r4, r5, r6, r7, lr}
    1aba:	460f      	mov	r7, r1
    1abc:	4605      	mov	r5, r0
    1abe:	4616      	mov	r6, r2
    1ac0:	b089      	sub	sp, #36	; 0x24
    1ac2:	6808      	ldr	r0, [r1, #0]
    1ac4:	68ba      	ldr	r2, [r7, #8]
    1ac6:	68fb      	ldr	r3, [r7, #12]
    1ac8:	6849      	ldr	r1, [r1, #4]
    1aca:	466c      	mov	r4, sp
    1acc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1ace:	6938      	ldr	r0, [r7, #16]
    1ad0:	6979      	ldr	r1, [r7, #20]
    1ad2:	69ba      	ldr	r2, [r7, #24]
    1ad4:	69fb      	ldr	r3, [r7, #28]
    1ad6:	c40f      	stmia	r4!, {r0, r1, r2, r3}
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
    1ad8:	4668      	mov	r0, sp
    1ada:	f000 fa5b 	bl	1f94 <f25519_normalize>
    1ade:	6830      	ldr	r0, [r6, #0]
    1ae0:	6871      	ldr	r1, [r6, #4]
    1ae2:	68b2      	ldr	r2, [r6, #8]
    1ae4:	68f3      	ldr	r3, [r6, #12]
    1ae6:	6028      	str	r0, [r5, #0]
    1ae8:	6069      	str	r1, [r5, #4]
    1aea:	60aa      	str	r2, [r5, #8]
    1aec:	60eb      	str	r3, [r5, #12]
    1aee:	6930      	ldr	r0, [r6, #16]
    1af0:	69f3      	ldr	r3, [r6, #28]
    1af2:	6971      	ldr	r1, [r6, #20]
    1af4:	69b2      	ldr	r2, [r6, #24]
    1af6:	6128      	str	r0, [r5, #16]
    1af8:	61eb      	str	r3, [r5, #28]
    1afa:	6169      	str	r1, [r5, #20]
    1afc:	61aa      	str	r2, [r5, #24]
	parity = (tmp[0] & 1) << 7;

	f25519_copy(c, y);
	f25519_normalize(c);
    1afe:	4628      	mov	r0, r5
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1b00:	f89d 4000 	ldrb.w	r4, [sp]

	f25519_copy(c, y);
	f25519_normalize(c);
    1b04:	f000 fa46 	bl	1f94 <f25519_normalize>
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1b08:	01e4      	lsls	r4, r4, #7

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1b0a:	7feb      	ldrb	r3, [r5, #31]
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1b0c:	b2e4      	uxtb	r4, r4

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1b0e:	431c      	orrs	r4, r3
    1b10:	77ec      	strb	r4, [r5, #31]
}
    1b12:	b009      	add	sp, #36	; 0x24
    1b14:	bdf0      	pop	{r4, r5, r6, r7, pc}
    1b16:	bf00      	nop

00001b18 <ed25519_try_unpack>:

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b18:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1b1c:	6817      	ldr	r7, [r2, #0]
    1b1e:	6856      	ldr	r6, [r2, #4]
    1b20:	6895      	ldr	r5, [r2, #8]
    1b22:	f8d2 e00c 	ldr.w	lr, [r2, #12]
    1b26:	4614      	mov	r4, r2
	const int parity = comp[31] >> 7;
    1b28:	f894 801f 	ldrb.w	r8, [r4, #31]
    1b2c:	600f      	str	r7, [r1, #0]
    1b2e:	604e      	str	r6, [r1, #4]
    1b30:	608d      	str	r5, [r1, #8]
    1b32:	f8c1 e00c 	str.w	lr, [r1, #12]
    1b36:	f8d4 e01c 	ldr.w	lr, [r4, #28]
    1b3a:	6927      	ldr	r7, [r4, #16]
    1b3c:	6966      	ldr	r6, [r4, #20]
    1b3e:	69a5      	ldr	r5, [r4, #24]
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b40:	b098      	sub	sp, #96	; 0x60
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1b42:	f008 037f 	and.w	r3, r8, #127	; 0x7f
    1b46:	f8c1 e01c 	str.w	lr, [r1, #28]
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b4a:	4604      	mov	r4, r0
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1b4c:	77cb      	strb	r3, [r1, #31]
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b4e:	460a      	mov	r2, r1
    1b50:	610f      	str	r7, [r1, #16]
    1b52:	614e      	str	r6, [r1, #20]
    1b54:	618d      	str	r5, [r1, #24]
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1b56:	a810      	add	r0, sp, #64	; 0x40

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
	f25519_add(a, b, f25519_one);
    1b58:	4d1f      	ldr	r5, [pc, #124]	; (1bd8 <ed25519_try_unpack+0xc0>)
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1b5a:	f000 fb71 	bl	2240 <f25519_mul__distinct>

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
    1b5e:	a910      	add	r1, sp, #64	; 0x40
    1b60:	a808      	add	r0, sp, #32
    1b62:	4a1e      	ldr	r2, [pc, #120]	; (1bdc <ed25519_try_unpack+0xc4>)
    1b64:	f000 fb6c 	bl	2240 <f25519_mul__distinct>
	f25519_add(a, b, f25519_one);
    1b68:	462a      	mov	r2, r5
    1b6a:	a908      	add	r1, sp, #32
    1b6c:	4668      	mov	r0, sp
    1b6e:	f000 faf9 	bl	2164 <f25519_add>
	f25519_inv__distinct(b, a);
    1b72:	a808      	add	r0, sp, #32
    1b74:	4669      	mov	r1, sp
    1b76:	f000 fba7 	bl	22c8 <f25519_inv__distinct>

	/* Compute a = y^2-1 */
	f25519_sub(a, c, f25519_one);
    1b7a:	4668      	mov	r0, sp
    1b7c:	a910      	add	r1, sp, #64	; 0x40
    1b7e:	462a      	mov	r2, r5
    1b80:	f000 fb14 	bl	21ac <f25519_sub>

	/* Compute c = a*b = (y^2-1)/(1-dy^2) */
	f25519_mul__distinct(c, a, b);
    1b84:	aa08      	add	r2, sp, #32
    1b86:	a810      	add	r0, sp, #64	; 0x40
    1b88:	4669      	mov	r1, sp
    1b8a:	f000 fb59 	bl	2240 <f25519_mul__distinct>

	/* Compute a, b = +/-sqrt(c), if c is square */
	f25519_sqrt(a, c);
    1b8e:	4668      	mov	r0, sp
    1b90:	a910      	add	r1, sp, #64	; 0x40
    1b92:	f000 fe8f 	bl	28b4 <f25519_sqrt>
	f25519_neg(b, a);
    1b96:	a808      	add	r0, sp, #32
    1b98:	4669      	mov	r1, sp
    1b9a:	f000 fb2d 	bl	21f8 <f25519_neg>

	/* Select one of them, based on the compressed parity bit */
	f25519_select(x, a, b, (a[0] ^ parity) & 1);
    1b9e:	f89d 3000 	ldrb.w	r3, [sp]
    1ba2:	aa08      	add	r2, sp, #32
    1ba4:	ea83 13d8 	eor.w	r3, r3, r8, lsr #7
    1ba8:	f003 0301 	and.w	r3, r3, #1
    1bac:	4620      	mov	r0, r4
    1bae:	4669      	mov	r1, sp
    1bb0:	f000 fa76 	bl	20a0 <f25519_select>

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
    1bb4:	4621      	mov	r1, r4
    1bb6:	4622      	mov	r2, r4
    1bb8:	4668      	mov	r0, sp
    1bba:	f000 fb41 	bl	2240 <f25519_mul__distinct>
	f25519_normalize(a);
    1bbe:	4668      	mov	r0, sp
    1bc0:	f000 f9e8 	bl	1f94 <f25519_normalize>
	f25519_normalize(c);
    1bc4:	a810      	add	r0, sp, #64	; 0x40
    1bc6:	f000 f9e5 	bl	1f94 <f25519_normalize>

	return f25519_eq(a, c);
    1bca:	4668      	mov	r0, sp
    1bcc:	a910      	add	r1, sp, #64	; 0x40
    1bce:	f000 fa19 	bl	2004 <f25519_eq>
}
    1bd2:	b018      	add	sp, #96	; 0x60
    1bd4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1bd8:	00007260 	andeq	r7, r0, r0, ror #4
    1bdc:	00007220 	andeq	r7, r0, r0, lsr #4

00001be0 <ed25519_add>:
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1be0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1be4:	4614      	mov	r4, r2
    1be6:	b0c0      	sub	sp, #256	; 0x100
    1be8:	460d      	mov	r5, r1
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bea:	f101 0820 	add.w	r8, r1, #32
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1bee:	4606      	mov	r6, r0
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bf0:	4641      	mov	r1, r8
    1bf2:	462a      	mov	r2, r5
    1bf4:	a810      	add	r0, sp, #64	; 0x40
	f25519_sub(d, p2->y, p2->x);
    1bf6:	f104 0720 	add.w	r7, r4, #32
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bfa:	f000 fad7 	bl	21ac <f25519_sub>
	f25519_sub(d, p2->y, p2->x);
    1bfe:	4639      	mov	r1, r7
    1c00:	4622      	mov	r2, r4
    1c02:	a818      	add	r0, sp, #96	; 0x60
    1c04:	f000 fad2 	bl	21ac <f25519_sub>
	f25519_mul__distinct(a, c, d);
    1c08:	a910      	add	r1, sp, #64	; 0x40
    1c0a:	aa18      	add	r2, sp, #96	; 0x60
    1c0c:	4668      	mov	r0, sp
    1c0e:	f000 fb17 	bl	2240 <f25519_mul__distinct>

	/* B = (Y1+X1)(Y2+X2) */
	f25519_add(c, p1->y, p1->x);
    1c12:	a810      	add	r0, sp, #64	; 0x40
    1c14:	4641      	mov	r1, r8
    1c16:	462a      	mov	r2, r5
    1c18:	f000 faa4 	bl	2164 <f25519_add>
	f25519_add(d, p2->y, p2->x);
    1c1c:	a818      	add	r0, sp, #96	; 0x60
    1c1e:	4639      	mov	r1, r7
    1c20:	4622      	mov	r2, r4
    1c22:	f000 fa9f 	bl	2164 <f25519_add>
	f25519_mul__distinct(b, c, d);
    1c26:	a910      	add	r1, sp, #64	; 0x40
    1c28:	aa18      	add	r2, sp, #96	; 0x60
    1c2a:	a808      	add	r0, sp, #32
    1c2c:	f000 fb08 	bl	2240 <f25519_mul__distinct>

	/* C = T1 k T2 */
	f25519_mul__distinct(d, p1->t, p2->t);
    1c30:	a818      	add	r0, sp, #96	; 0x60
    1c32:	f105 0140 	add.w	r1, r5, #64	; 0x40
    1c36:	f104 0240 	add.w	r2, r4, #64	; 0x40
    1c3a:	f000 fb01 	bl	2240 <f25519_mul__distinct>
	f25519_mul__distinct(c, d, ed25519_k);
    1c3e:	a810      	add	r0, sp, #64	; 0x40
    1c40:	a918      	add	r1, sp, #96	; 0x60
    1c42:	4a1e      	ldr	r2, [pc, #120]	; (1cbc <ed25519_add+0xdc>)
    1c44:	f000 fafc 	bl	2240 <f25519_mul__distinct>

	/* D = Z1 2 Z2 */
	f25519_mul__distinct(d, p1->z, p2->z);
    1c48:	a818      	add	r0, sp, #96	; 0x60
    1c4a:	f105 0160 	add.w	r1, r5, #96	; 0x60
    1c4e:	f104 0260 	add.w	r2, r4, #96	; 0x60
    1c52:	f000 faf5 	bl	2240 <f25519_mul__distinct>
	f25519_add(d, d, d);
    1c56:	a818      	add	r0, sp, #96	; 0x60
    1c58:	4601      	mov	r1, r0
    1c5a:	4602      	mov	r2, r0
    1c5c:	f000 fa82 	bl	2164 <f25519_add>

	/* E = B - A */
	f25519_sub(e, b, a);
    1c60:	a908      	add	r1, sp, #32
    1c62:	466a      	mov	r2, sp
    1c64:	a820      	add	r0, sp, #128	; 0x80
    1c66:	f000 faa1 	bl	21ac <f25519_sub>

	/* F = D - C */
	f25519_sub(f, d, c);
    1c6a:	a918      	add	r1, sp, #96	; 0x60
    1c6c:	aa10      	add	r2, sp, #64	; 0x40
    1c6e:	a828      	add	r0, sp, #160	; 0xa0
    1c70:	f000 fa9c 	bl	21ac <f25519_sub>

	/* G = D + C */
	f25519_add(g, d, c);
    1c74:	a918      	add	r1, sp, #96	; 0x60
    1c76:	aa10      	add	r2, sp, #64	; 0x40
    1c78:	a830      	add	r0, sp, #192	; 0xc0
    1c7a:	f000 fa73 	bl	2164 <f25519_add>

	/* H = B + A */
	f25519_add(h, b, a);
    1c7e:	a908      	add	r1, sp, #32
    1c80:	466a      	mov	r2, sp
    1c82:	a838      	add	r0, sp, #224	; 0xe0
    1c84:	f000 fa6e 	bl	2164 <f25519_add>

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1c88:	4630      	mov	r0, r6
    1c8a:	a920      	add	r1, sp, #128	; 0x80
    1c8c:	aa28      	add	r2, sp, #160	; 0xa0
    1c8e:	f000 fad7 	bl	2240 <f25519_mul__distinct>

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1c92:	f106 0020 	add.w	r0, r6, #32
    1c96:	a930      	add	r1, sp, #192	; 0xc0
    1c98:	aa38      	add	r2, sp, #224	; 0xe0
    1c9a:	f000 fad1 	bl	2240 <f25519_mul__distinct>

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1c9e:	a920      	add	r1, sp, #128	; 0x80
    1ca0:	aa38      	add	r2, sp, #224	; 0xe0
    1ca2:	f106 0040 	add.w	r0, r6, #64	; 0x40
    1ca6:	f000 facb 	bl	2240 <f25519_mul__distinct>

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1caa:	f106 0060 	add.w	r0, r6, #96	; 0x60
    1cae:	a928      	add	r1, sp, #160	; 0xa0
    1cb0:	aa30      	add	r2, sp, #192	; 0xc0
    1cb2:	f000 fac5 	bl	2240 <f25519_mul__distinct>
}
    1cb6:	b040      	add	sp, #256	; 0x100
    1cb8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1cbc:	00007100 	andeq	r7, r0, r0, lsl #2

00001cc0 <ed25519_double>:

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1cc0:	b570      	push	{r4, r5, r6, lr}
    1cc2:	b0b8      	sub	sp, #224	; 0xe0
    1cc4:	4604      	mov	r4, r0

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1cc6:	f101 0620 	add.w	r6, r1, #32
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1cca:	460a      	mov	r2, r1
    1ccc:	4668      	mov	r0, sp
	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
}

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1cce:	460d      	mov	r5, r1
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1cd0:	f000 fab6 	bl	2240 <f25519_mul__distinct>

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1cd4:	4631      	mov	r1, r6
    1cd6:	4632      	mov	r2, r6
    1cd8:	a808      	add	r0, sp, #32
    1cda:	f000 fab1 	bl	2240 <f25519_mul__distinct>

	/* C = 2 Z1^2 */
	f25519_mul__distinct(c, p->z, p->z);
    1cde:	f105 0160 	add.w	r1, r5, #96	; 0x60
    1ce2:	460a      	mov	r2, r1
    1ce4:	a810      	add	r0, sp, #64	; 0x40
    1ce6:	f000 faab 	bl	2240 <f25519_mul__distinct>
	f25519_add(c, c, c);
    1cea:	a810      	add	r0, sp, #64	; 0x40
    1cec:	4601      	mov	r1, r0
    1cee:	4602      	mov	r2, r0
    1cf0:	f000 fa38 	bl	2164 <f25519_add>

	/* D = a A (alter sign) */
	/* E = (X1+Y1)^2-A-B */
	f25519_add(f, p->x, p->y);
    1cf4:	4632      	mov	r2, r6
    1cf6:	4629      	mov	r1, r5
    1cf8:	a820      	add	r0, sp, #128	; 0x80
    1cfa:	f000 fa33 	bl	2164 <f25519_add>
	f25519_mul__distinct(e, f, f);
    1cfe:	a920      	add	r1, sp, #128	; 0x80
    1d00:	460a      	mov	r2, r1
    1d02:	a818      	add	r0, sp, #96	; 0x60
    1d04:	f000 fa9c 	bl	2240 <f25519_mul__distinct>
	f25519_sub(e, e, a);
    1d08:	a818      	add	r0, sp, #96	; 0x60
    1d0a:	4601      	mov	r1, r0
    1d0c:	466a      	mov	r2, sp
    1d0e:	f000 fa4d 	bl	21ac <f25519_sub>
	f25519_sub(e, e, b);
    1d12:	a818      	add	r0, sp, #96	; 0x60
    1d14:	4601      	mov	r1, r0
    1d16:	aa08      	add	r2, sp, #32
    1d18:	f000 fa48 	bl	21ac <f25519_sub>

	/* G = D + B */
	f25519_sub(g, b, a);
    1d1c:	a908      	add	r1, sp, #32
    1d1e:	466a      	mov	r2, sp
    1d20:	a828      	add	r0, sp, #160	; 0xa0
    1d22:	f000 fa43 	bl	21ac <f25519_sub>

	/* F = G - C */
	f25519_sub(f, g, c);
    1d26:	aa10      	add	r2, sp, #64	; 0x40
    1d28:	a820      	add	r0, sp, #128	; 0x80
    1d2a:	a928      	add	r1, sp, #160	; 0xa0
    1d2c:	f000 fa3e 	bl	21ac <f25519_sub>

	/* H = D - B */
	f25519_neg(h, b);
    1d30:	a908      	add	r1, sp, #32
    1d32:	a830      	add	r0, sp, #192	; 0xc0
    1d34:	f000 fa60 	bl	21f8 <f25519_neg>
	f25519_sub(h, h, a);
    1d38:	a830      	add	r0, sp, #192	; 0xc0
    1d3a:	4601      	mov	r1, r0
    1d3c:	466a      	mov	r2, sp
    1d3e:	f000 fa35 	bl	21ac <f25519_sub>

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1d42:	4620      	mov	r0, r4
    1d44:	a918      	add	r1, sp, #96	; 0x60
    1d46:	aa20      	add	r2, sp, #128	; 0x80
    1d48:	f000 fa7a 	bl	2240 <f25519_mul__distinct>

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1d4c:	f104 0020 	add.w	r0, r4, #32
    1d50:	a928      	add	r1, sp, #160	; 0xa0
    1d52:	aa30      	add	r2, sp, #192	; 0xc0
    1d54:	f000 fa74 	bl	2240 <f25519_mul__distinct>

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1d58:	a918      	add	r1, sp, #96	; 0x60
    1d5a:	aa30      	add	r2, sp, #192	; 0xc0
    1d5c:	f104 0040 	add.w	r0, r4, #64	; 0x40
    1d60:	f000 fa6e 	bl	2240 <f25519_mul__distinct>

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1d64:	f104 0060 	add.w	r0, r4, #96	; 0x60
    1d68:	a920      	add	r1, sp, #128	; 0x80
    1d6a:	aa28      	add	r2, sp, #160	; 0xa0
    1d6c:	f000 fa68 	bl	2240 <f25519_mul__distinct>
}
    1d70:	b038      	add	sp, #224	; 0xe0
    1d72:	bd70      	pop	{r4, r5, r6, pc}

00001d74 <ed25519_smult>:

void ed25519_smult(struct ed25519_pt *r_out, const struct ed25519_pt *p,
		   const uint8_t *e)
{
    1d74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    1d78:	b0c0      	sub	sp, #256	; 0x100
    1d7a:	4680      	mov	r8, r0
    1d7c:	460f      	mov	r7, r1
    1d7e:	4616      	mov	r6, r2

/* Order of the group generated by the base point */
static inline void ed25519_copy(struct ed25519_pt *dst,
				const struct ed25519_pt *src)
{
	memcpy(dst, src, sizeof(*dst));
    1d80:	4668      	mov	r0, sp
    1d82:	491c      	ldr	r1, [pc, #112]	; (1df4 <ed25519_smult+0x80>)
    1d84:	2280      	movs	r2, #128	; 0x80
    1d86:	f004 fceb 	bl	6760 <memcpy>
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1d8a:	24ff      	movs	r4, #255	; 0xff
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1d8c:	10e3      	asrs	r3, r4, #3
    1d8e:	5cf5      	ldrb	r5, [r6, r3]
    1d90:	f004 0307 	and.w	r3, r4, #7
    1d94:	411d      	asrs	r5, r3
		struct ed25519_pt s;

		ed25519_double(&r, &r);
    1d96:	4668      	mov	r0, sp
    1d98:	4669      	mov	r1, sp
    1d9a:	f7ff ff91 	bl	1cc0 <ed25519_double>
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1d9e:	f005 0501 	and.w	r5, r5, #1
		struct ed25519_pt s;

		ed25519_double(&r, &r);
		ed25519_add(&s, &r, p);
    1da2:	a820      	add	r0, sp, #128	; 0x80
    1da4:	4669      	mov	r1, sp
    1da6:	463a      	mov	r2, r7
    1da8:	f7ff ff1a 	bl	1be0 <ed25519_add>

		f25519_select(r.x, r.x, s.x, bit);
    1dac:	4668      	mov	r0, sp
    1dae:	4669      	mov	r1, sp
    1db0:	aa20      	add	r2, sp, #128	; 0x80
    1db2:	462b      	mov	r3, r5
    1db4:	f000 f974 	bl	20a0 <f25519_select>
		f25519_select(r.y, r.y, s.y, bit);
    1db8:	a808      	add	r0, sp, #32
    1dba:	4601      	mov	r1, r0
    1dbc:	aa28      	add	r2, sp, #160	; 0xa0
    1dbe:	462b      	mov	r3, r5
    1dc0:	f000 f96e 	bl	20a0 <f25519_select>
		f25519_select(r.z, r.z, s.z, bit);
    1dc4:	a818      	add	r0, sp, #96	; 0x60
    1dc6:	4601      	mov	r1, r0
    1dc8:	aa38      	add	r2, sp, #224	; 0xe0
    1dca:	462b      	mov	r3, r5
    1dcc:	f000 f968 	bl	20a0 <f25519_select>
		f25519_select(r.t, r.t, s.t, bit);
    1dd0:	a810      	add	r0, sp, #64	; 0x40
    1dd2:	462b      	mov	r3, r5
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1dd4:	3c01      	subs	r4, #1
		ed25519_add(&s, &r, p);

		f25519_select(r.x, r.x, s.x, bit);
		f25519_select(r.y, r.y, s.y, bit);
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
    1dd6:	4601      	mov	r1, r0
    1dd8:	aa30      	add	r2, sp, #192	; 0xc0
    1dda:	f000 f961 	bl	20a0 <f25519_select>
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1dde:	1c63      	adds	r3, r4, #1
    1de0:	d1d4      	bne.n	1d8c <ed25519_smult+0x18>
    1de2:	4640      	mov	r0, r8
    1de4:	4669      	mov	r1, sp
    1de6:	2280      	movs	r2, #128	; 0x80
    1de8:	f004 fcba 	bl	6760 <memcpy>
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
	}

	ed25519_copy(r_out, &r);
}
    1dec:	b040      	add	sp, #256	; 0x100
    1dee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    1df2:	bf00      	nop
    1df4:	00007120 	andeq	r7, r0, r0, lsr #2

00001df8 <edsign_verify>:
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1df8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    1dfc:	4606      	mov	r6, r0
    1dfe:	460f      	mov	r7, r1
    1e00:	b0e9      	sub	sp, #420	; 0x1a4
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e02:	6800      	ldr	r0, [r0, #0]
    1e04:	6871      	ldr	r1, [r6, #4]
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1e06:	4698      	mov	r8, r3
    1e08:	4691      	mov	r9, r2
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e0a:	68f3      	ldr	r3, [r6, #12]
    1e0c:	68b2      	ldr	r2, [r6, #8]
    1e0e:	ac48      	add	r4, sp, #288	; 0x120
    1e10:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1e12:	6930      	ldr	r0, [r6, #16]
    1e14:	6971      	ldr	r1, [r6, #20]
    1e16:	69b2      	ldr	r2, [r6, #24]
    1e18:	69f3      	ldr	r3, [r6, #28]
	memcpy(block + 32, a, 32);
    1e1a:	f50d 7ea0 	add.w	lr, sp, #320	; 0x140
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e1e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
	memcpy(block + 32, a, 32);
    1e20:	6838      	ldr	r0, [r7, #0]
    1e22:	6879      	ldr	r1, [r7, #4]
    1e24:	68ba      	ldr	r2, [r7, #8]
    1e26:	68fb      	ldr	r3, [r7, #12]
extern const struct sha512_state sha512_initial_state;

/* Set up a new context */
static inline void sha512_init(struct sha512_state *s)
{
	memcpy(s, &sha512_initial_state, sizeof(*s));
    1e28:	4d4f      	ldr	r5, [pc, #316]	; (1f68 <edsign_verify+0x170>)
    1e2a:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    1e2e:	6938      	ldr	r0, [r7, #16]
    1e30:	6979      	ldr	r1, [r7, #20]
    1e32:	69ba      	ldr	r2, [r7, #24]
    1e34:	69fb      	ldr	r3, [r7, #28]
    1e36:	ac28      	add	r4, sp, #160	; 0xa0
    1e38:	e8ae 000f 	stmia.w	lr!, {r0, r1, r2, r3}
    1e3c:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    1e3e:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1e40:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    1e42:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1e44:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    1e46:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    1e48:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
{
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
    1e4c:	f1b8 0f3f 	cmp.w	r8, #63	; 0x3f
    1e50:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    1e54:	d92a      	bls.n	1eac <edsign_verify+0xb4>
		memcpy(init_block + prefix_size, message, len);
		sha512_final(&s, init_block, len + prefix_size);
	} else {
		size_t i;

		memcpy(init_block + prefix_size, message,
    1e56:	464c      	mov	r4, r9
    1e58:	f50d 7eb0 	add.w	lr, sp, #352	; 0x160
    1e5c:	f109 0c40 	add.w	ip, r9, #64	; 0x40
    1e60:	6820      	ldr	r0, [r4, #0]
    1e62:	6861      	ldr	r1, [r4, #4]
    1e64:	68a2      	ldr	r2, [r4, #8]
    1e66:	68e3      	ldr	r3, [r4, #12]
    1e68:	4675      	mov	r5, lr
    1e6a:	c50f      	stmia	r5!, {r0, r1, r2, r3}
    1e6c:	3410      	adds	r4, #16
    1e6e:	4564      	cmp	r4, ip
    1e70:	46ae      	mov	lr, r5
    1e72:	d1f5      	bne.n	1e60 <edsign_verify+0x68>
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);
    1e74:	a828      	add	r0, sp, #160	; 0xa0
    1e76:	a948      	add	r1, sp, #288	; 0x120
    1e78:	f003 fa38 	bl	52ec <sha512_block>

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e7c:	f1b8 0fbf 	cmp.w	r8, #191	; 0xbf
    1e80:	d970      	bls.n	1f64 <edsign_verify+0x16c>
		     i + SHA512_BLOCK_SIZE <= len;
    1e82:	24c0      	movs	r4, #192	; 0xc0

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e84:	2140      	movs	r1, #64	; 0x40
    1e86:	e001      	b.n	1e8c <edsign_verify+0x94>
    1e88:	4621      	mov	r1, r4
		     i + SHA512_BLOCK_SIZE <= len;
    1e8a:	462c      	mov	r4, r5
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1e8c:	4449      	add	r1, r9
    1e8e:	a828      	add	r0, sp, #160	; 0xa0
		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
		     i + SHA512_BLOCK_SIZE <= len;
    1e90:	f104 0580 	add.w	r5, r4, #128	; 0x80
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1e94:	f003 fa2a 	bl	52ec <sha512_block>

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e98:	45a8      	cmp	r8, r5
    1e9a:	d2f5      	bcs.n	1e88 <edsign_verify+0x90>
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
    1e9c:	eb09 0104 	add.w	r1, r9, r4
    1ea0:	f108 0240 	add.w	r2, r8, #64	; 0x40
    1ea4:	a828      	add	r0, sp, #160	; 0xa0
    1ea6:	f003 fc6b 	bl	5780 <sha512_final>
    1eaa:	e00a      	b.n	1ec2 <edsign_verify+0xca>
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
		memcpy(init_block + prefix_size, message, len);
    1eac:	4649      	mov	r1, r9
    1eae:	4642      	mov	r2, r8
    1eb0:	a858      	add	r0, sp, #352	; 0x160
    1eb2:	f004 fc55 	bl	6760 <memcpy>
		sha512_final(&s, init_block, len + prefix_size);
    1eb6:	a828      	add	r0, sp, #160	; 0xa0
    1eb8:	a948      	add	r1, sp, #288	; 0x120
    1eba:	f108 0240 	add.w	r2, r8, #64	; 0x40
    1ebe:	f003 fc5f 	bl	5780 <sha512_final>
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
	}

	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
    1ec2:	a828      	add	r0, sp, #160	; 0xa0
    1ec4:	a948      	add	r1, sp, #288	; 0x120
    1ec6:	2200      	movs	r2, #0
    1ec8:	2340      	movs	r3, #64	; 0x40
    1eca:	f003 fc9d 	bl	5808 <sha512_get>
	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
    1ece:	4b27      	ldr	r3, [pc, #156]	; (1f6c <edsign_verify+0x174>)
    1ed0:	a810      	add	r0, sp, #64	; 0x40
    1ed2:	a948      	add	r1, sp, #288	; 0x120
    1ed4:	2240      	movs	r2, #64	; 0x40
    1ed6:	f001 f807 	bl	2ee8 <fprime_from_bytes>

static void sm_pack(uint8_t *r, const uint8_t *k)
{
	struct ed25519_pt p;

	ed25519_smult(&p, &ed25519_base, k);
    1eda:	a848      	add	r0, sp, #288	; 0x120
    1edc:	f106 0220 	add.w	r2, r6, #32
    1ee0:	4923      	ldr	r1, [pc, #140]	; (1f70 <edsign_verify+0x178>)
    1ee2:	f7ff ff47 	bl	1d74 <ed25519_smult>
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1ee6:	a820      	add	r0, sp, #128	; 0x80
    1ee8:	a928      	add	r1, sp, #160	; 0xa0
    1eea:	aa48      	add	r2, sp, #288	; 0x120
    1eec:	f7ff fdc6 	bl	1a7c <ed25519_unproject>
	ed25519_pack(packed, x, y);
    1ef0:	a920      	add	r1, sp, #128	; 0x80
    1ef2:	4668      	mov	r0, sp
    1ef4:	aa28      	add	r2, sp, #160	; 0xa0
    1ef6:	f7ff fddf 	bl	1ab8 <ed25519_pack>

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1efa:	a948      	add	r1, sp, #288	; 0x120
    1efc:	463a      	mov	r2, r7
    1efe:	a820      	add	r0, sp, #128	; 0x80
    1f00:	f7ff fe0a 	bl	1b18 <ed25519_try_unpack>

	ed25519_project(p, x, y);
    1f04:	a920      	add	r1, sp, #128	; 0x80

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1f06:	4605      	mov	r5, r0

	ed25519_project(p, x, y);
    1f08:	aa48      	add	r2, sp, #288	; 0x120
    1f0a:	a828      	add	r0, sp, #160	; 0xa0
    1f0c:	f7ff fd7e 	bl	1a0c <ed25519_project>
	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
    1f10:	a828      	add	r0, sp, #160	; 0xa0
    1f12:	4601      	mov	r1, r0
    1f14:	aa10      	add	r2, sp, #64	; 0x40
    1f16:	f7ff ff2d 	bl	1d74 <ed25519_smult>

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1f1a:	4632      	mov	r2, r6
    1f1c:	a920      	add	r1, sp, #128	; 0x80
    1f1e:	a818      	add	r0, sp, #96	; 0x60
    1f20:	f7ff fdfa 	bl	1b18 <ed25519_try_unpack>

	ed25519_project(p, x, y);
    1f24:	a918      	add	r1, sp, #96	; 0x60

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1f26:	4604      	mov	r4, r0

	ed25519_project(p, x, y);
    1f28:	aa20      	add	r2, sp, #128	; 0x80
    1f2a:	a848      	add	r0, sp, #288	; 0x120
    1f2c:	f7ff fd6e 	bl	1a0c <ed25519_project>

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
    1f30:	a828      	add	r0, sp, #160	; 0xa0
    1f32:	4601      	mov	r1, r0
    1f34:	aa48      	add	r2, sp, #288	; 0x120
    1f36:	f7ff fe53 	bl	1be0 <ed25519_add>
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1f3a:	a818      	add	r0, sp, #96	; 0x60
    1f3c:	a920      	add	r1, sp, #128	; 0x80
    1f3e:	aa28      	add	r2, sp, #160	; 0xa0
    1f40:	f7ff fd9c 	bl	1a7c <ed25519_unproject>
	ed25519_pack(packed, x, y);
    1f44:	a918      	add	r1, sp, #96	; 0x60
    1f46:	aa20      	add	r2, sp, #128	; 0x80
    1f48:	a808      	add	r0, sp, #32
    1f4a:	f7ff fdb5 	bl	1ab8 <ed25519_pack>
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
    1f4e:	4668      	mov	r0, sp
    1f50:	a908      	add	r1, sp, #32
    1f52:	f000 f857 	bl	2004 <f25519_eq>

	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
    1f56:	4028      	ands	r0, r5
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
    1f58:	f000 0001 	and.w	r0, r0, #1
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
}
    1f5c:	4020      	ands	r0, r4
    1f5e:	b069      	add	sp, #420	; 0x1a4
    1f60:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1f64:	2440      	movs	r4, #64	; 0x40
    1f66:	e799      	b.n	1e9c <edsign_verify+0xa4>
    1f68:	00007280 	andeq	r7, r0, r0, lsl #5
    1f6c:	00007240 	andeq	r7, r0, r0, asr #4
    1f70:	000071a0 	andeq	r7, r0, r0, lsr #3

00001f74 <f25519_load>:

const uint8_t f25519_zero[F25519_SIZE] = {0};
const uint8_t f25519_one[F25519_SIZE] = {1};

void f25519_load(uint8_t *x, uint32_t c)
{
    1f74:	b410      	push	{r4}
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
		c >>= 8;
    1f76:	0c0a      	lsrs	r2, r1, #16
    1f78:	0a0c      	lsrs	r4, r1, #8
    1f7a:	0e0b      	lsrs	r3, r1, #24
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    1f7c:	7001      	strb	r1, [r0, #0]
    1f7e:	7082      	strb	r2, [r0, #2]
    1f80:	7044      	strb	r4, [r0, #1]
    1f82:	70c3      	strb	r3, [r0, #3]
    1f84:	2100      	movs	r1, #0
    1f86:	3004      	adds	r0, #4
    1f88:	221c      	movs	r2, #28
		c >>= 8;
	}

	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}
    1f8a:	f85d 4b04 	ldr.w	r4, [sp], #4
    1f8e:	f004 bbf0 	b.w	6772 <memset>
    1f92:	bf00      	nop

00001f94 <f25519_normalize>:

void f25519_normalize(uint8_t *x)
{
    1f94:	b410      	push	{r4}
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1f96:	7fc4      	ldrb	r4, [r0, #31]
	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}

void f25519_normalize(uint8_t *x)
{
    1f98:	b089      	sub	sp, #36	; 0x24
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1f9a:	09e1      	lsrs	r1, r4, #7
    1f9c:	00ca      	lsls	r2, r1, #3
	x[31] &= 127;
    1f9e:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1fa2:	440a      	add	r2, r1
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fa4:	2300      	movs	r3, #0
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;
    1fa6:	77c4      	strb	r4, [r0, #31]
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1fa8:	eb01 0242 	add.w	r2, r1, r2, lsl #1
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
		c += x[i];
    1fac:	5cc1      	ldrb	r1, [r0, r3]
    1fae:	440a      	add	r2, r1
		x[i] = c;
    1fb0:	54c2      	strb	r2, [r0, r3]

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fb2:	3301      	adds	r3, #1
    1fb4:	2b20      	cmp	r3, #32
		c += x[i];
		x[i] = c;
		c >>= 8;
    1fb6:	f3c2 220f 	ubfx	r2, r2, #8, #16

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fba:	d1f7      	bne.n	1fac <f25519_normalize+0x18>
    1fbc:	2300      	movs	r3, #0
    1fbe:	2213      	movs	r2, #19
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += x[i];
    1fc0:	5cc1      	ldrb	r1, [r0, r3]
    1fc2:	440a      	add	r2, r1
		minusp[i] = c;
    1fc4:	f80d 2003 	strb.w	r2, [sp, r3]
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1fc8:	3301      	adds	r3, #1
    1fca:	2b1f      	cmp	r3, #31
		c += x[i];
		minusp[i] = c;
		c >>= 8;
    1fcc:	f3c2 220f 	ubfx	r2, r2, #8, #16
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1fd0:	d1f6      	bne.n	1fc0 <f25519_normalize+0x2c>
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1fd2:	7fc1      	ldrb	r1, [r0, #31]
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fd4:	2300      	movs	r3, #0
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1fd6:	3980      	subs	r1, #128	; 0x80
    1fd8:	440a      	add	r2, r1
    1fda:	b292      	uxth	r2, r2

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1fdc:	f342 34c0 	sbfx	r4, r2, #15, #1
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;
    1fe0:	f88d 201f 	strb.w	r2, [sp, #31]

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1fe4:	b2e4      	uxtb	r4, r4
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    1fe6:	f81d 2003 	ldrb.w	r2, [sp, r3]
    1fea:	5cc1      	ldrb	r1, [r0, r3]
    1fec:	4051      	eors	r1, r2
    1fee:	4021      	ands	r1, r4
    1ff0:	404a      	eors	r2, r1
    1ff2:	54c2      	strb	r2, [r0, r3]
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1ff4:	3301      	adds	r3, #1
    1ff6:	2b20      	cmp	r3, #32
    1ff8:	d1f5      	bne.n	1fe6 <f25519_normalize+0x52>
	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;

	/* Load x-p if no underflow */
	f25519_select(x, minusp, x, (c >> 15) & 1);
}
    1ffa:	b009      	add	sp, #36	; 0x24
    1ffc:	f85d 4b04 	ldr.w	r4, [sp], #4
    2000:	4770      	bx	lr
    2002:	bf00      	nop

00002004 <f25519_eq>:

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
    2004:	ea40 0301 	orr.w	r3, r0, r1
    2008:	079b      	lsls	r3, r3, #30
    200a:	b4f0      	push	{r4, r5, r6, r7}
    200c:	d13c      	bne.n	2088 <f25519_eq+0x84>
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    200e:	6807      	ldr	r7, [r0, #0]
    2010:	6842      	ldr	r2, [r0, #4]
    2012:	684b      	ldr	r3, [r1, #4]
    2014:	680e      	ldr	r6, [r1, #0]
    2016:	6885      	ldr	r5, [r0, #8]
    2018:	688c      	ldr	r4, [r1, #8]
    201a:	ea82 0c03 	eor.w	ip, r2, r3
    201e:	407e      	eors	r6, r7
    2020:	68c2      	ldr	r2, [r0, #12]
    2022:	68cb      	ldr	r3, [r1, #12]
    2024:	ea46 060c 	orr.w	r6, r6, ip
    2028:	ea85 0c04 	eor.w	ip, r5, r4
    202c:	6905      	ldr	r5, [r0, #16]
    202e:	690c      	ldr	r4, [r1, #16]
    2030:	ea46 0c0c 	orr.w	ip, r6, ip
    2034:	ea82 0603 	eor.w	r6, r2, r3
    2038:	6942      	ldr	r2, [r0, #20]
    203a:	694b      	ldr	r3, [r1, #20]
    203c:	ea4c 0c06 	orr.w	ip, ip, r6
    2040:	6987      	ldr	r7, [r0, #24]
    2042:	698e      	ldr	r6, [r1, #24]
    2044:	406c      	eors	r4, r5
    2046:	ea4c 0404 	orr.w	r4, ip, r4
    204a:	4053      	eors	r3, r2
    204c:	69c0      	ldr	r0, [r0, #28]
    204e:	69c9      	ldr	r1, [r1, #28]
    2050:	ea44 0203 	orr.w	r2, r4, r3
    2054:	ea87 0406 	eor.w	r4, r7, r6
    2058:	4322      	orrs	r2, r4
    205a:	ea80 0301 	eor.w	r3, r0, r1
    205e:	4313      	orrs	r3, r2
    2060:	ea43 2213 	orr.w	r2, r3, r3, lsr #8
    2064:	ea42 4213 	orr.w	r2, r2, r3, lsr #16
    2068:	f002 02ff 	and.w	r2, r2, #255	; 0xff
    206c:	ea42 6213 	orr.w	r2, r2, r3, lsr #24

	sum |= (sum >> 4);
    2070:	ea42 1212 	orr.w	r2, r2, r2, lsr #4
	sum |= (sum >> 2);
    2074:	ea42 0292 	orr.w	r2, r2, r2, lsr #2
	sum |= (sum >> 1);
    2078:	ea42 0252 	orr.w	r2, r2, r2, lsr #1

	return (sum ^ 1) & 1;
    207c:	f002 0001 	and.w	r0, r2, #1
}
    2080:	f080 0001 	eor.w	r0, r0, #1
    2084:	bcf0      	pop	{r4, r5, r6, r7}
    2086:	4770      	bx	lr
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2088:	2300      	movs	r3, #0
	f25519_select(x, minusp, x, (c >> 15) & 1);
}

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
    208a:	461a      	mov	r2, r3
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    208c:	5cc5      	ldrb	r5, [r0, r3]
    208e:	5ccc      	ldrb	r4, [r1, r3]
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2090:	3301      	adds	r3, #1
		sum |= x[i] ^ y[i];
    2092:	406c      	eors	r4, r5
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2094:	2b20      	cmp	r3, #32
		sum |= x[i] ^ y[i];
    2096:	ea42 0204 	orr.w	r2, r2, r4
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    209a:	d1f7      	bne.n	208c <f25519_eq+0x88>
    209c:	e7e8      	b.n	2070 <f25519_eq+0x6c>
    209e:	bf00      	nop

000020a0 <f25519_select>:
}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
    20a0:	b4f0      	push	{r4, r5, r6, r7}
    20a2:	1d04      	adds	r4, r0, #4
    20a4:	1d0f      	adds	r7, r1, #4
    20a6:	42b8      	cmp	r0, r7
    20a8:	bf38      	it	cc
    20aa:	42a1      	cmpcc	r1, r4
    20ac:	f102 0504 	add.w	r5, r2, #4
    20b0:	bf34      	ite	cc
    20b2:	2700      	movcc	r7, #0
    20b4:	2701      	movcs	r7, #1
    20b6:	42a8      	cmp	r0, r5
    20b8:	bf38      	it	cc
    20ba:	42a2      	cmpcc	r2, r4
    20bc:	bf34      	ite	cc
    20be:	2400      	movcc	r4, #0
    20c0:	2401      	movcs	r4, #1
	const uint8_t mask = -condition;
    20c2:	425b      	negs	r3, r3
    20c4:	4227      	tst	r7, r4
    20c6:	b2de      	uxtb	r6, r3
    20c8:	d03f      	beq.n	214a <f25519_select+0xaa>
    20ca:	ea41 0302 	orr.w	r3, r1, r2
    20ce:	4303      	orrs	r3, r0
    20d0:	079b      	lsls	r3, r3, #30
    20d2:	d13a      	bne.n	214a <f25519_select+0xaa>
    20d4:	2300      	movs	r3, #0
    20d6:	f366 0307 	bfi	r3, r6, #0, #8
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    20da:	680c      	ldr	r4, [r1, #0]
    20dc:	6815      	ldr	r5, [r2, #0]
    20de:	f366 230f 	bfi	r3, r6, #8, #8
    20e2:	f366 4317 	bfi	r3, r6, #16, #8
    20e6:	f366 631f 	bfi	r3, r6, #24, #8
    20ea:	4065      	eors	r5, r4
    20ec:	401d      	ands	r5, r3
    20ee:	406c      	eors	r4, r5
    20f0:	6004      	str	r4, [r0, #0]
    20f2:	684c      	ldr	r4, [r1, #4]
    20f4:	6855      	ldr	r5, [r2, #4]
    20f6:	4065      	eors	r5, r4
    20f8:	401d      	ands	r5, r3
    20fa:	406c      	eors	r4, r5
    20fc:	6044      	str	r4, [r0, #4]
    20fe:	688c      	ldr	r4, [r1, #8]
    2100:	6895      	ldr	r5, [r2, #8]
    2102:	4065      	eors	r5, r4
    2104:	401d      	ands	r5, r3
    2106:	406c      	eors	r4, r5
    2108:	6084      	str	r4, [r0, #8]
    210a:	68cc      	ldr	r4, [r1, #12]
    210c:	68d5      	ldr	r5, [r2, #12]
    210e:	4065      	eors	r5, r4
    2110:	401d      	ands	r5, r3
    2112:	406c      	eors	r4, r5
    2114:	60c4      	str	r4, [r0, #12]
    2116:	690c      	ldr	r4, [r1, #16]
    2118:	6915      	ldr	r5, [r2, #16]
    211a:	4065      	eors	r5, r4
    211c:	401d      	ands	r5, r3
    211e:	406c      	eors	r4, r5
    2120:	6104      	str	r4, [r0, #16]
    2122:	694c      	ldr	r4, [r1, #20]
    2124:	6955      	ldr	r5, [r2, #20]
    2126:	4065      	eors	r5, r4
    2128:	401d      	ands	r5, r3
    212a:	406c      	eors	r4, r5
    212c:	6144      	str	r4, [r0, #20]
    212e:	698c      	ldr	r4, [r1, #24]
    2130:	6995      	ldr	r5, [r2, #24]
    2132:	4065      	eors	r5, r4
    2134:	401d      	ands	r5, r3
    2136:	406c      	eors	r4, r5
    2138:	6184      	str	r4, [r0, #24]
    213a:	69c9      	ldr	r1, [r1, #28]
    213c:	69d2      	ldr	r2, [r2, #28]
}
    213e:	bcf0      	pop	{r4, r5, r6, r7}
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    2140:	404a      	eors	r2, r1
    2142:	4013      	ands	r3, r2
    2144:	4059      	eors	r1, r3
    2146:	61c1      	str	r1, [r0, #28]
}
    2148:	4770      	bx	lr
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    214a:	2300      	movs	r3, #0
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    214c:	5ccc      	ldrb	r4, [r1, r3]
    214e:	5cd5      	ldrb	r5, [r2, r3]
    2150:	4065      	eors	r5, r4
    2152:	4035      	ands	r5, r6
    2154:	406c      	eors	r4, r5
    2156:	54c4      	strb	r4, [r0, r3]
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2158:	3301      	adds	r3, #1
    215a:	2b20      	cmp	r3, #32
    215c:	d1f6      	bne.n	214c <f25519_select+0xac>
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}
    215e:	bcf0      	pop	{r4, r5, r6, r7}
    2160:	4770      	bx	lr
    2162:	bf00      	nop

00002164 <f25519_add>:
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    2164:	2300      	movs	r3, #0
	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}

void f25519_add(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2166:	b470      	push	{r4, r5, r6}
	uint16_t c = 0;
    2168:	461c      	mov	r4, r3
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
    216a:	5cce      	ldrb	r6, [r1, r3]
    216c:	5cd5      	ldrb	r5, [r2, r3]
    216e:	4435      	add	r5, r6
    2170:	eb05 2414 	add.w	r4, r5, r4, lsr #8
		r[i] = c;
    2174:	54c4      	strb	r4, [r0, r3]
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    2176:	3301      	adds	r3, #1
    2178:	2b20      	cmp	r3, #32
    217a:	d1f6      	bne.n	216a <f25519_add+0x6>
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;
    217c:	f3c4 14cf 	ubfx	r4, r4, #7, #16
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    2180:	7fc3      	ldrb	r3, [r0, #31]
	c = (c >> 7) * 19;
    2182:	eb04 02c4 	add.w	r2, r4, r4, lsl #3
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    2186:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	c = (c >> 7) * 19;
    218a:	eb04 0242 	add.w	r2, r4, r2, lsl #1
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    218e:	77c3      	strb	r3, [r0, #31]
	c = (c >> 7) * 19;
    2190:	b292      	uxth	r2, r2

	for (i = 0; i < F25519_SIZE; i++) {
    2192:	2300      	movs	r3, #0
		c += r[i];
    2194:	5cc1      	ldrb	r1, [r0, r3]
    2196:	440a      	add	r2, r1
    2198:	b292      	uxth	r2, r2
		r[i] = c;
    219a:	54c2      	strb	r2, [r0, r3]

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    219c:	3301      	adds	r3, #1
    219e:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    21a0:	ea4f 2212 	mov.w	r2, r2, lsr #8

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21a4:	d1f6      	bne.n	2194 <f25519_add+0x30>
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    21a6:	bc70      	pop	{r4, r5, r6}
    21a8:	4770      	bx	lr
    21aa:	bf00      	nop

000021ac <f25519_sub>:

void f25519_sub(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    21ac:	b470      	push	{r4, r5, r6}
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21ae:	2300      	movs	r3, #0
{
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
    21b0:	24da      	movs	r4, #218	; 0xda
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    21b2:	5ccd      	ldrb	r5, [r1, r3]
    21b4:	5cd6      	ldrb	r6, [r2, r3]
    21b6:	f505 457f 	add.w	r5, r5, #65280	; 0xff00
    21ba:	1bad      	subs	r5, r5, r6
    21bc:	442c      	add	r4, r5
		r[i] = c;
    21be:	54c4      	strb	r4, [r0, r3]
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21c0:	3301      	adds	r3, #1
    21c2:	2b1f      	cmp	r3, #31
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    21c4:	ea4f 2414 	mov.w	r4, r4, lsr #8
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21c8:	d1f3      	bne.n	21b2 <f25519_sub+0x6>
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    21ca:	7fc9      	ldrb	r1, [r1, #31]
    21cc:	7fd2      	ldrb	r2, [r2, #31]
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21ce:	2300      	movs	r3, #0
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    21d0:	1a8a      	subs	r2, r1, r2
    21d2:	4414      	add	r4, r2
	r[31] = c & 127;
	c = (c >> 7) * 19;
    21d4:	09e2      	lsrs	r2, r4, #7
    21d6:	eb02 01c2 	add.w	r1, r2, r2, lsl #3
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    21da:	f004 047f 	and.w	r4, r4, #127	; 0x7f
    21de:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;
    21e0:	eb02 0241 	add.w	r2, r2, r1, lsl #1

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    21e4:	5cc1      	ldrb	r1, [r0, r3]
    21e6:	440a      	add	r2, r1
		r[i] = c;
    21e8:	54c2      	strb	r2, [r0, r3]

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21ea:	3301      	adds	r3, #1
    21ec:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    21ee:	ea4f 2212 	mov.w	r2, r2, lsr #8

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21f2:	d1f7      	bne.n	21e4 <f25519_sub+0x38>
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    21f4:	bc70      	pop	{r4, r5, r6}
    21f6:	4770      	bx	lr

000021f8 <f25519_neg>:

void f25519_neg(uint8_t *r, const uint8_t *a)
{
    21f8:	b410      	push	{r4}
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21fa:	2300      	movs	r3, #0
{
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
    21fc:	22da      	movs	r2, #218	; 0xda
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 - ((uint32_t)a[i]);
    21fe:	5ccc      	ldrb	r4, [r1, r3]
    2200:	f5c4 447f 	rsb	r4, r4, #65280	; 0xff00
    2204:	4422      	add	r2, r4
		r[i] = c;
    2206:	54c2      	strb	r2, [r0, r3]
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2208:	3301      	adds	r3, #1
    220a:	2b1f      	cmp	r3, #31
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
    220c:	ea4f 2212 	mov.w	r2, r2, lsr #8
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2210:	d1f5      	bne.n	21fe <f25519_neg+0x6>
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
    2212:	7fc9      	ldrb	r1, [r1, #31]
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2214:	2300      	movs	r3, #0
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
    2216:	1a52      	subs	r2, r2, r1
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2218:	09d1      	lsrs	r1, r2, #7
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    221a:	f002 047f 	and.w	r4, r2, #127	; 0x7f
	c = (c >> 7) * 19;
    221e:	eb01 02c1 	add.w	r2, r1, r1, lsl #3
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    2222:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;
    2224:	eb01 0242 	add.w	r2, r1, r2, lsl #1

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2228:	5cc1      	ldrb	r1, [r0, r3]
    222a:	440a      	add	r2, r1
		r[i] = c;
    222c:	54c2      	strb	r2, [r0, r3]

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    222e:	3301      	adds	r3, #1
    2230:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    2232:	ea4f 2212 	mov.w	r2, r2, lsr #8

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2236:	d1f7      	bne.n	2228 <f25519_neg+0x30>
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    2238:	f85d 4b04 	ldr.w	r4, [sp], #4
    223c:	4770      	bx	lr
    223e:	bf00      	nop

00002240 <f25519_mul__distinct>:

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2240:	e92d 03f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9}
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2244:	f04f 0800 	mov.w	r8, #0
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    2248:	4643      	mov	r3, r8
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    224a:	f04f 0926 	mov.w	r9, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    224e:	0a1b      	lsrs	r3, r3, #8
    2250:	eb02 0508 	add.w	r5, r2, r8
		for (j = 0; j <= i; j++)
    2254:	2400      	movs	r4, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2256:	5d0f      	ldrb	r7, [r1, r4]
    2258:	f815 6901 	ldrb.w	r6, [r5], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    225c:	3401      	adds	r4, #1
    225e:	4544      	cmp	r4, r8
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2260:	fb07 3306 	mla	r3, r7, r6, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2264:	ddf7      	ble.n	2256 <f25519_mul__distinct+0x16>
    2266:	ea28 75e8 	bic.w	r5, r8, r8, asr #31
    226a:	1c6c      	adds	r4, r5, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    226c:	2c20      	cmp	r4, #32
    226e:	d00f      	beq.n	2290 <f25519_mul__distinct+0x50>
    2270:	ebc5 0608 	rsb	r6, r5, r8
    2274:	3620      	adds	r6, #32
    2276:	4416      	add	r6, r2
    2278:	440d      	add	r5, r1
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    227a:	f816 7d01 	ldrb.w	r7, [r6, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    227e:	f815 cf01 	ldrb.w	ip, [r5, #1]!
    2282:	fb09 f707 	mul.w	r7, r9, r7

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2286:	3401      	adds	r4, #1
    2288:	2c20      	cmp	r4, #32
			c += ((uint32_t)a[j]) *
    228a:	fb0c 3307 	mla	r3, ip, r7, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    228e:	d1f4      	bne.n	227a <f25519_mul__distinct+0x3a>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2290:	f800 3008 	strb.w	r3, [r0, r8]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2294:	f108 0801 	add.w	r8, r8, #1
    2298:	f1b8 0f20 	cmp.w	r8, #32
    229c:	d1d7      	bne.n	224e <f25519_mul__distinct+0xe>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    229e:	7fc1      	ldrb	r1, [r0, #31]
	c = (c >> 7) * 19;
    22a0:	09db      	lsrs	r3, r3, #7
    22a2:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22a6:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    22aa:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22ae:	77c1      	strb	r1, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22b0:	2300      	movs	r3, #0
		c += r[i];
    22b2:	5cc1      	ldrb	r1, [r0, r3]
    22b4:	440a      	add	r2, r1
		r[i] = c;
    22b6:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22b8:	3301      	adds	r3, #1
    22ba:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    22bc:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22c0:	d1f7      	bne.n	22b2 <f25519_mul__distinct+0x72>
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    22c2:	e8bd 03f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9}
    22c6:	4770      	bx	lr

000022c8 <f25519_inv__distinct>:
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    22c8:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    22cc:	2600      	movs	r6, #0
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    22ce:	b088      	sub	sp, #32
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    22d0:	4633      	mov	r3, r6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22d2:	f04f 0826 	mov.w	r8, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    22d6:	0a1b      	lsrs	r3, r3, #8
    22d8:	1874      	adds	r4, r6, r1
		for (j = 0; j <= i; j++)
    22da:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22dc:	5c8f      	ldrb	r7, [r1, r2]
    22de:	f814 5901 	ldrb.w	r5, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22e2:	3201      	adds	r2, #1
    22e4:	42b2      	cmp	r2, r6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22e6:	fb07 3305 	mla	r3, r7, r5, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22ea:	ddf7      	ble.n	22dc <f25519_inv__distinct+0x14>
    22ec:	ea26 74e6 	bic.w	r4, r6, r6, asr #31
    22f0:	1c62      	adds	r2, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22f2:	2a20      	cmp	r2, #32
    22f4:	d00e      	beq.n	2314 <f25519_inv__distinct+0x4c>
    22f6:	1b35      	subs	r5, r6, r4
    22f8:	3520      	adds	r5, #32
    22fa:	440d      	add	r5, r1
    22fc:	440c      	add	r4, r1
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    22fe:	f815 7d01 	ldrb.w	r7, [r5, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2302:	f814 cf01 	ldrb.w	ip, [r4, #1]!
    2306:	fb08 f707 	mul.w	r7, r8, r7

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    230a:	3201      	adds	r2, #1
    230c:	2a20      	cmp	r2, #32
			c += ((uint32_t)a[j]) *
    230e:	fb0c 3307 	mla	r3, ip, r7, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2312:	d1f4      	bne.n	22fe <f25519_inv__distinct+0x36>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2314:	f80d 3006 	strb.w	r3, [sp, r6]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2318:	3601      	adds	r6, #1
    231a:	2e20      	cmp	r6, #32
    231c:	d1db      	bne.n	22d6 <f25519_inv__distinct+0xe>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    231e:	f89d 401f 	ldrb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    2322:	09db      	lsrs	r3, r3, #7
    2324:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2328:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    232c:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2330:	f88d 401f 	strb.w	r4, [sp, #31]
    2334:	af08      	add	r7, sp, #32
	c = (c >> 7) * 19;
    2336:	466b      	mov	r3, sp

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2338:	781c      	ldrb	r4, [r3, #0]
    233a:	4422      	add	r2, r4
		r[i] = c;
    233c:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2340:	42bb      	cmp	r3, r7
		c += r[i];
		r[i] = c;
		c >>= 8;
    2342:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2346:	d1f7      	bne.n	2338 <f25519_inv__distinct+0x70>
    2348:	2500      	movs	r5, #0
    234a:	eb0d 0205 	add.w	r2, sp, r5
    234e:	462b      	mov	r3, r5
    2350:	f102 091f 	add.w	r9, r2, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2354:	f04f 0826 	mov.w	r8, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2358:	0a1b      	lsrs	r3, r3, #8
    235a:	194c      	adds	r4, r1, r5
		for (j = 0; j <= i; j++)
    235c:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    235e:	f81d c002 	ldrb.w	ip, [sp, r2]
    2362:	f814 6901 	ldrb.w	r6, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2366:	3201      	adds	r2, #1
    2368:	42aa      	cmp	r2, r5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    236a:	fb0c 3306 	mla	r3, ip, r6, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    236e:	ddf6      	ble.n	235e <f25519_inv__distinct+0x96>
    2370:	ea25 72e5 	bic.w	r2, r5, r5, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2374:	2a1f      	cmp	r2, #31
    2376:	d00e      	beq.n	2396 <f25519_inv__distinct+0xce>
    2378:	1aac      	subs	r4, r5, r2
    237a:	3420      	adds	r4, #32
    237c:	ae00      	add	r6, sp, #0
    237e:	440c      	add	r4, r1
    2380:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2382:	f814 6d01 	ldrb.w	r6, [r4, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2386:	f812 cf01 	ldrb.w	ip, [r2, #1]!
    238a:	fb08 f606 	mul.w	r6, r8, r6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    238e:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) *
    2390:	fb0c 3306 	mla	r3, ip, r6, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2394:	d1f5      	bne.n	2382 <f25519_inv__distinct+0xba>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2396:	5543      	strb	r3, [r0, r5]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2398:	3501      	adds	r5, #1
    239a:	2d20      	cmp	r5, #32
    239c:	d1dc      	bne.n	2358 <f25519_inv__distinct+0x90>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    239e:	7fc4      	ldrb	r4, [r0, #31]
	c = (c >> 7) * 19;
    23a0:	09db      	lsrs	r3, r3, #7
    23a2:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    23a6:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    23aa:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    23ae:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23b0:	2300      	movs	r3, #0
		c += r[i];
    23b2:	5cc4      	ldrb	r4, [r0, r3]
    23b4:	4422      	add	r2, r4
		r[i] = c;
    23b6:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23b8:	3301      	adds	r3, #1
    23ba:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    23bc:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23c0:	d1f7      	bne.n	23b2 <f25519_inv__distinct+0xea>
    23c2:	f04f 0cf8 	mov.w	ip, #248	; 0xf8
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    23c6:	2526      	movs	r5, #38	; 0x26
    23c8:	f10d 061f 	add.w	r6, sp, #31
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23cc:	f04f 0900 	mov.w	r9, #0
    23d0:	464b      	mov	r3, r9
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    23d2:	0a1b      	lsrs	r3, r3, #8
    23d4:	eb09 0400 	add.w	r4, r9, r0
		for (j = 0; j <= i; j++)
    23d8:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23da:	f810 a002 	ldrb.w	sl, [r0, r2]
    23de:	f814 8901 	ldrb.w	r8, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23e2:	3201      	adds	r2, #1
    23e4:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23e6:	fb0a 3308 	mla	r3, sl, r8, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23ea:	ddf6      	ble.n	23da <f25519_inv__distinct+0x112>
    23ec:	ea29 74e9 	bic.w	r4, r9, r9, asr #31
    23f0:	1c62      	adds	r2, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23f2:	2a20      	cmp	r2, #32
    23f4:	d010      	beq.n	2418 <f25519_inv__distinct+0x150>
    23f6:	ebc4 0809 	rsb	r8, r4, r9
    23fa:	f108 0820 	add.w	r8, r8, #32
    23fe:	4480      	add	r8, r0
    2400:	4404      	add	r4, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2402:	f818 ad01 	ldrb.w	sl, [r8, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2406:	f814 bf01 	ldrb.w	fp, [r4, #1]!
    240a:	fb05 fa0a 	mul.w	sl, r5, sl

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    240e:	3201      	adds	r2, #1
    2410:	2a20      	cmp	r2, #32
			c += ((uint32_t)a[j]) *
    2412:	fb0b 330a 	mla	r3, fp, sl, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2416:	d1f4      	bne.n	2402 <f25519_inv__distinct+0x13a>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2418:	f80d 3009 	strb.w	r3, [sp, r9]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    241c:	f109 0901 	add.w	r9, r9, #1
    2420:	f1b9 0f20 	cmp.w	r9, #32
    2424:	d1d5      	bne.n	23d2 <f25519_inv__distinct+0x10a>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2426:	f89d 401f 	ldrb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    242a:	09db      	lsrs	r3, r3, #7
    242c:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2430:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    2434:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2438:	f88d 401f 	strb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    243c:	ab00      	add	r3, sp, #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    243e:	781c      	ldrb	r4, [r3, #0]
    2440:	4422      	add	r2, r4
		r[i] = c;
    2442:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2446:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2448:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    244c:	d1f7      	bne.n	243e <f25519_inv__distinct+0x176>
    244e:	f04f 0900 	mov.w	r9, #0
    2452:	464b      	mov	r3, r9
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2454:	0a1b      	lsrs	r3, r3, #8
    2456:	eb01 0409 	add.w	r4, r1, r9
		for (j = 0; j <= i; j++)
    245a:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    245c:	f81d a002 	ldrb.w	sl, [sp, r2]
    2460:	f814 8901 	ldrb.w	r8, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2464:	3201      	adds	r2, #1
    2466:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2468:	fb0a 3308 	mla	r3, sl, r8, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    246c:	ddf6      	ble.n	245c <f25519_inv__distinct+0x194>
    246e:	ea29 72e9 	bic.w	r2, r9, r9, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2472:	2a1f      	cmp	r2, #31
    2474:	d010      	beq.n	2498 <f25519_inv__distinct+0x1d0>
    2476:	ebc2 0409 	rsb	r4, r2, r9
    247a:	3420      	adds	r4, #32
    247c:	f10d 0800 	add.w	r8, sp, #0
    2480:	440c      	add	r4, r1
    2482:	4442      	add	r2, r8
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2484:	f814 8d01 	ldrb.w	r8, [r4, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2488:	f812 af01 	ldrb.w	sl, [r2, #1]!
    248c:	fb05 f808 	mul.w	r8, r5, r8

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2490:	42b2      	cmp	r2, r6
			c += ((uint32_t)a[j]) *
    2492:	fb0a 3308 	mla	r3, sl, r8, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2496:	d1f5      	bne.n	2484 <f25519_inv__distinct+0x1bc>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2498:	f800 3009 	strb.w	r3, [r0, r9]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    249c:	f109 0901 	add.w	r9, r9, #1
    24a0:	f1b9 0f20 	cmp.w	r9, #32
    24a4:	d1d6      	bne.n	2454 <f25519_inv__distinct+0x18c>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    24a6:	7fc4      	ldrb	r4, [r0, #31]
	c = (c >> 7) * 19;
    24a8:	09db      	lsrs	r3, r3, #7
    24aa:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    24ae:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    24b2:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    24b6:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24b8:	2300      	movs	r3, #0
		c += r[i];
    24ba:	5cc4      	ldrb	r4, [r0, r3]
    24bc:	4422      	add	r2, r4
		r[i] = c;
    24be:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24c0:	3301      	adds	r3, #1
    24c2:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    24c4:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24c8:	d1f7      	bne.n	24ba <f25519_inv__distinct+0x1f2>
	/* 1 1 */
	f25519_mul__distinct(s, x, x);
	f25519_mul__distinct(r, s, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    24ca:	f1bc 0c01 	subs.w	ip, ip, #1
    24ce:	f47f af7d 	bne.w	23cc <f25519_inv__distinct+0x104>
    24d2:	4663      	mov	r3, ip
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24d4:	f04f 0926 	mov.w	r9, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    24d8:	0a1b      	lsrs	r3, r3, #8
    24da:	eb00 040c 	add.w	r4, r0, ip
		for (j = 0; j <= i; j++)
    24de:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24e0:	5c86      	ldrb	r6, [r0, r2]
    24e2:	f814 5901 	ldrb.w	r5, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24e6:	3201      	adds	r2, #1
    24e8:	4562      	cmp	r2, ip
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24ea:	fb06 3305 	mla	r3, r6, r5, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24ee:	ddf7      	ble.n	24e0 <f25519_inv__distinct+0x218>
    24f0:	ea2c 74ec 	bic.w	r4, ip, ip, asr #31
    24f4:	1c62      	adds	r2, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24f6:	2a20      	cmp	r2, #32
    24f8:	d00f      	beq.n	251a <f25519_inv__distinct+0x252>
    24fa:	ebc4 050c 	rsb	r5, r4, ip
    24fe:	3520      	adds	r5, #32
    2500:	4405      	add	r5, r0
    2502:	4404      	add	r4, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2504:	f815 6d01 	ldrb.w	r6, [r5, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2508:	f814 8f01 	ldrb.w	r8, [r4, #1]!
    250c:	fb09 f606 	mul.w	r6, r9, r6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2510:	3201      	adds	r2, #1
    2512:	2a20      	cmp	r2, #32
			c += ((uint32_t)a[j]) *
    2514:	fb08 3306 	mla	r3, r8, r6, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2518:	d1f4      	bne.n	2504 <f25519_inv__distinct+0x23c>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    251a:	f80d 300c 	strb.w	r3, [sp, ip]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    251e:	f10c 0c01 	add.w	ip, ip, #1
    2522:	f1bc 0f20 	cmp.w	ip, #32
    2526:	d1d7      	bne.n	24d8 <f25519_inv__distinct+0x210>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2528:	f89d 401f 	ldrb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    252c:	09db      	lsrs	r3, r3, #7
    252e:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2532:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    2536:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    253a:	f88d 401f 	strb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    253e:	ab00      	add	r3, sp, #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2540:	781c      	ldrb	r4, [r3, #0]
    2542:	4422      	add	r2, r4
		r[i] = c;
    2544:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2548:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    254a:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    254e:	d1f7      	bne.n	2540 <f25519_inv__distinct+0x278>
    2550:	2500      	movs	r5, #0
    2552:	eb0d 0205 	add.w	r2, sp, r5
    2556:	462b      	mov	r3, r5
    2558:	f102 091f 	add.w	r9, r2, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    255c:	f04f 0826 	mov.w	r8, #38	; 0x26
    2560:	ac00      	add	r4, sp, #0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2562:	0a1b      	lsrs	r3, r3, #8
    2564:	442c      	add	r4, r5
		for (j = 0; j <= i; j++)
    2566:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2568:	f81d c002 	ldrb.w	ip, [sp, r2]
    256c:	f814 6901 	ldrb.w	r6, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2570:	3201      	adds	r2, #1
    2572:	42aa      	cmp	r2, r5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2574:	fb0c 3306 	mla	r3, ip, r6, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2578:	ddf6      	ble.n	2568 <f25519_inv__distinct+0x2a0>
    257a:	ea25 72e5 	bic.w	r2, r5, r5, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    257e:	2a1f      	cmp	r2, #31
    2580:	d00e      	beq.n	25a0 <f25519_inv__distinct+0x2d8>
    2582:	1aac      	subs	r4, r5, r2
    2584:	ae00      	add	r6, sp, #0
    2586:	3420      	adds	r4, #32
    2588:	4434      	add	r4, r6
    258a:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    258c:	f814 6d01 	ldrb.w	r6, [r4, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2590:	f812 cf01 	ldrb.w	ip, [r2, #1]!
    2594:	fb08 f606 	mul.w	r6, r8, r6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2598:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) *
    259a:	fb0c 3306 	mla	r3, ip, r6, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    259e:	d1f5      	bne.n	258c <f25519_inv__distinct+0x2c4>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    25a0:	5543      	strb	r3, [r0, r5]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    25a2:	3501      	adds	r5, #1
    25a4:	2d20      	cmp	r5, #32
    25a6:	d1db      	bne.n	2560 <f25519_inv__distinct+0x298>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25a8:	7fc4      	ldrb	r4, [r0, #31]
	c = (c >> 7) * 19;
    25aa:	09db      	lsrs	r3, r3, #7
    25ac:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25b0:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    25b4:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25b8:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    25ba:	2300      	movs	r3, #0
		c += r[i];
    25bc:	5cc4      	ldrb	r4, [r0, r3]
    25be:	4422      	add	r2, r4
		r[i] = c;
    25c0:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    25c2:	3301      	adds	r3, #1
    25c4:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    25c6:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    25ca:	d1f7      	bne.n	25bc <f25519_inv__distinct+0x2f4>
    25cc:	2600      	movs	r6, #0
    25ce:	4633      	mov	r3, r6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25d0:	f04f 0926 	mov.w	r9, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    25d4:	0a1b      	lsrs	r3, r3, #8
    25d6:	198c      	adds	r4, r1, r6
		for (j = 0; j <= i; j++)
    25d8:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25da:	f810 c002 	ldrb.w	ip, [r0, r2]
    25de:	f814 5901 	ldrb.w	r5, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25e2:	3201      	adds	r2, #1
    25e4:	42b2      	cmp	r2, r6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25e6:	fb0c 3305 	mla	r3, ip, r5, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25ea:	ddf6      	ble.n	25da <f25519_inv__distinct+0x312>
    25ec:	ea26 74e6 	bic.w	r4, r6, r6, asr #31
    25f0:	1c62      	adds	r2, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25f2:	2a20      	cmp	r2, #32
    25f4:	d00e      	beq.n	2614 <f25519_inv__distinct+0x34c>
    25f6:	1b35      	subs	r5, r6, r4
    25f8:	3520      	adds	r5, #32
    25fa:	440d      	add	r5, r1
    25fc:	4404      	add	r4, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    25fe:	f815 cd01 	ldrb.w	ip, [r5, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2602:	f814 8f01 	ldrb.w	r8, [r4, #1]!
    2606:	fb09 fc0c 	mul.w	ip, r9, ip

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    260a:	3201      	adds	r2, #1
    260c:	2a20      	cmp	r2, #32
			c += ((uint32_t)a[j]) *
    260e:	fb08 330c 	mla	r3, r8, ip, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2612:	d1f4      	bne.n	25fe <f25519_inv__distinct+0x336>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2614:	f80d 3006 	strb.w	r3, [sp, r6]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2618:	3601      	adds	r6, #1
    261a:	2e20      	cmp	r6, #32
    261c:	d1da      	bne.n	25d4 <f25519_inv__distinct+0x30c>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    261e:	f89d 401f 	ldrb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    2622:	09db      	lsrs	r3, r3, #7
    2624:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2628:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    262c:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2630:	f88d 401f 	strb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    2634:	ab00      	add	r3, sp, #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2636:	781c      	ldrb	r4, [r3, #0]
    2638:	4422      	add	r2, r4
		r[i] = c;
    263a:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    263e:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2640:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2644:	d1f7      	bne.n	2636 <f25519_inv__distinct+0x36e>
    2646:	2500      	movs	r5, #0
    2648:	eb0d 0805 	add.w	r8, sp, r5
    264c:	f108 091f 	add.w	r9, r8, #31
    2650:	462b      	mov	r3, r5
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2652:	f04f 0826 	mov.w	r8, #38	; 0x26
    2656:	ac00      	add	r4, sp, #0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2658:	0a1b      	lsrs	r3, r3, #8
    265a:	442c      	add	r4, r5
		for (j = 0; j <= i; j++)
    265c:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    265e:	f81d c002 	ldrb.w	ip, [sp, r2]
    2662:	f814 6901 	ldrb.w	r6, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2666:	3201      	adds	r2, #1
    2668:	42aa      	cmp	r2, r5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    266a:	fb0c 3306 	mla	r3, ip, r6, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    266e:	ddf6      	ble.n	265e <f25519_inv__distinct+0x396>
    2670:	ea25 72e5 	bic.w	r2, r5, r5, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2674:	2a1f      	cmp	r2, #31
    2676:	d00e      	beq.n	2696 <f25519_inv__distinct+0x3ce>
    2678:	1aac      	subs	r4, r5, r2
    267a:	ae00      	add	r6, sp, #0
    267c:	3420      	adds	r4, #32
    267e:	4434      	add	r4, r6
    2680:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2682:	f814 6d01 	ldrb.w	r6, [r4, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2686:	f812 cf01 	ldrb.w	ip, [r2, #1]!
    268a:	fb08 f606 	mul.w	r6, r8, r6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    268e:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) *
    2690:	fb0c 3306 	mla	r3, ip, r6, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2694:	d1f5      	bne.n	2682 <f25519_inv__distinct+0x3ba>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2696:	5543      	strb	r3, [r0, r5]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2698:	3501      	adds	r5, #1
    269a:	2d20      	cmp	r5, #32
    269c:	d1db      	bne.n	2656 <f25519_inv__distinct+0x38e>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    269e:	7fc4      	ldrb	r4, [r0, #31]
	c = (c >> 7) * 19;
    26a0:	09db      	lsrs	r3, r3, #7
    26a2:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26a6:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    26aa:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26ae:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    26b0:	2300      	movs	r3, #0
		c += r[i];
    26b2:	5cc4      	ldrb	r4, [r0, r3]
    26b4:	4422      	add	r2, r4
		r[i] = c;
    26b6:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    26b8:	3301      	adds	r3, #1
    26ba:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    26bc:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    26c0:	d1f7      	bne.n	26b2 <f25519_inv__distinct+0x3ea>
    26c2:	2600      	movs	r6, #0
    26c4:	4633      	mov	r3, r6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26c6:	f04f 0926 	mov.w	r9, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    26ca:	0a1b      	lsrs	r3, r3, #8
    26cc:	1984      	adds	r4, r0, r6
		for (j = 0; j <= i; j++)
    26ce:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26d0:	f810 c002 	ldrb.w	ip, [r0, r2]
    26d4:	f814 5901 	ldrb.w	r5, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26d8:	3201      	adds	r2, #1
    26da:	42b2      	cmp	r2, r6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26dc:	fb0c 3305 	mla	r3, ip, r5, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26e0:	ddf6      	ble.n	26d0 <f25519_inv__distinct+0x408>
    26e2:	ea26 74e6 	bic.w	r4, r6, r6, asr #31
    26e6:	1c62      	adds	r2, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26e8:	2a20      	cmp	r2, #32
    26ea:	d00e      	beq.n	270a <f25519_inv__distinct+0x442>
    26ec:	1b35      	subs	r5, r6, r4
    26ee:	3520      	adds	r5, #32
    26f0:	4405      	add	r5, r0
    26f2:	4404      	add	r4, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    26f4:	f815 cd01 	ldrb.w	ip, [r5, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26f8:	f814 8f01 	ldrb.w	r8, [r4, #1]!
    26fc:	fb09 fc0c 	mul.w	ip, r9, ip

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2700:	3201      	adds	r2, #1
    2702:	2a20      	cmp	r2, #32
			c += ((uint32_t)a[j]) *
    2704:	fb08 330c 	mla	r3, r8, ip, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2708:	d1f4      	bne.n	26f4 <f25519_inv__distinct+0x42c>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    270a:	f80d 3006 	strb.w	r3, [sp, r6]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    270e:	3601      	adds	r6, #1
    2710:	2e20      	cmp	r6, #32
    2712:	d1da      	bne.n	26ca <f25519_inv__distinct+0x402>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2714:	f89d 401f 	ldrb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    2718:	09db      	lsrs	r3, r3, #7
    271a:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    271e:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    2722:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2726:	f88d 401f 	strb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    272a:	ab00      	add	r3, sp, #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    272c:	781c      	ldrb	r4, [r3, #0]
    272e:	4422      	add	r2, r4
		r[i] = c;
    2730:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2734:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2736:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    273a:	d1f7      	bne.n	272c <f25519_inv__distinct+0x464>
    273c:	2500      	movs	r5, #0
    273e:	eb0d 0805 	add.w	r8, sp, r5
    2742:	f108 091f 	add.w	r9, r8, #31
    2746:	462b      	mov	r3, r5
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2748:	f04f 0826 	mov.w	r8, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    274c:	0a1b      	lsrs	r3, r3, #8
    274e:	194c      	adds	r4, r1, r5
		for (j = 0; j <= i; j++)
    2750:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2752:	f81d c002 	ldrb.w	ip, [sp, r2]
    2756:	f814 6901 	ldrb.w	r6, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    275a:	3201      	adds	r2, #1
    275c:	42aa      	cmp	r2, r5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    275e:	fb0c 3306 	mla	r3, ip, r6, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2762:	ddf6      	ble.n	2752 <f25519_inv__distinct+0x48a>
    2764:	ea25 72e5 	bic.w	r2, r5, r5, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2768:	2a1f      	cmp	r2, #31
    276a:	d00e      	beq.n	278a <f25519_inv__distinct+0x4c2>
    276c:	1aac      	subs	r4, r5, r2
    276e:	3420      	adds	r4, #32
    2770:	ae00      	add	r6, sp, #0
    2772:	440c      	add	r4, r1
    2774:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2776:	f814 6d01 	ldrb.w	r6, [r4, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    277a:	f812 cf01 	ldrb.w	ip, [r2, #1]!
    277e:	fb08 f606 	mul.w	r6, r8, r6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2782:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) *
    2784:	fb0c 3306 	mla	r3, ip, r6, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2788:	d1f5      	bne.n	2776 <f25519_inv__distinct+0x4ae>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    278a:	5543      	strb	r3, [r0, r5]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    278c:	3501      	adds	r5, #1
    278e:	2d20      	cmp	r5, #32
    2790:	d1dc      	bne.n	274c <f25519_inv__distinct+0x484>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2792:	7fc4      	ldrb	r4, [r0, #31]
	c = (c >> 7) * 19;
    2794:	09db      	lsrs	r3, r3, #7
    2796:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    279a:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    279e:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    27a2:	77c4      	strb	r4, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27a4:	2300      	movs	r3, #0
		c += r[i];
    27a6:	5cc4      	ldrb	r4, [r0, r3]
    27a8:	4422      	add	r2, r4
		r[i] = c;
    27aa:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27ac:	3301      	adds	r3, #1
    27ae:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    27b0:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27b4:	d1f7      	bne.n	27a6 <f25519_inv__distinct+0x4de>
    27b6:	2600      	movs	r6, #0
    27b8:	4633      	mov	r3, r6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27ba:	f04f 0926 	mov.w	r9, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    27be:	0a1b      	lsrs	r3, r3, #8
    27c0:	1984      	adds	r4, r0, r6
		for (j = 0; j <= i; j++)
    27c2:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27c4:	f810 c002 	ldrb.w	ip, [r0, r2]
    27c8:	f814 5901 	ldrb.w	r5, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27cc:	3201      	adds	r2, #1
    27ce:	42b2      	cmp	r2, r6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27d0:	fb0c 3305 	mla	r3, ip, r5, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27d4:	ddf6      	ble.n	27c4 <f25519_inv__distinct+0x4fc>
    27d6:	ea26 74e6 	bic.w	r4, r6, r6, asr #31
    27da:	1c62      	adds	r2, r4, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27dc:	2a20      	cmp	r2, #32
    27de:	d00e      	beq.n	27fe <f25519_inv__distinct+0x536>
    27e0:	1b35      	subs	r5, r6, r4
    27e2:	3520      	adds	r5, #32
    27e4:	4405      	add	r5, r0
    27e6:	4404      	add	r4, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    27e8:	f815 cd01 	ldrb.w	ip, [r5, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27ec:	f814 8f01 	ldrb.w	r8, [r4, #1]!
    27f0:	fb09 fc0c 	mul.w	ip, r9, ip

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27f4:	3201      	adds	r2, #1
    27f6:	2a20      	cmp	r2, #32
			c += ((uint32_t)a[j]) *
    27f8:	fb08 330c 	mla	r3, r8, ip, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27fc:	d1f4      	bne.n	27e8 <f25519_inv__distinct+0x520>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    27fe:	f80d 3006 	strb.w	r3, [sp, r6]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2802:	3601      	adds	r6, #1
    2804:	2e20      	cmp	r6, #32
    2806:	d1da      	bne.n	27be <f25519_inv__distinct+0x4f6>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2808:	f89d 401f 	ldrb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    280c:	09db      	lsrs	r3, r3, #7
    280e:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2812:	f004 047f 	and.w	r4, r4, #127	; 0x7f
	c = (c >> 7) * 19;
    2816:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    281a:	f88d 401f 	strb.w	r4, [sp, #31]
	c = (c >> 7) * 19;
    281e:	ab00      	add	r3, sp, #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2820:	781c      	ldrb	r4, [r3, #0]
    2822:	4422      	add	r2, r4
		r[i] = c;
    2824:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2828:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    282a:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    282e:	d1f7      	bne.n	2820 <f25519_inv__distinct+0x558>
    2830:	2500      	movs	r5, #0
    2832:	eb0d 0205 	add.w	r2, sp, r5
    2836:	462b      	mov	r3, r5
    2838:	f102 081f 	add.w	r8, r2, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    283c:	f04f 0c26 	mov.w	ip, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2840:	0a1b      	lsrs	r3, r3, #8
    2842:	194c      	adds	r4, r1, r5
		for (j = 0; j <= i; j++)
    2844:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2846:	f81d 7002 	ldrb.w	r7, [sp, r2]
    284a:	f814 6901 	ldrb.w	r6, [r4], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    284e:	3201      	adds	r2, #1
    2850:	42aa      	cmp	r2, r5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2852:	fb07 3306 	mla	r3, r7, r6, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2856:	ddf6      	ble.n	2846 <f25519_inv__distinct+0x57e>
    2858:	ea25 72e5 	bic.w	r2, r5, r5, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    285c:	2a1f      	cmp	r2, #31
    285e:	d00e      	beq.n	287e <f25519_inv__distinct+0x5b6>
    2860:	1aac      	subs	r4, r5, r2
    2862:	3420      	adds	r4, #32
    2864:	ae00      	add	r6, sp, #0
    2866:	440c      	add	r4, r1
    2868:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    286a:	f814 6d01 	ldrb.w	r6, [r4, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    286e:	f812 7f01 	ldrb.w	r7, [r2, #1]!
    2872:	fb0c f606 	mul.w	r6, ip, r6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2876:	4542      	cmp	r2, r8
			c += ((uint32_t)a[j]) *
    2878:	fb07 3306 	mla	r3, r7, r6, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    287c:	d1f5      	bne.n	286a <f25519_inv__distinct+0x5a2>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    287e:	5543      	strb	r3, [r0, r5]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2880:	3501      	adds	r5, #1
    2882:	2d20      	cmp	r5, #32
    2884:	d1dc      	bne.n	2840 <f25519_inv__distinct+0x578>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2886:	7fc1      	ldrb	r1, [r0, #31]
	c = (c >> 7) * 19;
    2888:	09db      	lsrs	r3, r3, #7
    288a:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    288e:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    2892:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2896:	77c1      	strb	r1, [r0, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2898:	2300      	movs	r3, #0
		c += r[i];
    289a:	5cc1      	ldrb	r1, [r0, r3]
    289c:	440a      	add	r2, r1
		r[i] = c;
    289e:	54c2      	strb	r2, [r0, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28a0:	3301      	adds	r3, #1
    28a2:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    28a4:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28a8:	d1f7      	bne.n	289a <f25519_inv__distinct+0x5d2>
	f25519_mul__distinct(r, s, x);

	/* 1 */
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}
    28aa:	b008      	add	sp, #32
    28ac:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    28b0:	4770      	bx	lr
    28b2:	bf00      	nop

000028b4 <f25519_sqrt>:
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    28b4:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28b8:	2300      	movs	r3, #0
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    28ba:	b0a4      	sub	sp, #144	; 0x90
    28bc:	9002      	str	r0, [sp, #8]
    28be:	9103      	str	r1, [sp, #12]
	f25519_copy(r, tmp);
}

void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
    28c0:	461a      	mov	r2, r3
    28c2:	ae14      	add	r6, sp, #80	; 0x50
    28c4:	4608      	mov	r0, r1
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += b * ((uint32_t)a[i]);
    28c6:	5cc1      	ldrb	r1, [r0, r3]
    28c8:	0049      	lsls	r1, r1, #1
    28ca:	eb01 2212 	add.w	r2, r1, r2, lsr #8
		r[i] = c;
    28ce:	54f2      	strb	r2, [r6, r3]
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28d0:	3301      	adds	r3, #1
    28d2:	2b20      	cmp	r3, #32
    28d4:	d1f7      	bne.n	28c6 <f25519_sqrt+0x12>
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    28d6:	f89d 306f 	ldrb.w	r3, [sp, #111]	; 0x6f
	c >>= 7;
    28da:	09d2      	lsrs	r2, r2, #7
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    28dc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
	c >>= 7;
	c *= 19;
    28e0:	eb02 01c2 	add.w	r1, r2, r2, lsl #3
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    28e4:	f88d 306f 	strb.w	r3, [sp, #111]	; 0x6f
	c >>= 7;
	c *= 19;
    28e8:	eb02 0241 	add.w	r2, r2, r1, lsl #1
    28ec:	a81c      	add	r0, sp, #112	; 0x70
    28ee:	4633      	mov	r3, r6

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    28f0:	7819      	ldrb	r1, [r3, #0]
    28f2:	440a      	add	r2, r1
		r[i] = c;
    28f4:	f803 2b01 	strb.w	r2, [r3], #1

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28f8:	4283      	cmp	r3, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    28fa:	ea4f 2212 	mov.w	r2, r2, lsr #8

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28fe:	d1f7      	bne.n	28f0 <f25519_sqrt+0x3c>
    2900:	2400      	movs	r4, #0
    2902:	4623      	mov	r3, r4
    2904:	f106 0c1f 	add.w	ip, r6, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2908:	2726      	movs	r7, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    290a:	0a1b      	lsrs	r3, r3, #8
    290c:	1931      	adds	r1, r6, r4
		for (j = 0; j <= i; j++)
    290e:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2910:	f816 8002 	ldrb.w	r8, [r6, r2]
    2914:	f811 5901 	ldrb.w	r5, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2918:	3201      	adds	r2, #1
    291a:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    291c:	fb08 3305 	mla	r3, r8, r5, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2920:	ddf6      	ble.n	2910 <f25519_sqrt+0x5c>
    2922:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2926:	2a1f      	cmp	r2, #31
    2928:	d00d      	beq.n	2946 <f25519_sqrt+0x92>
    292a:	1aa1      	subs	r1, r4, r2
    292c:	3120      	adds	r1, #32
    292e:	4431      	add	r1, r6
    2930:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2932:	f811 5d01 	ldrb.w	r5, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2936:	f812 8f01 	ldrb.w	r8, [r2, #1]!
    293a:	fb07 f505 	mul.w	r5, r7, r5

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    293e:	4562      	cmp	r2, ip
			c += ((uint32_t)a[j]) *
    2940:	fb08 3305 	mla	r3, r8, r5, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2944:	d1f5      	bne.n	2932 <f25519_sqrt+0x7e>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2946:	a904      	add	r1, sp, #16
    2948:	550b      	strb	r3, [r1, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    294a:	3401      	adds	r4, #1
    294c:	2c20      	cmp	r4, #32
    294e:	d1dc      	bne.n	290a <f25519_sqrt+0x56>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2950:	f89d 102f 	ldrb.w	r1, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    2954:	09db      	lsrs	r3, r3, #7
    2956:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    295a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    295e:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2962:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
    2966:	af0c      	add	r7, sp, #48	; 0x30
	c = (c >> 7) * 19;
    2968:	ab04      	add	r3, sp, #16

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    296a:	7819      	ldrb	r1, [r3, #0]
    296c:	440a      	add	r2, r1
		r[i] = c;
    296e:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2972:	42bb      	cmp	r3, r7
		c += r[i];
		r[i] = c;
		c >>= 8;
    2974:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2978:	d1f7      	bne.n	296a <f25519_sqrt+0xb6>
    297a:	2400      	movs	r4, #0
    297c:	4623      	mov	r3, r4
    297e:	f10d 0c2f 	add.w	ip, sp, #47	; 0x2f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2982:	2526      	movs	r5, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2984:	0a1b      	lsrs	r3, r3, #8
    2986:	1931      	adds	r1, r6, r4
		for (j = 0; j <= i; j++)
    2988:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    298a:	f10d 0a10 	add.w	sl, sp, #16
    298e:	f81a 9002 	ldrb.w	r9, [sl, r2]
    2992:	f811 8901 	ldrb.w	r8, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2996:	3201      	adds	r2, #1
    2998:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    299a:	fb09 3308 	mla	r3, r9, r8, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    299e:	ddf4      	ble.n	298a <f25519_sqrt+0xd6>
    29a0:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29a4:	2a1f      	cmp	r2, #31
    29a6:	d00d      	beq.n	29c4 <f25519_sqrt+0x110>
    29a8:	1aa1      	subs	r1, r4, r2
    29aa:	3120      	adds	r1, #32
    29ac:	4431      	add	r1, r6
    29ae:	4452      	add	r2, sl
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    29b0:	f811 8d01 	ldrb.w	r8, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    29b4:	f812 9f01 	ldrb.w	r9, [r2, #1]!
    29b8:	fb05 f808 	mul.w	r8, r5, r8

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29bc:	4562      	cmp	r2, ip
			c += ((uint32_t)a[j]) *
    29be:	fb09 3308 	mla	r3, r9, r8, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29c2:	d1f5      	bne.n	29b0 <f25519_sqrt+0xfc>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    29c4:	5503      	strb	r3, [r0, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    29c6:	3401      	adds	r4, #1
    29c8:	2c20      	cmp	r4, #32
    29ca:	d1db      	bne.n	2984 <f25519_sqrt+0xd0>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29cc:	f89d 108f 	ldrb.w	r1, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    29d0:	09db      	lsrs	r3, r3, #7
    29d2:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    29d6:	f10d 0b90 	add.w	fp, sp, #144	; 0x90
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29da:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    29de:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29e2:	f88d 108f 	strb.w	r1, [sp, #143]	; 0x8f
    29e6:	f8cd b000 	str.w	fp, [sp]
	c = (c >> 7) * 19;
    29ea:	4603      	mov	r3, r0
    29ec:	46dc      	mov	ip, fp

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    29ee:	7819      	ldrb	r1, [r3, #0]
    29f0:	440a      	add	r2, r1
		r[i] = c;
    29f2:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    29f6:	4563      	cmp	r3, ip
		c += r[i];
		r[i] = c;
		c >>= 8;
    29f8:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    29fc:	d1f7      	bne.n	29ee <f25519_sqrt+0x13a>
    29fe:	21f8      	movs	r1, #248	; 0xf8
    2a00:	9101      	str	r1, [sp, #4]
    2a02:	f100 051f 	add.w	r5, r0, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a06:	2126      	movs	r1, #38	; 0x26
    2a08:	f10d 042f 	add.w	r4, sp, #47	; 0x2f

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2a0c:	f04f 0900 	mov.w	r9, #0
    2a10:	464b      	mov	r3, r9
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2a12:	0a1b      	lsrs	r3, r3, #8
    2a14:	eb00 0809 	add.w	r8, r0, r9
		for (j = 0; j <= i; j++)
    2a18:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a1a:	f810 b002 	ldrb.w	fp, [r0, r2]
    2a1e:	f818 a901 	ldrb.w	sl, [r8], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a22:	3201      	adds	r2, #1
    2a24:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a26:	fb0b 330a 	mla	r3, fp, sl, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a2a:	ddf6      	ble.n	2a1a <f25519_sqrt+0x166>
    2a2c:	ea29 72e9 	bic.w	r2, r9, r9, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a30:	2a1f      	cmp	r2, #31
    2a32:	d00f      	beq.n	2a54 <f25519_sqrt+0x1a0>
    2a34:	ebc2 0809 	rsb	r8, r2, r9
    2a38:	f108 0820 	add.w	r8, r8, #32
    2a3c:	4480      	add	r8, r0
    2a3e:	4402      	add	r2, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2a40:	f818 ad01 	ldrb.w	sl, [r8, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a44:	f812 bf01 	ldrb.w	fp, [r2, #1]!
    2a48:	fb01 fa0a 	mul.w	sl, r1, sl

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a4c:	42aa      	cmp	r2, r5
			c += ((uint32_t)a[j]) *
    2a4e:	fb0b 330a 	mla	r3, fp, sl, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a52:	d1f5      	bne.n	2a40 <f25519_sqrt+0x18c>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2a54:	f10d 0810 	add.w	r8, sp, #16
    2a58:	f808 3009 	strb.w	r3, [r8, r9]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2a5c:	f109 0901 	add.w	r9, r9, #1
    2a60:	f1b9 0f20 	cmp.w	r9, #32
    2a64:	d1d5      	bne.n	2a12 <f25519_sqrt+0x15e>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a66:	f89d 802f 	ldrb.w	r8, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    2a6a:	09db      	lsrs	r3, r3, #7
    2a6c:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a70:	f008 087f 	and.w	r8, r8, #127	; 0x7f
	c = (c >> 7) * 19;
    2a74:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a78:	f88d 802f 	strb.w	r8, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    2a7c:	ab04      	add	r3, sp, #16

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2a7e:	f893 8000 	ldrb.w	r8, [r3]
    2a82:	4442      	add	r2, r8
		r[i] = c;
    2a84:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a88:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2a8a:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a8e:	d1f6      	bne.n	2a7e <f25519_sqrt+0x1ca>
    2a90:	f04f 0900 	mov.w	r9, #0
    2a94:	464b      	mov	r3, r9
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2a96:	0a1b      	lsrs	r3, r3, #8
    2a98:	eb06 0809 	add.w	r8, r6, r9
		for (j = 0; j <= i; j++)
    2a9c:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a9e:	f10d 0c10 	add.w	ip, sp, #16
    2aa2:	f81c b002 	ldrb.w	fp, [ip, r2]
    2aa6:	f818 a901 	ldrb.w	sl, [r8], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2aaa:	3201      	adds	r2, #1
    2aac:	454a      	cmp	r2, r9
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2aae:	fb0b 330a 	mla	r3, fp, sl, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2ab2:	ddf4      	ble.n	2a9e <f25519_sqrt+0x1ea>
    2ab4:	ea29 72e9 	bic.w	r2, r9, r9, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ab8:	2a1f      	cmp	r2, #31
    2aba:	d00f      	beq.n	2adc <f25519_sqrt+0x228>
    2abc:	ebc2 0809 	rsb	r8, r2, r9
    2ac0:	f108 0820 	add.w	r8, r8, #32
    2ac4:	44b0      	add	r8, r6
    2ac6:	4462      	add	r2, ip
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2ac8:	f818 ad01 	ldrb.w	sl, [r8, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2acc:	f812 bf01 	ldrb.w	fp, [r2, #1]!
    2ad0:	fb01 fa0a 	mul.w	sl, r1, sl

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ad4:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) *
    2ad6:	fb0b 330a 	mla	r3, fp, sl, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ada:	d1f5      	bne.n	2ac8 <f25519_sqrt+0x214>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2adc:	f800 3009 	strb.w	r3, [r0, r9]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2ae0:	f109 0901 	add.w	r9, r9, #1
    2ae4:	f1b9 0f20 	cmp.w	r9, #32
    2ae8:	d1d5      	bne.n	2a96 <f25519_sqrt+0x1e2>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2aea:	f89d 808f 	ldrb.w	r8, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2aee:	09db      	lsrs	r3, r3, #7
    2af0:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2af4:	f008 087f 	and.w	r8, r8, #127	; 0x7f
	c = (c >> 7) * 19;
    2af8:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2afc:	f88d 808f 	strb.w	r8, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2b00:	4603      	mov	r3, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2b02:	f893 8000 	ldrb.w	r8, [r3]
    2b06:	4442      	add	r2, r8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b08:	f8dd 8000 	ldr.w	r8, [sp]
		c += r[i];
		r[i] = c;
    2b0c:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b10:	4598      	cmp	r8, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2b12:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b16:	d1f4      	bne.n	2b02 <f25519_sqrt+0x24e>
	/* 1 1 */
	f25519_mul__distinct(r, x, x);
	f25519_mul__distinct(s, r, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    2b18:	9a01      	ldr	r2, [sp, #4]
    2b1a:	3a01      	subs	r2, #1
    2b1c:	9201      	str	r2, [sp, #4]
    2b1e:	f47f af75 	bne.w	2a0c <f25519_sqrt+0x158>
    2b22:	4614      	mov	r4, r2
    2b24:	4613      	mov	r3, r2
    2b26:	f100 081f 	add.w	r8, r0, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b2a:	2526      	movs	r5, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2b2c:	0a1b      	lsrs	r3, r3, #8
    2b2e:	1901      	adds	r1, r0, r4
		for (j = 0; j <= i; j++)
    2b30:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b32:	f810 a002 	ldrb.w	sl, [r0, r2]
    2b36:	f811 9901 	ldrb.w	r9, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b3a:	3201      	adds	r2, #1
    2b3c:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b3e:	fb0a 3309 	mla	r3, sl, r9, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b42:	ddf6      	ble.n	2b32 <f25519_sqrt+0x27e>
    2b44:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b48:	2a1f      	cmp	r2, #31
    2b4a:	d00d      	beq.n	2b68 <f25519_sqrt+0x2b4>
    2b4c:	1aa1      	subs	r1, r4, r2
    2b4e:	3120      	adds	r1, #32
    2b50:	4401      	add	r1, r0
    2b52:	4402      	add	r2, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2b54:	f811 9d01 	ldrb.w	r9, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b58:	f812 af01 	ldrb.w	sl, [r2, #1]!
    2b5c:	fb05 f909 	mul.w	r9, r5, r9

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b60:	4542      	cmp	r2, r8
			c += ((uint32_t)a[j]) *
    2b62:	fb0a 3309 	mla	r3, sl, r9, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b66:	d1f5      	bne.n	2b54 <f25519_sqrt+0x2a0>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2b68:	f10d 0a10 	add.w	sl, sp, #16
    2b6c:	f80a 3004 	strb.w	r3, [sl, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2b70:	3401      	adds	r4, #1
    2b72:	2c20      	cmp	r4, #32
    2b74:	d1da      	bne.n	2b2c <f25519_sqrt+0x278>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b76:	f89d 102f 	ldrb.w	r1, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    2b7a:	09db      	lsrs	r3, r3, #7
    2b7c:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b80:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    2b84:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b88:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    2b8c:	4653      	mov	r3, sl

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2b8e:	7819      	ldrb	r1, [r3, #0]
    2b90:	440a      	add	r2, r1
		r[i] = c;
    2b92:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b96:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2b98:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b9c:	d1f7      	bne.n	2b8e <f25519_sqrt+0x2da>
    2b9e:	2400      	movs	r4, #0
    2ba0:	4623      	mov	r3, r4
    2ba2:	f10d 082f 	add.w	r8, sp, #47	; 0x2f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ba6:	2526      	movs	r5, #38	; 0x26
    2ba8:	a904      	add	r1, sp, #16
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2baa:	0a1b      	lsrs	r3, r3, #8
    2bac:	4421      	add	r1, r4
		for (j = 0; j <= i; j++)
    2bae:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2bb0:	f10d 0c10 	add.w	ip, sp, #16
    2bb4:	f81c a002 	ldrb.w	sl, [ip, r2]
    2bb8:	f811 9901 	ldrb.w	r9, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2bbc:	3201      	adds	r2, #1
    2bbe:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2bc0:	fb0a 3309 	mla	r3, sl, r9, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2bc4:	ddf4      	ble.n	2bb0 <f25519_sqrt+0x2fc>
    2bc6:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2bca:	2a1f      	cmp	r2, #31
    2bcc:	d00d      	beq.n	2bea <f25519_sqrt+0x336>
    2bce:	1aa1      	subs	r1, r4, r2
    2bd0:	3120      	adds	r1, #32
    2bd2:	4461      	add	r1, ip
    2bd4:	4462      	add	r2, ip
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2bd6:	f811 9d01 	ldrb.w	r9, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2bda:	f812 af01 	ldrb.w	sl, [r2, #1]!
    2bde:	fb05 f909 	mul.w	r9, r5, r9

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2be2:	4542      	cmp	r2, r8
			c += ((uint32_t)a[j]) *
    2be4:	fb0a 3309 	mla	r3, sl, r9, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2be8:	d1f5      	bne.n	2bd6 <f25519_sqrt+0x322>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2bea:	5503      	strb	r3, [r0, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2bec:	3401      	adds	r4, #1
    2bee:	2c20      	cmp	r4, #32
    2bf0:	d1da      	bne.n	2ba8 <f25519_sqrt+0x2f4>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bf2:	f89d 108f 	ldrb.w	r1, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2bf6:	09db      	lsrs	r3, r3, #7
    2bf8:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bfc:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    2c00:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c04:	f88d 108f 	strb.w	r1, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2c08:	4603      	mov	r3, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2c0a:	7819      	ldrb	r1, [r3, #0]
    2c0c:	440a      	add	r2, r1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c0e:	9900      	ldr	r1, [sp, #0]
		c += r[i];
		r[i] = c;
    2c10:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c14:	4299      	cmp	r1, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2c16:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c1a:	d1f6      	bne.n	2c0a <f25519_sqrt+0x356>
    2c1c:	2400      	movs	r4, #0
    2c1e:	4623      	mov	r3, r4
    2c20:	f100 081f 	add.w	r8, r0, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c24:	2526      	movs	r5, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2c26:	0a1b      	lsrs	r3, r3, #8
    2c28:	1931      	adds	r1, r6, r4
		for (j = 0; j <= i; j++)
    2c2a:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c2c:	f810 a002 	ldrb.w	sl, [r0, r2]
    2c30:	f811 9901 	ldrb.w	r9, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c34:	3201      	adds	r2, #1
    2c36:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c38:	fb0a 3309 	mla	r3, sl, r9, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c3c:	ddf6      	ble.n	2c2c <f25519_sqrt+0x378>
    2c3e:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c42:	2a1f      	cmp	r2, #31
    2c44:	d00d      	beq.n	2c62 <f25519_sqrt+0x3ae>
    2c46:	1aa1      	subs	r1, r4, r2
    2c48:	3120      	adds	r1, #32
    2c4a:	4431      	add	r1, r6
    2c4c:	4402      	add	r2, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2c4e:	f811 9d01 	ldrb.w	r9, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c52:	f812 af01 	ldrb.w	sl, [r2, #1]!
    2c56:	fb05 f909 	mul.w	r9, r5, r9

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c5a:	4542      	cmp	r2, r8
			c += ((uint32_t)a[j]) *
    2c5c:	fb0a 3309 	mla	r3, sl, r9, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c60:	d1f5      	bne.n	2c4e <f25519_sqrt+0x39a>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2c62:	aa04      	add	r2, sp, #16
    2c64:	5513      	strb	r3, [r2, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2c66:	3401      	adds	r4, #1
    2c68:	2c20      	cmp	r4, #32
    2c6a:	d1dc      	bne.n	2c26 <f25519_sqrt+0x372>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c6c:	f89d 102f 	ldrb.w	r1, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    2c70:	09db      	lsrs	r3, r3, #7
    2c72:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c76:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    2c7a:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c7e:	f88d 102f 	strb.w	r1, [sp, #47]	; 0x2f
	c = (c >> 7) * 19;
    2c82:	ab04      	add	r3, sp, #16

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2c84:	7819      	ldrb	r1, [r3, #0]
    2c86:	440a      	add	r2, r1
		r[i] = c;
    2c88:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c8c:	429f      	cmp	r7, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2c8e:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c92:	d1f7      	bne.n	2c84 <f25519_sqrt+0x3d0>
    2c94:	2400      	movs	r4, #0
    2c96:	4623      	mov	r3, r4
    2c98:	f10d 082f 	add.w	r8, sp, #47	; 0x2f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c9c:	2526      	movs	r5, #38	; 0x26
    2c9e:	a904      	add	r1, sp, #16
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2ca0:	0a1b      	lsrs	r3, r3, #8
    2ca2:	4421      	add	r1, r4
		for (j = 0; j <= i; j++)
    2ca4:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2ca6:	f10d 0b10 	add.w	fp, sp, #16
    2caa:	f81b a002 	ldrb.w	sl, [fp, r2]
    2cae:	f811 9901 	ldrb.w	r9, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2cb2:	3201      	adds	r2, #1
    2cb4:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2cb6:	fb0a 3309 	mla	r3, sl, r9, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2cba:	ddf4      	ble.n	2ca6 <f25519_sqrt+0x3f2>
    2cbc:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cc0:	2a1f      	cmp	r2, #31
    2cc2:	d00d      	beq.n	2ce0 <f25519_sqrt+0x42c>
    2cc4:	1aa1      	subs	r1, r4, r2
    2cc6:	3120      	adds	r1, #32
    2cc8:	4459      	add	r1, fp
    2cca:	445a      	add	r2, fp
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2ccc:	f811 9d01 	ldrb.w	r9, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2cd0:	f812 af01 	ldrb.w	sl, [r2, #1]!
    2cd4:	fb05 f909 	mul.w	r9, r5, r9

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cd8:	4542      	cmp	r2, r8
			c += ((uint32_t)a[j]) *
    2cda:	fb0a 3309 	mla	r3, sl, r9, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cde:	d1f5      	bne.n	2ccc <f25519_sqrt+0x418>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2ce0:	5503      	strb	r3, [r0, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2ce2:	3401      	adds	r4, #1
    2ce4:	2c20      	cmp	r4, #32
    2ce6:	d1da      	bne.n	2c9e <f25519_sqrt+0x3ea>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2ce8:	f89d 108f 	ldrb.w	r1, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2cec:	09db      	lsrs	r3, r3, #7
    2cee:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cf2:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    2cf6:	f8dd c000 	ldr.w	ip, [sp]
	c = (c >> 7) * 19;
    2cfa:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cfe:	f88d 108f 	strb.w	r1, [sp, #143]	; 0x8f
	c = (c >> 7) * 19;
    2d02:	4603      	mov	r3, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2d04:	7819      	ldrb	r1, [r3, #0]
    2d06:	440a      	add	r2, r1
		r[i] = c;
    2d08:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d0c:	459c      	cmp	ip, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2d0e:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d12:	d1f7      	bne.n	2d04 <f25519_sqrt+0x450>
    2d14:	2400      	movs	r4, #0
    2d16:	4623      	mov	r3, r4
    2d18:	f106 0c1f 	add.w	ip, r6, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d1c:	2526      	movs	r5, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2d1e:	0a1b      	lsrs	r3, r3, #8
    2d20:	1901      	adds	r1, r0, r4
		for (j = 0; j <= i; j++)
    2d22:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d24:	f816 9002 	ldrb.w	r9, [r6, r2]
    2d28:	f811 8901 	ldrb.w	r8, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d2c:	3201      	adds	r2, #1
    2d2e:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d30:	fb09 3308 	mla	r3, r9, r8, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d34:	ddf6      	ble.n	2d24 <f25519_sqrt+0x470>
    2d36:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d3a:	2a1f      	cmp	r2, #31
    2d3c:	d00d      	beq.n	2d5a <f25519_sqrt+0x4a6>
    2d3e:	1aa1      	subs	r1, r4, r2
    2d40:	3120      	adds	r1, #32
    2d42:	4401      	add	r1, r0
    2d44:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2d46:	f811 8d01 	ldrb.w	r8, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d4a:	f812 9f01 	ldrb.w	r9, [r2, #1]!
    2d4e:	fb05 f808 	mul.w	r8, r5, r8

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d52:	4562      	cmp	r2, ip
			c += ((uint32_t)a[j]) *
    2d54:	fb09 3308 	mla	r3, r9, r8, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d58:	d1f5      	bne.n	2d46 <f25519_sqrt+0x492>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2d5a:	553b      	strb	r3, [r7, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2d5c:	3401      	adds	r4, #1
    2d5e:	2c20      	cmp	r4, #32
    2d60:	d1dd      	bne.n	2d1e <f25519_sqrt+0x46a>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d62:	f89d 104f 	ldrb.w	r1, [sp, #79]	; 0x4f
	c = (c >> 7) * 19;
    2d66:	09db      	lsrs	r3, r3, #7
    2d68:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d6c:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    2d70:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d74:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
	c = (c >> 7) * 19;
    2d78:	463b      	mov	r3, r7

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2d7a:	7819      	ldrb	r1, [r3, #0]
    2d7c:	440a      	add	r2, r1
		r[i] = c;
    2d7e:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d82:	42b3      	cmp	r3, r6
		c += r[i];
		r[i] = c;
		c >>= 8;
    2d84:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d88:	d1f7      	bne.n	2d7a <f25519_sqrt+0x4c6>
    2d8a:	2300      	movs	r3, #0
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    2d8c:	2201      	movs	r2, #1
    2d8e:	921c      	str	r2, [sp, #112]	; 0x70
    2d90:	931d      	str	r3, [sp, #116]	; 0x74
    2d92:	931e      	str	r3, [sp, #120]	; 0x78
    2d94:	931f      	str	r3, [sp, #124]	; 0x7c
    2d96:	9320      	str	r3, [sp, #128]	; 0x80
    2d98:	9321      	str	r3, [sp, #132]	; 0x84
    2d9a:	9322      	str	r3, [sp, #136]	; 0x88
    2d9c:	9323      	str	r3, [sp, #140]	; 0x8c
    2d9e:	22da      	movs	r2, #218	; 0xda
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2da0:	5cfc      	ldrb	r4, [r7, r3]
    2da2:	5cc1      	ldrb	r1, [r0, r3]
    2da4:	f504 447f 	add.w	r4, r4, #65280	; 0xff00
    2da8:	1a61      	subs	r1, r4, r1
    2daa:	440a      	add	r2, r1
		r[i] = c;
    2dac:	54fa      	strb	r2, [r7, r3]
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2dae:	3301      	adds	r3, #1
    2db0:	2b1f      	cmp	r3, #31
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2db2:	ea4f 2212 	mov.w	r2, r2, lsr #8
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2db6:	d1f3      	bne.n	2da0 <f25519_sqrt+0x4ec>
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2db8:	f89d 404f 	ldrb.w	r4, [sp, #79]	; 0x4f
    2dbc:	f89d 108f 	ldrb.w	r1, [sp, #143]	; 0x8f
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2dc0:	463b      	mov	r3, r7
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2dc2:	1a61      	subs	r1, r4, r1
    2dc4:	4411      	add	r1, r2
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2dc6:	09ca      	lsrs	r2, r1, #7
    2dc8:	eb02 04c2 	add.w	r4, r2, r2, lsl #3
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2dcc:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    2dd0:	f88d 104f 	strb.w	r1, [sp, #79]	; 0x4f
	c = (c >> 7) * 19;
    2dd4:	eb02 0244 	add.w	r2, r2, r4, lsl #1

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2dd8:	7819      	ldrb	r1, [r3, #0]
    2dda:	440a      	add	r2, r1
		r[i] = c;
    2ddc:	f803 2b01 	strb.w	r2, [r3], #1

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2de0:	429e      	cmp	r6, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2de2:	ea4f 2212 	mov.w	r2, r2, lsr #8

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2de6:	d1f7      	bne.n	2dd8 <f25519_sqrt+0x524>
    2de8:	2400      	movs	r4, #0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2dea:	f8dd 900c 	ldr.w	r9, [sp, #12]

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2dee:	4623      	mov	r3, r4
    2df0:	f10d 0c2f 	add.w	ip, sp, #47	; 0x2f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2df4:	2526      	movs	r5, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2df6:	0a1b      	lsrs	r3, r3, #8
    2df8:	eb09 0104 	add.w	r1, r9, r4
		for (j = 0; j <= i; j++)
    2dfc:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2dfe:	f10d 0b10 	add.w	fp, sp, #16
    2e02:	f81b a002 	ldrb.w	sl, [fp, r2]
    2e06:	f811 8901 	ldrb.w	r8, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e0a:	3201      	adds	r2, #1
    2e0c:	42a2      	cmp	r2, r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e0e:	fb0a 3308 	mla	r3, sl, r8, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e12:	ddf4      	ble.n	2dfe <f25519_sqrt+0x54a>
    2e14:	ea24 72e4 	bic.w	r2, r4, r4, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e18:	2a1f      	cmp	r2, #31
    2e1a:	d00d      	beq.n	2e38 <f25519_sqrt+0x584>
    2e1c:	1aa1      	subs	r1, r4, r2
    2e1e:	3120      	adds	r1, #32
    2e20:	4449      	add	r1, r9
    2e22:	445a      	add	r2, fp
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2e24:	f811 8d01 	ldrb.w	r8, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2e28:	f812 af01 	ldrb.w	sl, [r2, #1]!
    2e2c:	fb05 f808 	mul.w	r8, r5, r8

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e30:	4562      	cmp	r2, ip
			c += ((uint32_t)a[j]) *
    2e32:	fb0a 3308 	mla	r3, sl, r8, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e36:	d1f5      	bne.n	2e24 <f25519_sqrt+0x570>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2e38:	5533      	strb	r3, [r6, r4]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2e3a:	3401      	adds	r4, #1
    2e3c:	2c20      	cmp	r4, #32
    2e3e:	d1da      	bne.n	2df6 <f25519_sqrt+0x542>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e40:	f89d 106f 	ldrb.w	r1, [sp, #111]	; 0x6f
	c = (c >> 7) * 19;
    2e44:	09db      	lsrs	r3, r3, #7
    2e46:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e4a:	f001 017f 	and.w	r1, r1, #127	; 0x7f
	c = (c >> 7) * 19;
    2e4e:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e52:	f88d 106f 	strb.w	r1, [sp, #111]	; 0x6f
	c = (c >> 7) * 19;
    2e56:	4633      	mov	r3, r6

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2e58:	7819      	ldrb	r1, [r3, #0]
    2e5a:	440a      	add	r2, r1
		r[i] = c;
    2e5c:	f803 2b01 	strb.w	r2, [r3], #1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e60:	4298      	cmp	r0, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2e62:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e66:	d1f7      	bne.n	2e58 <f25519_sqrt+0x5a4>
    2e68:	2000      	movs	r0, #0
    2e6a:	4603      	mov	r3, r0
    2e6c:	f106 081f 	add.w	r8, r6, #31
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2e70:	f04f 0c26 	mov.w	ip, #38	; 0x26
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2e74:	0a1b      	lsrs	r3, r3, #8
    2e76:	1839      	adds	r1, r7, r0
		for (j = 0; j <= i; j++)
    2e78:	2200      	movs	r2, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e7a:	5cb5      	ldrb	r5, [r6, r2]
    2e7c:	f811 4901 	ldrb.w	r4, [r1], #-1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e80:	3201      	adds	r2, #1
    2e82:	4282      	cmp	r2, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e84:	fb05 3304 	mla	r3, r5, r4, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e88:	ddf7      	ble.n	2e7a <f25519_sqrt+0x5c6>
    2e8a:	ea20 72e0 	bic.w	r2, r0, r0, asr #31
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e8e:	2a1f      	cmp	r2, #31
    2e90:	d00d      	beq.n	2eae <f25519_sqrt+0x5fa>
    2e92:	1a81      	subs	r1, r0, r2
    2e94:	3120      	adds	r1, #32
    2e96:	4439      	add	r1, r7
    2e98:	4432      	add	r2, r6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2e9a:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2e9e:	f812 5f01 	ldrb.w	r5, [r2, #1]!
    2ea2:	fb0c f404 	mul.w	r4, ip, r4

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ea6:	4542      	cmp	r2, r8
			c += ((uint32_t)a[j]) *
    2ea8:	fb05 3304 	mla	r3, r5, r4, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2eac:	d1f5      	bne.n	2e9a <f25519_sqrt+0x5e6>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2eae:	9a02      	ldr	r2, [sp, #8]
    2eb0:	5413      	strb	r3, [r2, r0]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2eb2:	3001      	adds	r0, #1
    2eb4:	2820      	cmp	r0, #32
    2eb6:	d1dd      	bne.n	2e74 <f25519_sqrt+0x5c0>

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2eb8:	09db      	lsrs	r3, r3, #7
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2eba:	7fd1      	ldrb	r1, [r2, #31]
	c = (c >> 7) * 19;
    2ebc:	eb03 02c3 	add.w	r2, r3, r3, lsl #3
    2ec0:	eb03 0242 	add.w	r2, r3, r2, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2ec4:	9b02      	ldr	r3, [sp, #8]
    2ec6:	f001 017f 	and.w	r1, r1, #127	; 0x7f
    2eca:	77d9      	strb	r1, [r3, #31]
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2ecc:	9902      	ldr	r1, [sp, #8]
    2ece:	2300      	movs	r3, #0
		c += r[i];
    2ed0:	5cc8      	ldrb	r0, [r1, r3]
    2ed2:	4402      	add	r2, r0
		r[i] = c;
    2ed4:	54ca      	strb	r2, [r1, r3]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2ed6:	3301      	adds	r3, #1
    2ed8:	2b20      	cmp	r3, #32
		c += r[i];
		r[i] = c;
		c >>= 8;
    2eda:	ea4f 2212 	mov.w	r2, r2, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2ede:	d1f7      	bne.n	2ed0 <f25519_sqrt+0x61c>
	f25519_sub(i, i, y);

	/* r = avi */
	f25519_mul__distinct(x, v, a);
	f25519_mul__distinct(r, x, i);
}
    2ee0:	b024      	add	sp, #144	; 0x90
    2ee2:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    2ee6:	4770      	bx	lr

00002ee8 <fprime_from_bytes>:
}

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
    2ee8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    2eec:	4691      	mov	r9, r2
    2eee:	b08b      	sub	sp, #44	; 0x2c
    2ef0:	4604      	mov	r4, r0
    2ef2:	460f      	mov	r7, r1
    2ef4:	461d      	mov	r5, r3
static int prime_msb(const uint8_t *p)
{
	int i;
	uint8_t x;

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
    2ef6:	221f      	movs	r2, #31
    2ef8:	e003      	b.n	2f02 <fprime_from_bytes+0x1a>
    2efa:	f112 32ff 	adds.w	r2, r2, #4294967295
    2efe:	f0c0 80b3 	bcc.w	3068 <fprime_from_bytes+0x180>
		if (p[i])
    2f02:	5cab      	ldrb	r3, [r5, r2]
    2f04:	2b00      	cmp	r3, #0
    2f06:	d0f8      	beq.n	2efa <fprime_from_bytes+0x12>
			break;

	x = p[i];
	i <<= 3;
    2f08:	00d2      	lsls	r2, r2, #3

	while (x) {
    2f0a:	085b      	lsrs	r3, r3, #1
		x >>= 1;
		i++;
    2f0c:	f102 0201 	add.w	r2, r2, #1
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    2f10:	d1fb      	bne.n	2f0a <fprime_from_bytes+0x22>
    2f12:	3a02      	subs	r2, #2

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
    2f14:	ea4f 0ac9 	mov.w	sl, r9, lsl #3
		x[i] = 0;
}

static inline int min_int(int a, int b)
{
	return a < b ? a : b;
    2f18:	4552      	cmp	r2, sl
    2f1a:	bfb4      	ite	lt
    2f1c:	4616      	movlt	r6, r2
    2f1e:	4656      	movge	r6, sl
void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
    2f20:	ea4f 08e6 	mov.w	r8, r6, asr #3
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);
    2f24:	4620      	mov	r0, r4
    2f26:	2100      	movs	r1, #0
    2f28:	2220      	movs	r2, #32
    2f2a:	f003 fc22 	bl	6772 <memset>

	for (i = 0; i < preload_bytes; i++)
    2f2e:	f1b8 0f00 	cmp.w	r8, #0
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
    2f32:	ebc6 0a0a 	rsb	sl, r6, sl
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
    2f36:	f006 0607 	and.w	r6, r6, #7
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f3a:	dd42      	ble.n	2fc2 <fprime_from_bytes+0xda>
    2f3c:	ebc8 0c09 	rsb	ip, r8, r9
    2f40:	eb07 030c 	add.w	r3, r7, ip
    2f44:	1d22      	adds	r2, r4, #4
    2f46:	1d19      	adds	r1, r3, #4
    2f48:	4293      	cmp	r3, r2
    2f4a:	bf38      	it	cc
    2f4c:	428c      	cmpcc	r4, r1
    2f4e:	bf34      	ite	cc
    2f50:	2200      	movcc	r2, #0
    2f52:	2201      	movcs	r2, #1
    2f54:	f1b8 0f09 	cmp.w	r8, #9
    2f58:	bf94      	ite	ls
    2f5a:	2200      	movls	r2, #0
    2f5c:	f002 0201 	andhi.w	r2, r2, #1
    2f60:	2a00      	cmp	r2, #0
    2f62:	f000 8087 	beq.w	3074 <fprime_from_bytes+0x18c>
    2f66:	ea43 0204 	orr.w	r2, r3, r4
    2f6a:	0792      	lsls	r2, r2, #30
    2f6c:	f040 8082 	bne.w	3074 <fprime_from_bytes+0x18c>
    2f70:	ea4f 0298 	mov.w	r2, r8, lsr #2
    2f74:	2100      	movs	r1, #0
    2f76:	ea4f 0b82 	mov.w	fp, r2, lsl #2
    2f7a:	4608      	mov	r0, r1
    2f7c:	9501      	str	r5, [sp, #4]
		n[i] = x[len - preload_bytes + i];
    2f7e:	585d      	ldr	r5, [r3, r1]
    2f80:	3001      	adds	r0, #1
    2f82:	4282      	cmp	r2, r0
    2f84:	5065      	str	r5, [r4, r1]
    2f86:	f101 0104 	add.w	r1, r1, #4
    2f8a:	d8f8      	bhi.n	2f7e <fprime_from_bytes+0x96>
    2f8c:	45c3      	cmp	fp, r8
    2f8e:	9d01      	ldr	r5, [sp, #4]
    2f90:	d017      	beq.n	2fc2 <fprime_from_bytes+0xda>
    2f92:	eb07 030b 	add.w	r3, r7, fp
    2f96:	f813 100c 	ldrb.w	r1, [r3, ip]
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f9a:	f10b 0301 	add.w	r3, fp, #1
    2f9e:	4598      	cmp	r8, r3
		n[i] = x[len - preload_bytes + i];
    2fa0:	f804 1022 	strb.w	r1, [r4, r2, lsl #2]
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fa4:	dd0d      	ble.n	2fc2 <fprime_from_bytes+0xda>
		n[i] = x[len - preload_bytes + i];
    2fa6:	18fa      	adds	r2, r7, r3
    2fa8:	f812 200c 	ldrb.w	r2, [r2, ip]
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fac:	f10b 0b02 	add.w	fp, fp, #2
    2fb0:	45d8      	cmp	r8, fp
		n[i] = x[len - preload_bytes + i];
    2fb2:	54e2      	strb	r2, [r4, r3]
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fb4:	dd05      	ble.n	2fc2 <fprime_from_bytes+0xda>
		n[i] = x[len - preload_bytes + i];
    2fb6:	eb07 030b 	add.w	r3, r7, fp
    2fba:	f813 300c 	ldrb.w	r3, [r3, ip]
    2fbe:	f804 300b 	strb.w	r3, [r4, fp]

	if (preload_bits) {
    2fc2:	b1be      	cbz	r6, 2ff4 <fprime_from_bytes+0x10c>
    2fc4:	2200      	movs	r2, #0
    2fc6:	4613      	mov	r3, r2
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c |= ((uint16_t)x[i]) << n;
    2fc8:	5ce1      	ldrb	r1, [r4, r3]
    2fca:	40b1      	lsls	r1, r6
    2fcc:	430a      	orrs	r2, r1
    2fce:	b292      	uxth	r2, r2
		x[i] = c;
    2fd0:	54e2      	strb	r2, [r4, r3]
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2fd2:	3301      	adds	r3, #1
    2fd4:	2b20      	cmp	r3, #32
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    2fd6:	ea4f 2212 	mov.w	r2, r2, lsr #8
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2fda:	d1f5      	bne.n	2fc8 <fprime_from_bytes+0xe0>
	for (i = 0; i < preload_bytes; i++)
		n[i] = x[len - preload_bytes + i];

	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
    2fdc:	f109 39ff 	add.w	r9, r9, #4294967295
    2fe0:	ebc8 0809 	rsb	r8, r8, r9
    2fe4:	f817 2008 	ldrb.w	r2, [r7, r8]
    2fe8:	f1c6 0608 	rsb	r6, r6, #8
    2fec:	4132      	asrs	r2, r6
    2fee:	7823      	ldrb	r3, [r4, #0]
    2ff0:	4313      	orrs	r3, r2
    2ff2:	7023      	strb	r3, [r4, #0]
	}

	for (i = rbits - 1; i >= 0; i--) {
    2ff4:	f1ba 0a01 	subs.w	sl, sl, #1
    2ff8:	d433      	bmi.n	3062 <fprime_from_bytes+0x17a>
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;
    2ffa:	ea4f 03ea 	mov.w	r3, sl, asr #3
    2ffe:	5cf8      	ldrb	r0, [r7, r3]
    3000:	f00a 0307 	and.w	r3, sl, #7
    3004:	4118      	asrs	r0, r3
}

/* Warning: this function may be variable-time in the argument n */
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
    3006:	2200      	movs	r2, #0
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
	}

	for (i = rbits - 1; i >= 0; i--) {
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;
    3008:	f000 0001 	and.w	r0, r0, #1
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    300c:	4613      	mov	r3, r2
		c |= ((uint16_t)x[i]) << n;
    300e:	5ce1      	ldrb	r1, [r4, r3]
    3010:	ea42 0241 	orr.w	r2, r2, r1, lsl #1
		x[i] = c;
    3014:	54e2      	strb	r2, [r4, r3]
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3016:	3301      	adds	r3, #1
    3018:	2b20      	cmp	r3, #32
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    301a:	ea4f 2212 	mov.w	r2, r2, lsr #8
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    301e:	d1f6      	bne.n	300e <fprime_from_bytes+0x126>

	for (i = rbits - 1; i >= 0; i--) {
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;

		shift_n_bits(n, 1);
		n[0] |= bit;
    3020:	7823      	ldrb	r3, [r4, #0]
}

static void raw_try_sub(uint8_t *x, const uint8_t *p)
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
    3022:	2200      	movs	r2, #0

	for (i = rbits - 1; i >= 0; i--) {
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;

		shift_n_bits(n, 1);
		n[0] |= bit;
    3024:	4303      	orrs	r3, r0
    3026:	7023      	strb	r3, [r4, #0]
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3028:	4613      	mov	r3, r2
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
    302a:	5ce0      	ldrb	r0, [r4, r3]
    302c:	5ce9      	ldrb	r1, [r5, r3]
    302e:	1a41      	subs	r1, r0, r1
    3030:	1a8a      	subs	r2, r1, r2
    3032:	b292      	uxth	r2, r2
		minusp[i] = c;
    3034:	a802      	add	r0, sp, #8
    3036:	54c2      	strb	r2, [r0, r3]
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3038:	3301      	adds	r3, #1
    303a:	2b20      	cmp	r3, #32
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
    303c:	f3c2 2200 	ubfx	r2, r2, #8, #1
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3040:	d1f3      	bne.n	302a <fprime_from_bytes+0x142>

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    3042:	4252      	negs	r2, r2
    3044:	b2d2      	uxtb	r2, r2
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
    3046:	2300      	movs	r3, #0
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    3048:	a802      	add	r0, sp, #8
    304a:	5cc1      	ldrb	r1, [r0, r3]
    304c:	5ce0      	ldrb	r0, [r4, r3]
    304e:	4048      	eors	r0, r1
    3050:	4010      	ands	r0, r2
    3052:	4041      	eors	r1, r0
    3054:	54e1      	strb	r1, [r4, r3]
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
    3056:	3301      	adds	r3, #1
    3058:	2b20      	cmp	r3, #32
    305a:	d1f5      	bne.n	3048 <fprime_from_bytes+0x160>
	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
	}

	for (i = rbits - 1; i >= 0; i--) {
    305c:	f11a 3aff 	adds.w	sl, sl, #4294967295
    3060:	d2cb      	bcs.n	2ffa <fprime_from_bytes+0x112>

		shift_n_bits(n, 1);
		n[0] |= bit;
		raw_try_sub(n, modulus);
	}
}
    3062:	b00b      	add	sp, #44	; 0x2c
    3064:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
    3068:	f815 3c01 	ldrb.w	r3, [r5, #-1]
	i <<= 3;

	while (x) {
    306c:	b14b      	cbz	r3, 3082 <fprime_from_bytes+0x19a>
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
    306e:	f06f 0207 	mvn.w	r2, #7
    3072:	e74a      	b.n	2f0a <fprime_from_bytes+0x22>
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    3074:	2200      	movs	r2, #0
		n[i] = x[len - preload_bytes + i];
    3076:	5c99      	ldrb	r1, [r3, r2]
    3078:	54a1      	strb	r1, [r4, r2]
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    307a:	3201      	adds	r2, #1
    307c:	4542      	cmp	r2, r8
    307e:	d1fa      	bne.n	3076 <fprime_from_bytes+0x18e>
    3080:	e79f      	b.n	2fc2 <fprime_from_bytes+0xda>
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    3082:	f06f 0209 	mvn.w	r2, #9
    3086:	e745      	b.n	2f14 <fprime_from_bytes+0x2c>

00003088 <sha256_starts>:
    (b)[(i) + 2] = (uint8) ( (n) >>  8 );       \
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    3088:	e92d 01f0 	stmdb	sp!, {r4, r5, r6, r7, r8}
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    308c:	f8df c048 	ldr.w	ip, [pc, #72]	; 30d8 <sha256_starts+0x50>
void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    3090:	f8df 8048 	ldr.w	r8, [pc, #72]	; 30dc <sha256_starts+0x54>
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    3094:	4f0a      	ldr	r7, [pc, #40]	; (30c0 <sha256_starts+0x38>)
    ctx->state[3] = 0xA54FF53A;
    3096:	4e0b      	ldr	r6, [pc, #44]	; (30c4 <sha256_starts+0x3c>)
    ctx->state[4] = 0x510E527F;
    3098:	4d0b      	ldr	r5, [pc, #44]	; (30c8 <sha256_starts+0x40>)
    ctx->state[5] = 0x9B05688C;
    309a:	4c0c      	ldr	r4, [pc, #48]	; (30cc <sha256_starts+0x44>)
    ctx->state[6] = 0x1F83D9AB;
    309c:	490c      	ldr	r1, [pc, #48]	; (30d0 <sha256_starts+0x48>)
    ctx->state[7] = 0x5BE0CD19;
    309e:	4a0d      	ldr	r2, [pc, #52]	; (30d4 <sha256_starts+0x4c>)
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    30a0:	2300      	movs	r3, #0
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    30a2:	f8c0 8008 	str.w	r8, [r0, #8]
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    30a6:	6107      	str	r7, [r0, #16]
    ctx->state[3] = 0xA54FF53A;
    30a8:	6146      	str	r6, [r0, #20]
    ctx->state[4] = 0x510E527F;
    30aa:	6185      	str	r5, [r0, #24]
    ctx->state[5] = 0x9B05688C;
    30ac:	61c4      	str	r4, [r0, #28]
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    30ae:	f8c0 c00c 	str.w	ip, [r0, #12]
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    30b2:	6201      	str	r1, [r0, #32]
    ctx->state[7] = 0x5BE0CD19;
    30b4:	6242      	str	r2, [r0, #36]	; 0x24
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    30b6:	6003      	str	r3, [r0, #0]
    ctx->total[1] = 0;
    30b8:	6043      	str	r3, [r0, #4]
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
}
    30ba:	e8bd 01f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8}
    30be:	4770      	bx	lr
    30c0:	3c6ef372 	stclcc	3, cr15, [lr], #-456	; 0xfffffe38
    30c4:	a54ff53a 	strbge	pc, [pc, #-1338]	; 2b92 <f25519_sqrt+0x2de>	; <UNPREDICTABLE>
    30c8:	510e527f 	tstpl	lr, pc, ror r2
    30cc:	9b05688c 	blls	15d304 <_etext+0x155cf0>
    30d0:	1f83d9ab 	svcne	0x0083d9ab
    30d4:	5be0cd19 	blpl	ff836540 <BootRAM+0xe7a6ce1>
    30d8:	bb67ae85 	bllt	19eeaf4 <_etext+0x19e74e0>
    30dc:	6a09e667 	bvs	27ca80 <_etext+0x27546c>

000030e0 <sha256_process>:

void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    30e0:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    30e4:	b09c      	sub	sp, #112	; 0x70
    30e6:	9019      	str	r0, [sp, #100]	; 0x64
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    30e8:	9a19      	ldr	r2, [sp, #100]	; 0x64

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    30ea:	6980      	ldr	r0, [r0, #24]
    F = ctx->state[5];
    30ec:	9b19      	ldr	r3, [sp, #100]	; 0x64
    G = ctx->state[6];
    H = ctx->state[7];
    30ee:	9c19      	ldr	r4, [sp, #100]	; 0x64
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    30f0:	9e19      	ldr	r6, [sp, #100]	; 0x64
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    30f2:	9004      	str	r0, [sp, #16]
    F = ctx->state[5];
    G = ctx->state[6];
    30f4:	6a12      	ldr	r2, [r2, #32]
    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    30f6:	69db      	ldr	r3, [r3, #28]
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30f8:	ea4f 15b0 	mov.w	r5, r0, ror #6
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    30fc:	9819      	ldr	r0, [sp, #100]	; 0x64
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];
    30fe:	6a64      	ldr	r4, [r4, #36]	; 0x24
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3100:	68b6      	ldr	r6, [r6, #8]
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    3102:	9202      	str	r2, [sp, #8]
    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    3104:	9303      	str	r3, [sp, #12]
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    3106:	68c0      	ldr	r0, [r0, #12]
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3108:	9608      	str	r6, [sp, #32]
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];
    310a:	9401      	str	r4, [sp, #4]

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    310c:	9a04      	ldr	r2, [sp, #16]
    310e:	9c02      	ldr	r4, [sp, #8]
    3110:	9e03      	ldr	r6, [sp, #12]
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    3112:	9007      	str	r0, [sp, #28]
    C = ctx->state[2];
    3114:	9819      	ldr	r0, [sp, #100]	; 0x64
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3116:	ea85 25f2 	eor.w	r5, r5, r2, ror #11
    311a:	4bd0      	ldr	r3, [pc, #832]	; (345c <sha256_process+0x37c>)
    311c:	ea84 0206 	eor.w	r2, r4, r6
    3120:	9c04      	ldr	r4, [sp, #16]
    3122:	9e01      	ldr	r6, [sp, #4]
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3124:	6900      	ldr	r0, [r0, #16]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3126:	784f      	ldrb	r7, [r1, #1]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3128:	ea85 6574 	eor.w	r5, r5, r4, ror #25
    312c:	4433      	add	r3, r6
    312e:	4022      	ands	r2, r4
    3130:	9e08      	ldr	r6, [sp, #32]
    3132:	9c07      	ldr	r4, [sp, #28]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3134:	f891 a000 	ldrb.w	sl, [r1]
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3138:	9006      	str	r0, [sp, #24]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    313a:	f891 c003 	ldrb.w	ip, [r1, #3]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    313e:	eb03 0805 	add.w	r8, r3, r5
    3142:	ea44 0006 	orr.w	r0, r4, r6
    3146:	9b02      	ldr	r3, [sp, #8]
    3148:	9c06      	ldr	r4, [sp, #24]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    314a:	043f      	lsls	r7, r7, #16
    314c:	f891 9002 	ldrb.w	r9, [r1, #2]
    3150:	ea47 670a 	orr.w	r7, r7, sl, lsl #24
    3154:	ea47 070c 	orr.w	r7, r7, ip
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3158:	405a      	eors	r2, r3
    315a:	4020      	ands	r0, r4
    315c:	9b07      	ldr	r3, [sp, #28]
    315e:	9c08      	ldr	r4, [sp, #32]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3160:	ea47 2909 	orr.w	r9, r7, r9, lsl #8
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3164:	ea4f 06b6 	mov.w	r6, r6, ror #2
    3168:	ea03 0504 	and.w	r5, r3, r4
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    316c:	f891 a005 	ldrb.w	sl, [r1, #5]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3170:	ea86 3674 	eor.w	r6, r6, r4, ror #13
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3174:	790c      	ldrb	r4, [r1, #4]
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3176:	f8cd 906c 	str.w	r9, [sp, #108]	; 0x6c
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    317a:	9f19      	ldr	r7, [sp, #100]	; 0x64
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    317c:	9b08      	ldr	r3, [sp, #32]
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    317e:	697f      	ldr	r7, [r7, #20]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3180:	4328      	orrs	r0, r5
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3182:	ea4f 4a0a 	mov.w	sl, sl, lsl #16
    3186:	79cd      	ldrb	r5, [r1, #7]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3188:	ea86 56b3 	eor.w	r6, r6, r3, ror #22
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    318c:	ea4a 6a04 	orr.w	sl, sl, r4, lsl #24
    3190:	798c      	ldrb	r4, [r1, #6]
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    3192:	9705      	str	r7, [sp, #20]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3194:	4430      	add	r0, r6
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3196:	ea4a 0a05 	orr.w	sl, sl, r5
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    319a:	9e03      	ldr	r6, [sp, #12]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    319c:	4442      	add	r2, r8
    319e:	46bc      	mov	ip, r7
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31a0:	9f04      	ldr	r7, [sp, #16]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    31a2:	444a      	add	r2, r9
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    31a4:	ea4a 2404 	orr.w	r4, sl, r4, lsl #8
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    31a8:	eb00 0b02 	add.w	fp, r0, r2
    31ac:	4494      	add	ip, r2
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    31ae:	940d      	str	r4, [sp, #52]	; 0x34
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31b0:	9d03      	ldr	r5, [sp, #12]
    31b2:	9c08      	ldr	r4, [sp, #32]
    31b4:	ea86 0207 	eor.w	r2, r6, r7
    31b8:	9802      	ldr	r0, [sp, #8]
    31ba:	ea0c 0202 	and.w	r2, ip, r2
    31be:	4ba8      	ldr	r3, [pc, #672]	; (3460 <sha256_process+0x380>)
    31c0:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
    31c4:	ea4b 0704 	orr.w	r7, fp, r4
    31c8:	406a      	eors	r2, r5
    31ca:	ea0b 0504 	and.w	r5, fp, r4
    31ce:	9c07      	ldr	r4, [sp, #28]
    31d0:	4403      	add	r3, r0
    31d2:	ea4f 18bc 	mov.w	r8, ip, ror #6
    31d6:	ea4f 06bb 	mov.w	r6, fp, ror #2
    31da:	444b      	add	r3, r9
    31dc:	ea88 28fc 	eor.w	r8, r8, ip, ror #11
    31e0:	4027      	ands	r7, r4
    31e2:	ea86 367b 	eor.w	r6, r6, fp, ror #13
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    31e6:	7a48      	ldrb	r0, [r1, #9]
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31e8:	ea88 687c 	eor.w	r8, r8, ip, ror #25
    31ec:	ea86 56bb 	eor.w	r6, r6, fp, ror #22
    31f0:	4413      	add	r3, r2
    31f2:	432f      	orrs	r7, r5
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    31f4:	7a0c      	ldrb	r4, [r1, #8]
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31f6:	4443      	add	r3, r8
    31f8:	4437      	add	r7, r6
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    31fa:	7acd      	ldrb	r5, [r1, #11]
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31fc:	441f      	add	r7, r3
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    31fe:	0400      	lsls	r0, r0, #16
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    3200:	970b      	str	r7, [sp, #44]	; 0x2c
    3202:	9e06      	ldr	r6, [sp, #24]
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3204:	9f04      	ldr	r7, [sp, #16]
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3206:	ea40 6004 	orr.w	r0, r0, r4, lsl #24
    320a:	7a8c      	ldrb	r4, [r1, #10]
    320c:	4328      	orrs	r0, r5
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    320e:	441e      	add	r6, r3
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3210:	ea8c 0907 	eor.w	r9, ip, r7
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3214:	ea40 2404 	orr.w	r4, r0, r4, lsl #8
    3218:	940e      	str	r4, [sp, #56]	; 0x38
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    321a:	9803      	ldr	r0, [sp, #12]
    321c:	ea06 0909 	and.w	r9, r6, r9
    3220:	4a90      	ldr	r2, [pc, #576]	; (3464 <sha256_process+0x384>)
    3222:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    3224:	ea89 0907 	eor.w	r9, r9, r7
    3228:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    322a:	4402      	add	r2, r0
    322c:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
    3230:	ea43 080b 	orr.w	r8, r3, fp
    3234:	ea4f 04b3 	mov.w	r4, r3, ror #2
    3238:	443a      	add	r2, r7
    323a:	ea03 070b 	and.w	r7, r3, fp
    323e:	9b08      	ldr	r3, [sp, #32]
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3240:	7b48      	ldrb	r0, [r1, #13]
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3242:	ea4f 15b6 	mov.w	r5, r6, ror #6
    3246:	ea08 0803 	and.w	r8, r8, r3
    324a:	ea84 347a 	eor.w	r4, r4, sl, ror #13
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    324e:	7b0b      	ldrb	r3, [r1, #12]
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3250:	ea84 54ba 	eor.w	r4, r4, sl, ror #22
    3254:	ea85 25f6 	eor.w	r5, r5, r6, ror #11
    3258:	ea48 0807 	orr.w	r8, r8, r7
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    325c:	0400      	lsls	r0, r0, #16
    325e:	7bcf      	ldrb	r7, [r1, #15]
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3260:	ea85 6576 	eor.w	r5, r5, r6, ror #25
    3264:	444a      	add	r2, r9
    3266:	44a0      	add	r8, r4
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3268:	ea40 6303 	orr.w	r3, r0, r3, lsl #24
    326c:	7b8c      	ldrb	r4, [r1, #14]
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    326e:	442a      	add	r2, r5
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3270:	433b      	orrs	r3, r7
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3272:	9d07      	ldr	r5, [sp, #28]
    3274:	4490      	add	r8, r2
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3276:	ea43 2404 	orr.w	r4, r3, r4, lsl #8
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    327a:	4415      	add	r5, r2
    327c:	f8cd 8030 	str.w	r8, [sp, #48]	; 0x30

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3280:	7c4f      	ldrb	r7, [r1, #17]
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3282:	4879      	ldr	r0, [pc, #484]	; (3468 <sha256_process+0x388>)
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3284:	940f      	str	r4, [sp, #60]	; 0x3c
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3286:	9a04      	ldr	r2, [sp, #16]

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3288:	7c0b      	ldrb	r3, [r1, #16]
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    328a:	4410      	add	r0, r2
    328c:	9a0b      	ldr	r2, [sp, #44]	; 0x2c

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    328e:	930a      	str	r3, [sp, #40]	; 0x28
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3290:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    3292:	ea48 0402 	orr.w	r4, r8, r2
    3296:	ea4f 02b8 	mov.w	r2, r8, ror #2

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    329a:	f891 8013 	ldrb.w	r8, [r1, #19]
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    329e:	4403      	add	r3, r0
    32a0:	9309      	str	r3, [sp, #36]	; 0x24

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32a2:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32a6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    32a8:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
    32ac:	ea86 0a0c 	eor.w	sl, r6, ip
    32b0:	ea03 0008 	and.w	r0, r3, r8
    32b4:	ea05 0a0a 	and.w	sl, r5, sl
    32b8:	ea82 3273 	eor.w	r2, r2, r3, ror #13
    32bc:	9b09      	ldr	r3, [sp, #36]	; 0x24

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32be:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32c2:	ea04 040b 	and.w	r4, r4, fp
    32c6:	ea8a 0a0c 	eor.w	sl, sl, ip
    32ca:	449a      	add	sl, r3
    32cc:	ea4f 19b5 	mov.w	r9, r5, ror #6
    32d0:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    32d2:	4320      	orrs	r0, r4

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32d4:	043f      	lsls	r7, r7, #16
    32d6:	9c10      	ldr	r4, [sp, #64]	; 0x40
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32d8:	ea89 29f5 	eor.w	r9, r9, r5, ror #11

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32dc:	ea47 6708 	orr.w	r7, r7, r8, lsl #24
    32e0:	f891 8012 	ldrb.w	r8, [r1, #18]
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32e4:	ea82 52b3 	eor.w	r2, r2, r3, ror #22

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32e8:	4327      	orrs	r7, r4
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32ea:	ea89 6975 	eor.w	r9, r9, r5, ror #25
    32ee:	44d1      	add	r9, sl

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32f0:	ea47 2808 	orr.w	r8, r7, r8, lsl #8
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32f4:	4410      	add	r0, r2
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    32f6:	7d4f      	ldrb	r7, [r1, #21]

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32f8:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    32fa:	4b5c      	ldr	r3, [pc, #368]	; (346c <sha256_process+0x38c>)
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32fc:	4448      	add	r0, r9
    32fe:	9009      	str	r0, [sp, #36]	; 0x24
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3300:	9712      	str	r7, [sp, #72]	; 0x48

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3302:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3306:	4443      	add	r3, r8
    3308:	ea4f 07b0 	mov.w	r7, r0, ror #2
    330c:	ea40 0802 	orr.w	r8, r0, r2
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3310:	7d08      	ldrb	r0, [r1, #20]
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    3312:	9c08      	ldr	r4, [sp, #32]
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3314:	9011      	str	r0, [sp, #68]	; 0x44

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3316:	4463      	add	r3, ip
    3318:	980b      	ldr	r0, [sp, #44]	; 0x2c
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    331a:	444c      	add	r4, r9
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    331c:	930a      	str	r3, [sp, #40]	; 0x28
    331e:	ea85 0a06 	eor.w	sl, r5, r6
    3322:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3324:	ea08 0800 	and.w	r8, r8, r0
    3328:	ea04 0a0a 	and.w	sl, r4, sl
    332c:	980a      	ldr	r0, [sp, #40]	; 0x28
    332e:	ea03 0c02 	and.w	ip, r3, r2
    3332:	ea8a 0a06 	eor.w	sl, sl, r6
    3336:	ea87 3773 	eor.w	r7, r7, r3, ror #13
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    333a:	9b12      	ldr	r3, [sp, #72]	; 0x48

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    333c:	ea4f 19b4 	mov.w	r9, r4, ror #6
    3340:	4482      	add	sl, r0
    3342:	ea48 0c0c 	orr.w	ip, r8, ip
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3346:	9811      	ldr	r0, [sp, #68]	; 0x44

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3348:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    334c:	ea89 29f4 	eor.w	r9, r9, r4, ror #11
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3350:	041a      	lsls	r2, r3, #16
    3352:	7dcb      	ldrb	r3, [r1, #23]

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3354:	ea89 6974 	eor.w	r9, r9, r4, ror #25
    3358:	ea87 57b8 	eor.w	r7, r7, r8, ror #22
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    335c:	ea42 6200 	orr.w	r2, r2, r0, lsl #24
    3360:	f891 8016 	ldrb.w	r8, [r1, #22]

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3364:	44ca      	add	sl, r9
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3366:	431a      	orrs	r2, r3

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3368:	44bc      	add	ip, r7
    336a:	44d4      	add	ip, sl
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    336c:	ea42 2808 	orr.w	r8, r2, r8, lsl #8
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3370:	4b3f      	ldr	r3, [pc, #252]	; (3470 <sha256_process+0x390>)

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3372:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3376:	f8cd 8044 	str.w	r8, [sp, #68]	; 0x44
    GET_UINT32( W[6],  data, 24 );
    337a:	7e4a      	ldrb	r2, [r1, #25]
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    337c:	4443      	add	r3, r8
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    337e:	9212      	str	r2, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3380:	441e      	add	r6, r3
    3382:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    3384:	9b09      	ldr	r3, [sp, #36]	; 0x24
    3386:	9f09      	ldr	r7, [sp, #36]	; 0x24
    3388:	ea02 0803 	and.w	r8, r2, r3
    338c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    338e:	ea4c 0907 	orr.w	r9, ip, r7
    3392:	ea4f 0cbc 	mov.w	ip, ip, ror #2

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3396:	eb0a 000b 	add.w	r0, sl, fp
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    339a:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    339c:	ea84 0b05 	eor.w	fp, r4, r5
    33a0:	ea8c 3c73 	eor.w	ip, ip, r3, ror #13
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33a4:	9b12      	ldr	r3, [sp, #72]	; 0x48
    33a6:	7e0f      	ldrb	r7, [r1, #24]
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33a8:	ea00 0b0b 	and.w	fp, r0, fp
    33ac:	ea8b 0b05 	eor.w	fp, fp, r5
    33b0:	ea09 0902 	and.w	r9, r9, r2
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33b4:	041a      	lsls	r2, r3, #16
    33b6:	7ecb      	ldrb	r3, [r1, #27]
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33b8:	445e      	add	r6, fp
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33ba:	ea42 6207 	orr.w	r2, r2, r7, lsl #24
    33be:	f891 b01a 	ldrb.w	fp, [r1, #26]
    33c2:	ea42 0703 	orr.w	r7, r2, r3
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33c6:	ea49 0808 	orr.w	r8, r9, r8
    33ca:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33ce:	ea47 2b0b 	orr.w	fp, r7, fp, lsl #8
    33d2:	f8cd b048 	str.w	fp, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33d6:	ea8c 5cb9 	eor.w	ip, ip, r9, ror #22
    33da:	ea4f 1ab0 	mov.w	sl, r0, ror #6
    33de:	ea8a 2af0 	eor.w	sl, sl, r0, ror #11
    33e2:	44e0      	add	r8, ip
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33e4:	4b23      	ldr	r3, [pc, #140]	; (3474 <sha256_process+0x394>)
    33e6:	f8dd c048 	ldr.w	ip, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33ea:	ea8a 6a70 	eor.w	sl, sl, r0, ror #25
    33ee:	4456      	add	r6, sl
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33f0:	4463      	add	r3, ip
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33f2:	44b0      	add	r8, r6
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33f4:	441d      	add	r5, r3
    33f6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33f8:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    33fa:	f891 a01d 	ldrb.w	sl, [r1, #29]
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33fe:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3402:	ea48 0909 	orr.w	r9, r8, r9
    3406:	ea4f 0cb8 	mov.w	ip, r8, ror #2
    340a:	ea08 0803 	and.w	r8, r8, r3
    340e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3410:	f8cd a04c 	str.w	sl, [sp, #76]	; 0x4c
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3414:	4432      	add	r2, r6
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3416:	ea80 0b04 	eor.w	fp, r0, r4
    341a:	9e09      	ldr	r6, [sp, #36]	; 0x24
    341c:	ea8c 3c73 	eor.w	ip, ip, r3, ror #13
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3420:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    3422:	7f0f      	ldrb	r7, [r1, #28]
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3424:	ea02 0b0b 	and.w	fp, r2, fp
    3428:	ea8b 0b04 	eor.w	fp, fp, r4
    342c:	ea09 0906 	and.w	r9, r9, r6
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3430:	041e      	lsls	r6, r3, #16
    3432:	7fcb      	ldrb	r3, [r1, #31]
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3434:	445d      	add	r5, fp
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3436:	ea46 6607 	orr.w	r6, r6, r7, lsl #24
    343a:	f891 b01e 	ldrb.w	fp, [r1, #30]
    343e:	431e      	orrs	r6, r3
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3440:	ea4f 1ab2 	mov.w	sl, r2, ror #6
    3444:	ea49 0808 	orr.w	r8, r9, r8
    3448:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    344c:	ea46 2b0b 	orr.w	fp, r6, fp, lsl #8
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3450:	ea8a 2af2 	eor.w	sl, sl, r2, ror #11
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3454:	f8cd b04c 	str.w	fp, [sp, #76]	; 0x4c
    3458:	e00e      	b.n	3478 <sha256_process+0x398>
    345a:	bf00      	nop
    345c:	428a2f98 	addmi	r2, sl, #152, 30	; 0x260
    3460:	71374491 			; <UNDEFINED> instruction: 0x71374491
    3464:	b5c0fbcf 	strblt	pc, [r0, #3023]	; 0xbcf	; <UNPREDICTABLE>
    3468:	e9b5dba5 	ldmib	r5!, {r0, r2, r5, r7, r8, r9, fp, ip, lr, pc}
    346c:	3956c25b 	ldmdbcc	r6, {r0, r1, r3, r4, r6, r9, lr, pc}^
    3470:	59f111f1 	ldmibpl	r1!, {r0, r4, r5, r6, r7, r8, ip}^
    3474:	923f82a4 	eorsls	r8, pc, #164, 4	; 0x4000000a
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3478:	ea8c 5cb9 	eor.w	ip, ip, r9, ror #22
    347c:	ea8a 6a72 	eor.w	sl, sl, r2, ror #25
    3480:	44aa      	add	sl, r5
    3482:	44e0      	add	r8, ip
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3484:	4de9      	ldr	r5, [pc, #932]	; (382c <sha256_process+0x74c>)
    3486:	f8dd c04c 	ldr.w	ip, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    348a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    348c:	4465      	add	r5, ip
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    348e:	44d0      	add	r8, sl
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3490:	442c      	add	r4, r5
    3492:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3494:	4453      	add	r3, sl
    3496:	f8cd 8030 	str.w	r8, [sp, #48]	; 0x30
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    349a:	f891 a021 	ldrb.w	sl, [r1, #33]	; 0x21
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    349e:	9e0a      	ldr	r6, [sp, #40]	; 0x28
    34a0:	ea48 0909 	orr.w	r9, r8, r9
    34a4:	ea4f 0cb8 	mov.w	ip, r8, ror #2
    34a8:	ea08 0805 	and.w	r8, r8, r5
    34ac:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34ae:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34b2:	ea82 0b00 	eor.w	fp, r2, r0
    34b6:	ea09 0906 	and.w	r9, r9, r6
    34ba:	ea8c 3c75 	eor.w	ip, ip, r5, ror #13
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34be:	9d14      	ldr	r5, [sp, #80]	; 0x50
    34c0:	f891 7020 	ldrb.w	r7, [r1, #32]
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34c4:	ea03 0b0b 	and.w	fp, r3, fp
    34c8:	ea4f 1ab3 	mov.w	sl, r3, ror #6
    34cc:	ea49 0808 	orr.w	r8, r9, r8
    34d0:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
    34d4:	ea8b 0b00 	eor.w	fp, fp, r0
    34d8:	ea8a 2af3 	eor.w	sl, sl, r3, ror #11
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34dc:	042e      	lsls	r6, r5, #16
    34de:	f891 5023 	ldrb.w	r5, [r1, #35]	; 0x23
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34e2:	ea8a 6a73 	eor.w	sl, sl, r3, ror #25
    34e6:	ea8c 5cb9 	eor.w	ip, ip, r9, ror #22
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34ea:	ea46 6607 	orr.w	r6, r6, r7, lsl #24
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34ee:	445c      	add	r4, fp
    34f0:	4454      	add	r4, sl
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34f2:	4335      	orrs	r5, r6
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34f4:	44e0      	add	r8, ip
    34f6:	9e09      	ldr	r6, [sp, #36]	; 0x24
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34f8:	f891 b022 	ldrb.w	fp, [r1, #34]	; 0x22
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34fc:	44a0      	add	r8, r4
    34fe:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
    3502:	4426      	add	r6, r4
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3504:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
    3508:	9c0c      	ldr	r4, [sp, #48]	; 0x30
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    350a:	f891 a025 	ldrb.w	sl, [r1, #37]	; 0x25
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    350e:	4fc8      	ldr	r7, [pc, #800]	; (3830 <sha256_process+0x750>)
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3510:	ea45 2b0b 	orr.w	fp, r5, fp, lsl #8
    GET_UINT32( W[9],  data, 36 );
    3514:	f8cd a050 	str.w	sl, [sp, #80]	; 0x50
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3518:	f8cd b068 	str.w	fp, [sp, #104]	; 0x68
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    351c:	ea83 0902 	eor.w	r9, r3, r2
    3520:	445f      	add	r7, fp
    3522:	ea4f 0abc 	mov.w	sl, ip, ror #2
    3526:	ea4c 0b04 	orr.w	fp, ip, r4
    352a:	ea0c 0c04 	and.w	ip, ip, r4
    352e:	9c09      	ldr	r4, [sp, #36]	; 0x24
    3530:	ea06 0909 	and.w	r9, r6, r9
    3534:	ea89 0902 	eor.w	r9, r9, r2
    3538:	4438      	add	r0, r7
    353a:	ea8a 3a74 	eor.w	sl, sl, r4, ror #13
    353e:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3540:	9c14      	ldr	r4, [sp, #80]	; 0x50
    3542:	f891 5024 	ldrb.w	r5, [r1, #36]	; 0x24
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3546:	ea4f 18b6 	mov.w	r8, r6, ror #6
    354a:	4448      	add	r0, r9
    354c:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    3550:	ea88 28f6 	eor.w	r8, r8, r6, ror #11
    3554:	ea0b 0b07 	and.w	fp, fp, r7
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3558:	0427      	lsls	r7, r4, #16
    355a:	f891 4027 	ldrb.w	r4, [r1, #39]	; 0x27
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    355e:	ea88 6876 	eor.w	r8, r8, r6, ror #25
    3562:	ea8a 5ab9 	eor.w	sl, sl, r9, ror #22
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3566:	ea47 6505 	orr.w	r5, r7, r5, lsl #24
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    356a:	ea4b 0b0c 	orr.w	fp, fp, ip
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    356e:	f891 7026 	ldrb.w	r7, [r1, #38]	; 0x26
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3572:	4440      	add	r0, r8
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3574:	432c      	orrs	r4, r5
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3576:	44d3      	add	fp, sl
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3578:	4dae      	ldr	r5, [pc, #696]	; (3834 <sha256_process+0x754>)
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    357a:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    357e:	ea44 2707 	orr.w	r7, r4, r7, lsl #8
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3582:	4483      	add	fp, r0
    3584:	f8cd b028 	str.w	fp, [sp, #40]	; 0x28
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3588:	443d      	add	r5, r7
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    358a:	4481      	add	r9, r0
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    358c:	442a      	add	r2, r5
    358e:	9809      	ldr	r0, [sp, #36]	; 0x24
    3590:	9d0a      	ldr	r5, [sp, #40]	; 0x28
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3592:	f891 a029 	ldrb.w	sl, [r1, #41]	; 0x29
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3596:	9714      	str	r7, [sp, #80]	; 0x50
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3598:	ea4b 0b00 	orr.w	fp, fp, r0
    359c:	ea05 0700 	and.w	r7, r5, r0
    35a0:	980c      	ldr	r0, [sp, #48]	; 0x30
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35a2:	f8cd a054 	str.w	sl, [sp, #84]	; 0x54
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35a6:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    35a8:	ea86 0803 	eor.w	r8, r6, r3
    35ac:	ea0b 0b00 	and.w	fp, fp, r0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35b0:	9815      	ldr	r0, [sp, #84]	; 0x54
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35b2:	ea09 0808 	and.w	r8, r9, r8
    35b6:	ea4f 1cb9 	mov.w	ip, r9, ror #6
    35ba:	ea4f 0ab4 	mov.w	sl, r4, ror #2
    35be:	ea4b 0b07 	orr.w	fp, fp, r7
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35c2:	f891 4028 	ldrb.w	r4, [r1, #40]	; 0x28
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35c6:	9f0a      	ldr	r7, [sp, #40]	; 0x28
    35c8:	ea88 0803 	eor.w	r8, r8, r3
    35cc:	ea8c 2cf9 	eor.w	ip, ip, r9, ror #11
    35d0:	ea8a 3a75 	eor.w	sl, sl, r5, ror #13
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35d4:	0405      	lsls	r5, r0, #16
    35d6:	f891 002b 	ldrb.w	r0, [r1, #43]	; 0x2b
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35da:	ea8c 6c79 	eor.w	ip, ip, r9, ror #25
    35de:	ea8a 5ab7 	eor.w	sl, sl, r7, ror #22
    35e2:	4442      	add	r2, r8
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35e4:	ea45 6404 	orr.w	r4, r5, r4, lsl #24
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35e8:	4462      	add	r2, ip
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35ea:	f891 802a 	ldrb.w	r8, [r1, #42]	; 0x2a
    35ee:	4304      	orrs	r4, r0
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35f0:	44d3      	add	fp, sl
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35f2:	980a      	ldr	r0, [sp, #40]	; 0x28
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35f4:	4493      	add	fp, r2
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35f6:	4d90      	ldr	r5, [pc, #576]	; (3838 <sha256_process+0x758>)
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35f8:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35fa:	ea44 2808 	orr.w	r8, r4, r8, lsl #8
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    35fe:	ea4b 0c00 	orr.w	ip, fp, r0
    3602:	9809      	ldr	r0, [sp, #36]	; 0x24
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3604:	f8cd b02c 	str.w	fp, [sp, #44]	; 0x2c
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3608:	4445      	add	r5, r8
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    360a:	4417      	add	r7, r2
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    360c:	ea89 0a06 	eor.w	sl, r9, r6
    3610:	ea4f 04bb 	mov.w	r4, fp, ror #2
    3614:	442b      	add	r3, r5
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3616:	f891 b02c 	ldrb.w	fp, [r1, #44]	; 0x2c
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    361a:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    361c:	ea0c 0c00 	and.w	ip, ip, r0
    3620:	980a      	ldr	r0, [sp, #40]	; 0x28
    3622:	ea07 0a0a 	and.w	sl, r7, sl
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3626:	f8cd b058 	str.w	fp, [sp, #88]	; 0x58
    362a:	f891 202d 	ldrb.w	r2, [r1, #45]	; 0x2d
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    362e:	ea05 0b00 	and.w	fp, r5, r0
    3632:	ea8a 0a06 	eor.w	sl, sl, r6
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3636:	f8cd 8054 	str.w	r8, [sp, #84]	; 0x54
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    363a:	4453      	add	r3, sl
    363c:	ea4f 18b7 	mov.w	r8, r7, ror #6
    3640:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
    3644:	ea4c 0c0b 	orr.w	ip, ip, fp
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3648:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    364c:	ea88 28f7 	eor.w	r8, r8, r7, ror #11
    3650:	ea84 3475 	eor.w	r4, r4, r5, ror #13
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3654:	0412      	lsls	r2, r2, #16
    3656:	f891 502f 	ldrb.w	r5, [r1, #47]	; 0x2f
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    365a:	ea88 6877 	eor.w	r8, r8, r7, ror #25
    365e:	ea84 54ba 	eor.w	r4, r4, sl, ror #22
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3662:	ea42 620b 	orr.w	r2, r2, fp, lsl #24
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3666:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    366a:	f891 b02e 	ldrb.w	fp, [r1, #46]	; 0x2e
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    366e:	4443      	add	r3, r8
    3670:	44a4      	add	ip, r4
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3672:	432a      	orrs	r2, r5
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3674:	4c71      	ldr	r4, [pc, #452]	; (383c <sha256_process+0x75c>)
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3676:	eb0c 0803 	add.w	r8, ip, r3
    367a:	449a      	add	sl, r3
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    367c:	ea42 2b0b 	orr.w	fp, r2, fp, lsl #8
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3680:	ea87 0c09 	eor.w	ip, r7, r9
    3684:	445c      	add	r4, fp
    3686:	ea0a 0c0c 	and.w	ip, sl, ip
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    368a:	f8cd b058 	str.w	fp, [sp, #88]	; 0x58
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    368e:	ea8c 0c09 	eor.w	ip, ip, r9
    3692:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    3694:	4426      	add	r6, r4
    3696:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    369a:	f891 4030 	ldrb.w	r4, [r1, #48]	; 0x30
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    369e:	4466      	add	r6, ip
    36a0:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
    36a4:	ea48 0002 	orr.w	r0, r8, r2
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36a8:	940c      	str	r4, [sp, #48]	; 0x30
    36aa:	f891 3031 	ldrb.w	r3, [r1, #49]	; 0x31
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36ae:	ea00 000b 	and.w	r0, r0, fp
    36b2:	ea08 0b0c 	and.w	fp, r8, ip
    36b6:	ea4f 15ba 	mov.w	r5, sl, ror #6
    36ba:	ea4f 02b8 	mov.w	r2, r8, ror #2
    36be:	ea40 000b 	orr.w	r0, r0, fp
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36c2:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
    36c6:	f891 4033 	ldrb.w	r4, [r1, #51]	; 0x33
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36ca:	ea85 25fa 	eor.w	r5, r5, sl, ror #11
    36ce:	ea82 3278 	eor.w	r2, r2, r8, ror #13
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36d2:	041b      	lsls	r3, r3, #16
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36d4:	ea85 657a 	eor.w	r5, r5, sl, ror #25
    36d8:	ea82 52b8 	eor.w	r2, r2, r8, ror #22
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36dc:	ea43 630b 	orr.w	r3, r3, fp, lsl #24
    36e0:	f891 b032 	ldrb.w	fp, [r1, #50]	; 0x32
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36e4:	442e      	add	r6, r5
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36e6:	4323      	orrs	r3, r4
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36e8:	4410      	add	r0, r2
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36ea:	4a55      	ldr	r2, [pc, #340]	; (3840 <sha256_process+0x760>)
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36ec:	9c09      	ldr	r4, [sp, #36]	; 0x24
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36ee:	ea43 2b0b 	orr.w	fp, r3, fp, lsl #8
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36f2:	4430      	add	r0, r6
    36f4:	9009      	str	r0, [sp, #36]	; 0x24
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36f6:	445a      	add	r2, fp
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36f8:	4434      	add	r4, r6
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36fa:	4491      	add	r9, r2
    36fc:	ea8a 0607 	eor.w	r6, sl, r7
    3700:	9a09      	ldr	r2, [sp, #36]	; 0x24
    3702:	4026      	ands	r6, r4
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3704:	f891 3035 	ldrb.w	r3, [r1, #53]	; 0x35
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3708:	407e      	eors	r6, r7
    370a:	ea4f 0cb2 	mov.w	ip, r2, ror #2
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    370e:	f8cd b05c 	str.w	fp, [sp, #92]	; 0x5c
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3712:	ea8c 3c72 	eor.w	ip, ip, r2, ror #13
    3716:	f8dd b02c 	ldr.w	fp, [sp, #44]	; 0x2c
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    371a:	f891 2034 	ldrb.w	r2, [r1, #52]	; 0x34
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    371e:	44b1      	add	r9, r6
    3720:	9e09      	ldr	r6, [sp, #36]	; 0x24
    3722:	ea40 0008 	orr.w	r0, r0, r8
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3726:	041b      	lsls	r3, r3, #16
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3728:	ea00 000b 	and.w	r0, r0, fp
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    372c:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
    3730:	f891 b037 	ldrb.w	fp, [r1, #55]	; 0x37
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3734:	ea06 0208 	and.w	r2, r6, r8
    3738:	4310      	orrs	r0, r2
    373a:	ea4f 15b4 	mov.w	r5, r4, ror #6
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    373e:	f891 2036 	ldrb.w	r2, [r1, #54]	; 0x36
    3742:	ea43 030b 	orr.w	r3, r3, fp
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3746:	ea85 25f4 	eor.w	r5, r5, r4, ror #11
    374a:	ea8c 5cb6 	eor.w	ip, ip, r6, ror #22
    374e:	ea85 6574 	eor.w	r5, r5, r4, ror #25
    3752:	4484      	add	ip, r0
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3754:	ea43 2202 	orr.w	r2, r3, r2, lsl #8
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3758:	980a      	ldr	r0, [sp, #40]	; 0x28
    375a:	44a9      	add	r9, r5
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    375c:	9218      	str	r2, [sp, #96]	; 0x60
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    375e:	eb0c 0b09 	add.w	fp, ip, r9
    3762:	4448      	add	r0, r9
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3764:	4e37      	ldr	r6, [pc, #220]	; (3844 <sha256_process+0x764>)
    3766:	f8dd 9060 	ldr.w	r9, [sp, #96]	; 0x60
    376a:	ea84 020a 	eor.w	r2, r4, sl
    376e:	444e      	add	r6, r9
    3770:	4002      	ands	r2, r0
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3772:	f891 5039 	ldrb.w	r5, [r1, #57]	; 0x39
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3776:	ea82 020a 	eor.w	r2, r2, sl
    377a:	443e      	add	r6, r7
    377c:	9f09      	ldr	r7, [sp, #36]	; 0x24
    377e:	4416      	add	r6, r2
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3780:	f891 2038 	ldrb.w	r2, [r1, #56]	; 0x38
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3784:	ea4b 0307 	orr.w	r3, fp, r7
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3788:	042d      	lsls	r5, r5, #16
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    378a:	ea03 0308 	and.w	r3, r3, r8
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    378e:	ea45 6502 	orr.w	r5, r5, r2, lsl #24
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3792:	ea0b 0207 	and.w	r2, fp, r7
    3796:	4313      	orrs	r3, r2
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3798:	f891 203b 	ldrb.w	r2, [r1, #59]	; 0x3b
    379c:	f891 703a 	ldrb.w	r7, [r1, #58]	; 0x3a
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37a0:	ea4f 1cb0 	mov.w	ip, r0, ror #6
    37a4:	ea4f 09bb 	mov.w	r9, fp, ror #2
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    37a8:	4315      	orrs	r5, r2
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37aa:	ea8c 2cf0 	eor.w	ip, ip, r0, ror #11
    37ae:	ea89 397b 	eor.w	r9, r9, fp, ror #13
    37b2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    37b4:	ea8c 6c70 	eor.w	ip, ip, r0, ror #25
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    37b8:	ea45 2707 	orr.w	r7, r5, r7, lsl #8
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37bc:	ea89 59bb 	eor.w	r9, r9, fp, ror #22
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    37c0:	970b      	str	r7, [sp, #44]	; 0x2c
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37c2:	4466      	add	r6, ip
    37c4:	4499      	add	r9, r3
    37c6:	4432      	add	r2, r6
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37c8:	4b1f      	ldr	r3, [pc, #124]	; (3848 <sha256_process+0x768>)
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37ca:	444e      	add	r6, r9
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37cc:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    37d0:	ea80 0704 	eor.w	r7, r0, r4
    37d4:	444b      	add	r3, r9
    37d6:	4017      	ands	r7, r2
    37d8:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
    37dc:	4067      	eors	r7, r4
    37de:	449a      	add	sl, r3
    37e0:	44ba      	add	sl, r7
    37e2:	ea46 070b 	orr.w	r7, r6, fp
    37e6:	ea06 030b 	and.w	r3, r6, fp
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    37ea:	f891 503d 	ldrb.w	r5, [r1, #61]	; 0x3d
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37ee:	ea07 070c 	and.w	r7, r7, ip
    37f2:	431f      	orrs	r7, r3
    37f4:	ea4f 0cb6 	mov.w	ip, r6, ror #2
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    37f8:	f891 303c 	ldrb.w	r3, [r1, #60]	; 0x3c
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37fc:	ea8c 3c76 	eor.w	ip, ip, r6, ror #13
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3800:	042d      	lsls	r5, r5, #16
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3802:	ea8c 5cb6 	eor.w	ip, ip, r6, ror #22
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3806:	ea45 6503 	orr.w	r5, r5, r3, lsl #24
    380a:	f891 303f 	ldrb.w	r3, [r1, #63]	; 0x3f
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    380e:	ea4f 19b2 	mov.w	r9, r2, ror #6
    3812:	4467      	add	r7, ip
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3814:	f891 c03e 	ldrb.w	ip, [r1, #62]	; 0x3e
    3818:	431d      	orrs	r5, r3
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    381a:	ea89 29f2 	eor.w	r9, r9, r2, ror #11
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    381e:	490b      	ldr	r1, [pc, #44]	; (384c <sha256_process+0x76c>)
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3820:	ea45 2c0c 	orr.w	ip, r5, ip, lsl #8
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3824:	ea89 6972 	eor.w	r9, r9, r2, ror #25
    3828:	e012      	b.n	3850 <sha256_process+0x770>
    382a:	bf00      	nop
    382c:	ab1c5ed5 	blge	71b388 <_etext+0x713d74>
    3830:	d807aa98 	stmdale	r7, {r3, r4, r7, r9, fp, sp, pc}
    3834:	12835b01 	addne	r5, r3, #1024	; 0x400
    3838:	243185be 	ldrtcs	r8, [r1], #-1470	; 0x5be
    383c:	550c7dc3 	strpl	r7, [ip, #-3523]	; 0xdc3
    3840:	72be5d74 	adcsvc	r5, lr, #116, 26	; 0x1d00
    3844:	80deb1fe 	ldrshhi	fp, [lr], #30
    3848:	9bdc06a7 	blls	ff7052ec <BootRAM+0xe675a8d>
    384c:	c19bf174 	orrsgt	pc, fp, r4, ror r1	; <UNPREDICTABLE>
    3850:	44ca      	add	sl, r9
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3852:	4461      	add	r1, ip
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3854:	f8cd c030 	str.w	ip, [sp, #48]	; 0x30
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3858:	eb0a 0308 	add.w	r3, sl, r8
    385c:	4457      	add	r7, sl
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    385e:	440c      	add	r4, r1
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3860:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
    3864:	991b      	ldr	r1, [sp, #108]	; 0x6c
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3866:	ea82 0900 	eor.w	r9, r2, r0
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    386a:	448a      	add	sl, r1
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    386c:	ea03 0909 	and.w	r9, r3, r9
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3870:	990b      	ldr	r1, [sp, #44]	; 0x2c
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3872:	ea89 0900 	eor.w	r9, r9, r0
    3876:	ea4f 1cb3 	mov.w	ip, r3, ror #6
    387a:	444c      	add	r4, r9
    387c:	ea8c 2cf3 	eor.w	ip, ip, r3, ror #11
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3880:	ea4f 4971 	mov.w	r9, r1, ror #17
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3884:	ea47 0506 	orr.w	r5, r7, r6
    3888:	ea4f 08b7 	mov.w	r8, r7, ror #2
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    388c:	ea89 49f1 	eor.w	r9, r9, r1, ror #19
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3890:	ea8c 6c73 	eor.w	ip, ip, r3, ror #25
    3894:	44a4      	add	ip, r4
    3896:	ea05 050b 	and.w	r5, r5, fp
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    389a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    389c:	ea88 3877 	eor.w	r8, r8, r7, ror #13
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38a0:	ea89 2991 	eor.w	r9, r9, r1, lsr #10
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    38a4:	ea07 0106 	and.w	r1, r7, r6
    38a8:	ea88 58b7 	eor.w	r8, r8, r7, ror #22
    38ac:	430d      	orrs	r5, r1
    38ae:	4445      	add	r5, r8
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38b0:	ea4f 18f4 	mov.w	r8, r4, ror #7
    38b4:	ea88 48b4 	eor.w	r8, r8, r4, ror #18
    38b8:	ea88 08d4 	eor.w	r8, r8, r4, lsr #3
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    38bc:	9c09      	ldr	r4, [sp, #36]	; 0x24
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38be:	44d1      	add	r9, sl
    38c0:	49eb      	ldr	r1, [pc, #940]	; (3c70 <sha256_process+0xb90>)
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    38c2:	4464      	add	r4, ip
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38c4:	44c8      	add	r8, r9
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    38c6:	4465      	add	r5, ip
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38c8:	4441      	add	r1, r8
    38ca:	ea83 0c02 	eor.w	ip, r3, r2
    38ce:	ea4f 19b4 	mov.w	r9, r4, ror #6
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38d2:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38d6:	ea04 0c0c 	and.w	ip, r4, ip
    38da:	4408      	add	r0, r1
    38dc:	ea89 21f4 	eor.w	r1, r9, r4, ror #11
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38e0:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38e4:	ea8c 0c02 	eor.w	ip, ip, r2
    38e8:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38ec:	44d1      	add	r9, sl
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38ee:	ea45 0807 	orr.w	r8, r5, r7
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38f2:	f8dd a030 	ldr.w	sl, [sp, #48]	; 0x30
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38f6:	ea81 6174 	eor.w	r1, r1, r4, ror #25
    38fa:	4460      	add	r0, ip
    38fc:	4408      	add	r0, r1
    38fe:	ea08 0806 	and.w	r8, r8, r6
    3902:	ea05 0107 	and.w	r1, r5, r7
    3906:	ea4f 0cb5 	mov.w	ip, r5, ror #2
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    390a:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    390e:	ea8c 3c75 	eor.w	ip, ip, r5, ror #13
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3912:	ea4f 497a 	mov.w	r9, sl, ror #17
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3916:	ea48 0801 	orr.w	r8, r8, r1
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    391a:	990e      	ldr	r1, [sp, #56]	; 0x38
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    391c:	ea8c 5cb5 	eor.w	ip, ip, r5, ror #22
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3920:	ea89 49fa 	eor.w	r9, r9, sl, ror #19
    3924:	ea89 299a 	eor.w	r9, r9, sl, lsr #10
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3928:	44e0      	add	r8, ip
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    392a:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    392e:	ea4f 1cf1 	mov.w	ip, r1, ror #7
    3932:	ea8c 4cb1 	eor.w	ip, ip, r1, ror #18
    3936:	44d1      	add	r9, sl
    3938:	ea8c 0cd1 	eor.w	ip, ip, r1, lsr #3
    393c:	49cd      	ldr	r1, [pc, #820]	; (3c74 <sha256_process+0xb94>)
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    393e:	4483      	add	fp, r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3940:	44cc      	add	ip, r9
    3942:	ea84 0903 	eor.w	r9, r4, r3
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3946:	4480      	add	r8, r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3948:	4461      	add	r1, ip
    394a:	ea4f 10bb 	mov.w	r0, fp, ror #6
    394e:	ea0b 0909 	and.w	r9, fp, r9
    3952:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
    3956:	ea89 0903 	eor.w	r9, r9, r3
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    395a:	f8dd c058 	ldr.w	ip, [sp, #88]	; 0x58
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    395e:	440a      	add	r2, r1
    3960:	ea80 21fb 	eor.w	r1, r0, fp, ror #11
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3964:	980e      	ldr	r0, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3966:	ea48 0a05 	orr.w	sl, r8, r5
    396a:	ea81 617b 	eor.w	r1, r1, fp, ror #25
    396e:	444a      	add	r2, r9
    3970:	ea4f 09b8 	mov.w	r9, r8, ror #2
    3974:	440a      	add	r2, r1
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3976:	4484      	add	ip, r0
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3978:	ea08 0105 	and.w	r1, r8, r5
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    397c:	980f      	ldr	r0, [sp, #60]	; 0x3c
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    397e:	ea0a 0a07 	and.w	sl, sl, r7
    3982:	ea89 3978 	eor.w	r9, r9, r8, ror #13
    3986:	ea89 59b8 	eor.w	r9, r9, r8, ror #22
    398a:	ea4a 0a01 	orr.w	sl, sl, r1
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    398e:	f8cd c034 	str.w	ip, [sp, #52]	; 0x34
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3992:	44ca      	add	sl, r9
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3994:	ea4f 1cf0 	mov.w	ip, r0, ror #7
    3998:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    399c:	ea8c 4cb0 	eor.w	ip, ip, r0, ror #18
    39a0:	ea8c 0cd0 	eor.w	ip, ip, r0, lsr #3
    39a4:	ea4f 4179 	mov.w	r1, r9, ror #17
    39a8:	980d      	ldr	r0, [sp, #52]	; 0x34
    39aa:	ea81 41f9 	eor.w	r1, r1, r9, ror #19
    39ae:	4484      	add	ip, r0
    39b0:	ea81 2199 	eor.w	r1, r1, r9, lsr #10
    39b4:	48b0      	ldr	r0, [pc, #704]	; (3c78 <sha256_process+0xb98>)
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    39b6:	4416      	add	r6, r2
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39b8:	4461      	add	r1, ip
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    39ba:	4492      	add	sl, r2
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39bc:	4408      	add	r0, r1
    39be:	ea8b 0204 	eor.w	r2, fp, r4
    39c2:	ea4f 1cb6 	mov.w	ip, r6, ror #6
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39c6:	f8dd 905c 	ldr.w	r9, [sp, #92]	; 0x5c
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39ca:	4032      	ands	r2, r6
    39cc:	4403      	add	r3, r0
    39ce:	ea8c 20f6 	eor.w	r0, ip, r6, ror #11
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39d2:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39d6:	4062      	eors	r2, r4
    39d8:	910d      	str	r1, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39da:	44e1      	add	r9, ip
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39dc:	ea4a 0108 	orr.w	r1, sl, r8
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39e0:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39e4:	ea80 6076 	eor.w	r0, r0, r6, ror #25
    39e8:	4413      	add	r3, r2
    39ea:	4403      	add	r3, r0
    39ec:	4029      	ands	r1, r5
    39ee:	ea0a 0008 	and.w	r0, sl, r8
    39f2:	ea4f 02ba 	mov.w	r2, sl, ror #2
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39f6:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39fa:	ea82 327a 	eor.w	r2, r2, sl, ror #13
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39fe:	ea4f 19fc 	mov.w	r9, ip, ror #7
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3a02:	4301      	orrs	r1, r0
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a04:	980a      	ldr	r0, [sp, #40]	; 0x28
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3a06:	ea82 52ba 	eor.w	r2, r2, sl, ror #22
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a0a:	ea89 49bc 	eor.w	r9, r9, ip, ror #18
    3a0e:	ea89 09dc 	eor.w	r9, r9, ip, lsr #3
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3a12:	4411      	add	r1, r2
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a14:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
    3a18:	ea4f 4270 	mov.w	r2, r0, ror #17
    3a1c:	ea82 42f0 	eor.w	r2, r2, r0, ror #19
    3a20:	44cc      	add	ip, r9
    3a22:	ea82 2290 	eor.w	r2, r2, r0, lsr #10
    3a26:	4895      	ldr	r0, [pc, #596]	; (3c7c <sha256_process+0xb9c>)
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3a28:	441f      	add	r7, r3
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a2a:	4462      	add	r2, ip
    3a2c:	ea86 090b 	eor.w	r9, r6, fp
    3a30:	4410      	add	r0, r2
    3a32:	ea07 0909 	and.w	r9, r7, r9
    3a36:	ea4f 1cb7 	mov.w	ip, r7, ror #6
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3a3a:	4419      	add	r1, r3
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a3c:	920e      	str	r2, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a3e:	9b10      	ldr	r3, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a40:	ea89 090b 	eor.w	r9, r9, fp
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a44:	9a18      	ldr	r2, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a46:	4420      	add	r0, r4
    3a48:	ea8c 2cf7 	eor.w	ip, ip, r7, ror #11
    3a4c:	ea41 040a 	orr.w	r4, r1, sl
    3a50:	ea8c 6c77 	eor.w	ip, ip, r7, ror #25
    3a54:	4448      	add	r0, r9
    3a56:	ea4f 09b1 	mov.w	r9, r1, ror #2
    3a5a:	4460      	add	r0, ip
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a5c:	441a      	add	r2, r3
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a5e:	ea01 0c0a 	and.w	ip, r1, sl
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a62:	9b11      	ldr	r3, [sp, #68]	; 0x44
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a64:	ea04 0408 	and.w	r4, r4, r8
    3a68:	ea89 3971 	eor.w	r9, r9, r1, ror #13
    3a6c:	ea89 59b1 	eor.w	r9, r9, r1, ror #22
    3a70:	ea44 040c 	orr.w	r4, r4, ip
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a74:	920f      	str	r2, [sp, #60]	; 0x3c
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a76:	444c      	add	r4, r9
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a78:	ea4f 12f3 	mov.w	r2, r3, ror #7
    3a7c:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
    3a80:	ea82 42b3 	eor.w	r2, r2, r3, ror #18
    3a84:	ea82 02d3 	eor.w	r2, r2, r3, lsr #3
    3a88:	ea4f 4c79 	mov.w	ip, r9, ror #17
    3a8c:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    3a8e:	ea8c 4cf9 	eor.w	ip, ip, r9, ror #19
    3a92:	4413      	add	r3, r2
    3a94:	ea8c 2c99 	eor.w	ip, ip, r9, lsr #10
    3a98:	4a79      	ldr	r2, [pc, #484]	; (3c80 <sha256_process+0xba0>)
    3a9a:	449c      	add	ip, r3
    3a9c:	4462      	add	r2, ip
    3a9e:	f8cd c03c 	str.w	ip, [sp, #60]	; 0x3c
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3aa2:	4405      	add	r5, r0
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3aa4:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3aa8:	ea87 0306 	eor.w	r3, r7, r6
    3aac:	4493      	add	fp, r2
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3aae:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3ab0:	402b      	ands	r3, r5
    3ab2:	ea4f 1cb5 	mov.w	ip, r5, ror #6
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3ab6:	4404      	add	r4, r0
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3ab8:	4073      	eors	r3, r6
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3aba:	444a      	add	r2, r9
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3abc:	ea8c 2cf5 	eor.w	ip, ip, r5, ror #11
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ac0:	9210      	str	r2, [sp, #64]	; 0x40
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3ac2:	ea44 0001 	orr.w	r0, r4, r1
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ac6:	9a12      	ldr	r2, [sp, #72]	; 0x48
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3ac8:	449b      	add	fp, r3
    3aca:	ea8c 6c75 	eor.w	ip, ip, r5, ror #25
    3ace:	44dc      	add	ip, fp
    3ad0:	ea00 000a 	and.w	r0, r0, sl
    3ad4:	ea04 0b01 	and.w	fp, r4, r1
    3ad8:	ea4f 09b4 	mov.w	r9, r4, ror #2
    3adc:	ea89 3974 	eor.w	r9, r9, r4, ror #13
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ae0:	ea4f 13f2 	mov.w	r3, r2, ror #7
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3ae4:	ea40 000b 	orr.w	r0, r0, fp
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ae8:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3aec:	ea89 59b4 	eor.w	r9, r9, r4, ror #22
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3af0:	ea83 43b2 	eor.w	r3, r3, r2, ror #18
    3af4:	ea83 03d2 	eor.w	r3, r3, r2, lsr #3
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3af8:	4448      	add	r0, r9
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3afa:	9a10      	ldr	r2, [sp, #64]	; 0x40
    3afc:	ea4f 497b 	mov.w	r9, fp, ror #17
    3b00:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    3b04:	441a      	add	r2, r3
    3b06:	ea89 299b 	eor.w	r9, r9, fp, lsr #10
    3b0a:	4b5e      	ldr	r3, [pc, #376]	; (3c84 <sha256_process+0xba4>)
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3b0c:	44e0      	add	r8, ip
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b0e:	4491      	add	r9, r2
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3b10:	4460      	add	r0, ip
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b12:	f8cd 9040 	str.w	r9, [sp, #64]	; 0x40
    3b16:	ea85 0c07 	eor.w	ip, r5, r7
    3b1a:	444b      	add	r3, r9
    3b1c:	ea4f 19b8 	mov.w	r9, r8, ror #6
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b20:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b24:	ea08 0c0c 	and.w	ip, r8, ip
    3b28:	441e      	add	r6, r3
    3b2a:	ea89 23f8 	eor.w	r3, r9, r8, ror #11
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b2e:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b32:	ea8c 0c07 	eor.w	ip, ip, r7
    3b36:	ea40 0204 	orr.w	r2, r0, r4
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b3a:	44d9      	add	r9, fp
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b3c:	ea83 6378 	eor.w	r3, r3, r8, ror #25
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b40:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b44:	4466      	add	r6, ip
    3b46:	441e      	add	r6, r3
    3b48:	400a      	ands	r2, r1
    3b4a:	ea00 0304 	and.w	r3, r0, r4
    3b4e:	ea4f 0cb0 	mov.w	ip, r0, ror #2
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b52:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b56:	ea8c 3c70 	eor.w	ip, ip, r0, ror #13
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b5a:	ea4f 19fb 	mov.w	r9, fp, ror #7
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b5e:	431a      	orrs	r2, r3
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b60:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b62:	ea8c 5cb0 	eor.w	ip, ip, r0, ror #22
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b66:	ea89 49bb 	eor.w	r9, r9, fp, ror #18
    3b6a:	ea89 09db 	eor.w	r9, r9, fp, lsr #3
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b6e:	4462      	add	r2, ip
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b70:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
    3b74:	ea4f 4c73 	mov.w	ip, r3, ror #17
    3b78:	ea8c 4cf3 	eor.w	ip, ip, r3, ror #19
    3b7c:	44cb      	add	fp, r9
    3b7e:	ea8c 2c93 	eor.w	ip, ip, r3, lsr #10
    3b82:	44dc      	add	ip, fp
    3b84:	f8cd c044 	str.w	ip, [sp, #68]	; 0x44
    3b88:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    3b8c:	4b3e      	ldr	r3, [pc, #248]	; (3c88 <sha256_process+0xba8>)
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b8e:	4432      	add	r2, r6
    3b90:	44b2      	add	sl, r6
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b92:	ea88 0c05 	eor.w	ip, r8, r5
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3b96:	9e1a      	ldr	r6, [sp, #104]	; 0x68
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b98:	444b      	add	r3, r9
    3b9a:	ea0a 0c0c 	and.w	ip, sl, ip
    3b9e:	ea8c 0c05 	eor.w	ip, ip, r5
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3ba2:	ea4f 1bf6 	mov.w	fp, r6, ror #7
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ba6:	441f      	add	r7, r3
    3ba8:	ea4f 19ba 	mov.w	r9, sl, ror #6
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bac:	ea8b 4bb6 	eor.w	fp, fp, r6, ror #18
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bb0:	ea89 29fa 	eor.w	r9, r9, sl, ror #11
    3bb4:	4467      	add	r7, ip
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bb6:	f8dd c04c 	ldr.w	ip, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bba:	ea42 0300 	orr.w	r3, r2, r0
    3bbe:	ea89 697a 	eor.w	r9, r9, sl, ror #25
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bc2:	ea8b 0bd6 	eor.w	fp, fp, r6, lsr #3
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bc6:	ea4f 06b2 	mov.w	r6, r2, ror #2
    3bca:	444f      	add	r7, r9
    3bcc:	4023      	ands	r3, r4
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bce:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    3bd2:	44e3      	add	fp, ip
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bd4:	ea86 3672 	eor.w	r6, r6, r2, ror #13
    3bd8:	ea02 0c00 	and.w	ip, r2, r0
    3bdc:	ea86 56b2 	eor.w	r6, r6, r2, ror #22
    3be0:	ea43 030c 	orr.w	r3, r3, ip
    3be4:	4433      	add	r3, r6
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3be6:	ea4f 4c79 	mov.w	ip, r9, ror #17
    3bea:	9e09      	ldr	r6, [sp, #36]	; 0x24
    3bec:	ea8c 4cf9 	eor.w	ip, ip, r9, ror #19
    3bf0:	44b3      	add	fp, r6
    3bf2:	ea8c 2c99 	eor.w	ip, ip, r9, lsr #10
    3bf6:	4e25      	ldr	r6, [pc, #148]	; (3c8c <sha256_process+0xbac>)
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bf8:	443b      	add	r3, r7
    3bfa:	4439      	add	r1, r7
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bfc:	44dc      	add	ip, fp
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3bfe:	9f14      	ldr	r7, [sp, #80]	; 0x50
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c00:	ea8a 0908 	eor.w	r9, sl, r8
    3c04:	4466      	add	r6, ip
    3c06:	ea01 0909 	and.w	r9, r1, r9
    3c0a:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
    3c0e:	4435      	add	r5, r6
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c10:	f8dd c050 	ldr.w	ip, [sp, #80]	; 0x50
    3c14:	ea4f 1bf7 	mov.w	fp, r7, ror #7
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c18:	ea89 0908 	eor.w	r9, r9, r8
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c1c:	ea8b 4bb7 	eor.w	fp, fp, r7, ror #18
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c20:	44a9      	add	r9, r5
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c22:	9d1a      	ldr	r5, [sp, #104]	; 0x68
    3c24:	ea8b 0bdc 	eor.w	fp, fp, ip, lsr #3
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c28:	ea43 0c02 	orr.w	ip, r3, r2
    3c2c:	ea03 0602 	and.w	r6, r3, r2
    3c30:	ea4f 17b1 	mov.w	r7, r1, ror #6
    3c34:	ea0c 0c00 	and.w	ip, ip, r0
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c38:	445d      	add	r5, fp
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c3a:	ea4f 0bb3 	mov.w	fp, r3, ror #2
    3c3e:	ea87 27f1 	eor.w	r7, r7, r1, ror #11
    3c42:	ea8b 3b73 	eor.w	fp, fp, r3, ror #13
    3c46:	ea4c 0c06 	orr.w	ip, ip, r6
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c4a:	9e11      	ldr	r6, [sp, #68]	; 0x44
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c4c:	ea87 6771 	eor.w	r7, r7, r1, ror #25
    3c50:	ea8b 5bb3 	eor.w	fp, fp, r3, ror #22
    3c54:	44b9      	add	r9, r7
    3c56:	44dc      	add	ip, fp
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c58:	ea4f 4776 	mov.w	r7, r6, ror #17
    3c5c:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    3c60:	ea87 47f6 	eor.w	r7, r7, r6, ror #19
    3c64:	445d      	add	r5, fp
    3c66:	ea87 2796 	eor.w	r7, r7, r6, lsr #10
    3c6a:	19ef      	adds	r7, r5, r7
    3c6c:	e010      	b.n	3c90 <sha256_process+0xbb0>
    3c6e:	bf00      	nop
    3c70:	e49b69c1 	ldr	r6, [fp], #2497	; 0x9c1
    3c74:	efbe4786 	svc	0x00be4786
    3c78:	0fc19dc6 	svceq	0x00c19dc6
    3c7c:	240ca1cc 	strcs	sl, [ip], #-460	; 0x1cc
    3c80:	2de92c6f 	stclcs	12, cr2, [r9, #444]!	; 0x1bc
    3c84:	4a7484aa 	bmi	1d24f34 <_etext+0x1d1d920>
    3c88:	5cb0a9dc 	ldcpl	9, cr10, [r0], #880	; 0x370
    3c8c:	76f988da 	usatvc	r8, #25, sl, asr #17
    3c90:	9713      	str	r7, [sp, #76]	; 0x4c
    3c92:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
    3c96:	4ee6      	ldr	r6, [pc, #920]	; (4030 <sha256_process+0xf50>)
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c98:	44cc      	add	ip, r9
    3c9a:	444c      	add	r4, r9
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c9c:	ea81 050a 	eor.w	r5, r1, sl
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3ca0:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3ca4:	445e      	add	r6, fp
    3ca6:	4025      	ands	r5, r4
    3ca8:	ea85 050a 	eor.w	r5, r5, sl
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cac:	ea4f 17f9 	mov.w	r7, r9, ror #7
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cb0:	44b0      	add	r8, r6
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cb2:	ea87 47b9 	eor.w	r7, r7, r9, ror #18
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cb6:	ea4f 1bb4 	mov.w	fp, r4, ror #6
    3cba:	44a8      	add	r8, r5
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cbc:	9d14      	ldr	r5, [sp, #80]	; 0x50
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cbe:	ea8b 2bf4 	eor.w	fp, fp, r4, ror #11
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cc2:	ea87 07d9 	eor.w	r7, r7, r9, lsr #3
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cc6:	ea4c 0603 	orr.w	r6, ip, r3
    3cca:	ea8b 6b74 	eor.w	fp, fp, r4, ror #25
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cce:	442f      	add	r7, r5
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cd0:	ea4f 05bc 	mov.w	r5, ip, ror #2
    3cd4:	44d8      	add	r8, fp
    3cd6:	ea0c 0903 	and.w	r9, ip, r3
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cda:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cde:	4016      	ands	r6, r2
    3ce0:	ea85 357c 	eor.w	r5, r5, ip, ror #13
    3ce4:	ea85 55bc 	eor.w	r5, r5, ip, ror #22
    3ce8:	ea46 0609 	orr.w	r6, r6, r9
    3cec:	442e      	add	r6, r5
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cee:	ea4f 497b 	mov.w	r9, fp, ror #17
    3cf2:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    3cf4:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    3cf8:	442f      	add	r7, r5
    3cfa:	ea89 299b 	eor.w	r9, r9, fp, lsr #10
    3cfe:	44b9      	add	r9, r7
    3d00:	f8cd 9050 	str.w	r9, [sp, #80]	; 0x50
    3d04:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
    3d08:	4dca      	ldr	r5, [pc, #808]	; (4034 <sha256_process+0xf54>)
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d0a:	f8dd 9058 	ldr.w	r9, [sp, #88]	; 0x58
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3d0e:	4440      	add	r0, r8
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d10:	ea84 0701 	eor.w	r7, r4, r1
    3d14:	445d      	add	r5, fp
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3d16:	4446      	add	r6, r8
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d18:	44aa      	add	sl, r5
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d1a:	ea4f 18f9 	mov.w	r8, r9, ror #7
    3d1e:	9d16      	ldr	r5, [sp, #88]	; 0x58
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d20:	4007      	ands	r7, r0
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d22:	f8dd b054 	ldr.w	fp, [sp, #84]	; 0x54
    3d26:	ea88 48b9 	eor.w	r8, r8, r9, ror #18
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d2a:	404f      	eors	r7, r1
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d2c:	ea88 08d5 	eor.w	r8, r8, r5, lsr #3
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d30:	4457      	add	r7, sl
    3d32:	ea46 0a0c 	orr.w	sl, r6, ip
    3d36:	ea06 050c 	and.w	r5, r6, ip
    3d3a:	ea4f 19b0 	mov.w	r9, r0, ror #6
    3d3e:	ea0a 0a03 	and.w	sl, sl, r3
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d42:	44d8      	add	r8, fp
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d44:	ea4f 0bb6 	mov.w	fp, r6, ror #2
    3d48:	ea89 29f0 	eor.w	r9, r9, r0, ror #11
    3d4c:	ea8b 3b76 	eor.w	fp, fp, r6, ror #13
    3d50:	ea4a 0a05 	orr.w	sl, sl, r5
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d54:	9d13      	ldr	r5, [sp, #76]	; 0x4c
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d56:	ea89 6970 	eor.w	r9, r9, r0, ror #25
    3d5a:	ea8b 5bb6 	eor.w	fp, fp, r6, ror #22
    3d5e:	444f      	add	r7, r9
    3d60:	44da      	add	sl, fp
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d62:	ea4f 4975 	mov.w	r9, r5, ror #17
    3d66:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    3d6a:	ea89 49f5 	eor.w	r9, r9, r5, ror #19
    3d6e:	44d8      	add	r8, fp
    3d70:	ea89 2995 	eor.w	r9, r9, r5, lsr #10
    3d74:	44c1      	add	r9, r8
    3d76:	f8cd 9054 	str.w	r9, [sp, #84]	; 0x54
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d7a:	44ba      	add	sl, r7
    3d7c:	443a      	add	r2, r7
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d7e:	4dae      	ldr	r5, [pc, #696]	; (4038 <sha256_process+0xf58>)
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d80:	9f17      	ldr	r7, [sp, #92]	; 0x5c
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d82:	ea80 0804 	eor.w	r8, r0, r4
    3d86:	444d      	add	r5, r9
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d88:	ea4f 1bf7 	mov.w	fp, r7, ror #7
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d8c:	ea02 0808 	and.w	r8, r2, r8
    3d90:	4429      	add	r1, r5
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d92:	ea8b 4bb7 	eor.w	fp, fp, r7, ror #18
    3d96:	9d16      	ldr	r5, [sp, #88]	; 0x58
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d98:	ea88 0804 	eor.w	r8, r8, r4
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d9c:	ea8b 0bd7 	eor.w	fp, fp, r7, lsr #3
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3da0:	4488      	add	r8, r1
    3da2:	ea4a 0106 	orr.w	r1, sl, r6
    3da6:	ea4f 19b2 	mov.w	r9, r2, ror #6
    3daa:	ea01 010c 	and.w	r1, r1, ip
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3dae:	44ab      	add	fp, r5
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3db0:	ea4f 07ba 	mov.w	r7, sl, ror #2
    3db4:	ea0a 0506 	and.w	r5, sl, r6
    3db8:	ea89 29f2 	eor.w	r9, r9, r2, ror #11
    3dbc:	ea87 377a 	eor.w	r7, r7, sl, ror #13
    3dc0:	4329      	orrs	r1, r5
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3dc2:	9d14      	ldr	r5, [sp, #80]	; 0x50
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3dc4:	ea89 6972 	eor.w	r9, r9, r2, ror #25
    3dc8:	ea87 57ba 	eor.w	r7, r7, sl, ror #22
    3dcc:	44c8      	add	r8, r9
    3dce:	4439      	add	r1, r7
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3dd0:	ea4f 4975 	mov.w	r9, r5, ror #17
    3dd4:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    3dd6:	ea89 49f5 	eor.w	r9, r9, r5, ror #19
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3dda:	4441      	add	r1, r8
    3ddc:	4443      	add	r3, r8
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3dde:	44bb      	add	fp, r7
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3de0:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3de4:	ea89 2995 	eor.w	r9, r9, r5, lsr #10
    3de8:	4f94      	ldr	r7, [pc, #592]	; (403c <sha256_process+0xf5c>)
    3dea:	44d9      	add	r9, fp
    3dec:	f8cd 9058 	str.w	r9, [sp, #88]	; 0x58
    3df0:	ea82 0500 	eor.w	r5, r2, r0
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3df4:	ea4f 1bf8 	mov.w	fp, r8, ror #7
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3df8:	444f      	add	r7, r9
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3dfa:	f8dd 9060 	ldr.w	r9, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3dfe:	401d      	ands	r5, r3
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e00:	ea8b 4bb8 	eor.w	fp, fp, r8, ror #18
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e04:	4427      	add	r7, r4
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e06:	9c17      	ldr	r4, [sp, #92]	; 0x5c
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e08:	4045      	eors	r5, r0
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e0a:	ea8b 0bd9 	eor.w	fp, fp, r9, lsr #3
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e0e:	ea41 090a 	orr.w	r9, r1, sl
    3e12:	ea4f 18b3 	mov.w	r8, r3, ror #6
    3e16:	442f      	add	r7, r5
    3e18:	ea09 0906 	and.w	r9, r9, r6
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e1c:	44a3      	add	fp, r4
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e1e:	ea4f 05b1 	mov.w	r5, r1, ror #2
    3e22:	ea01 040a 	and.w	r4, r1, sl
    3e26:	ea88 28f3 	eor.w	r8, r8, r3, ror #11
    3e2a:	ea85 3571 	eor.w	r5, r5, r1, ror #13
    3e2e:	ea49 0904 	orr.w	r9, r9, r4
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e32:	9c15      	ldr	r4, [sp, #84]	; 0x54
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e34:	ea88 6873 	eor.w	r8, r8, r3, ror #25
    3e38:	ea85 55b1 	eor.w	r5, r5, r1, ror #22
    3e3c:	4447      	add	r7, r8
    3e3e:	44a9      	add	r9, r5
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e40:	ea4f 4874 	mov.w	r8, r4, ror #17
    3e44:	9d10      	ldr	r5, [sp, #64]	; 0x40
    3e46:	ea88 48f4 	eor.w	r8, r8, r4, ror #19
    3e4a:	44ab      	add	fp, r5
    3e4c:	ea88 2894 	eor.w	r8, r8, r4, lsr #10
    3e50:	44d8      	add	r8, fp
    3e52:	f8cd 805c 	str.w	r8, [sp, #92]	; 0x5c
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e56:	eb07 040c 	add.w	r4, r7, ip
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e5a:	4d79      	ldr	r5, [pc, #484]	; (4040 <sha256_process+0xf60>)
    3e5c:	f8dd c05c 	ldr.w	ip, [sp, #92]	; 0x5c
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e60:	44b9      	add	r9, r7
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e62:	ea83 0b02 	eor.w	fp, r3, r2
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e66:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e68:	4465      	add	r5, ip
    3e6a:	ea04 0b0b 	and.w	fp, r4, fp
    3e6e:	ea8b 0b02 	eor.w	fp, fp, r2
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e72:	ea4f 18f7 	mov.w	r8, r7, ror #7
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e76:	4428      	add	r0, r5
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e78:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    3e7a:	ea88 48b7 	eor.w	r8, r8, r7, ror #18
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e7e:	4458      	add	r0, fp
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e80:	f8dd b060 	ldr.w	fp, [sp, #96]	; 0x60
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e84:	ea49 0c01 	orr.w	ip, r9, r1
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e88:	ea88 08d5 	eor.w	r8, r8, r5, lsr #3
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e8c:	ea4f 17b4 	mov.w	r7, r4, ror #6
    3e90:	ea09 0501 	and.w	r5, r9, r1
    3e94:	ea0c 0c0a 	and.w	ip, ip, sl
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e98:	44d8      	add	r8, fp
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e9a:	ea4f 0bb9 	mov.w	fp, r9, ror #2
    3e9e:	ea87 27f4 	eor.w	r7, r7, r4, ror #11
    3ea2:	ea8b 3b79 	eor.w	fp, fp, r9, ror #13
    3ea6:	ea4c 0c05 	orr.w	ip, ip, r5
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3eaa:	9d16      	ldr	r5, [sp, #88]	; 0x58
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3eac:	ea87 6774 	eor.w	r7, r7, r4, ror #25
    3eb0:	ea8b 5bb9 	eor.w	fp, fp, r9, ror #22
    3eb4:	4438      	add	r0, r7
    3eb6:	44dc      	add	ip, fp
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3eb8:	ea4f 4775 	mov.w	r7, r5, ror #17
    3ebc:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
    3ec0:	ea87 47f5 	eor.w	r7, r7, r5, ror #19
    3ec4:	44d8      	add	r8, fp
    3ec6:	ea87 2795 	eor.w	r7, r7, r5, lsr #10
    3eca:	4d5e      	ldr	r5, [pc, #376]	; (4044 <sha256_process+0xf64>)
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3ecc:	eb00 0b06 	add.w	fp, r0, r6
    3ed0:	4484      	add	ip, r0
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3ed2:	4447      	add	r7, r8
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ed4:	980c      	ldr	r0, [sp, #48]	; 0x30
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3ed6:	ea84 0603 	eor.w	r6, r4, r3
    3eda:	443d      	add	r5, r7
    3edc:	ea0b 0606 	and.w	r6, fp, r6
    3ee0:	405e      	eors	r6, r3
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ee2:	ea4f 18f0 	mov.w	r8, r0, ror #7
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3ee6:	442a      	add	r2, r5
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ee8:	ea88 48b0 	eor.w	r8, r8, r0, ror #18
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3eec:	4432      	add	r2, r6
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3eee:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
    3ef0:	ea88 05d0 	eor.w	r5, r8, r0, lsr #3
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3ef4:	ea4c 0809 	orr.w	r8, ip, r9
    3ef8:	9718      	str	r7, [sp, #96]	; 0x60
    3efa:	ea08 0801 	and.w	r8, r8, r1
    3efe:	ea0c 0009 	and.w	r0, ip, r9
    3f02:	ea4f 17bb 	mov.w	r7, fp, ror #6
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f06:	4435      	add	r5, r6
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3f08:	ea4f 06bc 	mov.w	r6, ip, ror #2
    3f0c:	ea87 27fb 	eor.w	r7, r7, fp, ror #11
    3f10:	ea86 367c 	eor.w	r6, r6, ip, ror #13
    3f14:	ea48 0000 	orr.w	r0, r8, r0
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f18:	f8dd 805c 	ldr.w	r8, [sp, #92]	; 0x5c
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3f1c:	ea87 677b 	eor.w	r7, r7, fp, ror #25
    3f20:	ea86 56bc 	eor.w	r6, r6, ip, ror #22
    3f24:	443a      	add	r2, r7
    3f26:	4430      	add	r0, r6
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f28:	ea4f 4778 	mov.w	r7, r8, ror #17
    3f2c:	9e12      	ldr	r6, [sp, #72]	; 0x48
    3f2e:	ea87 47f8 	eor.w	r7, r7, r8, ror #19
    3f32:	4435      	add	r5, r6
    3f34:	ea87 2898 	eor.w	r8, r7, r8, lsr #10
    3f38:	4e43      	ldr	r6, [pc, #268]	; (4048 <sha256_process+0xf68>)
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3f3a:	4492      	add	sl, r2
    3f3c:	4410      	add	r0, r2
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f3e:	9f09      	ldr	r7, [sp, #36]	; 0x24
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f40:	44a8      	add	r8, r5
    3f42:	ea8b 0204 	eor.w	r2, fp, r4
    3f46:	4446      	add	r6, r8
    3f48:	ea0a 0202 	and.w	r2, sl, r2
    3f4c:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
    3f50:	4062      	eors	r2, r4
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f52:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    3f56:	ea4f 15f7 	mov.w	r5, r7, ror #7
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f5a:	4433      	add	r3, r6
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f5c:	ea85 45b7 	eor.w	r5, r5, r7, ror #18
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f60:	4413      	add	r3, r2
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f62:	9a0c      	ldr	r2, [sp, #48]	; 0x30
    3f64:	ea85 05d8 	eor.w	r5, r5, r8, lsr #3
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f68:	ea40 080c 	orr.w	r8, r0, ip
    3f6c:	ea08 0809 	and.w	r8, r8, r9
    3f70:	ea00 060c 	and.w	r6, r0, ip
    3f74:	ea4f 17ba 	mov.w	r7, sl, ror #6
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f78:	4415      	add	r5, r2
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f7a:	ea4f 02b0 	mov.w	r2, r0, ror #2
    3f7e:	ea87 27fa 	eor.w	r7, r7, sl, ror #11
    3f82:	ea82 3270 	eor.w	r2, r2, r0, ror #13
    3f86:	ea48 0606 	orr.w	r6, r8, r6
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f8a:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f8e:	ea87 677a 	eor.w	r7, r7, sl, ror #25
    3f92:	ea82 52b0 	eor.w	r2, r2, r0, ror #22
    3f96:	443b      	add	r3, r7
    3f98:	4416      	add	r6, r2
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f9a:	ea4f 4778 	mov.w	r7, r8, ror #17
    3f9e:	9a13      	ldr	r2, [sp, #76]	; 0x4c
    3fa0:	ea87 47f8 	eor.w	r7, r7, r8, ror #19
    3fa4:	4415      	add	r5, r2
    3fa6:	ea87 2798 	eor.w	r7, r7, r8, lsr #10
    3faa:	4a28      	ldr	r2, [pc, #160]	; (404c <sha256_process+0xf6c>)
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3fac:	4419      	add	r1, r3
    3fae:	441e      	add	r6, r3
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fb0:	19ef      	adds	r7, r5, r7
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fb2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fb4:	ea8a 050b 	eor.w	r5, sl, fp
    3fb8:	443a      	add	r2, r7
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fba:	ea4f 18f3 	mov.w	r8, r3, ror #7
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fbe:	400d      	ands	r5, r1
    3fc0:	4422      	add	r2, r4
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fc2:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fc4:	970c      	str	r7, [sp, #48]	; 0x30
    3fc6:	ea85 050b 	eor.w	r5, r5, fp
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fca:	9f09      	ldr	r7, [sp, #36]	; 0x24
    3fcc:	ea88 48b3 	eor.w	r8, r8, r3, ror #18
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fd0:	ea4f 13b1 	mov.w	r3, r1, ror #6
    3fd4:	ea83 23f1 	eor.w	r3, r3, r1, ror #11
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fd8:	ea88 08d4 	eor.w	r8, r8, r4, lsr #3
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fdc:	442a      	add	r2, r5
    3fde:	ea46 0500 	orr.w	r5, r6, r0
    3fe2:	ea83 6471 	eor.w	r4, r3, r1, ror #25
    3fe6:	ea05 050c 	and.w	r5, r5, ip
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fea:	44b8      	add	r8, r7
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fec:	ea4f 03b6 	mov.w	r3, r6, ror #2
    3ff0:	ea06 0700 	and.w	r7, r6, r0
    3ff4:	ea83 3376 	eor.w	r3, r3, r6, ror #13
    3ff8:	432f      	orrs	r7, r5
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3ffa:	9d0b      	ldr	r5, [sp, #44]	; 0x2c
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3ffc:	ea83 53b6 	eor.w	r3, r3, r6, ror #22
    4000:	4422      	add	r2, r4
    4002:	441f      	add	r7, r3
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4004:	ea4f 4475 	mov.w	r4, r5, ror #17
    4008:	9b14      	ldr	r3, [sp, #80]	; 0x50
    400a:	ea84 44f5 	eor.w	r4, r4, r5, ror #19
    400e:	4498      	add	r8, r3
    4010:	ea84 2495 	eor.w	r4, r4, r5, lsr #10
    4014:	4444      	add	r4, r8
    4016:	9409      	str	r4, [sp, #36]	; 0x24
    4018:	4b0d      	ldr	r3, [pc, #52]	; (4050 <sha256_process+0xf70>)
    401a:	9d09      	ldr	r5, [sp, #36]	; 0x24
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    401c:	4417      	add	r7, r2
    401e:	4491      	add	r9, r2
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4020:	9c0d      	ldr	r4, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4022:	ea81 020a 	eor.w	r2, r1, sl
    4026:	442b      	add	r3, r5
    4028:	ea09 0202 	and.w	r2, r9, r2
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    402c:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    402e:	e011      	b.n	4054 <sha256_process+0xf74>
    4030:	983e5152 	ldmdals	lr!, {r1, r4, r6, r8, ip, lr}
    4034:	a831c66d 	ldmdage	r1!, {r0, r2, r3, r5, r6, r9, sl, lr, pc}
    4038:	b00327c8 	andlt	r2, r3, r8, asr #15
    403c:	bf597fc7 	svclt	0x00597fc7
    4040:	c6e00bf3 			; <UNDEFINED> instruction: 0xc6e00bf3
    4044:	d5a79147 	strle	r9, [r7, #327]!	; 0x147
    4048:	06ca6351 			; <UNDEFINED> instruction: 0x06ca6351
    404c:	14292967 	strtne	r2, [r9], #-2407	; 0x967
    4050:	27b70a85 	ldrcs	r0, [r7, r5, lsl #21]!
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4054:	ea82 020a 	eor.w	r2, r2, sl
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4058:	ea4f 18f4 	mov.w	r8, r4, ror #7
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    405c:	445b      	add	r3, fp
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    405e:	ea88 48b4 	eor.w	r8, r8, r4, ror #18
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4062:	4413      	add	r3, r2
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4064:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    4066:	ea88 0bd5 	eor.w	fp, r8, r5, lsr #3
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    406a:	ea47 0806 	orr.w	r8, r7, r6
    406e:	ea08 0800 	and.w	r8, r8, r0
    4072:	ea07 0506 	and.w	r5, r7, r6
    4076:	ea4f 14b9 	mov.w	r4, r9, ror #6
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    407a:	4493      	add	fp, r2
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    407c:	ea4f 02b7 	mov.w	r2, r7, ror #2
    4080:	ea84 24f9 	eor.w	r4, r4, r9, ror #11
    4084:	ea82 3277 	eor.w	r2, r2, r7, ror #13
    4088:	ea48 0505 	orr.w	r5, r8, r5
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    408c:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4090:	ea84 6479 	eor.w	r4, r4, r9, ror #25
    4094:	ea82 52b7 	eor.w	r2, r2, r7, ror #22
    4098:	4423      	add	r3, r4
    409a:	4415      	add	r5, r2
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    409c:	ea4f 4478 	mov.w	r4, r8, ror #17
    40a0:	9a15      	ldr	r2, [sp, #84]	; 0x54
    40a2:	ea84 44f8 	eor.w	r4, r4, r8, ror #19
    40a6:	4493      	add	fp, r2
    40a8:	ea84 2498 	eor.w	r4, r4, r8, lsr #10
    40ac:	445c      	add	r4, fp
    40ae:	940a      	str	r4, [sp, #40]	; 0x28
    40b0:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40b4:	9c0e      	ldr	r4, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    40b6:	4af1      	ldr	r2, [pc, #964]	; (447c <sha256_process+0x139c>)
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    40b8:	449c      	add	ip, r3
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    40ba:	ea89 0b01 	eor.w	fp, r9, r1
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    40be:	441d      	add	r5, r3
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    40c0:	4442      	add	r2, r8
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40c2:	ea4f 13f4 	mov.w	r3, r4, ror #7
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    40c6:	ea0c 0b0b 	and.w	fp, ip, fp
    40ca:	ea8b 0b01 	eor.w	fp, fp, r1
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40ce:	ea83 43b4 	eor.w	r3, r3, r4, ror #18
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    40d2:	4452      	add	r2, sl
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40d4:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    40d8:	ea83 03d4 	eor.w	r3, r3, r4, lsr #3
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    40dc:	445a      	add	r2, fp
    40de:	ea45 0b07 	orr.w	fp, r5, r7
    40e2:	ea0b 0b06 	and.w	fp, fp, r6
    40e6:	ea05 0407 	and.w	r4, r5, r7
    40ea:	ea4f 18bc 	mov.w	r8, ip, ror #6
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40ee:	449a      	add	sl, r3
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    40f0:	ea4f 03b5 	mov.w	r3, r5, ror #2
    40f4:	ea88 28fc 	eor.w	r8, r8, ip, ror #11
    40f8:	ea83 3375 	eor.w	r3, r3, r5, ror #13
    40fc:	ea4b 0404 	orr.w	r4, fp, r4
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4100:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4104:	ea88 687c 	eor.w	r8, r8, ip, ror #25
    4108:	ea83 53b5 	eor.w	r3, r3, r5, ror #22
    410c:	4442      	add	r2, r8
    410e:	441c      	add	r4, r3
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4110:	ea4f 487b 	mov.w	r8, fp, ror #17
    4114:	9b16      	ldr	r3, [sp, #88]	; 0x58
    4116:	ea88 48fb 	eor.w	r8, r8, fp, ror #19
    411a:	449a      	add	sl, r3
    411c:	ea88 289b 	eor.w	r8, r8, fp, lsr #10
    4120:	44d0      	add	r8, sl
    4122:	f8cd 8034 	str.w	r8, [sp, #52]	; 0x34
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4126:	4410      	add	r0, r2
    4128:	4414      	add	r4, r2
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    412a:	4bd5      	ldr	r3, [pc, #852]	; (4480 <sha256_process+0x13a0>)
    412c:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    412e:	f8dd 803c 	ldr.w	r8, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4132:	ea8c 0b09 	eor.w	fp, ip, r9
    4136:	4413      	add	r3, r2
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4138:	ea4f 1af8 	mov.w	sl, r8, ror #7
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    413c:	ea00 0b0b 	and.w	fp, r0, fp
    4140:	440b      	add	r3, r1
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4142:	990f      	ldr	r1, [sp, #60]	; 0x3c
    4144:	9a0e      	ldr	r2, [sp, #56]	; 0x38
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4146:	ea8b 0b09 	eor.w	fp, fp, r9
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    414a:	ea8a 4ab8 	eor.w	sl, sl, r8, ror #18
    414e:	ea8a 0ad1 	eor.w	sl, sl, r1, lsr #3
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4152:	445b      	add	r3, fp
    4154:	ea44 0b05 	orr.w	fp, r4, r5
    4158:	ea0b 0b07 	and.w	fp, fp, r7
    415c:	ea04 0105 	and.w	r1, r4, r5
    4160:	ea4f 18b0 	mov.w	r8, r0, ror #6
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4164:	4492      	add	sl, r2
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4166:	ea4f 02b4 	mov.w	r2, r4, ror #2
    416a:	ea88 28f0 	eor.w	r8, r8, r0, ror #11
    416e:	ea82 3274 	eor.w	r2, r2, r4, ror #13
    4172:	ea4b 0101 	orr.w	r1, fp, r1
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4176:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    417a:	ea88 6870 	eor.w	r8, r8, r0, ror #25
    417e:	ea82 52b4 	eor.w	r2, r2, r4, ror #22
    4182:	4443      	add	r3, r8
    4184:	4411      	add	r1, r2
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4186:	ea4f 487b 	mov.w	r8, fp, ror #17
    418a:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    418c:	ea88 48fb 	eor.w	r8, r8, fp, ror #19
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4190:	441e      	add	r6, r3
    4192:	4419      	add	r1, r3
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4194:	4492      	add	sl, r2
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4196:	9b10      	ldr	r3, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4198:	ea88 289b 	eor.w	r8, r8, fp, lsr #10
    419c:	4ab9      	ldr	r2, [pc, #740]	; (4484 <sha256_process+0x13a4>)
    419e:	44d0      	add	r8, sl
    41a0:	ea80 0b0c 	eor.w	fp, r0, ip
    41a4:	4442      	add	r2, r8
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41a6:	ea4f 1af3 	mov.w	sl, r3, ror #7
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41aa:	ea06 0b0b 	and.w	fp, r6, fp
    41ae:	ea8b 0b0c 	eor.w	fp, fp, ip
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41b2:	ea8a 4ab3 	eor.w	sl, sl, r3, ror #18
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41b6:	4491      	add	r9, r2
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41b8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    41ba:	ea8a 0ad3 	eor.w	sl, sl, r3, lsr #3
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41be:	44d9      	add	r9, fp
    41c0:	ea41 0b04 	orr.w	fp, r1, r4
    41c4:	f8cd 8038 	str.w	r8, [sp, #56]	; 0x38
    41c8:	ea0b 0b05 	and.w	fp, fp, r5
    41cc:	ea4f 18b6 	mov.w	r8, r6, ror #6
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41d0:	4492      	add	sl, r2
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41d2:	ea4f 03b1 	mov.w	r3, r1, ror #2
    41d6:	ea01 0204 	and.w	r2, r1, r4
    41da:	ea88 28f6 	eor.w	r8, r8, r6, ror #11
    41de:	ea83 3371 	eor.w	r3, r3, r1, ror #13
    41e2:	ea4b 0202 	orr.w	r2, fp, r2
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41e6:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41ea:	ea88 6876 	eor.w	r8, r8, r6, ror #25
    41ee:	ea83 53b1 	eor.w	r3, r3, r1, ror #22
    41f2:	44c1      	add	r9, r8
    41f4:	441a      	add	r2, r3
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41f6:	ea4f 487b 	mov.w	r8, fp, ror #17
    41fa:	9b18      	ldr	r3, [sp, #96]	; 0x60
    41fc:	ea88 48fb 	eor.w	r8, r8, fp, ror #19
    4200:	449a      	add	sl, r3
    4202:	ea88 289b 	eor.w	r8, r8, fp, lsr #10
    4206:	44d0      	add	r8, sl
    4208:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
    420c:	f8dd b03c 	ldr.w	fp, [sp, #60]	; 0x3c
    4210:	4b9d      	ldr	r3, [pc, #628]	; (4488 <sha256_process+0x13a8>)
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4212:	444a      	add	r2, r9
    4214:	444f      	add	r7, r9
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4216:	ea86 0800 	eor.w	r8, r6, r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    421a:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    421e:	445b      	add	r3, fp
    4220:	ea07 0808 	and.w	r8, r7, r8
    4224:	ea88 0800 	eor.w	r8, r8, r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4228:	ea4f 1af9 	mov.w	sl, r9, ror #7
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    422c:	449c      	add	ip, r3
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    422e:	9b11      	ldr	r3, [sp, #68]	; 0x44
    4230:	ea8a 4ab9 	eor.w	sl, sl, r9, ror #18
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4234:	44c4      	add	ip, r8
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4236:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    423a:	ea42 0b01 	orr.w	fp, r2, r1
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    423e:	ea8a 0ad3 	eor.w	sl, sl, r3, lsr #3
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4242:	ea0b 0b04 	and.w	fp, fp, r4
    4246:	ea02 0301 	and.w	r3, r2, r1
    424a:	ea4f 19b7 	mov.w	r9, r7, ror #6
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    424e:	44c2      	add	sl, r8
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4250:	ea4f 08b2 	mov.w	r8, r2, ror #2
    4254:	ea89 29f7 	eor.w	r9, r9, r7, ror #11
    4258:	ea88 3872 	eor.w	r8, r8, r2, ror #13
    425c:	ea4b 0303 	orr.w	r3, fp, r3
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4260:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4264:	ea89 6977 	eor.w	r9, r9, r7, ror #25
    4268:	ea88 58b2 	eor.w	r8, r8, r2, ror #22
    426c:	44cc      	add	ip, r9
    426e:	4443      	add	r3, r8
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4270:	ea4f 497b 	mov.w	r9, fp, ror #17
    4274:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
    4278:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    427c:	44c2      	add	sl, r8
    427e:	ea89 2b9b 	eor.w	fp, r9, fp, lsr #10
    4282:	44d3      	add	fp, sl
    4284:	f8df 820c 	ldr.w	r8, [pc, #524]	; 4494 <sha256_process+0x13b4>
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4288:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    428c:	4465      	add	r5, ip
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    428e:	ea87 0906 	eor.w	r9, r7, r6
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4292:	4463      	add	r3, ip
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4294:	f8cd b040 	str.w	fp, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4298:	ea4f 1cfa 	mov.w	ip, sl, ror #7
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    429c:	44d8      	add	r8, fp
    429e:	ea05 0909 	and.w	r9, r5, r9
    42a2:	ea4f 1bb5 	mov.w	fp, r5, ror #6
    42a6:	ea89 0906 	eor.w	r9, r9, r6
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42aa:	ea8c 4cba 	eor.w	ip, ip, sl, ror #18
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    42ae:	4480      	add	r8, r0
    42b0:	ea8b 2bf5 	eor.w	fp, fp, r5, ror #11
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42b4:	9811      	ldr	r0, [sp, #68]	; 0x44
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    42b6:	ea8b 6b75 	eor.w	fp, fp, r5, ror #25
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42ba:	ea8c 0cda 	eor.w	ip, ip, sl, lsr #3
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    42be:	44c8      	add	r8, r9
    42c0:	ea43 0a02 	orr.w	sl, r3, r2
    42c4:	ea4f 09b3 	mov.w	r9, r3, ror #2
    42c8:	44d8      	add	r8, fp
    42ca:	ea0a 0a01 	and.w	sl, sl, r1
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42ce:	f8dd b03c 	ldr.w	fp, [sp, #60]	; 0x3c
    42d2:	4484      	add	ip, r0
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    42d4:	ea89 3973 	eor.w	r9, r9, r3, ror #13
    42d8:	ea03 0002 	and.w	r0, r3, r2
    42dc:	ea89 59b3 	eor.w	r9, r9, r3, ror #22
    42e0:	ea4a 0000 	orr.w	r0, sl, r0
    42e4:	4448      	add	r0, r9
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42e6:	ea4f 4a7b 	mov.w	sl, fp, ror #17
    42ea:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
    42ee:	ea8a 4afb 	eor.w	sl, sl, fp, ror #19
    42f2:	44cc      	add	ip, r9
    42f4:	ea8a 2a9b 	eor.w	sl, sl, fp, lsr #10
    42f8:	44e2      	add	sl, ip
    42fa:	f8cd a044 	str.w	sl, [sp, #68]	; 0x44
    42fe:	f8df 9198 	ldr.w	r9, [pc, #408]	; 4498 <sha256_process+0x13b8>
    4302:	f8dd b044 	ldr.w	fp, [sp, #68]	; 0x44
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4306:	4440      	add	r0, r8
    4308:	4444      	add	r4, r8
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    430a:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    430e:	ea85 0807 	eor.w	r8, r5, r7
    4312:	44d9      	add	r9, fp
    4314:	ea04 0808 	and.w	r8, r4, r8
    4318:	ea88 0807 	eor.w	r8, r8, r7
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    431c:	ea4f 1cfa 	mov.w	ip, sl, ror #7
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4320:	44b1      	add	r9, r6
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4322:	9e13      	ldr	r6, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4324:	44c1      	add	r9, r8
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4326:	ea8c 4cba 	eor.w	ip, ip, sl, ror #18
    432a:	f8dd 8048 	ldr.w	r8, [sp, #72]	; 0x48
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    432e:	ea40 0b03 	orr.w	fp, r0, r3
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4332:	ea8c 0cd6 	eor.w	ip, ip, r6, lsr #3
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4336:	ea0b 0b02 	and.w	fp, fp, r2
    433a:	ea00 0603 	and.w	r6, r0, r3
    433e:	ea4f 1ab4 	mov.w	sl, r4, ror #6
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4342:	44c4      	add	ip, r8
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4344:	ea4f 08b0 	mov.w	r8, r0, ror #2
    4348:	ea8a 2af4 	eor.w	sl, sl, r4, ror #11
    434c:	ea88 3870 	eor.w	r8, r8, r0, ror #13
    4350:	ea4b 0606 	orr.w	r6, fp, r6
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4354:	f8dd b040 	ldr.w	fp, [sp, #64]	; 0x40
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4358:	ea88 58b0 	eor.w	r8, r8, r0, ror #22
    435c:	ea8a 6a74 	eor.w	sl, sl, r4, ror #25
    4360:	44ca      	add	sl, r9
    4362:	4446      	add	r6, r8
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4364:	ea4f 497b 	mov.w	r9, fp, ror #17
    4368:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    436c:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    4370:	44c4      	add	ip, r8
    4372:	ea89 299b 	eor.w	r9, r9, fp, lsr #10
    4376:	44e1      	add	r9, ip
    4378:	f8cd 9048 	str.w	r9, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    437c:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4380:	f8dd c048 	ldr.w	ip, [sp, #72]	; 0x48
    4384:	f8df 8114 	ldr.w	r8, [pc, #276]	; 449c <sha256_process+0x13bc>
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4388:	4451      	add	r1, sl
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    438a:	ea84 0905 	eor.w	r9, r4, r5
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    438e:	4456      	add	r6, sl
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4390:	44e0      	add	r8, ip
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4392:	ea4f 1afb 	mov.w	sl, fp, ror #7
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4396:	ea01 0909 	and.w	r9, r1, r9
    439a:	ea89 0905 	eor.w	r9, r9, r5
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    439e:	ea8a 4abb 	eor.w	sl, sl, fp, ror #18
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43a2:	4447      	add	r7, r8
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43a4:	f8dd 804c 	ldr.w	r8, [sp, #76]	; 0x4c
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43a8:	444f      	add	r7, r9
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43aa:	ea8a 0adb 	eor.w	sl, sl, fp, lsr #3
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43ae:	ea46 0900 	orr.w	r9, r6, r0
    43b2:	ea09 0903 	and.w	r9, r9, r3
    43b6:	ea4f 1cb1 	mov.w	ip, r1, ror #6
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43ba:	44c2      	add	sl, r8
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43bc:	ea4f 0bb6 	mov.w	fp, r6, ror #2
    43c0:	ea06 0800 	and.w	r8, r6, r0
    43c4:	ea8c 2cf1 	eor.w	ip, ip, r1, ror #11
    43c8:	ea8b 3b76 	eor.w	fp, fp, r6, ror #13
    43cc:	ea49 0808 	orr.w	r8, r9, r8
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43d0:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43d4:	ea8b 5bb6 	eor.w	fp, fp, r6, ror #22
    43d8:	ea8c 6c71 	eor.w	ip, ip, r1, ror #25
    43dc:	44bc      	add	ip, r7
    43de:	44d8      	add	r8, fp
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43e0:	ea4f 4779 	mov.w	r7, r9, ror #17
    43e4:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    43e8:	ea87 47f9 	eor.w	r7, r7, r9, ror #19
    43ec:	44da      	add	sl, fp
    43ee:	ea87 2999 	eor.w	r9, r7, r9, lsr #10
    43f2:	44d1      	add	r9, sl
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43f4:	4462      	add	r2, ip
    43f6:	44e0      	add	r8, ip
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43f8:	f8cd 904c 	str.w	r9, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43fc:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4400:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
    4404:	4f21      	ldr	r7, [pc, #132]	; (448c <sha256_process+0x13ac>)
    4406:	ea81 0b04 	eor.w	fp, r1, r4
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    440a:	ea4f 19fc 	mov.w	r9, ip, ror #7
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    440e:	4457      	add	r7, sl
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4410:	ea89 49bc 	eor.w	r9, r9, ip, ror #18
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4414:	ea02 0b0b 	and.w	fp, r2, fp
    4418:	ea8b 0b04 	eor.w	fp, fp, r4
    441c:	443d      	add	r5, r7
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    441e:	ea89 07dc 	eor.w	r7, r9, ip, lsr #3
    4422:	f8dd c050 	ldr.w	ip, [sp, #80]	; 0x50
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4426:	445d      	add	r5, fp
    4428:	ea48 0b06 	orr.w	fp, r8, r6
    442c:	ea0b 0b00 	and.w	fp, fp, r0
    4430:	ea4f 1ab2 	mov.w	sl, r2, ror #6
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4434:	4467      	add	r7, ip
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4436:	ea08 0c06 	and.w	ip, r8, r6
    443a:	ea8a 2af2 	eor.w	sl, sl, r2, ror #11
    443e:	ea4b 0c0c 	orr.w	ip, fp, ip
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4442:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4446:	ea8a 6a72 	eor.w	sl, sl, r2, ror #25
    444a:	44aa      	add	sl, r5
    444c:	ea4f 09b8 	mov.w	r9, r8, ror #2
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4450:	ea4f 457b 	mov.w	r5, fp, ror #17
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4454:	ea89 3978 	eor.w	r9, r9, r8, ror #13
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4458:	ea85 45fb 	eor.w	r5, r5, fp, ror #19
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    445c:	ea89 59b8 	eor.w	r9, r9, r8, ror #22
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4460:	ea85 2b9b 	eor.w	fp, r5, fp, lsr #10
    4464:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4466:	44cc      	add	ip, r9
    4468:	44d4      	add	ip, sl
    446a:	4453      	add	r3, sl
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    446c:	442f      	add	r7, r5
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    446e:	f8dd a058 	ldr.w	sl, [sp, #88]	; 0x58
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4472:	4d07      	ldr	r5, [pc, #28]	; (4490 <sha256_process+0x13b0>)
    4474:	44bb      	add	fp, r7
    4476:	f8cd b050 	str.w	fp, [sp, #80]	; 0x50
    447a:	e011      	b.n	44a0 <sha256_process+0x13c0>
    447c:	2e1b2138 	mrccs	1, 0, r2, cr11, cr8, {1}
    4480:	4d2c6dfc 	stcmi	13, cr6, [ip, #-1008]!	; 0xfffffc10
    4484:	53380d13 	teqpl	r8, #1216	; 0x4c0
    4488:	650a7354 	strvs	r7, [sl, #-852]	; 0x354
    448c:	a2bfe8a1 	adcsge	lr, pc, #10551296	; 0xa10000
    4490:	a81a664b 	ldmdage	sl, {r0, r1, r3, r6, r9, sl, sp, lr}
    4494:	766a0abb 			; <UNDEFINED> instruction: 0x766a0abb
    4498:	81c2c92e 	bichi	ip, r2, lr, lsr #18
    449c:	92722c85 	rsbsls	r2, r2, #34048	; 0x8500
    44a0:	ea82 0701 	eor.w	r7, r2, r1
    44a4:	445d      	add	r5, fp
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44a6:	ea4f 19fa 	mov.w	r9, sl, ror #7
    44aa:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    44ae:	401f      	ands	r7, r3
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44b0:	ea89 49ba 	eor.w	r9, r9, sl, ror #18
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    44b4:	442c      	add	r4, r5
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44b6:	9d15      	ldr	r5, [sp, #84]	; 0x54
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    44b8:	404f      	eors	r7, r1
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44ba:	ea89 09db 	eor.w	r9, r9, fp, lsr #3
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    44be:	ea4c 0b08 	orr.w	fp, ip, r8
    44c2:	ea0b 0b06 	and.w	fp, fp, r6
    44c6:	ea4f 1ab3 	mov.w	sl, r3, ror #6
    44ca:	443c      	add	r4, r7
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44cc:	44a9      	add	r9, r5
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    44ce:	ea4f 07bc 	mov.w	r7, ip, ror #2
    44d2:	ea0c 0508 	and.w	r5, ip, r8
    44d6:	ea8a 2af3 	eor.w	sl, sl, r3, ror #11
    44da:	ea87 377c 	eor.w	r7, r7, ip, ror #13
    44de:	ea4b 0505 	orr.w	r5, fp, r5
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44e2:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    44e6:	ea8a 6a73 	eor.w	sl, sl, r3, ror #25
    44ea:	ea87 57bc 	eor.w	r7, r7, ip, ror #22
    44ee:	4454      	add	r4, sl
    44f0:	443d      	add	r5, r7
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44f2:	ea4f 4a7b 	mov.w	sl, fp, ror #17
    44f6:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    44f8:	ea8a 4afb 	eor.w	sl, sl, fp, ror #19
    44fc:	44b9      	add	r9, r7
    44fe:	ea8a 2a9b 	eor.w	sl, sl, fp, lsr #10
    4502:	44ca      	add	sl, r9
    4504:	f8cd a054 	str.w	sl, [sp, #84]	; 0x54
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4508:	4420      	add	r0, r4
    450a:	4425      	add	r5, r4
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    450c:	f8dd b05c 	ldr.w	fp, [sp, #92]	; 0x5c
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4510:	9c15      	ldr	r4, [sp, #84]	; 0x54
    4512:	4fee      	ldr	r7, [pc, #952]	; (48cc <sha256_process+0x17ec>)
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4514:	ea4f 19fb 	mov.w	r9, fp, ror #7
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4518:	4427      	add	r7, r4
    451a:	ea83 0a02 	eor.w	sl, r3, r2
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    451e:	ea89 49bb 	eor.w	r9, r9, fp, ror #18
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4522:	4439      	add	r1, r7
    4524:	ea4f 1bb0 	mov.w	fp, r0, ror #6
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4528:	9f17      	ldr	r7, [sp, #92]	; 0x5c
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    452a:	ea8b 2bf0 	eor.w	fp, fp, r0, ror #11
    452e:	ea00 0a0a 	and.w	sl, r0, sl
    4532:	ea8a 0a02 	eor.w	sl, sl, r2
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4536:	ea89 09d7 	eor.w	r9, r9, r7, lsr #3
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    453a:	ea8b 6770 	eor.w	r7, fp, r0, ror #25
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    453e:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4542:	4451      	add	r1, sl
    4544:	ea45 0a0c 	orr.w	sl, r5, ip
    4548:	ea0a 0a08 	and.w	sl, sl, r8
    454c:	ea05 040c 	and.w	r4, r5, ip
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4550:	44d9      	add	r9, fp
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4552:	ea4f 0bb5 	mov.w	fp, r5, ror #2
    4556:	ea8b 3b75 	eor.w	fp, fp, r5, ror #13
    455a:	ea4a 0404 	orr.w	r4, sl, r4
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    455e:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4562:	ea8b 5bb5 	eor.w	fp, fp, r5, ror #22
    4566:	4439      	add	r1, r7
    4568:	445c      	add	r4, fp
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    456a:	ea4f 477a 	mov.w	r7, sl, ror #17
    456e:	f8dd b03c 	ldr.w	fp, [sp, #60]	; 0x3c
    4572:	ea87 47fa 	eor.w	r7, r7, sl, ror #19
    4576:	44d9      	add	r9, fp
    4578:	ea87 2a9a 	eor.w	sl, r7, sl, lsr #10
    457c:	4fd4      	ldr	r7, [pc, #848]	; (48d0 <sha256_process+0x17f0>)
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    457e:	440c      	add	r4, r1
    4580:	440e      	add	r6, r1
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4582:	44ca      	add	sl, r9
    4584:	ea80 0103 	eor.w	r1, r0, r3
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4588:	f8dd 9060 	ldr.w	r9, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    458c:	4457      	add	r7, sl
    458e:	4031      	ands	r1, r6
    4590:	f8cd a058 	str.w	sl, [sp, #88]	; 0x58
    4594:	4059      	eors	r1, r3
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4596:	f8dd a060 	ldr.w	sl, [sp, #96]	; 0x60
    459a:	ea4f 1bf9 	mov.w	fp, r9, ror #7
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    459e:	4417      	add	r7, r2
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45a0:	ea8b 4bb9 	eor.w	fp, fp, r9, ror #18
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    45a4:	440f      	add	r7, r1
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45a6:	9917      	ldr	r1, [sp, #92]	; 0x5c
    45a8:	ea8b 0bda 	eor.w	fp, fp, sl, lsr #3
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    45ac:	ea44 0a05 	orr.w	sl, r4, r5
    45b0:	ea0a 0a0c 	and.w	sl, sl, ip
    45b4:	ea04 0205 	and.w	r2, r4, r5
    45b8:	ea4f 19b6 	mov.w	r9, r6, ror #6
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45bc:	448b      	add	fp, r1
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    45be:	ea4f 01b4 	mov.w	r1, r4, ror #2
    45c2:	ea89 29f6 	eor.w	r9, r9, r6, ror #11
    45c6:	ea81 3174 	eor.w	r1, r1, r4, ror #13
    45ca:	ea4a 0202 	orr.w	r2, sl, r2
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45ce:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    45d2:	ea89 6976 	eor.w	r9, r9, r6, ror #25
    45d6:	ea81 51b4 	eor.w	r1, r1, r4, ror #22
    45da:	444f      	add	r7, r9
    45dc:	440a      	add	r2, r1
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45de:	ea4f 497a 	mov.w	r9, sl, ror #17
    45e2:	9910      	ldr	r1, [sp, #64]	; 0x40
    45e4:	ea89 49fa 	eor.w	r9, r9, sl, ror #19
    45e8:	448b      	add	fp, r1
    45ea:	ea89 299a 	eor.w	r9, r9, sl, lsr #10
    45ee:	44d9      	add	r9, fp
    45f0:	f8cd 905c 	str.w	r9, [sp, #92]	; 0x5c
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    45f4:	44b8      	add	r8, r7
    45f6:	443a      	add	r2, r7
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45f8:	49b6      	ldr	r1, [pc, #728]	; (48d4 <sha256_process+0x17f4>)
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    45fa:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45fc:	ea86 0b00 	eor.w	fp, r6, r0
    4600:	4449      	add	r1, r9
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4602:	ea4f 1af7 	mov.w	sl, r7, ror #7
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4606:	ea08 0b0b 	and.w	fp, r8, fp
    460a:	ea8b 0b00 	eor.w	fp, fp, r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    460e:	ea8a 4ab7 	eor.w	sl, sl, r7, ror #18
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4612:	440b      	add	r3, r1
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4614:	9918      	ldr	r1, [sp, #96]	; 0x60
    4616:	ea8a 0ad7 	eor.w	sl, sl, r7, lsr #3
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    461a:	445b      	add	r3, fp
    461c:	ea42 0b04 	orr.w	fp, r2, r4
    4620:	ea0b 0b05 	and.w	fp, fp, r5
    4624:	ea4f 19b8 	mov.w	r9, r8, ror #6
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4628:	448a      	add	sl, r1
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    462a:	ea4f 07b2 	mov.w	r7, r2, ror #2
    462e:	ea02 0104 	and.w	r1, r2, r4
    4632:	ea89 29f8 	eor.w	r9, r9, r8, ror #11
    4636:	ea87 3772 	eor.w	r7, r7, r2, ror #13
    463a:	ea4b 0101 	orr.w	r1, fp, r1
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    463e:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4642:	ea89 6978 	eor.w	r9, r9, r8, ror #25
    4646:	ea87 57b2 	eor.w	r7, r7, r2, ror #22
    464a:	444b      	add	r3, r9
    464c:	4439      	add	r1, r7
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    464e:	ea4f 497b 	mov.w	r9, fp, ror #17
    4652:	9f11      	ldr	r7, [sp, #68]	; 0x44
    4654:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    4658:	44ba      	add	sl, r7
    465a:	ea89 299b 	eor.w	r9, r9, fp, lsr #10
    465e:	44d1      	add	r9, sl
    4660:	f8cd 9060 	str.w	r9, [sp, #96]	; 0x60
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4664:	449c      	add	ip, r3
    4666:	4419      	add	r1, r3
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4668:	4f9b      	ldr	r7, [pc, #620]	; (48d8 <sha256_process+0x17f8>)
    466a:	9b18      	ldr	r3, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    466c:	f8dd b030 	ldr.w	fp, [sp, #48]	; 0x30
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4670:	ea88 0906 	eor.w	r9, r8, r6
    4674:	441f      	add	r7, r3
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4676:	ea4f 1afb 	mov.w	sl, fp, ror #7
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    467a:	ea0c 0909 	and.w	r9, ip, r9
    467e:	4407      	add	r7, r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4680:	980c      	ldr	r0, [sp, #48]	; 0x30
    4682:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4684:	ea89 0906 	eor.w	r9, r9, r6
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4688:	ea8a 4abb 	eor.w	sl, sl, fp, ror #18
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    468c:	ea4f 1bbc 	mov.w	fp, ip, ror #6
    4690:	ea8b 2bfc 	eor.w	fp, fp, ip, ror #11
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4694:	ea8a 0ad0 	eor.w	sl, sl, r0, lsr #3
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4698:	444f      	add	r7, r9
    469a:	ea41 0902 	orr.w	r9, r1, r2
    469e:	ea8b 607c 	eor.w	r0, fp, ip, ror #25
    46a2:	ea09 0904 	and.w	r9, r9, r4
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46a6:	449a      	add	sl, r3
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    46a8:	ea4f 0bb1 	mov.w	fp, r1, ror #2
    46ac:	ea01 0302 	and.w	r3, r1, r2
    46b0:	ea8b 3b71 	eor.w	fp, fp, r1, ror #13
    46b4:	ea49 0303 	orr.w	r3, r9, r3
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46b8:	f8dd 905c 	ldr.w	r9, [sp, #92]	; 0x5c
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    46bc:	ea8b 5bb1 	eor.w	fp, fp, r1, ror #22
    46c0:	4407      	add	r7, r0
    46c2:	445b      	add	r3, fp
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46c4:	ea4f 4079 	mov.w	r0, r9, ror #17
    46c8:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
    46cc:	ea80 40f9 	eor.w	r0, r0, r9, ror #19
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    46d0:	443b      	add	r3, r7
    46d2:	443d      	add	r5, r7
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46d4:	44da      	add	sl, fp
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46d6:	9f09      	ldr	r7, [sp, #36]	; 0x24
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46d8:	ea80 2999 	eor.w	r9, r0, r9, lsr #10
    46dc:	487f      	ldr	r0, [pc, #508]	; (48dc <sha256_process+0x17fc>)
    46de:	44d1      	add	r9, sl
    46e0:	ea8c 0b08 	eor.w	fp, ip, r8
    46e4:	4448      	add	r0, r9
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46e6:	ea4f 1af7 	mov.w	sl, r7, ror #7
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46ea:	ea05 0b0b 	and.w	fp, r5, fp
    46ee:	ea8b 0b08 	eor.w	fp, fp, r8
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46f2:	ea8a 4ab7 	eor.w	sl, sl, r7, ror #18
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46f6:	4406      	add	r6, r0
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46f8:	980c      	ldr	r0, [sp, #48]	; 0x30
    46fa:	ea8a 0ad7 	eor.w	sl, sl, r7, lsr #3
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46fe:	445e      	add	r6, fp
    4700:	ea43 0b01 	orr.w	fp, r3, r1
    4704:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
    4708:	ea0b 0b02 	and.w	fp, fp, r2
    470c:	ea4f 19b5 	mov.w	r9, r5, ror #6
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4710:	4482      	add	sl, r0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4712:	ea4f 07b3 	mov.w	r7, r3, ror #2
    4716:	ea03 0001 	and.w	r0, r3, r1
    471a:	ea89 29f5 	eor.w	r9, r9, r5, ror #11
    471e:	ea87 3773 	eor.w	r7, r7, r3, ror #13
    4722:	ea4b 0000 	orr.w	r0, fp, r0
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4726:	f8dd b060 	ldr.w	fp, [sp, #96]	; 0x60
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    472a:	ea89 6975 	eor.w	r9, r9, r5, ror #25
    472e:	ea87 57b3 	eor.w	r7, r7, r3, ror #22
    4732:	444e      	add	r6, r9
    4734:	4438      	add	r0, r7
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4736:	ea4f 497b 	mov.w	r9, fp, ror #17
    473a:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    473c:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    4740:	44ba      	add	sl, r7
    4742:	ea89 299b 	eor.w	r9, r9, fp, lsr #10
    4746:	44d1      	add	r9, sl
    4748:	f8cd 9030 	str.w	r9, [sp, #48]	; 0x30
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    474c:	4430      	add	r0, r6
    474e:	4434      	add	r4, r6
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4750:	4f63      	ldr	r7, [pc, #396]	; (48e0 <sha256_process+0x1800>)
    4752:	9e0c      	ldr	r6, [sp, #48]	; 0x30
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4754:	f8dd 9028 	ldr.w	r9, [sp, #40]	; 0x28
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4758:	4437      	add	r7, r6
    475a:	ea85 0a0c 	eor.w	sl, r5, ip
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    475e:	ea4f 1bf9 	mov.w	fp, r9, ror #7
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4762:	4447      	add	r7, r8
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4764:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4768:	ea04 0a0a 	and.w	sl, r4, sl
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    476c:	ea8b 4bb9 	eor.w	fp, fp, r9, ror #18
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4770:	ea8a 0a0c 	eor.w	sl, sl, ip
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4774:	ea8b 0bd8 	eor.w	fp, fp, r8, lsr #3
    4778:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    477c:	4457      	add	r7, sl
    477e:	ea40 0a03 	orr.w	sl, r0, r3
    4782:	ea0a 0a01 	and.w	sl, sl, r1
    4786:	ea00 0603 	and.w	r6, r0, r3
    478a:	ea4f 19b4 	mov.w	r9, r4, ror #6
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    478e:	44d8      	add	r8, fp
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4790:	ea4f 0bb0 	mov.w	fp, r0, ror #2
    4794:	ea89 29f4 	eor.w	r9, r9, r4, ror #11
    4798:	ea8b 3b70 	eor.w	fp, fp, r0, ror #13
    479c:	ea4a 0606 	orr.w	r6, sl, r6
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47a0:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    47a4:	ea8b 5bb0 	eor.w	fp, fp, r0, ror #22
    47a8:	ea89 6974 	eor.w	r9, r9, r4, ror #25
    47ac:	44b9      	add	r9, r7
    47ae:	445e      	add	r6, fp
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47b0:	ea4f 477a 	mov.w	r7, sl, ror #17
    47b4:	f8dd b050 	ldr.w	fp, [sp, #80]	; 0x50
    47b8:	ea87 47fa 	eor.w	r7, r7, sl, ror #19
    47bc:	44d8      	add	r8, fp
    47be:	ea87 2a9a 	eor.w	sl, r7, sl, lsr #10
    47c2:	44c2      	add	sl, r8
    47c4:	4f47      	ldr	r7, [pc, #284]	; (48e4 <sha256_process+0x1804>)
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47c6:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    47ca:	444a      	add	r2, r9
    47cc:	444e      	add	r6, r9
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47ce:	ea84 0905 	eor.w	r9, r4, r5
    47d2:	f8cd a068 	str.w	sl, [sp, #104]	; 0x68
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47d6:	ea4f 1bf8 	mov.w	fp, r8, ror #7
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47da:	4457      	add	r7, sl
    47dc:	ea02 0909 	and.w	r9, r2, r9
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47e0:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47e4:	ea89 0905 	eor.w	r9, r9, r5
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47e8:	ea8b 4bb8 	eor.w	fp, fp, r8, ror #18
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47ec:	4467      	add	r7, ip
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47ee:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47f2:	444f      	add	r7, r9
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47f4:	ea8b 0bda 	eor.w	fp, fp, sl, lsr #3
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47f8:	ea46 0900 	orr.w	r9, r6, r0
    47fc:	ea09 0903 	and.w	r9, r9, r3
    4800:	ea4f 18b2 	mov.w	r8, r2, ror #6
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4804:	44e3      	add	fp, ip
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4806:	ea4f 0ab6 	mov.w	sl, r6, ror #2
    480a:	ea06 0c00 	and.w	ip, r6, r0
    480e:	ea88 28f2 	eor.w	r8, r8, r2, ror #11
    4812:	ea8a 3a76 	eor.w	sl, sl, r6, ror #13
    4816:	ea49 0c0c 	orr.w	ip, r9, ip
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    481a:	f8dd 9030 	ldr.w	r9, [sp, #48]	; 0x30
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    481e:	ea8a 5ab6 	eor.w	sl, sl, r6, ror #22
    4822:	ea88 6872 	eor.w	r8, r8, r2, ror #25
    4826:	44b8      	add	r8, r7
    4828:	44d4      	add	ip, sl
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    482a:	ea4f 4779 	mov.w	r7, r9, ror #17
    482e:	f8dd a054 	ldr.w	sl, [sp, #84]	; 0x54
    4832:	ea87 47f9 	eor.w	r7, r7, r9, ror #19
    4836:	ea87 2999 	eor.w	r9, r7, r9, lsr #10
    483a:	44d3      	add	fp, sl
    483c:	4f2a      	ldr	r7, [pc, #168]	; (48e8 <sha256_process+0x1808>)
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    483e:	44c4      	add	ip, r8
    4840:	4441      	add	r1, r8
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4842:	44cb      	add	fp, r9
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4844:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4848:	445f      	add	r7, fp
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    484a:	ea4f 1af8 	mov.w	sl, r8, ror #7
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    484e:	443d      	add	r5, r7
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4850:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4852:	ea82 0904 	eor.w	r9, r2, r4
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4856:	ea8a 4ab8 	eor.w	sl, sl, r8, ror #18
    485a:	ea8a 0ad7 	eor.w	sl, sl, r7, lsr #3
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    485e:	ea01 0909 	and.w	r9, r1, r9
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4862:	9f0d      	ldr	r7, [sp, #52]	; 0x34
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4864:	ea4f 18b1 	mov.w	r8, r1, ror #6
    4868:	ea89 0904 	eor.w	r9, r9, r4
    486c:	ea88 28f1 	eor.w	r8, r8, r1, ror #11
    4870:	444d      	add	r5, r9
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4872:	4457      	add	r7, sl
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4874:	ea4c 0906 	orr.w	r9, ip, r6
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4878:	f8dd a068 	ldr.w	sl, [sp, #104]	; 0x68
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    487c:	ea88 6871 	eor.w	r8, r8, r1, ror #25
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4880:	9709      	str	r7, [sp, #36]	; 0x24
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4882:	44a8      	add	r8, r5
    4884:	ea09 0900 	and.w	r9, r9, r0
    4888:	ea0c 0506 	and.w	r5, ip, r6
    488c:	ea4f 07bc 	mov.w	r7, ip, ror #2
    4890:	ea87 377c 	eor.w	r7, r7, ip, ror #13
    4894:	ea49 0505 	orr.w	r5, r9, r5
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4898:	ea4f 497a 	mov.w	r9, sl, ror #17
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    489c:	ea87 57bc 	eor.w	r7, r7, ip, ror #22
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48a0:	ea89 49fa 	eor.w	r9, r9, sl, ror #19
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    48a4:	443d      	add	r5, r7
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48a6:	ea89 299a 	eor.w	r9, r9, sl, lsr #10
    48aa:	9f16      	ldr	r7, [sp, #88]	; 0x58
    48ac:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    48b0:	4445      	add	r5, r8
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48b2:	44ba      	add	sl, r7
    48b4:	44d1      	add	r9, sl
    48b6:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48ba:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48be:	4f0b      	ldr	r7, [pc, #44]	; (48ec <sha256_process+0x180c>)
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48c0:	ea4f 1af9 	mov.w	sl, r9, ror #7
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48c4:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
    48c8:	e012      	b.n	48f0 <sha256_process+0x1810>
    48ca:	bf00      	nop
    48cc:	c24b8b70 	subgt	r8, fp, #112, 22	; 0x1c000
    48d0:	c76c51a3 	strbgt	r5, [ip, -r3, lsr #3]!
    48d4:	d192e819 	orrsle	lr, r2, r9, lsl r8
    48d8:	d6990624 	ldrle	r0, [r9], r4, lsr #12
    48dc:	f40e3585 	vst3.32	{d3,d5,d7}, [lr], r5
    48e0:	106aa070 	rsbne	sl, sl, r0, ror r0
    48e4:	19a4c116 	stmibne	r4!, {r1, r2, r4, r8, lr, pc}
    48e8:	1e376c08 	cdpne	12, 3, cr6, cr7, cr8, {0}
    48ec:	2748774c 	strbcs	r7, [r8, -ip, asr #14]
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    48f0:	4443      	add	r3, r8
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48f2:	444f      	add	r7, r9
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48f4:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48f8:	443c      	add	r4, r7
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48fa:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48fc:	ea81 0802 	eor.w	r8, r1, r2
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4900:	ea8a 4ab9 	eor.w	sl, sl, r9, ror #18
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4904:	ea03 0808 	and.w	r8, r3, r8
    4908:	ea4f 19b3 	mov.w	r9, r3, ror #6
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    490c:	ea8a 0ad7 	eor.w	sl, sl, r7, lsr #3
    4910:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4912:	ea88 0802 	eor.w	r8, r8, r2
    4916:	ea89 29f3 	eor.w	r9, r9, r3, ror #11
    491a:	ea89 6973 	eor.w	r9, r9, r3, ror #25
    491e:	4444      	add	r4, r8
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4920:	44ba      	add	sl, r7
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4922:	ea45 080c 	orr.w	r8, r5, ip
    4926:	ea4f 07b5 	mov.w	r7, r5, ror #2
    492a:	444c      	add	r4, r9
    492c:	ea08 0806 	and.w	r8, r8, r6
    4930:	ea05 090c 	and.w	r9, r5, ip
    4934:	ea87 3775 	eor.w	r7, r7, r5, ror #13
    4938:	ea87 57b5 	eor.w	r7, r7, r5, ror #22
    493c:	ea48 0809 	orr.w	r8, r8, r9
    4940:	44b8      	add	r8, r7
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4942:	ea4f 497b 	mov.w	r9, fp, ror #17
    4946:	9f17      	ldr	r7, [sp, #92]	; 0x5c
    4948:	ea89 49fb 	eor.w	r9, r9, fp, ror #19
    494c:	44ba      	add	sl, r7
    494e:	ea89 299b 	eor.w	r9, r9, fp, lsr #10
    4952:	44d1      	add	r9, sl
    4954:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4958:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    495c:	4fe8      	ldr	r7, [pc, #928]	; (4d00 <sha256_process+0x1c20>)
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    495e:	ea4f 1af9 	mov.w	sl, r9, ror #7
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4962:	f8dd 9038 	ldr.w	r9, [sp, #56]	; 0x38
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4966:	44a0      	add	r8, r4
    4968:	4420      	add	r0, r4
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    496a:	ea83 0401 	eor.w	r4, r3, r1
    496e:	444f      	add	r7, r9
    4970:	4004      	ands	r4, r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4972:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4976:	404c      	eors	r4, r1
    4978:	4417      	add	r7, r2
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    497a:	9a10      	ldr	r2, [sp, #64]	; 0x40
    497c:	ea8a 4ab9 	eor.w	sl, sl, r9, ror #18
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4980:	4427      	add	r7, r4
    4982:	ea4f 19b0 	mov.w	r9, r0, ror #6
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4986:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    4988:	ea8a 0ad2 	eor.w	sl, sl, r2, lsr #3
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    498c:	ea89 29f0 	eor.w	r9, r9, r0, ror #11
    4990:	ea48 0205 	orr.w	r2, r8, r5
    4994:	ea89 6970 	eor.w	r9, r9, r0, ror #25
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4998:	4454      	add	r4, sl
    499a:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    499e:	9409      	str	r4, [sp, #36]	; 0x24
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    49a0:	444f      	add	r7, r9
    49a2:	ea02 020c 	and.w	r2, r2, ip
    49a6:	ea08 0905 	and.w	r9, r8, r5
    49aa:	ea4f 04b8 	mov.w	r4, r8, ror #2
    49ae:	ea84 3478 	eor.w	r4, r4, r8, ror #13
    49b2:	ea42 0209 	orr.w	r2, r2, r9
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49b6:	ea4f 497a 	mov.w	r9, sl, ror #17
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    49ba:	ea84 54b8 	eor.w	r4, r4, r8, ror #22
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49be:	ea89 49fa 	eor.w	r9, r9, sl, ror #19
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    49c2:	4422      	add	r2, r4
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49c4:	ea89 299a 	eor.w	r9, r9, sl, lsr #10
    49c8:	9c18      	ldr	r4, [sp, #96]	; 0x60
    49ca:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    49ce:	443a      	add	r2, r7
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49d0:	44a2      	add	sl, r4
    49d2:	44d1      	add	r9, sl
    49d4:	f8cd 903c 	str.w	r9, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49d8:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49dc:	4cc9      	ldr	r4, [pc, #804]	; (4d04 <sha256_process+0x1c24>)
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49de:	ea4f 1af9 	mov.w	sl, r9, ror #7
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49e2:	f8dd 903c 	ldr.w	r9, [sp, #60]	; 0x3c
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    49e6:	443e      	add	r6, r7
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49e8:	444c      	add	r4, r9
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49ea:	f8dd 9044 	ldr.w	r9, [sp, #68]	; 0x44
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49ee:	4421      	add	r1, r4
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49f0:	9c11      	ldr	r4, [sp, #68]	; 0x44
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49f2:	ea80 0703 	eor.w	r7, r0, r3
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49f6:	ea8a 4ab9 	eor.w	sl, sl, r9, ror #18
    49fa:	ea8a 0ad4 	eor.w	sl, sl, r4, lsr #3
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49fe:	4037      	ands	r7, r6
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a00:	9c10      	ldr	r4, [sp, #64]	; 0x40
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a02:	ea4f 19b6 	mov.w	r9, r6, ror #6
    4a06:	405f      	eors	r7, r3
    4a08:	ea89 29f6 	eor.w	r9, r9, r6, ror #11
    4a0c:	ea89 6976 	eor.w	r9, r9, r6, ror #25
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a10:	4454      	add	r4, sl
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a12:	440f      	add	r7, r1
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a14:	f8dd a038 	ldr.w	sl, [sp, #56]	; 0x38
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a18:	ea42 0108 	orr.w	r1, r2, r8
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a1c:	9409      	str	r4, [sp, #36]	; 0x24
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a1e:	444f      	add	r7, r9
    4a20:	4029      	ands	r1, r5
    4a22:	ea02 0908 	and.w	r9, r2, r8
    4a26:	ea4f 04b2 	mov.w	r4, r2, ror #2
    4a2a:	ea84 3472 	eor.w	r4, r4, r2, ror #13
    4a2e:	ea41 0109 	orr.w	r1, r1, r9
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a32:	ea4f 497a 	mov.w	r9, sl, ror #17
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a36:	ea84 54b2 	eor.w	r4, r4, r2, ror #22
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a3a:	ea89 49fa 	eor.w	r9, r9, sl, ror #19
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a3e:	4421      	add	r1, r4
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a40:	ea89 299a 	eor.w	r9, r9, sl, lsr #10
    4a44:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    4a46:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a4a:	4439      	add	r1, r7
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a4c:	44a2      	add	sl, r4
    4a4e:	44d1      	add	r9, sl
    4a50:	f8cd 9040 	str.w	r9, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a54:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a58:	4cab      	ldr	r4, [pc, #684]	; (4d08 <sha256_process+0x1c28>)
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a5a:	ea4f 1af9 	mov.w	sl, r9, ror #7
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a5e:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a62:	44bc      	add	ip, r7
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a64:	ea86 0700 	eor.w	r7, r6, r0
    4a68:	444c      	add	r4, r9
    4a6a:	ea0c 0707 	and.w	r7, ip, r7
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a6e:	f8dd 9048 	ldr.w	r9, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a72:	4047      	eors	r7, r0
    4a74:	4423      	add	r3, r4
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a76:	9c12      	ldr	r4, [sp, #72]	; 0x48
    4a78:	ea8a 4ab9 	eor.w	sl, sl, r9, ror #18
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a7c:	443b      	add	r3, r7
    4a7e:	ea4f 19bc 	mov.w	r9, ip, ror #6
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a82:	9f11      	ldr	r7, [sp, #68]	; 0x44
    4a84:	ea8a 0ad4 	eor.w	sl, sl, r4, lsr #3
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a88:	ea89 29fc 	eor.w	r9, r9, ip, ror #11
    4a8c:	ea41 0402 	orr.w	r4, r1, r2
    4a90:	ea89 697c 	eor.w	r9, r9, ip, ror #25
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a94:	4457      	add	r7, sl
    4a96:	f8dd a03c 	ldr.w	sl, [sp, #60]	; 0x3c
    4a9a:	9709      	str	r7, [sp, #36]	; 0x24
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a9c:	444b      	add	r3, r9
    4a9e:	ea04 0408 	and.w	r4, r4, r8
    4aa2:	ea01 0902 	and.w	r9, r1, r2
    4aa6:	ea4f 07b1 	mov.w	r7, r1, ror #2
    4aaa:	ea87 3771 	eor.w	r7, r7, r1, ror #13
    4aae:	ea44 0409 	orr.w	r4, r4, r9
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4ab2:	ea4f 497a 	mov.w	r9, sl, ror #17
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4ab6:	ea87 57b1 	eor.w	r7, r7, r1, ror #22
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4aba:	ea89 49fa 	eor.w	r9, r9, sl, ror #19
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4abe:	443c      	add	r4, r7
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4ac0:	ea89 299a 	eor.w	r9, r9, sl, lsr #10
    4ac4:	9f0c      	ldr	r7, [sp, #48]	; 0x30
    4ac6:	f8dd a024 	ldr.w	sl, [sp, #36]	; 0x24
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4aca:	441c      	add	r4, r3
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4acc:	44ba      	add	sl, r7
    4ace:	44d1      	add	r9, sl
    4ad0:	f8cd 9044 	str.w	r9, [sp, #68]	; 0x44
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4ad4:	441d      	add	r5, r3
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4ad6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4ad8:	4f8c      	ldr	r7, [pc, #560]	; (4d0c <sha256_process+0x1c2c>)
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4ada:	ea4f 19f3 	mov.w	r9, r3, ror #7
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4ade:	9b11      	ldr	r3, [sp, #68]	; 0x44
    4ae0:	ea8c 0a06 	eor.w	sl, ip, r6
    4ae4:	441f      	add	r7, r3
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4ae6:	9b13      	ldr	r3, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4ae8:	4438      	add	r0, r7
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4aea:	ea89 49b3 	eor.w	r9, r9, r3, ror #18
    4aee:	9f13      	ldr	r7, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4af0:	ea4f 13b5 	mov.w	r3, r5, ror #6
    4af4:	ea83 23f5 	eor.w	r3, r3, r5, ror #11
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4af8:	ea89 09d7 	eor.w	r9, r9, r7, lsr #3
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4afc:	ea05 0a0a 	and.w	sl, r5, sl
    4b00:	ea83 6775 	eor.w	r7, r3, r5, ror #25
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b04:	9b12      	ldr	r3, [sp, #72]	; 0x48
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b06:	ea8a 0a06 	eor.w	sl, sl, r6
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b0a:	444b      	add	r3, r9
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b0c:	4450      	add	r0, sl
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b0e:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b12:	ea44 0a01 	orr.w	sl, r4, r1
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b16:	9309      	str	r3, [sp, #36]	; 0x24
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b18:	4438      	add	r0, r7
    4b1a:	ea0a 0a02 	and.w	sl, sl, r2
    4b1e:	ea04 0701 	and.w	r7, r4, r1
    4b22:	ea4f 03b4 	mov.w	r3, r4, ror #2
    4b26:	ea83 3374 	eor.w	r3, r3, r4, ror #13
    4b2a:	ea4a 0a07 	orr.w	sl, sl, r7
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b2e:	ea4f 4779 	mov.w	r7, r9, ror #17
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b32:	ea83 53b4 	eor.w	r3, r3, r4, ror #22
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b36:	ea87 47f9 	eor.w	r7, r7, r9, ror #19
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b3a:	449a      	add	sl, r3
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b3c:	ea87 2799 	eor.w	r7, r7, r9, lsr #10
    4b40:	9b1a      	ldr	r3, [sp, #104]	; 0x68
    4b42:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b46:	4482      	add	sl, r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b48:	4499      	add	r9, r3
    4b4a:	444f      	add	r7, r9
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b4c:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b50:	9712      	str	r7, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b52:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b56:	4480      	add	r8, r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b58:	4b6d      	ldr	r3, [pc, #436]	; (4d10 <sha256_process+0x1c30>)
    4b5a:	9812      	ldr	r0, [sp, #72]	; 0x48
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b5c:	ea4f 17fa 	mov.w	r7, sl, ror #7
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b60:	4403      	add	r3, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b62:	ea87 47ba 	eor.w	r7, r7, sl, ror #18
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b66:	ea85 090c 	eor.w	r9, r5, ip
    4b6a:	441e      	add	r6, r3
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b6c:	ea87 07da 	eor.w	r7, r7, sl, lsr #3
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b70:	9b09      	ldr	r3, [sp, #36]	; 0x24
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b72:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b76:	ea08 0909 	and.w	r9, r8, r9
    4b7a:	ea89 090c 	eor.w	r9, r9, ip
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b7e:	4457      	add	r7, sl
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b80:	ea4f 0ab3 	mov.w	sl, r3, ror #2
    4b84:	444e      	add	r6, r9
    4b86:	ea8a 3a73 	eor.w	sl, sl, r3, ror #13
    4b8a:	ea43 0904 	orr.w	r9, r3, r4
    4b8e:	ea8a 5ab3 	eor.w	sl, sl, r3, ror #22
    4b92:	ea4f 10b8 	mov.w	r0, r8, ror #6
    4b96:	4023      	ands	r3, r4
    4b98:	ea09 0901 	and.w	r9, r9, r1
    4b9c:	ea80 20f8 	eor.w	r0, r0, r8, ror #11
    4ba0:	ea49 0903 	orr.w	r9, r9, r3
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ba4:	9b11      	ldr	r3, [sp, #68]	; 0x44
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4ba6:	ea80 6078 	eor.w	r0, r0, r8, ror #25
    4baa:	4406      	add	r6, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bac:	ea4f 4073 	mov.w	r0, r3, ror #17
    4bb0:	ea80 40f3 	eor.w	r0, r0, r3, ror #19
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4bb4:	44d1      	add	r9, sl
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bb6:	445f      	add	r7, fp
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4bb8:	44b1      	add	r9, r6
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bba:	ea80 2093 	eor.w	r0, r0, r3, lsr #10
    4bbe:	4b55      	ldr	r3, [pc, #340]	; (4d14 <sha256_process+0x1c34>)
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4bc0:	4432      	add	r2, r6
    4bc2:	f8cd 9028 	str.w	r9, [sp, #40]	; 0x28
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bc6:	1838      	adds	r0, r7, r0
    4bc8:	ea88 0605 	eor.w	r6, r8, r5
    4bcc:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    4bd0:	4403      	add	r3, r0
    4bd2:	4016      	ands	r6, r2
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bd4:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bd8:	406e      	eors	r6, r5
    4bda:	449c      	add	ip, r3
    4bdc:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    4be0:	44b4      	add	ip, r6
    4be2:	ea4f 06ba 	mov.w	r6, sl, ror #2
    4be6:	9013      	str	r0, [sp, #76]	; 0x4c
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4be8:	ea4f 17f9 	mov.w	r7, r9, ror #7
    4bec:	9815      	ldr	r0, [sp, #84]	; 0x54
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bee:	ea86 367a 	eor.w	r6, r6, sl, ror #13
    4bf2:	ea4a 030b 	orr.w	r3, sl, fp
    4bf6:	ea86 56ba 	eor.w	r6, r6, sl, ror #22
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bfa:	ea87 47b9 	eor.w	r7, r7, r9, ror #18
    4bfe:	f8dd a050 	ldr.w	sl, [sp, #80]	; 0x50
    4c02:	ea87 07d0 	eor.w	r7, r7, r0, lsr #3
    4c06:	4457      	add	r7, sl
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4c08:	f8dd a028 	ldr.w	sl, [sp, #40]	; 0x28
    4c0c:	ea4f 19b2 	mov.w	r9, r2, ror #6
    4c10:	4023      	ands	r3, r4
    4c12:	ea0a 000b 	and.w	r0, sl, fp
    4c16:	ea89 29f2 	eor.w	r9, r9, r2, ror #11
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c1a:	f8dd b048 	ldr.w	fp, [sp, #72]	; 0x48
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4c1e:	ea89 6972 	eor.w	r9, r9, r2, ror #25
    4c22:	4318      	orrs	r0, r3
    4c24:	44cc      	add	ip, r9
    4c26:	4430      	add	r0, r6
    4c28:	4460      	add	r0, ip
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c2a:	9e0d      	ldr	r6, [sp, #52]	; 0x34
    4c2c:	ea4f 437b 	mov.w	r3, fp, ror #17
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4c30:	900d      	str	r0, [sp, #52]	; 0x34
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c32:	f8dd a058 	ldr.w	sl, [sp, #88]	; 0x58
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c36:	ea83 43fb 	eor.w	r3, r3, fp, ror #19
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4c3a:	4461      	add	r1, ip
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c3c:	ea83 239b 	eor.w	r3, r3, fp, lsr #10
    4c40:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
    4c44:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
    4c48:	4437      	add	r7, r6
    4c4a:	441f      	add	r7, r3
    4c4c:	4e32      	ldr	r6, [pc, #200]	; (4d18 <sha256_process+0x1c38>)
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c4e:	ea4f 13fa 	mov.w	r3, sl, ror #7
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c52:	ea82 0908 	eor.w	r9, r2, r8
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c56:	ea83 43ba 	eor.w	r3, r3, sl, ror #18
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c5a:	ea4b 0a0c 	orr.w	sl, fp, ip
    4c5e:	ea4f 0cbb 	mov.w	ip, fp, ror #2
    4c62:	443e      	add	r6, r7
    4c64:	ea01 0909 	and.w	r9, r1, r9
    4c68:	ea8c 3c7b 	eor.w	ip, ip, fp, ror #13
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c6c:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c70:	ea89 0908 	eor.w	r9, r9, r8
    4c74:	4435      	add	r5, r6
    4c76:	444d      	add	r5, r9
    4c78:	9e09      	ldr	r6, [sp, #36]	; 0x24
    4c7a:	f8dd 9034 	ldr.w	r9, [sp, #52]	; 0x34
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c7e:	ea83 03db 	eor.w	r3, r3, fp, lsr #3
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c82:	f8dd b028 	ldr.w	fp, [sp, #40]	; 0x28
    4c86:	ea0a 0a06 	and.w	sl, sl, r6
    4c8a:	ea09 060b 	and.w	r6, r9, fp
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c8e:	f8dd 904c 	ldr.w	r9, [sp, #76]	; 0x4c
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c92:	f8dd b034 	ldr.w	fp, [sp, #52]	; 0x34
    4c96:	ea4f 10b1 	mov.w	r0, r1, ror #6
    4c9a:	ea8c 5cbb 	eor.w	ip, ip, fp, ror #22
    4c9e:	ea80 20f1 	eor.w	r0, r0, r1, ror #11
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4ca2:	f8dd b04c 	ldr.w	fp, [sp, #76]	; 0x4c
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4ca6:	ea4a 0a06 	orr.w	sl, sl, r6
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4caa:	ea4f 4679 	mov.w	r6, r9, ror #17
    4cae:	f8dd 9054 	ldr.w	r9, [sp, #84]	; 0x54
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4cb2:	ea80 6071 	eor.w	r0, r0, r1, ror #25
    4cb6:	44e2      	add	sl, ip
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cb8:	f8dd c038 	ldr.w	ip, [sp, #56]	; 0x38
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4cbc:	4428      	add	r0, r5
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cbe:	ea86 46fb 	eor.w	r6, r6, fp, ror #19
    4cc2:	444b      	add	r3, r9
    4cc4:	ea86 259b 	eor.w	r5, r6, fp, lsr #10
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4cc8:	4482      	add	sl, r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cca:	4463      	add	r3, ip
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4ccc:	f8cd a038 	str.w	sl, [sp, #56]	; 0x38
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cd0:	442b      	add	r3, r5
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cd2:	9d17      	ldr	r5, [sp, #92]	; 0x5c
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4cd4:	4404      	add	r4, r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cd6:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cda:	ea4f 10f5 	mov.w	r0, r5, ror #7
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cde:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    4ce0:	4e0e      	ldr	r6, [pc, #56]	; (4d1c <sha256_process+0x1c3c>)
    4ce2:	ea4b 0c05 	orr.w	ip, fp, r5
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4ce6:	f8dd b05c 	ldr.w	fp, [sp, #92]	; 0x5c
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cea:	441e      	add	r6, r3
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cec:	ea80 40bb 	eor.w	r0, r0, fp, ror #18
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cf0:	f8dd b038 	ldr.w	fp, [sp, #56]	; 0x38
    4cf4:	4446      	add	r6, r8
    4cf6:	ea4f 05bb 	mov.w	r5, fp, ror #2
    4cfa:	ea85 357b 	eor.w	r5, r5, fp, ror #13
    4cfe:	e00f      	b.n	4d20 <sha256_process+0x1c40>
    4d00:	34b0bcb5 	ldrtcc	fp, [r0], #3253	; 0xcb5
    4d04:	391c0cb3 	ldmdbcc	ip, {r0, r1, r4, r5, r7, sl, fp}
    4d08:	4ed8aa4a 	vfnmami.f32	s21, s16, s20
    4d0c:	5b9cca4f 	blpl	fe737650 <BootRAM+0xd6a7df1>
    4d10:	682e6ff3 	stmdavs	lr!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
    4d14:	748f82ee 	strvc	r8, [pc], #750	; 4d1c <sha256_process+0x1c3c>
    4d18:	78a5636f 	stmiavc	r5!, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}
    4d1c:	84c87814 	strbhi	r7, [r8], #2068	; 0x814
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d20:	f8dd b05c 	ldr.w	fp, [sp, #92]	; 0x5c
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d24:	f8dd 8028 	ldr.w	r8, [sp, #40]	; 0x28
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d28:	ea80 00db 	eor.w	r0, r0, fp, lsr #3
    4d2c:	9014      	str	r0, [sp, #80]	; 0x50
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d2e:	ea0c 0c08 	and.w	ip, ip, r8
    4d32:	980e      	ldr	r0, [sp, #56]	; 0x38
    4d34:	f8dd 8034 	ldr.w	r8, [sp, #52]	; 0x34
    4d38:	ea81 0a02 	eor.w	sl, r1, r2
    4d3c:	ea00 0b08 	and.w	fp, r0, r8
    4d40:	ea4c 0c0b 	orr.w	ip, ip, fp
    4d44:	ea85 55b0 	eor.w	r5, r5, r0, ror #22
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d48:	f8dd b058 	ldr.w	fp, [sp, #88]	; 0x58
    4d4c:	9814      	ldr	r0, [sp, #80]	; 0x50
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d4e:	ea04 0a0a 	and.w	sl, r4, sl
    4d52:	ea4f 19b4 	mov.w	r9, r4, ror #6
    4d56:	ea8a 0a02 	eor.w	sl, sl, r2
    4d5a:	ea89 29f4 	eor.w	r9, r9, r4, ror #11
    4d5e:	44b2      	add	sl, r6
    4d60:	ea89 6974 	eor.w	r9, r9, r4, ror #25
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d64:	ea4f 4677 	mov.w	r6, r7, ror #17
    4d68:	4458      	add	r0, fp
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d6a:	eb0c 0b05 	add.w	fp, ip, r5
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d6e:	f8dd c03c 	ldr.w	ip, [sp, #60]	; 0x3c
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d72:	eb0a 0809 	add.w	r8, sl, r9
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d76:	ea86 46f7 	eor.w	r6, r6, r7, ror #19
    4d7a:	ea86 2697 	eor.w	r6, r6, r7, lsr #10
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d7e:	44c3      	add	fp, r8
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d80:	9f18      	ldr	r7, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d82:	4460      	add	r0, ip
    4d84:	4daa      	ldr	r5, [pc, #680]	; (5030 <sha256_process+0x1f50>)
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d86:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d8a:	4430      	add	r0, r6
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d8c:	f8cd b024 	str.w	fp, [sp, #36]	; 0x24
    4d90:	44c4      	add	ip, r8
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d92:	ea4f 16f7 	mov.w	r6, r7, ror #7
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d96:	f8dd 8024 	ldr.w	r8, [sp, #36]	; 0x24
    4d9a:	9f0e      	ldr	r7, [sp, #56]	; 0x38
    4d9c:	4405      	add	r5, r0
    4d9e:	1955      	adds	r5, r2, r5
    4da0:	950f      	str	r5, [sp, #60]	; 0x3c
    4da2:	9a09      	ldr	r2, [sp, #36]	; 0x24
    4da4:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    4da6:	ea48 0907 	orr.w	r9, r8, r7
    4daa:	ea4f 07b8 	mov.w	r7, r8, ror #2
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dae:	f8dd 8060 	ldr.w	r8, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4db2:	ea84 0b01 	eor.w	fp, r4, r1
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4db6:	ea86 46b8 	eor.w	r6, r6, r8, ror #18
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4dba:	ea02 0805 	and.w	r8, r2, r5
    4dbe:	9a0d      	ldr	r2, [sp, #52]	; 0x34
    4dc0:	9d09      	ldr	r5, [sp, #36]	; 0x24
    4dc2:	ea09 0902 	and.w	r9, r9, r2
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dc6:	9a18      	ldr	r2, [sp, #96]	; 0x60
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4dc8:	ea0c 0b0b 	and.w	fp, ip, fp
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dcc:	ea86 06d2 	eor.w	r6, r6, r2, lsr #3
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4dd0:	ea49 0808 	orr.w	r8, r9, r8
    4dd4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
    4dd6:	f8dd 9024 	ldr.w	r9, [sp, #36]	; 0x24
    4dda:	ea4f 1abc 	mov.w	sl, ip, ror #6
    4dde:	ea8b 0b01 	eor.w	fp, fp, r1
    4de2:	ea87 3775 	eor.w	r7, r7, r5, ror #13
    4de6:	4493      	add	fp, r2
    4de8:	ea87 57b9 	eor.w	r7, r7, r9, ror #22
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dec:	9a17      	ldr	r2, [sp, #92]	; 0x5c
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4dee:	ea8a 2afc 	eor.w	sl, sl, ip, ror #11
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4df2:	ea4f 4573 	mov.w	r5, r3, ror #17
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4df6:	ea8a 6a7c 	eor.w	sl, sl, ip, ror #25
    4dfa:	44b8      	add	r8, r7
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dfc:	9f10      	ldr	r7, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4dfe:	44da      	add	sl, fp
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e00:	4416      	add	r6, r2
    4e02:	ea85 45f3 	eor.w	r5, r5, r3, ror #19
    4e06:	443e      	add	r6, r7
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4e08:	44d0      	add	r8, sl
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e0a:	ea85 2593 	eor.w	r5, r5, r3, lsr #10
    4e0e:	4f89      	ldr	r7, [pc, #548]	; (5034 <sha256_process+0x1f54>)
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4e10:	f8cd 8040 	str.w	r8, [sp, #64]	; 0x40
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e14:	1975      	adds	r5, r6, r5
    4e16:	9b10      	ldr	r3, [sp, #64]	; 0x40
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e18:	f8dd 902c 	ldr.w	r9, [sp, #44]	; 0x2c
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e1c:	950f      	str	r5, [sp, #60]	; 0x3c
    4e1e:	442f      	add	r7, r5
    4e20:	9d09      	ldr	r5, [sp, #36]	; 0x24
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e22:	ea4f 18f9 	mov.w	r8, r9, ror #7
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e26:	ea4f 06b3 	mov.w	r6, r3, ror #2
    4e2a:	ea43 0905 	orr.w	r9, r3, r5
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e2e:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4e30:	9a0a      	ldr	r2, [sp, #40]	; 0x28
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e32:	ea88 48b3 	eor.w	r8, r8, r3, ror #18
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e36:	9b10      	ldr	r3, [sp, #64]	; 0x40
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4e38:	4452      	add	r2, sl
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e3a:	ea8c 0b04 	eor.w	fp, ip, r4
    4e3e:	ea02 0b0b 	and.w	fp, r2, fp
    4e42:	4439      	add	r1, r7
    4e44:	ea03 0705 	and.w	r7, r3, r5
    4e48:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    4e4a:	ea8b 0b04 	eor.w	fp, fp, r4
    4e4e:	ea86 3673 	eor.w	r6, r6, r3, ror #13
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e52:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e54:	ea09 0905 	and.w	r9, r9, r5
    4e58:	4459      	add	r1, fp
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e5a:	f8dd b060 	ldr.w	fp, [sp, #96]	; 0x60
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e5e:	ea4f 1ab2 	mov.w	sl, r2, ror #6
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e62:	ea88 08d3 	eor.w	r8, r8, r3, lsr #3
    4e66:	ea4f 4570 	mov.w	r5, r0, ror #17
    4e6a:	9b11      	ldr	r3, [sp, #68]	; 0x44
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e6c:	ea49 0707 	orr.w	r7, r9, r7
    4e70:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
    4e74:	ea8a 2af2 	eor.w	sl, sl, r2, ror #11
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e78:	44d8      	add	r8, fp
    4e7a:	ea85 45f0 	eor.w	r5, r5, r0, ror #19
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e7e:	ea8a 6a72 	eor.w	sl, sl, r2, ror #25
    4e82:	ea86 56b9 	eor.w	r6, r6, r9, ror #22
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e86:	4498      	add	r8, r3
    4e88:	ea85 2590 	eor.w	r5, r5, r0, lsr #10
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e8c:	980d      	ldr	r0, [sp, #52]	; 0x34
    4e8e:	4451      	add	r1, sl
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e90:	4445      	add	r5, r8
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e92:	4437      	add	r7, r6
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e94:	950d      	str	r5, [sp, #52]	; 0x34
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e96:	187b      	adds	r3, r7, r1
    4e98:	4408      	add	r0, r1
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e9a:	990c      	ldr	r1, [sp, #48]	; 0x30
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e9c:	4e66      	ldr	r6, [pc, #408]	; (5038 <sha256_process+0x1f58>)
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4e9e:	ea4f 18f1 	mov.w	r8, r1, ror #7
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ea2:	9910      	ldr	r1, [sp, #64]	; 0x40
    4ea4:	442e      	add	r6, r5
    4ea6:	ea4f 17b0 	mov.w	r7, r0, ror #6
    4eaa:	4434      	add	r4, r6
    4eac:	ea87 26f0 	eor.w	r6, r7, r0, ror #11
    4eb0:	ea03 0701 	and.w	r7, r3, r1
    4eb4:	9909      	ldr	r1, [sp, #36]	; 0x24
    4eb6:	ea43 0a09 	orr.w	sl, r3, r9
    4eba:	ea0a 0a01 	and.w	sl, sl, r1
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ebe:	990c      	ldr	r1, [sp, #48]	; 0x30
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ec0:	ea82 0b0c 	eor.w	fp, r2, ip
    4ec4:	ea4a 0a07 	orr.w	sl, sl, r7
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ec8:	4d5c      	ldr	r5, [pc, #368]	; (503c <sha256_process+0x1f5c>)
    4eca:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ecc:	ea00 0b0b 	and.w	fp, r0, fp
    4ed0:	ea4f 09b3 	mov.w	r9, r3, ror #2
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ed4:	ea88 48b1 	eor.w	r8, r8, r1, ror #18
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ed8:	ea8b 0b0c 	eor.w	fp, fp, ip
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4edc:	443d      	add	r5, r7
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ede:	ea89 3973 	eor.w	r9, r9, r3, ror #13
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ee2:	ea88 08d1 	eor.w	r8, r8, r1, lsr #3
    4ee6:	990f      	ldr	r1, [sp, #60]	; 0x3c
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ee8:	ea86 6670 	eor.w	r6, r6, r0, ror #25
    4eec:	ea89 59b3 	eor.w	r9, r9, r3, ror #22
    4ef0:	445c      	add	r4, fp
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ef2:	44a8      	add	r8, r5
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ef4:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    4ef6:	4434      	add	r4, r6
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ef8:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4efa:	44ca      	add	sl, r9
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4efc:	ea4f 4b71 	mov.w	fp, r1, ror #17
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4f00:	4425      	add	r5, r4
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f02:	ea8b 4bf1 	eor.w	fp, fp, r1, ror #19
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4f06:	eb0a 0104 	add.w	r1, sl, r4
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f0a:	9c12      	ldr	r4, [sp, #72]	; 0x48
    4f0c:	ea8b 2697 	eor.w	r6, fp, r7, lsr #10
    4f10:	f8dd b040 	ldr.w	fp, [sp, #64]	; 0x40
    4f14:	44a0      	add	r8, r4
    4f16:	ea41 0403 	orr.w	r4, r1, r3
    4f1a:	ea04 040b 	and.w	r4, r4, fp
    4f1e:	940b      	str	r4, [sp, #44]	; 0x2c
    4f20:	ea80 0902 	eor.w	r9, r0, r2
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f24:	9c1a      	ldr	r4, [sp, #104]	; 0x68
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f26:	4446      	add	r6, r8
    4f28:	ea05 0909 	and.w	r9, r5, r9
    4f2c:	4466      	add	r6, ip
    4f2e:	ea4f 0ab1 	mov.w	sl, r1, ror #2
    4f32:	ea4f 18b5 	mov.w	r8, r5, ror #6
    4f36:	ea89 0902 	eor.w	r9, r9, r2
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f3a:	ea4f 1cf4 	mov.w	ip, r4, ror #7
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f3e:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    4f40:	ea01 0b03 	and.w	fp, r1, r3
    4f44:	44b1      	add	r9, r6
    4f46:	ea8a 3a71 	eor.w	sl, sl, r1, ror #13
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f4a:	9e1a      	ldr	r6, [sp, #104]	; 0x68
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f4c:	ea88 28f5 	eor.w	r8, r8, r5, ror #11
    4f50:	ea8a 5ab1 	eor.w	sl, sl, r1, ror #22
    4f54:	ea88 6875 	eor.w	r8, r8, r5, ror #25
    4f58:	ea44 0b0b 	orr.w	fp, r4, fp
    4f5c:	eb0b 040a 	add.w	r4, fp, sl
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f60:	ea8c 4cb6 	eor.w	ip, ip, r6, ror #18
    4f64:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f68:	eb09 0608 	add.w	r6, r9, r8
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f6c:	4f34      	ldr	r7, [pc, #208]	; (5040 <sha256_process+0x1f60>)
    4f6e:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
    4f72:	f8dd 9068 	ldr.w	r9, [sp, #104]	; 0x68
    4f76:	4447      	add	r7, r8
    4f78:	ea4f 487a 	mov.w	r8, sl, ror #17
    4f7c:	ea8c 0cd9 	eor.w	ip, ip, r9, lsr #3
    4f80:	ea88 48fa 	eor.w	r8, r8, sl, ror #19
    4f84:	f8dd a04c 	ldr.w	sl, [sp, #76]	; 0x4c
    4f88:	4467      	add	r7, ip
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f8a:	f8dd b024 	ldr.w	fp, [sp, #36]	; 0x24
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f8e:	4457      	add	r7, sl
    4f90:	f8dd a034 	ldr.w	sl, [sp, #52]	; 0x34
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f94:	4434      	add	r4, r6
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f96:	ea85 0c00 	eor.w	ip, r5, r0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f9a:	445e      	add	r6, fp
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f9c:	ea88 289a 	eor.w	r8, r8, sl, lsr #10
    4fa0:	ea06 0c0c 	and.w	ip, r6, ip
    4fa4:	4447      	add	r7, r8
    4fa6:	ea8c 0c00 	eor.w	ip, ip, r0
    4faa:	4417      	add	r7, r2
    4fac:	ea44 0b01 	orr.w	fp, r4, r1
    4fb0:	9a04      	ldr	r2, [sp, #16]
    4fb2:	ea4f 09b4 	mov.w	r9, r4, ror #2
    4fb6:	4467      	add	r7, ip
    4fb8:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
    4fbc:	ea0b 0b03 	and.w	fp, fp, r3
    4fc0:	ea04 0a01 	and.w	sl, r4, r1
    4fc4:	ea89 3974 	eor.w	r9, r9, r4, ror #13
    4fc8:	ea89 59b4 	eor.w	r9, r9, r4, ror #22
    4fcc:	4494      	add	ip, r2
    4fce:	ea4b 0a0a 	orr.w	sl, fp, sl
    4fd2:	9a08      	ldr	r2, [sp, #32]
    4fd4:	44ca      	add	sl, r9
    4fd6:	4492      	add	sl, r2
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    ctx->state[7] += H;
    4fd8:	9a01      	ldr	r2, [sp, #4]
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4fda:	ea4f 18b6 	mov.w	r8, r6, ror #6
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    ctx->state[7] += H;
    4fde:	4410      	add	r0, r2
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    4fe0:	9a05      	ldr	r2, [sp, #20]
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4fe2:	ea88 28f6 	eor.w	r8, r8, r6, ror #11

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    4fe6:	4413      	add	r3, r2
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    4fe8:	9a02      	ldr	r2, [sp, #8]
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4fea:	ea88 6876 	eor.w	r8, r8, r6, ror #25
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    4fee:	4415      	add	r5, r2
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    4ff0:	9a06      	ldr	r2, [sp, #24]
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4ff2:	4447      	add	r7, r8

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    4ff4:	4411      	add	r1, r2
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    4ff6:	9a07      	ldr	r2, [sp, #28]
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    4ff8:	f8dd 8064 	ldr.w	r8, [sp, #100]	; 0x64
    ctx->state[1] += B;
    4ffc:	4414      	add	r4, r2
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    4ffe:	9a03      	ldr	r2, [sp, #12]
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    5000:	44ba      	add	sl, r7
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    5002:	4416      	add	r6, r2

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    5004:	4467      	add	r7, ip
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    5006:	f8c8 a008 	str.w	sl, [r8, #8]
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    500a:	f8c8 3014 	str.w	r3, [r8, #20]
    ctx->state[4] += E;
    500e:	f8c8 7018 	str.w	r7, [r8, #24]
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    5012:	f8c8 400c 	str.w	r4, [r8, #12]
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    5016:	f8c8 601c 	str.w	r6, [r8, #28]
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    501a:	f8c8 1010 	str.w	r1, [r8, #16]
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    501e:	f8c8 5020 	str.w	r5, [r8, #32]
    ctx->state[7] += H;
    5022:	f8c8 0024 	str.w	r0, [r8, #36]	; 0x24
}
    5026:	b01c      	add	sp, #112	; 0x70
    5028:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    502c:	4770      	bx	lr
    502e:	bf00      	nop
    5030:	8cc70208 	sfmhi	f0, 2, [r7], {8}
    5034:	90befffa 	ldrshtls	pc, [lr], sl	; <UNPREDICTABLE>
    5038:	a4506ceb 	ldrbge	r6, [r0], #-3307	; 0xceb
    503c:	bef9a3f7 	mrclt	3, 7, sl, cr9, cr7, {7}
    5040:	c67178f2 			; <UNDEFINED> instruction: 0xc67178f2

00005044 <sha256_update>:

void sha256_update( sha256_context *ctx, uint8 *input, uint32 length )
{
    5044:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    uint32 left, fill;

    if( ! length ) return;
    5048:	4617      	mov	r7, r2
    ctx->state[6] += G;
    ctx->state[7] += H;
}

void sha256_update( sha256_context *ctx, uint8 *input, uint32 length )
{
    504a:	4606      	mov	r6, r0
    504c:	4688      	mov	r8, r1
    uint32 left, fill;

    if( ! length ) return;
    504e:	b302      	cbz	r2, 5092 <sha256_update+0x4e>

    left = ctx->total[0] & 0x3F;
    5050:	6803      	ldr	r3, [r0, #0]
    fill = 64 - left;

    ctx->total[0] += length;
    5052:	441a      	add	r2, r3
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    5054:	4297      	cmp	r7, r2
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    5056:	6002      	str	r2, [r0, #0]
{
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    5058:	f003 033f 	and.w	r3, r3, #63	; 0x3f
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    505c:	d902      	bls.n	5064 <sha256_update+0x20>
        ctx->total[1]++;
    505e:	6842      	ldr	r2, [r0, #4]
    5060:	3201      	adds	r2, #1
    5062:	6042      	str	r2, [r0, #4]

    if( left && length >= fill )
    5064:	b9bb      	cbnz	r3, 5096 <sha256_update+0x52>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5066:	2f3f      	cmp	r7, #63	; 0x3f
    5068:	d912      	bls.n	5090 <sha256_update+0x4c>
    506a:	463d      	mov	r5, r7
    506c:	4644      	mov	r4, r8
    {
        sha256_process( ctx, input );
    506e:	4621      	mov	r1, r4
        length -= 64;
    5070:	3d40      	subs	r5, #64	; 0x40
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    5072:	4630      	mov	r0, r6
    5074:	f7fe f834 	bl	30e0 <sha256_process>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5078:	2d3f      	cmp	r5, #63	; 0x3f
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    507a:	f104 0440 	add.w	r4, r4, #64	; 0x40
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    507e:	d8f6      	bhi.n	506e <sha256_update+0x2a>
    5080:	f1a7 0340 	sub.w	r3, r7, #64	; 0x40
    5084:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
    5088:	3340      	adds	r3, #64	; 0x40
    508a:	4498      	add	r8, r3
    508c:	f007 073f 	and.w	r7, r7, #63	; 0x3f
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    5090:	b9ef      	cbnz	r7, 50ce <sha256_update+0x8a>
    5092:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    5096:	f1c3 0440 	rsb	r4, r3, #64	; 0x40
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    509a:	42a7      	cmp	r7, r4
    509c:	d208      	bcs.n	50b0 <sha256_update+0x6c>
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    509e:	f103 0028 	add.w	r0, r3, #40	; 0x28
    50a2:	4430      	add	r0, r6
    50a4:	4641      	mov	r1, r8
    50a6:	463a      	mov	r2, r7
                (void *) input, length );
    }
}
    50a8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    50ac:	f001 bb58 	b.w	6760 <memcpy>
    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
    50b0:	f103 0028 	add.w	r0, r3, #40	; 0x28
    50b4:	4641      	mov	r1, r8
    50b6:	4622      	mov	r2, r4
    50b8:	4430      	add	r0, r6
    50ba:	f001 fb51 	bl	6760 <memcpy>
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    50be:	4630      	mov	r0, r6
    50c0:	f106 0128 	add.w	r1, r6, #40	; 0x28
    50c4:	f7fe f80c 	bl	30e0 <sha256_process>
        length -= fill;
    50c8:	1b3f      	subs	r7, r7, r4
        input  += fill;
    50ca:	44a0      	add	r8, r4
    50cc:	e7cb      	b.n	5066 <sha256_update+0x22>
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    50ce:	2300      	movs	r3, #0
    50d0:	e7e5      	b.n	509e <sha256_update+0x5a>
    50d2:	bf00      	nop

000050d4 <sha256_finish>:
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    50d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    uint32 last, padn;
    uint32 high, low;
    uint8 msglen[8];

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    50d8:	e890 0088 	ldmia.w	r0, {r3, r7}
    low  = ( ctx->total[0] <<  3 );
    50dc:	00da      	lsls	r2, r3, #3

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );

    last = ctx->total[0] & 0x3F;
    50de:	f003 063f 	and.w	r6, r3, #63	; 0x3f
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    50e2:	b083      	sub	sp, #12
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    50e4:	ea4f 6812 	mov.w	r8, r2, lsr #24

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    50e8:	2e37      	cmp	r6, #55	; 0x37
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    50ea:	f88d 8004 	strb.w	r8, [sp, #4]

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    50ee:	bf94      	ite	ls
    50f0:	f1c6 0838 	rsbls	r8, r6, #56	; 0x38
    50f4:	f1c6 0878 	rsbhi	r8, r6, #120	; 0x78
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    50f8:	4604      	mov	r4, r0
    uint32 last, padn;
    uint32 high, low;
    uint8 msglen[8];

    high = ( ctx->total[0] >> 29 )
    50fa:	0f58      	lsrs	r0, r3, #29
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    50fc:	4443      	add	r3, r8
{
    uint32 last, padn;
    uint32 high, low;
    uint8 msglen[8];

    high = ( ctx->total[0] >> 29 )
    50fe:	ea40 00c7 	orr.w	r0, r0, r7, lsl #3
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    5102:	4598      	cmp	r8, r3

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    5104:	ea4f 6b10 	mov.w	fp, r0, lsr #24
    5108:	ea4f 4a10 	mov.w	sl, r0, lsr #16
    510c:	ea4f 2910 	mov.w	r9, r0, lsr #8
    PUT_UINT32( low,  msglen, 4 );
    5110:	ea4f 4c12 	mov.w	ip, r2, lsr #16
    5114:	ea4f 2e12 	mov.w	lr, r2, lsr #8

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;
    5118:	bf88      	it	hi
    511a:	3701      	addhi	r7, #1
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    511c:	460d      	mov	r5, r1

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    511e:	f88d 0003 	strb.w	r0, [sp, #3]
    5122:	f88d b000 	strb.w	fp, [sp]
    5126:	f88d a001 	strb.w	sl, [sp, #1]
    512a:	f88d 9002 	strb.w	r9, [sp, #2]
    PUT_UINT32( low,  msglen, 4 );
    512e:	f88d 2007 	strb.w	r2, [sp, #7]
    5132:	f88d c005 	strb.w	ip, [sp, #5]
    5136:	f88d e006 	strb.w	lr, [sp, #6]
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    513a:	6023      	str	r3, [r4, #0]
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;
    513c:	bf88      	it	hi
    513e:	6067      	strhi	r7, [r4, #4]

    if( left && length >= fill )
    5140:	2e00      	cmp	r6, #0
    5142:	f000 80a1 	beq.w	5288 <sha256_finish+0x1b4>
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    5146:	f1c6 0740 	rsb	r7, r6, #64	; 0x40
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    514a:	45b8      	cmp	r8, r7
    514c:	d273      	bcs.n	5236 <sha256_finish+0x162>
    514e:	f8df 9198 	ldr.w	r9, [pc, #408]	; 52e8 <sha256_finish+0x214>
    5152:	4642      	mov	r2, r8
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    5154:	b12a      	cbz	r2, 5162 <sha256_finish+0x8e>
    {
        memcpy( (void *) (ctx->buffer + left),
    5156:	f106 0028 	add.w	r0, r6, #40	; 0x28
    515a:	4420      	add	r0, r4
    515c:	4649      	mov	r1, r9
    515e:	f001 faff 	bl	6760 <memcpy>
{
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    5162:	6822      	ldr	r2, [r4, #0]
    fill = 64 - left;

    ctx->total[0] += length;
    5164:	f102 0308 	add.w	r3, r2, #8
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    5168:	2b07      	cmp	r3, #7
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    516a:	6023      	str	r3, [r4, #0]
{
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    516c:	f002 083f 	and.w	r8, r2, #63	; 0x3f
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    5170:	d802      	bhi.n	5178 <sha256_finish+0xa4>
        ctx->total[1]++;
    5172:	6863      	ldr	r3, [r4, #4]
    5174:	3301      	adds	r3, #1
    5176:	6063      	str	r3, [r4, #4]

    if( left && length >= fill )
    5178:	f1b8 0f00 	cmp.w	r8, #0
    517c:	d005      	beq.n	518a <sha256_finish+0xb6>
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    517e:	f1c8 0940 	rsb	r9, r8, #64	; 0x40
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    5182:	f1b9 0f08 	cmp.w	r9, #8
    5186:	f240 8082 	bls.w	528e <sha256_finish+0x1ba>
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    518a:	2608      	movs	r6, #8
    518c:	46e9      	mov	r9, sp
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    518e:	f108 0028 	add.w	r0, r8, #40	; 0x28
    5192:	4420      	add	r0, r4
    5194:	4649      	mov	r1, r9
    5196:	4632      	mov	r2, r6
    5198:	f001 fae2 	bl	6760 <memcpy>
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    sha256_update( ctx, sha256_padding, padn );
    sha256_update( ctx, msglen, 8 );

    PUT_UINT32( ctx->state[0], digest,  0 );
    519c:	7ae3      	ldrb	r3, [r4, #11]
    519e:	702b      	strb	r3, [r5, #0]
    51a0:	8963      	ldrh	r3, [r4, #10]
    51a2:	706b      	strb	r3, [r5, #1]
    51a4:	68a3      	ldr	r3, [r4, #8]
    51a6:	0a1b      	lsrs	r3, r3, #8
    51a8:	70ab      	strb	r3, [r5, #2]
    51aa:	68a3      	ldr	r3, [r4, #8]
    51ac:	70eb      	strb	r3, [r5, #3]
    PUT_UINT32( ctx->state[1], digest,  4 );
    51ae:	7be3      	ldrb	r3, [r4, #15]
    51b0:	712b      	strb	r3, [r5, #4]
    51b2:	89e3      	ldrh	r3, [r4, #14]
    51b4:	716b      	strb	r3, [r5, #5]
    51b6:	68e3      	ldr	r3, [r4, #12]
    51b8:	0a1b      	lsrs	r3, r3, #8
    51ba:	71ab      	strb	r3, [r5, #6]
    51bc:	68e3      	ldr	r3, [r4, #12]
    51be:	71eb      	strb	r3, [r5, #7]
    PUT_UINT32( ctx->state[2], digest,  8 );
    51c0:	7ce3      	ldrb	r3, [r4, #19]
    51c2:	722b      	strb	r3, [r5, #8]
    51c4:	8a63      	ldrh	r3, [r4, #18]
    51c6:	726b      	strb	r3, [r5, #9]
    51c8:	6923      	ldr	r3, [r4, #16]
    51ca:	0a1b      	lsrs	r3, r3, #8
    51cc:	72ab      	strb	r3, [r5, #10]
    51ce:	6923      	ldr	r3, [r4, #16]
    51d0:	72eb      	strb	r3, [r5, #11]
    PUT_UINT32( ctx->state[3], digest, 12 );
    51d2:	7de3      	ldrb	r3, [r4, #23]
    51d4:	732b      	strb	r3, [r5, #12]
    51d6:	8ae3      	ldrh	r3, [r4, #22]
    51d8:	736b      	strb	r3, [r5, #13]
    51da:	6963      	ldr	r3, [r4, #20]
    51dc:	0a1b      	lsrs	r3, r3, #8
    51de:	73ab      	strb	r3, [r5, #14]
    51e0:	6963      	ldr	r3, [r4, #20]
    51e2:	73eb      	strb	r3, [r5, #15]
    PUT_UINT32( ctx->state[4], digest, 16 );
    51e4:	7ee3      	ldrb	r3, [r4, #27]
    51e6:	742b      	strb	r3, [r5, #16]
    51e8:	8b63      	ldrh	r3, [r4, #26]
    51ea:	746b      	strb	r3, [r5, #17]
    51ec:	69a3      	ldr	r3, [r4, #24]
    51ee:	0a1b      	lsrs	r3, r3, #8
    51f0:	74ab      	strb	r3, [r5, #18]
    51f2:	69a3      	ldr	r3, [r4, #24]
    51f4:	74eb      	strb	r3, [r5, #19]
    PUT_UINT32( ctx->state[5], digest, 20 );
    51f6:	7fe3      	ldrb	r3, [r4, #31]
    51f8:	752b      	strb	r3, [r5, #20]
    51fa:	8be3      	ldrh	r3, [r4, #30]
    51fc:	756b      	strb	r3, [r5, #21]
    51fe:	69e3      	ldr	r3, [r4, #28]
    5200:	0a1b      	lsrs	r3, r3, #8
    5202:	75ab      	strb	r3, [r5, #22]
    5204:	69e3      	ldr	r3, [r4, #28]
    5206:	75eb      	strb	r3, [r5, #23]
    PUT_UINT32( ctx->state[6], digest, 24 );
    5208:	f894 3023 	ldrb.w	r3, [r4, #35]	; 0x23
    520c:	762b      	strb	r3, [r5, #24]
    520e:	8c63      	ldrh	r3, [r4, #34]	; 0x22
    5210:	766b      	strb	r3, [r5, #25]
    5212:	6a23      	ldr	r3, [r4, #32]
    5214:	0a1b      	lsrs	r3, r3, #8
    5216:	76ab      	strb	r3, [r5, #26]
    5218:	6a23      	ldr	r3, [r4, #32]
    521a:	76eb      	strb	r3, [r5, #27]
    PUT_UINT32( ctx->state[7], digest, 28 );
    521c:	f894 3027 	ldrb.w	r3, [r4, #39]	; 0x27
    5220:	772b      	strb	r3, [r5, #28]
    5222:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
    5224:	776b      	strb	r3, [r5, #29]
    5226:	6a63      	ldr	r3, [r4, #36]	; 0x24
    5228:	0a1b      	lsrs	r3, r3, #8
    522a:	77ab      	strb	r3, [r5, #30]
    522c:	6a63      	ldr	r3, [r4, #36]	; 0x24
    522e:	77eb      	strb	r3, [r5, #31]
    5230:	b003      	add	sp, #12
    5232:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
    5236:	f8df 90b0 	ldr.w	r9, [pc, #176]	; 52e8 <sha256_finish+0x214>
    523a:	f106 0028 	add.w	r0, r6, #40	; 0x28
    523e:	4649      	mov	r1, r9
    5240:	4420      	add	r0, r4
    5242:	463a      	mov	r2, r7
    5244:	f001 fa8c 	bl	6760 <memcpy>
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    5248:	4620      	mov	r0, r4
    524a:	f104 0128 	add.w	r1, r4, #40	; 0x28
        length -= fill;
    524e:	ebc7 0808 	rsb	r8, r7, r8
        input  += fill;
    5252:	44b9      	add	r9, r7

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    5254:	f7fd ff44 	bl	30e0 <sha256_process>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5258:	f1b8 0f3f 	cmp.w	r8, #63	; 0x3f
    525c:	d93a      	bls.n	52d4 <sha256_finish+0x200>
    525e:	4647      	mov	r7, r8
    5260:	464e      	mov	r6, r9
    {
        sha256_process( ctx, input );
    5262:	4631      	mov	r1, r6
        length -= 64;
    5264:	3f40      	subs	r7, #64	; 0x40
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    5266:	4620      	mov	r0, r4
    5268:	f7fd ff3a 	bl	30e0 <sha256_process>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    526c:	2f3f      	cmp	r7, #63	; 0x3f
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    526e:	f106 0640 	add.w	r6, r6, #64	; 0x40
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5272:	d8f6      	bhi.n	5262 <sha256_finish+0x18e>
    5274:	f1a8 0340 	sub.w	r3, r8, #64	; 0x40
    5278:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
    527c:	3340      	adds	r3, #64	; 0x40
    527e:	4499      	add	r9, r3
    5280:	f008 023f 	and.w	r2, r8, #63	; 0x3f
    5284:	2600      	movs	r6, #0
    5286:	e765      	b.n	5154 <sha256_finish+0x80>
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    5288:	f8df 905c 	ldr.w	r9, [pc, #92]	; 52e8 <sha256_finish+0x214>
    528c:	e7e4      	b.n	5258 <sha256_finish+0x184>
    {
        memcpy( (void *) (ctx->buffer + left),
    528e:	f108 0028 	add.w	r0, r8, #40	; 0x28
    5292:	464a      	mov	r2, r9
    5294:	4669      	mov	r1, sp
    5296:	4420      	add	r0, r4
    5298:	f001 fa62 	bl	6760 <memcpy>
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
    529c:	f1a8 0638 	sub.w	r6, r8, #56	; 0x38
        input  += fill;
    52a0:	ab00      	add	r3, sp, #0

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    52a2:	4620      	mov	r0, r4
    52a4:	f104 0128 	add.w	r1, r4, #40	; 0x28
        length -= fill;
        input  += fill;
    52a8:	4499      	add	r9, r3

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    52aa:	f7fd ff19 	bl	30e0 <sha256_process>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    52ae:	2e3f      	cmp	r6, #63	; 0x3f
    52b0:	d913      	bls.n	52da <sha256_finish+0x206>
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
    52b2:	464f      	mov	r7, r9
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    52b4:	4639      	mov	r1, r7
        length -= 64;
    52b6:	3e40      	subs	r6, #64	; 0x40
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    52b8:	4620      	mov	r0, r4
    52ba:	f7fd ff11 	bl	30e0 <sha256_process>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    52be:	2e3f      	cmp	r6, #63	; 0x3f
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    52c0:	f107 0740 	add.w	r7, r7, #64	; 0x40
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    52c4:	d8f6      	bhi.n	52b4 <sha256_finish+0x1e0>
    52c6:	f108 0608 	add.w	r6, r8, #8
    52ca:	f1a9 0940 	sub.w	r9, r9, #64	; 0x40
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    52ce:	f04f 0800 	mov.w	r8, #0
    52d2:	e75c      	b.n	518e <sha256_finish+0xba>
    }

    while( length >= 64 )
    52d4:	4642      	mov	r2, r8
    52d6:	2600      	movs	r6, #0
    52d8:	e73c      	b.n	5154 <sha256_finish+0x80>
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    52da:	2e00      	cmp	r6, #0
    52dc:	f43f af5e 	beq.w	519c <sha256_finish+0xc8>
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    52e0:	f04f 0800 	mov.w	r8, #0
    52e4:	e753      	b.n	518e <sha256_finish+0xba>
    52e6:	bf00      	nop
    52e8:	200002c4 	andcs	r0, r0, r4, asr #5

000052ec <sha512_block>:
{
	return (x >> bits) | (x << (64 - bits));
}

void sha512_block(struct sha512_state *s, const uint8_t *blk)
{
    52ec:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    52f0:	b0e4      	sub	sp, #400	; 0x190
    52f2:	460c      	mov	r4, r1
    52f4:	9033      	str	r0, [sp, #204]	; 0xcc
    52f6:	f101 0c80 	add.w	ip, r1, #128	; 0x80
    52fa:	ad42      	add	r5, sp, #264	; 0x108

static inline uint64_t load64(const uint8_t *x)
{
	uint64_t r;

	r = *(x++);
    52fc:	7820      	ldrb	r0, [r4, #0]
	r = (r << 8) | *(x++);
    52fe:	2100      	movs	r1, #0
    5300:	0e02      	lsrs	r2, r0, #24
    5302:	0203      	lsls	r3, r0, #8
    5304:	9211      	str	r2, [sp, #68]	; 0x44
    5306:	7860      	ldrb	r0, [r4, #1]
    5308:	9310      	str	r3, [sp, #64]	; 0x40
    530a:	e9dd 6710 	ldrd	r6, r7, [sp, #64]	; 0x40
    530e:	4339      	orrs	r1, r7
    5310:	4330      	orrs	r0, r6
	r = (r << 8) | *(x++);
    5312:	020f      	lsls	r7, r1, #8
    5314:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
    5318:	0206      	lsls	r6, r0, #8
    531a:	2100      	movs	r1, #0
    531c:	78a0      	ldrb	r0, [r4, #2]
    531e:	4339      	orrs	r1, r7
    5320:	4330      	orrs	r0, r6
	r = (r << 8) | *(x++);
    5322:	ea4f 2801 	mov.w	r8, r1, lsl #8
    5326:	ea48 6910 	orr.w	r9, r8, r0, lsr #24
    532a:	ea4f 2a00 	mov.w	sl, r0, lsl #8
    532e:	f8cd 9034 	str.w	r9, [sp, #52]	; 0x34
    5332:	78e0      	ldrb	r0, [r4, #3]
    5334:	f8cd a030 	str.w	sl, [sp, #48]	; 0x30
    5338:	2100      	movs	r1, #0
    533a:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30
    533e:	4319      	orrs	r1, r3
    5340:	4310      	orrs	r0, r2
	r = (r << 8) | *(x++);
    5342:	020b      	lsls	r3, r1, #8
    5344:	ea43 6810 	orr.w	r8, r3, r0, lsr #24
    5348:	ea4f 2900 	mov.w	r9, r0, lsl #8
    534c:	f8cd 803c 	str.w	r8, [sp, #60]	; 0x3c
    5350:	7920      	ldrb	r0, [r4, #4]
    5352:	f8cd 9038 	str.w	r9, [sp, #56]	; 0x38
    5356:	2100      	movs	r1, #0
    5358:	e9dd ab0e 	ldrd	sl, fp, [sp, #56]	; 0x38
    535c:	ea41 010b 	orr.w	r1, r1, fp
    5360:	ea40 000a 	orr.w	r0, r0, sl
	r = (r << 8) | *(x++);
    5364:	ea4f 2b01 	mov.w	fp, r1, lsl #8
    5368:	ea4b 6b10 	orr.w	fp, fp, r0, lsr #24
    536c:	ea4f 2a00 	mov.w	sl, r0, lsl #8
    5370:	2100      	movs	r1, #0
    5372:	7960      	ldrb	r0, [r4, #5]
    5374:	ea41 010b 	orr.w	r1, r1, fp
    5378:	ea40 000a 	orr.w	r0, r0, sl
	r = (r << 8) | *(x++);
    537c:	ea4f 2901 	mov.w	r9, r1, lsl #8
    5380:	ea49 6910 	orr.w	r9, r9, r0, lsr #24
    5384:	ea4f 2800 	mov.w	r8, r0, lsl #8
    5388:	2100      	movs	r1, #0
    538a:	79a0      	ldrb	r0, [r4, #6]
    538c:	ea41 0109 	orr.w	r1, r1, r9
    5390:	ea40 0008 	orr.w	r0, r0, r8
	r = (r << 8) | *(x++);
    5394:	020b      	lsls	r3, r1, #8
    5396:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
    539a:	0202      	lsls	r2, r0, #8
    539c:	79e0      	ldrb	r0, [r4, #7]
    539e:	2100      	movs	r1, #0
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
		w[i] = load64(blk);
		blk += 8;
    53a0:	3408      	adds	r4, #8
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
    53a2:	4310      	orrs	r0, r2
    53a4:	4319      	orrs	r1, r3
{
	uint64_t w[16];
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
    53a6:	4564      	cmp	r4, ip
		w[i] = load64(blk);
    53a8:	e9e5 0102 	strd	r0, r1, [r5, #8]!
{
	uint64_t w[16];
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
    53ac:	d1a6      	bne.n	52fc <sha512_block+0x10>
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
    53ae:	9b33      	ldr	r3, [sp, #204]	; 0xcc
	c = s->h[2];
    53b0:	9d33      	ldr	r5, [sp, #204]	; 0xcc
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
    53b2:	e9d3 2302 	ldrd	r2, r3, [r3, #8]
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    53b6:	9933      	ldr	r1, [sp, #204]	; 0xcc
	b = s->h[1];
    53b8:	e9cd 2336 	strd	r2, r3, [sp, #216]	; 0xd8
	c = s->h[2];
    53bc:	e9d5 4504 	ldrd	r4, r5, [r5, #16]
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    53c0:	e9d1 0100 	ldrd	r0, r1, [r1]
	b = s->h[1];
    53c4:	e9cd 230c 	strd	r2, r3, [sp, #48]	; 0x30
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    53c8:	9a33      	ldr	r2, [sp, #204]	; 0xcc
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    53ca:	e9cd 4538 	strd	r4, r5, [sp, #224]	; 0xe0
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    53ce:	f102 0330 	add.w	r3, r2, #48	; 0x30
    53d2:	e9d3 2300 	ldrd	r2, r3, [r3]
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    53d6:	e9cd 450e 	strd	r4, r5, [sp, #56]	; 0x38
	d = s->h[3];
    53da:	9f33      	ldr	r7, [sp, #204]	; 0xcc
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    53dc:	ac40      	add	r4, sp, #256	; 0x100
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    53de:	4689      	mov	r9, r1
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    53e0:	e9c4 2300 	strd	r2, r3, [r4]

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    53e4:	e9d7 6706 	ldrd	r6, r7, [r7, #24]
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    53e8:	e9cd 0134 	strd	r0, r1, [sp, #208]	; 0xd0
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
    53ec:	f8dd b0cc 	ldr.w	fp, [sp, #204]	; 0xcc
	f = s->h[5];
    53f0:	9933      	ldr	r1, [sp, #204]	; 0xcc
	g = s->h[6];
	h = s->h[7];
    53f2:	9c33      	ldr	r4, [sp, #204]	; 0xcc

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    53f4:	e9cd 673a 	strd	r6, r7, [sp, #232]	; 0xe8
	e = s->h[4];
    53f8:	e9db ab08 	ldrd	sl, fp, [fp, #32]
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    53fc:	f104 0538 	add.w	r5, r4, #56	; 0x38
    5400:	e9d5 4500 	ldrd	r4, r5, [r5]

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    5404:	e9cd 672a 	strd	r6, r7, [sp, #168]	; 0xa8
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    5408:	ae42      	add	r6, sp, #264	; 0x108
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    540a:	4680      	mov	r8, r0
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
    540c:	f04f 0c00 	mov.w	ip, #0
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
    5410:	e9d1 010a 	ldrd	r0, r1, [r1, #40]	; 0x28
	g = s->h[6];
    5414:	461f      	mov	r7, r3
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
    5416:	e9cd 013e 	strd	r0, r1, [sp, #248]	; 0xf8
    541a:	e9cd 0114 	strd	r0, r1, [sp, #80]	; 0x50
	g = s->h[6];
	h = s->h[7];
    541e:	465b      	mov	r3, fp
    5420:	e9c6 4500 	strd	r4, r5, [r6]
    5424:	4620      	mov	r0, r4
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    5426:	4616      	mov	r6, r2
	h = s->h[7];
    5428:	4629      	mov	r1, r5
    542a:	4652      	mov	r2, sl
	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
    542c:	e9cd ab3c 	strd	sl, fp, [sp, #240]	; 0xf0
    5430:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    5434:	46c2      	mov	sl, r8
    5436:	46cb      	mov	fp, r9
    5438:	4690      	mov	r8, r2
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    543a:	e9cd 6712 	strd	r6, r7, [sp, #72]	; 0x48
	h = s->h[7];
    543e:	e9cd 012c 	strd	r0, r1, [sp, #176]	; 0xb0
    5442:	4699      	mov	r9, r3
    5444:	4662      	mov	r2, ip
    5446:	e018      	b.n	547a <sha512_block+0x18e>

		/* Update round state */
		h = g;
		g = f;
		f = e;
		e = d + temp1;
    5448:	e9dd 4512 	ldrd	r4, r5, [sp, #72]	; 0x48
    544c:	e9dd 670e 	ldrd	r6, r7, [sp, #56]	; 0x38
    5450:	e9cd 452c 	strd	r4, r5, [sp, #176]	; 0xb0
    5454:	e9dd 4514 	ldrd	r4, r5, [sp, #80]	; 0x50
    5458:	e9cd 672a 	strd	r6, r7, [sp, #168]	; 0xa8
    545c:	e9dd 670c 	ldrd	r6, r7, [sp, #48]	; 0x30
    5460:	e9cd 4512 	strd	r4, r5, [sp, #72]	; 0x48
    5464:	e9cd 670e 	strd	r6, r7, [sp, #56]	; 0x38
    5468:	e9cd 8914 	strd	r8, r9, [sp, #80]	; 0x50
    546c:	4690      	mov	r8, r2
    546e:	9a10      	ldr	r2, [sp, #64]	; 0x40
    5470:	e9cd ab0c 	strd	sl, fp, [sp, #48]	; 0x30
    5474:	4699      	mov	r9, r3
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
    5476:	4682      	mov	sl, r0
    5478:	468b      	mov	fp, r1
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
    547a:	ab64      	add	r3, sp, #400	; 0x190
    547c:	eb03 05c2 	add.w	r5, r3, r2, lsl #3
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5480:	ea4f 4298 	mov.w	r2, r8, lsr #18
    5484:	ea42 3289 	orr.w	r2, r2, r9, lsl #14
    5488:	9216      	str	r2, [sp, #88]	; 0x58
    548a:	ea4f 3298 	mov.w	r2, r8, lsr #14
    548e:	ea42 4289 	orr.w	r2, r2, r9, lsl #18
    5492:	9218      	str	r2, [sp, #96]	; 0x60
    5494:	ea4f 4299 	mov.w	r2, r9, lsr #18
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    5498:	f10c 0c01 	add.w	ip, ip, #1
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    549c:	ea42 3288 	orr.w	r2, r2, r8, lsl #14
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    54a0:	f00c 040f 	and.w	r4, ip, #15
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54a4:	9217      	str	r2, [sp, #92]	; 0x5c
    54a6:	ea4f 3299 	mov.w	r2, r9, lsr #14
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    54aa:	eb03 01c4 	add.w	r1, r3, r4, lsl #3
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54ae:	ea42 4288 	orr.w	r2, r2, r8, lsl #18
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    54b2:	e951 0120 	ldrd	r0, r1, [r1, #-128]	; 0x80
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54b6:	9219      	str	r2, [sp, #100]	; 0x64
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    54b8:	09c6      	lsrs	r6, r0, #7
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    54ba:	9410      	str	r4, [sp, #64]	; 0x40
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54bc:	ea4f 52c8 	mov.w	r2, r8, lsl #23
    54c0:	0844      	lsrs	r4, r0, #1
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    54c2:	ea46 6741 	orr.w	r7, r6, r1, lsl #25
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54c6:	ea44 74c1 	orr.w	r4, r4, r1, lsl #31
    54ca:	ea42 2259 	orr.w	r2, r2, r9, lsr #9
    54ce:	f10c 030d 	add.w	r3, ip, #13
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    54d2:	9708      	str	r7, [sp, #32]
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54d4:	9422      	str	r4, [sp, #136]	; 0x88
    54d6:	921a      	str	r2, [sp, #104]	; 0x68
    54d8:	0a04      	lsrs	r4, r0, #8

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    54da:	af64      	add	r7, sp, #400	; 0x190
    54dc:	f003 030f 	and.w	r3, r3, #15
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54e0:	ea4f 52c9 	mov.w	r2, r9, lsl #23
    54e4:	ea44 6401 	orr.w	r4, r4, r1, lsl #24
    54e8:	084e      	lsrs	r6, r1, #1

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    54ea:	eb07 03c3 	add.w	r3, r7, r3, lsl #3
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54ee:	ea42 2258 	orr.w	r2, r2, r8, lsr #9
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    54f2:	09cf      	lsrs	r7, r1, #7
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54f4:	ea46 76c0 	orr.w	r6, r6, r0, lsl #31
    54f8:	9424      	str	r4, [sp, #144]	; 0x90
    54fa:	921b      	str	r2, [sp, #108]	; 0x6c
    54fc:	0a09      	lsrs	r1, r1, #8

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    54fe:	e953 2320 	ldrd	r2, r3, [r3, #-128]	; 0x80
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5502:	0994      	lsrs	r4, r2, #6
    5504:	940a      	str	r4, [sp, #40]	; 0x28
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5506:	9709      	str	r7, [sp, #36]	; 0x24
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5508:	9623      	str	r6, [sp, #140]	; 0x8c
    550a:	ea41 6100 	orr.w	r1, r1, r0, lsl #24
    550e:	9125      	str	r1, [sp, #148]	; 0x94
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5510:	e9dd 6722 	ldrd	r6, r7, [sp, #136]	; 0x88
    5514:	e9dd 0108 	ldrd	r0, r1, [sp, #32]
    5518:	404f      	eors	r7, r1
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    551a:	990a      	ldr	r1, [sp, #40]	; 0x28
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    551c:	4046      	eors	r6, r0
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    551e:	ea41 6183 	orr.w	r1, r1, r3, lsl #26
    5522:	910a      	str	r1, [sp, #40]	; 0x28
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5524:	0cd1      	lsrs	r1, r2, #19
    5526:	ea41 3143 	orr.w	r1, r1, r3, lsl #13
    552a:	9126      	str	r1, [sp, #152]	; 0x98
    552c:	ea4f 718a 	mov.w	r1, sl, lsl #30
    5530:	ea41 019b 	orr.w	r1, r1, fp, lsr #2
    5534:	911c      	str	r1, [sp, #112]	; 0x70
    5536:	ea4f 711a 	mov.w	r1, sl, lsr #28
    553a:	ea41 110b 	orr.w	r1, r1, fp, lsl #4
    553e:	911e      	str	r1, [sp, #120]	; 0x78
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
    5540:	e9dd 0124 	ldrd	r0, r1, [sp, #144]	; 0x90
    5544:	4070      	eors	r0, r6
    5546:	4079      	eors	r1, r7
    5548:	e9cd 0130 	strd	r0, r1, [sp, #192]	; 0xc0
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
    554c:	e9dd 6718 	ldrd	r6, r7, [sp, #96]	; 0x60
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5550:	0999      	lsrs	r1, r3, #6
    5552:	910b      	str	r1, [sp, #44]	; 0x2c

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
    5554:	e9dd 0116 	ldrd	r0, r1, [sp, #88]	; 0x58
    5558:	4070      	eors	r0, r6
    555a:	4079      	eors	r1, r7
    555c:	f10c 0408 	add.w	r4, ip, #8
    5560:	e9dd 671a 	ldrd	r6, r7, [sp, #104]	; 0x68
    5564:	4046      	eors	r6, r0
    5566:	404f      	eors	r7, r1
    5568:	e9cd 672e 	strd	r6, r7, [sp, #184]	; 0xb8
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    556c:	e9dd 0130 	ldrd	r0, r1, [sp, #192]	; 0xc0
	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
    5570:	af64      	add	r7, sp, #400	; 0x190
    5572:	f004 040f 	and.w	r4, r4, #15
    5576:	eb07 04c4 	add.w	r4, r7, r4, lsl #3
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    557a:	e955 6720 	ldrd	r6, r7, [r5, #-128]	; 0x80
    557e:	1980      	adds	r0, r0, r6
    5580:	eb41 0107 	adc.w	r1, r1, r7
    5584:	e9cd 0130 	strd	r0, r1, [sp, #192]	; 0xc0
    5588:	e954 0120 	ldrd	r0, r1, [r4, #-128]	; 0x80
    558c:	e9dd 6730 	ldrd	r6, r7, [sp, #192]	; 0xc0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5590:	0cdc      	lsrs	r4, r3, #19
    5592:	ea44 3442 	orr.w	r4, r4, r2, lsl #13
    5596:	9427      	str	r4, [sp, #156]	; 0x9c
    5598:	00d4      	lsls	r4, r2, #3
    559a:	ea44 7453 	orr.w	r4, r4, r3, lsr #29
    559e:	00db      	lsls	r3, r3, #3
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55a0:	1980      	adds	r0, r0, r6
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55a2:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55a6:	eb41 0107 	adc.w	r1, r1, r7
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55aa:	9428      	str	r4, [sp, #160]	; 0xa0
    55ac:	9329      	str	r3, [sp, #164]	; 0xa4
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    55ae:	e9dd 6726 	ldrd	r6, r7, [sp, #152]	; 0x98
    55b2:	e9dd 230a 	ldrd	r2, r3, [sp, #40]	; 0x28
    55b6:	4056      	eors	r6, r2
    55b8:	405f      	eors	r7, r3
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
    55ba:	e9dd 2328 	ldrd	r2, r3, [sp, #160]	; 0xa0
    55be:	4056      	eors	r6, r2
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55c0:	1982      	adds	r2, r0, r6
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
    55c2:	ea87 0703 	eor.w	r7, r7, r3
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55c6:	eb41 0307 	adc.w	r3, r1, r7
    55ca:	e9cd 2330 	strd	r2, r3, [sp, #192]	; 0xc0
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
    55ce:	e9dd 0112 	ldrd	r0, r1, [sp, #72]	; 0x48
    55d2:	e9dd 2314 	ldrd	r2, r3, [sp, #80]	; 0x50
    55d6:	ea20 0008 	bic.w	r0, r0, r8
    55da:	ea02 0208 	and.w	r2, r2, r8
    55de:	ea03 0309 	and.w	r3, r3, r9
    55e2:	ea21 0109 	bic.w	r1, r1, r9
    55e6:	4050      	eors	r0, r2
    55e8:	4059      	eors	r1, r3
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55ea:	ea4f 738b 	mov.w	r3, fp, lsl #30

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55ee:	e9dd 672e 	ldrd	r6, r7, [sp, #184]	; 0xb8
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55f2:	ea43 039a 	orr.w	r3, r3, sl, lsr #2

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55f6:	1980      	adds	r0, r0, r6
    55f8:	eb41 0107 	adc.w	r1, r1, r7
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55fc:	931d      	str	r3, [sp, #116]	; 0x74

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55fe:	e955 6720 	ldrd	r6, r7, [r5, #-128]	; 0x80
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5602:	ea4f 634a 	mov.w	r3, sl, lsl #25

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5606:	1836      	adds	r6, r6, r0
    5608:	eb47 0701 	adc.w	r7, r7, r1
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    560c:	ea43 13db 	orr.w	r3, r3, fp, lsr #7
    5610:	ea4f 721b 	mov.w	r2, fp, lsr #28
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5614:	e9dd 010c 	ldrd	r0, r1, [sp, #48]	; 0x30
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5618:	ea42 120a 	orr.w	r2, r2, sl, lsl #4
    561c:	9320      	str	r3, [sp, #128]	; 0x80

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    561e:	e9cd 672e 	strd	r6, r7, [sp, #184]	; 0xb8
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5622:	e9dd 670e 	ldrd	r6, r7, [sp, #56]	; 0x38
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5626:	ea4f 634b 	mov.w	r3, fp, lsl #25
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    562a:	404f      	eors	r7, r1
    562c:	4953      	ldr	r1, [pc, #332]	; (577c <sha512_block+0x490>)
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    562e:	921f      	str	r2, [sp, #124]	; 0x7c
    5630:	ea43 13da 	orr.w	r3, r3, sl, lsr #7
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5634:	4046      	eors	r6, r0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5636:	9321      	str	r3, [sp, #132]	; 0x84
    5638:	eb01 04cc 	add.w	r4, r1, ip, lsl #3
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
    563c:	e9dd 231c 	ldrd	r2, r3, [sp, #112]	; 0x70
    5640:	e9dd 011e 	ldrd	r0, r1, [sp, #120]	; 0x78
    5644:	4042      	eors	r2, r0
    5646:	404b      	eors	r3, r1
    5648:	e9dd 0120 	ldrd	r0, r1, [sp, #128]	; 0x80
    564c:	4050      	eors	r0, r2
    564e:	4059      	eors	r1, r3
    5650:	e9cd 0100 	strd	r0, r1, [sp]
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    5654:	e9dd 2330 	ldrd	r2, r3, [sp, #192]	; 0xc0

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5658:	e9dd 012e 	ldrd	r0, r1, [sp, #184]	; 0xb8
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    565c:	e945 2320 	strd	r2, r3, [r5, #-128]	; 0x80

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5660:	f1a4 0508 	sub.w	r5, r4, #8
    5664:	e9d5 4500 	ldrd	r4, r5, [r5]
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5668:	e9dd 230c 	ldrd	r2, r3, [sp, #48]	; 0x30

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    566c:	1900      	adds	r0, r0, r4
    566e:	eb41 0105 	adc.w	r1, r1, r5
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5672:	ea06 060a 	and.w	r6, r6, sl
    5676:	ea07 070b 	and.w	r7, r7, fp
    567a:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
    567e:	4014      	ands	r4, r2
    5680:	401d      	ands	r5, r3
    5682:	4074      	eors	r4, r6
    5684:	407d      	eors	r5, r7

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5686:	e9dd 672c 	ldrd	r6, r7, [sp, #176]	; 0xb0
    568a:	1980      	adds	r0, r0, r6
    568c:	eb41 0107 	adc.w	r1, r1, r7
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
		const uint64_t temp2 = S0 + maj;
    5690:	e9dd 2300 	ldrd	r2, r3, [sp]
    5694:	18a4      	adds	r4, r4, r2
    5696:	eb45 0503 	adc.w	r5, r5, r3

		/* Update round state */
		h = g;
		g = f;
		f = e;
		e = d + temp1;
    569a:	e9dd 232a 	ldrd	r2, r3, [sp, #168]	; 0xa8
    569e:	1812      	adds	r2, r2, r0
    56a0:	eb43 0301 	adc.w	r3, r3, r1
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
    56a4:	1900      	adds	r0, r0, r4
    56a6:	eb41 0105 	adc.w	r1, r1, r5
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
    56aa:	f1bc 0f50 	cmp.w	ip, #80	; 0x50
    56ae:	f47f aecb 	bne.w	5448 <sha512_block+0x15c>
    56b2:	4614      	mov	r4, r2
    56b4:	461d      	mov	r5, r3
    56b6:	4602      	mov	r2, r0
    56b8:	460b      	mov	r3, r1
    56ba:	4640      	mov	r0, r8
    56bc:	4649      	mov	r1, r9
    56be:	46d0      	mov	r8, sl
    56c0:	46d9      	mov	r9, fp
    56c2:	4682      	mov	sl, r0
    56c4:	468b      	mov	fp, r1
    56c6:	4620      	mov	r0, r4
    56c8:	4629      	mov	r1, r5
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    56ca:	e9dd 4534 	ldrd	r4, r5, [sp, #208]	; 0xd0
    56ce:	18a4      	adds	r4, r4, r2
    56d0:	eb45 0503 	adc.w	r5, r5, r3
	s->h[1] += b;
    56d4:	e9dd 6736 	ldrd	r6, r7, [sp, #216]	; 0xd8
    56d8:	eb16 0608 	adds.w	r6, r6, r8
    56dc:	eb47 0709 	adc.w	r7, r7, r9
	s->h[2] += c;
    56e0:	e9dd 2338 	ldrd	r2, r3, [sp, #224]	; 0xe0
    56e4:	e9dd 890c 	ldrd	r8, r9, [sp, #48]	; 0x30
    56e8:	eb18 0802 	adds.w	r8, r8, r2
    56ec:	eb49 0903 	adc.w	r9, r9, r3
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    56f0:	e9cd 4506 	strd	r4, r5, [sp, #24]
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    56f4:	e9dd 450e 	ldrd	r4, r5, [sp, #56]	; 0x38
	s->h[4] += e;
    56f8:	e9dd 233c 	ldrd	r2, r3, [sp, #240]	; 0xf0
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
    56fc:	e9cd 6704 	strd	r6, r7, [sp, #16]
	s->h[2] += c;
	s->h[3] += d;
    5700:	e9dd 673a 	ldrd	r6, r7, [sp, #232]	; 0xe8
    5704:	19a4      	adds	r4, r4, r6
    5706:	eb45 0507 	adc.w	r5, r5, r7
	s->h[4] += e;
    570a:	1880      	adds	r0, r0, r2
    570c:	eb41 0103 	adc.w	r1, r1, r3
	s->h[5] += f;
	s->h[6] += g;
    5710:	af40      	add	r7, sp, #256	; 0x100
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
    5712:	e9dd 233e 	ldrd	r2, r3, [sp, #248]	; 0xf8
    5716:	eb12 020a 	adds.w	r2, r2, sl
    571a:	eb43 030b 	adc.w	r3, r3, fp
	s->h[6] += g;
    571e:	e9d7 6700 	ldrd	r6, r7, [r7]

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    5722:	e9cd 4502 	strd	r4, r5, [sp, #8]
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    5726:	e9dd 4514 	ldrd	r4, r5, [sp, #80]	; 0x50
	s->h[7] += h;
    572a:	f50d 7b84 	add.w	fp, sp, #264	; 0x108
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    572e:	19a4      	adds	r4, r4, r6
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5730:	f8dd c0cc 	ldr.w	ip, [sp, #204]	; 0xcc
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    5734:	eb45 0507 	adc.w	r5, r5, r7
	s->h[7] += h;
    5738:	e9db ab00 	ldrd	sl, fp, [fp]
    573c:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
    5740:	eb16 060a 	adds.w	r6, r6, sl
    5744:	eb47 070b 	adc.w	r7, r7, fp
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
    5748:	e9cc 8904 	strd	r8, r9, [ip, #16]
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    574c:	e9dd ab06 	ldrd	sl, fp, [sp, #24]
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    5750:	e9dd 8902 	ldrd	r8, r9, [sp, #8]
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5754:	e9cc ab00 	strd	sl, fp, [ip]
	s->h[1] += b;
    5758:	e9dd ab04 	ldrd	sl, fp, [sp, #16]
	s->h[2] += c;
	s->h[3] += d;
    575c:	e9cc 8906 	strd	r8, r9, [ip, #24]
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
    5760:	e9cc ab02 	strd	sl, fp, [ip, #8]
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
    5764:	e9cc 0108 	strd	r0, r1, [ip, #32]
	s->h[5] += f;
    5768:	e9cc 230a 	strd	r2, r3, [ip, #40]	; 0x28
	s->h[6] += g;
    576c:	e9cc 450c 	strd	r4, r5, [ip, #48]	; 0x30
	s->h[7] += h;
    5770:	e9cc 670e 	strd	r6, r7, [ip, #56]	; 0x38
}
    5774:	b064      	add	sp, #400	; 0x190
    5776:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
    577a:	4770      	bx	lr
    577c:	000072c0 	andeq	r7, r0, r0, asr #5

00005780 <sha512_final>:

void sha512_final(struct sha512_state *s, const uint8_t *blk,
		  size_t total_size)
{
    5780:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
    5784:	2580      	movs	r5, #128	; 0x80
	s->h[7] += h;
}

void sha512_final(struct sha512_state *s, const uint8_t *blk,
		  size_t total_size)
{
    5786:	b0a0      	sub	sp, #128	; 0x80
    5788:	4614      	mov	r4, r2
    578a:	4682      	mov	sl, r0
    578c:	460f      	mov	r7, r1
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
    578e:	4668      	mov	r0, sp
    5790:	462a      	mov	r2, r5
    5792:	2100      	movs	r1, #0
    5794:	f000 ffed 	bl	6772 <memset>
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
    5798:	f014 067f 	ands.w	r6, r4, #127	; 0x7f
    579c:	d11e      	bne.n	57dc <sha512_final+0x5c>
		memcpy(temp, blk, last_size);
	temp[last_size] = 0x80;
    579e:	f88d 5000 	strb.w	r5, [sp]
		sha512_block(s, temp);
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
    57a2:	00e2      	lsls	r2, r4, #3

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    57a4:	0a14      	lsrs	r4, r2, #8
	*(x--) = v;
	v >>= 8;
    57a6:	0a26      	lsrs	r6, r4, #8

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    57a8:	2500      	movs	r5, #0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57aa:	ea4f 2816 	mov.w	r8, r6, lsr #8
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
	sha512_block(s, temp);
    57ae:	4650      	mov	r0, sl
    57b0:	4669      	mov	r1, sp
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    57b2:	f88d 207f 	strb.w	r2, [sp, #127]	; 0x7f
	v >>= 8;
	*(x--) = v;
    57b6:	f88d 407e 	strb.w	r4, [sp, #126]	; 0x7e
	v >>= 8;
	*(x--) = v;
    57ba:	f88d 607d 	strb.w	r6, [sp, #125]	; 0x7d
	v >>= 8;
	*(x--) = v;
    57be:	f88d 807c 	strb.w	r8, [sp, #124]	; 0x7c
	v >>= 8;
	*(x--) = v;
    57c2:	f88d 507b 	strb.w	r5, [sp, #123]	; 0x7b
	v >>= 8;
	*(x--) = v;
    57c6:	f88d 507a 	strb.w	r5, [sp, #122]	; 0x7a
	v >>= 8;
	*(x--) = v;
    57ca:	f88d 5079 	strb.w	r5, [sp, #121]	; 0x79
	v >>= 8;
	*(x--) = v;
    57ce:	f88d 5078 	strb.w	r5, [sp, #120]	; 0x78
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
	sha512_block(s, temp);
    57d2:	f7ff fd8b 	bl	52ec <sha512_block>
}
    57d6:	b020      	add	sp, #128	; 0x80
    57d8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
{
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
		memcpy(temp, blk, last_size);
    57dc:	4639      	mov	r1, r7
    57de:	4668      	mov	r0, sp
    57e0:	4632      	mov	r2, r6
    57e2:	f000 ffbd 	bl	6760 <memcpy>
	temp[last_size] = 0x80;
    57e6:	eb0d 0305 	add.w	r3, sp, r5
    57ea:	4433      	add	r3, r6

	if (last_size > 111) {
    57ec:	2e6f      	cmp	r6, #111	; 0x6f
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
		memcpy(temp, blk, last_size);
	temp[last_size] = 0x80;
    57ee:	f803 5c80 	strb.w	r5, [r3, #-128]

	if (last_size > 111) {
    57f2:	d9d6      	bls.n	57a2 <sha512_final+0x22>
		sha512_block(s, temp);
    57f4:	4650      	mov	r0, sl
    57f6:	4669      	mov	r1, sp
    57f8:	f7ff fd78 	bl	52ec <sha512_block>
		memset(temp, 0, sizeof(temp));
    57fc:	4668      	mov	r0, sp
    57fe:	462a      	mov	r2, r5
    5800:	2100      	movs	r1, #0
    5802:	f000 ffb6 	bl	6772 <memset>
    5806:	e7cc      	b.n	57a2 <sha512_final+0x22>

00005808 <sha512_get>:
	sha512_block(s, temp);
}

void sha512_get(const struct sha512_state *s, uint8_t *hash,
		unsigned int offset, unsigned int len)
{
    5808:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	int i;

	if (offset > SHA512_BLOCK_SIZE)
    580c:	2a80      	cmp	r2, #128	; 0x80
	sha512_block(s, temp);
}

void sha512_get(const struct sha512_state *s, uint8_t *hash,
		unsigned int offset, unsigned int len)
{
    580e:	b09b      	sub	sp, #108	; 0x6c
    5810:	9014      	str	r0, [sp, #80]	; 0x50
    5812:	910f      	str	r1, [sp, #60]	; 0x3c
	int i;

	if (offset > SHA512_BLOCK_SIZE)
    5814:	d87b      	bhi.n	590e <sha512_get+0x106>
		return;

	if (len > SHA512_BLOCK_SIZE - offset)
    5816:	f1c2 0180 	rsb	r1, r2, #128	; 0x80
    581a:	4299      	cmp	r1, r3
    581c:	bf28      	it	cs
    581e:	4619      	movcs	r1, r3
		len = SHA512_BLOCK_SIZE - offset;

	/* Skip whole words */
	i = offset >> 3;
    5820:	08d0      	lsrs	r0, r2, #3
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
    5822:	f012 0207 	ands.w	r2, r2, #7
    5826:	910d      	str	r1, [sp, #52]	; 0x34

	if (len > SHA512_BLOCK_SIZE - offset)
		len = SHA512_BLOCK_SIZE - offset;

	/* Skip whole words */
	i = offset >> 3;
    5828:	900e      	str	r0, [sp, #56]	; 0x38
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
    582a:	9215      	str	r2, [sp, #84]	; 0x54
    582c:	d172      	bne.n	5914 <sha512_get+0x10c>
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    582e:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    5830:	2d07      	cmp	r5, #7
    5832:	d969      	bls.n	5908 <sha512_get+0x100>
    5834:	f1a5 0308 	sub.w	r3, r5, #8
    5838:	08db      	lsrs	r3, r3, #3
    583a:	980e      	ldr	r0, [sp, #56]	; 0x38
    583c:	9c14      	ldr	r4, [sp, #80]	; 0x50
    583e:	469c      	mov	ip, r3
    5840:	4484      	add	ip, r0
    5842:	930a      	str	r3, [sp, #40]	; 0x28
    5844:	f104 0308 	add.w	r3, r4, #8
    5848:	eb03 0ccc 	add.w	ip, r3, ip, lsl #3
    584c:	eb04 00c0 	add.w	r0, r4, r0, lsl #3
    5850:	990f      	ldr	r1, [sp, #60]	; 0x3c
    5852:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
    5856:	9012      	str	r0, [sp, #72]	; 0x48
		store64(hash, s->h[i++]);
    5858:	9c12      	ldr	r4, [sp, #72]	; 0x48
    585a:	e8f4 2302 	ldrd	r2, r3, [r4], #8
    585e:	e9cd 2306 	strd	r2, r3, [sp, #24]

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5862:	9d06      	ldr	r5, [sp, #24]
    5864:	f8dd c01c 	ldr.w	ip, [sp, #28]
    5868:	0a2a      	lsrs	r2, r5, #8
    586a:	ea42 620c 	orr.w	r2, r2, ip, lsl #24
    586e:	ea4f 231c 	mov.w	r3, ip, lsr #8
	*(x--) = v;
	v >>= 8;
    5872:	0a10      	lsrs	r0, r2, #8
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
		store64(hash, s->h[i++]);
    5874:	9412      	str	r4, [sp, #72]	; 0x48
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5876:	ea40 6403 	orr.w	r4, r0, r3, lsl #24
    587a:	0a1d      	lsrs	r5, r3, #8
	*(x--) = v;
	v >>= 8;
    587c:	ea4f 2a14 	mov.w	sl, r4, lsr #8
    5880:	ea4a 6a05 	orr.w	sl, sl, r5, lsl #24
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5884:	9404      	str	r4, [sp, #16]
	*(x--) = v;
	v >>= 8;
    5886:	ea4f 2b15 	mov.w	fp, r5, lsr #8
	*(x--) = v;
	v >>= 8;
    588a:	ea4f 241a 	mov.w	r4, sl, lsr #8
    588e:	ea44 640b 	orr.w	r4, r4, fp, lsl #24
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5892:	9505      	str	r5, [sp, #20]
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5894:	0a26      	lsrs	r6, r4, #8
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5896:	ea4f 251b 	mov.w	r5, fp, lsr #8
	*(x--) = v;
	v >>= 8;
    589a:	ea46 6605 	orr.w	r6, r6, r5, lsl #24
    589e:	0a2f      	lsrs	r7, r5, #8
	*(x--) = v;
	v >>= 8;
    58a0:	ea4f 2816 	mov.w	r8, r6, lsr #8
    58a4:	ea48 6807 	orr.w	r8, r8, r7, lsl #24
    58a8:	ea4f 2917 	mov.w	r9, r7, lsr #8
	*(x--) = v;
	v >>= 8;
    58ac:	ea4f 2018 	mov.w	r0, r8, lsr #8
    58b0:	ea40 6c09 	orr.w	ip, r0, r9, lsl #24
    58b4:	ea4f 2019 	mov.w	r0, r9, lsr #8
    58b8:	9009      	str	r0, [sp, #36]	; 0x24
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58ba:	f89d 0010 	ldrb.w	r0, [sp, #16]
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58be:	f8cd c020 	str.w	ip, [sp, #32]
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58c2:	7148      	strb	r0, [r1, #5]
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58c4:	f89d c020 	ldrb.w	ip, [sp, #32]
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    58c8:	f89d 0018 	ldrb.w	r0, [sp, #24]
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58cc:	f881 8001 	strb.w	r8, [r1, #1]
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    58d0:	71c8      	strb	r0, [r1, #7]
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d2:	708e      	strb	r6, [r1, #2]
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d4:	70cc      	strb	r4, [r1, #3]
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d6:	f881 a004 	strb.w	sl, [r1, #4]
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58da:	718a      	strb	r2, [r1, #6]
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    58dc:	9812      	ldr	r0, [sp, #72]	; 0x48
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58de:	f801 cb08 	strb.w	ip, [r1], #8
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    58e2:	f8dd c040 	ldr.w	ip, [sp, #64]	; 0x40
    58e6:	4560      	cmp	r0, ip
    58e8:	d1b6      	bne.n	5858 <sha512_get+0x50>
    58ea:	980e      	ldr	r0, [sp, #56]	; 0x38
    58ec:	990a      	ldr	r1, [sp, #40]	; 0x28
    58ee:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    58f0:	9d0d      	ldr	r5, [sp, #52]	; 0x34
    58f2:	1c4b      	adds	r3, r1, #1
    58f4:	f100 0c01 	add.w	ip, r0, #1
    58f8:	4461      	add	r1, ip
    58fa:	eb04 04c3 	add.w	r4, r4, r3, lsl #3
    58fe:	f005 0507 	and.w	r5, r5, #7
    5902:	910e      	str	r1, [sp, #56]	; 0x38
    5904:	940f      	str	r4, [sp, #60]	; 0x3c
    5906:	950d      	str	r5, [sp, #52]	; 0x34
		hash += 8;
		len -= 8;
	}

	/* Read out bytes */
	if (len) {
    5908:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    590a:	2b00      	cmp	r3, #0
    590c:	d173      	bne.n	59f6 <sha512_get+0x1ee>
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
	}
}
    590e:	b01b      	add	sp, #108	; 0x6c
    5910:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    5914:	9c14      	ldr	r4, [sp, #80]	; 0x50
    5916:	eb04 03c0 	add.w	r3, r4, r0, lsl #3
    591a:	e9d3 2300 	ldrd	r2, r3, [r3]

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    591e:	0a14      	lsrs	r4, r2, #8
    5920:	ea44 6403 	orr.w	r4, r4, r3, lsl #24
    5924:	0a1d      	lsrs	r5, r3, #8
	*(x--) = v;
	v >>= 8;
    5926:	0a21      	lsrs	r1, r4, #8
    5928:	ea41 6c05 	orr.w	ip, r1, r5, lsl #24
    592c:	ea4f 2e15 	mov.w	lr, r5, lsr #8
	*(x--) = v;
	v >>= 8;
    5930:	ea4f 211c 	mov.w	r1, ip, lsr #8
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5934:	f8cd c028 	str.w	ip, [sp, #40]	; 0x28
	*(x--) = v;
	v >>= 8;
    5938:	ea41 6c0e 	orr.w	ip, r1, lr, lsl #24
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    593c:	f8cd e02c 	str.w	lr, [sp, #44]	; 0x2c
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5940:	ea4f 211c 	mov.w	r1, ip, lsr #8
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5944:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
    5948:	f8cd c040 	str.w	ip, [sp, #64]	; 0x40
	*(x--) = v;
	v >>= 8;
    594c:	ea41 6c0e 	orr.w	ip, r1, lr, lsl #24
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5950:	f8cd e044 	str.w	lr, [sp, #68]	; 0x44
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5954:	ea4f 201c 	mov.w	r0, ip, lsr #8
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5958:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
	*(x--) = v;
	v >>= 8;
    595c:	ea40 600e 	orr.w	r0, r0, lr, lsl #24
    5960:	ea4f 211e 	mov.w	r1, lr, lsr #8
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5964:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5968:	0a02      	lsrs	r2, r0, #8
    596a:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
    596e:	0a0b      	lsrs	r3, r1, #8
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5970:	f8cd c048 	str.w	ip, [sp, #72]	; 0x48
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5974:	0a15      	lsrs	r5, r2, #8
    5976:	ea45 6c03 	orr.w	ip, r5, r3, lsl #24
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    597a:	f88d 4066 	strb.w	r4, [sp, #102]	; 0x66
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    597e:	f89d 5048 	ldrb.w	r5, [sp, #72]	; 0x48
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5982:	f89d 4040 	ldrb.w	r4, [sp, #64]	; 0x40
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5986:	f8cd c018 	str.w	ip, [sp, #24]
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    598a:	f8cd e04c 	str.w	lr, [sp, #76]	; 0x4c
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
		uint8_t tmp[8];
		unsigned int c = 8 - offset;
    598e:	f8dd c054 	ldr.w	ip, [sp, #84]	; 0x54
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5992:	f89d e028 	ldrb.w	lr, [sp, #40]	; 0x28
	v >>= 8;
	*(x--) = v;
    5996:	f88d 4064 	strb.w	r4, [sp, #100]	; 0x64
	v >>= 8;
	*(x--) = v;
    599a:	f88d 5063 	strb.w	r5, [sp, #99]	; 0x63
    599e:	9c0d      	ldr	r4, [sp, #52]	; 0x34
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59a0:	f89d 5018 	ldrb.w	r5, [sp, #24]
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59a4:	f88d e065 	strb.w	lr, [sp, #101]	; 0x65
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59a8:	f88d 0062 	strb.w	r0, [sp, #98]	; 0x62
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59ac:	ea4f 2e13 	mov.w	lr, r3, lsr #8
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59b0:	f88d 2061 	strb.w	r2, [sp, #97]	; 0x61
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    59b4:	980e      	ldr	r0, [sp, #56]	; 0x38
		memcpy(hash, tmp + offset, c);
    59b6:	9a15      	ldr	r2, [sp, #84]	; 0x54
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59b8:	a91a      	add	r1, sp, #104	; 0x68
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
		uint8_t tmp[8];
		unsigned int c = 8 - offset;
    59ba:	f1cc 0308 	rsb	r3, ip, #8
    59be:	429c      	cmp	r4, r3
    59c0:	bf38      	it	cc
    59c2:	4623      	movcc	r3, r4
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59c4:	f801 5d08 	strb.w	r5, [r1, #-8]!
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    59c8:	f100 0c01 	add.w	ip, r0, #1
		memcpy(hash, tmp + offset, c);
		len -= c;
    59cc:	1ae4      	subs	r4, r4, r3

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    59ce:	4411      	add	r1, r2
    59d0:	980f      	ldr	r0, [sp, #60]	; 0x3c
    59d2:	461a      	mov	r2, r3
		len -= c;
    59d4:	940d      	str	r4, [sp, #52]	; 0x34

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    59d6:	9302      	str	r3, [sp, #8]
    59d8:	f8cd c00c 	str.w	ip, [sp, #12]
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59dc:	f8cd e01c 	str.w	lr, [sp, #28]

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    59e0:	f000 febe 	bl	6760 <memcpy>
		len -= c;
		hash += c;
    59e4:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
    59e6:	9b02      	ldr	r3, [sp, #8]
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    59e8:	f8dd c00c 	ldr.w	ip, [sp, #12]
		memcpy(hash, tmp + offset, c);
		len -= c;
		hash += c;
    59ec:	441c      	add	r4, r3
    59ee:	940f      	str	r4, [sp, #60]	; 0x3c
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    59f0:	f8cd c038 	str.w	ip, [sp, #56]	; 0x38
    59f4:	e71b      	b.n	582e <sha512_get+0x26>

	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
    59f6:	9c14      	ldr	r4, [sp, #80]	; 0x50
    59f8:	9d0e      	ldr	r5, [sp, #56]	; 0x38
    59fa:	eb04 0cc5 	add.w	ip, r4, r5, lsl #3
    59fe:	e9dc 0100 	ldrd	r0, r1, [ip]
    5a02:	e9cd 0104 	strd	r0, r1, [sp, #16]

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5a06:	ea4f 2a10 	mov.w	sl, r0, lsr #8
    5a0a:	ea4a 6a01 	orr.w	sl, sl, r1, lsl #24
    5a0e:	9905      	ldr	r1, [sp, #20]
	*(x--) = v;
	v >>= 8;
    5a10:	ea4f 281a 	mov.w	r8, sl, lsr #8

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5a14:	ea4f 2b11 	mov.w	fp, r1, lsr #8
	*(x--) = v;
	v >>= 8;
    5a18:	ea48 680b 	orr.w	r8, r8, fp, lsl #24
    5a1c:	ea4f 291b 	mov.w	r9, fp, lsr #8
	*(x--) = v;
	v >>= 8;
    5a20:	ea4f 2618 	mov.w	r6, r8, lsr #8
    5a24:	ea46 6609 	orr.w	r6, r6, r9, lsl #24
    5a28:	ea4f 2719 	mov.w	r7, r9, lsr #8
	*(x--) = v;
	v >>= 8;
    5a2c:	0a34      	lsrs	r4, r6, #8
    5a2e:	ea44 6407 	orr.w	r4, r4, r7, lsl #24
    5a32:	0a3d      	lsrs	r5, r7, #8
	*(x--) = v;
	v >>= 8;
    5a34:	0a20      	lsrs	r0, r4, #8
    5a36:	ea40 6005 	orr.w	r0, r0, r5, lsl #24
    5a3a:	0a29      	lsrs	r1, r5, #8
	*(x--) = v;
	v >>= 8;
    5a3c:	0a03      	lsrs	r3, r0, #8
    5a3e:	ea43 6c01 	orr.w	ip, r3, r1, lsl #24
    5a42:	ea4f 2e11 	mov.w	lr, r1, lsr #8
	*(x--) = v;
	v >>= 8;
    5a46:	ea4f 231c 	mov.w	r3, ip, lsr #8
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5a4a:	f89d 2010 	ldrb.w	r2, [sp, #16]
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5a4e:	f8cd c018 	str.w	ip, [sp, #24]
	*(x--) = v;
	v >>= 8;
    5a52:	ea43 6c0e 	orr.w	ip, r3, lr, lsl #24
    5a56:	f8cd c010 	str.w	ip, [sp, #16]
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5a5a:	f88d 2067 	strb.w	r2, [sp, #103]	; 0x67
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a5e:	f88d 0062 	strb.w	r0, [sp, #98]	; 0x62
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a62:	f89d 2010 	ldrb.w	r2, [sp, #16]
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a66:	f89d 0018 	ldrb.w	r0, [sp, #24]
	v >>= 8;
	*(x--) = v;
    5a6a:	a91a      	add	r1, sp, #104	; 0x68
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a6c:	f88d 0061 	strb.w	r0, [sp, #97]	; 0x61
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5a70:	f8cd e01c 	str.w	lr, [sp, #28]
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a74:	f88d a066 	strb.w	sl, [sp, #102]	; 0x66
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5a78:	ea4f 2e1e 	mov.w	lr, lr, lsr #8
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a7c:	f88d 8065 	strb.w	r8, [sp, #101]	; 0x65
	v >>= 8;
	*(x--) = v;
    5a80:	f88d 6064 	strb.w	r6, [sp, #100]	; 0x64
	v >>= 8;
	*(x--) = v;
    5a84:	f88d 4063 	strb.w	r4, [sp, #99]	; 0x63
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    5a88:	980f      	ldr	r0, [sp, #60]	; 0x3c
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a8a:	f801 2d08 	strb.w	r2, [r1, #-8]!
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    5a8e:	9a0d      	ldr	r2, [sp, #52]	; 0x34
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5a90:	f8cd e014 	str.w	lr, [sp, #20]
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    5a94:	f000 fe64 	bl	6760 <memcpy>
	}
}
    5a98:	b01b      	add	sp, #108	; 0x6c
    5a9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    5a9e:	bf00      	nop

00005aa0 <failErase>:
    for (i = 0; i < len; i++)
        uart_printf("%02x", data[i]);
    uart_printf("\n");
}

void failErase () {
    5aa0:	b508      	push	{r3, lr}
	// for whatever reason this only flashes upto 0x08008800
	flashErasePage((u32)(0x08008000));
    5aa2:	480a      	ldr	r0, [pc, #40]	; (5acc <failErase+0x2c>)
    5aa4:	f7fb fd36 	bl	1514 <flashErasePage>
	flashErasePage((u32)(0x08008000+1024));
    5aa8:	4809      	ldr	r0, [pc, #36]	; (5ad0 <failErase+0x30>)
    5aaa:	f7fb fd33 	bl	1514 <flashErasePage>
	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
    5aae:	4809      	ldr	r0, [pc, #36]	; (5ad4 <failErase+0x34>)
    5ab0:	f7fb fd30 	bl	1514 <flashErasePage>
	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
    5ab4:	4808      	ldr	r0, [pc, #32]	; (5ad8 <failErase+0x38>)
    5ab6:	f7fb fd2d 	bl	1514 <flashErasePage>
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
    5aba:	4808      	ldr	r0, [pc, #32]	; (5adc <failErase+0x3c>)
    5abc:	f7fb fd2a 	bl	1514 <flashErasePage>
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
}
    5ac0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	flashErasePage((u32)(0x08008000));
	flashErasePage((u32)(0x08008000+1024));
	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
    5ac4:	4806      	ldr	r0, [pc, #24]	; (5ae0 <failErase+0x40>)
    5ac6:	f7fb bd25 	b.w	1514 <flashErasePage>
    5aca:	bf00      	nop
    5acc:	08008000 	stmdaeq	r0, {pc}
    5ad0:	08008400 	stmdaeq	r0, {sl, pc}
    5ad4:	08008320 	stmdaeq	r0, {r5, r8, r9, pc}
    5ad8:	080084b0 	stmdaeq	r0, {r4, r5, r7, sl, pc}
    5adc:	08008640 	stmdaeq	r0, {r6, r9, sl, pc}
    5ae0:	080087d0 	stmdaeq	r0, {r4, r6, r7, r8, r9, sl, pc}

00005ae4 <imageCheckFromAddress>:
}

int imageCheckFromAddress(ImageObjectHandle *newHandle, vu32 flashAddress, bool shouldEraseFlashOnFail)
{
    5ae4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    5ae8:	b0d4      	sub	sp, #336	; 0x150
    5aea:	9101      	str	r1, [sp, #4]
    5aec:	4607      	mov	r7, r0
	ImageRootHeader		*hdr;
	ImageInternalState		state;
	int bufferSize = 0x28+0x40;
	unsigned char imageBuffer[bufferSize];
    memset(imageBuffer, 0xFF, sizeof(imageBuffer));
    5aee:	21ff      	movs	r1, #255	; 0xff
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
}

int imageCheckFromAddress(ImageObjectHandle *newHandle, vu32 flashAddress, bool shouldEraseFlashOnFail)
{
    5af0:	4690      	mov	r8, r2
	ImageRootHeader		*hdr;
	ImageInternalState		state;
	int bufferSize = 0x28+0x40;
	unsigned char imageBuffer[bufferSize];
    memset(imageBuffer, 0xFF, sizeof(imageBuffer));
    5af2:	a83a      	add	r0, sp, #232	; 0xe8
    5af4:	2268      	movs	r2, #104	; 0x68
    5af6:	f000 fe3c 	bl	6772 <memset>
    memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
    memset(&state, 0, sizeof(state));
    5afa:	ae03      	add	r6, sp, #12
	ImageRootHeader		*hdr;
	ImageInternalState		state;
	int bufferSize = 0x28+0x40;
	unsigned char imageBuffer[bufferSize];
    memset(imageBuffer, 0xFF, sizeof(imageBuffer));
    memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
    5afc:	9901      	ldr	r1, [sp, #4]
    5afe:	2268      	movs	r2, #104	; 0x68
    5b00:	a83a      	add	r0, sp, #232	; 0xe8
    5b02:	f000 fe2d 	bl	6760 <memcpy>
    memset(&state, 0, sizeof(state));
    5b06:	2100      	movs	r1, #0
    5b08:	2214      	movs	r2, #20
    5b0a:	4630      	mov	r0, r6
    5b0c:	f000 fe31 	bl	6772 <memset>
		{
			failErase();
		}
		return(EINVAL);		/* buffer too small to really contain header */
	}
	if ((hdr->header.magic) != kImageHeaderMagic) {
    5b10:	993a      	ldr	r1, [sp, #232]	; 0xe8
    5b12:	4a41      	ldr	r2, [pc, #260]	; (5c18 <imageCheckFromAddress+0x134>)
    5b14:	4291      	cmp	r1, r2
    5b16:	d001      	beq.n	5b1c <imageCheckFromAddress+0x38>
		debug_print("bad magic 0x%08x expecting 0x%08x\n", (hdr->header.magic), kImageHeaderMagic);
    5b18:	4840      	ldr	r0, [pc, #256]	; (5c1c <imageCheckFromAddress+0x138>)
    5b1a:	e004      	b.n	5b26 <imageCheckFromAddress+0x42>
			failErase();
		}
		*newHandle = &state;
		return(kImageImageMissingMagic);		/* magic must match */
	}
	if ((hdr->signing.imageType) != 0x45444f53)
    5b1c:	993e      	ldr	r1, [sp, #248]	; 0xf8
    5b1e:	4a40      	ldr	r2, [pc, #256]	; (5c20 <imageCheckFromAddress+0x13c>)
    5b20:	4291      	cmp	r1, r2
    5b22:	d00c      	beq.n	5b3e <imageCheckFromAddress+0x5a>
	{
		debug_print("bad magic 0x%08x expecting 0x%X\n", (hdr->signing.imageType), 0x45444f53);
    5b24:	483f      	ldr	r0, [pc, #252]	; (5c24 <imageCheckFromAddress+0x140>)
    5b26:	f7fb fb67 	bl	11f8 <uart_printf>
		state.flags = kImageImageMissingMagic;
    5b2a:	2304      	movs	r3, #4
    5b2c:	6073      	str	r3, [r6, #4]
		if (shouldEraseFlashOnFail)
    5b2e:	f1b8 0f00 	cmp.w	r8, #0
    5b32:	d001      	beq.n	5b38 <imageCheckFromAddress+0x54>
		{
			failErase();
    5b34:	f7ff ffb4 	bl	5aa0 <failErase>
		}
		*newHandle = &state;
    5b38:	603e      	str	r6, [r7, #0]
		return(kImageImageMissingMagic);		/* magic must match */
    5b3a:	2004      	movs	r0, #4
    5b3c:	e068      	b.n	5c10 <imageCheckFromAddress+0x12c>
	}
	state.flags = kImageImageWasInstantiated;
    5b3e:	2301      	movs	r3, #1
    5b40:	6073      	str	r3, [r6, #4]

	debug_print("dataSize: 0x%X\n", (hdr->header.dataSize));
    5b42:	4839      	ldr	r0, [pc, #228]	; (5c28 <imageCheckFromAddress+0x144>)
    5b44:	993c      	ldr	r1, [sp, #240]	; 0xf0
    5b46:	f7fb fb57 	bl	11f8 <uart_printf>

	state.cursor = hdr->header.dataSize;
    5b4a:	9b3c      	ldr	r3, [sp, #240]	; 0xf0
	state.lastTag = -1;

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5b4c:	2220      	movs	r2, #32
    5b4e:	21ff      	movs	r1, #255	; 0xff
	}
	state.flags = kImageImageWasInstantiated;

	debug_print("dataSize: 0x%X\n", (hdr->header.dataSize));

	state.cursor = hdr->header.dataSize;
    5b50:	60f3      	str	r3, [r6, #12]
	state.lastTag = -1;

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5b52:	a808      	add	r0, sp, #32
	state.flags = kImageImageWasInstantiated;

	debug_print("dataSize: 0x%X\n", (hdr->header.dataSize));

	state.cursor = hdr->header.dataSize;
	state.lastTag = -1;
    5b54:	f04f 33ff 	mov.w	r3, #4294967295
    5b58:	6133      	str	r3, [r6, #16]

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5b5a:	f000 fe0a 	bl	6772 <memset>

    sha256_context ctx;
    sha256_starts(&ctx);
    5b5e:	a820      	add	r0, sp, #128	; 0x80
    5b60:	f7fd fa92 	bl	3088 <sha256_starts>
    int buffSize = 0x1;
    char buff[buffSize];

    int i = 0x84;
    char cmpEnd[5] = {0x01, 0x00, 0x00, 0x00, 0x00}; 
    hexdump((flashAddress+i), 0x10);
    5b64:	9801      	ldr	r0, [sp, #4]
    5b66:	2110      	movs	r1, #16
    5b68:	3084      	adds	r0, #132	; 0x84
    5b6a:	f7fb fb53 	bl	1214 <hexdump>

    int finish = hdr->header.dataSize + 0x84;
    5b6e:	9d3c      	ldr	r5, [sp, #240]	; 0xf0
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
    5b70:	9901      	ldr	r1, [sp, #4]
    5b72:	9a01      	ldr	r2, [sp, #4]

    int i = 0x84;
    char cmpEnd[5] = {0x01, 0x00, 0x00, 0x00, 0x00}; 
    hexdump((flashAddress+i), 0x10);

    int finish = hdr->header.dataSize + 0x84;
    5b74:	3584      	adds	r5, #132	; 0x84
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
    5b76:	482d      	ldr	r0, [pc, #180]	; (5c2c <imageCheckFromAddress+0x148>)
    5b78:	3184      	adds	r1, #132	; 0x84
    5b7a:	442a      	add	r2, r5
    5b7c:	f7fb fb3c 	bl	11f8 <uart_printf>
    sha256_starts(&ctx);

    int buffSize = 0x1;
    char buff[buffSize];

    int i = 0x84;
    5b80:	2484      	movs	r4, #132	; 0x84
    char cmpEnd[5] = {0x01, 0x00, 0x00, 0x00, 0x00}; 
    hexdump((flashAddress+i), 0x10);

    int finish = hdr->header.dataSize + 0x84;
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
    while (i < finish)
    5b82:	42ac      	cmp	r4, r5
    5b84:	da08      	bge.n	5b98 <imageCheckFromAddress+0xb4>
    {
    	memset(buff, 0xFF, buffSize);
    	memcpy(buff, (unsigned char *)(flashAddress+i), buffSize);
    5b86:	9b01      	ldr	r3, [sp, #4]
		  	debug_print("Last block: %X\n", (flashAddress+i));
		  	break;
			}
		hexdump((vu32 *)(flashAddress+i), buffSize);
		}*/
		sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
    5b88:	9901      	ldr	r1, [sp, #4]
    5b8a:	a820      	add	r0, sp, #128	; 0x80
    5b8c:	4421      	add	r1, r4
    5b8e:	2201      	movs	r2, #1
    5b90:	f7ff fa58 	bl	5044 <sha256_update>
		i += 0x1;
    5b94:	3401      	adds	r4, #1
    5b96:	e7f4      	b.n	5b82 <imageCheckFromAddress+0x9e>
    }
    debug_print("Ended at: %X\n", (flashAddress+i));
    5b98:	9901      	ldr	r1, [sp, #4]
    5b9a:	4825      	ldr	r0, [pc, #148]	; (5c30 <imageCheckFromAddress+0x14c>)
    5b9c:	4421      	add	r1, r4
    5b9e:	f7fb fb2b 	bl	11f8 <uart_printf>
    hexdump((vu32 *)(flashAddress+i), 0x10);
    5ba2:	9801      	ldr	r0, [sp, #4]
    5ba4:	2110      	movs	r1, #16
    5ba6:	4420      	add	r0, r4
    5ba8:	f7fb fb34 	bl	1214 <hexdump>
    if ((flashAddress+i) != (flashAddress+finish))
    5bac:	9a01      	ldr	r2, [sp, #4]
    5bae:	9b01      	ldr	r3, [sp, #4]
    5bb0:	4414      	add	r4, r2
    5bb2:	441d      	add	r5, r3
    5bb4:	42ac      	cmp	r4, r5
    5bb6:	d005      	beq.n	5bc4 <imageCheckFromAddress+0xe0>
    {
    	debug_print("Calculated hash is probably wrong...\n");
    5bb8:	481e      	ldr	r0, [pc, #120]	; (5c34 <imageCheckFromAddress+0x150>)
    5bba:	f7fb fb1d 	bl	11f8 <uart_printf>
    	state.flags = kImageImageHashCalcFailed;
    	*newHandle = &state;
    5bbe:	603e      	str	r6, [r7, #0]
		return(kImageImageHashCalcFailed);
    5bc0:	2005      	movs	r0, #5
    5bc2:	e025      	b.n	5c10 <imageCheckFromAddress+0x12c>
	    sha256_update(&ctx, uniqueID, 0x17);
    }

    //debug_print("%s\n", uniqueID);
    
    sha256_finish(&ctx, sha256sum);
    5bc4:	a908      	add	r1, sp, #32
    5bc6:	a820      	add	r0, sp, #128	; 0x80
    5bc8:	f7ff fa84 	bl	50d4 <sha256_finish>
    print_hash(sha256sum);
    // verify signature against recalc hash
    uint8_t sigbuff[0x40];
    memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
    5bcc:	ac10      	add	r4, sp, #64	; 0x40
    }

    //debug_print("%s\n", uniqueID);
    
    sha256_finish(&ctx, sha256sum);
    print_hash(sha256sum);
    5bce:	a808      	add	r0, sp, #32
    // verify signature against recalc hash
    uint8_t sigbuff[0x40];
    memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
    5bd0:	ad3f      	add	r5, sp, #252	; 0xfc
    }

    //debug_print("%s\n", uniqueID);
    
    sha256_finish(&ctx, sha256sum);
    print_hash(sha256sum);
    5bd2:	f7fb fb6d 	bl	12b0 <print_hash>
    // verify signature against recalc hash
    uint8_t sigbuff[0x40];
    memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
    5bd6:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    5bd8:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5bda:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    5bdc:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5bde:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
    5be0:	c40f      	stmia	r4!, {r0, r1, r2, r3}
    5be2:	e895 000f 	ldmia.w	r5, {r0, r1, r2, r3}
    5be6:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}

    if (edsign_verify(sigbuff, rootCA, sha256sum, 32) <= 0) {
    5bea:	a810      	add	r0, sp, #64	; 0x40
    5bec:	4912      	ldr	r1, [pc, #72]	; (5c38 <imageCheckFromAddress+0x154>)
    5bee:	aa08      	add	r2, sp, #32
    5bf0:	2320      	movs	r3, #32
    5bf2:	f7fc f901 	bl	1df8 <edsign_verify>
    5bf6:	b948      	cbnz	r0, 5c0c <imageCheckFromAddress+0x128>
    	state.flags = kImageImageRejectSignature;
    5bf8:	2302      	movs	r3, #2
    5bfa:	6073      	str	r3, [r6, #4]
    	if (shouldEraseFlashOnFail)
    5bfc:	f1b8 0f00 	cmp.w	r8, #0
    5c00:	d001      	beq.n	5c06 <imageCheckFromAddress+0x122>
		{
			failErase();
    5c02:	f7ff ff4d 	bl	5aa0 <failErase>
		}
    	*newHandle = &state;
    5c06:	603e      	str	r6, [r7, #0]
    	return kImageImageRejectSignature;
    5c08:	2002      	movs	r0, #2
    5c0a:	e001      	b.n	5c10 <imageCheckFromAddress+0x12c>
    } else {
    	state.flags = kImageImageIsTrusted;
    	*newHandle = &state;
    5c0c:	603e      	str	r6, [r7, #0]
    	return kImageImageIsTrusted;
    5c0e:	2003      	movs	r0, #3
    }
	
	*newHandle = &state;
	return(0);
}
    5c10:	b054      	add	sp, #336	; 0x150
    5c12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    5c16:	bf00      	nop
    5c18:	45626332 	strbmi	r6, [r2, #-818]!	; 0x332
    5c1c:	00007540 	andeq	r7, r0, r0, asr #10
    5c20:	45444f53 	strbmi	r4, [r4, #-3923]	; 0xf53
    5c24:	00007563 	andeq	r7, r0, r3, ror #10
    5c28:	00007584 	andeq	r7, r0, r4, lsl #11
    5c2c:	00007594 	muleq	r0, r4, r5
    5c30:	000075aa 	andeq	r7, r0, sl, lsr #11
    5c34:	000075b8 			; <UNDEFINED> instruction: 0x000075b8
    5c38:	20000404 	andcs	r0, r0, r4, lsl #8

00005c3c <SetEPTxStatus>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxStatus(u8 bEpNum, u16 wState)
{
  _SetEPTxStatus(bEpNum, wState);
    5c3c:	0080      	lsls	r0, r0, #2
    5c3e:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    5c42:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
    5c46:	6803      	ldr	r3, [r0, #0]
    5c48:	06ca      	lsls	r2, r1, #27
    5c4a:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
    5c4e:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    5c52:	b29b      	uxth	r3, r3
    5c54:	bf48      	it	mi
    5c56:	f083 0310 	eormi.w	r3, r3, #16
    5c5a:	068a      	lsls	r2, r1, #26
    5c5c:	bf48      	it	mi
    5c5e:	f083 0320 	eormi.w	r3, r3, #32
    5c62:	6003      	str	r3, [r0, #0]
    5c64:	4770      	bx	lr

00005c66 <SetEPRxValid>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxValid(u8 bEpNum)
{
  _SetEPRxStatus(bEpNum, EP_RX_VALID);
    5c66:	0080      	lsls	r0, r0, #2
    5c68:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    5c6c:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
    5c70:	6803      	ldr	r3, [r0, #0]
    5c72:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    5c76:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    5c7a:	b29b      	uxth	r3, r3
    5c7c:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
    5c80:	6003      	str	r3, [r0, #0]
    5c82:	4770      	bx	lr

00005c84 <Clear_Status_Out>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void Clear_Status_Out(u8 bEpNum)
{
  _ClearEP_KIND(bEpNum);
    5c84:	0080      	lsls	r0, r0, #2
    5c86:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    5c8a:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
    5c8e:	6803      	ldr	r3, [r0, #0]
    5c90:	f423 43e2 	bic.w	r3, r3, #28928	; 0x7100
    5c94:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    5c98:	041b      	lsls	r3, r3, #16
    5c9a:	0c1b      	lsrs	r3, r3, #16
    5c9c:	6003      	str	r3, [r0, #0]
    5c9e:	4770      	bx	lr

00005ca0 <ClearDTOG_RX>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_RX(u8 bEpNum)
{
  _ClearDTOG_RX(bEpNum);
    5ca0:	0080      	lsls	r0, r0, #2
    5ca2:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    5ca6:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
    5caa:	6803      	ldr	r3, [r0, #0]
    5cac:	045b      	lsls	r3, r3, #17
    5cae:	d506      	bpl.n	5cbe <ClearDTOG_RX+0x1e>
    5cb0:	6802      	ldr	r2, [r0, #0]
    5cb2:	f648 738f 	movw	r3, #36751	; 0x8f8f
    5cb6:	4013      	ands	r3, r2
    5cb8:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
    5cbc:	6003      	str	r3, [r0, #0]
    5cbe:	4770      	bx	lr

00005cc0 <ClearDTOG_TX>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_TX(u8 bEpNum)
{
  _ClearDTOG_TX(bEpNum);
    5cc0:	0080      	lsls	r0, r0, #2
    5cc2:	f100 4080 	add.w	r0, r0, #1073741824	; 0x40000000
    5cc6:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
    5cca:	6803      	ldr	r3, [r0, #0]
    5ccc:	065b      	lsls	r3, r3, #25
    5cce:	d506      	bpl.n	5cde <ClearDTOG_TX+0x1e>
    5cd0:	6802      	ldr	r2, [r0, #0]
    5cd2:	f648 738f 	movw	r3, #36751	; 0x8f8f
    5cd6:	4013      	ands	r3, r2
    5cd8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    5cdc:	6003      	str	r3, [r0, #0]
    5cde:	4770      	bx	lr

00005ce0 <GetEPTxAddr>:
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
u16 GetEPTxAddr(u8 bEpNum)
{
  return(_GetEPTxAddr(bEpNum));
    5ce0:	4b05      	ldr	r3, [pc, #20]	; (5cf8 <GetEPTxAddr+0x18>)
    5ce2:	681b      	ldr	r3, [r3, #0]
    5ce4:	b29b      	uxth	r3, r3
    5ce6:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    5cea:	f100 5000 	add.w	r0, r0, #536870912	; 0x20000000
    5cee:	f500 5040 	add.w	r0, r0, #12288	; 0x3000
    5cf2:	0040      	lsls	r0, r0, #1
}
    5cf4:	8800      	ldrh	r0, [r0, #0]
    5cf6:	4770      	bx	lr
    5cf8:	40005c50 	andmi	r5, r0, r0, asr ip

00005cfc <GetEPRxAddr>:
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
u16 GetEPRxAddr(u8 bEpNum)
{
  return(_GetEPRxAddr(bEpNum));
    5cfc:	4b04      	ldr	r3, [pc, #16]	; (5d10 <GetEPRxAddr+0x14>)
    5cfe:	681b      	ldr	r3, [r3, #0]
    5d00:	b29b      	uxth	r3, r3
    5d02:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    5d06:	4b03      	ldr	r3, [pc, #12]	; (5d14 <GetEPRxAddr+0x18>)
    5d08:	4403      	add	r3, r0
    5d0a:	005b      	lsls	r3, r3, #1
}
    5d0c:	8818      	ldrh	r0, [r3, #0]
    5d0e:	4770      	bx	lr
    5d10:	40005c50 	andmi	r5, r0, r0, asr ip
    5d14:	20003004 	andcs	r3, r0, r4

00005d18 <SetEPTxCount>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxCount(u8 bEpNum, u16 wCount)
{
  _SetEPTxCount(bEpNum, wCount);
    5d18:	4b04      	ldr	r3, [pc, #16]	; (5d2c <SetEPTxCount+0x14>)
    5d1a:	681b      	ldr	r3, [r3, #0]
    5d1c:	b29b      	uxth	r3, r3
    5d1e:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    5d22:	4b03      	ldr	r3, [pc, #12]	; (5d30 <SetEPTxCount+0x18>)
    5d24:	4403      	add	r3, r0
    5d26:	005b      	lsls	r3, r3, #1
    5d28:	6019      	str	r1, [r3, #0]
    5d2a:	4770      	bx	lr
    5d2c:	40005c50 	andmi	r5, r0, r0, asr ip
    5d30:	20003002 	andcs	r3, r0, r2

00005d34 <SetEPRxCount>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxCount(u8 bEpNum, u16 wCount)
{
  _SetEPRxCount(bEpNum, wCount);
    5d34:	4b0d      	ldr	r3, [pc, #52]	; (5d6c <SetEPRxCount+0x38>)
    5d36:	293e      	cmp	r1, #62	; 0x3e
    5d38:	681b      	ldr	r3, [r3, #0]
    5d3a:	b29b      	uxth	r3, r3
    5d3c:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
    5d40:	4b0b      	ldr	r3, [pc, #44]	; (5d70 <SetEPRxCount+0x3c>)
    5d42:	4403      	add	r3, r0
    5d44:	ea4f 0243 	mov.w	r2, r3, lsl #1
    5d48:	d909      	bls.n	5d5e <SetEPRxCount+0x2a>
    5d4a:	094b      	lsrs	r3, r1, #5
    5d4c:	06c8      	lsls	r0, r1, #27
    5d4e:	bf04      	itt	eq
    5d50:	f103 33ff 	addeq.w	r3, r3, #4294967295
    5d54:	b29b      	uxtheq	r3, r3
    5d56:	029b      	lsls	r3, r3, #10
    5d58:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
    5d5c:	e004      	b.n	5d68 <SetEPRxCount+0x34>
    5d5e:	084b      	lsrs	r3, r1, #1
    5d60:	07c9      	lsls	r1, r1, #31
    5d62:	bf48      	it	mi
    5d64:	3301      	addmi	r3, #1
    5d66:	029b      	lsls	r3, r3, #10
    5d68:	6013      	str	r3, [r2, #0]
    5d6a:	4770      	bx	lr
    5d6c:	40005c50 	andmi	r5, r0, r0, asr ip
    5d70:	20003006 	andcs	r3, r0, r6

00005d74 <CTR_LP>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CTR_LP(void)
{
    5d74:	b570      	push	{r4, r5, r6, lr}
  u32 wEPVal = 0;
  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
    5d76:	4a4c      	ldr	r2, [pc, #304]	; (5ea8 <CTR_LP+0x134>)
    5d78:	4b4c      	ldr	r3, [pc, #304]	; (5eac <CTR_LP+0x138>)
    5d7a:	6811      	ldr	r1, [r2, #0]
    5d7c:	b288      	uxth	r0, r1
    5d7e:	040c      	lsls	r4, r1, #16
    5d80:	8018      	strh	r0, [r3, #0]
    5d82:	f140 8090 	bpl.w	5ea6 <CTR_LP+0x132>
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
    5d86:	f647 71ff 	movw	r1, #32767	; 0x7fff
    5d8a:	6011      	str	r1, [r2, #0]
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
    5d8c:	881a      	ldrh	r2, [r3, #0]
    5d8e:	4c48      	ldr	r4, [pc, #288]	; (5eb0 <CTR_LP+0x13c>)
    5d90:	f002 020f 	and.w	r2, r2, #15
    5d94:	7022      	strb	r2, [r4, #0]
    if (EPindex == 0)
    5d96:	2a00      	cmp	r2, #0
    5d98:	d15f      	bne.n	5e5a <CTR_LP+0xe6>
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */
      SaveRState = _GetEPRxStatus(ENDP0);
    5d9a:	4c46      	ldr	r4, [pc, #280]	; (5eb4 <CTR_LP+0x140>)
    5d9c:	4d46      	ldr	r5, [pc, #280]	; (5eb8 <CTR_LP+0x144>)
    5d9e:	6822      	ldr	r2, [r4, #0]
      SaveTState = _GetEPTxStatus(ENDP0);
    5da0:	4e46      	ldr	r6, [pc, #280]	; (5ebc <CTR_LP+0x148>)
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */
      SaveRState = _GetEPRxStatus(ENDP0);
    5da2:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
    5da6:	802a      	strh	r2, [r5, #0]
      SaveTState = _GetEPTxStatus(ENDP0);
    5da8:	6822      	ldr	r2, [r4, #0]
    5daa:	f002 0230 	and.w	r2, r2, #48	; 0x30
    5dae:	8032      	strh	r2, [r6, #0]
      _SetEPRxStatus(ENDP0, EP_RX_NAK);
    5db0:	6822      	ldr	r2, [r4, #0]
    5db2:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    5db6:	f022 0270 	bic.w	r2, r2, #112	; 0x70
    5dba:	b292      	uxth	r2, r2
    5dbc:	f482 5200 	eor.w	r2, r2, #8192	; 0x2000
    5dc0:	6022      	str	r2, [r4, #0]
      _SetEPTxStatus(ENDP0, EP_TX_NAK);
    5dc2:	6822      	ldr	r2, [r4, #0]
    5dc4:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
    5dc8:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    5dcc:	b292      	uxth	r2, r2
    5dce:	f082 0220 	eor.w	r2, r2, #32
    5dd2:	6022      	str	r2, [r4, #0]


      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
    5dd4:	881b      	ldrh	r3, [r3, #0]
    5dd6:	06d8      	lsls	r0, r3, #27
    5dd8:	d502      	bpl.n	5de0 <CTR_LP+0x6c>
        /* DIR = 1 */

        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */

        wEPVal = _GetENDPOINT(ENDP0);
    5dda:	6823      	ldr	r3, [r4, #0]
        if ((wEPVal & EP_CTR_TX) != 0)
    5ddc:	0619      	lsls	r1, r3, #24
    5dde:	d507      	bpl.n	5df0 <CTR_LP+0x7c>
        {
          _ClearEP_CTR_TX(ENDP0);
    5de0:	6822      	ldr	r2, [r4, #0]
    5de2:	f648 730f 	movw	r3, #36623	; 0x8f0f
    5de6:	4013      	ands	r3, r2
    5de8:	6023      	str	r3, [r4, #0]
          In0_Process();
    5dea:	f000 fc61 	bl	66b0 <In0_Process>
    5dee:	e012      	b.n	5e16 <CTR_LP+0xa2>
          /* before terminate set Tx & Rx status */
          _SetEPRxStatus(ENDP0, SaveRState);
          _SetEPTxStatus(ENDP0, SaveTState);
          return;
        }
        else if ((wEPVal &EP_SETUP) != 0)
    5df0:	051a      	lsls	r2, r3, #20
    5df2:	d507      	bpl.n	5e04 <CTR_LP+0x90>
        {
          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
    5df4:	6822      	ldr	r2, [r4, #0]
    5df6:	f640 738f 	movw	r3, #3983	; 0xf8f
    5dfa:	4013      	ands	r3, r2
    5dfc:	6023      	str	r3, [r4, #0]
          Setup0_Process();
    5dfe:	f000 fa69 	bl	62d4 <Setup0_Process>
    5e02:	e008      	b.n	5e16 <CTR_LP+0xa2>
          _SetEPRxStatus(ENDP0, SaveRState);
          _SetEPTxStatus(ENDP0, SaveTState);
          return;
        }

        else if ((wEPVal & EP_CTR_RX) != 0)
    5e04:	0418      	lsls	r0, r3, #16
    5e06:	d5b6      	bpl.n	5d76 <CTR_LP+0x2>
        {
          _ClearEP_CTR_RX(ENDP0);
    5e08:	6822      	ldr	r2, [r4, #0]
    5e0a:	f640 738f 	movw	r3, #3983	; 0xf8f
    5e0e:	4013      	ands	r3, r2
    5e10:	6023      	str	r3, [r4, #0]
          Out0_Process();
    5e12:	f000 fbcd 	bl	65b0 <Out0_Process>
          /* before terminate set Tx & Rx status */
          _SetEPRxStatus(ENDP0, SaveRState);
    5e16:	6823      	ldr	r3, [r4, #0]
    5e18:	882a      	ldrh	r2, [r5, #0]
    5e1a:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    5e1e:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    5e22:	b29b      	uxth	r3, r3
    5e24:	04d1      	lsls	r1, r2, #19
    5e26:	bf48      	it	mi
    5e28:	f483 5380 	eormi.w	r3, r3, #4096	; 0x1000
    5e2c:	0495      	lsls	r5, r2, #18
    5e2e:	4a21      	ldr	r2, [pc, #132]	; (5eb4 <CTR_LP+0x140>)
    5e30:	bf48      	it	mi
    5e32:	f483 5300 	eormi.w	r3, r3, #8192	; 0x2000
    5e36:	6013      	str	r3, [r2, #0]
          _SetEPTxStatus(ENDP0, SaveTState);
    5e38:	6813      	ldr	r3, [r2, #0]
    5e3a:	8831      	ldrh	r1, [r6, #0]
    5e3c:	f423 43e0 	bic.w	r3, r3, #28672	; 0x7000
    5e40:	f023 0340 	bic.w	r3, r3, #64	; 0x40
    5e44:	b29b      	uxth	r3, r3
    5e46:	06cc      	lsls	r4, r1, #27
    5e48:	bf48      	it	mi
    5e4a:	f083 0310 	eormi.w	r3, r3, #16
    5e4e:	0688      	lsls	r0, r1, #26
    5e50:	bf48      	it	mi
    5e52:	f083 0320 	eormi.w	r3, r3, #32
    5e56:	6013      	str	r3, [r2, #0]
          return;
    5e58:	bd70      	pop	{r4, r5, r6, pc}
    else
    {
      /* Decode and service non control endpoints interrupt  */

      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
    5e5a:	0093      	lsls	r3, r2, #2
    5e5c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    5e60:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
    5e64:	681d      	ldr	r5, [r3, #0]
      if ((wEPVal & EP_CTR_RX) != 0)
    5e66:	0429      	lsls	r1, r5, #16
    5e68:	d509      	bpl.n	5e7e <CTR_LP+0x10a>
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
    5e6a:	6818      	ldr	r0, [r3, #0]
    5e6c:	f640 718f 	movw	r1, #3983	; 0xf8f
    5e70:	4001      	ands	r1, r0
    5e72:	6019      	str	r1, [r3, #0]

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
    5e74:	4b12      	ldr	r3, [pc, #72]	; (5ec0 <CTR_LP+0x14c>)
    5e76:	3a01      	subs	r2, #1
    5e78:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
    5e7c:	4798      	blx	r3

      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
    5e7e:	062b      	lsls	r3, r5, #24
    5e80:	f57f af79 	bpl.w	5d76 <CTR_LP+0x2>
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
    5e84:	7821      	ldrb	r1, [r4, #0]
    5e86:	f648 720f 	movw	r2, #36623	; 0x8f0f
    5e8a:	008b      	lsls	r3, r1, #2
    5e8c:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    5e90:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
    5e94:	6818      	ldr	r0, [r3, #0]

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
    5e96:	3901      	subs	r1, #1
      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
    5e98:	4002      	ands	r2, r0
    5e9a:	601a      	str	r2, [r3, #0]

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
    5e9c:	4b09      	ldr	r3, [pc, #36]	; (5ec4 <CTR_LP+0x150>)
    5e9e:	f853 3021 	ldr.w	r3, [r3, r1, lsl #2]
    5ea2:	4798      	blx	r3
    5ea4:	e767      	b.n	5d76 <CTR_LP+0x2>
    5ea6:	bd70      	pop	{r4, r5, r6, pc}
    5ea8:	40005c44 	andmi	r5, r0, r4, asr #24
    5eac:	2000048c 	andcs	r0, r0, ip, lsl #9
    5eb0:	20000584 	andcs	r0, r0, r4, lsl #11
    5eb4:	40005c00 	andmi	r5, r0, r0, lsl #24
    5eb8:	20000576 	andcs	r0, r0, r6, ror r5
    5ebc:	20000578 	andcs	r0, r0, r8, ror r5
    5ec0:	20000064 	andcs	r0, r0, r4, rrx
    5ec4:	20000048 	andcs	r0, r0, r8, asr #32

00005ec8 <USB_Init>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void USB_Init(void)
{
    5ec8:	b508      	push	{r3, lr}
  pInformation = &Device_Info;
    5eca:	4a07      	ldr	r2, [pc, #28]	; (5ee8 <USB_Init+0x20>)
    5ecc:	4b07      	ldr	r3, [pc, #28]	; (5eec <USB_Init+0x24>)
  pInformation->ControlState = 2;
  pProperty = &Device_Property;
  pUser_Standard_Requests = &User_Standard_Requests;
    5ece:	4908      	ldr	r1, [pc, #32]	; (5ef0 <USB_Init+0x28>)
* Output         : None.
* Return         : None.
*******************************************************************************/
void USB_Init(void)
{
  pInformation = &Device_Info;
    5ed0:	6013      	str	r3, [r2, #0]
  pInformation->ControlState = 2;
    5ed2:	2202      	movs	r2, #2
    5ed4:	721a      	strb	r2, [r3, #8]
  pProperty = &Device_Property;
    5ed6:	4b07      	ldr	r3, [pc, #28]	; (5ef4 <USB_Init+0x2c>)
    5ed8:	4a07      	ldr	r2, [pc, #28]	; (5ef8 <USB_Init+0x30>)
    5eda:	6013      	str	r3, [r2, #0]
  pUser_Standard_Requests = &User_Standard_Requests;
    5edc:	4a07      	ldr	r2, [pc, #28]	; (5efc <USB_Init+0x34>)
  /* Initialize devices one by one */

  pProperty->Init();
    5ede:	681b      	ldr	r3, [r3, #0]
void USB_Init(void)
{
  pInformation = &Device_Info;
  pInformation->ControlState = 2;
  pProperty = &Device_Property;
  pUser_Standard_Requests = &User_Standard_Requests;
    5ee0:	6011      	str	r1, [r2, #0]
  /* Initialize devices one by one */

  pProperty->Init();
    5ee2:	4798      	blx	r3
    5ee4:	bd08      	pop	{r3, pc}
    5ee6:	bf00      	nop
    5ee8:	200005a8 	andcs	r0, r0, r8, lsr #11
    5eec:	20000588 	andcs	r0, r0, r8, lsl #11
    5ef0:	20000080 	andcs	r0, r0, r0, lsl #1
    5ef4:	20000014 	andcs	r0, r0, r4, lsl r0
    5ef8:	20000580 	andcs	r0, r0, r0, lsl #11
    5efc:	200005a4 	andcs	r0, r0, r4, lsr #11

00005f00 <Standard_GetConfiguration>:
* Output         : None.
* Return         : Return 1 , if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
u8 *Standard_GetConfiguration(u16 Length)
{
    5f00:	b510      	push	{r4, lr}
    5f02:	4c06      	ldr	r4, [pc, #24]	; (5f1c <Standard_GetConfiguration+0x1c>)
  if (Length == 0)
    5f04:	b918      	cbnz	r0, 5f0e <Standard_GetConfiguration+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength =
    5f06:	6823      	ldr	r3, [r4, #0]
    5f08:	2201      	movs	r2, #1
    5f0a:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_Configuration);
    return 0;
    5f0c:	bd10      	pop	{r4, pc}
  }
  pUser_Standard_Requests->User_GetConfiguration();
    5f0e:	4b04      	ldr	r3, [pc, #16]	; (5f20 <Standard_GetConfiguration+0x20>)
    5f10:	681b      	ldr	r3, [r3, #0]
    5f12:	681b      	ldr	r3, [r3, #0]
    5f14:	4798      	blx	r3
  return (u8 *)&pInformation->Current_Configuration;
    5f16:	6820      	ldr	r0, [r4, #0]
    5f18:	300a      	adds	r0, #10
}
    5f1a:	bd10      	pop	{r4, pc}
    5f1c:	200005a8 	andcs	r0, r0, r8, lsr #11
    5f20:	200005a4 	andcs	r0, r0, r4, lsr #11

00005f24 <Standard_GetInterface>:
* Output         : None.
* Return         : Return 0, if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
u8 *Standard_GetInterface(u16 Length)
{
    5f24:	b510      	push	{r4, lr}
    5f26:	4c06      	ldr	r4, [pc, #24]	; (5f40 <Standard_GetInterface+0x1c>)
  if (Length == 0)
    5f28:	b918      	cbnz	r0, 5f32 <Standard_GetInterface+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength =
    5f2a:	6823      	ldr	r3, [r4, #0]
    5f2c:	2201      	movs	r2, #1
    5f2e:	821a      	strh	r2, [r3, #16]
      sizeof(pInformation->Current_AlternateSetting);
    return 0;
    5f30:	bd10      	pop	{r4, pc}
  }
  pUser_Standard_Requests->User_GetInterface();
    5f32:	4b04      	ldr	r3, [pc, #16]	; (5f44 <Standard_GetInterface+0x20>)
    5f34:	681b      	ldr	r3, [r3, #0]
    5f36:	689b      	ldr	r3, [r3, #8]
    5f38:	4798      	blx	r3
  return (u8 *)&pInformation->Current_AlternateSetting;
    5f3a:	6820      	ldr	r0, [r4, #0]
    5f3c:	300c      	adds	r0, #12
}
    5f3e:	bd10      	pop	{r4, pc}
    5f40:	200005a8 	andcs	r0, r0, r8, lsr #11
    5f44:	200005a4 	andcs	r0, r0, r4, lsr #11

00005f48 <Standard_GetStatus>:
* Output         : None.
* Return         : Return 0, if the request is at end of data block,
*                  or is invalid when "Length" is 0.
*******************************************************************************/
u8 *Standard_GetStatus(u16 Length)
{
    5f48:	b510      	push	{r4, lr}
    5f4a:	4b20      	ldr	r3, [pc, #128]	; (5fcc <Standard_GetStatus+0x84>)
  if (Length == 0)
    5f4c:	b918      	cbnz	r0, 5f56 <Standard_GetStatus+0xe>
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
    5f4e:	681b      	ldr	r3, [r3, #0]
    5f50:	2202      	movs	r2, #2
    5f52:	821a      	strh	r2, [r3, #16]
    return 0;
    5f54:	bd10      	pop	{r4, pc}
  }

  StatusInfo.w = 0;
    5f56:	4a1e      	ldr	r2, [pc, #120]	; (5fd0 <Standard_GetStatus+0x88>)
  /* Reset Status Information */

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    5f58:	6819      	ldr	r1, [r3, #0]
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
    return 0;
  }

  StatusInfo.w = 0;
    5f5a:	2000      	movs	r0, #0
    5f5c:	8010      	strh	r0, [r2, #0]
  /* Reset Status Information */

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    5f5e:	780c      	ldrb	r4, [r1, #0]
    5f60:	4613      	mov	r3, r2
    5f62:	f014 047f 	ands.w	r4, r4, #127	; 0x7f
    5f66:	d10d      	bne.n	5f84 <Standard_GetStatus+0x3c>
  {
    /*Get Device Status */
    u8 Feature = pInformation->Current_Feature;
    5f68:	7a4a      	ldrb	r2, [r1, #9]

    /* Remote Wakeup enabled */
    if (ValBit(Feature, 5))
    5f6a:	0691      	lsls	r1, r2, #26
    {
      SetBit(StatusInfo0, 1);
    5f6c:	bf44      	itt	mi
    5f6e:	2102      	movmi	r1, #2
    5f70:	7019      	strbmi	r1, [r3, #0]
    }

    /* Bus-powered */
    if (ValBit(Feature, 6))
    5f72:	f012 0f40 	tst.w	r2, #64	; 0x40
    {
      ClrBit(StatusInfo0, 0);
    5f76:	781a      	ldrb	r2, [r3, #0]
    5f78:	bf14      	ite	ne
    5f7a:	f022 0201 	bicne.w	r2, r2, #1
    }
    else /* Self-powered */
    {
      SetBit(StatusInfo0, 0);
    5f7e:	f042 0201 	orreq.w	r2, r2, #1
    5f82:	e014      	b.n	5fae <Standard_GetStatus+0x66>
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    5f84:	2c01      	cmp	r4, #1
    5f86:	d01f      	beq.n	5fc8 <Standard_GetStatus+0x80>
  {
    return (u8 *)&StatusInfo;
  }
  /*Get EndPoint Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    5f88:	2c02      	cmp	r4, #2
    5f8a:	d11e      	bne.n	5fca <Standard_GetStatus+0x82>
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;
    5f8c:	7909      	ldrb	r1, [r1, #4]

    Related_Endpoint = (wIndex0 & 0x0f);
    5f8e:	f001 020f 	and.w	r2, r1, #15
    5f92:	0092      	lsls	r2, r2, #2
    if (ValBit(wIndex0, 7))
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5f94:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    5f98:	f502 42b8 	add.w	r2, r2, #23552	; 0x5c00
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;

    Related_Endpoint = (wIndex0 & 0x0f);
    if (ValBit(wIndex0, 7))
    5f9c:	f011 0f80 	tst.w	r1, #128	; 0x80
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5fa0:	6812      	ldr	r2, [r2, #0]
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;

    Related_Endpoint = (wIndex0 & 0x0f);
    if (ValBit(wIndex0, 7))
    5fa2:	d006      	beq.n	5fb2 <Standard_GetStatus+0x6a>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5fa4:	f002 0230 	and.w	r2, r2, #48	; 0x30
    5fa8:	2a10      	cmp	r2, #16
    5faa:	d107      	bne.n	5fbc <Standard_GetStatus+0x74>
      {
        SetBit(StatusInfo0, 0); /* IN Endpoint stalled */
    5fac:	2201      	movs	r2, #1
    5fae:	701a      	strb	r2, [r3, #0]
    5fb0:	e004      	b.n	5fbc <Standard_GetStatus+0x74>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
    5fb2:	f402 5240 	and.w	r2, r2, #12288	; 0x3000
    5fb6:	f5b2 5f80 	cmp.w	r2, #4096	; 0x1000
    5fba:	e7f6      	b.n	5faa <Standard_GetStatus+0x62>
  }
  else
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
    5fbc:	4b05      	ldr	r3, [pc, #20]	; (5fd4 <Standard_GetStatus+0x8c>)
    5fbe:	681b      	ldr	r3, [r3, #0]
    5fc0:	691b      	ldr	r3, [r3, #16]
    5fc2:	4798      	blx	r3
  return (u8 *)&StatusInfo;
    5fc4:	4802      	ldr	r0, [pc, #8]	; (5fd0 <Standard_GetStatus+0x88>)
    5fc6:	bd10      	pop	{r4, pc}
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
  {
    return (u8 *)&StatusInfo;
    5fc8:	4610      	mov	r0, r2
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
  return (u8 *)&StatusInfo;
}
    5fca:	bd10      	pop	{r4, pc}
    5fcc:	200005a8 	andcs	r0, r0, r8, lsr #11
    5fd0:	200005ae 	andcs	r0, r0, lr, lsr #11
    5fd4:	200005a4 	andcs	r0, r0, r4, lsr #11

00005fd8 <DataStageIn>:
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
    5fd8:	4a23      	ldr	r2, [pc, #140]	; (6068 <DataStageIn+0x90>)
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
    5fda:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
    5fde:	6814      	ldr	r4, [r2, #0]
    5fe0:	4690      	mov	r8, r2
  u32 save_wLength = pEPinfo->Usb_wLength;
    5fe2:	8a23      	ldrh	r3, [r4, #16]
  u32 ControlState = pInformation->ControlState;
    5fe4:	7a26      	ldrb	r6, [r4, #8]
    5fe6:	4f21      	ldr	r7, [pc, #132]	; (606c <DataStageIn+0x94>)

  u8 *DataBuffer;
  u32 Length;

  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
    5fe8:	b9a3      	cbnz	r3, 6014 <DataStageIn+0x3c>
    5fea:	2e04      	cmp	r6, #4
    5fec:	d112      	bne.n	6014 <DataStageIn+0x3c>
  {
    if(Data_Mul_MaxPacketSize == TRUE)
    5fee:	4920      	ldr	r1, [pc, #128]	; (6070 <DataStageIn+0x98>)
    5ff0:	780a      	ldrb	r2, [r1, #0]
    5ff2:	2a01      	cmp	r2, #1
    5ff4:	d10a      	bne.n	600c <DataStageIn+0x34>
    {
      /* No more data to send and empty packet */
      Send0LengthData();
    5ff6:	4a1f      	ldr	r2, [pc, #124]	; (6074 <DataStageIn+0x9c>)
    5ff8:	6810      	ldr	r0, [r2, #0]
    5ffa:	4a1f      	ldr	r2, [pc, #124]	; (6078 <DataStageIn+0xa0>)
    5ffc:	b280      	uxth	r0, r0
    5ffe:	4402      	add	r2, r0
    6000:	0052      	lsls	r2, r2, #1
    6002:	6013      	str	r3, [r2, #0]
    6004:	2230      	movs	r2, #48	; 0x30
    6006:	803a      	strh	r2, [r7, #0]
      ControlState = LAST_IN_DATA;
      Data_Mul_MaxPacketSize = FALSE;
    6008:	700b      	strb	r3, [r1, #0]
    600a:	e027      	b.n	605c <DataStageIn+0x84>
    }
    else
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
      vSetEPTxStatus(EP_TX_STALL);
    600c:	2310      	movs	r3, #16
    600e:	803b      	strh	r3, [r7, #0]
      Data_Mul_MaxPacketSize = FALSE;
    }
    else
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
    6010:	2607      	movs	r6, #7
    6012:	e023      	b.n	605c <DataStageIn+0x84>
    }

    goto Expect_Status_Out;
  }

  Length = pEPinfo->PacketSize;
    6014:	8aa5      	ldrh	r5, [r4, #20]
  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
    6016:	42ab      	cmp	r3, r5
    6018:	bf8c      	ite	hi
    601a:	2602      	movhi	r6, #2
    601c:	2604      	movls	r6, #4
  if (Length > save_wLength)
  {
    Length = save_wLength;
  }

  DataBuffer = (*pEPinfo->CopyData)(Length);
    601e:	429d      	cmp	r5, r3
    6020:	bf28      	it	cs
    6022:	461d      	movcs	r5, r3
    6024:	4628      	mov	r0, r5
    6026:	69a3      	ldr	r3, [r4, #24]
    6028:	4798      	blx	r3
    602a:	4681      	mov	r9, r0

  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
    602c:	2000      	movs	r0, #0
    602e:	f7ff fe57 	bl	5ce0 <GetEPTxAddr>
    6032:	462a      	mov	r2, r5
    6034:	4601      	mov	r1, r0
    6036:	4648      	mov	r0, r9
    6038:	f000 fb68 	bl	670c <UserToPMABufferCopy>

  SetEPTxCount(ENDP0, Length);
    603c:	4629      	mov	r1, r5
    603e:	2000      	movs	r0, #0
    6040:	f7ff fe6a 	bl	5d18 <SetEPTxCount>

  pEPinfo->Usb_wLength -= Length;
    6044:	8a23      	ldrh	r3, [r4, #16]
  pEPinfo->Usb_wOffset += Length;
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */
    6046:	f44f 5240 	mov.w	r2, #12288	; 0x3000

  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
    604a:	1b5b      	subs	r3, r3, r5
    604c:	8223      	strh	r3, [r4, #16]
  pEPinfo->Usb_wOffset += Length;
    604e:	8a63      	ldrh	r3, [r4, #18]
    6050:	441d      	add	r5, r3
  vSetEPTxStatus(EP_TX_VALID);
    6052:	2330      	movs	r3, #48	; 0x30
    6054:	803b      	strh	r3, [r7, #0]

  USB_StatusOut();/* Expect the host to abort the data IN stage */
    6056:	4b09      	ldr	r3, [pc, #36]	; (607c <DataStageIn+0xa4>)
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
  pEPinfo->Usb_wOffset += Length;
    6058:	8265      	strh	r5, [r4, #18]
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */
    605a:	801a      	strh	r2, [r3, #0]

Expect_Status_Out:
  pInformation->ControlState = ControlState;
    605c:	f8d8 3000 	ldr.w	r3, [r8]
    6060:	721e      	strb	r6, [r3, #8]
    6062:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6066:	bf00      	nop
    6068:	200005a8 	andcs	r0, r0, r8, lsr #11
    606c:	20000578 	andcs	r0, r0, r8, ror r5
    6070:	20000dcc 	andcs	r0, r0, ip, asr #27
    6074:	40005c50 	andmi	r5, r0, r0, asr ip
    6078:	20003002 	andcs	r3, r0, r2
    607c:	20000576 	andcs	r0, r0, r6, ror r5

00006080 <Standard_SetConfiguration>:
* Output         : None.
* Return         : Return USB_SUCCESS, if the request is performed.
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{
    6080:	b510      	push	{r4, lr}

  if ((pInformation->USBwValue0 <=
    6082:	4b0a      	ldr	r3, [pc, #40]	; (60ac <Standard_SetConfiguration+0x2c>)
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
    6084:	490a      	ldr	r1, [pc, #40]	; (60b0 <Standard_SetConfiguration+0x30>)
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{

  if ((pInformation->USBwValue0 <=
    6086:	681b      	ldr	r3, [r3, #0]
    6088:	7849      	ldrb	r1, [r1, #1]
    608a:	789a      	ldrb	r2, [r3, #2]
    608c:	4291      	cmp	r1, r2
    608e:	d30a      	bcc.n	60a6 <Standard_SetConfiguration+0x26>
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
    6090:	78d9      	ldrb	r1, [r3, #3]
    6092:	b941      	cbnz	r1, 60a6 <Standard_SetConfiguration+0x26>
      && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
    6094:	889c      	ldrh	r4, [r3, #4]
    6096:	b934      	cbnz	r4, 60a6 <Standard_SetConfiguration+0x26>
  {
    pInformation->Current_Configuration = pInformation->USBwValue0;
    6098:	729a      	strb	r2, [r3, #10]
    pUser_Standard_Requests->User_SetConfiguration();
    609a:	4b06      	ldr	r3, [pc, #24]	; (60b4 <Standard_SetConfiguration+0x34>)
    609c:	681b      	ldr	r3, [r3, #0]
    609e:	685b      	ldr	r3, [r3, #4]
    60a0:	4798      	blx	r3
    return USB_SUCCESS;
    60a2:	4620      	mov	r0, r4
    60a4:	bd10      	pop	{r4, pc}
  }
  else
  {
    return USB_UNSUPPORT;
    60a6:	2002      	movs	r0, #2
  }
}
    60a8:	bd10      	pop	{r4, pc}
    60aa:	bf00      	nop
    60ac:	200005a8 	andcs	r0, r0, r8, lsr #11
    60b0:	200000a4 	andcs	r0, r0, r4, lsr #1
    60b4:	200005a4 	andcs	r0, r0, r4, lsr #11

000060b8 <Standard_SetInterface>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetInterface(void)
{
    60b8:	b538      	push	{r3, r4, r5, lr}
  RESULT Re;
  /*Test if the specified Interface and Alternate Setting are supported by
    the application Firmware*/
  Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
    60ba:	4a0e      	ldr	r2, [pc, #56]	; (60f4 <Standard_SetInterface+0x3c>)
    60bc:	4c0e      	ldr	r4, [pc, #56]	; (60f8 <Standard_SetInterface+0x40>)
    60be:	6812      	ldr	r2, [r2, #0]
    60c0:	6823      	ldr	r3, [r4, #0]
    60c2:	6992      	ldr	r2, [r2, #24]
    60c4:	7918      	ldrb	r0, [r3, #4]
    60c6:	7899      	ldrb	r1, [r3, #2]
    60c8:	4790      	blx	r2

  if (pInformation->Current_Configuration != 0)
    60ca:	6823      	ldr	r3, [r4, #0]
    60cc:	7a9a      	ldrb	r2, [r3, #10]
    60ce:	b17a      	cbz	r2, 60f0 <Standard_SetInterface+0x38>
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
    60d0:	b970      	cbnz	r0, 60f0 <Standard_SetInterface+0x38>
    60d2:	795a      	ldrb	r2, [r3, #5]
    60d4:	b962      	cbnz	r2, 60f0 <Standard_SetInterface+0x38>
        || (pInformation->USBwValue1 != 0))
    60d6:	78dd      	ldrb	r5, [r3, #3]
    60d8:	b955      	cbnz	r5, 60f0 <Standard_SetInterface+0x38>
    {
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
    60da:	4b08      	ldr	r3, [pc, #32]	; (60fc <Standard_SetInterface+0x44>)
    60dc:	681b      	ldr	r3, [r3, #0]
    60de:	68db      	ldr	r3, [r3, #12]
    60e0:	4798      	blx	r3
      pInformation->Current_Interface = pInformation->USBwIndex0;
    60e2:	6823      	ldr	r3, [r4, #0]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
      return USB_SUCCESS;
    60e4:	4628      	mov	r0, r5
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
      pInformation->Current_Interface = pInformation->USBwIndex0;
    60e6:	791a      	ldrb	r2, [r3, #4]
    60e8:	72da      	strb	r2, [r3, #11]
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
    60ea:	789a      	ldrb	r2, [r3, #2]
    60ec:	731a      	strb	r2, [r3, #12]
      return USB_SUCCESS;
    60ee:	bd38      	pop	{r3, r4, r5, pc}
    }

  }

  return USB_UNSUPPORT;
    60f0:	2002      	movs	r0, #2
}
    60f2:	bd38      	pop	{r3, r4, r5, pc}
    60f4:	20000580 	andcs	r0, r0, r0, lsl #11
    60f8:	200005a8 	andcs	r0, r0, r8, lsr #11
    60fc:	200005a4 	andcs	r0, r0, r4, lsr #11

00006100 <Standard_ClearFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_ClearFeature(void)
{
    6100:	b538      	push	{r3, r4, r5, lr}
  u32     Type_Rec = Type_Recipient;
    6102:	4b2f      	ldr	r3, [pc, #188]	; (61c0 <Standard_ClearFeature+0xc0>)
    6104:	681b      	ldr	r3, [r3, #0]
    6106:	7818      	ldrb	r0, [r3, #0]
  u32     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6108:	f010 007f 	ands.w	r0, r0, #127	; 0x7f
    610c:	d104      	bne.n	6118 <Standard_ClearFeature+0x18>
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
    610e:	7a5a      	ldrb	r2, [r3, #9]
    6110:	f022 0220 	bic.w	r2, r2, #32
    6114:	725a      	strb	r2, [r3, #9]
    return USB_SUCCESS;
    6116:	bd38      	pop	{r3, r4, r5, pc}
  }
  else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    6118:	2802      	cmp	r0, #2
    611a:	d14e      	bne.n	61ba <Standard_ClearFeature+0xba>
    DEVICE* pDev;
    u32 Related_Endpoint;
    u32 wIndex0;
    u32 rEP;

    if ((pInformation->USBwValue != ENDPOINT_STALL)
    611c:	885a      	ldrh	r2, [r3, #2]
    611e:	2a00      	cmp	r2, #0
    6120:	d14c      	bne.n	61bc <Standard_ClearFeature+0xbc>
        || (pInformation->USBwIndex1 != 0))
    6122:	795a      	ldrb	r2, [r3, #5]
    6124:	2a00      	cmp	r2, #0
    6126:	d149      	bne.n	61bc <Standard_ClearFeature+0xbc>
    {
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    6128:	791a      	ldrb	r2, [r3, #4]
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    612a:	4d26      	ldr	r5, [pc, #152]	; (61c4 <Standard_ClearFeature+0xc4>)
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    rEP = wIndex0 & ~0x80;
    612c:	f022 0080 	bic.w	r0, r2, #128	; 0x80
    6130:	0084      	lsls	r4, r0, #2

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
    6132:	f104 4180 	add.w	r1, r4, #1073741824	; 0x40000000
    6136:	f501 41b8 	add.w	r1, r1, #23552	; 0x5c00
    613a:	6809      	ldr	r1, [r1, #0]
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    613c:	782d      	ldrb	r5, [r5, #0]
    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    rEP = wIndex0 & ~0x80;
    Related_Endpoint = ENDP0 + rEP;

    if (ValBit(pInformation->USBwIndex0, 7))
    613e:	f012 0f80 	tst.w	r2, #128	; 0x80
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
    6142:	bf14      	ite	ne
    6144:	f001 0130 	andne.w	r1, r1, #48	; 0x30
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    6148:	f401 5140 	andeq.w	r1, r1, #12288	; 0x3000
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    614c:	42a8      	cmp	r0, r5
    614e:	d234      	bcs.n	61ba <Standard_ClearFeature+0xba>
    6150:	2900      	cmp	r1, #0
    6152:	d032      	beq.n	61ba <Standard_ClearFeature+0xba>
        || (pInformation->Current_Configuration == 0))
    6154:	7a9b      	ldrb	r3, [r3, #10]
    6156:	b383      	cbz	r3, 61ba <Standard_ClearFeature+0xba>


    if (wIndex0 & 0x80)
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    6158:	f104 4480 	add.w	r4, r4, #1073741824	; 0x40000000
    615c:	f504 44b8 	add.w	r4, r4, #23552	; 0x5c00
    {
      return USB_UNSUPPORT;
    }


    if (wIndex0 & 0x80)
    6160:	0612      	lsls	r2, r2, #24
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    6162:	6823      	ldr	r3, [r4, #0]
    {
      return USB_UNSUPPORT;
    }


    if (wIndex0 & 0x80)
    6164:	d50c      	bpl.n	6180 <Standard_ClearFeature+0x80>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    6166:	f003 0330 	and.w	r3, r3, #48	; 0x30
    616a:	2b10      	cmp	r3, #16
    616c:	d11f      	bne.n	61ae <Standard_ClearFeature+0xae>
      {
        ClearDTOG_TX(Related_Endpoint);
    616e:	b2c4      	uxtb	r4, r0
    6170:	4620      	mov	r0, r4
    6172:	f7ff fda5 	bl	5cc0 <ClearDTOG_TX>
        SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
    6176:	4620      	mov	r0, r4
    6178:	2130      	movs	r1, #48	; 0x30
    617a:	f7ff fd5f 	bl	5c3c <SetEPTxStatus>
    617e:	e016      	b.n	61ae <Standard_ClearFeature+0xae>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
    6180:	f403 5340 	and.w	r3, r3, #12288	; 0x3000
    6184:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    6188:	d111      	bne.n	61ae <Standard_ClearFeature+0xae>
      {
        if (Related_Endpoint == ENDP0)
    618a:	b928      	cbnz	r0, 6198 <Standard_ClearFeature+0x98>
        {
          /* After clear the STALL, enable the default endpoint receiver */
          SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
    618c:	4b0e      	ldr	r3, [pc, #56]	; (61c8 <Standard_ClearFeature+0xc8>)
    618e:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
    6192:	f7ff fdcf 	bl	5d34 <SetEPRxCount>
    6196:	e001      	b.n	619c <Standard_ClearFeature+0x9c>
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
        }
        else
        {
          ClearDTOG_RX(Related_Endpoint);
    6198:	f7ff fd82 	bl	5ca0 <ClearDTOG_RX>
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
    619c:	6823      	ldr	r3, [r4, #0]
    619e:	f423 4380 	bic.w	r3, r3, #16384	; 0x4000
    61a2:	f023 0370 	bic.w	r3, r3, #112	; 0x70
    61a6:	b29b      	uxth	r3, r3
    61a8:	f483 5340 	eor.w	r3, r3, #12288	; 0x3000
    61ac:	6023      	str	r3, [r4, #0]
        }
      }
    }
    pUser_Standard_Requests->User_ClearFeature();
    61ae:	4b07      	ldr	r3, [pc, #28]	; (61cc <Standard_ClearFeature+0xcc>)
    61b0:	681b      	ldr	r3, [r3, #0]
    61b2:	695b      	ldr	r3, [r3, #20]
    61b4:	4798      	blx	r3
    return USB_SUCCESS;
    61b6:	2000      	movs	r0, #0
    61b8:	bd38      	pop	{r3, r4, r5, pc}
  }

  return USB_UNSUPPORT;
    61ba:	2002      	movs	r0, #2
}
    61bc:	bd38      	pop	{r3, r4, r5, pc}
    61be:	bf00      	nop
    61c0:	200005a8 	andcs	r0, r0, r8, lsr #11
    61c4:	200000a4 	andcs	r0, r0, r4, lsr #1
    61c8:	20000014 	andcs	r0, r0, r4, lsl r0
    61cc:	200005a4 	andcs	r0, r0, r4, lsr #11

000061d0 <Standard_SetEndPointFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetEndPointFeature(void)
{
    61d0:	b538      	push	{r3, r4, r5, lr}
  u32    wIndex0;
  u32    Related_Endpoint;
  u32    rEP;
  u32   Status;

  wIndex0 = pInformation->USBwIndex0;
    61d2:	4b1d      	ldr	r3, [pc, #116]	; (6248 <Standard_SetEndPointFeature+0x78>)
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    61d4:	4d1d      	ldr	r5, [pc, #116]	; (624c <Standard_SetEndPointFeature+0x7c>)
  u32    wIndex0;
  u32    Related_Endpoint;
  u32    rEP;
  u32   Status;

  wIndex0 = pInformation->USBwIndex0;
    61d6:	6819      	ldr	r1, [r3, #0]
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    61d8:	782d      	ldrb	r5, [r5, #0]
  u32    wIndex0;
  u32    Related_Endpoint;
  u32    rEP;
  u32   Status;

  wIndex0 = pInformation->USBwIndex0;
    61da:	790a      	ldrb	r2, [r1, #4]
  rEP = wIndex0 & ~0x80;
    61dc:	f022 0480 	bic.w	r4, r2, #128	; 0x80
    61e0:	00a3      	lsls	r3, r4, #2

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
    61e2:	f103 4080 	add.w	r0, r3, #1073741824	; 0x40000000
    61e6:	f500 40b8 	add.w	r0, r0, #23552	; 0x5c00
    61ea:	6800      	ldr	r0, [r0, #0]

  wIndex0 = pInformation->USBwIndex0;
  rEP = wIndex0 & ~0x80;
  Related_Endpoint = ENDP0 + rEP;

  if (ValBit(pInformation->USBwIndex0, 7))
    61ec:	f012 0f80 	tst.w	r2, #128	; 0x80
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
    61f0:	bf14      	ite	ne
    61f2:	f000 0030 	andne.w	r0, r0, #48	; 0x30
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
    61f6:	f400 5040 	andeq.w	r0, r0, #12288	; 0x3000
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    61fa:	42ac      	cmp	r4, r5
    61fc:	d222      	bcs.n	6244 <Standard_SetEndPointFeature+0x74>
      || pInformation->USBwValue != 0 || Status == 0
    61fe:	884c      	ldrh	r4, [r1, #2]
    6200:	bb04      	cbnz	r4, 6244 <Standard_SetEndPointFeature+0x74>
    6202:	b1f8      	cbz	r0, 6244 <Standard_SetEndPointFeature+0x74>
      || pInformation->Current_Configuration == 0)
    6204:	7a89      	ldrb	r1, [r1, #10]
    6206:	b1e9      	cbz	r1, 6244 <Standard_SetEndPointFeature+0x74>
  else
  {
    if (wIndex0 & 0x80)
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6208:	f103 4380 	add.w	r3, r3, #1073741824	; 0x40000000
    620c:	f503 43b8 	add.w	r3, r3, #23552	; 0x5c00
  {
    return USB_UNSUPPORT;
  }
  else
  {
    if (wIndex0 & 0x80)
    6210:	f012 0f80 	tst.w	r2, #128	; 0x80
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6214:	681a      	ldr	r2, [r3, #0]
  {
    return USB_UNSUPPORT;
  }
  else
  {
    if (wIndex0 & 0x80)
    6216:	d007      	beq.n	6228 <Standard_SetEndPointFeature+0x58>
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6218:	f422 42e0 	bic.w	r2, r2, #28672	; 0x7000
    621c:	f022 0240 	bic.w	r2, r2, #64	; 0x40
    6220:	b292      	uxth	r2, r2
    6222:	f082 0210 	eor.w	r2, r2, #16
    6226:	e006      	b.n	6236 <Standard_SetEndPointFeature+0x66>
    }

    else
    {
      /* OUT endpoint */
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    6228:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
    622c:	f022 0270 	bic.w	r2, r2, #112	; 0x70
    6230:	b292      	uxth	r2, r2
    6232:	f482 5280 	eor.w	r2, r2, #4096	; 0x1000
    6236:	601a      	str	r2, [r3, #0]
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
    6238:	4b05      	ldr	r3, [pc, #20]	; (6250 <Standard_SetEndPointFeature+0x80>)
    623a:	681b      	ldr	r3, [r3, #0]
    623c:	699b      	ldr	r3, [r3, #24]
    623e:	4798      	blx	r3
  return USB_SUCCESS;
    6240:	2000      	movs	r0, #0
    6242:	bd38      	pop	{r3, r4, r5, pc}

  if (Related_Endpoint >= Device_Table.Total_Endpoint
      || pInformation->USBwValue != 0 || Status == 0
      || pInformation->Current_Configuration == 0)
  {
    return USB_UNSUPPORT;
    6244:	2002      	movs	r0, #2
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
  return USB_SUCCESS;
}
    6246:	bd38      	pop	{r3, r4, r5, pc}
    6248:	200005a8 	andcs	r0, r0, r8, lsr #11
    624c:	200000a4 	andcs	r0, r0, r4, lsr #1
    6250:	200005a4 	andcs	r0, r0, r4, lsr #11

00006254 <Standard_SetDeviceFeature>:
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetDeviceFeature(void)
{
    6254:	b508      	push	{r3, lr}
  SetBit(pInformation->Current_Feature, 5);
    6256:	4b06      	ldr	r3, [pc, #24]	; (6270 <Standard_SetDeviceFeature+0x1c>)
    6258:	681b      	ldr	r3, [r3, #0]
    625a:	7a5a      	ldrb	r2, [r3, #9]
    625c:	f042 0220 	orr.w	r2, r2, #32
    6260:	725a      	strb	r2, [r3, #9]
  pUser_Standard_Requests->User_SetDeviceFeature();
    6262:	4b04      	ldr	r3, [pc, #16]	; (6274 <Standard_SetDeviceFeature+0x20>)
    6264:	681b      	ldr	r3, [r3, #0]
    6266:	69db      	ldr	r3, [r3, #28]
    6268:	4798      	blx	r3
  return USB_SUCCESS;
}
    626a:	2000      	movs	r0, #0
    626c:	bd08      	pop	{r3, pc}
    626e:	bf00      	nop
    6270:	200005a8 	andcs	r0, r0, r8, lsr #11
    6274:	200005a4 	andcs	r0, r0, r4, lsr #11

00006278 <Standard_GetDescriptorData>:
*******************************************************************************/
u8 *Standard_GetDescriptorData(u16 Length, ONE_DESCRIPTOR *pDesc)
{
  u32  wOffset;

  wOffset = pInformation->Ctrl_Info.Usb_wOffset;
    6278:	4b05      	ldr	r3, [pc, #20]	; (6290 <Standard_GetDescriptorData+0x18>)
    627a:	681a      	ldr	r2, [r3, #0]
    627c:	8a53      	ldrh	r3, [r2, #18]
  if (Length == 0)
    627e:	b918      	cbnz	r0, 6288 <Standard_GetDescriptorData+0x10>
  {
    pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
    6280:	8889      	ldrh	r1, [r1, #4]
    6282:	1acb      	subs	r3, r1, r3
    6284:	8213      	strh	r3, [r2, #16]
    return 0;
    6286:	4770      	bx	lr
  }

  return pDesc->Descriptor + wOffset;
    6288:	6808      	ldr	r0, [r1, #0]
    628a:	4418      	add	r0, r3
}
    628c:	4770      	bx	lr
    628e:	bf00      	nop
    6290:	200005a8 	andcs	r0, r0, r8, lsr #11

00006294 <Post0_Process>:
* Output         : None.
* Return         : - 0 if the control State is in PAUSE
*                  - 1 if not.
*******************************************************************************/
u8 Post0_Process(void)
{
    6294:	b508      	push	{r3, lr}
  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
    6296:	4b0b      	ldr	r3, [pc, #44]	; (62c4 <Post0_Process+0x30>)
    6298:	2000      	movs	r0, #0
    629a:	f893 1030 	ldrb.w	r1, [r3, #48]	; 0x30
    629e:	f7ff fd49 	bl	5d34 <SetEPRxCount>

  if (pInformation->ControlState == STALLED)
    62a2:	4b09      	ldr	r3, [pc, #36]	; (62c8 <Post0_Process+0x34>)
    62a4:	681b      	ldr	r3, [r3, #0]
    62a6:	7a18      	ldrb	r0, [r3, #8]
    62a8:	2808      	cmp	r0, #8
    62aa:	d106      	bne.n	62ba <Post0_Process+0x26>
  {
    vSetEPRxStatus(EP_RX_STALL);
    62ac:	4b07      	ldr	r3, [pc, #28]	; (62cc <Post0_Process+0x38>)
    62ae:	f44f 5280 	mov.w	r2, #4096	; 0x1000
    62b2:	801a      	strh	r2, [r3, #0]
    vSetEPTxStatus(EP_TX_STALL);
    62b4:	4b06      	ldr	r3, [pc, #24]	; (62d0 <Post0_Process+0x3c>)
    62b6:	2210      	movs	r2, #16
    62b8:	801a      	strh	r2, [r3, #0]
  }

  return (pInformation->ControlState == PAUSE);
}
    62ba:	f1b0 0309 	subs.w	r3, r0, #9
    62be:	4258      	negs	r0, r3
    62c0:	4158      	adcs	r0, r3
    62c2:	bd08      	pop	{r3, pc}
    62c4:	20000014 	andcs	r0, r0, r4, lsl r0
    62c8:	200005a8 	andcs	r0, r0, r8, lsr #11
    62cc:	20000576 	andcs	r0, r0, r6, ror r5
    62d0:	20000578 	andcs	r0, r0, r8, ror r5

000062d4 <Setup0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 Setup0_Process(void)
{
    62d4:	b573      	push	{r0, r1, r4, r5, r6, lr}
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    62d6:	4e96      	ldr	r6, [pc, #600]	; (6530 <Setup0_Process+0x25c>)
    62d8:	4b96      	ldr	r3, [pc, #600]	; (6534 <Setup0_Process+0x260>)
    62da:	6832      	ldr	r2, [r6, #0]

  if (pInformation->ControlState != PAUSE)
    62dc:	4d96      	ldr	r5, [pc, #600]	; (6538 <Setup0_Process+0x264>)
    62de:	b292      	uxth	r2, r2
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    62e0:	4413      	add	r3, r2
    62e2:	005b      	lsls	r3, r3, #1
    62e4:	681a      	ldr	r2, [r3, #0]

  if (pInformation->ControlState != PAUSE)
    62e6:	682b      	ldr	r3, [r5, #0]
    62e8:	7a19      	ldrb	r1, [r3, #8]
    62ea:	2909      	cmp	r1, #9
    62ec:	d00f      	beq.n	630e <Setup0_Process+0x3a>
    62ee:	b292      	uxth	r2, r2
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    62f0:	0052      	lsls	r2, r2, #1
    62f2:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    62f6:	f502 42c0 	add.w	r2, r2, #24576	; 0x6000

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
    62fa:	7811      	ldrb	r1, [r2, #0]
    62fc:	7019      	strb	r1, [r3, #0]
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
    62fe:	7851      	ldrb	r1, [r2, #1]
    6300:	7059      	strb	r1, [r3, #1]
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = *pBuf.w++; /* wValue in Little Endian */
    6302:	8891      	ldrh	r1, [r2, #4]
    6304:	8059      	strh	r1, [r3, #2]
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = *pBuf.w++; /* wIndex in Little Endian */
    6306:	8911      	ldrh	r1, [r2, #8]
    6308:	8099      	strh	r1, [r3, #4]
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwLength = *pBuf.w; /* wLength in Little Endian */
    630a:	8992      	ldrh	r2, [r2, #12]
    630c:	80da      	strh	r2, [r3, #6]
  }

  pInformation->ControlState = SETTING_UP;
    630e:	2201      	movs	r2, #1
    6310:	721a      	strb	r2, [r3, #8]
  if (pInformation->USBwLength == 0)
    6312:	88da      	ldrh	r2, [r3, #6]
    6314:	785c      	ldrb	r4, [r3, #1]
    6316:	2a00      	cmp	r2, #0
    6318:	d161      	bne.n	63de <Setup0_Process+0x10a>
{
  RESULT Result = USB_UNSUPPORT;
  u32 RequestNo = pInformation->USBbRequest;
  u32 ControlState;

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    631a:	781a      	ldrb	r2, [r3, #0]
    631c:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
    6320:	d13a      	bne.n	6398 <Setup0_Process+0xc4>
  {
    /* Device Request*/
    /* SET_CONFIGURATION*/
    if (RequestNo == SET_CONFIGURATION)
    6322:	2c09      	cmp	r4, #9
    6324:	d102      	bne.n	632c <Setup0_Process+0x58>
    {
      Result = Standard_SetConfiguration();
    6326:	f7ff feab 	bl	6080 <Standard_SetConfiguration>
    632a:	e044      	b.n	63b6 <Setup0_Process+0xe2>
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    632c:	2c05      	cmp	r4, #5
    632e:	d10f      	bne.n	6350 <Setup0_Process+0x7c>
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
    6330:	f993 2002 	ldrsb.w	r2, [r3, #2]
    6334:	2a00      	cmp	r2, #0
    6336:	da01      	bge.n	633c <Setup0_Process+0x68>
          || (pInformation->USBwIndex != 0)
          || (pInformation->Current_Configuration != 0))
        /* Device Address should be 127 or less*/
      {
        ControlState = STALLED;
    6338:	2308      	movs	r3, #8
    633a:	e04d      	b.n	63d8 <Setup0_Process+0x104>
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
    633c:	78da      	ldrb	r2, [r3, #3]
    633e:	2a00      	cmp	r2, #0
    6340:	d1fa      	bne.n	6338 <Setup0_Process+0x64>
          || (pInformation->USBwIndex != 0)
    6342:	889a      	ldrh	r2, [r3, #4]
    6344:	2a00      	cmp	r2, #0
    6346:	d1f7      	bne.n	6338 <Setup0_Process+0x64>
          || (pInformation->Current_Configuration != 0))
    6348:	7a9b      	ldrb	r3, [r3, #10]
    634a:	2b00      	cmp	r3, #0
    634c:	d037      	beq.n	63be <Setup0_Process+0xea>
    634e:	e7f3      	b.n	6338 <Setup0_Process+0x64>
      {
        Result = USB_SUCCESS;
      }
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    6350:	2c03      	cmp	r4, #3
    6352:	d113      	bne.n	637c <Setup0_Process+0xa8>
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
    6354:	789a      	ldrb	r2, [r3, #2]
    6356:	2a01      	cmp	r2, #1
    6358:	d007      	beq.n	636a <Setup0_Process+0x96>
  }


  if (Result != USB_SUCCESS)
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    635a:	4b78      	ldr	r3, [pc, #480]	; (653c <Setup0_Process+0x268>)
    635c:	4620      	mov	r0, r4
    635e:	681b      	ldr	r3, [r3, #0]
    6360:	695b      	ldr	r3, [r3, #20]
    6362:	4798      	blx	r3
    if (Result == USB_NOT_READY)
    6364:	2803      	cmp	r0, #3
    6366:	d128      	bne.n	63ba <Setup0_Process+0xe6>
    6368:	e035      	b.n	63d6 <Setup0_Process+0x102>
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
          && (pInformation->USBwIndex == 0)
    636a:	889a      	ldrh	r2, [r3, #4]
    636c:	2a00      	cmp	r2, #0
    636e:	d1f4      	bne.n	635a <Setup0_Process+0x86>
          && (ValBit(pInformation->Current_Feature, 5)))
    6370:	7a5b      	ldrb	r3, [r3, #9]
    6372:	0698      	lsls	r0, r3, #26
    6374:	d5f1      	bpl.n	635a <Setup0_Process+0x86>
      {
        Result = Standard_SetDeviceFeature();
    6376:	f7ff ff6d 	bl	6254 <Standard_SetDeviceFeature>
    637a:	e01c      	b.n	63b6 <Setup0_Process+0xe2>
      {
        Result = USB_UNSUPPORT;
      }
    }
    /*Clear FEATURE for Device */
    else if (RequestNo == CLEAR_FEATURE)
    637c:	2c01      	cmp	r4, #1
    637e:	d1ec      	bne.n	635a <Setup0_Process+0x86>
    {
      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
    6380:	789a      	ldrb	r2, [r3, #2]
    6382:	2a01      	cmp	r2, #1
    6384:	d1e9      	bne.n	635a <Setup0_Process+0x86>
          && pInformation->USBwIndex == 0
    6386:	889a      	ldrh	r2, [r3, #4]
    6388:	2a00      	cmp	r2, #0
    638a:	d1e6      	bne.n	635a <Setup0_Process+0x86>
          && ValBit(pInformation->Current_Feature, 5))
    638c:	7a5b      	ldrb	r3, [r3, #9]
    638e:	0699      	lsls	r1, r3, #26
    6390:	d5e3      	bpl.n	635a <Setup0_Process+0x86>
      {
        Result = Standard_ClearFeature();
    6392:	f7ff feb5 	bl	6100 <Standard_ClearFeature>
    6396:	e00e      	b.n	63b6 <Setup0_Process+0xe2>
    }

  }

  /* Interface Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    6398:	2a01      	cmp	r2, #1
    639a:	d104      	bne.n	63a6 <Setup0_Process+0xd2>
  {
    /*SET INTERFACE*/
    if (RequestNo == SET_INTERFACE)
    639c:	2c0b      	cmp	r4, #11
    639e:	d1dc      	bne.n	635a <Setup0_Process+0x86>
    {
      Result = Standard_SetInterface();
    63a0:	f7ff fe8a 	bl	60b8 <Standard_SetInterface>
    63a4:	e007      	b.n	63b6 <Setup0_Process+0xe2>
    }
  }

  /* EndPoint Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    63a6:	2a02      	cmp	r2, #2
    63a8:	d1d7      	bne.n	635a <Setup0_Process+0x86>
  {
    /*CLEAR FEATURE for EndPoint*/
    if (RequestNo == CLEAR_FEATURE)
    63aa:	2c01      	cmp	r4, #1
    63ac:	d0f1      	beq.n	6392 <Setup0_Process+0xbe>
    {
      Result = Standard_ClearFeature();
    }
    /* SET FEATURE for EndPoint*/
    else if (RequestNo == SET_FEATURE)
    63ae:	2c03      	cmp	r4, #3
    63b0:	d1d3      	bne.n	635a <Setup0_Process+0x86>
    {
      Result = Standard_SetEndPointFeature();
    63b2:	f7ff ff0d 	bl	61d0 <Standard_SetEndPointFeature>
  {
    Result = USB_UNSUPPORT;
  }


  if (Result != USB_SUCCESS)
    63b6:	b110      	cbz	r0, 63be <Setup0_Process+0xea>
    63b8:	e7cf      	b.n	635a <Setup0_Process+0x86>
      ControlState = PAUSE;
      goto exit_NoData_Setup0;
    }
  }

  if (Result != USB_SUCCESS)
    63ba:	2800      	cmp	r0, #0
    63bc:	d1bc      	bne.n	6338 <Setup0_Process+0x64>
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();
    63be:	6832      	ldr	r2, [r6, #0]
    63c0:	4b5f      	ldr	r3, [pc, #380]	; (6540 <Setup0_Process+0x26c>)
    63c2:	b292      	uxth	r2, r2
    63c4:	4413      	add	r3, r2
    63c6:	005b      	lsls	r3, r3, #1
    63c8:	2200      	movs	r2, #0
    63ca:	601a      	str	r2, [r3, #0]
    63cc:	4b5d      	ldr	r3, [pc, #372]	; (6544 <Setup0_Process+0x270>)
    63ce:	2230      	movs	r2, #48	; 0x30
    63d0:	801a      	strh	r2, [r3, #0]
  {
    ControlState = STALLED;
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
    63d2:	2306      	movs	r3, #6
    63d4:	e000      	b.n	63d8 <Setup0_Process+0x104>
  if (Result != USB_SUCCESS)
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    if (Result == USB_NOT_READY)
    {
      ControlState = PAUSE;
    63d6:	2309      	movs	r3, #9
  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();

exit_NoData_Setup0:
  pInformation->ControlState = ControlState;
    63d8:	682a      	ldr	r2, [r5, #0]
    63da:	7213      	strb	r3, [r2, #8]
    63dc:	e0d4      	b.n	6588 <Setup0_Process+0x2b4>


  CopyRoutine = NULL;
  wOffset = 0;

  if (Request_No == GET_DESCRIPTOR)
    63de:	2c06      	cmp	r4, #6
    63e0:	d118      	bne.n	6414 <Setup0_Process+0x140>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    63e2:	781a      	ldrb	r2, [r3, #0]
    63e4:	0652      	lsls	r2, r2, #25
    63e6:	d17c      	bne.n	64e2 <Setup0_Process+0x20e>
    {
      u8 wValue1 = pInformation->USBwValue1;
    63e8:	78da      	ldrb	r2, [r3, #3]
    63ea:	4b54      	ldr	r3, [pc, #336]	; (653c <Setup0_Process+0x268>)
      if (wValue1 == DEVICE_DESCRIPTOR)
    63ec:	2a01      	cmp	r2, #1
    63ee:	d102      	bne.n	63f6 <Setup0_Process+0x122>
      {
        CopyRoutine = pProperty->GetDeviceDescriptor;
    63f0:	681b      	ldr	r3, [r3, #0]
    63f2:	69db      	ldr	r3, [r3, #28]
    63f4:	e06c      	b.n	64d0 <Setup0_Process+0x1fc>
      }
      else if (wValue1 == CONFIG_DESCRIPTOR)
    63f6:	2a02      	cmp	r2, #2
    63f8:	d102      	bne.n	6400 <Setup0_Process+0x12c>
      {
        CopyRoutine = pProperty->GetConfigDescriptor;
    63fa:	681b      	ldr	r3, [r3, #0]
    63fc:	6a1b      	ldr	r3, [r3, #32]
    63fe:	e067      	b.n	64d0 <Setup0_Process+0x1fc>
      }
      else if (wValue1 == STRING_DESCRIPTOR)
    6400:	2a03      	cmp	r2, #3
    6402:	d102      	bne.n	640a <Setup0_Process+0x136>
      {
        CopyRoutine = pProperty->GetStringDescriptor;
    6404:	681b      	ldr	r3, [r3, #0]
    6406:	6a5b      	ldr	r3, [r3, #36]	; 0x24
    6408:	e062      	b.n	64d0 <Setup0_Process+0x1fc>
      } else if (wValue1 == 0x21) /* added to support functional descriptors */
    640a:	2a21      	cmp	r2, #33	; 0x21
    640c:	d169      	bne.n	64e2 <Setup0_Process+0x20e>
      {
	CopyRoutine = pProperty->GetFunctionalDescriptor;
    640e:	681b      	ldr	r3, [r3, #0]
    6410:	6a9b      	ldr	r3, [r3, #40]	; 0x28
    6412:	e05d      	b.n	64d0 <Setup0_Process+0x1fc>
      } /* End of GET_DESCRIPTOR */
    }
  }

  /*GET STATUS*/
  else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
    6414:	2c00      	cmp	r4, #0
    6416:	d13c      	bne.n	6492 <Setup0_Process+0x1be>
    6418:	8859      	ldrh	r1, [r3, #2]
    641a:	2900      	cmp	r1, #0
    641c:	d161      	bne.n	64e2 <Setup0_Process+0x20e>
           && (pInformation->USBwLength == 0x0002)
           && (pInformation->USBwIndex1 == 0))
    641e:	685a      	ldr	r2, [r3, #4]
    6420:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
    6424:	f5b2 3f00 	cmp.w	r2, #131072	; 0x20000
    6428:	d15b      	bne.n	64e2 <Setup0_Process+0x20e>
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    642a:	781a      	ldrb	r2, [r3, #0]
    642c:	f012 027f 	ands.w	r2, r2, #127	; 0x7f
    6430:	d104      	bne.n	643c <Setup0_Process+0x168>
        && (pInformation->USBwIndex == 0))
    6432:	889b      	ldrh	r3, [r3, #4]
    6434:	2b00      	cmp	r3, #0
    6436:	f000 80ab 	beq.w	6590 <Setup0_Process+0x2bc>
    643a:	e052      	b.n	64e2 <Setup0_Process+0x20e>
    {
      CopyRoutine = Standard_GetStatus;
    }

    /* GET STATUS for Interface*/
    else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    643c:	2a01      	cmp	r2, #1
    643e:	d10c      	bne.n	645a <Setup0_Process+0x186>
    {
      if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
    6440:	4a3e      	ldr	r2, [pc, #248]	; (653c <Setup0_Process+0x268>)
    6442:	7918      	ldrb	r0, [r3, #4]
    6444:	6812      	ldr	r2, [r2, #0]
    6446:	6992      	ldr	r2, [r2, #24]
    6448:	4790      	blx	r2
    644a:	2800      	cmp	r0, #0
    644c:	d149      	bne.n	64e2 <Setup0_Process+0x20e>
          && (pInformation->Current_Configuration != 0))
    644e:	682b      	ldr	r3, [r5, #0]
    6450:	7a9b      	ldrb	r3, [r3, #10]
    6452:	2b00      	cmp	r3, #0
    6454:	f040 809c 	bne.w	6590 <Setup0_Process+0x2bc>
    6458:	e043      	b.n	64e2 <Setup0_Process+0x20e>
        CopyRoutine = Standard_GetStatus;
      }
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    645a:	2a02      	cmp	r2, #2
    645c:	d141      	bne.n	64e2 <Setup0_Process+0x20e>
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
    645e:	791b      	ldrb	r3, [r3, #4]
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    6460:	4839      	ldr	r0, [pc, #228]	; (6548 <Setup0_Process+0x274>)
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
    6462:	f003 010f 	and.w	r1, r3, #15
    6466:	008a      	lsls	r2, r1, #2

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
    6468:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
    646c:	f502 42b8 	add.w	r2, r2, #23552	; 0x5c00
    6470:	6812      	ldr	r2, [r2, #0]
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    6472:	7800      	ldrb	r0, [r0, #0]
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
      Reserved = pInformation->USBwIndex0 & 0x70;

      if (ValBit(pInformation->USBwIndex0, 7))
    6474:	f013 0f80 	tst.w	r3, #128	; 0x80
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
    6478:	bf14      	ite	ne
    647a:	f002 0230 	andne.w	r2, r2, #48	; 0x30
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
    647e:	f402 5240 	andeq.w	r2, r2, #12288	; 0x3000
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    6482:	4281      	cmp	r1, r0
    6484:	d22d      	bcs.n	64e2 <Setup0_Process+0x20e>
    6486:	f013 0f70 	tst.w	r3, #112	; 0x70
    648a:	d12a      	bne.n	64e2 <Setup0_Process+0x20e>
          && (Status != 0))
    648c:	2a00      	cmp	r2, #0
    648e:	d17f      	bne.n	6590 <Setup0_Process+0x2bc>
    6490:	e027      	b.n	64e2 <Setup0_Process+0x20e>
    }

  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
    6492:	2c08      	cmp	r4, #8
    6494:	d103      	bne.n	649e <Setup0_Process+0x1ca>
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6496:	781b      	ldrb	r3, [r3, #0]
    6498:	065b      	lsls	r3, r3, #25
    649a:	d07b      	beq.n	6594 <Setup0_Process+0x2c0>
    649c:	e021      	b.n	64e2 <Setup0_Process+0x20e>
    {
      CopyRoutine = Standard_GetConfiguration;
    }
  }
  /*GET INTERFACE*/
  else if (Request_No == GET_INTERFACE)
    649e:	2c0a      	cmp	r4, #10
    64a0:	d11f      	bne.n	64e2 <Setup0_Process+0x20e>
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    64a2:	781a      	ldrb	r2, [r3, #0]
    64a4:	f002 027f 	and.w	r2, r2, #127	; 0x7f
    64a8:	2a01      	cmp	r2, #1
    64aa:	d11a      	bne.n	64e2 <Setup0_Process+0x20e>
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
    64ac:	7a9a      	ldrb	r2, [r3, #10]
    64ae:	b1c2      	cbz	r2, 64e2 <Setup0_Process+0x20e>
    64b0:	8859      	ldrh	r1, [r3, #2]
    64b2:	b9b1      	cbnz	r1, 64e2 <Setup0_Process+0x20e>
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
    64b4:	685a      	ldr	r2, [r3, #4]
    64b6:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
    64ba:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
    64be:	d110      	bne.n	64e2 <Setup0_Process+0x20e>
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
    64c0:	4a1e      	ldr	r2, [pc, #120]	; (653c <Setup0_Process+0x268>)
    64c2:	7918      	ldrb	r0, [r3, #4]
    64c4:	6812      	ldr	r2, [r2, #0]
    64c6:	6992      	ldr	r2, [r2, #24]
    64c8:	4790      	blx	r2
    64ca:	2800      	cmp	r0, #0
    64cc:	d064      	beq.n	6598 <Setup0_Process+0x2c4>
    64ce:	e008      	b.n	64e2 <Setup0_Process+0x20e>
      CopyRoutine = Standard_GetInterface;
    }

  }

  if (CopyRoutine)
    64d0:	b13b      	cbz	r3, 64e2 <Setup0_Process+0x20e>
  {
    pInformation->Ctrl_Info.Usb_wOffset = wOffset;
    64d2:	682a      	ldr	r2, [r5, #0]
    64d4:	2400      	movs	r4, #0
    64d6:	8254      	strh	r4, [r2, #18]
    pInformation->Ctrl_Info.CopyData = CopyRoutine;
    64d8:	6193      	str	r3, [r2, #24]
    /* sb in the original the cast to word was directly */
    /* now the cast is made step by step */
    (*CopyRoutine)(0);
    64da:	4620      	mov	r0, r4
    64dc:	4798      	blx	r3
    Result = USB_SUCCESS;
    64de:	4620      	mov	r0, r4
    64e0:	e00a      	b.n	64f8 <Setup0_Process+0x224>
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
    64e2:	4b16      	ldr	r3, [pc, #88]	; (653c <Setup0_Process+0x268>)
    64e4:	681a      	ldr	r2, [r3, #0]
    64e6:	682b      	ldr	r3, [r5, #0]
    64e8:	6912      	ldr	r2, [r2, #16]
    64ea:	7858      	ldrb	r0, [r3, #1]
    64ec:	4790      	blx	r2
    if (Result == USB_NOT_READY)
    64ee:	2803      	cmp	r0, #3
    64f0:	d102      	bne.n	64f8 <Setup0_Process+0x224>
    {
      pInformation->ControlState = PAUSE;
    64f2:	4b11      	ldr	r3, [pc, #68]	; (6538 <Setup0_Process+0x264>)
    64f4:	681b      	ldr	r3, [r3, #0]
    64f6:	e005      	b.n	6504 <Setup0_Process+0x230>
      return;
    }
  }

  if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
    64f8:	682b      	ldr	r3, [r5, #0]
    64fa:	f64f 71ff 	movw	r1, #65535	; 0xffff
    64fe:	8a1a      	ldrh	r2, [r3, #16]
    6500:	428a      	cmp	r2, r1
    6502:	d101      	bne.n	6508 <Setup0_Process+0x234>
  {
    /* Data is not ready, wait it */
    pInformation->ControlState = PAUSE;
    6504:	2209      	movs	r2, #9
    6506:	e003      	b.n	6510 <Setup0_Process+0x23c>
    return;
  }
  if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
    6508:	2802      	cmp	r0, #2
    650a:	d000      	beq.n	650e <Setup0_Process+0x23a>
    650c:	b912      	cbnz	r2, 6514 <Setup0_Process+0x240>
  {
    /* Unsupported request */
    pInformation->ControlState = STALLED;
    650e:	2208      	movs	r2, #8
    6510:	721a      	strb	r2, [r3, #8]
    6512:	e039      	b.n	6588 <Setup0_Process+0x2b4>
    return;
  }


  if (ValBit(pInformation->USBbmRequestType, 7))
    6514:	f993 1000 	ldrsb.w	r1, [r3]
    6518:	2900      	cmp	r1, #0
    651a:	da2f      	bge.n	657c <Setup0_Process+0x2a8>
  {
    /* Device ==> Host */
    vu32 wLength = pInformation->USBwLength;
    651c:	88d9      	ldrh	r1, [r3, #6]
    651e:	9101      	str	r1, [sp, #4]

    /* Restrict the data length to be the one host asks */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
    6520:	9801      	ldr	r0, [sp, #4]
    6522:	4282      	cmp	r2, r0
    6524:	4805      	ldr	r0, [pc, #20]	; (653c <Setup0_Process+0x268>)
    6526:	d911      	bls.n	654c <Setup0_Process+0x278>
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
    6528:	9a01      	ldr	r2, [sp, #4]
    652a:	821a      	strh	r2, [r3, #16]
    652c:	e01f      	b.n	656e <Setup0_Process+0x29a>
    652e:	bf00      	nop
    6530:	40005c50 	andmi	r5, r0, r0, asr ip
    6534:	20003004 	andcs	r3, r0, r4
    6538:	200005a8 	andcs	r0, r0, r8, lsr #11
    653c:	20000580 	andcs	r0, r0, r0, lsl #11
    6540:	20003002 	andcs	r3, r0, r2
    6544:	20000578 	andcs	r0, r0, r8, ror r5
    6548:	200000a4 	andcs	r0, r0, r4, lsr #1
    }

    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
    654c:	428a      	cmp	r2, r1
    654e:	d20e      	bcs.n	656e <Setup0_Process+0x29a>
    {
      if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
    6550:	6801      	ldr	r1, [r0, #0]
    6552:	f891 1030 	ldrb.w	r1, [r1, #48]	; 0x30
    6556:	428a      	cmp	r2, r1
    6558:	d201      	bcs.n	655e <Setup0_Process+0x28a>
      {
        Data_Mul_MaxPacketSize = FALSE;
    655a:	2100      	movs	r1, #0
    655c:	e005      	b.n	656a <Setup0_Process+0x296>
      }
      else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
    655e:	fb92 f4f1 	sdiv	r4, r2, r1
    6562:	fb01 2214 	mls	r2, r1, r4, r2
    6566:	b912      	cbnz	r2, 656e <Setup0_Process+0x29a>
      {
        Data_Mul_MaxPacketSize = TRUE;
    6568:	2101      	movs	r1, #1
    656a:	4a0c      	ldr	r2, [pc, #48]	; (659c <Setup0_Process+0x2c8>)
    656c:	7011      	strb	r1, [r2, #0]
      }
    }

    pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
    656e:	6802      	ldr	r2, [r0, #0]
    6570:	f892 2030 	ldrb.w	r2, [r2, #48]	; 0x30
    6574:	829a      	strh	r2, [r3, #20]
    DataStageIn();
    6576:	f7ff fd2f 	bl	5fd8 <DataStageIn>
    657a:	e005      	b.n	6588 <Setup0_Process+0x2b4>
  }
  else
  {
    pInformation->ControlState = OUT_DATA;
    657c:	2203      	movs	r2, #3
    657e:	721a      	strb	r2, [r3, #8]
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
    6580:	4b07      	ldr	r3, [pc, #28]	; (65a0 <Setup0_Process+0x2cc>)
    6582:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    6586:	801a      	strh	r2, [r3, #0]
  else
  {
    /* Setup with data stage */
    Data_Setup0();
  }
  return Post0_Process();
    6588:	f7ff fe84 	bl	6294 <Post0_Process>
}
    658c:	b002      	add	sp, #8
    658e:	bd70      	pop	{r4, r5, r6, pc}
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
        && (pInformation->USBwIndex == 0))
    {
      CopyRoutine = Standard_GetStatus;
    6590:	4b04      	ldr	r3, [pc, #16]	; (65a4 <Setup0_Process+0x2d0>)
    6592:	e79e      	b.n	64d2 <Setup0_Process+0x1fe>
  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    {
      CopyRoutine = Standard_GetConfiguration;
    6594:	4b04      	ldr	r3, [pc, #16]	; (65a8 <Setup0_Process+0x2d4>)
    6596:	e79c      	b.n	64d2 <Setup0_Process+0x1fe>
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
    {
      CopyRoutine = Standard_GetInterface;
    6598:	4b04      	ldr	r3, [pc, #16]	; (65ac <Setup0_Process+0x2d8>)
    659a:	e79a      	b.n	64d2 <Setup0_Process+0x1fe>
    659c:	20000dcc 	andcs	r0, r0, ip, asr #27
    65a0:	20000576 	andcs	r0, r0, r6, ror r5
    65a4:	00005f49 	andeq	r5, r0, r9, asr #30
    65a8:	00005f01 	andeq	r5, r0, r1, lsl #30
    65ac:	00005f25 	andeq	r5, r0, r5, lsr #30

000065b0 <Out0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 Out0_Process(void)
{
    65b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  u32 ControlState = pInformation->ControlState;
    65b2:	4d2b      	ldr	r5, [pc, #172]	; (6660 <Out0_Process+0xb0>)
    65b4:	682c      	ldr	r4, [r5, #0]
    65b6:	7a23      	ldrb	r3, [r4, #8]

  if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
    65b8:	2b03      	cmp	r3, #3
    65ba:	d001      	beq.n	65c0 <Out0_Process+0x10>
    65bc:	2b05      	cmp	r3, #5
    65be:	d141      	bne.n	6644 <Out0_Process+0x94>
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  u32 save_rLength;

  save_rLength = pEPinfo->Usb_rLength;

  if (pEPinfo->CopyData && save_rLength)
    65c0:	69a3      	ldr	r3, [r4, #24]
void DataStageOut(void)
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  u32 save_rLength;

  save_rLength = pEPinfo->Usb_rLength;
    65c2:	8a22      	ldrh	r2, [r4, #16]

  if (pEPinfo->CopyData && save_rLength)
    65c4:	b1ab      	cbz	r3, 65f2 <Out0_Process+0x42>
    65c6:	b1a2      	cbz	r2, 65f2 <Out0_Process+0x42>
  {
    u8 *Buffer;
    u32 Length;

    Length = pEPinfo->PacketSize;
    65c8:	8aa6      	ldrh	r6, [r4, #20]
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    65ca:	4296      	cmp	r6, r2
    65cc:	bf28      	it	cs
    65ce:	4616      	movcs	r6, r2
    65d0:	4630      	mov	r0, r6
    65d2:	4798      	blx	r3
    pEPinfo->Usb_rLength -= Length;
    65d4:	8a23      	ldrh	r3, [r4, #16]
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    65d6:	4607      	mov	r7, r0
    pEPinfo->Usb_rLength -= Length;
    65d8:	1b9b      	subs	r3, r3, r6
    65da:	8223      	strh	r3, [r4, #16]
    pEPinfo->Usb_rOffset += Length;
    65dc:	8a63      	ldrh	r3, [r4, #18]

    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
    65de:	2000      	movs	r0, #0
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    pEPinfo->Usb_rLength -= Length;
    pEPinfo->Usb_rOffset += Length;
    65e0:	4433      	add	r3, r6
    65e2:	8263      	strh	r3, [r4, #18]

    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
    65e4:	f7ff fb8a 	bl	5cfc <GetEPRxAddr>
    65e8:	4632      	mov	r2, r6
    65ea:	4601      	mov	r1, r0
    65ec:	4638      	mov	r0, r7
    65ee:	f000 f8a5 	bl	673c <PMAToUserBufferCopy>
  }

  if (pEPinfo->Usb_rLength != 0)
    65f2:	8a23      	ldrh	r3, [r4, #16]
    65f4:	b153      	cbz	r3, 660c <Out0_Process+0x5c>
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    65f6:	4b1b      	ldr	r3, [pc, #108]	; (6664 <Out0_Process+0xb4>)
    SetEPTxCount(ENDP0, 0);
    65f8:	2000      	movs	r0, #0
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
  }

  if (pEPinfo->Usb_rLength != 0)
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    65fa:	f44f 5240 	mov.w	r2, #12288	; 0x3000
    SetEPTxCount(ENDP0, 0);
    65fe:	4601      	mov	r1, r0
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
  }

  if (pEPinfo->Usb_rLength != 0)
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    6600:	801a      	strh	r2, [r3, #0]
    SetEPTxCount(ENDP0, 0);
    6602:	f7ff fb89 	bl	5d18 <SetEPTxCount>
    vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
    6606:	4b18      	ldr	r3, [pc, #96]	; (6668 <Out0_Process+0xb8>)
    6608:	2230      	movs	r2, #48	; 0x30
    660a:	801a      	strh	r2, [r3, #0]
  }
  /* Set the next State*/
  if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
    660c:	8a23      	ldrh	r3, [r4, #16]
    660e:	8aa2      	ldrh	r2, [r4, #20]
    6610:	429a      	cmp	r2, r3
    6612:	d802      	bhi.n	661a <Out0_Process+0x6a>
  {
    pInformation->ControlState = OUT_DATA;
    6614:	682b      	ldr	r3, [r5, #0]
    6616:	2203      	movs	r2, #3
    6618:	e002      	b.n	6620 <Out0_Process+0x70>
  }
  else
  {
    if (pEPinfo->Usb_rLength > 0)
    661a:	b11b      	cbz	r3, 6624 <Out0_Process+0x74>
    {
      pInformation->ControlState = LAST_OUT_DATA;
    661c:	682b      	ldr	r3, [r5, #0]
    661e:	2205      	movs	r2, #5
    6620:	721a      	strb	r2, [r3, #8]
    6622:	e00c      	b.n	663e <Out0_Process+0x8e>
    }
    else if (pEPinfo->Usb_rLength == 0)
    {
      pInformation->ControlState = WAIT_STATUS_IN;
    6624:	682a      	ldr	r2, [r5, #0]
    6626:	2106      	movs	r1, #6
    6628:	7211      	strb	r1, [r2, #8]
      USB_StatusIn();
    662a:	4a10      	ldr	r2, [pc, #64]	; (666c <Out0_Process+0xbc>)
    662c:	6811      	ldr	r1, [r2, #0]
    662e:	4a10      	ldr	r2, [pc, #64]	; (6670 <Out0_Process+0xc0>)
    6630:	b289      	uxth	r1, r1
    6632:	440a      	add	r2, r1
    6634:	0052      	lsls	r2, r2, #1
    6636:	6013      	str	r3, [r2, #0]
    6638:	4b0b      	ldr	r3, [pc, #44]	; (6668 <Out0_Process+0xb8>)
    663a:	2230      	movs	r2, #48	; 0x30
    663c:	801a      	strh	r2, [r3, #0]
  u32 ControlState = pInformation->ControlState;

  if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
  {
    DataStageOut();
    ControlState = pInformation->ControlState; /* may be changed outside the function */
    663e:	682b      	ldr	r3, [r5, #0]
    6640:	7a1b      	ldrb	r3, [r3, #8]
    6642:	e006      	b.n	6652 <Out0_Process+0xa2>
  }

  else if (ControlState == WAIT_STATUS_OUT)
    6644:	2b07      	cmp	r3, #7
    6646:	d103      	bne.n	6650 <Out0_Process+0xa0>
  {
    (*pProperty->Process_Status_OUT)();
    6648:	4b0a      	ldr	r3, [pc, #40]	; (6674 <Out0_Process+0xc4>)
    664a:	681b      	ldr	r3, [r3, #0]
    664c:	68db      	ldr	r3, [r3, #12]
    664e:	4798      	blx	r3
  }

  else if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
  {
    /* host aborts the transfer before finish */
    ControlState = STALLED;
    6650:	2308      	movs	r3, #8
  else
  {
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;
    6652:	682a      	ldr	r2, [r5, #0]
    6654:	7213      	strb	r3, [r2, #8]

  return Post0_Process();
}
    6656:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
    665a:	f7ff be1b 	b.w	6294 <Post0_Process>
    665e:	bf00      	nop
    6660:	200005a8 	andcs	r0, r0, r8, lsr #11
    6664:	20000576 	andcs	r0, r0, r6, ror r5
    6668:	20000578 	andcs	r0, r0, r8, ror r5
    666c:	40005c50 	andmi	r5, r0, r0, asr ip
    6670:	20003002 	andcs	r3, r0, r2
    6674:	20000580 	andcs	r0, r0, r0, lsl #11

00006678 <SetDeviceAddress>:
* Input          : - Val: device adress.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetDeviceAddress(u8 Val)
{
    6678:	b530      	push	{r4, r5, lr}
  u32 i;
  u32 nEP = Device_Table.Total_Endpoint;
    667a:	4b0b      	ldr	r3, [pc, #44]	; (66a8 <SetDeviceAddress+0x30>)
    667c:	781c      	ldrb	r4, [r3, #0]

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
    667e:	2300      	movs	r3, #0
    6680:	42a3      	cmp	r3, r4
    6682:	d20c      	bcs.n	669e <SetDeviceAddress+0x26>
    6684:	f103 5280 	add.w	r2, r3, #268435456	; 0x10000000
    6688:	f502 52b8 	add.w	r2, r2, #5888	; 0x1700
    668c:	0091      	lsls	r1, r2, #2
  {
    _SetEPAddress((u8)i, (u8)i);
    668e:	680d      	ldr	r5, [r1, #0]
    6690:	f648 728f 	movw	r2, #36751	; 0x8f8f
    6694:	402a      	ands	r2, r5
    6696:	431a      	orrs	r2, r3
    6698:	600a      	str	r2, [r1, #0]
{
  u32 i;
  u32 nEP = Device_Table.Total_Endpoint;

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
    669a:	3301      	adds	r3, #1
    669c:	e7f0      	b.n	6680 <SetDeviceAddress+0x8>
  {
    _SetEPAddress((u8)i, (u8)i);
  } /* for */
  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
    669e:	4b03      	ldr	r3, [pc, #12]	; (66ac <SetDeviceAddress+0x34>)
    66a0:	f040 0080 	orr.w	r0, r0, #128	; 0x80
    66a4:	6018      	str	r0, [r3, #0]
    66a6:	bd30      	pop	{r4, r5, pc}
    66a8:	200000a4 	andcs	r0, r0, r4, lsr #1
    66ac:	40005c4c 	andmi	r5, r0, ip, asr #24

000066b0 <In0_Process>:
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 In0_Process(void)
{
    66b0:	b510      	push	{r4, lr}
  u32 ControlState = pInformation->ControlState;
    66b2:	4c13      	ldr	r4, [pc, #76]	; (6700 <In0_Process+0x50>)
    66b4:	6823      	ldr	r3, [r4, #0]
    66b6:	7a1a      	ldrb	r2, [r3, #8]

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
    66b8:	2a02      	cmp	r2, #2
    66ba:	d001      	beq.n	66c0 <In0_Process+0x10>
    66bc:	2a04      	cmp	r2, #4
    66be:	d104      	bne.n	66ca <In0_Process+0x1a>
  {
    DataStageIn();
    66c0:	f7ff fc8a 	bl	5fd8 <DataStageIn>
    /* ControlState may be changed outside the function */
    ControlState = pInformation->ControlState;
    66c4:	6823      	ldr	r3, [r4, #0]
    66c6:	7a1b      	ldrb	r3, [r3, #8]
    66c8:	e013      	b.n	66f2 <In0_Process+0x42>
  }

  else if (ControlState == WAIT_STATUS_IN)
    66ca:	2a06      	cmp	r2, #6
    66cc:	d110      	bne.n	66f0 <In0_Process+0x40>
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
    66ce:	785a      	ldrb	r2, [r3, #1]
    66d0:	2a05      	cmp	r2, #5
    66d2:	d109      	bne.n	66e8 <In0_Process+0x38>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    66d4:	781a      	ldrb	r2, [r3, #0]
    ControlState = pInformation->ControlState;
  }

  else if (ControlState == WAIT_STATUS_IN)
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
    66d6:	0652      	lsls	r2, r2, #25
    66d8:	d106      	bne.n	66e8 <In0_Process+0x38>
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    {
      SetDeviceAddress(pInformation->USBwValue0);
    66da:	7898      	ldrb	r0, [r3, #2]
    66dc:	f7ff ffcc 	bl	6678 <SetDeviceAddress>
      pUser_Standard_Requests->User_SetDeviceAddress();
    66e0:	4b08      	ldr	r3, [pc, #32]	; (6704 <In0_Process+0x54>)
    66e2:	681b      	ldr	r3, [r3, #0]
    66e4:	6a1b      	ldr	r3, [r3, #32]
    66e6:	4798      	blx	r3
    }
    (*pProperty->Process_Status_IN)();
    66e8:	4b07      	ldr	r3, [pc, #28]	; (6708 <In0_Process+0x58>)
    66ea:	681b      	ldr	r3, [r3, #0]
    66ec:	689b      	ldr	r3, [r3, #8]
    66ee:	4798      	blx	r3
    ControlState = STALLED;
  }

  else
  {
    ControlState = STALLED;
    66f0:	2308      	movs	r3, #8
  }

  pInformation->ControlState = ControlState;
    66f2:	6822      	ldr	r2, [r4, #0]
    66f4:	7213      	strb	r3, [r2, #8]

  return Post0_Process();
}
    66f6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
    66fa:	f7ff bdcb 	b.w	6294 <Post0_Process>
    66fe:	bf00      	nop
    6700:	200005a8 	andcs	r0, r0, r8, lsr #11
    6704:	200005a4 	andcs	r0, r0, r4, lsr #11
    6708:	20000580 	andcs	r0, r0, r0, lsl #11

0000670c <UserToPMABufferCopy>:
*                  - wNBytes: no. of bytes to be copied.
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
    670c:	b530      	push	{r4, r5, lr}
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
    670e:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
    6712:	3201      	adds	r2, #1
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
    6714:	f501 5140 	add.w	r1, r1, #12288	; 0x3000
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
    6718:	1052      	asrs	r2, r2, #1
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
    671a:	0049      	lsls	r1, r1, #1
  for (i = n; i != 0; i--)
    671c:	2300      	movs	r3, #0
    671e:	4293      	cmp	r3, r2
    6720:	f100 0002 	add.w	r0, r0, #2
    6724:	d009      	beq.n	673a <UserToPMABufferCopy+0x2e>
  {
    temp1 = (u16) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (u16) * pbUsrBuf << 8;
    6726:	f810 5c01 	ldrb.w	r5, [r0, #-1]
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
  {
    temp1 = (u16) * pbUsrBuf;
    672a:	f810 4c02 	ldrb.w	r4, [r0, #-2]
    pbUsrBuf++;
    temp2 = temp1 | (u16) * pbUsrBuf << 8;
    672e:	ea44 2405 	orr.w	r4, r4, r5, lsl #8
    *pdwVal++ = temp2;
    6732:	f821 4023 	strh.w	r4, [r1, r3, lsl #2]
    6736:	3301      	adds	r3, #1
    6738:	e7f1      	b.n	671e <UserToPMABufferCopy+0x12>
    pdwVal++;
    pbUsrBuf++;
  }
}
    673a:	bd30      	pop	{r4, r5, pc}

0000673c <PMAToUserBufferCopy>:
*                  - wNBytes     = no. of bytes to be copied.
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
    673c:	b510      	push	{r4, lr}
  u32 n = (wNBytes + 1) >> 1;/* /2*/
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
    673e:	f101 5100 	add.w	r1, r1, #536870912	; 0x20000000
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;/* /2*/
    6742:	3201      	adds	r2, #1
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
    6744:	f501 5140 	add.w	r1, r1, #12288	; 0x3000
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;/* /2*/
    6748:	1052      	asrs	r2, r2, #1
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
    674a:	0049      	lsls	r1, r1, #1
  for (i = n; i != 0; i--)
    674c:	2300      	movs	r3, #0
    674e:	4293      	cmp	r3, r2
    6750:	d005      	beq.n	675e <PMAToUserBufferCopy+0x22>
  {
    *(u16*)pbUsrBuf++ = *pdwVal++;
    6752:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
    6756:	f820 4013 	strh.w	r4, [r0, r3, lsl #1]
    675a:	3301      	adds	r3, #1
    675c:	e7f7      	b.n	674e <PMAToUserBufferCopy+0x12>
    pbUsrBuf++;
  }
}
    675e:	bd10      	pop	{r4, pc}

00006760 <memcpy>:
    6760:	b510      	push	{r4, lr}
    6762:	2300      	movs	r3, #0
    6764:	4293      	cmp	r3, r2
    6766:	d003      	beq.n	6770 <memcpy+0x10>
    6768:	5ccc      	ldrb	r4, [r1, r3]
    676a:	54c4      	strb	r4, [r0, r3]
    676c:	3301      	adds	r3, #1
    676e:	e7f9      	b.n	6764 <memcpy+0x4>
    6770:	bd10      	pop	{r4, pc}

00006772 <memset>:
    6772:	4402      	add	r2, r0
    6774:	4603      	mov	r3, r0
    6776:	4293      	cmp	r3, r2
    6778:	d002      	beq.n	6780 <memset+0xe>
    677a:	f803 1b01 	strb.w	r1, [r3], #1
    677e:	e7fa      	b.n	6776 <memset+0x4>
    6780:	4770      	bx	lr

00006782 <_vsiprintf_r>:
    6782:	b510      	push	{r4, lr}
    6784:	b09a      	sub	sp, #104	; 0x68
    6786:	9100      	str	r1, [sp, #0]
    6788:	9104      	str	r1, [sp, #16]
    678a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
    678e:	9102      	str	r1, [sp, #8]
    6790:	9105      	str	r1, [sp, #20]
    6792:	f64f 71ff 	movw	r1, #65535	; 0xffff
    6796:	f8ad 100e 	strh.w	r1, [sp, #14]
    679a:	f44f 7402 	mov.w	r4, #520	; 0x208
    679e:	4669      	mov	r1, sp
    67a0:	f8ad 400c 	strh.w	r4, [sp, #12]
    67a4:	f000 f870 	bl	6888 <_svfiprintf_r>
    67a8:	9b00      	ldr	r3, [sp, #0]
    67aa:	2200      	movs	r2, #0
    67ac:	701a      	strb	r2, [r3, #0]
    67ae:	b01a      	add	sp, #104	; 0x68
    67b0:	bd10      	pop	{r4, pc}
	...

000067b4 <vsiprintf>:
    67b4:	b530      	push	{r4, r5, lr}
    67b6:	4613      	mov	r3, r2
    67b8:	4a04      	ldr	r2, [pc, #16]	; (67cc <vsiprintf+0x18>)
    67ba:	4605      	mov	r5, r0
    67bc:	460c      	mov	r4, r1
    67be:	6810      	ldr	r0, [r2, #0]
    67c0:	4629      	mov	r1, r5
    67c2:	4622      	mov	r2, r4
    67c4:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
    67c8:	f7ff bfdb 	b.w	6782 <_vsiprintf_r>
    67cc:	20000484 	andcs	r0, r0, r4, lsl #9

000067d0 <__ssputs_r>:
    67d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    67d4:	688d      	ldr	r5, [r1, #8]
    67d6:	4681      	mov	r9, r0
    67d8:	42ab      	cmp	r3, r5
    67da:	460c      	mov	r4, r1
    67dc:	4692      	mov	sl, r2
    67de:	461f      	mov	r7, r3
    67e0:	d343      	bcc.n	686a <__ssputs_r+0x9a>
    67e2:	898b      	ldrh	r3, [r1, #12]
    67e4:	f413 6f90 	tst.w	r3, #1152	; 0x480
    67e8:	d03d      	beq.n	6866 <__ssputs_r+0x96>
    67ea:	6826      	ldr	r6, [r4, #0]
    67ec:	6909      	ldr	r1, [r1, #16]
    67ee:	2202      	movs	r2, #2
    67f0:	ebc1 0806 	rsb	r8, r1, r6
    67f4:	6966      	ldr	r6, [r4, #20]
    67f6:	eb06 0646 	add.w	r6, r6, r6, lsl #1
    67fa:	fb96 f6f2 	sdiv	r6, r6, r2
    67fe:	f108 0201 	add.w	r2, r8, #1
    6802:	443a      	add	r2, r7
    6804:	4296      	cmp	r6, r2
    6806:	bf38      	it	cc
    6808:	4616      	movcc	r6, r2
    680a:	055b      	lsls	r3, r3, #21
    680c:	d50f      	bpl.n	682e <__ssputs_r+0x5e>
    680e:	4631      	mov	r1, r6
    6810:	f000 fb1a 	bl	6e48 <_malloc_r>
    6814:	4605      	mov	r5, r0
    6816:	b198      	cbz	r0, 6840 <__ssputs_r+0x70>
    6818:	6921      	ldr	r1, [r4, #16]
    681a:	4642      	mov	r2, r8
    681c:	f7ff ffa0 	bl	6760 <memcpy>
    6820:	89a3      	ldrh	r3, [r4, #12]
    6822:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
    6826:	f043 0380 	orr.w	r3, r3, #128	; 0x80
    682a:	81a3      	strh	r3, [r4, #12]
    682c:	e013      	b.n	6856 <__ssputs_r+0x86>
    682e:	4632      	mov	r2, r6
    6830:	f000 fb5e 	bl	6ef0 <_realloc_r>
    6834:	4605      	mov	r5, r0
    6836:	b970      	cbnz	r0, 6856 <__ssputs_r+0x86>
    6838:	4648      	mov	r0, r9
    683a:	6921      	ldr	r1, [r4, #16]
    683c:	f000 fac0 	bl	6dc0 <_free_r>
    6840:	230c      	movs	r3, #12
    6842:	f8c9 3000 	str.w	r3, [r9]
    6846:	89a3      	ldrh	r3, [r4, #12]
    6848:	f04f 30ff 	mov.w	r0, #4294967295
    684c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
    6850:	81a3      	strh	r3, [r4, #12]
    6852:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6856:	6125      	str	r5, [r4, #16]
    6858:	6166      	str	r6, [r4, #20]
    685a:	4445      	add	r5, r8
    685c:	ebc8 0606 	rsb	r6, r8, r6
    6860:	6025      	str	r5, [r4, #0]
    6862:	60a6      	str	r6, [r4, #8]
    6864:	463d      	mov	r5, r7
    6866:	42af      	cmp	r7, r5
    6868:	d200      	bcs.n	686c <__ssputs_r+0x9c>
    686a:	463d      	mov	r5, r7
    686c:	462a      	mov	r2, r5
    686e:	6820      	ldr	r0, [r4, #0]
    6870:	4651      	mov	r1, sl
    6872:	f000 fa89 	bl	6d88 <memmove>
    6876:	68a3      	ldr	r3, [r4, #8]
    6878:	2000      	movs	r0, #0
    687a:	1b5b      	subs	r3, r3, r5
    687c:	60a3      	str	r3, [r4, #8]
    687e:	6823      	ldr	r3, [r4, #0]
    6880:	441d      	add	r5, r3
    6882:	6025      	str	r5, [r4, #0]
    6884:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

00006888 <_svfiprintf_r>:
    6888:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
    688c:	b09d      	sub	sp, #116	; 0x74
    688e:	9303      	str	r3, [sp, #12]
    6890:	898b      	ldrh	r3, [r1, #12]
    6892:	4607      	mov	r7, r0
    6894:	061c      	lsls	r4, r3, #24
    6896:	460d      	mov	r5, r1
    6898:	4616      	mov	r6, r2
    689a:	d50c      	bpl.n	68b6 <_svfiprintf_r+0x2e>
    689c:	690b      	ldr	r3, [r1, #16]
    689e:	b953      	cbnz	r3, 68b6 <_svfiprintf_r+0x2e>
    68a0:	2140      	movs	r1, #64	; 0x40
    68a2:	f000 fad1 	bl	6e48 <_malloc_r>
    68a6:	6028      	str	r0, [r5, #0]
    68a8:	6128      	str	r0, [r5, #16]
    68aa:	b910      	cbnz	r0, 68b2 <_svfiprintf_r+0x2a>
    68ac:	230c      	movs	r3, #12
    68ae:	603b      	str	r3, [r7, #0]
    68b0:	e0c7      	b.n	6a42 <_svfiprintf_r+0x1ba>
    68b2:	2340      	movs	r3, #64	; 0x40
    68b4:	616b      	str	r3, [r5, #20]
    68b6:	2300      	movs	r3, #0
    68b8:	9309      	str	r3, [sp, #36]	; 0x24
    68ba:	2320      	movs	r3, #32
    68bc:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
    68c0:	2330      	movs	r3, #48	; 0x30
    68c2:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
    68c6:	4633      	mov	r3, r6
    68c8:	461c      	mov	r4, r3
    68ca:	f813 2b01 	ldrb.w	r2, [r3], #1
    68ce:	b91a      	cbnz	r2, 68d8 <_svfiprintf_r+0x50>
    68d0:	ebb4 0906 	subs.w	r9, r4, r6
    68d4:	d00f      	beq.n	68f6 <_svfiprintf_r+0x6e>
    68d6:	e002      	b.n	68de <_svfiprintf_r+0x56>
    68d8:	2a25      	cmp	r2, #37	; 0x25
    68da:	d1f5      	bne.n	68c8 <_svfiprintf_r+0x40>
    68dc:	e7f8      	b.n	68d0 <_svfiprintf_r+0x48>
    68de:	4638      	mov	r0, r7
    68e0:	4629      	mov	r1, r5
    68e2:	4632      	mov	r2, r6
    68e4:	464b      	mov	r3, r9
    68e6:	f7ff ff73 	bl	67d0 <__ssputs_r>
    68ea:	3001      	adds	r0, #1
    68ec:	f000 80a4 	beq.w	6a38 <_svfiprintf_r+0x1b0>
    68f0:	9b09      	ldr	r3, [sp, #36]	; 0x24
    68f2:	444b      	add	r3, r9
    68f4:	9309      	str	r3, [sp, #36]	; 0x24
    68f6:	7823      	ldrb	r3, [r4, #0]
    68f8:	2b00      	cmp	r3, #0
    68fa:	f000 809d 	beq.w	6a38 <_svfiprintf_r+0x1b0>
    68fe:	2300      	movs	r3, #0
    6900:	f04f 32ff 	mov.w	r2, #4294967295
    6904:	9304      	str	r3, [sp, #16]
    6906:	9307      	str	r3, [sp, #28]
    6908:	9205      	str	r2, [sp, #20]
    690a:	9306      	str	r3, [sp, #24]
    690c:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
    6910:	931a      	str	r3, [sp, #104]	; 0x68
    6912:	f104 0901 	add.w	r9, r4, #1
    6916:	4e4d      	ldr	r6, [pc, #308]	; (6a4c <_svfiprintf_r+0x1c4>)
    6918:	464c      	mov	r4, r9
    691a:	4630      	mov	r0, r6
    691c:	7821      	ldrb	r1, [r4, #0]
    691e:	2205      	movs	r2, #5
    6920:	f000 fa24 	bl	6d6c <memchr>
    6924:	f109 0901 	add.w	r9, r9, #1
    6928:	9b04      	ldr	r3, [sp, #16]
    692a:	b128      	cbz	r0, 6938 <_svfiprintf_r+0xb0>
    692c:	1b86      	subs	r6, r0, r6
    692e:	2001      	movs	r0, #1
    6930:	40b0      	lsls	r0, r6
    6932:	4303      	orrs	r3, r0
    6934:	9304      	str	r3, [sp, #16]
    6936:	e7ee      	b.n	6916 <_svfiprintf_r+0x8e>
    6938:	06d9      	lsls	r1, r3, #27
    693a:	bf44      	itt	mi
    693c:	2220      	movmi	r2, #32
    693e:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    6942:	071a      	lsls	r2, r3, #28
    6944:	bf44      	itt	mi
    6946:	222b      	movmi	r2, #43	; 0x2b
    6948:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
    694c:	7822      	ldrb	r2, [r4, #0]
    694e:	2a2a      	cmp	r2, #42	; 0x2a
    6950:	d002      	beq.n	6958 <_svfiprintf_r+0xd0>
    6952:	9b07      	ldr	r3, [sp, #28]
    6954:	4621      	mov	r1, r4
    6956:	e00e      	b.n	6976 <_svfiprintf_r+0xee>
    6958:	9a03      	ldr	r2, [sp, #12]
    695a:	1d11      	adds	r1, r2, #4
    695c:	6812      	ldr	r2, [r2, #0]
    695e:	9103      	str	r1, [sp, #12]
    6960:	2a00      	cmp	r2, #0
    6962:	db01      	blt.n	6968 <_svfiprintf_r+0xe0>
    6964:	9207      	str	r2, [sp, #28]
    6966:	e004      	b.n	6972 <_svfiprintf_r+0xea>
    6968:	4252      	negs	r2, r2
    696a:	f043 0302 	orr.w	r3, r3, #2
    696e:	9207      	str	r2, [sp, #28]
    6970:	9304      	str	r3, [sp, #16]
    6972:	3401      	adds	r4, #1
    6974:	e00a      	b.n	698c <_svfiprintf_r+0x104>
    6976:	460c      	mov	r4, r1
    6978:	7822      	ldrb	r2, [r4, #0]
    697a:	3101      	adds	r1, #1
    697c:	3a30      	subs	r2, #48	; 0x30
    697e:	2a09      	cmp	r2, #9
    6980:	d803      	bhi.n	698a <_svfiprintf_r+0x102>
    6982:	200a      	movs	r0, #10
    6984:	fb00 2303 	mla	r3, r0, r3, r2
    6988:	e7f5      	b.n	6976 <_svfiprintf_r+0xee>
    698a:	9307      	str	r3, [sp, #28]
    698c:	7823      	ldrb	r3, [r4, #0]
    698e:	2b2e      	cmp	r3, #46	; 0x2e
    6990:	d119      	bne.n	69c6 <_svfiprintf_r+0x13e>
    6992:	7863      	ldrb	r3, [r4, #1]
    6994:	2b2a      	cmp	r3, #42	; 0x2a
    6996:	d109      	bne.n	69ac <_svfiprintf_r+0x124>
    6998:	9b03      	ldr	r3, [sp, #12]
    699a:	3402      	adds	r4, #2
    699c:	1d1a      	adds	r2, r3, #4
    699e:	681b      	ldr	r3, [r3, #0]
    69a0:	9203      	str	r2, [sp, #12]
    69a2:	2b00      	cmp	r3, #0
    69a4:	bfb8      	it	lt
    69a6:	f04f 33ff 	movlt.w	r3, #4294967295
    69aa:	e00b      	b.n	69c4 <_svfiprintf_r+0x13c>
    69ac:	1c61      	adds	r1, r4, #1
    69ae:	2300      	movs	r3, #0
    69b0:	460c      	mov	r4, r1
    69b2:	7822      	ldrb	r2, [r4, #0]
    69b4:	3101      	adds	r1, #1
    69b6:	3a30      	subs	r2, #48	; 0x30
    69b8:	2a09      	cmp	r2, #9
    69ba:	d803      	bhi.n	69c4 <_svfiprintf_r+0x13c>
    69bc:	200a      	movs	r0, #10
    69be:	fb00 2303 	mla	r3, r0, r3, r2
    69c2:	e7f5      	b.n	69b0 <_svfiprintf_r+0x128>
    69c4:	9305      	str	r3, [sp, #20]
    69c6:	4e22      	ldr	r6, [pc, #136]	; (6a50 <_svfiprintf_r+0x1c8>)
    69c8:	7821      	ldrb	r1, [r4, #0]
    69ca:	4630      	mov	r0, r6
    69cc:	2203      	movs	r2, #3
    69ce:	f000 f9cd 	bl	6d6c <memchr>
    69d2:	b130      	cbz	r0, 69e2 <_svfiprintf_r+0x15a>
    69d4:	1b86      	subs	r6, r0, r6
    69d6:	2040      	movs	r0, #64	; 0x40
    69d8:	40b0      	lsls	r0, r6
    69da:	9b04      	ldr	r3, [sp, #16]
    69dc:	3401      	adds	r4, #1
    69de:	4303      	orrs	r3, r0
    69e0:	9304      	str	r3, [sp, #16]
    69e2:	7821      	ldrb	r1, [r4, #0]
    69e4:	481b      	ldr	r0, [pc, #108]	; (6a54 <_svfiprintf_r+0x1cc>)
    69e6:	2206      	movs	r2, #6
    69e8:	1c66      	adds	r6, r4, #1
    69ea:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
    69ee:	f000 f9bd 	bl	6d6c <memchr>
    69f2:	b188      	cbz	r0, 6a18 <_svfiprintf_r+0x190>
    69f4:	4b18      	ldr	r3, [pc, #96]	; (6a58 <_svfiprintf_r+0x1d0>)
    69f6:	b933      	cbnz	r3, 6a06 <_svfiprintf_r+0x17e>
    69f8:	9b03      	ldr	r3, [sp, #12]
    69fa:	3307      	adds	r3, #7
    69fc:	f023 0307 	bic.w	r3, r3, #7
    6a00:	3308      	adds	r3, #8
    6a02:	9303      	str	r3, [sp, #12]
    6a04:	e014      	b.n	6a30 <_svfiprintf_r+0x1a8>
    6a06:	ab03      	add	r3, sp, #12
    6a08:	9300      	str	r3, [sp, #0]
    6a0a:	4638      	mov	r0, r7
    6a0c:	a904      	add	r1, sp, #16
    6a0e:	462a      	mov	r2, r5
    6a10:	4b12      	ldr	r3, [pc, #72]	; (6a5c <_svfiprintf_r+0x1d4>)
    6a12:	f3af 8000 	nop.w
    6a16:	e007      	b.n	6a28 <_svfiprintf_r+0x1a0>
    6a18:	ab03      	add	r3, sp, #12
    6a1a:	9300      	str	r3, [sp, #0]
    6a1c:	4638      	mov	r0, r7
    6a1e:	a904      	add	r1, sp, #16
    6a20:	462a      	mov	r2, r5
    6a22:	4b0e      	ldr	r3, [pc, #56]	; (6a5c <_svfiprintf_r+0x1d4>)
    6a24:	f000 f88e 	bl	6b44 <_printf_i>
    6a28:	f1b0 3fff 	cmp.w	r0, #4294967295
    6a2c:	4680      	mov	r8, r0
    6a2e:	d003      	beq.n	6a38 <_svfiprintf_r+0x1b0>
    6a30:	9b09      	ldr	r3, [sp, #36]	; 0x24
    6a32:	4443      	add	r3, r8
    6a34:	9309      	str	r3, [sp, #36]	; 0x24
    6a36:	e746      	b.n	68c6 <_svfiprintf_r+0x3e>
    6a38:	89ab      	ldrh	r3, [r5, #12]
    6a3a:	065b      	lsls	r3, r3, #25
    6a3c:	d401      	bmi.n	6a42 <_svfiprintf_r+0x1ba>
    6a3e:	9809      	ldr	r0, [sp, #36]	; 0x24
    6a40:	e001      	b.n	6a46 <_svfiprintf_r+0x1be>
    6a42:	f04f 30ff 	mov.w	r0, #4294967295
    6a46:	b01d      	add	sp, #116	; 0x74
    6a48:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    6a4c:	000075e0 	andeq	r7, r0, r0, ror #11
    6a50:	000075e6 	andeq	r7, r0, r6, ror #11
    6a54:	000075ea 	andeq	r7, r0, sl, ror #11
    6a58:	00000000 	andeq	r0, r0, r0
    6a5c:	000067d1 	ldrdeq	r6, [r0], -r1

00006a60 <_printf_common>:
    6a60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    6a64:	4615      	mov	r5, r2
    6a66:	461f      	mov	r7, r3
    6a68:	688a      	ldr	r2, [r1, #8]
    6a6a:	690b      	ldr	r3, [r1, #16]
    6a6c:	4606      	mov	r6, r0
    6a6e:	429a      	cmp	r2, r3
    6a70:	bfa8      	it	ge
    6a72:	4613      	movge	r3, r2
    6a74:	602b      	str	r3, [r5, #0]
    6a76:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
    6a7a:	460c      	mov	r4, r1
    6a7c:	f8dd 8020 	ldr.w	r8, [sp, #32]
    6a80:	b10a      	cbz	r2, 6a86 <_printf_common+0x26>
    6a82:	3301      	adds	r3, #1
    6a84:	602b      	str	r3, [r5, #0]
    6a86:	6823      	ldr	r3, [r4, #0]
    6a88:	0699      	lsls	r1, r3, #26
    6a8a:	d502      	bpl.n	6a92 <_printf_common+0x32>
    6a8c:	682b      	ldr	r3, [r5, #0]
    6a8e:	3302      	adds	r3, #2
    6a90:	602b      	str	r3, [r5, #0]
    6a92:	6823      	ldr	r3, [r4, #0]
    6a94:	f013 0906 	ands.w	r9, r3, #6
    6a98:	d01d      	beq.n	6ad6 <_printf_common+0x76>
    6a9a:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
    6a9e:	6822      	ldr	r2, [r4, #0]
    6aa0:	3300      	adds	r3, #0
    6aa2:	bf18      	it	ne
    6aa4:	2301      	movne	r3, #1
    6aa6:	0692      	lsls	r2, r2, #26
    6aa8:	d51f      	bpl.n	6aea <_printf_common+0x8a>
    6aaa:	18e1      	adds	r1, r4, r3
    6aac:	2030      	movs	r0, #48	; 0x30
    6aae:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
    6ab2:	1c5a      	adds	r2, r3, #1
    6ab4:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
    6ab8:	4422      	add	r2, r4
    6aba:	3302      	adds	r3, #2
    6abc:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
    6ac0:	e013      	b.n	6aea <_printf_common+0x8a>
    6ac2:	4630      	mov	r0, r6
    6ac4:	4639      	mov	r1, r7
    6ac6:	f104 0219 	add.w	r2, r4, #25
    6aca:	2301      	movs	r3, #1
    6acc:	47c0      	blx	r8
    6ace:	3001      	adds	r0, #1
    6ad0:	d007      	beq.n	6ae2 <_printf_common+0x82>
    6ad2:	f109 0901 	add.w	r9, r9, #1
    6ad6:	68e2      	ldr	r2, [r4, #12]
    6ad8:	682b      	ldr	r3, [r5, #0]
    6ada:	1ad3      	subs	r3, r2, r3
    6adc:	4599      	cmp	r9, r3
    6ade:	dbf0      	blt.n	6ac2 <_printf_common+0x62>
    6ae0:	e7db      	b.n	6a9a <_printf_common+0x3a>
    6ae2:	f04f 30ff 	mov.w	r0, #4294967295
    6ae6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
    6aea:	4630      	mov	r0, r6
    6aec:	4639      	mov	r1, r7
    6aee:	f104 0243 	add.w	r2, r4, #67	; 0x43
    6af2:	47c0      	blx	r8
    6af4:	3001      	adds	r0, #1
    6af6:	d0f4      	beq.n	6ae2 <_printf_common+0x82>
    6af8:	6823      	ldr	r3, [r4, #0]
    6afa:	682a      	ldr	r2, [r5, #0]
    6afc:	f003 0306 	and.w	r3, r3, #6
    6b00:	68e1      	ldr	r1, [r4, #12]
    6b02:	2b04      	cmp	r3, #4
    6b04:	bf08      	it	eq
    6b06:	ebc2 0501 	rsbeq	r5, r2, r1
    6b0a:	6923      	ldr	r3, [r4, #16]
    6b0c:	68a2      	ldr	r2, [r4, #8]
    6b0e:	bf0c      	ite	eq
    6b10:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
    6b14:	2500      	movne	r5, #0
    6b16:	429a      	cmp	r2, r3
    6b18:	bfc4      	itt	gt
    6b1a:	ebc3 0302 	rsbgt	r3, r3, r2
    6b1e:	18ed      	addgt	r5, r5, r3
    6b20:	f04f 0900 	mov.w	r9, #0
    6b24:	45a9      	cmp	r9, r5
    6b26:	da0a      	bge.n	6b3e <_printf_common+0xde>
    6b28:	4630      	mov	r0, r6
    6b2a:	4639      	mov	r1, r7
    6b2c:	f104 021a 	add.w	r2, r4, #26
    6b30:	2301      	movs	r3, #1
    6b32:	47c0      	blx	r8
    6b34:	3001      	adds	r0, #1
    6b36:	d0d4      	beq.n	6ae2 <_printf_common+0x82>
    6b38:	f109 0901 	add.w	r9, r9, #1
    6b3c:	e7f2      	b.n	6b24 <_printf_common+0xc4>
    6b3e:	2000      	movs	r0, #0
    6b40:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

00006b44 <_printf_i>:
    6b44:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
    6b48:	7e0e      	ldrb	r6, [r1, #24]
    6b4a:	4680      	mov	r8, r0
    6b4c:	2e6e      	cmp	r6, #110	; 0x6e
    6b4e:	460c      	mov	r4, r1
    6b50:	4691      	mov	r9, r2
    6b52:	469a      	mov	sl, r3
    6b54:	9d0c      	ldr	r5, [sp, #48]	; 0x30
    6b56:	f101 0043 	add.w	r0, r1, #67	; 0x43
    6b5a:	f000 80a5 	beq.w	6ca8 <_printf_i+0x164>
    6b5e:	d811      	bhi.n	6b84 <_printf_i+0x40>
    6b60:	2e63      	cmp	r6, #99	; 0x63
    6b62:	d022      	beq.n	6baa <_printf_i+0x66>
    6b64:	d809      	bhi.n	6b7a <_printf_i+0x36>
    6b66:	2e00      	cmp	r6, #0
    6b68:	f000 80af 	beq.w	6cca <_printf_i+0x186>
    6b6c:	2e58      	cmp	r6, #88	; 0x58
    6b6e:	f040 80bf 	bne.w	6cf0 <_printf_i+0x1ac>
    6b72:	f881 6045 	strb.w	r6, [r1, #69]	; 0x45
    6b76:	4a7b      	ldr	r2, [pc, #492]	; (6d64 <_printf_i+0x220>)
    6b78:	e04f      	b.n	6c1a <_printf_i+0xd6>
    6b7a:	2e64      	cmp	r6, #100	; 0x64
    6b7c:	d01e      	beq.n	6bbc <_printf_i+0x78>
    6b7e:	2e69      	cmp	r6, #105	; 0x69
    6b80:	d01c      	beq.n	6bbc <_printf_i+0x78>
    6b82:	e0b5      	b.n	6cf0 <_printf_i+0x1ac>
    6b84:	2e73      	cmp	r6, #115	; 0x73
    6b86:	f000 80a4 	beq.w	6cd2 <_printf_i+0x18e>
    6b8a:	d809      	bhi.n	6ba0 <_printf_i+0x5c>
    6b8c:	2e6f      	cmp	r6, #111	; 0x6f
    6b8e:	d02b      	beq.n	6be8 <_printf_i+0xa4>
    6b90:	2e70      	cmp	r6, #112	; 0x70
    6b92:	f040 80ad 	bne.w	6cf0 <_printf_i+0x1ac>
    6b96:	680b      	ldr	r3, [r1, #0]
    6b98:	f043 0320 	orr.w	r3, r3, #32
    6b9c:	600b      	str	r3, [r1, #0]
    6b9e:	e038      	b.n	6c12 <_printf_i+0xce>
    6ba0:	2e75      	cmp	r6, #117	; 0x75
    6ba2:	d021      	beq.n	6be8 <_printf_i+0xa4>
    6ba4:	2e78      	cmp	r6, #120	; 0x78
    6ba6:	d034      	beq.n	6c12 <_printf_i+0xce>
    6ba8:	e0a2      	b.n	6cf0 <_printf_i+0x1ac>
    6baa:	682b      	ldr	r3, [r5, #0]
    6bac:	f101 0742 	add.w	r7, r1, #66	; 0x42
    6bb0:	1d1a      	adds	r2, r3, #4
    6bb2:	681b      	ldr	r3, [r3, #0]
    6bb4:	602a      	str	r2, [r5, #0]
    6bb6:	f881 3042 	strb.w	r3, [r1, #66]	; 0x42
    6bba:	e09d      	b.n	6cf8 <_printf_i+0x1b4>
    6bbc:	6822      	ldr	r2, [r4, #0]
    6bbe:	682b      	ldr	r3, [r5, #0]
    6bc0:	f012 0f80 	tst.w	r2, #128	; 0x80
    6bc4:	d003      	beq.n	6bce <_printf_i+0x8a>
    6bc6:	1d1a      	adds	r2, r3, #4
    6bc8:	602a      	str	r2, [r5, #0]
    6bca:	681d      	ldr	r5, [r3, #0]
    6bcc:	e005      	b.n	6bda <_printf_i+0x96>
    6bce:	0651      	lsls	r1, r2, #25
    6bd0:	d5f9      	bpl.n	6bc6 <_printf_i+0x82>
    6bd2:	1d1a      	adds	r2, r3, #4
    6bd4:	602a      	str	r2, [r5, #0]
    6bd6:	f9b3 5000 	ldrsh.w	r5, [r3]
    6bda:	2d00      	cmp	r5, #0
    6bdc:	da39      	bge.n	6c52 <_printf_i+0x10e>
    6bde:	232d      	movs	r3, #45	; 0x2d
    6be0:	426d      	negs	r5, r5
    6be2:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    6be6:	e034      	b.n	6c52 <_printf_i+0x10e>
    6be8:	6822      	ldr	r2, [r4, #0]
    6bea:	682b      	ldr	r3, [r5, #0]
    6bec:	f012 0f80 	tst.w	r2, #128	; 0x80
    6bf0:	d003      	beq.n	6bfa <_printf_i+0xb6>
    6bf2:	1d1a      	adds	r2, r3, #4
    6bf4:	602a      	str	r2, [r5, #0]
    6bf6:	681d      	ldr	r5, [r3, #0]
    6bf8:	e004      	b.n	6c04 <_printf_i+0xc0>
    6bfa:	0652      	lsls	r2, r2, #25
    6bfc:	d5f9      	bpl.n	6bf2 <_printf_i+0xae>
    6bfe:	1d1a      	adds	r2, r3, #4
    6c00:	602a      	str	r2, [r5, #0]
    6c02:	881d      	ldrh	r5, [r3, #0]
    6c04:	7e23      	ldrb	r3, [r4, #24]
    6c06:	4a57      	ldr	r2, [pc, #348]	; (6d64 <_printf_i+0x220>)
    6c08:	2b6f      	cmp	r3, #111	; 0x6f
    6c0a:	bf14      	ite	ne
    6c0c:	230a      	movne	r3, #10
    6c0e:	2308      	moveq	r3, #8
    6c10:	e01b      	b.n	6c4a <_printf_i+0x106>
    6c12:	2378      	movs	r3, #120	; 0x78
    6c14:	4a54      	ldr	r2, [pc, #336]	; (6d68 <_printf_i+0x224>)
    6c16:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
    6c1a:	6823      	ldr	r3, [r4, #0]
    6c1c:	6829      	ldr	r1, [r5, #0]
    6c1e:	f013 0f80 	tst.w	r3, #128	; 0x80
    6c22:	f101 0604 	add.w	r6, r1, #4
    6c26:	602e      	str	r6, [r5, #0]
    6c28:	d001      	beq.n	6c2e <_printf_i+0xea>
    6c2a:	680d      	ldr	r5, [r1, #0]
    6c2c:	e002      	b.n	6c34 <_printf_i+0xf0>
    6c2e:	065f      	lsls	r7, r3, #25
    6c30:	d5fb      	bpl.n	6c2a <_printf_i+0xe6>
    6c32:	880d      	ldrh	r5, [r1, #0]
    6c34:	07de      	lsls	r6, r3, #31
    6c36:	bf44      	itt	mi
    6c38:	f043 0320 	orrmi.w	r3, r3, #32
    6c3c:	6023      	strmi	r3, [r4, #0]
    6c3e:	b91d      	cbnz	r5, 6c48 <_printf_i+0x104>
    6c40:	6823      	ldr	r3, [r4, #0]
    6c42:	f023 0320 	bic.w	r3, r3, #32
    6c46:	6023      	str	r3, [r4, #0]
    6c48:	2310      	movs	r3, #16
    6c4a:	2100      	movs	r1, #0
    6c4c:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
    6c50:	e001      	b.n	6c56 <_printf_i+0x112>
    6c52:	4a44      	ldr	r2, [pc, #272]	; (6d64 <_printf_i+0x220>)
    6c54:	230a      	movs	r3, #10
    6c56:	6866      	ldr	r6, [r4, #4]
    6c58:	2e00      	cmp	r6, #0
    6c5a:	60a6      	str	r6, [r4, #8]
    6c5c:	db03      	blt.n	6c66 <_printf_i+0x122>
    6c5e:	6821      	ldr	r1, [r4, #0]
    6c60:	f021 0104 	bic.w	r1, r1, #4
    6c64:	6021      	str	r1, [r4, #0]
    6c66:	b905      	cbnz	r5, 6c6a <_printf_i+0x126>
    6c68:	b16e      	cbz	r6, 6c86 <_printf_i+0x142>
    6c6a:	f104 0142 	add.w	r1, r4, #66	; 0x42
    6c6e:	fbb5 f6f3 	udiv	r6, r5, r3
    6c72:	fb03 5516 	mls	r5, r3, r6, r5
    6c76:	5d55      	ldrb	r5, [r2, r5]
    6c78:	460f      	mov	r7, r1
    6c7a:	f801 5901 	strb.w	r5, [r1], #-1
    6c7e:	4635      	mov	r5, r6
    6c80:	2e00      	cmp	r6, #0
    6c82:	d1f4      	bne.n	6c6e <_printf_i+0x12a>
    6c84:	e000      	b.n	6c88 <_printf_i+0x144>
    6c86:	4607      	mov	r7, r0
    6c88:	2b08      	cmp	r3, #8
    6c8a:	d10a      	bne.n	6ca2 <_printf_i+0x15e>
    6c8c:	6823      	ldr	r3, [r4, #0]
    6c8e:	07dd      	lsls	r5, r3, #31
    6c90:	d507      	bpl.n	6ca2 <_printf_i+0x15e>
    6c92:	6862      	ldr	r2, [r4, #4]
    6c94:	6923      	ldr	r3, [r4, #16]
    6c96:	429a      	cmp	r2, r3
    6c98:	dc03      	bgt.n	6ca2 <_printf_i+0x15e>
    6c9a:	2330      	movs	r3, #48	; 0x30
    6c9c:	f807 3c01 	strb.w	r3, [r7, #-1]
    6ca0:	3f01      	subs	r7, #1
    6ca2:	1bc0      	subs	r0, r0, r7
    6ca4:	6120      	str	r0, [r4, #16]
    6ca6:	e02c      	b.n	6d02 <_printf_i+0x1be>
    6ca8:	6809      	ldr	r1, [r1, #0]
    6caa:	682b      	ldr	r3, [r5, #0]
    6cac:	f011 0f80 	tst.w	r1, #128	; 0x80
    6cb0:	6962      	ldr	r2, [r4, #20]
    6cb2:	d004      	beq.n	6cbe <_printf_i+0x17a>
    6cb4:	1d19      	adds	r1, r3, #4
    6cb6:	6029      	str	r1, [r5, #0]
    6cb8:	681b      	ldr	r3, [r3, #0]
    6cba:	601a      	str	r2, [r3, #0]
    6cbc:	e005      	b.n	6cca <_printf_i+0x186>
    6cbe:	0649      	lsls	r1, r1, #25
    6cc0:	d5f8      	bpl.n	6cb4 <_printf_i+0x170>
    6cc2:	1d19      	adds	r1, r3, #4
    6cc4:	6029      	str	r1, [r5, #0]
    6cc6:	681b      	ldr	r3, [r3, #0]
    6cc8:	801a      	strh	r2, [r3, #0]
    6cca:	2300      	movs	r3, #0
    6ccc:	6123      	str	r3, [r4, #16]
    6cce:	4607      	mov	r7, r0
    6cd0:	e017      	b.n	6d02 <_printf_i+0x1be>
    6cd2:	682b      	ldr	r3, [r5, #0]
    6cd4:	1d1a      	adds	r2, r3, #4
    6cd6:	602a      	str	r2, [r5, #0]
    6cd8:	681f      	ldr	r7, [r3, #0]
    6cda:	4638      	mov	r0, r7
    6cdc:	f000 f93e 	bl	6f5c <strlen>
    6ce0:	6863      	ldr	r3, [r4, #4]
    6ce2:	6120      	str	r0, [r4, #16]
    6ce4:	4298      	cmp	r0, r3
    6ce6:	bf88      	it	hi
    6ce8:	6123      	strhi	r3, [r4, #16]
    6cea:	6923      	ldr	r3, [r4, #16]
    6cec:	6063      	str	r3, [r4, #4]
    6cee:	e005      	b.n	6cfc <_printf_i+0x1b8>
    6cf0:	f104 0742 	add.w	r7, r4, #66	; 0x42
    6cf4:	f884 6042 	strb.w	r6, [r4, #66]	; 0x42
    6cf8:	2301      	movs	r3, #1
    6cfa:	6123      	str	r3, [r4, #16]
    6cfc:	2300      	movs	r3, #0
    6cfe:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
    6d02:	f8cd a000 	str.w	sl, [sp]
    6d06:	4640      	mov	r0, r8
    6d08:	4621      	mov	r1, r4
    6d0a:	aa03      	add	r2, sp, #12
    6d0c:	464b      	mov	r3, r9
    6d0e:	f7ff fea7 	bl	6a60 <_printf_common>
    6d12:	3001      	adds	r0, #1
    6d14:	d102      	bne.n	6d1c <_printf_i+0x1d8>
    6d16:	f04f 30ff 	mov.w	r0, #4294967295
    6d1a:	e01f      	b.n	6d5c <_printf_i+0x218>
    6d1c:	4640      	mov	r0, r8
    6d1e:	4649      	mov	r1, r9
    6d20:	463a      	mov	r2, r7
    6d22:	6923      	ldr	r3, [r4, #16]
    6d24:	47d0      	blx	sl
    6d26:	3001      	adds	r0, #1
    6d28:	d0f5      	beq.n	6d16 <_printf_i+0x1d2>
    6d2a:	6823      	ldr	r3, [r4, #0]
    6d2c:	079b      	lsls	r3, r3, #30
    6d2e:	d405      	bmi.n	6d3c <_printf_i+0x1f8>
    6d30:	68e0      	ldr	r0, [r4, #12]
    6d32:	9b03      	ldr	r3, [sp, #12]
    6d34:	4298      	cmp	r0, r3
    6d36:	bfb8      	it	lt
    6d38:	4618      	movlt	r0, r3
    6d3a:	e00f      	b.n	6d5c <_printf_i+0x218>
    6d3c:	2500      	movs	r5, #0
    6d3e:	68e2      	ldr	r2, [r4, #12]
    6d40:	9b03      	ldr	r3, [sp, #12]
    6d42:	1ad3      	subs	r3, r2, r3
    6d44:	429d      	cmp	r5, r3
    6d46:	daf3      	bge.n	6d30 <_printf_i+0x1ec>
    6d48:	4640      	mov	r0, r8
    6d4a:	4649      	mov	r1, r9
    6d4c:	f104 0219 	add.w	r2, r4, #25
    6d50:	2301      	movs	r3, #1
    6d52:	47d0      	blx	sl
    6d54:	3001      	adds	r0, #1
    6d56:	d0de      	beq.n	6d16 <_printf_i+0x1d2>
    6d58:	3501      	adds	r5, #1
    6d5a:	e7f0      	b.n	6d3e <_printf_i+0x1fa>
    6d5c:	b004      	add	sp, #16
    6d5e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    6d62:	bf00      	nop
    6d64:	000075f1 	strdeq	r7, [r0], -r1
    6d68:	00007602 	andeq	r7, r0, r2, lsl #12

00006d6c <memchr>:
    6d6c:	b510      	push	{r4, lr}
    6d6e:	b2c9      	uxtb	r1, r1
    6d70:	4402      	add	r2, r0
    6d72:	4290      	cmp	r0, r2
    6d74:	4603      	mov	r3, r0
    6d76:	d005      	beq.n	6d84 <memchr+0x18>
    6d78:	781c      	ldrb	r4, [r3, #0]
    6d7a:	3001      	adds	r0, #1
    6d7c:	428c      	cmp	r4, r1
    6d7e:	d1f8      	bne.n	6d72 <memchr+0x6>
    6d80:	4618      	mov	r0, r3
    6d82:	bd10      	pop	{r4, pc}
    6d84:	2000      	movs	r0, #0
    6d86:	bd10      	pop	{r4, pc}

00006d88 <memmove>:
    6d88:	4281      	cmp	r1, r0
    6d8a:	b570      	push	{r4, r5, r6, lr}
    6d8c:	d301      	bcc.n	6d92 <memmove+0xa>
    6d8e:	2300      	movs	r3, #0
    6d90:	e00e      	b.n	6db0 <memmove+0x28>
    6d92:	188c      	adds	r4, r1, r2
    6d94:	42a0      	cmp	r0, r4
    6d96:	d2fa      	bcs.n	6d8e <memmove+0x6>
    6d98:	1885      	adds	r5, r0, r2
    6d9a:	4613      	mov	r3, r2
    6d9c:	f113 33ff 	adds.w	r3, r3, #4294967295
    6da0:	d305      	bcc.n	6dae <memmove+0x26>
    6da2:	4251      	negs	r1, r2
    6da4:	1866      	adds	r6, r4, r1
    6da6:	5cf6      	ldrb	r6, [r6, r3]
    6da8:	4429      	add	r1, r5
    6daa:	54ce      	strb	r6, [r1, r3]
    6dac:	e7f6      	b.n	6d9c <memmove+0x14>
    6dae:	bd70      	pop	{r4, r5, r6, pc}
    6db0:	4293      	cmp	r3, r2
    6db2:	d003      	beq.n	6dbc <memmove+0x34>
    6db4:	5ccc      	ldrb	r4, [r1, r3]
    6db6:	54c4      	strb	r4, [r0, r3]
    6db8:	3301      	adds	r3, #1
    6dba:	e7f9      	b.n	6db0 <memmove+0x28>
    6dbc:	bd70      	pop	{r4, r5, r6, pc}
	...

00006dc0 <_free_r>:
    6dc0:	b530      	push	{r4, r5, lr}
    6dc2:	2900      	cmp	r1, #0
    6dc4:	d03c      	beq.n	6e40 <_free_r+0x80>
    6dc6:	f851 2c04 	ldr.w	r2, [r1, #-4]
    6dca:	1f0b      	subs	r3, r1, #4
    6dcc:	491d      	ldr	r1, [pc, #116]	; (6e44 <_free_r+0x84>)
    6dce:	2a00      	cmp	r2, #0
    6dd0:	bfb8      	it	lt
    6dd2:	189b      	addlt	r3, r3, r2
    6dd4:	680a      	ldr	r2, [r1, #0]
    6dd6:	460c      	mov	r4, r1
    6dd8:	b912      	cbnz	r2, 6de0 <_free_r+0x20>
    6dda:	605a      	str	r2, [r3, #4]
    6ddc:	600b      	str	r3, [r1, #0]
    6dde:	bd30      	pop	{r4, r5, pc}
    6de0:	4293      	cmp	r3, r2
    6de2:	d20d      	bcs.n	6e00 <_free_r+0x40>
    6de4:	6819      	ldr	r1, [r3, #0]
    6de6:	1858      	adds	r0, r3, r1
    6de8:	4290      	cmp	r0, r2
    6dea:	d103      	bne.n	6df4 <_free_r+0x34>
    6dec:	585a      	ldr	r2, [r3, r1]
    6dee:	4411      	add	r1, r2
    6df0:	6842      	ldr	r2, [r0, #4]
    6df2:	6019      	str	r1, [r3, #0]
    6df4:	605a      	str	r2, [r3, #4]
    6df6:	6023      	str	r3, [r4, #0]
    6df8:	bd30      	pop	{r4, r5, pc}
    6dfa:	4299      	cmp	r1, r3
    6dfc:	d803      	bhi.n	6e06 <_free_r+0x46>
    6dfe:	460a      	mov	r2, r1
    6e00:	6851      	ldr	r1, [r2, #4]
    6e02:	2900      	cmp	r1, #0
    6e04:	d1f9      	bne.n	6dfa <_free_r+0x3a>
    6e06:	6814      	ldr	r4, [r2, #0]
    6e08:	1915      	adds	r5, r2, r4
    6e0a:	429d      	cmp	r5, r3
    6e0c:	d10a      	bne.n	6e24 <_free_r+0x64>
    6e0e:	681b      	ldr	r3, [r3, #0]
    6e10:	4423      	add	r3, r4
    6e12:	18d0      	adds	r0, r2, r3
    6e14:	4288      	cmp	r0, r1
    6e16:	6013      	str	r3, [r2, #0]
    6e18:	d112      	bne.n	6e40 <_free_r+0x80>
    6e1a:	6808      	ldr	r0, [r1, #0]
    6e1c:	4403      	add	r3, r0
    6e1e:	6013      	str	r3, [r2, #0]
    6e20:	684b      	ldr	r3, [r1, #4]
    6e22:	e00c      	b.n	6e3e <_free_r+0x7e>
    6e24:	d902      	bls.n	6e2c <_free_r+0x6c>
    6e26:	230c      	movs	r3, #12
    6e28:	6003      	str	r3, [r0, #0]
    6e2a:	bd30      	pop	{r4, r5, pc}
    6e2c:	6818      	ldr	r0, [r3, #0]
    6e2e:	181c      	adds	r4, r3, r0
    6e30:	428c      	cmp	r4, r1
    6e32:	d103      	bne.n	6e3c <_free_r+0x7c>
    6e34:	680c      	ldr	r4, [r1, #0]
    6e36:	6849      	ldr	r1, [r1, #4]
    6e38:	4420      	add	r0, r4
    6e3a:	6018      	str	r0, [r3, #0]
    6e3c:	6059      	str	r1, [r3, #4]
    6e3e:	6053      	str	r3, [r2, #4]
    6e40:	bd30      	pop	{r4, r5, pc}
    6e42:	bf00      	nop
    6e44:	20000dd4 	ldrdcs	r0, [r0], -r4

00006e48 <_malloc_r>:
    6e48:	b570      	push	{r4, r5, r6, lr}
    6e4a:	1ccd      	adds	r5, r1, #3
    6e4c:	f025 0503 	bic.w	r5, r5, #3
    6e50:	3508      	adds	r5, #8
    6e52:	2d0c      	cmp	r5, #12
    6e54:	bf38      	it	cc
    6e56:	250c      	movcc	r5, #12
    6e58:	2d00      	cmp	r5, #0
    6e5a:	4606      	mov	r6, r0
    6e5c:	db3f      	blt.n	6ede <_malloc_r+0x96>
    6e5e:	428d      	cmp	r5, r1
    6e60:	d33d      	bcc.n	6ede <_malloc_r+0x96>
    6e62:	4b21      	ldr	r3, [pc, #132]	; (6ee8 <_malloc_r+0xa0>)
    6e64:	681c      	ldr	r4, [r3, #0]
    6e66:	4618      	mov	r0, r3
    6e68:	4621      	mov	r1, r4
    6e6a:	b1a1      	cbz	r1, 6e96 <_malloc_r+0x4e>
    6e6c:	680b      	ldr	r3, [r1, #0]
    6e6e:	1b5b      	subs	r3, r3, r5
    6e70:	d40e      	bmi.n	6e90 <_malloc_r+0x48>
    6e72:	2b0b      	cmp	r3, #11
    6e74:	d903      	bls.n	6e7e <_malloc_r+0x36>
    6e76:	600b      	str	r3, [r1, #0]
    6e78:	18cc      	adds	r4, r1, r3
    6e7a:	50cd      	str	r5, [r1, r3]
    6e7c:	e01f      	b.n	6ebe <_malloc_r+0x76>
    6e7e:	428c      	cmp	r4, r1
    6e80:	d102      	bne.n	6e88 <_malloc_r+0x40>
    6e82:	6862      	ldr	r2, [r4, #4]
    6e84:	6002      	str	r2, [r0, #0]
    6e86:	e01a      	b.n	6ebe <_malloc_r+0x76>
    6e88:	684b      	ldr	r3, [r1, #4]
    6e8a:	6063      	str	r3, [r4, #4]
    6e8c:	460c      	mov	r4, r1
    6e8e:	e016      	b.n	6ebe <_malloc_r+0x76>
    6e90:	460c      	mov	r4, r1
    6e92:	6849      	ldr	r1, [r1, #4]
    6e94:	e7e9      	b.n	6e6a <_malloc_r+0x22>
    6e96:	4c15      	ldr	r4, [pc, #84]	; (6eec <_malloc_r+0xa4>)
    6e98:	6823      	ldr	r3, [r4, #0]
    6e9a:	b91b      	cbnz	r3, 6ea4 <_malloc_r+0x5c>
    6e9c:	4630      	mov	r0, r6
    6e9e:	f000 f84d 	bl	6f3c <_sbrk_r>
    6ea2:	6020      	str	r0, [r4, #0]
    6ea4:	4629      	mov	r1, r5
    6ea6:	4630      	mov	r0, r6
    6ea8:	f000 f848 	bl	6f3c <_sbrk_r>
    6eac:	1c43      	adds	r3, r0, #1
    6eae:	4601      	mov	r1, r0
    6eb0:	d015      	beq.n	6ede <_malloc_r+0x96>
    6eb2:	1cc4      	adds	r4, r0, #3
    6eb4:	f024 0403 	bic.w	r4, r4, #3
    6eb8:	4284      	cmp	r4, r0
    6eba:	d10a      	bne.n	6ed2 <_malloc_r+0x8a>
    6ebc:	6025      	str	r5, [r4, #0]
    6ebe:	f104 000b 	add.w	r0, r4, #11
    6ec2:	1d23      	adds	r3, r4, #4
    6ec4:	f020 0007 	bic.w	r0, r0, #7
    6ec8:	1ac3      	subs	r3, r0, r3
    6eca:	d00b      	beq.n	6ee4 <_malloc_r+0x9c>
    6ecc:	425a      	negs	r2, r3
    6ece:	50e2      	str	r2, [r4, r3]
    6ed0:	bd70      	pop	{r4, r5, r6, pc}
    6ed2:	4630      	mov	r0, r6
    6ed4:	1a61      	subs	r1, r4, r1
    6ed6:	f000 f831 	bl	6f3c <_sbrk_r>
    6eda:	3001      	adds	r0, #1
    6edc:	d1ee      	bne.n	6ebc <_malloc_r+0x74>
    6ede:	230c      	movs	r3, #12
    6ee0:	6033      	str	r3, [r6, #0]
    6ee2:	2000      	movs	r0, #0
    6ee4:	bd70      	pop	{r4, r5, r6, pc}
    6ee6:	bf00      	nop
    6ee8:	20000dd4 	ldrdcs	r0, [r0], -r4
    6eec:	20000dd0 	ldrdcs	r0, [r0], -r0	; <UNPREDICTABLE>

00006ef0 <_realloc_r>:
    6ef0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    6ef2:	4606      	mov	r6, r0
    6ef4:	4614      	mov	r4, r2
    6ef6:	460d      	mov	r5, r1
    6ef8:	b921      	cbnz	r1, 6f04 <_realloc_r+0x14>
    6efa:	4611      	mov	r1, r2
    6efc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    6f00:	f7ff bfa2 	b.w	6e48 <_malloc_r>
    6f04:	b91a      	cbnz	r2, 6f0e <_realloc_r+0x1e>
    6f06:	f7ff ff5b 	bl	6dc0 <_free_r>
    6f0a:	4620      	mov	r0, r4
    6f0c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6f0e:	f000 f82d 	bl	6f6c <_malloc_usable_size_r>
    6f12:	42a0      	cmp	r0, r4
    6f14:	d20e      	bcs.n	6f34 <_realloc_r+0x44>
    6f16:	4630      	mov	r0, r6
    6f18:	4621      	mov	r1, r4
    6f1a:	f7ff ff95 	bl	6e48 <_malloc_r>
    6f1e:	4607      	mov	r7, r0
    6f20:	b150      	cbz	r0, 6f38 <_realloc_r+0x48>
    6f22:	4629      	mov	r1, r5
    6f24:	4622      	mov	r2, r4
    6f26:	f7ff fc1b 	bl	6760 <memcpy>
    6f2a:	4630      	mov	r0, r6
    6f2c:	4629      	mov	r1, r5
    6f2e:	f7ff ff47 	bl	6dc0 <_free_r>
    6f32:	e001      	b.n	6f38 <_realloc_r+0x48>
    6f34:	4628      	mov	r0, r5
    6f36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    6f38:	4638      	mov	r0, r7
    6f3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

00006f3c <_sbrk_r>:
    6f3c:	b538      	push	{r3, r4, r5, lr}
    6f3e:	4c06      	ldr	r4, [pc, #24]	; (6f58 <_sbrk_r+0x1c>)
    6f40:	2300      	movs	r3, #0
    6f42:	4605      	mov	r5, r0
    6f44:	4608      	mov	r0, r1
    6f46:	6023      	str	r3, [r4, #0]
    6f48:	f000 f81a 	bl	6f80 <_sbrk>
    6f4c:	1c43      	adds	r3, r0, #1
    6f4e:	d102      	bne.n	6f56 <_sbrk_r+0x1a>
    6f50:	6823      	ldr	r3, [r4, #0]
    6f52:	b103      	cbz	r3, 6f56 <_sbrk_r+0x1a>
    6f54:	602b      	str	r3, [r5, #0]
    6f56:	bd38      	pop	{r3, r4, r5, pc}
    6f58:	200005b0 			; <UNDEFINED> instruction: 0x200005b0

00006f5c <strlen>:
    6f5c:	4603      	mov	r3, r0
    6f5e:	f813 2b01 	ldrb.w	r2, [r3], #1
    6f62:	2a00      	cmp	r2, #0
    6f64:	d1fb      	bne.n	6f5e <strlen+0x2>
    6f66:	1a18      	subs	r0, r3, r0
    6f68:	3801      	subs	r0, #1
    6f6a:	4770      	bx	lr

00006f6c <_malloc_usable_size_r>:
    6f6c:	f851 0c04 	ldr.w	r0, [r1, #-4]
    6f70:	2800      	cmp	r0, #0
    6f72:	da02      	bge.n	6f7a <_malloc_usable_size_r+0xe>
    6f74:	3904      	subs	r1, #4
    6f76:	580b      	ldr	r3, [r1, r0]
    6f78:	4418      	add	r0, r3
    6f7a:	3804      	subs	r0, #4
    6f7c:	4770      	bx	lr
	...

00006f80 <_sbrk>:
    6f80:	4a09      	ldr	r2, [pc, #36]	; (6fa8 <_sbrk+0x28>)
    6f82:	6813      	ldr	r3, [r2, #0]
    6f84:	b163      	cbz	r3, 6fa0 <_sbrk+0x20>
    6f86:	4418      	add	r0, r3
    6f88:	4669      	mov	r1, sp
    6f8a:	4288      	cmp	r0, r1
    6f8c:	d802      	bhi.n	6f94 <_sbrk+0x14>
    6f8e:	6010      	str	r0, [r2, #0]
    6f90:	4618      	mov	r0, r3
    6f92:	4770      	bx	lr
    6f94:	4b05      	ldr	r3, [pc, #20]	; (6fac <_sbrk+0x2c>)
    6f96:	220c      	movs	r2, #12
    6f98:	601a      	str	r2, [r3, #0]
    6f9a:	f04f 30ff 	mov.w	r0, #4294967295
    6f9e:	4770      	bx	lr
    6fa0:	4b03      	ldr	r3, [pc, #12]	; (6fb0 <_sbrk+0x30>)
    6fa2:	6013      	str	r3, [r2, #0]
    6fa4:	e7ef      	b.n	6f86 <_sbrk+0x6>
    6fa6:	bf00      	nop
    6fa8:	20000dd8 	ldrdcs	r0, [r0], -r8
    6fac:	200005b0 			; <UNDEFINED> instruction: 0x200005b0
    6fb0:	200005b4 			; <UNDEFINED> instruction: 0x200005b4
    6fb4:	6f6f420a 	svcvs	0x006f420a
    6fb8:	616f6c74 	smcvs	63172	; 0xf6c4
    6fbc:	20726564 	rsbscs	r6, r2, r4, ror #10
    6fc0:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
    6fc4:	0a2e2e2e 	beq	b92884 <_etext+0xb8b270>
    6fc8:	65686300 	strbvs	r6, [r8, #-768]!	; 0x300
    6fcc:	6e696b63 	vnmulvs.f64	d22, d9, d19
    6fd0:	68632067 	stmdavs	r3!, {r0, r1, r2, r5, r6, sp}^
    6fd4:	2e6e6961 	cdpcs	9, 6, cr6, cr14, cr1, {3}
    6fd8:	000a2e2e 	andeq	r2, sl, lr, lsr #28
    6fdc:	67616d69 	strbvs	r6, [r1, -r9, ror #26]!
    6fe0:	68632065 	stmdavs	r3!, {r0, r2, r5, r6, sp}^
    6fe4:	206b6365 	rsbcs	r6, fp, r5, ror #6
    6fe8:	3a746572 	bcc	1d205b8 <_etext+0x1d18fa4>
    6fec:	0a582520 	beq	1610474 <_etext+0x1608e60>
    6ff0:	6f6f4200 	svcvs	0x006f4200
    6ff4:	4b4f2074 	blmi	13cf1cc <_etext+0x13c7bb8>
    6ff8:	6946000a 	stmdbvs	r6, {r1, r3}^
    6ffc:	61776d72 	cmnvs	r7, r2, ror sp
    7000:	6d206572 	cfstr32vs	mvfx6, [r0, #-456]!	; 0xfffffe38
    7004:	69737369 	ldmdbvs	r3!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}^
    7008:	2e2e676e 	cdpcs	7, 2, cr6, cr14, cr14, {3}
    700c:	6177202e 	cmnvs	r7, lr, lsr #32
    7010:	6e697469 	cdpvs	4, 6, cr7, cr9, cr9, {3}
    7014:	6e692067 	cdpvs	0, 6, cr2, cr9, cr7, {3}
    7018:	55464420 	strbpl	r4, [r6, #-1056]	; 0x420
    701c:	6953000a 	ldmdbvs	r3, {r1, r3}^
    7020:	74616e67 	strbtvc	r6, [r1], #-3687	; 0xe67
    7024:	20657275 	rsbcs	r7, r5, r5, ror r2
    7028:	65766e75 	ldrbvs	r6, [r6, #-3701]!	; 0xe75
    702c:	69666972 	stmdbvs	r6!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    7030:	2e2e6465 	cdpcs	4, 2, cr6, cr14, cr5, {3}
    7034:	6177202e 	cmnvs	r7, lr, lsr #32
    7038:	6e697469 	cdpvs	4, 6, cr7, cr9, cr9, {3}
    703c:	6e692067 	cdpvs	0, 6, cr2, cr9, cr7, {3}
    7040:	55464420 	strbpl	r4, [r6, #-1056]	; 0x420
    7044:	6148000a 	cmpvs	r8, sl
    7048:	63206873 	teqvs	r0, #7536640	; 0x730000
    704c:	75636c61 	strbvc	r6, [r3, #-3169]!	; 0xc61
    7050:	6974616c 	ldmdbvs	r4!, {r2, r3, r5, r6, r8, sp, lr}^
    7054:	66206e6f 	strtvs	r6, [r0], -pc, ror #28
    7058:	656c6961 	strbvs	r6, [ip, #-2401]!	; 0x961
    705c:	2e2e2e64 	cdpcs	14, 2, cr2, cr14, cr4, {3}
    7060:	69617720 	stmdbvs	r1!, {r5, r8, r9, sl, ip, sp, lr}^
    7064:	676e6974 			; <UNDEFINED> instruction: 0x676e6974
    7068:	206e6920 	rsbcs	r6, lr, r0, lsr #18
    706c:	0a554644 	beq	1558984 <_etext+0x1551370>
    7070:	55464400 	strbpl	r4, [r6, #-1024]	; 0x400
    7074:	6e696620 	cdpvs	6, 6, cr6, cr9, cr0, {1}
    7078:	65687369 	strbvs	r7, [r8, #-873]!	; 0x369
    707c:	70752064 	rsbsvc	r2, r5, r4, rrx
    7080:	64616f6c 	strbtvs	r6, [r1], #-3948	; 0xf6c
    7084:	754a000a 	strbvc	r0, [sl, #-10]
    7088:	6e69706d 	cdpvs	0, 6, cr7, cr9, cr13, {3}
    708c:	6f742067 	svcvs	0x00742067
    7090:	2e534f20 	cdpcs	15, 5, cr4, cr3, cr0, {1}
    7094:	7c20000a 	stcvc	0, cr0, [r0], #-40	; 0xffffffd8
    7098:	0a7c7325 	beq	1f23d34 <_etext+0x1f1c720>
    709c:	32302500 	eorscc	r2, r0, #0, 10
    70a0:	20002058 	andcs	r2, r0, r8, asr r0
    70a4:	25002020 	strcs	r2, [r0, #-32]
    70a8:	00783230 	rsbseq	r3, r8, r0, lsr r2
    70ac:	6f6c7055 	svcvs	0x006c7055
    70b0:	64656461 	strbtvs	r6, [r5], #-1121	; 0x461
    70b4:	67697320 	strbvs	r7, [r9, -r0, lsr #6]!
    70b8:	7574616e 	ldrbvc	r6, [r4, #-366]!	; 0x16e
    70bc:	76206572 			; <UNDEFINED> instruction: 0x76206572
    70c0:	66697265 	strbtvs	r7, [r9], -r5, ror #4
    70c4:	21646569 	cmncs	r4, r9, ror #10
    70c8:	6d49000a 	stclvs	0, cr0, [r9, #-40]	; 0xffffffd8
    70cc:	20656761 	rsbcs	r6, r5, r1, ror #14
    70d0:	65766e75 	ldrbvs	r6, [r6, #-3701]!	; 0xe75
    70d4:	69666972 	stmdbvs	r6!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    70d8:	2e2e6465 	cdpcs	4, 2, cr6, cr14, cr5, {3}
    70dc:	6977202e 	ldmdbvs	r7!, {r1, r2, r3, r5, sp}^
    70e0:	20646570 	rsbcs	r6, r4, r0, ror r5
    70e4:	6f6d656d 	svcvs	0x006d656d
    70e8:	66207972 			; <UNDEFINED> instruction: 0x66207972
    70ec:	6320726f 	teqvs	r0, #-268435450	; 0xf0000006
    70f0:	6e61656c 	cdpvs	5, 6, cr6, cr1, cr12, {3}
    70f4:	73657220 	cmnvc	r5, #32, 4
    70f8:	0a2e7465 	beq	ba4294 <_etext+0xb9cc80>
    70fc:	00000000 	andeq	r0, r0, r0

00007100 <ed25519_k>:
    7100:	26b2f159 	ssatcs	pc, #19, r9, asr #2	; <UNPREDICTABLE>
    7104:	ebd69b94 	bl	ff5adf5c <BootRAM+0xe51e6fd>
    7108:	8283b156 	addhi	fp, r3, #-2147483627	; 0x80000015
    710c:	00e0149a 	smlaleq	r1, r0, sl, r4
    7110:	eef3d130 	mrc	1, 7, sp, cr3, cr0, {1}
    7114:	198e80f2 	stmibne	lr, {r1, r4, r5, r6, r7, pc}
    7118:	56dffce7 	ldrbpl	pc, [pc], r7, ror #25	; <UNPREDICTABLE>
    711c:	2406d9dc 	strcs	sp, [r6], #-2524	; 0x9dc

00007120 <ed25519_neutral>:
	...
    7140:	00000001 	andeq	r0, r0, r1
	...
    7180:	00000001 	andeq	r0, r0, r1
	...

000071a0 <ed25519_base>:
    71a0:	8f25d51a 	svchi	0x0025d51a
    71a4:	c9562d60 	ldmdbgt	r6, {r5, r6, r8, sl, fp, sp}^
    71a8:	9525a7b2 	strls	sl, [r5, #-1970]!	; 0x7b2
    71ac:	692cc760 	stmdbvs	ip!, {r5, r6, r8, r9, sl, lr, pc}
    71b0:	fdd6dc5c 	ldc2l	12, cr13, [r6, #368]	; 0x170
    71b4:	c0a4e231 	adcgt	lr, r4, r1, lsr r2
    71b8:	cd6e53fe 	stclgt	3, cr5, [lr, #-1016]!	; 0xfffffc08
    71bc:	216936d3 	ldrdcs	r3, [r9, #-99]!	; 0xffffff9d
    71c0:	66666658 			; <UNDEFINED> instruction: 0x66666658
    71c4:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    71c8:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    71cc:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    71d0:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    71d4:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    71d8:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    71dc:	66666666 	strbtvs	r6, [r6], -r6, ror #12
    71e0:	a5b7dda3 	ldrge	sp, [r7, #3491]!	; 0xda3
    71e4:	6dde8ab3 	vldrvs	s17, [lr, #716]	; 0x2cc
    71e8:	775152f5 	smmlsrvc	r1, r5, r2, r5
    71ec:	20f09f80 	rscscs	r9, r0, r0, lsl #31
    71f0:	64abe37d 	strtvs	lr, [fp], #893	; 0x37d
    71f4:	66ea4e8e 	strbtvs	r4, [sl], lr, lsl #29
    71f8:	d78b7665 	strle	r7, [fp, r5, ror #12]
    71fc:	67875f0f 	strvs	r5, [r7, pc, lsl #30]
    7200:	00000001 	andeq	r0, r0, r1
	...

00007220 <ed25519_d>:
    7220:	135978a3 	cmpne	r9, #10682368	; 0xa30000
    7224:	75eb4dca 	strbvc	r4, [fp, #3530]!	; 0xdca
    7228:	4141d8ab 	smlaltbmi	sp, r1, fp, r8
    722c:	00700a4d 	rsbseq	r0, r0, sp, asr #20
    7230:	7779e898 			; <UNDEFINED> instruction: 0x7779e898
    7234:	8cc74079 	stclhi	0, cr4, [r7], {121}	; 0x79
    7238:	2b6ffe73 	blcs	1c06c0c <_etext+0x1bff5f8>
    723c:	52036cee 	andpl	r6, r3, #60928	; 0xee00

00007240 <ed25519_order>:
    7240:	5cf5d3ed 	ldclpl	3, cr13, [r5], #948	; 0x3b4
    7244:	5812631a 	ldmdapl	r2, {r1, r3, r4, r8, r9, sp, lr}
    7248:	a2f79cd6 	rscsge	r9, r7, #54784	; 0xd600
    724c:	14def9de 	ldrbne	pc, [lr], #2526	; 0x9de	; <UNPREDICTABLE>
	...
    725c:	10000000 	andne	r0, r0, r0

00007260 <f25519_one>:
    7260:	00000001 	andeq	r0, r0, r1
	...

00007280 <sha512_initial_state>:
    7280:	f3bcc908 	vtbl.8	d12, {d12-d13}, d8
    7284:	6a09e667 	bvs	280c28 <_etext+0x279614>
    7288:	84caa73b 	strbhi	sl, [sl], #1851	; 0x73b
    728c:	bb67ae85 	bllt	19f2ca8 <_etext+0x19eb694>
    7290:	fe94f82b 	cdp2	8, 9, cr15, cr4, cr11, {1}
    7294:	3c6ef372 	stclcc	3, cr15, [lr], #-456	; 0xfffffe38
    7298:	5f1d36f1 	svcpl	0x001d36f1
    729c:	a54ff53a 	strbge	pc, [pc, #-1338]	; 6d6a <_printf_i+0x226>	; <UNPREDICTABLE>
    72a0:	ade682d1 	sfmge	f0, 3, [r6, #836]!	; 0x344
    72a4:	510e527f 	tstpl	lr, pc, ror r2
    72a8:	2b3e6c1f 	blcs	fa232c <_etext+0xf9ad18>
    72ac:	9b05688c 	blls	1614e4 <_etext+0x159ed0>
    72b0:	fb41bd6b 	blx	1076866 <_etext+0x106f252>
    72b4:	1f83d9ab 	svcne	0x0083d9ab
    72b8:	137e2179 	cmnne	lr, #1073741854	; 0x4000001e
    72bc:	5be0cd19 	blpl	ff83a728 <BootRAM+0xe7aaec9>

000072c0 <round_k>:
    72c0:	d728ae22 	strle	sl, [r8, -r2, lsr #28]!
    72c4:	428a2f98 	addmi	r2, sl, #152, 30	; 0x260
    72c8:	23ef65cd 	mvncs	r6, #859832320	; 0x33400000
    72cc:	71374491 			; <UNDEFINED> instruction: 0x71374491
    72d0:	ec4d3b2f 	mcrr	11, 2, r3, sp, cr15
    72d4:	b5c0fbcf 	strblt	pc, [r0, #3023]	; 0xbcf	; <UNPREDICTABLE>
    72d8:	8189dbbc 			; <UNDEFINED> instruction: 0x8189dbbc
    72dc:	e9b5dba5 	ldmib	r5!, {r0, r2, r5, r7, r8, r9, fp, ip, lr, pc}
    72e0:	f348b538 	vqrshl.u8	d27, d24, d8
    72e4:	3956c25b 	ldmdbcc	r6, {r0, r1, r3, r4, r6, r9, lr, pc}^
    72e8:	b605d019 			; <UNDEFINED> instruction: 0xb605d019
    72ec:	59f111f1 	ldmibpl	r1!, {r0, r4, r5, r6, r7, r8, ip}^
    72f0:	af194f9b 	svcge	0x00194f9b
    72f4:	923f82a4 	eorsls	r8, pc, #164, 4	; 0x4000000a
    72f8:	da6d8118 	ble	1b67760 <_etext+0x1b6014c>
    72fc:	ab1c5ed5 	blge	71ee58 <_etext+0x717844>
    7300:	a3030242 	movwge	r0, #12866	; 0x3242
    7304:	d807aa98 	stmdale	r7, {r3, r4, r7, r9, fp, sp, pc}
    7308:	45706fbe 	ldrbmi	r6, [r0, #-4030]!	; 0xfbe
    730c:	12835b01 	addne	r5, r3, #1024	; 0x400
    7310:	4ee4b28c 	cdpmi	2, 14, cr11, cr4, cr12, {4}
    7314:	243185be 	ldrtcs	r8, [r1], #-1470	; 0x5be
    7318:	d5ffb4e2 	ldrble	fp, [pc, #1250]!	; 7802 <_etext+0x1ee>
    731c:	550c7dc3 	strpl	r7, [ip, #-3523]	; 0xdc3
    7320:	f27b896f 	vmla.i<illegal width 64>	q12, <illegal reg q5.5>, <illegal reg q15.5>
    7324:	72be5d74 	adcsvc	r5, lr, #116, 26	; 0x1d00
    7328:	3b1696b1 	blcc	5acdf4 <_etext+0x5a57e0>
    732c:	80deb1fe 	ldrshhi	fp, [lr], #30
    7330:	25c71235 	strbcs	r1, [r7, #565]	; 0x235
    7334:	9bdc06a7 	blls	ff708dd8 <BootRAM+0xe679579>
    7338:	cf692694 	svcgt	0x00692694
    733c:	c19bf174 	orrsgt	pc, fp, r4, ror r1	; <UNPREDICTABLE>
    7340:	9ef14ad2 	mrcls	10, 7, r4, cr1, cr2, {6}
    7344:	e49b69c1 	ldr	r6, [fp], #2497	; 0x9c1
    7348:	384f25e3 	stmdacc	pc, {r0, r1, r5, r6, r7, r8, sl, sp}^	; <UNPREDICTABLE>
    734c:	efbe4786 	svc	0x00be4786
    7350:	8b8cd5b5 	blhi	fe33ca2c <BootRAM+0xd2ad1cd>
    7354:	0fc19dc6 	svceq	0x00c19dc6
    7358:	77ac9c65 	strvc	r9, [ip, r5, ror #24]!
    735c:	240ca1cc 	strcs	sl, [ip], #-460	; 0x1cc
    7360:	592b0275 	stmdbpl	fp!, {r0, r2, r4, r5, r6, r9}
    7364:	2de92c6f 	stclcs	12, cr2, [r9, #444]!	; 0x1bc
    7368:	6ea6e483 	cdpvs	4, 10, cr14, cr6, cr3, {4}
    736c:	4a7484aa 	bmi	1d2861c <_etext+0x1d21008>
    7370:	bd41fbd4 	vstrlt	d31, [r1, #-848]	; 0xfffffcb0
    7374:	5cb0a9dc 	ldcpl	9, cr10, [r0], #880	; 0x370
    7378:	831153b5 	tsthi	r1, #-738197502	; 0xd4000002
    737c:	76f988da 	usatvc	r8, #25, sl, asr #17
    7380:	ee66dfab 	cdp	15, 6, cr13, cr6, cr11, {5}
    7384:	983e5152 	ldmdals	lr!, {r1, r4, r6, r8, ip, lr}
    7388:	2db43210 	lfmcs	f3, 4, [r4, #64]!	; 0x40
    738c:	a831c66d 	ldmdage	r1!, {r0, r2, r3, r5, r6, r9, sl, lr, pc}
    7390:	98fb213f 	ldmls	fp!, {r0, r1, r2, r3, r4, r5, r8, sp}^
    7394:	b00327c8 	andlt	r2, r3, r8, asr #15
    7398:	beef0ee4 	cdplt	14, 14, cr0, cr15, cr4, {7}
    739c:	bf597fc7 	svclt	0x00597fc7
    73a0:	3da88fc2 	stccc	15, cr8, [r8, #776]!	; 0x308
    73a4:	c6e00bf3 			; <UNDEFINED> instruction: 0xc6e00bf3
    73a8:	930aa725 	movwls	sl, #42789	; 0xa725
    73ac:	d5a79147 	strle	r9, [r7, #327]!	; 0x147
    73b0:	e003826f 	and	r8, r3, pc, ror #4
    73b4:	06ca6351 			; <UNDEFINED> instruction: 0x06ca6351
    73b8:	0a0e6e70 	beq	3a2d80 <_etext+0x39b76c>
    73bc:	14292967 	strtne	r2, [r9], #-2407	; 0x967
    73c0:	46d22ffc 			; <UNDEFINED> instruction: 0x46d22ffc
    73c4:	27b70a85 	ldrcs	r0, [r7, r5, lsl #21]!
    73c8:	5c26c926 	stcpl	9, cr12, [r6], #-152	; 0xffffff68
    73cc:	2e1b2138 	mrccs	1, 0, r2, cr11, cr8, {1}
    73d0:	5ac42aed 	bpl	ff111f8c <BootRAM+0xe08272d>
    73d4:	4d2c6dfc 	stcmi	13, cr6, [ip, #-1008]!	; 0xfffffc10
    73d8:	9d95b3df 	ldcls	3, cr11, [r5, #892]	; 0x37c
    73dc:	53380d13 	teqpl	r8, #1216	; 0x4c0
    73e0:	8baf63de 	blhi	febe0360 <BootRAM+0xdb50b01>
    73e4:	650a7354 	strvs	r7, [sl, #-852]	; 0x354
    73e8:	3c77b2a8 	lfmcc	f3, 3, [r7], #-672	; 0xfffffd60
    73ec:	766a0abb 			; <UNDEFINED> instruction: 0x766a0abb
    73f0:	47edaee6 	strbmi	sl, [sp, r6, ror #29]!
    73f4:	81c2c92e 	bichi	ip, r2, lr, lsr #18
    73f8:	1482353b 	strne	r3, [r2], #1339	; 0x53b
    73fc:	92722c85 	rsbsls	r2, r2, #34048	; 0x8500
    7400:	4cf10364 	ldclmi	3, cr0, [r1], #400	; 0x190
    7404:	a2bfe8a1 	adcsge	lr, pc, #10551296	; 0xa10000
    7408:	bc423001 	mcrrlt	0, 0, r3, r2, cr1
    740c:	a81a664b 	ldmdage	sl, {r0, r1, r3, r6, r9, sl, sp, lr}
    7410:	d0f89791 	smlalsle	r9, r8, r1, r7
    7414:	c24b8b70 	subgt	r8, fp, #112, 22	; 0x1c000
    7418:	0654be30 			; <UNDEFINED> instruction: 0x0654be30
    741c:	c76c51a3 	strbgt	r5, [ip, -r3, lsr #3]!
    7420:	d6ef5218 	usatle	r5, #15, r8, lsl #4
    7424:	d192e819 	orrsle	lr, r2, r9, lsl r8
    7428:	5565a910 	strbpl	sl, [r5, #-2320]!	; 0x910
    742c:	d6990624 	ldrle	r0, [r9], r4, lsr #12
    7430:	5771202a 	ldrbpl	r2, [r1, -sl, lsr #32]!
    7434:	f40e3585 	vst3.32	{d3,d5,d7}, [lr], r5
    7438:	32bbd1b8 	adcscc	sp, fp, #184, 2	; 0x2e
    743c:	106aa070 	rsbne	sl, sl, r0, ror r0
    7440:	b8d2d0c8 	ldmlt	r2, {r3, r6, r7, ip, lr, pc}^
    7444:	19a4c116 	stmibne	r4!, {r1, r2, r4, r8, lr, pc}
    7448:	5141ab53 	cmppl	r1, r3, asr fp
    744c:	1e376c08 	cdpne	12, 3, cr6, cr7, cr8, {0}
    7450:	df8eeb99 	svcle	0x008eeb99
    7454:	2748774c 	strbcs	r7, [r8, -ip, asr #14]
    7458:	e19b48a8 	orrs	r4, fp, r8, lsr #17
    745c:	34b0bcb5 	ldrtcc	fp, [r0], #3253	; 0xcb5
    7460:	c5c95a63 	strbgt	r5, [r9, #2659]	; 0xa63
    7464:	391c0cb3 	ldmdbcc	ip, {r0, r1, r4, r5, r7, sl, fp}
    7468:	e3418acb 	movt	r8, #6859	; 0x1acb
    746c:	4ed8aa4a 	vfnmami.f32	s21, s16, s20
    7470:	7763e373 			; <UNDEFINED> instruction: 0x7763e373
    7474:	5b9cca4f 	blpl	fe739db8 <BootRAM+0xd6aa559>
    7478:	d6b2b8a3 	ldrtle	fp, [r2], r3, lsr #17
    747c:	682e6ff3 	stmdavs	lr!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
    7480:	5defb2fc 	sfmpl	f3, 3, [pc, #1008]!	; 7878 <_etext+0x264>
    7484:	748f82ee 	strvc	r8, [pc], #750	; 748c <round_k+0x1cc>
    7488:	43172f60 	tstmi	r7, #96, 30	; 0x180
    748c:	78a5636f 	stmiavc	r5!, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}
    7490:	a1f0ab72 	mvnsge	sl, r2, ror fp
    7494:	84c87814 	strbhi	r7, [r8], #2068	; 0x814
    7498:	1a6439ec 	bne	1915c50 <_etext+0x190e63c>
    749c:	8cc70208 	sfmhi	f0, 2, [r7], {8}
    74a0:	23631e28 	cmncs	r3, #40, 28	; 0x280
    74a4:	90befffa 	ldrshtls	pc, [lr], sl	; <UNPREDICTABLE>
    74a8:	de82bde9 	cdple	13, 8, cr11, cr2, cr9, {7}
    74ac:	a4506ceb 	ldrbge	r6, [r0], #-3307	; 0xceb
    74b0:	b2c67915 	sbclt	r7, r6, #344064	; 0x54000
    74b4:	bef9a3f7 	mrclt	3, 7, sl, cr9, cr7, {7}
    74b8:	e372532b 	cmn	r2, #-1409286144	; 0xac000000
    74bc:	c67178f2 			; <UNDEFINED> instruction: 0xc67178f2
    74c0:	ea26619c 	b	99fb38 <_etext+0x998524>
    74c4:	ca273ece 	bgt	9d7004 <_etext+0x9cf9f0>
    74c8:	21c0c207 	biccs	ip, r0, r7, lsl #4
    74cc:	d186b8c7 	orrle	fp, r6, r7, asr #17
    74d0:	cde0eb1e 	stclgt	11, cr14, [r0, #120]!	; 0x78
    74d4:	eada7dd6 	b	ff6a6c34 <BootRAM+0xe6173d5>
    74d8:	ee6ed178 	mcr	1, 3, sp, cr14, cr8, {3}
    74dc:	f57d4f7f 			; <UNDEFINED> instruction: 0xf57d4f7f
    74e0:	72176fba 	andsvc	r6, r7, #744	; 0x2e8
    74e4:	06f067aa 	ldrbteq	r6, [r0], sl, lsr #15
    74e8:	a2c898a6 	sbcge	r9, r8, #10878976	; 0xa60000
    74ec:	0a637dc5 	beq	18e6c08 <_etext+0x18df5f4>
    74f0:	bef90dae 	cdplt	13, 15, cr0, cr9, cr14, {5}
    74f4:	113f9804 	teqne	pc, r4, lsl #16
    74f8:	131c471b 	tstne	ip, #7077888	; 0x6c0000
    74fc:	1b710b35 	blne	1c4a1d8 <_etext+0x1c42bc4>
    7500:	23047d84 	movwcs	r7, #19844	; 0x4d84
    7504:	28db77f5 	ldmcs	fp, {r0, r2, r4, r5, r6, r7, r8, r9, sl, ip, sp, lr}^
    7508:	40c72493 	smullmi	r2, r7, r3, r4
    750c:	32caab7b 	sbccc	sl, sl, #125952	; 0x1ec00
    7510:	15c9bebc 	strbne	fp, [r9, #3772]	; 0xebc
    7514:	3c9ebe0a 	ldccc	14, cr11, [lr], {10}
    7518:	9c100d4c 	ldcls	13, cr0, [r0], {76}	; 0x4c
    751c:	431d67c4 	tstmi	sp, #196, 14	; 0x3100000
    7520:	cb3e42b6 	blgt	f98000 <_etext+0xf909ec>
    7524:	4cc5d4be 	cfstrdmi	mvd13, [r5], {190}	; 0xbe
    7528:	fc657e2a 	stc2l	14, cr7, [r5], #-168	; 0xffffff58
    752c:	597f299c 	ldmdbpl	pc!, {r2, r3, r4, r7, r8, fp, sp}^	; <UNPREDICTABLE>
    7530:	3ad6faec 	bcc	ff5c60e8 <BootRAM+0xe536889>
    7534:	5fcb6fab 	svcpl	0x00cb6fab
    7538:	4a475817 	bmi	11dd59c <_etext+0x11d5f88>
    753c:	6c44198c 	mcrrvs	9, 8, r1, r4, cr12
    7540:	20646162 	rsbcs	r6, r4, r2, ror #2
    7544:	6967616d 	stmdbvs	r7!, {r0, r2, r3, r5, r6, r8, sp, lr}^
    7548:	78302063 	ldmdavc	r0!, {r0, r1, r5, r6, sp}
    754c:	78383025 	ldmdavc	r8!, {r0, r2, r5, ip, sp}
    7550:	70786520 	rsbsvc	r6, r8, r0, lsr #10
    7554:	69746365 	ldmdbvs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    7558:	3020676e 	eorcc	r6, r0, lr, ror #14
    755c:	38302578 	ldmdacc	r0!, {r3, r4, r5, r6, r8, sl, sp}
    7560:	62000a78 	andvs	r0, r0, #120, 20	; 0x78000
    7564:	6d206461 	cfstrsvs	mvf6, [r0, #-388]!	; 0xfffffe7c
    7568:	63696761 	cmnvs	r9, #25427968	; 0x1840000
    756c:	25783020 	ldrbcs	r3, [r8, #-32]!
    7570:	20783830 	rsbscs	r3, r8, r0, lsr r8
    7574:	65707865 	ldrbvs	r7, [r0, #-2149]!	; 0x865
    7578:	6e697463 	cdpvs	4, 6, cr7, cr9, cr3, {3}
    757c:	78302067 	ldmdavc	r0!, {r0, r1, r2, r5, r6, sp}
    7580:	000a5825 	andeq	r5, sl, r5, lsr #16
    7584:	61746164 	cmnvs	r4, r4, ror #2
    7588:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
    758c:	7830203a 	ldmdavc	r0!, {r1, r3, r4, r5, sp}
    7590:	000a5825 	andeq	r5, sl, r5, lsr #16
    7594:	72617453 	rsbvc	r7, r1, #1392508928	; 0x53000000
    7598:	25203a74 	strcs	r3, [r0, #-2676]!	; 0xa74
    759c:	69460a58 	stmdbvs	r6, {r3, r4, r6, r9, fp}^
    75a0:	6873696e 	ldmdavs	r3!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
    75a4:	5825203a 	stmdapl	r5!, {r1, r3, r4, r5, sp}
    75a8:	6e45000a 	cdpvs	0, 4, cr0, cr5, cr10, {0}
    75ac:	20646564 	rsbcs	r6, r4, r4, ror #10
    75b0:	203a7461 	eorscs	r7, sl, r1, ror #8
    75b4:	000a5825 	andeq	r5, sl, r5, lsr #16
    75b8:	636c6143 	cmnvs	ip, #-1073741808	; 0xc0000010
    75bc:	74616c75 	strbtvc	r6, [r1], #-3189	; 0xc75
    75c0:	68206465 	stmdavs	r0!, {r0, r2, r5, r6, sl, sp, lr}
    75c4:	20687361 	rsbcs	r7, r8, r1, ror #6
    75c8:	70207369 	eorvc	r7, r0, r9, ror #6
    75cc:	61626f72 	smcvs	9970	; 0x26f2
    75d0:	20796c62 	rsbscs	r6, r9, r2, ror #24
    75d4:	6e6f7277 	mcrvs	2, 3, r7, cr15, cr7, {3}
    75d8:	2e2e2e67 	cdpcs	14, 2, cr2, cr14, cr7, {3}
    75dc:	0043000a 	subeq	r0, r3, sl
    75e0:	2b302d23 	blcs	c12a74 <_etext+0xc0b460>
    75e4:	6c680020 	stclvs	0, cr0, [r8], #-128	; 0xffffff80
    75e8:	6665004c 	strbtvs	r0, [r5], -ip, asr #32
    75ec:	47464567 	strbmi	r4, [r6, -r7, ror #10]
    75f0:	32313000 	eorscc	r3, r1, #0
    75f4:	36353433 			; <UNDEFINED> instruction: 0x36353433
    75f8:	41393837 	teqmi	r9, r7, lsr r8
    75fc:	45444342 	strbmi	r4, [r4, #-834]	; 0x342
    7600:	31300046 	teqcc	r0, r6, asr #32
    7604:	35343332 	ldrcc	r3, [r4, #-818]!	; 0x332
    7608:	39383736 	ldmdbcc	r8!, {r1, r2, r4, r5, r8, r9, sl, ip, sp}
    760c:	64636261 	strbtvs	r6, [r3], #-609	; 0x261
    7610:	00006665 	andeq	r6, r0, r5, ror #12

Disassembly of section .data:

20000000 <_sdata>:
20000000:	00000000 	andeq	r0, r0, r0
20000004:	04030201 	streq	r0, [r3], #-513	; 0x201
20000008:	04030201 	streq	r0, [r3], #-513	; 0x201
2000000c:	09080706 	stmdbeq	r8, {r1, r2, r8, r9, sl}

20000010 <ADCPrescTable>:
20000010:	08060402 	stmdaeq	r6, {r1, sl}

20000014 <Device_Property>:
20000014:	00000f1d 	andeq	r0, r0, sp, lsl pc
20000018:	00000bdd 	ldrdeq	r0, [r0], -sp
2000001c:	00000b9b 	muleq	r0, fp, fp
20000020:	00000b9d 	muleq	r0, sp, fp
20000024:	00000c85 	andeq	r0, r0, r5, lsl #25
20000028:	00000d29 	andeq	r0, r0, r9, lsr #26
2000002c:	00000b9f 	muleq	r0, pc, fp	; <UNPREDICTABLE>
20000030:	00000ce5 	andeq	r0, r0, r5, ror #25
20000034:	00000cf1 	strdeq	r0, [r0], -r1
20000038:	00000cfd 	strdeq	r0, [r0], -sp
2000003c:	00000d1d 	andeq	r0, r0, sp, lsl sp
20000040:	00000000 	andeq	r0, r0, r0
20000044:	00000040 	andeq	r0, r0, r0, asr #32

20000048 <pEpInt_IN>:
20000048:	00000b99 	muleq	r0, r9, fp
2000004c:	00000b99 	muleq	r0, r9, fp
20000050:	00000b99 	muleq	r0, r9, fp
20000054:	00000b99 	muleq	r0, r9, fp
20000058:	00000b99 	muleq	r0, r9, fp
2000005c:	00000b99 	muleq	r0, r9, fp
20000060:	00000b99 	muleq	r0, r9, fp

20000064 <pEpInt_OUT>:
20000064:	00000b99 	muleq	r0, r9, fp
20000068:	00000b99 	muleq	r0, r9, fp
2000006c:	00000b99 	muleq	r0, r9, fp
20000070:	00000b99 	muleq	r0, r9, fp
20000074:	00000b99 	muleq	r0, r9, fp
20000078:	00000b99 	muleq	r0, r9, fp
2000007c:	00000b99 	muleq	r0, r9, fp

20000080 <User_Standard_Requests>:
20000080:	00000ba9 	andeq	r0, r0, r9, lsr #23
20000084:	00000bad 	andeq	r0, r0, sp, lsr #23
20000088:	00000bc5 	andeq	r0, r0, r5, asr #23
2000008c:	00000bc7 	andeq	r0, r0, r7, asr #23
20000090:	00000bc9 	andeq	r0, r0, r9, asr #23
20000094:	00000bcb 	andeq	r0, r0, fp, asr #23
20000098:	00000bcd 	andeq	r0, r0, sp, asr #23
2000009c:	00000bcf 	andeq	r0, r0, pc, asr #23
200000a0:	00000bd1 	ldrdeq	r0, [r0], -r1

200000a4 <Device_Table>:
200000a4:	00000101 	andeq	r0, r0, r1, lsl #2

200000a8 <usbStringDescriptor>:
200000a8:	200000fc 	strdcs	r0, [r0], -ip
200000ac:	00000004 	andeq	r0, r0, r4
200000b0:	20000146 	andcs	r0, r0, r6, asr #2
200000b4:	00000012 	andeq	r0, r0, r2, lsl r0
200000b8:	20000160 	andcs	r0, r0, r0, ror #2
200000bc:	00000014 	andeq	r0, r0, r4, lsl r0
200000c0:	2000012d 	andcs	r0, r0, sp, lsr #2
200000c4:	00000010 	andeq	r0, r0, r0, lsl r0
200000c8:	20000174 	andcs	r0, r0, r4, ror r1
200000cc:	00000078 	andeq	r0, r0, r8, ror r0
200000d0:	200001ec 	andcs	r0, r0, ip, ror #3
200000d4:	00000064 	andeq	r0, r0, r4, rrx
200000d8:	20000250 	andcs	r0, r0, r0, asr r2
200000dc:	00000064 	andeq	r0, r0, r4, rrx

200000e0 <u8_usbDeviceDescriptorDFU>:
200000e0:	01000112 	tsteq	r0, r2, lsl r1
200000e4:	40000000 	andmi	r0, r0, r0
200000e8:	00031eaf 	andeq	r1, r3, pc, lsr #29
200000ec:	02010201 	andeq	r0, r1, #268435456	; 0x10000000
200000f0:	00000103 	andeq	r0, r0, r3, lsl #2

200000f4 <usbFunctionalDescriptor>:
200000f4:	2000013d 	andcs	r0, r0, sp, lsr r1
200000f8:	00000009 	andeq	r0, r0, r9

200000fc <u8_usbStringLangId>:
200000fc:	04090304 	streq	r0, [r9], #-772	; 0x304

20000100 <u8_usbConfigDescriptorDFU>:
20000100:	002d0209 	eoreq	r0, sp, r9, lsl #4
20000104:	80000101 	andhi	r0, r0, r1, lsl #2
20000108:	00040932 	andeq	r0, r4, r2, lsr r9
2000010c:	01fe0000 	mvnseq	r0, r0
20000110:	04090402 	streq	r0, [r9], #-1026	; 0x402
20000114:	fe000100 	cdp2	1, 0, cr0, cr0, cr0, {0}
20000118:	09050201 	stmdbeq	r5, {r0, r9}
2000011c:	00020004 	andeq	r0, r2, r4
20000120:	060201fe 			; <UNDEFINED> instruction: 0x060201fe
20000124:	ff032109 			; <UNDEFINED> instruction: 0xff032109
20000128:	10080000 	andne	r0, r8, r0
2000012c:	44031001 	strmi	r1, [r3], #-1

2000012d <u8_usbStringSerial>:
2000012d:	00440310 	subeq	r0, r4, r0, lsl r3
20000131:	00560045 	subseq	r0, r6, r5, asr #32
20000135:	00300020 	eorseq	r0, r0, r0, lsr #32
20000139:	00310030 	eorseq	r0, r1, r0, lsr r0

2000013d <u8_usbFunctionalDescriptor>:
2000013d:	ff032109 			; <UNDEFINED> instruction: 0xff032109
20000141:	10080000 	andne	r0, r8, r0
20000145:	4c031201 	sfmmi	f1, 4, [r3], {1}

20000146 <u8_usbStringVendor>:
20000146:	004c0312 	subeq	r0, ip, r2, lsl r3
2000014a:	00610065 	rsbeq	r0, r1, r5, rrx
2000014e:	004c0066 	subeq	r0, ip, r6, rrx
20000152:	00620061 	rsbeq	r0, r2, r1, rrx
20000156:	00e00073 	rsceq	r0, r0, r3, ror r0

20000158 <usbDeviceDescriptorDFU>:
20000158:	200000e0 	andcs	r0, r0, r0, ror #1
2000015c:	00000012 	andeq	r0, r0, r2, lsl r0

20000160 <u8_usbStringProduct>:
20000160:	004d0314 	subeq	r0, sp, r4, lsl r3
20000164:	00700061 	rsbseq	r0, r0, r1, rrx
20000168:	0065006c 	rsbeq	r0, r5, ip, rrx
2000016c:	00300020 	eorseq	r0, r0, r0, lsr #32
20000170:	00330030 	eorseq	r0, r3, r0, lsr r0

20000174 <u8_usbStringAlt0>:
20000174:	00450378 	subeq	r0, r5, r8, ror r3
20000178:	0063006e 	rsbeq	r0, r3, lr, rrx
2000017c:	0061006c 	rsbeq	r0, r1, ip, rrx
20000180:	00650076 	rsbeq	r0, r5, r6, ror r0
20000184:	00440020 	subeq	r0, r4, r0, lsr #32
20000188:	00550046 	subseq	r0, r5, r6, asr #32
2000018c:	00420020 	subeq	r0, r2, r0, lsr #32
20000190:	006f006f 	rsbeq	r0, pc, pc, rrx
20000194:	006c0074 	rsbeq	r0, ip, r4, ror r0
20000198:	0061006f 	rsbeq	r0, r1, pc, rrx
2000019c:	00650064 	rsbeq	r0, r5, r4, rrx
200001a0:	00200072 	eoreq	r0, r0, r2, ror r0
200001a4:	00450020 	subeq	r0, r5, r0, lsr #32
200001a8:	00520052 	subseq	r0, r2, r2, asr r0
200001ac:	0052004f 	subseq	r0, r2, pc, asr #32
200001b0:	0020002e 	eoreq	r0, r0, lr, lsr #32
200001b4:	00700055 	rsbseq	r0, r0, r5, asr r0
200001b8:	006f006c 	rsbeq	r0, pc, ip, rrx
200001bc:	00640061 	rsbeq	r0, r4, r1, rrx
200001c0:	00740020 	rsbseq	r0, r4, r0, lsr #32
200001c4:	0020006f 	eoreq	r0, r0, pc, rrx
200001c8:	00410052 	subeq	r0, r1, r2, asr r0
200001cc:	0020004d 	eoreq	r0, r0, sp, asr #32
200001d0:	006f006e 	rsbeq	r0, pc, lr, rrx
200001d4:	00200074 	eoreq	r0, r0, r4, ror r0
200001d8:	00750073 	rsbseq	r0, r5, r3, ror r0
200001dc:	00700070 	rsbseq	r0, r0, r0, ror r0
200001e0:	0072006f 	rsbseq	r0, r2, pc, rrx
200001e4:	00650074 	rsbeq	r0, r5, r4, ror r0
200001e8:	002e0064 	eoreq	r0, lr, r4, rrx

200001ec <u8_usbStringAlt1>:
200001ec:	00450364 	subeq	r0, r5, r4, ror #6
200001f0:	0063006e 	rsbeq	r0, r3, lr, rrx
200001f4:	0061006c 	rsbeq	r0, r1, ip, rrx
200001f8:	00650076 	rsbeq	r0, r5, r6, ror r0
200001fc:	00440020 	subeq	r0, r4, r0, lsr #32
20000200:	00550046 	subseq	r0, r5, r6, asr #32
20000204:	00420020 	subeq	r0, r2, r0, lsr #32
20000208:	006f006f 	rsbeq	r0, pc, pc, rrx
2000020c:	006c0074 	rsbeq	r0, ip, r4, ror r0
20000210:	0061006f 	rsbeq	r0, r1, pc, rrx
20000214:	00650064 	rsbeq	r0, r5, r4, rrx
20000218:	00200072 	eoreq	r0, r0, r2, ror r0
2000021c:	00550020 	subseq	r0, r5, r0, lsr #32
20000220:	006c0070 	rsbeq	r0, ip, r0, ror r0
20000224:	0061006f 	rsbeq	r0, r1, pc, rrx
20000228:	00200064 	eoreq	r0, r0, r4, rrx
2000022c:	006f0074 	rsbeq	r0, pc, r4, ror r0	; <UNPREDICTABLE>
20000230:	00460020 	subeq	r0, r6, r0, lsr #32
20000234:	0061006c 	rsbeq	r0, r1, ip, rrx
20000238:	00680073 	rsbeq	r0, r8, r3, ror r0
2000023c:	00300020 	eorseq	r0, r0, r0, lsr #32
20000240:	00380078 	eorseq	r0, r8, r8, ror r0
20000244:	00300030 	eorseq	r0, r0, r0, lsr r0
20000248:	00300037 	eorseq	r0, r0, r7, lsr r0
2000024c:	00300030 	eorseq	r0, r0, r0, lsr r0

20000250 <u8_usbStringAlt2>:
20000250:	00450364 	subeq	r0, r5, r4, ror #6
20000254:	0063006e 	rsbeq	r0, r3, lr, rrx
20000258:	0061006c 	rsbeq	r0, r1, ip, rrx
2000025c:	00650076 	rsbeq	r0, r5, r6, ror r0
20000260:	00440020 	subeq	r0, r4, r0, lsr #32
20000264:	00550046 	subseq	r0, r5, r6, asr #32
20000268:	00420020 	subeq	r0, r2, r0, lsr #32
2000026c:	006f006f 	rsbeq	r0, pc, pc, rrx
20000270:	006c0074 	rsbeq	r0, ip, r4, ror r0
20000274:	0061006f 	rsbeq	r0, r1, pc, rrx
20000278:	00650064 	rsbeq	r0, r5, r4, rrx
2000027c:	00200072 	eoreq	r0, r0, r2, ror r0
20000280:	00550020 	subseq	r0, r5, r0, lsr #32
20000284:	006c0070 	rsbeq	r0, ip, r0, ror r0
20000288:	0061006f 	rsbeq	r0, r1, pc, rrx
2000028c:	00200064 	eoreq	r0, r0, r4, rrx
20000290:	006f0074 	rsbeq	r0, pc, r4, ror r0	; <UNPREDICTABLE>
20000294:	00460020 	subeq	r0, r6, r0, lsr #32
20000298:	0061006c 	rsbeq	r0, r1, ip, rrx
2000029c:	00680073 	rsbeq	r0, r8, r3, ror r0
200002a0:	00300020 	eorseq	r0, r0, r0, lsr #32
200002a4:	00380078 	eorseq	r0, r8, r8, ror r0
200002a8:	00300030 	eorseq	r0, r0, r0, lsr r0
200002ac:	00300032 	eorseq	r0, r0, r2, lsr r0
200002b0:	00300030 	eorseq	r0, r0, r0, lsr r0

200002b4 <usbConfigDescriptorDFU>:
200002b4:	20000100 	andcs	r0, r0, r0, lsl #2
200002b8:	0000002d 	andeq	r0, r0, sp, lsr #32

200002bc <userAppEnd>:
200002bc:	20005000 	andcs	r5, r0, r0

200002c0 <userAppAddr>:
200002c0:	20000c00 	andcs	r0, r0, r0, lsl #24

200002c4 <sha256_padding>:
200002c4:	00000080 	andeq	r0, r0, r0, lsl #1
	...

20000304 <k>:
20000304:	428a2f98 	addmi	r2, sl, #152, 30	; 0x260
20000308:	71374491 			; <UNDEFINED> instruction: 0x71374491
2000030c:	b5c0fbcf 	strblt	pc, [r0, #3023]	; 0xbcf	; <UNPREDICTABLE>
20000310:	e9b5dba5 	ldmib	r5!, {r0, r2, r5, r7, r8, r9, fp, ip, lr, pc}
20000314:	3956c25b 	ldmdbcc	r6, {r0, r1, r3, r4, r6, r9, lr, pc}^
20000318:	59f111f1 	ldmibpl	r1!, {r0, r4, r5, r6, r7, r8, ip}^
2000031c:	923f82a4 	eorsls	r8, pc, #164, 4	; 0x4000000a
20000320:	ab1c5ed5 	blge	20717e7c <_estack+0x712e7c>
20000324:	d807aa98 	stmdale	r7, {r3, r4, r7, r9, fp, sp, pc}
20000328:	12835b01 	addne	r5, r3, #1024	; 0x400
2000032c:	243185be 	ldrtcs	r8, [r1], #-1470	; 0x5be
20000330:	550c7dc3 	strpl	r7, [ip, #-3523]	; 0xdc3
20000334:	72be5d74 	adcsvc	r5, lr, #116, 26	; 0x1d00
20000338:	80deb1fe 	ldrshhi	fp, [lr], #30
2000033c:	9bdc06a7 	blls	1f701de0 <_etext+0x1f6fa7cc>
20000340:	c19bf174 	orrsgt	pc, fp, r4, ror r1	; <UNPREDICTABLE>
20000344:	e49b69c1 	ldr	r6, [fp], #2497	; 0x9c1
20000348:	efbe4786 	svc	0x00be4786
2000034c:	0fc19dc6 	svceq	0x00c19dc6
20000350:	240ca1cc 	strcs	sl, [ip], #-460	; 0x1cc
20000354:	2de92c6f 	stclcs	12, cr2, [r9, #444]!	; 0x1bc
20000358:	4a7484aa 	bmi	21d21608 <_estack+0x1d1c608>
2000035c:	5cb0a9dc 	ldcpl	9, cr10, [r0], #880	; 0x370
20000360:	76f988da 	usatvc	r8, #25, sl, asr #17
20000364:	983e5152 	ldmdals	lr!, {r1, r4, r6, r8, ip, lr}
20000368:	a831c66d 	ldmdage	r1!, {r0, r2, r3, r5, r6, r9, sl, lr, pc}
2000036c:	b00327c8 	andlt	r2, r3, r8, asr #15
20000370:	bf597fc7 	svclt	0x00597fc7
20000374:	c6e00bf3 			; <UNDEFINED> instruction: 0xc6e00bf3
20000378:	d5a79147 	strle	r9, [r7, #327]!	; 0x147
2000037c:	06ca6351 			; <UNDEFINED> instruction: 0x06ca6351
20000380:	14292967 	strtne	r2, [r9], #-2407	; 0x967
20000384:	27b70a85 	ldrcs	r0, [r7, r5, lsl #21]!
20000388:	2e1b2138 	mrccs	1, 0, r2, cr11, cr8, {1}
2000038c:	4d2c6dfc 	stcmi	13, cr6, [ip, #-1008]!	; 0xfffffc10
20000390:	53380d13 	teqpl	r8, #1216	; 0x4c0
20000394:	650a7354 	strvs	r7, [sl, #-852]	; 0x354
20000398:	766a0abb 			; <UNDEFINED> instruction: 0x766a0abb
2000039c:	81c2c92e 	bichi	ip, r2, lr, lsr #18
200003a0:	92722c85 	rsbsls	r2, r2, #34048	; 0x8500
200003a4:	a2bfe8a1 	adcsge	lr, pc, #10551296	; 0xa10000
200003a8:	a81a664b 	ldmdage	sl, {r0, r1, r3, r6, r9, sl, sp, lr}
200003ac:	c24b8b70 	subgt	r8, fp, #112, 22	; 0x1c000
200003b0:	c76c51a3 	strbgt	r5, [ip, -r3, lsr #3]!
200003b4:	d192e819 	orrsle	lr, r2, r9, lsl r8
200003b8:	d6990624 	ldrle	r0, [r9], r4, lsr #12
200003bc:	f40e3585 	vst3.32	{d3,d5,d7}, [lr], r5
200003c0:	106aa070 	rsbne	sl, sl, r0, ror r0
200003c4:	19a4c116 	stmibne	r4!, {r1, r2, r4, r8, lr, pc}
200003c8:	1e376c08 	cdpne	12, 3, cr6, cr7, cr8, {0}
200003cc:	2748774c 	strbcs	r7, [r8, -ip, asr #14]
200003d0:	34b0bcb5 	ldrtcc	fp, [r0], #3253	; 0xcb5
200003d4:	391c0cb3 	ldmdbcc	ip, {r0, r1, r4, r5, r7, sl, fp}
200003d8:	4ed8aa4a 	vfnmami.f32	s21, s16, s20
200003dc:	5b9cca4f 	blpl	1e732d20 <_etext+0x1e72b70c>
200003e0:	682e6ff3 	stmdavs	lr!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, fp, sp, lr}
200003e4:	748f82ee 	strvc	r8, [pc], #750	; 200003ec <k+0xe8>
200003e8:	78a5636f 	stmiavc	r5!, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}
200003ec:	84c87814 	strbhi	r7, [r8], #2068	; 0x814
200003f0:	8cc70208 	sfmhi	f0, 2, [r7], {8}
200003f4:	90befffa 	ldrshtls	pc, [lr], sl	; <UNPREDICTABLE>
200003f8:	a4506ceb 	ldrbge	r6, [r0], #-3307	; 0xceb
200003fc:	bef9a3f7 	mrclt	3, 7, sl, cr9, cr7, {7}
20000400:	c67178f2 			; <UNDEFINED> instruction: 0xc67178f2

20000404 <rootCA>:
20000404:	042d0cbd 	strteq	r0, [sp], #-3261	; 0xcbd
20000408:	c6955a2e 	ldrgt	r5, [r5], lr, lsr #20
2000040c:	3ffc28b6 	svccc	0x00fc28b6
20000410:	fba16c85 	blx	1e85b62e <_etext+0x1e85401a>
20000414:	380725b5 	stmdacc	r7, {r0, r2, r4, r5, r7, r8, sl, sp}
20000418:	449d05c0 	ldrmi	r0, [sp], #1472	; 0x5c0
2000041c:	a6e3a704 	strbtge	sl, [r3], r4, lsl #14
20000420:	41b83bac 			; <UNDEFINED> instruction: 0x41b83bac

20000424 <impure_data>:
	...
20000444:	000075de 	ldrdeq	r7, [r0], -lr
	...

20000484 <_impure_ptr>:
20000484:	20000424 	andcs	r0, r0, r4, lsr #8

Disassembly of section .bss:

20000488 <_sbss>:
20000488:	00000000 	andeq	r0, r0, r0

2000048c <wIstr>:
	...

2000048e <ResumeS>:
	...

20000490 <input>:
	...

200004ec <sha256sum>:
	...

2000050c <ctx>:
	...

20000574 <code_copy_lock>:
	...

20000576 <SaveRState>:
	...

20000578 <SaveTState>:
20000578:	00000000 	andeq	r0, r0, r0

2000057c <SaveState>:
2000057c:	00000000 	andeq	r0, r0, r0

20000580 <pProperty>:
20000580:	00000000 	andeq	r0, r0, r0

20000584 <EPindex>:
20000584:	00000000 	andeq	r0, r0, r0

20000588 <Device_Info>:
	...

200005a4 <pUser_Standard_Requests>:
200005a4:	00000000 	andeq	r0, r0, r0

200005a8 <pInformation>:
200005a8:	00000000 	andeq	r0, r0, r0

200005ac <wInterrupt_Mask>:
	...

200005ae <StatusInfo>:
	...

200005b0 <errno>:
200005b0:	00000000 	andeq	r0, r0, r0

Disassembly of section .bss.bIntPackSOF:

200005b4 <bIntPackSOF>:
	...

Disassembly of section .bss.bDeviceState:

200005b8 <bDeviceState>:
200005b8:	00000000 	andeq	r0, r0, r0

Disassembly of section .bss.recvBuffer:

200005bc <recvBuffer>:
	...

Disassembly of section .bss.uploadBlockLen:

20000dbc <uploadBlockLen>:
	...

Disassembly of section .bss.thisBlockLen:

20000dbe <thisBlockLen>:
	...

Disassembly of section .bss.userFirmwareLen:

20000dc0 <userFirmwareLen>:
20000dc0:	00000000 	andeq	r0, r0, r0

Disassembly of section .bss.userUploadType:

20000dc4 <userUploadType>:
	...

Disassembly of section .bss.dfuAppStatus:

20000dc5 <dfuAppStatus>:
20000dc5:	00000000 	andeq	r0, r0, r0
	...

Disassembly of section .bss.dfuBusy:

20000dcb <dfuBusy>:
	...

Disassembly of section .bss.Data_Mul_MaxPacketSize:

20000dcc <Data_Mul_MaxPacketSize>:
	...

Disassembly of section .bss.__malloc_sbrk_start:

20000dd0 <__malloc_sbrk_start>:
20000dd0:	00000000 	andeq	r0, r0, r0

Disassembly of section .bss.__malloc_free_list:

20000dd4 <__malloc_free_list>:
20000dd4:	00000000 	andeq	r0, r0, r0

Disassembly of section .bss.heap_end.4246:

20000dd8 <heap_end.4246>:
20000dd8:	00000000 	andeq	r0, r0, r0

Disassembly of section ._usrstack:

20000ddc <_susrstack>:
	...

Disassembly of section .comment:

00000000 <.comment>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void NOP_Process(void)
{
   0:	3a434347 	bcc	10d0d24 <_etext+0x10c9710>
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
   4:	4e472820 	cdpmi	8, 4, cr2, cr7, cr0, {1}
   8:	6f542055 	svcvs	0x00542055
   c:	20736c6f 	rsbscs	r6, r3, pc, ror #24
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
  10:	20726f66 	rsbscs	r6, r2, r6, ror #30
  14:	204d5241 	subcs	r5, sp, r1, asr #4
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
  18:	65626d45 	strbvs	r6, [r2, #-3397]!	; 0xd45
  1c:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
  20:	6f725020 	svcvs	0x00725020
  24:	73736563 	cmnvc	r3, #415236096	; 0x18c00000
  28:	2973726f 	ldmdbcs	r3!, {r0, r1, r2, r3, r5, r6, r9, ip, sp, lr}^
    if ((wEPVal & EP_CTR_RX) != 0)
  2c:	382e3420 	stmdacc	lr!, {r5, sl, ip, sp}
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
  30:	3220342e 	eorcc	r3, r0, #771751936	; 0x2e000000
  34:	30343130 	eorscc	r3, r4, r0, lsr r1
  38:	20353237 	eorscs	r3, r5, r7, lsr r2

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
  3c:	6c657228 	sfmvs	f7, 2, [r5], #-160	; 0xffffff60

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
  40:	65736165 	ldrbvs	r6, [r3, #-357]!	; 0x165
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
  44:	415b2029 	cmpmi	fp, r9, lsr #32
  48:	652f4d52 	strvs	r4, [pc, #-3410]!	; fffff2fe <BootRAM+0xef6fa9f>
  4c:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
  50:	2d646564 	cfstr64cs	mvdx6, [r4, #-400]!	; 0xfffffe70
  54:	2d385f34 	ldccs	15, cr5, [r8, #-208]!	; 0xffffff30
  58:	6e617262 	cdpvs	2, 6, cr7, cr1, cr2, {3}
  5c:	72206863 	eorvc	r6, r0, #6488064	; 0x630000
  60:	73697665 	cmnvc	r9, #105906176	; 0x6500000
  64:	206e6f69 	rsbcs	r6, lr, r9, ror #30
  68:	31333132 	teqcc	r3, r2, lsr r1
  6c:	005d3734 	subseq	r3, sp, r4, lsr r7

Disassembly of section .ARM.attributes:

00000000 <.ARM.attributes>:
   0:	00002e41 	andeq	r2, r0, r1, asr #28
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
   4:	61656100 	cmnvs	r5, r0, lsl #2
   8:	01006962 	tsteq	r0, r2, ror #18
   c:	00000024 	andeq	r0, r0, r4, lsr #32
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
  10:	726f4305 	rsbvc	r4, pc, #335544320	; 0x14000000
  14:	2d786574 	cfldr64cs	mvdx6, [r8, #-464]!	; 0xfffffe30
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
  18:	0600334d 	streq	r3, [r0], -sp, asr #6
  1c:	094d070a 	stmdbeq	sp, {r1, r3, r8, r9, sl}^
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
  20:	14041202 	strne	r1, [r4], #-514	; 0x202
  24:	17011501 	strne	r1, [r1, -r1, lsl #10]
  28:	1a011803 	bne	4603c <_etext+0x3ea28>
    if ((wEPVal & EP_CTR_RX) != 0)
  2c:	Address 0x0000002c is out of bounds.


Disassembly of section .debug_aranges:

00000000 <.debug_aranges>:
   0:	00000024 	andeq	r0, r0, r4, lsr #32
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
   4:	00000002 	andeq	r0, r0, r2
   8:	00040000 	andeq	r0, r4, r0
   c:	00000000 	andeq	r0, r0, r0
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
  10:	00000b4c 	andeq	r0, r0, ip, asr #22
  14:	00000048 	andeq	r0, r0, r8, asr #32
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
  18:	00000b94 	muleq	r0, r4, fp
  1c:	00000004 	andeq	r0, r0, r4
	...
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
  28:	0000001c 	andeq	r0, r0, ip, lsl r0
    if ((wEPVal & EP_CTR_RX) != 0)
  2c:	007c0002 	rsbseq	r0, ip, r2
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
  30:	00040000 	andeq	r0, r4, r0
	...

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
  3c:	0000007a 	andeq	r0, r0, sl, ror r0
	...

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
  48:	0000011c 	andeq	r0, r0, ip, lsl r1
  4c:	00fe0002 	rscseq	r0, lr, r2

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
  50:	00040000 	andeq	r0, r4, r0
  54:	00000000 	andeq	r0, r0, r0
  58:	00000b98 	muleq	r0, r8, fp
  5c:	00000002 	andeq	r0, r0, r2
  60:	00000b9a 	muleq	r0, sl, fp
  64:	00000002 	andeq	r0, r0, r2
  68:	00000b9c 	muleq	r0, ip, fp
  6c:	00000002 	andeq	r0, r0, r2
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPDblBuffCount(u8 bEpNum, u8 bDir, u16 wCount)
{
  _SetEPDblBuffCount(bEpNum, bDir, wCount);
  70:	00000b9e 	muleq	r0, lr, fp
  74:	0000000a 	andeq	r0, r0, sl
  78:	00000ba8 	andeq	r0, r0, r8, lsr #23
  7c:	00000002 	andeq	r0, r0, r2
  80:	00000bac 	andeq	r0, r0, ip, lsr #23
  84:	00000018 	andeq	r0, r0, r8, lsl r0
  88:	00000bc4 	andeq	r0, r0, r4, asr #23
  8c:	00000002 	andeq	r0, r0, r2
  90:	00000bc6 	andeq	r0, r0, r6, asr #23
  94:	00000002 	andeq	r0, r0, r2
  98:	00000bc8 	andeq	r0, r0, r8, asr #23
  9c:	00000002 	andeq	r0, r0, r2
  a0:	00000bca 	andeq	r0, r0, sl, asr #23
  a4:	00000002 	andeq	r0, r0, r2
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
  a8:	00000bcc 	andeq	r0, r0, ip, asr #23

	return f25519_eq(a, c);
  ac:	00000002 	andeq	r0, r0, r2
  b0:	00000bce 	andeq	r0, r0, lr, asr #23
  b4:	00000002 	andeq	r0, r0, r2
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
  b8:	00000bd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
	f25519_normalize(ey);
  bc:	0000000c 	andeq	r0, r0, ip
  c0:	00000bdc 	ldrdeq	r0, [r0], -ip

	return ok;
}
  c4:	000000a8 	andeq	r0, r0, r8, lsr #1
  c8:	00000c84 	andeq	r0, r0, r4, lsl #25
  cc:	00000060 	andeq	r0, r0, r0, rrx
  d0:	00000ce4 	andeq	r0, r0, r4, ror #25
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
  d4:	0000000c 	andeq	r0, r0, ip
  d8:	00000cf0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
		minusp[i] = c;
  dc:	0000000c 	andeq	r0, r0, ip
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
  e0:	00000cfc 	strdeq	r0, [r0], -ip
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
  e4:	00000020 	andeq	r0, r0, r0, lsr #32

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
  e8:	00000d1c 	andeq	r0, r0, ip, lsl sp
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
  ec:	0000000c 	andeq	r0, r0, ip
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
  f0:	00000d28 	andeq	r0, r0, r8, lsr #26
  f4:	00000028 	andeq	r0, r0, r8, lsr #32
  f8:	00000d50 	andeq	r0, r0, r0, asr sp
  fc:	00000068 	andeq	r0, r0, r8, rrx
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
 100:	00000000 	andeq	r0, r0, r0

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
 104:	00000004 	andeq	r0, r0, r4
 108:	00000db8 			; <UNDEFINED> instruction: 0x00000db8
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
 10c:	0000001c 	andeq	r0, r0, ip, lsl r0
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
 110:	00000dd4 	ldrdeq	r0, [r0], -r4
 114:	00000018 	andeq	r0, r0, r8, lsl r0
 118:	00000dec 	andeq	r0, r0, ip, ror #27
 11c:	00000084 	andeq	r0, r0, r4, lsl #1
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
 120:	00000e70 	andeq	r0, r0, r0, ror lr
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
 124:	00000048 	andeq	r0, r0, r8, asr #32
 128:	00000eb8 			; <UNDEFINED> instruction: 0x00000eb8
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
 12c:	0000003c 	andeq	r0, r0, ip, lsr r0

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
 130:	00000ef4 	strdeq	r0, [r0], -r4
	i <<= 3;

	while (x) {
 134:	00000004 	andeq	r0, r0, r4
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
 138:	00000ef8 	strdeq	r0, [r0], -r8
 13c:	00000024 	andeq	r0, r0, r4, lsr #32
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
 140:	00000f1c 	andeq	r0, r0, ip, lsl pc
	f25519_mul_c(z3, x1sq, 4);
 144:	00000040 	andeq	r0, r0, r0, asr #32
 148:	00000f5c 	andeq	r0, r0, ip, asr pc
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
 14c:	00000022 	andeq	r0, r0, r2, lsr #32
 150:	00000f80 	andeq	r0, r0, r0, lsl #31
 154:	000000b4 	strheq	r0, [r0], -r4
	f25519_sub(b, x3, z3); /* D */
 158:	00000000 	andeq	r0, r0, r0
 15c:	0000000c 	andeq	r0, r0, ip
	...
	f25519_mul__distinct(da, a, b);
 168:	00000014 	andeq	r0, r0, r4, lsl r0

	f25519_sub(b, x2, z2);
 16c:	0f0a0002 	svceq	0x000a0002
 170:	00040000 	andeq	r0, r4, r0
	...
	f25519_add(a, x3, z3); /* C */
	f25519_mul__distinct(cb, a, b);
 180:	0000001c 	andeq	r0, r0, ip, lsl r0
 184:	11670002 	cmnne	r7, r2

	f25519_add(a, da, cb);
 188:	00040000 	andeq	r0, r4, r0
 18c:	00000000 	andeq	r0, r0, r0
 190:	00001034 	andeq	r1, r0, r4, lsr r0
	f25519_mul__distinct(b, a, a);
 194:	00000104 	andeq	r0, r0, r4, lsl #2
	...
	f25519_mul__distinct(x5, z1, b);
 1a0:	00000104 	andeq	r0, r0, r4, lsl #2
 1a4:	161b0002 	ldrne	r0, [fp], -r2

	f25519_sub(a, da, cb);
 1a8:	00040000 	andeq	r0, r4, r0
 1ac:	00000000 	andeq	r0, r0, r0
	f25519_mul__distinct(b, a, a);
 1b0:	00001138 	andeq	r1, r0, r8, lsr r1
 1b4:	00000016 	andeq	r0, r0, r6, lsl r0
 1b8:	0000114e 	andeq	r1, r0, lr, asr #2

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
 1bc:	00000012 	andeq	r0, r0, r2, lsl r0
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
 1c0:	00001160 	andeq	r1, r0, r0, ror #2
 1c4:	00000050 	andeq	r0, r0, r0, asr r0

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
 1c8:	000011b0 			; <UNDEFINED> instruction: 0x000011b0
 1cc:	0000000a 	andeq	r0, r0, sl
 1d0:	000011ba 			; <UNDEFINED> instruction: 0x000011ba
 1d4:	00000016 	andeq	r0, r0, r6, lsl r0
		f25519_select(zm1, zm1, zm, bit);
 1d8:	000011d0 	ldrdeq	r1, [r0], -r0
 1dc:	00000028 	andeq	r0, r0, r8, lsr #32
 1e0:	000011f8 	strdeq	r1, [r0], -r8
		f25519_select(xm, xm, xms, bit);
 1e4:	0000001a 	andeq	r0, r0, sl, lsl r0
 1e8:	00001214 	andeq	r1, r0, r4, lsl r2
 1ec:	0000009c 	muleq	r0, ip, r0
		f25519_select(zm, zm, zms, bit);
 1f0:	000012b0 			; <UNDEFINED> instruction: 0x000012b0
 1f4:	00000028 	andeq	r0, r0, r8, lsr #32
 1f8:	000012d8 	ldrdeq	r1, [r0], -r8
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
 1fc:	00000088 	andeq	r0, r0, r8, lsl #1
 200:	00001360 	andeq	r1, r0, r0, ror #6
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
 204:	00000048 	andeq	r0, r0, r8, asr #32
 208:	000013a8 	andeq	r1, r0, r8, lsr #7
	f25519_mul__distinct(result, zm1, xm);
 20c:	00000060 	andeq	r0, r0, r0, rrx
 210:	00001408 	andeq	r1, r0, r8, lsl #8
	f25519_normalize(result);
 214:	00000014 	andeq	r0, r0, r4, lsl r0
 218:	0000141c 	andeq	r1, r0, ip, lsl r4
}
 21c:	0000001c 	andeq	r0, r0, ip, lsl r0
 220:	00000000 	andeq	r0, r0, r0
 224:	0000002e 	andeq	r0, r0, lr, lsr #32
 228:	00001438 	andeq	r1, r0, r8, lsr r4
 22c:	00000018 	andeq	r0, r0, r8, lsl r0
 230:	00000000 	andeq	r0, r0, r0
 234:	0000002c 	andeq	r0, r0, ip, lsr #32
 238:	00000000 	andeq	r0, r0, r0
 23c:	00000048 	andeq	r0, r0, r8, asr #32
 240:	00001450 	andeq	r1, r0, r0, asr r4
 244:	0000006c 	andeq	r0, r0, ip, rrx
 248:	000014bc 			; <UNDEFINED> instruction: 0x000014bc
 24c:	00000024 	andeq	r0, r0, r4, lsr #32
 250:	000014e0 	andeq	r1, r0, r0, ror #9
 254:	0000001e 	andeq	r0, r0, lr, lsl r0
 258:	00001500 	andeq	r1, r0, r0, lsl #10
 25c:	00000014 	andeq	r0, r0, r4, lsl r0
 260:	00001514 	andeq	r1, r0, r4, lsl r5
 264:	00000034 	andeq	r0, r0, r4, lsr r0
 268:	00000000 	andeq	r0, r0, r0
 26c:	00000030 	andeq	r0, r0, r0, lsr r0
 270:	00001548 	andeq	r1, r0, r8, asr #10
 274:	0000004c 	andeq	r0, r0, ip, asr #32
 278:	00001594 	muleq	r0, r4, r5
 27c:	0000000c 	andeq	r0, r0, ip
 280:	000015a0 	andeq	r1, r0, r0, lsr #11
 284:	00000018 	andeq	r0, r0, r8, lsl r0
 288:	000015b8 			; <UNDEFINED> instruction: 0x000015b8
 28c:	00000012 	andeq	r0, r0, r2, lsl r0
 290:	000015cc 	andeq	r1, r0, ip, asr #11
 294:	00000010 	andeq	r0, r0, r0, lsl r0
 298:	000015dc 	ldrdeq	r1, [r0], -ip
 29c:	00000018 	andeq	r0, r0, r8, lsl r0
	...
 2a8:	00000084 	andeq	r0, r0, r4, lsl #1
 2ac:	28980002 	ldmcs	r8, {r1}
 2b0:	00040000 	andeq	r0, r4, r0
 2b4:	00000000 	andeq	r0, r0, r0
 2b8:	000015f4 	strdeq	r1, [r0], -r4
 2bc:	00000088 	andeq	r0, r0, r8, lsl #1
 2c0:	0000167c 	andeq	r1, r0, ip, ror r6
 2c4:	00000044 	andeq	r0, r0, r4, asr #32
 2c8:	00000000 	andeq	r0, r0, r0
 2cc:	00000002 	andeq	r0, r0, r2
 2d0:	000016c0 	andeq	r1, r0, r0, asr #13
 2d4:	00000018 	andeq	r0, r0, r8, lsl r0
 2d8:	000016d8 	ldrdeq	r1, [r0], -r8
 2dc:	00000018 	andeq	r0, r0, r8, lsl r0
 2e0:	000016f0 	strdeq	r1, [r0], -r0
 2e4:	00000028 	andeq	r0, r0, r8, lsr #32
 2e8:	00001718 	andeq	r1, r0, r8, lsl r7
 2ec:	00000034 	andeq	r0, r0, r4, lsr r0
 2f0:	0000174c 	andeq	r1, r0, ip, asr #14
 2f4:	0000005c 	andeq	r0, r0, ip, asr r0
 2f8:	000017a8 	andeq	r1, r0, r8, lsr #15
 2fc:	00000254 	andeq	r0, r0, r4, asr r2
 300:	00000000 	andeq	r0, r0, r0
 304:	0000000c 	andeq	r0, r0, ip
 308:	00000000 	andeq	r0, r0, r0
 30c:	0000000c 	andeq	r0, r0, ip
 310:	000019fc 	strdeq	r1, [r0], -ip
 314:	0000000c 	andeq	r0, r0, ip
 318:	00000000 	andeq	r0, r0, r0
 31c:	0000001c 	andeq	r0, r0, ip, lsl r0
 320:	00001a08 	andeq	r1, r0, r8, lsl #20
 324:	00000002 	andeq	r0, r0, r2
	...
 330:	0000001c 	andeq	r0, r0, ip, lsl r0
 334:	32110002 	andscc	r0, r1, #2
 338:	00040000 	andeq	r0, r4, r0
	...
 344:	00000228 	andeq	r0, r0, r8, lsr #4
	...
 350:	0000004c 	andeq	r0, r0, ip, asr #32
 354:	3c480002 	mcrrcc	0, 0, r0, r8, cr2
 358:	00040000 	andeq	r0, r4, r0
 35c:	00000000 	andeq	r0, r0, r0
 360:	00001a0c 	andeq	r1, r0, ip, lsl #20
 364:	00000070 	andeq	r0, r0, r0, ror r0
 368:	00001a7c 	andeq	r1, r0, ip, ror sl
 36c:	0000003a 	andeq	r0, r0, sl, lsr r0
 370:	00001ab8 			; <UNDEFINED> instruction: 0x00001ab8
 374:	0000005e 	andeq	r0, r0, lr, asr r0
 378:	00001b18 	andeq	r1, r0, r8, lsl fp
 37c:	000000c8 	andeq	r0, r0, r8, asr #1
 380:	00001be0 	andeq	r1, r0, r0, ror #23
 384:	000000e0 	andeq	r0, r0, r0, ror #1
 388:	00001cc0 	andeq	r1, r0, r0, asr #25
 38c:	000000b4 	strheq	r0, [r0], -r4
 390:	00001d74 	andeq	r1, r0, r4, ror sp
 394:	00000084 	andeq	r0, r0, r4, lsl #1
	...
 3a0:	00000024 	andeq	r0, r0, r4, lsr #32
 3a4:	4afe0002 	bmi	fff803b4 <BootRAM+0xeef0b55>
 3a8:	00040000 	andeq	r0, r4, r0
	...
 3b4:	0000007c 	andeq	r0, r0, ip, ror r0
 3b8:	00001df8 	strdeq	r1, [r0], -r8
 3bc:	0000017c 	andeq	r0, r0, ip, ror r1
	...
 3c8:	0000007c 	andeq	r0, r0, ip, ror r0
 3cc:	565a0002 	ldrbpl	r0, [sl], -r2
 3d0:	00040000 	andeq	r0, r4, r0
 3d4:	00000000 	andeq	r0, r0, r0
 3d8:	00001f74 	andeq	r1, r0, r4, ror pc
 3dc:	0000001e 	andeq	r0, r0, lr, lsl r0
 3e0:	00001f94 	muleq	r0, r4, pc	; <UNPREDICTABLE>
 3e4:	0000006e 	andeq	r0, r0, lr, rrx
 3e8:	00002004 	andeq	r2, r0, r4
 3ec:	0000009a 	muleq	r0, sl, r0
 3f0:	000020a0 	andeq	r2, r0, r0, lsr #1
 3f4:	000000c2 	andeq	r0, r0, r2, asr #1
 3f8:	00002164 	andeq	r2, r0, r4, ror #2
 3fc:	00000046 	andeq	r0, r0, r6, asr #32
 400:	000021ac 	andeq	r2, r0, ip, lsr #3
 404:	0000004c 	andeq	r0, r0, ip, asr #32
 408:	000021f8 	strdeq	r2, [r0], -r8
 40c:	00000046 	andeq	r0, r0, r6, asr #32
 410:	00002240 	andeq	r2, r0, r0, asr #4
 414:	00000088 	andeq	r0, r0, r8, lsl #1
 418:	00000000 	andeq	r0, r0, r0
 41c:	000000b8 	strheq	r0, [r0], -r8
 420:	00000000 	andeq	r0, r0, r0
 424:	00000040 	andeq	r0, r0, r0, asr #32
 428:	000022c8 	andeq	r2, r0, r8, asr #5
 42c:	000005ea 	andeq	r0, r0, sl, ror #11
 430:	00000000 	andeq	r0, r0, r0
 434:	00000026 	andeq	r0, r0, r6, lsr #32
 438:	000028b4 			; <UNDEFINED> instruction: 0x000028b4
 43c:	00000634 	andeq	r0, r0, r4, lsr r6
	...
 448:	0000005c 	andeq	r0, r0, ip, asr r0
 44c:	66010002 	strvs	r0, [r1], -r2
 450:	00040000 	andeq	r0, r4, r0
	...
 45c:	0000001e 	andeq	r0, r0, lr, lsl r0
 460:	00002ee8 	andeq	r2, r0, r8, ror #29
 464:	000001a0 	andeq	r0, r0, r0, lsr #3
 468:	00000000 	andeq	r0, r0, r0
 46c:	0000002c 	andeq	r0, r0, ip, lsr #32
 470:	00000000 	andeq	r0, r0, r0
 474:	0000009a 	muleq	r0, sl, r0
 478:	00000000 	andeq	r0, r0, r0
 47c:	000000c2 	andeq	r0, r0, r2, asr #1
 480:	00000000 	andeq	r0, r0, r0
 484:	00000058 	andeq	r0, r0, r8, asr r0
 488:	00000000 	andeq	r0, r0, r0
 48c:	0000008e 	andeq	r0, r0, lr, lsl #1
 490:	00000000 	andeq	r0, r0, r0
 494:	0000013e 	andeq	r0, r0, lr, lsr r1
 498:	00000000 	andeq	r0, r0, r0
 49c:	000000d2 	ldrdeq	r0, [r0], -r2
	...
 4a8:	00000024 	andeq	r0, r0, r4, lsr #32
 4ac:	73750002 	cmnvc	r5, #2
 4b0:	00040000 	andeq	r0, r4, r0
	...
 4bc:	00000040 	andeq	r0, r0, r0, asr #32
 4c0:	00000000 	andeq	r0, r0, r0
 4c4:	000000d4 	ldrdeq	r0, [r0], -r4
	...
 4d0:	00000034 	andeq	r0, r0, r4, lsr r0
 4d4:	799f0002 	ldmibvc	pc, {r1}	; <UNPREDICTABLE>
 4d8:	00040000 	andeq	r0, r4, r0
 4dc:	00000000 	andeq	r0, r0, r0
 4e0:	00003088 	andeq	r3, r0, r8, lsl #1
 4e4:	00000058 	andeq	r0, r0, r8, asr r0
 4e8:	000030e0 	andeq	r3, r0, r0, ror #1
 4ec:	00001f64 	andeq	r1, r0, r4, ror #30
 4f0:	00005044 	andeq	r5, r0, r4, asr #32
 4f4:	0000008e 	andeq	r0, r0, lr, lsl #1
 4f8:	000050d4 	ldrdeq	r5, [r0], -r4
 4fc:	00000218 	andeq	r0, r0, r8, lsl r2
	...
 508:	0000002c 	andeq	r0, r0, ip, lsr #32
 50c:	7f4f0002 	svcvc	0x004f0002
 510:	00040000 	andeq	r0, r4, r0
 514:	00000000 	andeq	r0, r0, r0
 518:	000052ec 	andeq	r5, r0, ip, ror #5
 51c:	00000494 	muleq	r0, r4, r4
 520:	00005780 	andeq	r5, r0, r0, lsl #15
 524:	00000088 	andeq	r0, r0, r8, lsl #1
 528:	00005808 	andeq	r5, r0, r8, lsl #16
 52c:	00000296 	muleq	r0, r6, r2
	...
 538:	00000024 	andeq	r0, r0, r4, lsr #32
 53c:	86d20002 	ldrbhi	r0, [r2], r2
 540:	00040000 	andeq	r0, r4, r0
 544:	00000000 	andeq	r0, r0, r0
 548:	00005aa0 	andeq	r5, r0, r0, lsr #21
 54c:	00000044 	andeq	r0, r0, r4, asr #32
 550:	00005ae4 	andeq	r5, r0, r4, ror #21
 554:	00000158 	andeq	r0, r0, r8, asr r1
	...
 560:	000001ec 	andeq	r0, r0, ip, ror #3
 564:	8ee00002 	cdphi	0, 14, cr0, cr0, cr2, {0}
 568:	00040000 	andeq	r0, r4, r0
	...
 574:	0000000c 	andeq	r0, r0, ip
 578:	00000000 	andeq	r0, r0, r0
 57c:	0000000c 	andeq	r0, r0, ip
 580:	00000000 	andeq	r0, r0, r0
 584:	0000000c 	andeq	r0, r0, ip
 588:	00000000 	andeq	r0, r0, r0
 58c:	0000000c 	andeq	r0, r0, ip
 590:	00000000 	andeq	r0, r0, r0
 594:	0000000c 	andeq	r0, r0, ip
 598:	00000000 	andeq	r0, r0, r0
 59c:	0000000c 	andeq	r0, r0, ip
 5a0:	00000000 	andeq	r0, r0, r0
 5a4:	0000000c 	andeq	r0, r0, ip
 5a8:	00000000 	andeq	r0, r0, r0
 5ac:	00000010 	andeq	r0, r0, r0, lsl r0
 5b0:	00000000 	andeq	r0, r0, r0
 5b4:	0000000c 	andeq	r0, r0, ip
 5b8:	00000000 	andeq	r0, r0, r0
 5bc:	0000000e 	andeq	r0, r0, lr
 5c0:	00000000 	andeq	r0, r0, r0
 5c4:	00000010 	andeq	r0, r0, r0, lsl r0
 5c8:	00000000 	andeq	r0, r0, r0
 5cc:	0000001c 	andeq	r0, r0, ip, lsl r0
 5d0:	00000000 	andeq	r0, r0, r0
 5d4:	00000012 	andeq	r0, r0, r2, lsl r0
 5d8:	00005c3c 	andeq	r5, r0, ip, lsr ip
 5dc:	0000002a 	andeq	r0, r0, sl, lsr #32
 5e0:	00000000 	andeq	r0, r0, r0
 5e4:	0000002a 	andeq	r0, r0, sl, lsr #32
 5e8:	00000000 	andeq	r0, r0, r0
 5ec:	00000024 	andeq	r0, r0, r4, lsr #32
 5f0:	00000000 	andeq	r0, r0, r0
 5f4:	00000012 	andeq	r0, r0, r2, lsl r0
 5f8:	00000000 	andeq	r0, r0, r0
 5fc:	00000012 	andeq	r0, r0, r2, lsl r0
 600:	00000000 	andeq	r0, r0, r0
 604:	0000001e 	andeq	r0, r0, lr, lsl r0
 608:	00005c66 	andeq	r5, r0, r6, ror #24
 60c:	0000001e 	andeq	r0, r0, lr, lsl r0
 610:	00000000 	andeq	r0, r0, r0
 614:	0000001e 	andeq	r0, r0, lr, lsl r0
 618:	00000000 	andeq	r0, r0, r0
 61c:	0000001c 	andeq	r0, r0, ip, lsl r0
 620:	00005c84 	andeq	r5, r0, r4, lsl #25
 624:	0000001c 	andeq	r0, r0, ip, lsl r0
 628:	00000000 	andeq	r0, r0, r0
 62c:	0000001e 	andeq	r0, r0, lr, lsl r0
 630:	00000000 	andeq	r0, r0, r0
 634:	0000001e 	andeq	r0, r0, lr, lsl r0
 638:	00000000 	andeq	r0, r0, r0
 63c:	0000001c 	andeq	r0, r0, ip, lsl r0
 640:	00000000 	andeq	r0, r0, r0
 644:	0000001a 	andeq	r0, r0, sl, lsl r0
 648:	00000000 	andeq	r0, r0, r0
 64c:	0000001a 	andeq	r0, r0, sl, lsl r0
 650:	00000000 	andeq	r0, r0, r0
 654:	00000018 	andeq	r0, r0, r8, lsl r0
 658:	00000000 	andeq	r0, r0, r0
 65c:	0000001c 	andeq	r0, r0, ip, lsl r0
 660:	00000000 	andeq	r0, r0, r0
 664:	00000020 	andeq	r0, r0, r0, lsr #32
 668:	00000000 	andeq	r0, r0, r0
 66c:	00000020 	andeq	r0, r0, r0, lsr #32
 670:	00005ca0 	andeq	r5, r0, r0, lsr #25
 674:	00000020 	andeq	r0, r0, r0, lsr #32
 678:	00005cc0 	andeq	r5, r0, r0, asr #25
 67c:	00000020 	andeq	r0, r0, r0, lsr #32
 680:	00000000 	andeq	r0, r0, r0
 684:	0000001e 	andeq	r0, r0, lr, lsl r0
 688:	00000000 	andeq	r0, r0, r0
 68c:	00000012 	andeq	r0, r0, r2, lsl r0
 690:	00000000 	andeq	r0, r0, r0
 694:	00000020 	andeq	r0, r0, r0, lsr #32
 698:	00000000 	andeq	r0, r0, r0
 69c:	00000020 	andeq	r0, r0, r0, lsr #32
 6a0:	00005ce0 	andeq	r5, r0, r0, ror #25
 6a4:	0000001c 	andeq	r0, r0, ip, lsl r0
 6a8:	00005cfc 	strdeq	r5, [r0], -ip
 6ac:	0000001c 	andeq	r0, r0, ip, lsl r0
 6b0:	00005d18 	andeq	r5, r0, r8, lsl sp
 6b4:	0000001c 	andeq	r0, r0, ip, lsl r0
 6b8:	00000000 	andeq	r0, r0, r0
 6bc:	00000026 	andeq	r0, r0, r6, lsr #32
 6c0:	00005d34 	andeq	r5, r0, r4, lsr sp
 6c4:	00000040 	andeq	r0, r0, r0, asr #32
 6c8:	00000000 	andeq	r0, r0, r0
 6cc:	00000020 	andeq	r0, r0, r0, lsr #32
 6d0:	00000000 	andeq	r0, r0, r0
 6d4:	00000020 	andeq	r0, r0, r0, lsr #32
 6d8:	00000000 	andeq	r0, r0, r0
 6dc:	00000038 	andeq	r0, r0, r8, lsr r0
 6e0:	00000000 	andeq	r0, r0, r0
 6e4:	00000020 	andeq	r0, r0, r0, lsr #32
 6e8:	00000000 	andeq	r0, r0, r0
 6ec:	00000020 	andeq	r0, r0, r0, lsr #32
 6f0:	00000000 	andeq	r0, r0, r0
 6f4:	0000001c 	andeq	r0, r0, ip, lsl r0
 6f8:	00000000 	andeq	r0, r0, r0
 6fc:	0000001c 	andeq	r0, r0, ip, lsl r0
 700:	00000000 	andeq	r0, r0, r0
 704:	000000a8 	andeq	r0, r0, r8, lsr #1
 708:	00000000 	andeq	r0, r0, r0
 70c:	0000005c 	andeq	r0, r0, ip, asr r0
 710:	00000000 	andeq	r0, r0, r0
 714:	0000005c 	andeq	r0, r0, ip, asr r0
 718:	00000000 	andeq	r0, r0, r0
 71c:	00000020 	andeq	r0, r0, r0, lsr #32
 720:	00000000 	andeq	r0, r0, r0
 724:	00000020 	andeq	r0, r0, r0, lsr #32
 728:	00000000 	andeq	r0, r0, r0
 72c:	00000044 	andeq	r0, r0, r4, asr #32
 730:	00000000 	andeq	r0, r0, r0
 734:	0000003a 	andeq	r0, r0, sl, lsr r0
 738:	00000000 	andeq	r0, r0, r0
 73c:	00000006 	andeq	r0, r0, r6
 740:	00000000 	andeq	r0, r0, r0
 744:	0000000a 	andeq	r0, r0, sl
	...
 750:	00000024 	andeq	r0, r0, r4, lsr #32
 754:	9b6c0002 	blls	1b00764 <_etext+0x1af9150>
 758:	00040000 	andeq	r0, r4, r0
 75c:	00000000 	andeq	r0, r0, r0
 760:	00005d74 	andeq	r5, r0, r4, ror sp
 764:	00000154 	andeq	r0, r0, r4, asr r1
 768:	00000000 	andeq	r0, r0, r0
 76c:	00000070 	andeq	r0, r0, r0, ror r0
	...
 778:	0000001c 	andeq	r0, r0, ip, lsl r0
 77c:	9d480002 	stclls	0, cr0, [r8, #-8]
 780:	00040000 	andeq	r0, r4, r0
 784:	00000000 	andeq	r0, r0, r0
 788:	00005ec8 	andeq	r5, r0, r8, asr #29
 78c:	00000038 	andeq	r0, r0, r8, lsr r0
	...
 798:	00000094 	muleq	r0, r4, r0
 79c:	a1450002 	cmpge	r5, r2
 7a0:	00040000 	andeq	r0, r4, r0
 7a4:	00000000 	andeq	r0, r0, r0
 7a8:	00005f00 	andeq	r5, r0, r0, lsl #30
 7ac:	00000024 	andeq	r0, r0, r4, lsr #32
 7b0:	00005f24 	andeq	r5, r0, r4, lsr #30
 7b4:	00000024 	andeq	r0, r0, r4, lsr #32
 7b8:	00005f48 	andeq	r5, r0, r8, asr #30
 7bc:	00000090 	muleq	r0, r0, r0
 7c0:	00005fd8 	ldrdeq	r5, [r0], -r8
 7c4:	000000a8 	andeq	r0, r0, r8, lsr #1
 7c8:	00006080 	andeq	r6, r0, r0, lsl #1
 7cc:	00000038 	andeq	r0, r0, r8, lsr r0
 7d0:	000060b8 	strheq	r6, [r0], -r8
 7d4:	00000048 	andeq	r0, r0, r8, asr #32
 7d8:	00006100 	andeq	r6, r0, r0, lsl #2
 7dc:	000000d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
 7e0:	000061d0 	ldrdeq	r6, [r0], -r0
 7e4:	00000084 	andeq	r0, r0, r4, lsl #1
 7e8:	00006254 	andeq	r6, r0, r4, asr r2
 7ec:	00000024 	andeq	r0, r0, r4, lsr #32
 7f0:	00006278 	andeq	r6, r0, r8, ror r2
 7f4:	0000001c 	andeq	r0, r0, ip, lsl r0
 7f8:	00006294 	muleq	r0, r4, r2
 7fc:	00000040 	andeq	r0, r0, r0, asr #32
 800:	000062d4 	ldrdeq	r6, [r0], -r4
 804:	000002dc 	ldrdeq	r0, [r0], -ip
 808:	000065b0 			; <UNDEFINED> instruction: 0x000065b0
 80c:	000000c8 	andeq	r0, r0, r8, asr #1
 810:	00006678 	andeq	r6, r0, r8, ror r6
 814:	00000038 	andeq	r0, r0, r8, lsr r0
 818:	000066b0 			; <UNDEFINED> instruction: 0x000066b0
 81c:	0000005c 	andeq	r0, r0, ip, asr r0
 820:	00000000 	andeq	r0, r0, r0
 824:	00000002 	andeq	r0, r0, r2
	...
 830:	00000024 	andeq	r0, r0, r4, lsr #32
 834:	af290002 	svcge	0x00290002
 838:	00040000 	andeq	r0, r4, r0
 83c:	00000000 	andeq	r0, r0, r0
 840:	0000670c 	andeq	r6, r0, ip, lsl #14
 844:	00000030 	andeq	r0, r0, r0, lsr r0
 848:	0000673c 	andeq	r6, r0, ip, lsr r7
 84c:	00000024 	andeq	r0, r0, r4, lsr #32
	...

Disassembly of section .debug_info:

00000000 <.debug_info>:
       0:	00000078 	andeq	r0, r0, r8, ror r0
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
       4:	00000002 	andeq	r0, r0, r2
       8:	01040000 	mrseq	r0, (UNDEF: 4)
	...
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
      14:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
      18:	696c5f32 	stmdbvs	ip!, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
      1c:	5f632f62 	svcpl	0x00632f62
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
      20:	796c6e6f 	stmdbvc	ip!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
      24:	6174735f 	cmnvs	r4, pc, asr r3
      28:	70757472 	rsbsvc	r7, r5, r2, ror r4
    if ((wEPVal & EP_CTR_RX) != 0)
      2c:	4300732e 	movwmi	r7, #814	; 0x32e
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
      30:	73555c3a 	cmpvc	r5, #14848	; 0x3a00
      34:	5c737265 	lfmpl	f7, 2, [r3], #-404	; 0xfffffe6c
      38:	66696168 	strbtvs	r6, [r9], -r8, ror #2

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
      3c:	68637369 	stmdavs	r3!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}^

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
      40:	7365445c 	cmnvc	r5, #92, 8	; 0x5c000000
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
      44:	706f746b 	rsbvc	r7, pc, fp, ror #8
      48:	636e655c 	cmnvs	lr, #92, 10	; 0x17000000
      4c:	6576616c 	ldrbvs	r6, [r6, #-364]!	; 0x16c

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
      50:	6f72705f 	svcvs	0x0072705f
      54:	7463656a 	strbtvc	r6, [r3], #-1386	; 0x56a
      58:	6f6f625c 	svcvs	0x006f625c
      5c:	616f6c74 	smcvs	63172	; 0xf6c4
      60:	5c726564 	cfldr64pl	mvdx6, [r2], #-400	; 0xfffffe70
      64:	334d5453 	movtcc	r5, #54355	; 0xd453
      68:	00314632 	eorseq	r4, r1, r2, lsr r6
      6c:	20554e47 	subscs	r4, r5, r7, asr #28
      70:	32205341 	eorcc	r5, r0, #67108865	; 0x4000001
      74:	2e33322e 	cdpcs	2, 3, cr3, cr3, cr14, {1}
      78:	80010032 	andhi	r0, r1, r2, lsr r0
      7c:	0000007e 	andeq	r0, r0, lr, ror r0
      80:	00120002 	andseq	r0, r2, r2
      84:	01040000 	mrseq	r0, (UNDEF: 4)
      88:	00000075 	andeq	r0, r0, r5, ror r0
	...
      94:	74732f2e 	ldrbtvc	r2, [r3], #-3886	; 0xf2e
      98:	5f32336d 	svcpl	0x0032336d
      9c:	2f62696c 	svccs	0x0062696c
      a0:	74726f63 	ldrbtvc	r6, [r2], #-3939	; 0xf63
      a4:	336d7865 	cmncc	sp, #6619136	; 0x650000
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
      a8:	63616d5f 	cmnvs	r1, #6080	; 0x17c0

	return f25519_eq(a, c);
      ac:	532e6f72 	teqpl	lr, #456	; 0x1c8
      b0:	5c3a4300 	ldcpl	3, cr4, [sl], #-0
      b4:	72657355 	rsbvc	r7, r5, #1409286145	; 0x54000001
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
      b8:	61685c73 	smcvs	34243	; 0x85c3
	f25519_normalize(ey);
      bc:	73696669 	cmnvc	r9, #110100480	; 0x6900000
      c0:	445c6863 	ldrbmi	r6, [ip], #-2147	; 0x863

	return ok;
}
      c4:	746b7365 	strbtvc	r7, [fp], #-869	; 0x365
      c8:	655c706f 	ldrbvs	r7, [ip, #-111]	; 0x6f
      cc:	616c636e 	cmnvs	ip, lr, ror #6
      d0:	705f6576 	subsvc	r6, pc, r6, ror r5	; <UNPREDICTABLE>
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
      d4:	656a6f72 	strbvs	r6, [sl, #-3954]!	; 0xf72
      d8:	625c7463 	subsvs	r7, ip, #1660944384	; 0x63000000
		minusp[i] = c;
      dc:	6c746f6f 	ldclvs	15, cr6, [r4], #-444	; 0xfffffe44
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
      e0:	6564616f 	strbvs	r6, [r4, #-367]!	; 0x16f
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
      e4:	54535c72 	ldrbpl	r5, [r3], #-3186	; 0xc72

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
      e8:	4632334d 	ldrtmi	r3, [r2], -sp, asr #6
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
      ec:	4e470031 	mcrmi	0, 2, r0, cr7, cr1, {1}
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
      f0:	53412055 	movtpl	r2, #4181	; 0x1055
      f4:	322e3220 	eorcc	r3, lr, #32, 4
      f8:	00322e33 	eorseq	r2, r2, r3, lsr lr
      fc:	0e088001 	cdpeq	0, 0, cr8, cr8, cr1, {0}
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     100:	00040000 	andeq	r0, r4, r0

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
     104:	00000026 	andeq	r0, r0, r6, lsr #32
     108:	06390104 	ldrteq	r0, [r9], -r4, lsl #2
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     10c:	eb010000 	bl	40114 <_etext+0x38b00>
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
     110:	93000003 	movwls	r0, #3
     114:	20000008 	andcs	r0, r0, r8
     118:	00000000 	andeq	r0, r0, r0
     11c:	1b000000 	blne	124 <_Minimum_Stack_Size+0x24>
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     120:	02000001 	andeq	r0, r0, #1
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
     124:	02570704 	subseq	r0, r7, #4, 14	; 0x100000
     128:	04030000 	streq	r0, [r3], #-0
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
     12c:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
     130:	06010200 	streq	r0, [r1], -r0, lsl #4
	i <<= 3;

	while (x) {
     134:	0000081a 	andeq	r0, r0, sl, lsl r8
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
     138:	18080102 	stmdane	r8, {r1, r8}
     13c:	02000008 	andeq	r0, r0, #8
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
     140:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
	f25519_mul_c(z3, x1sq, 4);
     144:	02020000 	andeq	r0, r2, #0
     148:	00094907 	andeq	r4, r9, r7, lsl #18
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	05040200 	streq	r0, [r4, #-512]	; 0x200
     150:	000004da 	ldrdeq	r0, [r0], -sl
     154:	52070402 	andpl	r0, r7, #33554432	; 0x2000000
	f25519_sub(b, x3, z3); /* D */
     158:	02000002 	andeq	r0, r0, #2
     15c:	04d50508 	ldrbeq	r0, [r5], #1288	; 0x508
	f25519_mul__distinct(da, a, b);
     160:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
     164:	00024d07 	andeq	r4, r2, r7, lsl #26
     168:	07040200 	streq	r0, [r4, -r0, lsl #4]

	f25519_sub(b, x2, z2);
     16c:	0000078b 	andeq	r0, r0, fp, lsl #15
     170:	00780404 	rsbseq	r0, r8, r4, lsl #8
	f25519_add(a, x3, z3); /* C */
     174:	02050000 	andeq	r0, r5, #0
     178:	08210801 	stmdaeq	r1!, {r0, fp}
     17c:	75060000 	strvc	r0, [r6, #-0]
	f25519_mul__distinct(cb, a, b);
     180:	02003233 	andeq	r3, r0, #805306371	; 0x30000003
     184:	00005627 	andeq	r5, r0, r7, lsr #12

	f25519_add(a, da, cb);
     188:	31750600 	cmncc	r5, r0, lsl #12
     18c:	28020036 	stmdacs	r2, {r1, r2, r4, r5}
     190:	00000048 	andeq	r0, r0, r8, asr #32
	f25519_mul__distinct(b, a, a);
     194:	00387506 	eorseq	r7, r8, r6, lsl #10
     198:	003a2902 	eorseq	r2, sl, r2, lsl #18
	f25519_mul__distinct(x5, z1, b);
     19c:	5a070000 	bpl	1c01a4 <_etext+0x1b8b90>
     1a0:	02000003 	andeq	r0, r0, #3
     1a4:	0000ab2f 	andeq	sl, r0, pc, lsr #22

	f25519_sub(a, da, cb);
     1a8:	00560800 	subseq	r0, r6, r0, lsl #16
     1ac:	e3070000 	movw	r0, #28672	; 0x7000
	f25519_mul__distinct(b, a, a);
     1b0:	02000001 	andeq	r0, r0, #1
     1b4:	0000bb30 	andeq	fp, r0, r0, lsr fp
     1b8:	00480800 	subeq	r0, r8, r0, lsl #16

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	76060000 	strvc	r0, [r6], -r0
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	02003875 	andeq	r3, r0, #7667712	; 0x750000
     1c4:	0000cb31 	andeq	ip, r0, r1, lsr fp

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1c8:	003a0800 	eorseq	r0, sl, r0, lsl #16
     1cc:	01090000 	mrseq	r0, (UNDEF: 9)
     1d0:	00e53702 	rsceq	r3, r5, r2, lsl #14
     1d4:	530a0000 	movwpl	r0, #40960	; 0xa000
		f25519_select(zm1, zm1, zm, bit);
     1d8:	00000007 	andeq	r0, r0, r7
     1dc:	0001a70a 	andeq	sl, r1, sl, lsl #14
     1e0:	07000100 	streq	r0, [r0, -r0, lsl #2]
		f25519_select(xm, xm, xms, bit);
     1e4:	0000052d 	andeq	r0, r0, sp, lsr #10
     1e8:	00d03702 	sbcseq	r3, r0, r2, lsl #14
     1ec:	040b0000 	streq	r0, [fp], #-0
		f25519_select(zm, zm, zms, bit);
     1f0:	0129ae03 	teqeq	r9, r3, lsl #28
     1f4:	b60c0000 	strlt	r0, [ip], -r0
     1f8:	03000005 	movweq	r0, #5
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fc:	000096af 	andeq	r9, r0, pc, lsr #13
     200:	700c0000 	andvc	r0, ip, r0
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     204:	03000009 	movweq	r0, #9
     208:	000096b0 			; <UNDEFINED> instruction: 0x000096b0
	f25519_mul__distinct(result, zm1, xm);
     20c:	dd0c0100 	stfles	f0, [ip, #-0]
     210:	03000008 	movweq	r0, #8
	f25519_normalize(result);
     214:	000096b1 			; <UNDEFINED> instruction: 0x000096b1
     218:	960c0200 	strls	r0, [ip], -r0, lsl #4
}
     21c:	03000003 	movweq	r0, #3
     220:	0000e5b2 			; <UNDEFINED> instruction: 0x0000e5b2
     224:	07000300 	streq	r0, [r0, -r0, lsl #6]
     228:	000001f5 	strdeq	r0, [r0], -r5
     22c:	00f0b303 	rscseq	fp, r0, r3, lsl #6
     230:	280b0000 	stmdacs	fp, {}	; <UNPREDICTABLE>
     234:	01b4d903 			; <UNDEFINED> instruction: 0x01b4d903
     238:	430d0000 	movwmi	r0, #53248	; 0xd000
     23c:	da030052 	ble	c038c <_etext+0xb8d78>
     240:	000000a0 	andeq	r0, r0, r0, lsr #1
     244:	07590c00 	ldrbeq	r0, [r9, -r0, lsl #24]
     248:	db030000 	blle	c0250 <_etext+0xb8c3c>
     24c:	000000a0 	andeq	r0, r0, r0, lsr #1
     250:	49430d04 	stmdbmi	r3, {r2, r8, sl, fp}^
     254:	dc030052 	stcle	0, cr0, [r3], {82}	; 0x52
     258:	000000a0 	andeq	r0, r0, r0, lsr #1
     25c:	002a0c08 	eoreq	r0, sl, r8, lsl #24
     260:	dd030000 	stcle	0, cr0, [r3, #-0]
     264:	000000a0 	andeq	r0, r0, r0, lsr #1
     268:	00f10c0c 	rscseq	r0, r1, ip, lsl #24
     26c:	de030000 	cdple	0, 0, cr0, cr3, cr0, {0}
     270:	000000a0 	andeq	r0, r0, r0, lsr #1
     274:	04450c10 	strbeq	r0, [r5], #-3088	; 0xc10
     278:	df030000 	svcle	0x00030000
     27c:	000000a0 	andeq	r0, r0, r0, lsr #1
     280:	05ef0c14 	strbeq	r0, [pc, #3092]!	; e9c <usbPowerOn+0x2c>
     284:	e0030000 	and	r0, r3, r0
     288:	000000a0 	andeq	r0, r0, r0, lsr #1
     28c:	00000c18 	andeq	r0, r0, r8, lsl ip
     290:	e1030000 	mrs	r0, (UNDEF: 3)
     294:	000000a0 	andeq	r0, r0, r0, lsr #1
     298:	061a0c1c 			; <UNDEFINED> instruction: 0x061a0c1c
     29c:	e2030000 	and	r0, r3, #0
     2a0:	000000a0 	andeq	r0, r0, r0, lsr #1
     2a4:	53430d20 	movtpl	r0, #15648	; 0x3d20
     2a8:	e3030052 	movw	r0, #12370	; 0x3052
     2ac:	000000a0 	andeq	r0, r0, r0, lsr #1
     2b0:	33070024 	movwcc	r0, #28708	; 0x7024
     2b4:	03000003 	movweq	r0, #3
     2b8:	000134e4 	andeq	r3, r1, r4, ror #9
     2bc:	023d0e00 	eorseq	r0, sp, #0, 28
     2c0:	05010000 	streq	r0, [r1, #-0]
     2c4:	0001e416 	andeq	lr, r1, r6, lsl r4
     2c8:	05320a00 	ldreq	r0, [r2, #-2560]!	; 0xa00
     2cc:	0a000000 	beq	2d4 <GPIO_ReadOutputDataBit+0x8>
     2d0:	00000724 	andeq	r0, r0, r4, lsr #14
     2d4:	017e0a01 	cmneq	lr, r1, lsl #20
     2d8:	0a020000 	beq	802e0 <_etext+0x78ccc>
     2dc:	00000920 	andeq	r0, r0, r0, lsr #18
     2e0:	330f0003 	movwcc	r0, #61443	; 0xf003
     2e4:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
     2e8:	02092404 	andeq	r2, r9, #4, 8	; 0x4000000
     2ec:	e00c0000 	and	r0, ip, r0
     2f0:	04000002 	streq	r0, [r0], #-2
     2f4:	00020926 	andeq	r0, r2, r6, lsr #18
     2f8:	f10c0000 	cpsid	
     2fc:	04000003 	streq	r0, [r0], #-3
     300:	00008b27 	andeq	r8, r0, r7, lsr #22
     304:	04000400 	streq	r0, [r0], #-1024	; 0x400
     308:	00009604 	andeq	r9, r0, r4, lsl #12
     30c:	05720700 	ldrbeq	r0, [r2, #-1792]!	; 0x700
     310:	29040000 	stmdbcs	r4, {}	; <UNPREDICTABLE>
     314:	000001e4 	andeq	r0, r0, r4, ror #3
     318:	00057107 	andeq	r7, r5, r7, lsl #2
     31c:	25290400 	strcs	r0, [r9, #-1024]!	; 0x400
     320:	04000002 	streq	r0, [r0], #-2
     324:	0001e404 	andeq	lr, r1, r4, lsl #8
     328:	07c00e00 	strbeq	r0, [r0, r0, lsl #28]
     32c:	04010000 	streq	r0, [r1], #-0
     330:	0002502d 	andeq	r5, r2, sp, lsr #32
     334:	02860a00 	addeq	r0, r6, #0, 20
     338:	0a000000 	beq	340 <GPIO_PinRemapConfig+0xc>
     33c:	000009a9 	andeq	r0, r0, r9, lsr #19
     340:	01300a01 	teqeq	r0, r1, lsl #20
     344:	0a020000 	beq	8034c <_etext+0x78d38>
     348:	0000062b 	andeq	r0, r0, fp, lsr #12
     34c:	c1070003 	tstgt	r7, r3
     350:	04000007 	streq	r0, [r0], #-7
     354:	00022b34 	andeq	r2, r2, r4, lsr fp
     358:	05ff0f00 	ldrbeq	r0, [pc, #3840]!	; 1260 <hexdump+0x4c>
     35c:	040c0000 	streq	r0, [ip], #-0
     360:	00029838 	andeq	r9, r2, r8, lsr r8
     364:	01d70c00 	bicseq	r0, r7, r0, lsl #24
     368:	50040000 	andpl	r0, r4, r0
     36c:	0000008b 	andeq	r0, r0, fp, lsl #1
     370:	086d0c00 	stmdaeq	sp!, {sl, fp}^
     374:	51040000 	mrspl	r0, (UNDEF: 4)
     378:	0000008b 	andeq	r0, r0, fp, lsl #1
     37c:	21250c02 	teqcs	r5, r2, lsl #24
     380:	52040000 	andpl	r0, r4, #0
     384:	0000008b 	andeq	r0, r0, fp, lsl #1
     388:	07380c04 	ldreq	r0, [r8, -r4, lsl #24]!
     38c:	53040000 	movwpl	r0, #16384	; 0x4000
     390:	000002a7 	andeq	r0, r0, r7, lsr #5
     394:	09100008 	ldmdbeq	r0, {r3}
     398:	a7000002 	strge	r0, [r0, -r2]
     39c:	11000002 	tstne	r0, r2
     3a0:	0000008b 	andeq	r0, r0, fp, lsl #1
     3a4:	98040400 	stmdals	r4, {sl}
     3a8:	07000002 	streq	r0, [r0, -r2]
     3ac:	00000600 	andeq	r0, r0, r0, lsl #12
     3b0:	025b5404 	subseq	r5, fp, #4, 8	; 0x4000000
     3b4:	230f0000 	movwcs	r0, #61440	; 0xf000
     3b8:	02000006 	andeq	r0, r0, #6
     3bc:	02dd5804 	sbcseq	r5, sp, #4, 16	; 0x40000
     3c0:	700c0000 	andvc	r0, ip, r0
     3c4:	04000003 	streq	r0, [r0], #-3
     3c8:	0000965a 	andeq	r9, r0, sl, asr r6
     3cc:	8c0c0000 	stchi	0, cr0, [ip], {-0}
     3d0:	04000005 	streq	r0, [r0], #-5
     3d4:	0000965b 	andeq	r9, r0, fp, asr r6
     3d8:	07000100 	streq	r0, [r0, -r0, lsl #2]
     3dc:	00000624 	andeq	r0, r0, r4, lsr #12
     3e0:	02b85d04 	adcseq	r5, r8, #4, 26	; 0x100
     3e4:	42120000 	andsmi	r0, r2, #0
     3e8:	04020057 	streq	r0, [r2], #-87	; 0x57
     3ec:	00030c62 	andeq	r0, r3, r2, ror #24
     3f0:	62620d00 	rsbvs	r0, r2, #0, 26
     3f4:	65040030 	strvs	r0, [r4, #-48]	; 0x30
     3f8:	00000096 	muleq	r0, r6, r0
     3fc:	62620d00 	rsbvs	r0, r2, #0, 26
     400:	66040031 			; <UNDEFINED> instruction: 0x66040031
     404:	00000096 	muleq	r0, r6, r0
     408:	02130001 	andseq	r0, r3, #1
     40c:	03285f04 	teqeq	r8, #4, 30
     410:	77140000 	ldrvc	r0, [r4, -r0]
     414:	8b610400 	blhi	184141c <_etext+0x1839e08>
     418:	14000000 	strne	r0, [r0], #-0
     41c:	04007762 	streq	r7, [r0], #-1890	; 0x762
     420:	0002e868 	andeq	lr, r2, r8, ror #16
     424:	30070000 	andcc	r0, r7, r0
     428:	04000009 	streq	r0, [r0], #-9
     42c:	00030c69 	andeq	r0, r3, r9, ror #24
     430:	01140f00 	tsteq	r4, r0, lsl #30
     434:	041c0000 	ldreq	r0, [ip], #-0
     438:	0003c46b 	andeq	ip, r3, fp, ror #8
     43c:	07670c00 	strbeq	r0, [r7, -r0, lsl #24]!
     440:	6d040000 	stcvs	0, cr0, [r4, #-0]
     444:	00000096 	muleq	r0, r6, r0
     448:	00150c00 	andseq	r0, r5, r0, lsl #24
     44c:	6e040000 	cdpvs	0, 0, cr0, cr4, cr0, {0}
     450:	00000096 	muleq	r0, r6, r0
     454:	03110c01 	tsteq	r1, #256	; 0x100
     458:	6f040000 	svcvs	0x00040000
     45c:	00000328 	andeq	r0, r0, r8, lsr #6
     460:	01480c02 	cmpeq	r8, r2, lsl #24
     464:	70040000 	andvc	r0, r4, r0
     468:	00000328 	andeq	r0, r0, r8, lsr #6
     46c:	04eb0c04 	strbteq	r0, [fp], #3076	; 0xc04
     470:	71040000 	mrsvc	r0, (UNDEF: 4)
     474:	00000328 	andeq	r0, r0, r8, lsr #6
     478:	06ef0c06 	strbteq	r0, [pc], r6, lsl #24
     47c:	73040000 	movwvc	r0, #16384	; 0x4000
     480:	00000096 	muleq	r0, r6, r0
     484:	08080c08 	stmdaeq	r8, {r3, sl, fp}
     488:	74040000 	strvc	r0, [r4], #-0
     48c:	00000096 	muleq	r0, r6, r0
     490:	05070c09 	streq	r0, [r7, #-3081]	; 0xc09
     494:	75040000 	strvc	r0, [r4, #-0]
     498:	00000096 	muleq	r0, r6, r0
     49c:	054f0c0a 	strbeq	r0, [pc, #-3082]	; fffff89a <BootRAM+0xef7003b>
     4a0:	76040000 	strvc	r0, [r4], -r0
     4a4:	00000096 	muleq	r0, r6, r0
     4a8:	05d60c0b 	ldrbeq	r0, [r6, #3083]	; 0xc0b
     4ac:	77040000 	strvc	r0, [r4, -r0]
     4b0:	00000096 	muleq	r0, r6, r0
     4b4:	07c80c0c 	strbeq	r0, [r8, ip, lsl #24]
     4b8:	7a040000 	bvc	1004c0 <_etext+0xf8eac>
     4bc:	000002ad 	andeq	r0, r0, sp, lsr #5
     4c0:	15070010 	strne	r0, [r7, #-16]
     4c4:	04000001 	streq	r0, [r0], #-1
     4c8:	0003337b 	andeq	r3, r3, fp, ror r3
     4cc:	03a90f00 			; <UNDEFINED> instruction: 0x03a90f00
     4d0:	04340000 	ldrteq	r0, [r4], #-0
     4d4:	0004787d 	andeq	r7, r4, sp, ror r8
     4d8:	02960c00 	addseq	r0, r6, #0, 24
     4dc:	7f040000 	svcvc	0x00040000
     4e0:	00000072 	andeq	r0, r0, r2, ror r0
     4e4:	04b80c00 	ldrteq	r0, [r8], #3072	; 0xc00
     4e8:	80040000 	andhi	r0, r4, r0
     4ec:	00000072 	andeq	r0, r0, r2, ror r0
     4f0:	09370c04 	ldmdbeq	r7!, {r2, sl, fp}
     4f4:	83040000 	movwhi	r0, #16384	; 0x4000
     4f8:	00000072 	andeq	r0, r0, r2, ror r0
     4fc:	07780c08 	ldrbeq	r0, [r8, -r8, lsl #24]!
     500:	84040000 	strhi	r0, [r4], #-0
     504:	00000072 	andeq	r0, r0, r2, ror r0
     508:	02c30c0c 	sbceq	r0, r3, #12, 24	; 0xc00
     50c:	96040000 	strls	r0, [r4], -r0
     510:	00000487 	andeq	r0, r0, r7, lsl #9
     514:	006d0c10 	rsbeq	r0, sp, r0, lsl ip
     518:	a1040000 	mrsge	r0, (UNDEF: 4)
     51c:	00000487 	andeq	r0, r0, r7, lsl #9
     520:	09c50c14 	stmibeq	r5, {r2, r4, sl, fp}^
     524:	ab040000 	blge	10052c <_etext+0xf8f18>
     528:	000004a1 	andeq	r0, r0, r1, lsr #9
     52c:	02d70c18 	sbcseq	r0, r7, #24, 24	; 0x1800
     530:	ad040000 	stcge	0, cr0, [r4, #-0]
     534:	000002a7 	andeq	r0, r0, r7, lsr #5
     538:	03b90c1c 			; <UNDEFINED> instruction: 0x03b90c1c
     53c:	ae040000 	cdpge	0, 0, cr0, cr4, cr0, {0}
     540:	000002a7 	andeq	r0, r0, r7, lsr #5
     544:	01c30c20 	biceq	r0, r3, r0, lsr #24
     548:	af040000 	svcge	0x00040000
     54c:	000002a7 	andeq	r0, r0, r7, lsr #5
     550:	03420c24 	movteq	r0, #11300	; 0x2c24
     554:	b0040000 	andlt	r0, r4, r0
     558:	000002a7 	andeq	r0, r0, r7, lsr #5
     55c:	04670c28 	strbteq	r0, [r7], #-3112	; 0xc28
     560:	b2040000 	andlt	r0, r4, #0
     564:	00000209 	andeq	r0, r0, r9, lsl #4
     568:	21220c2c 	teqcs	r2, ip, lsr #24
     56c:	b3040000 	movwlt	r0, #16384	; 0x4000
     570:	00000096 	muleq	r0, r6, r0
     574:	50100030 	andspl	r0, r0, r0, lsr r0
     578:	87000002 	strhi	r0, [r0, -r2]
     57c:	11000004 	tstne	r0, r4
     580:	00000096 	muleq	r0, r6, r0
     584:	78040400 	stmdavc	r4, {sl}
     588:	10000004 	andne	r0, r0, r4
     58c:	00000250 	andeq	r0, r0, r0, asr r2
     590:	000004a1 	andeq	r0, r0, r1, lsr #9
     594:	00009611 	andeq	r9, r0, r1, lsl r6
     598:	00961100 	addseq	r1, r6, r0, lsl #2
     59c:	04000000 	streq	r0, [r0], #-0
     5a0:	00048d04 	andeq	r8, r4, r4, lsl #26
     5a4:	03aa0700 			; <UNDEFINED> instruction: 0x03aa0700
     5a8:	b5040000 	strlt	r0, [r4, #-0]
     5ac:	000003cf 	andeq	r0, r0, pc, asr #7
     5b0:	00008a0f 	andeq	r8, r0, pc, lsl #20
     5b4:	b7042400 	strlt	r2, [r4, -r0, lsl #8]
     5b8:	0000052b 	andeq	r0, r0, fp, lsr #10
     5bc:	0005a00c 	andeq	sl, r5, ip
     5c0:	72b90400 	adcsvc	r0, r9, #0, 8
     5c4:	00000000 	andeq	r0, r0, r0
     5c8:	00041d0c 	andeq	r1, r4, ip, lsl #26
     5cc:	72ba0400 	adcsvc	r0, sl, #0, 8
     5d0:	04000000 	streq	r0, [r0], #-0
     5d4:	00029b0c 	andeq	r9, r2, ip, lsl #22
     5d8:	72bb0400 	adcsvc	r0, fp, #0, 8
     5dc:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
     5e0:	0004330c 	andeq	r3, r4, ip, lsl #6
     5e4:	72bc0400 	adcsvc	r0, ip, #0, 8
     5e8:	0c000000 	stceq	0, cr0, [r0], {-0}
     5ec:	0000a20c 	andeq	sl, r0, ip, lsl #4
     5f0:	72bd0400 	adcsvc	r0, sp, #0, 8
     5f4:	10000000 	andne	r0, r0, r0
     5f8:	0007410c 	andeq	r4, r7, ip, lsl #2
     5fc:	72be0400 	adcsvc	r0, lr, #0, 8
     600:	14000000 	strne	r0, [r0], #-0
     604:	0008f80c 	andeq	pc, r8, ip, lsl #16
     608:	72bf0400 	adcsvc	r0, pc, #0, 8
     60c:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
     610:	0001910c 	andeq	r9, r1, ip, lsl #2
     614:	72c00400 	sbcvc	r0, r0, #0, 8
     618:	1c000000 	stcne	0, cr0, [r0], {-0}
     61c:	0002ad0c 	andeq	sl, r2, ip, lsl #26
     620:	72c10400 	sbcvc	r0, r1, #0, 8
     624:	20000000 	andcs	r0, r0, r0
     628:	008b0700 	addeq	r0, fp, r0, lsl #14
     62c:	c3040000 	movwgt	r0, #16384	; 0x4000
     630:	000004b2 			; <UNDEFINED> instruction: 0x000004b2
     634:	0000fa0e 	andeq	pc, r0, lr, lsl #20
     638:	3d060100 	stfccs	f0, [r6, #-0]
     63c:	00000573 	andeq	r0, r0, r3, ror r5
     640:	0005c60a 	andeq	ip, r5, sl, lsl #12
     644:	570a0000 	strpl	r0, [sl, -r0]
     648:	01000004 	tsteq	r0, r4
     64c:	0000080a 	andeq	r0, r0, sl, lsl #16
     650:	670a0200 	strvs	r0, [sl, -r0, lsl #4]
     654:	03000001 	movweq	r0, #1
     658:	0008d00a 	andeq	sp, r8, sl
     65c:	8c0a0400 	cfstrshi	mvf0, [sl], {-0}
     660:	05000003 	streq	r0, [r0, #-3]
     664:	0004ca0a 	andeq	ip, r4, sl, lsl #20
     668:	1c0a0600 	stcne	6, cr0, [sl], {-0}
     66c:	07000003 	streq	r0, [r0, -r3]
     670:	00fb0700 	rscseq	r0, fp, r0, lsl #14
     674:	46060000 	strmi	r0, [r6], -r0
     678:	00000536 	andeq	r0, r0, r6, lsr r5
     67c:	0008790e 	andeq	r7, r8, lr, lsl #18
     680:	48060100 	stmdami	r6, {r8}
     684:	000005af 	andeq	r0, r0, pc, lsr #11
     688:	0008870a 	andeq	r8, r8, sl, lsl #14
     68c:	5c0a0000 	stcpl	0, cr0, [sl], {-0}
     690:	01000009 	tsteq	r0, r9
     694:	0004e30a 	andeq	lr, r4, sl, lsl #6
     698:	920a0200 	andls	r0, sl, #0, 4
     69c:	03000009 	movweq	r0, #9
     6a0:	0003cd0a 	andeq	ip, r3, sl, lsl #26
     6a4:	f70a0400 			; <UNDEFINED> instruction: 0xf70a0400
     6a8:	05000007 	streq	r0, [r0, #-7]
     6ac:	087a0700 	ldmdaeq	sl!, {r8, r9, sl}^
     6b0:	4f060000 	svcmi	0x00060000
     6b4:	0000057e 	andeq	r0, r0, lr, ror r5
     6b8:	6301020b 	movwvs	r0, #4619	; 0x120b
     6bc:	000005db 	ldrdeq	r0, [r0], -fp
     6c0:	0003010c 	andeq	r0, r3, ip, lsl #2
     6c4:	db640100 	blle	1900acc <_etext+0x18f94b8>
     6c8:	00000005 	andeq	r0, r0, r5
     6cc:	0003080c 	andeq	r0, r3, ip, lsl #16
     6d0:	e0650100 	rsb	r0, r5, r0, lsl #2
     6d4:	01000005 	tsteq	r0, r5
     6d8:	05730800 	ldrbeq	r0, [r3, #-2048]!	; 0x800
     6dc:	96080000 	strls	r0, [r8], -r0
     6e0:	15000000 	strne	r0, [r0, #-0]
     6e4:	00000121 	andeq	r0, r0, r1, lsr #2
     6e8:	50018801 	andpl	r8, r1, r1, lsl #16
     6ec:	01000002 	tsteq	r0, r2
     6f0:	00000603 	andeq	r0, r0, r3, lsl #12
     6f4:	0005f716 	andeq	pc, r5, r6, lsl r7	; <UNPREDICTABLE>
     6f8:	01880100 	orreq	r0, r8, r0, lsl #2
     6fc:	00000096 	muleq	r0, r6, r0
     700:	03281700 	teqeq	r8, #0, 14
     704:	ad010000 	stcge	0, cr0, [r1, #-0]
     708:	01081801 	tsteq	r8, r1, lsl #16
     70c:	a7010000 	strge	r0, [r1, -r0]
     710:	00000b98 	muleq	r0, r8, fp
     714:	00000002 	andeq	r0, r0, r2
     718:	be199c01 	cdplt	12, 1, cr9, cr9, cr1, {0}
     71c:	01000004 	tsteq	r0, r4
     720:	0b9a0157 	bleq	fe680c84 <BootRAM+0xd5f1425>
     724:	00020000 	andeq	r0, r2, r0
     728:	9c010000 	stcls	0, cr0, [r1], {-0}
     72c:	00049a19 	andeq	r9, r4, r9, lsl sl
     730:	015c0100 	cmpeq	ip, r0, lsl #2
     734:	00000b9c 	muleq	r0, ip, fp
     738:	00000002 	andeq	r0, r0, r2
     73c:	da1a9c01 	ble	6a7748 <_etext+0x6a0134>
     740:	01000000 	mrseq	r0, (UNDEF: 0)
     744:	02500193 	subseq	r0, r0, #-1073741788	; 0xc0000024
     748:	0b9e0000 	bleq	fe780750 <BootRAM+0xd6f0ef1>
     74c:	000a0000 	andeq	r0, sl, r0
     750:	9c010000 	stcls	0, cr0, [r1], {-0}
     754:	00000679 	andeq	r0, r0, r9, ror r6
     758:	0000631b 	andeq	r6, r0, fp, lsl r3
     75c:	01930100 	orrseq	r0, r3, r0, lsl #2
     760:	00000096 	muleq	r0, r6, r0
     764:	00000000 	andeq	r0, r0, r0
     768:	0001731c 	andeq	r7, r1, ip, lsl r3
     76c:	01930100 	orrseq	r0, r3, r0, lsl #2
     770:	00000096 	muleq	r0, r6, r0
     774:	19005101 	stmdbne	r0, {r0, r8, ip, lr}
     778:	00000206 	andeq	r0, r0, r6, lsl #4
     77c:	a801bf01 	stmdage	r1, {r0, r8, r9, sl, fp, ip, sp, pc}
     780:	0200000b 	andeq	r0, r0, #11
     784:	01000000 	mrseq	r0, (UNDEF: 0)
     788:	0153199c 			; <UNDEFINED> instruction: 0x0153199c
     78c:	c4010000 	strgt	r0, [r1], #-0
     790:	000bac01 	andeq	sl, fp, r1, lsl #24
     794:	00001800 	andeq	r1, r0, r0, lsl #16
     798:	199c0100 	ldmibne	ip, {r8}
     79c:	00000706 	andeq	r0, r0, r6, lsl #14
     7a0:	c401cb01 	strgt	ip, [r1], #-2817	; 0xb01
     7a4:	0200000b 	andeq	r0, r0, #11
     7a8:	01000000 	mrseq	r0, (UNDEF: 0)
     7ac:	04f7199c 	ldrbteq	r1, [r7], #2460	; 0x99c
     7b0:	d0010000 	andle	r0, r1, r0
     7b4:	000bc601 	andeq	ip, fp, r1, lsl #12
     7b8:	00000200 	andeq	r0, r0, r0, lsl #4
     7bc:	199c0100 	ldmibne	ip, {r8}
     7c0:	0000084c 	andeq	r0, r0, ip, asr #16
     7c4:	c801d501 	stmdagt	r1, {r0, r8, sl, ip, lr, pc}
     7c8:	0200000b 	andeq	r0, r0, #11
     7cc:	01000000 	mrseq	r0, (UNDEF: 0)
     7d0:	0910199c 	ldmdbeq	r0, {r2, r3, r4, r7, r8, fp, ip}
     7d4:	da010000 	ble	407dc <_etext+0x391c8>
     7d8:	000bca01 	andeq	ip, fp, r1, lsl #20
     7dc:	00000200 	andeq	r0, r0, r0, lsl #4
     7e0:	199c0100 	ldmibne	ip, {r8}
     7e4:	00000227 	andeq	r0, r0, r7, lsr #4
     7e8:	cc01df01 	stcgt	15, cr13, [r1], {1}
     7ec:	0200000b 	andeq	r0, r0, #11
     7f0:	01000000 	mrseq	r0, (UNDEF: 0)
     7f4:	0859199c 	ldmdaeq	r9, {r2, r3, r4, r7, r8, fp, ip}^
     7f8:	e4010000 	str	r0, [r1], #-0
     7fc:	000bce01 	andeq	ip, fp, r1, lsl #28
     800:	00000200 	andeq	r0, r0, r0, lsl #4
     804:	199c0100 	ldmibne	ip, {r8}
     808:	000001ac 	andeq	r0, r0, ip, lsr #3
     80c:	d001e901 	andle	lr, r1, r1, lsl #18
     810:	0c00000b 	stceq	0, cr0, [r0], {11}
     814:	01000000 	mrseq	r0, (UNDEF: 0)
     818:	04b51d9c 	ldrteq	r1, [r5], #3484	; 0xd9c
     81c:	3d010000 	stccc	0, cr0, [r1, #-0]
     820:	000bdc01 	andeq	sp, fp, r1, lsl #24
     824:	0000a800 	andeq	sl, r0, r0, lsl #16
     828:	a49c0100 	ldrge	r0, [ip], #256	; 0x100
     82c:	1e000007 	cdpne	0, 0, cr0, cr0, cr7, {0}
     830:	00000c0c 	andeq	r0, r0, ip, lsl #24
     834:	00000012 	andeq	r0, r0, r2, lsl r0
     838:	0000074f 	andeq	r0, r0, pc, asr #14
     83c:	00075e1f 	andeq	r5, r7, pc, lsl lr
     840:	01480100 	mrseq	r0, (UNDEF: 88)
     844:	0000008b 	andeq	r0, r0, fp, lsl #1
     848:	00000021 	andeq	r0, r0, r1, lsr #32
     84c:	0be22000 	bleq	ff888854 <BootRAM+0xe7f8ff5>
     850:	0d280000 	stceq	0, cr0, [r8, #-0]
     854:	42210000 	eormi	r0, r1, #0
     858:	2f00000c 	svccs	0x0000000c
     85c:	6c00000d 	stcvs	0, cr0, [r0], {13}
     860:	22000007 	andcs	r0, r0, #7
     864:	74025001 	strvc	r5, [r2], #-1
     868:	50210000 	eorpl	r0, r1, r0
     86c:	4100000c 	tstmi	r0, ip
     870:	8000000d 	andhi	r0, r0, sp
     874:	22000007 	andcs	r0, r0, #7
     878:	74025001 	strvc	r5, [r2], #-1
     87c:	56210000 	strtpl	r0, [r1], -r0
     880:	5800000c 	stmdapl	r0, {r2, r3}
     884:	9400000d 	strls	r0, [r0], #-13
     888:	22000007 	andcs	r0, r0, #7
     88c:	74025001 	strvc	r5, [r2], #-1
     890:	66230000 	strtvs	r0, [r3], -r0
     894:	6a00000c 	bvs	8cc <USART_ClockInit+0x10>
     898:	2200000d 	andcs	r0, r0, #13
     89c:	30015001 	andcc	r5, r1, r1
     8a0:	ea1a0000 	b	6808a8 <_etext+0x679294>
     8a4:	01000007 	tsteq	r0, r7
     8a8:	02500161 	subseq	r0, r0, #1073741848	; 0x40000018
     8ac:	0c840000 	stceq	0, cr0, [r4], {0}
     8b0:	00600000 	rsbeq	r0, r0, r0
     8b4:	9c010000 	stcls	0, cr0, [r1], {-0}
     8b8:	000007f4 	strdeq	r0, [r0], -r4
     8bc:	0005f71b 	andeq	pc, r5, fp, lsl r7	; <UNPREDICTABLE>
     8c0:	01610100 	cmneq	r1, r0, lsl #2
     8c4:	00000096 	muleq	r0, r6, r0
     8c8:	00000070 	andeq	r0, r0, r0, ror r0
     8cc:	00060e1f 	andeq	r0, r6, pc, lsl lr
     8d0:	01620100 	cmneq	r2, r0, lsl #2
     8d4:	000002a7 	andeq	r0, r0, r7, lsr #5
     8d8:	00000091 	muleq	r0, r1, r0
     8dc:	000c9c20 	andeq	r9, ip, r0, lsr #24
     8e0:	000d7b00 	andeq	r7, sp, r0, lsl #22
     8e4:	0cc82400 	cfstrdeq	mvd2, [r8], {0}
     8e8:	01220000 	teqeq	r2, r0
     8ec:	00740250 	rsbseq	r0, r4, r0, asr r2
     8f0:	d41a0000 	ldrle	r0, [sl], #-0
     8f4:	01000002 	tsteq	r0, r2
     8f8:	0209019d 	andeq	r0, r9, #1073741863	; 0x40000027
     8fc:	0ce40000 	stcleq	0, cr0, [r4]
     900:	000c0000 	andeq	r0, ip, r0
     904:	9c010000 	stcls	0, cr0, [r1], {-0}
     908:	00000828 	andeq	r0, r0, r8, lsr #16
     90c:	6e656c25 	cdpvs	12, 6, cr6, cr5, cr5, {1}
     910:	019d0100 	orrseq	r0, sp, r0, lsl #2
     914:	0000008b 	andeq	r0, r0, fp, lsl #1
     918:	000000c8 	andeq	r0, r0, r8, asr #1
     91c:	000cea26 	andeq	lr, ip, r6, lsr #20
     920:	000d8600 	andeq	r8, sp, r0, lsl #12
     924:	b61a0000 	ldrlt	r0, [sl], -r0
     928:	01000003 	tsteq	r0, r3
     92c:	020901a2 	andeq	r0, r9, #-2147483608	; 0x80000028
     930:	0cf00000 	ldcleq	0, cr0, [r0]
     934:	000c0000 	andeq	r0, ip, r0
     938:	9c010000 	stcls	0, cr0, [r1], {-0}
     93c:	0000085c 	andeq	r0, r0, ip, asr r8
     940:	6e656c25 	cdpvs	12, 6, cr6, cr5, cr5, {1}
     944:	01a20100 			; <UNDEFINED> instruction: 0x01a20100
     948:	0000008b 	andeq	r0, r0, fp, lsl #1
     94c:	000000e9 	andeq	r0, r0, r9, ror #1
     950:	000cf626 	andeq	pc, ip, r6, lsr #12
     954:	000d8600 	andeq	r8, sp, r0, lsl #12
     958:	c01a0000 	andsgt	r0, sl, r0
     95c:	01000001 	tsteq	r0, r1
     960:	020901a7 	andeq	r0, r9, #-1073741783	; 0xc0000029
     964:	0cfc0000 	ldcleq	0, cr0, [ip]
     968:	00200000 	eoreq	r0, r0, r0
     96c:	9c010000 	stcls	0, cr0, [r1], {-0}
     970:	0000089c 	muleq	r0, ip, r8
     974:	6e656c25 	cdpvs	12, 6, cr6, cr5, cr5, {1}
     978:	01a70100 			; <UNDEFINED> instruction: 0x01a70100
     97c:	0000008b 	andeq	r0, r0, fp, lsl #1
     980:	0000010a 	andeq	r0, r0, sl, lsl #2
     984:	00002127 	andeq	r2, r0, r7, lsr #2
     988:	01a90100 			; <UNDEFINED> instruction: 0x01a90100
     98c:	00000096 	muleq	r0, r6, r0
     990:	000d1026 	andeq	r1, sp, r6, lsr #32
     994:	000d8600 	andeq	r8, sp, r0, lsl #12
     998:	3f1a0000 	svccc	0x001a0000
     99c:	01000003 	tsteq	r0, r3
     9a0:	020901b1 	andeq	r0, r9, #1073741868	; 0x4000002c
     9a4:	0d1c0000 	ldceq	0, cr0, [ip, #-0]
     9a8:	000c0000 	andeq	r0, ip, r0
     9ac:	9c010000 	stcls	0, cr0, [r1], {-0}
     9b0:	000008d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     9b4:	6e656c25 	cdpvs	12, 6, cr6, cr5, cr5, {1}
     9b8:	01b10100 			; <UNDEFINED> instruction: 0x01b10100
     9bc:	0000008b 	andeq	r0, r0, fp, lsl #1
     9c0:	00000144 	andeq	r0, r0, r4, asr #2
     9c4:	000d2226 	andeq	r2, sp, r6, lsr #4
     9c8:	000d8600 	andeq	r8, sp, r0, lsl #12
     9cc:	e5280000 	str	r0, [r8, #-0]!
     9d0:	28000005 	stmdacs	r0, {r0, r2}
     9d4:	2800000d 	stmdacs	r0, {r0, r2, r3}
     9d8:	01000000 	mrseq	r0, (UNDEF: 0)
     9dc:	0009099c 	muleq	r9, ip, r9
     9e0:	05f62900 	ldrbeq	r2, [r6, #2304]!	; 0x900
     9e4:	01650000 	cmneq	r5, r0
     9e8:	382a0000 	stmdacc	sl!, {}	; <UNPREDICTABLE>
     9ec:	0e00000d 	cdpeq	0, 0, cr0, cr0, cr13, {0}
     9f0:	29000000 	stmdbcs	r0, {}	; <UNPREDICTABLE>
     9f4:	000005f6 	strdeq	r0, [r0], -r6
     9f8:	0000019f 	muleq	r0, pc, r1	; <UNPREDICTABLE>
     9fc:	000d3c20 	andeq	r3, sp, r0, lsr #24
     a00:	000d7b00 	andeq	r7, sp, r0, lsl #22
     a04:	2b000000 	blcs	a0c <USART_SetPrescaler+0x4>
     a08:	000007d2 	ldrdeq	r0, [r0], -r2
     a0c:	0d506c01 	ldcleq	12, cr6, [r0, #-4]
     a10:	00680000 	rsbeq	r0, r8, r0
     a14:	9c010000 	stcls	0, cr0, [r1], {-0}
     a18:	00000987 	andeq	r0, r0, r7, lsl #19
     a1c:	00071e2c 	andeq	r1, r7, ip, lsr #28
     a20:	878d0100 	strhi	r0, [sp, r0, lsl #2]
     a24:	02000009 	andeq	r0, r0, #9
     a28:	032d6c91 	teqeq	sp, #37120	; 0x9100
     a2c:	9c000006 	stcls	0, cr0, [r0], {6}
     a30:	0400000d 	streq	r0, [r0], #-13
     a34:	01000000 	mrseq	r0, (UNDEF: 0)
     a38:	0009499c 	muleq	r9, ip, r9
     a3c:	0da02000 	stceq	0, cr2, [r0]
     a40:	0da00000 	stceq	0, cr0, [r0]
     a44:	21000000 	mrscs	r0, (UNDEF: 0)
     a48:	00000d5e 	andeq	r0, r0, lr, asr sp
     a4c:	00000da7 	andeq	r0, r0, r7, lsr #27
     a50:	0000096a 	andeq	r0, r0, sl, ror #18
     a54:	01520122 	cmpeq	r2, r2, lsr #2
     a58:	51012230 	tstpl	r1, r0, lsr r2
     a5c:	01223c01 	teqeq	r2, r1, lsl #24
     a60:	000c0550 	andeq	r0, ip, r0, asr r5
     a64:	00400108 	subeq	r0, r0, r8, lsl #2
     a68:	000d6621 	andeq	r6, sp, r1, lsr #12
     a6c:	000dc300 	andeq	ip, sp, r0, lsl #6
     a70:	00097d00 	andeq	r7, r9, r0, lsl #26
     a74:	50012200 	andpl	r2, r1, r0, lsl #4
     a78:	20003c01 	andcs	r3, r0, r1, lsl #24
     a7c:	00000d82 	andeq	r0, r0, r2, lsl #27
     a80:	00000dd9 	ldrdeq	r0, [r0], -r9
     a84:	00800800 	addeq	r0, r0, r0, lsl #16
     a88:	03280000 	teqeq	r8, #0
     a8c:	00000006 	andeq	r0, r0, r6
     a90:	04000000 	streq	r0, [r0], #-0
     a94:	01000000 	mrseq	r0, (UNDEF: 0)
     a98:	0009a99c 	muleq	r9, ip, r9
     a9c:	00002600 	andeq	r2, r0, r0, lsl #12
     aa0:	0da00000 	stceq	0, cr0, [r0]
     aa4:	2b000000 	blcs	aac <USART_IrDAConfig+0x4>
     aa8:	00000581 	andeq	r0, r0, r1, lsl #11
     aac:	0db8b301 	ldceq	3, cr11, [r8, #4]!
     ab0:	001c0000 	andseq	r0, ip, r0
     ab4:	9c010000 	stcls	0, cr0, [r1], {-0}
     ab8:	000009ce 	andeq	r0, r0, lr, asr #19
     abc:	0005612e 	andeq	r6, r5, lr, lsr #2
     ac0:	8bb50100 	blhi	fed40ec8 <BootRAM+0xdcb1669>
     ac4:	b5000000 	strlt	r0, [r0, #-0]
     ac8:	00000001 	andeq	r0, r0, r1
     acc:	0004a72b 	andeq	sl, r4, fp, lsr #14
     ad0:	d4be0100 	ldrtle	r0, [lr], #256	; 0x100
     ad4:	1800000d 	stmdane	r0, {r0, r2, r3}
     ad8:	01000000 	mrseq	r0, (UNDEF: 0)
     adc:	0009f69c 	muleq	r9, ip, r6
     ae0:	05612c00 	strbeq	r2, [r1, #-3072]!	; 0xc00
     ae4:	c0010000 	andgt	r0, r1, r0
     ae8:	0000008b 	andeq	r0, r0, fp, lsl #1
     aec:	09007106 	stmdbeq	r0, {r1, r2, r8, ip, sp, lr}
     af0:	009f1afb 			; <UNDEFINED> instruction: 0x009f1afb
     af4:	00047d2b 	andeq	r7, r4, fp, lsr #26
     af8:	eccb0100 	stfe	f0, [fp], {0}
     afc:	8400000d 	strhi	r0, [r0], #-13
     b00:	01000000 	mrseq	r0, (UNDEF: 0)
     b04:	000a3c9c 	muleq	sl, ip, ip
     b08:	08262f00 	stmdaeq	r6!, {r8, r9, sl, fp, sp}
     b0c:	cb010000 	blgt	40b14 <_etext+0x39500>
     b10:	00000573 	andeq	r0, r0, r3, ror r5
     b14:	000001cc 	andeq	r0, r0, ip, asr #3
     b18:	0005612e 	andeq	r6, r5, lr, lsr #2
     b1c:	8bcd0100 	blhi	ff340f24 <BootRAM+0xe2b16c5>
     b20:	1f000000 	svcne	0x00000000
     b24:	20000002 	andcs	r0, r0, r2
     b28:	00000e0a 	andeq	r0, r0, sl, lsl #28
     b2c:	000009ce 	andeq	r0, r0, lr, asr #19
     b30:	000e1020 	andeq	r1, lr, r0, lsr #32
     b34:	0009ce00 	andeq	ip, r9, r0, lsl #28
     b38:	4c300000 	ldcmi	0, cr0, [r0], #-0
     b3c:	01000004 	tsteq	r0, r4
     b40:	000250fc 	strdeq	r5, [r2], -ip
     b44:	000e7000 	andeq	r7, lr, r0
     b48:	00004800 	andeq	r4, r0, r0, lsl #16
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	739c0100 	orrsvc	r0, ip, #0, 2
  b	LoopCopyDataInit
     b50:	3100000a 	tstcc	r0, sl

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
     b54:	00000ea2 	andeq	r0, r0, r2, lsr #29
	str	r3, [r0, r1]
	adds	r1, r1, #4
     b58:	00000da7 	andeq	r0, r0, r7, lsr #27

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
     b5c:	01520122 	cmpeq	r2, r2, lsr #2
	adds	r2, r0, r1
	cmp	r2, r3
     b60:	51012231 	tstpl	r1, r1, lsr r2
	bcc	CopyDataInit
     b64:	01223c01 	teqeq	r2, r1, lsl #24
	ldr	r2, =_sbss
	b	LoopFillZerobss
     b68:	000c0550 	andeq	r0, ip, r0, asr r5
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	00400108 	subeq	r0, r0, r8, lsl #2
	str	r3, [r2], #4
     b70:	06e31a00 	strbteq	r1, [r3], r0, lsl #20

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
     b74:	14010000 	strne	r0, [r1], #-0
	bcc	FillZerobss
     b78:	00025001 	andeq	r5, r2, r1
/* Call the application's entry point.*/
	bl	main
     b7c:	000eb800 	andeq	fp, lr, r0, lsl #16
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	00003c00 	andeq	r3, r0, r0, lsl #24
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	ac9c0100 	ldfges	f0, [ip], {0}
	ldr	r3, =_edata
     b88:	3100000a 	tstcc	r0, sl
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	00000ed4 	ldrdeq	r0, [r0], -r4
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	00000da7 	andeq	r0, r0, r7, lsr #27
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	02520122 	subseq	r0, r2, #-2147483640	; 0x80000008
}


/* dummy proc */
void nothingProc(void)
{
     b98:	01220074 	teqeq	r2, r4, ror r0
{
    return;
}

void usbStatusOut(void)
{
     b9c:	223c0151 	eorscs	r0, ip, #1073741844	; 0x40000014
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
     ba0:	0c055001 	stceq	0, cr5, [r5], {1}
     ba4:	40010800 	andmi	r0, r1, r0, lsl #16
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	672b0000 	strvs	r0, [fp, -r0]!
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	01000005 	tsteq	r0, r5
     bb0:	000ef4a0 	andeq	pc, lr, r0, lsr #9
        bDeviceState = CONFIGURED;
     bb4:	00000400 	andeq	r0, r0, r0, lsl #8
     bb8:	cb9c0100 	blgt	fe700fc0 <BootRAM+0xd671761>
     bbc:	2600000a 	strcs	r0, [r0], -sl
     bc0:	00000ef8 	strdeq	r0, [r0], -r8
    }
}

void usbGetInterface(void)
{
     bc4:	00000a73 	andeq	r0, r0, r3, ror sl
{
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	04731d00 	ldrbteq	r1, [r3], #-3328	; 0xd00
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	f0010000 			; <UNDEFINED> instruction: 0xf0010000
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	000ef801 	andeq	pc, lr, r1, lsl #16
     bd4:	00002400 	andeq	r2, r0, r0, lsl #8
     bd8:	019c0100 	orrseq	r0, ip, r0, lsl #2
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	3200000b 	andcc	r0, r0, #11
    dfuUpdateByReset();
     be0:	00000401 	andeq	r0, r0, r1, lsl #8

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	2901f201 	stmdbcs	r1, {r0, r9, ip, sp, lr, pc}

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be8:	02000001 	andeq	r0, r0, #1
     bec:	16317491 			; <UNDEFINED> instruction: 0x16317491
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	e500000f 	str	r0, [r0, #-15]
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	2200000d 	andcs	r0, r0, #13
     bf8:	7d025001 	stcvc	0, cr5, [r2, #-4]

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfc:	1d000004 	stcne	0, cr0, [r0, #-16]
     c00:	0000005b 	andeq	r0, r0, fp, asr r0
     c04:	1c012d01 	stcne	13, cr2, [r1], {1}
     c08:	4000000f 	andmi	r0, r0, pc
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c0c:	01000000 	mrseq	r0, (UNDEF: 0)
     c10:	000b339c 	muleq	fp, ip, r3
     c14:	0f222000 	svceq	0x00222000
     c18:	0dfd0000 	ldcleq	0, cr0, [sp]
     c1c:	2e200000 	cdpcs	0, 2, cr0, cr0, cr0, {0}

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c20:	3c00000f 	stccc	0, cr0, [r0], {15}
     c24:	2000000a 	andcs	r0, r0, sl
     c28:	00000f42 	andeq	r0, r0, r2, asr #30
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	00000acb 	andeq	r0, r0, fp, asr #21
     c30:	00801d00 	addeq	r1, r0, r0, lsl #26
     c34:	fb010000 	blx	40c3e <_etext+0x3962a>
     c38:	000f5c01 	andeq	r5, pc, r1, lsl #24
     c3c:	00002200 	andeq	r2, r0, r0, lsl #4

    Clear_Status_Out(ENDP0);
     c40:	699c0100 	ldmibvs	ip, {r8}

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c44:	3200000b 	andcc	r0, r0, #11
     c48:	00000401 	andeq	r0, r0, r1, lsl #8
     c4c:	2901fd01 	stmdbcs	r1, {r0, r8, sl, fp, ip, sp, lr, pc}
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	02000001 	andeq	r0, r0, #1
     c54:	78317491 	ldmdavc	r1!, {r0, r4, r7, sl, ip, sp, lr}

    bDeviceState = ATTACHED;
     c58:	e500000f 	str	r0, [r0, #-15]
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
     c5c:	2200000d 	andcs	r0, r0, #13

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	7d025001 	stcvc	0, cr5, [r2, #-4]
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c64:	33000004 	movwcc	r0, #4
     c68:	000000bf 	strheq	r0, [r0], -pc	; <UNPREDICTABLE>
     c6c:	80020501 	andhi	r0, r2, r1, lsl #10
     c70:	b400000f 	strlt	r0, [r0], #-15
     c74:	01000000 	mrseq	r0, (UNDEF: 0)
     c78:	000bb49c 	muleq	fp, ip, r4
     c7c:	0f9c2000 	svceq	0x009c2000
     c80:	0e040000 	cdpeq	0, 0, cr0, cr4, cr0, {0}
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	d6210000 	strtle	r0, [r1], -r0
     c88:	f600000f 			; <UNDEFINED> instruction: 0xf600000f
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8c:	9b000009 	blls	cb8 <usbDataSetup+0x34>
     c90:	2200000b 	andcs	r0, r0, #11
     c94:	30015001 	andcc	r5, r1, r1
        if (dfuUpdateByRequest()) {
     c98:	0fe42000 	svceq	0x00e42000
     c9c:	09a90000 	stmibeq	r9!, {}	; <UNPREDICTABLE>
            // successfull state transition, handle the request
            switch (request) {
     ca0:	1c230000 	stcne	0, cr0, [r3], #-0
     ca4:	f6000010 			; <UNDEFINED> instruction: 0xf6000010
     ca8:	22000009 	andcs	r0, r0, #9
     cac:	37015001 	strcc	r5, [r1, -r1]
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	43340000 	teqmi	r4, #0
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
     cb4:	01000005 	tsteq	r0, r5
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
     cb8:	05af0255 	streq	r0, [pc, #597]!	; f15 <usbEnbISR+0x1d>
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	00000000 	andeq	r0, r0, r0
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
     cc0:	000c0000 	andeq	r0, ip, r0
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	9c010000 	stcls	0, cr0, [r1], {-0}
        (*CopyRoutine)(0);

        return USB_SUCCESS;
     cc8:	00041435 	andeq	r1, r4, r5, lsr r4
    }

    return USB_UNSUPPORT;
     ccc:	d9690100 	stmdble	r9!, {r8}^
}
     cd0:	0000000b 	andeq	r0, r0, fp
     cd4:	36400210 			; <UNDEFINED> instruction: 0x36400210
     cd8:	00000bde 	ldrdeq	r0, [r0], -lr
     cdc:	01b40404 			; <UNDEFINED> instruction: 0x01b40404
     ce0:	02370000 	eorseq	r0, r7, #0
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	01000008 	tsteq	r0, r8
     ce8:	0000b02b 	andeq	fp, r0, fp, lsr #32
     cec:	8c030500 	cfstr32hi	mvfx0, [r3], {-0}
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	37200004 	strcc	r0, [r0, -r4]!
     cf4:	000002eb 	andeq	r0, r0, fp, ror #5
     cf8:	04a73301 	strteq	r3, [r7], #769	; 0x301
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	03050000 	movweq	r0, #20480	; 0x5000
     d00:	20000014 	andcs	r0, r0, r4, lsl r0
    if (strIndex > STR_DESC_LEN) {
     d04:	001f6d37 	andseq	r6, pc, r7, lsr sp	; <UNPREDICTABLE>
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d08:	2b430100 	blcs	10c1110 <_etext+0x10b9afc>
     d0c:	05000005 	streq	r0, [r0, #-5]
    }
}
     d10:	00008003 	andeq	r8, r0, r3
     d14:	021a3720 	andseq	r3, sl, #32, 14	; 0x800000
     d18:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
     d1c:	000002dd 	ldrdeq	r0, [r0], -sp
     d20:	00a40305 	adceq	r0, r4, r5, lsl #6
     d24:	e8382000 	ldmda	r8!, {sp}

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	07000001 	streq	r0, [r0, -r1]
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2c:	000c3322 	andeq	r3, ip, r2, lsr #6
     d30:	c4040400 	strgt	r0, [r4], #-1024	; 0x400
     d34:	38000003 	stmdacc	r0, {r0, r1}
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	0000013e 	andeq	r0, r0, lr, lsr r1
     d3c:	0c442507 	cfstr64eq	mvdx2, [r4], {7}
            return USB_SUCCESS;
     d40:	04040000 	streq	r0, [r4], #-0
     d44:	000004a7 	andeq	r0, r0, r7, lsr #9
        }
    }
    return USB_UNSUPPORT;
}
     d48:	00051d38 	andeq	r1, r5, r8, lsr sp
     d4c:	8b2d0700 	blhi	b42954 <_etext+0xb3b340>

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d54:	00000a27 	andeq	r0, r0, r7, lsr #20
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	020f2308 	andeq	r2, pc, #8, 6	; 0x20000000
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5c:	44380000 	ldrtmi	r0, [r8], #-0
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d60:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
     d64:	00020f24 	andeq	r0, r2, r4, lsr #30
     d68:	020f3900 	andeq	r3, pc, #0, 18
     d6c:	0c7b0000 	ldcleq	0, cr0, [fp], #-0
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d70:	6b3a0000 	blvs	e80d78 <_etext+0xe79764>
     d74:	06000000 	streq	r0, [r0], -r0
     d78:	03d73800 	bicseq	r3, r7, #0, 16
     d7c:	25080000 	strcs	r0, [r8, #-0]
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d80:	00000c6b 	andeq	r0, r0, fp, ror #24
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	0007a838 	andeq	sl, r7, r8, lsr r8
     d88:	0f260800 	svceq	0x00260800
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8c:	37000002 	strcc	r0, [r0, -r2]
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d90:	000000b1 	strheq	r0, [r0], -r1
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d94:	002c2c06 	eoreq	r2, ip, r6, lsl #24
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d98:	03050000 	movweq	r0, #20480	; 0x5000

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	20000488 	andcs	r0, r0, r8, lsl #9
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	00009639 	andeq	r9, r0, r9, lsr r6
     da4:	000cad00 	andeq	sl, ip, r0, lsl #26
     da8:	38003b00 	stmdacc	r0, {r8, r9, fp, ip, sp}
     dac:	00000041 	andeq	r0, r0, r1, asr #32
     db0:	0ca22501 	cfstr32eq	mvfx2, [r2], #4
     db4:	a5380000 	ldrge	r0, [r8, #-0]!
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	01000007 	tsteq	r0, r7
     dbc:	000ca226 	andeq	sl, ip, r6, lsr #4
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dc0:	02fb3700 	rscseq	r3, fp, #0, 14

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	28010000 	stmdacs	r1, {}	; <UNPREDICTABLE>
     dc8:	000000a0 	andeq	r0, r0, r0, lsr #1
     dcc:	05b80305 	ldreq	r0, [r8, #773]!	; 0x305
     dd0:	d7372000 	ldrle	r2, [r7, -r0]!
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	01000006 	tsteq	r0, r6
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd8:	0000c02c 	andeq	ip, r0, ip, lsr #32
     ddc:	b4030500 	strlt	r0, [r3], #-1280	; 0x500

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	39200005 	stmdbcc	r0!, {r0, r2}
     de4:	00000072 	andeq	r0, r0, r2, ror r0
     de8:	00000cf5 	strdeq	r0, [r0], -r5
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	00006b3a 	andeq	r6, r0, sl, lsr fp
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	37000600 	strcc	r0, [r0, -r0, lsl #12]
        ResumeS.eState = eResumeSetVal;
     df4:	000009b3 			; <UNDEFINED> instruction: 0x000009b3

    switch (ResumeS.eState) {
     df8:	0ce54f01 	stcleq	15, cr4, [r5], #4
     dfc:	03050000 	movweq	r0, #20480	; 0x5000
     e00:	20000048 	andcs	r0, r0, r8, asr #32
     e04:	00096537 	andeq	r6, r9, r7, lsr r5
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	e5590100 	ldrb	r0, [r9, #-256]	; 0x100
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	0500000c 	streq	r0, [r0, #-12]
        ResumeS.eState = RESUME_START;
     e10:	00006403 	andeq	r6, r0, r3, lsl #8
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	07163720 	ldreq	r3, [r6, -r0, lsr #14]
        ResumeS.eState = RESUME_WAIT;
     e18:	66010000 	strvs	r0, [r1], -r0
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	000005ba 			; <UNDEFINED> instruction: 0x000005ba
     e20:	048e0305 	streq	r0, [lr], #773	; 0x305
        if (ResumeS.bESOFcnt == 0)
     e24:	3b3c2000 	blcc	f08e2c <_etext+0xf01818>
            ResumeS.eState = RESUME_START;
     e28:	09000008 	stmdbeq	r0, {r3}
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	07943d6e 	ldreq	r3, [r4, lr, ror #26]
     e30:	460a0000 	strmi	r0, [sl], -r0
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e34:	000d4102 	andeq	r4, sp, r2, lsl #2
        ResumeS.eState = RESUME_ON;
     e38:	00961100 	addseq	r1, r6, r0, lsl #2
        ResumeS.bESOFcnt = 10;
     e3c:	3d000000 	stccc	0, cr0, [r0, #-0]
        break;
     e40:	0000099c 	muleq	r0, ip, r9
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e44:	5802570a 	stmdapl	r2, {r1, r3, r8, r9, sl, ip, lr}
     e48:	1100000d 	tstne	r0, sp
        if (ResumeS.bESOFcnt == 0) {
     e4c:	00000096 	muleq	r0, r6, r0
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	00008b11 	andeq	r8, r0, r1, lsl fp
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	7f3d0000 	svcvc	0x003d0000
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e58:	0a000003 	beq	e6c <usbResume+0x80>
            ResumeS.eState = RESUME_OFF;
     e5c:	0d6a0240 	sfmeq	f0, 2, [sl, #-256]!	; 0xffffff00
     e60:	96110000 	ldrls	r0, [r1], -r0
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e64:	00000000 	andeq	r0, r0, r0
     e68:	0002b23e 	andeq	fp, r2, lr, lsr r2
     e6c:	7be90400 	blvc	ffa41e74 <BootRAM+0xe9b2615>
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	1100000d 	tstne	r0, sp
     e74:	00000096 	muleq	r0, r6, r0
     e78:	04873f00 	streq	r3, [r7], #3840	; 0xf00
     e7c:	6d090000 	stcvs	0, cr0, [r9, #-0]

    _SetCNTR(CNTR_FRES);
     e80:	000000e5 	andeq	r0, r0, r5, ror #1
     e84:	00026440 	andeq	r6, r2, r0, asr #8
     e88:	09e50400 	stmibeq	r5!, {sl}^
     e8c:	a0000002 	andge	r0, r0, r2
    _SetCNTR(0);
    _SetISTR(0);
     e90:	1100000d 	tstne	r0, sp

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e94:	0000008b 	andeq	r0, r0, fp, lsl #1
    _SetCNTR(wInterrupt_Mask);
     e98:	00021a11 	andeq	r1, r2, r1, lsl sl
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9c:	923c0000 	eorsls	r0, ip, #0
     ea0:	07000002 	streq	r0, [r0, -r2]
#endif
#endif

    return USB_SUCCESS;
}
     ea4:	07db3d19 	bfieq	r3, r9, #26, #2
     ea8:	24030000 	strcs	r0, [r3], #-0
     eac:	000dc301 	andeq	ip, sp, r1, lsl #6
     eb0:	00801100 	addeq	r1, r0, r0, lsl #2
     eb4:	96110000 	ldrls	r0, [r1], -r0

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	11000000 	mrsne	r0, (UNDEF: 0)
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	00000096 	muleq	r0, r6, r0
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
     ec0:	027f4100 	rsbseq	r4, pc, #0, 2
     ec4:	25030000 	strcs	r0, [r3, #-0]
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec8:	00002501 	andeq	r2, r0, r1, lsl #10
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     ecc:	000dd900 	andeq	sp, sp, r0, lsl #18
     ed0:	002c1100 	eoreq	r1, ip, r0, lsl #2
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	42000000 	andmi	r0, r0, #0
     ed8:	0000035f 	andeq	r0, r0, pc, asr r3
     edc:	2c013c03 	stccs	12, cr3, [r1], {3}

    return USB_SUCCESS;
}
     ee0:	3d000000 	stccc	0, cr0, [r0, #-0]
     ee4:	000009e1 	andeq	r0, r0, r1, ror #19
     ee8:	f7013803 			; <UNDEFINED> instruction: 0xf7013803
     eec:	1100000d 	tstne	r0, sp
     ef0:	00000df7 	strdeq	r0, [r0], -r7
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	29040400 	stmdbcs	r4, {sl}
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	3c000001 	stccc	0, cr0, [r0], {1}
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efc:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	343c6a09 	ldrtcc	r6, [ip], #-2569	; 0xa09
     f04:	0b000008 	bleq	f2c <usbInit+0x10>
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f08:	0259001a 	subseq	r0, r9, #26
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	00040000 	andeq	r0, r4, r0
     f10:	0000040b 	andeq	r0, r0, fp, lsl #8
    nvicInit(&NVIC_InitStructure);
     f14:	06390104 	ldrteq	r0, [r9], -r4, lsl #2
}
     f18:	9a010000 	bls	40f20 <_etext+0x3990c>

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	9300000a 	movwls	r0, #10
    dfuInit();
     f20:	c6000008 	strgt	r0, [r0], -r8

    pInformation->Current_Configuration = 0;
     f24:	02000004 	andeq	r0, r0, #4
     f28:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    usbPowerOn();
     f2c:	04030074 	streq	r0, [r3], #-116	; 0x74

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
     f30:	00025707 	andeq	r5, r2, r7, lsl #14
     f34:	06010300 	streq	r0, [r1], -r0, lsl #6
     f38:	0000081a 	andeq	r0, r0, sl, lsl r8
    _SetCNTR(wInterrupt_Mask);
     f3c:	18080103 	stmdane	r8, {r0, r1, r8}

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f40:	03000008 	movweq	r0, #8
    bDeviceState = UNCONNECTED;
     f44:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
     f48:	02030000 	andeq	r0, r3, #0
     f4c:	00094907 	andeq	r4, r9, r7, lsl #18
     f50:	05040300 	streq	r0, [r4, #-768]	; 0x300
     f54:	000004da 	ldrdeq	r0, [r0], -sl
     f58:	52070403 	andpl	r0, r7, #50331648	; 0x3000000
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	03000002 	movweq	r0, #2
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f60:	04d50508 	ldrbeq	r0, [r5], #1288	; 0x508
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	08030000 	stmdaeq	r3, {}	; <UNPREDICTABLE>

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f68:	00024d07 	andeq	r4, r2, r7, lsl #26
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	07040300 	streq	r0, [r4, -r0, lsl #6]
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	0000078b 	andeq	r0, r0, fp, lsl #15
    nvicInit(&NVIC_InitStructure);
     f74:	21080103 	tstcs	r8, r3, lsl #2
}
     f78:	04000008 	streq	r0, [r0], #-8
     f7c:	00363175 	eorseq	r3, r6, r5, ror r1

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	00402801 	subeq	r2, r0, r1, lsl #16
    wIstr = _GetISTR();
     f84:	75040000 	strvc	r0, [r4, #-0]

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	29010038 	stmdbcs	r1, {r3, r4, r5}
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8c:	00000032 	andeq	r0, r0, r2, lsr r0

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f90:	00003305 	andeq	r3, r0, r5, lsl #6
     f94:	24020800 	strcs	r0, [r2], #-2048	; 0x800
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	000000ab 	andeq	r0, r0, fp, lsr #1
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	0002e006 	andeq	lr, r2, r6
     fa0:	ab260200 	blge	9817a8 <_etext+0x97a194>
     fa4:	00000000 	andeq	r0, r0, r0
        _SetISTR((u16)CLR_RESET);
     fa8:	0003f106 	andeq	pc, r3, r6, lsl #2
        Device_Property.Reset();
     fac:	71270200 	teqvc	r7, r0, lsl #4
     fb0:	04000000 	streq	r0, [r0], #-0
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb4:	7c040700 	stcvc	7, cr0, [r4], {-0}
     fb8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
        _SetISTR((u16)CLR_ERR);
     fbc:	00000572 	andeq	r0, r0, r2, ror r5
     fc0:	00862902 	addeq	r2, r6, r2, lsl #18
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc4:	b1090000 	mrslt	r0, (UNDEF: 9)
     fc8:	03000000 	movweq	r0, #0
        _SetISTR((u16)CLR_WKUP);
     fcc:	00001d2c 	andeq	r1, r0, ip, lsr #26
        usbResume(RESUME_EXTERNAL);
     fd0:	88030500 	stmdahi	r3, {r8, sl}
     fd4:	09200004 	stmdbeq	r0!, {r2}
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd8:	00000a27 	andeq	r0, r0, r7, lsr #20
     fdc:	00b13d04 	adcseq	r3, r1, r4, lsl #26

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	03050000 	movweq	r0, #20480	; 0x5000
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	20000158 	andcs	r0, r0, r8, asr r1
     fe8:	00004409 	andeq	r4, r0, r9, lsl #8
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fec:	b1970400 	orrslt	r0, r7, r0, lsl #8
     ff0:	05000000 	streq	r0, [r0, #-0]
        _SetISTR((u16)CLR_SOF);
     ff4:	0002b403 	andeq	fp, r2, r3, lsl #8
     ff8:	00b10a20 	adcseq	r0, r1, r0, lsr #20
        bIntPackSOF++;
     ffc:	00ff0000 	rscseq	r0, pc, r0
    1000:	630b0000 	movwvs	r0, #45056	; 0xb000
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	06000000 	streq	r0, [r0], -r0
    1008:	03d70900 	bicseq	r0, r7, #0, 18
        _SetISTR((u16)CLR_ESOF);
    100c:	cc040000 	stcgt	0, cr0, [r4], {-0}
    1010:	000000ef 	andeq	r0, r0, pc, ror #1
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    }
#endif

}
    1014:	00a80305 	adceq	r0, r8, r5, lsl #6
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	a8092000 	stmdage	r9, {sp}
    101c:	04000007 	streq	r0, [r0], #-7
    1020:	0000b14f 	andeq	fp, r0, pc, asr #2
    1024:	f4030500 	vst3.8	{d0,d2,d4}, [r3], r0
    1028:	0a200000 	beq	801030 <_etext+0x7f9a1c>
    102c:	0000007c 	andeq	r0, r0, ip, ror r0
    1030:	00000131 	andeq	r0, r0, r1, lsr r1
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
    1034:	0000630b 	andeq	r6, r0, fp, lsl #6
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    1038:	09001100 	stmdbeq	r0, {r8, ip}
    setupCLK();
    103c:	00000a24 	andeq	r0, r0, r4, lsr #20
    setupLEDAndButton();
    1040:	01212604 	teqeq	r1, r4, lsl #12
    setupUSB();
    1044:	03050000 	movweq	r0, #20480	; 0x5000
    setupFLASH();
    1048:	200000e0 	andcs	r0, r0, r0, ror #1
    uartInit();
    104c:	00007c0a 	andeq	r7, r0, sl, lsl #24
    usbReset();
    1050:	00015200 	andeq	r5, r1, r0, lsl #4
	uart_printf("\nBootloader init...\n");
    1054:	00630b00 	rsbeq	r0, r3, r0, lsl #22
    1058:	00080000 	andeq	r0, r8, r0

    if (readPin(GPIOB, 15) == 0x0)
    105c:	0007a509 	andeq	sl, r7, r9, lsl #10
    1060:	42420400 	submi	r0, r2, #0, 8
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1064:	05000001 	streq	r0, [r0, #-1]
    1068:	00013d03 	andeq	r3, r1, r3, lsl #26
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    106c:	007c0a20 	rsbseq	r0, ip, r0, lsr #20
    1070:	01730000 	cmneq	r3, r0
    1074:	630b0000 	movwvs	r0, #45056	; 0xb000
    
    debug_print("image check ret: %X\n", ret);
    1078:	2c000000 	stccs	0, cr0, [r0], {-0}
    107c:	00410900 	subeq	r0, r1, r0, lsl #18
	switch (ret)
    1080:	55040000 	strpl	r0, [r4, #-0]
    1084:	00000163 	andeq	r0, r0, r3, ror #2
    1088:	01000305 	tsteq	r0, r5, lsl #6

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
	bool no_user_jump = FALSE;
    108c:	7c0a2000 	stcvc	0, cr2, [sl], {-0}
    1090:	94000000 	strls	r0, [r0], #-0
    1094:	0b000001 	bleq	10a0 <main+0x6c>
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1098:	00000063 	andeq	r0, r0, r3, rrx
			no_user_jump = FALSE;
    109c:	87090003 	strhi	r0, [r9, -r3]
			break;

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    10a0:	0400000a 	streq	r0, [r0], #-10
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    10a4:	0001849d 	muleq	r1, sp, r4
			no_user_jump = TRUE;
			break;

		case kImageImageHashCalcFailed:
			uart_printf("Hash calculation failed... waiting in DFU\n");
    10a8:	fc030500 	stc2	5, cr0, [r3], {-0}
    10ac:	09200000 	stmdbeq	r0!, {}	; <UNPREDICTABLE>
			break;
			
		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10b0:	000009ea 	andeq	r0, r0, sl, ror #19
    10b4:	0121a404 	teqeq	r1, r4, lsl #8
    10b8:	03050000 	movweq	r0, #20480	; 0x5000
    10bc:	20000146 	andcs	r0, r0, r6, asr #2
    10c0:	00007c0a 	andeq	r7, r0, sl, lsl #24

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10c4:	0001c600 	andeq	ip, r1, r0, lsl #12
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10c8:	00630b00 	rsbeq	r0, r3, r0, lsl #22
    10cc:	00130000 	andseq	r0, r3, r0
    10d0:	000a7309 	andeq	r7, sl, r9, lsl #6
    10d4:	b6aa0400 	strtlt	r0, [sl], r0, lsl #8
    10d8:	05000001 	streq	r0, [r0, #-1]

		if (dfuUploadStarted()) 
    10dc:	00016003 	andeq	r6, r1, r3
		{
			uart_printf("DFU finished upload\n");
    10e0:	007c0a20 	rsbseq	r0, ip, r0, lsr #20
    10e4:	01e70000 	mvneq	r0, r0
			dfuFinishUpload(); // systemHardReset from DFU once done
    10e8:	630b0000 	movwvs	r0, #45056	; 0xb000
    10ec:	0f000000 	svceq	0x00000000
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10f0:	0a4f0900 	beq	13c34f8 <_etext+0x13bbee4>
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10f4:	b0040000 	andlt	r0, r4, r0
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10f8:	000001d7 	ldrdeq	r0, [r0], -r7
    10fc:	012d0305 	teqeq	sp, r5, lsl #6
	}
	
	return 0;// Added to please the compiler
    1100:	7c0a2000 	stcvc	0, cr2, [sl], {-0}
    1104:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    1108:	0b000002 	bleq	1118 <main+0xe4>
    110c:	00000063 	andeq	r0, r0, r3, rrx
    1110:	62090077 	andvs	r0, r9, #119	; 0x77
    1114:	0400000a 	streq	r0, [r0], #-10
    1118:	0001f8b6 			; <UNDEFINED> instruction: 0x0001f8b6
    111c:	74030500 	strvc	r0, [r3], #-1280	; 0x500
    1120:	0a200001 	beq	80112c <_etext+0x7f9b18>
    1124:	0000007c 	andeq	r0, r0, ip, ror r0
    1128:	00000229 	andeq	r0, r0, r9, lsr #4
    112c:	0000630b 	andeq	r6, r0, fp, lsl #6
    1130:	09006300 	stmdbeq	r0, {r8, r9, sp, lr}
    1134:	00000a13 	andeq	r0, r0, r3, lsl sl
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1138:	0219bd04 	andseq	fp, r9, #4, 26	; 0x100
    113c:	03050000 	movweq	r0, #20480	; 0x5000
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    1140:	200001ec 	andcs	r0, r0, ip, ror #3
    1144:	000a3e09 	andeq	r3, sl, r9, lsl #28
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1148:	19c40400 	stmibne	r4, {sl}^
    114c:	05000002 	streq	r0, [r0, #-2]
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    1150:	00025003 	andeq	r5, r2, r3
    1154:	09fd0920 	ldmibeq	sp!, {r5, r8, fp}^
        return TRUE;
    } else {
        return FALSE;
    }
}
    1158:	ca040000 	bgt	101160 <_etext+0xf9b4c>
    115c:	0000007c 	andeq	r0, r0, ip, ror r0

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	00000305 	andeq	r0, r0, r5, lsl #6
    1164:	b0000000 	andlt	r0, r0, r0
    1168:	04000004 	streq	r0, [r0], #-4
    gpio_write_bit( bank,pin,1-onState);
    116c:	00049500 	andeq	r9, r4, r0, lsl #10
    1170:	39010400 	stmdbcc	r1, {sl}
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1174:	01000006 	tsteq	r0, r6
    gpio_write_bit( bank,pin,1-onState);
    1178:	00000bfb 	strdeq	r0, [r0], -fp

    u32 c;
    while (count-- > 0) 
    117c:	00000893 	muleq	r0, r3, r8
	{
        for (c = rate; c > 0; c--)
    1180:	00000130 	andeq	r0, r0, r0, lsr r1
    1184:	00000000 	andeq	r0, r0, r0
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1188:	00000538 	andeq	r0, r0, r8, lsr r5
    118c:	000ae302 	andeq	lr, sl, r2, lsl #6
    1190:	30d40200 	sbcscc	r0, r4, r0, lsl #4
		
        for (c = rate; c > 0; c--)
    1194:	03000000 	movweq	r0, #0
    1198:	02570704 	subseq	r0, r7, #4, 14	; 0x100000
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    119c:	04040000 	streq	r0, [r4], #-0
    11a0:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
    11a4:	06010300 	streq	r0, [r1], -r0, lsl #6
    11a8:	0000081a 	andeq	r0, r0, sl, lsl r8
    11ac:	000ad902 	andeq	sp, sl, r2, lsl #18

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    11b0:	501c0300 	andspl	r0, ip, r0, lsl #6
    11b4:	03000000 	movweq	r0, #0
  USARTx->DR = ch;  
    11b8:	08180801 	ldmdaeq	r8, {r0, fp}
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11bc:	02030000 	andeq	r0, r3, #0
  while(*str != 0)
    11c0:	0006fc05 	andeq	pc, r6, r5, lsl #24
    11c4:	07020300 	streq	r0, [r2, -r0, lsl #6]
  {
    UU_PutChar(USARTx, *str);
    11c8:	00000949 	andeq	r0, r0, r9, asr #18
    11cc:	da050403 	ble	1421e0 <_etext+0x13abcc>
    str++;
  }
}

void vprint(const char *fmt, va_list argp)
{
    11d0:	02000004 	andeq	r0, r0, #4
    11d4:	00000abf 			; <UNDEFINED> instruction: 0x00000abf
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11d8:	00773803 	rsbseq	r3, r7, r3, lsl #16
    11dc:	04030000 	streq	r0, [r3], #-0
    11e0:	00025207 	andeq	r5, r2, r7, lsl #4
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11e4:	05080300 	streq	r0, [r8, #-768]	; 0x300
    11e8:	000004d5 	ldrdeq	r0, [r0], -r5

    }
}
    11ec:	4d070803 	stcmi	8, cr0, [r7, #-12]
    11f0:	03000002 	movweq	r0, #2
    11f4:	078b0704 	streq	r0, [fp, r4, lsl #14]

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11f8:	01030000 	mrseq	r0, (UNDEF: 3)
    11fc:	00082108 	andeq	r2, r8, r8, lsl #2
    1200:	a0040500 	andge	r0, r4, r0, lsl #10
    va_list argp;
    va_start(argp, fmt);
    vprint(fmt, argp);
    1204:	06000000 	streq	r0, [r0], -r0
    va_end(argp);
}
    1208:	00000093 	muleq	r0, r3, r0
    120c:	000adb02 	andeq	sp, sl, r2, lsl #22
    1210:	452a0400 	strmi	r0, [sl, #-1024]!	; 0x400

void hexdump(unsigned char *data, size_t size)
{
    1214:	02000000 	andeq	r0, r0, #0
    1218:	00000ac1 	andeq	r0, r0, r1, asr #21
    int i;
    char cs[17];
    memset(cs, 0, 17);
    121c:	006c4204 	rsbeq	r4, ip, r4, lsl #4
    1220:	75070000 	strvc	r0, [r7, #-0]
    1224:	05003233 	streq	r3, [r0, #-563]	; 0x233

    for(i = 0; i < size; i++)
    1228:	00007727 	andeq	r7, r0, r7, lsr #14
    122c:	38750700 	ldmdacc	r5!, {r8, r9, sl}^
    {
        if(i != 0 && i % 0x10 == 0)
    1230:	50290500 	eorpl	r0, r9, r0, lsl #10
        {
            debug_print(" |%s|\n", cs);
    1234:	02000000 	andeq	r0, r0, #0
    1238:	0000035a 	andeq	r0, r0, sl, asr r3
            memset(cs, 0, 17);
    123c:	00db2f05 	sbcseq	r2, fp, r5, lsl #30
    1240:	77080000 	strvc	r0, [r8, -r0]
    1244:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
        }
        else if(i != 0 && i % 0x8 == 0)
    1248:	f5370501 			; <UNDEFINED> instruction: 0xf5370501
    124c:	0a000000 	beq	1254 <hexdump+0x40>
        {
            debug_print(" ",0);
    1250:	00000753 	andeq	r0, r0, r3, asr r7
        }
        debug_print("%02X ", data[i]);
    1254:	01a70a00 			; <UNDEFINED> instruction: 0x01a70a00
    1258:	00010000 	andeq	r0, r1, r0
        cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
    125c:	00052d02 	andeq	r2, r5, r2, lsl #26
    1260:	e0370500 	eors	r0, r7, r0, lsl #10
    1264:	0b000000 	bleq	126c <hexdump+0x58>
    1268:	00000b59 	andeq	r0, r0, r9, asr fp
    126c:	550d0614 	strpl	r0, [sp, #-1556]	; 0x614
    1270:	0c000001 	stceq	0, cr0, [r0], {1}
    }

    i = i % 0x10;
    if(i != 0)
    1274:	00000b51 	andeq	r0, r0, r1, asr fp
        while(i++ < 0x10)
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
    1278:	00b00e06 	adcseq	r0, r0, r6, lsl #28
    127c:	0c000000 	stceq	0, cr0, [r0], {-0}
}
    1280:	00000b09 	andeq	r0, r0, r9, lsl #22
    }

    i = i % 0x10;
    if(i != 0)
    {
        if(i <= 0x8)
    1284:	00b01006 	adcseq	r1, r0, r6
        {
            debug_print(" ",0);
    1288:	0c040000 	stceq	0, cr0, [r4], {-0}
    128c:	00000aca 	andeq	r0, r0, sl, asr #21
        }
        while(i++ < 0x10)
    1290:	00b01106 	adcseq	r1, r0, r6, lsl #2
        {
            debug_print("   ",0);
    1294:	0c080000 	stceq	0, cr0, [r8], {-0}
    1298:	00000afa 	strdeq	r0, [r0], -sl
    129c:	00b01306 	adcseq	r1, r0, r6, lsl #6
    12a0:	0c0c0000 	stceq	0, cr0, [ip], {-0}
    12a4:	00000bb9 			; <UNDEFINED> instruction: 0x00000bb9
    12a8:	00b01406 	adcseq	r1, r0, r6, lsl #8
    12ac:	0c100000 	ldceq	0, cr0, [r0], {-0}
    }
    debug_print(" |%s|\n", cs);
}

void print_hash(unsigned char hash[])
{
    12b0:	00000bb0 			; <UNDEFINED> instruction: 0x00000bb0
   int idx;
   for (idx=0; idx < 32; idx++)
    12b4:	01551506 	cmpeq	r5, r6, lsl #10
      debug_print("%02x",hash[idx]);
    12b8:	00140000 	andseq	r0, r4, r0
    12bc:	0000a50d 	andeq	sl, r0, sp, lsl #10
}

void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
    12c0:	00016400 	andeq	r6, r1, r0, lsl #8
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12c4:	008c0e00 	addeq	r0, ip, r0, lsl #28
}
    12c8:	02000000 	andeq	r0, r0, #0
void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12cc:	00000b5a 	andeq	r0, r0, sl, asr fp
    12d0:	01001606 	tsteq	r0, r6, lsl #12
    12d4:	e70b0000 	str	r0, [fp, -r0]
}

#endif
void uartInit(void) {
    12d8:	1400000b 	strne	r0, [r0], #-11
    12dc:	01b81806 			; <UNDEFINED> instruction: 0x01b81806
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    12e0:	8c0c0000 	stchi	0, cr0, [ip], {-0}
    12e4:	0600000b 	streq	r0, [r0], -fp
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    12e8:	0001b819 	andeq	fp, r1, r9, lsl r8
    12ec:	cb0c0000 	blgt	3012f4 <_etext+0x2f9ce0>
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    12f0:	0600000b 	streq	r0, [r0], -fp
    12f4:	0000b01a 	andeq	fp, r0, sl, lsl r0
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    12f8:	250c0400 	strcs	r0, [ip, #-1024]	; 0x400
    12fc:	0600000c 	streq	r0, [r0], -ip
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1300:	00002520 	andeq	r2, r0, r0, lsr #10
    1304:	a90c0800 	stmdbge	ip, {fp}
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1308:	0600000b 	streq	r0, [r0], -fp
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    130c:	00003722 	andeq	r3, r0, r2, lsr #14
    1310:	360c0c00 	strcc	r0, [ip], -r0, lsl #24
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1314:	0600000b 	streq	r0, [r0], -fp
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1318:	00003723 	andeq	r3, r0, r3, lsr #14
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    131c:	05001000 	streq	r1, [r0, #-0]
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1320:	00016404 	andeq	r6, r1, r4, lsl #8
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1324:	0c070200 	sfmeq	f0, 4, [r7], {-0}
    1328:	27060000 	strcs	r0, [r6, -r0]
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    132c:	000001c9 	andeq	r0, r0, r9, asr #3
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    1330:	016f0405 	cmneq	pc, r5, lsl #8
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1334:	020f0000 	andeq	r0, pc, #0
    USART_InitStructure.USART_Parity = USART_Parity_No;
    1338:	0100000c 	tsteq	r0, ip
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    133c:	0000373d 	andeq	r3, r0, sp, lsr r7
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1340:	00103400 	andseq	r3, r0, r0, lsl #8
    1344:	00010400 	andeq	r0, r1, r0, lsl #8
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    1348:	c79c0100 	ldrgt	r0, [ip, r0, lsl #2]
        
    USART_Init(USART1, &USART_InitStructure);
    134c:	10000003 	andne	r0, r0, r3
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    1350:	00000bda 	ldrdeq	r0, [r0], -sl
    1354:	00f53f01 	rscseq	r3, r5, r1, lsl #30
}
    1358:	02460000 	subeq	r0, r6, #0
    135c:	3e110000 	cdpcc	0, 1, cr0, cr1, cr0, {0}

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    1360:	0100000b 	tsteq	r0, fp
    1364:	0000f540 	andeq	pc, r0, r0, asr #10
    1368:	18120000 	ldmdane	r2, {}	; <UNPREDICTABLE>
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    136c:	0100000b 	tsteq	r0, fp
    1370:	0001be51 	andeq	fp, r1, r1, asr lr
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    1374:	6c910200 	lfmvs	f0, 4, [r1], {0}
    1378:	74657213 	strbtvc	r7, [r5], #-531	; 0x213
    137c:	37530100 	ldrbcc	r0, [r3, -r0, lsl #2]
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    1380:	cc000000 	stcgt	0, cr0, [r0], {-0}
    1384:	10000002 	andne	r0, r0, r2
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    1388:	00000c19 	andeq	r0, r0, r9, lsl ip
    138c:	00377101 	eorseq	r7, r7, r1, lsl #2

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    1390:	02f70000 	rscseq	r0, r7, #0
    1394:	3c140000 	ldccc	0, cr0, [r4], {-0}
    1398:	d8000010 	stmdale	r0, {r4}
    139c:	14000003 	strne	r0, [r0], #-3
    13a0:	00001040 	andeq	r1, r0, r0, asr #32
    13a4:	000003e0 	andeq	r0, r0, r0, ror #7
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    13a8:	00104414 	andseq	r4, r0, r4, lsl r4
    13ac:	0003e800 	andeq	lr, r3, r0, lsl #16
    13b0:	10481400 	subne	r1, r8, r0, lsl #8
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    13b4:	03f00000 	mvnseq	r0, #0
    13b8:	4c140000 	ldcmi	0, cr0, [r4], {-0}

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    13bc:	f7000010 			; <UNDEFINED> instruction: 0xf7000010
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    13c0:	14000003 	strne	r0, [r0], #-3
    13c4:	00001050 	andeq	r1, r0, r0, asr r0
    13c8:	000003ff 	strdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    13cc:	00105414 	andseq	r5, r0, r4, lsl r4
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    13d0:	00040700 	andeq	r0, r4, r0, lsl #14
    13d4:	105a1500 	subsne	r1, sl, r0, lsl #10

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    13d8:	040e0000 	streq	r0, [lr], #-0
    13dc:	02850000 	addeq	r0, r5, #0
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    13e0:	01160000 	tsteq	r6, r0
    13e4:	b4030550 	strlt	r0, [r3], #-1360	; 0x550
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    13e8:	0000006f 	andeq	r0, r0, pc, rrx
    13ec:	00106215 	andseq	r6, r0, r5, lsl r2
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    13f0:	00042100 	andeq	r2, r4, r0, lsl #2
    13f4:	0002a100 	andeq	sl, r2, r0, lsl #2
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    13f8:	51011600 	tstpl	r1, r0, lsl #12
    13fc:	01163f01 	tsteq	r6, r1, lsl #30
    1400:	000c0550 	andeq	r0, ip, r0, asr r5
    1404:	0040010c 	subeq	r0, r0, ip, lsl #2

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    1408:	00106a15 	andseq	r6, r0, r5, lsl sl
    140c:	00040e00 	andeq	r0, r4, r0, lsl #28
    1410:	0002b800 	andeq	fp, r2, r0, lsl #16
    1414:	50011600 	andpl	r1, r1, r0, lsl #12
    1418:	6fc90305 	svcvs	0x00c90305
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    141c:	15000000 	strne	r0, [r0, #-0]
    1420:	00001074 	andeq	r1, r0, r4, ror r0
        u32 rwmVal = pRCC->CR;
    1424:	0000043c 	andeq	r0, r0, ip, lsr r4
        rwmVal |= 0x01;
    1428:	000002da 	ldrdeq	r0, [r0], -sl
        pRCC->CR = rwmVal;
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    142c:	01520116 	cmpeq	r2, r6, lsl r1
    1430:	51011630 	tstpl	r1, r0, lsr r6
}   
    1434:	80000c05 	andhi	r0, r0, r5, lsl #24
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    1438:	01160800 	tsteq	r6, r0, lsl #16
void setMspAndJump(u32 usrAddr) {
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    143c:	6c910250 	lfmvs	f0, 4, [r1], {80}	; 0x50
  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1440:	10801500 	addne	r1, r0, r0, lsl #10

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1444:	040e0000 	streq	r0, [lr], #-0
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    1448:	02f70000 	rscseq	r0, r7, #0
    144c:	01160000 	tsteq	r6, r0
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    1450:	02750251 	rsbseq	r0, r5, #268435461	; 0x10000005
    1454:	05500116 	ldrbeq	r0, [r0, #-278]	; 0x116
    1458:	006fdc03 	rsbeq	sp, pc, r3, lsl #24
    145c:	9c150000 	ldcls	0, cr0, [r5], {-0}
    tmppre = (0x4 - tmppriority);
    1460:	0e000010 	mcreq	0, 0, r0, cr0, cr0, {0}
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    1464:	0e000004 	cdpeq	0, 0, cr0, cr0, cr4, {0}


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    1468:	16000003 	strne	r0, [r0], -r3

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    146c:	03055001 	movweq	r5, #20481	; 0x5001
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    1470:	00006ff1 	strdeq	r6, [r0], -r1

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1474:	10ae1400 	adcne	r1, lr, r0, lsl #8
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    1478:	040e0000 	streq	r0, [lr], #-0
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    147c:	c2150000 	andsgt	r0, r5, #0

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1480:	61000010 	tstvs	r0, r0, lsl r0
    1484:	45000004 	strmi	r0, [r0, #-4]
    1488:	16000003 	strne	r0, [r0], -r3
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    148c:	44035301 	strmi	r5, [r3], #-769	; 0x301
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    1490:	0116243e 	tsteq	r6, lr, lsr r4
    tmppriority &= tmpmask;
    1494:	16350152 			; <UNDEFINED> instruction: 0x16350152
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    1498:	3d015101 	stfccs	f5, [r1, #-4]

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    149c:	05500116 	ldrbeq	r0, [r0, #-278]	; 0x116
    14a0:	0110000c 	tsteq	r0, ip
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    14a4:	7d021640 	stcvc	6, cr1, [r2, #-256]	; 0xffffff00
    14a8:	00300100 	eorseq	r0, r0, r0, lsl #2
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    14ac:	0010da15 	andseq	sp, r0, r5, lsl sl
    14b0:	00046100 	andeq	r6, r4, r0, lsl #2
    14b4:	00037300 	andeq	r7, r3, r0, lsl #6
    14b8:	53011600 	movwpl	r1, #5632	; 0x1600
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    14bc:	24404003 	strbcs	r4, [r0], #-3
    14c0:	01520116 	cmpeq	r2, r6, lsl r1
    14c4:	51011631 	tstpl	r1, r1, lsr r6
    rNVIC->ICER[1] = 0xFFFFFFFF;
    14c8:	01163d01 	tsteq	r6, r1, lsl #26
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    14cc:	000c0550 	andeq	r0, ip, r0, asr r5
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    14d0:	16400110 			; <UNDEFINED> instruction: 0x16400110

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    14d4:	01007d02 	tsteq	r0, r2, lsl #26
    14d8:	de140030 	mrcle	0, 0, r0, cr4, cr0, {1}
    14dc:	87000010 	smladhi	r0, r0, r0, r0

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    14e0:	15000004 	strne	r0, [r0, #-4]
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    14e4:	000010e6 	andeq	r1, r0, r6, ror #1
    nvicDisableInterrupts();
    14e8:	0000040e 	andeq	r0, r0, lr, lsl #8
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    14ec:	00000393 	muleq	r0, r3, r3
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    14f0:	05500116 	ldrbeq	r0, [r0, #-278]	; 0x116
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14f4:	00707103 	rsbseq	r7, r0, r3, lsl #2
}
    14f8:	ea140000 	b	501500 <_etext+0x4f9eec>
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14fc:	98000010 	stmdals	r0, {r4}

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1500:	15000004 	strne	r0, [r0, #-4]
    1504:	000010f8 	strdeq	r1, [r0], -r8

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    1508:	0000040e 	andeq	r0, r0, lr, lsl #8
    150c:	000003b3 			; <UNDEFINED> instruction: 0x000003b3
    1510:	05500116 	ldrbeq	r0, [r0, #-278]	; 0x116
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1514:	00708603 	rsbseq	r8, r0, r3, lsl #12
    1518:	fe170000 	cdp2	0, 1, cr0, cr7, cr0, {0}
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    151c:	a5000010 	strge	r0, [r0, #-16]

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1520:	16000004 	strne	r0, [r0], -r4
    1524:	0c055001 	stceq	0, cr5, [r5], {1}
    1528:	08008084 	stmdaeq	r0, {r2, r7, pc}
    SET_REG(FLASH_AR, pageAddr);
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    152c:	b1180000 	tstlt	r8, r0
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1530:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    1534:	0000372c 	andeq	r3, r0, ip, lsr #14

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    1538:	88030500 	stmdahi	r3, {r8, sl}

    return TRUE;
}
    153c:	19200004 	stmdbne	r0!, {r2}
    1540:	00000b9d 	muleq	r0, sp, fp
    1544:	19012c07 	stmdbne	r1, {r0, r1, r2, sl, fp, sp}
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    1548:	00000bd1 	ldrdeq	r0, [r0], -r1
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    154c:	19012d07 	stmdbne	r1, {r0, r1, r2, r8, sl, fp, sp}
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    1550:	00000b24 	andeq	r0, r0, r4, lsr #22

    u32 rwmVal = GET_REG(FLASH_CR);
    SET_REG(FLASH_CR, FLASH_CR_PG);
    1554:	1a012e07 	bne	4cd78 <_etext+0x45764>
    1558:	000007d2 	ldrdeq	r0, [r0], -r2

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    155c:	c0195108 	andsgt	r5, r9, r8, lsl #2
    1560:	0700000b 	streq	r0, [r0, -fp]
    *(flashAddr + 0x01) = (vu16)hhWord;
    1564:	4819012f 	ldmdami	r9, {r0, r1, r2, r3, r5, r8}
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1568:	0700000b 	streq	r0, [r0, -fp]
    156c:	b51a012a 	ldrlt	r0, [sl, #-298]	; 0x12a
    *(flashAddr) = (vu16)lhWord;
    1570:	08000004 	stmdaeq	r0, {r2}
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1574:	0ab31b5d 	beq	fecc82f0 <BootRAM+0xdc38a91>
    1578:	3f070000 	svccc	0x00070000

    rwmVal &= 0xFFFFFFFE;
    157c:	00042101 	andeq	r2, r4, r1, lsl #2
    SET_REG(FLASH_CR, rwmVal);

    /* verify the write */
    if (*(vu32 *)addr != word) {
    1580:	009a1c00 	addseq	r1, sl, r0, lsl #24
        return FALSE;
    }

    return TRUE;
}
    1584:	001d0000 	andseq	r0, sp, r0
    1588:	000aab1e 	andeq	sl, sl, lr, lsl fp
    158c:	01270700 	teqeq	r7, r0, lsl #14
    1590:	000000f5 	strdeq	r0, [r0], -r5

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    1594:	0000043c 	andeq	r0, r0, ip, lsr r4
    1598:	0000bb1c 	andeq	fp, r0, ip, lsl fp
    159c:	00c61c00 	sbceq	r1, r6, r0, lsl #24
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    15a0:	1f000000 	svcne	0x00000000
    15a4:	00000b6c 	andeq	r0, r0, ip, ror #22
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    15a8:	00376706 	eorseq	r6, r7, r6, lsl #14
    15ac:	045b0000 	ldrbeq	r0, [fp], #-0
    15b0:	5b1c0000 	blpl	7015b8 <_etext+0x6f9fa4>
    15b4:	1c000004 	stcne	0, cr0, [r0], {4}

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    15b8:	000000d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
	{
		pin-=8;
    15bc:	0000f51c 	andeq	pc, r0, ip, lsl r5	; <UNPREDICTABLE>
	}
	mask = 0x0F << (pin<<2);
    15c0:	04050000 	streq	r0, [r5], #-0
    15c4:	000001be 			; <UNDEFINED> instruction: 0x000001be
	return ~mask;
}	
    15c8:	000b821b 	andeq	r8, fp, fp, lsl r2

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    15cc:	01280700 	teqeq	r8, r0, lsl #14
    15d0:	00000487 	andeq	r0, r0, r7, lsl #9
}
    15d4:	0000bb1c 	andeq	fp, r0, ip, lsl fp
    15d8:	00c61c00 	sbceq	r1, r6, r0, lsl #24

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    15dc:	c61c0000 	ldrgt	r0, [ip], -r0
	{
		return 0x800;
    15e0:	1c000000 	stcne	0, cr0, [r0], {-0}
	}
	else
	{
		return 0x400;
	}
}
    15e4:	000000bb 	strheq	r0, [r0], -fp
    15e8:	0000c61c 	andeq	ip, r0, ip, lsl r6
    15ec:	2f200000 	svccs	0x00200000
    15f0:	0900000c 	stmdbeq	r0, {r2, r3}

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15f4:	0000f57c 	andeq	pc, r0, ip, ror r5	; <UNPREDICTABLE>
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    15f8:	00049800 	andeq	r9, r4, r0, lsl #16

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15fc:	21001d00 	tstcs	r0, r0, lsl #26
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1600:	00000aea 	andeq	r0, r0, sl, ror #21
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    1604:	04a57e09 	strteq	r7, [r5], #3593	; 0xe09
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    1608:	001d0000 	andseq	r0, sp, r0
    160c:	000b9222 	andeq	r9, fp, r2, lsr #4
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1610:	01300700 	teqeq	r0, r0, lsl #14
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1614:	0000bb1c 	andeq	fp, r0, ip, lsl fp
    userAppEnd = RAM_END;
    1618:	79000000 	stmdbvc	r0, {}	; <UNPREDICTABLE>
    161c:	04000012 	streq	r0, [r0], #-18
    userUploadType=DFU_UPLOAD_NONE;
    1620:	00066a00 	andeq	r6, r6, r0, lsl #20
    1624:	39010400 	stmdbcc	r1, {sl}
    code_copy_lock = WAIT;
    1628:	01000006 	tsteq	r0, r6
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    162c:	00000ce0 	andeq	r0, r0, r0, ror #25
    1630:	00000893 	muleq	r0, r3, r8
    1634:	00000140 	andeq	r0, r0, r0, asr #2
    memset(input, 0xFF, sizeof(input));
    1638:	00000000 	andeq	r0, r0, r0
    163c:	0000071c 	andeq	r0, r0, ip, lsl r7

    sha256_starts(&ctx);
}
    1640:	000ae302 	andeq	lr, sl, r2, lsl #6
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1644:	30d40200 	sbcscc	r0, r4, r0, lsl #4
    1648:	03000000 	movweq	r0, #0
    164c:	02570704 	subseq	r0, r7, #4, 14	; 0x100000
    1650:	d9020000 	stmdble	r2, {}	; <UNPREDICTABLE>
    1654:	0300000d 	movweq	r0, #13
    1658:	00004228 	andeq	r4, r0, r8, lsr #4
    165c:	10610400 	rsbne	r0, r1, r0, lsl #8
    1660:	08040000 	stmdaeq	r4, {}	; <UNPREDICTABLE>
    1664:	00005900 	andeq	r5, r0, r0, lsl #18
    1668:	0edd0500 	cdpeq	5, 13, cr0, cr13, cr0, {0}
    166c:	00590000 	subseq	r0, r9, r0
    1670:	00000000 	andeq	r0, r0, r0
    1674:	04070406 	streq	r0, [r7], #-1030	; 0x406
    1678:	746e6905 	strbtvc	r6, [lr], #-2309	; 0x905
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    167c:	06010300 	streq	r0, [r1], -r0, lsl #6
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    1680:	0000081a 	andeq	r0, r0, sl, lsl r8
    1684:	000ad902 	andeq	sp, sl, r2, lsl #18

    if (startState == appDETACH) {
    1688:	741c0400 	ldrvc	r0, [ip], #-1024	; 0x400
    168c:	03000000 	movweq	r0, #0
        dfuAppStatus.bState = dfuIDLE;
    1690:	08180801 	ldmdaeq	r8, {r0, fp}
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
    1694:	02030000 	andeq	r0, r3, #0
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1698:	0006fc05 	andeq	pc, r6, r5, lsl #24
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    169c:	0da10200 	sfmeq	f0, 4, [r1]
    } else if (startState == appIDLE || startState == dfuIDLE) {
    16a0:	26040000 	strcs	r0, [r4], -r0
    16a4:	0000008d 	andeq	r0, r0, sp, lsl #1
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    16a8:	49070203 	stmdbmi	r7, {r0, r1, r9}
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    16ac:	03000009 	movweq	r0, #9
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    16b0:	04da0504 	ldrbeq	r0, [sl], #1284	; 0x504
    16b4:	bf020000 	svclt	0x00020000
    16b8:	0400000a 	streq	r0, [r0], #-10
    16bc:	0000a638 	andeq	sl, r0, r8, lsr r6

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    16c0:	07040300 	streq	r0, [r4, -r0, lsl #6]
        pInformation->Ctrl_Info.Usb_wLength = 1;
    16c4:	00000252 	andeq	r0, r0, r2, asr r2
    16c8:	d5050803 	strle	r0, [r5, #-2051]	; 0x803
        return NULL;
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    16cc:	03000004 	movweq	r0, #4
    }
}
    16d0:	024d0708 	subeq	r0, sp, #8, 14	; 0x200000
    16d4:	04030000 	streq	r0, [r3], #-0

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    16d8:	00078b07 	andeq	r8, r7, r7, lsl #22
        pInformation->Ctrl_Info.Usb_wLength = 6;
    16dc:	c8040800 	stmdagt	r4, {fp}
    16e0:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
        return NULL;
    } else {
        return (u8*)(&dfuAppStatus);
    16e4:	00740408 	rsbseq	r0, r4, r8, lsl #8
    }
}
    16e8:	04080000 	streq	r0, [r8], #-0
    16ec:	000000d5 	ldrdeq	r0, [r0], -r5


u8 *dfuCopyDNLOAD(u16 length) {
    16f0:	21080103 	tstcs	r8, r3, lsl #2
    if (length == 0) {
    16f4:	08000008 	stmdaeq	r0, {r3}
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    16f8:	0000e204 	andeq	lr, r0, r4, lsl #4
    16fc:	00d50a00 	sbcseq	r0, r5, r0, lsl #20
        thisBlockLen = pInformation->USBwLengths.w;
    1700:	db020000 	blle	81708 <_etext+0x7a0f4>
        return NULL;
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1704:	0500000a 	streq	r0, [r0, #-10]
    1708:	0000692a 	andeq	r6, r0, sl, lsr #18
    }
}
    170c:	0da30200 	sfmeq	f0, 4, [r3]
    1710:	36050000 	strcc	r0, [r5], -r0
    1714:	00000082 	andeq	r0, r0, r2, lsl #1

u8 *dfuCopyUPLOAD(u16 length) {
    1718:	000ac102 	andeq	ip, sl, r2, lsl #2
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    171c:	9b420500 	blls	1082b24 <_etext+0x107b510>
    1720:	02000000 	andeq	r0, r0, #0
    1724:	00001063 	andeq	r1, r0, r3, rrx
        return NULL;
    1728:	00376203 	eorseq	r6, r7, r3, lsl #4
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    172c:	750b0000 	strvc	r0, [fp, #-0]
    1730:	06003233 			; <UNDEFINED> instruction: 0x06003233
    1734:	0000a627 	andeq	sl, r0, r7, lsr #12
    1738:	31750b00 	cmncc	r5, r0, lsl #22
    }
}
    173c:	28060036 	stmdacs	r6, {r1, r2, r4, r5}
    1740:	0000008d 	andeq	r0, r0, sp, lsl #1
    1744:	0038750b 	eorseq	r7, r8, fp, lsl #10
    1748:	00742906 	rsbseq	r2, r4, r6, lsl #18

void dfuCopyBufferToExec() {
    174c:	5a020000 	bpl	81754 <_etext+0x7a140>
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    1750:	06000003 	streq	r0, [r0], -r3
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    1754:	00013e2f 	andeq	r3, r1, pc, lsr #28
    1758:	00a60c00 	adceq	r0, r6, r0, lsl #24
    175c:	e3020000 	movw	r0, #8192	; 0x2000
    1760:	06000001 	streq	r0, [r0], -r1
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    1764:	00014e30 	andeq	r4, r1, r0, lsr lr
	}

    flashErasePage((u32)(userSpace));
    1768:	008d0c00 	addeq	r0, sp, r0, lsl #24

    for (i = 0; i < thisBlockLen; i = i + 4) {
    176c:	20020000 	andcs	r0, r2, r0
    1770:	06000011 			; <UNDEFINED> instruction: 0x06000011
    1774:	00015e33 	andeq	r5, r1, r3, lsr lr
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    1778:	013e0a00 	teqeq	lr, r0, lsl #20
    177c:	010d0000 	mrseq	r0, (UNDEF: 13)
    1780:	01783706 	cmneq	r8, r6, lsl #14
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    1784:	530e0000 	movwpl	r0, #57344	; 0xe000
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    1788:	00000007 	andeq	r0, r0, r7
    178c:	0001a70e 	andeq	sl, r1, lr, lsl #14
    thisBlockLen = 0;
    1790:	02000100 	andeq	r0, r0, #0, 2
    1794:	0000052d 	andeq	r0, r0, sp, lsr #10
    1798:	01633706 	cmneq	r3, r6, lsl #14
    179c:	010d0000 	mrseq	r0, (UNDEF: 13)
    17a0:	01983b06 	orrseq	r3, r8, r6, lsl #22
    17a4:	540e0000 	strpl	r0, [lr], #-0
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    17a8:	0000000e 	andeq	r0, r0, lr
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    17ac:	00106b0e 	andseq	r6, r0, lr, lsl #22
    17b0:	02000100 	andeq	r0, r0, #0, 2

    u8 startState = dfuAppStatus.bState;
    17b4:	00000c88 	andeq	r0, r0, r8, lsl #25
    17b8:	01833b06 	orreq	r3, r3, r6, lsl #22
    dfuAppStatus.bStatus = OK;
    17bc:	280f0000 	stmdacs	pc, {}	; <UNPREDICTABLE>
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    17c0:	02239207 	eoreq	r9, r3, #1879048192	; 0x70000000

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17c4:	43100000 	tstmi	r0, #0
    17c8:	93070052 	movwls	r0, #28754	; 0x7052
            if (pInformation->USBwLengths.w > 0) {
    17cc:	00000133 	andeq	r0, r0, r3, lsr r1
    17d0:	07591100 	ldrbeq	r1, [r9, -r0, lsl #2]
                userFirmwareLen = 0;
    17d4:	94070000 	strls	r0, [r7], #-0
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    17d8:	00000133 	andeq	r0, r0, r3, lsr r1
    17dc:	49431004 	stmdbmi	r3, {r2, ip}^
    17e0:	95070052 	strls	r0, [r7, #-82]	; 0x52
    17e4:	00000133 	andeq	r0, r0, r3, lsr r1
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    17e8:	002a1108 	eoreq	r1, sl, r8, lsl #2
						userAppAddr = USER_CODE_FLASH0X8002000;
    17ec:	96070000 	strls	r0, [r7], -r0
    17f0:	00000133 	andeq	r0, r0, r3, lsr r1
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    17f4:	0e0d110c 	adfeqe	f1, f5, #4.0
    17f8:	97070000 	strls	r0, [r7, -r0]
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    17fc:	00000133 	andeq	r0, r0, r3, lsr r1
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1800:	04451110 	strbeq	r1, [r5], #-272	; 0x110
						flashUnlock();
    1804:	98070000 	stmdals	r7, {}	; <UNPREDICTABLE>

						break;
    1808:	00000133 	andeq	r0, r0, r3, lsr r1

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    180c:	05ef1114 	strbeq	r1, [pc, #276]!	; 1928 <dfuUpdateByRequest+0x180>
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1810:	99070000 	stmdbls	r7, {}	; <UNPREDICTABLE>
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1814:	00000133 	andeq	r0, r0, r3, lsr r1
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    1818:	00001118 	andeq	r1, r0, r8, lsl r1
    181c:	9a070000 	bls	1c1824 <_etext+0x1ba210>
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    1820:	00000133 	andeq	r0, r0, r3, lsr r1
    1824:	061e111c 			; <UNDEFINED> instruction: 0x061e111c
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1828:	9b070000 	blls	1c1830 <_etext+0x1ba21c>
    182c:	00000133 	andeq	r0, r0, r3, lsr r1
    1830:	53431020 	movtpl	r1, #12320	; 0x3020
			
            switch(pInformation->Current_AlternateSetting) {
    1834:	9c070052 	stcls	0, cr0, [r7], {82}	; 0x52
    1838:	00000133 	andeq	r0, r0, r3, lsr r1
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    183c:	1d020024 	stcne	0, cr0, [r2, #-144]	; 0xffffff70
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1840:	0700000f 	streq	r0, [r0, -pc]
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1844:	0001a39d 	muleq	r1, sp, r3
					userAppEnd = getFlashEnd();
    1848:	033c1200 	teqeq	ip, #0, 4
    184c:	02c3a007 	sbceq	sl, r3, #7

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    1850:	55110000 	ldrpl	r0, [r1, #-0]
					dfuAppStatus.bStatus = errWRITE;
    1854:	0700000d 	streq	r0, [r0, -sp]
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    1858:	0002d3a1 	andeq	sp, r2, r1, lsr #7
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    185c:	7c110000 	ldcvc	0, cr0, [r1], {-0}
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1860:	0700000f 	streq	r0, [r0, -pc]
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    1864:	0002d8a2 	andeq	sp, r2, r2, lsr #17
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1868:	ff110800 			; <UNDEFINED> instruction: 0xff110800
    186c:	07000010 	smladeq	r0, r0, r0, r0
    1870:	0002e8a3 	andeq	lr, r2, r3, lsr #17

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    1874:	5a118000 	bpl	46187c <_etext+0x45a268>
                dfuCopyBufferToExec();
    1878:	0700000d 	streq	r0, [r0, -sp]
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    187c:	0002d8a4 	andeq	sp, r2, r4, lsr #17
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    1880:	6a138800 	bvs	4e3888 <_etext+0x4dc274>
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    1884:	07000011 	smladeq	r0, r1, r0, r0
    1888:	0002eda5 	andeq	lr, r2, r5, lsr #27

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    188c:	13010000 	movwne	r0, #4096	; 0x1000
    1890:	00000f90 	muleq	r0, r0, pc	; <UNPREDICTABLE>
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    1894:	02d8a607 	sbcseq	sl, r8, #7340032	; 0x700000
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    1898:	01080000 	mrseq	r0, (UNDEF: 8)
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    189c:	000f1813 	andeq	r1, pc, r3, lsl r8	; <UNPREDICTABLE>
    18a0:	f2a70700 	vabdl.s32	q0, d7, d0
    18a4:	80000002 	andhi	r0, r0, r2
            if (pInformation->USBwLengths.w > 0) {
    18a8:	0f9a1301 	svceq	0x009a1301
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    18ac:	a8070000 	stmdage	r7, {}	; <UNPREDICTABLE>
                }*/
                ImageObjectHandle imageHandle;
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    18b0:	000002d8 	ldrdeq	r0, [r0], -r8
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    18b4:	1b130188 	blne	4c1edc <_etext+0x4ba8c8>
                }*/
                ImageObjectHandle imageHandle;
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    18b8:	07000011 	smladeq	r0, r1, r0, r0
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
                }
                switch (ret)
    18bc:	0002f7a9 	andeq	pc, r2, r9, lsr #15
    18c0:	13020000 	movwne	r0, #8192	; 0x2000
    18c4:	00000fa4 	andeq	r0, r0, r4, lsr #31
                {
                    case kImageImageIsTrusted:
                        uart_printf("Uploaded signature verified!\n");
    18c8:	02fcaa07 	rscseq	sl, ip, #28672	; 0x7000
                        break;

                    case kImageImageMissingMagic:
                    case kImageImageRejectSignature:
                        uart_printf("Image unverified... wiped memory for clean reset.\n");
    18cc:	02080000 	andeq	r0, r8, #0
    18d0:	52504914 	subspl	r4, r0, #20, 18	; 0x50000
                        break;

                    default:
                        break;
                }
                flashLock();
    18d4:	1cab0700 	stcne	7, cr0, [fp]
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    18d8:	00000003 	andeq	r0, r0, r3
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18dc:	33150003 	tstcc	r5, #3
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18e0:	d3000001 	movwle	r0, #1
    18e4:	16000002 	strne	r0, [r0], -r2
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuMANIFEST_SYNC) {
    18e8:	000000bb 	strheq	r0, [r0], -fp
        /* device has received last block, waiting DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18ec:	c30c0001 	movwgt	r0, #49153	; 0xc001
    18f0:	15000002 	strne	r0, [r0, #-2]
            dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    18f4:	00000113 	andeq	r0, r0, r3, lsl r1
            dfuAppStatus.bStatus = OK;
    18f8:	000002e8 	andeq	r0, r0, r8, ror #5
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18fc:	0000bb16 	andeq	fp, r0, r6, lsl fp
    1900:	0c001d00 	stceq	13, cr1, [r0], {-0}
            dfuAppStatus.bState  = dfuMANIFEST_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuMANIFEST) {
    1904:	000002c3 	andeq	r0, r0, r3, asr #5
        /* device is in manifestation phase */

        /* should never receive request while in manifest! */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
        dfuAppStatus.bStatus = OK;
    } else if (startState == dfuMANIFEST_WAIT_RESET) {
    1908:	0002c30c 	andeq	ip, r2, ip, lsl #6
        /* device has programmed new firmware but needs external
           usb reset or power on reset to run the new code */

        /* consider timing out and self-resetting */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    } else if (startState == dfuUPLOAD_IDLE) {
    190c:	02c30c00 	sbceq	r0, r3, #0, 24
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
    1910:	c30c0000 	movwgt	r0, #49152	; 0xc000
    1914:	15000002 	strne	r0, [r0, #-2]
            if (pInformation->USBwLengths.w > 0) {
    1918:	00000113 	andeq	r0, r0, r3, lsl r1
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    191c:	0000030c 	andeq	r0, r0, ip, lsl #6
    1920:	0000bb16 	andeq	fp, r0, r6, lsl fp
    1924:	15003d00 	strne	r3, [r0, #-3328]	; 0xd00
    1928:	00000133 	andeq	r0, r0, r3, lsr r1
    192c:	0000031c 	andeq	r0, r0, ip, lsl r3
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1930:	0000bb16 	andeq	fp, r0, r6, lsl fp
    1934:	0c000e00 	stceq	14, cr0, [r0], {-0}
    1938:	0000030c 	andeq	r0, r0, ip, lsl #6
    193c:	00104d02 	andseq	r4, r0, r2, lsl #26
    1940:	2eac0700 	cdpcs	7, 10, cr0, cr12, cr0, {0}
    1944:	0f000002 	svceq	0x00000002
                    thisBlockLen = uploadBlockLen;
    1948:	65ae0704 	strvs	r0, [lr, #1796]!	; 0x704
    194c:	11000003 	tstne	r0, r3
                    dfuAppStatus.bState  = dfuUPLOAD_IDLE;
                } else {
                    /* if above comparison was just equal, thisBlockLen becomes zero
                    next time when USBWValue has been increased by one */
                    thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
    1950:	000005b6 			; <UNDEFINED> instruction: 0x000005b6
    1954:	0129af07 	teqeq	r9, r7, lsl #30
    1958:	11000000 	mrsne	r0, (UNDEF: 0)
    195c:	00000970 	andeq	r0, r0, r0, ror r9
                    
                    /* check for overflow due to USBwValue out of range */
                    if (thisBlockLen >= pInformation->USBwLengths.w) {
    1960:	0129b007 	teqeq	r9, r7
    1964:	11010000 	mrsne	r0, (UNDEF: 1)
                        thisBlockLen = 0;
    1968:	000008dd 	ldrdeq	r0, [r0], -sp
                    }
                    
                    dfuAppStatus.bState  = dfuIDLE;
                }
            } else {
                dfuAppStatus.bState  = dfuERROR;
    196c:	0129b107 	teqeq	r9, r7, lsl #2
                dfuAppStatus.bStatus = errNOTDONE;
    1970:	11020000 	mrsne	r0, (UNDEF: 2)
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    1974:	00000396 	muleq	r0, r6, r3
            dfuAppStatus.bState  = dfuIDLE;
    1978:	0178b207 	cmneq	r8, r7, lsl #4
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    197c:	00030000 	andeq	r0, r3, r0
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1980:	0001f502 	andeq	pc, r1, r2, lsl #10
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1984:	2cb30700 	ldccs	7, cr0, [r3]
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuERROR)               {
    1988:	0f000003 	svceq	0x00000003
        /* status is in error, awaiting DFU_CLRSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    198c:	21b50740 			; <UNDEFINED> instruction: 0x21b50740
    1990:	11000004 	tstne	r0, r4
    1994:	00000de8 	andeq	r0, r0, r8, ror #27
            /* todo, add routine to wait for last block write to finish */
            dfuAppStatus.bState  = dfuERROR;
    1998:	0153b607 	cmpeq	r3, r7, lsl #12
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    199c:	11000000 	mrsne	r0, (UNDEF: 0)
            dfuAppStatus.bState  = dfuERROR;
        } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
    19a0:	00001072 	andeq	r1, r0, r2, ror r0
            /* todo handle any cleanup we need here */
            dfuAppStatus.bState  = dfuIDLE;
    19a4:	0133b707 	teqeq	r3, r7, lsl #14
            dfuAppStatus.bStatus = OK;
    19a8:	11040000 	mrsne	r0, (UNDEF: 4)
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else {
        /* some kind of error... */
        dfuAppStatus.bState  = dfuERROR;
    19ac:	00001037 	andeq	r1, r0, r7, lsr r0
        dfuAppStatus.bStatus = errSTALLEDPKT;
    19b0:	0133b807 	teqeq	r3, r7, lsl #16
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}
    19b4:	11080000 	mrsne	r0, (UNDEF: 8)
    19b8:	00000e5c 	andeq	r0, r0, ip, asr lr
    19bc:	0133b907 	teqeq	r3, r7, lsl #18
    19c0:	100c0000 	andne	r0, ip, r0
    19c4:	00524353 	subseq	r4, r2, r3, asr r3
    19c8:	0133ba07 	teqeq	r3, r7, lsl #20
    19cc:	10100000 	andsne	r0, r0, r0
    19d0:	00524343 	subseq	r4, r2, r3, asr #6
    19d4:	0133bb07 	teqeq	r3, r7, lsl #22
    19d8:	11140000 	tstne	r4, r0
    19dc:	00000df5 	strdeq	r0, [r0], -r5
    19e0:	0431bc07 	ldrteq	fp, [r1], #-3079	; 0xc07
    19e4:	11180000 	tstne	r8, r0
    19e8:	00000eab 	andeq	r0, r0, fp, lsr #29
    19ec:	0133bd07 	teqeq	r3, r7, lsl #26
    19f0:	11240000 	teqne	r4, r0
    19f4:	00000ecb 	andeq	r0, r0, fp, asr #29
    19f8:	0133be07 	teqeq	r3, r7, lsl #28
    dfuAppStatus.bState = newState;
}

bool dfuUploadStarted()
{
    return dfuBusy;
    19fc:	11280000 	teqne	r8, r0
}
    1a00:	00000e16 	andeq	r0, r0, r6, lsl lr
    1a04:	0133bf07 	teqeq	r3, r7, lsl #30

void dfuFinishUpload() {

    while (1)
	{
		__asm__ __volatile__ ("");
    1a08:	112c0000 	teqne	ip, r0
};

/* Conversion to and from projective coordinates */
void ed25519_project(struct ed25519_pt *p,
		     const uint8_t *x, const uint8_t *y)
{
    1a0c:	00000cb4 			; <UNDEFINED> instruction: 0x00000cb4
    1a10:	0133c007 	teqeq	r3, r7
    1a14:	11300000 	teqne	r0, r0
    1a18:	00000f68 	andeq	r0, r0, r8, ror #30
    1a1c:	0133c107 	teqeq	r3, r7, lsl #2
    1a20:	11340000 	teqne	r4, r0
    1a24:	00001025 	andeq	r1, r0, r5, lsr #32
    1a28:	0133c207 	teqeq	r3, r7, lsl #4
    1a2c:	11380000 	teqne	r8, r0
    1a30:	00000dfa 	strdeq	r0, [r0], -sl
    1a34:	0133c307 	teqeq	r3, r7, lsl #6
    1a38:	003c0000 	eorseq	r0, ip, r0
    1a3c:	00013315 	andeq	r3, r1, r5, lsl r3
    1a40:	00043100 	andeq	r3, r4, r0, lsl #2
    1a44:	00bb1600 	adcseq	r1, fp, r0, lsl #12
    1a48:	00020000 	andeq	r0, r2, r0
    1a4c:	0004210c 	andeq	r2, r4, ip, lsl #2
    1a50:	107c0200 	rsbsne	r0, ip, r0, lsl #4
    1a54:	c4070000 	strgt	r0, [r7], #-0
    1a58:	00000370 	andeq	r0, r0, r0, ror r3
    1a5c:	c6071c0f 	strgt	r1, [r7], -pc, lsl #24
    1a60:	000004f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    1a64:	00525310 	subseq	r5, r2, r0, lsl r3
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
    1a68:	04f0c807 	ldrbteq	ip, [r0], #2055	; 0x807
	f25519_mul__distinct(p->t, x, y);
    1a6c:	11000000 	mrsne	r0, (UNDEF: 0)
    1a70:	00000f7c 	andeq	r0, r0, ip, ror pc
}
    1a74:	00f2c907 	rscseq	ip, r2, r7, lsl #18
		     const uint8_t *x, const uint8_t *y)
{
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
	f25519_mul__distinct(p->t, x, y);
    1a78:	10020000 	andne	r0, r2, r0
}

void ed25519_unproject(uint8_t *x, uint8_t *y,
		       const struct ed25519_pt *p)
{
    1a7c:	07005244 	streq	r5, [r0, -r4, asr #4]
    1a80:	0004f0ca 	andeq	pc, r4, sl, asr #1
    1a84:	86110400 	ldrhi	r0, [r1], -r0, lsl #8
	uint8_t z1[F25519_SIZE];

	f25519_inv__distinct(z1, p->z);
    1a88:	0700000f 	streq	r0, [r0, -pc]
    1a8c:	0000f2cb 	andeq	pc, r0, fp, asr #5
	f25519_mul__distinct(x, p->x, z1);
    1a90:	42100600 	andsmi	r0, r0, #0, 12
    1a94:	07005252 	smlsdeq	r0, r2, r2, r5
    1a98:	0004f0cc 	andeq	pc, r4, ip, asr #1
	f25519_mul__distinct(y, p->y, z1);
    1a9c:	90110800 	andsls	r0, r1, r0, lsl #16
    1aa0:	0700000f 	streq	r0, [r0, -pc]
    1aa4:	0000f2cd 	andeq	pc, r0, sp, asr #5

	f25519_normalize(x);
    1aa8:	43100a00 	tstmi	r0, #0, 20
	f25519_normalize(y);
    1aac:	07003152 	smlsdeq	r0, r2, r1, r3
    1ab0:	0004f0ce 	andeq	pc, r4, lr, asr #1
}
    1ab4:	9a110c00 	bls	444abc <_etext+0x43d4a8>
	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
};

void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y)
{
    1ab8:	0700000f 	streq	r0, [r0, -pc]
    1abc:	0000f2cf 	andeq	pc, r0, pc, asr #5
    1ac0:	43100e00 	tstmi	r0, #0, 28
    1ac4:	07003252 	smlsdeq	r0, r2, r2, r3
    1ac8:	0004f0d0 	ldrdeq	pc, [r4], -r0
    1acc:	a4111000 	ldrge	r1, [r1], #-0
    1ad0:	0700000f 	streq	r0, [r0, -pc]
    1ad4:	0000f2d1 	ldrdeq	pc, [r0], -r1
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
    1ad8:	43101200 	tstmi	r0, #0, 4
    1adc:	07003352 	smlsdeq	r0, r2, r3, r3
    1ae0:	0004f0d2 	ldrdeq	pc, [r4], -r2
    1ae4:	ae111400 	cfmulsge	mvf1, mvf1, mvf0
    1ae8:	0700000f 	streq	r0, [r0, -pc]
    1aec:	0000f2d3 	ldrdeq	pc, [r0], -r3
    1af0:	39111600 	ldmdbcc	r1, {r9, sl, ip}
    1af4:	0700000d 	streq	r0, [r0, -sp]
    1af8:	0004f0d4 	ldrdeq	pc, [r4], -r4
    1afc:	b8111800 	ldmdalt	r1, {fp, ip}
	parity = (tmp[0] & 1) << 7;
    1b00:	0700000f 	streq	r0, [r0, -pc]

	f25519_copy(c, y);
	f25519_normalize(c);
    1b04:	0000f2d5 	ldrdeq	pc, [r0], -r5
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1b08:	0c001a00 	stceq	10, cr1, [r0], {-0}
    1b0c:	000000f2 	strdeq	r0, [r0], -r2

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1b10:	000dff02 	andeq	pc, sp, r2, lsl #30
}
    1b14:	41d60700 	bicsmi	r0, r6, r0, lsl #14

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b18:	04000004 	streq	r0, [r0], #-4
    1b1c:	00000cfa 	strdeq	r0, [r0], -sl
    1b20:	24e70708 	strbtcs	r0, [r7], #1800	; 0x708
    1b24:	10000005 	andne	r0, r0, r5
	const int parity = comp[31] >> 7;
    1b28:	07005243 	streq	r5, [r0, -r3, asr #4]
    1b2c:	000133e8 	andeq	r3, r1, r8, ror #7
    1b30:	43100000 	tstmi	r0, #0
    1b34:	07005253 	smlsdeq	r0, r3, r2, r5
    1b38:	000133e9 	andeq	r3, r1, r9, ror #7
    1b3c:	04000400 	streq	r0, [r0], #-1024	; 0x400
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b40:	00000d74 	andeq	r0, r0, r4, ror sp
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1b44:	5df40738 	ldclpl	7, cr0, [r4, #224]!	; 0xe0
    1b48:	11000006 	tstne	r0, r6
    1b4c:	00000f86 	andeq	r0, r0, r6, lsl #31
    1b50:	065df507 	ldrbeq	pc, [sp], -r7, lsl #10	; <UNPREDICTABLE>
    1b54:	10000000 	andne	r0, r0, r0
	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
	f25519_add(a, b, f25519_one);
    1b58:	00315244 	eorseq	r5, r1, r4, asr #4
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1b5c:	0143f607 	cmpeq	r3, r7, lsl #12

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
    1b60:	11040000 	mrsne	r0, (UNDEF: 4)
    1b64:	00000f90 	muleq	r0, r0, pc	; <UNPREDICTABLE>
	f25519_add(a, b, f25519_one);
    1b68:	0662f707 	strbteq	pc, [r2], -r7, lsl #14	; <UNPREDICTABLE>
    1b6c:	10060000 	andne	r0, r6, r0
    1b70:	00325244 	eorseq	r5, r2, r4, asr #4
	f25519_inv__distinct(b, a);
    1b74:	0143f807 	cmpeq	r3, r7, lsl #16
    1b78:	11080000 	mrsne	r0, (UNDEF: 8)

	/* Compute a = y^2-1 */
	f25519_sub(a, c, f25519_one);
    1b7c:	00000f9a 	muleq	r0, sl, pc	; <UNPREDICTABLE>
    1b80:	0662f907 	strbteq	pc, [r2], -r7, lsl #18	; <UNPREDICTABLE>

	/* Compute c = a*b = (y^2-1)/(1-dy^2) */
	f25519_mul__distinct(c, a, b);
    1b84:	100a0000 	andne	r0, sl, r0
    1b88:	00335244 	eorseq	r5, r3, r4, asr #4
    1b8c:	0143fa07 	cmpeq	r3, r7, lsl #20

	/* Compute a, b = +/-sqrt(c), if c is square */
	f25519_sqrt(a, c);
    1b90:	110c0000 	mrsne	r0, (UNDEF: 12)
    1b94:	00000fa4 	andeq	r0, r0, r4, lsr #31
	f25519_neg(b, a);
    1b98:	0662fb07 	strbteq	pc, [r2], -r7, lsl #22	; <UNPREDICTABLE>
    1b9c:	100e0000 	andne	r0, lr, r0

	/* Select one of them, based on the compressed parity bit */
	f25519_select(x, a, b, (a[0] ^ parity) & 1);
    1ba0:	00345244 	eorseq	r5, r4, r4, asr #4
    1ba4:	0143fc07 	cmpeq	r3, r7, lsl #24
    1ba8:	11100000 	tstne	r0, r0
    1bac:	00000fae 	andeq	r0, r0, lr, lsr #31
    1bb0:	0662fd07 	strbteq	pc, [r2], -r7, lsl #26	; <UNPREDICTABLE>

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
    1bb4:	10120000 	andsne	r0, r2, r0
    1bb8:	00355244 	eorseq	r5, r5, r4, asr #4
    1bbc:	0143fe07 	cmpeq	r3, r7, lsl #28
	f25519_normalize(a);
    1bc0:	11140000 	tstne	r4, r0
	f25519_normalize(c);
    1bc4:	00000fb8 			; <UNDEFINED> instruction: 0x00000fb8
    1bc8:	0662ff07 	strbteq	pc, [r2], -r7, lsl #30	; <UNPREDICTABLE>

	return f25519_eq(a, c);
    1bcc:	17160000 	ldrne	r0, [r6, -r0]
    1bd0:	00365244 	eorseq	r5, r6, r4, asr #4
}
    1bd4:	43010007 	movwmi	r0, #4103	; 0x1007
    1bd8:	18000001 	stmdane	r0, {r0}
    1bdc:	00118e18 	andseq	r8, r1, r8, lsl lr
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1be0:	01010700 	tsteq	r1, r0, lsl #14
    1be4:	00000662 	andeq	r0, r0, r2, ror #12
    1be8:	5244171a 	subpl	r1, r4, #6815744	; 0x680000
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bec:	02070037 	andeq	r0, r7, #55	; 0x37
    1bf0:	00014301 	andeq	r4, r1, r1, lsl #6
    1bf4:	c2181c00 	andsgt	r1, r8, #0, 24
	f25519_sub(d, p2->y, p2->x);
    1bf8:	0700000f 	streq	r0, [r0, -pc]
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bfc:	06620103 	strbteq	r0, [r2], -r3, lsl #2
	f25519_sub(d, p2->y, p2->x);
    1c00:	171e0000 	ldrne	r0, [lr, -r0]
    1c04:	00385244 	eorseq	r5, r8, r4, asr #4
	f25519_mul__distinct(a, c, d);
    1c08:	43010407 	movwmi	r0, #5127	; 0x1407
    1c0c:	20000001 	andcs	r0, r0, r1
    1c10:	000fcc18 	andeq	ip, pc, r8, lsl ip	; <UNPREDICTABLE>

	/* B = (Y1+X1)(Y2+X2) */
	f25519_add(c, p1->y, p1->x);
    1c14:	01050700 	tsteq	r5, r0, lsl #14
    1c18:	00000662 	andeq	r0, r0, r2, ror #12
	f25519_add(d, p2->y, p2->x);
    1c1c:	52441722 	subpl	r1, r4, #8912896	; 0x880000
    1c20:	06070039 			; <UNDEFINED> instruction: 0x06070039
    1c24:	00014301 	andeq	r4, r1, r1, lsl #6
	f25519_mul__distinct(b, c, d);
    1c28:	e9182400 	ldmdb	r8, {sl, sp}
    1c2c:	07000010 	smladeq	r0, r0, r0, r0

	/* C = T1 k T2 */
	f25519_mul__distinct(d, p1->t, p2->t);
    1c30:	06620107 	strbteq	r0, [r2], -r7, lsl #2
    1c34:	18260000 	stmdane	r6!, {}	; <UNPREDICTABLE>
    1c38:	00000f13 	andeq	r0, r0, r3, lsl pc
    1c3c:	43010807 	movwmi	r0, #6151	; 0x1807
	f25519_mul__distinct(c, d, ed25519_k);
    1c40:	28000001 	stmdacs	r0, {r0}
    1c44:	0010f418 	andseq	pc, r0, r8, lsl r4	; <UNPREDICTABLE>

	/* D = Z1 2 Z2 */
	f25519_mul__distinct(d, p1->z, p2->z);
    1c48:	01090700 	tsteq	r9, r0, lsl #14
    1c4c:	00000662 	andeq	r0, r0, r2, ror #12
    1c50:	113d182a 	teqne	sp, sl, lsr #16
    1c54:	0a070000 	beq	1c1c5c <_etext+0x1ba648>
	f25519_add(d, d, d);
    1c58:	00013301 	andeq	r3, r1, r1, lsl #6
    1c5c:	43172c00 	tstmi	r7, #0, 24

	/* E = B - A */
	f25519_sub(e, b, a);
    1c60:	0b070052 	bleq	1c1db0 <_etext+0x1ba79c>
    1c64:	00013301 	andeq	r3, r1, r1, lsl #6
    1c68:	43173000 	tstmi	r7, #0

	/* F = D - C */
	f25519_sub(f, d, c);
    1c6c:	07005253 	smlsdeq	r0, r3, r2, r5
    1c70:	0133010c 	teqeq	r3, ip, lsl #2

	/* G = D + C */
	f25519_add(g, d, c);
    1c74:	00340000 	eorseq	r0, r4, r0
    1c78:	0001130a 	andeq	r1, r1, sl, lsl #6
    1c7c:	011e0a00 	tsteq	lr, r0, lsl #20

	/* H = B + A */
	f25519_add(h, b, a);
    1c80:	45190000 	ldrmi	r0, [r9, #-0]
    1c84:	0c00000f 	stceq	0, cr0, [r0], {15}

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1c88:	a9011507 	stmdbge	r1, {r0, r1, r2, r8, sl, ip}
    1c8c:	18000006 	stmdane	r0, {r1, r2}
    1c90:	00001077 	andeq	r1, r0, r7, ror r0

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1c94:	f2011607 	vmax.s8	d1, d1, d7
    1c98:	00000000 	andeq	r0, r0, r0
    1c9c:	00101218 	andseq	r1, r0, r8, lsl r2

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1ca0:	01170700 	tsteq	r7, r0, lsl #14
    1ca4:	000000f2 	strdeq	r0, [r0], -r2
    1ca8:	10881802 	addne	r1, r8, r2, lsl #16

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1cac:	18070000 	stmdane	r7, {}	; <UNPREDICTABLE>
    1cb0:	0000fd01 	andeq	pc, r0, r1, lsl #26
    1cb4:	8d180400 	cfldrshi	mvf0, [r8, #-0]
}
    1cb8:	07000010 	smladeq	r0, r0, r0, r0
    1cbc:	00fd0119 	rscseq	r0, sp, r9, lsl r1

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1cc0:	00080000 	andeq	r0, r8, r0
    1cc4:	5f01100f 	svcpl	0x0001100f

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1cc8:	000006fa 	strdeq	r0, [r0], -sl
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1ccc:	000d4611 	andeq	r4, sp, r1, lsl r6
    1cd0:	fd610100 	stc2l	1, cr0, [r1, #-0]

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1cd4:	00000000 	andeq	r0, r0, r0
    1cd8:	000ccf11 	andeq	ip, ip, r1, lsl pc
    1cdc:	f2660100 	vrhadd.s32	d16, d6, d0

	/* C = 2 Z1^2 */
	f25519_mul__distinct(c, p->z, p->z);
    1ce0:	04000000 	streq	r0, [r0], #-0
    1ce4:	000ceb11 	andeq	lr, ip, r1, lsl fp
    1ce8:	f2690100 	vrhadd.s32	d16, d9, d0
	f25519_add(c, c, c);
    1cec:	06000000 	streq	r0, [r0], -r0
    1cf0:	000d9411 	andeq	r9, sp, r1, lsl r4

	/* D = a A (alter sign) */
	/* E = (X1+Y1)^2-A-B */
	f25519_add(f, p->x, p->y);
    1cf4:	f26c0100 	vrhadd.s32	d16, d12, d0
    1cf8:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    1cfc:	000e8911 	andeq	r8, lr, r1, lsl r9
	f25519_mul__distinct(e, f, f);
    1d00:	f2730100 	vrhadd.s<illegal width 64>	d16, d3, d0
    1d04:	0a000000 	beq	1d0c <ed25519_double+0x4c>
	f25519_sub(e, e, a);
    1d08:	000eb111 	andeq	fp, lr, r1, lsl r1
    1d0c:	f2760100 	vrhadd.s<illegal width 64>	d16, d6, d0
    1d10:	0c000000 	stceq	0, cr0, [r0], {-0}
	f25519_sub(e, e, b);
    1d14:	11090200 	mrsne	r0, R9_fiq
    1d18:	79010000 	stmdbvc	r1, {}	; <UNPREDICTABLE>

	/* G = D + B */
	f25519_sub(g, b, a);
    1d1c:	000006a9 	andeq	r0, r0, r9, lsr #13
    1d20:	9201010d 	andls	r0, r1, #1073741827	; 0x40000003
    1d24:	00000720 	andeq	r0, r0, r0, lsr #14

	/* F = G - C */
	f25519_sub(f, g, c);
    1d28:	000d630e 	andeq	r6, sp, lr, lsl #6
    1d2c:	290e0100 	stmdbcs	lr, {r8}

	/* H = D - B */
	f25519_neg(h, b);
    1d30:	0200000d 	andeq	r0, r0, #13
    1d34:	0010bd0e 	andseq	fp, r0, lr, lsl #26
	f25519_sub(h, h, a);
    1d38:	02000300 	andeq	r0, r0, #0, 6
    1d3c:	00001143 	andeq	r1, r0, r3, asr #2
    1d40:	07059601 	streq	r9, [r5, -r1, lsl #12]

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1d44:	010d0000 	mrseq	r0, (UNDEF: 13)
    1d48:	07659901 	strbeq	r9, [r5, -r1, lsl #18]!

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1d4c:	6e0e0000 	cdpvs	0, 0, cr0, cr14, cr0, {0}
    1d50:	0000000f 	andeq	r0, r0, pc
    1d54:	0011780e 	andseq	r7, r1, lr, lsl #16

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1d58:	b70e0400 	strlt	r0, [lr, -r0, lsl #8]
    1d5c:	2800000d 	stmdacs	r0, {r0, r2, r3}
    1d60:	000dcb0e 	andeq	ip, sp, lr, lsl #22

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1d64:	0e00c800 	cdpeq	8, 0, cr12, cr0, cr0, {0}
    1d68:	000010d8 	ldrdeq	r1, [r0], -r8
    1d6c:	0e3e0e14 	mrceq	14, 1, r0, cr14, cr4, {0}
}
    1d70:	0e100000 	cdpeq	0, 1, cr0, cr0, cr0, {0}

void ed25519_smult(struct ed25519_pt *r_out, const struct ed25519_pt *p,
		   const uint8_t *e)
{
    1d74:	00000f2b 	andeq	r0, r0, fp, lsr #30
    1d78:	0fd60e1c 	svceq	0x00d60e1c
    1d7c:	00180000 	andseq	r0, r8, r0
    1d80:	00103c02 	andseq	r3, r0, r2, lsl #24
    1d84:	2ba10100 	blcs	fe84218c <BootRAM+0xd7b292d>
    1d88:	0f000007 	svceq	0x00000007
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1d8c:	9da30104 	stflss	f0, [r3, #16]!
    1d90:	11000007 	tstne	r0, r7
    1d94:	00000c5e 	andeq	r0, r0, lr, asr ip
		struct ed25519_pt s;

		ed25519_double(&r, &r);
    1d98:	00f2a501 	rscseq	sl, r2, r1, lsl #10
    1d9c:	11000000 	mrsne	r0, (UNDEF: 0)
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1da0:	00000fe6 	andeq	r0, r0, r6, ror #31
		struct ed25519_pt s;

		ed25519_double(&r, &r);
		ed25519_add(&s, &r, p);
    1da4:	0720a801 	streq	sl, [r0, -r1, lsl #16]!
    1da8:	11020000 	mrsne	r0, (UNDEF: 2)

		f25519_select(r.x, r.x, s.x, bit);
    1dac:	00000c54 	andeq	r0, r0, r4, asr ip
    1db0:	0765ab01 	strbeq	sl, [r5, -r1, lsl #22]!
    1db4:	00030000 	andeq	r0, r3, r0
		f25519_select(r.y, r.y, s.y, bit);
    1db8:	00109202 	andseq	r9, r0, r2, lsl #4
    1dbc:	70ad0100 	adcvc	r0, sp, r0, lsl #2
    1dc0:	0f000007 	svceq	0x00000007
		f25519_select(r.z, r.z, s.z, bit);
    1dc4:	05af011c 	streq	r0, [pc, #284]!	; 1ee8 <edsign_verify+0xf0>
    1dc8:	10000008 	andne	r0, r0, r8
    1dcc:	004c5243 	subeq	r5, ip, r3, asr #4
		f25519_select(r.t, r.t, s.t, bit);
    1dd0:	0805b101 	stmdaeq	r5, {r0, r8, ip, sp, pc}
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1dd4:	10000000 	andne	r0, r0, r0
		ed25519_add(&s, &r, p);

		f25519_select(r.x, r.x, s.x, bit);
		f25519_select(r.y, r.y, s.y, bit);
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
    1dd8:	00485243 	subeq	r5, r8, r3, asr #4
    1ddc:	0805b201 	stmdaeq	r5, {r0, r9, ip, sp, pc}
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1de0:	10040000 	andne	r0, r4, r0
    1de4:	00524449 	subseq	r4, r2, r9, asr #8
    1de8:	0805b301 	stmdaeq	r5, {r0, r8, r9, ip, sp, pc}
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
	}

	ed25519_copy(r_out, &r);
}
    1dec:	10080000 	andne	r0, r8, r0
    1df0:	0052444f 	subseq	r4, r2, pc, asr #8
    1df4:	0805b401 	stmdaeq	r5, {r0, sl, ip, sp, pc}
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1df8:	110c0000 	mrsne	r0, (UNDEF: 12)
    1dfc:	00000c4f 	andeq	r0, r0, pc, asr #24
    1e00:	0805b501 	stmdaeq	r5, {r0, r8, sl, ip, sp, pc}
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e04:	10100000 	andsne	r0, r0, r0
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1e08:	00525242 	subseq	r5, r2, r2, asr #4
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e0c:	0805b601 	stmdaeq	r5, {r0, r9, sl, ip, sp, pc}
    1e10:	11140000 	tstne	r4, r0
    1e14:	000011ba 			; <UNDEFINED> instruction: 0x000011ba
    1e18:	0805b701 	stmdaeq	r5, {r0, r8, r9, sl, ip, sp, pc}
	memcpy(block + 32, a, 32);
    1e1c:	00180000 	andseq	r0, r8, r0
    1e20:	0000fd0c 	andeq	pc, r0, ip, lsl #26
    1e24:	102a0200 	eorne	r0, sl, r0, lsl #4
    1e28:	b8010000 	stmdalt	r1, {}	; <UNPREDICTABLE>
    1e2c:	000007a8 	andeq	r0, r0, r8, lsr #15
    1e30:	0007db1a 	andeq	sp, r7, sl, lsl fp
    1e34:	383a0100 	ldmdacc	sl!, {r8}
    1e38:	16000011 			; <UNDEFINED> instruction: 0x16000011
    1e3c:	01000000 	mrseq	r0, (UNDEF: 0)
    1e40:	0008569c 	muleq	r8, ip, r6
    1e44:	11551b00 	cmpne	r5, r0, lsl #22
    1e48:	3a010000 	bcc	41e50 <_etext+0x3a83c>
{
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
    1e4c:	00000113 	andeq	r0, r0, r3, lsl r1
    1e50:	701c5001 	andsvc	r5, ip, r1
    1e54:	01006e69 	tsteq	r0, r9, ror #28
		memcpy(init_block + prefix_size, message, len);
		sha512_final(&s, init_block, len + prefix_size);
	} else {
		size_t i;

		memcpy(init_block + prefix_size, message,
    1e58:	0001293a 	andeq	r2, r1, sl, lsr r9
    1e5c:	00033000 	andeq	r3, r3, r0
    1e60:	61761c00 	cmnvs	r6, r0, lsl #24
    1e64:	3a01006c 	bcc	4201c <_etext+0x3aa08>
    1e68:	00000129 	andeq	r0, r0, r9, lsr #2
    1e6c:	00000351 	andeq	r0, r0, r1, asr r3
    1e70:	0aab1d00 	beq	feac9278 <BootRAM+0xda39a19>
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);
    1e74:	3f010000 	svccc	0x00010000
    1e78:	00000178 	andeq	r0, r0, r8, ror r1

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e7c:	0000114e 	andeq	r1, r0, lr, asr #2
    1e80:	00000012 	andeq	r0, r0, r2, lsl r0
    1e84:	088e9c01 	stmeq	lr, {r0, sl, fp, ip, pc}
    1e88:	551e0000 	ldrpl	r0, [lr, #-0]
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1e8c:	01000011 	tsteq	r0, r1, lsl r0
		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
		     i + SHA512_BLOCK_SIZE <= len;
    1e90:	0001133f 	andeq	r1, r1, pc, lsr r3
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1e94:	00038700 	andeq	r8, r3, r0, lsl #14

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e98:	69701c00 	ldmdbvs	r0!, {sl, fp, ip}^
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
    1e9c:	3f01006e 	svccc	0x0001006e
    1ea0:	00000129 	andeq	r0, r0, r9, lsr #2
    1ea4:	000003a8 	andeq	r0, r0, r8, lsr #7
    1ea8:	0b821a00 	bleq	fe0886b0 <BootRAM+0xcff8e51>
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
		memcpy(init_block + prefix_size, message, len);
    1eac:	48010000 	stmdami	r1, {}	; <UNPREDICTABLE>
    1eb0:	00001160 	andeq	r1, r0, r0, ror #2
    1eb4:	00000050 	andeq	r0, r0, r0, asr r0
		sha512_final(&s, init_block, len + prefix_size);
    1eb8:	09579c01 	ldmdbeq	r7, {r0, sl, fp, ip, pc}^
    1ebc:	551e0000 	ldrpl	r0, [lr, #-0]
    1ec0:	01000011 	tsteq	r0, r1, lsl r0
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
	}

	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
    1ec4:	00011348 	andeq	r1, r1, r8, asr #6
    1ec8:	0003c900 	andeq	ip, r3, r0, lsl #18
    1ecc:	69701c00 	ldmdbvs	r0!, {sl, fp, ip}^
	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
    1ed0:	4801006e 	stmdami	r1, {r1, r2, r3, r5, r6}
    1ed4:	00000129 	andeq	r0, r0, r9, lsr #2
    1ed8:	000003e7 	andeq	r0, r0, r7, ror #7

static void sm_pack(uint8_t *r, const uint8_t *k)
{
	struct ed25519_pt p;

	ed25519_smult(&p, &ed25519_base, k);
    1edc:	000c1f1e 	andeq	r1, ip, lr, lsl pc
    1ee0:	29480100 	stmdbcs	r8, {r8}^
    1ee4:	08000001 	stmdaeq	r0, {r0}
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1ee8:	1e000004 	cdpne	0, 0, cr0, cr0, cr4, {0}
    1eec:	00000e4f 	andeq	r0, r0, pc, asr #28
	ed25519_pack(packed, x, y);
    1ef0:	01134801 	tsteq	r3, r1, lsl #16
    1ef4:	04500000 	ldrbeq	r0, [r0], #-0
    1ef8:	3e1b0000 	cdpcc	0, 1, cr0, cr11, cr0, {0}

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1efc:	0100000d 	tsteq	r0, sp
    1f00:	00012948 	andeq	r2, r1, r8, asr #18

	ed25519_project(p, x, y);
    1f04:	00910200 	addseq	r0, r1, r0, lsl #4
    1f08:	0100631f 	tsteq	r0, pc, lsl r3
    1f0c:	0001134c 	andeq	r1, r1, ip, asr #6
	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
    1f10:	00046e00 	andeq	r6, r4, r0, lsl #28
    1f14:	117c2000 	cmnne	ip, r0
    1f18:	08150000 	ldmdaeq	r5, {}	; <UNPREDICTABLE>

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1f1c:	091a0000 	ldmdbeq	sl, {}	; <UNPREDICTABLE>
    1f20:	01210000 	teqeq	r1, r0

	ed25519_project(p, x, y);
    1f24:	00770252 	rsbseq	r0, r7, r2, asr r2
    1f28:	02510121 	subseq	r0, r1, #1073741832	; 0x40000008
    1f2c:	01210079 	teqeq	r1, r9, ror r0

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
    1f30:	00780250 	rsbseq	r0, r8, r0, asr r2
    1f34:	11922000 	orrsne	r2, r2, r0
    1f38:	08150000 	ldmdaeq	r5, {}	; <UNPREDICTABLE>
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1f3c:	093a0000 	ldmdbeq	sl!, {}	; <UNPREDICTABLE>
    1f40:	01210000 	teqeq	r1, r0
	ed25519_pack(packed, x, y);
    1f44:	007a0252 	rsbseq	r0, sl, r2, asr r2
    1f48:	02510121 	subseq	r0, r1, #1073741832	; 0x40000008
    1f4c:	01210079 	teqeq	r1, r9, ror r0
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
    1f50:	00780250 	rsbseq	r0, r8, r0, asr r2
    1f54:	11a82200 			; <UNDEFINED> instruction: 0x11a82200
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
    1f58:	08150000 	ldmdaeq	r5, {}	; <UNPREDICTABLE>
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
}
    1f5c:	01210000 	teqeq	r1, r0
    1f60:	00770252 	rsbseq	r0, r7, r2, asr r2

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1f64:	02510121 	subseq	r0, r1, #1073741832	; 0x40000008
    1f68:	01210079 	teqeq	r1, r9, ror r0
    1f6c:	00780250 	rsbseq	r0, r8, r0, asr r2
    1f70:	f8230000 			; <UNDEFINED> instruction: 0xf8230000

const uint8_t f25519_zero[F25519_SIZE] = {0};
const uint8_t f25519_one[F25519_SIZE] = {1};

void f25519_load(uint8_t *x, uint32_t c)
{
    1f74:	0100000f 	tsteq	r0, pc
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
		c >>= 8;
    1f78:	11b0011f 	lslsne	r0, pc, r1
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    1f7c:	000a0000 	andeq	r0, sl, r0
    1f80:	9c010000 	stcls	0, cr0, [r1], {-0}
    1f84:	00000989 	andeq	r0, r0, r9, lsl #19
    1f88:	000f6124 	andeq	r6, pc, r4, lsr #2
		c >>= 8;
	}

	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}
    1f8c:	011f0100 	tsteq	pc, r0, lsl #2
    1f90:	00000989 	andeq	r0, r0, r9, lsl #19

void f25519_normalize(uint8_t *x)
{
    1f94:	63255001 	teqvs	r5, #1
    1f98:	1f010068 	svcne	0x00010068
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1f9c:	0000e701 	andeq	lr, r0, r1, lsl #14
	x[31] &= 127;
    1fa0:	00510100 	subseq	r0, r1, r0, lsl #2

	for (i = 0; i < F25519_SIZE; i++) {
    1fa4:	04f50408 	ldrbteq	r0, [r5], #1032	; 0x408
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1fa8:	d0230000 	eorle	r0, r3, r0
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
		c += x[i];
    1fac:	0100000e 	tsteq	r0, lr
		x[i] = c;
    1fb0:	11ba0125 			; <UNDEFINED> instruction: 0x11ba0125

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fb4:	00160000 	andseq	r0, r6, r0
		c += x[i];
		x[i] = c;
		c >>= 8;
    1fb8:	9c010000 	stcls	0, cr0, [r1], {-0}

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fbc:	000009d6 	ldrdeq	r0, [r0], -r6
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += x[i];
    1fc0:	000f6126 	andeq	r6, pc, r6, lsr #2
		minusp[i] = c;
    1fc4:	01250100 	teqeq	r5, r0, lsl #2
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1fc8:	00000989 	andeq	r0, r0, r9, lsl #19
		c += x[i];
		minusp[i] = c;
		c >>= 8;
    1fcc:	00000497 	muleq	r0, r7, r4
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1fd0:	72747327 	rsbsvc	r7, r4, #-1677721600	; 0x9c000000
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fd4:	01250100 	teqeq	r5, r0, lsl #2
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1fd8:	000009d6 	ldrdeq	r0, [r0], -r6

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1fdc:	000004b5 			; <UNDEFINED> instruction: 0x000004b5
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;
    1fe0:	0011cc22 	andseq	ip, r1, r2, lsr #24

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1fe4:	00095700 	andeq	r5, r9, r0, lsl #14
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    1fe8:	50012100 	andpl	r2, r1, r0, lsl #2
    1fec:	00007502 	andeq	r7, r0, r2, lsl #10
    1ff0:	e7040800 	str	r0, [r4, -r0, lsl #16]
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1ff4:	23000000 	movwcs	r0, #0
    1ff8:	00000f5a 	andeq	r0, r0, sl, asr pc
	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;

	/* Load x-p if no underflow */
	f25519_select(x, minusp, x, (c >> 15) & 1);
}
    1ffc:	d0012e01 	andle	r2, r1, r1, lsl #28
    2000:	28000011 	stmdacs	r0, {r0, r4}

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
    2004:	01000000 	mrseq	r0, (UNDEF: 0)
    2008:	000a579c 	muleq	sl, ip, r7
    200c:	6d662700 	stclvs	7, cr2, [r6, #-0]
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    2010:	2e010074 	mcrcs	0, 0, r0, cr1, cr4, {3}
    2014:	0000dc01 	andeq	sp, r0, r1, lsl #24
    2018:	0004f800 	andeq	pc, r4, r0, lsl #16
    201c:	0f402600 	svceq	0x00402600
    2020:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    2024:	00010801 	andeq	r0, r1, r1, lsl #16
    2028:	00052400 	andeq	r2, r5, r0, lsl #8
    202c:	0e6a2800 	cdpeq	8, 6, cr2, cr10, cr0, {0}
    2030:	30010000 	andcc	r0, r1, r0
    2034:	000a5701 	andeq	r5, sl, r1, lsl #14
    2038:	b0910300 	addslt	r0, r1, r0, lsl #6
    203c:	11e0207e 	mvnne	r2, lr, ror r0
    2040:	11d40000 	bicsne	r0, r4, r0
    2044:	0a3d0000 	beq	f4204c <_etext+0xf3aa38>
    2048:	01210000 	teqeq	r1, r0
    204c:	01f30351 	mvnseq	r0, r1, asr r3
    2050:	50012150 	andpl	r2, r1, r0, asr r1
    2054:	00007d02 	andeq	r7, r0, r2, lsl #26
    2058:	0011ec22 	andseq	lr, r1, r2, lsr #24
    205c:	00098f00 	andeq	r8, r9, r0, lsl #30
    2060:	51012100 	mrspl	r2, (UNDEF: 17)
    2064:	21007d02 	tstcs	r0, r2, lsl #26
    2068:	0c055001 	stceq	0, cr5, [r5], {1}
    206c:	40013800 	andmi	r3, r1, r0, lsl #16

	sum |= (sum >> 4);
    2070:	d5150000 	ldrle	r0, [r5, #-0]
	sum |= (sum >> 2);
    2074:	67000000 	strvs	r0, [r0, -r0]
	sum |= (sum >> 1);
    2078:	1600000a 	strne	r0, [r0], -sl

	return (sum ^ 1) & 1;
    207c:	000000bb 	strheq	r0, [r0], -fp
}
    2080:	b32300c7 	teqlt	r3, #199	; 0xc7
    2084:	0100000a 	tsteq	r0, sl
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2088:	11f80138 	mvnsne	r0, r8, lsr r1
		sum |= x[i] ^ y[i];
    208c:	001a0000 	andseq	r0, sl, r0
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2090:	9c010000 	stcls	0, cr0, [r1], {-0}
    2094:	00000ab4 			; <UNDEFINED> instruction: 0x00000ab4
		sum |= x[i] ^ y[i];
    2098:	746d6625 	strbtvc	r6, [sp], #-1573	; 0x625
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    209c:	01380100 	teqeq	r8, r0, lsl #2
}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
    20a0:	000000dc 	ldrdeq	r0, [r0], -ip
    20a4:	29709102 	ldmdbcs	r0!, {r1, r8, ip, pc}^
    20a8:	000f4028 	andeq	r4, pc, r8, lsr #32
    20ac:	013a0100 	teqeq	sl, r0, lsl #2
    20b0:	00000108 	andeq	r0, r0, r8, lsl #2
    20b4:	22649102 	rsbcs	r9, r4, #-2147483648	; 0x80000000
    20b8:	00001208 	andeq	r1, r0, r8, lsl #4
    20bc:	000009dc 	ldrdeq	r0, [r0], -ip
    20c0:	02510121 	subseq	r0, r1, #1073741832	; 0x40000008
	const uint8_t mask = -condition;
    20c4:	01215491 			; <UNDEFINED> instruction: 0x01215491
    20c8:	50910350 	addspl	r0, r1, r0, asr r3
    20cc:	23000006 	movwcs	r0, #6
    20d0:	00000d21 	andeq	r0, r0, r1, lsr #26
    20d4:	14014001 	strne	r4, [r1], #-1
    20d8:	9c000012 	stcls	0, cr0, [r0], {18}
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    20dc:	01000000 	mrseq	r0, (UNDEF: 0)
    20e0:	000be89c 	muleq	fp, ip, r8
    20e4:	0e7d2600 	cdpeq	6, 7, cr2, cr13, cr0, {0}
    20e8:	40010000 	andmi	r0, r1, r0
    20ec:	0000c901 	andeq	ip, r0, r1, lsl #18
    20f0:	00053700 	andeq	r3, r5, r0, lsl #14
    20f4:	1a0a2600 	bne	28b8fc <_etext+0x2842e8>
    20f8:	40010000 	andmi	r0, r1, r0
    20fc:	00002501 	andeq	r2, r0, r1, lsl #10
    2100:	00055500 	andeq	r5, r5, r0, lsl #10
    2104:	00692a00 	rsbeq	r2, r9, r0, lsl #20
    2108:	5b014201 	blpl	52914 <_etext+0x4b300>
    210c:	73000000 	movwvc	r0, #0
    2110:	2b000005 	blcs	212c <f25519_select+0x8c>
    2114:	01007363 	tsteq	r0, r3, ror #6
    2118:	0be80143 	bleq	ffa0262c <BootRAM+0xe972dcd>
    211c:	91020000 	mrsls	r0, (UNDEF: 2)
    2120:	12262054 	eorne	r2, r6, #84	; 0x54
    2124:	11f30000 	mvnsne	r0, r0
    2128:	0b240000 	bleq	902130 <_etext+0x8fab1c>
    212c:	01210000 	teqeq	r1, r0
    2130:	21410152 	cmpcs	r1, r2, asr r1
    2134:	30015101 	andcc	r5, r1, r1, lsl #2
    2138:	02500121 	subseq	r0, r0, #1073741832	; 0x40000008
    213c:	20005491 	mulcs	r0, r1, r4
    2140:	0000123c 	andeq	r1, r0, ip, lsr r2
    2144:	00000a67 	andeq	r0, r0, r7, ror #20
}
    2148:	00000b41 	andeq	r0, r0, r1, asr #22
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    214c:	02510121 	subseq	r0, r1, #1073741832	; 0x40000008
    2150:	01215491 			; <UNDEFINED> instruction: 0x01215491
    2154:	96030550 			; <UNDEFINED> instruction: 0x96030550
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2158:	00000070 	andeq	r0, r0, r0, ror r0
    215c:	00124620 	andseq	r4, r2, r0, lsr #12
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}
    2160:	0011f300 	andseq	pc, r1, r0, lsl #6
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    2164:	000b6000 	andeq	r6, fp, r0
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}

void f25519_add(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint16_t c = 0;
    2168:	52012100 	andpl	r2, r1, #0, 2
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
    216c:	01214101 	teqeq	r1, r1, lsl #2
    2170:	00750251 	rsbseq	r0, r5, r1, asr r2
		r[i] = c;
    2174:	02500121 	subseq	r0, r0, #1073741832	; 0x40000008
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    2178:	20005491 	mulcs	r0, r1, r4
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;
    217c:	00001254 	andeq	r1, r0, r4, asr r2
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    2180:	00000a67 	andeq	r0, r0, r7, ror #20
	c = (c >> 7) * 19;
    2184:	00000b7f 	andeq	r0, r0, pc, ror fp
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    2188:	04510121 	ldrbeq	r0, [r1], #-289	; 0x121
	c = (c >> 7) * 19;
    218c:	1a370074 	bne	dc2364 <_etext+0xdbad50>
    2190:	05500121 	ldrbeq	r0, [r0, #-289]	; 0x121

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2194:	0070a503 	rsbseq	sl, r0, r3, lsl #10
    2198:	5c200000 	stcpl	0, cr0, [r0], #-0

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    219c:	67000012 	smladvs	r0, r2, r0, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    21a0:	9600000a 	strls	r0, [r0], -sl

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21a4:	2100000b 	tstcs	r0, fp
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    21a8:	03055001 	movweq	r5, #20481	; 0x5001

void f25519_sub(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    21ac:	0000709d 	muleq	r0, sp, r0
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
    21b0:	127e2000 	rsbsne	r2, lr, #0
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    21b4:	0a670000 	beq	19c21bc <_etext+0x19baba8>
    21b8:	0bb30000 	bleq	fecc21c0 <BootRAM+0xdc32961>
    21bc:	01210000 	teqeq	r1, r0
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21c0:	54910251 	ldrpl	r0, [r1], #593	; 0x251
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    21c4:	05500121 	ldrbeq	r0, [r0, #-289]	; 0x121
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21c8:	00709603 	rsbseq	r9, r0, r3, lsl #12
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    21cc:	8e200000 	cdphi	0, 2, cr0, cr0, cr0, {0}
    21d0:	67000012 	smladvs	r0, r2, r0, r0
	r[31] = c & 127;
	c = (c >> 7) * 19;
    21d4:	cf00000a 	svcgt	0x0000000a
    21d8:	2100000b 	tstcs	r0, fp
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    21dc:	30015101 	andcc	r5, r1, r1, lsl #2
	c = (c >> 7) * 19;
    21e0:	05500121 	ldrbeq	r0, [r0, #-289]	; 0x121

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    21e4:	0070a503 	rsbseq	sl, r0, r3, lsl #10
		r[i] = c;
    21e8:	9a220000 	bls	8821f0 <_etext+0x87abdc>

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21ec:	67000012 	smladvs	r0, r2, r0, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    21f0:	2100000a 	tstcs	r0, sl
	}
}
    21f4:	30015101 	andcc	r5, r1, r1, lsl #2

void f25519_neg(uint8_t *r, const uint8_t *a)
{
    21f8:	05500121 	ldrbeq	r0, [r0, #-289]	; 0x121
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
    21fc:	0070a303 	rsbseq	sl, r0, r3, lsl #6
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 - ((uint32_t)a[i]);
    2200:	15000000 	strne	r0, [r0, #-0]
    2204:	000000d5 	ldrdeq	r0, [r0], -r5
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2208:	00000bf8 	strdeq	r0, [r0], -r8
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
    220c:	0000bb16 	andeq	fp, r0, r6, lsl fp
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2210:	23001000 	movwcs	r1, #0

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2214:	00000d89 	andeq	r0, r0, r9, lsl #27
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2218:	b0016401 	andlt	r6, r1, r1, lsl #8
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    221c:	28000012 	stmdacs	r0, {r1, r4}
	c = (c >> 7) * 19;
    2220:	01000000 	mrseq	r0, (UNDEF: 0)
    2224:	000c5e9c 	muleq	ip, ip, lr

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2228:	0d8f2600 	stceq	6, cr2, [pc]	; 2230 <f25519_neg+0x38>
		r[i] = c;
    222c:	64010000 	strvs	r0, [r1], #-0

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2230:	0000c901 	andeq	ip, r0, r1, lsl #18
		c += r[i];
		r[i] = c;
		c >>= 8;
    2234:	0005c000 	andeq	ip, r5, r0
	}
}
    2238:	64692a00 	strbtvs	r2, [r9], #-2560	; 0xa00
    223c:	66010078 			; <UNDEFINED> instruction: 0x66010078

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2240:	00005b01 	andeq	r5, r0, r1, lsl #22
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2244:	0005ec00 	andeq	lr, r5, r0, lsl #24
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    2248:	12c02000 	sbcne	r2, r0, #0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    224c:	0a670000 	beq	19c2254 <_etext+0x19bac40>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2250:	0c450000 	mareq	acc0, r0, r5
		for (j = 0; j <= i; j++)
    2254:	01210000 	teqeq	r1, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2258:	a7030550 	smlsdge	r3, r0, r5, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    225c:	00000070 	andeq	r0, r0, r0, ror r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2260:	0012d02c 	andseq	sp, r2, ip, lsr #32

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2264:	000a6700 	andeq	r6, sl, r0, lsl #14
    2268:	51012100 	mrspl	r2, (UNDEF: 17)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    226c:	01213001 	teqeq	r1, r1
    2270:	c8030550 	stmdagt	r3, {r4, r6, r8, sl}
    2274:	00000070 	andeq	r0, r0, r0, ror r0
    2278:	0b482300 	bleq	120ae80 <_etext+0x120386c>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    227c:	6d010000 	stcvs	0, cr0, [r1, #-0]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2280:	0012d801 	andseq	sp, r2, r1, lsl #16
    2284:	00008800 	andeq	r8, r0, r0, lsl #16

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2288:	4d9c0100 	ldfmis	f0, [ip]
			c += ((uint32_t)a[j]) *
    228c:	2800000d 	stmdacs	r0, {r0, r2, r3}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2290:	00000f00 	andeq	r0, r0, r0, lsl #30
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2294:	9d016e01 	stcls	14, cr6, [r1, #-4]
    2298:	02000007 	andeq	r0, r0, #7
    229c:	2a286491 	bcs	a1b4e8 <_etext+0xa13ed4>

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    22a0:	0100000e 	tsteq	r0, lr
    22a4:	06fa016f 	ldrbteq	r0, [sl], pc, ror #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22a8:	91020000 	mrsls	r0, (UNDEF: 2)
	c = (c >> 7) * 19;
    22ac:	0dac2d68 	stceq	13, cr2, [ip, #416]!	; 0x1a0

	for (i = 0; i < F25519_SIZE; i++) {
    22b0:	8a010000 	bhi	422b8 <_etext+0x3aca4>
		c += r[i];
    22b4:	00005b01 	andeq	r5, r0, r1, lsl #22
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22b8:	000ca400 	andeq	sl, ip, r0, lsl #8
		c += r[i];
		r[i] = c;
		c >>= 8;
    22bc:	2d002900 	stccs	9, cr2, [r0, #-0]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22c0:	000010ce 	andeq	r1, r0, lr, asr #1
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    22c4:	5b018d01 	blpl	656d0 <_etext+0x5e0bc>
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    22c8:	b6000000 	strlt	r0, [r0], -r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    22cc:	2900000c 	stmdbcs	r0, {r2, r3}
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    22d0:	12e82000 	rscne	r2, r8, #0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22d4:	12100000 	andsne	r0, r0, #0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    22d8:	0cd00000 	ldcleq	0, cr0, [r0], {0}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22dc:	01210000 	teqeq	r1, r0
    22e0:	21310151 	teqcs	r1, r1, asr r1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22e4:	0a035001 	beq	d62f0 <_etext+0xcecdc>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22e8:	20004000 	andcs	r4, r0, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22ec:	000012f0 	strdeq	r1, [r0], -r0
    22f0:	00001210 	andeq	r1, r0, r0, lsl r2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22f4:	00000ce9 	andeq	r0, r0, r9, ror #25
    22f8:	01510121 	cmpeq	r1, r1, lsr #2
    22fc:	50012131 	andpl	r2, r1, r1, lsr r1
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2300:	00007402 	andeq	r7, r0, r2, lsl #8
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2304:	00130c20 	andseq	r0, r3, r0, lsr #24
    2308:	00122700 	andseq	r2, r2, r0, lsl #14

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    230c:	000d0300 	andeq	r0, sp, r0, lsl #6
			c += ((uint32_t)a[j]) *
    2310:	51012100 	mrspl	r2, (UNDEF: 17)
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2314:	21649102 	cmncs	r4, r2, lsl #2
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2318:	74025001 	strvc	r5, [r2], #-1
    231c:	24200000 	strtcs	r0, [r0], #-0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2320:	27000013 	smladcs	r0, r3, r0, r0
	c = (c >> 7) * 19;
    2324:	1d000012 	stcne	0, cr0, [r0, #-72]	; 0xffffffb8
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2328:	2100000d 	tstcs	r0, sp
	c = (c >> 7) * 19;
    232c:	91025101 	tstls	r2, r1, lsl #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2330:	50012164 	andpl	r2, r1, r4, ror #2
    2334:	00007402 	andeq	r7, r0, r2, lsl #8
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2338:	00134e20 	andseq	r4, r3, r0, lsr #28
		r[i] = c;
    233c:	00124a00 	andseq	r4, r2, r0, lsl #20
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2340:	000d3700 	andeq	r3, sp, r0, lsl #14
		c += r[i];
		r[i] = c;
		c >>= 8;
    2344:	51012100 	mrspl	r2, (UNDEF: 17)
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2348:	21689102 	cmncs	r8, r2, lsl #2
    234c:	74025001 	strvc	r5, [r2], #-1
    2350:	56220000 	strtpl	r0, [r2], -r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2354:	5c000013 	stcpl	0, cr0, [r0], {19}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2358:	21000012 	tstcs	r0, r2, lsl r0
		for (j = 0; j <= i; j++)
    235c:	31015101 	tstcc	r1, r1, lsl #2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2360:	02500121 	subseq	r0, r0, #1073741832	; 0x40000008
    2364:	00000074 	andeq	r0, r0, r4, ror r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2368:	000b9d2e 	andeq	r9, fp, lr, lsr #26
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    236c:	01900100 	orrseq	r0, r0, r0, lsl #2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2370:	00001360 	andeq	r1, r0, r0, ror #6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2374:	00000048 	andeq	r0, r0, r8, asr #32
    2378:	d1239c01 	teqle	r3, r1, lsl #24
    237c:	0100000b 	tsteq	r0, fp
    2380:	13a8019a 			; <UNDEFINED> instruction: 0x13a8019a
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2384:	00600000 	rsbeq	r0, r0, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2388:	9c010000 	stcls	0, cr0, [r1], {-0}
    238c:	00000d83 	andeq	r0, r0, r3, lsl #27
    2390:	0011ab2f 	andseq	sl, r1, pc, lsr #22

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2394:	019b0100 	orrseq	r0, fp, r0, lsl #2
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2398:	00000030 	andeq	r0, r0, r0, lsr r0
    239c:	7f300000 	svcvc	0x00300000

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    23a0:	01000002 	tsteq	r0, r2
    23a4:	003002af 	eorseq	r0, r0, pc, lsr #5
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    23a8:	ad010000 	stcge	0, cr0, [r1, #-0]
	c = (c >> 7) * 19;
    23ac:	3100000d 	tstcc	r0, sp

	for (i = 0; i < F25519_SIZE; i++) {
    23b0:	006e6970 	rsbeq	r6, lr, r0, ror r9
		c += r[i];
    23b4:	5b02af01 	blpl	adfc0 <_etext+0xa69ac>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23b8:	32000000 	andcc	r0, r0, #0
		c += r[i];
		r[i] = c;
		c >>= 8;
    23bc:	00000d1c 	andeq	r0, r0, ip, lsl sp
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23c0:	3002b101 	andcc	fp, r2, r1, lsl #2
    23c4:	00000000 	andeq	r0, r0, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    23c8:	000b242e 	andeq	r2, fp, lr, lsr #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23cc:	01c40100 	biceq	r0, r4, r0, lsl #2
    23d0:	00001408 	andeq	r1, r0, r8, lsl #8
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    23d4:	00000014 	andeq	r0, r0, r4, lsl r0
		for (j = 0; j <= i; j++)
    23d8:	c0239c01 	eorgt	r9, r3, r1, lsl #24
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23dc:	0100000b 	tsteq	r0, fp
    23e0:	141c01c8 	ldrne	r0, [ip], #-456	; 0x1c8

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23e4:	001c0000 	andseq	r0, ip, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23e8:	9c010000 	stcls	0, cr0, [r1], {-0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23ec:	00000df0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    23f0:	00142433 	andseq	r2, r4, r3, lsr r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23f4:	00000800 	andeq	r0, r0, r0, lsl #16
    23f8:	0e943400 	cdpeq	4, 9, cr3, cr4, cr0, {0}
    23fc:	cb010000 	blgt	42404 <_etext+0x3adf0>
    2400:	00011301 	andeq	r1, r1, r1, lsl #6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2404:	00062300 	andeq	r2, r6, r0, lsl #6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2408:	23000000 	movwcs	r0, #0
    240c:	00000d80 	andeq	r0, r0, r0, lsl #27

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2410:	0001d501 	andeq	sp, r1, r1, lsl #10
			c += ((uint32_t)a[j]) *
    2414:	2e000000 	cdpcs	0, 0, cr0, cr0, cr0, {0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2418:	01000000 	mrseq	r0, (UNDEF: 0)
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    241c:	000e169c 	muleq	lr, ip, r6
    2420:	64692700 	strbtvs	r2, [r9], #-1792	; 0x700
    2424:	01d50100 	bicseq	r0, r5, r0, lsl #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2428:	00000e16 	andeq	r0, r0, r6, lsl lr
	c = (c >> 7) * 19;
    242c:	00000636 	andeq	r0, r0, r6, lsr r6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2430:	67040800 	strvs	r0, [r4, -r0, lsl #16]
	c = (c >> 7) * 19;
    2434:	35000006 	strcc	r0, [r0, #-6]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2438:	00001017 	andeq	r1, r0, r7, lsl r0
	c = (c >> 7) * 19;
    243c:	3801e201 	stmdacc	r1, {r0, r9, sp, lr, pc}

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2440:	18000014 	stmdane	r0, {r2, r4}
		r[i] = c;
    2444:	01000000 	mrseq	r0, (UNDEF: 0)
		c >>= 8;
    2448:	000e6f9c 	muleq	lr, ip, pc	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    244c:	0ea32600 	cdpeq	6, 10, cr2, cr3, cr0, {0}
    2450:	e2010000 	and	r0, r1, #0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2454:	00011301 	andeq	r1, r1, r1, lsl #6
    2458:	00065700 	andeq	r5, r6, r0, lsl #14
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    245c:	0e623600 	cdpeq	6, 6, cr3, cr2, cr0, {0}
    2460:	e6010000 	str	r0, [r1], -r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2464:	0000c201 	andeq	ip, r0, r1, lsl #4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2468:	116f3400 	cmnne	pc, r0, lsl #8

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    246c:	e7010000 	str	r0, [r1, -r0]
    2470:	00011301 	andeq	r1, r1, r1, lsl #6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2474:	00067800 	andeq	r7, r6, r0, lsl #16
    2478:	0ee23400 	cdpeq	4, 14, cr3, cr2, cr0, {0}
    247c:	e9010000 	stmdb	r1, {}	; <UNPREDICTABLE>
    2480:	000e4201 	andeq	r4, lr, r1, lsl #4
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2484:	00067800 	andeq	r7, r6, r0, lsl #16
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2488:	77230000 	strvc	r0, [r3, -r0]!
    248c:	0100000c 	tsteq	r0, ip

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2490:	00000208 	andeq	r0, r0, r8, lsl #4
			c += ((uint32_t)a[j]) *
    2494:	002c0000 	eoreq	r0, ip, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2498:	9c010000 	stcls	0, cr0, [r1], {-0}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    249c:	00000e94 	muleq	r0, r4, lr
    24a0:	000dc524 	andeq	ip, sp, r4, lsr #10
    24a4:	02080100 	andeq	r0, r8, #0, 2

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    24a8:	0000011e 	andeq	r0, r0, lr, lsl r1
    24ac:	37005001 	strcc	r5, [r0, -r1]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    24b0:	00000c98 	muleq	r0, r8, ip
	c = (c >> 7) * 19;
    24b4:	5b021701 	blpl	880c0 <_etext+0x80aac>

	for (i = 0; i < F25519_SIZE; i++) {
    24b8:	00000000 	andeq	r0, r0, r0
		c += r[i];
    24bc:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24c0:	01000000 	mrseq	r0, (UNDEF: 0)
		c += r[i];
		r[i] = c;
		c >>= 8;
    24c4:	000ece9c 	muleq	lr, ip, lr
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24c8:	0e9b3400 	cdpeq	4, 9, cr3, cr11, cr0, {0}
	/* 1 1 */
	f25519_mul__distinct(s, x, x);
	f25519_mul__distinct(r, s, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    24cc:	19010000 	stmdbne	r1, {}	; <UNPREDICTABLE>
    24d0:	00017802 	andeq	r7, r1, r2, lsl #16
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24d4:	00068b00 	andeq	r8, r6, r0, lsl #22
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    24d8:	00002200 	andeq	r2, r0, r0, lsl #4
    24dc:	0e6f0000 	cdpeq	0, 6, cr0, cr15, cr0, {0}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24e0:	01210000 	teqeq	r1, r0
    24e4:	00300150 	eorseq	r0, r0, r0, asr r1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24e8:	09e12300 	stmibeq	r1!, {r8, r9, sp}^
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24ec:	31010000 	mrscc	r0, (UNDEF: 1)

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24f0:	00145002 	andseq	r5, r4, r2
    24f4:	00006c00 	andeq	r6, r0, r0, lsl #24
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24f8:	659c0100 	ldrvs	r0, [ip, #256]	; 0x100
    24fc:	2400000f 	strcs	r0, [r0], #-15
    2500:	000010ad 	andeq	r1, r0, sp, lsr #1
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2504:	65023101 	strvs	r3, [r2, #-257]	; 0x101
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2508:	0100000f 	tsteq	r0, pc
    250c:	119f3450 	orrsne	r3, pc, r0, asr r4	; <UNPREDICTABLE>

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2510:	32010000 	andcc	r0, r1, #0
			c += ((uint32_t)a[j]) *
    2514:	00011302 	andeq	r1, r1, r2, lsl #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2518:	0006aa00 	andeq	sl, r6, r0, lsl #20
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    251c:	0dee3400 	cfstrdeq	mvd3, [lr]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2520:	33010000 	movwcc	r0, #4096	; 0x1000
    2524:	00011302 	andeq	r1, r1, r2, lsl #6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2528:	00071600 	andeq	r1, r7, r0, lsl #12
	c = (c >> 7) * 19;
    252c:	0d193400 	cfldrseq	mvf3, [r9, #-0]
    2530:	34010000 	strcc	r0, [r1], #-0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2534:	00011302 	andeq	r1, r1, r2, lsl #6
	c = (c >> 7) * 19;
    2538:	00074b00 	andeq	r4, r7, r0, lsl #22
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    253c:	0e823400 	cdpeq	4, 8, cr3, cr2, cr0, {0}
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2540:	35010000 	strcc	r0, [r1, #-0]
		r[i] = c;
    2544:	00011302 	andeq	r1, r1, r2, lsl #6
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2548:	00078300 	andeq	r8, r7, r0, lsl #6
		c += r[i];
		r[i] = c;
		c >>= 8;
    254c:	105a3400 	subsne	r3, sl, r0, lsl #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2550:	36010000 	strcc	r0, [r1], -r0
    2554:	00011302 	andeq	r1, r1, r2, lsl #6
    2558:	0007c000 	andeq	ip, r7, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    255c:	0f3b3800 	svceq	0x003b3800
    2560:	38010000 	stmdacc	r1, {}	; <UNPREDICTABLE>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2564:	000f6b02 	andeq	r6, pc, r2, lsl #22
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2568:	83da8000 	bicshi	r8, sl, #0
    256c:	82387e80 	eorshi	r7, r8, #128, 28	; 0x800

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2570:	0100000c 	tsteq	r0, ip
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2574:	0f710239 	svceq	0x00710239

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2578:	c2800000 	addgt	r0, r0, #0
    257c:	007e8083 	rsbseq	r8, lr, r3, lsl #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2580:	03650408 	cmneq	r5, #8, 8	; 0x8000000
    2584:	04080000 	streq	r0, [r8], #-0
    2588:	00000436 	andeq	r0, r0, r6, lsr r4
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    258c:	03210408 	teqeq	r1, #8, 8	; 0x8000000
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2590:	b9230000 	stmdblt	r3!, {}	; <UNPREDICTABLE>
    2594:	0100000c 	tsteq	r0, ip

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2598:	14bc0254 	ldrtne	r0, [ip], #596	; 0x254
			c += ((uint32_t)a[j]) *
    259c:	00240000 	eoreq	r0, r4, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    25a0:	9c010000 	stcls	0, cr0, [r1], {-0}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    25a4:	00000f9f 	muleq	r0, pc, pc	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25a8:	000c8238 	andeq	r8, ip, r8, lsr r2
	c = (c >> 7) * 19;
    25ac:	02550100 	subseq	r0, r5, #0, 2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25b0:	00000f71 	andeq	r0, r0, r1, ror pc
	c = (c >> 7) * 19;
    25b4:	8083c280 	addhi	ip, r3, r0, lsl #5
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25b8:	9223007e 	eorls	r0, r3, #126	; 0x7e
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    25bc:	0100000b 	tsteq	r0, fp
		r[i] = c;
    25c0:	14e001f4 	strbtne	r0, [r0], #500	; 0x1f4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    25c4:	001e0000 	andseq	r0, lr, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    25c8:	9c010000 	stcls	0, cr0, [r1], {-0}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    25cc:	00000ffb 	strdeq	r0, [r0], -fp
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25d0:	000ea326 	andeq	sl, lr, r6, lsr #6
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    25d4:	01f40100 	mvnseq	r0, r0, lsl #2
		for (j = 0; j <= i; j++)
    25d8:	00000113 	andeq	r0, r0, r3, lsl r1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25dc:	000007ee 	andeq	r0, r0, lr, ror #15
    25e0:	0014e839 	andseq	lr, r4, r9, lsr r8

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25e4:	00126e00 	andseq	r6, r2, r0, lsl #28
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25e8:	14ec3900 	strbtne	r3, [ip], #2304	; 0x900

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25ec:	0f770000 	svceq	0x00770000
    25f0:	f0390000 			; <UNDEFINED> instruction: 0xf0390000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25f4:	75000014 	strvc	r0, [r0, #-20]
    25f8:	39000012 	stmdbcc	r0, {r1, r4}
    25fc:	000014f4 	strdeq	r1, [r0], -r4
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2600:	00000d4d 	andeq	r0, r0, sp, asr #26
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2604:	0014fe2c 	andseq	pc, r4, ip, lsr #28
    2608:	000e1c00 	andeq	r1, lr, r0, lsl #24

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    260c:	50012100 	andpl	r2, r1, r0, lsl #2
			c += ((uint32_t)a[j]) *
    2610:	5001f303 	andpl	pc, r1, r3, lsl #6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2614:	67230000 	strvs	r0, [r3, -r0]!
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2618:	0100000c 	tsteq	r0, ip
    261c:	1500025e 	strne	r0, [r0, #-606]	; 0x25e
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2620:	00140000 	andseq	r0, r4, r0
	c = (c >> 7) * 19;
    2624:	9c010000 	stcls	0, cr0, [r1], {-0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2628:	00001023 	andeq	r1, r0, r3, lsr #32
	c = (c >> 7) * 19;
    262c:	000f3b38 	andeq	r3, pc, r8, lsr fp	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2630:	025f0100 	subseq	r0, pc, #0, 2
	c = (c >> 7) * 19;
    2634:	00000f6b 	andeq	r0, r0, fp, ror #30

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2638:	8083da80 	addhi	sp, r3, r0, lsl #21
		r[i] = c;
    263c:	403a007e 	eorsmi	r0, sl, lr, ror r0
		c >>= 8;
    2640:	0100000c 	tsteq	r0, ip
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2644:	0178026a 	cmneq	r8, sl, ror #4
    2648:	15140000 	ldrne	r0, [r4, #-0]
    264c:	00340000 	eorseq	r0, r4, r0
    2650:	9c010000 	stcls	0, cr0, [r1], {-0}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2654:	0000105e 	andeq	r1, r0, lr, asr r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2658:	00115a26 	andseq	r5, r1, r6, lsr #20
		for (j = 0; j <= i; j++)
    265c:	026a0100 	rsbeq	r0, sl, #0, 2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2660:	00000113 	andeq	r0, r0, r3, lsl r1
    2664:	00000825 	andeq	r0, r0, r5, lsr #16

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2668:	000e9434 	andeq	r9, lr, r4, lsr r4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    266c:	026b0100 	rsbeq	r0, fp, #0, 2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2670:	00000113 	andeq	r0, r0, r3, lsl r1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2674:	00000846 	andeq	r0, r0, r6, asr #16
    2678:	0f4a3a00 	svceq	0x004a3a00
    267c:	7b010000 	blvc	42684 <_etext+0x3b070>
    2680:	00017802 	andeq	r7, r1, r2, lsl #16
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2684:	00000000 	andeq	r0, r0, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2688:	00003000 	andeq	r3, r0, r0
    268c:	a09c0100 	addsge	r0, ip, r0, lsl #2
    2690:	26000010 			; <UNDEFINED> instruction: 0x26000010

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2694:	0000115a 	andeq	r1, r0, sl, asr r1
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2698:	13027b01 	movwne	r7, #11009	; 0x2b01
    269c:	66000001 	strvs	r0, [r0], -r1

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    26a0:	27000008 	strcs	r0, [r0, -r8]
    26a4:	7b01006e 	blvc	42864 <_etext+0x3b250>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26a8:	00011e02 	andeq	r1, r1, r2, lsl #28
	c = (c >> 7) * 19;
    26ac:	00089200 	andeq	r9, r8, r0, lsl #4

	for (i = 0; i < F25519_SIZE; i++) {
    26b0:	00003900 	andeq	r3, r0, r0, lsl #18
		c += r[i];
    26b4:	10230000 	eorne	r0, r3, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    26b8:	3a000000 	bcc	26c0 <f25519_inv__distinct+0x3f8>
		c += r[i];
		r[i] = c;
		c >>= 8;
    26bc:	00000e1b 	andeq	r0, r0, fp, lsl lr
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    26c0:	78028501 	stmdavc	r2, {r0, r8, sl, pc}
    26c4:	48000001 	stmdami	r0, {r0}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26c8:	4c000015 	stcmi	0, cr0, [r0], {21}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    26cc:	01000000 	mrseq	r0, (UNDEF: 0)
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26d0:	0011179c 	mulseq	r1, ip, r7
    26d4:	11042600 	tstne	r4, r0, lsl #12

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26d8:	85010000 	strhi	r0, [r1, #-0]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26dc:	00011302 	andeq	r1, r1, r2, lsl #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26e0:	0008d600 	andeq	sp, r8, r0, lsl #12
    26e4:	100d2400 	andne	r2, sp, r0, lsl #8
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26e8:	85010000 	strhi	r0, [r1, #-0]
    26ec:	00011302 	andeq	r1, r1, r2, lsl #6
    26f0:	34510100 	ldrbcc	r0, [r1], #-256	; 0x100
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    26f4:	000010a3 	andeq	r1, r0, r3, lsr #1
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26f8:	17028601 	strne	r8, [r2, -r1, lsl #12]
    26fc:	d6000011 			; <UNDEFINED> instruction: 0xd6000011

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2700:	28000008 	stmdacs	r0, {r3}
			c += ((uint32_t)a[j]) *
    2704:	00001163 	andeq	r1, r0, r3, ror #2

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2708:	33028701 	movwcc	r8, #9985	; 0x2701
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    270c:	02000001 	andeq	r0, r0, #1
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2710:	98286891 	stmdals	r8!, {r0, r4, r7, fp, sp, lr}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2714:	01000011 	tsteq	r0, r1, lsl r0
	c = (c >> 7) * 19;
    2718:	01330288 	teqeq	r3, r8, lsl #5
    271c:	91020000 	mrsls	r0, (UNDEF: 2)
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2720:	0e94346c 	cdpeq	4, 9, cr3, cr4, cr12, {3}
	c = (c >> 7) * 19;
    2724:	8a010000 	bhi	4272c <_etext+0x3b118>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2728:	00011302 	andeq	r1, r1, r2, lsl #6
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    272c:	0008f700 	andeq	pc, r8, r0, lsl #14
		r[i] = c;
    2730:	04080000 	streq	r0, [r8], #-0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2734:	00000143 	andeq	r0, r0, r3, asr #2
		c += r[i];
		r[i] = c;
		c >>= 8;
    2738:	0010032e 	andseq	r0, r0, lr, lsr #6
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    273c:	02a00100 	adceq	r0, r0, #0, 2
    2740:	00001594 	muleq	r0, r4, r5
    2744:	0000000c 	andeq	r0, r0, ip
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2748:	712e9c01 	teqvc	lr, r1, lsl #24
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    274c:	0100000e 	tsteq	r0, lr
		for (j = 0; j <= i; j++)
    2750:	15a002a7 	strne	r0, [r0, #679]!	; 0x2a7
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2754:	00180000 	andseq	r0, r8, r0
    2758:	9c010000 	stcls	0, cr0, [r1], {-0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    275c:	000d833b 	andeq	r8, sp, fp, lsr r3
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2760:	0015b800 	andseq	fp, r5, r0, lsl #16

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2764:	00001200 	andeq	r1, r0, r0, lsl #4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2768:	679c0100 	ldrvs	r0, [ip, r0, lsl #2]
    276c:	3c000011 	stccc	0, cr0, [r0], {17}
    2770:	00000d94 	muleq	r0, r4, sp
    2774:	00000915 	andeq	r0, r0, r5, lsl r9
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2778:	000da03d 	andeq	sl, sp, sp, lsr r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    277c:	00093300 	andeq	r3, r9, r0, lsl #6
    2780:	ea3a0000 	b	e82788 <_etext+0xe7b174>
    2784:	0100000e 	tsteq	r0, lr

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2788:	005b02bb 	ldrheq	r0, [fp], #-43	; 0xffffffd5
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    278c:	15cc0000 	strbne	r0, [ip]
    2790:	00100000 	andseq	r0, r0, r0

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2794:	9c010000 	stcls	0, cr0, [r1], {-0}
    2798:	00001192 	muleq	r0, r2, r1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    279c:	000ef63e 	andeq	pc, lr, lr, lsr r6	; <UNPREDICTABLE>
	c = (c >> 7) * 19;
    27a0:	02bd0100 	adcseq	r0, sp, #0, 2

	for (i = 0; i < F25519_SIZE; i++) {
    27a4:	00001192 	muleq	r0, r2, r1
		c += r[i];
    27a8:	1ffff7e0 	svcne	0x00fff7e0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27ac:	8d040800 	stchi	8, cr0, [r4, #-0]
		c += r[i];
		r[i] = c;
		c >>= 8;
    27b0:	3a000000 	bcc	27b8 <f25519_inv__distinct+0x4f0>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27b4:	0000035f 	andeq	r0, r0, pc, asr r3
    27b8:	5b02c101 	blpl	b2bc4 <_etext+0xab5b0>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27bc:	dc000000 	stcle	0, cr0, [r0], {-0}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    27c0:	18000015 	stmdane	r0, {r0, r2, r4}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27c4:	01000000 	mrseq	r0, (UNDEF: 0)
    27c8:	0011c39c 	mulseq	r1, ip, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27cc:	0ef63e00 	cdpeq	14, 15, cr3, cr6, cr0, {0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27d0:	c4010000 	strgt	r0, [r1], #-0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27d4:	00119202 	andseq	r9, r1, r2, lsl #4
    27d8:	fff7e000 			; <UNDEFINED> instruction: 0xfff7e000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27dc:	b13f001f 	teqlt	pc, pc, lsl r0	; <UNPREDICTABLE>
    27e0:	0a000000 	beq	27e8 <f25519_inv__distinct+0x520>
    27e4:	00005b2c 	andeq	r5, r0, ip, lsr #22
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    27e8:	88030500 	stmdahi	r3, {r8, sl}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27ec:	40200004 	eormi	r0, r0, r4
    27f0:	00000d06 	andeq	r0, r0, r6, lsl #26

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27f4:	005bb709 	subseq	fp, fp, r9, lsl #14
			c += ((uint32_t)a[j]) *
    27f8:	11f30000 	mvnsne	r0, r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27fc:	cf410000 	svcgt	0x00410000
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2800:	41000000 	mrsmi	r0, (UNDEF: 0)
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2804:	000000dc 	ldrdeq	r0, [r0], -ip
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2808:	00003741 	andeq	r3, r0, r1, asr #14
	c = (c >> 7) * 19;
    280c:	f1420000 			; <UNDEFINED> instruction: 0xf1420000
    2810:	5900000f 	stmdbpl	r0, {r0, r1, r2, r3}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2814:	10000000 	andne	r0, r0, r0
	c = (c >> 7) * 19;
    2818:	41000012 	tstmi	r0, r2, lsl r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    281c:	00000059 	andeq	r0, r0, r9, asr r0
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2820:	00005b41 	andeq	r5, r0, r1, asr #22
		r[i] = c;
    2824:	00bb4100 	adcseq	r4, fp, r0, lsl #2
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2828:	43000000 	movwmi	r0, #0
		c += r[i];
		r[i] = c;
		c >>= 8;
    282c:	00001126 	andeq	r1, r0, r6, lsr #2
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2830:	27011301 	strcs	r1, [r1, -r1, lsl #6]
    2834:	41000012 	tstmi	r0, r2, lsl r0
    2838:	000000fd 	strdeq	r0, [r0], -sp
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    283c:	00019841 	andeq	r9, r1, r1, asr #16
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2840:	0f430000 	svceq	0x00430000
		for (j = 0; j <= i; j++)
    2844:	0100000d 	tsteq	r0, sp
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2848:	123e0114 	eorsne	r0, lr, #20, 2
    284c:	3e410000 	cdpcc	0, 4, cr0, cr1, cr0, {0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2850:	41000012 	tstmi	r0, r2, lsl r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2854:	00001244 	andeq	r1, r0, r4, asr #4

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2858:	0a040800 	beq	104860 <_etext+0xfd24c>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    285c:	08000008 	stmdaeq	r0, {r3}
    2860:	00079d04 	andeq	r9, r7, r4, lsl #26
    2864:	0dac2d00 	stceq	13, cr2, [ip]
    2868:	8a010000 	bhi	42870 <_etext+0x3b25c>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    286c:	00005b01 	andeq	r5, r0, r1, lsl #22
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2870:	00125c00 	andseq	r5, r2, r0, lsl #24
    2874:	2d002900 	stccs	9, cr2, [r0, #-0]
    2878:	000010ce 	andeq	r1, r0, lr, asr #1

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    287c:	5b018d01 	blpl	65c88 <_etext+0x5e674>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2880:	6e000000 	cdpvs	0, 0, cr0, cr0, cr0, {0}
    2884:	29000012 	stmdbcs	r0, {r1, r4}

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2888:	00804400 	addeq	r4, r0, r0, lsl #8
    288c:	820a0000 	andhi	r0, sl, #0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2890:	00056744 	andeq	r6, r5, r4, asr #14
	c = (c >> 7) * 19;
    2894:	00520a00 	subseq	r0, r2, r0, lsl #20

	for (i = 0; i < F25519_SIZE; i++) {
    2898:	00000975 	andeq	r0, r0, r5, ror r9
		c += r[i];
    289c:	0a550004 	beq	15428b4 <_etext+0x153b2a0>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28a0:	01040000 	mrseq	r0, (UNDEF: 4)
		c += r[i];
		r[i] = c;
		c >>= 8;
    28a4:	00000639 	andeq	r0, r0, r9, lsr r6
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28a8:	0012b801 	andseq	fp, r2, r1, lsl #16
	f25519_mul__distinct(r, s, x);

	/* 1 */
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}
    28ac:	00089300 	andeq	r9, r8, r0, lsl #6
    28b0:	00023800 	andeq	r3, r2, r0, lsl #16
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    28b4:	00000000 	andeq	r0, r0, r0
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28b8:	000c5200 	andeq	r5, ip, r0, lsl #4
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    28bc:	06010200 	streq	r0, [r1], -r0, lsl #4
	f25519_copy(r, tmp);
}

void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
    28c0:	0000081a 	andeq	r0, r0, sl, lsl r8
    28c4:	000ad903 	andeq	sp, sl, r3, lsl #18
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += b * ((uint32_t)a[i]);
    28c8:	371c0200 	ldrcc	r0, [ip, -r0, lsl #4]
    28cc:	02000000 	andeq	r0, r0, #0
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28d0:	08180801 	ldmdaeq	r8, {r0, fp}
    28d4:	02020000 	andeq	r0, r2, #0
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    28d8:	0006fc05 	andeq	pc, r6, r5, lsl #24
    28dc:	07020200 	streq	r0, [r2, -r0, lsl #4]
	c >>= 7;
	c *= 19;
    28e0:	00000949 	andeq	r0, r0, r9, asr #18
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    28e4:	da050402 	ble	1438f4 <_etext+0x13c2e0>
	c >>= 7;
	c *= 19;
    28e8:	03000004 	movweq	r0, #4
    28ec:	00000abf 			; <UNDEFINED> instruction: 0x00000abf

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    28f0:	005e3802 	subseq	r3, lr, r2, lsl #16
		r[i] = c;
    28f4:	04020000 	streq	r0, [r2], #-0

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28f8:	00025207 	andeq	r5, r2, r7, lsl #4
		c += r[i];
		r[i] = c;
		c >>= 8;
    28fc:	05080200 	streq	r0, [r8, #-512]	; 0x200

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2900:	000004d5 	ldrdeq	r0, [r0], -r5
    2904:	4d070802 	stcmi	8, cr0, [r7, #-8]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2908:	04000002 	streq	r0, [r0], #-2
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    290c:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2910:	04020074 	streq	r0, [r2], #-116	; 0x74
    2914:	00025707 	andeq	r5, r2, r7, lsl #14

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2918:	0adb0300 	beq	ff6c3520 <BootRAM+0xe633cc1>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    291c:	2a030000 	bcs	c2924 <_etext+0xbb310>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2920:	0000002c 	andeq	r0, r0, ip, lsr #32
    2924:	000ac103 	andeq	ip, sl, r3, lsl #2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2928:	53420300 	movtpl	r0, #8960	; 0x2300
    292c:	05000000 	streq	r0, [r0, #-0]
    2930:	00323375 	eorseq	r3, r2, r5, ror r3
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2934:	005e2704 	subseq	r2, lr, r4, lsl #14
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2938:	75050000 	strvc	r0, [r5, #-0]
    293c:	04003631 	streq	r3, [r0], #-1585	; 0x631
    2940:	00004528 	andeq	r4, r0, r8, lsr #10

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2944:	38750500 	ldmdacc	r5!, {r8, sl}^
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2948:	37290400 	strcc	r0, [r9, -r0, lsl #8]!
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    294c:	03000000 	movweq	r0, #0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2950:	0000035a 	andeq	r0, r0, sl, asr r3
	c = (c >> 7) * 19;
    2954:	00c22f04 	sbceq	r2, r2, r4, lsl #30
    2958:	5e060000 	cdppl	0, 0, cr0, cr6, cr0, {0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    295c:	07000000 	streq	r0, [r0, -r0]
	c = (c >> 7) * 19;
    2960:	dc370401 	cfldrsle	mvf0, [r7], #-4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2964:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
	c = (c >> 7) * 19;
    2968:	00000753 	andeq	r0, r0, r3, asr r7

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    296c:	01a70800 			; <UNDEFINED> instruction: 0x01a70800
		r[i] = c;
    2970:	00010000 	andeq	r0, r1, r0
		c >>= 8;
    2974:	00052d03 	andeq	r2, r5, r3, lsl #26
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2978:	c7370400 	ldrgt	r0, [r7, -r0, lsl #8]!
    297c:	03000000 	movweq	r0, #0
    2980:	00000ae3 	andeq	r0, r0, r3, ror #21
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2984:	007ad405 	rsbseq	sp, sl, r5, lsl #8
		for (j = 0; j <= i; j++)
    2988:	04090000 	streq	r0, [r9], #-0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    298c:	8b070402 	blhi	1c399c <_etext+0x1bc388>
    2990:	02000007 	andeq	r0, r0, #7
    2994:	08210801 	stmdaeq	r1!, {r0, fp}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2998:	040a0000 	streq	r0, [sl], #-0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    299c:	00000108 	andeq	r0, r0, r8, lsl #2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    29a0:	0000fb0b 	andeq	pc, r0, fp, lsl #22
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29a4:	ad040a00 	vstrge	s0, [r4, #-0]
    29a8:	0c000000 	stceq	0, cr0, [r0], {-0}
    29ac:	000005ff 	strdeq	r0, [r0], -pc	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    29b0:	5038060c 	eorspl	r0, r8, ip, lsl #12
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    29b4:	0d000001 	stceq	0, cr0, [r0, #-4]
    29b8:	000001d7 	ldrdeq	r0, [r0], -r7

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29bc:	00a25006 	adceq	r5, r2, r6
			c += ((uint32_t)a[j]) *
    29c0:	0d000000 	stceq	0, cr0, [r0, #-0]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    29c4:	0000086d 	andeq	r0, r0, sp, ror #16
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    29c8:	00a25106 	adceq	r5, r2, r6, lsl #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29cc:	0d020000 	stceq	0, cr0, [r2, #-0]
	c = (c >> 7) * 19;
    29d0:	00002125 	andeq	r2, r0, r5, lsr #2
    29d4:	00a25206 	adceq	r5, r2, r6, lsl #4
    29d8:	0d040000 	stceq	0, cr0, [r4, #-0]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29dc:	00000738 	andeq	r0, r0, r8, lsr r7
	c = (c >> 7) * 19;
    29e0:	015f5306 	cmpeq	pc, r6, lsl #6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29e4:	00080000 	andeq	r0, r8, r0
    29e8:	00010d0e 	andeq	r0, r1, lr, lsl #26
	c = (c >> 7) * 19;
    29ec:	00015f00 	andeq	r5, r1, r0, lsl #30

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    29f0:	00a20f00 	adceq	r0, r2, r0, lsl #30
		r[i] = c;
    29f4:	0a000000 	beq	29fc <f25519_sqrt+0x148>
		c >>= 8;
    29f8:	00015004 	andeq	r5, r1, r4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    29fc:	06000300 	streq	r0, [r0], -r0, lsl #6
    2a00:	54060000 	strpl	r0, [r6], #-0
    2a04:	00000113 	andeq	r0, r0, r3, lsl r1
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a08:	00574210 	subseq	r4, r7, r0, lsl r2

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2a0c:	94620602 	strbtls	r0, [r2], #-1538	; 0x602
    2a10:	11000001 	tstne	r0, r1
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2a14:	00306262 	eorseq	r6, r0, r2, ror #4
		for (j = 0; j <= i; j++)
    2a18:	00ad6506 	adceq	r6, sp, r6, lsl #10
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a1c:	11000000 	mrsne	r0, (UNDEF: 0)
    2a20:	00316262 	eorseq	r6, r1, r2, ror #4

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a24:	00ad6606 	adceq	r6, sp, r6, lsl #12
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a28:	00010000 	andeq	r0, r1, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a2c:	5f060212 	svcpl	0x00060212
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a30:	000001b0 			; <UNDEFINED> instruction: 0x000001b0
    2a34:	06007713 			; <UNDEFINED> instruction: 0x06007713
    2a38:	0000a261 	andeq	sl, r0, r1, ror #4
    2a3c:	77621300 	strbvc	r1, [r2, -r0, lsl #6]!
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2a40:	70680600 	rsbvc	r0, r8, r0, lsl #12
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a44:	00000001 	andeq	r0, r0, r1
    2a48:	00093003 	andeq	r3, r9, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a4c:	94690600 	strbtls	r0, [r9], #-1536	; 0x600
			c += ((uint32_t)a[j]) *
    2a50:	0c000001 	stceq	0, cr0, [r0], {1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2a54:	00000114 	andeq	r0, r0, r4, lsl r1
    2a58:	4c6b061c 	stclmi	6, cr0, [fp], #-112	; 0xffffff90
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2a5c:	0d000002 	stceq	0, cr0, [r0, #-8]
    2a60:	00000767 	andeq	r0, r0, r7, ror #14
    2a64:	00ad6d06 	adceq	r6, sp, r6, lsl #26
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a68:	0d000000 	stceq	0, cr0, [r0, #-0]
	c = (c >> 7) * 19;
    2a6c:	00000015 	andeq	r0, r0, r5, lsl r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a70:	00ad6e06 	adceq	r6, sp, r6, lsl #28
	c = (c >> 7) * 19;
    2a74:	0d010000 	stceq	0, cr0, [r1, #-0]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a78:	00000311 	andeq	r0, r0, r1, lsl r3
	c = (c >> 7) * 19;
    2a7c:	01b06f06 	lslseq	r6, r6, #30

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2a80:	0d020000 	stceq	0, cr0, [r2, #-0]
		r[i] = c;
    2a84:	00000148 	andeq	r0, r0, r8, asr #2
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a88:	01b07006 	movseq	r7, r6
		c += r[i];
		r[i] = c;
		c >>= 8;
    2a8c:	0d040000 	stceq	0, cr0, [r4, #-0]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a90:	000004eb 	andeq	r0, r0, fp, ror #9
    2a94:	01b07106 	lslseq	r7, r6, #2
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2a98:	0d060000 	stceq	0, cr0, [r6, #-0]
		for (j = 0; j <= i; j++)
    2a9c:	000006ef 	andeq	r0, r0, pc, ror #13
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2aa0:	00ad7306 	adceq	r7, sp, r6, lsl #6
    2aa4:	0d080000 	stceq	0, cr0, [r8, #-0]
    2aa8:	00000808 	andeq	r0, r0, r8, lsl #16

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2aac:	00ad7406 	adceq	r7, sp, r6, lsl #8
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2ab0:	0d090000 	stceq	0, cr0, [r9, #-0]

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2ab4:	00000507 	andeq	r0, r0, r7, lsl #10
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ab8:	00ad7506 	adceq	r7, sp, r6, lsl #10
    2abc:	0d0a0000 	stceq	0, cr0, [sl, #-0]
    2ac0:	0000054f 	andeq	r0, r0, pc, asr #10
    2ac4:	00ad7606 	adceq	r7, sp, r6, lsl #12
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2ac8:	0d0b0000 	stceq	0, cr0, [fp, #-0]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2acc:	000005d6 	ldrdeq	r0, [r0], -r6
    2ad0:	00ad7706 	adceq	r7, sp, r6, lsl #14

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ad4:	0d0c0000 	stceq	0, cr0, [ip, #-0]
			c += ((uint32_t)a[j]) *
    2ad8:	000007c8 	andeq	r0, r0, r8, asr #15
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2adc:	01657a06 	cmneq	r5, r6, lsl #20
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2ae0:	00100000 	andseq	r0, r0, r0
    2ae4:	00011503 	andeq	r1, r1, r3, lsl #10
    2ae8:	bb7b0600 	bllt	1ec42f0 <_etext+0x1ebccdc>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2aec:	07000001 	streq	r0, [r0, -r1]
	c = (c >> 7) * 19;
    2af0:	8a230701 	bhi	8c46fc <_etext+0x8bd0e8>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2af4:	08000002 	stmdaeq	r0, {r1}
	c = (c >> 7) * 19;
    2af8:	000012fa 	strdeq	r1, [r0], -sl
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2afc:	123d0800 	eorsne	r0, sp, #0, 16
	c = (c >> 7) * 19;
    2b00:	08010000 	stmdaeq	r1, {}	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2b04:	0000129d 	muleq	r0, sp, r2
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b08:	11bf0802 			; <UNDEFINED> instruction: 0x11bf0802
		c += r[i];
		r[i] = c;
    2b0c:	08030000 	stmdaeq	r3, {}	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b10:	000012df 	ldrdeq	r1, [r0], -pc	; <UNPREDICTABLE>
		c += r[i];
		r[i] = c;
		c >>= 8;
    2b14:	13cd0804 	bicne	r0, sp, #4, 16	; 0x40000
	/* 1 1 */
	f25519_mul__distinct(r, x, x);
	f25519_mul__distinct(s, r, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    2b18:	08050000 	stmdaeq	r5, {}	; <UNPREDICTABLE>
    2b1c:	000011f7 	strdeq	r1, [r0], -r7
    2b20:	1e030006 	cdpne	0, 0, cr0, cr3, cr6, {0}
    2b24:	07000012 	smladeq	r0, r2, r0, r0
    2b28:	00025723 	andeq	r5, r2, r3, lsr #14
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2b2c:	13350c00 	teqne	r5, #0, 24
		for (j = 0; j <= i; j++)
    2b30:	07060000 	streq	r0, [r6, -r0]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b34:	0002ea29 	andeq	lr, r2, r9, lsr #20
    2b38:	13540d00 	cmpne	r4, #0, 26

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b3c:	2a070000 	bcs	1c2b44 <_etext+0x1bb530>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b40:	000000ad 	andeq	r0, r0, sp, lsr #1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b44:	136a0d00 	cmnne	sl, #0, 26
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b48:	2b070000 	blcs	1c2b50 <_etext+0x1bb53c>
    2b4c:	000000ad 	andeq	r0, r0, sp, lsr #1
    2b50:	13790d01 	cmnne	r9, #1, 26	; 0x40
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2b54:	2c070000 	stccs	0, cr0, [r7], {-0}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b58:	000000ad 	andeq	r0, r0, sp, lsr #1
    2b5c:	13880d02 	orrne	r0, r8, #2, 26	; 0x80

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b60:	2d070000 	stccs	0, cr0, [r7, #-0]
			c += ((uint32_t)a[j]) *
    2b64:	000000ad 	andeq	r0, r0, sp, lsr #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2b68:	14320d03 	ldrtne	r0, [r2], #-3331	; 0xd03
    2b6c:	2e070000 	cdpcs	0, 0, cr0, cr7, cr0, {0}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2b70:	000000ad 	andeq	r0, r0, sp, lsr #1
    2b74:	12c80d04 	sbcne	r0, r8, #4, 26	; 0x100
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b78:	2f070000 	svccs	0x00070000
	c = (c >> 7) * 19;
    2b7c:	000000ad 	andeq	r0, r0, sp, lsr #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b80:	36030005 	strcc	r0, [r3], -r5
	c = (c >> 7) * 19;
    2b84:	07000013 	smladeq	r0, r3, r0, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b88:	00029530 	andeq	r9, r2, r0, lsr r5
	c = (c >> 7) * 19;
    2b8c:	12971400 	addsne	r1, r7, #0, 8

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2b90:	07010000 	streq	r0, [r1, -r0]
		r[i] = c;
    2b94:	00031a32 	andeq	r1, r3, r2, lsr sl
		c >>= 8;
    2b98:	13a60800 			; <UNDEFINED> instruction: 0x13a60800
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b9c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    2ba0:	000013ff 	strdeq	r1, [r0], -pc	; <UNPREDICTABLE>
    2ba4:	4e451501 	cdpmi	5, 4, cr1, cr5, cr1, {0}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ba8:	08020044 	stmdaeq	r2, {r2, r6}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2bac:	0000016e 	andeq	r0, r0, lr, ror #2
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2bb0:	98030003 	stmdals	r3, {r0, r1}
    2bb4:	07000012 	smladeq	r0, r2, r0, r0
    2bb8:	0002f537 	andeq	pc, r2, r7, lsr r5	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2bbc:	08681600 	stmdaeq	r8!, {r9, sl, ip}^
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2bc0:	0003520c 	andeq	r5, r3, ip, lsl #4

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2bc4:	19090d00 	stmdbne	r9, {r8, sl, fp}
    2bc8:	0e080000 	cdpeq	0, 0, cr0, cr8, cr0, {0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2bcc:	00000352 	andeq	r0, r0, r2, asr r3
    2bd0:	17b90d00 	ldrne	r0, [r9, r0, lsl #26]!
    2bd4:	0f080000 	svceq	0x00080000
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2bd8:	00000362 	andeq	r0, r0, r2, ror #6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2bdc:	046c0d08 	strbteq	r0, [ip], #-3336	; 0xd08
    2be0:	10080000 	andne	r0, r8, r0
    2be4:	00000372 	andeq	r0, r0, r2, ror r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2be8:	5e170028 	cdppl	0, 1, cr0, cr7, cr8, {1}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2bec:	62000000 	andvs	r0, r0, #0
    2bf0:	18000003 	stmdane	r0, {r0, r1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bf4:	000000f4 	strdeq	r0, [r0], -r4
	c = (c >> 7) * 19;
    2bf8:	5e170001 	cdppl	0, 1, cr0, cr7, cr1, {0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bfc:	72000000 	andvc	r0, r0, #0
	c = (c >> 7) * 19;
    2c00:	18000003 	stmdane	r0, {r0, r1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c04:	000000f4 	strdeq	r0, [r0], -r4
	c = (c >> 7) * 19;
    2c08:	37170007 	ldrcc	r0, [r7, -r7]

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2c0c:	82000000 	andhi	r0, r0, #0
		r[i] = c;
    2c10:	18000003 	stmdane	r0, {r0, r1}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c14:	000000f4 	strdeq	r0, [r0], -r4
		c += r[i];
		r[i] = c;
		c >>= 8;
    2c18:	9703003f 	smladxls	r3, pc, r0, r0	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c1c:	08000013 	stmdaeq	r0, {r0, r1, r4}
    2c20:	00032512 	andeq	r2, r3, r2, lsl r5
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c24:	0b590c00 	bleq	1645c2c <_etext+0x163e618>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2c28:	09140000 	ldmdbeq	r4, {}	; <UNPREDICTABLE>
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c2c:	0003e20d 	andeq	lr, r3, sp, lsl #4
    2c30:	0b510d00 	bleq	1446038 <_etext+0x143ea24>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c34:	0e090000 	cdpeq	0, 0, cr0, cr9, cr0, {0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c38:	0000008c 	andeq	r0, r0, ip, lsl #1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c3c:	0b090d00 	bleq	246044 <_etext+0x23ea30>
    2c40:	10090000 	andne	r0, r9, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c44:	0000008c 	andeq	r0, r0, ip, lsl #1
    2c48:	0aca0d04 	beq	ff286060 <BootRAM+0xe1f6801>
    2c4c:	11090000 	mrsne	r0, (UNDEF: 9)
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2c50:	0000008c 	andeq	r0, r0, ip, lsl #1
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c54:	0afa0d08 	beq	ffe8607c <BootRAM+0xedf681d>
    2c58:	13090000 	movwne	r0, #36864	; 0x9000
    2c5c:	0000008c 	andeq	r0, r0, ip, lsl #1

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c60:	0bb90d0c 	bleq	fee46098 <BootRAM+0xddb6839>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2c64:	14090000 	strne	r0, [r9], #-0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2c68:	0000008c 	andeq	r0, r0, ip, lsl #1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c6c:	0bb00d10 	bleq	fec060b4 <BootRAM+0xdb76855>
	c = (c >> 7) * 19;
    2c70:	15090000 	strne	r0, [r9, #-0]
    2c74:	000003e2 	andeq	r0, r0, r2, ror #7
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c78:	81170014 	tsthi	r7, r4, lsl r0
	c = (c >> 7) * 19;
    2c7c:	f1000000 	cps	#0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c80:	19000003 	stmdbne	r0, {r0, r1}
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2c84:	000000f4 	strdeq	r0, [r0], -r4
		r[i] = c;
    2c88:	0b5a0300 	bleq	1683890 <_etext+0x167c27c>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c8c:	16090000 	strne	r0, [r9], -r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    2c90:	0000038d 	andeq	r0, r0, sp, lsl #7
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c94:	000be70c 	andeq	lr, fp, ip, lsl #14
    2c98:	18091400 	stmdane	r9, {sl, ip}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c9c:	00000445 	andeq	r0, r0, r5, asr #8
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2ca0:	000b8c0d 	andeq	r8, fp, sp, lsl #24
		for (j = 0; j <= i; j++)
    2ca4:	45190900 	ldrmi	r0, [r9, #-2304]	; 0x900
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2ca8:	00000004 	andeq	r0, r0, r4
    2cac:	000bcb0d 	andeq	ip, fp, sp, lsl #22
    2cb0:	8c1a0900 	ldchi	9, cr0, [sl], {-0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2cb4:	04000000 	streq	r0, [r0], #-0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2cb8:	000c250d 	andeq	r2, ip, sp, lsl #10

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2cbc:	e7200900 	str	r0, [r0, -r0, lsl #18]!
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cc0:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    2cc4:	000ba90d 	andeq	sl, fp, sp, lsl #18
    2cc8:	73220900 	teqvc	r2, #0, 18
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2ccc:	0c000000 	stceq	0, cr0, [r0], {-0}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2cd0:	000b360d 	andeq	r3, fp, sp, lsl #12
    2cd4:	73230900 	teqvc	r3, #0, 18

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cd8:	10000000 	andne	r0, r0, r0
			c += ((uint32_t)a[j]) *
    2cdc:	f1040a00 			; <UNDEFINED> instruction: 0xf1040a00
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2ce0:	03000003 	movweq	r0, #3
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2ce4:	00000c07 	andeq	r0, r0, r7, lsl #24
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2ce8:	04562709 	ldrbeq	r2, [r6], #-1801	; 0x709
	c = (c >> 7) * 19;
    2cec:	040a0000 	streq	r0, [sl], #-0
    2cf0:	000003fc 	strdeq	r0, [r0], -ip
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cf4:	0009bd1a 	andeq	fp, r9, sl, lsl sp
    2cf8:	f43d0100 			; <UNDEFINED> instruction: 0xf43d0100
	c = (c >> 7) * 19;
    2cfc:	88000015 	stmdahi	r0, {r0, r2, r4}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d00:	01000000 	mrseq	r0, (UNDEF: 0)
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2d04:	0004cb9c 	muleq	r4, ip, fp
		r[i] = c;
    2d08:	16361b00 	ldrtne	r1, [r6], -r0, lsl #22
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d0c:	089e0000 	ldmeq	lr, {}	; <UNPREDICTABLE>
		c += r[i];
		r[i] = c;
		c >>= 8;
    2d10:	04940000 	ldreq	r0, [r4], #0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d14:	011c0000 	tsteq	ip, r0
    2d18:	20080252 	andcs	r0, r8, r2, asr r2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d1c:	0251011c 	subseq	r0, r1, #28, 2
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2d20:	011cff08 	tsteq	ip, r8, lsl #30
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d24:	ec030550 	cfstr32	mvfx0, [r3], {80}	; 0x50
    2d28:	00200004 	eoreq	r0, r0, r4

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d2c:	0016401b 	andseq	r4, r6, fp, lsl r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d30:	00089e00 	andeq	r9, r8, r0, lsl #28

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d34:	0004b700 	andeq	fp, r4, r0, lsl #14
    2d38:	52011c00 	andpl	r1, r1, #0, 24
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d3c:	1c5c0802 	mrrcne	8, 0, r0, ip, cr2
    2d40:	08025101 	stmdaeq	r2, {r0, r8, ip, lr}
    2d44:	50011cff 	strdpl	r1, [r1], -pc	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2d48:	04900305 	ldreq	r0, [r0], #773	; 0x305
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d4c:	1d002000 	stcne	0, cr2, [r0, #-0]
    2d50:	0000164a 	andeq	r1, r0, sl, asr #12
    2d54:	000008bd 			; <UNDEFINED> instruction: 0x000008bd

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d58:	0550011c 	ldrbeq	r0, [r0, #-284]	; 0x11c
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2d5c:	00050c03 	andeq	r0, r5, r3, lsl #24
    2d60:	1e000020 	cdpne	0, 0, cr0, cr0, cr0, {1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d64:	0000083b 	andeq	r0, r0, fp, lsr r8
	c = (c >> 7) * 19;
    2d68:	7c018801 	stcvc	8, cr8, [r1], {1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d6c:	44000016 	strmi	r0, [r0], #-22
	c = (c >> 7) * 19;
    2d70:	01000000 	mrseq	r0, (UNDEF: 0)
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d74:	00050d9c 	muleq	r5, ip, sp
	c = (c >> 7) * 19;
    2d78:	11e01f00 	mvnne	r1, r0, lsl #30

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2d7c:	89010000 	stmdbhi	r1, {}	; <UNPREDICTABLE>
		r[i] = c;
    2d80:	0000ad01 	andeq	sl, r0, r1, lsl #26
		c >>= 8;
    2d84:	00096500 	andeq	r6, r9, r0, lsl #10
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d88:	16982000 	ldrne	r2, [r8], r0
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    2d8c:	08d40000 	ldmeq	r4, {}^	; <UNPREDICTABLE>
    2d90:	a0210000 	eorge	r0, r1, r0
    2d94:	dc000016 	stcle	0, cr0, [r0], {22}
    2d98:	21000008 	tstcs	r0, r8
    2d9c:	000016b4 			; <UNDEFINED> instruction: 0x000016b4
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2da0:	000008e3 	andeq	r0, r0, r3, ror #17
    2da4:	127c2200 	rsbsne	r2, ip, #0, 4
    2da8:	9f010000 	svcls	0x00010000
		r[i] = c;
    2dac:	00000001 	andeq	r0, r0, r1
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2db0:	00000200 	andeq	r0, r0, r0, lsl #4
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2db4:	239c0100 	orrscs	r0, ip, #0, 2
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2db8:	00001347 	andeq	r1, r0, r7, asr #6
    2dbc:	0d01a201 	sfmeq	f2, 1, [r1, #-4]
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2dc0:	c0000001 	andgt	r0, r0, r1
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2dc4:	18000016 	stmdane	r0, {r1, r2, r4}
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2dc8:	01000000 	mrseq	r0, (UNDEF: 0)
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2dcc:	00054a9c 	muleq	r5, ip, sl
    2dd0:	13402400 	movtne	r2, #1024	; 0x400
	c = (c >> 7) * 19;
    2dd4:	a2010000 	andge	r0, r1, #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2dd8:	0000a201 	andeq	sl, r0, r1, lsl #4
		r[i] = c;
    2ddc:	00098e00 	andeq	r8, r9, r0, lsl #28

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2de0:	b0230000 	eorlt	r0, r3, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    2de4:	01000013 	tsteq	r0, r3, lsl r0

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2de8:	010d01ab 	smlatbeq	sp, fp, r1, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2dec:	16d80000 	ldrbne	r0, [r8], r0

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2df0:	00180000 	andseq	r0, r8, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2df4:	9c010000 	stcls	0, cr0, [r1], {-0}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2df8:	00000575 	andeq	r0, r0, r5, ror r5
		for (j = 0; j <= i; j++)
    2dfc:	00134024 	andseq	r4, r3, r4, lsr #32
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e00:	01ab0100 			; <UNDEFINED> instruction: 0x01ab0100
    2e04:	000000a2 	andeq	r0, r0, r2, lsr #1
    2e08:	000009af 	andeq	r0, r0, pc, lsr #19

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e0c:	135c2300 	cmpne	ip, #0, 6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e10:	b5010000 	strlt	r0, [r1, #-0]

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e14:	00010d01 	andeq	r0, r1, r1, lsl #26
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e18:	0016f000 	andseq	pc, r6, r0
    2e1c:	00002800 	andeq	r2, r0, r0, lsl #16
    2e20:	a09c0100 	addsge	r0, ip, r0, lsl #2
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2e24:	24000005 	strcs	r0, [r0], #-5
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2e28:	00001340 	andeq	r1, r0, r0, asr #6
    2e2c:	a201b501 	andge	fp, r1, #4194304	; 0x400000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e30:	d0000000 	andle	r0, r0, r0
			c += ((uint32_t)a[j]) *
    2e34:	00000009 	andeq	r0, r0, r9
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2e38:	00125723 	andseq	r5, r2, r3, lsr #14
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2e3c:	01bf0100 			; <UNDEFINED> instruction: 0x01bf0100
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e40:	0000010d 	andeq	r0, r0, sp, lsl #2
	c = (c >> 7) * 19;
    2e44:	00001718 	andeq	r1, r0, r8, lsl r7
    2e48:	00000034 	andeq	r0, r0, r4, lsr r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e4c:	05cb9c01 	strbeq	r9, [fp, #3073]	; 0xc01
	c = (c >> 7) * 19;
    2e50:	40240000 	eormi	r0, r4, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e54:	01000013 	tsteq	r0, r3, lsl r0
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2e58:	00a201bf 			; <UNDEFINED> instruction: 0x00a201bf
		r[i] = c;
    2e5c:	09f10000 	ldmibeq	r1!, {}^	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e60:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
		c += r[i];
		r[i] = c;
		c >>= 8;
    2e64:	0000141e 	andeq	r1, r0, lr, lsl r4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e68:	4c01c801 	stcmi	8, cr12, [r1], {1}
    2e6c:	5c000017 	stcpl	0, cr0, [r0], {23}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2e70:	01000000 	mrseq	r0, (UNDEF: 0)
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2e74:	0006239c 	muleq	r6, ip, r3
		for (j = 0; j <= i; j++)
    2e78:	00692500 	rsbeq	r2, r9, r0, lsl #10
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e7c:	7301c901 	movwvc	ip, #6401	; 0x1901

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e80:	12000000 	andne	r0, r0, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e84:	2600000a 	strcs	r0, [r0], -sl

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e88:	000012be 			; <UNDEFINED> instruction: 0x000012be
    2e8c:	2301ca01 	movwcs	ip, #6657	; 0x1a01
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e90:	1b000006 	blne	2eb0 <f25519_sqrt+0x5fc>
    2e94:	0000176c 	andeq	r1, r0, ip, ror #14
    2e98:	000008eb 	andeq	r0, r0, fp, ror #17
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2e9c:	0000060f 	andeq	r0, r0, pc, lsl #12
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ea0:	0250011c 	subseq	r0, r0, #28, 2
    2ea4:	27000074 	smlsdxcs	r0, r4, r0, r0
    2ea8:	00001782 	andeq	r1, r0, r2, lsl #15

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2eac:	00000901 	andeq	r0, r0, r1, lsl #18
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2eb0:	0550011c 	ldrbeq	r0, [r0, #-284]	; 0x11c
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2eb4:	00750074 	rsbseq	r0, r5, r4, ror r0

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2eb8:	0a000022 	beq	2f48 <fprime_from_bytes+0x60>
    2ebc:	00009704 	andeq	r9, r0, r4, lsl #14
    2ec0:	04872800 	streq	r2, [r7], #2048	; 0x800
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2ec4:	51010000 	mrspl	r0, (UNDEF: 1)
    2ec8:	000000dc 	ldrdeq	r0, [r0], -ip
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2ecc:	000017a8 	andeq	r1, r0, r8, lsr #15
		c += r[i];
    2ed0:	00000254 	andeq	r0, r0, r4, asr r2
		r[i] = c;
    2ed4:	06d29c01 	ldrbeq	r9, [r2], r1, lsl #24
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2ed8:	e0290000 	eor	r0, r9, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    2edc:	01000011 	tsteq	r0, r1, lsl r0
	f25519_sub(i, i, y);

	/* r = avi */
	f25519_mul__distinct(x, v, a);
	f25519_mul__distinct(r, x, i);
}
    2ee0:	0000ad56 	andeq	sl, r0, r6, asr sp
    2ee4:	000a3100 	andeq	r3, sl, r0, lsl #2
}

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
    2ee8:	18ae2a00 	stmiane	lr!, {r9, fp, sp}
    2eec:	002a0000 	eoreq	r0, sl, r0
    2ef0:	06ad0000 	strteq	r0, [sp], r0
    2ef4:	182b0000 	stmdane	fp!, {}	; <UNPREDICTABLE>
static int prime_msb(const uint8_t *p)
{
	int i;
	uint8_t x;

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
    2ef8:	0100000b 	tsteq	r0, fp
    2efc:	044b0113 	strbeq	r0, [fp], #-275	; 0x113
    2f00:	91020000 	mrsls	r0, (UNDEF: 2)
		if (p[i])
    2f04:	65722564 	ldrbvs	r2, [r2, #-1380]!	; 0x564
			break;

	x = p[i];
	i <<= 3;
    2f08:	14010074 	strne	r0, [r1], #-116	; 0x74

	while (x) {
		x >>= 1;
		i++;
    2f0c:	00007301 	andeq	r7, r0, r1, lsl #6
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    2f10:	000a9100 	andeq	r9, sl, r0, lsl #2

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
    2f14:	18ba1b00 	ldmne	sl!, {r8, r9, fp, ip}
		x[i] = 0;
}

static inline int min_int(int a, int b)
{
	return a < b ? a : b;
    2f18:	091c0000 	ldmdbeq	ip, {}	; <UNPREDICTABLE>
    2f1c:	069a0000 	ldreq	r0, [sl], r0
void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
    2f20:	011c0000 	tsteq	ip, r0
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);
    2f24:	000c0551 	andeq	r0, ip, r1, asr r5
    2f28:	1c080080 	stcne	0, cr0, [r8], {128}	; 0x80
    2f2c:	7d025001 	stcvc	0, cr5, [r2, #-4]

	for (i = 0; i < preload_bytes; i++)
    2f30:	d2200004 	eorle	r0, r0, #4
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
    2f34:	41000018 	tstmi	r0, r8, lsl r0
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
    2f38:	20000009 	andcs	r0, r0, r9
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f3c:	000018d6 	ldrdeq	r1, [r0], -r6
    2f40:	00000954 	andeq	r0, r0, r4, asr r9
    2f44:	18042000 	stmdane	r4, {sp}
    2f48:	095c0000 	ldmdbeq	ip, {}^	; <UNPREDICTABLE>
    2f4c:	08200000 	stmdaeq	r0!, {}	; <UNPREDICTABLE>
    2f50:	64000018 	strvs	r0, [r0], #-24
    2f54:	20000009 	andcs	r0, r0, r9
    2f58:	0000184a 	andeq	r1, r0, sl, asr #16
    2f5c:	0000096c 	andeq	r0, r0, ip, ror #18
    2f60:	00187a20 	andseq	r7, r8, r0, lsr #20
    2f64:	0005cb00 	andeq	ip, r5, r0, lsl #22
    2f68:	e82c0000 	stmda	ip!, {}	; <UNPREDICTABLE>
    2f6c:	01000013 	tsteq	r0, r3, lsl r0
    2f70:	00ad01f0 	strdeq	r0, [sp], r0	; <UNPREDICTABLE>
    2f74:	00000000 	andeq	r0, r0, r0
    2f78:	000c0000 	andeq	r0, ip, r0
    2f7c:	9c010000 	stcls	0, cr0, [r1], {-0}
		n[i] = x[len - preload_bytes + i];
    2f80:	0012121e 	andseq	r1, r2, lr, lsl r2
    2f84:	01f50100 	mvnseq	r0, r0, lsl #2
    2f88:	00000000 	andeq	r0, r0, r0
    2f8c:	0000000c 	andeq	r0, r0, ip
    2f90:	070d9c01 	streq	r9, [sp, -r1, lsl #24]
    2f94:	152d0000 	strne	r0, [sp, #-0]!
    2f98:	01000014 	tsteq	r0, r4, lsl r0
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f9c:	00ad01f5 	strdeq	r0, [sp], r5	; <UNPREDICTABLE>
		n[i] = x[len - preload_bytes + i];
    2fa0:	50010000 	andpl	r0, r1, r0
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fa4:	0c2f2e00 	stceq	14, cr2, [pc], #-0	; 2fac <fprime_from_bytes+0xc4>
		n[i] = x[len - preload_bytes + i];
    2fa8:	fa010000 	blx	42fb0 <_etext+0x3b99c>
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fac:	0000dc01 	andeq	sp, r0, r1, lsl #24
    2fb0:	0019fc00 	andseq	pc, r9, r0, lsl #24
    2fb4:	00000c00 	andeq	r0, r0, r0, lsl #24
		n[i] = x[len - preload_bytes + i];
    2fb8:	2e9c0100 	fmlcse	f0, f4, f0
    2fbc:	0000122f 	andeq	r1, r0, pc, lsr #4
    2fc0:	dc01ff01 	stcle	15, cr15, [r1], {1}

	if (preload_bits) {
    2fc4:	00000000 	andeq	r0, r0, r0
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c |= ((uint16_t)x[i]) << n;
    2fc8:	1c000000 	stcne	0, cr0, [r0], {-0}
    2fcc:	01000000 	mrseq	r0, (UNDEF: 0)
		x[i] = c;
    2fd0:	0aea2f9c 	beq	ffa8ee48 <BootRAM+0xe9ff5e9>
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2fd4:	05010000 	streq	r0, [r1, #-0]
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    2fd8:	001a0802 	andseq	r0, sl, r2, lsl #16
	for (i = 0; i < preload_bytes; i++)
		n[i] = x[len - preload_bytes + i];

	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
    2fdc:	00000200 	andeq	r0, r0, r0, lsl #4
    2fe0:	309c0100 	addscc	r0, ip, r0, lsl #2
    2fe4:	000011eb 	andeq	r1, r0, fp, ror #3
    2fe8:	075c2801 	ldrbeq	r2, [ip, -r1, lsl #16]
    2fec:	03050000 	movweq	r0, #20480	; 0x5000
    2ff0:	200002c0 	andcs	r0, r0, r0, asr #5
	}

	for (i = rbits - 1; i >= 0; i--) {
    2ff4:	00009706 	andeq	r9, r0, r6, lsl #14
    2ff8:	13f43000 	mvnsne	r3, #0
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;
    2ffc:	29010000 	stmdbcs	r1, {}	; <UNPREDICTABLE>
    3000:	0000075c 	andeq	r0, r0, ip, asr r7
    3004:	02bc0305 	adcseq	r0, ip, #335544320	; 0x14000000
    3008:	1a302000 	bne	c0b010 <_etext+0xc039fc>
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    300c:	01000013 	tsteq	r0, r3, lsl r0
		c |= ((uint16_t)x[i]) << n;
    3010:	0007832a 	andeq	r8, r7, sl, lsr #6
		x[i] = c;
    3014:	c5030500 	strgt	r0, [r3, #-1280]	; 0x500
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3018:	0620000d 	strteq	r0, [r0], -sp
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    301c:	000002ea 	andeq	r0, r0, sl, ror #5

	for (i = rbits - 1; i >= 0; i--) {
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;

		shift_n_bits(n, 1);
		n[0] |= bit;
    3020:	0000ad17 	andeq	sl, r0, r7, lsl sp
    3024:	00079900 	andeq	r9, r7, r0, lsl #18
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3028:	00f43100 	rscseq	r3, r4, r0, lsl #2
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
    302c:	07ff0000 	ldrbeq	r0, [pc, r0]!
    3030:	124c3000 	subne	r3, ip, #0
		minusp[i] = c;
    3034:	33010000 	movwcc	r0, #4096	; 0x1000
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3038:	000007aa 	andeq	r0, r0, sl, lsr #15
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
    303c:	05bc0305 	ldreq	r0, [ip, #773]!	; 0x305
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3040:	88062000 	stmdahi	r6, {sp}

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    3044:	30000007 	andcc	r0, r0, r7
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    3048:	0000130a 	andeq	r1, r0, sl, lsl #6
    304c:	075c3501 	ldrbeq	r3, [ip, -r1, lsl #10]
    3050:	03050000 	movweq	r0, #20480	; 0x5000
    3054:	20000dc0 	andcs	r0, r0, r0, asr #27
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
    3058:	00126530 	andseq	r6, r2, r0, lsr r5
	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
	}

	for (i = rbits - 1; i >= 0; i--) {
    305c:	d1360100 	teqle	r6, r0, lsl #2
    3060:	05000007 	streq	r0, [r0, #-7]

		shift_n_bits(n, 1);
		n[0] |= bit;
		raw_try_sub(n, modulus);
	}
}
    3064:	000dbe03 	andeq	fp, sp, r3, lsl #28

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
    3068:	00a20620 	adceq	r0, r2, r0, lsr #12
	i <<= 3;

	while (x) {
    306c:	d0300000 	eorsle	r0, r0, r0
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
    3070:	01000012 	tsteq	r0, r2, lsl r0
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    3074:	0007d137 	andeq	sp, r7, r7, lsr r1
		n[i] = x[len - preload_bytes + i];
    3078:	bc030500 	cfstr32lt	mvfx0, [r3], {-0}
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    307c:	3220000d 	eorcc	r0, r0, #13
    3080:	000001e8 	andeq	r0, r0, r8, ror #3
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    3084:	07f2220a 	ldrbeq	r2, [r2, sl, lsl #4]!
    (b)[(i) + 2] = (uint8) ( (n) >>  8 );       \
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    3088:	040a0000 	streq	r0, [sl], #-0
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    308c:	0000024c 	andeq	r0, r0, ip, asr #4
void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    3090:	0000b133 	andeq	fp, r0, r3, lsr r1
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    3094:	732c0b00 	teqvc	ip, #0, 22
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    3098:	05000000 	streq	r0, [r0, #-0]
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    309c:	00048803 	andeq	r8, r4, r3, lsl #16
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    30a0:	128f3320 	addne	r3, pc, #32, 6	; 0x80000000
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    30a4:	2c010000 	stccs	0, cr0, [r1], {-0}
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    30a8:	0000081a 	andeq	r0, r0, sl, lsl r8
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    30ac:	0dcb0305 	stcleq	3, cr0, [fp, #20]
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    30b0:	dc062000 	stcle	0, cr2, [r6], {-0}
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
    30b4:	33000000 	movwcc	r0, #0
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;
    30b8:	00001406 	andeq	r1, r0, r6, lsl #8
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
}
    30bc:	08302b01 	ldmdaeq	r0!, {r0, r8, r9, fp, sp}
    30c0:	03050000 	movweq	r0, #20480	; 0x5000
    30c4:	20000dc4 	andcs	r0, r0, r4, asr #27
    30c8:	00028a06 	andeq	r8, r2, r6, lsl #20
    30cc:	00371700 	eorseq	r1, r7, r0, lsl #14
    30d0:	08450000 	stmdaeq	r5, {}^	; <UNPREDICTABLE>
    30d4:	f4180000 			; <UNDEFINED> instruction: 0xf4180000
    30d8:	1f000000 	svcne	0x00000000
    30dc:	12723300 	rsbsne	r3, r2, #0, 6

void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    30e0:	2e010000 	cdpcs	0, 0, cr0, cr1, cr0, {0}
    30e4:	00000835 	andeq	r0, r0, r5, lsr r8
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    30e8:	04ec0305 	strbteq	r0, [ip], #773	; 0x305
    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    30ec:	81172000 	tsthi	r7, r0
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    30f0:	66000000 	strvs	r0, [r0], -r0
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    30f4:	18000008 	stmdane	r0, {r3}
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30f8:	000000f4 	strdeq	r0, [r0], -r4
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    30fc:	da33005b 	ble	cc3270 <_etext+0xcbbc5c>
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3100:	01000011 	tsteq	r0, r1, lsl r0
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    3104:	0008562f 	andeq	r5, r8, pc, lsr #12
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3108:	90030500 	andls	r0, r3, r0, lsl #10
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    310c:	34200004 	strtcc	r0, [r0], #-4
    3110:	00787463 	rsbseq	r7, r8, r3, ror #8
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3114:	03823001 	orreq	r3, r2, #1
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3118:	03050000 	movweq	r0, #20480	; 0x5000
    311c:	2000050c 	andcs	r0, r0, ip, lsl #10
    3120:	0013be33 	andseq	fp, r3, r3, lsr lr
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3124:	993a0100 	ldmdbls	sl!, {r8}
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3128:	05000008 	streq	r0, [r0, #-8]
    312c:	00057403 	andeq	r7, r5, r3, lsl #8
    3130:	031a0620 	tsteq	sl, #32, 12	; 0x2000000
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3134:	f1350000 			; <UNDEFINED> instruction: 0xf1350000
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3138:	0d00000f 	stceq	0, cr0, [r0, #-60]	; 0xffffffc4
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    313c:	0000f219 	andeq	pc, r0, r9, lsl r2	; <UNPREDICTABLE>
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3140:	0008bd00 	andeq	fp, r8, r0, lsl #26
    3144:	00f20f00 	rscseq	r0, r2, r0, lsl #30
    3148:	730f0000 	movwvc	r0, #61440	; 0xf000
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    314c:	0f000000 	svceq	0x00000000
    3150:	000000e7 	andeq	r0, r0, r7, ror #1
    3154:	13273600 	teqne	r7, #0, 12
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3158:	14080000 	strne	r0, [r8], #-0
    315c:	000008ce 	andeq	r0, r0, lr, asr #17
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3160:	0008ce0f 	andeq	ip, r8, pc, lsl #28
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3164:	040a0000 	streq	r0, [sl], #-0
    3168:	00000382 	andeq	r0, r0, r2, lsl #7
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    316c:	000cb937 	andeq	fp, ip, r7, lsr r9
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3170:	01390c00 	teqeq	r9, r0, lsl #24
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3174:	00047338 	andeq	r7, r4, r8, lsr r3
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3178:	37830b00 	strcc	r0, [r3, r0, lsl #22]
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    317c:	00000c67 	andeq	r0, r0, r7, ror #24
    3180:	39012b0c 	stmdbcc	r1, {r2, r3, r8, r9, fp, sp}
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3184:	00000c40 	andeq	r0, r0, r0, asr #24
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3188:	dc01340c 	cfstrsle	mvf3, [r1], {12}
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    318c:	01000000 	mrseq	r0, (UNDEF: 0)
    3190:	0f000009 	svceq	0x00000009
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3194:	00000097 	muleq	r0, r7, r0
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3198:	0e1b3900 	cdpeq	9, 1, cr3, cr11, cr0, {0}
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    319c:	330c0000 	movwcc	r0, #49152	; 0xc000
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31a0:	0000dc01 	andeq	sp, r0, r1, lsl #24
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    31a4:	00091c00 	andeq	r1, r9, r0, lsl #24
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    31a8:	00970f00 	addseq	r0, r7, r0, lsl #30
    31ac:	970f0000 	strls	r0, [pc, -r0]
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31b0:	00000000 	andeq	r0, r0, r0
    31b4:	000b6c35 	andeq	r6, fp, r5, lsr ip
    31b8:	73670900 	cmnvc	r7, #0, 18
    31bc:	3b000000 	blcc	31c4 <sha256_process+0xe4>
    31c0:	0f000009 	svceq	0x00000009
    31c4:	0000093b 	andeq	r0, r0, fp, lsr r9
    31c8:	0000b70f 	andeq	fp, r0, pc, lsl #14
    31cc:	00dc0f00 	sbcseq	r0, ip, r0, lsl #30
    31d0:	0a000000 	beq	31d8 <sha256_process+0xf8>
    31d4:	00044b04 	andeq	r4, r4, r4, lsl #22
    31d8:	0ab33a00 	beq	fecd19e0 <BootRAM+0xdc42181>
    31dc:	3f0c0000 	svccc	0x000c0000
    31e0:	00095401 	andeq	r5, r9, r1, lsl #8
    31e4:	01020f00 	tsteq	r2, r0, lsl #30
    31e8:	003b0000 	eorseq	r0, fp, r0
    31ec:	00100337 	andseq	r0, r0, r7, lsr r3
    31f0:	01360c00 	teqeq	r6, r0, lsl #24
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    31f4:	000bc037 	andeq	ip, fp, r7, lsr r0
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31f8:	012f0c00 	teqeq	pc, r0, lsl #24
    31fc:	000e7137 	andeq	r7, lr, r7, lsr r1
    3200:	01370c00 	teqeq	r7, r0, lsl #24
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3204:	000eea3c 	andeq	lr, lr, ip, lsr sl
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3208:	013b0c00 	teqeq	fp, r0, lsl #24
    320c:	00000073 	andeq	r0, r0, r3, ror r0
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3210:	000a3300 	andeq	r3, sl, r0, lsl #6
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3214:	d1000400 	tstle	r0, r0, lsl #8
    3218:	0400000d 	streq	r0, [r0], #-13
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    321c:	0014a601 	andseq	sl, r4, r1, lsl #12
    3220:	14390100 	ldrtne	r0, [r9], #-256	; 0x100
    3224:	08930000 	ldmeq	r3, {}	; <UNPREDICTABLE>
    3228:	03300000 	teqeq	r0, #0
    322c:	00000000 	andeq	r0, r0, r0
    3230:	100e0000 	andne	r0, lr, r0
    3234:	01020000 	mrseq	r0, (UNDEF: 2)
    3238:	00081a06 	andeq	r1, r8, r6, lsl #20
    323c:	0ad90300 	beq	ff643e44 <BootRAM+0xe5b45e5>
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3240:	1c030000 	stcne	0, cr0, [r3], {-0}
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3244:	00000037 	andeq	r0, r0, r7, lsr r0
    3248:	18080102 	stmdane	r8, {r1, r8}
    324c:	02000008 	andeq	r0, r0, #8
    3250:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
    3254:	02020000 	andeq	r0, r2, #0
    3258:	00094907 	andeq	r4, r9, r7, lsl #18
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    325c:	05040200 	streq	r0, [r4, #-512]	; 0x200
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3260:	000004da 	ldrdeq	r0, [r0], -sl
    3264:	000abf03 	andeq	fp, sl, r3, lsl #30
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3268:	5e380300 	cdppl	3, 3, cr0, cr8, cr0, {0}
    326c:	02000000 	andeq	r0, r0, #0
    3270:	02520704 	subseq	r0, r2, #4, 14	; 0x100000
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3274:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3278:	0004d505 	andeq	sp, r4, r5, lsl #10
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    327c:	07080200 	streq	r0, [r8, -r0, lsl #4]

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3280:	0000024d 	andeq	r0, r0, sp, asr #4
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3284:	69050404 	stmdbvs	r5, {r2, sl}
    GET_UINT32( W[4],  data, 16 );
    3288:	0200746e 	andeq	r7, r0, #1845493760	; 0x6e000000
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    328c:	02570704 	subseq	r0, r7, #4, 14	; 0x100000
    3290:	db030000 	blle	c3298 <_etext+0xbbc84>
    3294:	0400000a 	streq	r0, [r0], #-10
    3298:	00002c2a 	andeq	r2, r0, sl, lsr #24

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    329c:	0ac10300 	beq	ff043ea4 <BootRAM+0xdfb4645>
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32a0:	42040000 	andmi	r0, r4, #0

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32a4:	00000053 	andeq	r0, r0, r3, asr r0
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32a8:	8b070402 	blhi	1c42b8 <_etext+0x1bcca4>
    32ac:	02000007 	andeq	r0, r0, #7
    32b0:	08210801 	stmdaeq	r1!, {r0, fp}
    32b4:	52050000 	andpl	r0, r5, #0
    32b8:	02000014 	andeq	r0, r0, #20
    32bc:	00c40322 	sbceq	r0, r4, r2, lsr #6

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32c0:	78060000 	stmdavc	r6, {}	; <UNPREDICTABLE>
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32c4:	c4220200 	strtgt	r0, [r2], #-512	; 0x200
    32c8:	06000000 	streq	r0, [r0], -r0
    32cc:	22020061 	andcs	r0, r2, #97	; 0x61
    32d0:	000000ca 	andeq	r0, r0, sl, asr #1

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32d4:	81040700 	tsthi	r4, r0, lsl #14
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32d8:	07000000 	streq	r0, [r0, -r0]

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32dc:	0000d004 	andeq	sp, r0, r4
    32e0:	00810800 	addeq	r0, r1, r0, lsl #16
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32e4:	a4050000 	strge	r0, [r5], #-0

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32e8:	01000015 	tsteq	r0, r5, lsl r0
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32ec:	0158012a 	cmpeq	r8, sl, lsr #2

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32f0:	78060000 	stmdavc	r6, {}	; <UNPREDICTABLE>
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32f4:	2a010035 	bcs	433d0 <_etext+0x3bdbc>
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32f8:	000000c4 	andeq	r0, r0, r4, asr #1
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32fc:	00357a06 	eorseq	r7, r5, r6, lsl #20
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3300:	00c42a01 	sbceq	r2, r4, r1, lsl #20

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3304:	78060000 	stmdavc	r6, {}	; <UNPREDICTABLE>

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3308:	2b010031 	blcs	433d4 <_etext+0x3bdc0>
    330c:	000000ca 	andeq	r0, r0, sl, asr #1
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3310:	00317a06 	eorseq	r7, r1, r6, lsl #20
    3314:	00ca2b01 	sbceq	r2, sl, r1, lsl #22

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3318:	78060000 	stmdavc	r6, {}	; <UNPREDICTABLE>
    331c:	2c010032 	stccs	0, cr0, [r1], {50}	; 0x32
    3320:	000000ca 	andeq	r0, r0, sl, asr #1
    3324:	00327a06 	eorseq	r7, r2, r6, lsl #20
    3328:	00ca2c01 	sbceq	r2, sl, r1, lsl #24
    332c:	78060000 	stmdavc	r6, {}	; <UNPREDICTABLE>
    3330:	2d010033 	stccs	0, cr0, [r1, #-204]	; 0xffffff34
    3334:	000000ca 	andeq	r0, r0, sl, asr #1
    3338:	00337a06 	eorseq	r7, r3, r6, lsl #20
    333c:	00ca2d01 	sbceq	r2, sl, r1, lsl #26
    3340:	64090000 	strvs	r0, [r9], #-0
    3344:	3d010061 	stccc	0, cr0, [r1, #-388]	; 0xfffffe7c
    3348:	00000158 	andeq	r0, r0, r8, asr r1
    334c:	00626309 	rsbeq	r6, r2, r9, lsl #6
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3350:	01583e01 	cmpeq	r8, r1, lsl #28

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3354:	61090000 	mrsvs	r0, (UNDEF: 9)
    3358:	583f0100 	ldmdapl	pc!, {r8}	; <UNPREDICTABLE>
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    335c:	09000001 	stmdbeq	r0, {r0}
    3360:	40010062 	andmi	r0, r1, r2, rrx

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3364:	00000158 	andeq	r0, r0, r8, asr r1
    3368:	00810a00 	addeq	r0, r1, r0, lsl #20
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    336c:	01680000 	cmneq	r8, r0
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3370:	970b0000 	strls	r0, [fp, -r0]

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3374:	1f000000 	svcne	0x00000000
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3378:	14480500 	strbne	r0, [r8], #-1280	; 0x500
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    337c:	0c010000 	stceq	0, cr0, [r1], {-0}
    3380:	0001c701 	andeq	ip, r1, r1, lsl #14
    3384:	33780600 	cmncc	r8, #0, 12
    3388:	c40c0100 	strgt	r0, [ip], #-256	; 0x100
    338c:	06000000 	streq	r0, [r0], -r0
    3390:	0100337a 	tsteq	r0, sl, ror r3
    3394:	0000c40c 	andeq	ip, r0, ip, lsl #8

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3398:	31780600 	cmncc	r8, r0, lsl #12
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    339c:	ca0d0100 	bgt	3437a4 <_etext+0x33c190>
    33a0:	06000000 	streq	r0, [r0], -r0
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33a4:	0100317a 	tsteq	r0, sl, ror r1
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33a8:	0000ca0d 	andeq	ip, r0, sp, lsl #20
    33ac:	14840c00 	strne	r0, [r4], #3072	; 0xc00
    33b0:	16010000 	strne	r0, [r1], -r0
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33b4:	00000158 	andeq	r0, r0, r8, asr r1
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33b8:	0014940c 	andseq	r9, r4, ip, lsl #8
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33bc:	58170100 	ldmdapl	r7, {r8}
    33c0:	0c000001 	stceq	0, cr0, [r0], {1}
    33c4:	0000154f 	andeq	r1, r0, pc, asr #10
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33c8:	01581801 	cmpeq	r8, r1, lsl #16
    33cc:	61090000 	mrsvs	r0, (UNDEF: 9)
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33d0:	58190100 	ldmdapl	r9, {r8}
    33d4:	00000001 	andeq	r0, r0, r1
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33d8:	0014990d 	andseq	r9, r4, sp, lsl #18
    33dc:	00530100 	subseq	r0, r3, r0, lsl #2
    33e0:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33e4:	01000002 	tsteq	r0, r2
    33e8:	00095c9c 	muleq	r9, ip, ip
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33ec:	159d0e00 	ldrne	r0, [sp, #3584]	; 0xe00
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33f0:	53010000 	movwpl	r0, #4096	; 0x1000
    33f4:	000000c4 	andeq	r0, r0, r4, asr #1
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33f8:	00000aaf 	andeq	r0, r0, pc, lsr #21
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    33fc:	0100710f 	tsteq	r0, pc, lsl #2
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3400:	0000ca53 	andeq	ip, r0, r3, asr sl
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3404:	000adb00 	andeq	sp, sl, r0, lsl #22
    3408:	00650f00 	rsbeq	r0, r5, r0, lsl #30
    340c:	00ca5301 	sbceq	r5, sl, r1, lsl #6
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3410:	0b070000 	bleq	1c3418 <_etext+0x1bbe04>
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3414:	78100000 	ldmdavc	r0, {}	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3418:	5601006d 	strpl	r0, [r1], -sp, rrx
    341c:	00000158 	andeq	r0, r0, r8, asr r1
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3420:	7da89103 	stfvcd	f1, [r8, #12]!
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3424:	006d7a10 	rsbeq	r7, sp, r0, lsl sl
    3428:	01585701 	cmpeq	r8, r1, lsl #14
    342c:	91030000 	mrsls	r0, (UNDEF: 3)
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3430:	78107dc8 	ldmdavc	r0, {r3, r6, r7, r8, sl, fp, ip, sp, lr}
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3434:	0100316d 	tsteq	r0, sp, ror #2
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3438:	0001585a 	andeq	r5, r1, sl, asr r8
    343c:	e8910300 	ldm	r1, {r8, r9}
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3440:	6d7a107d 	ldclvs	0, cr1, [sl, #-500]!	; 0xfffffe0c
    3444:	5b010031 	blpl	43510 <_etext+0x3befc>
    3448:	00000158 	andeq	r0, r0, r8, asr r1
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    344c:	7e889103 	sinvce	f1, f3
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3450:	01006911 	tsteq	r0, r1, lsl r9
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3454:	0000735d 	andeq	r7, r0, sp, asr r3
    3458:	000b3300 	andeq	r3, fp, r0, lsl #6
    345c:	00a51200 	adceq	r1, r5, r0, lsl #4
    3460:	00000000 	andeq	r0, r0, r0
    3464:	02b00000 	adcseq	r0, r0, #0
    3468:	60010000 	andvs	r0, r1, r0
    346c:	00000272 	andeq	r0, r0, r2, ror r2
    3470:	0000ba13 	andeq	fp, r0, r3, lsl sl
    3474:	000b5e00 	andeq	r5, fp, r0, lsl #28
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3478:	00b11300 	adcseq	r1, r1, r0, lsl #6
    347c:	0b7f0000 	bleq	1fc3484 <_etext+0x1fbbe70>
    3480:	14000000 	strne	r0, [r0], #-0
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3484:	000002e0 	andeq	r0, r0, r0, ror #5
    3488:	0000090e 	andeq	r0, r0, lr, lsl #18
    348c:	74696211 	strbtvc	r6, [r9], #-529	; 0x211
    3490:	5c630100 	stfple	f0, [r3], #-0
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3494:	ae000009 	cdpge	0, 0, cr0, cr0, cr9, {0}
    3498:	1000000b 	andne	r0, r0, fp
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    349c:	00736d78 	rsbseq	r6, r3, r8, ror sp
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34a0:	01586401 	cmpeq	r8, r1, lsl #8
    34a4:	91030000 	mrsls	r0, (UNDEF: 3)
    34a8:	7a107ea8 	bvc	422f50 <_etext+0x41b93c>
    34ac:	0100736d 	tsteq	r0, sp, ror #6
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34b0:	00015865 	andeq	r5, r1, r5, ror #16
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34b4:	c8910300 	ldmgt	r1, {r8, r9}
    34b8:	00d5127e 	sbcseq	r1, r5, lr, ror r2
    34bc:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34c0:	02f80000 	rscseq	r0, r8, #0
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34c4:	68010000 	stmdavs	r1, {}	; <UNPREDICTABLE>
    34c8:	000004b7 			; <UNDEFINED> instruction: 0x000004b7
    34cc:	0000ff15 	andeq	pc, r0, r5, lsl pc	; <UNPREDICTABLE>
    34d0:	01271300 	teqeq	r7, r0, lsl #6
    34d4:	0bc10000 	bleq	ff0434dc <BootRAM+0xdfb3c7d>
    34d8:	1d130000 	ldcne	0, cr0, [r3, #-0]
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34dc:	30000001 	andcc	r0, r0, r1
    34e0:	1300000c 	movwne	r0, #12
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34e4:	00000113 	andeq	r0, r0, r3, lsl r1
    34e8:	00000c86 	andeq	r0, r0, r6, lsl #25
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34ec:	00010913 	andeq	r0, r1, r3, lsl r9
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34f0:	000cf500 	andeq	pc, ip, r0, lsl #10
    34f4:	00f51300 	rscseq	r1, r5, r0, lsl #6
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34f8:	0d240000 	stceq	0, cr0, [r4, #-0]
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34fc:	eb130000 	bl	4c3504 <_etext+0x4bbef0>
    3500:	c1000000 	mrsgt	r0, (UNDEF: 0)
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3504:	1300000b 	movwne	r0, #11
    3508:	000000e1 	andeq	r0, r0, r1, ror #1
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    350c:	00000c30 	andeq	r0, r0, r0, lsr ip
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3510:	0002f816 	andeq	pc, r2, r6, lsl r8	; <UNPREDICTABLE>
    GET_UINT32( W[9],  data, 36 );
    3514:	01311700 	teqeq	r1, r0, lsl #14
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3518:	91030000 	mrsls	r0, (UNDEF: 3)
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    351c:	3b177ee8 	blcc	5e30c4 <_etext+0x5dbab0>
    3520:	03000001 	movweq	r0, #1
    3524:	177f8891 			; <UNDEFINED> instruction: 0x177f8891
    3528:	00000145 	andeq	r0, r0, r5, asr #2
    352c:	7fa89103 	svcvc	0x00a89103
    3530:	00014e17 	andeq	r4, r1, r7, lsl lr
    3534:	48910200 	ldmmi	r1, {r9}
    3538:	00000018 	andeq	r0, r0, r8, lsl r0
    353c:	00098700 	andeq	r8, r9, r0, lsl #14
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3540:	00034900 	andeq	r4, r3, r0, lsl #18
    3544:	52011900 	andpl	r1, r1, #0, 18
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3548:	7dc89103 	stfvcp	f1, [r8, #12]
    354c:	02510119 	subseq	r0, r1, #1073741830	; 0x40000006
    3550:	0119007d 	tsteq	r9, sp, ror r0
    3554:	a8910350 	ldmge	r1, {r4, r6, r8, r9}
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3558:	0018007f 	andseq	r0, r8, pc, ror r0
    355c:	a2000000 	andge	r0, r0, #0
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3560:	6b000009 	blvs	358c <sha256_process+0x4ac>
    3564:	19000003 	stmdbne	r0, {r0, r1}
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3568:	91035201 	tstls	r3, r1, lsl #4
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    356c:	01197e88 	tsteq	r9, r8, lsl #29
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3570:	e8910351 	ldm	r1, {r0, r4, r6, r8, r9}
    3574:	5001197d 	andpl	r1, r1, sp, ror r9
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3578:	00489102 	subeq	r9, r8, r2, lsl #2
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    357c:	00000018 	andeq	r0, r0, r8, lsl r0
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3580:	0009bd00 	andeq	fp, r9, r0, lsl #26
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3584:	00038d00 	andeq	r8, r3, r0, lsl #26
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3588:	52011900 	andpl	r1, r1, #0, 18
    358c:	19489102 	stmdbne	r8, {r1, r8, ip, pc}^
    3590:	91035101 	tstls	r3, r1, lsl #2
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3594:	01197fa8 	tsteq	r9, r8, lsr #31
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3598:	e8910350 	ldm	r1, {r4, r6, r8, r9}
    359c:	0018007e 	andseq	r0, r8, lr, ror r0
    35a0:	a2000000 	andge	r0, r0, #0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35a4:	ae000009 	cdpge	0, 0, cr0, cr0, cr9, {0}
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35a8:	19000003 	stmdbne	r0, {r0, r1}
    35ac:	91035201 	tstls	r3, r1, lsl #4
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35b0:	01197dc8 	tsteq	r9, r8, asr #27
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35b4:	007d0251 	rsbseq	r0, sp, r1, asr r2
    35b8:	02500119 	subseq	r0, r0, #1073741830	; 0x40000006
    35bc:	18004891 	stmdane	r0, {r0, r4, r7, fp, lr}
    35c0:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35c4:	00000987 	andeq	r0, r0, r7, lsl #19
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35c8:	000003d1 	ldrdeq	r0, [r0], -r1
    35cc:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    35d0:	197e8891 	ldmdbne	lr!, {r0, r4, r7, fp, pc}^
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35d4:	91035101 	tstls	r3, r1, lsl #2
    35d8:	01197de8 	tsteq	r9, r8, ror #27
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35dc:	a8910350 	ldmge	r1, {r4, r6, r8, r9}
    35e0:	0018007f 	andseq	r0, r8, pc, ror r0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35e4:	bd000000 	stclt	0, cr0, [r0, #-0]
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35e8:	f3000009 	vhadd.u8	d0, d0, d9
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35ec:	19000003 	stmdbne	r0, {r0, r1}
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35f0:	91025201 	tstls	r2, r1, lsl #4
    35f4:	51011948 	tstpl	r1, r8, asr #18
    35f8:	7fa89103 	svcvc	0x00a89103
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35fc:	03500119 	cmpeq	r0, #1073741830	; 0x40000006
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3600:	007f8891 			; <UNDEFINED> instruction: 0x007f8891
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3604:	00000018 	andeq	r0, r0, r8, lsl r0
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3608:	00098700 	andeq	r8, r9, r0, lsl #14
    360c:	00041600 	andeq	r1, r4, r0, lsl #12
    3610:	52011900 	andpl	r1, r1, #0, 18
    3614:	7f889103 	svcvc	0x00889103
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3618:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    361c:	197ee891 	ldmdbne	lr!, {r0, r4, r7, fp, sp, lr, pc}^
    3620:	91035001 	tstls	r3, r1
    3624:	18007fa8 	stmdane	r0, {r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3628:	00000000 	andeq	r0, r0, r0
    362c:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3630:	00000438 	andeq	r0, r0, r8, lsr r4
    3634:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3638:	197fa891 	ldmdbne	pc!, {r0, r4, r7, fp, sp, pc}^	; <UNPREDICTABLE>
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    363c:	91035101 	tstls	r3, r1, lsl #2
    3640:	01197fa8 	tsteq	r9, r8, lsr #31
    3644:	48910250 	ldmmi	r1, {r4, r6, r9}
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3648:	00001800 	andeq	r1, r0, r0, lsl #16
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    364c:	09bd0000 	ldmibeq	sp!, {}	; <UNPREDICTABLE>
    3650:	04530000 	ldrbeq	r0, [r3], #-0
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3654:	01190000 	tsteq	r9, r0
    3658:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    365c:	03500119 	cmpeq	r0, #1073741830	; 0x40000006
    3660:	007de891 			; <UNDEFINED> instruction: 0x007de891
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3664:	00000018 	andeq	r0, r0, r8, lsl r0
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3668:	0009a200 	andeq	sl, r9, r0, lsl #4
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    366c:	00047600 	andeq	r7, r4, r0, lsl #12
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3670:	52011900 	andpl	r1, r1, #0, 18
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3674:	7f889103 	svcvc	0x00889103
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3678:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    367c:	197ee891 	ldmdbne	lr!, {r0, r4, r7, fp, sp, lr, pc}^
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3680:	91035001 	tstls	r3, r1
    3684:	18007fa8 	stmdane	r0, {r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    3688:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    368c:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3690:	00000498 	muleq	r0, r8, r4
    3694:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    3698:	197fa891 	ldmdbne	pc!, {r0, r4, r7, fp, sp, pc}^	; <UNPREDICTABLE>
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    369c:	91035101 	tstls	r3, r1, lsl #2
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36a0:	01197fa8 	tsteq	r9, r8, lsr #31
    36a4:	48910250 	ldmmi	r1, {r4, r6, r9}
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36a8:	00001a00 	andeq	r1, r0, r0, lsl #20
    36ac:	09bd0000 	ldmibeq	sp!, {}	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36b0:	01190000 	tsteq	r9, r0
    36b4:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    36b8:	02510119 	subseq	r0, r1, #1073741830	; 0x40000006
    36bc:	01190076 	tsteq	r9, r6, ror r0
    36c0:	88910350 	ldmhi	r1, {r4, r6, r8, r9}
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36c4:	0000007e 	andeq	r0, r0, lr, ror r0
    36c8:	0001681b 	andeq	r6, r1, fp, lsl r8
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36cc:	00000000 	andeq	r0, r0, r0
    36d0:	00006400 	andeq	r6, r0, r0, lsl #8
    36d4:	69690100 	stmdbvs	r9!, {r8}^
    36d8:	13000006 	movwne	r0, #6
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36dc:	00000192 	muleq	r0, r2, r1
    36e0:	00000c86 	andeq	r0, r0, r6, lsl #25
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36e4:	00018813 	andeq	r8, r1, r3, lsl r8
    36e8:	000cf500 	andeq	pc, ip, r0, lsl #10
    36ec:	017e1300 	cmneq	lr, r0, lsl #6
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36f0:	0c860000 	stceq	0, cr0, [r6], {0}
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36f4:	74130000 	ldrvc	r0, [r3], #-0
    36f8:	f5000001 			; <UNDEFINED> instruction: 0xf5000001
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36fc:	1c00000c 	stcne	0, cr0, [r0], {12}
    3700:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3704:	00000064 	andeq	r0, r0, r4, rrx
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3708:	00019c17 	andeq	r9, r1, r7, lsl ip
    370c:	e8910300 	ldm	r1, {r8, r9}
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3710:	01a7177e 			; <UNDEFINED> instruction: 0x01a7177e
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3714:	91030000 	mrsls	r0, (UNDEF: 3)
    3718:	b2177f88 	andslt	r7, r7, #136, 30	; 0x220
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    371c:	03000001 	movweq	r0, #1
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3720:	177fa891 			; <UNDEFINED> instruction: 0x177fa891
    3724:	000001bd 			; <UNDEFINED> instruction: 0x000001bd
    3728:	18489102 	stmdane	r8, {r1, r8, ip, pc}^
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    372c:	00000000 	andeq	r0, r0, r0
    3730:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3734:	0000053b 	andeq	r0, r0, fp, lsr r5
    3738:	02520119 	subseq	r0, r2, #1073741830	; 0x40000006
    373c:	0119007d 	tsteq	r9, sp, ror r0
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3740:	007d0251 	rsbseq	r0, sp, r1, asr r2
    3744:	03500119 	cmpeq	r0, #1073741830	; 0x40000006
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3748:	007ee891 			; <UNDEFINED> instruction: 0x007ee891
    374c:	00000018 	andeq	r0, r0, r8, lsl r0
    3750:	0009bd00 	andeq	fp, r9, r0, lsl #26
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3754:	00055e00 	andeq	r5, r5, r0, lsl #28
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3758:	52011900 	andpl	r1, r1, #0, 18
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    375c:	7dc89103 	stfvcp	f1, [r8, #12]
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3760:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3764:	197dc891 	ldmdbne	sp!, {r0, r4, r7, fp, lr, pc}^
    3768:	91035001 	tstls	r3, r1
    376c:	18007f88 	stmdane	r0, {r3, r7, r8, r9, sl, fp, ip, sp, lr}
    3770:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3774:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3778:	00000580 	andeq	r0, r0, r0, lsl #11
    377c:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3780:	197dc891 	ldmdbne	sp!, {r0, r4, r7, fp, lr, pc}^
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3784:	7d025101 	stfvcs	f5, [r2, #-4]
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3788:	50011900 	andpl	r1, r1, r0, lsl #18
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    378c:	7fa89103 	svcvc	0x00a89103
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3790:	00001800 	andeq	r1, r0, r0, lsl #16
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3794:	09a20000 	stmibeq	r2!, {}	; <UNPREDICTABLE>
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3798:	05a20000 	streq	r0, [r2, #0]!
    379c:	01190000 	tsteq	r9, r0
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37a0:	88910352 	ldmhi	r1, {r1, r4, r6, r8, r9}
    37a4:	5101197f 	tstpl	r1, pc, ror r9
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    37a8:	7ee89103 	urdvce	f1, f3
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37ac:	02500119 	subseq	r0, r0, #1073741830	; 0x40000006
    37b0:	18004891 	stmdane	r0, {r0, r4, r7, fp, lr}
    37b4:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    37b8:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37bc:	000005c2 	andeq	r0, r0, r2, asr #11
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    37c0:	02520119 	subseq	r0, r2, #1073741830	; 0x40000006
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37c4:	01194891 			; <UNDEFINED> instruction: 0x01194891
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37c8:	48910251 	ldmmi	r1, {r0, r4, r6, r9}
    37cc:	02500119 	subseq	r0, r0, #1073741830	; 0x40000006
    37d0:	1800007d 	stmdane	r0, {r0, r2, r3, r4, r5, r6}
    37d4:	00000000 	andeq	r0, r0, r0
    37d8:	000009d8 	ldrdeq	r0, [r0], -r8
    37dc:	000005e6 	andeq	r0, r0, r6, ror #11
    37e0:	05520119 	ldrbeq	r0, [r2, #-281]	; 0x119
    37e4:	076d060c 	strbeq	r0, [sp, -ip, lsl #12]!
    37e8:	51011900 	tstpl	r1, r0, lsl #18
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    37ec:	7fa89103 	svcvc	0x00a89103
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37f0:	02500119 	subseq	r0, r0, #1073741830	; 0x40000006
    37f4:	18004891 	stmdane	r0, {r0, r4, r7, fp, lr}
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    37f8:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37fc:	00000987 	andeq	r0, r0, r7, lsl #19
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3800:	00000607 	andeq	r0, r0, r7, lsl #12
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3804:	02520119 	subseq	r0, r2, #1073741830	; 0x40000006
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3808:	01194891 			; <UNDEFINED> instruction: 0x01194891
    380c:	e8910351 	ldm	r1, {r0, r4, r6, r8, r9}
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3810:	5001197e 	andpl	r1, r1, lr, ror r9
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3814:	00489102 	subeq	r9, r8, r2, lsl #2
    3818:	00000018 	andeq	r0, r0, r8, lsl r0
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    381c:	00098700 	andeq	r8, r9, r0, lsl #14
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3820:	00062800 	andeq	r2, r6, r0, lsl #16
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3824:	52011900 	andpl	r1, r1, #0, 18
    3828:	19489102 	stmdbne	r8, {r1, r8, ip, pc}^
    382c:	91035101 	tstls	r3, r1, lsl #2
    3830:	01197f88 	tsteq	r9, r8, lsl #31
    3834:	48910250 	ldmmi	r1, {r4, r6, r9}
    3838:	00001800 	andeq	r1, r0, r0, lsl #16
    383c:	09bd0000 	ldmibeq	sp!, {}	; <UNPREDICTABLE>
    3840:	064a0000 	strbeq	r0, [sl], -r0
    3844:	01190000 	tsteq	r9, r0
    3848:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    384c:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    3850:	197fa891 	ldmdbne	pc!, {r0, r4, r7, fp, sp, pc}^	; <UNPREDICTABLE>
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3854:	91035001 	tstls	r3, r1
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3858:	1a007ee8 	bne	23400 <_etext+0x1bdec>
    385c:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3860:	000009d8 	ldrdeq	r0, [r0], -r8
    3864:	01520119 	cmpeq	r2, r9, lsl r1
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3868:	51011934 	tstpl	r1, r4, lsr r9
    386c:	7ee89103 	urdvce	f1, f3
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3870:	03500119 	cmpeq	r0, #1073741830	; 0x40000006
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3874:	007dc891 			; <UNDEFINED> instruction: 0x007dc891
    3878:	d5120000 	ldrle	r0, [r2, #-0]
    387c:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3880:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3884:	01000003 	tsteq	r0, r3
    3888:	0008706c 	andeq	r7, r8, ip, rrx
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    388c:	01271500 	teqeq	r7, r0, lsl #10
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3890:	1d130000 	ldcne	0, cr0, [r3, #-0]
    3894:	24000001 	strcs	r0, [r0], #-1
    3898:	1300000d 	movwne	r0, #13
    389c:	00000113 	andeq	r0, r0, r3, lsl r1
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38a0:	00000c86 	andeq	r0, r0, r6, lsl #25
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    38a4:	00010913 	andeq	r0, r1, r3, lsl r9
    38a8:	000cf500 	andeq	pc, ip, r0, lsl #10
    38ac:	00ff1300 	rscseq	r1, pc, r0, lsl #6
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38b0:	0bc10000 	bleq	ff0438b8 <BootRAM+0xdfb4059>
    38b4:	f5130000 			; <UNDEFINED> instruction: 0xf5130000
    38b8:	30000000 	andcc	r0, r0, r0
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    38bc:	1300000c 	movwne	r0, #12
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38c0:	000000eb 	andeq	r0, r0, fp, ror #1
    38c4:	00000d45 	andeq	r0, r0, r5, asr #26
    38c8:	0000e113 	andeq	lr, r0, r3, lsl r1
    38cc:	000d9b00 	andeq	r9, sp, r0, lsl #22
    38d0:	03181600 	tsteq	r8, #0, 12
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38d4:	31170000 	tstcc	r7, r0
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38d8:	03000001 	movweq	r0, #1
    38dc:	177ee891 			; <UNDEFINED> instruction: 0x177ee891
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38e0:	0000013b 	andeq	r0, r0, fp, lsr r1
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38e4:	7f889103 	svcvc	0x00889103
    38e8:	00014517 	andeq	r4, r1, r7, lsl r5
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38ec:	a8910300 	ldmge	r1, {r8, r9}
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38f0:	014e177f 	hvceq	57727	; 0xe17f
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38f4:	91020000 	mrsls	r0, (UNDEF: 2)
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38f8:	00001848 	andeq	r1, r0, r8, asr #16
    38fc:	09870000 	stmibeq	r7, {}	; <UNPREDICTABLE>
    3900:	070a0000 	streq	r0, [sl, -r0]
    3904:	01190000 	tsteq	r9, r0
    3908:	c8910352 	ldmgt	r1, {r1, r4, r6, r8, r9}
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    390c:	5101197d 	tstpl	r1, sp, ror r9
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3910:	19007d02 	stmdbne	r0, {r1, r8, sl, fp, ip, sp, lr}
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3914:	91035001 	tstls	r3, r1
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3918:	18007fa8 	stmdane	r0, {r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    391c:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3920:	000009a2 	andeq	r0, r0, r2, lsr #19
    3924:	00000724 	andeq	r0, r0, r4, lsr #14
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3928:	02510119 	subseq	r0, r1, #1073741830	; 0x40000006
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    392c:	01190076 	tsteq	r9, r6, ror r0
    3930:	48910250 	ldmmi	r1, {r4, r6, r9}
    3934:	00001800 	andeq	r1, r0, r0, lsl #16
    3938:	09bd0000 	ldmibeq	sp!, {}	; <UNPREDICTABLE>
    393c:	07460000 	strbeq	r0, [r6, -r0]
    3940:	01190000 	tsteq	r9, r0
    3944:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    3948:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    394c:	197fa891 	ldmdbne	pc!, {r0, r4, r7, fp, sp, pc}^	; <UNPREDICTABLE>
    3950:	91035001 	tstls	r3, r1
    3954:	18007ee8 	stmdane	r0, {r3, r5, r6, r7, r9, sl, fp, ip, sp, lr}
    3958:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    395c:	000009a2 	andeq	r0, r0, r2, lsr #19
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3960:	00000767 	andeq	r0, r0, r7, ror #14
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3964:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3968:	197dc891 	ldmdbne	sp!, {r0, r4, r7, fp, lr, pc}^
    396c:	7d025101 	stfvcs	f5, [r2, #-4]
    3970:	50011900 	andpl	r1, r1, r0, lsl #18
    3974:	00489102 	subeq	r9, r8, r2, lsl #2
    3978:	00000018 	andeq	r0, r0, r8, lsl r0
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    397c:	00098700 	andeq	r8, r9, r0, lsl #14
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3980:	00078200 	andeq	r8, r7, r0, lsl #4
    3984:	51011900 	tstpl	r1, r0, lsl #18
    3988:	19007602 	stmdbne	r0, {r1, r9, sl, ip, sp, lr}
    398c:	91035001 	tstls	r3, r1
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3990:	18007fa8 	stmdane	r0, {r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    3994:	00000000 	andeq	r0, r0, r0
    3998:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    399c:	000007a4 	andeq	r0, r0, r4, lsr #15
    39a0:	02520119 	subseq	r0, r2, #1073741830	; 0x40000006
    39a4:	01194891 			; <UNDEFINED> instruction: 0x01194891
    39a8:	a8910351 	ldmge	r1, {r0, r4, r6, r8, r9}
    39ac:	5001197f 	andpl	r1, r1, pc, ror r9
    39b0:	7f889103 	svcvc	0x00889103
    39b4:	00001800 	andeq	r1, r0, r0, lsl #16
    39b8:	09870000 	stmibeq	r7, {}	; <UNPREDICTABLE>
    39bc:	07c70000 	strbeq	r0, [r7, r0]
    39c0:	01190000 	tsteq	r9, r0
    39c4:	88910352 	ldmhi	r1, {r1, r4, r6, r8, r9}
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39c8:	5101197f 	tstpl	r1, pc, ror r9
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39cc:	7ee89103 	urdvce	f1, f3
    39d0:	03500119 	cmpeq	r0, #1073741830	; 0x40000006
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39d4:	007fa891 			; <UNDEFINED> instruction: 0x007fa891
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39d8:	00000018 	andeq	r0, r0, r8, lsl r0
    39dc:	0009bd00 	andeq	fp, r9, r0, lsl #26
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39e0:	0007e900 	andeq	lr, r7, r0, lsl #18
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39e4:	52011900 	andpl	r1, r1, #0, 18
    39e8:	7fa89103 	svcvc	0x00a89103
    39ec:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    39f0:	197fa891 	ldmdbne	pc!, {r0, r4, r7, fp, sp, pc}^	; <UNPREDICTABLE>
    39f4:	91025001 	tstls	r2, r1
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39f8:	00180048 	andseq	r0, r8, r8, asr #32
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39fc:	bd000000 	stclt	0, cr0, [r0, #-0]
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a00:	0b000009 	bleq	3a2c <sha256_process+0x94c>
    3a04:	19000008 	stmdbne	r0, {r3}
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3a08:	91025201 	tstls	r2, r1, lsl #4
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a0c:	51011948 	tstpl	r1, r8, asr #18
    3a10:	7e889103 	sinvce	f1, f3
    3a14:	03500119 	cmpeq	r0, #1073741830	; 0x40000006
    3a18:	007ea891 			; <UNDEFINED> instruction: 0x007ea891
    3a1c:	00000018 	andeq	r0, r0, r8, lsl r0
    3a20:	0009a200 	andeq	sl, r9, r0, lsl #4
    3a24:	00082e00 	andeq	r2, r8, r0, lsl #28
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3a28:	52011900 	andpl	r1, r1, #0, 18
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a2c:	7f889103 	svcvc	0x00889103
    3a30:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    3a34:	197ee891 	ldmdbne	lr!, {r0, r4, r7, fp, sp, lr, pc}^
    3a38:	91035001 	tstls	r3, r1
    3a3c:	18007fa8 	stmdane	r0, {r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    3a40:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a44:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a48:	00000850 	andeq	r0, r0, r0, asr r8
    3a4c:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    3a50:	197fa891 	ldmdbne	pc!, {r0, r4, r7, fp, sp, pc}^	; <UNPREDICTABLE>
    3a54:	91035101 	tstls	r3, r1, lsl #2
    3a58:	01197fa8 	tsteq	r9, r8, lsr #31
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a5c:	48910250 	ldmmi	r1, {r4, r6, r9}
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a60:	00001a00 	andeq	r1, r0, r0, lsl #20
    3a64:	09bd0000 	ldmibeq	sp!, {}	; <UNPREDICTABLE>
    3a68:	01190000 	tsteq	r9, r0
    3a6c:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    3a70:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a74:	197de891 	ldmdbne	sp!, {r0, r4, r7, fp, sp, lr, pc}^
    3a78:	91035001 	tstls	r3, r1
    3a7c:	00007ec8 	andeq	r7, r0, r8, asr #29
    3a80:	00001800 	andeq	r1, r0, r0, lsl #16
    3a84:	09f30000 	ldmibeq	r3!, {}^	; <UNPREDICTABLE>
    3a88:	08980000 	ldmeq	r8, {}	; <UNPREDICTABLE>
    3a8c:	01190000 	tsteq	r9, r0
    3a90:	00750253 	rsbseq	r0, r5, r3, asr r2
    3a94:	02520119 	subseq	r0, r2, #1073741830	; 0x40000006
    3a98:	0119007d 	tsteq	r9, sp, ror r0
    3a9c:	e8910351 	ldm	r1, {r0, r4, r6, r8, r9}
    3aa0:	5001197d 	andpl	r1, r1, sp, ror r9
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3aa4:	7de89103 	stfvcp	f1, [r8, #12]!
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3aa8:	00001800 	andeq	r1, r0, r0, lsl #16
    3aac:	09f30000 	ldmibeq	r3!, {}^	; <UNPREDICTABLE>
    3ab0:	08c10000 	stmiaeq	r1, {}^	; <UNPREDICTABLE>
    3ab4:	01190000 	tsteq	r9, r0
    3ab8:	00750253 	rsbseq	r0, r5, r3, asr r2
    3abc:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ac0:	197dc891 	ldmdbne	sp!, {r0, r4, r7, fp, lr, pc}^
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3ac4:	91035101 	tstls	r3, r1, lsl #2
    3ac8:	01197e88 	tsteq	r9, r8, lsl #29
    3acc:	88910350 	ldmhi	r1, {r4, r6, r8, r9}
    3ad0:	0018007e 	andseq	r0, r8, lr, ror r0
    3ad4:	f3000000 	vhadd.u8	d0, d0, d0
    3ad8:	e8000009 	stmda	r0, {r0, r3}
    3adc:	19000008 	stmdbne	r0, {r3}
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ae0:	75025301 	strvc	r5, [r2, #-769]	; 0x301
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3ae4:	52011900 	andpl	r1, r1, #0, 18
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ae8:	7ea89103 	tanvce	f1, f3
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3aec:	02510119 	subseq	r0, r1, #1073741830	; 0x40000006
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3af0:	0119007d 	tsteq	r9, sp, ror r0
    3af4:	007d0250 	rsbseq	r0, sp, r0, asr r2
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3af8:	00001a00 	andeq	r1, r0, r0, lsl #20
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3afc:	09f30000 	ldmibeq	r3!, {}^	; <UNPREDICTABLE>
    3b00:	01190000 	tsteq	r9, r0
    3b04:	00750253 	rsbseq	r0, r5, r3, asr r2
    3b08:	03520119 	cmpeq	r2, #1073741830	; 0x40000006
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3b0c:	197ec891 	ldmdbne	lr!, {r0, r4, r7, fp, lr, pc}^
    3b10:	91035101 	tstls	r3, r1, lsl #2
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b14:	01197dc8 	tsteq	r9, r8, asr #27
    3b18:	c8910350 	ldmgt	r1, {r4, r6, r8, r9}
    3b1c:	1800007d 	stmdane	r0, {r0, r2, r3, r4, r5, r6}
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b20:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b24:	00000a13 	andeq	r0, r0, r3, lsl sl
    3b28:	0000092a 	andeq	r0, r0, sl, lsr #18
    3b2c:	03510119 	cmpeq	r1, #1073741830	; 0x40000006
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b30:	197dc891 	ldmdbne	sp!, {r0, r4, r7, fp, lr, pc}^
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b34:	91035001 	tstls	r3, r1
    3b38:	18007e88 	stmdane	r0, {r3, r7, r9, sl, fp, ip, sp, lr}
    3b3c:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b40:	000009bd 			; <UNDEFINED> instruction: 0x000009bd
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b44:	0000094b 	andeq	r0, r0, fp, asr #18
    3b48:	02520119 	subseq	r0, r2, #1073741830	; 0x40000006
    3b4c:	0119007d 	tsteq	r9, sp, ror r0
    3b50:	88910351 	ldmhi	r1, {r0, r4, r6, r8, r9}
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b54:	5001197e 	andpl	r1, r1, lr, ror r9
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b58:	00007802 	andeq	r7, r0, r2, lsl #16
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b5c:	0000001a 	andeq	r0, r0, sl, lsl r0
    3b60:	000a2900 	andeq	r2, sl, r0, lsl #18
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b64:	50011900 	andpl	r1, r1, r0, lsl #18
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b68:	00007802 	andeq	r7, r0, r2, lsl #16
    3b6c:	00730800 	rsbseq	r0, r3, r0, lsl #16
    3b70:	891d0000 	ldmdbhi	sp, {}	; <UNPREDICTABLE>
    3b74:	02000014 	andeq	r0, r0, #20
    3b78:	00096c1c 	andeq	r6, r9, ip, lsl ip
    3b7c:	01580800 	cmpeq	r8, r0, lsl #16
    3b80:	5e1e0000 	cdppl	0, 1, cr0, cr14, cr0, {0}
    3b84:	01000014 	tsteq	r0, r4, lsl r0
    3b88:	00098209 	andeq	r8, r9, r9, lsl #4
    3b8c:	00030500 	andeq	r0, r3, r0, lsl #10
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b90:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b94:	00000158 	andeq	r0, r0, r8, asr r1
    3b98:	00146c1f 	andseq	r6, r4, pc, lsl ip
    3b9c:	a23a0200 	eorsge	r0, sl, #0, 4
    3ba0:	20000009 	andcs	r0, r0, r9
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3ba4:	000000c4 	andeq	r0, r0, r4, asr #1
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ba8:	0000ca20 	andeq	ip, r0, r0, lsr #20
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bac:	00ca2000 	sbceq	r2, sl, r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bb0:	1f000000 	svcne	0x00000000
    3bb4:	00001544 	andeq	r1, r0, r4, asr #10
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bb8:	09bd3b02 	ldmibeq	sp!, {r1, r8, r9, fp, ip, sp}
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bbc:	c4200000 	strtgt	r0, [r0], #-0
    3bc0:	20000000 	andcs	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bc4:	000000ca 	andeq	r0, r0, sl, asr #1
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bc8:	0000ca20 	andeq	ip, r0, r0, lsr #20
    3bcc:	651f0000 	ldrvs	r0, [pc, #-0]	; 3bd4 <sha256_process+0xaf4>
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bd0:	02000015 	andeq	r0, r0, #21
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bd4:	0009d844 	andeq	sp, r9, r4, asr #16
    3bd8:	00c42000 	sbceq	r2, r4, r0
    3bdc:	ca200000 	bgt	803be4 <_etext+0x7fc5d0>
    3be0:	20000000 	andcs	r0, r0, r0
    3be4:	000000ca 	andeq	r0, r0, sl, asr #1
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3be8:	14771f00 	ldrbtne	r1, [r7], #-3840	; 0xf00
    3bec:	4b020000 	blmi	83bf4 <_etext+0x7c5e0>
    3bf0:	000009f3 	strdeq	r0, [r0], -r3
    3bf4:	0000c420 	andeq	ip, r0, r0, lsr #8
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bf8:	00ca2000 	sbceq	r2, sl, r0
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bfc:	8c200000 	stchi	0, cr0, [r0], #-0
    3c00:	00000000 	andeq	r0, r0, r0
    3c04:	00158f1f 	andseq	r8, r5, pc, lsl pc
    3c08:	13330200 	teqne	r3, #0, 4
    3c0c:	2000000a 	andcs	r0, r0, sl
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c10:	000000c4 	andeq	r0, r0, r4, asr #1
    3c14:	0000ca20 	andeq	ip, r0, r0, lsr #20
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c18:	00ca2000 	sbceq	r2, sl, r0
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c1c:	81200000 	teqhi	r0, r0
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c20:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c24:	00157a1f 	andseq	r7, r5, pc, lsl sl
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c28:	29510200 	ldmdbcs	r1, {r9}^
    3c2c:	2000000a 	andcs	r0, r0, sl
    3c30:	000000c4 	andeq	r0, r0, r4, asr #1
    3c34:	0000ca20 	andeq	ip, r0, r0, lsr #20
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c38:	54210000 	strtpl	r0, [r1], #-0
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c3c:	02000015 	andeq	r0, r0, #21
    3c40:	00c42028 	sbceq	r2, r4, r8, lsr #32
    3c44:	00000000 	andeq	r0, r0, r0
    3c48:	00000eb2 			; <UNDEFINED> instruction: 0x00000eb2
    3c4c:	0f7d0004 	svceq	0x007d0004
    3c50:	01040000 	mrseq	r0, (UNDEF: 4)
    3c54:	000014a6 	andeq	r1, r0, r6, lsr #9
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c58:	00160e01 	andseq	r0, r6, r1, lsl #28
    3c5c:	00089300 	andeq	r9, r8, r0, lsl #6
    3c60:	0003a800 	andeq	sl, r3, r0, lsl #16
    3c64:	00000000 	andeq	r0, r0, r0
    3c68:	00126100 	andseq	r6, r2, r0, lsl #2
    3c6c:	06010200 	streq	r0, [r1], -r0, lsl #4
    3c70:	0000081a 	andeq	r0, r0, sl, lsl r8
    3c74:	000ad903 	andeq	sp, sl, r3, lsl #18
    3c78:	371c0400 	ldrcc	r0, [ip, -r0, lsl #8]
    3c7c:	02000000 	andeq	r0, r0, #0
    3c80:	08180801 	ldmdaeq	r8, {r0, fp}
    3c84:	02020000 	andeq	r0, r2, #0
    3c88:	0006fc05 	andeq	pc, r6, r5, lsl #24
    3c8c:	07020200 	streq	r0, [r2, -r0, lsl #4]
    3c90:	00000949 	andeq	r0, r0, r9, asr #18
    3c94:	da050402 	ble	144ca4 <_etext+0x13d690>
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c98:	03000004 	movweq	r0, #4
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c9c:	00000abf 			; <UNDEFINED> instruction: 0x00000abf
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3ca0:	005e3804 	subseq	r3, lr, r4, lsl #16
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3ca4:	04020000 	streq	r0, [r2], #-0
    3ca8:	00025207 	andeq	r5, r2, r7, lsl #4
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cac:	05080200 	streq	r0, [r8, #-512]	; 0x200
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cb0:	000004d5 	ldrdeq	r0, [r0], -r5
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cb4:	4d070802 	stcmi	8, cr0, [r7, #-8]
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cb8:	04000002 	streq	r0, [r0], #-2
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cbc:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cc0:	04020074 	streq	r0, [r2], #-116	; 0x74
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cc4:	00025707 	andeq	r5, r2, r7, lsl #14
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cc8:	0adb0300 	beq	ff6c48d0 <BootRAM+0xe635071>
    3ccc:	2a050000 	bcs	143cd4 <_etext+0x13c6c0>
    3cd0:	0000002c 	andeq	r0, r0, ip, lsr #32
    3cd4:	000ac103 	andeq	ip, sl, r3, lsl #2
    3cd8:	53420500 	movtpl	r0, #9472	; 0x2500
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cdc:	02000000 	andeq	r0, r0, #0
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3ce0:	078b0704 	streq	r0, [fp, r4, lsl #14]
    3ce4:	04050000 	streq	r0, [r5], #-0
    3ce8:	21080102 	tstcs	r8, r2, lsl #2
    3cec:	06000008 	streq	r0, [r0], -r8
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cf0:	00001680 	andeq	r1, r0, r0, lsl #13
    3cf4:	dc200380 	stcle	3, cr0, [r0], #-512	; 0xfffffe00
    3cf8:	07000000 	streq	r0, [r0, -r0]
    3cfc:	21030078 	tstcs	r3, r8, ror r0
    3d00:	000000dc 	ldrdeq	r0, [r0], -ip
    3d04:	00790700 	rsbseq	r0, r9, r0, lsl #14
    3d08:	00dc2203 	sbcseq	r2, ip, r3, lsl #4
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d0c:	07200000 	streq	r0, [r0, -r0]!
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d10:	23030074 	movwcs	r0, #12404	; 0x3074
    3d14:	000000dc 	ldrdeq	r0, [r0], -ip
    3d18:	007a0740 	rsbseq	r0, sl, r0, asr #14
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d1c:	00dc2403 	sbcseq	r2, ip, r3, lsl #8
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d20:	00600000 	rsbeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d24:	00008108 	andeq	r8, r0, r8, lsl #2
    3d28:	0000ec00 	andeq	lr, r0, r0, lsl #24
    3d2c:	00970900 	addseq	r0, r7, r0, lsl #18
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d30:	001f0000 	andseq	r0, pc, r0
    3d34:	0014520a 	andseq	r5, r4, sl, lsl #4
    3d38:	03220200 	teqeq	r2, #0, 4
    3d3c:	0000010b 	andeq	r0, r0, fp, lsl #2
    3d40:	0200780b 	andeq	r7, r0, #720896	; 0xb0000
    3d44:	00010b22 	andeq	r0, r1, r2, lsr #22
    3d48:	00610b00 	rsbeq	r0, r1, r0, lsl #22
    3d4c:	01112202 	tsteq	r1, r2, lsl #4
    3d50:	0c000000 	stceq	0, cr0, [r0], {-0}
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d54:	00008104 	andeq	r8, r0, r4, lsl #2
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d58:	17040c00 	strne	r0, [r4, -r0, lsl #24]
    3d5c:	0d000001 	stceq	0, cr0, [r0, #-4]
    3d60:	00000081 	andeq	r0, r0, r1, lsl #1
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d64:	0016980a 	andseq	r9, r6, sl, lsl #16
    3d68:	03460300 	movteq	r0, #25344	; 0x6300
    3d6c:	0000013f 	andeq	r0, r0, pc, lsr r1
    3d70:	7473640b 	ldrbtvc	r6, [r3], #-1035	; 0x40b
    3d74:	3f460300 	svccc	0x00460300
    3d78:	0b000001 	bleq	3d84 <sha256_process+0xca4>
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d7c:	00637273 	rsbeq	r7, r3, r3, ror r2
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d80:	01454703 	cmpeq	r5, r3, lsl #14
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d84:	0c000000 	stceq	0, cr0, [r0], {-0}
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d88:	0000a704 	andeq	sl, r0, r4, lsl #14
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d8c:	4b040c00 	blmi	106d94 <_etext+0xff780>
    3d90:	0d000001 	stceq	0, cr0, [r0, #-4]
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d94:	000000a7 	andeq	r0, r0, r7, lsr #1
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d98:	0015fe0e 	andseq	pc, r5, lr, lsl #28
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d9c:	0c320100 	ldfeqs	f0, [r2], #-0
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3da0:	7000001a 	andvc	r0, r0, sl, lsl r0
    3da4:	01000000 	mrseq	r0, (UNDEF: 0)
    3da8:	0002109c 	muleq	r2, ip, r0
    3dac:	00700f00 	rsbseq	r0, r0, r0, lsl #30
    3db0:	013f3201 	teqeq	pc, r1, lsl #4
    3db4:	0dd80000 	ldcleq	0, cr0, [r8]
    3db8:	780f0000 	stmdavc	pc, {}	; <UNPREDICTABLE>
    3dbc:	11330100 	teqne	r3, r0, lsl #2
    3dc0:	11000001 	tstne	r0, r1
    3dc4:	0f00000e 	svceq	0x0000000e
    3dc8:	33010079 	movwcc	r0, #4217	; 0x1079
    3dcc:	00000111 	andeq	r0, r0, r1, lsl r1
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3dd0:	00000e48 	andeq	r0, r0, r8, asr #28
    3dd4:	0000ec10 	andeq	lr, r0, r0, lsl ip
    3dd8:	001a1000 	andseq	r1, sl, r0
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3ddc:	00002800 	andeq	r2, r0, r0, lsl #16
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3de0:	b2350100 	eorslt	r0, r5, #0, 2
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3de4:	11000001 	tstne	r0, r1
    3de8:	00000101 	andeq	r0, r0, r1, lsl #2
    3dec:	00000e7f 	andeq	r0, r0, pc, ror lr
    3df0:	0000f811 	andeq	pc, r0, r1, lsl r8	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3df4:	000eab00 	andeq	sl, lr, r0, lsl #22
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3df8:	ec120000 	ldc	0, cr0, [r2], {-0}
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3dfc:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    3e00:	4000001a 	andmi	r0, r0, sl, lsl r0
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e04:	01000003 	tsteq	r0, r3
    3e08:	0001d436 	andeq	sp, r1, r6, lsr r4
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e0c:	01011300 	mrseq	r1, SP_irq
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e10:	f8110000 			; <UNDEFINED> instruction: 0xf8110000
    3e14:	e4000000 	str	r0, [r0], #-0
    3e18:	0000000e 	andeq	r0, r0, lr
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e1c:	001a6c14 	andseq	r6, sl, r4, lsl ip
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e20:	000d9d00 	andeq	r9, sp, r0, lsl #26
    3e24:	0001ee00 	andeq	lr, r1, r0, lsl #28
    3e28:	51011500 	tstpl	r1, r0, lsl #10
    3e2c:	01153101 	tsteq	r5, r1, lsl #2
    3e30:	e0740350 	rsbs	r0, r4, r0, asr r3
    3e34:	7c160000 	ldcvc	0, cr0, [r6], {-0}
    3e38:	b300001a 	movwlt	r0, #26
    3e3c:	1500000d 	strne	r0, [r0, #-13]
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e40:	f3035201 	vhsub.u8	d5, d3, d1
    3e44:	01155201 	tsteq	r5, r1, lsl #4
    3e48:	01f30351 	mvnseq	r0, r1, asr r3
    3e4c:	50011551 	andpl	r1, r1, r1, asr r5
    3e50:	5001f305 	andpl	pc, r1, r5, lsl #6
    3e54:	00004023 	andeq	r4, r0, r3, lsr #32
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e58:	0016380e 	andseq	r3, r6, lr, lsl #16
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e5c:	7c3b0100 	ldfvcs	f0, [fp], #-0
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e60:	3a00001a 	bcc	3ed0 <sha256_process+0xdf0>
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e64:	01000000 	mrseq	r0, (UNDEF: 0)
    3e68:	0002d99c 	muleq	r2, ip, r9
    3e6c:	00780f00 	rsbseq	r0, r8, r0, lsl #30
    3e70:	010b3b01 	tsteq	fp, r1, lsl #22
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e74:	0f230000 	svceq	0x00230000
    3e78:	790f0000 	stmdbvc	pc, {}	; <UNPREDICTABLE>
    3e7c:	0b3b0100 	bleq	ec4284 <_etext+0xebcc70>
    3e80:	41000001 	tstmi	r0, r1
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e84:	0f00000f 	svceq	0x0000000f
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e88:	3c010070 	stccc	0, cr0, [r1], {112}	; 0x70
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e8c:	00000145 	andeq	r0, r0, r5, asr #2
    3e90:	00000f5f 	andeq	r0, r0, pc, asr pc
    3e94:	00317a17 	eorseq	r7, r1, r7, lsl sl
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e98:	00dc3e01 	sbcseq	r3, ip, r1, lsl #28
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e9c:	91020000 	mrsls	r0, (UNDEF: 2)
    3ea0:	1a901450 	bne	fe408fe8 <BootRAM+0xd379789>
    3ea4:	0dce0000 	stcleq	0, cr0, [lr]
    3ea8:	02740000 	rsbseq	r0, r4, #0
    3eac:	01150000 	tsteq	r5, r0
    3eb0:	e0740351 	rsbs	r0, r4, r1, asr r3
    3eb4:	50011500 	andpl	r1, r1, r0, lsl #10
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3eb8:	00007d02 	andeq	r7, r0, r2, lsl #26
    3ebc:	001a9a14 	andseq	r9, sl, r4, lsl sl
    3ec0:	000db300 	andeq	fp, sp, r0, lsl #6
    3ec4:	00029400 	andeq	r9, r2, r0, lsl #8
    3ec8:	52011500 	andpl	r1, r1, #0, 10
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3ecc:	15007d02 	strne	r7, [r0, #-3330]	; 0xd02
    3ed0:	74025101 	strvc	r5, [r2], #-257	; 0x101
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ed4:	50011500 	andpl	r1, r1, r0, lsl #10
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3ed8:	00007602 	andeq	r7, r0, r2, lsl #12
    3edc:	001aa614 	andseq	sl, sl, r4, lsl r6
    3ee0:	000db300 	andeq	fp, sp, r0, lsl #6
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ee4:	0002b400 	andeq	fp, r2, r0, lsl #8
    3ee8:	52011500 	andpl	r1, r1, #0, 10
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3eec:	15007d02 	strne	r7, [r0, #-3330]	; 0xd02
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ef0:	74025101 	strvc	r5, [r2], #-257	; 0x101
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3ef4:	50011520 	andpl	r1, r1, r0, lsr #10
    3ef8:	00007502 	andeq	r7, r0, r2, lsl #10
    3efc:	001aac14 	andseq	sl, sl, r4, lsl ip
    3f00:	000de400 	andeq	lr, sp, r0, lsl #8
    3f04:	0002c800 	andeq	ip, r2, r0, lsl #16
    3f08:	50011500 	andpl	r1, r1, r0, lsl #10
    3f0c:	00007602 	andeq	r7, r0, r2, lsl #12
    3f10:	001ab218 	andseq	fp, sl, r8, lsl r2
    3f14:	000de400 	andeq	lr, sp, r0, lsl #8
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f18:	50011500 	andpl	r1, r1, r0, lsl #10
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3f1c:	00007502 	andeq	r7, r0, r2, lsl #10
    3f20:	15cb0e00 	strbne	r0, [fp, #3584]	; 0xe00
    3f24:	5e010000 	cdppl	0, 0, cr0, cr1, cr0, {0}
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f28:	00001ab8 			; <UNDEFINED> instruction: 0x00001ab8
    3f2c:	0000005e 	andeq	r0, r0, lr, asr r0
    3f30:	039f9c01 	orrseq	r9, pc, #256	; 0x100
    3f34:	630f0000 	movwvs	r0, #61440	; 0xf000
    3f38:	0b5e0100 	bleq	1784340 <_etext+0x177cd2c>
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3f3c:	7d000001 	stcvc	0, cr0, [r0, #-4]
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f40:	0f00000f 	svceq	0x0000000f
    3f44:	5e010078 	mcrpl	0, 0, r0, cr1, cr8, {3}
    3f48:	00000111 	andeq	r0, r0, r1, lsl r1
    3f4c:	00000f9b 	muleq	r0, fp, pc	; <UNPREDICTABLE>
    3f50:	0100790f 	tsteq	r0, pc, lsl #18
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f54:	0001115e 	andeq	r1, r1, lr, asr r1
    3f58:	000fb900 	andeq	fp, pc, r0, lsl #18
    3f5c:	6d741700 	ldclvs	7, cr1, [r4, #-0]
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f60:	60010070 	andvs	r0, r1, r0, ror r0
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f64:	000000dc 	ldrdeq	r0, [r0], -ip
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f68:	19489102 	stmdbne	r8, {r1, r8, ip, pc}^
    3f6c:	000015d8 	ldrdeq	r1, [r0], -r8
    3f70:	00816101 	addeq	r6, r1, r1, lsl #2
    3f74:	0fd70000 	svceq	0x00d70000
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f78:	ec100000 	ldc	0, cr0, [r0], {-0}
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f7c:	c2000000 	andgt	r0, r0, #0
    3f80:	1600001a 			; <UNDEFINED> instruction: 0x1600001a
    3f84:	01000000 	mrseq	r0, (UNDEF: 0)
    3f88:	00035863 	andeq	r5, r3, r3, ror #16
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f8c:	01011100 	mrseq	r1, (UNDEF: 17)
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f90:	0fea0000 	svceq	0x00ea0000
    3f94:	f8110000 			; <UNDEFINED> instruction: 0xf8110000
    3f98:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f9c:	00000010 	andeq	r0, r0, r0, lsl r0
    3fa0:	0000ec10 	andeq	lr, r0, r0, lsl ip
    3fa4:	001ade00 	andseq	sp, sl, r0, lsl #28
    3fa8:	00002000 	andeq	r2, r0, r0
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3fac:	7a670100 	bvc	19c43b4 <_etext+0x19bcda0>
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fb0:	1a000003 	bne	3fc4 <sha256_process+0xee4>
    3fb4:	00000101 	andeq	r0, r0, r1, lsl #2
    3fb8:	f81a5601 			; <UNDEFINED> instruction: 0xf81a5601
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fbc:	01000000 	mrseq	r0, (UNDEF: 0)
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fc0:	de140055 	mrcle	0, 0, r0, cr4, cr5, {2}
    3fc4:	e400001a 	str	r0, [r0], #-26
    3fc8:	8e00000d 	cdphi	0, 0, cr0, cr0, cr13, {0}
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fcc:	15000003 	strne	r0, [r0, #-3]
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fd0:	7d025001 	stcvc	0, cr5, [r2, #-4]
    3fd4:	08180000 	ldmdaeq	r8, {}	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fd8:	e400001b 	str	r0, [r0], #-27
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fdc:	1500000d 	strne	r0, [r0, #-13]
    3fe0:	75025001 	strvc	r5, [r2, #-1]
    3fe4:	1b000000 	blne	3fec <sha256_process+0xf0c>
    3fe8:	000015eb 	andeq	r1, r0, fp, ror #11
    3fec:	00816c01 	addeq	r6, r1, r1, lsl #24
    3ff0:	1b180000 	blne	603ff8 <_etext+0x5fc9e4>
    3ff4:	00c80000 	sbceq	r0, r8, r0
    3ff8:	9c010000 	stcls	0, cr0, [r1], {-0}
    3ffc:	000005b4 			; <UNDEFINED> instruction: 0x000005b4
    4000:	0100780f 	tsteq	r0, pc, lsl #16
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4004:	00010b6c 	andeq	r0, r1, ip, ror #22
    4008:	00102800 	andseq	r2, r0, r0, lsl #16
    400c:	00790f00 	rsbseq	r0, r9, r0, lsl #30
    4010:	010b6c01 	tsteq	fp, r1, lsl #24
    4014:	10540000 	subsne	r0, r4, r0
    4018:	af1c0000 	svcge	0x001c0000
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    401c:	01000015 	tsteq	r0, r5, lsl r0
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4020:	0001116c 	andeq	r1, r1, ip, ror #2
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4024:	00107500 	andseq	r7, r0, r0, lsl #10
    4028:	15d81900 	ldrbne	r1, [r8, #2304]	; 0x900
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    402c:	6e010000 	cdpvs	0, 0, cr0, cr1, cr0, {0}
    4030:	000005b4 			; <UNDEFINED> instruction: 0x000005b4
    4034:	00001096 	muleq	r0, r6, r0
    4038:	01006117 	tsteq	r0, r7, lsl r1
    403c:	0000dc6f 	andeq	sp, r0, pc, ror #24
    4040:	88910300 	ldmhi	r1, {r8, r9}
    4044:	0062177f 	rsbeq	r1, r2, pc, ror r7
    4048:	00dc7001 	sbcseq	r7, ip, r1
    404c:	91030000 	mrsls	r0, (UNDEF: 3)
    4050:	63177fa8 	tstvs	r7, #168, 30	; 0x2a0
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4054:	dc710100 	ldflee	f0, [r1], #-0
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4058:	02000000 	andeq	r0, r0, #0
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    405c:	ec124891 	ldc	8, cr4, [r2], {145}	; 0x91
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4060:	1c000000 	stcne	0, cr0, [r0], {-0}
    4064:	6800001b 	stmdavs	r0, {r0, r1, r3, r4}
    4068:	01000003 	tsteq	r0, r3
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    406c:	00043c74 	andeq	r3, r4, r4, ror ip
    4070:	01011100 	mrseq	r1, (UNDEF: 17)
    4074:	10b00000 	adcsne	r0, r0, r0
    4078:	f8110000 			; <UNDEFINED> instruction: 0xf8110000
    407c:	d1000000 	mrsle	r0, (UNDEF: 0)
    4080:	00000010 	andeq	r0, r0, r0, lsl r0
    4084:	001b5e14 	andseq	r5, fp, r4, lsl lr
    4088:	000db300 	andeq	fp, sp, r0, lsl #6
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    408c:	00045e00 	andeq	r5, r4, r0, lsl #28
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4090:	52011500 	andpl	r1, r1, #0, 10
    4094:	5101f303 	tstpl	r1, r3, lsl #6
    4098:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    409c:	155101f3 	ldrbne	r0, [r1, #-499]	; 0x1f3
    40a0:	91025001 	tstls	r2, r1
    40a4:	68140048 	ldmdavs	r4, {r3, r6}
    40a8:	b300001b 	movwlt	r0, #27
    40ac:	8200000d 	andhi	r0, r0, #13
    40b0:	15000004 	strne	r0, [r0, #-4]
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40b4:	03055201 	movweq	r5, #20993	; 0x5201
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    40b8:	00007220 	andeq	r7, r0, r0, lsr #4
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    40bc:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    40c0:	01154891 			; <UNDEFINED> instruction: 0x01154891
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40c4:	a8910350 	ldmge	r1, {r4, r6, r8, r9}
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    40c8:	7214007f 	andsvc	r0, r4, #127	; 0x7f
    40cc:	f500001b 			; <UNDEFINED> instruction: 0xf500001b
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40d0:	a300000d 	movwge	r0, #13
    40d4:	15000004 	strne	r0, [r0, #-4]
    40d8:	75025201 	strvc	r5, [r2, #-513]	; 0x201
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    40dc:	51011500 	tstpl	r1, r0, lsl #10
    40e0:	7fa89103 	svcvc	0x00a89103
    40e4:	02500115 	subseq	r0, r0, #1073741829	; 0x40000005
    40e8:	1400007d 	strne	r0, [r0], #-125	; 0x7d
    40ec:	00001b7a 	andeq	r1, r0, sl, ror fp
    40f0:	00000dce 	andeq	r0, r0, lr, asr #27
    40f4:	000004be 			; <UNDEFINED> instruction: 0x000004be
    40f8:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    40fc:	0115007d 	tsteq	r5, sp, ror r0
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4100:	a8910350 	ldmge	r1, {r4, r6, r8, r9}
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4104:	8414007f 	ldrhi	r0, [r4], #-127	; 0x7f
    4108:	1000001b 	andne	r0, r0, fp, lsl r0
    410c:	de00000e 	cdple	0, 0, cr0, cr0, cr14, {0}
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4110:	15000004 	strne	r0, [r0, #-4]
    4114:	75025201 	strvc	r5, [r2, #-513]	; 0x201
    4118:	51011500 	tstpl	r1, r0, lsl #10
    411c:	15489102 	strbne	r9, [r8, #-258]	; 0x102
    4120:	7d025001 	stcvc	0, cr5, [r2, #-4]
    4124:	8e140000 	cdphi	0, 1, cr0, cr4, cr0, {0}
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4128:	b300001b 	movwlt	r0, #27
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    412c:	ff00000d 			; <UNDEFINED> instruction: 0xff00000d
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4130:	15000004 	strne	r0, [r0, #-4]
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4134:	91035201 	tstls	r3, r1, lsl #4
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4138:	01157fa8 	tsteq	r5, r8, lsr #31
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    413c:	007d0251 	rsbseq	r0, sp, r1, asr r2
    4140:	02500115 	subseq	r0, r0, #1073741829	; 0x40000005
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4144:	14004891 	strne	r4, [r0], #-2193	; 0x891
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4148:	00001b96 	muleq	r0, r6, fp
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    414c:	00000e2b 	andeq	r0, r0, fp, lsr #28
    4150:	00000519 	andeq	r0, r0, r9, lsl r5
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4154:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    4158:	01154891 			; <UNDEFINED> instruction: 0x01154891
    415c:	007d0250 	rsbseq	r0, sp, r0, asr r2
    4160:	1b9e1400 	blne	fe789168 <BootRAM+0xd6f9909>
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4164:	0e410000 	cdpeq	0, 4, cr0, cr1, cr0, {0}
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4168:	05340000 	ldreq	r0, [r4, #-0]!
    416c:	01150000 	tsteq	r5, r0
    4170:	007d0251 	rsbseq	r0, sp, r1, asr r2
    4174:	03500115 	cmpeq	r0, #1073741829	; 0x40000005
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4178:	007fa891 			; <UNDEFINED> instruction: 0x007fa891
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    417c:	001bb414 	andseq	fp, fp, r4, lsl r4
    4180:	000e5700 	andeq	r5, lr, r0, lsl #14
    4184:	00055500 	andeq	r5, r5, r0, lsl #10
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4188:	52011500 	andpl	r1, r1, #0, 10
    418c:	7fa89103 	svcvc	0x00a89103
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4190:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4194:	0115007d 	tsteq	r5, sp, ror r0
    4198:	00740250 	rsbseq	r0, r4, r0, asr r2
    419c:	1bbe1400 	blne	fef891a4 <BootRAM+0xdef9945>
    41a0:	0db30000 	ldceq	0, cr0, [r3]
    41a4:	05750000 	ldrbeq	r0, [r5, #-0]!
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41a8:	01150000 	tsteq	r5, r0
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41ac:	00740252 	rsbseq	r0, r4, r2, asr r2
    41b0:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41b4:	01150074 	tsteq	r5, r4, ror r0
    41b8:	007d0250 	rsbseq	r0, sp, r0, asr r2
    41bc:	1bc41400 	blne	ff1091c4 <BootRAM+0xe079965>
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41c0:	0de40000 	stcleq	0, cr0, [r4]
    41c4:	05890000 	streq	r0, [r9]
    41c8:	01150000 	tsteq	r5, r0
    41cc:	007d0250 	rsbseq	r0, sp, r0, asr r2
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41d0:	1bca1400 	blne	ff2891d8 <BootRAM+0xe1f9979>
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41d4:	0de40000 	stcleq	0, cr0, [r4]
    41d8:	059d0000 	ldreq	r0, [sp]
    41dc:	01150000 	tsteq	r5, r0
    41e0:	48910250 	ldmmi	r1, {r4, r6, r9}
    41e4:	1bd21800 	blne	ff48a1ec <BootRAM+0xe3fa98d>
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41e8:	0e770000 	cdpeq	0, 7, cr0, cr7, cr0, {0}
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41ec:	01150000 	tsteq	r5, r0
    41f0:	48910251 	ldmmi	r1, {r0, r4, r6, r9}
    41f4:	02500115 	subseq	r0, r0, #1073741829	; 0x40000005
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41f8:	0000007d 	andeq	r0, r0, sp, ror r0
    41fc:	0000730d 	andeq	r7, r0, sp, lsl #6
    4200:	15df0e00 	ldrbne	r0, [pc, #3584]	; 5008 <sha256_process+0x1f28>
    4204:	9c010000 	stcls	0, cr0, [r1], {-0}
    4208:	00001be0 	andeq	r1, r0, r0, ror #23
    420c:	000000e0 	andeq	r0, r0, r0, ror #1
    4210:	08c39c01 	stmiaeq	r3, {r0, sl, fp, ip, pc}^
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4214:	720f0000 	andvc	r0, pc, #0
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4218:	3f9c0100 	svccc	0x009c0100
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    421c:	f2000001 	vhadd.s8	d0, d0, d1
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4220:	0f000010 	svceq	0x00000010
    4224:	01003170 	tsteq	r0, r0, ror r1
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4228:	0001459d 	muleq	r1, sp, r5
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    422c:	00111e00 	andseq	r1, r1, r0, lsl #28
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4230:	32700f00 	rsbscc	r0, r0, #0, 30
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4234:	459d0100 	ldrmi	r0, [sp, #256]	; 0x100
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4238:	4a000001 	bmi	4244 <sha256_process+0x1164>
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    423c:	17000011 	smladne	r0, r1, r0, r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4240:	b3010061 	movwlt	r0, #4193	; 0x1061
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4244:	000000dc 	ldrdeq	r0, [r0], -ip
    4248:	7de89103 	stfvcp	f1, [r8, #12]!
    424c:	01006217 	tsteq	r0, r7, lsl r2
    4250:	0000dcb4 			; <UNDEFINED> instruction: 0x0000dcb4
    4254:	88910300 	ldmhi	r1, {r8, r9}
    4258:	0063177e 	rsbeq	r1, r3, lr, ror r7
    425c:	00dcb501 	sbcseq	fp, ip, r1, lsl #10
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4260:	91030000 	mrsls	r0, (UNDEF: 3)
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4264:	64177ea8 	ldrvs	r7, [r7], #-3752	; 0xea8
    4268:	dcb60100 	ldfles	f0, [r6]
    426c:	03000000 	movweq	r0, #0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4270:	177ec891 			; <UNDEFINED> instruction: 0x177ec891
    4274:	b7010065 	strlt	r0, [r1, -r5, rrx]
    4278:	000000dc 	ldrdeq	r0, [r0], -ip
    427c:	7ee89103 	urdvce	f1, f3
    4280:	01006617 	tsteq	r0, r7, lsl r6
    4284:	0000dcb8 			; <UNDEFINED> instruction: 0x0000dcb8
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4288:	88910300 	ldmhi	r1, {r8, r9}
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    428c:	0067177f 	rsbeq	r1, r7, pc, ror r7
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4290:	00dcb901 	sbcseq	fp, ip, r1, lsl #18
    4294:	91030000 	mrsls	r0, (UNDEF: 3)
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4298:	68177fa8 	ldmdavs	r7, {r3, r5, r7, r8, r9, sl, fp, ip, sp, lr}
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    429c:	dcba0100 	ldfles	f0, [sl]
    42a0:	02000000 	andeq	r0, r0, #0
    42a4:	fe144891 	mrc2	8, 0, r4, cr4, cr1, {4}
    42a8:	1000001b 	andne	r0, r0, fp, lsl r0
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42ac:	7f00000e 	svcvc	0x0000000e
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    42b0:	15000006 	strne	r0, [r0, #-6]
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42b4:	75025201 	strvc	r5, [r2, #-513]	; 0x201
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    42b8:	51011500 	tstpl	r1, r0, lsl #10
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42bc:	15007802 	strne	r7, [r0, #-2050]	; 0x802
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    42c0:	91035001 	tstls	r3, r1
    42c4:	14007ea8 	strne	r7, [r0], #-3752	; 0xea8
    42c8:	00001c08 	andeq	r1, r0, r8, lsl #24
    42cc:	00000e10 	andeq	r0, r0, r0, lsl lr
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42d0:	000006a0 	andeq	r0, r0, r0, lsr #13
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    42d4:	02520115 	subseq	r0, r2, #1073741829	; 0x40000005
    42d8:	01150074 	tsteq	r5, r4, ror r0
    42dc:	00770251 	rsbseq	r0, r7, r1, asr r2
    42e0:	03500115 	cmpeq	r0, #1073741829	; 0x40000005
    42e4:	007ec891 			; <UNDEFINED> instruction: 0x007ec891
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42e8:	001c1214 	andseq	r1, ip, r4, lsl r2
    42ec:	000db300 	andeq	fp, sp, r0, lsl #6
    42f0:	0006c200 	andeq	ip, r6, r0, lsl #4
    42f4:	52011500 	andpl	r1, r1, #0, 10
    42f8:	7ec89103 	acsvce	f1, f3
    42fc:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    4300:	157ea891 	ldrbne	sl, [lr, #-2193]!	; 0x891
    4304:	7d025001 	stcvc	0, cr5, [r2, #-4]
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4308:	1c140000 	ldcne	0, cr0, [r4], {-0}
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    430c:	f500001c 			; <UNDEFINED> instruction: 0xf500001c
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4310:	e300000d 	movw	r0, #13
    4314:	15000006 	strne	r0, [r0, #-6]
    4318:	75025201 	strvc	r5, [r2, #-513]	; 0x201
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    431c:	51011500 	tstpl	r1, r0, lsl #10
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4320:	15007802 	strne	r7, [r0, #-2050]	; 0x802
    4324:	91035001 	tstls	r3, r1
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4328:	14007ea8 	strne	r7, [r0], #-3752	; 0xea8
    432c:	00001c26 	andeq	r1, r0, r6, lsr #24
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4330:	00000df5 	strdeq	r0, [r0], -r5
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4334:	00000704 	andeq	r0, r0, r4, lsl #14
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4338:	02520115 	subseq	r0, r2, #1073741829	; 0x40000005
    433c:	01150074 	tsteq	r5, r4, ror r0
    4340:	00770251 	rsbseq	r0, r7, r1, asr r2
    4344:	03500115 	cmpeq	r0, #1073741829	; 0x40000005
    4348:	007ec891 			; <UNDEFINED> instruction: 0x007ec891
    434c:	001c3014 	andseq	r3, ip, r4, lsl r0
    4350:	000db300 	andeq	fp, sp, r0, lsl #6
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4354:	00072700 	andeq	r2, r7, r0, lsl #14
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4358:	52011500 	andpl	r1, r1, #0, 10
    435c:	7ec89103 	acsvce	f1, f3
    4360:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4364:	157ea891 	ldrbne	sl, [lr, #-2193]!	; 0x891
    4368:	91035001 	tstls	r3, r1
    436c:	14007e88 	strne	r7, [r0], #-3720	; 0xe88
    4370:	00001c3e 	andeq	r1, r0, lr, lsr ip
    4374:	00000db3 			; <UNDEFINED> instruction: 0x00000db3
    4378:	0000074a 	andeq	r0, r0, sl, asr #14
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    437c:	03520115 	cmpeq	r2, #1073741829	; 0x40000005
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4380:	1500c074 	strne	ip, [r0, #-116]	; 0x74
    4384:	75035101 	strvc	r5, [r3, #-257]	; 0x101
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4388:	011500c0 	tsteq	r5, r0, asr #1
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    438c:	c8910350 	ldmgt	r1, {r4, r6, r8, r9}
    4390:	4814007e 	ldmdami	r4, {r1, r2, r3, r4, r5, r6}
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4394:	b300001c 	movwlt	r0, #28
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4398:	6f00000d 	svcvs	0x0000000d
    439c:	15000007 	strne	r0, [r0, #-7]
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43a0:	03055201 	movweq	r5, #20993	; 0x5201
    43a4:	00007100 	andeq	r7, r0, r0, lsl #2
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43a8:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43ac:	157ec891 	ldrbne	ip, [lr, #-2193]!	; 0x891
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43b0:	91035001 	tstls	r3, r1
    43b4:	14007ea8 	strne	r7, [r0], #-3752	; 0xea8
    43b8:	00001c56 	andeq	r1, r0, r6, asr ip
    43bc:	00000db3 			; <UNDEFINED> instruction: 0x00000db3
    43c0:	00000792 	muleq	r0, r2, r7
    43c4:	03520115 	cmpeq	r2, #1073741829	; 0x40000005
    43c8:	1500e074 	strne	lr, [r0, #-116]	; 0x74
    43cc:	75035101 	strvc	r5, [r3, #-257]	; 0x101
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43d0:	011500e0 	tsteq	r5, r0, ror #1
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43d4:	c8910350 	ldmgt	r1, {r4, r6, r8, r9}
    43d8:	6014007e 	andsvs	r0, r4, lr, ror r0
    43dc:	f500001c 			; <UNDEFINED> instruction: 0xf500001c
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43e0:	b500000d 	strlt	r0, [r0, #-13]
    43e4:	15000007 	strne	r0, [r0, #-7]
    43e8:	91035201 	tstls	r3, r1, lsl #4
    43ec:	01157ec8 	tsteq	r5, r8, asr #29
    43f0:	c8910351 	ldmgt	r1, {r0, r4, r6, r8, r9}
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43f4:	5001157e 	andpl	r1, r1, lr, ror r5
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43f8:	7ec89103 	acsvce	f1, f3
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    43fc:	1c6a1400 	cfstrdne	mvd1, [sl], #-0
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4400:	0e100000 	cdpeq	0, 1, cr0, cr0, cr0, {0}
    4404:	07d70000 	ldrbeq	r0, [r7, r0]
    4408:	01150000 	tsteq	r5, r0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    440c:	007d0252 	rsbseq	r0, sp, r2, asr r2
    4410:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4414:	157e8891 	ldrbne	r8, [lr, #-2193]!	; 0x891
    4418:	91035001 	tstls	r3, r1
    441c:	14007ee8 	strne	r7, [r0], #-3816	; 0xee8
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4420:	00001c74 	andeq	r1, r0, r4, ror ip
    4424:	00000e10 	andeq	r0, r0, r0, lsl lr
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4428:	000007fa 	strdeq	r0, [r0], -sl
    442c:	03520115 	cmpeq	r2, #1073741829	; 0x40000005
    4430:	157ea891 	ldrbne	sl, [lr, #-2193]!	; 0x891
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4434:	91035101 	tstls	r3, r1, lsl #2
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4438:	01157ec8 	tsteq	r5, r8, asr #29
    443c:	88910350 	ldmhi	r1, {r4, r6, r8, r9}
    4440:	7e14007f 	mrcvc	0, 0, r0, cr4, cr15, {3}
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4444:	f500001c 			; <UNDEFINED> instruction: 0xf500001c
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4448:	1d00000d 	stcne	0, cr0, [r0, #-52]	; 0xffffffcc
    444c:	15000008 	strne	r0, [r0, #-8]
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4450:	91035201 	tstls	r3, r1, lsl #4
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4454:	01157ea8 	tsteq	r5, r8, lsr #29
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4458:	c8910351 	ldmgt	r1, {r0, r4, r6, r8, r9}
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    445c:	5001157e 	andpl	r1, r1, lr, ror r5
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4460:	7fa89103 	svcvc	0x00a89103
    4464:	1c881400 	cfstrsne	mvf1, [r8], {0}
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4468:	0df50000 	ldcleq	0, cr0, [r5]
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    446c:	083e0000 	ldmdaeq	lr!, {}	; <UNPREDICTABLE>
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4470:	01150000 	tsteq	r5, r0
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4474:	007d0252 	rsbseq	r0, sp, r2, asr r2
    4478:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    447c:	157e8891 	ldrbne	r8, [lr, #-2193]!	; 0x891
    4480:	91025001 	tstls	r2, r1
    4484:	92140048 	andsls	r0, r4, #72	; 0x48
    4488:	b300001c 	movwlt	r0, #28
    448c:	6000000d 	andvs	r0, r0, sp
    4490:	15000008 	strne	r0, [r0, #-8]
    4494:	91035201 	tstls	r3, r1, lsl #4
    4498:	01157f88 	tsteq	r5, r8, lsl #31
    449c:	e8910351 	ldm	r1, {r0, r4, r6, r8, r9}
    44a0:	5001157e 	andpl	r1, r1, lr, ror r5
    44a4:	00007602 	andeq	r7, r0, r2, lsl #12
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44a8:	001c9e14 	andseq	r9, ip, r4, lsl lr
    44ac:	000db300 	andeq	fp, sp, r0, lsl #6
    44b0:	00088100 	andeq	r8, r8, r0, lsl #2
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    44b4:	52011500 	andpl	r1, r1, #0, 10
    44b8:	15489102 	strbne	r9, [r8, #-258]	; 0x102
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44bc:	91035101 	tstls	r3, r1, lsl #2
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    44c0:	01157fa8 	tsteq	r5, r8, lsr #31
    44c4:	20760250 	rsbscs	r0, r6, r0, asr r2
    44c8:	1caa1400 	cfstrsne	mvf1, [sl]
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44cc:	0db30000 	ldceq	0, cr0, [r3]
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    44d0:	08a30000 	stmiaeq	r3!, {}	; <UNPREDICTABLE>
    44d4:	01150000 	tsteq	r5, r0
    44d8:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    44dc:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    44e0:	157ee891 	ldrbne	lr, [lr, #-2193]!	; 0x891
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44e4:	76035001 	strvc	r5, [r3], -r1
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    44e8:	180000c0 	stmdane	r0, {r6, r7}
    44ec:	00001cb6 			; <UNDEFINED> instruction: 0x00001cb6
    44f0:	00000db3 			; <UNDEFINED> instruction: 0x00000db3
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44f4:	03520115 	cmpeq	r2, #1073741829	; 0x40000005
    44f8:	157fa891 	ldrbne	sl, [pc, #-2193]!	; 3c6f <sha256_process+0xb8f>
    44fc:	91035101 	tstls	r3, r1, lsl #2
    4500:	01157f88 	tsteq	r5, r8, lsl #31
    4504:	e0760350 	rsbs	r0, r6, r0, asr r3
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4508:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    450c:	00001671 	andeq	r1, r0, r1, ror r6
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4510:	1cc0e701 	stclne	7, cr14, [r0], {1}
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4514:	00b40000 	adcseq	r0, r4, r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4518:	9c010000 	stcls	0, cr0, [r1], {-0}
    451c:	00000b62 	andeq	r0, r0, r2, ror #22
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4520:	0100720f 	tsteq	r0, pc, lsl #4
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4524:	00013fe7 	andeq	r3, r1, r7, ror #31
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4528:	00117600 	andseq	r7, r1, r0, lsl #12
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    452c:	00700f00 	rsbseq	r0, r0, r0, lsl #30
    4530:	0145e701 	cmpeq	r5, r1, lsl #14
    4534:	11940000 	orrsne	r0, r4, r0
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4538:	61170000 	tstvs	r7, r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    453c:	dcfa0100 	ldflee	f0, [sl]
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4540:	03000000 	movweq	r0, #0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4544:	177e9091 			; <UNDEFINED> instruction: 0x177e9091
    4548:	fb010062 	blx	446da <_etext+0x3d0c6>
    454c:	000000dc 	ldrdeq	r0, [r0], -ip
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4550:	7eb09103 	asnvcs	f1, f3
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4554:	01006317 	tsteq	r0, r7, lsl r3
    4558:	0000dcfc 	strdeq	sp, [r0], -ip
    455c:	d0910300 	addsle	r0, r1, r0, lsl #6
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4560:	0065177e 	rsbeq	r1, r5, lr, ror r7
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4564:	00dcfd01 	sbcseq	pc, ip, r1, lsl #26
    4568:	91030000 	mrsls	r0, (UNDEF: 3)
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    456c:	66177ef0 			; <UNDEFINED> instruction: 0x66177ef0
    4570:	dcfe0100 	ldflee	f0, [lr]
    4574:	03000000 	movweq	r0, #0
    4578:	177f9091 			; <UNDEFINED> instruction: 0x177f9091
    457c:	ff010067 			; <UNDEFINED> instruction: 0xff010067
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4580:	000000dc 	ldrdeq	r0, [r0], -ip
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4584:	7fb09103 	svcvc	0x00b09103
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4588:	0100681d 	tsteq	r0, sp, lsl r8
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    458c:	00dc0100 	sbcseq	r0, ip, r0, lsl #2
    4590:	91020000 	mrsls	r0, (UNDEF: 2)
    4594:	1cd41450 	cfldrdne	mvd1, [r4], {80}	; 0x50
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4598:	0db30000 	ldceq	0, cr0, [r3]
    459c:	096d0000 	stmdbeq	sp!, {}^	; <UNPREDICTABLE>
    45a0:	01150000 	tsteq	r5, r0
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    45a4:	00750252 	rsbseq	r0, r5, r2, asr r2
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45a8:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    45ac:	01150075 	tsteq	r5, r5, ror r0
    45b0:	007d0250 	rsbseq	r0, sp, r0, asr r2
    45b4:	1cde1400 	cfldrdne	mvd1, [lr], {0}
    45b8:	0db30000 	ldceq	0, cr0, [r3]
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45bc:	098e0000 	stmibeq	lr, {}	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    45c0:	01150000 	tsteq	r5, r0
    45c4:	00760252 	rsbseq	r0, r6, r2, asr r2
    45c8:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    45cc:	01150076 	tsteq	r5, r6, ror r0
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45d0:	b0910350 	addslt	r0, r1, r0, asr r3
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    45d4:	ea14007e 	b	5047d4 <_etext+0x4fd1c0>
    45d8:	b300001c 	movwlt	r0, #28
    45dc:	b100000d 	tstlt	r0, sp
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45e0:	15000009 	strne	r0, [r0, #-9]
    45e4:	75035201 	strvc	r5, [r3, #-513]	; 0x201
    45e8:	011500e0 	tsteq	r5, r0, ror #1
    45ec:	e0750351 	rsbs	r0, r5, r1, asr r3
    45f0:	50011500 	andpl	r1, r1, r0, lsl #10
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    45f4:	7ed09103 	atnvcs	f1, f3
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45f8:	1cf41400 	cfldrdne	mvd1, [r4]
    45fc:	0df50000 	ldcleq	0, cr0, [r5]
    4600:	09d40000 	ldmibeq	r4, {}^	; <UNPREDICTABLE>
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4604:	01150000 	tsteq	r5, r0
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4608:	d0910352 	addsle	r0, r1, r2, asr r3
    460c:	5101157e 	tstpl	r1, lr, ror r5
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4610:	7ed09103 	atnvcs	f1, f3
    4614:	03500115 	cmpeq	r0, #1073741829	; 0x40000005
    4618:	007ed091 			; <UNDEFINED> instruction: 0x007ed091
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    461c:	001cfe14 	andseq	pc, ip, r4, lsl lr	; <UNPREDICTABLE>
    4620:	000df500 	andeq	pc, sp, r0, lsl #10
    4624:	0009f500 	andeq	pc, r9, r0, lsl #10
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4628:	52011500 	andpl	r1, r1, #0, 10
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    462c:	15007602 	strne	r7, [r0, #-1538]	; 0x602
    4630:	75025101 	strvc	r5, [r2, #-257]	; 0x101
    4634:	50011500 	andpl	r1, r1, r0, lsl #10
    4638:	7f909103 	svcvc	0x00909103
    463c:	1d081400 	cfstrsne	mvf1, [r8, #-0]
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4640:	0db30000 	ldceq	0, cr0, [r3]
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4644:	0a180000 	beq	60464c <_etext+0x5fd038>
    4648:	01150000 	tsteq	r5, r0
    464c:	90910352 	addsls	r0, r1, r2, asr r3
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4650:	5101157f 	tstpl	r1, pc, ror r5
    4654:	7f909103 	svcvc	0x00909103
    4658:	03500115 	cmpeq	r0, #1073741829	; 0x40000005
    465c:	007ef091 			; <UNDEFINED> instruction: 0x007ef091
    4660:	001d1214 	andseq	r1, sp, r4, lsl r2
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4664:	000e1000 	andeq	r1, lr, r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4668:	000a3a00 	andeq	r3, sl, r0, lsl #20
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    466c:	52011500 	andpl	r1, r1, #0, 10
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4670:	15007d02 	strne	r7, [r0, #-3330]	; 0xd02
    4674:	91035101 	tstls	r3, r1, lsl #2
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4678:	01157ef0 			; <UNDEFINED> instruction: 0x01157ef0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    467c:	f0910350 			; <UNDEFINED> instruction: 0xf0910350
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4680:	1c14007e 	ldcne	0, cr0, [r4], {126}	; 0x7e
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4684:	1000001d 	andne	r0, r0, sp, lsl r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4688:	5d00000e 	stcpl	0, cr0, [r0, #-56]	; 0xffffffc8
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    468c:	1500000a 	strne	r0, [r0, #-10]
    4690:	91035201 	tstls	r3, r1, lsl #4
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4694:	01157eb0 			; <UNDEFINED> instruction: 0x01157eb0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4698:	f0910351 			; <UNDEFINED> instruction: 0xf0910351
    469c:	5001157e 	andpl	r1, r1, lr, ror r5
    46a0:	7ef09103 	nrmvcs	f1, f3
    46a4:	1d261400 	cfstrsne	mvf1, [r6, #-0]
    46a8:	0e100000 	cdpeq	0, 1, cr0, cr0, cr0, {0}
    46ac:	0a7f0000 	beq	1fc46b4 <_etext+0x1fbd0a0>
    46b0:	01150000 	tsteq	r5, r0
    46b4:	007d0252 	rsbseq	r0, sp, r2, asr r2
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46b8:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    46bc:	157eb091 	ldrbne	fp, [lr, #-145]!	; 0x91
    46c0:	91035001 	tstls	r3, r1
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46c4:	14007fb0 	strne	r7, [r0], #-4016	; 0xfb0
    46c8:	00001d30 	andeq	r1, r0, r0, lsr sp
    46cc:	00000e10 	andeq	r0, r0, r0, lsl lr
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    46d0:	00000aa2 	andeq	r0, r0, r2, lsr #21
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46d4:	03520115 	cmpeq	r2, #1073741829	; 0x40000005
    46d8:	157ed091 	ldrbne	sp, [lr, #-145]!	; 0x91
    46dc:	91035101 	tstls	r3, r1, lsl #2
    46e0:	01157fb0 			; <UNDEFINED> instruction: 0x01157fb0
    46e4:	90910350 	addsls	r0, r1, r0, asr r3
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46e8:	3814007f 	ldmdacc	r4, {r0, r1, r2, r3, r4, r5, r6}
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46ec:	4100001d 	tstmi	r0, sp, lsl r0
    46f0:	bd00000e 	stclt	0, cr0, [r0, #-56]	; 0xffffffc8
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46f4:	1500000a 	strne	r0, [r0, #-10]
    46f8:	91035101 	tstls	r3, r1, lsl #2
    46fc:	01157eb0 			; <UNDEFINED> instruction: 0x01157eb0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4700:	50910250 	addspl	r0, r1, r0, asr r2
    4704:	1d421400 	cfstrdne	mvd1, [r2, #-0]
    4708:	0e100000 	cdpeq	0, 1, cr0, cr0, cr0, {0}
    470c:	0add0000 	beq	ff744714 <BootRAM+0xe6b4eb5>
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4710:	01150000 	tsteq	r5, r0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4714:	007d0252 	rsbseq	r0, sp, r2, asr r2
    4718:	02510115 	subseq	r0, r1, #1073741829	; 0x40000005
    471c:	01155091 			; <UNDEFINED> instruction: 0x01155091
    4720:	50910250 	addspl	r0, r1, r0, asr r2
    4724:	1d4c1400 	cfstrdne	mvd1, [ip, #-0]
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4728:	0db30000 	ldceq	0, cr0, [r3]
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    472c:	0aff0000 	beq	fffc4734 <BootRAM+0xef34ed5>
    4730:	01150000 	tsteq	r5, r0
    4734:	90910352 	addsls	r0, r1, r2, asr r3
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4738:	5101157f 	tstpl	r1, pc, ror r5
    473c:	7ef09103 	nrmvcs	f1, f3
    4740:	02500115 	subseq	r0, r0, #1073741829	; 0x40000005
    4744:	14000074 	strne	r0, [r0], #-116	; 0x74
    4748:	00001d58 	andeq	r1, r0, r8, asr sp
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    474c:	00000db3 			; <UNDEFINED> instruction: 0x00000db3
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4750:	00000b20 	andeq	r0, r0, r0, lsr #22
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4754:	02520115 	subseq	r0, r2, #1073741829	; 0x40000005
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4758:	01155091 			; <UNDEFINED> instruction: 0x01155091
    475c:	b0910351 	addslt	r0, r1, r1, asr r3
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4760:	5001157f 	andpl	r1, r1, pc, ror r5
    4764:	00207402 	eoreq	r7, r0, r2, lsl #8
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4768:	001d6414 	andseq	r6, sp, r4, lsl r4
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    476c:	000db300 	andeq	fp, sp, r0, lsl #6
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4770:	000b4200 	andeq	r4, fp, r0, lsl #4
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4774:	52011500 	andpl	r1, r1, #0, 10
    4778:	15509102 	ldrbne	r9, [r0, #-258]	; 0x102
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    477c:	91035101 	tstls	r3, r1, lsl #2
    4780:	01157ef0 			; <UNDEFINED> instruction: 0x01157ef0
    4784:	c0740350 	rsbsgt	r0, r4, r0, asr r3
    4788:	70180000 	andsvc	r0, r8, r0
    478c:	b300001d 	movwlt	r0, #29
    4790:	1500000d 	strne	r0, [r0, #-13]
    4794:	91035201 	tstls	r3, r1, lsl #4
    4798:	01157fb0 			; <UNDEFINED> instruction: 0x01157fb0
    479c:	90910351 	addsls	r0, r1, r1, asr r3
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47a0:	5001157f 	andpl	r1, r1, pc, ror r5
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    47a4:	00e07403 	rsceq	r7, r0, r3, lsl #8
    47a8:	1e1e0000 	cdpne	0, 1, cr0, cr14, cr0, {0}
    47ac:	01000016 	tsteq	r0, r6, lsl r0
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47b0:	1d74012a 	ldfnee	f0, [r4, #-168]!	; 0xffffff58
    47b4:	00840000 	addeq	r0, r4, r0
    47b8:	9c010000 	stcls	0, cr0, [r1], {-0}
    47bc:	00000d49 	andeq	r0, r0, r9, asr #26
    47c0:	0015be1f 	andseq	fp, r5, pc, lsl lr
    47c4:	012a0100 	teqeq	sl, r0, lsl #2
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47c8:	0000013f 	andeq	r0, r0, pc, lsr r1
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    47cc:	000011b2 			; <UNDEFINED> instruction: 0x000011b2
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47d0:	01007020 	tsteq	r0, r0, lsr #32
    47d4:	0145012a 	cmpeq	r5, sl, lsr #2
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47d8:	11de0000 	bicsne	r0, lr, r0
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47dc:	65200000 	strvs	r0, [r0, #-0]!
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47e0:	012b0100 	teqeq	fp, r0, lsl #2
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47e4:	00000111 	andeq	r0, r0, r1, lsl r1
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47e8:	0000120a 	andeq	r1, r0, sl, lsl #4
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47ec:	0100721d 	tsteq	r0, sp, lsl r2
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47f0:	00a7012d 	adceq	r0, r7, sp, lsr #2
    47f4:	91030000 	mrsls	r0, (UNDEF: 3)
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47f8:	69217de8 	stmdbvs	r1!, {r3, r5, r6, r7, r8, sl, fp, ip, sp, lr}
    47fc:	012e0100 	teqeq	lr, r0, lsl #2
    4800:	00000073 	andeq	r0, r0, r3, ror r0
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4804:	00001236 	andeq	r1, r0, r6, lsr r2
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4808:	00011c22 	andeq	r1, r1, r2, lsr #24
    480c:	001d8000 	andseq	r8, sp, r0
    4810:	00000a00 	andeq	r0, r0, r0, lsl #20
    4814:	01300100 	teqeq	r0, r0, lsl #2
    4818:	00000c09 	andeq	r0, r0, r9, lsl #24
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    481c:	0001331a 	andeq	r3, r1, sl, lsl r3
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4820:	20030600 	andcs	r0, r3, r0, lsl #12
    4824:	9f000071 	svcls	0x00000071
    4828:	00012811 	andeq	r2, r1, r1, lsl r8
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    482c:	00126e00 	andseq	r6, r2, r0, lsl #28
    4830:	1d8a1800 	stcne	8, cr1, [sl]
    4834:	0e910000 	cdpeq	0, 9, cr0, cr1, cr0, {0}
    4838:	01150000 	tsteq	r5, r0
    483c:	80080252 	andhi	r0, r8, r2, asr r2
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4840:	05510115 	ldrbeq	r0, [r1, #-277]	; 0x115
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4844:	00712003 	rsbseq	r2, r1, r3
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4848:	50011500 	andpl	r1, r1, r0, lsl #10
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    484c:	00007d02 	andeq	r7, r0, r2, lsl #26
    4850:	03902300 	orrseq	r2, r0, #0, 6
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4854:	0d090000 	stceq	0, cr0, [r9, #-0]
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4858:	62210000 	eorvs	r0, r1, #0
    485c:	01007469 	tsteq	r0, r9, ror #8
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4860:	01170133 	tsteq	r7, r3, lsr r1
    4864:	129d0000 	addsne	r0, sp, #0
    4868:	731d0000 	tstvc	sp, #0
    486c:	01340100 	teqeq	r4, r0, lsl #2
    4870:	000000a7 	andeq	r0, r0, r7, lsr #1
    4874:	7ee89103 	urdvce	f1, f3
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4878:	001d9e14 	andseq	r9, sp, r4, lsl lr
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    487c:	0008c300 	andeq	ip, r8, r0, lsl #6
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4880:	000c4a00 	andeq	r4, ip, r0, lsl #20
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4884:	51011500 	tstpl	r1, r0, lsl #10
    4888:	15007d02 	strne	r7, [r0, #-3330]	; 0xd02
    488c:	7d025001 	stcvc	0, cr5, [r2, #-4]
    4890:	ac140000 	ldcge	0, cr0, [r4], {-0}
    4894:	b900001d 	stmdblt	r0, {r0, r2, r3, r4}
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4898:	6b000005 	blvs	48b4 <sha256_process+0x17d4>
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    489c:	1500000c 	strne	r0, [r0, #-12]
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48a0:	77025201 	strvc	r5, [r2, -r1, lsl #4]
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    48a4:	51011500 	tstpl	r1, r0, lsl #10
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48a8:	15007d02 	strne	r7, [r0, #-3330]	; 0xd02
    48ac:	91035001 	tstls	r3, r1
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    48b0:	14007ee8 	strne	r7, [r0], #-3816	; 0xee8
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48b4:	00001db8 			; <UNDEFINED> instruction: 0x00001db8
    48b8:	00000e57 	andeq	r0, r0, r7, asr lr
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48bc:	00000c92 	muleq	r0, r2, ip
    48c0:	02530115 	subseq	r0, r3, #1073741829	; 0x40000005
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48c4:	01150075 	tsteq	r5, r5, ror r0
    48c8:	e8910352 	ldm	r1, {r1, r4, r6, r8, r9}
    48cc:	5101157e 	tstpl	r1, lr, ror r5
    48d0:	15007d02 	strne	r7, [r0, #-3330]	; 0xd02
    48d4:	7d025001 	stcvc	0, cr5, [r2, #-4]
    48d8:	c4140000 	ldrgt	r0, [r4], #-0
    48dc:	5700001d 	smladpl	r0, sp, r0, r0
    48e0:	bb00000e 	bllt	4920 <sha256_process+0x1840>
    48e4:	1500000c 	strne	r0, [r0, #-12]
    48e8:	75025301 	strvc	r5, [r2, #-769]	; 0x301
    48ec:	52011500 	andpl	r1, r1, #0, 10
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    48f0:	7f889103 	svcvc	0x00889103
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48f4:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48f8:	157e8891 	ldrbne	r8, [lr, #-2193]!	; 0x891
    48fc:	91035001 	tstls	r3, r1
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4900:	14007e88 	strne	r7, [r0], #-3720	; 0xe88
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4904:	00001dd0 	ldrdeq	r1, [r0], -r0
    4908:	00000e57 	andeq	r0, r0, r7, asr lr
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    490c:	00000ce3 	andeq	r0, r0, r3, ror #25
    4910:	02530115 	subseq	r0, r3, #1073741829	; 0x40000005
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4914:	01150075 	tsteq	r5, r5, ror r0
    4918:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    491c:	03510115 	cmpeq	r1, #1073741829	; 0x40000005
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4920:	157ec891 	ldrbne	ip, [lr, #-2193]!	; 0x891
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4924:	91035001 	tstls	r3, r1
    4928:	18007ec8 	stmdane	r0, {r3, r6, r7, r9, sl, fp, ip, sp, lr}
    492c:	00001dde 	ldrdeq	r1, [r0], -lr
    4930:	00000e57 	andeq	r0, r0, r7, asr lr
    4934:	02530115 	subseq	r0, r3, #1073741829	; 0x40000005
    4938:	01150075 	tsteq	r5, r5, ror r0
    493c:	a8910352 	ldmge	r1, {r1, r4, r6, r8, r9}
    4940:	5101157f 	tstpl	r1, pc, ror r5
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4944:	7ea89103 	tanvce	f1, f3
    4948:	03500115 	cmpeq	r0, #1073741829	; 0x40000005
    494c:	007ea891 			; <UNDEFINED> instruction: 0x007ea891
    4950:	011c2400 	tsteq	ip, r0, lsl #8
    4954:	1de20000 	stclne	0, cr0, [r2]
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4958:	000a0000 	andeq	r0, sl, r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    495c:	3f010000 	svccc	0x00010000
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4960:	01331101 	teqeq	r3, r1, lsl #2
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4964:	12b00000 	adcsne	r0, r0, #0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4968:	28110000 	ldmdacs	r1, {}	; <UNPREDICTABLE>
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    496c:	df000001 	svcle	0x00000001
    4970:	18000012 	stmdane	r0, {r1, r4}
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4974:	00001dec 	andeq	r1, r0, ip, ror #27
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4978:	00000e91 	muleq	r0, r1, lr
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    497c:	02520115 	subseq	r0, r2, #1073741829	; 0x40000005
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4980:	01158008 	tsteq	r5, r8
    4984:	007d0251 	rsbseq	r0, sp, r1, asr r2
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4988:	02500115 	subseq	r0, r0, #1073741829	; 0x40000005
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    498c:	00000078 	andeq	r0, r0, r8, ror r0
    4990:	16a52500 	strtne	r2, [r5], r0, lsl #10
    4994:	57010000 	strpl	r0, [r1, -r0]
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4998:	00000d5a 	andeq	r0, r0, sl, asr sp
    499c:	72200305 	eorvc	r0, r0, #335544320	; 0x14000000
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    49a0:	dc0d0000 	stcle	0, cr0, [sp], {-0}
    49a4:	25000000 	strcs	r0, [r0, #-0]
    49a8:	000016af 	andeq	r1, r0, pc, lsr #13
    49ac:	0d5a9501 	cfldr64eq	mvdx9, [sl, #-4]
    49b0:	03050000 	movweq	r0, #20480	; 0x5000
    49b4:	00007100 	andeq	r7, r0, r0, lsl #2
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49b8:	00148926 	andseq	r8, r4, r6, lsr #18
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    49bc:	5a1c0200 	bpl	7051c4 <_etext+0x6fdbb0>
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49c0:	2700000d 	strcs	r0, [r0, -sp]
    49c4:	0000168b 	andeq	r1, r0, fp, lsl #13
    49c8:	014b1401 	cmpeq	fp, r1, lsl #8
    49cc:	03050000 	movweq	r0, #20480	; 0x5000
    49d0:	000071a0 	andeq	r7, r0, r0, lsr #3
    49d4:	00164a27 	andseq	r4, r6, r7, lsr #20
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49d8:	4b2a0100 	blmi	a84de0 <_etext+0xa7d7cc>
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49dc:	05000001 	streq	r0, [r0, #-1]
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49e0:	00712003 	rsbseq	r2, r1, r3
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49e4:	162c2800 	strtne	r2, [ip], -r0, lsl #16
    49e8:	1f020000 	svcne	0x00020000
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49ec:	00000db3 			; <UNDEFINED> instruction: 0x00000db3
    49f0:	00010b29 	andeq	r0, r1, r9, lsr #22
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49f4:	008c2900 	addeq	r2, ip, r0, lsl #18
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49f8:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    49fc:	00001565 	andeq	r1, r0, r5, ror #10
    4a00:	0dce4402 	cfstrdeq	mvd4, [lr, #8]
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a04:	0b290000 	bleq	a44a0c <_etext+0xa3d3f8>
    4a08:	29000001 	stmdbcs	r0, {r0}
    4a0c:	00000111 	andeq	r0, r0, r1, lsl r1
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a10:	00011129 	andeq	r1, r1, r9, lsr #2
    4a14:	7a280000 	bvc	a04a1c <_etext+0x9fd408>
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a18:	02000015 	andeq	r0, r0, #21
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a1c:	000de451 	andeq	lr, sp, r1, asr r4
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a20:	010b2900 	tsteq	fp, r0, lsl #18
    4a24:	11290000 	teqne	r9, r0
    4a28:	00000001 	andeq	r0, r0, r1
    4a2c:	00155428 	andseq	r5, r5, r8, lsr #8
    4a30:	f5280200 			; <UNDEFINED> instruction: 0xf5280200
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a34:	2900000d 	stmdbcs	r0, {r0, r2, r3}
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a38:	0000010b 	andeq	r0, r0, fp, lsl #2
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a3c:	146c2800 	strbtne	r2, [ip], #-2048	; 0x800
    4a40:	3a020000 	bcc	84a48 <_etext+0x7d434>
    4a44:	00000e10 	andeq	r0, r0, r0, lsl lr
    4a48:	00010b29 	andeq	r0, r1, r9, lsr #22
    4a4c:	01112900 	tsteq	r1, r0, lsl #18
    4a50:	11290000 	teqne	r9, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a54:	00000001 	andeq	r0, r0, r1
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a58:	00154428 	andseq	r4, r5, r8, lsr #8
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a5c:	2b3b0200 	blcs	ec5264 <_etext+0xebdc50>
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a60:	2900000e 	stmdbcs	r0, {r1, r2, r3}
    4a64:	0000010b 	andeq	r0, r0, fp, lsl #2
    4a68:	00011129 	andeq	r1, r1, r9, lsr #2
    4a6c:	01112900 	tsteq	r1, r0, lsl #18
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a70:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a74:	0000165a 	andeq	r1, r0, sl, asr r6
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a78:	0e415a02 	vmlaeq.f32	s11, s2, s4
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a7c:	0b290000 	bleq	a44a84 <_etext+0xa3d470>
    4a80:	29000001 	stmdbcs	r0, {r0}
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a84:	00000111 	andeq	r0, r0, r1, lsl r1
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a88:	16662800 	strbtne	r2, [r6], -r0, lsl #16
    4a8c:	3e020000 	cdpcc	0, 0, cr0, cr2, cr0, {0}
    4a90:	00000e57 	andeq	r0, r0, r7, asr lr
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a94:	00010b29 	andeq	r0, r1, r9, lsr #22
    4a98:	01112900 	tsteq	r1, r0, lsl #18
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a9c:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    4aa0:	0000158f 	andeq	r1, r0, pc, lsl #11
    4aa4:	0e773302 	cdpeq	3, 7, cr3, cr7, cr2, {0}
    4aa8:	0b290000 	bleq	a44ab0 <_etext+0xa3d49c>
    4aac:	29000001 	stmdbcs	r0, {r0}
    4ab0:	00000111 	andeq	r0, r0, r1, lsl r1
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4ab4:	00011129 	andeq	r1, r1, r9, lsr #2
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4ab8:	00812900 	addeq	r2, r1, r0, lsl #18
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4abc:	2a000000 	bcs	4ac4 <sha256_process+0x19e4>
    4ac0:	000015b4 			; <UNDEFINED> instruction: 0x000015b4
    4ac4:	00812d02 	addeq	r2, r1, r2, lsl #26
    4ac8:	0e910000 	cdpeq	0, 9, cr0, cr1, cr0, {0}
    4acc:	11290000 	teqne	r9, r0
    4ad0:	29000001 	stmdbcs	r0, {r0}
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4ad4:	00000111 	andeq	r0, r0, r1, lsl r1
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4ad8:	15c42b00 	strbne	r2, [r4, #2816]	; 0xb00
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4adc:	009e0000 	addseq	r0, lr, r0
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4ae0:	0eae0000 	cdpeq	0, 10, cr0, cr14, cr0, {0}
    4ae4:	9e290000 	cdpls	0, 2, cr0, cr9, cr0, {0}
    4ae8:	29000000 	stmdbcs	r0, {}	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4aec:	00000eae 	andeq	r0, r0, lr, lsr #29
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4af0:	00009729 	andeq	r9, r0, r9, lsr #14
    4af4:	040c0000 	streq	r0, [ip], #-0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4af8:	00000eb4 			; <UNDEFINED> instruction: 0x00000eb4
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4afc:	0b58002c 	bleq	1604bb4 <_etext+0x15fd5a0>
    4b00:	00040000 	andeq	r0, r4, r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b04:	000011ef 	andeq	r1, r0, pc, ror #3
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b08:	14a60104 	strtne	r0, [r6], #260	; 0x104
    4b0c:	d1010000 	mrsle	r0, (UNDEF: 1)
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b10:	93000016 	movwls	r0, #22
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b14:	00000008 	andeq	r0, r0, r8
    4b18:	00000005 	andeq	r0, r0, r5
    4b1c:	03000000 	movweq	r0, #0
    4b20:	02000015 	andeq	r0, r0, #21
    4b24:	081a0601 	ldmdaeq	sl, {r0, r9, sl}
    4b28:	d9030000 	stmdble	r3, {}	; <UNPREDICTABLE>
    4b2c:	0400000a 	streq	r0, [r0], #-10
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b30:	0000371c 	andeq	r3, r0, ip, lsl r7
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b34:	08010200 	stmdaeq	r1, {r9}
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b38:	00000818 	andeq	r0, r0, r8, lsl r8
    4b3c:	fc050202 	stc2	2, cr0, [r5], {2}
    4b40:	02000006 	andeq	r0, r0, #6
    4b44:	09490702 	stmdbeq	r9, {r1, r8, r9, sl}^
    4b48:	04020000 	streq	r0, [r2], #-0
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b4c:	0004da05 	andeq	sp, r4, r5, lsl #20
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b50:	07040200 	streq	r0, [r4, -r0, lsl #4]
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b54:	00000252 	andeq	r0, r0, r2, asr r2
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b58:	d5050802 	strle	r0, [r5, #-2050]	; 0x802
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b5c:	03000004 	movweq	r0, #4
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b60:	00001743 	andeq	r1, r0, r3, asr #14
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b64:	006c4e04 	rsbeq	r4, ip, r4, lsl #28
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b68:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b6c:	00024d07 	andeq	r4, r2, r7, lsl #26
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b70:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b74:	00746e69 	rsbseq	r6, r4, r9, ror #28
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b78:	57070402 	strpl	r0, [r7, -r2, lsl #8]
    4b7c:	03000002 	movweq	r0, #2
    4b80:	00000adb 	ldrdeq	r0, [r0], -fp
    4b84:	002c2a05 	eoreq	r2, ip, r5, lsl #20
    4b88:	45030000 	strmi	r0, [r3, #-0]
    4b8c:	05000017 	streq	r0, [r0, #-23]
    4b90:	0000614e 	andeq	r6, r0, lr, asr #2
    4b94:	0ae30300 	beq	ff8c579c <BootRAM+0xe835f3d>
    4b98:	d4060000 	strle	r0, [r6], #-0
    4b9c:	0000007a 	andeq	r0, r0, sl, ror r0
    4ba0:	8b070402 	blhi	1c5bb0 <_etext+0x1be59c>
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ba4:	05000007 	streq	r0, [r0, #-7]
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4ba8:	08010204 	stmdaeq	r1, {r2, r9}
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bac:	00000821 	andeq	r0, r0, r1, lsr #16
    4bb0:	00168006 	andseq	r8, r6, r6
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4bb4:	20038000 	andcs	r8, r3, r0
    4bb8:	000000e7 	andeq	r0, r0, r7, ror #1
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bbc:	03007807 	movweq	r7, #2055	; 0x807
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4bc0:	0000e721 	andeq	lr, r0, r1, lsr #14
    4bc4:	79070000 	stmdbvc	r7, {}	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bc8:	e7220300 	str	r0, [r2, -r0, lsl #6]!
    4bcc:	20000000 	andcs	r0, r0, r0
    4bd0:	03007407 	movweq	r7, #1031	; 0x407
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bd4:	0000e723 	andeq	lr, r0, r3, lsr #14
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bd8:	7a074000 	bvc	1d4be0 <_etext+0x1cd5cc>
    4bdc:	e7240300 	str	r0, [r4, -r0, lsl #6]!
    4be0:	60000000 	andvs	r0, r0, r0
    4be4:	00810800 	addeq	r0, r1, r0, lsl #16
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4be8:	00f70000 	rscseq	r0, r7, r0
    4bec:	a2090000 	andge	r0, r9, #0
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bf0:	1f000000 	svcne	0x00000000
    4bf4:	17b20600 	ldrne	r0, [r2, r0, lsl #12]!
    4bf8:	02400000 	subeq	r0, r0, #0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bfc:	00010e14 	andeq	r0, r1, r4, lsl lr
    4c00:	00680700 	rsbeq	r0, r8, r0, lsl #14
    4c04:	010e1502 	tsteq	lr, r2, lsl #10
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4c08:	00000000 	andeq	r0, r0, r0
    4c0c:	00008c08 	andeq	r8, r0, r8, lsl #24
    4c10:	00011e00 	andeq	r1, r1, r0, lsl #28
    4c14:	00a20900 	adceq	r0, r2, r0, lsl #18
    4c18:	00070000 	andeq	r0, r7, r0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c1c:	0017cd0a 	andseq	ip, r7, sl, lsl #26
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4c20:	031c0200 	tsteq	ip, #0, 4
    4c24:	00000134 	andeq	r0, r0, r4, lsr r1
    4c28:	0200730b 	andeq	r7, r0, #738197504	; 0x2c000000
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c2c:	0001341c 	andeq	r3, r1, ip, lsl r4
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4c30:	040c0000 	streq	r0, [ip], #-0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c34:	000000f7 	strdeq	r0, [r0], -r7
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c38:	0016e00a 	andseq	lr, r6, sl
    4c3c:	033e0300 	teqeq	lr, #0, 6
    4c40:	00000150 	andeq	r0, r0, r0, asr r1
    4c44:	0300650b 	movweq	r6, #1291	; 0x50b
    4c48:	0001503e 	andeq	r5, r1, lr, lsr r0
    4c4c:	040c0000 	streq	r0, [ip], #-0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c50:	00000081 	andeq	r0, r0, r1, lsl #1
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c54:	0017870a 	andseq	r8, r7, sl, lsl #14
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c58:	01420100 	mrseq	r0, (UNDEF: 82)
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c5c:	000001ae 	andeq	r0, r0, lr, lsr #3
    4c60:	0017250d 	andseq	r2, r7, sp, lsl #10
    4c64:	50420100 	subpl	r0, r2, r0, lsl #2
    4c68:	0d000001 	stceq	0, cr0, [r0, #-4]
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c6c:	000016c6 	andeq	r1, r0, r6, asr #13
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c70:	01504301 	cmpeq	r0, r1, lsl #6
    4c74:	4e0d0000 	cdpmi	0, 0, cr0, cr13, cr0, {0}
    4c78:	01000017 	tsteq	r0, r7, lsl r0
    4c7c:	00007343 	andeq	r7, r0, r3, asr #6
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c80:	177f0d00 	ldrbne	r0, [pc, -r0, lsl #26]!
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c84:	44010000 	strmi	r0, [r1], #-0
    4c88:	000001ae 	andeq	r0, r0, lr, lsr #3
    4c8c:	6e656c0b 	cdpvs	12, 6, cr6, cr5, cr11, {0}
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c90:	97440100 	strbls	r0, [r4, -r0, lsl #2]
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c94:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    4c98:	46010073 			; <UNDEFINED> instruction: 0x46010073
    4c9c:	000000f7 	strdeq	r0, [r0], -r7
    4ca0:	00690e0f 	rsbeq	r0, r9, pc, lsl #28
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4ca4:	00974e01 	addseq	r4, r7, r1, lsl #28
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4ca8:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cac:	01b4040c 			; <UNDEFINED> instruction: 0x01b4040c
    4cb0:	81100000 	tsthi	r0, r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4cb4:	0a000000 	beq	4cbc <sha256_process+0x1bdc>
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cb8:	0000171a 	andeq	r1, r0, sl, lsl r7
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4cbc:	e5011501 	str	r1, [r1, #-1281]	; 0x501
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cc0:	0d000001 	stceq	0, cr0, [r0, #-4]
    4cc4:	00001733 	andeq	r1, r0, r3, lsr r7
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4cc8:	01501501 	cmpeq	r0, r1, lsl #10
    4ccc:	2c0d0000 	stccs	0, cr0, [sp], {-0}
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cd0:	01000017 	tsteq	r0, r7, lsl r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4cd4:	0001ae15 	andeq	sl, r1, r5, lsl lr
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cd8:	00730e00 	rsbseq	r0, r3, r0, lsl #28
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4cdc:	00f71701 	rscseq	r1, r7, r1, lsl #14
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4ce0:	0a000000 	beq	4ce8 <sha256_process+0x1c08>
    4ce4:	000017aa 	andeq	r1, r0, sl, lsr #15
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4ce8:	0d013201 	sfmeq	f3, 4, [r1, #-4]
    4cec:	0b000002 	bleq	4cfc <sha256_process+0x1c1c>
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cf0:	32010072 	andcc	r0, r1, #114	; 0x72
    4cf4:	00000150 	andeq	r0, r0, r0, asr r1
    4cf8:	01006b0b 	tsteq	r0, fp, lsl #22
    4cfc:	0001ae32 	andeq	sl, r1, r2, lsr lr
    4d00:	00700e00 	rsbseq	r0, r0, r0, lsl #28
    4d04:	00b23401 	adcseq	r3, r2, r1, lsl #8
    4d08:	11000000 	mrsne	r0, (UNDEF: 0)
    4d0c:	01007070 	tsteq	r0, r0, ror r0
    4d10:	023f0129 	eorseq	r0, pc, #1073741834	; 0x4000000a
    4d14:	3c0d0000 	stccc	0, cr0, [sp], {-0}
    4d18:	01000017 	tsteq	r0, r7, lsl r0
    4d1c:	00015029 	andeq	r5, r1, r9, lsr #32
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d20:	00700b00 	rsbseq	r0, r0, r0, lsl #22
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d24:	023f2901 	eorseq	r2, pc, #16384	; 0x4000
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d28:	780e0000 	stmdavc	lr, {}	; <UNPREDICTABLE>
    4d2c:	e72b0100 	str	r0, [fp, -r0, lsl #2]!
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d30:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    4d34:	2c010079 	stccs	0, cr0, [r1], {121}	; 0x79
    4d38:	000000e7 	andeq	r0, r0, r7, ror #1
    4d3c:	45040c00 	strmi	r0, [r4, #-3072]	; 0xc00
    4d40:	10000002 	andne	r0, r0, r2
    4d44:	000000b2 	strheq	r0, [r0], -r2
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d48:	00179812 	andseq	r9, r7, r2, lsl r8
    4d4c:	003a0100 	eorseq	r0, sl, r0, lsl #2
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d50:	7c000000 	stcvc	0, cr0, [r0], {-0}
    4d54:	01000000 	mrseq	r0, (UNDEF: 0)
    4d58:	0004089c 	muleq	r4, ip, r8
    4d5c:	75701300 	ldrbvc	r1, [r0, #-768]!	; 0x300
    4d60:	3a010062 	bcc	44ef0 <_etext+0x3d8dc>
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d64:	00000150 	andeq	r0, r0, r0, asr r1
    4d68:	00001300 	andeq	r1, r0, r0, lsl #6
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d6c:	00172c14 	andseq	r2, r7, r4, lsl ip
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d70:	ae3a0100 	rsfgee	f0, f2, f0
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d74:	2c000001 	stccs	0, cr0, [r0], {1}
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d78:	15000013 	strne	r0, [r0, #-19]
    4d7c:	00001733 	andeq	r1, r0, r3, lsr r7
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d80:	04083c01 	streq	r3, [r8], #-3073	; 0xc01
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d84:	91030000 	mrsls	r0, (UNDEF: 3)
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d88:	b9167ea8 	ldmdblt	r6, {r3, r5, r7, r9, sl, fp, ip, sp, lr}
    4d8c:	00000001 	andeq	r0, r0, r1
    4d90:	e8000000 	stmda	r0, {}	; <UNPREDICTABLE>
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d94:	01000003 	tsteq	r0, r3
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d98:	00033d3e 	andeq	r3, r3, lr, lsr sp
    4d9c:	01d01700 	bicseq	r1, r0, r0, lsl #14
    4da0:	13580000 	cmpne	r8, #0
    4da4:	c5170000 	ldrgt	r0, [r7, #-0]
    4da8:	84000001 	strhi	r0, [r0], #-1
    4dac:	18000013 	stmdane	r0, {r0, r1, r4}
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4db0:	000003e8 	andeq	r0, r0, r8, ror #7
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4db4:	0001db19 	andeq	sp, r1, r9, lsl fp
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4db8:	e8910300 	ldm	r1, {r8, r9}
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4dbc:	011e167e 	tsteq	lr, lr, ror r6
    4dc0:	00000000 	andeq	r0, r0, r0
    4dc4:	04180000 	ldreq	r0, [r8], #-0
    4dc8:	19010000 	stmdbne	r1, {}	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dcc:	000002dc 	ldrdeq	r0, [r0], -ip
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4dd0:	00012a17 	andeq	r2, r1, r7, lsl sl
    4dd4:	0013da00 	andseq	sp, r3, r0, lsl #20
    4dd8:	3a160000 	bcc	584de0 <_etext+0x57d7cc>
    4ddc:	00000001 	andeq	r0, r0, r1
    4de0:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    4de4:	01000004 	tsteq	r0, r4
    4de8:	0002f91c 	andeq	pc, r2, ip, lsl r9	; <UNPREDICTABLE>
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dec:	01461700 	cmpeq	r6, r0, lsl #14
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4df0:	14920000 	ldrne	r0, [r2], #0
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4df4:	1a000000 	bne	4dfc <sha256_process+0x1d1c>
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4df8:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4dfc:	00000a04 	andeq	r0, r0, r4, lsl #20
    4e00:	00000319 	andeq	r0, r0, r9, lsl r3
    4e04:	0252011b 	subseq	r0, r2, #-1073741818	; 0xc0000006
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4e08:	011b2008 	tsteq	fp, r8
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e0c:	00770251 	rsbseq	r0, r7, r1, asr r2
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4e10:	0250011b 	subseq	r0, r0, #-1073741818	; 0xc0000006
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e14:	1c005074 	stcne	0, cr5, [r0], {116}	; 0x74
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e18:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e1c:	00000a1f 	andeq	r0, r0, pc, lsl sl
    4e20:	0253011b 	subseq	r0, r3, #-1073741818	; 0xc0000006
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e24:	011b4008 	tsteq	fp, r8
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e28:	1b300152 	blne	c05378 <_etext+0xbfdd64>
    4e2c:	91035101 	tstls	r3, r1, lsl #2
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4e30:	011b7ea8 	tsteq	fp, r8, lsr #29
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e34:	50740250 	rsbspl	r0, r4, r0, asr r2
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4e38:	1d000000 	stcne	0, cr0, [r0, #-0]
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e3c:	000001e5 	andeq	r0, r0, r5, ror #3
    4e40:	00000000 	andeq	r0, r0, r0
    4e44:	00000458 	andeq	r0, r0, r8, asr r4
    4e48:	fa173f01 	blx	5d4a54 <_etext+0x5cd440>
    4e4c:	cf000001 	svcgt	0x00000001
    4e50:	17000014 	smladne	r0, r4, r0, r0
    4e54:	000001f1 	strdeq	r0, [r0], -r1
    4e58:	000014fe 	strdeq	r1, [r0], -lr
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e5c:	00045818 	andeq	r5, r4, r8, lsl r8
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e60:	02031900 	andeq	r1, r3, #0, 18
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e64:	91030000 	mrsls	r0, (UNDEF: 3)
    4e68:	0d1e7ee8 	ldceq	14, cr7, [lr, #-928]	; 0xfffffc60
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e6c:	00000002 	andeq	r0, r0, r2
    4e70:	14000000 	strne	r0, [r0], #-0
    4e74:	01000000 	mrseq	r0, (UNDEF: 0)
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e78:	0003ed37 	andeq	lr, r3, r7, lsr sp
    4e7c:	02231700 	eoreq	r1, r3, #0, 14
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e80:	151f0000 	ldrne	r0, [pc, #-0]	; 4e88 <sha256_process+0x1da8>
    4e84:	18170000 	ldmdane	r7, {}	; <UNPREDICTABLE>
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e88:	5c000002 	stcpl	0, cr0, [r0], {2}
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e8c:	1f000015 	svcne	0x00000015
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e90:	00000000 	andeq	r0, r0, r0
    4e94:	00000014 	andeq	r0, r0, r4, lsl r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e98:	00022c19 	andeq	r2, r2, r9, lsl ip
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e9c:	e8910300 	ldm	r1, {r8, r9}
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ea0:	0235197d 	eorseq	r1, r5, #2048000	; 0x1f4000
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ea4:	91030000 	mrsls	r0, (UNDEF: 3)
    4ea8:	001a7e88 	andseq	r7, sl, r8, lsl #29
    4eac:	45000000 	strmi	r0, [r0, #-0]
    4eb0:	ce00000a 	cdpgt	0, 0, cr0, cr0, cr10, {0}
    4eb4:	1b000003 	blne	4ec8 <sha256_process+0x1de8>
    4eb8:	91035201 	tstls	r3, r1, lsl #4
    4ebc:	011b7ee8 	tsteq	fp, r8, ror #29
    4ec0:	88910351 	ldmhi	r1, {r0, r4, r6, r8, r9}
    4ec4:	50011b7e 	andpl	r1, r1, lr, ror fp
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ec8:	00007d02 	andeq	r7, r0, r2, lsl #26
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ecc:	0000001c 	andeq	r0, r0, ip, lsl r0
    4ed0:	000a6000 	andeq	r6, sl, r0
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ed4:	52011b00 	andpl	r1, r1, #0, 22
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ed8:	7e889103 	sinvce	f1, f3
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4edc:	0251011b 	subseq	r0, r1, #-1073741818	; 0xc0000006
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ee0:	011b007d 	tsteq	fp, sp, ror r0
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ee4:	00760250 	rsbseq	r0, r6, r0, asr r2
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ee8:	1c000000 	stcne	0, cr0, [r0], {-0}
    4eec:	00000000 	andeq	r0, r0, r0
    4ef0:	00000a7b 	andeq	r0, r0, fp, ror sl
    4ef4:	0352011b 	cmpeq	r2, #-1073741818	; 0xc0000006
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ef8:	1b7ea891 	blne	1faf144 <_etext+0x1fa7b30>
    4efc:	91035001 	tstls	r3, r1
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4f00:	00007ee8 	andeq	r7, r0, r8, ror #29
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f04:	81080000 	mrshi	r0, (UNDEF: 8)
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4f08:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f0c:	09000004 	stmdbeq	r0, {r2}
    4f10:	000000a2 	andeq	r0, r0, r2, lsr #1
    4f14:	7a0a003f 	bvc	285018 <_etext+0x27da04>
    4f18:	01000017 	tsteq	r0, r7, lsl r0
    4f1c:	045f0169 	ldrbeq	r0, [pc], #-361	; 4f24 <sha256_process+0x1e44>
    4f20:	7a0b0000 	bvc	2c4f28 <_etext+0x2bd914>
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f24:	50690100 	rsbpl	r0, r9, r0, lsl #2
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f28:	0b000001 	bleq	4f34 <sha256_process+0x1e54>
    4f2c:	69010072 	stmdbvs	r1, {r1, r4, r5, r6}
    4f30:	000001ae 	andeq	r0, r0, lr, lsr #3
    4f34:	0100610b 	tsteq	r0, fp, lsl #2
    4f38:	0001ae69 	andeq	sl, r1, r9, ror #28
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f3c:	006d0b00 	rsbeq	r0, sp, r0, lsl #22
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f40:	01ae6a01 			; <UNDEFINED> instruction: 0x01ae6a01
    4f44:	6c0b0000 	stcvs	0, cr0, [fp], {-0}
    4f48:	01006e65 	tsteq	r0, r5, ror #28
    4f4c:	0000976a 	andeq	r9, r0, sl, ror #14
    4f50:	17e02000 	strbne	r2, [r0, r0]!
    4f54:	6c010000 	stcvs	0, cr0, [r1], {-0}
    4f58:	0000045f 	andeq	r0, r0, pc, asr r4
    4f5c:	00810800 	addeq	r0, r1, r0, lsl #16
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f60:	046f0000 	strbteq	r0, [pc], #-0	; 4f68 <sha256_process+0x1e88>
    4f64:	a2090000 	andge	r0, r9, #0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f68:	7f000000 	svcvc	0x00000000
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f6c:	70752100 	rsbsvc	r2, r5, r0, lsl #2
    4f70:	1f010070 	svcne	0x00010070
    4f74:	00000081 	andeq	r0, r0, r1, lsl #1
    4f78:	0004b001 	andeq	fp, r4, r1
    4f7c:	00700b00 	rsbseq	r0, r0, r0, lsl #22
    4f80:	04b01f01 	ldrteq	r1, [r0], #3841	; 0xf01
    4f84:	3c0d0000 	stccc	0, cr0, [sp], {-0}
    4f88:	01000017 	tsteq	r0, r7, lsl r0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f8c:	0001ae1f 	andeq	sl, r1, pc, lsl lr
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f90:	00780e00 	rsbseq	r0, r8, r0, lsl #28
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f94:	00e72101 	rsceq	r2, r7, r1, lsl #2
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f98:	790e0000 	stmdbvc	lr, {}	; <UNPREDICTABLE>
    4f9c:	e7220100 	str	r0, [r2, -r0, lsl #2]!
    4fa0:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    4fa4:	01006b6f 	tsteq	r0, pc, ror #22
    4fa8:	00008123 	andeq	r8, r0, r3, lsr #2
    4fac:	040c0000 	streq	r0, [ip], #-0
    4fb0:	000000b2 	strheq	r0, [r0], -r2
    4fb4:	0017bf22 	andseq	fp, r7, r2, lsr #30
    4fb8:	818c0100 	orrhi	r0, ip, r0, lsl #2
    4fbc:	f8000000 			; <UNDEFINED> instruction: 0xf8000000
    4fc0:	7c00001d 	stcvc	0, cr0, [r0], {29}
    4fc4:	01000001 	tsteq	r0, r1
    4fc8:	0009d39c 	muleq	r9, ip, r3
    4fcc:	17101400 	ldrne	r1, [r0, -r0, lsl #8]
    4fd0:	8c010000 	stchi	0, cr0, [r1], {-0}
    4fd4:	000001ae 	andeq	r0, r0, lr, lsr #3
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    ctx->state[7] += H;
    4fd8:	0000157d 	andeq	r1, r0, sp, ror r5
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4fdc:	62757013 	rsbsvs	r7, r5, #19

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    4fe0:	ae8c0100 	rmfgee	f0, f4, f0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4fe4:	9b000001 	blls	4ff0 <sha256_process+0x1f10>
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    4fe8:	14000015 	strne	r0, [r0], #-21
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4fec:	0000177f 	andeq	r1, r0, pc, ror r7

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    4ff0:	01ae8d01 			; <UNDEFINED> instruction: 0x01ae8d01
    4ff4:	15b90000 	ldrne	r0, [r9, #0]!
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    4ff8:	6c130000 	ldcvs	0, cr0, [r3], {-0}
    ctx->state[1] += B;
    4ffc:	01006e65 	tsteq	r0, r5, ror #28
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    5000:	0000978d 	andeq	r9, r0, sp, lsl #15
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    5004:	0015d700 	andseq	sp, r5, r0, lsl #14
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    5008:	00702300 	rsbseq	r2, r0, r0, lsl #6
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    500c:	00b28f01 	adcseq	r8, r2, r1, lsl #30
    ctx->state[4] += E;
    5010:	91030000 	mrsls	r0, (UNDEF: 3)
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    5014:	71237de0 	teqvc	r3, r0, ror #27
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    5018:	b2900100 	addslt	r0, r0, #0, 2
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    501c:	03000000 	movweq	r0, #0
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    5020:	237ee091 	cmncs	lr, #145	; 0x91
    ctx->state[7] += H;
    5024:	0073686c 	rsbseq	r6, r3, ip, ror #16
}
    5028:	00e79101 	rsceq	r9, r7, r1, lsl #2
    502c:	91030000 	mrsls	r0, (UNDEF: 3)
    5030:	72237cc0 	eorvc	r7, r3, #192, 24	; 0xc000
    5034:	01007368 	tsteq	r0, r8, ror #6
    5038:	0000e792 	muleq	r0, r2, r7
    503c:	e0910300 	adds	r0, r1, r0, lsl #6
    5040:	007a237c 	rsbseq	r2, sl, ip, ror r3

void sha256_update( sha256_context *ctx, uint8 *input, uint32 length )
{
    5044:	00e79301 	rsceq	r9, r7, r1, lsl #6
    uint32 left, fill;

    if( ! length ) return;
    5048:	91030000 	mrsls	r0, (UNDEF: 3)
    ctx->state[6] += G;
    ctx->state[7] += H;
}

void sha256_update( sha256_context *ctx, uint8 *input, uint32 length )
{
    504c:	6f247d80 	svcvs	0x00247d80
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    5050:	9401006b 	strls	r0, [r1], #-107	; 0x6b
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    5054:	00000081 	andeq	r0, r0, r1, lsl #1
{
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    5058:	000015f5 	strdeq	r1, [r0], -r5
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    505c:	00041816 	andeq	r1, r4, r6, lsl r8
        ctx->total[1]++;
    5060:	001e0200 	andseq	r0, lr, r0, lsl #4

    if( left && length >= fill )
    5064:	00047800 	andeq	r7, r4, r0, lsl #16
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5068:	06970100 	ldreq	r0, [r7], r0, lsl #2
    506c:	17000007 	strne	r0, [r0, -r7]
    {
        sha256_process( ctx, input );
        length -= 64;
    5070:	00000448 	andeq	r0, r0, r8, asr #8
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    5074:	00001636 	andeq	r1, r0, r6, lsr r6
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5078:	00043f17 	andeq	r3, r4, r7, lsl pc
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    507c:	00165400 	andseq	r5, r6, r0, lsl #8
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5080:	04361700 	ldrteq	r1, [r6], #-1792	; 0x700
    5084:	16720000 	ldrbtne	r0, [r2], -r0
    5088:	2d170000 	ldccs	0, cr0, [r7, #-0]
    508c:	90000004 	andls	r0, r0, r4
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    5090:	17000016 	smladne	r0, r6, r0, r0
    5094:	00000424 	andeq	r0, r0, r4, lsr #8
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    5098:	000016ae 	andeq	r1, r0, lr, lsr #13
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    509c:	00047818 	andeq	r7, r4, r8, lsl r8
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    50a0:	04531900 	ldrbeq	r1, [r3], #-2304	; 0x900
    50a4:	91030000 	mrsls	r0, (UNDEF: 3)
                (void *) input, length );
    }
}
    50a8:	561d7ee0 	ldrpl	r7, [sp], -r0, ror #29
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    50ac:	28000001 	stmdacs	r0, {r0}
    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
    50b0:	9800001e 	stmdals	r0, {r1, r2, r3, r4}
    50b4:	01000004 	tsteq	r0, r4
    50b8:	01782570 	cmneq	r8, r0, ror r5
    50bc:	26400000 	strbcs	r0, [r0], -r0
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    50c0:	0000018e 	andeq	r0, r0, lr, lsl #3
    50c4:	83265801 	teqhi	r6, #65536	; 0x10000
        length -= fill;
    50c8:	01000001 	tsteq	r0, r1
        input  += fill;
    50cc:	016d1759 	cmneq	sp, r9, asr r7
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    50d0:	16f60000 	ldrbtne	r0, [r6], r0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    50d4:	62170000 	andsvs	r0, r7, #0
    uint32 last, padn;
    uint32 high, low;
    uint8 msglen[8];

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    50d8:	06000001 	streq	r0, [r0], -r1
    low  = ( ctx->total[0] <<  3 );
    50dc:	18000018 	stmdane	r0, {r3, r4}

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );

    last = ctx->total[0] & 0x3F;
    50e0:	00000498 	muleq	r0, r8, r4
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    50e4:	00019919 	andeq	r9, r1, r9, lsl r9

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    50e8:	e0910300 	adds	r0, r1, r0, lsl #6
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    50ec:	011e167d 	tsteq	lr, sp, ror r6

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    50f0:	1e280000 	cdpne	0, 2, cr0, cr8, cr0, {0}
    50f4:	04c00000 	strbeq	r0, [r0], #0
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    50f8:	48010000 	stmdami	r1, {}	; <UNPREDICTABLE>
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    50fc:	0000060c 	andeq	r0, r0, ip, lsl #12
{
    uint32 last, padn;
    uint32 high, low;
    uint8 msglen[8];

    high = ( ctx->total[0] >> 29 )
    5100:	00012a17 	andeq	r2, r1, r7, lsl sl
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    5104:	00184e00 	andseq	r4, r8, r0, lsl #28
    5108:	e8270000 	stmda	r7!, {}	; <UNPREDICTABLE>
    510c:	71000004 	tstvc	r0, r4
    PUT_UINT32( low,  msglen, 4 );
    5110:	28000006 	stmdacs	r0, {r1, r2}
    5114:	000001a3 	andeq	r0, r0, r3, lsr #3

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;
    5118:	000019b6 			; <UNDEFINED> instruction: 0x000019b6
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

void sha256_finish( sha256_context *ctx, uint8 digest[32] )
{
    511c:	001e7c1a 	andseq	r7, lr, sl, lsl ip

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    5120:	000a9600 	andeq	r9, sl, r0, lsl #12
    5124:	00063a00 	andeq	r3, r6, r0, lsl #20
    5128:	51011b00 	tstpl	r1, r0, lsl #22
    512c:	7ee09103 	urdvcs	f1, f3
    PUT_UINT32( low,  msglen, 4 );
    5130:	0350011b 	cmpeq	r0, #-1073741818	; 0xc0000006
    5134:	007de091 			; <UNDEFINED> instruction: 0x007de091
    5138:	001e981a 	andseq	r9, lr, sl, lsl r8

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;
    513c:	000a9600 	andeq	r9, sl, r0, lsl #12

    if( left && length >= fill )
    5140:	00064f00 	andeq	r4, r6, r0, lsl #30
    5144:	50011b00 	andpl	r1, r1, r0, lsl #22
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    5148:	7de09103 	stfvcp	f1, [r0, #12]!
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    514c:	1eaa1c00 	cdpne	12, 10, cr1, cr10, cr0, {0}
    5150:	0a040000 	beq	105158 <_etext+0xfdb44>
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    5154:	011b0000 	tsteq	fp, r0
    {
        memcpy( (void *) (ctx->buffer + left),
    5158:	c0780352 	rsbsgt	r0, r8, r2, asr r3
    515c:	51011b00 	tstpl	r1, r0, lsl #22
    5160:	74007905 	strvc	r7, [r0], #-2309	; 0x905
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    5164:	011b2200 	tsteq	fp, r0, lsl #4
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    5168:	e0910350 	adds	r0, r1, r0, asr r3
{
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    516c:	1a00007d 	bne	5368 <sha512_block+0x7c>
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    5170:	00001eb6 			; <UNDEFINED> instruction: 0x00001eb6
        ctx->total[1]++;
    5174:	00000aac 	andeq	r0, r0, ip, lsr #21

    if( left && length >= fill )
    5178:	00000692 	muleq	r0, r2, r6
    517c:	0252011b 	subseq	r0, r2, #-1073741818	; 0xc0000006
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    5180:	011b0078 	tsteq	fp, r8, ror r0
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    5184:	00790251 	rsbseq	r0, r9, r1, asr r2
    5188:	0350011b 	cmpeq	r0, #-1073741818	; 0xc0000006
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    518c:	007fa091 			; <UNDEFINED> instruction: 0x007fa091
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    5190:	001ec21a 	andseq	ip, lr, sl, lsl r2
    5194:	000a0400 	andeq	r0, sl, r0, lsl #8
    5198:	0006b400 	andeq	fp, r6, r0, lsl #8
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    sha256_update( ctx, sha256_padding, padn );
    sha256_update( ctx, msglen, 8 );

    PUT_UINT32( ctx->state[0], digest,  0 );
    519c:	52011b00 	andpl	r1, r1, #0, 22
    51a0:	00c07803 	sbceq	r7, r0, r3, lsl #16
    51a4:	0351011b 	cmpeq	r1, #-1073741818	; 0xc0000006
    51a8:	1b7ee091 	blne	1fbd3f4 <_etext+0x1fb5de0>
    51ac:	74025001 	strvc	r5, [r2], #-1
    PUT_UINT32( ctx->state[1], digest,  4 );
    51b0:	ce1a0050 	mrcgt	0, 0, r0, cr10, cr0, {2}
    51b4:	1f00001e 	svcne	0x0000001e
    51b8:	db00000a 	blle	51e8 <sha256_finish+0x114>
    51bc:	1b000006 	blne	51dc <sha256_finish+0x108>
    PUT_UINT32( ctx->state[2], digest,  8 );
    51c0:	08025301 	stmdaeq	r2, {r0, r8, r9, ip, lr}
    51c4:	52011b40 	andpl	r1, r1, #64, 22	; 0x10000
    51c8:	011b3001 	tsteq	fp, r1
    51cc:	e0910351 	adds	r0, r1, r1, asr r3
    51d0:	50011b7e 	andpl	r1, r1, lr, ror fp
    PUT_UINT32( ctx->state[3], digest, 12 );
    51d4:	7de09103 	stfvcp	f1, [r0, #12]!
    51d8:	1eda1c00 	cdpne	12, 13, cr1, cr10, cr0, {0}
    51dc:	0ad00000 	beq	ff4051e4 <BootRAM+0xe375985>
    51e0:	011b0000 	tsteq	fp, r0
    PUT_UINT32( ctx->state[4], digest, 16 );
    51e4:	40030553 	andmi	r0, r3, r3, asr r5
    51e8:	1b000072 	blne	53b8 <sha512_block+0xcc>
    51ec:	08025201 	stmdaeq	r2, {r0, r9, ip, lr}
    51f0:	51011b40 	tstpl	r1, r0, asr #22
    51f4:	7ee09103 	urdvcs	f1, f3
    PUT_UINT32( ctx->state[5], digest, 20 );
    51f8:	0350011b 	cmpeq	r0, #-1073741818	; 0xc0000006
    51fc:	007d8091 			; <UNDEFINED> instruction: 0x007d8091
    5200:	00000000 	andeq	r0, r0, r0
    5204:	0001e51e 	andeq	lr, r1, lr, lsl r5
    PUT_UINT32( ctx->state[6], digest, 24 );
    5208:	001eda00 	andseq	sp, lr, r0, lsl #20
    520c:	00002000 	andeq	r2, r0, r0
    5210:	d99a0100 	ldmible	sl, {r8}
    5214:	17000007 	strne	r0, [r0, -r7]
    5218:	000001fa 	strdeq	r0, [r0], -sl
    PUT_UINT32( ctx->state[7], digest, 28 );
    521c:	000019f9 	strdeq	r1, [r0], -r9
    5220:	0001f117 	andeq	pc, r1, r7, lsl r1	; <UNPREDICTABLE>
    5224:	001a2600 	andseq	r2, sl, r0, lsl #12
    5228:	1eda1f00 	cdpne	15, 13, cr1, cr10, cr0, {0}
    522c:	00200000 	eoreq	r0, r0, r0
    5230:	03190000 	tsteq	r9, #0
    5234:	03000002 	movweq	r0, #2
    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
    5238:	1e7ee091 	mrcne	0, 3, lr, cr14, cr1, {4}
    523c:	0000020d 	andeq	r0, r0, sp, lsl #4
    5240:	00001ee6 	andeq	r1, r0, r6, ror #29
    5244:	00000014 	andeq	r0, r0, r4, lsl r0
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    5248:	07c03701 	strbeq	r3, [r0, r1, lsl #14]
    524c:	23170000 	tstcs	r7, #0
        length -= fill;
    5250:	47000002 	strmi	r0, [r0, -r2]

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    5254:	1700001a 	smladne	r0, sl, r0, r0
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5258:	00000218 	andeq	r0, r0, r8, lsl r2
    525c:	00001ada 	ldrdeq	r1, [r0], -sl
    5260:	001ee61f 	andseq	lr, lr, pc, lsl r6
    {
        sha256_process( ctx, input );
        length -= 64;
    5264:	00001400 	andeq	r1, r0, r0, lsl #8
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    5268:	022c1900 	eoreq	r1, ip, #0, 18
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    526c:	91030000 	mrsls	r0, (UNDEF: 3)
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    5270:	35197dc0 	ldrcc	r7, [r9, #-3520]	; 0xdc0
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5274:	03000002 	movweq	r0, #2
    5278:	1a7de091 	bne	1f7d4c4 <_etext+0x1f75eb0>
    527c:	00001ef0 	strdeq	r1, [r0], -r0
    5280:	00000a45 	andeq	r0, r0, r5, asr #20
    5284:	000007a0 	andeq	r0, r0, r0, lsr #15
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    5288:	0352011b 	cmpeq	r2, #-1073741818	; 0xc0000006
    528c:	1b7ee091 	blne	1fbd4d8 <_etext+0x1fb5ec4>
    {
        memcpy( (void *) (ctx->buffer + left),
    5290:	91035101 	tstls	r3, r1, lsl #2
    5294:	011b7de0 	tsteq	fp, r0, ror #27
    5298:	c0910350 	addsgt	r0, r1, r0, asr r3
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
    529c:	fa1c007d 	blx	705498 <_etext+0x6fde84>
        input  += fill;
    52a0:	6000001e 	andvs	r0, r0, lr, lsl r0

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    52a4:	1b00000a 	blne	52d4 <sha256_finish+0x200>
        length -= fill;
        input  += fill;
    52a8:	91035201 	tstls	r3, r1, lsl #4

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    52ac:	011b7de0 	tsteq	fp, r0, ror #27
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    52b0:	c0910351 	addsgt	r0, r1, r1, asr r3
    {
        sha256_process( ctx, input );
    52b4:	50011b7d 	andpl	r1, r1, sp, ror fp
    52b8:	00007d02 	andeq	r7, r0, r2, lsl #26
    52bc:	e61c0000 	ldr	r0, [ip], -r0
        length -= 64;
        input  += 64;
    52c0:	7b00001e 	blvc	5340 <sha512_block+0x54>
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    52c4:	1b00000a 	blne	52f4 <sha512_block+0x8>
    52c8:	76025201 	strvc	r5, [r2], -r1, lsl #4
    52cc:	50011b20 	andpl	r1, r1, r0, lsr #22
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    52d0:	7ee09103 	urdvcs	f1, f3
    }

    while( length >= 64 )
    52d4:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    52d8:	0000046f 	andeq	r0, r0, pc, ror #8
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    52dc:	00001efa 	strdeq	r1, [r0], -sl
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    52e0:	00000016 	andeq	r0, r0, r6, lsl r0
    52e4:	08659d01 	stmdaeq	r5!, {r0, r8, sl, fp, ip, pc}^
    52e8:	88170000 	ldmdahi	r7, {}	; <UNPREDICTABLE>
{
	return (x >> bits) | (x << (64 - bits));
}

void sha512_block(struct sha512_state *s, const uint8_t *blk)
{
    52ec:	fb000004 	blx	5306 <sha512_block+0x1a>
    52f0:	1700001a 	smladne	r0, sl, r0, r0
    52f4:	0000047f 	andeq	r0, r0, pc, ror r4
    52f8:	00001b0e 	andeq	r1, r0, lr, lsl #22

static inline uint64_t load64(const uint8_t *x)
{
	uint64_t r;

	r = *(x++);
    52fc:	001efa1f 	andseq	pc, lr, pc, lsl sl	; <UNPREDICTABLE>
	r = (r << 8) | *(x++);
    5300:	00001600 	andeq	r1, r0, r0, lsl #12
    5304:	04931900 	ldreq	r1, [r3], #2304	; 0x900
    5308:	91030000 	mrsls	r0, (UNDEF: 3)
    530c:	9c197dc0 	ldcls	13, cr7, [r9], {192}	; 0xc0
    5310:	03000004 	movweq	r0, #4
	r = (r << 8) | *(x++);
    5314:	287ee091 	ldmdacs	lr!, {r0, r4, r7, sp, lr, pc}^
    5318:	000004a5 	andeq	r0, r0, r5, lsr #9
    531c:	00001b88 	andeq	r1, r0, r8, lsl #23
    5320:	001f041a 	andseq	r0, pc, sl, lsl r4	; <UNPREDICTABLE>
	r = (r << 8) | *(x++);
    5324:	000af000 	andeq	pc, sl, r0
    5328:	00084400 	andeq	r4, r8, r0, lsl #8
    532c:	52011b00 	andpl	r1, r1, #0, 22
    5330:	1b007702 	blne	22f40 <_etext+0x1b92c>
    5334:	91035101 	tstls	r3, r1, lsl #2
    5338:	011b7ee0 	tsteq	fp, r0, ror #29
    533c:	c0910350 	addsgt	r0, r1, r0, asr r3
    5340:	101c007d 	andsne	r0, ip, sp, ror r0
	r = (r << 8) | *(x++);
    5344:	0f00001f 	svceq	0x0000001f
    5348:	1b00000b 	blne	537c <sha512_block+0x90>
    534c:	91035201 	tstls	r3, r1, lsl #4
    5350:	011b7ee0 	tsteq	fp, r0, ror #29
    5354:	c0910351 	addsgt	r0, r1, r1, asr r3
    5358:	50011b7d 	andpl	r1, r1, sp, ror fp
    535c:	7de09103 	stfvcp	f1, [r0, #12]!
    5360:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
	r = (r << 8) | *(x++);
    5364:	0000046f 	andeq	r0, r0, pc, ror #8
    5368:	00001f1a 	andeq	r1, r0, sl, lsl pc
    536c:	00000016 	andeq	r0, r0, r6, lsl r0
    5370:	08f19f01 	ldmeq	r1!, {r0, r8, r9, sl, fp, ip, pc}^
    5374:	88170000 	ldmdahi	r7, {}	; <UNPREDICTABLE>
    5378:	a6000004 	strge	r0, [r0], -r4
	r = (r << 8) | *(x++);
    537c:	1700001b 	smladne	r0, fp, r0, r0
    5380:	0000047f 	andeq	r0, r0, pc, ror r4
    5384:	00001bb9 			; <UNDEFINED> instruction: 0x00001bb9
    5388:	001f1a1f 	andseq	r1, pc, pc, lsl sl	; <UNPREDICTABLE>
    538c:	00001600 	andeq	r1, r0, r0, lsl #12
    5390:	04931900 	ldreq	r1, [r3], #2304	; 0x900
	r = (r << 8) | *(x++);
    5394:	91030000 	mrsls	r0, (UNDEF: 3)
    5398:	9c197da0 	ldcls	13, cr7, [r9], {160}	; 0xa0
    539c:	03000004 	movweq	r0, #4
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
		w[i] = load64(blk);
		blk += 8;
    53a0:	287dc091 	ldmdacs	sp!, {r0, r4, r7, lr, pc}^
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
    53a4:	000004a5 	andeq	r0, r0, r5, lsr #9
	uint64_t w[16];
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
		w[i] = load64(blk);
    53a8:	00001c01 	andeq	r1, r0, r1, lsl #24
{
	uint64_t w[16];
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
    53ac:	001f241a 	andseq	r2, pc, sl, lsl r4	; <UNPREDICTABLE>
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    53b0:	000af000 	andeq	pc, sl, r0
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
    53b4:	0008d000 	andeq	sp, r8, r0
    53b8:	52011b00 	andpl	r1, r1, #0, 22
	c = s->h[2];
    53bc:	1b007602 	blne	22bcc <_etext+0x1b5b8>
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    53c0:	91035101 	tstls	r3, r1, lsl #2
	b = s->h[1];
    53c4:	011b7dc0 	tsteq	fp, r0, asr #27
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    53c8:	a0910350 	addsge	r0, r1, r0, asr r3
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    53cc:	301c007d 	andscc	r0, ip, sp, ror r0
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    53d0:	0f00001f 	svceq	0x0000001f
    53d4:	1b00000b 	blne	5408 <sha512_block+0x11c>
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    53d8:	91035201 	tstls	r3, r1, lsl #4
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    53dc:	011b7dc0 	tsteq	fp, r0, asr #27
    53e0:	a0910351 	addsge	r0, r1, r1, asr r3

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    53e4:	50011b7d 	andpl	r1, r1, sp, ror fp
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    53e8:	7ee09103 	urdvcs	f1, f3
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
    53ec:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
	f = s->h[5];
    53f0:	0000020d 	andeq	r0, r0, sp, lsl #4

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    53f4:	00001f3a 	andeq	r1, r0, sl, lsr pc
	e = s->h[4];
    53f8:	00000014 	andeq	r0, r0, r4, lsl r0
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    53fc:	0975a101 	ldmdbeq	r5!, {r0, r8, sp, pc}^
    5400:	23170000 	tstcs	r7, #0

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    5404:	1f000002 	svcne	0x00000002
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    5408:	1700001c 	smladne	r0, ip, r0, r0

	for (i = 0; i < 80; i++) {
    540c:	00000218 	andeq	r0, r0, r8, lsl r2
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
    5410:	00001c4e 	andeq	r1, r0, lr, asr #24
	g = s->h[6];
    5414:	001f3a1f 	andseq	r3, pc, pc, lsl sl	; <UNPREDICTABLE>
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
    5418:	00001400 	andeq	r1, r0, r0, lsl #8
    541c:	022c1900 	eoreq	r1, ip, #0, 18
	g = s->h[6];
	h = s->h[7];
    5420:	91030000 	mrsls	r0, (UNDEF: 3)
    5424:	35197da0 	ldrcc	r7, [r9, #-3488]	; 0xda0
    5428:	03000002 	movweq	r0, #2
	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
    542c:	1a7dc091 	bne	1f75678 <_etext+0x1f6e064>
    5430:	00001f44 	andeq	r1, r0, r4, asr #30
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    5434:	00000a45 	andeq	r0, r0, r5, asr #20
    5438:	00000954 	andeq	r0, r0, r4, asr r9
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    543c:	0352011b 	cmpeq	r2, #-1073741818	; 0xc0000006
	h = s->h[7];
    5440:	1b7de091 	blne	1f7d68c <_etext+0x1f76078>
    5444:	91035101 	tstls	r3, r1, lsl #2

		/* Update round state */
		h = g;
		g = f;
		f = e;
		e = d + temp1;
    5448:	011b7dc0 	tsteq	fp, r0, asr #27
    544c:	a0910350 	addsge	r0, r1, r0, asr r3
    5450:	4e1c007d 	mrcmi	0, 0, r0, cr12, cr13, {3}
    5454:	6000001f 	andvs	r0, r0, pc, lsl r0
    5458:	1b00000a 	blne	5488 <sha512_block+0x19c>
    545c:	91035201 	tstls	r3, r1, lsl #4
    5460:	011b7dc0 	tsteq	fp, r0, asr #27
    5464:	a0910351 	addsge	r0, r1, r1, asr r3
    5468:	50011b7d 	andpl	r1, r1, sp, ror fp
    546c:	7ce09103 	stfvcp	f1, [r0], #12
    5470:	1a000000 	bne	5478 <sha512_block+0x18c>
    5474:	00001f1a 	andeq	r1, r0, sl, lsl pc
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
    5478:	00000a7b 	andeq	r0, r0, fp, ror sl
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
    547c:	00000998 	muleq	r0, r8, r9
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5480:	0352011b 	cmpeq	r2, #-1073741818	; 0xc0000006
    5484:	1b7d8091 	blne	1f656d0 <_etext+0x1f5e0bc>
    5488:	91035101 	tstls	r3, r1, lsl #2
    548c:	011b7de0 	tsteq	fp, r0, ror #27
    5490:	e0910350 	adds	r0, r1, r0, asr r3
    5494:	3a1a007d 	bcc	685690 <_etext+0x67e07c>
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    5498:	2a00001f 	bcs	551c <sha512_block+0x230>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    549c:	bb00000b 	bllt	54d0 <sha512_block+0x1e4>
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    54a0:	1b000009 	blne	54cc <sha512_block+0x1e0>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54a4:	91035201 	tstls	r3, r1, lsl #4
    54a8:	011b7ee0 	tsteq	fp, r0, ror #29
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    54ac:	e0910351 	adds	r0, r1, r1, asr r3
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54b0:	50011b7d 	andpl	r1, r1, sp, ror fp
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    54b4:	7de09103 	stfvcp	f1, [r0, #12]!
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    54b8:	1f561c00 	svcne	0x00561c00
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54bc:	0b450000 	bleq	11454c4 <_etext+0x113deb0>
    54c0:	011b0000 	tsteq	fp, r0
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    54c4:	e0910351 	adds	r0, r1, r1, asr r3
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54c8:	50011b7c 	andpl	r1, r1, ip, ror fp
    54cc:	00007d02 	andeq	r7, r0, r2, lsl #26
    54d0:	175a1500 	ldrbne	r1, [sl, -r0, lsl #10]
    54d4:	0e010000 	cdpeq	0, 0, cr0, cr1, cr0, {0}
    54d8:	000009e4 	andeq	r0, r0, r4, ror #19

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    54dc:	72400305 	subvc	r0, r0, #335544320	; 0x14000000
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54e0:	e7100000 	ldr	r0, [r0, -r0]
    54e4:	29000000 	stmdbcs	r0, {}	; <UNPREDICTABLE>
    54e8:	0000168b 	andeq	r1, r0, fp, lsl #13

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    54ec:	02452703 	subeq	r2, r5, #786432	; 0xc0000
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54f0:	f0290000 			; <UNDEFINED> instruction: 0xf0290000
    54f4:	02000016 	andeq	r0, r0, #22
    54f8:	0009ff19 	andeq	pc, r9, r9, lsl pc	; <UNPREDICTABLE>
    54fc:	00f71000 	rscseq	r1, r7, r0

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    5500:	b92a0000 	stmdblt	sl!, {}	; <UNPREDICTABLE>
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5504:	02000016 	andeq	r0, r0, #22
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5508:	000a1f2b 	andeq	r1, sl, fp, lsr #30
    550c:	01342b00 	teqeq	r4, r0, lsl #22
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5510:	ae2b0000 	cdpge	0, 2, cr0, cr11, cr0, {0}
    5514:	2b000001 	blcs	5520 <sha512_block+0x234>
    5518:	00000097 	muleq	r0, r7, r0
    551c:	17052a00 	strne	r2, [r5, -r0, lsl #20]
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5520:	31020000 	mrscc	r0, (UNDEF: 2)
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5524:	00000a3f 	andeq	r0, r0, pc, lsr sl
    5528:	000a3f2b 	andeq	r3, sl, fp, lsr #30
    552c:	01502b00 	cmpeq	r0, r0, lsl #22
    5530:	7a2b0000 	bvc	ac5538 <_etext+0xabdf24>
    5534:	2b000000 	blcs	553c <sha512_block+0x250>
    5538:	0000007a 	andeq	r0, r0, sl, ror r0
    553c:	ff040c00 			; <UNDEFINED> instruction: 0xff040c00
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
    5540:	2a000009 	bcs	556c <sha512_block+0x280>
    5544:	00001638 	andeq	r1, r0, r8, lsr r6
    5548:	0a602e03 	beq	1810d5c <_etext+0x1809748>
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
    554c:	502b0000 	eorpl	r0, fp, r0
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5550:	2b000001 	blcs	555c <sha512_block+0x270>

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
    5554:	00000150 	andeq	r0, r0, r0, asr r1
    5558:	00023f2b 	andeq	r3, r2, fp, lsr #30
    555c:	cb2a0000 	blgt	a85564 <_etext+0xa7df50>
    5560:	03000015 	movweq	r0, #21
    5564:	000a7b37 	andeq	r7, sl, r7, lsr fp
    5568:	01502b00 	cmpeq	r0, r0, lsl #22
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    556c:	ae2b0000 	cdpge	0, 2, cr0, cr11, cr0, {0}
	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
    5570:	2b000001 	blcs	557c <sha512_block+0x290>
    5574:	000001ae 	andeq	r0, r0, lr, lsr #3
    5578:	161e2a00 	ldrne	r2, [lr], -r0, lsl #20
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    557c:	4f030000 	svcmi	0x00030000
    5580:	00000a96 	muleq	r0, r6, sl
    5584:	0004b02b 	andeq	fp, r4, fp, lsr #32
    5588:	023f2b00 	eorseq	r2, pc, #0, 22
    558c:	ae2b0000 	cdpge	0, 2, cr0, cr11, cr0, {0}
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5590:	00000001 	andeq	r0, r0, r1
    5594:	0017d92a 	andseq	sp, r7, sl, lsr #18
    5598:	ac240200 	sfmge	f0, 4, [r4], #-0
    559c:	2b00000a 	blcs	55cc <sha512_block+0x2e0>
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55a0:	00000134 	andeq	r0, r0, r4, lsr r1
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55a4:	0001ae2b 	andeq	sl, r1, fp, lsr #28
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55a8:	c42c0000 	strtgt	r0, [ip], #-0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55ac:	a9000015 	stmdbge	r0, {r0, r2, r4}
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    55b0:	c9000000 	stmdbgt	r0, {}	; <UNPREDICTABLE>
    55b4:	2b00000a 	blcs	55e4 <sha512_block+0x2f8>
    55b8:	000000a9 	andeq	r0, r0, r9, lsr #1
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
    55bc:	000ac92b 	andeq	ip, sl, fp, lsr #18
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55c0:	00a22b00 	adceq	r2, r2, r0, lsl #22
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
    55c4:	0c000000 	stceq	0, cr0, [r0], {-0}
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55c8:	000acf04 	andeq	ip, sl, r4, lsl #30
    55cc:	682a2d00 	stmdavs	sl!, {r8, sl, fp, sp}
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
    55d0:	07000017 	smladeq	r0, r7, r0, r0
    55d4:	000af021 	andeq	pc, sl, r1, lsr #32
    55d8:	01502b00 	cmpeq	r0, r0, lsl #22
    55dc:	ae2b0000 	cdpge	0, 2, cr0, cr11, cr0, {0}
    55e0:	2b000001 	blcs	55ec <sha512_block+0x300>
    55e4:	00000097 	muleq	r0, r7, r0
    55e8:	0001ae2b 	andeq	sl, r1, fp, lsr #28
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55ec:	eb2e0000 	bl	b855f4 <_etext+0xb7dfe0>

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55f0:	03000015 	movweq	r0, #21
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55f4:	00008138 	andeq	r8, r0, r8, lsr r1

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55f8:	000b0f00 	andeq	r0, fp, r0, lsl #30
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55fc:	01502b00 	cmpeq	r0, r0, lsl #22

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5600:	502b0000 	eorpl	r0, fp, r0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5604:	2b000001 	blcs	5610 <sha512_block+0x324>

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5608:	000001ae 	andeq	r0, r0, lr, lsr #3
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    560c:	15fe2a00 	ldrbne	r2, [lr, #2560]!	; 0xa00
    5610:	2b030000 	blcs	c5618 <_etext+0xbe004>
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5614:	00000b2a 	andeq	r0, r0, sl, lsr #22
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5618:	0004b02b 	andeq	fp, r4, fp, lsr #32
    561c:	01ae2b00 			; <UNDEFINED> instruction: 0x01ae2b00

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5620:	ae2b0000 	cdpge	0, 2, cr0, cr11, cr0, {0}
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5624:	00000001 	andeq	r0, r0, r1
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5628:	0015df2a 	andseq	sp, r5, sl, lsr #30
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    562c:	454c0300 	strbmi	r0, [ip, #-768]	; 0x300
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5630:	2b00000b 	blcs	5664 <sha512_block+0x378>
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5634:	000004b0 			; <UNDEFINED> instruction: 0x000004b0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5638:	00023f2b 	andeq	r3, r2, fp, lsr #30
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
    563c:	023f2b00 	eorseq	r2, pc, #0, 22
    5640:	2f000000 	svccs	0x00000000
    5644:	000015b4 			; <UNDEFINED> instruction: 0x000015b4
    5648:	00812d08 	addeq	r2, r1, r8, lsl #26
    564c:	ae2b0000 	cdpge	0, 2, cr0, cr11, cr0, {0}
    5650:	2b000001 	blcs	565c <sha512_block+0x370>
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    5654:	000001ae 	andeq	r0, r0, lr, lsr #3

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5658:	0fa30000 	svceq	0x00a30000
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    565c:	00040000 	andeq	r0, r4, r0

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5660:	00001462 	andeq	r1, r0, r2, ror #8
    5664:	14a60104 	strtne	r0, [r6], #260	; 0x104
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5668:	fa010000 	blx	45670 <_etext+0x3e05c>

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    566c:	93000017 	movwls	r0, #23
    5670:	58000008 	stmdapl	r0, {r3}
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5674:	00000006 	andeq	r0, r0, r6
    5678:	71000000 	mrsvc	r0, (UNDEF: 0)
    567c:	02000017 	andeq	r0, r0, #23
    5680:	081a0601 	ldmdaeq	sl, {r0, r9, sl}
    5684:	d9030000 	stmdble	r3, {}	; <UNPREDICTABLE>

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5688:	0300000a 	movweq	r0, #10
    568c:	0000371c 	andeq	r3, r0, ip, lsl r7
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
		const uint64_t temp2 = S0 + maj;
    5690:	08010200 	stmdaeq	r1, {r9}
    5694:	00000818 	andeq	r0, r0, r8, lsl r8
    5698:	fc050202 	stc2	2, cr0, [r5], {2}

		/* Update round state */
		h = g;
		g = f;
		f = e;
		e = d + temp1;
    569c:	03000006 	movweq	r0, #6
    56a0:	00000da1 	andeq	r0, r0, r1, lsr #27
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
    56a4:	00502603 	subseq	r2, r0, r3, lsl #12
    56a8:	02020000 	andeq	r0, r2, #0
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
    56ac:	00094907 	andeq	r4, r9, r7, lsl #18
    56b0:	05040200 	streq	r0, [r4, #-512]	; 0x200
    56b4:	000004da 	ldrdeq	r0, [r0], -sl
    56b8:	000abf03 	andeq	fp, sl, r3, lsl #30
    56bc:	69380300 	ldmdbvs	r8!, {r8, r9}
    56c0:	02000000 	andeq	r0, r0, #0
    56c4:	02520704 	subseq	r0, r2, #4, 14	; 0x100000
    56c8:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    56cc:	0004d505 	andeq	sp, r4, r5, lsl #10
    56d0:	07080200 	streq	r0, [r8, -r0, lsl #4]
	s->h[1] += b;
    56d4:	0000024d 	andeq	r0, r0, sp, asr #4
    56d8:	69050404 	stmdbvs	r5, {r2, sl}
    56dc:	0200746e 	andeq	r7, r0, #1845493760	; 0x6e000000
	s->h[2] += c;
    56e0:	02570704 	subseq	r0, r7, #4, 14	; 0x100000
    56e4:	db030000 	blle	c56ec <_etext+0xbe0d8>
    56e8:	0400000a 	streq	r0, [r0], #-10
    56ec:	00002c2a 	andeq	r2, r0, sl, lsr #24
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    56f0:	0da30300 	stceq	3, cr0, [r3]
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    56f4:	36040000 	strcc	r0, [r4], -r0
	s->h[4] += e;
    56f8:	00000045 	andeq	r0, r0, r5, asr #32
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
    56fc:	000ac103 	andeq	ip, sl, r3, lsl #2
	s->h[2] += c;
	s->h[3] += d;
    5700:	5e420400 	cdppl	4, 4, cr0, cr2, cr0, {0}
    5704:	02000000 	andeq	r0, r0, #0
    5708:	078b0704 	streq	r0, [fp, r4, lsl #14]
	s->h[4] += e;
    570c:	04050000 	streq	r0, [r5], #-0
	s->h[5] += f;
	s->h[6] += g;
    5710:	21080102 	tstcs	r8, r2, lsl #2
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
    5714:	06000008 	streq	r0, [r0], -r8
    5718:	0000158f 	andeq	r1, r0, pc, lsl #11
    571c:	0a014b01 	beq	58328 <_etext+0x50d14>
	s->h[6] += g;
    5720:	07000001 	streq	r0, [r0, -r1]

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    5724:	00747364 	rsbseq	r7, r4, r4, ror #6
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    5728:	010a4b01 	tsteq	sl, r1, lsl #22
	s->h[7] += h;
    572c:	ed080000 	stc	0, cr0, [r8, #-0]
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5730:	01000017 	tsteq	r0, r7, lsl r0
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    5734:	0001104c 	andeq	r1, r1, ip, asr #32
	s->h[7] += h;
    5738:	6e6f0700 	cdpvs	7, 6, cr0, cr15, cr0, {0}
    573c:	4c010065 	stcmi	0, cr0, [r1], {101}	; 0x65
    5740:	00000110 	andeq	r0, r0, r0, lsl r1
    5744:	00181f08 	andseq	r1, r8, r8, lsl #30
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
    5748:	8c4d0100 	stfhie	f0, [sp], {-0}
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    574c:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    5750:	00000d1c 	andeq	r0, r0, ip, lsl sp
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5754:	01164f01 	tsteq	r6, r1, lsl #30
	s->h[1] += b;
    5758:	690a0000 	stmdbvs	sl, {}	; <UNPREDICTABLE>
	s->h[2] += c;
	s->h[3] += d;
    575c:	7e500100 	rdfvcs	f0, f0, f0
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
    5760:	00000000 	andeq	r0, r0, r0
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
    5764:	008c040b 	addeq	r0, ip, fp, lsl #8
	s->h[5] += f;
    5768:	040b0000 	streq	r0, [fp], #-0
	s->h[6] += g;
    576c:	00000116 	andeq	r0, r0, r6, lsl r1
	s->h[7] += h;
    5770:	00008c0c 	andeq	r8, r0, ip, lsl #24
}
    5774:	14520d00 	ldrbne	r0, [r2], #-3328	; 0xd00
    5778:	22020000 	andcs	r0, r2, #0
    577c:	00013a03 	andeq	r3, r1, r3, lsl #20

void sha512_final(struct sha512_state *s, const uint8_t *blk,
		  size_t total_size)
{
    5780:	00780700 	rsbseq	r0, r8, r0, lsl #14
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
    5784:	010a2202 	tsteq	sl, r2, lsl #4
	s->h[7] += h;
}

void sha512_final(struct sha512_state *s, const uint8_t *blk,
		  size_t total_size)
{
    5788:	61070000 	mrsvs	r0, (UNDEF: 7)
    578c:	10220200 	eorne	r0, r2, r0, lsl #4
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
    5790:	00000001 	andeq	r0, r0, r1
    5794:	00162c06 	andseq	r2, r6, r6, lsl #24
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
    5798:	010c0100 	mrseq	r0, (UNDEF: 28)
    579c:	00000162 	andeq	r0, r0, r2, ror #2
		memcpy(temp, blk, last_size);
	temp[last_size] = 0x80;
    57a0:	01007807 	tsteq	r0, r7, lsl #16

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    57a4:	00010a0c 	andeq	r0, r1, ip, lsl #20
    57a8:	00630700 	rsbeq	r0, r3, r0, lsl #14
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57ac:	00a20c01 	adceq	r0, r2, r1, lsl #24
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
	sha512_block(s, temp);
    57b0:	690a0000 	stmdbvs	sl, {}	; <UNPREDICTABLE>
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    57b4:	7e0e0100 	adfvce	f0, f6, f0
	v >>= 8;
	*(x--) = v;
    57b8:	00000000 	andeq	r0, r0, r0
	v >>= 8;
	*(x--) = v;
    57bc:	00013a0e 	andeq	r3, r1, lr, lsl #20
	v >>= 8;
	*(x--) = v;
    57c0:	001f7400 	andseq	r7, pc, r0, lsl #8
	v >>= 8;
	*(x--) = v;
    57c4:	00001e00 	andeq	r1, r0, r0, lsl #28
	v >>= 8;
	*(x--) = v;
    57c8:	ae9c0100 	fmlgee	f0, f4, f0
	v >>= 8;
	*(x--) = v;
    57cc:	0f000001 	svceq	0x00000001
	v >>= 8;
	*(x--) = v;
    57d0:	00000146 	andeq	r0, r0, r6, asr #2
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
	sha512_block(s, temp);
    57d4:	00001c96 	muleq	r0, r6, ip
}
    57d8:	00014f0f 	andeq	r4, r1, pc, lsl #30
{
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
		memcpy(temp, blk, last_size);
    57dc:	001cc400 	andseq	ip, ip, r0, lsl #8
    57e0:	01581000 	cmpeq	r8, r0
    57e4:	1d160000 	ldcne	0, cr0, [r6, #-0]
	temp[last_size] = 0x80;
    57e8:	92110000 	andsls	r0, r1, #0

	if (last_size > 111) {
    57ec:	8d00001f 	stchi	0, cr0, [r0, #-124]	; 0xffffff84
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
		memcpy(temp, blk, last_size);
	temp[last_size] = 0x80;
    57f0:	1200000f 	andne	r0, r0, #15

	if (last_size > 111) {
		sha512_block(s, temp);
    57f4:	4c015201 	sfmmi	f5, 4, [r1], {1}
    57f8:	01510112 	cmpeq	r1, r2, lsl r1
		memset(temp, 0, sizeof(temp));
    57fc:	50011230 	andpl	r1, r1, r0, lsr r2
    5800:	5001f305 	andpl	pc, r1, r5, lsl #6
    5804:	00000423 	andeq	r0, r0, r3, lsr #8
	sha512_block(s, temp);
}

void sha512_get(const struct sha512_state *s, uint8_t *hash,
		unsigned int offset, unsigned int len)
{
    5808:	00155413 	andseq	r5, r5, r3, lsl r4
	int i;

	if (offset > SHA512_BLOCK_SIZE)
    580c:	94190100 	ldrls	r0, [r9], #-256	; 0x100
	sha512_block(s, temp);
}

void sha512_get(const struct sha512_state *s, uint8_t *hash,
		unsigned int offset, unsigned int len)
{
    5810:	6e00001f 	mcrvs	0, 0, r0, cr0, cr15, {0}
	int i;

	if (offset > SHA512_BLOCK_SIZE)
    5814:	01000000 	mrseq	r0, (UNDEF: 0)
		return;

	if (len > SHA512_BLOCK_SIZE - offset)
    5818:	00023d9c 	muleq	r2, ip, sp
    581c:	00781400 	rsbseq	r1, r8, r0, lsl #8
		len = SHA512_BLOCK_SIZE - offset;

	/* Skip whole words */
	i = offset >> 3;
    5820:	010a1901 	tsteq	sl, r1, lsl #18
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
    5824:	50010000 	andpl	r0, r1, r0

	if (len > SHA512_BLOCK_SIZE - offset)
		len = SHA512_BLOCK_SIZE - offset;

	/* Skip whole words */
	i = offset >> 3;
    5828:	00182915 	andseq	r2, r8, r5, lsl r9
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
    582c:	3d1b0100 	ldfccs	f0, [fp, #-0]
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    5830:	02000002 	andeq	r0, r0, #2
    5834:	63165891 	tstvs	r6, #9502720	; 0x910000
    5838:	971c0100 	ldrls	r0, [ip, -r0, lsl #2]
    583c:	4e000000 	cdpmi	0, 0, cr0, cr0, cr0, {0}
    5840:	1600001d 			; <UNDEFINED> instruction: 0x1600001d
    5844:	1d010069 	stcne	0, cr0, [r1, #-420]	; 0xfffffe5c
    5848:	0000007e 	andeq	r0, r0, lr, ror r0
    584c:	00001d6c 	andeq	r1, r0, ip, ror #26
    5850:	0000bd17 	andeq	fp, r0, r7, lsl sp
    5854:	001fd400 	andseq	sp, pc, r0, lsl #8
		store64(hash, s->h[i++]);
    5858:	00051800 	andeq	r1, r5, r0, lsl #16
    585c:	0f390100 	svceq	0x00390100
    5860:	000000ea 	andeq	r0, r0, sl, ror #1

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5864:	00001dba 			; <UNDEFINED> instruction: 0x00001dba
    5868:	0000df18 	andeq	sp, r0, r8, lsl pc
    586c:	0f500100 	svceq	0x00500100
    5870:	000000d4 	ldrdeq	r0, [r0], -r4
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
		store64(hash, s->h[i++]);
    5874:	00001dd1 	ldrdeq	r1, [r0], -r1	; <UNPREDICTABLE>
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5878:	0000c918 	andeq	ip, r0, r8, lsl r9
	*(x--) = v;
	v >>= 8;
    587c:	19500100 	ldmdbne	r0, {r8}^
    5880:	00000518 	andeq	r0, r0, r8, lsl r5
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5884:	0000f510 	andeq	pc, r0, r0, lsl r5	; <UNPREDICTABLE>
	*(x--) = v;
	v >>= 8;
    5888:	001df100 	andseq	pc, sp, r0, lsl #2
	*(x--) = v;
	v >>= 8;
    588c:	01001a00 	tsteq	r0, r0, lsl #20
    5890:	53010000 	movwpl	r0, #4096	; 0x1000
	*(x--) = v;
	v >>= 8;
    5894:	1b000000 	blne	589c <sha512_get+0x94>
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5898:	0000008c 	andeq	r0, r0, ip, lsl #1
	*(x--) = v;
	v >>= 8;
    589c:	0000024d 	andeq	r0, r0, sp, asr #4
	*(x--) = v;
	v >>= 8;
    58a0:	0000ad1c 	andeq	sl, r0, ip, lsl sp
    58a4:	1d001f00 	stcne	15, cr1, [r0, #-0]
    58a8:	000015b4 			; <UNDEFINED> instruction: 0x000015b4
	*(x--) = v;
	v >>= 8;
    58ac:	008c3c01 	addeq	r3, ip, r1, lsl #24
    58b0:	20040000 	andcs	r0, r4, r0
    58b4:	009a0000 	addseq	r0, sl, r0
    58b8:	9c010000 	stcls	0, cr0, [r1], {-0}
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58bc:	0000029d 	muleq	r0, sp, r2
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58c0:	0100781e 	tsteq	r0, lr, lsl r8
	*(x--) = v;
    58c4:	0001103c 	andeq	r1, r1, ip, lsr r0
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    58c8:	001e0400 	andseq	r0, lr, r0, lsl #8
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58cc:	00791e00 	rsbseq	r1, r9, r0, lsl #28
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    58d0:	01103c01 	tsteq	r0, r1, lsl #24
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d4:	1e300000 	cdpne	0, 3, cr0, cr0, cr0, {0}
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d8:	73160000 	tstvc	r6, #0
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    58dc:	01006d75 	tsteq	r0, r5, ror sp
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58e0:	00008c3e 	andeq	r8, r0, lr, lsr ip
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    58e4:	001e5c00 	andseq	r5, lr, r0, lsl #24
    58e8:	00691600 	rsbeq	r1, r9, r0, lsl #12
    58ec:	007e3f01 	rsbseq	r3, lr, r1, lsl #30
    58f0:	1ea40000 	cdpne	0, 10, cr0, cr4, cr0, {0}
    58f4:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    58f8:	000000bd 	strheq	r0, [r0], -sp
    58fc:	000020a0 	andeq	r2, r0, r0, lsr #1
    5900:	000000c2 	andeq	r0, r0, r2, asr #1
    5904:	02e59c01 	rsceq	r9, r5, #256	; 0x100
		hash += 8;
		len -= 8;
	}

	/* Read out bytes */
	if (len) {
    5908:	c9180000 	ldmdbgt	r8, {}	; <UNPREDICTABLE>
    590c:	01000000 	mrseq	r0, (UNDEF: 0)
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
	}
}
    5910:	00d40f50 	sbcseq	r0, r4, r0, asr pc
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    5914:	1ee70000 	cdpne	0, 14, cr0, cr7, cr0, {0}
    5918:	df0f0000 	svcle	0x000f0000
    591c:	13000000 	movwne	r0, #0

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5920:	0f00001f 	svceq	0x0000001f
    5924:	000000ea 	andeq	r0, r0, sl, ror #1
	*(x--) = v;
	v >>= 8;
    5928:	00001f3f 	andeq	r1, r0, pc, lsr pc
    592c:	0000f510 	andeq	pc, r0, r0, lsl r5	; <UNPREDICTABLE>
	*(x--) = v;
	v >>= 8;
    5930:	001f6000 	andseq	r6, pc, r0
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5934:	01001000 	mrseq	r1, (UNDEF: 0)
	*(x--) = v;
	v >>= 8;
    5938:	1f890000 	svcne	0x00890000
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    593c:	13000000 	movwne	r0, #0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5940:	0000146c 	andeq	r1, r0, ip, ror #8
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5944:	21645601 	cmncs	r4, r1, lsl #12
    5948:	00460000 	subeq	r0, r6, r0
	*(x--) = v;
	v >>= 8;
    594c:	9c010000 	stcls	0, cr0, [r1], {-0}
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5950:	0000033a 	andeq	r0, r0, sl, lsr r3
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5954:	01007214 	tsteq	r0, r4, lsl r2
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5958:	00010a56 	andeq	r0, r1, r6, asr sl
	*(x--) = v;
	v >>= 8;
    595c:	1e500100 	rdfnes	f0, f0, f0
    5960:	56010061 	strpl	r0, [r1], -r1, rrx
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5964:	00000110 	andeq	r0, r0, r0, lsl r1
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5968:	00001fb4 			; <UNDEFINED> instruction: 0x00001fb4
    596c:	0100621e 	tsteq	r0, lr, lsl r2
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5970:	00011056 	andeq	r1, r1, r6, asr r0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5974:	001fd500 	andseq	sp, pc, r0, lsl #10
    5978:	00631600 	rsbeq	r1, r3, r0, lsl #12
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    597c:	00975801 	addseq	r5, r7, r1, lsl #16
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5980:	1ff60000 	svcne	0x00f60000
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5984:	69160000 	ldmdbvs	r6, {}	; <UNPREDICTABLE>
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5988:	7e590100 	rdfvce	f0, f1, f0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    598c:	3a000000 	bcc	5994 <sha512_get+0x18c>
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
		uint8_t tmp[8];
		unsigned int c = 8 - offset;
    5990:	00000020 	andeq	r0, r0, r0, lsr #32
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5994:	00154406 	andseq	r4, r5, r6, lsl #8
	v >>= 8;
	*(x--) = v;
    5998:	016d0100 	cmneq	sp, r0, lsl #2
	v >>= 8;
	*(x--) = v;
    599c:	00000374 	andeq	r0, r0, r4, ror r3
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59a0:	01007207 	tsteq	r0, r7, lsl #4
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59a4:	00010a6d 	andeq	r0, r1, sp, ror #20
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59a8:	00610700 	rsbeq	r0, r1, r0, lsl #14
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59ac:	01106d01 	tsteq	r0, r1, lsl #26
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59b0:	62070000 	andvs	r0, r7, #0
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    59b4:	106d0100 	rsbne	r0, sp, r0, lsl #2
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59b8:	0a000001 	beq	59c4 <sha512_get+0x1bc>
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
		uint8_t tmp[8];
		unsigned int c = 8 - offset;
    59bc:	6f010063 	svcvs	0x00010063
    59c0:	000000a2 	andeq	r0, r0, r2, lsr #1
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59c4:	0100690a 	tsteq	r0, sl, lsl #18
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    59c8:	00007e70 	andeq	r7, r0, r0, ror lr
		memcpy(hash, tmp + offset, c);
		len -= c;
    59cc:	3a0e0000 	bcc	3859d4 <_etext+0x37e3c0>

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    59d0:	ac000003 	stcge	0, cr0, [r0], {3}
		len -= c;
    59d4:	4c000021 	stcmi	0, cr0, [r0], {33}	; 0x21

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    59d8:	01000000 	mrseq	r0, (UNDEF: 0)
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59dc:	0003b39c 	muleq	r3, ip, r3

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    59e0:	03461800 	movteq	r1, #26624	; 0x6800
		len -= c;
		hash += c;
    59e4:	50010000 	andpl	r0, r1, r0
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    59e8:	00034f0f 	andeq	r4, r3, pc, lsl #30
		memcpy(hash, tmp + offset, c);
		len -= c;
		hash += c;
    59ec:	00208800 	eoreq	r8, r0, r0, lsl #16
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    59f0:	03580f00 	cmpeq	r8, #0, 30
    59f4:	20a90000 	adccs	r0, r9, r0

	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
    59f8:	61100000 	tstvs	r0, r0
    59fc:	ca000003 	bgt	5a10 <sha512_get+0x208>
    5a00:	10000020 	andne	r0, r0, r0, lsr #32
    5a04:	0000036a 	andeq	r0, r0, sl, ror #6

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5a08:	000020f5 	strdeq	r2, [r0], -r5
    5a0c:	16661300 	strbtne	r1, [r6], -r0, lsl #6
	*(x--) = v;
	v >>= 8;
    5a10:	85010000 	strhi	r0, [r1, #-0]

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5a14:	000021f8 	strdeq	r2, [r0], -r8
	*(x--) = v;
	v >>= 8;
    5a18:	00000046 	andeq	r0, r0, r6, asr #32
    5a1c:	03fb9c01 	mvnseq	r9, #256	; 0x100
	*(x--) = v;
	v >>= 8;
    5a20:	72140000 	andsvc	r0, r4, #0
    5a24:	0a850100 	beq	fe145e2c <BootRAM+0xd0b65cd>
    5a28:	01000001 	tsteq	r0, r1
	*(x--) = v;
	v >>= 8;
    5a2c:	00611e50 	rsbeq	r1, r1, r0, asr lr
    5a30:	01108501 	tsteq	r0, r1, lsl #10
	*(x--) = v;
	v >>= 8;
    5a34:	214f0000 	mrscs	r0, SPSR
    5a38:	63160000 	tstvs	r6, #0
	*(x--) = v;
	v >>= 8;
    5a3c:	a2870100 	addge	r0, r7, #0, 2
    5a40:	70000000 	andvc	r0, r0, r0
    5a44:	16000021 	strne	r0, [r0], -r1, lsr #32
	*(x--) = v;
	v >>= 8;
    5a48:	88010069 	stmdahi	r1, {r0, r3, r5, r6}
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5a4c:	0000007e 	andeq	r0, r0, lr, ror r0
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5a50:	0000219b 	muleq	r0, fp, r1
	*(x--) = v;
	v >>= 8;
    5a54:	15650600 	strbne	r0, [r5, #-1536]!	; 0x600
    5a58:	9d010000 	stcls	0, cr0, [r1, #-0]
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5a5c:	00044001 	andeq	r4, r4, r1
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a60:	00720700 	rsbseq	r0, r2, r0, lsl #14
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a64:	010a9d01 	tsteq	sl, r1, lsl #26
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a68:	61070000 	mrsvs	r0, (UNDEF: 7)
    5a6c:	109d0100 	addsne	r0, sp, r0, lsl #2
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5a70:	07000001 	streq	r0, [r0, -r1]
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a74:	9d010062 	stcls	0, cr0, [r1, #-392]	; 0xfffffe78
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5a78:	00000110 	andeq	r0, r0, r0, lsl r1
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a7c:	0100630a 	tsteq	r0, sl, lsl #6
	v >>= 8;
	*(x--) = v;
    5a80:	0000a29f 	muleq	r0, pc, r2	; <UNPREDICTABLE>
	v >>= 8;
	*(x--) = v;
    5a84:	00690a00 	rsbeq	r0, r9, r0, lsl #20
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    5a88:	007ea001 	rsbseq	sl, lr, r1
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a8c:	0a1f0000 	beq	7c5a94 <_etext+0x7be480>
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5a90:	a301006a 	movwge	r0, #4202	; 0x106a
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    5a94:	0000007e 	andeq	r0, r0, lr, ror r0
	}
}
    5a98:	fb0e0000 	blx	385aa2 <_etext+0x37e48e>
    5a9c:	40000003 	andmi	r0, r0, r3
    for (i = 0; i < len; i++)
        uart_printf("%02x", data[i]);
    uart_printf("\n");
}

void failErase () {
    5aa0:	88000022 	stmdahi	r0, {r1, r5}
	// for whatever reason this only flashes upto 0x08008800
	flashErasePage((u32)(0x08008000));
    5aa4:	01000000 	mrseq	r0, (UNDEF: 0)
	flashErasePage((u32)(0x08008000+1024));
    5aa8:	0004929c 	muleq	r4, ip, r2
    5aac:	04071800 	streq	r1, [r7], #-2048	; 0x800
	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
    5ab0:	50010000 	andpl	r0, r1, r0
	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
    5ab4:	0004100f 	andeq	r1, r4, pc
    5ab8:	0021f500 	eoreq	pc, r1, r0, lsl #10
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
    5abc:	04190f00 	ldreq	r0, [r9], #-3840	; 0xf00
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
}
    5ac0:	22160000 	andscs	r0, r6, #0
	flashErasePage((u32)(0x08008000));
	flashErasePage((u32)(0x08008000+1024));
	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
    5ac4:	22100000 	andscs	r0, r0, #0
    5ac8:	37000004 	strcc	r0, [r0, -r4]
    5acc:	10000022 	andne	r0, r0, r2, lsr #32
    5ad0:	0000042b 	andeq	r0, r0, fp, lsr #8
    5ad4:	00002261 	andeq	r2, r0, r1, ror #4
    5ad8:	00224a20 	eoreq	r4, r2, r0, lsr #20
    5adc:	00004a00 	andeq	r4, r0, r0, lsl #20
    5ae0:	04351000 	ldrteq	r1, [r5], #-0
}

int imageCheckFromAddress(ImageObjectHandle *newHandle, vu32 flashAddress, bool shouldEraseFlashOnFail)
{
    5ae4:	22af0000 	adccs	r0, pc, #0
    5ae8:	00000000 	andeq	r0, r0, r0
    5aec:	00181413 	andseq	r1, r8, r3, lsl r4
    5af0:	00ba0100 	adcseq	r0, sl, r0, lsl #2
	ImageRootHeader		*hdr;
	ImageInternalState		state;
	int bufferSize = 0x28+0x40;
	unsigned char imageBuffer[bufferSize];
    memset(imageBuffer, 0xFF, sizeof(imageBuffer));
    5af4:	b8000000 	stmdalt	r0, {}	; <UNPREDICTABLE>
    5af8:	01000000 	mrseq	r0, (UNDEF: 0)
    memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
    5afc:	0005599c 	muleq	r5, ip, r9
    5b00:	00721e00 	rsbseq	r1, r2, r0, lsl #28
    5b04:	010aba01 	tsteq	sl, r1, lsl #20
    memset(&state, 0, sizeof(state));
    5b08:	22fe0000 	rscscs	r0, lr, #0
    5b0c:	611e0000 	tstvs	lr, r0
		{
			failErase();
		}
		return(EINVAL);		/* buffer too small to really contain header */
	}
	if ((hdr->header.magic) != kImageHeaderMagic) {
    5b10:	10ba0100 	adcsne	r0, sl, r0, lsl #2
    5b14:	2a000001 	bcs	5b20 <imageCheckFromAddress+0x3c>
		debug_print("bad magic 0x%08x expecting 0x%08x\n", (hdr->header.magic), kImageHeaderMagic);
    5b18:	1e000023 	cdpne	0, 0, cr0, cr0, cr3, {1}
			failErase();
		}
		*newHandle = &state;
		return(kImageImageMissingMagic);		/* magic must match */
	}
	if ((hdr->signing.imageType) != 0x45444f53)
    5b1c:	ba010062 	blt	45cac <_etext+0x3e698>
    5b20:	00000110 	andeq	r0, r0, r0, lsl r1
	{
		debug_print("bad magic 0x%08x expecting 0x%X\n", (hdr->signing.imageType), 0x45444f53);
    5b24:	0000234b 	andeq	r2, r0, fp, asr #6
    5b28:	706d7421 	rsbvc	r7, sp, r1, lsr #8
		state.flags = kImageImageMissingMagic;
    5b2c:	3dbc0100 	ldfccs	f0, [ip]
		if (shouldEraseFlashOnFail)
    5b30:	02000002 	andeq	r0, r0, #2
		{
			failErase();
    5b34:	fb224891 	blx	897d82 <_etext+0x89076e>
		}
		*newHandle = &state;
    5b38:	00000003 	andeq	r0, r0, r3
		return(kImageImageMissingMagic);		/* magic must match */
    5b3c:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
	}
	state.flags = kImageImageWasInstantiated;
    5b40:	01000005 	tsteq	r0, r5

	debug_print("dataSize: 0x%X\n", (hdr->header.dataSize));
    5b44:	000536be 			; <UNDEFINED> instruction: 0x000536be
    5b48:	04190f00 	ldreq	r0, [r9], #-3840	; 0xf00
	state.cursor = hdr->header.dataSize;
	state.lastTag = -1;

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5b4c:	236c0000 	cmncs	ip, #0
	}
	state.flags = kImageImageWasInstantiated;

	debug_print("dataSize: 0x%X\n", (hdr->header.dataSize));

	state.cursor = hdr->header.dataSize;
    5b50:	100f0000 	andne	r0, pc, r0
	state.lastTag = -1;
    5b54:	8d000004 	stchi	0, cr0, [r0, #-16]
    5b58:	0f000023 	svceq	0x00000023

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5b5c:	00000407 	andeq	r0, r0, r7, lsl #8

    sha256_context ctx;
    sha256_starts(&ctx);
    5b60:	000023ae 	andeq	r2, r0, lr, lsr #7
    int buffSize = 0x1;
    char buff[buffSize];

    int i = 0x84;
    char cmpEnd[5] = {0x01, 0x00, 0x00, 0x00, 0x00}; 
    hexdump((flashAddress+i), 0x10);
    5b64:	00053819 	andeq	r3, r5, r9, lsl r8
    5b68:	04221000 	strteq	r1, [r2], #-0
    5b6c:	23db0000 	bicscs	r0, fp, #0

    int finish = hdr->header.dataSize + 0x84;
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
    5b70:	2b100000 	blcs	405b78 <_etext+0x3fe564>

    int i = 0x84;
    char cmpEnd[5] = {0x01, 0x00, 0x00, 0x00, 0x00}; 
    hexdump((flashAddress+i), 0x10);

    int finish = hdr->header.dataSize + 0x84;
    5b74:	05000004 	streq	r0, [r0, #-4]
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
    5b78:	20000024 	andcs	r0, r0, r4, lsr #32
    5b7c:	00000000 	andeq	r0, r0, r0
    sha256_starts(&ctx);

    int buffSize = 0x1;
    char buff[buffSize];

    int i = 0x84;
    5b80:	00000048 	andeq	r0, r0, r8, asr #32
    char cmpEnd[5] = {0x01, 0x00, 0x00, 0x00, 0x00}; 
    hexdump((flashAddress+i), 0x10);

    int finish = hdr->header.dataSize + 0x84;
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
    while (i < finish)
    5b84:	00043510 	andeq	r3, r4, r0, lsl r5
		  	debug_print("Last block: %X\n", (flashAddress+i));
		  	break;
			}
		hexdump((vu32 *)(flashAddress+i), buffSize);
		}*/
		sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
    5b88:	00246600 	eoreq	r6, r4, r0, lsl #12
    5b8c:	00000000 	andeq	r0, r0, r0
    5b90:	00011b23 	andeq	r1, r1, r3, lsr #22
		i += 0x1;
    5b94:	00000000 	andeq	r0, r0, r0
    }
    debug_print("Ended at: %X\n", (flashAddress+i));
    5b98:	00002600 	andeq	r2, r0, r0, lsl #12
    5b9c:	0fbf0100 	svceq	0x00bf0100
    5ba0:	00000130 	andeq	r0, r0, r0, lsr r1
    hexdump((vu32 *)(flashAddress+i), 0x10);
    5ba4:	000024b5 			; <UNDEFINED> instruction: 0x000024b5
    5ba8:	0001270f 	andeq	r2, r1, pc, lsl #14
    if ((flashAddress+i) != (flashAddress+finish))
    5bac:	0024e200 	eoreq	lr, r4, r0, lsl #4
    5bb0:	06000000 	streq	r0, [r0], -r0
    5bb4:	00001477 	andeq	r1, r0, r7, ror r4
    {
    	debug_print("Calculated hash is probably wrong...\n");
    5bb8:	9301c201 	movwls	ip, #4609	; 0x1201
    5bbc:	07000005 	streq	r0, [r0, -r5]
    	state.flags = kImageImageHashCalcFailed;
    	*newHandle = &state;
		return(kImageImageHashCalcFailed);
    5bc0:	c2010072 	andgt	r0, r1, #114	; 0x72
	    sha256_update(&ctx, uniqueID, 0x17);
    }

    //debug_print("%s\n", uniqueID);
    
    sha256_finish(&ctx, sha256sum);
    5bc4:	0000010a 	andeq	r0, r0, sl, lsl #2
    5bc8:	01006107 	tsteq	r0, r7, lsl #2
    print_hash(sha256sum);
    // verify signature against recalc hash
    uint8_t sigbuff[0x40];
    memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
    5bcc:	000110c2 	andeq	r1, r1, r2, asr #1
    5bd0:	00620700 	rsbeq	r0, r2, r0, lsl #14
    }

    //debug_print("%s\n", uniqueID);
    
    sha256_finish(&ctx, sha256sum);
    print_hash(sha256sum);
    5bd4:	00a2c201 	adceq	ip, r2, r1, lsl #4
    // verify signature against recalc hash
    uint8_t sigbuff[0x40];
    memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
    5bd8:	630a0000 	movwvs	r0, #40960	; 0xa000
    5bdc:	a2c40100 	sbcge	r0, r4, #0, 2
    5be0:	0a000000 	beq	5be8 <imageCheckFromAddress+0x104>
    5be4:	c5010069 	strgt	r0, [r1, #-105]	; 0x69
    5be8:	0000007e 	andeq	r0, r0, lr, ror r0

    if (edsign_verify(sigbuff, rootCA, sha256sum, 32) <= 0) {
    5bec:	05590e00 	ldrbeq	r0, [r9, #-3584]	; 0xe00
    5bf0:	00000000 	andeq	r0, r0, r0
    5bf4:	00400000 	subeq	r0, r0, r0
    	state.flags = kImageImageRejectSignature;
    5bf8:	9c010000 	stcls	0, cr0, [r1], {-0}
    	if (shouldEraseFlashOnFail)
    5bfc:	000005d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    5c00:	00056518 	andeq	r6, r5, r8, lsl r5
		{
			failErase();
    5c04:	18500100 	ldmdane	r0, {r8}^
		}
    	*newHandle = &state;
    	return kImageImageRejectSignature;
    5c08:	0000056e 	andeq	r0, r0, lr, ror #10
    } else {
    	state.flags = kImageImageIsTrusted;
    	*newHandle = &state;
    5c0c:	770f5101 	strvc	r5, [pc, -r1, lsl #2]
    	return kImageImageIsTrusted;
    }
	
	*newHandle = &state;
	return(0);
}
    5c10:	03000005 	movweq	r0, #5
    5c14:	10000025 	andne	r0, r0, r5, lsr #32
    5c18:	00000580 	andeq	r0, r0, r0, lsl #11
    5c1c:	00002524 	andeq	r2, r0, r4, lsr #10
    5c20:	00058910 	andeq	r8, r5, r0, lsl r9
    5c24:	00255200 	eoreq	r5, r5, r0, lsl #4
    5c28:	7a130000 	bvc	4c5c30 <_etext+0x4be61c>
    5c2c:	01000015 	tsteq	r0, r5, lsl r0
    5c30:	0022c8d8 	ldrdeq	ip, [r2], -r8	; <UNPREDICTABLE>
    5c34:	0005ea00 	andeq	lr, r5, r0, lsl #20
    5c38:	e79c0100 	ldr	r0, [ip, r0, lsl #2]
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxStatus(u8 bEpNum, u16 wState)
{
  _SetEPTxStatus(bEpNum, wState);
    5c3c:	14000009 	strne	r0, [r0], #-9
    5c40:	d8010072 	stmdale	r1, {r1, r4, r5, r6}
    5c44:	0000010a 	andeq	r0, r0, sl, lsl #2
    5c48:	781e5001 	ldmdavc	lr, {r0, ip, lr}
    5c4c:	10d80100 	sbcsne	r0, r8, r0, lsl #2
    5c50:	a0000001 	andge	r0, r0, r1
    5c54:	21000025 	tstcs	r0, r5, lsr #32
    5c58:	da010073 	ble	45e2c <_etext+0x3e818>
    5c5c:	0000023d 	andeq	r0, r0, sp, lsr r2
    5c60:	0a409102 	beq	102a070 <_etext+0x1022a5c>
    5c64:	db010069 	blle	45e10 <_etext+0x3e7fc>
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxValid(u8 bEpNum)
{
  _SetEPRxStatus(bEpNum, EP_RX_VALID);
    5c68:	0000007e 	andeq	r0, r0, lr, ror r0
    5c6c:	0003fb22 	andeq	pc, r3, r2, lsr #22
    5c70:	0022cc00 	eoreq	ip, r2, r0, lsl #24
    5c74:	00055000 	andeq	r5, r5, r0
    5c78:	6cee0100 	stfvse	f0, [lr]
    5c7c:	0f000006 	svceq	0x00000006
    5c80:	00000419 	andeq	r0, r0, r9, lsl r4
* Output         : None.
* Return         : None.
*******************************************************************************/
void Clear_Status_Out(u8 bEpNum)
{
  _ClearEP_KIND(bEpNum);
    5c84:	000025c1 	andeq	r2, r0, r1, asr #11
    5c88:	0004100f 	andeq	r1, r4, pc
    5c8c:	0025c100 	eoreq	ip, r5, r0, lsl #2
    5c90:	04070f00 	streq	r0, [r7], #-3840	; 0xf00
    5c94:	25e20000 	strbcs	r0, [r2, #0]!
    5c98:	50190000 	andspl	r0, r9, r0
    5c9c:	10000005 	andne	r0, r0, r5
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_RX(u8 bEpNum)
{
  _ClearDTOG_RX(bEpNum);
    5ca0:	00000422 	andeq	r0, r0, r2, lsr #8
    5ca4:	0000260f 	andeq	r2, r0, pc, lsl #12
    5ca8:	00042b10 	andeq	r2, r4, r0, lsl fp
    5cac:	00263900 	eoreq	r3, r6, r0, lsl #18
    5cb0:	22d22000 	sbcscs	r2, r2, #0
    5cb4:	00460000 	subeq	r0, r6, r0
    5cb8:	35100000 	ldrcc	r0, [r0, #-0]
    5cbc:	9a000004 	bls	5cd4 <ClearDTOG_TX+0x14>
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_TX(u8 bEpNum)
{
  _ClearDTOG_TX(bEpNum);
    5cc0:	00000026 	andeq	r0, r0, r6, lsr #32
    5cc4:	fb220000 	blx	885cce <_etext+0x87e6ba>
    5cc8:	54000003 	strpl	r0, [r0], #-3
    5ccc:	68000023 	stmdavs	r0, {r0, r1, r5}
    5cd0:	01000005 	tsteq	r0, r5
    5cd4:	0006baef 	andeq	fp, r6, pc, ror #21
    5cd8:	04192400 	ldreq	r2, [r9], #-1024	; 0x400
    5cdc:	10240000 	eorne	r0, r4, r0
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
u16 GetEPTxAddr(u8 bEpNum)
{
  return(_GetEPTxAddr(bEpNum));
    5ce0:	24000004 	strcs	r0, [r0], #-4
    5ce4:	00000407 	andeq	r0, r0, r7, lsl #8
    5ce8:	00056819 	andeq	r6, r5, r9, lsl r8
    5cec:	04221000 	strteq	r1, [r2], #-0
    5cf0:	26e90000 	strbtcs	r0, [r9], r0
}
    5cf4:	2b100000 	blcs	405cfc <_etext+0x3fe6e8>
    5cf8:	07000004 	streq	r0, [r0, -r4]
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
u16 GetEPRxAddr(u8 bEpNum)
{
  return(_GetEPRxAddr(bEpNum));
    5cfc:	20000027 	andcs	r0, r0, r7, lsr #32
    5d00:	00002354 	andeq	r2, r0, r4, asr r3
    5d04:	00000044 	andeq	r0, r0, r4, asr #32
    5d08:	00043510 	andeq	r3, r4, r0, lsl r5
}
    5d0c:	00274900 	eoreq	r4, r7, r0, lsl #18
    5d10:	00000000 	andeq	r0, r0, r0
    5d14:	0003fb22 	andeq	pc, r3, r2, lsr #22
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxCount(u8 bEpNum, u16 wCount)
{
  _SetEPTxCount(bEpNum, wCount);
    5d18:	0023c600 	eoreq	ip, r3, r0, lsl #12
    5d1c:	00058000 	andeq	r8, r5, r0
    5d20:	04f30100 	ldrbteq	r0, [r3], #256	; 0x100
    5d24:	24000007 	strcs	r0, [r0], #-7
    5d28:	00000419 	andeq	r0, r0, r9, lsl r4
    5d2c:	00041024 	andeq	r1, r4, r4, lsr #32
    5d30:	04072400 	streq	r2, [r7], #-1024	; 0x400
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxCount(u8 bEpNum, u16 wCount)
{
  _SetEPRxCount(bEpNum, wCount);
    5d34:	80190000 	andshi	r0, r9, r0
    5d38:	10000005 	andne	r0, r0, r5
    5d3c:	00000422 	andeq	r0, r0, r2, lsr #8
    5d40:	000027c3 	andeq	r2, r0, r3, asr #15
    5d44:	00042b10 	andeq	r2, r4, r0, lsl fp
    5d48:	0027ed00 	eoreq	lr, r7, r0, lsl #26
    5d4c:	05981900 	ldreq	r1, [r8, #2304]	; 0x900
    5d50:	35100000 	ldrcc	r0, [r0, #-0]
    5d54:	4e000004 	cdpmi	0, 0, cr0, cr0, cr4, {0}
    5d58:	00000028 	andeq	r0, r0, r8, lsr #32
    5d5c:	fb250000 	blx	945d66 <_etext+0x93e752>
    5d60:	54000003 	strpl	r0, [r0], #-3
    5d64:	76000024 	strvc	r0, [r0], -r4, lsr #32
    5d68:	01000000 	mrseq	r0, (UNDEF: 0)
    5d6c:	000756f4 	strdeq	r5, [r7], -r4
    5d70:	04192400 	ldreq	r2, [r9], #-1024	; 0x400
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CTR_LP(void)
{
    5d74:	10240000 	eorne	r0, r4, r0
  u32 wEPVal = 0;
  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
    5d78:	24000004 	strcs	r0, [r0], #-4
    5d7c:	00000407 	andeq	r0, r0, r7, lsl #8
    5d80:	00245420 	eoreq	r5, r4, r0, lsr #8
    5d84:	00007600 	andeq	r7, r0, r0, lsl #12
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
    5d88:	04221000 	strteq	r1, [r2], #-0
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
    5d8c:	289d0000 	ldmcs	sp, {}	; <UNPREDICTABLE>
    5d90:	2b100000 	blcs	405d98 <_etext+0x3fe784>
    5d94:	bb000004 	bllt	5dac <CTR_LP+0x38>
    if (EPindex == 0)
    5d98:	20000028 	andcs	r0, r0, r8, lsr #32
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */
      SaveRState = _GetEPRxStatus(ENDP0);
    5d9c:	00002454 	andeq	r2, r0, r4, asr r4
      SaveTState = _GetEPTxStatus(ENDP0);
    5da0:	00000048 	andeq	r0, r0, r8, asr #32
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */
      SaveRState = _GetEPRxStatus(ENDP0);
    5da4:	00043510 	andeq	r3, r4, r0, lsl r5
      SaveTState = _GetEPTxStatus(ENDP0);
    5da8:	0028fd00 	eoreq	pc, r8, r0, lsl #26
    5dac:	00000000 	andeq	r0, r0, r0
      _SetEPRxStatus(ENDP0, EP_RX_NAK);
    5db0:	0003fb25 	andeq	pc, r3, r5, lsr #22
    5db4:	0024d400 	eoreq	sp, r4, r0, lsl #8
    5db8:	00008800 	andeq	r8, r0, r0, lsl #16
    5dbc:	a8f80100 	ldmge	r8!, {r8}^
    5dc0:	24000007 	strcs	r0, [r0], #-7
      _SetEPTxStatus(ENDP0, EP_TX_NAK);
    5dc4:	00000419 	andeq	r0, r0, r9, lsl r4
    5dc8:	00041024 	andeq	r1, r4, r4, lsr #32
    5dcc:	04072400 	streq	r2, [r7], #-1024	; 0x400
    5dd0:	d4200000 	strtle	r0, [r0], #-0


      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
    5dd4:	88000024 	stmdahi	r0, {r2, r5}
    5dd8:	10000000 	andne	r0, r0, r0

        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */

        wEPVal = _GetENDPOINT(ENDP0);
        if ((wEPVal & EP_CTR_TX) != 0)
    5ddc:	00000422 	andeq	r0, r0, r2, lsr #8
        {
          _ClearEP_CTR_TX(ENDP0);
    5de0:	00002977 	andeq	r2, r0, r7, ror r9
    5de4:	00042b10 	andeq	r2, r4, r0, lsl fp
    5de8:	00299500 	eoreq	r9, r9, r0, lsl #10
          In0_Process();
    5dec:	24d42000 	ldrbcs	r2, [r4], #0
          /* before terminate set Tx & Rx status */
          _SetEPRxStatus(ENDP0, SaveRState);
          _SetEPTxStatus(ENDP0, SaveTState);
          return;
        }
        else if ((wEPVal &EP_SETUP) != 0)
    5df0:	004a0000 	subeq	r0, sl, r0
        {
          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
    5df4:	35100000 	ldrcc	r0, [r0, #-0]
    5df8:	ea000004 	b	5e10 <CTR_LP+0x9c>
    5dfc:	00000029 	andeq	r0, r0, r9, lsr #32
          Setup0_Process();
    5e00:	fb250000 	blx	945e0a <_etext+0x93e7f6>
          _SetEPRxStatus(ENDP0, SaveRState);
          _SetEPTxStatus(ENDP0, SaveTState);
          return;
        }

        else if ((wEPVal & EP_CTR_RX) != 0)
    5e04:	5c000003 	stcpl	0, cr0, [r0], {3}
        {
          _ClearEP_CTR_RX(ENDP0);
    5e08:	74000025 	strvc	r0, [r0], #-37	; 0x25
    5e0c:	01000000 	mrseq	r0, (UNDEF: 0)
    5e10:	0007fafb 	strdeq	pc, [r7], -fp
          Out0_Process();
    5e14:	04192400 	ldreq	r2, [r9], #-1024	; 0x400
          /* before terminate set Tx & Rx status */
          _SetEPRxStatus(ENDP0, SaveRState);
    5e18:	10240000 	eorne	r0, r4, r0
    5e1c:	24000004 	strcs	r0, [r0], #-4
    5e20:	00000407 	andeq	r0, r0, r7, lsl #8
    5e24:	00255c20 	eoreq	r5, r5, r0, lsr #24
    5e28:	00007400 	andeq	r7, r0, r0, lsl #8
    5e2c:	04221000 	strteq	r1, [r2], #-0
    5e30:	2a390000 	bcs	e45e38 <_etext+0xe3e824>
    5e34:	2b100000 	blcs	405e3c <_etext+0x3fe828>
          _SetEPTxStatus(ENDP0, SaveTState);
    5e38:	57000004 	strpl	r0, [r0, -r4]
    5e3c:	2000002a 	andcs	r0, r0, sl, lsr #32
    5e40:	0000255c 	andeq	r2, r0, ip, asr r5
    5e44:	00000046 	andeq	r0, r0, r6, asr #32
    5e48:	00043510 	andeq	r3, r4, r0, lsl r5
    5e4c:	002a9900 	eoreq	r9, sl, r0, lsl #18
    5e50:	00000000 	andeq	r0, r0, r0
    5e54:	0003fb25 	andeq	pc, r3, r5, lsr #22
          return;
    5e58:	0025d000 	eoreq	sp, r5, r0
    else
    {
      /* Decode and service non control endpoints interrupt  */

      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
    5e5c:	00008200 	andeq	r8, r0, r0, lsl #4
    5e60:	4cfc0100 	ldfmie	f0, [ip]
    5e64:	24000008 	strcs	r0, [r0], #-8
      if ((wEPVal & EP_CTR_RX) != 0)
    5e68:	00000419 	andeq	r0, r0, r9, lsl r4
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
    5e6c:	00041024 	andeq	r1, r4, r4, lsr #32
    5e70:	04072400 	streq	r2, [r7], #-1024	; 0x400

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
    5e74:	d0200000 	eorle	r0, r0, r0
    5e78:	82000025 	andhi	r0, r0, #37	; 0x25
    5e7c:	10000000 	andne	r0, r0, r0

      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
    5e80:	00000422 	andeq	r0, r0, r2, lsr #8
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
    5e84:	00002b13 	andeq	r2, r0, r3, lsl fp
    5e88:	00042b10 	andeq	r2, r4, r0, lsl fp
    5e8c:	002b3100 	eoreq	r3, fp, r0, lsl #2
    5e90:	25d02000 	ldrbcs	r2, [r0]
    5e94:	00480000 	subeq	r0, r8, r0
    5e98:	35100000 	ldrcc	r0, [r0, #-0]

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
    5e9c:	86000004 	strhi	r0, [r0], -r4
    5ea0:	0000002b 	andeq	r0, r0, fp, lsr #32
    5ea4:	fb250000 	blx	945eae <_etext+0x93e89a>
    5ea8:	52000003 	andpl	r0, r0, #3
    5eac:	74000026 	strvc	r0, [r0], #-38	; 0x26
    5eb0:	01000000 	mrseq	r0, (UNDEF: 0)
    5eb4:	00089eff 	strdeq	r9, [r8], -pc	; <UNPREDICTABLE>
    5eb8:	04192400 	ldreq	r2, [r9], #-1024	; 0x400
    5ebc:	10240000 	eorne	r0, r4, r0
    5ec0:	24000004 	strcs	r0, [r0], #-4
    5ec4:	00000407 	andeq	r0, r0, r7, lsl #8
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void USB_Init(void)
{
    5ec8:	00265220 	eoreq	r5, r6, r0, lsr #4
  pInformation = &Device_Info;
    5ecc:	00007400 	andeq	r7, r0, r0, lsl #8
    5ed0:	04221000 	strteq	r1, [r2], #-0
  pInformation->ControlState = 2;
    5ed4:	2bd50000 	blcs	ff545edc <BootRAM+0xe4b667d>
  pProperty = &Device_Property;
    5ed8:	2b100000 	blcs	405ee0 <_etext+0x3fe8cc>
  pUser_Standard_Requests = &User_Standard_Requests;
    5edc:	f3000004 	vhadd.u8	d0, d0, d4
    5ee0:	2000002b 	andcs	r0, r0, fp, lsr #32
  /* Initialize devices one by one */

  pProperty->Init();
    5ee4:	00002652 	andeq	r2, r0, r2, asr r6
    5ee8:	00000046 	andeq	r0, r0, r6, asr #32
    5eec:	00043510 	andeq	r3, r4, r0, lsl r5
    5ef0:	002c3500 	eoreq	r3, ip, r0, lsl #10
    5ef4:	00000000 	andeq	r0, r0, r0
    5ef8:	0003fb26 	andeq	pc, r3, r6, lsr #22
    5efc:	0026c600 	eoreq	ip, r6, r0, lsl #12
* Output         : None.
* Return         : Return 1 , if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
u8 *Standard_GetConfiguration(u16 Length)
{
    5f00:	00008200 	andeq	r8, r0, r0, lsl #4
  if (Length == 0)
    5f04:	01020100 	mrseq	r0, (UNDEF: 18)
  {
    pInformation->Ctrl_Info.Usb_wLength =
    5f08:	000008f1 	strdeq	r0, [r0], -r1
      sizeof(pInformation->Current_Configuration);
    return 0;
    5f0c:	00041924 	andeq	r1, r4, r4, lsr #18
  }
  pUser_Standard_Requests->User_GetConfiguration();
    5f10:	04102400 	ldreq	r2, [r0], #-1024	; 0x400
    5f14:	07240000 	streq	r0, [r4, -r0]!
  return (u8 *)&pInformation->Current_Configuration;
    5f18:	20000004 	andcs	r0, r0, r4
}
    5f1c:	000026c6 	andeq	r2, r0, r6, asr #13
    5f20:	00000082 	andeq	r0, r0, r2, lsl #1
* Output         : None.
* Return         : Return 0, if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
u8 *Standard_GetInterface(u16 Length)
{
    5f24:	00042210 	andeq	r2, r4, r0, lsl r2
  if (Length == 0)
    5f28:	002caf00 	eoreq	sl, ip, r0, lsl #30
  {
    pInformation->Ctrl_Info.Usb_wLength =
    5f2c:	042b1000 	strteq	r1, [fp], #-0
      sizeof(pInformation->Current_AlternateSetting);
    return 0;
    5f30:	2ccd0000 	stclcs	0, cr0, [sp], {0}
  }
  pUser_Standard_Requests->User_GetInterface();
    5f34:	c6200000 	strtgt	r0, [r0], -r0
    5f38:	48000026 	stmdami	r0, {r1, r2, r5}
  return (u8 *)&pInformation->Current_AlternateSetting;
    5f3c:	10000000 	andne	r0, r0, r0
}
    5f40:	00000435 	andeq	r0, r0, r5, lsr r4
    5f44:	00002d22 	andeq	r2, r0, r2, lsr #26
* Output         : None.
* Return         : Return 0, if the request is at end of data block,
*                  or is invalid when "Length" is 0.
*******************************************************************************/
u8 *Standard_GetStatus(u16 Length)
{
    5f48:	26000000 	strcs	r0, [r0], -r0
  if (Length == 0)
    5f4c:	000003fb 	strdeq	r0, [r0], -fp
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
    5f50:	00002748 	andeq	r2, r0, r8, asr #14
    return 0;
    5f54:	00000072 	andeq	r0, r0, r2, ror r0
  }

  StatusInfo.w = 0;
  /* Reset Status Information */

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    5f58:	44010301 	strmi	r0, [r1], #-769	; 0x301
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
    return 0;
  }

  StatusInfo.w = 0;
    5f5c:	24000009 	strcs	r0, [r0], #-9
  /* Reset Status Information */

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    5f60:	00000419 	andeq	r0, r0, r9, lsl r4
    5f64:	00041024 	andeq	r1, r4, r4, lsr #32
  {
    /*Get Device Status */
    u8 Feature = pInformation->Current_Feature;
    5f68:	04072400 	streq	r2, [r7], #-1024	; 0x400

    /* Remote Wakeup enabled */
    if (ValBit(Feature, 5))
    {
      SetBit(StatusInfo0, 1);
    5f6c:	48200000 	stmdami	r0!, {}	; <UNPREDICTABLE>
    5f70:	72000027 	andvc	r0, r0, #39	; 0x27
    }

    /* Bus-powered */
    if (ValBit(Feature, 6))
    5f74:	10000000 	andne	r0, r0, r0
    {
      ClrBit(StatusInfo0, 0);
    5f78:	00000422 	andeq	r0, r0, r2, lsr #8
    5f7c:	00002d71 	andeq	r2, r0, r1, ror sp
    }
    else /* Self-powered */
    {
      SetBit(StatusInfo0, 0);
    5f80:	00042b10 	andeq	r2, r4, r0, lsl fp
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    5f84:	002d8f00 	eoreq	r8, sp, r0, lsl #30
  {
    return (u8 *)&StatusInfo;
  }
  /*Get EndPoint Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    5f88:	27482000 	strbcs	r2, [r8, -r0]
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;
    5f8c:	00440000 	subeq	r0, r4, r0

    Related_Endpoint = (wIndex0 & 0x0f);
    5f90:	35100000 	ldrcc	r0, [r0, #-0]
    if (ValBit(wIndex0, 7))
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5f94:	d1000004 	tstle	r0, r4
    5f98:	0000002d 	andeq	r0, r0, sp, lsr #32
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;

    Related_Endpoint = (wIndex0 & 0x0f);
    if (ValBit(wIndex0, 7))
    5f9c:	fb260000 	blx	985fa6 <_etext+0x97e992>
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5fa0:	ba000003 	blt	5fb4 <Standard_GetStatus+0x6c>
    5fa4:	82000027 	andhi	r0, r0, #39	; 0x27
    5fa8:	01000000 	mrseq	r0, (UNDEF: 0)
      {
        SetBit(StatusInfo0, 0); /* IN Endpoint stalled */
    5fac:	09970106 	ldmibeq	r7, {r1, r2, r8}
    5fb0:	19240000 	stmdbne	r4!, {}	; <UNPREDICTABLE>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
    5fb4:	24000004 	strcs	r0, [r0], #-4
    5fb8:	00000410 	andeq	r0, r0, r0, lsl r4
  }
  else
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
    5fbc:	00040724 	andeq	r0, r4, r4, lsr #14
    5fc0:	27ba2000 	ldrcs	r2, [sl, r0]!
  return (u8 *)&StatusInfo;
    5fc4:	00820000 	addeq	r0, r2, r0
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
  {
    return (u8 *)&StatusInfo;
    5fc8:	22100000 	andscs	r0, r0, #0
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
  return (u8 *)&StatusInfo;
}
    5fcc:	4b000004 	blmi	5fe4 <DataStageIn+0xc>
    5fd0:	1000002e 	andne	r0, r0, lr, lsr #32
    5fd4:	0000042b 	andeq	r0, r0, fp, lsr #8
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
    5fd8:	00002e69 	andeq	r2, r0, r9, ror #28
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
    5fdc:	0027ba20 	eoreq	fp, r7, r0, lsr #20
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
    5fe0:	00004800 	andeq	r4, r0, r0, lsl #16
  u32 save_wLength = pEPinfo->Usb_wLength;
  u32 ControlState = pInformation->ControlState;
    5fe4:	04351000 	ldrteq	r1, [r5], #-0

  u8 *DataBuffer;
  u32 Length;

  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
    5fe8:	2ebe0000 	cdpcs	0, 11, cr0, cr14, cr0, {0}
    5fec:	00000000 	andeq	r0, r0, r0
  {
    if(Data_Mul_MaxPacketSize == TRUE)
    5ff0:	03fb2700 	mvnseq	r2, #0, 14
    5ff4:	283c0000 	ldmdacs	ip!, {}	; <UNPREDICTABLE>
    {
      /* No more data to send and empty packet */
      Send0LengthData();
    5ff8:	006e0000 	rsbeq	r0, lr, r0
    5ffc:	07010000 	streq	r0, [r1, -r0]
    6000:	04192401 	ldreq	r2, [r9], #-1025	; 0x401
    6004:	10240000 	eorne	r0, r4, r0
      ControlState = LAST_IN_DATA;
      Data_Mul_MaxPacketSize = FALSE;
    6008:	24000004 	strcs	r0, [r0], #-4
    }
    else
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
      vSetEPTxStatus(EP_TX_STALL);
    600c:	00000407 	andeq	r0, r0, r7, lsl #8
      Data_Mul_MaxPacketSize = FALSE;
    }
    else
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
    6010:	00283c20 	eoreq	r3, r8, r0, lsr #24
    }

    goto Expect_Status_Out;
  }

  Length = pEPinfo->PacketSize;
    6014:	00006e00 	andeq	r6, r0, r0, lsl #28
  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
    6018:	04221000 	strteq	r1, [r2], #-0
    601c:	2f0d0000 	svccs	0x000d0000
  if (Length > save_wLength)
  {
    Length = save_wLength;
  }

  DataBuffer = (*pEPinfo->CopyData)(Length);
    6020:	2b100000 	blcs	406028 <_etext+0x3fea14>
    6024:	2b000004 	blcs	603c <DataStageIn+0x64>
    6028:	2000002f 	andcs	r0, r0, pc, lsr #32

  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
    602c:	0000283c 	andeq	r2, r0, ip, lsr r8
    6030:	00000044 	andeq	r0, r0, r4, asr #32
    6034:	00043510 	andeq	r3, r4, r0, lsl r5
    6038:	002f6d00 	eoreq	r6, pc, r0, lsl #26

  SetEPTxCount(ENDP0, Length);
    603c:	00000000 	andeq	r0, r0, r0
    6040:	18092800 	stmdane	r9, {fp, sp}

  pEPinfo->Usb_wLength -= Length;
    6044:	0a010000 	beq	4604c <_etext+0x3ea38>
  pEPinfo->Usb_wOffset += Length;
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */
    6048:	00000001 	andeq	r0, r0, r1

  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
    604c:	00002600 	andeq	r2, r0, r0, lsl #12
  pEPinfo->Usb_wOffset += Length;
    6050:	659c0100 	ldrvs	r0, [ip, #256]	; 0x100
  vSetEPTxStatus(EP_TX_VALID);
    6054:	2900000a 	stmdbcs	r0, {r1, r3}
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
  pEPinfo->Usb_wOffset += Length;
    6058:	0a010072 	beq	46228 <_etext+0x3ec14>
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */

Expect_Status_Out:
  pInformation->ControlState = ControlState;
    605c:	00010a01 	andeq	r0, r1, r1, lsl #20
    6060:	002fe700 	eoreq	lr, pc, r0, lsl #14
    6064:	00782900 	rsbseq	r2, r8, r0, lsl #18
    6068:	10010a01 	andne	r0, r1, r1, lsl #20
    606c:	05000001 	streq	r0, [r0, #-1]
    6070:	2a000030 	bcs	6138 <Standard_ClearFeature+0x38>
    6074:	00706d74 	rsbseq	r6, r0, r4, ror sp
    6078:	3d010c01 	stccc	12, cr0, [r1, #-4]
    607c:	02000002 	andeq	r0, r0, #2
* Output         : None.
* Return         : Return USB_SUCCESS, if the request is performed.
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{
    6080:	1b265091 	blne	99a2cc <_etext+0x992cb8>

  if ((pInformation->USBwValue0 <=
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
    6084:	00000001 	andeq	r0, r0, r1
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{

  if ((pInformation->USBwValue0 <=
    6088:	16000000 	strne	r0, [r0], -r0
    608c:	01000000 	mrseq	r0, (UNDEF: 0)
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
    6090:	0a4d010f 	beq	13464d4 <_etext+0x133eec0>
      && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
    6094:	300f0000 	andcc	r0, pc, r0
  {
    pInformation->Current_Configuration = pInformation->USBwValue0;
    6098:	26000001 	strcs	r0, [r0], -r1
    pUser_Standard_Requests->User_SetConfiguration();
    609c:	18000030 	stmdane	r0, {r4, r5}
    60a0:	00000127 	andeq	r0, r0, r7, lsr #2
    return USB_SUCCESS;
    60a4:	2b005501 	blcs	1b4b0 <_etext+0x13e9c>
  }
  else
  {
    return USB_UNSUPPORT;
  }
}
    60a8:	00000000 	andeq	r0, r0, r0
    60ac:	000005d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    60b0:	03510112 	cmpeq	r1, #-2147483644	; 0x80000004
    60b4:	125101f3 	subsne	r0, r1, #-1073741764	; 0xc000003c
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetInterface(void)
{
    60b8:	7d025001 	stcvc	0, cr5, [r2, #-4]
  RESULT Re;
  /*Test if the specified Interface and Alternate Setting are supported by
    the application Firmware*/
  Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
    60bc:	2c000000 	stccs	0, cr0, [r0], {-0}
    60c0:	000017f2 	strdeq	r1, [r0], -r2
    60c4:	01011501 	tsteq	r1, r1, lsl #10
    60c8:	00000a9b 	muleq	r0, fp, sl

  if (pInformation->Current_Configuration != 0)
    60cc:	0100722d 	tsteq	r0, sp, lsr #4
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
    60d0:	010a0115 	tsteq	sl, r5, lsl r1
    60d4:	782d0000 	stmdavc	sp!, {}	; <UNPREDICTABLE>
        || (pInformation->USBwValue1 != 0))
    60d8:	01150100 	tsteq	r5, r0, lsl #2
    {
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
    60dc:	00000110 	andeq	r0, r0, r0, lsl r1
    60e0:	0100732d 	tsteq	r0, sp, lsr #6
      pInformation->Current_Interface = pInformation->USBwIndex0;
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
      return USB_SUCCESS;
    60e4:	010a0115 	tsteq	sl, r5, lsl r1
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
      pInformation->Current_Interface = pInformation->USBwIndex0;
    60e8:	692e0000 	stmdbvs	lr!, {}	; <UNPREDICTABLE>
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
    60ec:	01170100 	tsteq	r7, r0, lsl #2
      return USB_SUCCESS;
    }

  }

  return USB_UNSUPPORT;
    60f0:	0000007e 	andeq	r0, r0, lr, ror r0
}
    60f4:	165a2800 	ldrbne	r2, [sl], -r0, lsl #16
    60f8:	30010000 	andcc	r0, r1, r0
    60fc:	0028b401 	eoreq	fp, r8, r1, lsl #8
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_ClearFeature(void)
{
    6100:	00063400 	andeq	r3, r6, r0, lsl #8
  u32     Type_Rec = Type_Recipient;
    6104:	619c0100 	orrsvs	r0, ip, r0, lsl #2
  u32     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6108:	2900000f 	stmdbcs	r0, {r0, r1, r2, r3}
    610c:	30010072 	andcc	r0, r1, r2, ror r0
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
    6110:	00010a01 	andeq	r0, r1, r1, lsl #20
    6114:	00304600 	eorseq	r4, r0, r0, lsl #12
    return USB_SUCCESS;
  }
  else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    6118:	00612900 	rsbeq	r2, r1, r0, lsl #18
    DEVICE* pDev;
    u32 Related_Endpoint;
    u32 wIndex0;
    u32 rEP;

    if ((pInformation->USBwValue != ENDPOINT_STALL)
    611c:	10013001 	andne	r3, r1, r1
    6120:	73000001 	movwvc	r0, #1
        || (pInformation->USBwIndex1 != 0))
    6124:	2a000030 	bcs	61ec <Standard_SetEndPointFeature+0x1c>
    {
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    6128:	32010076 	andcc	r0, r1, #118	; 0x76
    rEP = wIndex0 & ~0x80;
    612c:	00023d01 	andeq	r3, r2, r1, lsl #26
    6130:	e0910300 	adds	r0, r1, r0, lsl #6

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
    6134:	00692a7e 	rsbeq	r2, r9, lr, ror sl
    6138:	3d013301 	stccc	3, cr3, [r1, #-4]
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    613c:	03000002 	movweq	r0, #2
    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    rEP = wIndex0 & ~0x80;
    Related_Endpoint = ENDP0 + rEP;

    if (ValBit(pInformation->USBwIndex0, 7))
    6140:	2a7f8091 	bcs	1fe638c <_etext+0x1fded78>
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
    6144:	34010078 	strcc	r0, [r1], #-120	; 0x78
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    6148:	00023d01 	andeq	r3, r2, r1, lsl #26
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    614c:	a0910300 	addsge	r0, r1, r0, lsl #6
    6150:	00792a7f 	rsbseq	r2, r9, pc, ror sl
        || (pInformation->Current_Configuration == 0))
    6154:	3d013501 	cfstr32cc	mvfx3, [r1, #-4]


    if (wIndex0 & 0x80)
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    6158:	02000002 	andeq	r0, r0, #2
    615c:	592f4091 	stmdbpl	pc!, {r0, r4, r7, lr}	; <UNPREDICTABLE>
    {
      return USB_UNSUPPORT;
    }


    if (wIndex0 & 0x80)
    6160:	b8000005 	stmdalt	r0, {r0, r2}
    6164:	b0000028 	andlt	r0, r0, r8, lsr #32
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    6168:	01000005 	tsteq	r0, r5
    616c:	0b490138 	bleq	1246654 <_etext+0x123f040>
      {
        ClearDTOG_TX(Related_Endpoint);
    6170:	77300000 	ldrvc	r0, [r0, -r0]!
    6174:	02000005 	andeq	r0, r0, #5
        SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
    6178:	00056e0f 	andeq	r6, r5, pc, lsl #28
    617c:	0030ab00 	eorseq	sl, r0, r0, lsl #22
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
    6180:	05650f00 	strbeq	r0, [r5, #-3840]!	; 0xf00
    6184:	30e30000 	rsccc	r0, r3, r0
    6188:	b0190000 	andslt	r0, r9, r0
      {
        if (Related_Endpoint == ENDP0)
        {
          /* After clear the STALL, enable the default endpoint receiver */
          SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
    618c:	10000005 	andne	r0, r0, r5
    6190:	00000580 	andeq	r0, r0, r0, lsl #11
    6194:	00003112 	andeq	r3, r0, r2, lsl r1
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
        }
        else
        {
          ClearDTOG_RX(Related_Endpoint);
    6198:	00058910 	andeq	r8, r5, r0, lsl r9
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
    619c:	00314000 	eorseq	r4, r1, r0
    61a0:	26000000 	strcs	r0, [r0], -r0
    61a4:	00000a65 	andeq	r0, r0, r5, ror #20
    61a8:	00002908 	andeq	r2, r0, r8, lsl #18
    61ac:	00000394 	muleq	r0, r4, r3
        }
      }
    }
    pUser_Standard_Requests->User_ClearFeature();
    61b0:	b1013901 	tstlt	r1, r1, lsl #18
    61b4:	2400000d 	strcs	r0, [r0], #-13
    return USB_SUCCESS;
    61b8:	00000a86 	andeq	r0, r0, r6, lsl #21
  }

  return USB_UNSUPPORT;
}
    61bc:	000a7c24 	andeq	r7, sl, r4, lsr #24
    61c0:	0a722400 	beq	1c8f1c8 <_etext+0x1c87bb4>
    61c4:	08200000 	stmdaeq	r0!, {}	; <UNPREDICTABLE>
    61c8:	94000029 	strls	r0, [r0], #-41	; 0x29
    61cc:	31000003 	tstcc	r0, r3
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetEndPointFeature(void)
{
    61d0:	00000a90 	muleq	r0, r0, sl
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    61d4:	0003fb26 	andeq	pc, r3, r6, lsr #22
    61d8:	00290800 	eoreq	r0, r9, r0, lsl #16
  u32    Related_Endpoint;
  u32    rEP;
  u32   Status;

  wIndex0 = pInformation->USBwIndex0;
  rEP = wIndex0 & ~0x80;
    61dc:	00007a00 	andeq	r7, r0, r0, lsl #20
    61e0:	011f0100 	tsteq	pc, r0, lsl #2

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
    61e4:	00000bcd 	andeq	r0, r0, sp, asr #23
    61e8:	00041924 	andeq	r1, r4, r4, lsr #18

  wIndex0 = pInformation->USBwIndex0;
  rEP = wIndex0 & ~0x80;
  Related_Endpoint = ENDP0 + rEP;

  if (ValBit(pInformation->USBwIndex0, 7))
    61ec:	04102400 	ldreq	r2, [r0], #-1024	; 0x400
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
    61f0:	07240000 	streq	r0, [r4, -r0]!
    61f4:	20000004 	andcs	r0, r0, r4
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
    61f8:	00002908 	andeq	r2, r0, r8, lsl #18
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    61fc:	0000007a 	andeq	r0, r0, sl, ror r0
      || pInformation->USBwValue != 0 || Status == 0
    6200:	00042210 	andeq	r2, r4, r0, lsl r2
      || pInformation->Current_Configuration == 0)
    6204:	0031a100 	eorseq	sl, r1, r0, lsl #2
  else
  {
    if (wIndex0 & 0x80)
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6208:	042b1000 	strteq	r1, [fp], #-0
    620c:	31bf0000 			; <UNDEFINED> instruction: 0x31bf0000
  {
    return USB_UNSUPPORT;
  }
  else
  {
    if (wIndex0 & 0x80)
    6210:	08200000 	stmdaeq	r0!, {}	; <UNPREDICTABLE>
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6214:	42000029 	andmi	r0, r0, #41	; 0x29
    6218:	10000000 	andne	r0, r0, r0
    621c:	00000435 	andeq	r0, r0, r5, lsr r4
    6220:	00003217 	andeq	r3, r0, r7, lsl r2
    6224:	2f000000 	svccs	0x00000000
    }

    else
    {
      /* OUT endpoint */
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    6228:	000003fb 	strdeq	r0, [r0], -fp
    622c:	00002982 	andeq	r2, r0, r2, lsl #19
    6230:	000005c8 	andeq	r0, r0, r8, asr #11
    6234:	1c012001 	stcne	0, cr2, [r1], {1}
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
    6238:	2400000c 	strcs	r0, [r0], #-12
    623c:	00000419 	andeq	r0, r0, r9, lsl r4
  return USB_SUCCESS;
    6240:	00041024 	andeq	r1, r4, r4, lsr #32

  if (Related_Endpoint >= Device_Table.Total_Endpoint
      || pInformation->USBwValue != 0 || Status == 0
      || pInformation->Current_Configuration == 0)
  {
    return USB_UNSUPPORT;
    6244:	04072400 	streq	r2, [r7], #-1024	; 0x400
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
  return USB_SUCCESS;
}
    6248:	c8190000 	ldmdagt	r9, {}	; <UNPREDICTABLE>
    624c:	10000005 	andne	r0, r0, r5
    6250:	00000422 	andeq	r0, r0, r2, lsr #8
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetDeviceFeature(void)
{
    6254:	00003291 	muleq	r0, r1, r2
  SetBit(pInformation->Current_Feature, 5);
    6258:	00042b10 	andeq	r2, r4, r0, lsl fp
    625c:	0032af00 	eorseq	sl, r2, r0, lsl #30
    6260:	29822000 	stmibcs	r2, {sp}
  pUser_Standard_Requests->User_SetDeviceFeature();
    6264:	00440000 	subeq	r0, r4, r0
    6268:	35100000 	ldrcc	r0, [r0, #-0]
  return USB_SUCCESS;
}
    626c:	04000004 	streq	r0, [r0], #-4
    6270:	00000033 	andeq	r0, r0, r3, lsr r0
    6274:	fb2f0000 	blx	bc627e <_etext+0xbbec6a>
*******************************************************************************/
u8 *Standard_GetDescriptorData(u16 Length, ONE_DESCRIPTOR *pDesc)
{
  u32  wOffset;

  wOffset = pInformation->Ctrl_Info.Usb_wOffset;
    6278:	06000003 	streq	r0, [r0], -r3
    627c:	e000002a 	and	r0, r0, sl, lsr #32
  if (Length == 0)
  {
    pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
    6280:	01000005 	tsteq	r0, r5
    6284:	0c670124 	stfeqe	f0, [r7], #-144	; 0xffffff70
    return 0;
  }

  return pDesc->Descriptor + wOffset;
    6288:	19240000 	stmdbne	r4!, {}	; <UNPREDICTABLE>
}
    628c:	24000004 	strcs	r0, [r0], #-4
    6290:	00000410 	andeq	r0, r0, r0, lsl r4
* Output         : None.
* Return         : - 0 if the control State is in PAUSE
*                  - 1 if not.
*******************************************************************************/
u8 Post0_Process(void)
{
    6294:	00040724 	andeq	r0, r4, r4, lsr #14
  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
    6298:	05e01900 	strbeq	r1, [r0, #2304]!	; 0x900
    629c:	22100000 	andscs	r0, r0, #0
    62a0:	81000004 	tsthi	r0, r4

  if (pInformation->ControlState == STALLED)
    62a4:	10000033 	andne	r0, r0, r3, lsr r0
    62a8:	0000042b 	andeq	r0, r0, fp, lsr #8
  {
    vSetEPRxStatus(EP_RX_STALL);
    62ac:	000033ab 	andeq	r3, r0, fp, lsr #7
    62b0:	0005f819 	andeq	pc, r5, r9, lsl r8	; <UNPREDICTABLE>
    vSetEPTxStatus(EP_TX_STALL);
    62b4:	04351000 	ldrteq	r1, [r5], #-0
    62b8:	340f0000 	strcc	r0, [pc], #-0	; 62c0 <Post0_Process+0x2c>
  }

  return (pInformation->ControlState == PAUSE);
}
    62bc:	00000000 	andeq	r0, r0, r0
    62c0:	03fb2600 	mvnseq	r2, #0, 12
    62c4:	2a960000 	bcs	fe5862cc <BootRAM+0xd4f6a6d>
    62c8:	00820000 	addeq	r0, r2, r0
    62cc:	25010000 	strcs	r0, [r1, #-0]
    62d0:	000cba01 	andeq	fp, ip, r1, lsl #20
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 Setup0_Process(void)
{
    62d4:	04192400 	ldreq	r2, [r9], #-1024	; 0x400
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    62d8:	10240000 	eorne	r0, r4, r0

  if (pInformation->ControlState != PAUSE)
    62dc:	24000004 	strcs	r0, [r0], #-4
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    62e0:	00000407 	andeq	r0, r0, r7, lsl #8
    62e4:	002a9620 	eoreq	r9, sl, r0, lsr #12

  if (pInformation->ControlState != PAUSE)
    62e8:	00008200 	andeq	r8, r0, r0, lsl #4
    62ec:	04221000 	strteq	r1, [r2], #-0
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    62f0:	34890000 	strcc	r0, [r9], #0
    62f4:	2b100000 	blcs	4062fc <_etext+0x3fece8>
    62f8:	a7000004 	strge	r0, [r0, -r4]

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
    62fc:	20000034 	andcs	r0, r0, r4, lsr r0
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
    6300:	00002a96 	muleq	r0, r6, sl
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = *pBuf.w++; /* wValue in Little Endian */
    6304:	0000004a 	andeq	r0, r0, sl, asr #32
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = *pBuf.w++; /* wIndex in Little Endian */
    6308:	00043510 	andeq	r3, r4, r0, lsl r5
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwLength = *pBuf.w; /* wLength in Little Endian */
    630c:	0034fc00 	eorseq	pc, r4, r0, lsl #24
  }

  pInformation->ControlState = SETTING_UP;
    6310:	00000000 	andeq	r0, r0, r0
  if (pInformation->USBwLength == 0)
    6314:	0003fb26 	andeq	pc, r3, r6, lsr #22
    6318:	002b2a00 	eoreq	r2, fp, r0, lsl #20
{
  RESULT Result = USB_UNSUPPORT;
  u32 RequestNo = pInformation->USBbRequest;
  u32 ControlState;

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    631c:	00007c00 	andeq	r7, r0, r0, lsl #24
    6320:	01290100 	teqeq	r9, r0, lsl #2
  {
    /* Device Request*/
    /* SET_CONFIGURATION*/
    if (RequestNo == SET_CONFIGURATION)
    6324:	00000d0d 	andeq	r0, r0, sp, lsl #26
    {
      Result = Standard_SetConfiguration();
    6328:	00041924 	andeq	r1, r4, r4, lsr #18
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    632c:	04102400 	ldreq	r2, [r0], #-1024	; 0x400
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
    6330:	07240000 	streq	r0, [r4, -r0]!
    6334:	20000004 	andcs	r0, r0, r4
          || (pInformation->USBwIndex != 0)
          || (pInformation->Current_Configuration != 0))
        /* Device Address should be 127 or less*/
      {
        ControlState = STALLED;
    6338:	00002b2a 	andeq	r2, r0, sl, lsr #22
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
    633c:	0000007c 	andeq	r0, r0, ip, ror r0
    6340:	00042210 	andeq	r2, r4, r0, lsl r2
          || (pInformation->USBwIndex != 0)
    6344:	00357900 	eorseq	r7, r5, r0, lsl #18
          || (pInformation->Current_Configuration != 0))
    6348:	042b1000 	strteq	r1, [fp], #-0
    634c:	35970000 	ldrcc	r0, [r7]
      {
        Result = USB_SUCCESS;
      }
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    6350:	2a200000 	bcs	806358 <_etext+0x7fed44>
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
    6354:	4600002b 	strmi	r0, [r0], -fp, lsr #32
    6358:	10000000 	andne	r0, r0, r0
  }


  if (Result != USB_SUCCESS)
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    635c:	00000435 	andeq	r0, r0, r5, lsr r4
    6360:	000035ef 	andeq	r3, r0, pc, ror #11
    if (Result == USB_NOT_READY)
    6364:	26000000 	strcs	r0, [r0], -r0
    6368:	000003fb 	strdeq	r0, [r0], -fp
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
          && (pInformation->USBwIndex == 0)
    636c:	00002ba6 	andeq	r2, r0, r6, lsr #23
          && (ValBit(pInformation->Current_Feature, 5)))
    6370:	0000007e 	andeq	r0, r0, lr, ror r0
    6374:	60012c01 	andvs	r2, r1, r1, lsl #24
      {
        Result = Standard_SetDeviceFeature();
    6378:	2400000d 	strcs	r0, [r0], #-13
      {
        Result = USB_UNSUPPORT;
      }
    }
    /*Clear FEATURE for Device */
    else if (RequestNo == CLEAR_FEATURE)
    637c:	00000419 	andeq	r0, r0, r9, lsl r4
    {
      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
    6380:	00041024 	andeq	r1, r4, r4, lsr #32
    6384:	04072400 	streq	r2, [r7], #-1024	; 0x400
          && pInformation->USBwIndex == 0
    6388:	a6200000 	strtge	r0, [r0], -r0
          && ValBit(pInformation->Current_Feature, 5))
    638c:	7e00002b 	cdpvc	0, 0, cr0, cr0, cr11, {1}
    6390:	10000000 	andne	r0, r0, r0
      {
        Result = Standard_ClearFeature();
    6394:	00000422 	andeq	r0, r0, r2, lsr #8
    }

  }

  /* Interface Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    6398:	00003669 	andeq	r3, r0, r9, ror #12
  {
    /*SET INTERFACE*/
    if (RequestNo == SET_INTERFACE)
    639c:	00042b10 	andeq	r2, r4, r0, lsl fp
    {
      Result = Standard_SetInterface();
    63a0:	00368700 	eorseq	r8, r6, r0, lsl #14
    63a4:	2ba62000 	blcs	fe98e3ac <BootRAM+0xd8feb4d>
    }
  }

  /* EndPoint Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    63a8:	00460000 	subeq	r0, r6, r0
  {
    /*CLEAR FEATURE for EndPoint*/
    if (RequestNo == CLEAR_FEATURE)
    63ac:	35100000 	ldrcc	r0, [r0, #-0]
    {
      Result = Standard_ClearFeature();
    }
    /* SET FEATURE for EndPoint*/
    else if (RequestNo == SET_FEATURE)
    63b0:	dc000004 	stcle	0, cr0, [r0], {4}
    {
      Result = Standard_SetEndPointFeature();
    63b4:	00000036 	andeq	r0, r0, r6, lsr r0
  {
    Result = USB_UNSUPPORT;
  }


  if (Result != USB_SUCCESS)
    63b8:	fb270000 	blx	9c63c2 <_etext+0x9bedae>
      ControlState = PAUSE;
      goto exit_NoData_Setup0;
    }
  }

  if (Result != USB_SUCCESS)
    63bc:	24000003 	strcs	r0, [r0], #-3
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();
    63c0:	7800002c 	stmdavc	r0, {r2, r3, r5}
    63c4:	01000000 	mrseq	r0, (UNDEF: 0)
    63c8:	1924012d 	stmdbne	r4!, {r0, r2, r3, r5, r8}
    63cc:	24000004 	strcs	r0, [r0], #-4
    63d0:	00000410 	andeq	r0, r0, r0, lsl r4
  {
    ControlState = STALLED;
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
    63d4:	00040724 	andeq	r0, r4, r4, lsr #14

  USB_StatusIn();

exit_NoData_Setup0:
  pInformation->ControlState = ControlState;
    63d8:	2c242000 	stccs	0, cr2, [r4], #-0
    63dc:	00780000 	rsbseq	r0, r8, r0


  CopyRoutine = NULL;
  wOffset = 0;

  if (Request_No == GET_DESCRIPTOR)
    63e0:	22100000 	andscs	r0, r0, #0
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    63e4:	59000004 	stmdbpl	r0, {r2}
    {
      u8 wValue1 = pInformation->USBwValue1;
    63e8:	10000037 	andne	r0, r0, r7, lsr r0
      if (wValue1 == DEVICE_DESCRIPTOR)
    63ec:	0000042b 	andeq	r0, r0, fp, lsr #8
      {
        CopyRoutine = pProperty->GetDeviceDescriptor;
    63f0:	00003777 	andeq	r3, r0, r7, ror r7
    63f4:	002c2420 	eoreq	r2, ip, r0, lsr #8
      }
      else if (wValue1 == CONFIG_DESCRIPTOR)
    63f8:	00004200 	andeq	r4, r0, r0, lsl #4
      {
        CopyRoutine = pProperty->GetConfigDescriptor;
    63fc:	04351000 	ldrteq	r1, [r5], #-0
      }
      else if (wValue1 == STRING_DESCRIPTOR)
    6400:	37cf0000 	strbcc	r0, [pc, r0]
      {
        CopyRoutine = pProperty->GetStringDescriptor;
    6404:	00000000 	andeq	r0, r0, r0
    6408:	26000000 	strcs	r0, [r0], -r0
      } else if (wValue1 == 0x21) /* added to support functional descriptors */
    640c:	000003fb 	strdeq	r0, [r0], -fp
      {
	CopyRoutine = pProperty->GetFunctionalDescriptor;
    6410:	00002c9c 	muleq	r0, ip, ip
      } /* End of GET_DESCRIPTOR */
    }
  }

  /*GET STATUS*/
  else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
    6414:	00000080 	andeq	r0, r0, r0, lsl #1
    6418:	04013c01 	streq	r3, [r1], #-3073	; 0xc01
    641c:	2400000e 	strcs	r0, [r0], #-14
           && (pInformation->USBwLength == 0x0002)
           && (pInformation->USBwIndex1 == 0))
    6420:	00000419 	andeq	r0, r0, r9, lsl r4
    6424:	00041024 	andeq	r1, r4, r4, lsr #32
    6428:	04072400 	streq	r2, [r7], #-1024	; 0x400
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    642c:	9c200000 	stcls	0, cr0, [r0], #-0
    6430:	8000002c 	andhi	r0, r0, ip, lsr #32
        && (pInformation->USBwIndex == 0))
    6434:	10000000 	andne	r0, r0, r0
    6438:	00000422 	andeq	r0, r0, r2, lsr #8
    {
      CopyRoutine = Standard_GetStatus;
    }

    /* GET STATUS for Interface*/
    else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    643c:	00003849 	andeq	r3, r0, r9, asr #16
    {
      if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
    6440:	00042b10 	andeq	r2, r4, r0, lsl fp
    6444:	00386700 	eorseq	r6, r8, r0, lsl #14
    6448:	2c9c2000 	ldccs	0, cr2, [ip], {0}
    644c:	00460000 	subeq	r0, r6, r0
          && (pInformation->Current_Configuration != 0))
    6450:	35100000 	ldrcc	r0, [r0, #-0]
    6454:	bc000004 	stclt	0, cr0, [r0], {4}
    6458:	00000038 	andeq	r0, r0, r8, lsr r0
        CopyRoutine = Standard_GetStatus;
      }
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    645c:	fb260000 	blx	986466 <_etext+0x97ee52>
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    6460:	1c000003 	stcne	0, cr0, [r0], {3}
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
    6464:	7000002d 	andvc	r0, r0, sp, lsr #32

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
    6468:	01000000 	mrseq	r0, (UNDEF: 0)
    646c:	0e57013d 	mrceq	1, 2, r0, cr7, cr13, {1}
    6470:	19240000 	stmdbne	r4!, {}	; <UNPREDICTABLE>
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
      Reserved = pInformation->USBwIndex0 & 0x70;

      if (ValBit(pInformation->USBwIndex0, 7))
    6474:	24000004 	strcs	r0, [r0], #-4
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
    6478:	00000410 	andeq	r0, r0, r0, lsl r4
    647c:	00040724 	andeq	r0, r4, r4, lsr #14
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
    6480:	2d1c2000 	ldccs	0, cr2, [ip, #-0]
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    6484:	00700000 	rsbseq	r0, r0, r0
    6488:	22100000 	andscs	r0, r0, #0
          && (Status != 0))
    648c:	39000004 	stmdbcc	r0, {r2}
    6490:	10000039 	andne	r0, r0, r9, lsr r0
    }

  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
    6494:	0000042b 	andeq	r0, r0, fp, lsr #8
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6498:	00003957 	andeq	r3, r0, r7, asr r9
    649c:	002d1c20 	eoreq	r1, sp, r0, lsr #24
    {
      CopyRoutine = Standard_GetConfiguration;
    }
  }
  /*GET INTERFACE*/
  else if (Request_No == GET_INTERFACE)
    64a0:	00004000 	andeq	r4, r0, r0
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    64a4:	04351000 	ldrteq	r1, [r5], #-0
    64a8:	39ae0000 	stmibcc	lr!, {}	; <UNPREDICTABLE>
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
    64ac:	00000000 	andeq	r0, r0, r0
    64b0:	013a2600 	teqeq	sl, r0, lsl #12
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
    64b4:	2d8c0000 	stccs	0, cr0, [ip]
    64b8:	00140000 	andseq	r0, r4, r0
    64bc:	3e010000 	cdpcc	0, 0, cr0, cr1, cr0, {0}
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
    64c0:	000e8a01 	andeq	r8, lr, r1, lsl #20
    64c4:	014f3000 	mrseq	r3, SPSR
    64c8:	24000000 	strcs	r0, [r0], #-0
    64cc:	00000146 	andeq	r0, r0, r6, asr #2
      CopyRoutine = Standard_GetInterface;
    }

  }

  if (CopyRoutine)
    64d0:	002d8c20 	eoreq	r8, sp, r0, lsr #24
  {
    pInformation->Ctrl_Info.Usb_wOffset = wOffset;
    64d4:	00001400 	andeq	r1, r0, r0, lsl #8
    pInformation->Ctrl_Info.CopyData = CopyRoutine;
    64d8:	01581000 	cmpeq	r8, r0
    /* sb in the original the cast to word was directly */
    /* now the cast is made step by step */
    (*CopyRoutine)(0);
    64dc:	3a280000 	bcc	a064e4 <_etext+0x9feed0>
    Result = USB_SUCCESS;
    64e0:	00000000 	andeq	r0, r0, r0
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
    64e4:	00033a2f 	andeq	r3, r3, pc, lsr #20
    64e8:	002da000 	eoreq	sl, sp, r0
    64ec:	00061000 	andeq	r1, r6, r0
    if (Result == USB_NOT_READY)
    64f0:	013f0100 	teqeq	pc, r0, lsl #2
    {
      pInformation->ControlState = PAUSE;
    64f4:	00000ec6 	andeq	r0, r0, r6, asr #29
      return;
    }
  }

  if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
    64f8:	00035824 	andeq	r5, r3, r4, lsr #16
    64fc:	034f2400 	movteq	r2, #62464	; 0xf400
    6500:	46240000 	strtmi	r0, [r4], -r0
  {
    /* Data is not ready, wait it */
    pInformation->ControlState = PAUSE;
    6504:	19000003 	stmdbne	r0, {r0, r1}
    return;
  }
  if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
    6508:	00000610 	andeq	r0, r0, r0, lsl r6
    650c:	00036110 	andeq	r6, r3, r0, lsl r1
  {
    /* Unsupported request */
    pInformation->ControlState = STALLED;
    6510:	003a4800 	eorseq	r4, sl, r0, lsl #16
    return;
  }


  if (ValBit(pInformation->USBbmRequestType, 7))
    6514:	036a1000 	cmneq	sl, #0
    6518:	3a710000 	bcc	1c46520 <_etext+0x1c3ef0c>
  {
    /* Device ==> Host */
    vu32 wLength = pInformation->USBwLength;
    651c:	00000000 	andeq	r0, r0, r0

    /* Restrict the data length to be the one host asks */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
    6520:	0003fb2f 	andeq	pc, r3, pc, lsr #22
    6524:	002dea00 	eoreq	lr, sp, r0, lsl #20
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
    6528:	00062800 	andeq	r2, r6, r0, lsl #16
    652c:	01420100 	mrseq	r0, (UNDEF: 82)
    6530:	00000f11 	andeq	r0, r0, r1, lsl pc
    6534:	00041924 	andeq	r1, r4, r4, lsr #18
    6538:	04102400 	ldreq	r2, [r0], #-1024	; 0x400
    653c:	07240000 	streq	r0, [r4, -r0]!
    6540:	19000004 	stmdbne	r0, {r2}
    6544:	00000628 	andeq	r0, r0, r8, lsr #12
    6548:	00042210 	andeq	r2, r4, r0, lsl r2
    }

    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
    654c:	003ad400 	eorseq	sp, sl, r0, lsl #8
    {
      if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
    6550:	042b1000 	strteq	r1, [fp], #-0
    6554:	3af20000 	bcc	ffc8655c <BootRAM+0xebf6cfd>
    6558:	40190000 	andsmi	r0, r9, r0
      {
        Data_Mul_MaxPacketSize = FALSE;
    655c:	10000006 	andne	r0, r0, r6
      }
      else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
    6560:	00000435 	andeq	r0, r0, r5, lsr r4
    6564:	00003b47 	andeq	r3, r0, r7, asr #22
      {
        Data_Mul_MaxPacketSize = TRUE;
    6568:	27000000 	strcs	r0, [r0, -r0]
    656c:	000003fb 	strdeq	r0, [r0], -fp
      }
    }

    pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
    6570:	00002e70 	andeq	r2, r0, r0, ror lr
    6574:	00000070 	andeq	r0, r0, r0, ror r0
    DataStageIn();
    6578:	24014301 	strcs	r4, [r1], #-769	; 0x301
  }
  else
  {
    pInformation->ControlState = OUT_DATA;
    657c:	00000419 	andeq	r0, r0, r9, lsl r4
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
    6580:	00041024 	andeq	r1, r4, r4, lsr #32
    6584:	04072400 	streq	r2, [r7], #-1024	; 0x400
  else
  {
    /* Setup with data stage */
    Data_Setup0();
  }
  return Post0_Process();
    6588:	70200000 	eorvc	r0, r0, r0
}
    658c:	7000002e 	andvc	r0, r0, lr, lsr #32
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
        && (pInformation->USBwIndex == 0))
    {
      CopyRoutine = Standard_GetStatus;
    6590:	10000000 	andne	r0, r0, r0
  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    {
      CopyRoutine = Standard_GetConfiguration;
    6594:	00000422 	andeq	r0, r0, r2, lsr #8
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
    {
      CopyRoutine = Standard_GetInterface;
    6598:	00003bc4 	andeq	r3, r0, r4, asr #23
    659c:	00042b10 	andeq	r2, r4, r0, lsl fp
    65a0:	003be200 	eorseq	lr, fp, r0, lsl #4
    65a4:	2e702000 	cdpcs	0, 7, cr2, cr0, cr0, {0}
    65a8:	00420000 	subeq	r0, r2, r0
    65ac:	35100000 	ldrcc	r0, [r0, #-0]
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 Out0_Process(void)
{
    65b0:	24000004 	strcs	r0, [r0], #-4
  u32 ControlState = pInformation->ControlState;
    65b4:	0000003c 	andeq	r0, r0, ip, lsr r0

  if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
    65b8:	32000000 	andcc	r0, r0, #0
    65bc:	000017e6 	andeq	r1, r0, r6, ror #15
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  u32 save_rLength;

  save_rLength = pEPinfo->Usb_rLength;

  if (pEPinfo->CopyData && save_rLength)
    65c0:	0f720901 	svceq	0x00720901
    65c4:	03050000 	movweq	r0, #20480	; 0x5000
  {
    u8 *Buffer;
    u32 Length;

    Length = pEPinfo->PacketSize;
    65c8:	00000000 	andeq	r0, r0, r0
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    65cc:	00023d0c 	andeq	r3, r2, ip, lsl #26
    65d0:	14893200 	strne	r3, [r9], #512	; 0x200
    pEPinfo->Usb_rLength -= Length;
    65d4:	0a010000 	beq	465dc <_etext+0x3efc8>
    65d8:	00000f88 	andeq	r0, r0, r8, lsl #31
    pEPinfo->Usb_rOffset += Length;
    65dc:	72600305 	rsbvc	r0, r0, #335544320	; 0x14000000
    65e0:	3d0c0000 	stccc	0, cr0, [ip, #-0]

    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
    65e4:	33000002 	movwcc	r0, #2
    65e8:	00000ff1 	strdeq	r0, [r0], -r1
    65ec:	000000b4 	strheq	r0, [r0], -r4
    65f0:	0000b434 	andeq	fp, r0, r4, lsr r4
  }

  if (pEPinfo->Usb_rLength != 0)
    65f4:	007e3400 	rsbseq	r3, lr, r0, lsl #8
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    SetEPTxCount(ENDP0, 0);
    65f8:	ad340000 	ldcge	0, cr0, [r4, #-0]
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
  }

  if (pEPinfo->Usb_rLength != 0)
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    65fc:	00000000 	andeq	r0, r0, r0
    6600:	000d7000 	andeq	r7, sp, r0
    SetEPTxCount(ENDP0, 0);
    6604:	1f000400 	svcne	0x00000400
    vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
    6608:	04000017 	streq	r0, [r0], #-23
  }
  /* Set the next State*/
  if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
    660c:	0014a601 	andseq	sl, r4, r1, lsl #12
    6610:	18f20100 	ldmne	r2!, {r8}^
  {
    pInformation->ControlState = OUT_DATA;
    6614:	08930000 	ldmeq	r3, {}	; <UNPREDICTABLE>
    6618:	08300000 	ldmdaeq	r0!, {}	; <UNPREDICTABLE>
  }
  else
  {
    if (pEPinfo->Usb_rLength > 0)
    {
      pInformation->ControlState = LAST_OUT_DATA;
    661c:	00000000 	andeq	r0, r0, r0
    6620:	1e770000 	cdpne	0, 7, cr0, cr7, cr0, {0}
    }
    else if (pEPinfo->Usb_rLength == 0)
    {
      pInformation->ControlState = WAIT_STATUS_IN;
    6624:	01020000 	mrseq	r0, (UNDEF: 2)
    6628:	00081a06 	andeq	r1, r8, r6, lsl #20
      USB_StatusIn();
    662c:	0ad90300 	beq	ff647234 <BootRAM+0xe5b79d5>
    6630:	1c030000 	stcne	0, cr0, [r3], {-0}
    6634:	00000037 	andeq	r0, r0, r7, lsr r0
    6638:	18080102 	stmdane	r8, {r1, r8}
    663c:	02000008 	andeq	r0, r0, #8
  u32 ControlState = pInformation->ControlState;

  if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
  {
    DataStageOut();
    ControlState = pInformation->ControlState; /* may be changed outside the function */
    6640:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
  }

  else if (ControlState == WAIT_STATUS_OUT)
    6644:	a1030000 	mrsge	r0, (UNDEF: 3)
  {
    (*pProperty->Process_Status_OUT)();
    6648:	0300000d 	movweq	r0, #13
    664c:	00005026 	andeq	r5, r0, r6, lsr #32
  }

  else if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
  {
    /* host aborts the transfer before finish */
    ControlState = STALLED;
    6650:	07020200 	streq	r0, [r2, -r0, lsl #4]
  else
  {
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;
    6654:	00000949 	andeq	r0, r0, r9, asr #18

  return Post0_Process();
}
    6658:	da050402 	ble	147668 <_etext+0x140054>
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
    665c:	03000004 	movweq	r0, #4
    6660:	00000abf 			; <UNDEFINED> instruction: 0x00000abf
    6664:	00693803 	rsbeq	r3, r9, r3, lsl #16
    6668:	04020000 	streq	r0, [r2], #-0
    666c:	00025207 	andeq	r5, r2, r7, lsl #4
    6670:	05080200 	streq	r0, [r8, #-512]	; 0x200
    6674:	000004d5 	ldrdeq	r0, [r0], -r5
* Input          : - Val: device adress.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetDeviceAddress(u8 Val)
{
    6678:	4d070802 	stcmi	8, cr0, [r7, #-8]
  u32 i;
  u32 nEP = Device_Table.Total_Endpoint;
    667c:	04000002 	streq	r0, [r0], #-2

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
    6680:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    6684:	04020074 	streq	r0, [r2], #-116	; 0x74
    6688:	00025707 	andeq	r5, r2, r7, lsl #14
    668c:	0adb0300 	beq	ff6c7294 <BootRAM+0xe637a35>
  {
    _SetEPAddress((u8)i, (u8)i);
    6690:	2a040000 	bcs	106698 <_etext+0xff084>
    6694:	0000002c 	andeq	r0, r0, ip, lsr #32
    6698:	000da303 	andeq	sl, sp, r3, lsl #6
{
  u32 i;
  u32 nEP = Device_Table.Total_Endpoint;

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
    669c:	45360400 	ldrmi	r0, [r6, #-1024]!	; 0x400
  {
    _SetEPAddress((u8)i, (u8)i);
  } /* for */
  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
    66a0:	03000000 	movweq	r0, #0
    66a4:	00000ac1 	andeq	r0, r0, r1, asr #21
    66a8:	005e4204 	subseq	r4, lr, r4, lsl #4
    66ac:	e3030000 	movw	r0, #12288	; 0x3000
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 In0_Process(void)
{
    66b0:	0500000a 	streq	r0, [r0, #-10]
  u32 ControlState = pInformation->ControlState;
    66b4:	000085d4 	ldrdeq	r8, [r0], -r4

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
    66b8:	07040200 	streq	r0, [r4, -r0, lsl #4]
    66bc:	0000078b 	andeq	r0, r0, fp, lsl #15
  {
    DataStageIn();
    66c0:	01020405 	tsteq	r2, r5, lsl #8
    /* ControlState may be changed outside the function */
    ControlState = pInformation->ControlState;
    66c4:	00082108 	andeq	r2, r8, r8, lsl #2
    66c8:	186f0600 	stmdane	pc!, {r9, sl}^	; <UNPREDICTABLE>
  }

  else if (ControlState == WAIT_STATUS_IN)
    66cc:	8f010000 	svchi	0x00010000
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
    66d0:	00011501 	andeq	r1, r1, r1, lsl #10
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    66d4:	73640700 	cmnvc	r4, #0, 14
    ControlState = pInformation->ControlState;
  }

  else if (ControlState == WAIT_STATUS_IN)
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
    66d8:	8f010074 	svchi	0x00010074
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    {
      SetDeviceAddress(pInformation->USBwValue0);
    66dc:	00000115 	andeq	r0, r0, r5, lsl r1
      pUser_Standard_Requests->User_SetDeviceAddress();
    66e0:	0017ed08 	andseq	lr, r7, r8, lsl #26
    66e4:	1b900100 	blne	fe406aec <BootRAM+0xd37728d>
    }
    (*pProperty->Process_Status_IN)();
    66e8:	07000001 	streq	r0, [r0, -r1]
    66ec:	00656e6f 	rsbeq	r6, r5, pc, ror #28
    ControlState = STALLED;
  }

  else
  {
    ControlState = STALLED;
    66f0:	011b9001 	tsteq	fp, r1
  }

  pInformation->ControlState = ControlState;
    66f4:	1f080000 	svcne	0x00080000

  return Post0_Process();
}
    66f8:	01000018 	tsteq	r0, r8, lsl r0
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
    66fc:	00008c91 	muleq	r0, r1, ip
    6700:	0d1c0900 	ldceq	9, cr0, [ip, #-0]
    6704:	93010000 	movwls	r0, #4096	; 0x1000
    6708:	00000121 	andeq	r0, r0, r1, lsr #2
*                  - wNBytes: no. of bytes to be copied.
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
    670c:	0100690a 	tsteq	r0, sl, lsl #18
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
    6710:	00007e94 	muleq	r0, r4, lr
    6714:	040b0000 	streq	r0, [fp], #-0
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
    6718:	0000008c 	andeq	r0, r0, ip, lsl #1
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
    671c:	0121040b 	teqeq	r1, fp, lsl #8
    6720:	8c0c0000 	stchi	0, cr0, [ip], {-0}
    6724:	0d000000 	stceq	0, cr0, [r0, #-0]
  {
    temp1 = (u16) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (u16) * pbUsrBuf << 8;
    6728:	00001893 	muleq	r0, r3, r8
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
  {
    temp1 = (u16) * pbUsrBuf;
    672c:	007e5601 	rsbseq	r5, lr, r1, lsl #12
    pbUsrBuf++;
    temp2 = temp1 | (u16) * pbUsrBuf << 8;
    6730:	49030000 	stmdbmi	r3, {}	; <UNPREDICTABLE>
    *pdwVal++ = temp2;
    6734:	07000001 	streq	r0, [r0, -r1]
    6738:	56010061 	strpl	r0, [r1], -r1, rrx
*                  - wNBytes     = no. of bytes to be copied.
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
    673c:	0000007e 	andeq	r0, r0, lr, ror r0
  u32 n = (wNBytes + 1) >> 1;/* /2*/
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
    6740:	01006207 	tsteq	r0, r7, lsl #4
    6744:	00007e56 	andeq	r7, r0, r6, asr lr
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;/* /2*/
    6748:	620e0000 	andvs	r0, lr, #0
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
    674c:	01000018 	tsteq	r0, r8, lsl r0
    6750:	017a013d 	cmneq	sl, sp, lsr r1
  {
    *(u16*)pbUsrBuf++ = *pdwVal++;
    6754:	78070000 	stmdavc	r7, {}	; <UNPREDICTABLE>
    6758:	153d0100 	ldrne	r0, [sp, #-256]!	; 0x100
    675c:	07000001 	streq	r0, [r0, -r1]
    6760:	3d01006e 	stccc	0, cr0, [r1, #-440]	; 0xfffffe48
    6764:	0000007e 	andeq	r0, r0, lr, ror r0
    6768:	0100630a 	tsteq	r0, sl, lsl #6
    676c:	0000973f 	andeq	r9, r0, pc, lsr r7
    6770:	00690a00 	rsbeq	r0, r9, r0, lsl #20
    6774:	007e4001 	rsbseq	r4, lr, r1
    6778:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    677c:	000018e6 	andeq	r1, r0, r6, ror #17
    6780:	99032602 	stmdbls	r3, {r1, r9, sl, sp}
    6784:	07000001 	streq	r0, [r0, -r1]
    6788:	26020078 			; <UNDEFINED> instruction: 0x26020078
    678c:	00000115 	andeq	r0, r0, r5, lsl r1
    6790:	02006107 	andeq	r6, r0, #-1073741823	; 0xc0000001
    6794:	00011b26 	andeq	r1, r1, r6, lsr #22
    6798:	200e0000 	andcs	r0, lr, r0
    679c:	01000019 	tsteq	r0, r9, lsl r0
    67a0:	01ca010c 	biceq	r0, sl, ip, lsl #2
    67a4:	78070000 	stmdavc	r7, {}	; <UNPREDICTABLE>
    67a8:	150c0100 	strne	r0, [ip, #-256]	; 0x100
    67ac:	07000001 	streq	r0, [r0, -r1]
    67b0:	0c010070 	stceq	0, cr0, [r1], {112}	; 0x70
    67b4:	0000011b 	andeq	r0, r0, fp, lsl r1
    67b8:	0100630a 	tsteq	r0, sl, lsl #6
    67bc:	0000970e 	andeq	r9, r0, lr, lsl #14
    67c0:	00690a00 	rsbeq	r0, r9, r0, lsl #20
    67c4:	007e0f01 	rsbseq	r0, lr, r1, lsl #30
    67c8:	06000000 	streq	r0, [r0], -r0
    67cc:	000018da 	ldrdeq	r1, [r0], -sl
    67d0:	f2014901 	vmla.i8	d4, d1, d1
    67d4:	07000001 	streq	r0, [r0, -r1]
    67d8:	49010078 	stmdbmi	r1, {r3, r4, r5, r6}
    67dc:	00000115 	andeq	r0, r0, r5, lsl r1
    67e0:	01006307 	tsteq	r0, r7, lsl #6
    67e4:	0000a249 	andeq	sl, r0, r9, asr #4
    67e8:	00690a00 	rsbeq	r0, r9, r0, lsl #20
    67ec:	007e4b01 	rsbseq	r4, lr, r1, lsl #22
    67f0:	0f000000 	svceq	0x00000000
    67f4:	000001ca 	andeq	r0, r0, sl, asr #3
    67f8:	00000000 	andeq	r0, r0, r0
    67fc:	0000001e 	andeq	r0, r0, lr, lsl r0
    6800:	023e9c01 	eorseq	r9, lr, #256	; 0x100
    6804:	d6100000 	ldrle	r0, [r0], -r0
    6808:	9e000001 	cdpls	0, 0, cr0, cr0, cr1, {0}
    680c:	1000003c 	andne	r0, r0, ip, lsr r0
    6810:	000001df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    6814:	00003ccc 	andeq	r3, r0, ip, asr #25
    6818:	0001e811 	andeq	lr, r1, r1, lsl r8
    681c:	003d1e00 	eorseq	r1, sp, r0, lsl #28
    6820:	00001200 	andeq	r1, r0, r0, lsl #4
    6824:	0d5a0000 	ldcleq	0, cr0, [sl, #-0]
    6828:	01130000 	tsteq	r3, r0
    682c:	134c0152 	movtne	r0, #49490	; 0xc152
    6830:	30015101 	andcc	r5, r1, r1, lsl #2
    6834:	05500113 	ldrbeq	r0, [r0, #-275]	; 0x113
    6838:	235001f3 	cmpcs	r0, #-1073741764	; 0xc000003c
    683c:	0d000004 	stceq	0, cr0, [r0, #-16]
    6840:	000018c6 	andeq	r1, r0, r6, asr #17
    6844:	007e2801 	rsbseq	r2, lr, r1, lsl #16
    6848:	6a010000 	bvs	46850 <_etext+0x3f23c>
    684c:	07000002 	streq	r0, [r0, -r2]
    6850:	28010070 	stmdacs	r1, {r4, r5, r6}
    6854:	0000011b 	andeq	r0, r0, fp, lsl r1
    6858:	0100690a 	tsteq	r0, sl, lsl #18
    685c:	00007e2a 	andeq	r7, r0, sl, lsr #28
    6860:	00780a00 	rsbseq	r0, r8, r0, lsl #20
    6864:	008c2b01 	addeq	r2, ip, r1, lsl #22
    6868:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    686c:	000018ba 			; <UNDEFINED> instruction: 0x000018ba
    6870:	a6011801 	strge	r1, [r1], -r1, lsl #16
    6874:	07000002 	streq	r0, [r0, -r2]
    6878:	18010078 	stmdane	r1, {r3, r4, r5, r6}
    687c:	00000115 	andeq	r0, r0, r5, lsl r1
    6880:	01007007 	tsteq	r0, r7
    6884:	00011b18 	andeq	r1, r1, r8, lsl fp
    6888:	18290900 	stmdane	r9!, {r8, fp}
    688c:	1a010000 	bne	46894 <_etext+0x3f280>
    6890:	000002a6 	andeq	r0, r0, r6, lsr #5
    6894:	0100630a 	tsteq	r0, sl, lsl #6
    6898:	0000971b 	andeq	r9, r0, fp, lsl r7
    689c:	00690a00 	rsbeq	r0, r9, r0, lsl #20
    68a0:	007e1c01 	rsbseq	r1, lr, r1, lsl #24
    68a4:	14000000 	strne	r0, [r0], #-0
    68a8:	0000008c 	andeq	r0, r0, ip, lsl #1
    68ac:	000002b6 			; <UNDEFINED> instruction: 0x000002b6
    68b0:	0000b815 	andeq	fp, r0, r5, lsl r8
    68b4:	16001f00 	strne	r1, [r0], -r0, lsl #30
    68b8:	00001768 	andeq	r1, r0, r8, ror #14
    68bc:	2ee85b01 	vfmacs.f64	d21, d8, d1
    68c0:	01a00000 	moveq	r0, r0
    68c4:	9c010000 	stcls	0, cr0, [r1], {-0}
    68c8:	000004d7 	ldrdeq	r0, [r0], -r7
    68cc:	01006e17 	tsteq	r0, r7, lsl lr
    68d0:	0001155b 	andeq	r1, r1, fp, asr r5
    68d4:	003d5600 	eorseq	r5, sp, r0, lsl #12
    68d8:	00781700 	rsbseq	r1, r8, r0, lsl #14
    68dc:	011b5c01 	tsteq	fp, r1, lsl #24
    68e0:	3d950000 	ldccc	0, cr0, [r5]
    68e4:	6c170000 	ldcvs	0, cr0, [r7], {-0}
    68e8:	01006e65 	tsteq	r0, r5, ror #28
    68ec:	0000ad5c 	andeq	sl, r0, ip, asr sp
    68f0:	003dd400 	eorseq	sp, sp, r0, lsl #8
    68f4:	189b1800 	ldmne	fp, {fp, ip}
    68f8:	5d010000 	stcpl	0, cr0, [r1, #-0]
    68fc:	0000011b 	andeq	r0, r0, fp, lsl r1
    6900:	00003e18 	andeq	r3, r0, r8, lsl lr
    6904:	00190109 	andseq	r0, r9, r9, lsl #2
    6908:	d75f0100 	ldrble	r0, [pc, -r0, lsl #2]
    690c:	19000004 	stmdbne	r0, {r2}
    6910:	00001830 	andeq	r1, r0, r0, lsr r8
    6914:	04d76001 	ldrbeq	r6, [r7], #1
    6918:	3e5c0000 	cdpcc	0, 5, cr0, cr12, cr0, {0}
    691c:	3e190000 	cdpcc	0, 1, cr0, cr9, cr0, {0}
    6920:	01000018 	tsteq	r0, r8, lsl r0
    6924:	0004d761 	andeq	sp, r4, r1, ror #14
    6928:	003e7a00 	eorseq	r7, lr, r0, lsl #20
    692c:	18561900 	ldmdane	r6, {r8, fp, ip}^
    6930:	62010000 	andvs	r0, r1, #0
    6934:	000004d7 	ldrdeq	r0, [r0], -r7
    6938:	00003e98 	muleq	r0, r8, lr
    693c:	0100691a 	tsteq	r0, sl, lsl r9
    6940:	00007e63 	andeq	r7, r0, r3, ror #28
    6944:	003ec300 	eorseq	ip, lr, r0, lsl #6
    6948:	023e1b00 	eorseq	r1, lr, #0, 22
    694c:	2ef60000 	cdpcs	0, 15, cr0, cr6, cr0, {0}
    6950:	06c80000 	strbeq	r0, [r8], r0
    6954:	5f010000 	svcpl	0x00010000
    6958:	0000037d 	andeq	r0, r0, sp, ror r3
    695c:	00024e10 	andeq	r4, r2, r0, lsl lr
    6960:	003f3c00 	eorseq	r3, pc, r0, lsl #24
    6964:	06c81c00 	strbeq	r1, [r8], r0, lsl #24
    6968:	57110000 	ldrpl	r0, [r1, -r0]
    696c:	80000002 	andhi	r0, r0, r2
    6970:	1100003f 	tstne	r0, pc, lsr r0
    6974:	00000260 	andeq	r0, r0, r0, ror #4
    6978:	00003fde 	ldrdeq	r3, [r0], -lr
    697c:	261d0000 	ldrcs	r0, [sp], -r0
    6980:	18000001 	stmdane	r0, {r0}
    6984:	0800002f 	stmdaeq	r0, {r0, r1, r2, r3, r5}
    6988:	01000000 	mrseq	r0, (UNDEF: 0)
    698c:	0003a35f 	andeq	sl, r3, pc, asr r3
    6990:	013f1000 	teqeq	pc, r0
    6994:	401c0000 	andsmi	r0, ip, r0
    6998:	36100000 	ldrcc	r0, [r0], -r0
    699c:	6c000001 	stcvs	0, cr0, [r0], {1}
    69a0:	00000040 	andeq	r0, r0, r0, asr #32
    69a4:	0001491d 	andeq	r4, r1, sp, lsl r9
    69a8:	002fc800 	eoreq	ip, pc, r0, lsl #16
    69ac:	00001400 	andeq	r1, r0, r0, lsl #8
    69b0:	dd6b0100 	stflee	f0, [fp, #-0]
    69b4:	1e000003 	cdpne	0, 0, cr0, cr0, cr3, {0}
    69b8:	0000015e 	andeq	r0, r0, lr, asr r1
    69bc:	0001551e 	andeq	r5, r1, lr, lsl r5
    69c0:	2fc81f00 	svccs	0x00c81f00
    69c4:	00140000 	andseq	r0, r4, r0
    69c8:	67110000 	ldrvs	r0, [r1, -r0]
    69cc:	7f000001 	svcvc	0x00000001
    69d0:	11000040 	tstne	r0, r0, asr #32
    69d4:	00000170 	andeq	r0, r0, r0, ror r1
    69d8:	0000409d 	muleq	r0, sp, r0
    69dc:	fa200000 	blx	8069e4 <_etext+0x7ff3d0>
    69e0:	6200002f 	andvs	r0, r0, #47	; 0x2f
    69e4:	bb000000 	bllt	69ec <_svfiprintf_r+0x164>
    69e8:	1a000004 	bne	6a00 <_svfiprintf_r+0x178>
    69ec:	00746962 	rsbseq	r6, r4, r2, ror #18
    69f0:	01217001 	teqeq	r1, r1
    69f4:	40c80000 	sbcmi	r0, r8, r0
    69f8:	491b0000 	ldmdbmi	fp, {}	; <UNPREDICTABLE>
    69fc:	06000001 	streq	r0, [r0], -r1
    6a00:	e8000030 	stmda	r0, {r4, r5}
    6a04:	01000006 	tsteq	r0, r6
    6a08:	00043372 	andeq	r3, r4, r2, ror r3
    6a0c:	015e1000 	cmpeq	lr, r0
    6a10:	40db0000 	sbcsmi	r0, fp, r0
    6a14:	551e0000 	ldrpl	r0, [lr, #-0]
    6a18:	1c000001 	stcne	0, cr0, [r0], {1}
    6a1c:	000006e8 	andeq	r0, r0, r8, ror #13
    6a20:	00016711 	andeq	r6, r1, r1, lsl r7
    6a24:	0040ef00 	subeq	lr, r0, r0, lsl #30
    6a28:	01701100 	cmneq	r0, r0, lsl #2
    6a2c:	410e0000 	mrsmi	r0, (UNDEF: 14)
    6a30:	00000000 	andeq	r0, r0, r0
    6a34:	00026a21 	andeq	r6, r2, r1, lsr #20
    6a38:	00302200 	eorseq	r2, r0, r0, lsl #4
    6a3c:	00070000 	andeq	r0, r7, r0
    6a40:	1e740100 	rpwnes	f0, f4, f0
    6a44:	0000027f 	andeq	r0, r0, pc, ror r2
    6a48:	00027610 	andeq	r7, r2, r0, lsl r6
    6a4c:	00414500 	subeq	r4, r1, r0, lsl #10
    6a50:	07001c00 	streq	r1, [r0, -r0, lsl #24]
    6a54:	88220000 	stmdahi	r2!, {}	; <UNPREDICTABLE>
    6a58:	03000002 	movweq	r0, #2
    6a5c:	117fb891 			; <UNDEFINED> instruction: 0x117fb891
    6a60:	00000293 	muleq	r0, r3, r2
    6a64:	00004158 	andeq	r4, r0, r8, asr r1
    6a68:	00029c11 	andeq	r9, r2, r1, lsl ip
    6a6c:	00419000 	subeq	r9, r1, r0
    6a70:	00c82300 	sbceq	r2, r8, r0, lsl #6
    6a74:	30420000 	subcc	r0, r2, r0
    6a78:	001a0000 	andseq	r0, sl, r0
    6a7c:	24010000 	strcs	r0, [r1], #-0
    6a80:	0000f510 	andeq	pc, r0, r0, lsl r5	; <UNPREDICTABLE>
    6a84:	0041c700 	subeq	ip, r1, r0, lsl #14
    6a88:	00ea1e00 	rsceq	r1, sl, r0, lsl #28
    6a8c:	df100000 	svcle	0x00100000
    6a90:	e8000000 	stmda	r0, {}	; <UNPREDICTABLE>
    6a94:	1e000041 	cdpne	0, 0, cr0, cr0, cr1, {2}
    6a98:	000000d4 	ldrdeq	r0, [r0], -r4
    6a9c:	0030421f 	eorseq	r4, r0, pc, lsl r2
    6aa0:	00001a00 	andeq	r1, r0, r0, lsl #20
    6aa4:	01001100 	mrseq	r1, (UNDEF: 16)
    6aa8:	41fb0000 	mvnsmi	r0, r0
    6aac:	0b110000 	bleq	446ab4 <_etext+0x43f4a0>
    6ab0:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    6ab4:	00000042 	andeq	r0, r0, r2, asr #32
    6ab8:	00000000 	andeq	r0, r0, r0
    6abc:	002f2e24 	eoreq	r2, pc, r4, lsr #28
    6ac0:	000d5a00 	andeq	r5, sp, r0, lsl #20
    6ac4:	52011300 	andpl	r1, r1, #0, 6
    6ac8:	13200802 	teqne	r0, #131072	; 0x20000
    6acc:	30015101 	andcc	r5, r1, r1, lsl #2
    6ad0:	02500113 	subseq	r0, r0, #-1073741820	; 0xc0000004
    6ad4:	00000074 	andeq	r0, r0, r4, ror r0
    6ad8:	00007e0c 	andeq	r7, r0, ip, lsl #28
    6adc:	190f1600 	stmdbne	pc, {r9, sl, ip}	; <UNPREDICTABLE>
    6ae0:	78010000 	stmdavc	r1, {}	; <UNPREDICTABLE>
    6ae4:	00000000 	andeq	r0, r0, r0
    6ae8:	0000002c 	andeq	r0, r0, ip, lsr #32
    6aec:	05619c01 	strbeq	r9, [r1, #-3073]!	; 0xc01
    6af0:	78170000 	ldmdavc	r7, {}	; <UNPREDICTABLE>
    6af4:	15780100 	ldrbne	r0, [r8, #-256]!	; 0x100
    6af8:	2d000001 	stccs	0, cr0, [r0, #-4]
    6afc:	18000042 	stmdane	r0, {r1, r6}
    6b00:	0000189b 	muleq	r0, fp, r8
    6b04:	011b7801 	tsteq	fp, r1, lsl #16
    6b08:	42560000 	subsmi	r0, r6, #0
    6b0c:	6e250000 	cdpvs	0, 2, cr0, cr5, cr0, {0}
    6b10:	a67a0100 	ldrbtge	r0, [sl], -r0, lsl #2
    6b14:	02000002 	andeq	r0, r0, #2
    6b18:	7a1d5091 	bvc	75ad64 <_etext+0x753750>
    6b1c:	00000001 	andeq	r0, r0, r1
    6b20:	16000000 	strne	r0, [r0], -r0
    6b24:	01000000 	mrseq	r0, (UNDEF: 0)
    6b28:	00053d7d 	andeq	r3, r5, sp, ror sp
    6b2c:	018f1000 	orreq	r1, pc, r0
    6b30:	42820000 	addmi	r0, r2, #0
    6b34:	86260000 	strthi	r0, [r6], -r0
    6b38:	01000001 	tsteq	r0, r1
    6b3c:	00240055 	eoreq	r0, r4, r5, asr r0
    6b40:	b6000000 	strlt	r0, [r0], -r0
    6b44:	13000002 	movwne	r0, #2
    6b48:	f3035301 	vcgt.u8	d5, d3, d1
    6b4c:	01135101 	tsteq	r3, r1, lsl #2
    6b50:	20080252 	andcs	r0, r8, r2, asr r2
    6b54:	02510113 	subseq	r0, r1, #-1073741820	; 0xc0000004
    6b58:	01130075 	tsteq	r3, r5, ror r0
    6b5c:	007d0250 	rsbseq	r0, sp, r0, asr r2
    6b60:	d0270000 	eorle	r0, r7, r0
    6b64:	01000018 	tsteq	r0, r8, lsl r0
    6b68:	00008c80 	andeq	r8, r0, r0, lsl #25
    6b6c:	00000000 	andeq	r0, r0, r0
    6b70:	00009a00 	andeq	r9, r0, r0, lsl #20
    6b74:	b19c0100 	orrslt	r0, ip, r0, lsl #2
    6b78:	17000005 	strne	r0, [r0, -r5]
    6b7c:	80010078 	andhi	r0, r1, r8, ror r0
    6b80:	0000011b 	andeq	r0, r0, fp, lsl r1
    6b84:	000042a2 	andeq	r4, r0, r2, lsr #5
    6b88:	01007917 	tsteq	r0, r7, lsl r9
    6b8c:	00011b80 	andeq	r1, r1, r0, lsl #23
    6b90:	0042ce00 	subeq	ip, r2, r0, lsl #28
    6b94:	75731a00 	ldrbvc	r1, [r3, #-2560]!	; 0xa00
    6b98:	8201006d 	andhi	r0, r1, #109	; 0x6d
    6b9c:	0000008c 	andeq	r0, r0, ip, lsl #1
    6ba0:	000042fa 	strdeq	r4, [r0], -sl
    6ba4:	0100691a 	tsteq	r0, sl, lsl r9
    6ba8:	00007e83 	andeq	r7, r0, r3, lsl #29
    6bac:	00434200 	subeq	r4, r3, r0, lsl #4
    6bb0:	c80f0000 	stmdagt	pc, {}	; <UNPREDICTABLE>
    6bb4:	00000000 	andeq	r0, r0, r0
    6bb8:	c2000000 	andgt	r0, r0, #0
    6bbc:	01000000 	mrseq	r0, (UNDEF: 0)
    6bc0:	0005f99c 	muleq	r5, ip, r9
    6bc4:	00d42600 	sbcseq	r2, r4, r0, lsl #12
    6bc8:	50010000 	andpl	r0, r1, r0
    6bcc:	0000df10 	andeq	sp, r0, r0, lsl pc
    6bd0:	00438500 	subeq	r8, r3, r0, lsl #10
    6bd4:	00ea1000 	rsceq	r1, sl, r0
    6bd8:	43b10000 			; <UNDEFINED> instruction: 0x43b10000
    6bdc:	f5100000 			; <UNDEFINED> instruction: 0xf5100000
    6be0:	dd000000 	stcle	0, cr0, [r0, #-0]
    6be4:	11000043 	tstne	r0, r3, asr #32
    6be8:	00000100 	andeq	r0, r0, r0, lsl #2
    6bec:	000043fe 	strdeq	r4, [r0], -lr
    6bf0:	00010b11 	andeq	r0, r1, r1, lsl fp
    6bf4:	00442700 	subeq	r2, r4, r0, lsl #14
    6bf8:	88060000 	stmdahi	r6, {}	; <UNPREDICTABLE>
    6bfc:	01000018 	tsteq	r0, r8, lsl r0
    6c00:	0623019a 			; <UNDEFINED> instruction: 0x0623019a
    6c04:	72070000 	andvc	r0, r7, #0
    6c08:	159a0100 	ldrne	r0, [sl, #256]	; 0x100
    6c0c:	07000001 	streq	r0, [r0, -r1]
    6c10:	9a010061 	bls	46d9c <_etext+0x3f788>
    6c14:	0000011b 	andeq	r0, r0, fp, lsl r1
    6c18:	00189b08 	andseq	r9, r8, r8, lsl #22
    6c1c:	1b9a0100 	blne	fe687024 <BootRAM+0xd5f77c5>
    6c20:	00000001 	andeq	r0, r0, r1
    6c24:	0005f90f 	andeq	pc, r5, pc, lsl #18
    6c28:	00000000 	andeq	r0, r0, r0
    6c2c:	00005800 	andeq	r5, r0, r0, lsl #16
    6c30:	149c0100 	ldrne	r0, [ip], #256	; 0x100
    6c34:	26000007 	strcs	r0, [r0], -r7
    6c38:	00000605 	andeq	r0, r0, r5, lsl #12
    6c3c:	0e105001 	cdpeq	0, 1, cr5, cr0, cr1, {0}
    6c40:	52000006 	andpl	r0, r0, #6
    6c44:	10000044 	andne	r0, r0, r4, asr #32
    6c48:	00000617 	andeq	r0, r0, r7, lsl r6
    6c4c:	00004473 	andeq	r4, r0, r3, ror r4
    6c50:	0001991b 	andeq	r9, r1, fp, lsl r9
    6c54:	00000000 	andeq	r0, r0, r0
    6c58:	00071800 	andeq	r1, r7, r0, lsl #16
    6c5c:	8b9c0100 	blhi	fe707064 <BootRAM+0xd677805>
    6c60:	10000006 	andne	r0, r0, r6
    6c64:	000001ae 	andeq	r0, r0, lr, lsr #3
    6c68:	00004494 	muleq	r0, r4, r4
    6c6c:	0001a526 	andeq	sl, r1, r6, lsr #10
    6c70:	1c500100 	ldfnee	f0, [r0], {-0}
    6c74:	00000718 	andeq	r0, r0, r8, lsl r7
    6c78:	0001b711 	andeq	fp, r1, r1, lsl r7
    6c7c:	0044b500 	subeq	fp, r4, r0, lsl #10
    6c80:	01c01100 	biceq	r1, r0, r0, lsl #2
    6c84:	44d40000 	ldrbmi	r0, [r4], #0
    6c88:	00000000 	andeq	r0, r0, r0
    6c8c:	00026a23 	andeq	r6, r2, r3, lsr #20
    6c90:	00000000 	andeq	r0, r0, r0
    6c94:	00003200 	andeq	r3, r0, r0, lsl #4
    6c98:	1e9d0100 	fmlnee	f0, f5, f0
    6c9c:	0000027f 	andeq	r0, r0, pc, ror r2
    6ca0:	0002761e 	andeq	r7, r2, lr, lsl r6
    6ca4:	00001f00 	andeq	r1, r0, r0, lsl #30
    6ca8:	00320000 	eorseq	r0, r2, r0
    6cac:	88220000 	stmdahi	r2!, {}	; <UNPREDICTABLE>
    6cb0:	02000002 	andeq	r0, r0, #2
    6cb4:	93115091 	tstls	r1, #145	; 0x91
    6cb8:	0b000002 	bleq	6cc8 <_printf_i+0x184>
    6cbc:	11000045 	tstne	r0, r5, asr #32
    6cc0:	0000029c 	muleq	r0, ip, r2
    6cc4:	00004537 	andeq	r4, r0, r7, lsr r5
    6cc8:	0000c823 	andeq	ip, r0, r3, lsr #16
    6ccc:	00000000 	andeq	r0, r0, r0
    6cd0:	00001a00 	andeq	r1, r0, r0, lsl #20
    6cd4:	10240100 	eorne	r0, r4, r0, lsl #2
    6cd8:	000000f5 	strdeq	r0, [r0], -r5
    6cdc:	00004562 	andeq	r4, r0, r2, ror #10
    6ce0:	0000ea26 	andeq	lr, r0, r6, lsr #20
    6ce4:	10500100 	subsne	r0, r0, r0, lsl #2
    6ce8:	000000df 	ldrdeq	r0, [r0], -pc	; <UNPREDICTABLE>
    6cec:	00004583 	andeq	r4, r0, r3, lsl #11
    6cf0:	0000d426 	andeq	sp, r0, r6, lsr #8
    6cf4:	1f500100 	svcne	0x00500100
    6cf8:	00000000 	andeq	r0, r0, r0
    6cfc:	0000001a 	andeq	r0, r0, sl, lsl r0
    6d00:	00010022 	andeq	r0, r1, r2, lsr #32
    6d04:	11510100 	cmpne	r1, r0, lsl #2
    6d08:	0000010b 	andeq	r0, r0, fp, lsl #2
    6d0c:	000045b0 			; <UNDEFINED> instruction: 0x000045b0
    6d10:	00000000 	andeq	r0, r0, r0
    6d14:	187d1600 	ldmdane	sp!, {r9, sl, ip}^
    6d18:	a0010000 	andge	r0, r1, r0
    6d1c:	00000000 	andeq	r0, r0, r0
    6d20:	0000008e 	andeq	r0, r0, lr, lsl #1
    6d24:	08a99c01 	stmiaeq	r9!, {r0, sl, fp, ip, pc}
    6d28:	72280000 	eorvc	r0, r8, #0
    6d2c:	15a00100 	strne	r0, [r0, #256]!	; 0x100
    6d30:	01000001 	tsteq	r0, r1
    6d34:	00611750 	rsbeq	r1, r1, r0, asr r7
    6d38:	011ba001 	tsteq	fp, r1
    6d3c:	45cf0000 	strbmi	r0, [pc]	; 6d44 <_printf_i+0x200>
    6d40:	9b180000 	blls	606d48 <_etext+0x5ff734>
    6d44:	01000018 	tsteq	r0, r8, lsl r0
    6d48:	00011ba0 	andeq	r1, r1, r0, lsr #23
    6d4c:	0045f000 	subeq	pc, r5, r0
    6d50:	01991b00 	orrseq	r1, r9, r0, lsl #22
    6d54:	00000000 	andeq	r0, r0, r0
    6d58:	07300000 	ldreq	r0, [r0, -r0]!
    6d5c:	a2010000 	andge	r0, r1, #0
    6d60:	0000078c 	andeq	r0, r0, ip, lsl #15
    6d64:	0001ae10 	andeq	sl, r1, r0, lsl lr
    6d68:	00461100 	subeq	r1, r6, r0, lsl #2
    6d6c:	01a52600 			; <UNDEFINED> instruction: 0x01a52600
    6d70:	50010000 	andpl	r0, r1, r0
    6d74:	0007301c 	andeq	r3, r7, ip, lsl r0
    6d78:	01b71100 			; <UNDEFINED> instruction: 0x01b71100
    6d7c:	46320000 	ldrtmi	r0, [r2], -r0
    6d80:	c0110000 	andsgt	r0, r1, r0
    6d84:	51000001 	tstpl	r0, r1
    6d88:	00000046 	andeq	r0, r0, r6, asr #32
    6d8c:	026a1d00 	rsbeq	r1, sl, #0, 26
    6d90:	00000000 	andeq	r0, r0, r0
    6d94:	00320000 	eorseq	r0, r2, r0
    6d98:	a3010000 	movwge	r0, #4096	; 0x1000
    6d9c:	0000081a 	andeq	r0, r0, sl, lsl r8
    6da0:	00027f1e 	andeq	r7, r2, lr, lsl pc
    6da4:	02761e00 	rsbseq	r1, r6, #0, 28
    6da8:	001f0000 	andseq	r0, pc, r0
    6dac:	32000000 	andcc	r0, r0, #0
    6db0:	22000000 	andcs	r0, r0, #0
    6db4:	00000288 	andeq	r0, r0, r8, lsl #5
    6db8:	11509102 	cmpne	r0, r2, lsl #2
    6dbc:	00000293 	muleq	r0, r3, r2
    6dc0:	00004688 	andeq	r4, r0, r8, lsl #13
    6dc4:	00029c11 	andeq	r9, r2, r1, lsl ip
    6dc8:	0046b400 	subeq	fp, r6, r0, lsl #8
    6dcc:	00c82300 	sbceq	r2, r8, r0, lsl #6
    6dd0:	00000000 	andeq	r0, r0, r0
    6dd4:	001a0000 	andseq	r0, sl, r0
    6dd8:	24010000 	strcs	r0, [r1], #-0
    6ddc:	0000f510 	andeq	pc, r0, r0, lsl r5	; <UNPREDICTABLE>
    6de0:	0046df00 	subeq	sp, r6, r0, lsl #30
    6de4:	00ea2600 	rsceq	r2, sl, r0, lsl #12
    6de8:	50010000 	andpl	r0, r1, r0
    6dec:	0000df10 	andeq	sp, r0, r0, lsl pc
    6df0:	00470000 	subeq	r0, r7, r0
    6df4:	00d42600 	sbcseq	r2, r4, r0, lsl #12
    6df8:	50010000 	andpl	r0, r1, r0
    6dfc:	0000001f 	andeq	r0, r0, pc, lsl r0
    6e00:	00001a00 	andeq	r1, r0, r0, lsl #20
    6e04:	01001100 	mrseq	r1, (UNDEF: 16)
    6e08:	472d0000 	strmi	r0, [sp, -r0]!
    6e0c:	0b110000 	bleq	446e14 <_etext+0x43f800>
    6e10:	40000001 	andmi	r0, r0, r1
    6e14:	00000047 	andeq	r0, r0, r7, asr #32
    6e18:	23000000 	movwcs	r0, #0
    6e1c:	0000026a 	andeq	r0, r0, sl, ror #4
    6e20:	00000000 	andeq	r0, r0, r0
    6e24:	00000036 	andeq	r0, r0, r6, lsr r0
    6e28:	7f10a401 	svcvc	0x0010a401
    6e2c:	5f000002 	svcpl	0x00000002
    6e30:	26000047 	strcs	r0, [r0], -r7, asr #32
    6e34:	00000276 	andeq	r0, r0, r6, ror r2
    6e38:	001f5001 	andseq	r5, pc, r1
    6e3c:	36000000 	strcc	r0, [r0], -r0
    6e40:	22000000 	andcs	r0, r0, #0
    6e44:	00000288 	andeq	r0, r0, r8, lsl #5
    6e48:	11509102 	cmpne	r0, r2, lsl #2
    6e4c:	00000293 	muleq	r0, r3, r2
    6e50:	00004780 	andeq	r4, r0, r0, lsl #15
    6e54:	00029c11 	andeq	r9, r2, r1, lsl ip
    6e58:	0047b800 	subeq	fp, r7, r0, lsl #16
    6e5c:	00c82300 	sbceq	r2, r8, r0, lsl #6
    6e60:	00000000 	andeq	r0, r0, r0
    6e64:	001a0000 	andseq	r0, sl, r0
    6e68:	24010000 	strcs	r0, [r1], #-0
    6e6c:	0000f510 	andeq	pc, r0, r0, lsl r5	; <UNPREDICTABLE>
    6e70:	0047ef00 	subeq	lr, r7, r0, lsl #30
    6e74:	00ea2600 	rsceq	r2, sl, r0, lsl #12
    6e78:	50010000 	andpl	r0, r1, r0
    6e7c:	0000df10 	andeq	sp, r0, r0, lsl pc
    6e80:	00481000 	subeq	r1, r8, r0
    6e84:	00d42600 	sbcseq	r2, r4, r0, lsl #12
    6e88:	50010000 	andpl	r0, r1, r0
    6e8c:	0000001f 	andeq	r0, r0, pc, lsl r0
    6e90:	00001a00 	andeq	r1, r0, r0, lsl #20
    6e94:	01002200 	mrseq	r2, R8_usr
    6e98:	51010000 	mrspl	r0, (UNDEF: 1)
    6e9c:	00010b11 	andeq	r0, r1, r1, lsl fp
    6ea0:	00483d00 	subeq	r3, r8, r0, lsl #26
    6ea4:	00000000 	andeq	r0, r0, r0
    6ea8:	a3160000 	tstge	r6, #0
    6eac:	01000018 	tsteq	r0, r8, lsl r0
    6eb0:	000000a7 	andeq	r0, r0, r7, lsr #1
    6eb4:	00013e00 	andeq	r3, r1, r0, lsl #28
    6eb8:	9b9c0100 	blls	fe7072c0 <BootRAM+0xd677a61>
    6ebc:	1700000b 	strne	r0, [r0, -fp]
    6ec0:	a7010072 	smlsdxge	r1, r2, r0, r0
    6ec4:	00000115 	andeq	r0, r0, r5, lsl r1
    6ec8:	0000485c 	andeq	r4, r0, ip, asr r8
    6ecc:	01006117 	tsteq	r0, r7, lsl r1
    6ed0:	00011ba7 	andeq	r1, r1, r7, lsr #23
    6ed4:	00487a00 	subeq	r7, r8, r0, lsl #20
    6ed8:	00621700 	rsbeq	r1, r2, r0, lsl #14
    6edc:	011ba701 	tsteq	fp, r1, lsl #14
    6ee0:	48980000 	ldmmi	r8, {}	; <UNPREDICTABLE>
    6ee4:	9b180000 	blls	606eec <_etext+0x5ff8d8>
    6ee8:	01000018 	tsteq	r0, r8, lsl r0
    6eec:	00011ba8 	andeq	r1, r1, r8, lsr #23
    6ef0:	0048b600 	subeq	fp, r8, r0, lsl #12
    6ef4:	00691a00 	rsbeq	r1, r9, r0, lsl #20
    6ef8:	007eaa01 	rsbseq	sl, lr, r1, lsl #20
    6efc:	48d40000 	ldmmi	r4, {}^	; <UNPREDICTABLE>
    6f00:	3e1b0000 	cdpcc	0, 1, cr0, cr11, cr0, {0}
    6f04:	00000002 	andeq	r0, r0, r2
    6f08:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
    6f0c:	01000007 	tsteq	r0, r7
    6f10:	000934ae 	andeq	r3, r9, lr, lsr #9
    6f14:	024e2600 	subeq	r2, lr, #0, 12
    6f18:	57010000 	strpl	r0, [r1, -r0]
    6f1c:	0007481c 	andeq	r4, r7, ip, lsl r8
    6f20:	02571100 	subseq	r1, r7, #0, 2
    6f24:	49010000 	stmdbmi	r1, {}	; <UNPREDICTABLE>
    6f28:	60110000 	andsvs	r0, r1, r0
    6f2c:	52000002 	andpl	r0, r0, #2
    6f30:	00000049 	andeq	r0, r0, r9, asr #32
    6f34:	00002000 	andeq	r2, r0, r0
    6f38:	00ea0000 	rsceq	r0, sl, r0
    6f3c:	0b7f0000 	bleq	1fc6f44 <_etext+0x1fbf930>
    6f40:	621a0000 	andsvs	r0, sl, #0
    6f44:	01007469 	tsteq	r0, r9, ror #8
    6f48:	000121af 	andeq	r2, r1, pc, lsr #3
    6f4c:	00498400 	subeq	r8, r9, r0, lsl #8
    6f50:	185c2900 	ldmdane	ip, {r8, fp, sp}^
    6f54:	b0010000 	andlt	r0, r1, r0
    6f58:	000002a6 	andeq	r0, r0, r6, lsr #5
    6f5c:	7f989103 	svcvc	0x00989103
    6f60:	0001491b 	andeq	r4, r1, fp, lsl r9
    6f64:	00000000 	andeq	r0, r0, r0
    6f68:	00076000 	andeq	r6, r7, r0
    6f6c:	99b20100 	ldmibls	r2!, {r8}
    6f70:	10000009 	andne	r0, r0, r9
    6f74:	0000015e 	andeq	r0, r0, lr, asr r1
    6f78:	000049a5 	andeq	r4, r0, r5, lsr #19
    6f7c:	0001551e 	andeq	r5, r1, lr, lsl r5
    6f80:	07601c00 	strbeq	r1, [r0, -r0, lsl #24]!
    6f84:	67110000 	ldrvs	r0, [r1, -r0]
    6f88:	b9000001 	stmdblt	r0, {r0}
    6f8c:	11000049 	tstne	r0, r9, asr #32
    6f90:	00000170 	andeq	r0, r0, r0, ror r1
    6f94:	000049d8 	ldrdeq	r4, [r0], -r8
    6f98:	6a1d0000 	bvs	746fa0 <_etext+0x73f98c>
    6f9c:	00000002 	andeq	r0, r0, r2
    6fa0:	2e000000 	cdpcs	0, 0, cr0, cr0, cr0, {0}
    6fa4:	01000000 	mrseq	r0, (UNDEF: 0)
    6fa8:	000a24b3 			; <UNDEFINED> instruction: 0x000a24b3
    6fac:	027f1e00 	rsbseq	r1, pc, #0, 28
    6fb0:	761e0000 	ldrvc	r0, [lr], -r0
    6fb4:	1f000002 	svcne	0x00000002
    6fb8:	00000000 	andeq	r0, r0, r0
    6fbc:	0000002e 	andeq	r0, r0, lr, lsr #32
    6fc0:	00028822 	andeq	r8, r2, r2, lsr #16
    6fc4:	b8910300 	ldmlt	r1, {r8, r9}
    6fc8:	0293117f 	addseq	r1, r3, #-1073741793	; 0xc000001f
    6fcc:	4a0f0000 	bmi	3c6fd4 <_etext+0x3bf9c0>
    6fd0:	9c110000 	ldcls	0, cr0, [r1], {-0}
    6fd4:	3b000002 	blcc	6fe4 <_sbrk+0x64>
    6fd8:	2300004a 	movwcs	r0, #74	; 0x4a
    6fdc:	000000c8 	andeq	r0, r0, r8, asr #1
    6fe0:	00000000 	andeq	r0, r0, r0
    6fe4:	00000018 	andeq	r0, r0, r8, lsl r0
    6fe8:	f5102401 			; <UNDEFINED> instruction: 0xf5102401
    6fec:	66000000 	strvs	r0, [r0], -r0
    6ff0:	1e00004a 	cdpne	0, 0, cr0, cr0, cr10, {2}
    6ff4:	000000ea 	andeq	r0, r0, sl, ror #1
    6ff8:	0000df10 	andeq	sp, r0, r0, lsl pc
    6ffc:	004a8700 	subeq	r8, sl, r0, lsl #14
    7000:	00d41e00 	sbcseq	r1, r4, r0, lsl #28
    7004:	001f0000 	andseq	r0, pc, r0
    7008:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
    700c:	11000000 	mrsne	r0, (UNDEF: 0)
    7010:	00000100 	andeq	r0, r0, r0, lsl #2
    7014:	00004a9a 	muleq	r0, sl, sl
    7018:	00010b11 	andeq	r0, r1, r1, lsl fp
    701c:	004aad00 	subeq	sl, sl, r0, lsl #26
    7020:	00000000 	andeq	r0, r0, r0
    7024:	017a1b00 	cmneq	sl, r0, lsl #22
    7028:	00000000 	andeq	r0, r0, r0
    702c:	07780000 	ldrbeq	r0, [r8, -r0]!
    7030:	b5010000 	strlt	r0, [r1, #-0]
    7034:	00000a4a 	andeq	r0, r0, sl, asr #20
    7038:	00018f10 	andeq	r8, r1, r0, lsl pc
    703c:	004acc00 	subeq	ip, sl, r0, lsl #24
    7040:	01861000 	orreq	r1, r6, r0
    7044:	4adf0000 	bmi	ff7c704c <BootRAM+0xe7377ed>
    7048:	1b000000 	blne	7050 <_sbrk+0xd0>
    704c:	000005f9 	strdeq	r0, [r0], -r9
    7050:	00000000 	andeq	r0, r0, r0
    7054:	00000790 	muleq	r0, r0, r7
    7058:	0b36b601 	bleq	db4864 <_etext+0xdad250>
    705c:	171e0000 	ldrne	r0, [lr, -r0]
    7060:	1e000006 	cdpne	0, 0, cr0, cr0, cr6, {0}
    7064:	0000060e 	andeq	r0, r0, lr, lsl #12
    7068:	00060510 	andeq	r0, r6, r0, lsl r5
    706c:	004af200 	subeq	pc, sl, r0, lsl #4
    7070:	01991b00 	orrseq	r1, r9, r0, lsl #22
    7074:	00000000 	andeq	r0, r0, r0
    7078:	07a80000 	streq	r0, [r8, r0]!
    707c:	9c010000 	stcls	0, cr0, [r1], {-0}
    7080:	00000aa6 	andeq	r0, r0, r6, lsr #21
    7084:	0001ae1e 	andeq	sl, r1, lr, lsl lr
    7088:	01a51e00 			; <UNDEFINED> instruction: 0x01a51e00
    708c:	a81c0000 	ldmdage	ip, {}	; <UNPREDICTABLE>
    7090:	11000007 	tstne	r0, r7
    7094:	000001b7 			; <UNDEFINED> instruction: 0x000001b7
    7098:	00004b05 	andeq	r4, r0, r5, lsl #22
    709c:	0001c011 	andeq	ip, r1, r1, lsl r0
    70a0:	004b3a00 	subeq	r3, fp, r0, lsl #20
    70a4:	23000000 	movwcs	r0, #0
    70a8:	0000026a 	andeq	r0, r0, sl, ror #4
    70ac:	00000000 	andeq	r0, r0, r0
    70b0:	00000034 	andeq	r0, r0, r4, lsr r0
    70b4:	7f1e9d01 	svcvc	0x001e9d01
    70b8:	1e000002 	cdpne	0, 0, cr0, cr0, cr2, {0}
    70bc:	00000276 	andeq	r0, r0, r6, ror r2
    70c0:	0000001f 	andeq	r0, r0, pc, lsl r0
    70c4:	00003400 	andeq	r3, r0, r0, lsl #8
    70c8:	02882200 	addeq	r2, r8, #0, 4
    70cc:	91030000 	mrsls	r0, (UNDEF: 3)
    70d0:	93117fb8 	tstls	r1, #184, 30	; 0x2e0
    70d4:	71000002 	tstvc	r0, r2
    70d8:	1100004b 	tstne	r0, fp, asr #32
    70dc:	0000029c 	muleq	r0, ip, r2
    70e0:	00004b9d 	muleq	r0, sp, fp
    70e4:	0000c823 	andeq	ip, r0, r3, lsr #16
    70e8:	00000000 	andeq	r0, r0, r0
    70ec:	00001c00 	andeq	r1, r0, r0, lsl #24
    70f0:	10240100 	eorne	r0, r4, r0, lsl #2
    70f4:	000000f5 	strdeq	r0, [r0], -r5
    70f8:	00004bc8 	andeq	r4, r0, r8, asr #23
    70fc:	0000ea10 	andeq	lr, r0, r0, lsl sl
    7100:	004be900 	subeq	lr, fp, r0, lsl #18
    7104:	00df1000 	sbcseq	r1, pc, r0
    7108:	4bfc0000 	blmi	fff07110 <BootRAM+0xee778b1>
    710c:	d4100000 	ldrle	r0, [r0], #-0
    7110:	e9000000 	stmdb	r0, {}	; <UNPREDICTABLE>
    7114:	1f00004b 	svcne	0x0000004b
    7118:	00000000 	andeq	r0, r0, r0
    711c:	0000001c 	andeq	r0, r0, ip, lsl r0
    7120:	00010011 	andeq	r0, r1, r1, lsl r0
    7124:	004c0f00 	subeq	r0, ip, r0, lsl #30
    7128:	010b1100 	mrseq	r1, (UNDEF: 27)
    712c:	4c220000 	stcmi	0, cr0, [r2], #-0
    7130:	00000000 	andeq	r0, r0, r0
    7134:	23000000 	movwcs	r0, #0
    7138:	000000c8 	andeq	r0, r0, r8, asr #1
    713c:	00000000 	andeq	r0, r0, r0
    7140:	00000020 	andeq	r0, r0, r0, lsr #32
    7144:	f510b801 			; <UNDEFINED> instruction: 0xf510b801
    7148:	41000000 	mrsmi	r0, (UNDEF: 0)
    714c:	1000004c 	andne	r0, r0, ip, asr #32
    7150:	000000ea 	andeq	r0, r0, sl, ror #1
    7154:	00004c62 	andeq	r4, r0, r2, ror #24
    7158:	0000df1e 	andeq	sp, r0, lr, lsl pc
    715c:	00d41e00 	sbcseq	r1, r4, r0, lsl #28
    7160:	001f0000 	andseq	r0, pc, r0
    7164:	20000000 	andcs	r0, r0, r0
    7168:	11000000 	mrsne	r0, (UNDEF: 0)
    716c:	00000100 	andeq	r0, r0, r0, lsl #2
    7170:	00004c75 	andeq	r4, r0, r5, ror ip
    7174:	00010b11 	andeq	r0, r1, r1, lsl fp
    7178:	004c8800 	subeq	r8, ip, r0, lsl #16
    717c:	00000000 	andeq	r0, r0, r0
    7180:	00000024 	andeq	r0, r0, r4, lsr #32
    7184:	000d5a00 	andeq	r5, sp, r0, lsl #20
    7188:	52011300 	andpl	r1, r1, #0, 6
    718c:	13200802 	teqne	r0, #131072	; 0x20000
    7190:	30015101 	andcc	r5, r1, r1, lsl #2
    7194:	02500113 	subseq	r0, r0, #-1073741820	; 0xc0000004
    7198:	00000075 	andeq	r0, r0, r5, ror r0
    719c:	00184b16 	andseq	r4, r8, r6, lsl fp
    71a0:	00bc0100 	adcseq	r0, ip, r0, lsl #2
    71a4:	d2000000 	andle	r0, r0, #0
    71a8:	01000000 	mrseq	r0, (UNDEF: 0)
    71ac:	000d2e9c 	muleq	sp, ip, lr
    71b0:	00721700 	rsbseq	r1, r2, r0, lsl #14
    71b4:	0115bc01 	tsteq	r5, r1, lsl #24
    71b8:	4ca70000 	stcmi	0, cr0, [r7]
    71bc:	61170000 	tstvs	r7, r0
    71c0:	1bbc0100 	blne	fef075c8 <BootRAM+0xde77d69>
    71c4:	c5000001 	strgt	r0, [r0, #-1]
    71c8:	1800004c 	stmdane	r0, {r2, r3, r6}
    71cc:	0000189b 	muleq	r0, fp, r8
    71d0:	011bbc01 	tsteq	fp, r1, lsl #24
    71d4:	4ce30000 	stclmi	0, cr0, [r3]
    71d8:	70250000 	eorvc	r0, r5, r0
    71dc:	0100326d 	tsteq	r0, sp, ror #4
    71e0:	0002a6be 			; <UNDEFINED> instruction: 0x0002a6be
    71e4:	a8910300 	ldmge	r1, {r8, r9}
    71e8:	00631a7f 	rsbeq	r1, r3, pc, ror sl
    71ec:	0097bf01 	addseq	fp, r7, r1, lsl #30
    71f0:	4d010000 	stcmi	0, cr0, [r1, #-0]
    71f4:	691a0000 	ldmdbvs	sl, {}	; <UNPREDICTABLE>
    71f8:	7ec00100 	polvcs	f0, f0, f0
    71fc:	36000000 	strcc	r0, [r0], -r0
    7200:	1b00004d 	blne	733c <round_k+0x7c>
    7204:	0000017a 	andeq	r0, r0, sl, ror r1
    7208:	00000000 	andeq	r0, r0, r0
    720c:	000007c0 	andeq	r0, r0, r0, asr #15
    7210:	0c28c301 	stceq	3, cr12, [r8], #-4
    7214:	8f100000 	svchi	0x00100000
    7218:	b5000001 	strlt	r0, [r0, #-1]
    721c:	1000004d 	andne	r0, r0, sp, asr #32
    7220:	00000186 	andeq	r0, r0, r6, lsl #3
    7224:	00004dd3 	ldrdeq	r4, [r0], -r3
    7228:	01ca1d00 	biceq	r1, sl, r0, lsl #26
    722c:	00000000 	andeq	r0, r0, r0
    7230:	00180000 	andseq	r0, r8, r0
    7234:	cb010000 	blgt	4723c <_etext+0x3fc28>
    7238:	00000c5d 	andeq	r0, r0, sp, asr ip
    723c:	0001df10 	andeq	sp, r1, r0, lsl pc
    7240:	004dff00 	subeq	pc, sp, r0, lsl #30
    7244:	01d61e00 	bicseq	r1, r6, r0, lsl #28
    7248:	001f0000 	andseq	r0, pc, r0
    724c:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
    7250:	11000000 	mrsne	r0, (UNDEF: 0)
    7254:	000001e8 	andeq	r0, r0, r8, ror #3
    7258:	00004e1f 	andeq	r4, r0, pc, lsl lr
    725c:	3e1b0000 	cdpcc	0, 1, cr0, cr11, cr0, {0}
    7260:	00000002 	andeq	r0, r0, r2
    7264:	e0000000 	and	r0, r0, r0
    7268:	01000007 	tsteq	r0, r7
    726c:	000c8ecd 	andeq	r8, ip, sp, asr #29
    7270:	024e1e00 	subeq	r1, lr, #0, 28
    7274:	e01c0000 	ands	r0, ip, r0
    7278:	11000007 	tstne	r0, r7
    727c:	00000257 	andeq	r0, r0, r7, asr r2
    7280:	00004e63 	andeq	r4, r0, r3, ror #28
    7284:	00026011 	andeq	r6, r2, r1, lsl r0
    7288:	004ec000 	subeq	ip, lr, r0
    728c:	2a000000 	bcs	7294 <sha512_initial_state+0x14>
    7290:	000007f8 	strdeq	r0, [r0], -r8
    7294:	00000d13 	andeq	r0, r0, r3, lsl sp
    7298:	00327225 	eorseq	r7, r2, r5, lsr #4
    729c:	02a6ce01 	adceq	ip, r6, #1, 28
    72a0:	91020000 	mrsls	r0, (UNDEF: 2)
    72a4:	017a1b48 	cmneq	sl, r8, asr #22
    72a8:	00000000 	andeq	r0, r0, r0
    72ac:	08180000 	ldmdaeq	r8, {}	; <UNPREDICTABLE>
    72b0:	d5010000 	strle	r0, [r1, #-0]
    72b4:	00000cca 	andeq	r0, r0, sl, asr #25
    72b8:	00018f10 	andeq	r8, r1, r0, lsl pc
    72bc:	004ef200 	subeq	pc, lr, r0, lsl #4
    72c0:	01861000 	orreq	r1, r6, r0
    72c4:	4f510000 	svcmi	0x00510000
    72c8:	2b000000 	blcs	72d0 <round_k+0x10>
    72cc:	00000000 	andeq	r0, r0, r0
    72d0:	000008a9 	andeq	r0, r0, r9, lsr #17
    72d4:	00000cf0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    72d8:	02530113 	subseq	r0, r3, #-1073741820	; 0xc0000004
    72dc:	01130077 	tsteq	r3, r7, ror r0
    72e0:	00760252 	rsbseq	r0, r6, r2, asr r2
    72e4:	02510113 	subseq	r0, r1, #-1073741820	; 0xc0000004
    72e8:	01130076 	tsteq	r3, r6, ror r0
    72ec:	48910250 	ldmmi	r1, {r4, r6, r9}
    72f0:	00002400 	andeq	r2, r0, r0, lsl #8
    72f4:	08a90000 	stmiaeq	r9!, {}	; <UNPREDICTABLE>
    72f8:	01130000 	tsteq	r3, r0
    72fc:	00770253 	rsbseq	r0, r7, r3, asr r2
    7300:	02520113 	subseq	r0, r2, #-1073741820	; 0xc0000004
    7304:	01130078 	tsteq	r3, r8, ror r0
    7308:	48910251 	ldmmi	r1, {r0, r4, r6, r9}
    730c:	02500113 	subseq	r0, r0, #-1073741820	; 0xc0000004
    7310:	00000076 	andeq	r0, r0, r6, ror r0
    7314:	00000024 	andeq	r0, r0, r4, lsr #32
    7318:	000d5a00 	andeq	r5, sp, r0, lsl #20
    731c:	52011300 	andpl	r1, r1, #0, 6
    7320:	01134c01 	tsteq	r3, r1, lsl #24
    7324:	13300151 	teqne	r0, #1073741844	; 0x40000014
    7328:	76025001 	strvc	r5, [r2], -r1
    732c:	2c000004 	stccs	0, cr0, [r0], {4}
    7330:	000018ae 	andeq	r1, r0, lr, lsr #17
    7334:	0d3f0901 	ldceq	9, cr0, [pc, #-4]!	; 7338 <round_k+0x78>
    7338:	03050000 	movweq	r0, #20480	; 0x5000
    733c:	00000000 	andeq	r0, r0, r0
    7340:	0002a60c 	andeq	sl, r2, ip, lsl #12
    7344:	19282c00 	stmdbne	r8!, {sl, fp, sp}
    7348:	0a010000 	beq	47350 <_etext+0x3fd3c>
    734c:	00000d55 	andeq	r0, r0, r5, asr sp
    7350:	00000305 	andeq	r0, r0, r5, lsl #6
    7354:	a60c0000 	strge	r0, [ip], -r0
    7358:	2d000002 	stccs	0, cr0, [r0, #-8]
    735c:	00000ff1 	strdeq	r0, [r0], -r1
    7360:	000000bf 	strheq	r0, [r0], -pc	; <UNPREDICTABLE>
    7364:	0000bf2e 	andeq	fp, r0, lr, lsr #30
    7368:	007e2e00 	rsbseq	r2, lr, r0, lsl #28
    736c:	b82e0000 	stmdalt	lr!, {}	; <UNPREDICTABLE>
    7370:	00000000 	andeq	r0, r0, r0
    7374:	00062600 	andeq	r2, r6, r0, lsl #12
    7378:	85000400 	strhi	r0, [r0, #-1024]	; 0x400
    737c:	04000019 	streq	r0, [r0], #-25
    7380:	0014a601 	andseq	sl, r4, r1, lsl #12
    7384:	19330100 	ldmdbne	r3!, {r8}
    7388:	08930000 	ldmeq	r3, {}	; <UNPREDICTABLE>
    738c:	08a00000 	stmiaeq	r0!, {}	; <UNPREDICTABLE>
    7390:	00000000 	andeq	r0, r0, r0
    7394:	22750000 	rsbscs	r0, r5, #0
    7398:	01020000 	mrseq	r0, (UNDEF: 2)
    739c:	00081a06 	andeq	r1, r8, r6, lsl #20
    73a0:	0ad90300 	beq	ff647fa8 <BootRAM+0xe5b8749>
    73a4:	1c020000 	stcne	0, cr0, [r2], {-0}
    73a8:	00000037 	andeq	r0, r0, r7, lsr r0
    73ac:	18080102 	stmdane	r8, {r1, r8}
    73b0:	02000008 	andeq	r0, r0, #8
    73b4:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
    73b8:	02020000 	andeq	r0, r2, #0
    73bc:	00094907 	andeq	r4, r9, r7, lsl #18
    73c0:	05040200 	streq	r0, [r4, #-512]	; 0x200
    73c4:	000004da 	ldrdeq	r0, [r0], -sl
    73c8:	52070402 	andpl	r0, r7, #33554432	; 0x2000000
    73cc:	02000002 	andeq	r0, r0, #2
    73d0:	04d50508 	ldrbeq	r0, [r5], #1288	; 0x508
    73d4:	08020000 	stmdaeq	r2, {}	; <UNPREDICTABLE>
    73d8:	00024d07 	andeq	r4, r2, r7, lsl #26
    73dc:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    73e0:	00746e69 	rsbseq	r6, r4, r9, ror #28
    73e4:	57070402 	strpl	r0, [r7, -r2, lsl #8]
    73e8:	03000002 	movweq	r0, #2
    73ec:	00000adb 	ldrdeq	r0, [r0], -fp
    73f0:	002c2a03 	eoreq	r2, ip, r3, lsl #20
    73f4:	04020000 	streq	r0, [r2], #-0
    73f8:	00078b07 	andeq	r8, r7, r7, lsl #22
    73fc:	08010200 	stmdaeq	r1, {r9}
    7400:	00000821 	andeq	r0, r0, r1, lsr #16
    7404:	00194c05 	andseq	r4, r9, r5, lsl #24
    7408:	000a0100 	andeq	r0, sl, r0, lsl #2
    740c:	40000000 	andmi	r0, r0, r0
    7410:	01000000 	mrseq	r0, (UNDEF: 0)
    7414:	0001689c 	muleq	r1, ip, r8
    7418:	19610600 	stmdbne	r1!, {r9, sl}^
    741c:	0a010000 	beq	47424 <_etext+0x3fe10>
    7420:	00000168 	andeq	r0, r0, r8, ror #2
    7424:	00004f6f 	andeq	r4, r0, pc, ror #30
    7428:	01007907 	tsteq	r0, r7, lsl #18
    742c:	00016e0a 	andeq	r6, r1, sl, lsl #28
    7430:	004f9b00 	subeq	r9, pc, r0, lsl #22
    7434:	19460800 	stmdbne	r6, {fp}^
    7438:	0c010000 	stceq	0, cr0, [r1], {-0}
    743c:	00000179 	andeq	r0, r0, r9, ror r1
    7440:	7fb09103 	svcvc	0x00b09103
    7444:	00198108 	andseq	r8, r9, r8, lsl #2
    7448:	790d0100 	stmdbvc	sp, {r8}
    744c:	02000001 	andeq	r0, r0, #1
    7450:	00095091 	muleq	r9, r1, r0
    7454:	4f000000 	svcmi	0x00000000
    7458:	fd000005 	stc2	0, cr0, [r0, #-20]	; 0xffffffec
    745c:	0a000000 	beq	7464 <round_k+0x1a4>
    7460:	75025201 	strvc	r5, [r2, #-513]	; 0x201
    7464:	51010a00 	tstpl	r1, r0, lsl #20
    7468:	0a007602 	beq	24c78 <_etext+0x1d664>
    746c:	7d025001 	stcvc	0, cr5, [r2, #-4]
    7470:	00090000 	andeq	r0, r9, r0
    7474:	6a000000 	bvs	747c <round_k+0x1bc>
    7478:	17000005 	strne	r0, [r0, -r5]
    747c:	0a000001 	beq	7488 <round_k+0x1c8>
    7480:	7d025101 	stfvcs	f5, [r2, #-4]
    7484:	50010a00 	andpl	r0, r1, r0, lsl #20
    7488:	00509102 	subseq	r9, r0, r2, lsl #2
    748c:	00000009 	andeq	r0, r0, r9
    7490:	00058000 	andeq	r8, r5, r0
    7494:	00013700 	andeq	r3, r1, r0, lsl #14
    7498:	52010a00 	andpl	r0, r1, #0, 20
    749c:	0a007502 	beq	248ac <_etext+0x1d298>
    74a0:	76025101 	strvc	r5, [r2], -r1, lsl #2
    74a4:	50010a00 	andpl	r0, r1, r0, lsl #20
    74a8:	00007d02 	andeq	r7, r0, r2, lsl #26
    74ac:	00000009 	andeq	r0, r0, r9
    74b0:	00059b00 	andeq	r9, r5, r0, lsl #22
    74b4:	00015700 	andeq	r5, r1, r0, lsl #14
    74b8:	52010a00 	andpl	r0, r1, #0, 20
    74bc:	0a509102 	beq	142b8cc <_etext+0x14242b8>
    74c0:	7d025101 	stfvcs	f5, [r2, #-4]
    74c4:	50010a00 	andpl	r0, r1, r0, lsl #20
    74c8:	00007402 	andeq	r7, r0, r2, lsl #8
    74cc:	0000000b 	andeq	r0, r0, fp
    74d0:	0005b600 	andeq	fp, r5, r0, lsl #12
    74d4:	50010a00 	andpl	r0, r1, r0, lsl #20
    74d8:	00007402 	andeq	r7, r0, r2, lsl #8
    74dc:	76040c00 	strvc	r0, [r4], -r0, lsl #24
    74e0:	0c000000 	stceq	0, cr0, [r0], {-0}
    74e4:	00017404 	andeq	r7, r1, r4, lsl #8
    74e8:	00760d00 	rsbseq	r0, r6, r0, lsl #26
    74ec:	760e0000 	strvc	r0, [lr], -r0
    74f0:	89000000 	stmdbhi	r0, {}	; <UNPREDICTABLE>
    74f4:	0f000001 	svceq	0x00000001
    74f8:	00000081 	andeq	r0, r0, r1, lsl #1
    74fc:	5b10001f 	blpl	407580 <_etext+0x3fff6c>
    7500:	01000019 	tsteq	r0, r9, lsl r0
    7504:	01bc0116 			; <UNDEFINED> instruction: 0x01bc0116
    7508:	65110000 	ldrvs	r0, [r1, #-0]
    750c:	16010079 			; <UNDEFINED> instruction: 0x16010079
    7510:	00000168 	andeq	r0, r0, r8, ror #2
    7514:	00786d11 	rsbseq	r6, r8, r1, lsl sp
    7518:	016e1601 	cmneq	lr, r1, lsl #12
    751c:	6e120000 	cdpvs	0, 1, cr0, cr2, cr0, {0}
    7520:	79180100 	ldmdbvc	r8, {r8}
    7524:	12000001 	andne	r0, r0, #1
    7528:	19010064 	stmdbne	r1, {r2, r5, r6}
    752c:	00000179 	andeq	r0, r0, r9, ror r1
    7530:	196c1300 	stmdbne	ip!, {r8, r9, ip}^
    7534:	21010000 	mrscs	r0, (UNDEF: 1)
    7538:	00000076 	andeq	r0, r0, r6, ror r0
    753c:	00022f01 	andeq	r2, r2, r1, lsl #30
    7540:	00781100 	rsbseq	r1, r8, r0, lsl #2
    7544:	01682101 	cmneq	r8, r1, lsl #2
    7548:	79110000 	ldmdbvc	r1, {}	; <UNPREDICTABLE>
    754c:	6e210100 	sufvss	f0, f1, f0
    7550:	14000001 	strne	r0, [r0], #-1
    7554:	000015d8 	ldrdeq	r1, [r0], -r8
    7558:	00682101 	rsbeq	r2, r8, r1, lsl #2
    755c:	64150000 	ldrvs	r0, [r5], #-0
    7560:	2f230100 	svccs	0x00230100
    7564:	20000002 	andcs	r0, r0, r2
    7568:	135978a3 	cmpne	r9, #10682368	; 0xa30000
    756c:	75eb4dca 	strbvc	r4, [fp, #3530]!	; 0xdca
    7570:	4141d8ab 	smlaltbmi	sp, r1, fp, r8
    7574:	00700a4d 	rsbseq	r0, r0, sp, asr #20
    7578:	7779e898 			; <UNDEFINED> instruction: 0x7779e898
    757c:	8cc74079 	stclhi	0, cr4, [r7], {121}	; 0x79
    7580:	2b6ffe73 	blcs	1c06f54 <_etext+0x1bff940>
    7584:	52036cee 	andpl	r6, r3, #60928	; 0xee00
    7588:	01006112 	tsteq	r0, r2, lsl r1
    758c:	0001792a 	andeq	r7, r1, sl, lsr #18
    7590:	00621200 	rsbeq	r1, r2, r0, lsl #4
    7594:	01792b01 	cmneq	r9, r1, lsl #22
    7598:	63120000 	tstvs	r2, #0
    759c:	792c0100 	stmdbvc	ip!, {r8}
    75a0:	00000001 	andeq	r0, r0, r1
    75a4:	0001790d 	andeq	r7, r1, sp, lsl #18
    75a8:	19721600 	ldmdbne	r2!, {r9, sl, ip}^
    75ac:	4b010000 	blmi	475b4 <_etext+0x3ffa0>
    75b0:	00000076 	andeq	r0, r0, r6, ror r0
    75b4:	00000000 	andeq	r0, r0, r0
    75b8:	000000d4 	ldrdeq	r0, [r0], -r4
    75bc:	053f9c01 	ldreq	r9, [pc, #-3073]!	; 69c3 <_svfiprintf_r+0x13b>
    75c0:	65070000 	strvs	r0, [r7, #-0]
    75c4:	4b010078 	blmi	477ac <_etext+0x40198>
    75c8:	00000168 	andeq	r0, r0, r8, ror #2
    75cc:	00004fd2 	ldrdeq	r4, [r0], -r2
    75d0:	00796507 	rsbseq	r6, r9, r7, lsl #10
    75d4:	01684b01 	cmneq	r8, r1, lsl #22
    75d8:	4ffe0000 	svcmi	0x00fe0000
    75dc:	6d070000 	stcvs	0, cr0, [r7, #-0]
    75e0:	4c010078 	stcmi	0, cr0, [r1], {120}	; 0x78
    75e4:	0000016e 	andeq	r0, r0, lr, ror #2
    75e8:	0000502a 	andeq	r5, r0, sl, lsr #32
    75ec:	0015d806 	andseq	sp, r5, r6, lsl #16
    75f0:	684c0100 	stmdavs	ip, {r8}^
    75f4:	56000000 	strpl	r0, [r0], -r0
    75f8:	12000050 	andne	r0, r0, #80	; 0x50
    75fc:	01006b6f 	tsteq	r0, pc, ror #22
    7600:	0000764e 	andeq	r7, r0, lr, asr #12
    7604:	01891700 	orreq	r1, r9, r0, lsl #14
    7608:	00000000 	andeq	r0, r0, r0
    760c:	08800000 	stmeq	r0, {}	; <UNPREDICTABLE>
    7610:	50010000 	andpl	r0, r1, r0
    7614:	00000347 	andeq	r0, r0, r7, asr #6
    7618:	00019f18 	andeq	r9, r1, r8, lsl pc
    761c:	00508200 	subseq	r8, r0, r0, lsl #4
    7620:	01951800 	orrseq	r1, r5, r0, lsl #16
    7624:	50ae0000 	adcpl	r0, lr, r0
    7628:	80190000 	andshi	r0, r9, r0
    762c:	1a000008 	bne	7654 <_etext+0x40>
    7630:	000001a9 	andeq	r0, r0, r9, lsr #3
    7634:	7fa89103 	svcvc	0x00a89103
    7638:	0001b21a 	andeq	fp, r1, sl, lsl r2
    763c:	48910200 	ldmmi	r1, {r9}
    7640:	00000009 	andeq	r0, r0, r9
    7644:	00058000 	andeq	r8, r5, r0
    7648:	0002ec00 	andeq	lr, r2, r0, lsl #24
    764c:	52010a00 	andpl	r0, r1, #0, 20
    7650:	0a007602 	beq	24e60 <_etext+0x1d84c>
    7654:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    7658:	50010a00 	andpl	r0, r1, r0, lsl #20
    765c:	7fa89103 	svcvc	0x00a89103
    7660:	00000900 	andeq	r0, r0, r0, lsl #18
    7664:	056a0000 	strbeq	r0, [sl, #-0]!
    7668:	03070000 	movweq	r0, #28672	; 0x7000
    766c:	010a0000 	mrseq	r0, (UNDEF: 10)
    7670:	a8910351 	ldmge	r1, {r0, r4, r6, r8, r9}
    7674:	50010a7f 	andpl	r0, r1, pc, ror sl
    7678:	00489102 	subeq	r9, r8, r2, lsl #2
    767c:	00000009 	andeq	r0, r0, r9
    7680:	00054f00 	andeq	r4, r5, r0, lsl #30
    7684:	00032800 	andeq	r2, r3, r0, lsl #16
    7688:	52010a00 	andpl	r0, r1, #0, 20
    768c:	0a007602 	beq	24e9c <_etext+0x1d888>
    7690:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    7694:	50010a00 	andpl	r0, r1, r0, lsl #20
    7698:	7fa89103 	svcvc	0x00a89103
    769c:	00000b00 	andeq	r0, r0, r0, lsl #22
    76a0:	059b0000 	ldreq	r0, [fp]
    76a4:	010a0000 	mrseq	r0, (UNDEF: 10)
    76a8:	48910252 	ldmmi	r1, {r1, r4, r6, r9}
    76ac:	0351010a 	cmpeq	r1, #-2147483646	; 0x80000002
    76b0:	0a7fa891 	beq	1ff18fc <_etext+0x1fea2e8>
    76b4:	74025001 	strvc	r5, [r2], #-1
    76b8:	00000000 	andeq	r0, r0, r0
    76bc:	0001bc1b 	andeq	fp, r1, fp, lsl ip
    76c0:	00000000 	andeq	r0, r0, r0
    76c4:	00008000 	andeq	r8, r0, r0
    76c8:	1a510100 	bne	1447ad0 <_etext+0x14404bc>
    76cc:	18000005 	stmdane	r0, {r0, r2}
    76d0:	000001de 	ldrdeq	r0, [r0], -lr
    76d4:	000050da 	ldrdeq	r5, [r0], -sl
    76d8:	0001d518 	andeq	sp, r1, r8, lsl r5
    76dc:	0050fb00 	subseq	pc, r0, r0, lsl #22
    76e0:	01cc1800 	biceq	r1, ip, r0, lsl #16
    76e4:	511c0000 	tstpl	ip, r0
    76e8:	001c0000 	andseq	r0, ip, r0
    76ec:	80000000 	andhi	r0, r0, r0
    76f0:	1a000000 	bne	76f8 <_etext+0xe4>
    76f4:	00000213 	andeq	r0, r0, r3, lsl r2
    76f8:	7f889103 	svcvc	0x00889103
    76fc:	00021c1a 	andeq	r1, r2, sl, lsl ip
    7700:	a8910300 	ldmge	r1, {r8, r9}
    7704:	02251a7f 	eoreq	r1, r5, #520192	; 0x7f000
    7708:	91020000 	mrsls	r0, (UNDEF: 2)
    770c:	01e91a48 	mvneq	r1, r8, asr #20
    7710:	03050000 	movweq	r0, #20480	; 0x5000
    7714:	00000000 	andeq	r0, r0, r0
    7718:	00000009 	andeq	r0, r0, r9
    771c:	00059b00 	andeq	r9, r5, r0, lsl #22
    7720:	0003c300 	andeq	ip, r3, r0, lsl #6
    7724:	52010a00 	andpl	r0, r1, #0, 20
    7728:	0a007402 	beq	24738 <_etext+0x1d124>
    772c:	74025101 	strvc	r5, [r2], #-257	; 0x101
    7730:	50010a00 	andpl	r0, r1, r0, lsl #20
    7734:	00489102 	subeq	r9, r8, r2, lsl #2
    7738:	00000009 	andeq	r0, r0, r9
    773c:	00059b00 	andeq	r9, r5, r0, lsl #22
    7740:	0003e700 	andeq	lr, r3, r0, lsl #14
    7744:	52010a00 	andpl	r0, r1, #0, 20
    7748:	00000305 	andeq	r0, r0, r5, lsl #6
    774c:	010a0000 	mrseq	r0, (UNDEF: 10)
    7750:	48910251 	ldmmi	r1, {r0, r4, r6, r9}
    7754:	0350010a 	cmpeq	r0, #-2147483646	; 0x80000002
    7758:	007fa891 			; <UNDEFINED> instruction: 0x007fa891
    775c:	00000009 	andeq	r0, r0, r9
    7760:	00058000 	andeq	r8, r5, r0
    7764:	00040800 	andeq	r0, r4, r0, lsl #16
    7768:	52010a00 	andpl	r0, r1, #0, 20
    776c:	0a007602 	beq	24f7c <_etext+0x1d968>
    7770:	91035101 	tstls	r3, r1, lsl #2
    7774:	010a7fa8 	smlatbeq	sl, r8, pc, r7	; <UNPREDICTABLE>
    7778:	007d0250 	rsbseq	r0, sp, r0, asr r2
    777c:	00000900 	andeq	r0, r0, r0, lsl #18
    7780:	056a0000 	strbeq	r0, [sl, #-0]!
    7784:	04230000 	strteq	r0, [r3], #-0
    7788:	010a0000 	mrseq	r0, (UNDEF: 10)
    778c:	007d0251 	rsbseq	r0, sp, r1, asr r2
    7790:	0350010a 	cmpeq	r0, #-2147483646	; 0x80000002
    7794:	007fa891 			; <UNDEFINED> instruction: 0x007fa891
    7798:	00000009 	andeq	r0, r0, r9
    779c:	00054f00 	andeq	r4, r5, r0, lsl #30
    77a0:	00044300 	andeq	r4, r4, r0, lsl #6
    77a4:	52010a00 	andpl	r0, r1, #0, 20
    77a8:	0a007602 	beq	24fb8 <_etext+0x1d9a4>
    77ac:	91025101 	tstls	r2, r1, lsl #2
    77b0:	50010a48 	andpl	r0, r1, r8, asr #20
    77b4:	00007d02 	andeq	r7, r0, r2, lsl #26
    77b8:	00000009 	andeq	r0, r0, r9
    77bc:	00059b00 	andeq	r9, r5, r0, lsl #22
    77c0:	00046400 	andeq	r6, r4, r0, lsl #8
    77c4:	52010a00 	andpl	r0, r1, #0, 20
    77c8:	7fa89103 	svcvc	0x00a89103
    77cc:	0251010a 	subseq	r0, r1, #-2147483646	; 0x80000002
    77d0:	010a007d 	tsteq	sl, sp, ror r0
    77d4:	48910250 	ldmmi	r1, {r4, r6, r9}
    77d8:	00000900 	andeq	r0, r0, r0, lsl #18
    77dc:	05c70000 	strbeq	r0, [r7]
    77e0:	047e0000 	ldrbteq	r0, [lr], #-0
    77e4:	010a0000 	mrseq	r0, (UNDEF: 10)
    77e8:	48910251 	ldmmi	r1, {r0, r4, r6, r9}
    77ec:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    77f0:	0900007d 	stmdbeq	r0, {r0, r2, r3, r4, r5, r6}
    77f4:	00000000 	andeq	r0, r0, r0
    77f8:	000005dd 	ldrdeq	r0, [r0], -sp
    77fc:	00000499 	muleq	r0, r9, r4
    7800:	0251010a 	subseq	r0, r1, #-2147483646	; 0x80000002
    7804:	010a007d 	tsteq	sl, sp, ror r0
    7808:	a8910350 	ldmge	r1, {r4, r6, r8, r9}
    780c:	0009007f 	andeq	r0, r9, pc, ror r0
    7810:	f3000000 	vhadd.u8	d0, d0, d0
    7814:	ba000005 	blt	7830 <_etext+0x21c>
    7818:	0a000004 	beq	7830 <_etext+0x21c>
    781c:	91035201 	tstls	r3, r1, lsl #4
    7820:	010a7fa8 	smlatbeq	sl, r8, pc, r7	; <UNPREDICTABLE>
    7824:	007d0251 	rsbseq	r0, sp, r1, asr r2
    7828:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    782c:	09000075 	stmdbeq	r0, {r0, r2, r4, r5, r6}
    7830:	00000000 	andeq	r0, r0, r0
    7834:	0000059b 	muleq	r0, fp, r5
    7838:	000004da 	ldrdeq	r0, [r0], -sl
    783c:	0252010a 	subseq	r0, r2, #-2147483646	; 0x80000002
    7840:	010a0075 	tsteq	sl, r5, ror r0
    7844:	00750251 	rsbseq	r0, r5, r1, asr r2
    7848:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    784c:	0900007d 	stmdbeq	r0, {r0, r2, r3, r4, r5, r6}
    7850:	00000000 	andeq	r0, r0, r0
    7854:	000005b6 			; <UNDEFINED> instruction: 0x000005b6
    7858:	000004ee 	andeq	r0, r0, lr, ror #9
    785c:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    7860:	0900007d 	stmdbeq	r0, {r0, r2, r3, r4, r5, r6}
    7864:	00000000 	andeq	r0, r0, r0
    7868:	000005b6 			; <UNDEFINED> instruction: 0x000005b6
    786c:	00000502 	andeq	r0, r0, r2, lsl #10
    7870:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    7874:	0b004891 	bleq	19ac0 <_etext+0x124ac>
    7878:	00000000 	andeq	r0, r0, r0
    787c:	00000613 	andeq	r0, r0, r3, lsl r6
    7880:	0251010a 	subseq	r0, r1, #-2147483646	; 0x80000002
    7884:	010a4891 			; <UNDEFINED> instruction: 0x010a4891
    7888:	007d0250 	rsbseq	r0, sp, r0, asr r2
    788c:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    7890:	00000000 	andeq	r0, r0, r0
    7894:	000005b6 			; <UNDEFINED> instruction: 0x000005b6
    7898:	0000052e 	andeq	r0, r0, lr, lsr #10
    789c:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    78a0:	0b000075 	bleq	7a7c <_etext+0x468>
    78a4:	00000000 	andeq	r0, r0, r0
    78a8:	000005b6 			; <UNDEFINED> instruction: 0x000005b6
    78ac:	0250010a 	subseq	r0, r0, #-2147483646	; 0x80000002
    78b0:	00000074 	andeq	r0, r0, r4, ror r0
    78b4:	0014891d 	andseq	r8, r4, sp, lsl r9
    78b8:	4a1c0400 	bmi	7088c0 <_etext+0x7012ac>
    78bc:	0d000005 	stceq	0, cr0, [r0, #-20]	; 0xffffffec
    78c0:	00000179 	andeq	r0, r0, r9, ror r1
    78c4:	0015441e 	andseq	r4, r5, lr, lsl r4
    78c8:	6a3b0400 	bvs	ec88d0 <_etext+0xec12bc>
    78cc:	1f000005 	svcne	0x00000005
    78d0:	00000168 	andeq	r0, r0, r8, ror #2
    78d4:	00016e1f 	andeq	r6, r1, pc, lsl lr
    78d8:	016e1f00 	cmneq	lr, r0, lsl #30
    78dc:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    78e0:	0000157a 	andeq	r1, r0, sl, ror r5
    78e4:	05805104 	streq	r5, [r0, #260]	; 0x104
    78e8:	681f0000 	ldmdavs	pc, {}	; <UNPREDICTABLE>
    78ec:	1f000001 	svcne	0x00000001
    78f0:	0000016e 	andeq	r0, r0, lr, ror #2
    78f4:	146c1e00 	strbtne	r1, [ip], #-3584	; 0xe00
    78f8:	3a040000 	bcc	107900 <_etext+0x1002ec>
    78fc:	0000059b 	muleq	r0, fp, r5
    7900:	0001681f 	andeq	r6, r1, pc, lsl r8
    7904:	016e1f00 	cmneq	lr, r0, lsl #30
    7908:	6e1f0000 	cdpvs	0, 1, cr0, cr15, cr0, {0}
    790c:	00000001 	andeq	r0, r0, r1
    7910:	0015651e 	andseq	r6, r5, lr, lsl r5
    7914:	b6440400 	strblt	r0, [r4], -r0, lsl #8
    7918:	1f000005 	svcne	0x00000005
    791c:	00000168 	andeq	r0, r0, r8, ror #2
    7920:	00016e1f 	andeq	r6, r1, pc, lsl lr
    7924:	016e1f00 	cmneq	lr, r0, lsl #30
    7928:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    792c:	00001554 	andeq	r1, r0, r4, asr r5
    7930:	05c72804 	strbeq	r2, [r7, #2052]	; 0x804
    7934:	681f0000 	ldmdavs	pc, {}	; <UNPREDICTABLE>
    7938:	00000001 	andeq	r0, r0, r1
    793c:	00165a1e 	andseq	r5, r6, lr, lsl sl
    7940:	dd5a0400 	cfldrdle	mvd0, [sl, #-0]
    7944:	1f000005 	svcne	0x00000005
    7948:	00000168 	andeq	r0, r0, r8, ror #2
    794c:	00016e1f 	andeq	r6, r1, pc, lsl lr
    7950:	661e0000 	ldrvs	r0, [lr], -r0
    7954:	04000016 	streq	r0, [r0], #-22
    7958:	0005f33e 	andeq	pc, r5, lr, lsr r3	; <UNPREDICTABLE>
    795c:	01681f00 	cmneq	r8, r0, lsl #30
    7960:	6e1f0000 	cdpvs	0, 1, cr0, cr15, cr0, {0}
    7964:	00000001 	andeq	r0, r0, r1
    7968:	00158f1e 	andseq	r8, r5, lr, lsl pc
    796c:	13330400 	teqne	r3, #0, 8
    7970:	1f000006 	svcne	0x00000006
    7974:	00000168 	andeq	r0, r0, r8, ror #2
    7978:	00016e1f 	andeq	r6, r1, pc, lsl lr
    797c:	016e1f00 	cmneq	lr, r0, lsl #30
    7980:	761f0000 	ldrvc	r0, [pc], -r0
    7984:	00000000 	andeq	r0, r0, r0
    7988:	0015b420 	andseq	fp, r5, r0, lsr #8
    798c:	762d0400 	strtvc	r0, [sp], -r0, lsl #8
    7990:	1f000000 	svcne	0x00000000
    7994:	0000016e 	andeq	r0, r0, lr, ror #2
    7998:	00016e1f 	andeq	r6, r1, pc, lsl lr
    799c:	ac000000 	stcge	0, cr0, [r0], {-0}
    79a0:	04000005 	streq	r0, [r0], #-5
    79a4:	001b4100 	andseq	r4, fp, r0, lsl #2
    79a8:	a6010400 	strge	r0, [r1], -r0, lsl #8
    79ac:	01000014 	tsteq	r0, r4, lsl r0
    79b0:	000019b1 			; <UNDEFINED> instruction: 0x000019b1
    79b4:	00000893 	muleq	r0, r3, r8
    79b8:	00000928 	andeq	r0, r0, r8, lsr #18
    79bc:	00000000 	andeq	r0, r0, r0
    79c0:	000023cb 	andeq	r2, r0, fp, asr #7
    79c4:	69050402 	stmdbvs	r5, {r1, sl}
    79c8:	0300746e 	movweq	r7, #1134	; 0x46e
    79cc:	02570704 	subseq	r0, r7, #4, 14	; 0x100000
    79d0:	01030000 	mrseq	r0, (UNDEF: 3)
    79d4:	00081a06 	andeq	r1, r8, r6, lsl #20
    79d8:	08010300 	stmdaeq	r1, {r8, r9}
    79dc:	00000818 	andeq	r0, r0, r8, lsl r8
    79e0:	fc050203 	stc2	2, cr0, [r5], {3}
    79e4:	03000006 	movweq	r0, #6
    79e8:	09490702 	stmdbeq	r9, {r1, r8, r9, sl}^
    79ec:	04030000 	streq	r0, [r3], #-0
    79f0:	0004da05 	andeq	sp, r4, r5, lsl #20
    79f4:	07040300 	streq	r0, [r4, -r0, lsl #6]
    79f8:	00000252 	andeq	r0, r0, r2, asr r2
    79fc:	d5050803 	strle	r0, [r5, #-2051]	; 0x803
    7a00:	03000004 	movweq	r0, #4
    7a04:	024d0708 	subeq	r0, sp, #8, 14	; 0x200000
    7a08:	04030000 	streq	r0, [r3], #-0
    7a0c:	00078b07 	andeq	r8, r7, r7, lsl #22
    7a10:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    7a14:	00003a04 	andeq	r3, r0, r4, lsl #20
    7a18:	08010300 	stmdaeq	r1, {r8, r9}
    7a1c:	00000821 	andeq	r0, r0, r1, lsr #16
    7a20:	0c026806 	stceq	8, cr6, [r2], {6}
    7a24:	000000ae 	andeq	r0, r0, lr, lsr #1
    7a28:	00190907 	andseq	r0, r9, r7, lsl #18
    7a2c:	ae0e0200 	cdpge	2, 0, cr0, cr14, cr0, {0}
    7a30:	00000000 	andeq	r0, r0, r0
    7a34:	0017b907 	andseq	fp, r7, r7, lsl #18
    7a38:	be0f0200 	cdplt	2, 0, cr0, cr15, cr0, {0}
    7a3c:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    7a40:	00046c07 	andeq	r6, r4, r7, lsl #24
    7a44:	ce100200 	cdpgt	2, 1, cr0, cr0, cr0, {0}
    7a48:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    7a4c:	00560800 	subseq	r0, r6, r0, lsl #16
    7a50:	00be0000 	adcseq	r0, lr, r0
    7a54:	6b090000 	blvs	247a5c <_etext+0x240448>
    7a58:	01000000 	mrseq	r0, (UNDEF: 0)
    7a5c:	00560800 	subseq	r0, r6, r0, lsl #16
    7a60:	00ce0000 	sbceq	r0, lr, r0
    7a64:	6b090000 	blvs	247a6c <_etext+0x240458>
    7a68:	07000000 	streq	r0, [r0, -r0]
    7a6c:	003a0800 	eorseq	r0, sl, r0, lsl #16
    7a70:	00de0000 	sbcseq	r0, lr, r0
    7a74:	6b090000 	blvs	247a7c <_etext+0x240468>
    7a78:	3f000000 	svccc	0x00000000
    7a7c:	13970a00 	orrsne	r0, r7, #0, 20
    7a80:	12020000 	andne	r0, r2, #0
    7a84:	00000081 	andeq	r0, r0, r1, lsl #1
    7a88:	0019cf0b 	andseq	ip, r9, fp, lsl #30
    7a8c:	01c10100 	biceq	r0, r1, r0, lsl #2
    7a90:	0000012d 	andeq	r0, r0, sp, lsr #2
    7a94:	7874630c 	ldmdavc	r4!, {r2, r3, r8, r9, sp, lr}^
    7a98:	2dc10100 	stfcse	f0, [r1]
    7a9c:	0d000001 	stceq	0, cr0, [r0, #-4]
    7aa0:	000011da 	ldrdeq	r1, [r0], -sl
    7aa4:	0074c101 	rsbseq	ip, r4, r1, lsl #2
    7aa8:	400d0000 	andmi	r0, sp, r0
    7aac:	01000013 	tsteq	r0, r3, lsl r0
    7ab0:	000056c1 	andeq	r5, r0, r1, asr #13
    7ab4:	198f0e00 	stmibne	pc, {r9, sl, fp}	; <UNPREDICTABLE>
    7ab8:	c3010000 	movwgt	r0, #4096	; 0x1000
    7abc:	00000056 	andeq	r0, r0, r6, asr r0
    7ac0:	0019940e 	andseq	r9, r9, lr, lsl #8
    7ac4:	56c30100 	strbpl	r0, [r3], r0, lsl #2
    7ac8:	00000000 	andeq	r0, r0, r0
    7acc:	00de0405 	sbcseq	r0, lr, r5, lsl #8
    7ad0:	270f0000 	strcs	r0, [pc, -r0]
    7ad4:	01000013 	tsteq	r0, r3, lsl r0
    7ad8:	0030882f 	eorseq	r8, r0, pc, lsr #16
    7adc:	00005800 	andeq	r5, r0, r0, lsl #16
    7ae0:	569c0100 	ldrpl	r0, [ip], r0, lsl #2
    7ae4:	10000001 	andne	r0, r0, r1
    7ae8:	00787463 	rsbseq	r7, r8, r3, ror #8
    7aec:	012d2f01 	teqeq	sp, r1, lsl #30
    7af0:	50010000 	andpl	r0, r1, r0
    7af4:	19c00f00 	stmibne	r0, {r8, r9, sl, fp}^
    7af8:	3e010000 	cdpcc	0, 0, cr0, cr1, cr0, {0}
    7afc:	000030e0 	andeq	r3, r0, r0, ror #1
    7b00:	00001f64 	andeq	r1, r0, r4, ror #30
    7b04:	021d9c01 	andseq	r9, sp, #256	; 0x100
    7b08:	63110000 	tstvs	r1, #0
    7b0c:	01007874 	tsteq	r0, r4, ror r8
    7b10:	00012d3e 	andeq	r2, r1, lr, lsr sp
    7b14:	00513d00 	subseq	r3, r1, r0, lsl #26
    7b18:	0e7d1200 	cdpeq	2, 7, cr1, cr13, cr0, {0}
    7b1c:	3e010000 	cdpcc	0, 0, cr0, cr1, cr0, {0}
    7b20:	00000074 	andeq	r0, r0, r4, ror r0
    7b24:	00005194 	muleq	r0, r4, r1
    7b28:	0019dd13 	andseq	sp, r9, r3, lsl sp
    7b2c:	56400100 	strbpl	r0, [r0], -r0, lsl #2
    7b30:	b5000000 	strlt	r0, [r0, #-0]
    7b34:	13000051 	movwne	r0, #81	; 0x51
    7b38:	000019e3 	andeq	r1, r0, r3, ror #19
    7b3c:	00564001 	subseq	r4, r6, r1
    7b40:	54270000 	strtpl	r0, [r7], #-0
    7b44:	57140000 	ldrpl	r0, [r4, -r0]
    7b48:	1d400100 	stfnee	f0, [r0, #-0]
    7b4c:	d1000002 	tstle	r0, r2
    7b50:	14000060 	strne	r0, [r0], #-96	; 0x60
    7b54:	41010041 	tstmi	r1, r1, asr #32
    7b58:	00000056 	andeq	r0, r0, r6, asr r0
    7b5c:	000069b6 			; <UNDEFINED> instruction: 0x000069b6
    7b60:	01004214 	tsteq	r0, r4, lsl r2
    7b64:	00005641 	andeq	r5, r0, r1, asr #12
    7b68:	006a3900 	rsbeq	r3, sl, r0, lsl #18
    7b6c:	00431400 	subeq	r1, r3, r0, lsl #8
    7b70:	00564101 	subseq	r4, r6, r1, lsl #2
    7b74:	6a9b0000 	bvs	fe6c7b7c <BootRAM+0xd63831d>
    7b78:	44140000 	ldrmi	r0, [r4], #-0
    7b7c:	56410100 	strbpl	r0, [r1], -r0, lsl #2
    7b80:	f0000000 			; <UNDEFINED> instruction: 0xf0000000
    7b84:	1400006a 	strne	r0, [r0], #-106	; 0x6a
    7b88:	41010045 	tstmi	r1, r5, asr #32
    7b8c:	00000056 	andeq	r0, r0, r6, asr r0
    7b90:	00006b45 	andeq	r6, r0, r5, asr #22
    7b94:	01004614 	tsteq	r0, r4, lsl r6
    7b98:	00005641 	andeq	r5, r0, r1, asr #12
    7b9c:	006bc600 	rsbeq	ip, fp, r0, lsl #12
    7ba0:	00471400 	subeq	r1, r7, r0, lsl #8
    7ba4:	00564101 	subseq	r4, r6, r1, lsl #2
    7ba8:	6c3e0000 	ldcvs	0, cr0, [lr], #-0
    7bac:	48140000 	ldmdami	r4, {}	; <UNPREDICTABLE>
    7bb0:	56410100 	strbpl	r0, [r1], -r0, lsl #2
    7bb4:	b6000000 	strlt	r0, [r0], -r0
    7bb8:	0000006c 	andeq	r0, r0, ip, rrx
    7bbc:	00005608 	andeq	r5, r0, r8, lsl #12
    7bc0:	00022d00 	andeq	r2, r2, r0, lsl #26
    7bc4:	006b0900 	rsbeq	r0, fp, r0, lsl #18
    7bc8:	003f0000 	eorseq	r0, pc, r0
    7bcc:	0000e915 	andeq	lr, r0, r5, lsl r9
    7bd0:	00504400 	subseq	r4, r0, r0, lsl #8
    7bd4:	00008e00 	andeq	r8, r0, r0, lsl #28
    7bd8:	f29c0100 	vaddw.s16	q0, q6, d0
    7bdc:	16000002 	strne	r0, [r0], -r2
    7be0:	000000f5 	strdeq	r0, [r0], -r5
    7be4:	00006d39 	andeq	r6, r0, r9, lsr sp
    7be8:	00010016 	andeq	r0, r1, r6, lsl r0
    7bec:	006d9100 	rsbeq	r9, sp, r0, lsl #2
    7bf0:	010b1600 	tsteq	fp, r0, lsl #12
    7bf4:	6def0000 	stclvs	0, cr0, [pc]	; 7bfc <_etext+0x5e8>
    7bf8:	16170000 	ldrne	r0, [r7], -r0
    7bfc:	17000001 	strne	r0, [r0, -r1]
    7c00:	00000121 	andeq	r0, r0, r1, lsr #2
    7c04:	0008b818 	andeq	fp, r8, r8, lsl r8
    7c08:	010b1600 	tsteq	fp, r0, lsl #12
    7c0c:	6e4d0000 	cdpvs	0, 4, cr0, cr13, cr0, {0}
    7c10:	00160000 	andseq	r0, r6, r0
    7c14:	a5000001 	strge	r0, [r0, #-1]
    7c18:	1600006e 	strne	r0, [r0], -lr, rrx
    7c1c:	000000f5 	strdeq	r0, [r0], -r5
    7c20:	00006eef 	andeq	r6, r0, pc, ror #29
    7c24:	0008b818 	andeq	fp, r8, r8, lsl r8
    7c28:	01161900 	tsteq	r6, r0, lsl #18
    7c2c:	6f470000 	svcvs	0x00470000
    7c30:	21190000 	tstcs	r9, r0
    7c34:	88000001 	stmdahi	r0, {r0}
    7c38:	1a00006f 	bne	7dfc <_etext+0x7e8>
    7c3c:	00005078 	andeq	r5, r0, r8, ror r0
    7c40:	00000156 	andeq	r0, r0, r6, asr r1
    7c44:	000002b6 			; <UNDEFINED> instruction: 0x000002b6
    7c48:	0251011b 	subseq	r0, r1, #-1073741818	; 0xc0000006
    7c4c:	011b0074 	tsteq	fp, r4, ror r0
    7c50:	00760250 	rsbseq	r0, r6, r0, asr r2
    7c54:	50b01c00 	adcspl	r1, r0, r0, lsl #24
    7c58:	058b0000 	streq	r0, [fp]
    7c5c:	be1a0000 	cdplt	0, 1, cr0, cr10, cr0, {0}
    7c60:	8b000050 	blhi	7da8 <_etext+0x794>
    7c64:	d9000005 	stmdble	r0, {r0, r2}
    7c68:	1b000002 	blne	7c78 <_etext+0x664>
    7c6c:	74025201 	strvc	r5, [r2], #-513	; 0x201
    7c70:	51011b00 	tstpl	r1, r0, lsl #22
    7c74:	00007802 	andeq	r7, r0, r2, lsl #16
    7c78:	0050c81d 	subseq	ip, r0, sp, lsl r8
    7c7c:	00015600 	andeq	r5, r1, r0, lsl #12
    7c80:	51011b00 	tstpl	r1, r0, lsl #22
    7c84:	1b287602 	blne	a25494 <_etext+0xa1de80>
    7c88:	76025001 	strvc	r5, [r2], -r1
    7c8c:	00000000 	andeq	r0, r0, r0
    7c90:	19990f00 	ldmibne	r9, {r8, r9, sl, fp}
    7c94:	f0010000 			; <UNDEFINED> instruction: 0xf0010000
    7c98:	000050d4 	ldrdeq	r5, [r0], -r4
    7c9c:	00000218 	andeq	r0, r0, r8, lsl r2
    7ca0:	054b9c01 	strbeq	r9, [fp, #-3073]	; 0xc01
    7ca4:	63110000 	tstvs	r1, #0
    7ca8:	01007874 	tsteq	r0, r4, ror r8
    7cac:	00012df0 	strdeq	r2, [r1], -r0
    7cb0:	006fc000 	rsbeq	ip, pc, r0
    7cb4:	19f81200 	ldmibne	r8!, {r9, ip}^
    7cb8:	f0010000 			; <UNDEFINED> instruction: 0xf0010000
    7cbc:	00000074 	andeq	r0, r0, r4, ror r0
    7cc0:	00006fde 	ldrdeq	r6, [r0], -lr
    7cc4:	0019ff13 	andseq	pc, r9, r3, lsl pc	; <UNPREDICTABLE>
    7cc8:	56f20100 	ldrbtpl	r0, [r2], r0, lsl #2
    7ccc:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    7cd0:	13000070 	movwne	r0, #112	; 0x70
    7cd4:	000019a7 	andeq	r1, r0, r7, lsr #19
    7cd8:	0056f201 	subseq	pc, r6, r1, lsl #4
    7cdc:	705c0000 	subsvc	r0, ip, r0
    7ce0:	ac130000 	ldcge	0, cr0, [r3], {-0}
    7ce4:	01000019 	tsteq	r0, r9, lsl r0
    7ce8:	000056f3 	strdeq	r5, [r0], -r3
    7cec:	00708500 	rsbseq	r8, r0, r0, lsl #10
    7cf0:	6f6c1400 	svcvs	0x006c1400
    7cf4:	f3010077 	vqadd.u8	q0, <illegal reg q0.5>, <illegal reg q11.5>
    7cf8:	00000056 	andeq	r0, r0, r6, asr r0
    7cfc:	000070ae 	andeq	r7, r0, lr, lsr #1
    7d00:	0019881e 	andseq	r8, r9, lr, lsl r8
    7d04:	4bf40100 	blmi	ffd0810c <BootRAM+0xec788ad>
    7d08:	02000005 	andeq	r0, r0, #5
    7d0c:	e91f5091 	ldmdb	pc, {r0, r4, r7, ip, lr}	; <UNPREDICTABLE>
    7d10:	fc000000 	stc2	0, cr0, [r0], {-0}
    7d14:	d0000050 	andle	r0, r0, r0, asr r0
    7d18:	01000008 	tsteq	r0, r8
    7d1c:	045b0100 	ldrbeq	r0, [fp], #-256	; 0x100
    7d20:	0b160000 	bleq	587d28 <_etext+0x580714>
    7d24:	5c000001 	stcpl	0, cr0, [r0], {1}
    7d28:	20000070 	andcs	r0, r0, r0, ror r0
    7d2c:	00000100 	andeq	r0, r0, r0, lsl #2
    7d30:	02c40306 	sbceq	r0, r4, #402653184	; 0x18000000
    7d34:	209f2000 	addscs	r2, pc, r0
    7d38:	000000f5 	strdeq	r0, [r0], -r5
    7d3c:	d0185401 	andsle	r5, r8, r1, lsl #8
    7d40:	17000008 	strne	r0, [r0, -r8]
    7d44:	00000116 	andeq	r0, r0, r6, lsl r1
    7d48:	00012117 	andeq	r2, r1, r7, lsl r1
    7d4c:	08d01800 	ldmeq	r0, {fp, ip}^
    7d50:	0b160000 	bleq	587d58 <_etext+0x580744>
    7d54:	d7000001 	strle	r0, [r0, -r1]
    7d58:	16000070 			; <UNDEFINED> instruction: 0x16000070
    7d5c:	00000100 	andeq	r0, r0, r0, lsl #2
    7d60:	0000713a 	andeq	r7, r0, sl, lsr r1
    7d64:	0000f520 	andeq	pc, r0, r0, lsr #10
    7d68:	18540100 	ldmdane	r4, {r8}^
    7d6c:	000008d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    7d70:	00011619 	andeq	r1, r1, r9, lsl r6
    7d74:	00719300 	rsbseq	r9, r1, r0, lsl #6
    7d78:	01211900 	teqeq	r1, r0, lsl #18
    7d7c:	71d40000 	bicsvc	r0, r4, r0
    7d80:	621a0000 	andsvs	r0, sl, #0
    7d84:	8b000051 	blhi	7ed0 <_etext+0x8bc>
    7d88:	02000005 	andeq	r0, r0, #5
    7d8c:	1b000004 	blne	7da4 <_etext+0x790>
    7d90:	79025101 	stmdbvc	r2, {r0, r8, ip, lr}
    7d94:	50011b00 	andpl	r1, r1, r0, lsl #22
    7d98:	76007407 	strvc	r7, [r0], -r7, lsl #8
    7d9c:	28232200 	stmdacs	r3!, {r9, sp}
    7da0:	52481a00 	subpl	r1, r8, #0, 20
    7da4:	058b0000 	streq	r0, [fp]
    7da8:	04270000 	strteq	r0, [r7], #-0
    7dac:	011b0000 	tsteq	fp, r0
    7db0:	00770252 	rsbseq	r0, r7, r2, asr r2
    7db4:	0251011b 	subseq	r0, r1, #-1073741818	; 0xc0000006
    7db8:	011b0079 	tsteq	fp, r9, ror r0
    7dbc:	00740750 	rsbseq	r0, r4, r0, asr r7
    7dc0:	23220076 	teqcs	r2, #118	; 0x76
    7dc4:	581a0028 	ldmdapl	sl, {r3, r5}
    7dc8:	56000052 			; <UNDEFINED> instruction: 0x56000052
    7dcc:	41000001 	tstmi	r0, r1
    7dd0:	1b000004 	blne	7de8 <_etext+0x7d4>
    7dd4:	74025101 	strvc	r5, [r2], #-257	; 0x101
    7dd8:	50011b28 	andpl	r1, r1, r8, lsr #22
    7ddc:	00007402 	andeq	r7, r0, r2, lsl #8
    7de0:	00526c1d 	subseq	r6, r2, sp, lsl ip
    7de4:	00015600 	andeq	r5, r1, r0, lsl #12
    7de8:	51011b00 	tstpl	r1, r0, lsl #22
    7dec:	1b007602 	blne	255fc <_etext+0x1dfe8>
    7df0:	74025001 	strvc	r5, [r2], #-1
    7df4:	00000000 	andeq	r0, r0, r0
    7df8:	e9210000 	stmdb	r1!, {}	; <UNPREDICTABLE>
    7dfc:	62000000 	andvs	r0, r0, #0
    7e00:	08000051 	stmdaeq	r0, {r0, r4, r6}
    7e04:	01000009 	tsteq	r0, r9
    7e08:	0b160101 	bleq	588214 <_etext+0x580c00>
    7e0c:	32000001 	andcc	r0, r0, #1
    7e10:	16000072 			; <UNDEFINED> instruction: 0x16000072
    7e14:	00000100 	andeq	r0, r0, r0, lsl #2
    7e18:	0000725e 	andeq	r7, r0, lr, asr r2
    7e1c:	0000f516 	andeq	pc, r0, r6, lsl r5	; <UNPREDICTABLE>
    7e20:	00729400 	rsbseq	r9, r2, r0, lsl #8
    7e24:	09081800 	stmdbeq	r8, {fp, ip}
    7e28:	16170000 	ldrne	r0, [r7], -r0
    7e2c:	17000001 	strne	r0, [r0, -r1]
    7e30:	00000121 	andeq	r0, r0, r1, lsr #2
    7e34:	00090818 	andeq	r0, r9, r8, lsl r8
    7e38:	010b1600 	tsteq	fp, r0, lsl #12
    7e3c:	72bd0000 	adcsvc	r0, sp, #0
    7e40:	00160000 	andseq	r0, r6, r0
    7e44:	0c000001 	stceq	0, cr0, [r0], {1}
    7e48:	16000073 			; <UNDEFINED> instruction: 0x16000073
    7e4c:	000000f5 	strdeq	r0, [r0], -r5
    7e50:	00007294 	muleq	r0, r4, r2
    7e54:	00090818 	andeq	r0, r9, r8, lsl r8
    7e58:	01161900 	tsteq	r6, r0, lsl #18
    7e5c:	734b0000 	movtvc	r0, #45056	; 0xb000
    7e60:	21190000 	tstcs	r9, r0
    7e64:	81000001 	tsthi	r0, r1
    7e68:	1a000073 	bne	803c <_etext+0xa28>
    7e6c:	0000519c 	muleq	r0, ip, r1
    7e70:	0000058b 	andeq	r0, r0, fp, lsl #11
    7e74:	000004f1 	strdeq	r0, [r0], -r1
    7e78:	0252011b 	subseq	r0, r2, #-1073741818	; 0xc0000006
    7e7c:	011b0076 	tsteq	fp, r6, ror r0
    7e80:	00790251 	rsbseq	r0, r9, r1, asr r2
    7e84:	0750011b 	smmlaeq	r0, fp, r1, r0
    7e88:	00780074 	rsbseq	r0, r8, r4, ror r0
    7e8c:	00282322 	eoreq	r2, r8, r2, lsr #6
    7e90:	00529c1a 	subseq	r9, r2, sl, lsl ip
    7e94:	00058b00 	andeq	r8, r5, r0, lsl #22
    7e98:	00051600 	andeq	r1, r5, r0, lsl #12
    7e9c:	52011b00 	andpl	r1, r1, #0, 22
    7ea0:	1b007902 	blne	262b0 <_etext+0x1ec9c>
    7ea4:	7d025101 	stfvcs	f5, [r2, #-4]
    7ea8:	50011b00 	andpl	r1, r1, r0, lsl #22
    7eac:	78007407 	stmdavc	r0, {r0, r1, r2, sl, ip, sp, lr}
    7eb0:	28232200 	stmdacs	r3!, {r9, sp}
    7eb4:	52ae1a00 	adcpl	r1, lr, #0, 20
    7eb8:	01560000 	cmpeq	r6, r0
    7ebc:	05300000 	ldreq	r0, [r0, #-0]!
    7ec0:	011b0000 	tsteq	fp, r0
    7ec4:	28740251 	ldmdacs	r4!, {r0, r4, r6, r9}^
    7ec8:	0250011b 	subseq	r0, r0, #-1073741818	; 0xc0000006
    7ecc:	1d000074 	stcne	0, cr0, [r0, #-464]	; 0xfffffe30
    7ed0:	000052be 			; <UNDEFINED> instruction: 0x000052be
    7ed4:	00000156 	andeq	r0, r0, r6, asr r1
    7ed8:	0251011b 	subseq	r0, r1, #-1073741818	; 0xc0000006
    7edc:	011b0077 	tsteq	fp, r7, ror r0
    7ee0:	00740250 	rsbseq	r0, r4, r0, asr r2
    7ee4:	00000000 	andeq	r0, r0, r0
    7ee8:	3a080000 	bcc	207ef0 <_etext+0x2008dc>
    7eec:	5b000000 	blpl	7ef4 <_etext+0x8e0>
    7ef0:	09000005 	stmdbeq	r0, {r0, r2}
    7ef4:	0000006b 	andeq	r0, r0, fp, rrx
    7ef8:	e91e0007 	ldmdb	lr, {r0, r1, r2}
    7efc:	01000019 	tsteq	r0, r9, lsl r0
    7f00:	0000cee8 	andeq	ip, r0, r8, ror #29
    7f04:	c4030500 	strgt	r0, [r3], #-1280	; 0x500
    7f08:	08200002 	stmdaeq	r0!, {r1}
    7f0c:	0000002c 	andeq	r0, r0, ip, lsr #32
    7f10:	0000057c 	andeq	r0, r0, ip, ror r5
    7f14:	00006b09 	andeq	r6, r0, r9, lsl #22
    7f18:	22003f00 	andcs	r3, r0, #0, 30
    7f1c:	1201006b 	andne	r0, r1, #107	; 0x6b
    7f20:	0000056c 	andeq	r0, r0, ip, ror #10
    7f24:	03040305 	movweq	r0, #17157	; 0x4305
    7f28:	c4232000 	strtgt	r2, [r3], #-0
    7f2c:	72000015 	andvc	r0, r0, #21
    7f30:	a8000000 	stmdage	r0, {}	; <UNPREDICTABLE>
    7f34:	24000005 	strcs	r0, [r0], #-5
    7f38:	00000072 	andeq	r0, r0, r2, ror r0
    7f3c:	0005a824 	andeq	sl, r5, r4, lsr #16
    7f40:	006b2400 	rsbeq	r2, fp, r0, lsl #8
    7f44:	05000000 	streq	r0, [r0, #-0]
    7f48:	0005ae04 	andeq	sl, r5, r4, lsl #28
    7f4c:	7f002500 	svcvc	0x00002500
    7f50:	04000007 	streq	r0, [r0], #-7
    7f54:	001d2100 	andseq	r2, sp, r0, lsl #2
    7f58:	a6010400 	strge	r0, [r1], -r0, lsl #8
    7f5c:	01000014 	tsteq	r0, r4, lsl r0
    7f60:	00001a38 	andeq	r1, r0, r8, lsr sl
    7f64:	00000893 	muleq	r0, r3, r8
    7f68:	00000ba0 	andeq	r0, r0, r0, lsr #23
    7f6c:	00000000 	andeq	r0, r0, r0
    7f70:	00002bd4 	ldrdeq	r2, [r0], -r4
    7f74:	4d070802 	stcmi	8, cr0, [r7, #-8]
    7f78:	02000002 	andeq	r0, r0, #2
    7f7c:	08180801 	ldmdaeq	r8, {r0, fp}
    7f80:	04020000 	streq	r0, [r2], #-0
    7f84:	00025707 	andeq	r5, r2, r7, lsl #14
    7f88:	06010200 	streq	r0, [r1], -r0, lsl #4
    7f8c:	0000081a 	andeq	r0, r0, sl, lsl r8
    7f90:	000ad903 	andeq	sp, sl, r3, lsl #18
    7f94:	2c1c0200 	lfmcs	f0, 4, [ip], {-0}
    7f98:	02000000 	andeq	r0, r0, #0
    7f9c:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
    7fa0:	02020000 	andeq	r0, r2, #0
    7fa4:	00094907 	andeq	r4, r9, r7, lsl #18
    7fa8:	05040200 	streq	r0, [r4, #-512]	; 0x200
    7fac:	000004da 	ldrdeq	r0, [r0], -sl
    7fb0:	52070402 	andpl	r0, r7, #33554432	; 0x2000000
    7fb4:	02000002 	andeq	r0, r0, #2
    7fb8:	04d50508 	ldrbeq	r0, [r5], #1288	; 0x508
    7fbc:	43030000 	movwmi	r0, #12288	; 0x3000
    7fc0:	02000017 	andeq	r0, r0, #23
    7fc4:	0000254e 	andeq	r2, r0, lr, asr #10
    7fc8:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    7fcc:	00746e69 	rsbseq	r6, r4, r9, ror #28
    7fd0:	000adb03 	andeq	sp, sl, r3, lsl #22
    7fd4:	412a0300 	teqmi	sl, r0, lsl #6
    7fd8:	03000000 	movweq	r0, #0
    7fdc:	00001745 	andeq	r1, r0, r5, asr #14
    7fe0:	006f4e03 	rsbeq	r4, pc, r3, lsl #28
    7fe4:	e3030000 	movw	r0, #12288	; 0x3000
    7fe8:	0400000a 	streq	r0, [r0], #-10
    7fec:	000033d4 	ldrdeq	r3, [r0], -r4
    7ff0:	07040200 	streq	r0, [r4, -r0, lsl #4]
    7ff4:	0000078b 	andeq	r0, r0, fp, lsl #15
    7ff8:	01020405 	tsteq	r2, r5, lsl #8
    7ffc:	00082108 	andeq	r2, r8, r8, lsl #2
    8000:	17b20600 	ldrne	r0, [r2, r0, lsl #12]!
    8004:	05400000 	strbeq	r0, [r0, #-0]
    8008:	0000c914 	andeq	ip, r0, r4, lsl r9
    800c:	00680700 	rsbeq	r0, r8, r0, lsl #14
    8010:	00c91505 	sbceq	r1, r9, r5, lsl #10
    8014:	00000000 	andeq	r0, r0, r0
    8018:	00008c08 	andeq	r8, r0, r8, lsl #24
    801c:	0000d900 	andeq	sp, r0, r0, lsl #18
    8020:	00a20900 	adceq	r0, r2, r0, lsl #18
    8024:	00070000 	andeq	r0, r7, r0
    8028:	001a2a0a 	andseq	r2, sl, sl, lsl #20
    802c:	8c5f0100 	ldfhie	f0, [pc], {-0}
    8030:	03000000 	movweq	r0, #0
    8034:	000000fe 	strdeq	r0, [r0], -lr
    8038:	0100780b 	tsteq	r0, fp, lsl #16
    803c:	00008c5f 	andeq	r8, r0, pc, asr ip
    8040:	18460c00 	stmdane	r6, {sl, fp}^
    8044:	5f010000 	svcpl	0x00010000
    8048:	0000007a 	andeq	r0, r0, sl, ror r0
    804c:	1a300d00 	bne	c0b454 <_etext+0xc03e40>
    8050:	4b010000 	blmi	48058 <_etext+0x40a44>
    8054:	00011d03 	andeq	r1, r1, r3, lsl #26
    8058:	00780b00 	rsbseq	r0, r8, r0, lsl #22
    805c:	011d4b01 	tsteq	sp, r1, lsl #22
    8060:	760b0000 	strvc	r0, [fp], -r0
    8064:	8c4b0100 	stfhie	f0, [fp], {-0}
    8068:	00000000 	andeq	r0, r0, r0
    806c:	0081040e 	addeq	r0, r1, lr, lsl #8
    8070:	470a0000 	strmi	r0, [sl, -r0]
    8074:	0100001a 	tsteq	r0, sl, lsl r0
    8078:	00008c3b 	andeq	r8, r0, fp, lsr ip
    807c:	01460300 	mrseq	r0, SPSR_und
    8080:	780b0000 	stmdavc	fp, {}	; <UNPREDICTABLE>
    8084:	463b0100 	ldrtmi	r0, [fp], -r0, lsl #2
    8088:	0f000001 	svceq	0x00000001
    808c:	3d010072 	stccc	0, cr0, [r1, #-456]	; 0xfffffe38
    8090:	0000008c 	andeq	r0, r0, ip, lsl #1
    8094:	4c040e00 	stcmi	14, cr0, [r4], {-0}
    8098:	10000001 	andne	r0, r0, r1
    809c:	00000081 	andeq	r0, r0, r1, lsl #1
    80a0:	0017d911 	andseq	sp, r7, r1, lsl r9
    80a4:	ec640100 	stfe	f0, [r4], #-0
    80a8:	94000052 	strls	r0, [r0], #-82	; 0x52
    80ac:	01000004 	tsteq	r0, r4
    80b0:	0004619c 	muleq	r4, ip, r1
    80b4:	00731200 	rsbseq	r1, r3, r0, lsl #4
    80b8:	04616401 	strbteq	r6, [r1], #-1025	; 0x401
    80bc:	73d80000 	bicsvc	r0, r8, #0
    80c0:	62120000 	andsvs	r0, r2, #0
    80c4:	01006b6c 	tsteq	r0, ip, ror #22
    80c8:	00014664 	andeq	r4, r1, r4, ror #12
    80cc:	00740500 	rsbseq	r0, r4, r0, lsl #10
    80d0:	00771300 	rsbseq	r1, r7, r0, lsl #6
    80d4:	04676601 	strbteq	r6, [r7], #-1537	; 0x601
    80d8:	91030000 	mrsls	r0, (UNDEF: 3)
    80dc:	61147ee0 	tstvs	r4, r0, ror #29
    80e0:	8c670100 	stfhie	f0, [r7], #-0
    80e4:	23000000 	movwcs	r0, #0
    80e8:	14000074 	strne	r0, [r0], #-116	; 0x74
    80ec:	67010062 	strvs	r0, [r1, -r2, rrx]
    80f0:	0000008c 	andeq	r0, r0, ip, lsl #1
    80f4:	00007483 	andeq	r7, r0, r3, lsl #9
    80f8:	01006314 	tsteq	r0, r4, lsl r3
    80fc:	00008c67 	andeq	r8, r0, r7, ror #24
    8100:	0074c500 	rsbseq	ip, r4, r0, lsl #10
    8104:	00641400 	rsbeq	r1, r4, r0, lsl #8
    8108:	008c6701 	addeq	r6, ip, r1, lsl #14
    810c:	750e0000 	strvc	r0, [lr, #-0]
    8110:	65140000 	ldrvs	r0, [r4, #-0]
    8114:	8c670100 	stfhie	f0, [r7], #-0
    8118:	72000000 	andvc	r0, r0, #0
    811c:	14000075 	strne	r0, [r0], #-117	; 0x75
    8120:	67010066 	strvs	r0, [r1, -r6, rrx]
    8124:	0000008c 	andeq	r0, r0, ip, lsl #1
    8128:	000075c6 	andeq	r7, r0, r6, asr #11
    812c:	01006714 	tsteq	r0, r4, lsl r7
    8130:	00008c67 	andeq	r8, r0, r7, ror #24
    8134:	00760700 	rsbseq	r0, r6, r0, lsl #14
    8138:	00681400 	rsbeq	r1, r8, r0, lsl #8
    813c:	008c6701 	addeq	r6, ip, r1, lsl #14
    8140:	764f0000 	strbvc	r0, [pc], -r0
    8144:	69140000 	ldmdbvs	r4, {}	; <UNPREDICTABLE>
    8148:	7a680100 	bvc	1a08550 <_etext+0x1a00f3c>
    814c:	9b000000 	blls	8154 <_etext+0xb40>
    8150:	15000076 	strne	r0, [r0, #-118]	; 0x76
    8154:	00000123 	andeq	r0, r0, r3, lsr #2
    8158:	000052fc 	strdeq	r5, [r0], -ip
    815c:	00000950 	andeq	r0, r0, r0, asr r9
    8160:	02306b01 	eorseq	r6, r0, #1024	; 0x400
    8164:	33160000 	tstcc	r6, #0
    8168:	de000001 	cdple	0, 0, cr0, cr0, cr1, {0}
    816c:	17000076 	smlsdxne	r0, r6, r0, r0
    8170:	00000950 	andeq	r0, r0, r0, asr r9
    8174:	00013c18 	andeq	r3, r1, r8, lsl ip
    8178:	00775900 	rsbseq	r5, r7, r0, lsl #18
    817c:	19000000 	stmdbne	r0, {}	; <UNPREDICTABLE>
    8180:	00005448 	andeq	r5, r0, r8, asr #8
    8184:	00000262 	andeq	r0, r0, r2, ror #4
    8188:	00697714 	rsbeq	r7, r9, r4, lsl r7
    818c:	04777b01 	ldrbteq	r7, [r7], #-2817	; 0xb01
    8190:	78350000 	ldmdavc	r5!, {}	; <UNPREDICTABLE>
    8194:	0f1a0000 	svceq	0x001a0000
    8198:	0100001a 	tsteq	r0, sl, lsl r0
    819c:	0004777c 	andeq	r7, r4, ip, ror r7
    81a0:	00784a00 	rsbseq	r4, r8, r0, lsl #20
    81a4:	69771400 	ldmdbvs	r7!, {sl, ip}^
    81a8:	7d010032 	stcvc	0, cr0, [r1, #-200]	; 0xffffff38
    81ac:	00000477 	andeq	r0, r0, r7, ror r4
    81b0:	000078a4 	andeq	r7, r0, r4, lsr #17
    81b4:	37697714 			; <UNDEFINED> instruction: 0x37697714
    81b8:	777e0100 	ldrbvc	r0, [lr, -r0, lsl #2]!
    81bc:	e8000004 	stmda	r0, {r2}
    81c0:	14000078 	strne	r0, [r0], #-120	; 0x78
    81c4:	01003073 	tsteq	r0, r3, ror r0
    81c8:	0004777f 	andeq	r7, r4, pc, ror r7
    81cc:	00793000 	rsbseq	r3, r9, r0
    81d0:	31731400 	cmncc	r3, r0, lsl #8
    81d4:	77810100 	strvc	r0, [r1, r0, lsl #2]
    81d8:	6c000004 	stcvs	0, cr0, [r0], {4}
    81dc:	1400007a 	strne	r0, [r0], #-122	; 0x7a
    81e0:	01003053 	qaddeq	r3, r3, r0
    81e4:	00047785 	andeq	r7, r4, r5, lsl #15
    81e8:	007b5500 	rsbseq	r5, fp, r0, lsl #10
    81ec:	31531400 	cmpcc	r3, r0, lsl #8
    81f0:	77860100 	strvc	r0, [r6, r0, lsl #2]
    81f4:	1a000004 	bne	820c <_etext+0xbf8>
    81f8:	1400007c 	strne	r0, [r0], #-124	; 0x7c
    81fc:	01006863 	tsteq	r0, r3, ror #16
    8200:	00047787 	andeq	r7, r4, r7, lsl #15
    8204:	007cdc00 	rsbseq	sp, ip, r0, lsl #24
    8208:	19dd1a00 	ldmibne	sp, {r9, fp, ip}^
    820c:	88010000 	stmdahi	r1, {}	; <UNPREDICTABLE>
    8210:	00000477 	andeq	r0, r0, r7, ror r4
    8214:	00007d26 	andeq	r7, r0, r6, lsr #26
    8218:	6a616d14 	bvs	1863670 <_etext+0x185c05c>
    821c:	77890100 	strvc	r0, [r9, r0, lsl #2]
    8220:	3e000004 	cdpcc	0, 0, cr0, cr0, cr4, {0}
    8224:	1a00007d 	bne	8420 <_etext+0xe0c>
    8228:	000019e3 	andeq	r1, r0, r3, ror #19
    822c:	04778a01 	ldrbteq	r8, [r7], #-2561	; 0xa01
    8230:	7d9a0000 	ldcvc	0, cr0, [sl]
    8234:	d9150000 	ldmdble	r5, {}	; <UNPREDICTABLE>
    8238:	80000000 	andhi	r0, r0, r0
    823c:	68000054 	stmdavs	r0, {r2, r4, r6}
    8240:	01000009 	tsteq	r0, r9
    8244:	00030d86 	andeq	r0, r3, r6, lsl #27
    8248:	00f21600 	rscseq	r1, r2, r0, lsl #12
    824c:	7dc20000 	stclvc	0, cr0, [r2]
    8250:	e9160000 	ldmdb	r6, {}	; <UNPREDICTABLE>
    8254:	e2000000 	and	r0, r0, #0
    8258:	0000007d 	andeq	r0, r0, sp, ror r0
    825c:	0000d915 	andeq	sp, r0, r5, lsl r9
    8260:	00548a00 	subseq	r8, r4, r0, lsl #20
    8264:	00099000 	andeq	r9, r9, r0
    8268:	33860100 	orrcc	r0, r6, #0, 2
    826c:	16000003 	strne	r0, [r0], -r3
    8270:	000000f2 	strdeq	r0, [r0], -r2
    8274:	00007e17 	andeq	r7, r0, r7, lsl lr
    8278:	0000e916 	andeq	lr, r0, r6, lsl r9
    827c:	007de200 	rsbseq	lr, sp, r0, lsl #4
    8280:	d9150000 	ldmdble	r5, {}	; <UNPREDICTABLE>
    8284:	bc000000 	stclt	0, cr0, [r0], {-0}
    8288:	b8000054 	stmdalt	r0, {r2, r4, r6}
    828c:	01000009 	tsteq	r0, r9
    8290:	00035986 	andeq	r5, r3, r6, lsl #19
    8294:	00f21600 	rscseq	r1, r2, r0, lsl #12
    8298:	7e370000 	cdpvc	0, 3, cr0, cr7, cr0, {0}
    829c:	e9160000 	ldmdb	r6, {}	; <UNPREDICTABLE>
    82a0:	e2000000 	and	r0, r0, #0
    82a4:	0000007d 	andeq	r0, r0, sp, ror r0
    82a8:	0000d915 	andeq	sp, r0, r5, lsl r9
    82ac:	0054c000 	subseq	ip, r4, r0
    82b0:	0009f000 	andeq	pc, r9, r0
    82b4:	7f800100 	svcvc	0x00800100
    82b8:	16000003 	strne	r0, [r0], -r3
    82bc:	000000f2 	strdeq	r0, [r0], -r2
    82c0:	00007e59 	andeq	r7, r0, r9, asr lr
    82c4:	0000e916 	andeq	lr, r0, r6, lsl r9
    82c8:	00784a00 	rsbseq	r4, r8, r0, lsl #20
    82cc:	d9150000 	ldmdble	r5, {}	; <UNPREDICTABLE>
    82d0:	d8000000 	stmdale	r0, {}	; <UNPREDICTABLE>
    82d4:	28000054 	stmdacs	r0, {r2, r4, r6}
    82d8:	0100000a 	tsteq	r0, sl
    82dc:	0003a580 	andeq	sl, r3, r0, lsl #11
    82e0:	00f21600 	rscseq	r1, r2, r0, lsl #12
    82e4:	7e790000 	cdpvc	0, 7, cr0, cr9, cr0, {0}
    82e8:	e9160000 	ldmdb	r6, {}	; <UNPREDICTABLE>
    82ec:	4a000000 	bmi	82f4 <_etext+0xce0>
    82f0:	00000078 	andeq	r0, r0, r8, ror r0
    82f4:	0000d915 	andeq	sp, r0, r5, lsl r9
    82f8:	00552400 	subseq	r2, r5, r0, lsl #8
    82fc:	000a5800 	andeq	r5, sl, r0, lsl #16
    8300:	cb820100 	blgt	fe088708 <BootRAM+0xcff8ea9>
    8304:	16000003 	strne	r0, [r0], -r3
    8308:	000000f2 	strdeq	r0, [r0], -r2
    830c:	00007e99 	muleq	r0, r9, lr
    8310:	0000e916 	andeq	lr, r0, r6, lsl r9
    8314:	0078a400 	rsbseq	sl, r8, r0, lsl #8
    8318:	d9150000 	ldmdble	r5, {}	; <UNPREDICTABLE>
    831c:	2c000000 	stccs	0, cr0, [r0], {-0}
    8320:	70000055 	andvc	r0, r0, r5, asr r0
    8324:	0100000a 	tsteq	r0, sl
    8328:	0003f185 	andeq	pc, r3, r5, lsl #3
    832c:	00f21600 	rscseq	r1, r2, r0, lsl #12
    8330:	7eb90000 	cdpvc	0, 11, cr0, cr9, cr0, {0}
    8334:	e9160000 	ldmdb	r6, {}	; <UNPREDICTABLE>
    8338:	db000000 	blle	8340 <_etext+0xd2c>
    833c:	0000007e 	andeq	r0, r0, lr, ror r0
    8340:	0000d915 	andeq	sp, r0, r5, lsl r9
    8344:	00553600 	subseq	r3, r5, r0, lsl #12
    8348:	000a9800 	andeq	r9, sl, r0, lsl #16
    834c:	17850100 	strne	r0, [r5, r0, lsl #2]
    8350:	16000004 	strne	r0, [r0], -r4
    8354:	000000f2 	strdeq	r0, [r0], -r2
    8358:	00007f10 	andeq	r7, r0, r0, lsl pc
    835c:	0000e916 	andeq	lr, r0, r6, lsl r9
    8360:	007edb00 	rsbseq	sp, lr, r0, lsl #22
    8364:	d9150000 	ldmdble	r5, {}	; <UNPREDICTABLE>
    8368:	98000000 	stmdals	r0, {}	; <UNPREDICTABLE>
    836c:	c0000055 	andgt	r0, r0, r5, asr r0
    8370:	0100000a 	tsteq	r0, sl
    8374:	00043d82 	andeq	r3, r4, r2, lsl #27
    8378:	00f21600 	rscseq	r1, r2, r0, lsl #12
    837c:	7f300000 	svcvc	0x00300000
    8380:	e9160000 	ldmdb	r6, {}	; <UNPREDICTABLE>
    8384:	a4000000 	strge	r0, [r0], #-0
    8388:	00000078 	andeq	r0, r0, r8, ror r0
    838c:	0000d91b 	andeq	sp, r0, fp, lsl r9
    8390:	00560200 	subseq	r0, r6, r0, lsl #4
    8394:	000ae000 	andeq	lr, sl, r0
    8398:	16850100 	strne	r0, [r5], r0, lsl #2
    839c:	000000f2 	strdeq	r0, [r0], -r2
    83a0:	00007f52 	andeq	r7, r0, r2, asr pc
    83a4:	0000e916 	andeq	lr, r0, r6, lsl r9
    83a8:	007edb00 	rsbseq	sp, lr, r0, lsl #22
    83ac:	00000000 	andeq	r0, r0, r0
    83b0:	00b2040e 	adcseq	r0, r2, lr, lsl #8
    83b4:	8c080000 	stchi	0, cr0, [r8], {-0}
    83b8:	77000000 	strvc	r0, [r0, -r0]
    83bc:	09000004 	stmdbeq	r0, {r2}
    83c0:	000000a2 	andeq	r0, r0, r2, lsr #1
    83c4:	8c10000f 	ldchi	0, cr0, [r0], {15}
    83c8:	11000000 	mrsne	r0, (UNDEF: 0)
    83cc:	000016b9 			; <UNDEFINED> instruction: 0x000016b9
    83d0:	5780a501 	strpl	sl, [r0, r1, lsl #10]
    83d4:	00880000 	addeq	r0, r8, r0
    83d8:	9c010000 	stcls	0, cr0, [r1], {-0}
    83dc:	0000058f 	andeq	r0, r0, pc, lsl #11
    83e0:	01007312 	tsteq	r0, r2, lsl r3
    83e4:	000461a5 	andeq	r6, r4, r5, lsr #3
    83e8:	007f7400 	rsbseq	r7, pc, r0, lsl #8
    83ec:	6c621200 	sfmvs	f1, 2, [r2], #-0
    83f0:	a501006b 	strge	r0, [r1, #-107]	; 0x6b
    83f4:	00000146 	andeq	r0, r0, r6, asr #2
    83f8:	00007f92 	muleq	r0, r2, pc	; <UNPREDICTABLE>
    83fc:	001a041c 	andseq	r0, sl, ip, lsl r4
    8400:	97a60100 	strls	r0, [r6, r0, lsl #2]!
    8404:	b0000000 	andlt	r0, r0, r0
    8408:	1d00007f 	stcne	0, cr0, [r0, #-508]	; 0xfffffe04
    840c:	00001a25 	andeq	r1, r0, r5, lsr #20
    8410:	058fa801 	streq	sl, [pc, #2049]	; 8c19 <_etext+0x1605>
    8414:	91030000 	mrsls	r0, (UNDEF: 3)
    8418:	141a7ee0 	ldrne	r7, [sl], #-3808	; 0xee0
    841c:	0100001a 	tsteq	r0, sl, lsl r0
    8420:	00059fa9 	andeq	r9, r5, r9, lsr #31
    8424:	007fe700 	rsbseq	lr, pc, r0, lsl #14
    8428:	00fe1500 	rscseq	r1, lr, r0, lsl #10
    842c:	57a40000 	strpl	r0, [r4, r0]!
    8430:	0b180000 	bleq	608438 <_etext+0x600e24>
    8434:	b5010000 	strlt	r0, [r1, #-0]
    8438:	00000500 	andeq	r0, r0, r0, lsl #10
    843c:	00011316 	andeq	r1, r1, r6, lsl r3
    8440:	00802600 	addeq	r2, r0, r0, lsl #12
    8444:	010a1600 	tsteq	sl, r0, lsl #12
    8448:	80530000 	subshi	r0, r3, r0
    844c:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    8450:	00005798 	muleq	r0, r8, r7
    8454:	00000741 	andeq	r0, r0, r1, asr #14
    8458:	0000051f 	andeq	r0, r0, pc, lsl r5
    845c:	0252011f 	subseq	r0, r2, #-1073741817	; 0xc0000007
    8460:	011f0075 	tsteq	pc, r5, ror r0	; <UNPREDICTABLE>
    8464:	1f300151 	svcne	0x00300151
    8468:	7d025001 	stcvc	0, cr5, [r2, #-4]
    846c:	d61e0000 	ldrle	r0, [lr], -r0
    8470:	51000057 	qaddpl	r0, r7, r0
    8474:	39000001 	stmdbcc	r0, {r0}
    8478:	1f000005 	svcne	0x00000005
    847c:	7d025101 	stfvcs	f5, [r2, #-4]
    8480:	50011f00 	andpl	r1, r1, r0, lsl #30
    8484:	00007a02 	andeq	r7, r0, r2, lsl #20
    8488:	0057e61e 	subseq	lr, r7, lr, lsl r6
    848c:	00075e00 	andeq	r5, r7, r0, lsl #28
    8490:	00055900 	andeq	r5, r5, r0, lsl #18
    8494:	52011f00 	andpl	r1, r1, #0, 30
    8498:	1f007602 	svcne	0x00007602
    849c:	77025101 	strvc	r5, [r2, -r1, lsl #2]
    84a0:	50011f00 	andpl	r1, r1, r0, lsl #30
    84a4:	00007d02 	andeq	r7, r0, r2, lsl #26
    84a8:	0057fc1e 	subseq	pc, r7, lr, lsl ip	; <UNPREDICTABLE>
    84ac:	00015100 	andeq	r5, r1, r0, lsl #2
    84b0:	00057300 	andeq	r7, r5, r0, lsl #6
    84b4:	51011f00 	tstpl	r1, r0, lsl #30
    84b8:	1f007d02 	svcne	0x00007d02
    84bc:	7a025001 	bvc	9c4c8 <_etext+0x94eb4>
    84c0:	06200000 	strteq	r0, [r0], -r0
    84c4:	41000058 	qaddmi	r0, r8, r0
    84c8:	1f000007 	svcne	0x00000007
    84cc:	75025201 	strvc	r5, [r2, #-513]	; 0x201
    84d0:	51011f00 	tstpl	r1, r0, lsl #30
    84d4:	011f3001 	tsteq	pc, r1
    84d8:	007d0250 	rsbseq	r0, sp, r0, asr r2
    84dc:	81080000 	mrshi	r0, (UNDEF: 8)
    84e0:	9f000000 	svcls	0x00000000
    84e4:	09000005 	stmdbeq	r0, {r0, r2}
    84e8:	000000a2 	andeq	r0, r0, r2, lsr #1
    84ec:	9710007f 			; <UNDEFINED> instruction: 0x9710007f
    84f0:	11000000 	mrsne	r0, (UNDEF: 0)
    84f4:	00001705 	andeq	r1, r0, r5, lsl #14
    84f8:	5808b901 	stmdapl	r8, {r0, r8, fp, ip, sp, pc}
    84fc:	02960000 	addseq	r0, r6, #0
    8500:	9c010000 	stcls	0, cr0, [r1], {-0}
    8504:	000006ef 	andeq	r0, r0, pc, ror #13
    8508:	01007312 	tsteq	r0, r2, lsl r3
    850c:	0006efb9 			; <UNDEFINED> instruction: 0x0006efb9
    8510:	0080b600 	addeq	fp, r0, r0, lsl #12
    8514:	0d8f1c00 	stceq	12, cr1, [pc]	; 851c <_etext+0xf08>
    8518:	b9010000 	stmdblt	r1, {}	; <UNPREDICTABLE>
    851c:	0000011d 	andeq	r0, r0, sp, lsl r1
    8520:	000080d5 	ldrdeq	r8, [r0], -r5
    8524:	001a1e1c 	andseq	r1, sl, ip, lsl lr
    8528:	33ba0100 			; <UNDEFINED> instruction: 0x33ba0100
    852c:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
    8530:	12000081 	andne	r0, r0, #129	; 0x81
    8534:	006e656c 	rsbeq	r6, lr, ip, ror #10
    8538:	0033ba01 	eorseq	fp, r3, r1, lsl #20
    853c:	81390000 	teqhi	r9, r0
    8540:	69140000 	ldmdbvs	r4, {}	; <UNPREDICTABLE>
    8544:	7abc0100 	bvc	fef0894c <BootRAM+0xde790ed>
    8548:	ae000000 	cdpge	0, 0, cr0, cr0, cr0, {0}
    854c:	15000081 	strne	r0, [r0, #-129]	; 0x81
    8550:	000000fe 	strdeq	r0, [r0], -lr
    8554:	00005862 	andeq	r5, r0, r2, ror #16
    8558:	00000b30 	andeq	r0, r0, r0, lsr fp
    855c:	0626d801 	strteq	sp, [r6], -r1, lsl #16
    8560:	13160000 	tstne	r6, #0
    8564:	d2000001 	andle	r0, r0, #1
    8568:	16000081 	strne	r0, [r0], -r1, lsl #1
    856c:	0000010a 	andeq	r0, r0, sl, lsl #2
    8570:	00008248 	andeq	r8, r0, r8, asr #4
    8574:	59142100 	ldmdbpl	r4, {r8, sp}
    8578:	00e20000 	rsceq	r0, r2, r0
    857c:	06900000 	ldreq	r0, [r0], r0
    8580:	74130000 	ldrvc	r0, [r3], #-0
    8584:	0100706d 	tsteq	r0, sp, rrx
    8588:	0006faca 	andeq	pc, r6, sl, asr #21
    858c:	50910200 	addspl	r0, r1, r0, lsl #4
    8590:	01006314 	tsteq	r0, r4, lsl r3
    8594:	000033cb 	andeq	r3, r0, fp, asr #7
    8598:	0082b600 	addeq	fp, r2, r0, lsl #12
    859c:	00fe1500 	rscseq	r1, lr, r0, lsl #10
    85a0:	591e0000 	ldmdbpl	lr, {}	; <UNPREDICTABLE>
    85a4:	0b500000 	bleq	14085ac <_etext+0x1400f98>
    85a8:	d0010000 	andle	r0, r1, r0
    85ac:	00000670 	andeq	r0, r0, r0, ror r6
    85b0:	00011322 	andeq	r1, r1, r2, lsr #6
    85b4:	010a1600 	tsteq	sl, r0, lsl #12
    85b8:	82c90000 	sbchi	r0, r9, #0
    85bc:	20000000 	andcs	r0, r0, r0
    85c0:	000059e4 	andeq	r5, r0, r4, ror #19
    85c4:	0000075e 	andeq	r0, r0, lr, asr r7
    85c8:	0951011f 	ldmdbeq	r1, {r0, r1, r2, r3, r4, r8}^
    85cc:	44910091 	ldrmi	r0, [r1], #145	; 0x91
    85d0:	30082206 	andcc	r2, r8, r6, lsl #4
    85d4:	50011f1c 	andpl	r1, r1, ip, lsl pc
    85d8:	7fac9104 	svcvc	0x00ac9104
    85dc:	19000006 	stmdbne	r0, {r1, r2}
    85e0:	000059f6 	strdeq	r5, [r0], -r6
    85e4:	000000a2 	andeq	r0, r0, r2, lsr #1
    85e8:	706d7413 	rsbvc	r7, sp, r3, lsl r4
    85ec:	fadf0100 	blx	ff7c89f4 <BootRAM+0xe739195>
    85f0:	02000006 	andeq	r0, r0, #6
    85f4:	fe155091 	mrc2	0, 0, r5, cr5, cr1, {4}
    85f8:	06000000 	streq	r0, [r0], -r0
    85fc:	8000005a 	andhi	r0, r0, sl, asr r0
    8600:	0100000b 	tsteq	r0, fp
    8604:	0006cde1 	andeq	ip, r6, r1, ror #27
    8608:	01131600 	tsteq	r3, r0, lsl #12
    860c:	82de0000 	sbcshi	r0, lr, #0
    8610:	0a160000 	beq	588618 <_etext+0x581004>
    8614:	5b000001 	blpl	8620 <_etext+0x100c>
    8618:	00000083 	andeq	r0, r0, r3, lsl #1
    861c:	005a9820 	subseq	r9, sl, r0, lsr #16
    8620:	00075e00 	andeq	r5, r7, r0, lsl #28
    8624:	52011f00 	andpl	r1, r1, #0, 30
    8628:	7fa49104 	svcvc	0x00a49104
    862c:	51011f06 	tstpl	r1, r6, lsl #30
    8630:	1f509102 	svcne	0x00509102
    8634:	91045001 	tstls	r4, r1
    8638:	00067fac 	andeq	r7, r6, ip, lsr #31
    863c:	040e0000 	streq	r0, [lr], #-0
    8640:	000006f5 	strdeq	r0, [r0], -r5
    8644:	0000b210 	andeq	fp, r0, r0, lsl r2
    8648:	00810800 	addeq	r0, r1, r0, lsl #16
    864c:	070a0000 	streq	r0, [sl, -r0]
    8650:	a2090000 	andge	r0, r9, #0
    8654:	07000000 	streq	r0, [r0, -r0]
    8658:	008c0800 	addeq	r0, ip, r0, lsl #16
    865c:	071a0000 	ldreq	r0, [sl, -r0]
    8660:	a2090000 	andge	r0, r9, #0
    8664:	4f000000 	svcmi	0x00000000
    8668:	1a4e1d00 	bne	138fa70 <_etext+0x138845c>
    866c:	10010000 	andne	r0, r1, r0
    8670:	0000072b 	andeq	r0, r0, fp, lsr #14
    8674:	72c00305 	sbcvc	r0, r0, #335544320	; 0x14000000
    8678:	0a100000 	beq	408680 <_etext+0x40106c>
    867c:	23000007 	movwcs	r0, #7
    8680:	000016f0 	strdeq	r1, [r0], -r0
    8684:	06f50901 	ldrbteq	r0, [r5], r1, lsl #18
    8688:	03050000 	movweq	r0, #20480	; 0x5000
    868c:	00007280 	andeq	r7, r0, r0, lsl #5
    8690:	000ff124 	andeq	pc, pc, r4, lsr #2
    8694:	0000a900 	andeq	sl, r0, r0, lsl #18
    8698:	00075e00 	andeq	r5, r7, r0, lsl #28
    869c:	00a92500 	adceq	r2, r9, r0, lsl #10
    86a0:	7a250000 	bvc	9486a8 <_etext+0x941094>
    86a4:	25000000 	strcs	r0, [r0, #-0]
    86a8:	000000a2 	andeq	r0, r0, r2, lsr #1
    86ac:	15c42400 	strbne	r2, [r4, #1024]	; 0x400
    86b0:	00a90000 	adceq	r0, r9, r0
    86b4:	077b0000 	ldrbeq	r0, [fp, -r0]!
    86b8:	a9250000 	stmdbge	r5!, {}	; <UNPREDICTABLE>
    86bc:	25000000 	strcs	r0, [r0, #-0]
    86c0:	0000077b 	andeq	r0, r0, fp, ror r7
    86c4:	0000a225 	andeq	sl, r0, r5, lsr #4
    86c8:	040e0000 	streq	r0, [lr], #-0
    86cc:	00000781 	andeq	r0, r0, r1, lsl #15
    86d0:	080a0026 	stmdaeq	sl, {r1, r2, r5}
    86d4:	00040000 	andeq	r0, r4, r0
    86d8:	00001f06 	andeq	r1, r0, r6, lsl #30
    86dc:	06390104 	ldrteq	r0, [r9], -r4, lsl #2
    86e0:	56010000 	strpl	r0, [r1], -r0
    86e4:	9300001a 	movwls	r0, #26
    86e8:	c0000008 	andgt	r0, r0, r8
    86ec:	0000000b 	andeq	r0, r0, fp
    86f0:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    86f4:	02000031 	andeq	r0, r0, #49	; 0x31
    86f8:	00000ae3 	andeq	r0, r0, r3, ror #21
    86fc:	0030d402 	eorseq	sp, r0, r2, lsl #8
    8700:	04030000 	streq	r0, [r3], #-0
    8704:	00025707 	andeq	r5, r2, r7, lsl #14
    8708:	05040400 	streq	r0, [r4, #-1024]	; 0x400
    870c:	6e690504 	cdpvs	5, 6, cr0, cr9, cr4, {0}
    8710:	01030074 	tsteq	r3, r4, ror r0
    8714:	00081a06 	andeq	r1, r8, r6, lsl #20
    8718:	0ad90200 	beq	ff648f20 <BootRAM+0xe5b96c1>
    871c:	1c030000 	stcne	0, cr0, [r3], {-0}
    8720:	00000052 	andeq	r0, r0, r2, asr r0
    8724:	18080103 	stmdane	r8, {r0, r1, r8}
    8728:	03000008 	movweq	r0, #8
    872c:	06fc0502 	ldrbteq	r0, [ip], r2, lsl #10
    8730:	02030000 	andeq	r0, r3, #0
    8734:	00094907 	andeq	r4, r9, r7, lsl #18
    8738:	05040300 	streq	r0, [r4, #-768]	; 0x300
    873c:	000004da 	ldrdeq	r0, [r0], -sl
    8740:	000abf02 	andeq	fp, sl, r2, lsl #30
    8744:	79380300 	ldmdbvc	r8!, {r8, r9}
    8748:	03000000 	movweq	r0, #0
    874c:	02520704 	subseq	r0, r2, #4, 14	; 0x100000
    8750:	08030000 	stmdaeq	r3, {}	; <UNPREDICTABLE>
    8754:	0004d505 	andeq	sp, r4, r5, lsl #10
    8758:	07080300 	streq	r0, [r8, -r0, lsl #6]
    875c:	0000024d 	andeq	r0, r0, sp, asr #4
    8760:	8b070403 	blhi	1c9774 <_etext+0x1c2160>
    8764:	06000007 	streq	r0, [r0], -r7
    8768:	00005204 	andeq	r5, r0, r4, lsl #4
    876c:	08010300 	stmdaeq	r1, {r8, r9}
    8770:	00000821 	andeq	r0, r0, r1, lsr #16
    8774:	00a80406 	adceq	r0, r8, r6, lsl #8
    8778:	9b070000 	blls	1c8780 <_etext+0x1c116c>
    877c:	02000000 	andeq	r0, r0, #0
    8780:	00000adb 	ldrdeq	r0, [r0], -fp
    8784:	00472a04 	subeq	r2, r7, r4, lsl #20
    8788:	c1020000 	mrsgt	r0, (UNDEF: 2)
    878c:	0400000a 	streq	r0, [r0], #-10
    8790:	00006e42 	andeq	r6, r0, r2, asr #28
    8794:	33750800 	cmncc	r5, #0, 16
    8798:	27050032 	smladxcs	r5, r2, r0, r0
    879c:	00000079 	andeq	r0, r0, r9, ror r0
    87a0:	00035a02 	andeq	r5, r3, r2, lsl #20
    87a4:	d92f0500 	stmdble	pc!, {r8, sl}	; <UNPREDICTABLE>
    87a8:	09000000 	stmdbeq	r0, {}	; <UNPREDICTABLE>
    87ac:	00000079 	andeq	r0, r0, r9, ror r0
    87b0:	3705010a 	strcc	r0, [r5, -sl, lsl #2]
    87b4:	000000f3 	strdeq	r0, [r0], -r3
    87b8:	0007530b 	andeq	r5, r7, fp, lsl #6
    87bc:	a70b0000 	strge	r0, [fp, -r0]
    87c0:	01000001 	tsteq	r0, r1
    87c4:	052d0200 	streq	r0, [sp, #-512]!	; 0x200
    87c8:	37050000 	strcc	r0, [r5, -r0]
    87cc:	000000de 	ldrdeq	r0, [r0], -lr
    87d0:	0c06680c 	stceq	8, cr6, [r6], {12}
    87d4:	0000012b 	andeq	r0, r0, fp, lsr #2
    87d8:	0019090d 	andseq	r0, r9, sp, lsl #18
    87dc:	2b0e0600 	blcs	389fe4 <_etext+0x3829d0>
    87e0:	00000001 	andeq	r0, r0, r1
    87e4:	0017b90d 	andseq	fp, r7, sp, lsl #18
    87e8:	3b0f0600 	blcc	3c9ff0 <_etext+0x3c29dc>
    87ec:	08000001 	stmdaeq	r0, {r0}
    87f0:	00046c0d 	andeq	r6, r4, sp, lsl #24
    87f4:	4b100600 	blmi	409ffc <_etext+0x4029e8>
    87f8:	28000001 	stmdacs	r0, {r0}
    87fc:	00790e00 	rsbseq	r0, r9, r0, lsl #28
    8800:	013b0000 	teqeq	fp, r0
    8804:	8e0f0000 	cdphi	0, 0, cr0, cr15, cr0, {0}
    8808:	01000000 	mrseq	r0, (UNDEF: 0)
    880c:	00790e00 	rsbseq	r0, r9, r0, lsl #28
    8810:	014b0000 	mrseq	r0, (UNDEF: 75)
    8814:	8e0f0000 	cdphi	0, 0, cr0, cr15, cr0, {0}
    8818:	07000000 	streq	r0, [r0, -r0]
    881c:	00520e00 	subseq	r0, r2, r0, lsl #28
    8820:	015b0000 	cmpeq	fp, r0
    8824:	8e0f0000 	cdphi	0, 0, cr0, cr15, cr0, {0}
    8828:	3f000000 	svccc	0x00000000
    882c:	13970200 	orrsne	r0, r7, #0, 4
    8830:	12060000 	andne	r0, r6, #0
    8834:	000000fe 	strdeq	r0, [r0], -lr
    8838:	000b5910 	andeq	r5, fp, r0, lsl r9
    883c:	0d071400 	cfstrseq	mvf1, [r7, #-0]
    8840:	000001bb 			; <UNDEFINED> instruction: 0x000001bb
    8844:	000b510d 	andeq	r5, fp, sp, lsl #2
    8848:	b80e0700 	stmdalt	lr, {r8, r9, sl}
    884c:	00000000 	andeq	r0, r0, r0
    8850:	000b090d 	andeq	r0, fp, sp, lsl #18
    8854:	b8100700 	ldmdalt	r0, {r8, r9, sl}
    8858:	04000000 	streq	r0, [r0], #-0
    885c:	000aca0d 	andeq	ip, sl, sp, lsl #20
    8860:	b8110700 	ldmdalt	r1, {r8, r9, sl}
    8864:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    8868:	000afa0d 	andeq	pc, sl, sp, lsl #20
    886c:	b8130700 	ldmdalt	r3, {r8, r9, sl}
    8870:	0c000000 	stceq	0, cr0, [r0], {-0}
    8874:	000bb90d 	andeq	fp, fp, sp, lsl #18
    8878:	b8140700 	ldmdalt	r4, {r8, r9, sl}
    887c:	10000000 	andne	r0, r0, r0
    8880:	000bb00d 	andeq	fp, fp, sp
    8884:	bb150700 	bllt	54a48c <_etext+0x542e78>
    8888:	14000001 	strne	r0, [r0], #-1
    888c:	00ad0e00 	adceq	r0, sp, r0, lsl #28
    8890:	01ca0000 	biceq	r0, sl, r0
    8894:	8e110000 	cdphi	0, 1, cr0, cr1, cr0, {0}
    8898:	00000000 	andeq	r0, r0, r0
    889c:	000b5a02 	andeq	r5, fp, r2, lsl #20
    88a0:	66160700 	ldrvs	r0, [r6], -r0, lsl #14
    88a4:	10000001 	andne	r0, r0, r1
    88a8:	00000be7 	andeq	r0, r0, r7, ror #23
    88ac:	1e180714 	mrcne	7, 0, r0, cr8, cr4, {0}
    88b0:	0d000002 	stceq	0, cr0, [r0, #-8]
    88b4:	00000b8c 	andeq	r0, r0, ip, lsl #23
    88b8:	021e1907 	andseq	r1, lr, #114688	; 0x1c000
    88bc:	0d000000 	stceq	0, cr0, [r0, #-0]
    88c0:	00000bcb 	andeq	r0, r0, fp, asr #23
    88c4:	00b81a07 	adcseq	r1, r8, r7, lsl #20
    88c8:	0d040000 	stceq	0, cr0, [r4, #-0]
    88cc:	00000c25 	andeq	r0, r0, r5, lsr #24
    88d0:	00252007 	eoreq	r2, r5, r7
    88d4:	0d080000 	stceq	0, cr0, [r8, #-0]
    88d8:	00000ba9 	andeq	r0, r0, r9, lsr #23
    88dc:	00392207 	eorseq	r2, r9, r7, lsl #4
    88e0:	0d0c0000 	stceq	0, cr0, [ip, #-0]
    88e4:	00000b36 	andeq	r0, r0, r6, lsr fp
    88e8:	00392307 	eorseq	r2, r9, r7, lsl #6
    88ec:	00100000 	andseq	r0, r0, r0
    88f0:	01ca0406 	biceq	r0, sl, r6, lsl #8
    88f4:	e8020000 	stmda	r2, {}	; <UNPREDICTABLE>
    88f8:	0700000b 	streq	r0, [r0, -fp]
    88fc:	0001d524 	andeq	sp, r1, r4, lsr #10
    8900:	0c070200 	sfmeq	f0, 4, [r7], {-0}
    8904:	27070000 	strcs	r0, [r7, -r0]
    8908:	0000023a 	andeq	r0, r0, sl, lsr r2
    890c:	01d50406 	bicseq	r0, r5, r6, lsl #8
    8910:	32100000 	andscc	r0, r0, #0
    8914:	1000001b 	andne	r0, r0, fp, lsl r0
    8918:	027d3807 	rsbseq	r3, sp, #458752	; 0x70000
    891c:	7f0d0000 	svcvc	0x000d0000
    8920:	0700001a 	smladeq	r0, sl, r0, r0
    8924:	0000b839 	andeq	fp, r0, r9, lsr r8
    8928:	0a0d0000 	beq	348930 <_etext+0x34131c>
    892c:	0700001a 	smladeq	r0, sl, r0, r0
    8930:	0000b83a 	andeq	fp, r0, sl, lsr r8
    8934:	8c0d0400 	cfstrshi	mvf0, [sp], {-0}
    8938:	0700001a 	smladeq	r0, sl, r0, r0
    893c:	0000b83b 	andeq	fp, r0, fp, lsr r8
    8940:	9e0d0800 	cdpls	8, 0, cr0, cr13, cr0, {0}
    8944:	0700001a 	smladeq	r0, sl, r0, r0
    8948:	0000b83c 	andeq	fp, r0, ip, lsr r8
    894c:	02000c00 	andeq	r0, r0, #0, 24
    8950:	00001b32 	andeq	r1, r0, r2, lsr fp
    8954:	02403d07 	subeq	r3, r0, #448	; 0x1c0
    8958:	c4100000 	ldrgt	r0, [r0], #-0
    895c:	4400001a 	strmi	r0, [r0], #-26
    8960:	02ad3f07 	adceq	r3, sp, #7, 30
    8964:	9e0d0000 	cdpls	0, 0, cr0, cr13, cr0, {0}
    8968:	0700001a 	smladeq	r0, sl, r0, r0
    896c:	0000b840 	andeq	fp, r0, r0, asr #16
    8970:	190d0000 	stmdbne	sp, {}	; <UNPREDICTABLE>
    8974:	0700001b 	smladeq	r0, fp, r0, r0
    8978:	0002ad41 	andeq	sl, r2, r1, asr #26
    897c:	0e000400 	cfcpyseq	mvf0, mvf0
    8980:	000000ad 	andeq	r0, r0, sp, lsr #1
    8984:	000002bd 			; <UNDEFINED> instruction: 0x000002bd
    8988:	00008e0f 	andeq	r8, r0, pc, lsl #28
    898c:	02003f00 	andeq	r3, r0, #0, 30
    8990:	00001ac4 	andeq	r1, r0, r4, asr #21
    8994:	02884207 	addeq	r4, r8, #1879048192	; 0x70000000
    8998:	6f100000 	svcvs	0x00100000
    899c:	5400001a 	strpl	r0, [r0], #-26
    89a0:	02ed4507 	rsceq	r4, sp, #29360128	; 0x1c00000
    89a4:	5e0d0000 	cdppl	0, 0, cr0, cr13, cr0, {0}
    89a8:	0700001a 	smladeq	r0, sl, r0, r0
    89ac:	00027d46 	andeq	r7, r2, r6, asr #26
    89b0:	b50d0000 	strlt	r0, [sp, #-0]
    89b4:	0700001a 	smladeq	r0, sl, r0, r0
    89b8:	0002bd47 	andeq	fp, r2, r7, asr #26
    89bc:	02001000 	andeq	r1, r0, #0
    89c0:	00001a6f 	andeq	r1, r0, pc, ror #20
    89c4:	02c84807 	sbceq	r4, r8, #458752	; 0x70000
    89c8:	04060000 	streq	r0, [r6], #-0
    89cc:	000002ed 	andeq	r0, r0, sp, ror #5
    89d0:	001b2812 	andseq	r2, fp, r2, lsl r8
    89d4:	a0260100 	eorge	r0, r6, r0, lsl #2
    89d8:	4400005a 	strmi	r0, [r0], #-90	; 0x5a
    89dc:	01000000 	mrseq	r0, (UNDEF: 0)
    89e0:	00039a9c 	muleq	r3, ip, sl
    89e4:	5aa81300 	bpl	fea0d5ec <BootRAM+0xd97dd8d>
    89e8:	06e50000 	strbteq	r0, [r5], r0
    89ec:	032a0000 	teqeq	sl, #0
    89f0:	01140000 	tsteq	r4, r0
    89f4:	000c0550 	andeq	r0, ip, r0, asr r5
    89f8:	00080080 	andeq	r0, r8, r0, lsl #1
    89fc:	005aae13 	subseq	sl, sl, r3, lsl lr
    8a00:	0006e500 	andeq	lr, r6, r0, lsl #10
    8a04:	00034100 	andeq	r4, r3, r0, lsl #2
    8a08:	50011400 	andpl	r1, r1, r0, lsl #8
    8a0c:	84000c05 	strhi	r0, [r0], #-3077	; 0xc05
    8a10:	13000800 	movwne	r0, #2048	; 0x800
    8a14:	00005ab4 			; <UNDEFINED> instruction: 0x00005ab4
    8a18:	000006e5 	andeq	r0, r0, r5, ror #13
    8a1c:	00000358 	andeq	r0, r0, r8, asr r3
    8a20:	05500114 	ldrbeq	r0, [r0, #-276]	; 0x114
    8a24:	0083200c 	addeq	r2, r3, ip
    8a28:	ba130008 	blt	4c8a50 <_etext+0x4c143c>
    8a2c:	e500005a 	str	r0, [r0, #-90]	; 0x5a
    8a30:	6f000006 	svcvs	0x00000006
    8a34:	14000003 	strne	r0, [r0], #-3
    8a38:	0c055001 	stceq	0, cr5, [r5], {1}
    8a3c:	080084b0 	stmdaeq	r0, {r4, r5, r7, sl, pc}
    8a40:	5ac01300 	bpl	ff00d648 <BootRAM+0xdf7dde9>
    8a44:	06e50000 	strbteq	r0, [r5], r0
    8a48:	03860000 	orreq	r0, r6, #0
    8a4c:	01140000 	tsteq	r4, r0
    8a50:	400c0550 	andmi	r0, ip, r0, asr r5
    8a54:	00080086 	andeq	r0, r8, r6, lsl #1
    8a58:	005aca15 	subseq	ip, sl, r5, lsl sl
    8a5c:	0006e500 	andeq	lr, r6, r0, lsl #10
    8a60:	50011400 	andpl	r1, r1, r0, lsl #8
    8a64:	87d00c05 	ldrbhi	r0, [r0, r5, lsl #24]
    8a68:	00000800 	andeq	r0, r0, r0, lsl #16
    8a6c:	000b6c16 	andeq	r6, fp, r6, lsl ip
    8a70:	39300100 	ldmdbcc	r0!, {r8}
    8a74:	e4000000 	str	r0, [r0], #-0
    8a78:	5800005a 	stmdapl	r0, {r1, r3, r4, r6}
    8a7c:	01000001 	tsteq	r0, r1
    8a80:	0006539c 	muleq	r6, ip, r3
    8a84:	1a651700 	bne	194e68c <_etext+0x1947078>
    8a88:	30010000 	andcc	r0, r1, r0
    8a8c:	00000653 	andeq	r0, r0, r3, asr r6
    8a90:	000083be 			; <UNDEFINED> instruction: 0x000083be
    8a94:	001aa817 	andseq	sl, sl, r7, lsl r8
    8a98:	ce300100 	rsfgts	f0, f0, f0
    8a9c:	ea000000 	b	8aa4 <_etext+0x1490>
    8aa0:	17000083 	strne	r0, [r0, -r3, lsl #1]
    8aa4:	00001ae6 	andeq	r1, r0, r6, ror #21
    8aa8:	00f33001 	rscseq	r3, r3, r1
    8aac:	84170000 	ldrhi	r0, [r7], #-0
    8ab0:	68180000 	ldmdavs	r8, {}	; <UNPREDICTABLE>
    8ab4:	01007264 	tsteq	r0, r4, ror #4
    8ab8:	0002f832 	andeq	pc, r2, r2, lsr r8	; <UNPREDICTABLE>
    8abc:	00843800 	addeq	r3, r4, r0, lsl #16
    8ac0:	17b91900 	ldrne	r1, [r9, r0, lsl #18]!
    8ac4:	33010000 	movwcc	r0, #4096	; 0x1000
    8ac8:	00000224 	andeq	r0, r0, r4, lsr #4
    8acc:	7da49103 	stfvcd	f1, [r4, #12]!
    8ad0:	001b051a 	andseq	r0, fp, sl, lsl r5
    8ad4:	39340100 	ldmdbcc	r4!, {r8}
    8ad8:	68000000 	stmdavs	r0, {}	; <UNPREDICTABLE>
    8adc:	001ada1b 	andseq	sp, sl, fp, lsl sl
    8ae0:	59350100 	ldmdbpl	r5!, {r8}
    8ae4:	5c000006 	stcpl	0, cr0, [r0], {6}
    8ae8:	19000084 	stmdbne	r0, {r2, r7}
    8aec:	00001272 	andeq	r1, r0, r2, ror r2
    8af0:	066b6001 	strbteq	r6, [fp], -r1
    8af4:	91030000 	mrsls	r0, (UNDEF: 3)
    8af8:	631c7db8 	tstvs	ip, #184, 26	; 0x2e00
    8afc:	01007874 	tsteq	r0, r4, ror r8
    8b00:	00015b64 	andeq	r5, r1, r4, ror #22
    8b04:	98910300 	ldmls	r1, {r8, r9}
    8b08:	1a951b7e 	bne	fe54f908 <BootRAM+0xd4c00a9>
    8b0c:	67010000 	strvs	r0, [r1, -r0]
    8b10:	00000039 	andeq	r0, r0, r9, lsr r0
    8b14:	000084b0 			; <UNDEFINED> instruction: 0x000084b0
    8b18:	00068e1d 	andeq	r8, r6, sp, lsl lr
    8b1c:	0084c400 	addeq	ip, r4, r0, lsl #8
    8b20:	1b001e00 	blne	10328 <_etext+0x8d14>
    8b24:	68010000 	stmdavs	r1, {}	; <UNPREDICTABLE>
    8b28:	0000067b 	andeq	r0, r0, fp, ror r6
    8b2c:	01006918 	tsteq	r0, r8, lsl r9
    8b30:	0000396a 	andeq	r3, r0, sl, ror #18
    8b34:	0084d800 	addeq	sp, r4, r0, lsl #16
    8b38:	1a851b00 	bne	fe14f740 <BootRAM+0xd0bfee1>
    8b3c:	6b010000 	blvs	48b44 <_etext+0x41530>
    8b40:	00000693 	muleq	r0, r3, r6
    8b44:	000084f8 	strdeq	r8, [r0], -r8	; <UNPREDICTABLE>
    8b48:	0019a01b 	andseq	sl, r9, fp, lsl r0
    8b4c:	396e0100 	stmdbcc	lr!, {r8}^
    8b50:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    8b54:	1e000085 	cdpne	0, 0, cr0, cr0, cr5, {4}
    8b58:	00001b10 	andeq	r1, r0, r0, lsl fp
    8b5c:	06a38b01 	strteq	r8, [r3], r1, lsl #22
    8b60:	891f0000 	ldmdbhi	pc, {}	; <UNPREDICTABLE>
    8b64:	0100000d 	tsteq	r0, sp
    8b68:	00003997 	muleq	r0, r7, r9
    8b6c:	0004a100 	andeq	sl, r4, r0, lsl #2
    8b70:	19002000 	stmdbne	r0, {sp}
    8b74:	00001afd 	strdeq	r1, [r0], -sp
    8b78:	02ad9901 	adceq	r9, sp, #16384	; 0x4000
    8b7c:	91030000 	mrsls	r0, (UNDEF: 3)
    8b80:	fa137dd8 	blx	4e82e8 <_etext+0x4e0cd4>
    8b84:	fb00005a 	blx	8cf6 <_etext+0x16e2>
    8b88:	d1000006 	tstle	r0, r6
    8b8c:	14000004 	strne	r0, [r0], #-4
    8b90:	08025201 	stmdaeq	r2, {r0, r9, ip, lr}
    8b94:	51011468 	tstpl	r1, r8, ror #8
    8b98:	14ff0802 	ldrbtne	r0, [pc], #2050	; 8ba0 <_etext+0x158c>
    8b9c:	91035001 	tstls	r3, r1
    8ba0:	13007f80 	movwne	r7, #3968	; 0xf80
    8ba4:	00005b06 	andeq	r5, r0, r6, lsl #22
    8ba8:	0000071a 	andeq	r0, r0, sl, lsl r7
    8bac:	000004ec 	andeq	r0, r0, ip, ror #9
    8bb0:	02520114 	subseq	r0, r2, #20, 2
    8bb4:	01146808 	tsteq	r4, r8, lsl #16
    8bb8:	80910350 	addshi	r0, r1, r0, asr r3
    8bbc:	1013007f 	andsne	r0, r3, pc, ror r0
    8bc0:	3e00005b 	mcrcc	0, 0, r0, cr0, cr11, {2}
    8bc4:	0a000007 	beq	8be8 <_etext+0x15d4>
    8bc8:	14000005 	strne	r0, [r0], #-5
    8bcc:	44015201 	strmi	r5, [r1], #-513	; 0x201
    8bd0:	01510114 	cmpeq	r1, r4, lsl r1
    8bd4:	50011430 	andpl	r1, r1, r0, lsr r4
    8bd8:	00007602 	andeq	r7, r0, r2, lsl #12
    8bdc:	005b2a21 	subseq	r2, fp, r1, lsr #20
    8be0:	00075b00 	andeq	r5, r7, r0, lsl #22
    8be4:	5b382100 	blpl	e10fec <_etext+0xe099d8>
    8be8:	02fe0000 	rscseq	r0, lr, #0
    8bec:	4a130000 	bmi	4c8bf4 <_etext+0x4c15e0>
    8bf0:	5b00005b 	blpl	8d64 <_etext+0x1750>
    8bf4:	33000007 	movwcc	r0, #7
    8bf8:	14000005 	strne	r0, [r0], #-5
    8bfc:	03055001 	movweq	r5, #20481	; 0x5001
    8c00:	00007584 	andeq	r7, r0, r4, lsl #11
    8c04:	5b5e1300 	blpl	178d80c <_etext+0x17861f8>
    8c08:	06fb0000 	ldrbteq	r0, [fp], r0
    8c0c:	05540000 	ldrbeq	r0, [r4, #-0]
    8c10:	01140000 	tsteq	r4, r0
    8c14:	20080252 	andcs	r0, r8, r2, asr r2
    8c18:	02510114 	subseq	r0, r1, #20, 2
    8c1c:	0114ff08 	tsteq	r4, r8, lsl #30
    8c20:	b8910350 	ldmlt	r1, {r4, r6, r8, r9}
    8c24:	6413007d 	ldrvs	r0, [r3], #-125	; 0x7d
    8c28:	6e00005b 	mcrvs	0, 0, r0, cr0, cr11, {2}
    8c2c:	69000007 	stmdbvs	r0, {r0, r1, r2}
    8c30:	14000005 	strne	r0, [r0], #-5
    8c34:	91035001 	tstls	r3, r1
    8c38:	13007e98 	movwne	r7, #3736	; 0xe98
    8c3c:	00005b6e 	andeq	r5, r0, lr, ror #22
    8c40:	00000785 	andeq	r0, r0, r5, lsl #15
    8c44:	0000057c 	andeq	r0, r0, ip, ror r5
    8c48:	01510114 	cmpeq	r1, r4, lsl r1
    8c4c:	80130040 	andshi	r0, r3, r0, asr #32
    8c50:	5b00005b 	blpl	8dc4 <_etext+0x17b0>
    8c54:	93000007 	movwls	r0, #7
    8c58:	14000005 	strne	r0, [r0], #-5
    8c5c:	03055001 	movweq	r5, #20481	; 0x5001
    8c60:	00007594 	muleq	r0, r4, r5
    8c64:	5b941300 	blpl	fe50d86c <BootRAM+0xd47e00d>
    8c68:	079c0000 	ldreq	r0, [ip, r0]
    8c6c:	05ad0000 	streq	r0, [sp, #0]!
    8c70:	01140000 	tsteq	r4, r0
    8c74:	14310152 	ldrtne	r0, [r1], #-338	; 0x152
    8c78:	91035001 	tstls	r3, r1
    8c7c:	13007e98 	movwne	r7, #3736	; 0xe98
    8c80:	00005ba2 	andeq	r5, r0, r2, lsr #23
    8c84:	0000075b 	andeq	r0, r0, fp, asr r7
    8c88:	000005c4 	andeq	r0, r0, r4, asr #11
    8c8c:	05500114 	ldrbeq	r0, [r0, #-276]	; 0x114
    8c90:	0075aa03 	rsbseq	sl, r5, r3, lsl #20
    8c94:	ac130000 	ldcge	0, cr0, [r3], {-0}
    8c98:	8500005b 	strhi	r0, [r0, #-91]	; 0x5b
    8c9c:	d7000007 	strle	r0, [r0, -r7]
    8ca0:	14000005 	strne	r0, [r0], #-5
    8ca4:	40015101 	andmi	r5, r1, r1, lsl #2
    8ca8:	5bbe1300 	blpl	fef8d8b0 <BootRAM+0xdefe051>
    8cac:	075b0000 	ldrbeq	r0, [fp, -r0]
    8cb0:	05ee0000 	strbeq	r0, [lr, #0]!
    8cb4:	01140000 	tsteq	r4, r0
    8cb8:	b8030550 	stmdalt	r3, {r4, r6, r8, sl}
    8cbc:	00000075 	andeq	r0, r0, r5, ror r0
    8cc0:	005bcc13 	subseq	ip, fp, r3, lsl ip
    8cc4:	0007b700 	andeq	fp, r7, r0, lsl #14
    8cc8:	00060a00 	andeq	r0, r6, r0, lsl #20
    8ccc:	51011400 	tstpl	r1, r0, lsl #8
    8cd0:	7db89103 	ldfvcd	f1, [r8, #12]!
    8cd4:	03500114 	cmpeq	r0, #20, 2
    8cd8:	007e9891 			; <UNDEFINED> instruction: 0x007e9891
    8cdc:	005bd613 	subseq	sp, fp, r3, lsl r6
    8ce0:	0007cd00 	andeq	ip, r7, r0, lsl #26
    8ce4:	00061f00 	andeq	r1, r6, r0, lsl #30
    8ce8:	50011400 	andpl	r1, r1, r0, lsl #8
    8cec:	7db89103 	ldfvcd	f1, [r8, #12]!
    8cf0:	5bf61300 	blpl	ffd8d8f8 <BootRAM+0xecfe099>
    8cf4:	07de0000 	ldrbeq	r0, [lr, r0]
    8cf8:	06490000 	strbeq	r0, [r9], -r0
    8cfc:	01140000 	tsteq	r4, r0
    8d00:	20080253 	andcs	r0, r8, r3, asr r2
    8d04:	03520114 	cmpeq	r2, #20, 2
    8d08:	147db891 	ldrbtne	fp, [sp], #-2193	; 0x891
    8d0c:	03055101 	movweq	r5, #20737	; 0x5101
    8d10:	20000404 	andcs	r0, r0, r4, lsl #8
    8d14:	02500114 	subseq	r0, r0, #20, 2
    8d18:	21005074 	tstcs	r0, r4, ror r0
    8d1c:	00005c06 	andeq	r5, r0, r6, lsl #24
    8d20:	000002fe 	strdeq	r0, [r0], -lr
    8d24:	2f040600 	svccs	0x00040600
    8d28:	0e000002 	cdpeq	0, 0, cr0, cr0, cr2, {0}
    8d2c:	00000052 	andeq	r0, r0, r2, asr r0
    8d30:	0000066b 	andeq	r0, r0, fp, ror #12
    8d34:	00008e22 	andeq	r8, r0, r2, lsr #28
    8d38:	67080200 	strvs	r0, [r8, -r0, lsl #4]
    8d3c:	00520e00 	subseq	r0, r2, r0, lsl #28
    8d40:	067b0000 	ldrbteq	r0, [fp], -r0
    8d44:	8e0f0000 	cdphi	0, 0, cr0, cr15, cr0, {0}
    8d48:	1f000000 	svcne	0x00000000
    8d4c:	009b0e00 	addseq	r0, fp, r0, lsl #28
    8d50:	068e0000 	streq	r0, [lr], r0
    8d54:	8e230000 	cdphi	0, 2, cr0, cr3, cr0, {0}
    8d58:	46000000 	strmi	r0, [r0], -r0
    8d5c:	00000004 	andeq	r0, r0, r4
    8d60:	00008e07 	andeq	r8, r0, r7, lsl #28
    8d64:	009b0e00 	addseq	r0, fp, r0, lsl #28
    8d68:	06a30000 	strteq	r0, [r3], r0
    8d6c:	8e0f0000 	cdphi	0, 0, cr0, cr15, cr0, {0}
    8d70:	04000000 	streq	r0, [r0], #-0
    8d74:	00520e00 	subseq	r0, r2, r0, lsl #28
    8d78:	06b30000 	ldrteq	r0, [r3], r0
    8d7c:	8e0f0000 	cdphi	0, 0, cr0, cr15, cr0, {0}
    8d80:	16000000 	strne	r0, [r0], -r0
    8d84:	00b12400 	adcseq	r2, r1, r0, lsl #8
    8d88:	2c080000 	stccs	0, cr0, [r8], {-0}
    8d8c:	00000039 	andeq	r0, r0, r9, lsr r0
    8d90:	04880305 	streq	r0, [r8], #773	; 0x305
    8d94:	ad0e2000 	stcge	0, cr2, [lr, #-0]
    8d98:	d4000000 	strle	r0, [r0], #-0
    8d9c:	0f000006 	svceq	0x00000006
    8da0:	0000008e 	andeq	r0, r0, lr, lsl #1
    8da4:	bd24001f 	stclt	0, cr0, [r4, #-124]!	; 0xffffff84
    8da8:	0100001a 	tsteq	r0, sl, lsl r0
    8dac:	0006c418 	andeq	ip, r6, r8, lsl r4
    8db0:	04030500 	streq	r0, [r3], #-1280	; 0x500
    8db4:	25200004 	strcs	r0, [r0, #-4]!
    8db8:	00000c40 	andeq	r0, r0, r0, asr #24
    8dbc:	f3013409 	vshl.u8	d3, d9, d1
    8dc0:	fb000000 	blx	8dca <_etext+0x17b6>
    8dc4:	26000006 	strcs	r0, [r0], -r6
    8dc8:	000000c3 	andeq	r0, r0, r3, asr #1
    8dcc:	0ff12700 	svceq	0x00f12700
    8dd0:	190a0000 	stmdbne	sl, {}	; <UNPREDICTABLE>
    8dd4:	00000037 	andeq	r0, r0, r7, lsr r0
    8dd8:	0000071a 	andeq	r0, r0, sl, lsl r7
    8ddc:	00003726 	andeq	r3, r0, r6, lsr #14
    8de0:	00392600 	eorseq	r2, r9, r0, lsl #12
    8de4:	25260000 	strcs	r0, [r6, #-0]!
    8de8:	00000000 	andeq	r0, r0, r0
    8dec:	0015c428 	andseq	ip, r5, r8, lsr #8
    8df0:	00003700 	andeq	r3, r0, r0, lsl #14
    8df4:	00073700 	andeq	r3, r7, r0, lsl #14
    8df8:	00372600 	eorseq	r2, r7, r0, lsl #12
    8dfc:	37260000 	strcc	r0, [r6, -r0]!
    8e00:	26000007 	strcs	r0, [r0], -r7
    8e04:	0000008e 	andeq	r0, r0, lr, lsl #1
    8e08:	3d040600 	stccc	6, cr0, [r4, #-0]
    8e0c:	29000007 	stmdbcs	r0, {r0, r1, r2}
    8e10:	000ff128 	andeq	pc, pc, r8, lsr #2
    8e14:	00003700 	andeq	r3, r0, r0, lsl #14
    8e18:	00075b00 	andeq	r5, r7, r0, lsl #22
    8e1c:	00372600 	eorseq	r2, r7, r0, lsl #12
    8e20:	39260000 	stmdbcc	r6!, {}	; <UNPREDICTABLE>
    8e24:	26000000 	strcs	r0, [r0], -r0
    8e28:	0000008e 	andeq	r0, r0, lr, lsl #1
    8e2c:	0ab32a00 	beq	fecd3634 <BootRAM+0xdc43dd5>
    8e30:	3f090000 	svccc	0x00090000
    8e34:	00076e01 	andeq	r6, r7, r1, lsl #28
    8e38:	00a22600 	adceq	r2, r2, r0, lsl #12
    8e3c:	00200000 	eoreq	r0, r0, r0
    8e40:	0013272b 	andseq	r2, r3, fp, lsr #14
    8e44:	7f140600 	svcvc	0x00140600
    8e48:	26000007 	strcs	r0, [r0], -r7
    8e4c:	0000077f 	andeq	r0, r0, pc, ror r7
    8e50:	5b040600 	blpl	10a658 <_etext+0x103044>
    8e54:	2a000001 	bcs	8e60 <_etext+0x184c>
    8e58:	00000d21 	andeq	r0, r0, r1, lsr #26
    8e5c:	9c014009 	stcls	0, cr4, [r1], {9}
    8e60:	26000007 	strcs	r0, [r0], -r7
    8e64:	00000095 	muleq	r0, r5, r0
    8e68:	00002526 	andeq	r2, r0, r6, lsr #10
    8e6c:	cf2b0000 	svcgt	0x002b0000
    8e70:	06000019 			; <UNDEFINED> instruction: 0x06000019
    8e74:	0007b715 	andeq	fp, r7, r5, lsl r7
    8e78:	077f2600 	ldrbeq	r2, [pc, -r0, lsl #12]!
    8e7c:	95260000 	strls	r0, [r6, #-0]!
    8e80:	26000000 	strcs	r0, [r0], -r0
    8e84:	00000079 	andeq	r0, r0, r9, ror r0
    8e88:	19992b00 	ldmibne	r9, {r8, r9, fp, sp}
    8e8c:	16060000 	strne	r0, [r6], -r0
    8e90:	000007cd 	andeq	r0, r0, sp, asr #15
    8e94:	00077f26 	andeq	r7, r7, r6, lsr #30
    8e98:	00952600 	addseq	r2, r5, r0, lsl #12
    8e9c:	1f000000 	svcne	0x00000000
    8ea0:	00000d89 	andeq	r0, r0, r9, lsl #27
    8ea4:	00399701 	eorseq	r9, r9, r1, lsl #14
    8ea8:	07de0000 	ldrbeq	r0, [lr, r0]
    8eac:	00200000 	eoreq	r0, r0, r0
    8eb0:	0017bf27 	andseq	fp, r7, r7, lsr #30
    8eb4:	ad2f0b00 	vstmdbge	pc!, {d0-d-1}
    8eb8:	02000000 	andeq	r0, r0, #0
    8ebc:	26000008 	strcs	r0, [r0], -r8
    8ec0:	00000802 	andeq	r0, r0, r2, lsl #16
    8ec4:	00080226 	andeq	r0, r8, r6, lsr #4
    8ec8:	08022600 	stmdaeq	r2, {r9, sl, sp}
    8ecc:	25260000 	strcs	r0, [r6, #-0]!
    8ed0:	00000000 	andeq	r0, r0, r0
    8ed4:	08080406 	stmdaeq	r8, {r1, r2, sl}
    8ed8:	ad070000 	stcge	0, cr0, [r7, #-0]
    8edc:	00000000 	andeq	r0, r0, r0
    8ee0:	00000c88 	andeq	r0, r0, r8, lsl #25
    8ee4:	21440004 	cmpcs	r4, r4
    8ee8:	01040000 	mrseq	r0, (UNDEF: 4)
    8eec:	00000639 	andeq	r0, r0, r9, lsr r6
    8ef0:	001cb301 	andseq	fp, ip, r1, lsl #6
    8ef4:	00089300 	andeq	r9, r8, r0, lsl #6
    8ef8:	000c8800 	andeq	r8, ip, r0, lsl #16
    8efc:	00000000 	andeq	r0, r0, r0
    8f00:	00335e00 	eorseq	r5, r3, r0, lsl #28
    8f04:	05040200 	streq	r0, [r4, #-512]	; 0x200
    8f08:	000004da 	ldrdeq	r0, [r0], -sl
    8f0c:	fc050202 	stc2	2, cr0, [r5], {2}
    8f10:	02000006 	andeq	r0, r0, #6
    8f14:	081a0601 	ldmdaeq	sl, {r0, r9, sl}
    8f18:	75030000 	strvc	r0, [r3, #-0]
    8f1c:	02003233 	andeq	r3, r0, #805306371	; 0x30000003
    8f20:	00004524 	andeq	r4, r0, r4, lsr #10
    8f24:	07040200 	streq	r0, [r4, -r0, lsl #4]
    8f28:	00000252 	andeq	r0, r0, r2, asr r2
    8f2c:	36317503 	ldrtcc	r7, [r1], -r3, lsl #10
    8f30:	57250200 	strpl	r0, [r5, -r0, lsl #4]!
    8f34:	02000000 	andeq	r0, r0, #0
    8f38:	09490702 	stmdbeq	r9, {r1, r8, r9, sl}^
    8f3c:	75030000 	strvc	r0, [r3, #-0]
    8f40:	26020038 			; <UNDEFINED> instruction: 0x26020038
    8f44:	00000068 	andeq	r0, r0, r8, rrx
    8f48:	18080102 	stmdane	r8, {r1, r8}
    8f4c:	04000008 	streq	r0, [r0], #-8
    8f50:	00001bc6 	andeq	r1, r0, r6, asr #23
    8f54:	8e160301 	cdphi	3, 1, cr0, cr6, cr1, {0}
    8f58:	05000000 	streq	r0, [r0, #-0]
    8f5c:	00001cc6 	andeq	r1, r0, r6, asr #25
    8f60:	1b910500 	blne	fe44a368 <BootRAM+0xd3bab09>
    8f64:	05010000 	streq	r0, [r1, #-0]
    8f68:	00001c6d 	andeq	r1, r0, sp, ror #24
    8f6c:	c7060002 	strgt	r0, [r6, -r2]
    8f70:	0300001b 	movweq	r0, #27
    8f74:	00006f1c 	andeq	r6, r0, ip, lsl pc
    8f78:	1da20700 	stcne	7, cr0, [r2]
    8f7c:	9b010000 	blls	48f84 <_etext+0x41970>
    8f80:	0000004c 	andeq	r0, r0, ip, asr #32
    8f84:	0000b501 	andeq	fp, r0, r1, lsl #10
    8f88:	1eb80800 	cdpne	8, 11, cr0, cr8, cr0, {0}
    8f8c:	9b010000 	blls	48f94 <_etext+0x41980>
    8f90:	0000005e 	andeq	r0, r0, lr, asr r0
    8f94:	1df90900 	ldclne	9, cr0, [r9]
    8f98:	22010000 	andcs	r0, r1, #0
    8f9c:	00000000 	andeq	r0, r0, r0
    8fa0:	0000000c 	andeq	r0, r0, ip
    8fa4:	00d89c01 	sbcseq	r9, r8, r1, lsl #24
    8fa8:	980a0000 	stmdals	sl, {}	; <UNPREDICTABLE>
    8fac:	0100001d 	tsteq	r0, sp, lsl r0
    8fb0:	00004c22 	andeq	r4, r0, r2, lsr #24
    8fb4:	00500100 	subseq	r0, r0, r0, lsl #2
    8fb8:	001c000b 	andseq	r0, ip, fp
    8fbc:	4c2e0100 	stfmis	f0, [lr], #-0
    8fc0:	00000000 	andeq	r0, r0, r0
    8fc4:	0c000000 	stceq	0, cr0, [r0], {-0}
    8fc8:	01000000 	mrseq	r0, (UNDEF: 0)
    8fcc:	1bd3099c 	blne	ff4cb644 <BootRAM+0xe43bde5>
    8fd0:	3a010000 	bcc	48fd8 <_etext+0x419c4>
    8fd4:	00000000 	andeq	r0, r0, r0
    8fd8:	0000000c 	andeq	r0, r0, ip
    8fdc:	01109c01 	tsteq	r0, r1, lsl #24
    8fe0:	980a0000 	stmdals	sl, {}	; <UNPREDICTABLE>
    8fe4:	0100001d 	tsteq	r0, sp, lsl r0
    8fe8:	00004c3a 	andeq	r4, r0, sl, lsr ip
    8fec:	00500100 	subseq	r0, r0, r0, lsl #2
    8ff0:	001d900b 	andseq	r9, sp, fp
    8ff4:	4c460100 	stfmie	f0, [r6], {-0}
    8ff8:	00000000 	andeq	r0, r0, r0
    8ffc:	0c000000 	stceq	0, cr0, [r0], {-0}
    9000:	01000000 	mrseq	r0, (UNDEF: 0)
    9004:	1e640b9c 	vmovne.8	d20[4], r0
    9008:	52010000 	andpl	r0, r1, #0
    900c:	0000004c 	andeq	r0, r0, ip, asr #32
    9010:	00000000 	andeq	r0, r0, r0
    9014:	0000000c 	andeq	r0, r0, ip
    9018:	c6099c01 	strgt	r9, [r9], -r1, lsl #24
    901c:	0100001d 	tsteq	r0, sp, lsl r0
    9020:	0000005e 	andeq	r0, r0, lr, asr r0
    9024:	00000c00 	andeq	r0, r0, r0, lsl #24
    9028:	5d9c0100 	ldfpls	f0, [ip]
    902c:	0a000001 	beq	9038 <_etext+0x1a24>
    9030:	00001d98 	muleq	r0, r8, sp
    9034:	004c5e01 	subeq	r5, ip, r1, lsl #28
    9038:	50010000 	andpl	r0, r1, r0
    903c:	1c190b00 	ldcne	11, cr0, [r9], {-0}
    9040:	6a010000 	bvs	49048 <_etext+0x41a34>
    9044:	0000004c 	andeq	r0, r0, ip, asr #32
    9048:	00000000 	andeq	r0, r0, r0
    904c:	0000000c 	andeq	r0, r0, ip
    9050:	01099c01 	tsteq	r9, r1, lsl #24
    9054:	0100001e 	tsteq	r0, lr, lsl r0
    9058:	00000076 	andeq	r0, r0, r6, ror r0
    905c:	00001000 	andeq	r1, r0, r0
    9060:	959c0100 	ldrls	r0, [ip, #256]	; 0x100
    9064:	0a000001 	beq	9070 <_etext+0x1a5c>
    9068:	00001d98 	muleq	r0, r8, sp
    906c:	004c7601 	subeq	r7, ip, r1, lsl #12
    9070:	50010000 	andpl	r0, r1, r0
    9074:	1d860b00 	vstrne	d0, [r6]
    9078:	82010000 	andhi	r0, r1, #0
    907c:	0000004c 	andeq	r0, r0, ip, asr #32
    9080:	00000000 	andeq	r0, r0, r0
    9084:	0000000c 	andeq	r0, r0, ip
    9088:	bf099c01 	svclt	0x00099c01
    908c:	0100001e 	tsteq	r0, lr, lsl r0
    9090:	0000008f 	andeq	r0, r0, pc, lsl #1
    9094:	00000e00 	andeq	r0, r0, r0, lsl #28
    9098:	dc9c0100 	ldfles	f0, [ip], {0}
    909c:	0c000001 	stceq	0, cr0, [r0], {1}
    90a0:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    90a4:	005e8f01 	subseq	r8, lr, r1, lsl #30
    90a8:	85310000 	ldrhi	r0, [r1, #-0]!
    90ac:	980a0000 	stmdals	sl, {}	; <UNPREDICTABLE>
    90b0:	0100001d 	tsteq	r0, sp, lsl r0
    90b4:	00004c8f 	andeq	r4, r0, pc, lsl #25
    90b8:	00510100 	subseq	r0, r1, r0, lsl #2
    90bc:	0000990d 	andeq	r9, r0, sp, lsl #18
    90c0:	00000000 	andeq	r0, r0, r0
    90c4:	00001000 	andeq	r1, r0, r0
    90c8:	f99c0100 			; <UNDEFINED> instruction: 0xf99c0100
    90cc:	0e000001 	cdpeq	0, 0, cr0, cr0, cr1, {0}
    90d0:	000000a9 	andeq	r0, r0, r9, lsr #1
    90d4:	00008552 	andeq	r8, r0, r2, asr r5
    90d8:	1c630900 	stclne	9, cr0, [r3], #-0
    90dc:	a8010000 	stmdage	r1, {}	; <UNPREDICTABLE>
    90e0:	00000000 	andeq	r0, r0, r0
    90e4:	0000001c 	andeq	r0, r0, ip, lsl r0
    90e8:	022d9c01 	eoreq	r9, sp, #256	; 0x100
    90ec:	b80c0000 	stmdalt	ip, {}	; <UNPREDICTABLE>
    90f0:	0100001e 	tsteq	r0, lr, lsl r0
    90f4:	00005ea8 	andeq	r5, r0, r8, lsr #29
    90f8:	00857300 	addeq	r7, r5, r0, lsl #6
    90fc:	1cad0c00 	stcne	12, cr0, [sp]
    9100:	a8010000 	stmdage	r1, {}	; <UNPREDICTABLE>
    9104:	0000004c 	andeq	r0, r0, ip, asr #32
    9108:	00008594 	muleq	r0, r4, r5
    910c:	1d360f00 	ldcne	15, cr0, [r6, #-0]
    9110:	b4010000 	strlt	r0, [r1], #-0
    9114:	0000004c 	andeq	r0, r0, ip, asr #32
    9118:	00000000 	andeq	r0, r0, r0
    911c:	00000012 	andeq	r0, r0, r2, lsl r0
    9120:	02569c01 	subseq	r9, r6, #256	; 0x100
    9124:	b80c0000 	stmdalt	ip, {}	; <UNPREDICTABLE>
    9128:	0100001e 	tsteq	r0, lr, lsl r0
    912c:	00005eb4 			; <UNDEFINED> instruction: 0x00005eb4
    9130:	0085b500 	addeq	fp, r5, r0, lsl #10
    9134:	aa090000 	bge	24913c <_etext+0x241b28>
    9138:	0100001e 	tsteq	r0, lr, lsl r0
    913c:	005c3cc1 	subseq	r3, ip, r1, asr #25
    9140:	00002a00 	andeq	r2, r0, r0, lsl #20
    9144:	9f9c0100 	svcls	0x009c0100
    9148:	0c000002 	stceq	0, cr0, [r0], {2}
    914c:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    9150:	005ec101 	subseq	ip, lr, r1, lsl #2
    9154:	85d60000 	ldrbhi	r0, [r6]
    9158:	170a0000 	strne	r0, [sl, -r0]
    915c:	01000014 	tsteq	r0, r4, lsl r0
    9160:	00004cc1 	andeq	r4, r0, r1, asr #25
    9164:	10510100 	subsne	r0, r1, r0, lsl #2
    9168:	00005c3c 	andeq	r5, r0, ip, lsr ip
    916c:	0000002a 	andeq	r0, r0, sl, lsr #32
    9170:	00075e11 	andeq	r5, r7, r1, lsl lr
    9174:	4cc30100 	stfmie	f0, [r3], {0}
    9178:	01000000 	mrseq	r0, (UNDEF: 0)
    917c:	09000053 	stmdbeq	r0, {r0, r1, r4, r6}
    9180:	00001c36 	andeq	r1, r0, r6, lsr ip
    9184:	0000ce01 	andeq	ip, r0, r1, lsl #28
    9188:	002a0000 	eoreq	r0, sl, r0
    918c:	9c010000 	stcls	0, cr0, [r1], {-0}
    9190:	000002e8 	andeq	r0, r0, r8, ror #5
    9194:	001eb80c 	andseq	fp, lr, ip, lsl #16
    9198:	5ece0100 	polple	f0, f6, f0
    919c:	f7000000 			; <UNDEFINED> instruction: 0xf7000000
    91a0:	0a000085 	beq	93bc <_etext+0x1da8>
    91a4:	00001417 	andeq	r1, r0, r7, lsl r4
    91a8:	004cce01 	subeq	ip, ip, r1, lsl #28
    91ac:	51010000 	mrspl	r0, (UNDEF: 1)
    91b0:	00000010 	andeq	r0, r0, r0, lsl r0
    91b4:	00002a00 	andeq	r2, r0, r0, lsl #20
    91b8:	075e1100 	ldrbeq	r1, [lr, -r0, lsl #2]
    91bc:	d0010000 	andle	r0, r1, r0
    91c0:	0000004c 	andeq	r0, r0, ip, asr #32
    91c4:	00005301 	andeq	r5, r0, r1, lsl #6
    91c8:	001b7c09 	andseq	r7, fp, r9, lsl #24
    91cc:	00db0100 	sbcseq	r0, fp, r0, lsl #2
    91d0:	24000000 	strcs	r0, [r0], #-0
    91d4:	01000000 	mrseq	r0, (UNDEF: 0)
    91d8:	00033e9c 	muleq	r3, ip, lr
    91dc:	1eb80c00 	cdpne	12, 11, cr0, cr8, cr0, {0}
    91e0:	db010000 	blle	491e8 <_etext+0x41bd4>
    91e4:	0000005e 	andeq	r0, r0, lr, asr r0
    91e8:	00008618 	andeq	r8, r0, r8, lsl r6
    91ec:	001ca80a 	andseq	sl, ip, sl, lsl #16
    91f0:	5edb0100 	cdppl	1, 13, cr0, cr11, cr0, {0}
    91f4:	01000000 	mrseq	r0, (UNDEF: 0)
    91f8:	1e7c1251 	mrcne	2, 3, r1, cr12, cr1, {2}
    91fc:	dd010000 	stcle	0, cr0, [r1, #-0]
    9200:	0000004c 	andeq	r0, r0, ip, asr #32
    9204:	00009913 	andeq	r9, r0, r3, lsl r9
    9208:	00000000 	andeq	r0, r0, r0
    920c:	000bd800 	andeq	sp, fp, r0, lsl #16
    9210:	0ede0100 	cdpeq	1, 13, cr0, cr14, cr0, {0}
    9214:	000000a9 	andeq	r0, r0, r9, lsr #1
    9218:	00008618 	andeq	r8, r0, r8, lsl r6
    921c:	9a0f0000 	bls	3c9224 <_etext+0x3c1c10>
    9220:	0100001c 	tsteq	r0, ip, lsl r0
    9224:	00004cf0 	strdeq	r4, [r0], -r0
    9228:	00000000 	andeq	r0, r0, r0
    922c:	00001200 	andeq	r1, r0, r0, lsl #4
    9230:	679c0100 	ldrvs	r0, [ip, r0, lsl #2]
    9234:	0c000003 	stceq	0, cr0, [r0], {3}
    9238:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    923c:	005ef001 	subseq	pc, lr, r1
    9240:	86390000 	ldrthi	r0, [r9], -r0
    9244:	0f000000 	svceq	0x00000000
    9248:	00001b9d 	muleq	r0, sp, fp
    924c:	004cfc01 	subeq	pc, ip, r1, lsl #24
    9250:	00000000 	andeq	r0, r0, r0
    9254:	00120000 	andseq	r0, r2, r0
    9258:	9c010000 	stcls	0, cr0, [r1], {-0}
    925c:	00000390 	muleq	r0, r0, r3
    9260:	001eb80c 	andseq	fp, lr, ip, lsl #16
    9264:	5efc0100 	cdppl	1, 15, cr0, cr12, cr0, {0}
    9268:	5a000000 	bpl	9270 <_etext+0x1c5c>
    926c:	00000086 	andeq	r0, r0, r6, lsl #1
    9270:	001b6f14 	andseq	r6, fp, r4, lsl pc
    9274:	01080100 	mrseq	r0, (UNDEF: 24)
    9278:	00000000 	andeq	r0, r0, r0
    927c:	0000001e 	andeq	r0, r0, lr, lsl r0
    9280:	03d19c01 	bicseq	r9, r1, #256	; 0x100
    9284:	b8150000 	ldmdalt	r5, {}	; <UNPREDICTABLE>
    9288:	0100001e 	tsteq	r0, lr, lsl r0
    928c:	005e0108 	subseq	r0, lr, r8, lsl #2
    9290:	867b0000 	ldrbthi	r0, [fp], -r0
    9294:	00100000 	andseq	r0, r0, r0
    9298:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    929c:	16000000 	strne	r0, [r0], -r0
    92a0:	0000075e 	andeq	r0, r0, lr, asr r7
    92a4:	4c010a01 	stcmi	10, cr0, [r1], {1}
    92a8:	9c000000 	stcls	0, cr0, [r0], {-0}
    92ac:	00000086 	andeq	r0, r0, r6, lsl #1
    92b0:	037f1400 	cmneq	pc, #0, 8
    92b4:	14010000 	strne	r0, [r1], #-0
    92b8:	005c6601 	subseq	r6, ip, r1, lsl #12
    92bc:	00001e00 	andeq	r1, r0, r0, lsl #28
    92c0:	129c0100 	addsne	r0, ip, #0, 2
    92c4:	15000004 	strne	r0, [r0, #-4]
    92c8:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    92cc:	5e011401 	cdppl	4, 0, cr1, cr1, cr1, {0}
    92d0:	c7000000 	strgt	r0, [r0, -r0]
    92d4:	10000086 	andne	r0, r0, r6, lsl #1
    92d8:	00005c66 	andeq	r5, r0, r6, ror #24
    92dc:	0000001e 	andeq	r0, r0, lr, lsl r0
    92e0:	00075e16 	andeq	r5, r7, r6, lsl lr
    92e4:	01160100 	tsteq	r6, r0, lsl #2
    92e8:	0000004c 	andeq	r0, r0, ip, asr #32
    92ec:	000086e8 	andeq	r8, r0, r8, ror #13
    92f0:	61140000 	tstvs	r4, r0
    92f4:	0100001d 	tsteq	r0, sp, lsl r0
    92f8:	00000120 	andeq	r0, r0, r0, lsr #2
    92fc:	001e0000 	andseq	r0, lr, r0
    9300:	9c010000 	stcls	0, cr0, [r1], {-0}
    9304:	00000439 	andeq	r0, r0, r9, lsr r4
    9308:	001eb815 	andseq	fp, lr, r5, lsl r8
    930c:	01200100 	teqeq	r0, r0, lsl #2
    9310:	0000005e 	andeq	r0, r0, lr, asr r0
    9314:	00008716 	andeq	r8, r0, r6, lsl r7
    9318:	1d791400 	cfldrdne	mvd1, [r9, #-0]
    931c:	2c010000 	stccs	0, cr0, [r1], {-0}
    9320:	00000001 	andeq	r0, r0, r1
    9324:	00001c00 	andeq	r1, r0, r0, lsl #24
    9328:	609c0100 	addsvs	r0, ip, r0, lsl #2
    932c:	15000004 	strne	r0, [r0, #-4]
    9330:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    9334:	5e012c01 	cdppl	12, 0, cr2, cr1, cr1, {0}
    9338:	37000000 	strcc	r0, [r0, -r0]
    933c:	00000087 	andeq	r0, r0, r7, lsl #1
    9340:	00079414 	andeq	r9, r7, r4, lsl r4
    9344:	01370100 	teqeq	r7, r0, lsl #2
    9348:	00005c84 	andeq	r5, r0, r4, lsl #25
    934c:	0000001c 	andeq	r0, r0, ip, lsl r0
    9350:	04879c01 	streq	r9, [r7], #3073	; 0xc01
    9354:	b8150000 	ldmdalt	r5, {}	; <UNPREDICTABLE>
    9358:	0100001e 	tsteq	r0, lr, lsl r0
    935c:	005e0137 	subseq	r0, lr, r7, lsr r1
    9360:	87580000 	ldrbhi	r0, [r8, -r0]
    9364:	14000000 	strne	r0, [r0], #-0
    9368:	00001e55 	andeq	r1, r0, r5, asr lr
    936c:	00014201 	andeq	r4, r1, r1, lsl #4
    9370:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    9374:	01000000 	mrseq	r0, (UNDEF: 0)
    9378:	0004ae9c 	muleq	r4, ip, lr
    937c:	1eb81500 	cdpne	5, 11, cr1, cr8, cr0, {0}
    9380:	42010000 	andmi	r0, r1, #0
    9384:	00005e01 	andeq	r5, r0, r1, lsl #28
    9388:	00877900 	addeq	r7, r7, r0, lsl #18
    938c:	f0140000 			; <UNDEFINED> instruction: 0xf0140000
    9390:	0100001c 	tsteq	r0, ip, lsl r0
    9394:	0000014d 	andeq	r0, r0, sp, asr #2
    9398:	001e0000 	andseq	r0, lr, r0
    939c:	9c010000 	stcls	0, cr0, [r1], {-0}
    93a0:	000004d5 	ldrdeq	r0, [r0], -r5
    93a4:	001eb815 	andseq	fp, lr, r5, lsl r8
    93a8:	014d0100 	mrseq	r0, (UNDEF: 93)
    93ac:	0000005e 	andeq	r0, r0, lr, asr r0
    93b0:	0000879a 	muleq	r0, sl, r7
    93b4:	1d131400 	cfldrsne	mvf1, [r3, #-0]
    93b8:	58010000 	stmdapl	r1, {}	; <UNPREDICTABLE>
    93bc:	00000001 	andeq	r0, r0, r1
    93c0:	00001c00 	andeq	r1, r0, r0, lsl #24
    93c4:	fc9c0100 	ldc2	1, cr0, [ip], {0}
    93c8:	15000004 	strne	r0, [r0, #-4]
    93cc:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    93d0:	5e015801 	cdppl	8, 0, cr5, cr1, cr1, {0}
    93d4:	bb000000 	bllt	93dc <_etext+0x1dc8>
    93d8:	00000087 	andeq	r0, r0, r7, lsl #1
    93dc:	001b4d17 	andseq	r4, fp, r7, lsl sp
    93e0:	01630100 	cmneq	r3, r0, lsl #2
    93e4:	0000004c 	andeq	r0, r0, ip, asr #32
    93e8:	00000000 	andeq	r0, r0, r0
    93ec:	0000001a 	andeq	r0, r0, sl, lsl r0
    93f0:	05279c01 	streq	r9, [r7, #-3073]!	; 0xc01
    93f4:	b8150000 	ldmdalt	r5, {}	; <UNPREDICTABLE>
    93f8:	0100001e 	tsteq	r0, lr, lsl r0
    93fc:	005e0163 	subseq	r0, lr, r3, ror #2
    9400:	87dc0000 	ldrbhi	r0, [ip, r0]
    9404:	17000000 	strne	r0, [r0, -r0]
    9408:	00001c08 	andeq	r1, r0, r8, lsl #24
    940c:	4c016e01 	stcmi	14, cr6, [r1], {1}
    9410:	00000000 	andeq	r0, r0, r0
    9414:	1a000000 	bne	941c <_etext+0x1e08>
    9418:	01000000 	mrseq	r0, (UNDEF: 0)
    941c:	0005529c 	muleq	r5, ip, r2
    9420:	1eb81500 	cdpne	5, 11, cr1, cr8, cr0, {0}
    9424:	6e010000 	cdpvs	0, 0, cr0, cr1, cr0, {0}
    9428:	00005e01 	andeq	r5, r0, r1, lsl #28
    942c:	0087fd00 	addeq	pc, r7, r0, lsl #26
    9430:	40140000 	andsmi	r0, r4, r0
    9434:	0100001d 	tsteq	r0, sp, lsl r0
    9438:	00000179 	andeq	r0, r0, r9, ror r1
    943c:	00180000 	andseq	r0, r8, r0
    9440:	9c010000 	stcls	0, cr0, [r1], {-0}
    9444:	00000579 	andeq	r0, r0, r9, ror r5
    9448:	001eb815 	andseq	fp, lr, r5, lsl r8
    944c:	01790100 	cmneq	r9, r0, lsl #2
    9450:	0000005e 	andeq	r0, r0, lr, asr r0
    9454:	0000881e 	andeq	r8, r0, lr, lsl r8
    9458:	1e181400 	cfmulsne	mvf1, mvf8, mvf0
    945c:	84010000 	strhi	r0, [r1], #-0
    9460:	00000001 	andeq	r0, r0, r1
    9464:	00001c00 	andeq	r1, r0, r0, lsl #24
    9468:	a09c0100 	addsge	r0, ip, r0, lsl #2
    946c:	15000005 	strne	r0, [r0, #-5]
    9470:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    9474:	5e018401 	cdppl	4, 0, cr8, cr1, cr1, {0}
    9478:	3f000000 	svccc	0x00000000
    947c:	00000088 	andeq	r0, r0, r8, lsl #1
    9480:	001c4414 	andseq	r4, ip, r4, lsl r4
    9484:	018f0100 	orreq	r0, pc, r0, lsl #2
    9488:	00000000 	andeq	r0, r0, r0
    948c:	00000020 	andeq	r0, r0, r0, lsr #32
    9490:	05c79c01 	strbeq	r9, [r7, #3073]	; 0xc01
    9494:	b8150000 	ldmdalt	r5, {}	; <UNPREDICTABLE>
    9498:	0100001e 	tsteq	r0, lr, lsl r0
    949c:	005e018f 	subseq	r0, lr, pc, lsl #3
    94a0:	88600000 	stmdahi	r0!, {}^	; <UNPREDICTABLE>
    94a4:	14000000 	strne	r0, [r0], #-0
    94a8:	00001bab 	andeq	r1, r0, fp, lsr #23
    94ac:	00019a01 	andeq	r9, r1, r1, lsl #20
    94b0:	20000000 	andcs	r0, r0, r0
    94b4:	01000000 	mrseq	r0, (UNDEF: 0)
    94b8:	0005ee9c 	muleq	r5, ip, lr
    94bc:	1eb81500 	cdpne	5, 11, cr1, cr8, cr0, {0}
    94c0:	9a010000 	bls	494c8 <_etext+0x41eb4>
    94c4:	00005e01 	andeq	r5, r0, r1, lsl #28
    94c8:	00888100 	addeq	r8, r8, r0, lsl #2
    94cc:	ed140000 	ldc	0, cr0, [r4, #-0]
    94d0:	0100001b 	tsteq	r0, fp, lsl r0
    94d4:	5ca001a5 	stfpls	f0, [r0], #660	; 0x294
    94d8:	00200000 	eoreq	r0, r0, r0
    94dc:	9c010000 	stcls	0, cr0, [r1], {-0}
    94e0:	00000615 	andeq	r0, r0, r5, lsl r6
    94e4:	001eb815 	andseq	fp, lr, r5, lsl r8
    94e8:	01a50100 			; <UNDEFINED> instruction: 0x01a50100
    94ec:	0000005e 	andeq	r0, r0, lr, asr r0
    94f0:	000088a2 	andeq	r8, r0, r2, lsr #17
    94f4:	1e9d1400 	cdpne	4, 9, cr1, cr13, cr0, {0}
    94f8:	b0010000 	andlt	r0, r1, r0
    94fc:	005cc001 	subseq	ip, ip, r1
    9500:	00002000 	andeq	r2, r0, r0
    9504:	3c9c0100 	ldfccs	f0, [ip], {0}
    9508:	15000006 	strne	r0, [r0, #-6]
    950c:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    9510:	5e01b001 	cdppl	0, 0, cr11, cr1, cr1, {0}
    9514:	c3000000 	movwgt	r0, #0
    9518:	00000088 	andeq	r0, r0, r8, lsl #1
    951c:	001c2914 	andseq	r2, ip, r4, lsl r9
    9520:	01bc0100 			; <UNDEFINED> instruction: 0x01bc0100
    9524:	00000000 	andeq	r0, r0, r0
    9528:	0000001e 	andeq	r0, r0, lr, lsl r0
    952c:	06739c01 	ldrbteq	r9, [r3], -r1, lsl #24
    9530:	b8150000 	ldmdalt	r5, {}	; <UNPREDICTABLE>
    9534:	0100001e 	tsteq	r0, lr, lsl r0
    9538:	005e01bc 	ldrheq	r0, [lr], #-28	; 0xffffffe4
    953c:	88e40000 	stmiahi	r4!, {}^	; <UNPREDICTABLE>
    9540:	fa150000 	blx	549548 <_etext+0x541f34>
    9544:	0100001b 	tsteq	r0, fp, lsl r0
    9548:	005e01bc 	ldrheq	r0, [lr], #-28	; 0xffffffe4
    954c:	89050000 	stmdbhi	r5, {}	; <UNPREDICTABLE>
    9550:	17000000 	strne	r0, [r0, -r0]
    9554:	00001bb9 			; <UNDEFINED> instruction: 0x00001bb9
    9558:	5e01c701 	cdppl	7, 0, cr12, cr1, cr1, {0}
    955c:	00000000 	andeq	r0, r0, r0
    9560:	12000000 	andne	r0, r0, #0
    9564:	01000000 	mrseq	r0, (UNDEF: 0)
    9568:	00069e9c 	muleq	r6, ip, lr
    956c:	1eb81500 	cdpne	5, 11, cr1, cr8, cr0, {0}
    9570:	c7010000 	strgt	r0, [r1, -r0]
    9574:	00005e01 	andeq	r5, r0, r1, lsl #28
    9578:	00892600 	addeq	r2, r9, r0, lsl #12
    957c:	07140000 	ldreq	r0, [r4, -r0]
    9580:	0100001d 	tsteq	r0, sp, lsl r0
    9584:	000001d3 	ldrdeq	r0, [r0], -r3
    9588:	00200000 	eoreq	r0, r0, r0
    958c:	9c010000 	stcls	0, cr0, [r1], {-0}
    9590:	000006d5 	ldrdeq	r0, [r0], -r5
    9594:	001eb815 	andseq	fp, lr, r5, lsl r8
    9598:	01d30100 	bicseq	r0, r3, r0, lsl #2
    959c:	0000005e 	andeq	r0, r0, lr, asr r0
    95a0:	00008947 	andeq	r8, r0, r7, asr #18
    95a4:	001dae15 	andseq	sl, sp, r5, lsl lr
    95a8:	01d30100 	bicseq	r0, r3, r0, lsl #2
    95ac:	0000004c 	andeq	r0, r0, ip, asr #32
    95b0:	00008968 	andeq	r8, r0, r8, ror #18
    95b4:	1ecb1400 	cdpne	4, 12, cr1, cr11, cr0, {0}
    95b8:	df010000 	svcle	0x00010000
    95bc:	00000001 	andeq	r0, r0, r1
    95c0:	00002000 	andeq	r2, r0, r0
    95c4:	0c9c0100 	ldfeqs	f0, [ip], {0}
    95c8:	15000007 	strne	r0, [r0, #-7]
    95cc:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    95d0:	5e01df01 	cdppl	15, 0, cr13, cr1, cr1, {0}
    95d4:	89000000 	stmdbhi	r0, {}	; <UNPREDICTABLE>
    95d8:	15000089 	strne	r0, [r0, #-137]	; 0x89
    95dc:	00001dae 	andeq	r1, r0, lr, lsr #27
    95e0:	4c01df01 	stcmi	15, cr13, [r1], {1}
    95e4:	aa000000 	bge	95ec <_etext+0x1fd8>
    95e8:	00000089 	andeq	r0, r0, r9, lsl #1
    95ec:	001e9117 	andseq	r9, lr, r7, lsl r1
    95f0:	01ea0100 	mvneq	r0, r0, lsl #2
    95f4:	0000004c 	andeq	r0, r0, ip, asr #32
    95f8:	00005ce0 	andeq	r5, r0, r0, ror #25
    95fc:	0000001c 	andeq	r0, r0, ip, lsl r0
    9600:	07379c01 	ldreq	r9, [r7, -r1, lsl #24]!
    9604:	b8150000 	ldmdalt	r5, {}	; <UNPREDICTABLE>
    9608:	0100001e 	tsteq	r0, lr, lsl r0
    960c:	005e01ea 	subseq	r0, lr, sl, ror #3
    9610:	89cb0000 	stmibhi	fp, {}^	; <UNPREDICTABLE>
    9614:	17000000 	strne	r0, [r0, -r0]
    9618:	00001c7d 	andeq	r1, r0, sp, ror ip
    961c:	4c01f501 	cfstr32mi	mvfx15, [r1], {1}
    9620:	fc000000 	stc2	0, cr0, [r0], {-0}
    9624:	1c00005c 	stcne	0, cr0, [r0], {92}	; 0x5c
    9628:	01000000 	mrseq	r0, (UNDEF: 0)
    962c:	0007629c 	muleq	r7, ip, r2
    9630:	1eb81500 	cdpne	5, 11, cr1, cr8, cr0, {0}
    9634:	f5010000 			; <UNDEFINED> instruction: 0xf5010000
    9638:	00005e01 	andeq	r5, r0, r1, lsl #28
    963c:	0089ec00 	addeq	lr, r9, r0, lsl #24
    9640:	6c140000 	ldcvs	0, cr0, [r4], {-0}
    9644:	0100001d 	tsteq	r0, sp, lsl r0
    9648:	5d180201 	lfmpl	f0, 4, [r8, #-4]
    964c:	001c0000 	andseq	r0, ip, r0
    9650:	9c010000 	stcls	0, cr0, [r1], {-0}
    9654:	00000797 	muleq	r0, r7, r7
    9658:	001eb815 	andseq	fp, lr, r5, lsl r8
    965c:	02010100 	andeq	r0, r1, #0, 2
    9660:	0000005e 	andeq	r0, r0, lr, asr r0
    9664:	00008a0d 	andeq	r8, r0, sp, lsl #20
    9668:	001c2218 	andseq	r2, ip, r8, lsl r2
    966c:	02010100 	andeq	r0, r1, #0, 2
    9670:	0000004c 	andeq	r0, r0, ip, asr #32
    9674:	14005101 	strne	r5, [r0], #-257	; 0x101
    9678:	00001dd6 	ldrdeq	r1, [r0], -r6
    967c:	00020d01 	andeq	r0, r2, r1, lsl #26
    9680:	26000000 	strcs	r0, [r0], -r0
    9684:	01000000 	mrseq	r0, (UNDEF: 0)
    9688:	0007e69c 	muleq	r7, ip, r6
    968c:	1dcf1800 	stclne	8, cr1, [pc]	; 9694 <_etext+0x2080>
    9690:	0d010000 	stceq	0, cr0, [r1, #-0]
    9694:	0007e602 	andeq	lr, r7, r2, lsl #12
    9698:	15500100 	ldrbne	r0, [r0, #-256]	; 0x100
    969c:	00001c22 	andeq	r1, r0, r2, lsr #24
    96a0:	4c020d01 	stcmi	13, cr0, [r2], {1}
    96a4:	2e000000 	cdpcs	0, 0, cr0, cr0, cr0, {0}
    96a8:	1000008a 	andne	r0, r0, sl, lsl #1
    96ac:	00000000 	andeq	r0, r0, r0
    96b0:	00000026 	andeq	r0, r0, r6, lsr #32
    96b4:	001be416 	andseq	lr, fp, r6, lsl r4
    96b8:	020f0100 	andeq	r0, pc, #0, 2
    96bc:	0000004c 	andeq	r0, r0, ip, asr #32
    96c0:	00008a68 	andeq	r8, r0, r8, ror #20
    96c4:	04190000 	ldreq	r0, [r9], #-0
    96c8:	0000003a 	andeq	r0, r0, sl, lsr r0
    96cc:	00099c14 	andeq	r9, r9, r4, lsl ip
    96d0:	02190100 	andseq	r0, r9, #0, 2
    96d4:	00005d34 	andeq	r5, r0, r4, lsr sp
    96d8:	00000040 	andeq	r0, r0, r0, asr #32
    96dc:	08519c01 	ldmdaeq	r1, {r0, sl, fp, ip, pc}^
    96e0:	b8150000 	ldmdalt	r5, {}	; <UNPREDICTABLE>
    96e4:	0100001e 	tsteq	r0, lr, lsl r0
    96e8:	005e0219 	subseq	r0, lr, r9, lsl r2
    96ec:	8a910000 	bhi	fe4496f4 <BootRAM+0xd3b9e95>
    96f0:	22150000 	andscs	r0, r5, #0
    96f4:	0100001c 	tsteq	r0, ip, lsl r0
    96f8:	004c0219 	subeq	r0, ip, r9, lsl r2
    96fc:	8ab20000 	bhi	fec89704 <BootRAM+0xdbf9ea5>
    9700:	34100000 	ldrcc	r0, [r0], #-0
    9704:	4000005d 	andmi	r0, r0, sp, asr r0
    9708:	1a000000 	bne	9710 <_etext+0x20fc>
    970c:	00001dcf 	andeq	r1, r0, pc, asr #27
    9710:	e6021b01 	str	r1, [r2], -r1, lsl #22
    9714:	01000007 	tsteq	r0, r7
    9718:	0bf01b52 	bleq	ffc10468 <BootRAM+0xeb80c09>
    971c:	e4160000 	ldr	r0, [r6], #-0
    9720:	0100001b 	tsteq	r0, fp, lsl r0
    9724:	004c021b 	subeq	r0, ip, fp, lsl r2
    9728:	8ad30000 	bhi	ff4c9730 <BootRAM+0xe439ed1>
    972c:	00000000 	andeq	r0, r0, r0
    9730:	1e0b1700 	cdpne	7, 0, cr1, cr11, cr0, {0}
    9734:	24010000 	strcs	r0, [r1], #-0
    9738:	00004c02 	andeq	r4, r0, r2, lsl #24
    973c:	00000000 	andeq	r0, r0, r0
    9740:	00002000 	andeq	r2, r0, r0
    9744:	7c9c0100 	ldfvcs	f0, [ip], {0}
    9748:	15000008 	strne	r0, [r0, #-8]
    974c:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    9750:	5e022401 	cdppl	4, 0, cr2, cr2, cr1, {0}
    9754:	0b000000 	bleq	975c <_etext+0x2148>
    9758:	0000008b 	andeq	r0, r0, fp, lsl #1
    975c:	001de617 	andseq	lr, sp, r7, lsl r6
    9760:	022f0100 	eoreq	r0, pc, #0, 2
    9764:	0000004c 	andeq	r0, r0, ip, asr #32
    9768:	00000000 	andeq	r0, r0, r0
    976c:	00000020 	andeq	r0, r0, r0, lsr #32
    9770:	08a79c01 	stmiaeq	r7!, {r0, sl, fp, ip, pc}
    9774:	b8150000 	ldmdalt	r5, {}	; <UNPREDICTABLE>
    9778:	0100001e 	tsteq	r0, lr, lsl r0
    977c:	005e022f 	subseq	r0, lr, pc, lsr #4
    9780:	8b2c0000 	blhi	b09788 <_etext+0xb02174>
    9784:	14000000 	strne	r0, [r0], #-0
    9788:	00001c52 	andeq	r1, r0, r2, asr ip
    978c:	00023c01 	andeq	r3, r2, r1, lsl #24
    9790:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    9794:	01000000 	mrseq	r0, (UNDEF: 0)
    9798:	0008ee9c 	muleq	r8, ip, lr
    979c:	1eb81500 	cdpne	5, 11, cr1, cr8, cr0, {0}
    97a0:	3c010000 	stccc	0, cr0, [r1], {-0}
    97a4:	00005e02 	andeq	r5, r0, r2, lsl #28
    97a8:	008b4d00 	addeq	r4, fp, r0, lsl #26
    97ac:	1e4b1500 	cdpne	5, 4, cr1, cr11, cr0, {0}
    97b0:	3c010000 	stccc	0, cr0, [r1], {-0}
    97b4:	00004c02 	andeq	r4, r0, r2, lsl #24
    97b8:	008b6e00 	addeq	r6, fp, r0, lsl #28
    97bc:	1ce11500 	cfstr64ne	mvdx1, [r1]
    97c0:	3c010000 	stccc	0, cr0, [r1], {-0}
    97c4:	00004c02 	andeq	r4, r0, r2, lsl #24
    97c8:	008b8f00 	addeq	r8, fp, r0, lsl #30
    97cc:	89140000 	ldmdbhi	r4, {}	; <UNPREDICTABLE>
    97d0:	0100001c 	tsteq	r0, ip, lsl r0
    97d4:	00000248 	andeq	r0, r0, r8, asr #4
    97d8:	00200000 	eoreq	r0, r0, r0
    97dc:	9c010000 	stcls	0, cr0, [r1], {-0}
    97e0:	00000925 	andeq	r0, r0, r5, lsr #18
    97e4:	001eb815 	andseq	fp, lr, r5, lsl r8
    97e8:	02480100 	subeq	r0, r8, #0, 2
    97ec:	0000005e 	andeq	r0, r0, lr, asr r0
    97f0:	00008bb0 			; <UNDEFINED> instruction: 0x00008bb0
    97f4:	001e4b15 	andseq	r4, lr, r5, lsl fp
    97f8:	02480100 	subeq	r0, r8, #0, 2
    97fc:	0000004c 	andeq	r0, r0, ip, asr #32
    9800:	00008bd1 	ldrdeq	r8, [r0], -r1
    9804:	1b5e1400 	blne	178e80c <_etext+0x17871f8>
    9808:	54010000 	strpl	r0, [r1], #-0
    980c:	00000002 	andeq	r0, r0, r2
    9810:	00002000 	andeq	r2, r0, r0
    9814:	5c9c0100 	ldfpls	f0, [ip], {0}
    9818:	15000009 	strne	r0, [r0, #-9]
    981c:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    9820:	5e025401 	cdppl	4, 0, cr5, cr2, cr1, {0}
    9824:	f2000000 	vhadd.s8	d0, d0, d0
    9828:	1500008b 	strne	r0, [r0, #-139]	; 0x8b
    982c:	00001ce1 	andeq	r1, r0, r1, ror #25
    9830:	4c025401 	cfstrsmi	mvf5, [r2], {1}
    9834:	13000000 	movwne	r0, #0
    9838:	0000008c 	andeq	r0, r0, ip, lsl #1
    983c:	001e6b17 	andseq	r6, lr, r7, lsl fp
    9840:	025f0100 	subseq	r0, pc, #0, 2
    9844:	0000004c 	andeq	r0, r0, ip, asr #32
    9848:	00000000 	andeq	r0, r0, r0
    984c:	0000001c 	andeq	r0, r0, ip, lsl r0
    9850:	09879c01 	stmibeq	r7, {r0, sl, fp, ip, pc}
    9854:	b8150000 	ldmdalt	r5, {}	; <UNPREDICTABLE>
    9858:	0100001e 	tsteq	r0, lr, lsl r0
    985c:	005e025f 	subseq	r0, lr, pc, asr r2
    9860:	8c340000 	ldchi	0, cr0, [r4], #-0
    9864:	17000000 	strne	r0, [r0, -r0]
    9868:	00001d25 	andeq	r1, r0, r5, lsr #26
    986c:	4c026a01 	stcmi	10, cr6, [r2], {1}
    9870:	00000000 	andeq	r0, r0, r0
    9874:	1c000000 	stcne	0, cr0, [r0], {-0}
    9878:	01000000 	mrseq	r0, (UNDEF: 0)
    987c:	0009b29c 	muleq	r9, ip, r2
    9880:	1eb81500 	cdpne	5, 11, cr1, cr8, cr0, {0}
    9884:	6a010000 	bvs	4988c <_etext+0x42278>
    9888:	00005e02 	andeq	r5, r0, r2, lsl #28
    988c:	008c5500 	addeq	r5, ip, r0, lsl #10
    9890:	4f140000 	svcmi	0x00140000
    9894:	0100001d 	tsteq	r0, sp, lsl r0
    9898:	00000276 	andeq	r0, r0, r6, ror r2
    989c:	00a80000 	adceq	r0, r8, r0
    98a0:	9c010000 	stcls	0, cr0, [r1], {-0}
    98a4:	00000a59 	andeq	r0, r0, r9, asr sl
    98a8:	001eb815 	andseq	fp, lr, r5, lsl r8
    98ac:	02760100 	rsbseq	r0, r6, #0, 2
    98b0:	0000005e 	andeq	r0, r0, lr, asr r0
    98b4:	00008c76 	andeq	r8, r0, r6, ror ip
    98b8:	001ca815 	andseq	sl, ip, r5, lsl r8
    98bc:	02760100 	rsbseq	r0, r6, #0, 2
    98c0:	0000005e 	andeq	r0, r0, lr, asr r0
    98c4:	00008cbb 			; <UNDEFINED> instruction: 0x00008cbb
    98c8:	001c2215 	andseq	r2, ip, r5, lsl r2
    98cc:	02760100 	rsbseq	r0, r6, #0, 2
    98d0:	0000004c 	andeq	r0, r0, ip, asr #32
    98d4:	00008d00 	andeq	r8, r0, r0, lsl #26
    98d8:	0000001c 	andeq	r0, r0, ip, lsl r0
    98dc:	00003a00 	andeq	r3, r0, r0, lsl #20
    98e0:	000a2c00 	andeq	r2, sl, r0, lsl #24
    98e4:	1dcf1600 	stclne	6, cr1, [pc]	; 98ec <_etext+0x22d8>
    98e8:	78010000 	stmdavc	r1, {}	; <UNPREDICTABLE>
    98ec:	0007e602 	andeq	lr, r7, r2, lsl #12
    98f0:	008d2c00 	addeq	r2, sp, r0, lsl #24
    98f4:	0c081b00 	stceq	11, cr1, [r8], {-0}
    98f8:	e4160000 	ldr	r0, [r6], #-0
    98fc:	0100001b 	tsteq	r0, fp, lsl r0
    9900:	004c0278 	subeq	r0, ip, r8, ror r2
    9904:	8d4a0000 	stclhi	0, cr0, [sl, #-0]
    9908:	00000000 	andeq	r0, r0, r0
    990c:	000c201b 	andeq	r2, ip, fp, lsl r0
    9910:	1dcf1600 	stclne	6, cr1, [pc]	; 9918 <_etext+0x2304>
    9914:	78010000 	stmdavc	r1, {}	; <UNPREDICTABLE>
    9918:	0007e602 	andeq	lr, r7, r2, lsl #12
    991c:	008d8200 	addeq	r8, sp, r0, lsl #4
    9920:	0c381b00 	ldceq	11, cr1, [r8], #-0
    9924:	e4160000 	ldr	r0, [r6], #-0
    9928:	0100001b 	tsteq	r0, fp, lsl r0
    992c:	004c0278 	subeq	r0, ip, r8, ror r2
    9930:	8da00000 	stchi	0, cr0, [r0]
    9934:	00000000 	andeq	r0, r0, r0
    9938:	1e391400 	cfabssne	mvf1, mvf9
    993c:	82010000 	andhi	r0, r1, #0
    9940:	00000002 	andeq	r0, r0, r2
    9944:	00005c00 	andeq	r5, r0, r0, lsl #24
    9948:	d09c0100 	addsle	r0, ip, r0, lsl #2
    994c:	1500000a 	strne	r0, [r0, #-10]
    9950:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    9954:	5e028201 	cdppl	2, 0, cr8, cr2, cr1, {0}
    9958:	d8000000 	stmdale	r0, {}	; <UNPREDICTABLE>
    995c:	1500008d 	strne	r0, [r0, #-141]	; 0x8d
    9960:	00001ca8 	andeq	r1, r0, r8, lsr #25
    9964:	5e028201 	cdppl	2, 0, cr8, cr2, cr1, {0}
    9968:	12000000 	andne	r0, r0, #0
    996c:	1500008e 	strne	r0, [r0, #-142]	; 0x8e
    9970:	00001c22 	andeq	r1, r0, r2, lsr #24
    9974:	4c028201 	sfmmi	f0, 1, [r2], {1}
    9978:	3e000000 	cdpcc	0, 0, cr0, cr0, cr0, {0}
    997c:	1000008e 	andne	r0, r0, lr, lsl #1
    9980:	00000000 	andeq	r0, r0, r0
    9984:	00000038 	andeq	r0, r0, r8, lsr r0
    9988:	001dcf16 	andseq	ip, sp, r6, lsl pc
    998c:	02840100 	addeq	r0, r4, #0, 2
    9990:	000007e6 	andeq	r0, r0, r6, ror #15
    9994:	00008e6a 	andeq	r8, r0, sl, ror #28
    9998:	000c581b 	andeq	r5, ip, fp, lsl r8
    999c:	1be41600 	blne	ff90f1a4 <BootRAM+0xe87f945>
    99a0:	84010000 	strhi	r0, [r1], #-0
    99a4:	00004c02 	andeq	r4, r0, r2, lsl #24
    99a8:	008e7d00 	addeq	r7, lr, r0, lsl #26
    99ac:	00000000 	andeq	r0, r0, r0
    99b0:	001ed714 	andseq	sp, lr, r4, lsl r7
    99b4:	028e0100 	addeq	r0, lr, #0, 2
    99b8:	00000000 	andeq	r0, r0, r0
    99bc:	0000005c 	andeq	r0, r0, ip, asr r0
    99c0:	0b479c01 	bleq	11f09cc <_etext+0x11e93b8>
    99c4:	b8150000 	ldmdalt	r5, {}	; <UNPREDICTABLE>
    99c8:	0100001e 	tsteq	r0, lr, lsl r0
    99cc:	005e028e 	subseq	r0, lr, lr, lsl #5
    99d0:	8eb50000 	cdphi	0, 11, cr0, cr5, cr0, {0}
    99d4:	a8150000 	ldmdage	r5, {}	; <UNPREDICTABLE>
    99d8:	0100001c 	tsteq	r0, ip, lsl r0
    99dc:	005e028e 	subseq	r0, lr, lr, lsl #5
    99e0:	8eef0000 	cdphi	0, 14, cr0, cr15, cr0, {0}
    99e4:	22150000 	andscs	r0, r5, #0
    99e8:	0100001c 	tsteq	r0, ip, lsl r0
    99ec:	004c028e 	subeq	r0, ip, lr, lsl #5
    99f0:	8f1b0000 	svchi	0x001b0000
    99f4:	00100000 	andseq	r0, r0, r0
    99f8:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    99fc:	16000000 	strne	r0, [r0], -r0
    9a00:	00001dcf 	andeq	r1, r0, pc, asr #27
    9a04:	e6029001 	str	r9, [r2], -r1
    9a08:	47000007 	strmi	r0, [r0, -r7]
    9a0c:	1b00008f 	blne	9c50 <_etext+0x263c>
    9a10:	00000c70 	andeq	r0, r0, r0, ror ip
    9a14:	001be416 	andseq	lr, fp, r6, lsl r4
    9a18:	02900100 	addseq	r0, r0, #0, 2
    9a1c:	0000004c 	andeq	r0, r0, ip, asr #32
    9a20:	00008f5a 	andeq	r8, r0, sl, asr pc
    9a24:	17000000 	strne	r0, [r0, -r0]
    9a28:	00001db4 			; <UNDEFINED> instruction: 0x00001db4
    9a2c:	4c029a01 	stcmi	10, cr9, [r2], {1}
    9a30:	00000000 	andeq	r0, r0, r0
    9a34:	20000000 	andcs	r0, r0, r0
    9a38:	01000000 	mrseq	r0, (UNDEF: 0)
    9a3c:	000b729c 	muleq	fp, ip, r2
    9a40:	1eb81500 	cdpne	5, 11, cr1, cr8, cr0, {0}
    9a44:	9a010000 	bls	49a4c <_etext+0x42438>
    9a48:	00005e02 	andeq	r5, r0, r2, lsl #28
    9a4c:	008f9200 	addeq	r9, pc, r0, lsl #4
    9a50:	27170000 	ldrcs	r0, [r7, -r0]
    9a54:	0100001e 	tsteq	r0, lr, lsl r0
    9a58:	004c02a6 	subeq	r0, ip, r6, lsr #5
    9a5c:	00000000 	andeq	r0, r0, r0
    9a60:	00200000 	eoreq	r0, r0, r0
    9a64:	9c010000 	stcls	0, cr0, [r1], {-0}
    9a68:	00000b9d 	muleq	r0, sp, fp
    9a6c:	001eb815 	andseq	fp, lr, r5, lsl r8
    9a70:	02a60100 	adceq	r0, r6, #0, 2
    9a74:	0000005e 	andeq	r0, r0, lr, asr r0
    9a78:	00008fb3 			; <UNDEFINED> instruction: 0x00008fb3
    9a7c:	1cd21700 	ldclne	7, cr1, [r2], {0}
    9a80:	b2010000 	andlt	r0, r1, #0
    9a84:	00008e02 	andeq	r8, r0, r2, lsl #28
    9a88:	00000000 	andeq	r0, r0, r0
    9a8c:	00004400 	andeq	r4, r0, r0, lsl #8
    9a90:	c89c0100 	ldmgt	ip, {r8}
    9a94:	1500000b 	strne	r0, [r0, #-11]
    9a98:	00001eb8 			; <UNDEFINED> instruction: 0x00001eb8
    9a9c:	5e02b201 	cdppl	2, 0, cr11, cr2, cr1, {0}
    9aa0:	d4000000 	strle	r0, [r0], #-0
    9aa4:	0000008f 	andeq	r0, r0, pc, lsl #1
    9aa8:	001b3e14 	andseq	r3, fp, r4, lsl lr
    9aac:	02c30100 	sbceq	r0, r3, #0, 2
    9ab0:	00000000 	andeq	r0, r0, r0
    9ab4:	0000003a 	andeq	r0, r0, sl, lsr r0
    9ab8:	0bfd9c01 	bleq	fff70ac4 <BootRAM+0xeee1265>
    9abc:	b8150000 	ldmdalt	r5, {}	; <UNPREDICTABLE>
    9ac0:	0100001e 	tsteq	r0, lr, lsl r0
    9ac4:	005e02c3 	subseq	r0, lr, r3, asr #5
    9ac8:	8ff50000 	svchi	0x00f50000
    9acc:	a8180000 	ldmdage	r8, {}	; <UNPREDICTABLE>
    9ad0:	0100001c 	tsteq	r0, ip, lsl r0
    9ad4:	005e02c3 	subseq	r0, lr, r3, asr #5
    9ad8:	51010000 	mrspl	r0, (UNDEF: 1)
    9adc:	1d001700 	stcne	7, cr1, [r0, #-0]
    9ae0:	d6010000 	strle	r0, [r1], -r0
    9ae4:	00004c02 	andeq	r4, r0, r2, lsl #24
    9ae8:	00000000 	andeq	r0, r0, r0
    9aec:	00000600 	andeq	r0, r0, r0, lsl #12
    9af0:	449c0100 	ldrmi	r0, [ip], #256	; 0x100
    9af4:	1d00000c 	stcne	0, cr0, [r0, #-48]	; 0xffffffd0
    9af8:	01006862 	tsteq	r0, r2, ror #16
    9afc:	005e02d6 	ldrsbeq	r0, [lr], #-38	; 0xffffffda
    9b00:	902f0000 	eorls	r0, pc, r0
    9b04:	621e0000 	andsvs	r0, lr, #0
    9b08:	d601006c 	strle	r0, [r1], -ip, rrx
    9b0c:	00005e02 	andeq	r5, r0, r2, lsl #28
    9b10:	16510100 	ldrbne	r0, [r1], -r0, lsl #2
    9b14:	00001c78 	andeq	r1, r0, r8, ror ip
    9b18:	4c02d801 	stcmi	8, cr13, [r2], {1}
    9b1c:	50000000 	andpl	r0, r0, r0
    9b20:	00000090 	muleq	r0, r0, r0
    9b24:	001bdb1f 	andseq	sp, fp, pc, lsl fp
    9b28:	02e30100 	rsceq	r0, r3, #0, 2
    9b2c:	0000004c 	andeq	r0, r0, ip, asr #32
    9b30:	00000000 	andeq	r0, r0, r0
    9b34:	0000000a 	andeq	r0, r0, sl
    9b38:	eb159c01 	bl	570b44 <_etext+0x569530>
    9b3c:	0100001c 	tsteq	r0, ip, lsl r0
    9b40:	004c02e3 	subeq	r0, ip, r3, ror #5
    9b44:	90890000 	addls	r0, r9, r0
    9b48:	f3160000 	vhadd.u16	d0, d6, d0
    9b4c:	0100001d 	tsteq	r0, sp, lsl r0
    9b50:	005e02e5 	subseq	r0, lr, r5, ror #5
    9b54:	90aa0000 	adcls	r0, sl, r0
    9b58:	78160000 	ldmdavc	r6, {}	; <UNPREDICTABLE>
    9b5c:	0100001c 	tsteq	r0, ip, lsl r0
    9b60:	004c02e6 	subeq	r0, ip, r6, ror #5
    9b64:	90bd0000 	adcsls	r0, sp, r0
    9b68:	00000000 	andeq	r0, r0, r0
    9b6c:	000001d8 	ldrdeq	r0, [r0], -r8
    9b70:	23390004 	teqcs	r9, #4
    9b74:	01040000 	mrseq	r0, (UNDEF: 4)
    9b78:	00000639 	andeq	r0, r0, r9, lsr r6
    9b7c:	001f1c01 	andseq	r1, pc, r1, lsl #24
    9b80:	00089300 	andeq	r9, r8, r0, lsl #6
    9b84:	000e6800 	andeq	r6, lr, r0, lsl #16
    9b88:	00000000 	andeq	r0, r0, r0
    9b8c:	00382900 	eorseq	r2, r8, r0, lsl #18
    9b90:	05040200 	streq	r0, [r4, #-512]	; 0x200
    9b94:	000004da 	ldrdeq	r0, [r0], -sl
    9b98:	fc050202 	stc2	2, cr0, [r5], {2}
    9b9c:	02000006 	andeq	r0, r0, #6
    9ba0:	081a0601 	ldmdaeq	sl, {r0, r9, sl}
    9ba4:	75030000 	strvc	r0, [r3, #-0]
    9ba8:	02003233 	andeq	r3, r0, #805306371	; 0x30000003
    9bac:	00004524 	andeq	r4, r0, r4, lsr #10
    9bb0:	07040200 	streq	r0, [r4, -r0, lsl #4]
    9bb4:	00000252 	andeq	r0, r0, r2, asr r2
    9bb8:	36317503 	ldrtcc	r7, [r1], -r3, lsl #10
    9bbc:	57250200 	strpl	r0, [r5, -r0, lsl #4]!
    9bc0:	02000000 	andeq	r0, r0, #0
    9bc4:	09490702 	stmdbeq	r9, {r1, r8, r9, sl}^
    9bc8:	75030000 	strvc	r0, [r3, #-0]
    9bcc:	26020038 			; <UNDEFINED> instruction: 0x26020038
    9bd0:	00000068 	andeq	r0, r0, r8, rrx
    9bd4:	18080102 	stmdane	r8, {r1, r8}
    9bd8:	04000008 	streq	r0, [r0], #-8
    9bdc:	006f0405 	rsbeq	r0, pc, r5, lsl #8
    9be0:	34060000 	strcc	r0, [r6], #-0
    9be4:	01000008 	tsteq	r0, r8
    9be8:	005d7429 	subseq	r7, sp, r9, lsr #8
    9bec:	00015400 	andeq	r5, r1, r0, lsl #8
    9bf0:	2a9c0100 	bcs	fe709ff8 <BootRAM+0xd67a799>
    9bf4:	07000001 	streq	r0, [r0, -r1]
    9bf8:	00001f15 	andeq	r1, r0, r5, lsl pc
    9bfc:	003a2b01 	eorseq	r2, sl, r1, lsl #22
    9c00:	90dc0000 	sbcsls	r0, ip, r0
    9c04:	b0080000 	andlt	r0, r8, r0
    9c08:	1200005d 	andne	r0, r0, #93	; 0x5d
    9c0c:	b7000000 	strlt	r0, [r0, -r0]
    9c10:	07000000 	streq	r0, [r0, -r0]
    9c14:	0000075e 	andeq	r0, r0, lr, asr r7
    9c18:	004c3c01 	subeq	r3, ip, r1, lsl #24
    9c1c:	914c0000 	mrsls	r0, (UNDEF: 76)
    9c20:	08000000 	stmdaeq	r0, {}	; <UNPREDICTABLE>
    9c24:	00005dc2 	andeq	r5, r0, r2, asr #27
    9c28:	00000012 	andeq	r0, r0, r2, lsl r0
    9c2c:	000000d4 	ldrdeq	r0, [r0], -r4
    9c30:	00075e07 	andeq	r5, r7, r7, lsl #28
    9c34:	4c3d0100 	ldfmis	f0, [sp], #-0
    9c38:	90000000 	andls	r0, r0, r0
    9c3c:	00000091 	muleq	r0, r1, r0
    9c40:	005e1608 	subseq	r1, lr, r8, lsl #12
    9c44:	00002200 	andeq	r2, r0, r0, lsl #4
    9c48:	0000f100 	andeq	pc, r0, r0, lsl #2
    9c4c:	075e0700 	ldrbeq	r0, [lr, -r0, lsl #14]
    9c50:	72010000 	andvc	r0, r1, #0
    9c54:	0000004c 	andeq	r0, r0, ip, asr #32
    9c58:	0000920a 	andeq	r9, r0, sl, lsl #4
    9c5c:	5e380800 	cdppl	8, 3, cr0, cr8, cr0, {0}
    9c60:	00200000 	eoreq	r0, r0, r0
    9c64:	010e0000 	mrseq	r0, (UNDEF: 14)
    9c68:	5e070000 	cdppl	0, 0, cr0, cr7, cr0, {0}
    9c6c:	01000007 	tsteq	r0, r7
    9c70:	00004c73 	andeq	r4, r0, r3, ror ip
    9c74:	00922b00 	addseq	r2, r2, r0, lsl #22
    9c78:	ee090000 	cdp	0, 0, cr0, cr9, cr0, {0}
    9c7c:	ba00005d 	blt	9df8 <_etext+0x27e4>
    9c80:	09000001 	stmdbeq	r0, {r0}
    9c84:	00005e02 	andeq	r5, r0, r2, lsl #28
    9c88:	000001c5 	andeq	r0, r0, r5, asr #3
    9c8c:	005e1609 	subseq	r1, lr, r9, lsl #12
    9c90:	0001d000 	andeq	sp, r1, r0
    9c94:	e9060000 	stmdb	r6, {}	; <UNPREDICTABLE>
    9c98:	0100001e 	tsteq	r0, lr, lsl r0
    9c9c:	0000009e 	muleq	r0, lr, r0
    9ca0:	00007000 	andeq	r7, r0, r0
    9ca4:	4f9c0100 	svcmi	0x009c0100
    9ca8:	07000001 	streq	r0, [r0, -r1]
    9cac:	00001f15 	andeq	r1, r0, r5, lsl pc
    9cb0:	003aa001 	eorseq	sl, sl, r1
    9cb4:	923e0000 	eorsls	r0, lr, #0
    9cb8:	0a000000 	beq	9cc0 <_etext+0x26ac>
    9cbc:	00000802 	andeq	r0, r0, r2, lsl #16
    9cc0:	5b022a03 	blpl	944d4 <_etext+0x8cec0>
    9cc4:	0b000001 	bleq	9cd0 <_etext+0x26bc>
    9cc8:	0000004c 	andeq	r0, r0, ip, asr #32
    9ccc:	001eff0c 	andseq	pc, lr, ip, lsl #30
    9cd0:	4c170100 	ldfmis	f0, [r7], {-0}
    9cd4:	05000000 	streq	r0, [r0, #-0]
    9cd8:	00057603 	andeq	r7, r5, r3, lsl #12
    9cdc:	1f0a0c20 	svcne	0x000a0c20
    9ce0:	18010000 	stmdane	r1, {}	; <UNPREDICTABLE>
    9ce4:	0000004c 	andeq	r0, r0, ip, asr #32
    9ce8:	05780305 	ldrbeq	r0, [r8, #-773]!	; 0x305
    9cec:	470d2000 	strmi	r2, [sp, -r0]
    9cf0:	0400001f 	streq	r0, [r0], #-31
    9cf4:	00005e1d 	andeq	r5, r0, sp, lsl lr
    9cf8:	00700e00 	rsbseq	r0, r0, r0, lsl #28
    9cfc:	019d0000 	orrseq	r0, sp, r0
    9d00:	9d0f0000 	stcls	0, cr0, [pc, #-0]	; 9d08 <_etext+0x26f4>
    9d04:	06000001 	streq	r0, [r0], -r1
    9d08:	07040200 	streq	r0, [r4, -r0, lsl #4]
    9d0c:	0000078b 	andeq	r0, r0, fp, lsl #15
    9d10:	0009b30d 	andeq	fp, r9, sp, lsl #6
    9d14:	8d1b0100 	ldfhis	f0, [fp, #-0]
    9d18:	0d000001 	stceq	0, cr0, [r0, #-4]
    9d1c:	00000965 	andeq	r0, r0, r5, ror #18
    9d20:	018d1c01 	orreq	r1, sp, r1, lsl #24
    9d24:	2e100000 	cdpcs	0, 1, cr0, cr0, cr0, {0}
    9d28:	0500001f 	streq	r0, [r0, #-31]
    9d2c:	00005edc 	ldrdeq	r5, [r0], -ip
    9d30:	1ef01000 	cdpne	0, 15, cr1, cr0, cr0, {0}
    9d34:	d9050000 	stmdble	r5, {}	; <UNPREDICTABLE>
    9d38:	0000005e 	andeq	r0, r0, lr, asr r0
    9d3c:	001f3a10 	andseq	r3, pc, r0, lsl sl	; <UNPREDICTABLE>
    9d40:	5edb0500 	cdppl	5, 13, cr0, cr11, cr0, {0}
    9d44:	00000000 	andeq	r0, r0, r0
    9d48:	000003f9 	strdeq	r0, [r0], -r9
    9d4c:	24130004 	ldrcs	r0, [r3], #-4
    9d50:	01040000 	mrseq	r0, (UNDEF: 4)
    9d54:	00000639 	andeq	r0, r0, r9, lsr r6
    9d58:	001f5901 	andseq	r5, pc, r1, lsl #18
    9d5c:	00089300 	andeq	r9, r8, r0, lsl #6
    9d60:	000e8000 	andeq	r8, lr, r0
    9d64:	00000000 	andeq	r0, r0, r0
    9d68:	0038e100 	eorseq	lr, r8, r0, lsl #2
    9d6c:	05040200 	streq	r0, [r4, #-512]	; 0x200
    9d70:	000004da 	ldrdeq	r0, [r0], -sl
    9d74:	fc050202 	stc2	2, cr0, [r5], {2}
    9d78:	02000006 	andeq	r0, r0, #6
    9d7c:	081a0601 	ldmdaeq	sl, {r0, r9, sl}
    9d80:	04020000 	streq	r0, [r2], #-0
    9d84:	00025207 	andeq	r5, r2, r7, lsl #4
    9d88:	31750300 	cmncc	r5, r0, lsl #6
    9d8c:	25020036 	strcs	r0, [r2, #-54]	; 0x36
    9d90:	0000004c 	andeq	r0, r0, ip, asr #32
    9d94:	49070202 	stmdbmi	r7, {r1, r9}
    9d98:	03000009 	movweq	r0, #9
    9d9c:	02003875 	andeq	r3, r0, #7667712	; 0x750000
    9da0:	00005d26 	andeq	r5, r0, r6, lsr #26
    9da4:	08010200 	stmdaeq	r1, {r9}
    9da8:	00000818 	andeq	r0, r0, r8, lsl r8
    9dac:	00530404 	subseq	r0, r3, r4, lsl #8
    9db0:	c0050000 	andgt	r0, r5, r0
    9db4:	01000007 	tsteq	r0, r7
    9db8:	008f2d03 	addeq	r2, pc, r3, lsl #26
    9dbc:	86060000 	strhi	r0, [r6], -r0
    9dc0:	00000002 	andeq	r0, r0, r2
    9dc4:	0009a906 	andeq	sl, r9, r6, lsl #18
    9dc8:	30060100 	andcc	r0, r6, r0, lsl #2
    9dcc:	02000001 	andeq	r0, r0, #1
    9dd0:	00062b06 	andeq	r2, r6, r6, lsl #22
    9dd4:	07000300 	streq	r0, [r0, -r0, lsl #6]
    9dd8:	000007c1 	andeq	r0, r0, r1, asr #15
    9ddc:	006a3403 	rsbeq	r3, sl, r3, lsl #8
    9de0:	ff080000 			; <UNDEFINED> instruction: 0xff080000
    9de4:	0c000005 	stceq	0, cr0, [r0], {5}
    9de8:	00d73803 	sbcseq	r3, r7, r3, lsl #16
    9dec:	d7090000 	strle	r0, [r9, -r0]
    9df0:	03000001 	movweq	r0, #1
    9df4:	00004150 	andeq	r4, r0, r0, asr r1
    9df8:	6d090000 	stcvs	0, cr0, [r9, #-0]
    9dfc:	03000008 	movweq	r0, #8
    9e00:	00004151 	andeq	r4, r0, r1, asr r1
    9e04:	25090200 	strcs	r0, [r9, #-512]	; 0x200
    9e08:	03000021 	movweq	r0, #33	; 0x21
    9e0c:	00004152 	andeq	r4, r0, r2, asr r1
    9e10:	38090400 	stmdacc	r9, {sl}
    9e14:	03000007 	movweq	r0, #7
    9e18:	0000e653 	andeq	lr, r0, r3, asr r6
    9e1c:	0a000800 	beq	be24 <_etext+0x4810>
    9e20:	00000064 	andeq	r0, r0, r4, rrx
    9e24:	000000e6 	andeq	r0, r0, r6, ror #1
    9e28:	0000410b 	andeq	r4, r0, fp, lsl #2
    9e2c:	04040000 	streq	r0, [r4], #-0
    9e30:	000000d7 	ldrdeq	r0, [r0], -r7
    9e34:	00060007 	andeq	r0, r6, r7
    9e38:	9a540300 	bls	150aa40 <_etext+0x150342c>
    9e3c:	0c000000 	stceq	0, cr0, [r0], {-0}
    9e40:	02005742 	andeq	r5, r0, #17301504	; 0x1080000
    9e44:	011b6203 	tsteq	fp, r3, lsl #4
    9e48:	620d0000 	andvs	r0, sp, #0
    9e4c:	03003062 	movweq	r3, #98	; 0x62
    9e50:	00005365 	andeq	r5, r0, r5, ror #6
    9e54:	620d0000 	andvs	r0, sp, #0
    9e58:	03003162 	movweq	r3, #354	; 0x162
    9e5c:	00005366 	andeq	r5, r0, r6, ror #6
    9e60:	0e000100 	adfeqs	f0, f0, f0
    9e64:	375f0302 	ldrbcc	r0, [pc, -r2, lsl #6]
    9e68:	0f000001 	svceq	0x00000001
    9e6c:	61030077 	tstvs	r3, r7, ror r0
    9e70:	00000041 	andeq	r0, r0, r1, asr #32
    9e74:	0077620f 	rsbseq	r6, r7, pc, lsl #4
    9e78:	00f76803 	rscseq	r6, r7, r3, lsl #16
    9e7c:	07000000 	streq	r0, [r0, -r0]
    9e80:	00000930 	andeq	r0, r0, r0, lsr r9
    9e84:	011b6903 	tsteq	fp, r3, lsl #18
    9e88:	14080000 	strne	r0, [r8], #-0
    9e8c:	1c000001 	stcne	0, cr0, [r0], {1}
    9e90:	01d36b03 	bicseq	r6, r3, r3, lsl #22
    9e94:	67090000 	strvs	r0, [r9, -r0]
    9e98:	03000007 	movweq	r0, #7
    9e9c:	0000536d 	andeq	r5, r0, sp, ror #6
    9ea0:	15090000 	strne	r0, [r9, #-0]
    9ea4:	03000000 	movweq	r0, #0
    9ea8:	0000536e 	andeq	r5, r0, lr, ror #6
    9eac:	11090100 	mrsne	r0, (UNDEF: 25)
    9eb0:	03000003 	movweq	r0, #3
    9eb4:	0001376f 	andeq	r3, r1, pc, ror #14
    9eb8:	48090200 	stmdami	r9, {r9}
    9ebc:	03000001 	movweq	r0, #1
    9ec0:	00013770 	andeq	r3, r1, r0, ror r7
    9ec4:	eb090400 	bl	24aecc <_etext+0x2438b8>
    9ec8:	03000004 	movweq	r0, #4
    9ecc:	00013771 	andeq	r3, r1, r1, ror r7
    9ed0:	ef090600 	svc	0x00090600
    9ed4:	03000006 	movweq	r0, #6
    9ed8:	00005373 	andeq	r5, r0, r3, ror r3
    9edc:	08090800 	stmdaeq	r9, {fp}
    9ee0:	03000008 	movweq	r0, #8
    9ee4:	00005374 	andeq	r5, r0, r4, ror r3
    9ee8:	07090900 	streq	r0, [r9, -r0, lsl #18]
    9eec:	03000005 	movweq	r0, #5
    9ef0:	00005375 	andeq	r5, r0, r5, ror r3
    9ef4:	4f090a00 	svcmi	0x00090a00
    9ef8:	03000005 	movweq	r0, #5
    9efc:	00005376 	andeq	r5, r0, r6, ror r3
    9f00:	d6090b00 	strle	r0, [r9], -r0, lsl #22
    9f04:	03000005 	movweq	r0, #5
    9f08:	00005377 	andeq	r5, r0, r7, ror r3
    9f0c:	c8090c00 	stmdagt	r9, {sl, fp}
    9f10:	03000007 	movweq	r0, #7
    9f14:	0000ec7a 	andeq	lr, r0, sl, ror ip
    9f18:	07001000 	streq	r1, [r0, -r0]
    9f1c:	00000115 	andeq	r0, r0, r5, lsl r1
    9f20:	01427b03 	cmpeq	r2, r3, lsl #22
    9f24:	a9080000 	stmdbge	r8, {}	; <UNPREDICTABLE>
    9f28:	34000003 	strcc	r0, [r0], #-3
    9f2c:	02877d03 	addeq	r7, r7, #3, 26	; 0xc0
    9f30:	96090000 	strls	r0, [r9], -r0
    9f34:	03000002 	movweq	r0, #2
    9f38:	0002887f 	andeq	r8, r2, pc, ror r8
    9f3c:	b8090000 	stmdalt	r9, {}	; <UNPREDICTABLE>
    9f40:	03000004 	movweq	r0, #4
    9f44:	00028880 	andeq	r8, r2, r0, lsl #17
    9f48:	37090400 	strcc	r0, [r9, -r0, lsl #8]
    9f4c:	03000009 	movweq	r0, #9
    9f50:	00028883 	andeq	r8, r2, r3, lsl #17
    9f54:	78090800 	stmdavc	r9, {fp}
    9f58:	03000007 	movweq	r0, #7
    9f5c:	00028884 	andeq	r8, r2, r4, lsl #17
    9f60:	c3090c00 	movwgt	r0, #39936	; 0x9c00
    9f64:	03000002 	movweq	r0, #2
    9f68:	00029d96 	muleq	r2, r6, sp
    9f6c:	6d091000 	stcvs	0, cr1, [r9, #-0]
    9f70:	03000000 	movweq	r0, #0
    9f74:	00029da1 	andeq	r9, r2, r1, lsr #27
    9f78:	c5091400 	strgt	r1, [r9, #-1024]	; 0x400
    9f7c:	03000009 	movweq	r0, #9
    9f80:	0002b7ab 	andeq	fp, r2, fp, lsr #15
    9f84:	d7091800 	strle	r1, [r9, -r0, lsl #16]
    9f88:	03000002 	movweq	r0, #2
    9f8c:	0000e6ad 	andeq	lr, r0, sp, lsr #13
    9f90:	b9091c00 	stmdblt	r9, {sl, fp, ip}
    9f94:	03000003 	movweq	r0, #3
    9f98:	0000e6ae 	andeq	lr, r0, lr, lsr #13
    9f9c:	c3092000 	movwgt	r2, #36864	; 0x9000
    9fa0:	03000001 	movweq	r0, #1
    9fa4:	0000e6af 	andeq	lr, r0, pc, lsr #13
    9fa8:	42092400 	andmi	r2, r9, #0, 8
    9fac:	03000003 	movweq	r0, #3
    9fb0:	0000e6b0 			; <UNDEFINED> instruction: 0x0000e6b0
    9fb4:	67092800 	strvs	r2, [r9, -r0, lsl #16]
    9fb8:	03000004 	movweq	r0, #4
    9fbc:	000064b2 			; <UNDEFINED> instruction: 0x000064b2
    9fc0:	22092c00 	andcs	r2, r9, #0, 24
    9fc4:	03000021 	movweq	r0, #33	; 0x21
    9fc8:	000053b3 			; <UNDEFINED> instruction: 0x000053b3
    9fcc:	10003000 	andne	r3, r0, r0
    9fd0:	02870404 	addeq	r0, r7, #4, 8	; 0x4000000
    9fd4:	8f0a0000 	svchi	0x000a0000
    9fd8:	9d000000 	stcls	0, cr0, [r0, #-0]
    9fdc:	0b000002 	bleq	9fec <_etext+0x29d8>
    9fe0:	00000053 	andeq	r0, r0, r3, asr r0
    9fe4:	8e040400 	cfcpyshi	mvf0, mvf4
    9fe8:	0a000002 	beq	9ff8 <_etext+0x29e4>
    9fec:	0000008f 	andeq	r0, r0, pc, lsl #1
    9ff0:	000002b7 			; <UNDEFINED> instruction: 0x000002b7
    9ff4:	0000530b 	andeq	r5, r0, fp, lsl #6
    9ff8:	00530b00 	subseq	r0, r3, r0, lsl #22
    9ffc:	04000000 	streq	r0, [r0], #-0
    a000:	0002a304 	andeq	sl, r2, r4, lsl #6
    a004:	03aa0700 			; <UNDEFINED> instruction: 0x03aa0700
    a008:	b5030000 	strlt	r0, [r3, #-0]
    a00c:	000001de 	ldrdeq	r0, [r0], -lr
    a010:	00008a08 	andeq	r8, r0, r8, lsl #20
    a014:	b7032400 	strlt	r2, [r3, -r0, lsl #8]
    a018:	00000341 	andeq	r0, r0, r1, asr #6
    a01c:	0005a009 	andeq	sl, r5, r9
    a020:	88b90300 	ldmhi	r9!, {r8, r9}
    a024:	00000002 	andeq	r0, r0, r2
    a028:	00041d09 	andeq	r1, r4, r9, lsl #26
    a02c:	88ba0300 	ldmhi	sl!, {r8, r9}
    a030:	04000002 	streq	r0, [r0], #-2
    a034:	00029b09 	andeq	r9, r2, r9, lsl #22
    a038:	88bb0300 	ldmhi	fp!, {r8, r9}
    a03c:	08000002 	stmdaeq	r0, {r1}
    a040:	00043309 	andeq	r3, r4, r9, lsl #6
    a044:	88bc0300 	ldmhi	ip!, {r8, r9}
    a048:	0c000002 	stceq	0, cr0, [r0], {2}
    a04c:	0000a209 	andeq	sl, r0, r9, lsl #4
    a050:	88bd0300 	pophi	{r8, r9}
    a054:	10000002 	andne	r0, r0, r2
    a058:	00074109 	andeq	r4, r7, r9, lsl #2
    a05c:	88be0300 	ldmhi	lr!, {r8, r9}
    a060:	14000002 	strne	r0, [r0], #-2
    a064:	0008f809 	andeq	pc, r8, r9, lsl #16
    a068:	88bf0300 	ldmhi	pc!, {r8, r9}	; <UNPREDICTABLE>
    a06c:	18000002 	stmdane	r0, {r1}
    a070:	00019109 	andeq	r9, r1, r9, lsl #2
    a074:	88c00300 	stmiahi	r0, {r8, r9}^
    a078:	1c000002 	stcne	0, cr0, [r0], {2}
    a07c:	0002ad09 	andeq	sl, r2, r9, lsl #26
    a080:	88c10300 	stmiahi	r1, {r8, r9}^
    a084:	20000002 	andcs	r0, r0, r2
    a088:	008b0700 	addeq	r0, fp, r0, lsl #14
    a08c:	c3030000 	movwgt	r0, #12288	; 0x3000
    a090:	000002c8 	andeq	r0, r0, r8, asr #5
    a094:	00029211 	andeq	r9, r2, r1, lsl r2
    a098:	c8350100 	ldmdagt	r5!, {r8}
    a09c:	3800005e 	stmdacc	r0, {r1, r2, r3, r4, r6}
    a0a0:	01000000 	mrseq	r0, (UNDEF: 0)
    a0a4:	02eb129c 	rsceq	r1, fp, #156, 4	; 0xc0000009
    a0a8:	ec030000 	stc	0, cr0, [r3], {-0}
    a0ac:	000002bd 			; <UNDEFINED> instruction: 0x000002bd
    a0b0:	001f6d12 	andseq	r6, pc, r2, lsl sp	; <UNPREDICTABLE>
    a0b4:	41ed0300 	mvnmi	r0, r0, lsl #6
    a0b8:	13000003 	movwne	r0, #3
    a0bc:	00001f84 	andeq	r1, r0, r4, lsl #31
    a0c0:	01d32701 	bicseq	r2, r3, r1, lsl #14
    a0c4:	03050000 	movweq	r0, #20480	; 0x5000
    a0c8:	20000588 	andcs	r0, r0, r8, lsl #11
    a0cc:	001f4713 	andseq	r4, pc, r3, lsl r7	; <UNPREDICTABLE>
    a0d0:	53180100 	tstpl	r8, #0, 2
    a0d4:	05000000 	streq	r0, [r0, #-0]
    a0d8:	00058403 	andeq	r8, r5, r3, lsl #8
    a0dc:	01e81320 	mvneq	r1, r0, lsr #6
    a0e0:	1d010000 	stcne	0, cr0, [r1, #-0]
    a0e4:	000003a6 	andeq	r0, r0, r6, lsr #7
    a0e8:	05a80305 	streq	r0, [r8, #773]!	; 0x305
    a0ec:	04042000 	streq	r2, [r4], #-0
    a0f0:	000001d3 	ldrdeq	r0, [r0], -r3
    a0f4:	00013e13 	andeq	r3, r1, r3, lsl lr
    a0f8:	bd200100 	stflts	f0, [r0, #-0]
    a0fc:	05000003 	streq	r0, [r0, #-3]
    a100:	00058003 	andeq	r8, r5, r3
    a104:	bd040420 	cfstrslt	mvf0, [r4, #-128]	; 0xffffff80
    a108:	13000002 	movwne	r0, #2
    a10c:	00001f6c 	andeq	r1, r0, ip, ror #30
    a110:	03d42801 	bicseq	r2, r4, #65536	; 0x10000
    a114:	03050000 	movweq	r0, #20480	; 0x5000
    a118:	200005a4 	andcs	r0, r0, r4, lsr #11
    a11c:	03410404 	movteq	r0, #5124	; 0x1404
    a120:	4f130000 	svcmi	0x00130000
    a124:	0100001f 	tsteq	r0, pc, lsl r0
    a128:	00004125 	andeq	r4, r0, r5, lsr #2
    a12c:	7c030500 	cfstr32vc	mvfx0, [r3], {-0}
    a130:	13200005 	teqne	r0, #5
    a134:	0000051d 	andeq	r0, r0, sp, lsl r5
    a138:	00412601 	subeq	r2, r1, r1, lsl #12
    a13c:	03050000 	movweq	r0, #20480	; 0x5000
    a140:	200005ac 	andcs	r0, r0, ip, lsr #11
    a144:	000de000 	andeq	lr, sp, r0
    a148:	16000400 	strne	r0, [r0], -r0, lsl #8
    a14c:	04000025 	streq	r0, [r0], #-37	; 0x25
    a150:	00063901 	andeq	r3, r6, r1, lsl #18
    a154:	1f900100 	svcne	0x00900100
    a158:	08930000 	ldmeq	r3, {}	; <UNPREDICTABLE>
    a15c:	0ec80000 	cdpeq	0, 12, cr0, cr8, cr0, {0}
    a160:	00000000 	andeq	r0, r0, r0
    a164:	39480000 	stmdbcc	r8, {}^	; <UNPREDICTABLE>
    a168:	04020000 	streq	r0, [r2], #-0
    a16c:	0004da05 	andeq	sp, r4, r5, lsl #20
    a170:	05020200 	streq	r0, [r2, #-512]	; 0x200
    a174:	000006fc 	strdeq	r0, [r0], -ip
    a178:	1a060102 	bne	18a588 <_etext+0x182f74>
    a17c:	03000008 	movweq	r0, #8
    a180:	00323375 	eorseq	r3, r2, r5, ror r3
    a184:	00452402 	subeq	r2, r5, r2, lsl #8
    a188:	04020000 	streq	r0, [r2], #-0
    a18c:	00025207 	andeq	r5, r2, r7, lsl #4
    a190:	31750300 	cmncc	r5, r0, lsl #6
    a194:	25020036 	strcs	r0, [r2, #-54]	; 0x36
    a198:	00000057 	andeq	r0, r0, r7, asr r0
    a19c:	49070202 	stmdbmi	r7, {r1, r9}
    a1a0:	03000009 	movweq	r0, #9
    a1a4:	02003875 	andeq	r3, r0, #7667712	; 0x750000
    a1a8:	00006826 	andeq	r6, r0, r6, lsr #16
    a1ac:	08010200 	stmdaeq	r1, {r9}
    a1b0:	00000818 	andeq	r0, r0, r8, lsl r8
    a1b4:	00035a04 	andeq	r5, r3, r4, lsl #20
    a1b8:	7a2c0200 	bvc	b0a9c0 <_etext+0xb033ac>
    a1bc:	05000000 	streq	r0, [r0, #-0]
    a1c0:	00000045 	andeq	r0, r0, r5, asr #32
    a1c4:	36020106 	strcc	r0, [r2], -r6, lsl #2
    a1c8:	00000094 	muleq	r0, r4, r0
    a1cc:	00075307 	andeq	r5, r7, r7, lsl #6
    a1d0:	a7070000 	strge	r0, [r7, -r0]
    a1d4:	01000001 	tsteq	r0, r1
    a1d8:	052d0400 	streq	r0, [sp, #-1024]!	; 0x400
    a1dc:	39020000 	stmdbcc	r2, {}	; <UNPREDICTABLE>
    a1e0:	0000007f 	andeq	r0, r0, pc, ror r0
    a1e4:	00023d08 	andeq	r3, r2, r8, lsl #26
    a1e8:	16030100 	strne	r0, [r3], -r0, lsl #2
    a1ec:	000000c4 	andeq	r0, r0, r4, asr #1
    a1f0:	00053207 	andeq	r3, r5, r7, lsl #4
    a1f4:	24070000 	strcs	r0, [r7], #-0
    a1f8:	01000007 	tsteq	r0, r7
    a1fc:	00017e07 	andeq	r7, r1, r7, lsl #28
    a200:	20070200 	andcs	r0, r7, r0, lsl #4
    a204:	03000009 	movweq	r0, #9
    a208:	008f0800 	addeq	r0, pc, r0, lsl #16
    a20c:	03010000 	movweq	r0, #4096	; 0x1000
    a210:	0001251f 	andeq	r2, r1, pc, lsl r5
    a214:	21020700 	tstcs	r2, r0, lsl #14
    a218:	07000000 	streq	r0, [r0, -r0]
    a21c:	00002331 	andeq	r2, r0, r1, lsr r3
    a220:	0f860701 	svceq	0x00860701
    a224:	07020000 	streq	r0, [r2, -r0]
    a228:	0000210d 	andeq	r2, r0, sp, lsl #2
    a22c:	0f900703 	svceq	0x00900703
    a230:	07040000 	streq	r0, [r4, -r0]
    a234:	000022c0 	andeq	r2, r0, r0, asr #5
    a238:	22f00705 	rscscs	r0, r0, #1310720	; 0x140000
    a23c:	07060000 	streq	r0, [r6, -r0]
    a240:	00002177 	andeq	r2, r0, r7, ror r1
    a244:	21d60707 	bicscs	r0, r6, r7, lsl #14
    a248:	07080000 	streq	r0, [r8, -r0]
    a24c:	00002227 	andeq	r2, r0, r7, lsr #4
    a250:	20d80709 	sbcscs	r0, r8, r9, lsl #14
    a254:	070a0000 	streq	r0, [sl, -r0]
    a258:	00002186 	andeq	r2, r0, r6, lsl #3
    a25c:	2249070b 	subcs	r0, r9, #2883584	; 0x2c0000
    a260:	070c0000 	streq	r0, [ip, -r0]
    a264:	00002155 	andeq	r2, r0, r5, asr r1
    a268:	f708000c 			; <UNDEFINED> instruction: 0xf708000c
    a26c:	01000021 	tsteq	r0, r1, lsr #32
    a270:	01503203 	cmpeq	r0, r3, lsl #4
    a274:	42070000 	andmi	r0, r7, #0
    a278:	01000020 	tsteq	r0, r0, lsr #32
    a27c:	0022a107 	eoreq	sl, r2, r7, lsl #2
    a280:	54070200 	strpl	r0, [r7], #-512	; 0x200
    a284:	03000020 	movweq	r0, #32
    a288:	00225807 	eoreq	r5, r2, r7, lsl #16
    a28c:	8d070400 	cfstrshi	mvf0, [r7, #-0]
    a290:	05000022 	streq	r0, [r0, #-34]	; 0x22
    a294:	21940800 	orrscs	r0, r4, r0, lsl #16
    a298:	03010000 	movweq	r0, #4096	; 0x1000
    a29c:	0001693c 	andeq	r6, r1, ip, lsr r9
    a2a0:	1fa30700 	svcne	0x00a30700
    a2a4:	07000000 	streq	r0, [r0, -r0]
    a2a8:	00002001 	andeq	r2, r0, r1
    a2ac:	e8080001 	stmda	r8, {r0}
    a2b0:	01000021 	tsteq	r0, r1, lsr #32
    a2b4:	01b21604 			; <UNDEFINED> instruction: 0x01b21604
    a2b8:	0c070000 	stceq	0, cr0, [r7], {-0}
    a2bc:	00000023 	andeq	r0, r0, r3, lsr #32
    a2c0:	00220807 	eoreq	r0, r2, r7, lsl #16
    a2c4:	8c070100 	stfhis	f0, [r7], {-0}
    a2c8:	02000020 	andeq	r0, r0, #32
    a2cc:	00234407 	eoreq	r4, r3, r7, lsl #8
    a2d0:	87070300 	strhi	r0, [r7, -r0, lsl #6]
    a2d4:	04000020 	streq	r0, [r0], #-32
    a2d8:	00233f07 	eoreq	r3, r3, r7, lsl #30
    a2dc:	22070500 	andcs	r0, r7, #0, 10
    a2e0:	06000023 	streq	r0, [r0], -r3, lsr #32
    a2e4:	00223907 	eoreq	r3, r2, r7, lsl #18
    a2e8:	16070700 	strne	r0, [r7], -r0, lsl #14
    a2ec:	08000020 	stmdaeq	r0, {r5}
    a2f0:	0020c807 	eoreq	ip, r0, r7, lsl #16
    a2f4:	09000900 	stmdbeq	r0, {r8, fp}
    a2f8:	00000033 	andeq	r0, r0, r3, lsr r0
    a2fc:	d7240408 	strle	r0, [r4, -r8, lsl #8]!
    a300:	0a000001 	beq	a30c <_etext+0x2cf8>
    a304:	000002e0 	andeq	r0, r0, r0, ror #5
    a308:	01d72604 	bicseq	r2, r7, r4, lsl #12
    a30c:	0a000000 	beq	a314 <_etext+0x2d00>
    a310:	000003f1 	strdeq	r0, [r0], -r1
    a314:	004c2704 	subeq	r2, ip, r4, lsl #14
    a318:	00040000 	andeq	r0, r4, r0
    a31c:	005e040b 	subseq	r0, lr, fp, lsl #8
    a320:	72040000 	andvc	r0, r4, #0
    a324:	04000005 	streq	r0, [r0], #-5
    a328:	0001b229 	andeq	fp, r1, r9, lsr #4
    a32c:	07c00800 	strbeq	r0, [r0, r0, lsl #16]
    a330:	04010000 	streq	r0, [r1], #-0
    a334:	00020d2d 	andeq	r0, r2, sp, lsr #26
    a338:	02860700 	addeq	r0, r6, #0, 14
    a33c:	07000000 	streq	r0, [r0, -r0]
    a340:	000009a9 	andeq	r0, r0, r9, lsr #19
    a344:	01300701 	teqeq	r0, r1, lsl #14
    a348:	07020000 	streq	r0, [r2, -r0]
    a34c:	0000062b 	andeq	r0, r0, fp, lsr #12
    a350:	c1040003 	tstgt	r4, r3
    a354:	04000007 	streq	r0, [r0], #-7
    a358:	0001e834 	andeq	lr, r1, r4, lsr r8
    a35c:	05ff0900 	ldrbeq	r0, [pc, #2304]!	; ac64 <_etext+0x3650>
    a360:	040c0000 	streq	r0, [ip], #-0
    a364:	00025538 	andeq	r5, r2, r8, lsr r5
    a368:	01d70a00 	bicseq	r0, r7, r0, lsl #20
    a36c:	50040000 	andpl	r0, r4, r0
    a370:	0000004c 	andeq	r0, r0, ip, asr #32
    a374:	086d0a00 	stmdaeq	sp!, {r9, fp}^
    a378:	51040000 	mrspl	r0, (UNDEF: 4)
    a37c:	0000004c 	andeq	r0, r0, ip, asr #32
    a380:	21250a02 	teqcs	r5, r2, lsl #20
    a384:	52040000 	andpl	r0, r4, #0
    a388:	0000004c 	andeq	r0, r0, ip, asr #32
    a38c:	07380a04 	ldreq	r0, [r8, -r4, lsl #20]!
    a390:	53040000 	movwpl	r0, #16384	; 0x4000
    a394:	00000264 	andeq	r0, r0, r4, ror #4
    a398:	d70c0008 	strle	r0, [ip, -r8]
    a39c:	64000001 	strvs	r0, [r0], #-1
    a3a0:	0d000002 	stceq	0, cr0, [r0, #-8]
    a3a4:	0000004c 	andeq	r0, r0, ip, asr #32
    a3a8:	55040b00 	strpl	r0, [r4, #-2816]	; 0xb00
    a3ac:	04000002 	streq	r0, [r0], #-2
    a3b0:	00000600 	andeq	r0, r0, r0, lsl #12
    a3b4:	02185404 	andseq	r5, r8, #4, 8	; 0x4000000
    a3b8:	23090000 	movwcs	r0, #36864	; 0x9000
    a3bc:	02000006 	andeq	r0, r0, #6
    a3c0:	029a5804 	addseq	r5, sl, #4, 16	; 0x40000
    a3c4:	700a0000 	andvc	r0, sl, r0
    a3c8:	04000003 	streq	r0, [r0], #-3
    a3cc:	00005e5a 	andeq	r5, r0, sl, asr lr
    a3d0:	8c0a0000 	stchi	0, cr0, [sl], {-0}
    a3d4:	04000005 	streq	r0, [r0], #-5
    a3d8:	00005e5b 	andeq	r5, r0, fp, asr lr
    a3dc:	04000100 	streq	r0, [r0], #-256	; 0x100
    a3e0:	00000624 	andeq	r0, r0, r4, lsr #12
    a3e4:	02755d04 	rsbseq	r5, r5, #4, 26	; 0x100
    a3e8:	420e0000 	andmi	r0, lr, #0
    a3ec:	04020057 	streq	r0, [r2], #-87	; 0x57
    a3f0:	0002c962 	andeq	ip, r2, r2, ror #18
    a3f4:	62620f00 	rsbvs	r0, r2, #0, 30
    a3f8:	65040030 	strvs	r0, [r4, #-48]	; 0x30
    a3fc:	0000005e 	andeq	r0, r0, lr, asr r0
    a400:	62620f00 	rsbvs	r0, r2, #0, 30
    a404:	66040031 			; <UNDEFINED> instruction: 0x66040031
    a408:	0000005e 	andeq	r0, r0, lr, asr r0
    a40c:	02100001 	andseq	r0, r0, #1
    a410:	02e55f04 	rsceq	r5, r5, #4, 30
    a414:	77110000 	ldrvc	r0, [r1, -r0]
    a418:	4c610400 	cfstrdmi	mvd0, [r1], #-0
    a41c:	11000000 	mrsne	r0, (UNDEF: 0)
    a420:	04007762 	streq	r7, [r0], #-1890	; 0x762
    a424:	0002a568 	andeq	sl, r2, r8, ror #10
    a428:	30040000 	andcc	r0, r4, r0
    a42c:	04000009 	streq	r0, [r0], #-9
    a430:	0002c969 	andeq	ip, r2, r9, ror #18
    a434:	01140900 	tsteq	r4, r0, lsl #18
    a438:	041c0000 	ldreq	r0, [ip], #-0
    a43c:	0003816b 	andeq	r8, r3, fp, ror #2
    a440:	07670a00 	strbeq	r0, [r7, -r0, lsl #20]!
    a444:	6d040000 	stcvs	0, cr0, [r4, #-0]
    a448:	0000005e 	andeq	r0, r0, lr, asr r0
    a44c:	00150a00 	andseq	r0, r5, r0, lsl #20
    a450:	6e040000 	cdpvs	0, 0, cr0, cr4, cr0, {0}
    a454:	0000005e 	andeq	r0, r0, lr, asr r0
    a458:	03110a01 	tsteq	r1, #4096	; 0x1000
    a45c:	6f040000 	svcvs	0x00040000
    a460:	000002e5 	andeq	r0, r0, r5, ror #5
    a464:	01480a02 	cmpeq	r8, r2, lsl #20
    a468:	70040000 	andvc	r0, r4, r0
    a46c:	000002e5 	andeq	r0, r0, r5, ror #5
    a470:	04eb0a04 	strbteq	r0, [fp], #2564	; 0xa04
    a474:	71040000 	mrsvc	r0, (UNDEF: 4)
    a478:	000002e5 	andeq	r0, r0, r5, ror #5
    a47c:	06ef0a06 	strbteq	r0, [pc], r6, lsl #20
    a480:	73040000 	movwvc	r0, #16384	; 0x4000
    a484:	0000005e 	andeq	r0, r0, lr, asr r0
    a488:	08080a08 	stmdaeq	r8, {r3, r9, fp}
    a48c:	74040000 	strvc	r0, [r4], #-0
    a490:	0000005e 	andeq	r0, r0, lr, asr r0
    a494:	05070a09 	streq	r0, [r7, #-2569]	; 0xa09
    a498:	75040000 	strvc	r0, [r4, #-0]
    a49c:	0000005e 	andeq	r0, r0, lr, asr r0
    a4a0:	054f0a0a 	strbeq	r0, [pc, #-2570]	; 9a9e <_etext+0x248a>
    a4a4:	76040000 	strvc	r0, [r4], -r0
    a4a8:	0000005e 	andeq	r0, r0, lr, asr r0
    a4ac:	05d60a0b 	ldrbeq	r0, [r6, #2571]	; 0xa0b
    a4b0:	77040000 	strvc	r0, [r4, -r0]
    a4b4:	0000005e 	andeq	r0, r0, lr, asr r0
    a4b8:	07c80a0c 	strbeq	r0, [r8, ip, lsl #20]
    a4bc:	7a040000 	bvc	10a4c4 <_etext+0x102eb0>
    a4c0:	0000026a 	andeq	r0, r0, sl, ror #4
    a4c4:	15040010 	strne	r0, [r4, #-16]
    a4c8:	04000001 	streq	r0, [r0], #-1
    a4cc:	0002f07b 	andeq	pc, r2, fp, ror r0	; <UNPREDICTABLE>
    a4d0:	03a90900 			; <UNDEFINED> instruction: 0x03a90900
    a4d4:	04340000 	ldrteq	r0, [r4], #-0
    a4d8:	0004357d 	andeq	r3, r4, sp, ror r5
    a4dc:	02960a00 	addseq	r0, r6, #0, 20
    a4e0:	7f040000 	svcvc	0x00040000
    a4e4:	00000436 	andeq	r0, r0, r6, lsr r4
    a4e8:	04b80a00 	ldrteq	r0, [r8], #2560	; 0xa00
    a4ec:	80040000 	andhi	r0, r4, r0
    a4f0:	00000436 	andeq	r0, r0, r6, lsr r4
    a4f4:	09370a04 	ldmdbeq	r7!, {r2, r9, fp}
    a4f8:	83040000 	movwhi	r0, #16384	; 0x4000
    a4fc:	00000436 	andeq	r0, r0, r6, lsr r4
    a500:	07780a08 	ldrbeq	r0, [r8, -r8, lsl #20]!
    a504:	84040000 	strhi	r0, [r4], #-0
    a508:	00000436 	andeq	r0, r0, r6, lsr r4
    a50c:	02c30a0c 	sbceq	r0, r3, #12, 20	; 0xc000
    a510:	96040000 	strls	r0, [r4], -r0
    a514:	0000044b 	andeq	r0, r0, fp, asr #8
    a518:	006d0a10 	rsbeq	r0, sp, r0, lsl sl
    a51c:	a1040000 	mrsge	r0, (UNDEF: 4)
    a520:	0000044b 	andeq	r0, r0, fp, asr #8
    a524:	09c50a14 	stmibeq	r5, {r2, r4, r9, fp}^
    a528:	ab040000 	blge	10a530 <_etext+0x102f1c>
    a52c:	00000465 	andeq	r0, r0, r5, ror #8
    a530:	02d70a18 	sbcseq	r0, r7, #24, 20	; 0x18000
    a534:	ad040000 	stcge	0, cr0, [r4, #-0]
    a538:	00000264 	andeq	r0, r0, r4, ror #4
    a53c:	03b90a1c 			; <UNDEFINED> instruction: 0x03b90a1c
    a540:	ae040000 	cdpge	0, 0, cr0, cr4, cr0, {0}
    a544:	00000264 	andeq	r0, r0, r4, ror #4
    a548:	01c30a20 	biceq	r0, r3, r0, lsr #20
    a54c:	af040000 	svcge	0x00040000
    a550:	00000264 	andeq	r0, r0, r4, ror #4
    a554:	03420a24 	movteq	r0, #10788	; 0x2a24
    a558:	b0040000 	andlt	r0, r4, r0
    a55c:	00000264 	andeq	r0, r0, r4, ror #4
    a560:	04670a28 	strbteq	r0, [r7], #-2600	; 0xa28
    a564:	b2040000 	andlt	r0, r4, #0
    a568:	000001d7 	ldrdeq	r0, [r0], -r7
    a56c:	21220a2c 	teqcs	r2, ip, lsr #20
    a570:	b3040000 	movwlt	r0, #16384	; 0x4000
    a574:	0000005e 	andeq	r0, r0, lr, asr r0
    a578:	0b120030 	bleq	48a640 <_etext+0x48302c>
    a57c:	00043504 	andeq	r3, r4, r4, lsl #10
    a580:	020d0c00 	andeq	r0, sp, #0, 24
    a584:	044b0000 	strbeq	r0, [fp], #-0
    a588:	5e0d0000 	cdppl	0, 0, cr0, cr13, cr0, {0}
    a58c:	00000000 	andeq	r0, r0, r0
    a590:	043c040b 	ldrteq	r0, [ip], #-1035	; 0x40b
    a594:	0d0c0000 	stceq	0, cr0, [ip, #-0]
    a598:	65000002 	strvs	r0, [r0, #-2]
    a59c:	0d000004 	stceq	0, cr0, [r0, #-16]
    a5a0:	0000005e 	andeq	r0, r0, lr, asr r0
    a5a4:	00005e0d 	andeq	r5, r0, sp, lsl #28
    a5a8:	040b0000 	streq	r0, [fp], #-0
    a5ac:	00000451 	andeq	r0, r0, r1, asr r4
    a5b0:	0003aa04 	andeq	sl, r3, r4, lsl #20
    a5b4:	8cb50400 	cfldrshi	mvf0, [r5]
    a5b8:	09000003 	stmdbeq	r0, {r0, r1}
    a5bc:	0000008a 	andeq	r0, r0, sl, lsl #1
    a5c0:	efb70424 	svc	0x00b70424
    a5c4:	0a000004 	beq	a5dc <_etext+0x2fc8>
    a5c8:	000005a0 	andeq	r0, r0, r0, lsr #11
    a5cc:	0436b904 	ldrteq	fp, [r6], #-2308	; 0x904
    a5d0:	0a000000 	beq	a5d8 <_etext+0x2fc4>
    a5d4:	0000041d 	andeq	r0, r0, sp, lsl r4
    a5d8:	0436ba04 	ldrteq	fp, [r6], #-2564	; 0xa04
    a5dc:	0a040000 	beq	10a5e4 <_etext+0x102fd0>
    a5e0:	0000029b 	muleq	r0, fp, r2
    a5e4:	0436bb04 	ldrteq	fp, [r6], #-2820	; 0xb04
    a5e8:	0a080000 	beq	20a5f0 <_etext+0x202fdc>
    a5ec:	00000433 	andeq	r0, r0, r3, lsr r4
    a5f0:	0436bc04 	ldrteq	fp, [r6], #-3076	; 0xc04
    a5f4:	0a0c0000 	beq	30a5fc <_etext+0x302fe8>
    a5f8:	000000a2 	andeq	r0, r0, r2, lsr #1
    a5fc:	0436bd04 	ldrteq	fp, [r6], #-3332	; 0xd04
    a600:	0a100000 	beq	40a608 <_etext+0x402ff4>
    a604:	00000741 	andeq	r0, r0, r1, asr #14
    a608:	0436be04 	ldrteq	fp, [r6], #-3588	; 0xe04
    a60c:	0a140000 	beq	50a614 <_etext+0x503000>
    a610:	000008f8 	strdeq	r0, [r0], -r8
    a614:	0436bf04 	ldrteq	fp, [r6], #-3844	; 0xf04
    a618:	0a180000 	beq	60a620 <_etext+0x60300c>
    a61c:	00000191 	muleq	r0, r1, r1
    a620:	0436c004 	ldrteq	ip, [r6], #-4
    a624:	0a1c0000 	beq	70a62c <_etext+0x703018>
    a628:	000002ad 	andeq	r0, r0, sp, lsr #5
    a62c:	0436c104 	ldrteq	ip, [r6], #-260	; 0x104
    a630:	00200000 	eoreq	r0, r0, r0
    a634:	00008b04 	andeq	r8, r0, r4, lsl #22
    a638:	76c30400 	strbvc	r0, [r3], r0, lsl #8
    a63c:	13000004 	movwne	r0, #4
    a640:	000021a6 	andeq	r2, r0, r6, lsr #3
    a644:	01d73501 	bicseq	r3, r7, r1, lsl #10
    a648:	5f000000 	svcpl	0x00000000
    a64c:	00240000 	eoreq	r0, r4, r0
    a650:	9c010000 	stcls	0, cr0, [r1], {-0}
    a654:	00000523 	andeq	r0, r0, r3, lsr #10
    a658:	000b0214 	andeq	r0, fp, r4, lsl r2
    a65c:	4c350100 	ldfmis	f0, [r5], #-0
    a660:	80000000 	andhi	r0, r0, r0
    a664:	00000092 	muleq	r0, r2, r0
    a668:	00216113 	eoreq	r6, r1, r3, lsl r1
    a66c:	d7630100 	strble	r0, [r3, -r0, lsl #2]!
    a670:	24000001 	strcs	r0, [r0], #-1
    a674:	2400005f 	strcs	r0, [r0], #-95	; 0x5f
    a678:	01000000 	mrseq	r0, (UNDEF: 0)
    a67c:	00054c9c 	muleq	r5, ip, ip
    a680:	0b021400 	bleq	8f688 <_etext+0x88074>
    a684:	63010000 	movwvs	r0, #4096	; 0x1000
    a688:	0000004c 	andeq	r0, r0, ip, asr #32
    a68c:	000092a1 	andeq	r9, r0, r1, lsr #5
    a690:	227a1300 	rsbscs	r1, sl, #0, 6
    a694:	9b010000 	blls	4a69c <_etext+0x43088>
    a698:	000001d7 	ldrdeq	r0, [r0], -r7
    a69c:	00005f48 	andeq	r5, r0, r8, asr #30
    a6a0:	00000090 	muleq	r0, r0, r0
    a6a4:	05b69c01 	ldreq	r9, [r6, #3073]!	; 0xc01
    a6a8:	02140000 	andseq	r0, r4, #0
    a6ac:	0100000b 	tsteq	r0, fp
    a6b0:	00004c9b 	muleq	r0, fp, ip
    a6b4:	0092c200 	addseq	ip, r2, r0, lsl #4
    a6b8:	5f681500 	svcpl	0x00681500
    a6bc:	001c0000 	andseq	r0, ip, r0
    a6c0:	05910000 	ldreq	r0, [r1]
    a6c4:	10160000 	andsne	r0, r6, r0
    a6c8:	01000008 	tsteq	r0, r8
    a6cc:	00005ea9 	andeq	r5, r0, r9, lsr #29
    a6d0:	0092e300 	addseq	lr, r2, r0, lsl #6
    a6d4:	8c170000 	ldchi	0, cr0, [r7], {-0}
    a6d8:	3000005f 	andcc	r0, r0, pc, asr r0
    a6dc:	16000000 	strne	r0, [r0], -r0
    a6e0:	000022cc 	andeq	r2, r0, ip, asr #5
    a6e4:	005ec301 	subseq	ip, lr, r1, lsl #6
    a6e8:	92f70000 	rscsls	r0, r7, #0
    a6ec:	e8180000 	ldmda	r8, {}	; <UNPREDICTABLE>
    a6f0:	01000022 	tsteq	r0, r2, lsr #32
    a6f4:	00005ec4 	andeq	r5, r0, r4, asr #29
    a6f8:	19000000 	stmdbne	r0, {}	; <UNPREDICTABLE>
    a6fc:	00001ff5 	strdeq	r1, [r0], -r5
    a700:	d801e001 	stmdale	r1, {r0, sp, lr, pc}
    a704:	a800005f 	stmdage	r0, {r0, r1, r2, r3, r4, r6}
    a708:	01000000 	mrseq	r0, (UNDEF: 0)
    a70c:	00067b9c 	muleq	r6, ip, fp
    a710:	22b81a00 	adcscs	r1, r8, #0, 20
    a714:	e2010000 	and	r0, r1, #0
    a718:	00067b01 	andeq	r7, r6, r1, lsl #22
    a71c:	00932800 	addseq	r2, r3, r0, lsl #16
    a720:	226d1a00 	rsbcs	r1, sp, #0, 20
    a724:	e3010000 	movw	r0, #4096	; 0x1000
    a728:	00003a01 	andeq	r3, r0, r1, lsl #20
    a72c:	00933d00 	addseq	r3, r3, r0, lsl #26
    a730:	06ef1a00 	strbteq	r1, [pc], r0, lsl #20
    a734:	e4010000 	str	r0, [r1], #-0
    a738:	00003a01 	andeq	r3, r0, r1, lsl #20
    a73c:	00938100 	addseq	r8, r3, r0, lsl #2
    a740:	1fc71a00 	svcne	0x00c71a00
    a744:	e6010000 	str	r0, [r1], -r0
    a748:	0001d701 	andeq	sp, r1, r1, lsl #14
    a74c:	0093cc00 	addseq	ip, r3, r0, lsl #24
    a750:	0b021a00 	bleq	90f58 <_etext+0x89944>
    a754:	e7010000 	str	r0, [r1, -r0]
    a758:	00003a01 	andeq	r3, r0, r1, lsl #20
    a75c:	0093ea00 	addseq	lr, r3, r0, lsl #20
    a760:	20b61b00 	adcscs	r1, r6, r0, lsl #22
    a764:	10010000 	andne	r0, r1, r0
    a768:	00605c02 	rsbeq	r5, r0, r2, lsl #24
    a76c:	602a1c00 	eorvs	r1, sl, r0, lsl #24
    a770:	06380000 	ldrteq	r0, [r8], -r0
    a774:	011d0000 	tsteq	sp, r0
    a778:	00750250 	rsbseq	r0, r5, r0, asr r2
    a77c:	60321e00 	eorsvs	r1, r2, r0, lsl #28
    a780:	0d1c0000 	ldceq	0, cr0, [ip, #-0]
    a784:	064b0000 	strbeq	r0, [fp], -r0
    a788:	011d0000 	tsteq	sp, r0
    a78c:	00300150 	eorseq	r0, r0, r0, asr r1
    a790:	00603c1e 	rsbeq	r3, r0, lr, lsl ip
    a794:	000d3200 	andeq	r3, sp, r0, lsl #4
    a798:	00066500 	andeq	r6, r6, r0, lsl #10
    a79c:	52011d00 	andpl	r1, r1, #0, 26
    a7a0:	1d007502 	cfstr32ne	mvfx7, [r0, #-8]
    a7a4:	79025001 	stmdbvc	r2, {r0, ip, lr}
    a7a8:	441f0000 	ldrmi	r0, [pc], #-0	; a7b0 <_etext+0x319c>
    a7ac:	4d000060 	stcmi	0, cr0, [r0, #-384]	; 0xfffffe80
    a7b0:	1d00000d 	stcne	0, cr0, [r0, #-52]	; 0xffffffcc
    a7b4:	75025101 	strvc	r5, [r2, #-257]	; 0x101
    a7b8:	50011d00 	andpl	r1, r1, r0, lsl #26
    a7bc:	00003001 	andeq	r3, r0, r1
    a7c0:	026a040b 	rsbeq	r0, sl, #184549376	; 0xb000000
    a7c4:	db200000 	blle	80a7cc <_etext+0x8031b8>
    a7c8:	0100001f 	tsteq	r0, pc, lsl r0
    a7cc:	00020d4a 	andeq	r0, r2, sl, asr #26
    a7d0:	00608000 	rsbeq	r8, r0, r0
    a7d4:	00003800 	andeq	r3, r0, r0, lsl #16
    a7d8:	139c0100 	orrsne	r0, ip, #0, 2
    a7dc:	000020a0 	andeq	r2, r0, r0, lsr #1
    a7e0:	020d7801 	andeq	r7, sp, #65536	; 0x10000
    a7e4:	60b80000 	adcsvs	r0, r8, r0
    a7e8:	00480000 	subeq	r0, r8, r0
    a7ec:	9c010000 	stcls	0, cr0, [r1], {-0}
    a7f0:	000006be 			; <UNDEFINED> instruction: 0x000006be
    a7f4:	00655221 	rsbeq	r5, r5, r1, lsr #4
    a7f8:	020d7a01 	andeq	r7, sp, #4096	; 0x1000
    a7fc:	94280000 	strtls	r0, [r8], #-0
    a800:	13000000 	movwne	r0, #0
    a804:	000021c0 	andeq	r2, r0, r0, asr #3
    a808:	020de901 	andeq	lr, sp, #16384	; 0x4000
    a80c:	61000000 	mrsvs	r0, (UNDEF: 0)
    a810:	00d00000 	sbcseq	r0, r0, r0
    a814:	9c010000 	stcls	0, cr0, [r1], {-0}
    a818:	00000796 	muleq	r0, r6, r7
    a81c:	00201e16 	eoreq	r1, r0, r6, lsl lr
    a820:	3aeb0100 	bcc	ffacac28 <BootRAM+0xea3b3c9>
    a824:	46000000 	strmi	r0, [r0], -r0
    a828:	16000094 			; <UNDEFINED> instruction: 0x16000094
    a82c:	00001339 	andeq	r1, r0, r9, lsr r3
    a830:	003aec01 	eorseq	lr, sl, r1, lsl #24
    a834:	947e0000 	ldrbtls	r0, [lr], #-0
    a838:	1c170000 	ldcne	0, cr0, [r7], {-0}
    a83c:	9e000061 	cdpls	0, 0, cr0, cr0, cr1, {3}
    a840:	18000000 	stmdane	r0, {}	; <UNPREDICTABLE>
    a844:	00002130 	andeq	r2, r0, r0, lsr r1
    a848:	0796f601 	ldreq	pc, [r6, r1, lsl #12]
    a84c:	cc160000 	ldcgt	0, cr0, [r6], {-0}
    a850:	01000022 	tsteq	r0, r2, lsr #32
    a854:	00003af7 	strdeq	r3, [r0], -r7
    a858:	0094a700 	addseq	sl, r4, r0, lsl #14
    a85c:	22e81600 	rsccs	r1, r8, #0, 12
    a860:	f8010000 			; <UNDEFINED> instruction: 0xf8010000
    a864:	0000003a 	andeq	r0, r0, sl, lsr r0
    a868:	000094d0 	ldrdeq	r9, [r0], -r0
    a86c:	50457221 	subpl	r7, r5, r1, lsr #4
    a870:	3af90100 	bcc	ffe4ac78 <BootRAM+0xedbb419>
    a874:	a7000000 	strge	r0, [r0, -r0]
    a878:	15000094 	strne	r0, [r0, #-148]	; 0x94
    a87c:	0000619c 	muleq	r0, ip, r1
    a880:	00000012 	andeq	r0, r0, r2, lsl r0
    a884:	00000754 	andeq	r0, r0, r4, asr r7
    a888:	00075e1a 	andeq	r5, r7, sl, lsl lr
    a88c:	012f0100 	teqeq	pc, r0, lsl #2
    a890:	0000004c 	andeq	r0, r0, ip, asr #32
    a894:	000094e8 	andeq	r9, r0, r8, ror #9
    a898:	61761e00 	cmnvs	r6, r0, lsl #28
    a89c:	0d640000 	stcleq	0, cr0, [r4, #-0]
    a8a0:	07680000 	strbeq	r0, [r8, -r0]!
    a8a4:	011d0000 	tsteq	sp, r0
    a8a8:	00740250 	rsbseq	r0, r4, r0, asr r2
    a8ac:	617e1e00 	cmnvs	lr, r0, lsl #28
    a8b0:	0d760000 	ldcleq	0, cr0, [r6, #-0]
    a8b4:	07820000 	streq	r0, [r2, r0]
    a8b8:	011d0000 	tsteq	sp, r0
    a8bc:	30080251 	andcc	r0, r8, r1, asr r2
    a8c0:	0250011d 	subseq	r0, r0, #1073741831	; 0x40000007
    a8c4:	22000074 	andcs	r0, r0, #116	; 0x74
    a8c8:	00006196 	muleq	r0, r6, r1
    a8cc:	00000d8d 	andeq	r0, r0, sp, lsl #27
    a8d0:	00619c22 	rsbeq	r9, r1, r2, lsr #24
    a8d4:	000da400 	andeq	sl, sp, r0, lsl #8
    a8d8:	0b000000 	bleq	a8e0 <_etext+0x32cc>
    a8dc:	00029a04 	andeq	r9, r2, r4, lsl #20
    a8e0:	20e62300 	rsccs	r2, r6, r0, lsl #6
    a8e4:	42010000 	andmi	r0, r1, #0
    a8e8:	00020d01 	andeq	r0, r2, r1, lsl #26
    a8ec:	0061d000 	rsbeq	sp, r1, r0
    a8f0:	00008400 	andeq	r8, r0, r0, lsl #8
    a8f4:	2b9c0100 	blcs	fe70acfc <BootRAM+0xd67b49d>
    a8f8:	1a000008 	bne	a920 <_etext+0x330c>
    a8fc:	000022e8 	andeq	r2, r0, r8, ror #5
    a900:	3a014401 	bcc	5b90c <_etext+0x542f8>
    a904:	16000000 	strne	r0, [r0], -r0
    a908:	1a000095 	bne	ab64 <_etext+0x3550>
    a90c:	000022cc 	andeq	r2, r0, ip, asr #5
    a910:	3a014501 	bcc	5bd1c <_etext+0x54708>
    a914:	3e000000 	cdpcc	0, 0, cr0, cr0, cr0, {0}
    a918:	24000095 	strcs	r0, [r0], #-149	; 0x95
    a91c:	00504572 	subseq	r4, r0, r2, ror r5
    a920:	3a014601 	bcc	5c12c <_etext+0x54b18>
    a924:	3e000000 	cdpcc	0, 0, cr0, cr0, cr0, {0}
    a928:	1a000095 	bne	ab84 <_etext+0x3570>
    a92c:	00001339 	andeq	r1, r0, r9, lsr r3
    a930:	3a014701 	bcc	5c53c <_etext+0x54f28>
    a934:	73000000 	movwvc	r0, #0
    a938:	25000095 	strcs	r0, [r0, #-149]	; 0x95
    a93c:	00000e90 	muleq	r0, r0, lr
    a940:	00000810 	andeq	r0, r0, r0, lsl r8
    a944:	00075e1a 	andeq	r5, r7, sl, lsl lr
    a948:	01630100 	cmneq	r3, r0, lsl #2
    a94c:	0000004c 	andeq	r0, r0, ip, asr #32
    a950:	00009591 	muleq	r0, r1, r5
    a954:	62281700 	eorvs	r1, r8, #0, 14
    a958:	00100000 	andseq	r0, r0, r0
    a95c:	5e1a0000 	cdppl	0, 1, cr0, cr10, cr0, {0}
    a960:	01000007 	tsteq	r0, r7
    a964:	004c0169 	subeq	r0, ip, r9, ror #2
    a968:	95b90000 	ldrls	r0, [r9, #0]!
    a96c:	00000000 	andeq	r0, r0, r0
    a970:	00213526 	eoreq	r3, r1, r6, lsr #10
    a974:	01780100 	cmneq	r8, r0, lsl #2
    a978:	0000020d 	andeq	r0, r0, sp, lsl #4
    a97c:	00006254 	andeq	r6, r0, r4, asr r2
    a980:	00000024 	andeq	r0, r0, r4, lsr #32
    a984:	64279c01 	strtvs	r9, [r7], #-3073	; 0xc01
    a988:	01000002 	tsteq	r0, r2
    a98c:	01d70192 			; <UNDEFINED> instruction: 0x01d70192
    a990:	62780000 	rsbsvs	r0, r8, #0
    a994:	001c0000 	andseq	r0, ip, r0
    a998:	9c010000 	stcls	0, cr0, [r1], {-0}
    a99c:	0000088c 	andeq	r0, r0, ip, lsl #17
    a9a0:	000b0228 	andeq	r0, fp, r8, lsr #4
    a9a4:	01920100 	orrseq	r0, r2, r0, lsl #2
    a9a8:	0000004c 	andeq	r0, r0, ip, asr #32
    a9ac:	000095d2 	ldrdeq	r9, [r0], -r2
    a9b0:	00214f28 	eoreq	r4, r1, r8, lsr #30
    a9b4:	01920100 	orrseq	r0, r2, r0, lsl #2
    a9b8:	0000088c 	andeq	r0, r0, ip, lsl #17
    a9bc:	000095f3 	strdeq	r9, [r0], -r3
    a9c0:	0008711a 	andeq	r7, r8, sl, lsl r1
    a9c4:	01940100 	orrseq	r0, r4, r0, lsl #2
    a9c8:	0000003a 	andeq	r0, r0, sl, lsr r0
    a9cc:	0000961f 	andeq	r9, r0, pc, lsl r6
    a9d0:	dd040b00 	vstrle	d0, [r4, #-0]
    a9d4:	27000001 	strcs	r0, [r0, -r1]
    a9d8:	00001fb9 			; <UNDEFINED> instruction: 0x00001fb9
    a9dc:	5e03c901 	cdppl	9, 0, cr12, cr3, cr1, {0}
    a9e0:	94000000 	strls	r0, [r0], #-0
    a9e4:	40000062 	andmi	r0, r0, r2, rrx
    a9e8:	01000000 	mrseq	r0, (UNDEF: 0)
    a9ec:	0008bc9c 	muleq	r8, ip, ip
    a9f0:	62a21f00 	adcvs	r1, r2, #0, 30
    a9f4:	0d8d0000 	stceq	0, cr0, [sp]
    a9f8:	011d0000 	tsteq	sp, r0
    a9fc:	00300150 	eorseq	r0, r0, r0, asr r1
    aa00:	202c2900 	eorcs	r2, ip, r0, lsl #18
    aa04:	1b010000 	blne	4aa0c <_etext+0x433f8>
    aa08:	08f60102 	ldmeq	r6!, {r1, r8}^
    aa0c:	b22a0000 	eorlt	r0, sl, #0
    aa10:	0100001f 	tsteq	r0, pc, lsl r0
    aa14:	020d021d 	andeq	r0, sp, #-805306367	; 0xd0000001
    aa18:	ce2a0000 	cdpgt	0, 2, cr0, cr10, cr0, {0}
    aa1c:	01000020 	tsteq	r0, r0, lsr #32
    aa20:	003a021e 	eorseq	r0, sl, lr, lsl r2
    aa24:	ef2a0000 	svc	0x002a0000
    aa28:	01000006 	tsteq	r0, r6
    aa2c:	003a021f 	eorseq	r0, sl, pc, lsl r2
    aa30:	272b0000 	strcs	r0, [fp, -r0]!
    aa34:	01000020 	tsteq	r0, r0, lsr #32
    aa38:	2900028b 	stmdbcs	r0, {r0, r1, r3, r7, r9}
    aa3c:	0000202e 	andeq	r2, r0, lr, lsr #32
    aa40:	01029701 	tsteq	r2, r1, lsl #14
    aa44:	00000978 	andeq	r0, r0, r8, ror r9
    aa48:	00060e2a 	andeq	r0, r6, sl, lsr #28
    aa4c:	02990100 	addseq	r0, r9, #0, 2
    aa50:	00000264 	andeq	r0, r0, r4, ror #4
    aa54:	001fb22a 	andseq	fp, pc, sl, lsr #4
    aa58:	029a0100 	addseq	r0, sl, #0, 2
    aa5c:	0000020d 	andeq	r0, r0, sp, lsl #4
    aa60:	0023172a 	eoreq	r1, r3, sl, lsr #14
    aa64:	029b0100 	addseq	r0, fp, #0, 2
    aa68:	0000003a 	andeq	r0, r0, sl, lsr r0
    aa6c:	0022cc2a 	eoreq	ip, r2, sl, lsr #24
    aa70:	029d0100 	addseq	r0, sp, #0, 2
    aa74:	0000003a 	andeq	r0, r0, sl, lsr r0
    aa78:	001fd22a 	andseq	sp, pc, sl, lsr #4
    aa7c:	029d0100 	addseq	r0, sp, #0, 2
    aa80:	0000003a 	andeq	r0, r0, sl, lsr r0
    aa84:	0008712a 	andeq	r7, r8, sl, lsr #2
    aa88:	029e0100 	addseq	r0, lr, #0, 2
    aa8c:	0000003a 	andeq	r0, r0, sl, lsr r0
    aa90:	0013392a 	andseq	r3, r3, sl, lsr #18
    aa94:	029e0100 	addseq	r0, lr, #0, 2
    aa98:	0000003a 	andeq	r0, r0, sl, lsr r0
    aa9c:	0009692c 	andeq	r6, r9, ip, lsr #18
    aaa0:	203a2a00 	eorscs	r2, sl, r0, lsl #20
    aaa4:	a9010000 	stmdbge	r1, {}	; <UNPREDICTABLE>
    aaa8:	00005e02 	andeq	r5, r0, r2, lsl #28
    aaac:	2a2d0000 	bcs	b4aab4 <_etext+0xb434a0>
    aab0:	000001db 	ldrdeq	r0, [r0], -fp
    aab4:	6f032501 	svcvs	0x00032501
    aab8:	00000000 	andeq	r0, r0, r0
    aabc:	1ef02300 	cdpne	3, 15, cr2, cr0, cr0, {0}
    aac0:	4c010000 	stcmi	0, cr0, [r1], {-0}
    aac4:	00005e03 	andeq	r5, r0, r3, lsl #28
    aac8:	0062d400 	rsbeq	sp, r2, r0, lsl #8
    aacc:	0002dc00 	andeq	sp, r2, r0, lsl #24
    aad0:	e69c0100 	ldr	r0, [ip], r0, lsl #2
    aad4:	2e00000a 	cdpcs	0, 0, cr0, cr0, cr10, {0}
    aad8:	034f0104 	movteq	r0, #61700	; 0xf104
    aadc:	000009b0 			; <UNDEFINED> instruction: 0x000009b0
    aae0:	0100622f 	tsteq	r0, pc, lsr #4
    aae4:	01d70351 	bicseq	r0, r7, r1, asr r3
    aae8:	772f0000 	strvc	r0, [pc, -r0]!
    aaec:	03520100 	cmpeq	r2, #0, 2
    aaf0:	00000ae6 	andeq	r0, r0, r6, ror #21
    aaf4:	22b31a00 	adcscs	r1, r3, #0, 20
    aaf8:	53010000 	movwpl	r0, #4096	; 0x1000
    aafc:	00099203 	andeq	r9, r9, r3, lsl #4
    ab00:	00965000 	addseq	r5, r6, r0
    ab04:	08bc3000 	ldmeq	ip!, {ip, sp}
    ab08:	631a0000 	tstvs	sl, #0
    ab0c:	00c40000 	sbceq	r0, r4, r0
    ab10:	67010000 	strvs	r0, [r1, -r0]
    ab14:	000a4003 	andeq	r4, sl, r3
    ab18:	631a1700 	tstvs	sl, #0, 14
    ab1c:	00c40000 	sbceq	r0, r4, r0
    ab20:	c9310000 	ldmdbgt	r1!, {}	; <UNPREDICTABLE>
    ab24:	73000008 	movwvc	r0, #8
    ab28:	31000096 	swpcc	r0, r6, [r0]	; <UNPREDICTABLE>
    ab2c:	000008d5 	ldrdeq	r0, [r0], -r5
    ab30:	0000971c 	andeq	r9, r0, ip, lsl r7
    ab34:	0008e131 	andeq	lr, r8, r1, lsr r1
    ab38:	00972f00 	addseq	r2, r7, r0, lsl #30
    ab3c:	08ed3200 	stmiaeq	sp!, {r9, ip, sp}^
    ab40:	63d80000 	bicsvs	r0, r8, #0
    ab44:	2a220000 	bcs	88ab4c <_etext+0x883538>
    ab48:	81000063 	tsthi	r0, r3, rrx
    ab4c:	1c000006 	stcne	0, cr0, [r0], {6}
    ab50:	00006364 	andeq	r6, r0, r4, ror #6
    ab54:	00000a1a 	andeq	r0, r0, sl, lsl sl
    ab58:	0250011d 	subseq	r0, r0, #1073741831	; 0x40000007
    ab5c:	22000074 	andcs	r0, r0, #116	; 0x74
    ab60:	0000637a 	andeq	r6, r0, sl, ror r3
    ab64:	0000082b 	andeq	r0, r0, fp, lsr #16
    ab68:	00639622 	rsbeq	r9, r3, r2, lsr #12
    ab6c:	0006be00 	andeq	fp, r6, r0, lsl #28
    ab70:	63a42200 			; <UNDEFINED> instruction: 0x63a42200
    ab74:	06960000 	ldreq	r0, [r6], r0
    ab78:	b6220000 	strtlt	r0, [r2], -r0
    ab7c:	9c000063 	stcls	0, cr0, [r0], {99}	; 0x63
    ab80:	00000007 	andeq	r0, r0, r7
    ab84:	08f63300 	ldmeq	r6!, {r8, r9, ip, sp}^
    ab88:	63de0000 	bicsvs	r0, lr, #0
    ab8c:	0eb00000 	cdpeq	0, 11, cr0, cr0, cr0, {0}
    ab90:	6c010000 	stcvs	0, cr0, [r1], {-0}
    ab94:	000adc03 	andeq	sp, sl, r3, lsl #24
    ab98:	0eb03400 	cdpeq	4, 11, cr3, cr0, cr0, {0}
    ab9c:	03310000 	teqeq	r1, #0
    aba0:	4e000009 	cdpmi	0, 0, cr0, cr0, cr9, {0}
    aba4:	31000097 	swpcc	r0, r7, [r0]	; <UNPREDICTABLE>
    aba8:	0000090f 	andeq	r0, r0, pc, lsl #18
    abac:	000097e5 	andeq	r9, r0, r5, ror #15
    abb0:	00091b31 	andeq	r1, r9, r1, lsr fp
    abb4:	00982500 	addseq	r2, r8, r0, lsl #10
    abb8:	09273100 	stmdbeq	r7!, {r8, ip, sp}
    abbc:	984e0000 	stmdals	lr, {}^	; <UNPREDICTABLE>
    abc0:	33310000 	teqcc	r1, #0
    abc4:	61000009 	tstvs	r0, r9
    abc8:	31000098 	swpcc	r0, r8, [r0]	; <UNPREDICTABLE>
    abcc:	0000093f 	andeq	r0, r0, pc, lsr r9
    abd0:	0000987c 	andeq	r9, r0, ip, ror r8
    abd4:	00094b31 	andeq	r4, r9, r1, lsr fp
    abd8:	00989c00 	addseq	r9, r8, r0, lsl #24
    abdc:	63e81500 	mvnvs	r1, #0, 10
    abe0:	002c0000 	eoreq	r0, ip, r0
    abe4:	0aaf0000 	beq	febcabec <BootRAM+0xdb3b38d>
    abe8:	5c310000 	ldcpl	0, cr0, [r1], #-0
    abec:	af000009 	svcge	0x00000009
    abf0:	00000098 	muleq	r0, r8, r0
    abf4:	00651c15 	rsbeq	r1, r5, r5, lsl ip
    abf8:	00006000 	andeq	r6, r0, r0
    abfc:	000ace00 	andeq	ip, sl, r0, lsl #28
    ac00:	096a3500 	stmdbeq	sl!, {r8, sl, ip, sp}^
    ac04:	91020000 	mrsls	r0, (UNDEF: 2)
    ac08:	657a226c 	ldrbvs	r2, [sl, #-620]!	; 0x26c
    ac0c:	05b60000 	ldreq	r0, [r6, #0]!
    ac10:	36000000 	strcc	r0, [r0], -r0
    ac14:	000064de 	ldrdeq	r6, [r0], -lr
    ac18:	0250011d 	subseq	r0, r0, #1073741831	; 0x40000007
    ac1c:	00000074 	andeq	r0, r0, r4, ror r0
    ac20:	658c2200 	strvs	r2, [ip, #512]	; 0x200
    ac24:	08920000 	ldmeq	r2, {}	; <UNPREDICTABLE>
    ac28:	0b000000 	bleq	ac30 <_etext+0x361c>
    ac2c:	00004c04 	andeq	r4, r0, r4, lsl #24
    ac30:	22ff2900 	rscscs	r2, pc, #0, 18
    ac34:	a7010000 	strge	r0, [r1, -r0]
    ac38:	0b2c0101 	bleq	b0b044 <_etext+0xb03a30>
    ac3c:	b82a0000 	stmdalt	sl!, {}	; <UNPREDICTABLE>
    ac40:	01000022 	tsteq	r0, r2, lsr #32
    ac44:	067b01a9 	ldrbteq	r0, [fp], -r9, lsr #3
    ac48:	7a2a0000 	bvc	a8ac50 <_etext+0xa8363c>
    ac4c:	01000020 	tsteq	r0, r0, lsr #32
    ac50:	003a01aa 	eorseq	r0, sl, sl, lsr #3
    ac54:	2a2d0000 	bcs	b4ac5c <_etext+0xb43648>
    ac58:	00001fcb 	andeq	r1, r0, fp, asr #31
    ac5c:	d701b001 	strle	fp, [r1, -r1]
    ac60:	2a000001 	bcs	ac6c <_etext+0x3658>
    ac64:	00000b02 	andeq	r0, r0, r2, lsl #22
    ac68:	3a01b101 	bcc	77074 <_etext+0x6fa60>
    ac6c:	00000000 	andeq	r0, r0, r0
    ac70:	1f3a2300 	svcne	0x003a2300
    ac74:	a0010000 	andge	r0, r1, r0
    ac78:	00005e03 	andeq	r5, r0, r3, lsl #28
    ac7c:	0065b000 	rsbeq	fp, r5, r0
    ac80:	0000c800 	andeq	ip, r0, r0, lsl #16
    ac84:	fe9c0100 	cdp2	1, 9, cr0, cr12, cr0, {0}
    ac88:	1a00000b 	bne	acbc <_etext+0x36a8>
    ac8c:	000006ef 	andeq	r0, r0, pc, ror #13
    ac90:	3a03a201 	bcc	f349c <_etext+0xebe88>
    ac94:	d9000000 	stmdble	r0, {}	; <UNPREDICTABLE>
    ac98:	30000098 	mulcc	r0, r8, r0
    ac9c:	00000aec 	andeq	r0, r0, ip, ror #21
    aca0:	000065c0 	andeq	r6, r0, r0, asr #11
    aca4:	0000007e 	andeq	r0, r0, lr, ror r0
    aca8:	f403a601 	vst1.8	{d10-d12}, [r3], r1
    acac:	1700000b 	strne	r0, [r0, -fp]
    acb0:	000065c0 	andeq	r6, r0, r0, asr #11
    acb4:	0000007e 	andeq	r0, r0, lr, ror r0
    acb8:	000af931 	andeq	pc, sl, r1, lsr r9	; <UNPREDICTABLE>
    acbc:	00992600 	addseq	r2, r9, r0, lsl #12
    acc0:	0b053100 	bleq	1570c8 <_etext+0x14fab4>
    acc4:	993b0000 	ldmdbls	fp!, {}	; <UNPREDICTABLE>
    acc8:	c8150000 	ldmdagt	r5, {}	; <UNPREDICTABLE>
    accc:	2a000065 	bcs	ae68 <_etext+0x3854>
    acd0:	de000000 	cdple	0, 0, cr0, cr0, cr0, {0}
    acd4:	3100000b 	tstcc	r0, fp
    acd8:	00000b12 	andeq	r0, r0, r2, lsl fp
    acdc:	0000994e 	andeq	r9, r0, lr, asr #18
    ace0:	000b1e31 	andeq	r1, fp, r1, lsr lr
    ace4:	00996c00 	addseq	r6, r9, r0, lsl #24
    ace8:	65d41c00 	ldrbvs	r1, [r4, #3072]	; 0xc00
    acec:	0bb40000 	bleq	fed0acf4 <BootRAM+0xdc7b495>
    acf0:	011d0000 	tsteq	sp, r0
    acf4:	00760250 	rsbseq	r0, r6, r0, asr r2
    acf8:	65e81e00 	strbvs	r1, [r8, #3584]!	; 0xe00
    acfc:	0db60000 	ldceq	0, cr0, [r6]
    ad00:	0bc70000 	bleq	ff1cad08 <BootRAM+0xe13b4a9>
    ad04:	011d0000 	tsteq	sp, r0
    ad08:	00300150 	eorseq	r0, r0, r0, asr r1
    ad0c:	0065f21f 	rsbeq	pc, r5, pc, lsl r2	; <UNPREDICTABLE>
    ad10:	000dcc00 	andeq	ip, sp, r0, lsl #24
    ad14:	52011d00 	andpl	r1, r1, #0, 26
    ad18:	1d007602 	stcne	6, cr7, [r0, #-8]
    ad1c:	77025001 	strvc	r5, [r2, -r1]
    ad20:	1f000000 	svcne	0x00000000
    ad24:	00006606 	andeq	r6, r0, r6, lsl #12
    ad28:	00000d4d 	andeq	r0, r0, sp, asr #26
    ad2c:	0151011d 	cmpeq	r1, sp, lsl r1
    ad30:	50011d30 	andpl	r1, r1, r0, lsr sp
    ad34:	00003001 	andeq	r3, r0, r1
    ad38:	665e3700 	ldrbvs	r3, [lr], -r0, lsl #14
    ad3c:	08920000 	ldmeq	r2, {}	; <UNPREDICTABLE>
    ad40:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
    ad44:	000002b2 			; <UNDEFINED> instruction: 0x000002b2
    ad48:	7803dd01 	stmdavc	r3, {r0, r8, sl, fp, ip, lr, pc}
    ad4c:	38000066 	stmdacc	r0, {r1, r2, r5, r6}
    ad50:	01000000 	mrseq	r0, (UNDEF: 0)
    ad54:	000c439c 	muleq	ip, ip, r3
    ad58:	61563900 	cmpvs	r6, r0, lsl #18
    ad5c:	dd01006c 	stcle	0, cr0, [r1, #-432]	; 0xfffffe50
    ad60:	00005e03 	andeq	r5, r0, r3, lsl #28
    ad64:	00999f00 	addseq	r9, r9, r0, lsl #30
    ad68:	00692400 	rsbeq	r2, r9, r0, lsl #8
    ad6c:	3a03df01 	bcc	102978 <_etext+0xfb364>
    ad70:	c0000000 	andgt	r0, r0, r0
    ad74:	24000099 	strcs	r0, [r0], #-153	; 0x99
    ad78:	0050456e 	subseq	r4, r0, lr, ror #10
    ad7c:	3a03e001 	bcc	102d88 <_etext+0xfb774>
    ad80:	df000000 	svcle	0x00000000
    ad84:	00000099 	muleq	r0, r9, r0
    ad88:	001f2e23 	andseq	r2, pc, r3, lsr #28
    ad8c:	03780100 	cmneq	r8, #0, 2
    ad90:	0000005e 	andeq	r0, r0, lr, asr r0
    ad94:	000066b0 			; <UNDEFINED> instruction: 0x000066b0
    ad98:	0000005c 	andeq	r0, r0, ip, asr r0
    ad9c:	0c899c01 	stceq	12, cr9, [r9], {1}
    ada0:	ef1a0000 	svc	0x001a0000
    ada4:	01000006 	tsteq	r0, r6
    ada8:	003a037a 	eorseq	r0, sl, sl, ror r3
    adac:	99f20000 	ldmibls	r2!, {}^	; <UNPREDICTABLE>
    adb0:	c4220000 	strtgt	r0, [r2], #-0
    adb4:	b6000066 	strlt	r0, [r0], -r6, rrx
    adb8:	22000005 	andcs	r0, r0, #5
    adbc:	000066e0 	andeq	r6, r0, r0, ror #13
    adc0:	00000bfe 	strdeq	r0, [r0], -lr
    adc4:	0066fe37 	rsbeq	pc, r6, r7, lsr lr	; <UNPREDICTABLE>
    adc8:	00089200 	andeq	r9, r8, r0, lsl #4
    adcc:	943a0000 	ldrtls	r0, [sl], #-0
    add0:	01000020 	tsteq	r0, r0, lsr #32
    add4:	000003f1 	strdeq	r0, [r0], -r1
    add8:	00020000 	andeq	r0, r2, r0
    addc:	9c010000 	stcls	0, cr0, [r1], {-0}
    ade0:	0002eb3b 	andeq	lr, r2, fp, lsr fp
    ade4:	6bec0400 	blvs	ffb0bdec <BootRAM+0xea7c58d>
    ade8:	3b000004 	blcc	ae00 <_etext+0x37ec>
    adec:	0000021a 	andeq	r0, r0, sl, lsl r2
    adf0:	029aee04 	addseq	lr, sl, #4, 28	; 0x40
    adf4:	ff3b0000 			; <UNDEFINED> instruction: 0xff3b0000
    adf8:	0400001e 	streq	r0, [r0], #-30
    adfc:	00004cf2 	strdeq	r4, [r0], -r2
    ae00:	1f0a3b00 	svcne	0x000a3b00
    ae04:	f3040000 	vhadd.u8	d0, d4, d0
    ae08:	0000004c 	andeq	r0, r0, ip, asr #32
    ae0c:	0001e83b 	andeq	lr, r1, fp, lsr r8
    ae10:	d2220500 	eorle	r0, r2, #0, 10
    ae14:	0b00000c 	bleq	ae4c <_etext+0x3838>
    ae18:	00038104 	andeq	r8, r3, r4, lsl #2
    ae1c:	013e3b00 	teqeq	lr, r0, lsl #22
    ae20:	25050000 	strcs	r0, [r5, #-0]
    ae24:	00000ce3 	andeq	r0, r0, r3, ror #25
    ae28:	046b040b 	strbteq	r0, [fp], #-1035	; 0x40b
    ae2c:	6c3b0000 	ldcvs	0, cr0, [fp], #-0
    ae30:	0500001f 	streq	r0, [r0, #-31]
    ae34:	000cf42a 	andeq	pc, ip, sl, lsr #8
    ae38:	ef040b00 	svc	0x00040b00
    ae3c:	3c000004 	stccc	0, cr0, [r0], {4}
    ae40:	000022dd 	ldrdeq	r2, [r0], -sp
    ae44:	02e52401 	rsceq	r2, r5, #16777216	; 0x1000000
    ae48:	03050000 	movweq	r0, #20480	; 0x5000
    ae4c:	200005ae 	andcs	r0, r0, lr, lsr #11
    ae50:	0021193c 	eoreq	r1, r1, ip, lsr r9
    ae54:	94250100 	strtls	r0, [r5], #-256	; 0x100
    ae58:	05000000 	streq	r0, [r0, #-0]
    ae5c:	000dcc03 	andeq	ip, sp, r3, lsl #24
    ae60:	1e913d20 	cdpne	13, 9, cr3, cr1, cr0, {1}
    ae64:	53070000 	movwpl	r0, #28672	; 0x7000
    ae68:	00004c02 	andeq	r4, r0, r2, lsl #24
    ae6c:	000d3200 	andeq	r3, sp, r0, lsl #4
    ae70:	005e0d00 	subseq	r0, lr, r0, lsl #26
    ae74:	3e000000 	cdpcc	0, 0, cr0, cr0, cr0, {0}
    ae78:	00002066 	andeq	r2, r0, r6, rrx
    ae7c:	0d4d1906 	stcleq	9, cr1, [sp, #-24]	; 0xffffffe8
    ae80:	d70d0000 	strle	r0, [sp, -r0]
    ae84:	0d000001 	stceq	0, cr0, [r0, #-4]
    ae88:	0000004c 	andeq	r0, r0, ip, asr #32
    ae8c:	00004c0d 	andeq	r4, r0, sp, lsl #24
    ae90:	6c3f0000 	ldcvs	0, cr0, [pc], #-0	; ae98 <_etext+0x3884>
    ae94:	0700001d 	smladeq	r0, sp, r0, r0
    ae98:	0d640256 	sfmeq	f0, 2, [r4, #-344]!	; 0xfffffea8
    ae9c:	5e0d0000 	cdppl	0, 0, cr0, cr13, cr0, {0}
    aea0:	0d000000 	stceq	0, cr0, [r0, #-0]
    aea4:	0000004c 	andeq	r0, r0, ip, asr #32
    aea8:	1e9d3f00 	cdpne	15, 9, cr3, cr13, cr0, {0}
    aeac:	4e070000 	cdpmi	0, 0, cr0, cr7, cr0, {0}
    aeb0:	000d7602 	andeq	r7, sp, r2, lsl #12
    aeb4:	005e0d00 	subseq	r0, lr, r0, lsl #26
    aeb8:	3f000000 	svccc	0x00000000
    aebc:	00001eaa 	andeq	r1, r0, sl, lsr #29
    aec0:	8d023a07 	vstrhi	s6, [r2, #-28]	; 0xffffffe4
    aec4:	0d00000d 	stceq	0, cr0, [r0, #-52]	; 0xffffffcc
    aec8:	0000005e 	andeq	r0, r0, lr, asr r0
    aecc:	00004c0d 	andeq	r4, r0, sp, lsl #24
    aed0:	9c3f0000 	ldcls	0, cr0, [pc], #-0	; aed8 <_etext+0x38c4>
    aed4:	07000009 	streq	r0, [r0, -r9]
    aed8:	0da40257 	sfmeq	f0, 4, [r4, #348]!	; 0x15c
    aedc:	5e0d0000 	cdppl	0, 0, cr0, cr13, cr0, {0}
    aee0:	0d000000 	stceq	0, cr0, [r0, #-0]
    aee4:	0000004c 	andeq	r0, r0, ip, asr #32
    aee8:	1bed3f00 	blne	ffb5aaf0 <BootRAM+0xeacb291>
    aeec:	4d070000 	stcmi	0, cr0, [r7, #-0]
    aef0:	000db602 	andeq	fp, sp, r2, lsl #12
    aef4:	005e0d00 	subseq	r0, lr, r0, lsl #26
    aef8:	3d000000 	stccc	0, cr0, [r0, #-0]
    aefc:	00001c7d 	andeq	r1, r0, sp, ror ip
    af00:	4c025407 	cfstrsmi	mvf5, [r2], {7}
    af04:	cc000000 	stcgt	0, cr0, [r0], {-0}
    af08:	0d00000d 	stceq	0, cr0, [r0, #-52]	; 0xffffffcc
    af0c:	0000005e 	andeq	r0, r0, lr, asr r0
    af10:	22134000 	andscs	r4, r3, #0
    af14:	1a060000 	bne	18af1c <_etext+0x183908>
    af18:	0001d70d 	andeq	sp, r1, sp, lsl #14
    af1c:	004c0d00 	subeq	r0, ip, r0, lsl #26
    af20:	4c0d0000 	stcmi	0, cr0, [sp], {-0}
    af24:	00000000 	andeq	r0, r0, r0
    af28:	00017000 	andeq	r7, r1, r0
    af2c:	b7000400 	strlt	r0, [r0, -r0, lsl #8]
    af30:	04000028 	streq	r0, [r0], #-40	; 0x28
    af34:	00063901 	andeq	r3, r6, r1, lsl #18
    af38:	234d0100 	movtcs	r0, #53504	; 0xd100
    af3c:	08930000 	ldmeq	r3, {}	; <UNPREDICTABLE>
    af40:	0f500000 	svceq	0x00500000
    af44:	00000000 	andeq	r0, r0, r0
    af48:	3c9c0000 	ldccc	0, cr0, [ip], {0}
    af4c:	04020000 	streq	r0, [r2], #-0
    af50:	0004da05 	andeq	sp, r4, r5, lsl #20
    af54:	05020200 	streq	r0, [r2, #-512]	; 0x200
    af58:	000006fc 	strdeq	r0, [r0], -ip
    af5c:	1a060102 	bne	18b36c <_etext+0x183d58>
    af60:	03000008 	movweq	r0, #8
    af64:	00323375 	eorseq	r3, r2, r5, ror r3
    af68:	00452402 	subeq	r2, r5, r2, lsl #8
    af6c:	04020000 	streq	r0, [r2], #-0
    af70:	00025207 	andeq	r5, r2, r7, lsl #4
    af74:	31750300 	cmncc	r5, r0, lsl #6
    af78:	25020036 	strcs	r0, [r2, #-54]	; 0x36
    af7c:	00000057 	andeq	r0, r0, r7, asr r0
    af80:	49070202 	stmdbmi	r7, {r1, r9}
    af84:	03000009 	movweq	r0, #9
    af88:	02003875 	andeq	r3, r0, #7667712	; 0x750000
    af8c:	00006826 	andeq	r6, r0, r6, lsr #16
    af90:	08010200 	stmdaeq	r1, {r9}
    af94:	00000818 	andeq	r0, r0, r8, lsl r8
    af98:	005e0404 	subseq	r0, lr, r4, lsl #8
    af9c:	66050000 	strvs	r0, [r5], -r0
    afa0:	01000020 	tsteq	r0, r0, lsr #32
    afa4:	00670c23 	rsbeq	r0, r7, r3, lsr #24
    afa8:	00003000 	andeq	r3, r0, r0
    afac:	fd9c0100 	ldc2	1, cr0, [ip]
    afb0:	06000000 	streq	r0, [r0], -r0
    afb4:	00002367 	andeq	r2, r0, r7, ror #6
    afb8:	006f2301 	rsbeq	r2, pc, r1, lsl #6
    afbc:	9a380000 	bls	e0afc4 <_etext+0xe039b0>
    afc0:	70060000 	andvc	r0, r6, r0
    afc4:	01000023 	tsteq	r0, r3, lsr #32
    afc8:	00004c23 	andeq	r4, r0, r3, lsr #24
    afcc:	009a7d00 	addseq	r7, sl, r0, lsl #26
    afd0:	235f0600 	cmpcs	pc, #0, 12
    afd4:	23010000 	movwcs	r0, #4096	; 0x1000
    afd8:	0000004c 	andeq	r0, r0, ip, asr #32
    afdc:	00009a9e 	muleq	r0, lr, sl
    afe0:	01006e07 	tsteq	r0, r7, lsl #28
    afe4:	00003a25 	andeq	r3, r0, r5, lsr #20
    afe8:	08520100 	ldmdaeq	r2, {r8}^
    afec:	26010069 	strcs	r0, [r1], -r9, rrx
    aff0:	0000003a 	andeq	r0, r0, sl, lsr r0
    aff4:	00009abf 			; <UNDEFINED> instruction: 0x00009abf
    aff8:	0019dd09 	andseq	sp, r9, r9, lsl #26
    affc:	3a260100 	bcc	98b404 <_etext+0x983df0>
    b000:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    b004:	0900009b 	stmdbeq	r0, {r0, r1, r3, r4, r7}
    b008:	000019e3 	andeq	r1, r0, r3, ror #19
    b00c:	003a2601 	eorseq	r2, sl, r1, lsl #12
    b010:	9b550000 	blls	154b018 <_etext+0x1543a04>
    b014:	7c090000 	stcvc	0, cr0, [r9], {-0}
    b018:	01000023 	tsteq	r0, r3, lsr #32
    b01c:	0000fd27 	andeq	pc, r0, r7, lsr #26
    b020:	009b7900 	addseq	r7, fp, r0, lsl #18
    b024:	04040000 	streq	r0, [r4], #-0
    b028:	0000004c 	andeq	r0, r0, ip, asr #32
    b02c:	00221305 	eoreq	r1, r2, r5, lsl #6
    b030:	3c3c0100 	ldfccs	f0, [ip], #-0
    b034:	24000067 	strcs	r0, [r0], #-103	; 0x67
    b038:	01000000 	mrseq	r0, (UNDEF: 0)
    b03c:	00016d9c 	muleq	r1, ip, sp
    b040:	23670600 	cmncs	r7, #0, 12
    b044:	3c010000 	stccc	0, cr0, [r1], {-0}
    b048:	0000006f 	andeq	r0, r0, pc, rrx
    b04c:	00009bb4 			; <UNDEFINED> instruction: 0x00009bb4
    b050:	00237006 	eoreq	r7, r3, r6
    b054:	4c3c0100 	ldfmis	f0, [ip], #-0
    b058:	ef000000 	svc	0x00000000
    b05c:	0600009b 			; <UNDEFINED> instruction: 0x0600009b
    b060:	0000235f 	andeq	r2, r0, pc, asr r3
    b064:	004c3c01 	subeq	r3, ip, r1, lsl #24
    b068:	9c100000 	ldcls	0, cr0, [r0], {-0}
    b06c:	6e070000 	cdpvs	0, 0, cr0, cr7, cr0, {0}
    b070:	3a3e0100 	bcc	f8b478 <_etext+0xf83e64>
    b074:	01000000 	mrseq	r0, (UNDEF: 0)
    b078:	00690852 	rsbeq	r0, r9, r2, asr r8
    b07c:	003a3f01 	eorseq	r3, sl, r1, lsl #30
    b080:	9c310000 	ldcls	0, cr0, [r1], #-0
    b084:	7c090000 	stcvc	0, cr0, [r9], {-0}
    b088:	01000023 	tsteq	r0, r3, lsr #32
    b08c:	00016d40 	andeq	r6, r1, r0, asr #26
    b090:	009c9000 	addseq	r9, ip, r0
    b094:	04040000 	streq	r0, [r4], #-0
    b098:	0000003a 	andeq	r0, r0, sl, lsr r0
	...

Disassembly of section .debug_abbrev:

00000000 <.debug_abbrev>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void NOP_Process(void)
{
       0:	10001101 	andne	r1, r0, r1, lsl #2
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
       4:	03065506 	movweq	r5, #25862	; 0x6506
       8:	25081b08 	strcs	r1, [r8, #-2824]	; 0xb08
       c:	00051308 	andeq	r1, r5, r8, lsl #6
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
      10:	11010000 	mrsne	r0, (UNDEF: 1)
      14:	11061000 	mrsne	r1, (UNDEF: 6)
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
      18:	03011201 	movweq	r1, #4609	; 0x1201
      1c:	25081b08 	strcs	r1, [r8, #-2824]	; 0xb08
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
      20:	00051308 	andeq	r1, r5, r8, lsl #6
      24:	11010000 	mrsne	r0, (UNDEF: 1)
      28:	130e2501 	movwne	r2, #58625	; 0xe501
    if ((wEPVal & EP_CTR_RX) != 0)
      2c:	1b0e030b 	blne	380c60 <_etext+0x37964c>
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
      30:	1117550e 	tstne	r7, lr, lsl #10
      34:	00171001 	andseq	r1, r7, r1
      38:	00240200 	eoreq	r0, r4, r0, lsl #4

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
      3c:	0b3e0b0b 	bleq	f82c70 <_etext+0xf7b65c>

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
      40:	00000e03 	andeq	r0, r0, r3, lsl #28
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
      44:	0b002403 	bleq	9058 <_etext+0x1a44>
      48:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
      4c:	04000008 	streq	r0, [r0], #-8

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
      50:	0b0b000f 	bleq	2c0094 <_etext+0x2b8a80>
      54:	00001349 	andeq	r1, r0, r9, asr #6
      58:	27001505 	strcs	r1, [r0, -r5, lsl #10]
      5c:	06000019 			; <UNDEFINED> instruction: 0x06000019
      60:	08030016 	stmdaeq	r3, {r1, r2, r4}
      64:	0b3b0b3a 	bleq	ec2d54 <_etext+0xebb740>
      68:	00001349 	andeq	r1, r0, r9, asr #6
      6c:	03001607 	movweq	r1, #1543	; 0x607
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPDblBuffCount(u8 bEpNum, u8 bDir, u16 wCount)
{
  _SetEPDblBuffCount(bEpNum, bDir, wCount);
      70:	3b0b3a0e 	blcc	2ce8b0 <_etext+0x2c729c>
      74:	0013490b 	andseq	r4, r3, fp, lsl #18
      78:	00350800 	eorseq	r0, r5, r0, lsl #16
      7c:	00001349 	andeq	r1, r0, r9, asr #6
      80:	0b010409 	bleq	410ac <_etext+0x39a98>
      84:	3b0b3a0b 	blcc	2ce8b8 <_etext+0x2c72a4>
      88:	0013010b 	andseq	r0, r3, fp, lsl #2
      8c:	00280a00 	eoreq	r0, r8, r0, lsl #20
      90:	0d1c0e03 	ldceq	14, cr0, [ip, #-12]
      94:	130b0000 	movwne	r0, #45056	; 0xb000
      98:	3a0b0b01 	bcc	2c2ca4 <_etext+0x2bb690>
      9c:	010b3b0b 	tsteq	fp, fp, lsl #22
      a0:	0c000013 	stceq	0, cr0, [r0], {19}
      a4:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
      a8:	0b3b0b3a 	bleq	ec2d98 <_etext+0xebb784>

	return f25519_eq(a, c);
      ac:	0b381349 	bleq	e04dd8 <_etext+0xdfd7c4>
      b0:	0d0d0000 	stceq	0, cr0, [sp, #-0]
      b4:	3a080300 	bcc	200cbc <_etext+0x1f96a8>
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
      b8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	f25519_normalize(ey);
      bc:	000b3813 	andeq	r3, fp, r3, lsl r8
      c0:	01040e00 	tsteq	r4, r0, lsl #28

	return ok;
}
      c4:	0b0b0e03 	bleq	2c38d8 <_etext+0x2bc2c4>
      c8:	0b3b0b3a 	bleq	ec2db8 <_etext+0xebb7a4>
      cc:	00001301 	andeq	r1, r0, r1, lsl #6
      d0:	0301130f 	movweq	r1, #4879	; 0x130f
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
      d4:	3a0b0b0e 	bcc	2c2d14 <_etext+0x2bb700>
      d8:	010b3b0b 	tsteq	fp, fp, lsl #22
		minusp[i] = c;
      dc:	10000013 	andne	r0, r0, r3, lsl r0
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
      e0:	19270115 	stmdbne	r7!, {r0, r2, r4, r8}
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
      e4:	13011349 	movwne	r1, #4937	; 0x1349

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
      e8:	05110000 	ldreq	r0, [r1, #-0]
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
      ec:	00134900 	andseq	r4, r3, r0, lsl #18
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
      f0:	01131200 	tsteq	r3, r0, lsl #4
      f4:	0b0b0803 	bleq	2c2108 <_etext+0x2baaf4>
      f8:	0b3b0b3a 	bleq	ec2de8 <_etext+0xebb7d4>
      fc:	00001301 	andeq	r1, r0, r1, lsl #6
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     100:	0b011713 	bleq	45d54 <_etext+0x3e740>

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
     104:	3b0b3a0b 	blcc	2ce938 <_etext+0x2c7324>
     108:	0013010b 	andseq	r0, r3, fp, lsl #2
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     10c:	000d1400 	andeq	r1, sp, r0, lsl #8
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
     110:	0b3a0803 	bleq	e82124 <_etext+0xe7ab10>
     114:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     118:	2e150000 	cdpcs	0, 1, cr0, cr5, cr0, {0}
     11c:	03193f01 	tsteq	r9, #1, 30
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     120:	3b0b3a0e 	blcc	2ce960 <_etext+0x2c734c>
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
     124:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
     128:	010b2013 	tsteq	fp, r3, lsl r0
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
     12c:	16000013 			; <UNDEFINED> instruction: 0x16000013

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
     130:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
	i <<= 3;

	while (x) {
     134:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
     138:	00001349 	andeq	r1, r0, r9, asr #6
     13c:	3f002e17 	svccc	0x00002e17
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
     140:	3a0e0319 	bcc	380dac <_etext+0x379798>
	f25519_mul_c(z3, x1sq, 4);
     144:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     148:	000b2019 	andeq	r2, fp, r9, lsl r0
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	002e1800 	eoreq	r1, lr, r0, lsl #16
     150:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     154:	0b3b0b3a 	bleq	ec2e44 <_etext+0xebb830>
	f25519_sub(b, x3, z3); /* D */
     158:	01111927 	tsteq	r1, r7, lsr #18
     15c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
	f25519_mul__distinct(da, a, b);
     160:	00194297 	mulseq	r9, r7, r2
     164:	002e1900 	eoreq	r1, lr, r0, lsl #18
     168:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}

	f25519_sub(b, x2, z2);
     16c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     170:	01111927 	tsteq	r1, r7, lsr #18
	f25519_add(a, x3, z3); /* C */
     174:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     178:	00194297 	mulseq	r9, r7, r2
     17c:	012e1a00 	teqeq	lr, r0, lsl #20
	f25519_mul__distinct(cb, a, b);
     180:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     184:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a

	f25519_add(a, da, cb);
     188:	13491927 	movtne	r1, #39207	; 0x9927
     18c:	06120111 			; <UNDEFINED> instruction: 0x06120111
     190:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
	f25519_mul__distinct(b, a, a);
     194:	00130119 	andseq	r0, r3, r9, lsl r1
     198:	00051b00 	andeq	r1, r5, r0, lsl #22
	f25519_mul__distinct(x5, z1, b);
     19c:	0b3a0e03 	bleq	e839b0 <_etext+0xe7c39c>
     1a0:	1349053b 	movtne	r0, #38203	; 0x953b
     1a4:	00001702 	andeq	r1, r0, r2, lsl #14

	f25519_sub(a, da, cb);
     1a8:	0300051c 	movweq	r0, #1308	; 0x51c
     1ac:	3b0b3a0e 	blcc	2ce9ec <_etext+0x2c73d8>
	f25519_mul__distinct(b, a, a);
     1b0:	02134905 	andseq	r4, r3, #81920	; 0x14000
     1b4:	1d000018 	stcne	0, cr0, [r0, #-96]	; 0xffffffa0
     1b8:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	0b3a0e03 	bleq	e839d0 <_etext+0xe7c3bc>
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
     1c4:	06120111 			; <UNDEFINED> instruction: 0x06120111

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1c8:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     1cc:	00130119 	andseq	r0, r3, r9, lsl r1
     1d0:	010b1e00 	tsteq	fp, r0, lsl #28
     1d4:	06120111 			; <UNDEFINED> instruction: 0x06120111
		f25519_select(zm1, zm1, zm, bit);
     1d8:	00001301 	andeq	r1, r0, r1, lsl #6
     1dc:	0300341f 	movweq	r3, #1055	; 0x41f
     1e0:	3b0b3a0e 	blcc	2cea20 <_etext+0x2c740c>
		f25519_select(xm, xm, xms, bit);
     1e4:	02134905 	andseq	r4, r3, #81920	; 0x14000
     1e8:	20000017 	andcs	r0, r0, r7, lsl r0
     1ec:	00018289 	andeq	r8, r1, r9, lsl #5
		f25519_select(zm, zm, zms, bit);
     1f0:	13310111 	teqne	r1, #1073741828	; 0x40000004
     1f4:	89210000 	stmdbhi	r1!, {}	; <UNPREDICTABLE>
     1f8:	11010182 	smlabbne	r1, r2, r1, r0
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fc:	01133101 	tsteq	r3, r1, lsl #2
     200:	22000013 	andcs	r0, r0, #19
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     204:	0001828a 	andeq	r8, r1, sl, lsl #5
     208:	42911802 	addsmi	r1, r1, #131072	; 0x20000
	f25519_mul__distinct(result, zm1, xm);
     20c:	23000018 	movwcs	r0, #24
     210:	01018289 	smlabbeq	r1, r9, r2, r8
	f25519_normalize(result);
     214:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
     218:	00133119 	andseq	r3, r3, r9, lsl r1
}
     21c:	82892400 	addhi	r2, r9, #0, 8
     220:	01110101 	tsteq	r1, r1, lsl #2
     224:	05250000 	streq	r0, [r5, #-0]!
     228:	3a080300 	bcc	200e30 <_etext+0x1f981c>
     22c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     230:	00170213 	andseq	r0, r7, r3, lsl r2
     234:	82892600 	addhi	r2, r9, #0, 12
     238:	01110001 	tsteq	r1, r1
     23c:	31194295 			; <UNDEFINED> instruction: 0x31194295
     240:	27000013 	smladcs	r0, r3, r0, r0
     244:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     248:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     24c:	00001349 	andeq	r1, r0, r9, asr #6
     250:	31012e28 	tstcc	r1, r8, lsr #28
     254:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     258:	97184006 	ldrls	r4, [r8, -r6]
     25c:	13011942 	movwne	r1, #6466	; 0x1942
     260:	05290000 	streq	r0, [r9, #-0]!
     264:	02133100 	andseq	r3, r3, #0, 2
     268:	2a000017 	bcs	2cc <GPIO_ReadOutputDataBit>
     26c:	0111010b 	tsteq	r1, fp, lsl #2
     270:	00000612 	andeq	r0, r0, r2, lsl r6
     274:	3f012e2b 	svccc	0x00012e2b
     278:	3a0e0319 	bcc	380ee4 <_etext+0x3798d0>
     27c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     280:	12011119 	andne	r1, r1, #1073741830	; 0x40000006
     284:	97184006 	ldrls	r4, [r8, -r6]
     288:	13011942 	movwne	r1, #6466	; 0x1942
     28c:	342c0000 	strtcc	r0, [ip], #-0
     290:	3a0e0300 	bcc	380e98 <_etext+0x379884>
     294:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     298:	00180213 	andseq	r0, r8, r3, lsl r2
     29c:	011d2d00 	tsteq	sp, r0, lsl #26
     2a0:	01111331 	tsteq	r1, r1, lsr r3
     2a4:	0b580612 	bleq	1601af4 <_etext+0x15fa4e0>
     2a8:	13010b59 	movwne	r0, #7001	; 0x1b59
     2ac:	342e0000 	strtcc	r0, [lr], #-0
     2b0:	3a0e0300 	bcc	380eb8 <_etext+0x3798a4>
     2b4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     2b8:	00170213 	andseq	r0, r7, r3, lsl r2
     2bc:	00052f00 	andeq	r2, r5, r0, lsl #30
     2c0:	0b3a0e03 	bleq	e83ad4 <_etext+0xe7c4c0>
     2c4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     2c8:	00001702 	andeq	r1, r0, r2, lsl #14
     2cc:	3f012e30 	svccc	0x00012e30
     2d0:	3a0e0319 	bcc	380f3c <_etext+0x379928>
     2d4:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
     2d8:	11134919 	tstne	r3, r9, lsl r9
     2dc:	40061201 	andmi	r1, r6, r1, lsl #4
     2e0:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
     2e4:	00001301 	andeq	r1, r0, r1, lsl #6
     2e8:	01828931 	orreq	r8, r2, r1, lsr r9
     2ec:	31011101 	tstcc	r1, r1, lsl #2
     2f0:	32000013 	andcc	r0, r0, #19
     2f4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     2f8:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     2fc:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     300:	2e330000 	cdpcs	0, 3, cr0, cr3, cr0, {0}
     304:	03193f01 	tsteq	r9, #1, 30
     308:	3b0b3a0e 	blcc	2ceb48 <_etext+0x2c7534>
     30c:	11192705 	tstne	r9, r5, lsl #14
     310:	40061201 	andmi	r1, r6, r1, lsl #4
     314:	19429618 	stmdbne	r2, {r3, r4, r9, sl, ip, pc}^
     318:	00001301 	andeq	r1, r0, r1, lsl #6
     31c:	3f002e34 	svccc	0x00002e34
     320:	3a0e0319 	bcc	380f8c <_etext+0x379978>
     324:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     328:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
     32c:	97184006 	ldrls	r4, [r8, -r6]
     330:	00001942 	andeq	r1, r0, r2, asr #18
     334:	03003435 	movweq	r3, #1077	; 0x435
     338:	3b0b3a0e 	blcc	2ceb78 <_etext+0x2c7564>
     33c:	1c13490b 	ldcne	9, cr4, [r3], {11}
     340:	36000006 	strcc	r0, [r0], -r6
     344:	13490026 	movtne	r0, #36902	; 0x9026
     348:	34370000 	ldrtcc	r0, [r7], #-0
     34c:	3a0e0300 	bcc	380f54 <_etext+0x379940>
     350:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     354:	02193f13 	andseq	r3, r9, #19, 30	; 0x4c
     358:	38000018 	stmdacc	r0, {r3, r4}
     35c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     360:	0b3b0b3a 	bleq	ec3050 <_etext+0xebba3c>
     364:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
     368:	0000193c 	andeq	r1, r0, ip, lsr r9
     36c:	49010139 	stmdbmi	r1, {r0, r3, r4, r5, r8}
     370:	00130113 	andseq	r0, r3, r3, lsl r1
     374:	00213a00 	eoreq	r3, r1, r0, lsl #20
     378:	0b2f1349 	bleq	bc50a4 <_etext+0xbbda90>
     37c:	213b0000 	teqcs	fp, r0
     380:	3c000000 	stccc	0, cr0, [r0], {-0}
     384:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
     388:	0b3a0e03 	bleq	e83b9c <_etext+0xe7c588>
     38c:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     390:	0000193c 	andeq	r1, r0, ip, lsr r9
     394:	3f012e3d 	svccc	0x00012e3d
     398:	3a0e0319 	bcc	381004 <_etext+0x3799f0>
     39c:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     3a0:	01193c19 	tsteq	r9, r9, lsl ip
     3a4:	3e000013 	mcrcc	0, 0, r0, cr0, cr3, {0}
     3a8:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     3ac:	0b3a0e03 	bleq	e83bc0 <_etext+0xe7c5ac>
     3b0:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     3b4:	1301193c 	movwne	r1, #6460	; 0x193c
     3b8:	2e3f0000 	cdpcs	0, 3, cr0, cr15, cr0, {0}
     3bc:	03193f00 	tsteq	r9, #0, 30
     3c0:	3b0b3a0e 	blcc	2cec00 <_etext+0x2c75ec>
     3c4:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
     3c8:	00193c13 	andseq	r3, r9, r3, lsl ip
     3cc:	012e4000 	teqeq	lr, r0
     3d0:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     3d4:	0b3b0b3a 	bleq	ec30c4 <_etext+0xebbab0>
     3d8:	13491927 	movtne	r1, #39207	; 0x9927
     3dc:	1301193c 	movwne	r1, #6460	; 0x193c
     3e0:	2e410000 	cdpcs	0, 4, cr0, cr1, cr0, {0}
     3e4:	03193f01 	tsteq	r9, #1, 30
     3e8:	3b0b3a0e 	blcc	2cec28 <_etext+0x2c7614>
     3ec:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
     3f0:	01193c13 	tsteq	r9, r3, lsl ip
     3f4:	42000013 	andmi	r0, r0, #19
     3f8:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
     3fc:	0b3a0e03 	bleq	e83c10 <_etext+0xe7c5fc>
     400:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
     404:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
     408:	01000000 	mrseq	r0, (UNDEF: 0)
     40c:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
     410:	0e030b13 	vmoveq.32	d3[0], r0
     414:	17100e1b 			; <UNDEFINED> instruction: 0x17100e1b
     418:	24020000 	strcs	r0, [r2], #-0
     41c:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     420:	0008030b 	andeq	r0, r8, fp, lsl #6
     424:	00240300 	eoreq	r0, r4, r0, lsl #6
     428:	0b3e0b0b 	bleq	f8305c <_etext+0xf7ba48>
     42c:	00000e03 	andeq	r0, r0, r3, lsl #28
     430:	03001604 	movweq	r1, #1540	; 0x604
     434:	3b0b3a08 	blcc	2cec5c <_etext+0x2c7648>
     438:	0013490b 	andseq	r4, r3, fp, lsl #18
     43c:	01130500 	tsteq	r3, r0, lsl #10
     440:	0b0b0e03 	bleq	2c3c54 <_etext+0x2bc640>
     444:	0b3b0b3a 	bleq	ec3134 <_etext+0xebbb20>
     448:	00001301 	andeq	r1, r0, r1, lsl #6
     44c:	03000d06 	movweq	r0, #3334	; 0xd06
     450:	3b0b3a0e 	blcc	2cec90 <_etext+0x2c767c>
     454:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     458:	0700000b 	streq	r0, [r0, -fp]
     45c:	0b0b000f 	bleq	2c04a0 <_etext+0x2b8e8c>
     460:	00001349 	andeq	r1, r0, r9, asr #6
     464:	03001608 	movweq	r1, #1544	; 0x608
     468:	3b0b3a0e 	blcc	2ceca8 <_etext+0x2c7694>
     46c:	0013490b 	andseq	r4, r3, fp, lsl #18
     470:	00340900 	eorseq	r0, r4, r0, lsl #18
     474:	0b3a0e03 	bleq	e83c88 <_etext+0xe7c674>
     478:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     47c:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
     480:	010a0000 	mrseq	r0, (UNDEF: 10)
     484:	01134901 	tsteq	r3, r1, lsl #18
     488:	0b000013 	bleq	4dc <RCC_GetSYSCLKSource>
     48c:	13490021 	movtne	r0, #36897	; 0x9021
     490:	00000b2f 	andeq	r0, r0, pc, lsr #22
     494:	01110100 	tsteq	r1, r0, lsl #2
     498:	0b130e25 	bleq	4c3d34 <_etext+0x4bc720>
     49c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     4a0:	01111755 	tsteq	r1, r5, asr r7
     4a4:	00001710 	andeq	r1, r0, r0, lsl r7
     4a8:	03001602 	movweq	r1, #1538	; 0x602
     4ac:	3b0b3a0e 	blcc	2cecec <_etext+0x2c76d8>
     4b0:	0013490b 	andseq	r4, r3, fp, lsl #18
     4b4:	00240300 	eoreq	r0, r4, r0, lsl #6
     4b8:	0b3e0b0b 	bleq	f830ec <_etext+0xf7bad8>
     4bc:	00000e03 	andeq	r0, r0, r3, lsl #28
     4c0:	0b002404 	bleq	94d8 <_etext+0x1ec4>
     4c4:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     4c8:	05000008 	streq	r0, [r0, #-8]
     4cc:	0b0b000f 	bleq	2c0510 <_etext+0x2b8efc>
     4d0:	00001349 	andeq	r1, r0, r9, asr #6
     4d4:	49002606 	stmdbmi	r0, {r1, r2, r9, sl, sp}
     4d8:	07000013 	smladeq	r0, r3, r0, r0
     4dc:	08030016 	stmdaeq	r3, {r1, r2, r4}
     4e0:	0b3b0b3a 	bleq	ec31d0 <_etext+0xebbbbc>
     4e4:	00001349 	andeq	r1, r0, r9, asr #6
     4e8:	49003508 	stmdbmi	r0, {r3, r8, sl, ip, sp}
     4ec:	09000013 	stmdbeq	r0, {r0, r1, r4}
     4f0:	0b0b0104 	bleq	2c0908 <_etext+0x2b92f4>
     4f4:	0b3b0b3a 	bleq	ec31e4 <_etext+0xebbbd0>
     4f8:	00001301 	andeq	r1, r0, r1, lsl #6
     4fc:	0300280a 	movweq	r2, #2058	; 0x80a
     500:	000d1c0e 	andeq	r1, sp, lr, lsl #24
     504:	01130b00 	tsteq	r3, r0, lsl #22
     508:	0b0b0e03 	bleq	2c3d1c <_etext+0x2bc708>
     50c:	0b3b0b3a 	bleq	ec31fc <_etext+0xebbbe8>
     510:	00001301 	andeq	r1, r0, r1, lsl #6
     514:	03000d0c 	movweq	r0, #3340	; 0xd0c
     518:	3b0b3a0e 	blcc	2ced58 <_etext+0x2c7744>
     51c:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     520:	0d00000b 	stceq	0, cr0, [r0, #-44]	; 0xffffffd4
     524:	13490101 	movtne	r0, #37121	; 0x9101
     528:	00001301 	andeq	r1, r0, r1, lsl #6
     52c:	4900210e 	stmdbmi	r0, {r1, r2, r3, r8, sp}
     530:	0f000013 	svceq	0x00000013
     534:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     538:	0b3a0e03 	bleq	e83d4c <_etext+0xe7c738>
     53c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     540:	06120111 			; <UNDEFINED> instruction: 0x06120111
     544:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     548:	00130119 	andseq	r0, r3, r9, lsl r1
     54c:	00341000 	eorseq	r1, r4, r0
     550:	0b3a0e03 	bleq	e83d64 <_etext+0xe7c750>
     554:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     558:	00001702 	andeq	r1, r0, r2, lsl #14
     55c:	03003411 	movweq	r3, #1041	; 0x411
     560:	3b0b3a0e 	blcc	2ceda0 <_etext+0x2c778c>
     564:	1c13490b 	ldcne	9, cr4, [r3], {11}
     568:	1200000b 	andne	r0, r0, #11
     56c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     570:	0b3b0b3a 	bleq	ec3260 <_etext+0xebbc4c>
     574:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     578:	34130000 	ldrcc	r0, [r3], #-0
     57c:	3a080300 	bcc	201184 <_etext+0x1f9b70>
     580:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     584:	00170213 	andseq	r0, r7, r3, lsl r2
     588:	82891400 	addhi	r1, r9, #0, 8
     58c:	01110001 	tsteq	r1, r1
     590:	00001331 	andeq	r1, r0, r1, lsr r3
     594:	01828915 	orreq	r8, r2, r5, lsl r9
     598:	31011101 	tstcc	r1, r1, lsl #2
     59c:	00130113 	andseq	r0, r3, r3, lsl r1
     5a0:	828a1600 	addhi	r1, sl, #0, 12
     5a4:	18020001 	stmdane	r2, {r0}
     5a8:	00184291 	mulseq	r8, r1, r2
     5ac:	82891700 	addhi	r1, r9, #0, 14
     5b0:	01110101 	tsteq	r1, r1, lsl #2
     5b4:	00001331 	andeq	r1, r0, r1, lsr r3
     5b8:	03003418 	movweq	r3, #1048	; 0x418
     5bc:	3b0b3a0e 	blcc	2cedfc <_etext+0x2c77e8>
     5c0:	3f13490b 	svccc	0x0013490b
     5c4:	00180219 	andseq	r0, r8, r9, lsl r2
     5c8:	002e1900 	eoreq	r1, lr, r0, lsl #18
     5cc:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     5d0:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     5d4:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
     5d8:	2e1a0000 	cdpcs	0, 1, cr0, cr10, cr0, {0}
     5dc:	03193f00 	tsteq	r9, #0, 30
     5e0:	3b0b3a0e 	blcc	2cee20 <_etext+0x2c780c>
     5e4:	3c19270b 	ldccc	7, cr2, [r9], {11}
     5e8:	1b000019 	blne	654 <RCC_APB2PeriphClockCmd+0x4>
     5ec:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     5f0:	0b3a0e03 	bleq	e83e04 <_etext+0xe7c7f0>
     5f4:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
     5f8:	1301193c 	movwne	r1, #6460	; 0x193c
     5fc:	051c0000 	ldreq	r0, [ip, #-0]
     600:	00134900 	andseq	r4, r3, r0, lsl #18
     604:	00181d00 	andseq	r1, r8, r0, lsl #26
     608:	2e1e0000 	cdpcs	0, 1, cr0, cr14, cr0, {0}
     60c:	03193f01 	tsteq	r9, #1, 30
     610:	3b0b3a0e 	blcc	2cee50 <_etext+0x2c783c>
     614:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
     618:	01193c13 	tsteq	r9, r3, lsl ip
     61c:	1f000013 	svcne	0x00000013
     620:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     624:	0b3a0e03 	bleq	e83e38 <_etext+0xe7c824>
     628:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     62c:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
     630:	00001301 	andeq	r1, r0, r1, lsl #6
     634:	3f012e20 	svccc	0x00012e20
     638:	3a0e0319 	bcc	3812a4 <_etext+0x379c90>
     63c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     640:	01193c13 	tsteq	r9, r3, lsl ip
     644:	21000013 	tstcs	r0, r3, lsl r0
     648:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     64c:	0b3a0e03 	bleq	e83e60 <_etext+0xe7c84c>
     650:	193c0b3b 	ldmdbne	ip!, {r0, r1, r3, r4, r5, r8, r9, fp}
     654:	00001301 	andeq	r1, r0, r1, lsl #6
     658:	3f012e22 	svccc	0x00012e22
     65c:	3a0e0319 	bcc	3812c8 <_etext+0x379cb4>
     660:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     664:	00193c19 	andseq	r3, r9, r9, lsl ip
     668:	11010000 	mrsne	r0, (UNDEF: 1)
     66c:	130e2501 	movwne	r2, #58625	; 0xe501
     670:	1b0e030b 	blne	3812a4 <_etext+0x379c90>
     674:	1117550e 	tstne	r7, lr, lsl #10
     678:	00171001 	andseq	r1, r7, r1
     67c:	00160200 	andseq	r0, r6, r0, lsl #4
     680:	0b3a0e03 	bleq	e83e94 <_etext+0xe7c880>
     684:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     688:	24030000 	strcs	r0, [r3], #-0
     68c:	3e0b0b00 	vmlacc.f64	d0, d11, d0
     690:	000e030b 	andeq	r0, lr, fp, lsl #6
     694:	01130400 	tsteq	r3, r0, lsl #8
     698:	0b0b0e03 	bleq	2c3eac <_etext+0x2bc898>
     69c:	0b3b0b3a 	bleq	ec338c <_etext+0xebbd78>
     6a0:	00001301 	andeq	r1, r0, r1, lsl #6
     6a4:	03000d05 	movweq	r0, #3333	; 0xd05
     6a8:	3813490e 	ldmdacc	r3, {r1, r2, r3, r8, fp, lr}
     6ac:	0019340b 	andseq	r3, r9, fp, lsl #8
     6b0:	000f0600 	andeq	r0, pc, r0, lsl #12
     6b4:	00000b0b 	andeq	r0, r0, fp, lsl #22
     6b8:	0b002407 	bleq	96dc <_etext+0x20c8>
     6bc:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     6c0:	08000008 	stmdaeq	r0, {r3}
     6c4:	0b0b000f 	bleq	2c0708 <_etext+0x2b90f4>
     6c8:	00001349 	andeq	r1, r0, r9, asr #6
     6cc:	27001509 	strcs	r1, [r0, -r9, lsl #10]
     6d0:	0a000019 	beq	73c <USART_DeInit+0x4>
     6d4:	13490026 	movtne	r0, #36902	; 0x9026
     6d8:	160b0000 	strne	r0, [fp], -r0
     6dc:	3a080300 	bcc	2012e4 <_etext+0x1f9cd0>
     6e0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     6e4:	0c000013 	stceq	0, cr0, [r0], {19}
     6e8:	13490035 	movtne	r0, #36917	; 0x9035
     6ec:	040d0000 	streq	r0, [sp], #-0
     6f0:	3a0b0b01 	bcc	2c32fc <_etext+0x2bbce8>
     6f4:	010b3b0b 	tsteq	fp, fp, lsl #22
     6f8:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     6fc:	0e030028 	cdpeq	0, 0, cr0, cr3, cr8, {1}
     700:	00000d1c 	andeq	r0, r0, ip, lsl sp
     704:	0b01130f 	bleq	45348 <_etext+0x3dd34>
     708:	3b0b3a0b 	blcc	2cef3c <_etext+0x2c7928>
     70c:	0013010b 	andseq	r0, r3, fp, lsl #2
     710:	000d1000 	andeq	r1, sp, r0
     714:	0b3a0803 	bleq	e82728 <_etext+0xe7b114>
     718:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     71c:	00000b38 	andeq	r0, r0, r8, lsr fp
     720:	03000d11 	movweq	r0, #3345	; 0xd11
     724:	3b0b3a0e 	blcc	2cef64 <_etext+0x2c7950>
     728:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     72c:	1200000b 	andne	r0, r0, #11
     730:	050b0113 	streq	r0, [fp, #-275]	; 0x113
     734:	0b3b0b3a 	bleq	ec3424 <_etext+0xebbe10>
     738:	00001301 	andeq	r1, r0, r1, lsl #6
     73c:	03000d13 	movweq	r0, #3347	; 0xd13
     740:	3b0b3a0e 	blcc	2cef80 <_etext+0x2c796c>
     744:	3813490b 	ldmdacc	r3, {r0, r1, r3, r8, fp, lr}
     748:	14000005 	strne	r0, [r0], #-5
     74c:	0803000d 	stmdaeq	r3, {r0, r2, r3}
     750:	0b3b0b3a 	bleq	ec3440 <_etext+0xebbe2c>
     754:	05381349 	ldreq	r1, [r8, #-841]!	; 0x349
     758:	01150000 	tsteq	r5, r0
     75c:	01134901 	tsteq	r3, r1, lsl #18
     760:	16000013 			; <UNDEFINED> instruction: 0x16000013
     764:	13490021 	movtne	r0, #36897	; 0x9021
     768:	00000b2f 	andeq	r0, r0, pc, lsr #22
     76c:	03000d17 	movweq	r0, #3351	; 0xd17
     770:	3b0b3a08 	blcc	2cef98 <_etext+0x2c7984>
     774:	38134905 	ldmdacc	r3, {r0, r2, r8, fp, lr}
     778:	1800000b 	stmdane	r0, {r0, r1, r3}
     77c:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     780:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     784:	0b381349 	bleq	e054b0 <_etext+0xdfde9c>
     788:	13190000 	tstne	r9, #0
     78c:	0b0e0301 	bleq	381398 <_etext+0x379d84>
     790:	3b0b3a0b 	blcc	2cefc4 <_etext+0x2c79b0>
     794:	00130105 	andseq	r0, r3, r5, lsl #2
     798:	012e1a00 	teqeq	lr, r0, lsl #20
     79c:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     7a0:	0b3b0b3a 	bleq	ec3490 <_etext+0xebbe7c>
     7a4:	01111927 	tsteq	r1, r7, lsr #18
     7a8:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     7ac:	01194297 			; <UNDEFINED> instruction: 0x01194297
     7b0:	1b000013 	blne	804 <__Stack_Size+0x4>
     7b4:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     7b8:	0b3b0b3a 	bleq	ec34a8 <_etext+0xebbe94>
     7bc:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
     7c0:	051c0000 	ldreq	r0, [ip, #-0]
     7c4:	3a080300 	bcc	2013cc <_etext+0x1f9db8>
     7c8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
     7cc:	00170213 	andseq	r0, r7, r3, lsl r2
     7d0:	012e1d00 	teqeq	lr, r0, lsl #26
     7d4:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     7d8:	0b3b0b3a 	bleq	ec34c8 <_etext+0xebbeb4>
     7dc:	13491927 	movtne	r1, #39207	; 0x9927
     7e0:	06120111 			; <UNDEFINED> instruction: 0x06120111
     7e4:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     7e8:	00130119 	andseq	r0, r3, r9, lsl r1
     7ec:	00051e00 	andeq	r1, r5, r0, lsl #28
     7f0:	0b3a0e03 	bleq	e84004 <_etext+0xe7c9f0>
     7f4:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     7f8:	00001702 	andeq	r1, r0, r2, lsl #14
     7fc:	0300341f 	movweq	r3, #1055	; 0x41f
     800:	3b0b3a08 	blcc	2cf028 <_etext+0x2c7a14>
     804:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     808:	20000017 	andcs	r0, r0, r7, lsl r0
     80c:	01018289 	smlabbeq	r1, r9, r2, r8
     810:	13310111 	teqne	r1, #1073741828	; 0x40000004
     814:	00001301 	andeq	r1, r0, r1, lsl #6
     818:	01828a21 	orreq	r8, r2, r1, lsr #20
     81c:	91180200 	tstls	r8, r0, lsl #4
     820:	00001842 	andeq	r1, r0, r2, asr #16
     824:	01828922 	orreq	r8, r2, r2, lsr #18
     828:	31011101 	tstcc	r1, r1, lsl #2
     82c:	23000013 	movwcs	r0, #19
     830:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     834:	0b3a0e03 	bleq	e84048 <_etext+0xe7ca34>
     838:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
     83c:	06120111 			; <UNDEFINED> instruction: 0x06120111
     840:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     844:	00130119 	andseq	r0, r3, r9, lsl r1
     848:	00052400 	andeq	r2, r5, r0, lsl #8
     84c:	0b3a0e03 	bleq	e84060 <_etext+0xe7ca4c>
     850:	1349053b 	movtne	r0, #38203	; 0x953b
     854:	00001802 	andeq	r1, r0, r2, lsl #16
     858:	03000525 	movweq	r0, #1317	; 0x525
     85c:	3b0b3a08 	blcc	2cf084 <_etext+0x2c7a70>
     860:	02134905 	andseq	r4, r3, #81920	; 0x14000
     864:	26000018 			; <UNDEFINED> instruction: 0x26000018
     868:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
     86c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     870:	17021349 	strne	r1, [r2, -r9, asr #6]
     874:	05270000 	streq	r0, [r7, #-0]!
     878:	3a080300 	bcc	201480 <_etext+0x1f9e6c>
     87c:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
     880:	00170213 	andseq	r0, r7, r3, lsl r2
     884:	00342800 	eorseq	r2, r4, r0, lsl #16
     888:	0b3a0e03 	bleq	e8409c <_etext+0xe7ca88>
     88c:	1349053b 	movtne	r0, #38203	; 0x953b
     890:	00001802 	andeq	r1, r0, r2, lsl #16
     894:	00001829 	andeq	r1, r0, r9, lsr #16
     898:	00342a00 	eorseq	r2, r4, r0, lsl #20
     89c:	0b3a0803 	bleq	e828b0 <_etext+0xe7b29c>
     8a0:	1349053b 	movtne	r0, #38203	; 0x953b
     8a4:	00001702 	andeq	r1, r0, r2, lsl #14
     8a8:	0300342b 	movweq	r3, #1067	; 0x42b
     8ac:	3b0b3a08 	blcc	2cf0d4 <_etext+0x2c7ac0>
     8b0:	02134905 	andseq	r4, r3, #81920	; 0x14000
     8b4:	2c000018 	stccs	0, cr0, [r0], {24}
     8b8:	01018289 	smlabbeq	r1, r9, r2, r8
     8bc:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
     8c0:	00133119 	andseq	r3, r3, r9, lsl r1
     8c4:	012e2d00 	teqeq	lr, r0, lsl #26
     8c8:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     8cc:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     8d0:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}
     8d4:	00001301 	andeq	r1, r0, r1, lsl #6
     8d8:	3f002e2e 	svccc	0x00002e2e
     8dc:	3a0e0319 	bcc	381548 <_etext+0x379f34>
     8e0:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     8e4:	12011119 	andne	r1, r1, #1073741830	; 0x40000006
     8e8:	97184006 	ldrls	r4, [r8, -r6]
     8ec:	00001942 	andeq	r1, r0, r2, asr #18
     8f0:	0300342f 	movweq	r3, #1071	; 0x42f
     8f4:	3b0b3a0e 	blcc	2cf134 <_etext+0x2c7b20>
     8f8:	1c134905 	ldcne	9, cr4, [r3], {5}
     8fc:	3000000b 	andcc	r0, r0, fp
     900:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     904:	0b3a0e03 	bleq	e84118 <_etext+0xe7cb04>
     908:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
     90c:	0b201349 	bleq	805638 <_etext+0x7fe024>
     910:	00001301 	andeq	r1, r0, r1, lsl #6
     914:	03000531 	movweq	r0, #1329	; 0x531
     918:	3b0b3a08 	blcc	2cf140 <_etext+0x2c7b2c>
     91c:	00134905 	andseq	r4, r3, r5, lsl #18
     920:	00343200 	eorseq	r3, r4, r0, lsl #4
     924:	0b3a0e03 	bleq	e84138 <_etext+0xe7cb24>
     928:	1349053b 	movtne	r0, #38203	; 0x953b
     92c:	0b330000 	bleq	cc0934 <_etext+0xcb9320>
     930:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
     934:	34000006 	strcc	r0, [r0], #-6
     938:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     93c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     940:	17021349 	strne	r1, [r2, -r9, asr #6]
     944:	2e350000 	cdpcs	0, 3, cr0, cr5, cr0, {0}
     948:	03193f01 	tsteq	r9, #1, 30
     94c:	3b0b3a0e 	blcc	2cf18c <_etext+0x2c7b78>
     950:	11192705 	tstne	r9, r5, lsl #14
     954:	40061201 	andmi	r1, r6, r1, lsl #4
     958:	19429618 	stmdbne	r2, {r3, r4, r9, sl, ip, pc}^
     95c:	00001301 	andeq	r1, r0, r1, lsl #6
     960:	03001636 	movweq	r1, #1590	; 0x636
     964:	3b0b3a0e 	blcc	2cf1a4 <_etext+0x2c7b90>
     968:	00134905 	andseq	r4, r3, r5, lsl #18
     96c:	012e3700 	teqeq	lr, r0, lsl #14
     970:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     974:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     978:	01111349 	tsteq	r1, r9, asr #6
     97c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     980:	01194297 			; <UNDEFINED> instruction: 0x01194297
     984:	38000013 	stmdacc	r0, {r0, r1, r4}
     988:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     98c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     990:	0d1c1349 	ldceq	3, cr1, [ip, #-292]	; 0xfffffedc
     994:	89390000 	ldmdbhi	r9!, {}	; <UNPREDICTABLE>
     998:	11000182 	smlabbne	r0, r2, r1, r0
     99c:	00133101 	andseq	r3, r3, r1, lsl #2
     9a0:	012e3a00 	teqeq	lr, r0, lsl #20
     9a4:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     9a8:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     9ac:	13491927 	movtne	r1, #39207	; 0x9927
     9b0:	06120111 			; <UNDEFINED> instruction: 0x06120111
     9b4:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     9b8:	00130119 	andseq	r0, r3, r9, lsl r1
     9bc:	012e3b00 	teqeq	lr, r0, lsl #22
     9c0:	01111331 	tsteq	r1, r1, lsr r3
     9c4:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     9c8:	01194297 			; <UNDEFINED> instruction: 0x01194297
     9cc:	3c000013 	stccc	0, cr0, [r0], {19}
     9d0:	13310005 	teqne	r1, #5
     9d4:	00001702 	andeq	r1, r0, r2, lsl #14
     9d8:	3100343d 	tstcc	r0, sp, lsr r4
     9dc:	00170213 	andseq	r0, r7, r3, lsl r2
     9e0:	00343e00 	eorseq	r3, r4, r0, lsl #28
     9e4:	0b3a0e03 	bleq	e841f8 <_etext+0xe7cbe4>
     9e8:	1349053b 	movtne	r0, #38203	; 0x953b
     9ec:	0000061c 	andeq	r0, r0, ip, lsl r6
     9f0:	0300343f 	movweq	r3, #1087	; 0x43f
     9f4:	3b0b3a0e 	blcc	2cf234 <_etext+0x2c7c20>
     9f8:	3f13490b 	svccc	0x0013490b
     9fc:	00180219 	andseq	r0, r8, r9, lsl r2
     a00:	012e4000 	teqeq	lr, r0
     a04:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     a08:	0b3b0b3a 	bleq	ec36f8 <_etext+0xebc0e4>
     a0c:	13491927 	movtne	r1, #39207	; 0x9927
     a10:	1301193c 	movwne	r1, #6460	; 0x193c
     a14:	05410000 	strbeq	r0, [r1, #-0]
     a18:	00134900 	andseq	r4, r3, r0, lsl #18
     a1c:	012e4200 	teqeq	lr, r0, lsl #4
     a20:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     a24:	13491927 	movtne	r1, #39207	; 0x9927
     a28:	193c1934 	ldmdbne	ip!, {r2, r4, r5, r8, fp, ip}
     a2c:	00001301 	andeq	r1, r0, r1, lsl #6
     a30:	3f012e43 	svccc	0x00012e43
     a34:	3a0e0319 	bcc	3816a0 <_etext+0x37a08c>
     a38:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
     a3c:	01193c19 	tsteq	r9, r9, lsl ip
     a40:	44000013 	strmi	r0, [r0], #-19
     a44:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
     a48:	0b3a0e03 	bleq	e8425c <_etext+0xe7cc48>
     a4c:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     a50:	0000193c 	andeq	r1, r0, ip, lsr r9
     a54:	01110100 	tsteq	r1, r0, lsl #2
     a58:	0b130e25 	bleq	4c42f4 <_etext+0x4bcce0>
     a5c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     a60:	01111755 	tsteq	r1, r5, asr r7
     a64:	00001710 	andeq	r1, r0, r0, lsl r7
     a68:	0b002402 	bleq	9a78 <_etext+0x2464>
     a6c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     a70:	0300000e 	movweq	r0, #14
     a74:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     a78:	0b3b0b3a 	bleq	ec3768 <_etext+0xebc154>
     a7c:	00001349 	andeq	r1, r0, r9, asr #6
     a80:	0b002404 	bleq	9a98 <_etext+0x2484>
     a84:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     a88:	05000008 	streq	r0, [r0, #-8]
     a8c:	08030016 	stmdaeq	r3, {r1, r2, r4}
     a90:	0b3b0b3a 	bleq	ec3780 <_etext+0xebc16c>
     a94:	00001349 	andeq	r1, r0, r9, asr #6
     a98:	49003506 	stmdbmi	r0, {r1, r2, r8, sl, ip, sp}
     a9c:	07000013 	smladeq	r0, r3, r0, r0
     aa0:	0b0b0104 	bleq	2c0eb8 <_etext+0x2b98a4>
     aa4:	0b3b0b3a 	bleq	ec3794 <_etext+0xebc180>
     aa8:	00001301 	andeq	r1, r0, r1, lsl #6
     aac:	03002808 	movweq	r2, #2056	; 0x808
     ab0:	000d1c0e 	andeq	r1, sp, lr, lsl #24
     ab4:	000f0900 	andeq	r0, pc, r0, lsl #18
     ab8:	00000b0b 	andeq	r0, r0, fp, lsl #22
     abc:	0b000f0a 	bleq	46ec <sha256_process+0x160c>
     ac0:	0013490b 	andseq	r4, r3, fp, lsl #18
     ac4:	00260b00 	eoreq	r0, r6, r0, lsl #22
     ac8:	00001349 	andeq	r1, r0, r9, asr #6
     acc:	0301130c 	movweq	r1, #4876	; 0x130c
     ad0:	3a0b0b0e 	bcc	2c3710 <_etext+0x2bc0fc>
     ad4:	010b3b0b 	tsteq	fp, fp, lsl #22
     ad8:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
     adc:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
     ae0:	0b3b0b3a 	bleq	ec37d0 <_etext+0xebc1bc>
     ae4:	0b381349 	bleq	e05810 <_etext+0xdfe1fc>
     ae8:	150e0000 	strne	r0, [lr, #-0]
     aec:	49192701 	ldmdbmi	r9, {r0, r8, r9, sl, sp}
     af0:	00130113 	andseq	r0, r3, r3, lsl r1
     af4:	00050f00 	andeq	r0, r5, r0, lsl #30
     af8:	00001349 	andeq	r1, r0, r9, asr #6
     afc:	03011310 	movweq	r1, #4880	; 0x1310
     b00:	3a0b0b08 	bcc	2c3728 <_etext+0x2bc114>
     b04:	010b3b0b 	tsteq	fp, fp, lsl #22
     b08:	11000013 	tstne	r0, r3, lsl r0
     b0c:	0803000d 	stmdaeq	r3, {r0, r2, r3}
     b10:	0b3b0b3a 	bleq	ec3800 <_etext+0xebc1ec>
     b14:	0b381349 	bleq	e05840 <_etext+0xdfe22c>
     b18:	17120000 	ldrne	r0, [r2, -r0]
     b1c:	3a0b0b01 	bcc	2c3728 <_etext+0x2bc114>
     b20:	010b3b0b 	tsteq	fp, fp, lsl #22
     b24:	13000013 	movwne	r0, #19
     b28:	0803000d 	stmdaeq	r3, {r0, r2, r3}
     b2c:	0b3b0b3a 	bleq	ec381c <_etext+0xebc208>
     b30:	00001349 	andeq	r1, r0, r9, asr #6
     b34:	03010414 	movweq	r0, #5140	; 0x1414
     b38:	3a0b0b0e 	bcc	2c3778 <_etext+0x2bc164>
     b3c:	010b3b0b 	tsteq	fp, fp, lsl #22
     b40:	15000013 	strne	r0, [r0, #-19]
     b44:	08030028 	stmdaeq	r3, {r3, r5}
     b48:	00000d1c 	andeq	r0, r0, ip, lsl sp
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	0b011316 	bleq	457ac <_etext+0x3e198>
  b	LoopCopyDataInit
     b50:	3b0b3a0b 	blcc	2cf384 <_etext+0x2c7d70>

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
     b54:	0013010b 	andseq	r0, r3, fp, lsl #2
	str	r3, [r0, r1]
	adds	r1, r1, #4
     b58:	01011700 	tsteq	r1, r0, lsl #14

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
     b5c:	13011349 	movwne	r1, #4937	; 0x1349
	adds	r2, r0, r1
	cmp	r2, r3
     b60:	21180000 	tstcs	r8, r0
	bcc	CopyDataInit
     b64:	2f134900 	svccs	0x00134900
	ldr	r2, =_sbss
	b	LoopFillZerobss
     b68:	1900000b 	stmdbne	r0, {r0, r1, r3}
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	13490021 	movtne	r0, #36897	; 0x9021
	str	r3, [r2], #4
     b70:	2e1a0000 	cdpcs	0, 1, cr0, cr10, cr0, {0}

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
     b74:	03193f01 	tsteq	r9, #1, 30
	bcc	FillZerobss
     b78:	3b0b3a0e 	blcc	2cf3b8 <_etext+0x2c7da4>
/* Call the application's entry point.*/
	bl	main
     b7c:	1119270b 	tstne	r9, fp, lsl #14
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	40061201 	andmi	r1, r6, r1, lsl #4
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
	ldr	r3, =_edata
     b88:	00001301 	andeq	r1, r0, r1, lsl #6
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	0182891b 	orreq	r8, r2, fp, lsl r9
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	31011101 	tstcc	r1, r1, lsl #2
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	00130113 	andseq	r0, r3, r3, lsl r1
}


/* dummy proc */
void nothingProc(void)
{
     b98:	828a1c00 	addhi	r1, sl, #0, 24
{
    return;
}

void usbStatusOut(void)
{
     b9c:	18020001 	stmdane	r2, {r0}
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
     ba0:	00184291 	mulseq	r8, r1, r2
     ba4:	82891d00 	addhi	r1, r9, #0, 26
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	01110101 	tsteq	r1, r1, lsl #2
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	31194295 			; <UNDEFINED> instruction: 0x31194295
     bb0:	1e000013 	mcrne	0, 0, r0, cr0, cr3, {0}
        bDeviceState = CONFIGURED;
     bb4:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
     bb8:	0b3a0e03 	bleq	e843cc <_etext+0xe7cdb8>
     bbc:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
     bc0:	06120111 			; <UNDEFINED> instruction: 0x06120111
    }
}

void usbGetInterface(void)
{
     bc4:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
{
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	00130119 	andseq	r0, r3, r9, lsl r1
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	00341f00 	eorseq	r1, r4, r0, lsl #30
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	0b3a0e03 	bleq	e843e4 <_etext+0xe7cdd0>
     bd4:	1349053b 	movtne	r0, #38203	; 0x953b
     bd8:	00001702 	andeq	r1, r0, r2, lsl #14
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	01828920 	orreq	r8, r2, r0, lsr #18
    dfuUpdateByReset();
     be0:	31011100 	mrscc	r1, (UNDEF: 17)

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	21000013 	tstcs	r0, r3, lsl r0

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be8:	00018289 	andeq	r8, r1, r9, lsl #5
     bec:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	00133119 	andseq	r3, r3, r9, lsl r1
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	002e2200 	eoreq	r2, lr, r0, lsl #4
     bf8:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfc:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     c00:	01111927 	tsteq	r1, r7, lsr #18
     c04:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     c08:	00194297 	mulseq	r9, r7, r2
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c0c:	012e2300 	teqeq	lr, r0, lsl #6
     c10:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     c14:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     c18:	13491927 	movtne	r1, #39207	; 0x9927
     c1c:	06120111 			; <UNDEFINED> instruction: 0x06120111

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c20:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     c24:	00130119 	andseq	r0, r3, r9, lsl r1
     c28:	00052400 	andeq	r2, r5, r0, lsl #8
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	0b3a0e03 	bleq	e84440 <_etext+0xe7ce2c>
     c30:	1349053b 	movtne	r0, #38203	; 0x953b
     c34:	00001702 	andeq	r1, r0, r2, lsl #14
     c38:	03003425 	movweq	r3, #1061	; 0x425
     c3c:	3b0b3a08 	blcc	2cf464 <_etext+0x2c7e50>

    Clear_Status_Out(ENDP0);
     c40:	02134905 	andseq	r4, r3, #81920	; 0x14000

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c44:	26000017 			; <UNDEFINED> instruction: 0x26000017
     c48:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     c4c:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	00001349 	andeq	r1, r0, r9, asr #6
     c54:	01828927 	orreq	r8, r2, r7, lsr #18

    bDeviceState = ATTACHED;
     c58:	31011101 	tstcc	r1, r1, lsl #2
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
     c5c:	28000013 	stmdacs	r0, {r0, r1, r4}

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c64:	0b3a0e03 	bleq	e84478 <_etext+0xe7ce64>
     c68:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     c6c:	01111349 	tsteq	r1, r9, asr #6
     c70:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     c74:	01194297 			; <UNDEFINED> instruction: 0x01194297
     c78:	29000013 	stmdbcs	r0, {r0, r1, r4}
     c7c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     c80:	0b3b0b3a 	bleq	ec3970 <_etext+0xebc35c>
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	17021349 	strne	r1, [r2, -r9, asr #6]
     c88:	0b2a0000 	bleq	a80c90 <_etext+0xa7967c>
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8c:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
     c90:	00130106 	andseq	r0, r3, r6, lsl #2
     c94:	00342b00 	eorseq	r2, r4, r0, lsl #22
        if (dfuUpdateByRequest()) {
     c98:	0b3a0e03 	bleq	e844ac <_etext+0xe7ce98>
     c9c:	1349053b 	movtne	r0, #38203	; 0x953b
            // successfull state transition, handle the request
            switch (request) {
     ca0:	00001802 	andeq	r1, r0, r2, lsl #16
     ca4:	3f002e2c 	svccc	0x00002e2c
     ca8:	3a0e0319 	bcc	381914 <_etext+0x37a300>
     cac:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	11134919 	tstne	r3, r9, lsl r9
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
     cb4:	40061201 	andmi	r1, r6, r1, lsl #4
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
     cb8:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	052d0000 	streq	r0, [sp, #-0]!
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
     cc0:	3a0e0300 	bcc	3818c8 <_etext+0x37a2b4>
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
        (*CopyRoutine)(0);

        return USB_SUCCESS;
     cc8:	00180213 	andseq	r0, r8, r3, lsl r2
    }

    return USB_UNSUPPORT;
     ccc:	002e2e00 	eoreq	r2, lr, r0, lsl #28
}
     cd0:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     cd4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     cd8:	01111349 	tsteq	r1, r9, asr #6
     cdc:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     ce0:	00194297 	mulseq	r9, r7, r2
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	002e2f00 	eoreq	r2, lr, r0, lsl #30
     ce8:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     cec:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	06120111 			; <UNDEFINED> instruction: 0x06120111
     cf4:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
     cf8:	30000019 	andcc	r0, r0, r9, lsl r0
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     d00:	0b3b0b3a 	bleq	ec39f0 <_etext+0xebc3dc>
    if (strIndex > STR_DESC_LEN) {
     d04:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d08:	21310000 	teqcs	r1, r0
     d0c:	2f134900 	svccs	0x00134900
    }
}
     d10:	32000005 	andcc	r0, r0, #5
     d14:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     d18:	0b3b0b3a 	bleq	ec3a08 <_etext+0xebc3f4>

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
     d1c:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
     d20:	0000193c 	andeq	r1, r0, ip, lsr r9
     d24:	03003433 	movweq	r3, #1075	; 0x433

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	3b0b3a0e 	blcc	2cf568 <_etext+0x2c7f54>
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2c:	3f13490b 	svccc	0x0013490b
     d30:	00180219 	andseq	r0, r8, r9, lsl r2
     d34:	00343400 	eorseq	r3, r4, r0, lsl #8
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	0b3a0803 	bleq	e82d4c <_etext+0xe7b738>
     d3c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
            return USB_SUCCESS;
     d40:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
     d44:	2e350000 	cdpcs	0, 3, cr0, cr5, cr0, {0}
        }
    }
    return USB_UNSUPPORT;
}
     d48:	03193f01 	tsteq	r9, #1, 30
     d4c:	3b0b3a0e 	blcc	2cf58c <_etext+0x2c7f78>

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d54:	01193c13 	tsteq	r9, r3, lsl ip
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	36000013 			; <UNDEFINED> instruction: 0x36000013
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5c:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d60:	0b3a0e03 	bleq	e84574 <_etext+0xe7cf60>
     d64:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
     d68:	1301193c 	movwne	r1, #6460	; 0x193c
     d6c:	2e370000 	cdpcs	0, 3, cr0, cr7, cr0, {0}
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d70:	03193f00 	tsteq	r9, #0, 30
     d74:	3b0b3a0e 	blcc	2cf5b4 <_etext+0x2c7fa0>
     d78:	3c192705 	ldccc	7, cr2, [r9], {5}
     d7c:	38000019 	stmdacc	r0, {r0, r3, r4}
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d80:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	0b3a0e03 	bleq	e84598 <_etext+0xe7cf84>
     d88:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8c:	0000193c 	andeq	r1, r0, ip, lsr r9
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d90:	3f012e39 	svccc	0x00012e39
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d94:	3a0e0319 	bcc	381a00 <_etext+0x37a3ec>
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d98:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	3c134919 	ldccc	9, cr4, [r3], {25}
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	00130119 	andseq	r0, r3, r9, lsl r1
     da4:	012e3a00 	teqeq	lr, r0, lsl #20
     da8:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     dac:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     db0:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
     db4:	00001301 	andeq	r1, r0, r1, lsl #6
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	0000183b 	andeq	r1, r0, fp, lsr r8
     dbc:	002e3c00 	eoreq	r3, lr, r0, lsl #24
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dc0:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
     dc8:	13491927 	movtne	r1, #39207	; 0x9927
     dcc:	0000193c 	andeq	r1, r0, ip, lsr r9
     dd0:	01110100 	tsteq	r1, r0, lsl #2
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	0b130e25 	bleq	4c4670 <_etext+0x4bd05c>
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd8:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
     ddc:	01111755 	tsteq	r1, r5, asr r7

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	00001710 	andeq	r1, r0, r0, lsl r7
     de4:	0b002402 	bleq	9df4 <_etext+0x27e0>
     de8:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	0300000e 	movweq	r0, #14
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
        ResumeS.eState = eResumeSetVal;
     df4:	0b3b0b3a 	bleq	ec3ae4 <_etext+0xebc4d0>

    switch (ResumeS.eState) {
     df8:	00001349 	andeq	r1, r0, r9, asr #6
     dfc:	0b002404 	bleq	9e14 <_etext+0x2800>
     e00:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     e04:	05000008 	streq	r0, [r0, #-8]
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	0e03012e 	adfeqsp	f0, f3, #0.5
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	0b3b0b3a 	bleq	ec3afc <_etext+0xebc4e8>
        ResumeS.eState = RESUME_START;
     e10:	0b201927 	bleq	8072b4 <_etext+0x7ffca0>
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	00001301 	andeq	r1, r0, r1, lsl #6
        ResumeS.eState = RESUME_WAIT;
     e18:	03000506 	movweq	r0, #1286	; 0x506
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	3b0b3a08 	blcc	2cf644 <_etext+0x2c8030>
     e20:	0013490b 	andseq	r4, r3, fp, lsl #18
        if (ResumeS.bESOFcnt == 0)
     e24:	000f0700 	andeq	r0, pc, r0, lsl #14
            ResumeS.eState = RESUME_START;
     e28:	13490b0b 	movtne	r0, #39691	; 0x9b0b
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	26080000 	strcs	r0, [r8], -r0
     e30:	00134900 	andseq	r4, r3, r0, lsl #18
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e34:	00340900 	eorseq	r0, r4, r0, lsl #18
        ResumeS.eState = RESUME_ON;
     e38:	0b3a0803 	bleq	e82e4c <_etext+0xe7b838>
        ResumeS.bESOFcnt = 10;
     e3c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
        break;
     e40:	010a0000 	mrseq	r0, (UNDEF: 10)
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e44:	01134901 	tsteq	r3, r1, lsl #18
     e48:	0b000013 	bleq	e9c <usbPowerOn+0x2c>
        if (ResumeS.bESOFcnt == 0) {
     e4c:	13490021 	movtne	r0, #36897	; 0x9021
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	00000b2f 	andeq	r0, r0, pc, lsr #22
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	0300340c 	movweq	r3, #1036	; 0x40c
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e58:	3b0b3a0e 	blcc	2cf698 <_etext+0x2c8084>
            ResumeS.eState = RESUME_OFF;
     e5c:	0013490b 	andseq	r4, r3, fp, lsl #18
     e60:	012e0d00 	teqeq	lr, r0, lsl #26
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e64:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     e68:	0b3b0b3a 	bleq	ec3b58 <_etext+0xebc544>
     e6c:	01111927 	tsteq	r1, r7, lsr #18
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
     e74:	01194297 			; <UNDEFINED> instruction: 0x01194297
     e78:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
     e7c:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}

    _SetCNTR(CNTR_FRES);
     e80:	0b3b0b3a 	bleq	ec3b70 <_etext+0xebc55c>
     e84:	17021349 	strne	r1, [r2, -r9, asr #6]
     e88:	050f0000 	streq	r0, [pc, #-0]	; e90 <usbPowerOn+0x20>
     e8c:	3a080300 	bcc	201a94 <_etext+0x1fa480>
    _SetCNTR(0);
    _SetISTR(0);
     e90:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e94:	00170213 	andseq	r0, r7, r3, lsl r2
    _SetCNTR(wInterrupt_Mask);
     e98:	00341000 	eorseq	r1, r4, r0
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9c:	0b3a0803 	bleq	e82eb0 <_etext+0xe7b89c>
     ea0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
#endif
#endif

    return USB_SUCCESS;
}
     ea4:	00001802 	andeq	r1, r0, r2, lsl #16
     ea8:	03003411 	movweq	r3, #1041	; 0x411
     eac:	3b0b3a08 	blcc	2cf6d4 <_etext+0x2c80c0>
     eb0:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
     eb4:	12000017 	andne	r0, r0, #23

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	1331011d 	teqne	r1, #1073741831	; 0x40000007
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	17550152 			; <UNDEFINED> instruction: 0x17550152
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
     ec0:	0b590b58 	bleq	1643c28 <_etext+0x163c614>
     ec4:	00001301 	andeq	r1, r0, r1, lsl #6
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec8:	31000513 	tstcc	r0, r3, lsl r5
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     ecc:	00170213 	andseq	r0, r7, r3, lsl r2
     ed0:	010b1400 	tsteq	fp, r0, lsl #8
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	13011755 	movwne	r1, #5973	; 0x1755
     ed8:	05150000 	ldreq	r0, [r5, #-0]
     edc:	00133100 	andseq	r3, r3, r0, lsl #2

    return USB_SUCCESS;
}
     ee0:	010b1600 	tsteq	fp, r0, lsl #12
     ee4:	00001755 	andeq	r1, r0, r5, asr r7
     ee8:	31003417 	tstcc	r0, r7, lsl r4
     eec:	00180213 	andseq	r0, r8, r3, lsl r2
     ef0:	82891800 	addhi	r1, r9, #0, 16
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	01110101 	tsteq	r1, r1, lsl #2
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	13011331 	movwne	r1, #4913	; 0x1331
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efc:	8a190000 	bhi	640f04 <_etext+0x6398f0>
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	02000182 	andeq	r0, r0, #-2147483616	; 0x80000020
     f04:	18429118 	stmdane	r2, {r3, r4, r8, ip, pc}^
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f08:	891a0000 	ldmdbhi	sl, {}	; <UNPREDICTABLE>
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	11010182 	smlabbne	r1, r2, r1, r0
     f10:	00133101 	andseq	r3, r3, r1, lsl #2
    nvicInit(&NVIC_InitStructure);
     f14:	011d1b00 	tsteq	sp, r0, lsl #22
}
     f18:	01111331 	tsteq	r1, r1, lsr r3

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	0b580612 	bleq	160276c <_etext+0x15fb158>
    dfuInit();
     f20:	13010b59 	movwne	r0, #7001	; 0x1b59

    pInformation->Current_Configuration = 0;
     f24:	0b1c0000 	bleq	700f2c <_etext+0x6f9918>
     f28:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
    usbPowerOn();
     f2c:	1d000006 	stcne	0, cr0, [r0, #-24]	; 0xffffffe8

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
     f30:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
     f34:	0b3b0b3a 	bleq	ec3c24 <_etext+0xebc610>
     f38:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
    _SetCNTR(wInterrupt_Mask);
     f3c:	0000193c 	andeq	r1, r0, ip, lsr r9

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f40:	0300341e 	movweq	r3, #1054	; 0x41e
    bDeviceState = UNCONNECTED;
     f44:	3b0b3a0e 	blcc	2cf784 <_etext+0x2c8170>
     f48:	3f13490b 	svccc	0x0013490b
     f4c:	00180219 	andseq	r0, r8, r9, lsl r2
     f50:	012e1f00 	teqeq	lr, r0, lsl #30
     f54:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
     f58:	0b3b0b3a 	bleq	ec3c48 <_etext+0xebc634>
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f60:	00001301 	andeq	r1, r0, r1, lsl #6
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	49000520 	stmdbmi	r0, {r5, r8, sl}

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f68:	21000013 	tstcs	r0, r3, lsl r0
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	0b3a0e03 	bleq	e84784 <_etext+0xe7d170>
    nvicInit(&NVIC_InitStructure);
     f74:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
}
     f78:	0000193c 	andeq	r1, r0, ip, lsr r9
     f7c:	01110100 	tsteq	r1, r0, lsl #2

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	0b130e25 	bleq	4c481c <_etext+0x4bd208>
    wIstr = _GetISTR();
     f84:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	01111755 	tsteq	r1, r5, asr r7
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8c:	00001710 	andeq	r1, r0, r0, lsl r7

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f90:	0b002402 	bleq	9fa0 <_etext+0x298c>
     f94:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	0300000e 	movweq	r0, #14
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
     fa0:	0b3b0b3a 	bleq	ec3c90 <_etext+0xebc67c>
     fa4:	00001349 	andeq	r1, r0, r9, asr #6
        _SetISTR((u16)CLR_RESET);
     fa8:	0b002404 	bleq	9fc0 <_etext+0x29ac>
        Device_Property.Reset();
     fac:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
     fb0:	05000008 	streq	r0, [r0, #-8]
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb4:	0b0b000f 	bleq	2c0ff8 <_etext+0x2b99e4>
     fb8:	13060000 	movwne	r0, #24576	; 0x6000
        _SetISTR((u16)CLR_ERR);
     fbc:	0b0e0301 	bleq	381bc8 <_etext+0x37a5b4>
     fc0:	3b0b3a0b 	blcc	2cf7f4 <_etext+0x2c81e0>
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc4:	0013010b 	andseq	r0, r3, fp, lsl #2
     fc8:	000d0700 	andeq	r0, sp, r0, lsl #14
        _SetISTR((u16)CLR_WKUP);
     fcc:	0b3a0803 	bleq	e82fe0 <_etext+0xe7b9cc>
        usbResume(RESUME_EXTERNAL);
     fd0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
     fd4:	00000b38 	andeq	r0, r0, r8, lsr fp
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd8:	49010108 	stmdbmi	r1, {r3, r8}
     fdc:	00130113 	andseq	r0, r3, r3, lsl r1

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	00210900 	eoreq	r0, r1, r0, lsl #18
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	0b2f1349 	bleq	bc5d10 <_etext+0xbbe6fc>
     fe8:	2e0a0000 	cdpcs	0, 0, cr0, cr10, cr0, {0}
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fec:	3a0e0301 	bcc	381bf8 <_etext+0x37a5e4>
     ff0:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
        _SetISTR((u16)CLR_SOF);
     ff4:	010b2019 	tsteq	fp, r9, lsl r0
     ff8:	0b000013 	bleq	104c <main+0x18>
        bIntPackSOF++;
     ffc:	08030005 	stmdaeq	r3, {r0, r2}
    1000:	0b3b0b3a 	bleq	ec3cf0 <_etext+0xebc6dc>
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	00001349 	andeq	r1, r0, r9, asr #6
    1008:	0b000f0c 	bleq	4c40 <sha256_process+0x1b60>
        _SetISTR((u16)CLR_ESOF);
    100c:	0013490b 	andseq	r4, r3, fp, lsl #18
    1010:	00260d00 	eoreq	r0, r6, r0, lsl #26
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    }
#endif

}
    1014:	00001349 	andeq	r1, r0, r9, asr #6
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	3f012e0e 	svccc	0x00012e0e
    101c:	3a0e0319 	bcc	381c88 <_etext+0x37a674>
    1020:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    1024:	12011119 	andne	r1, r1, #1073741830	; 0x40000006
    1028:	97184006 	ldrls	r4, [r8, -r6]
    102c:	13011942 	movwne	r1, #6466	; 0x1942
    1030:	050f0000 	streq	r0, [pc, #-0]	; 1038 <main+0x4>
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
    1034:	3a080300 	bcc	201c3c <_etext+0x1fa628>
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    1038:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    setupCLK();
    103c:	00170213 	andseq	r0, r7, r3, lsl r2
    setupLEDAndButton();
    1040:	011d1000 	tsteq	sp, r0
    setupUSB();
    1044:	01111331 	tsteq	r1, r1, lsr r3
    setupFLASH();
    1048:	0b580612 	bleq	1602898 <_etext+0x15fb284>
    uartInit();
    104c:	13010b59 	movwne	r0, #7001	; 0x1b59
    usbReset();
    1050:	05110000 	ldreq	r0, [r1, #-0]
	uart_printf("\nBootloader init...\n");
    1054:	02133100 	andseq	r3, r3, #0, 2
    1058:	12000017 	andne	r0, r0, #23

    if (readPin(GPIOB, 15) == 0x0)
    105c:	1331011d 	teqne	r1, #1073741831	; 0x40000007
    1060:	17550152 			; <UNDEFINED> instruction: 0x17550152
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1064:	0b590b58 	bleq	1643dcc <_etext+0x163c7b8>
    1068:	00001301 	andeq	r1, r0, r1, lsl #6
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    106c:	31000513 	tstcc	r0, r3, lsl r5
    1070:	14000013 	strne	r0, [r0], #-19
    1074:	01018289 	smlabbeq	r1, r9, r2, r8
    
    debug_print("image check ret: %X\n", ret);
    1078:	13310111 	teqne	r1, #1073741828	; 0x40000004
    107c:	00001301 	andeq	r1, r0, r1, lsl #6
	switch (ret)
    1080:	01828a15 	orreq	r8, r2, r5, lsl sl
    1084:	91180200 	tstls	r8, r0, lsl #4
    1088:	00001842 	andeq	r1, r0, r2, asr #16

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
	bool no_user_jump = FALSE;
    108c:	01828916 	orreq	r8, r2, r6, lsl r9
    1090:	95011101 	strls	r1, [r1, #-257]	; 0x101
    1094:	13311942 	teqne	r1, #1081344	; 0x108000
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1098:	34170000 	ldrcc	r0, [r7], #-0
			no_user_jump = FALSE;
    109c:	3a080300 	bcc	201ca4 <_etext+0x1fa690>
			break;

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    10a0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    10a4:	00180213 	andseq	r0, r8, r3, lsl r2
			no_user_jump = TRUE;
			break;

		case kImageImageHashCalcFailed:
			uart_printf("Hash calculation failed... waiting in DFU\n");
    10a8:	82891800 	addhi	r1, r9, #0, 16
    10ac:	01110101 	tsteq	r1, r1, lsl #2
			break;
			
		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10b0:	00001331 	andeq	r1, r0, r1, lsr r3
    10b4:	03003419 	movweq	r3, #1049	; 0x419
    10b8:	3b0b3a0e 	blcc	2cf8f8 <_etext+0x2c82e4>
    10bc:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    10c0:	1a000017 	bne	1124 <main+0xf0>

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10c4:	13310005 	teqne	r1, #5
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10c8:	00001802 	andeq	r1, r0, r2, lsl #16
    10cc:	3f012e1b 	svccc	0x00012e1b
    10d0:	3a0e0319 	bcc	381d3c <_etext+0x37a728>
    10d4:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    10d8:	11134919 	tstne	r3, r9, lsl r9

		if (dfuUploadStarted()) 
    10dc:	40061201 	andmi	r1, r6, r1, lsl #4
		{
			uart_printf("DFU finished upload\n");
    10e0:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
    10e4:	00001301 	andeq	r1, r0, r1, lsl #6
			dfuFinishUpload(); // systemHardReset from DFU once done
    10e8:	0300051c 	movweq	r0, #1308	; 0x51c
    10ec:	3b0b3a0e 	blcc	2cf92c <_etext+0x2c8318>
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10f0:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10f4:	1d000017 	stcne	0, cr0, [r0, #-92]	; 0xffffffa4
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10f8:	08030034 	stmdaeq	r3, {r2, r4, r5}
    10fc:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
	}
	
	return 0;// Added to please the compiler
    1100:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    1104:	2e1e0000 	cdpcs	0, 1, cr0, cr14, cr0, {0}
    1108:	03193f01 	tsteq	r9, #1, 30
    110c:	3b0b3a0e 	blcc	2cf94c <_etext+0x2c8338>
    1110:	11192705 	tstne	r9, r5, lsl #14
    1114:	40061201 	andmi	r1, r6, r1, lsl #4
    1118:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
    111c:	00001301 	andeq	r1, r0, r1, lsl #6
    1120:	0300051f 	movweq	r0, #1311	; 0x51f
    1124:	3b0b3a0e 	blcc	2cf964 <_etext+0x2c8350>
    1128:	02134905 	andseq	r4, r3, #81920	; 0x14000
    112c:	20000017 	andcs	r0, r0, r7, lsl r0
    1130:	08030005 	stmdaeq	r3, {r0, r2}
    1134:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1138:	17021349 	strne	r1, [r2, -r9, asr #6]
    113c:	34210000 	strtcc	r0, [r1], #-0
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    1140:	3a080300 	bcc	201d48 <_etext+0x1fa734>
    1144:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1148:	00170213 	andseq	r0, r7, r3, lsl r2
    114c:	011d2200 	tsteq	sp, r0, lsl #4
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    1150:	01111331 	tsteq	r1, r1, lsr r3
    1154:	0b580612 	bleq	16029a4 <_etext+0x15fb390>
        return TRUE;
    } else {
        return FALSE;
    }
}
    1158:	13010559 	movwne	r0, #5465	; 0x1559
    115c:	0b230000 	bleq	8c1164 <_etext+0x8b9b50>

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	01175501 	tsteq	r7, r1, lsl #10
    1164:	24000013 	strcs	r0, [r0], #-19
    1168:	1331011d 	teqne	r1, #1073741831	; 0x40000007
    gpio_write_bit( bank,pin,1-onState);
    116c:	06120111 			; <UNDEFINED> instruction: 0x06120111
    1170:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xb58
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1174:	34250000 	strtcc	r0, [r5], #-0
    gpio_write_bit( bank,pin,1-onState);
    1178:	3a0e0300 	bcc	381d80 <_etext+0x37a76c>

    u32 c;
    while (count-- > 0) 
    117c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	{
        for (c = rate; c > 0; c--)
    1180:	00180213 	andseq	r0, r8, r3, lsl r2
    1184:	00342600 	eorseq	r2, r4, r0, lsl #12
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1188:	0b3a0e03 	bleq	e8499c <_etext+0xe7d388>
    118c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1190:	193c193f 	ldmdbne	ip!, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
		
        for (c = rate; c > 0; c--)
    1194:	34270000 	strtcc	r0, [r7], #-0
    1198:	3a0e0300 	bcc	381da0 <_etext+0x37a78c>
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    119c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    11a0:	02193f13 	andseq	r3, r9, #19, 30	; 0x4c
    11a4:	28000018 	stmdacs	r0, {r3, r4}
    11a8:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    11ac:	0b3a0e03 	bleq	e849c0 <_etext+0xe7d3ac>

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    11b0:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    11b4:	1301193c 	movwne	r1, #6460	; 0x193c
  USARTx->DR = ch;  
    11b8:	05290000 	streq	r0, [r9, #-0]!
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11bc:	00134900 	andseq	r4, r3, r0, lsl #18
  while(*str != 0)
    11c0:	012e2a00 	teqeq	lr, r0, lsl #20
    11c4:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
  {
    UU_PutChar(USARTx, *str);
    11c8:	0b3b0b3a 	bleq	ec3eb8 <_etext+0xebc8a4>
    11cc:	13491927 	movtne	r1, #39207	; 0x9927
    str++;
  }
}

void vprint(const char *fmt, va_list argp)
{
    11d0:	1301193c 	movwne	r1, #6460	; 0x193c
    11d4:	2e2b0000 	cdpcs	0, 2, cr0, cr11, cr0, {0}
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11d8:	03193f01 	tsteq	r9, #1, 30
    11dc:	4919270e 	ldmdbmi	r9, {r1, r2, r3, r8, r9, sl, sp}
    11e0:	3c193413 	cfldrscc	mvf3, [r9], {19}
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11e4:	00130119 	andseq	r0, r3, r9, lsl r1
    11e8:	00262c00 	eoreq	r2, r6, r0, lsl #24

    }
}
    11ec:	01000000 	mrseq	r0, (UNDEF: 0)
    11f0:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    11f4:	0e030b13 	vmoveq.32	d3[0], r0

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11f8:	17550e1b 	smmlane	r5, fp, lr, r0
    11fc:	17100111 			; <UNDEFINED> instruction: 0x17100111
    1200:	24020000 	strcs	r0, [r2], #-0
    va_list argp;
    va_start(argp, fmt);
    vprint(fmt, argp);
    1204:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    va_end(argp);
}
    1208:	000e030b 	andeq	r0, lr, fp, lsl #6
    120c:	00160300 	andseq	r0, r6, r0, lsl #6
    1210:	0b3a0e03 	bleq	e84a24 <_etext+0xe7d410>

void hexdump(unsigned char *data, size_t size)
{
    1214:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1218:	24040000 	strcs	r0, [r4], #-0
    int i;
    char cs[17];
    memset(cs, 0, 17);
    121c:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1220:	0008030b 	andeq	r0, r8, fp, lsl #6
    1224:	000f0500 	andeq	r0, pc, r0, lsl #10

    for(i = 0; i < size; i++)
    1228:	00000b0b 	andeq	r0, r0, fp, lsl #22
    122c:	03011306 	movweq	r1, #4870	; 0x1306
    {
        if(i != 0 && i % 0x10 == 0)
    1230:	3a0b0b0e 	bcc	2c3e70 <_etext+0x2bc85c>
        {
            debug_print(" |%s|\n", cs);
    1234:	010b3b0b 	tsteq	fp, fp, lsl #22
    1238:	07000013 	smladeq	r0, r3, r0, r0
            memset(cs, 0, 17);
    123c:	0803000d 	stmdaeq	r3, {r0, r2, r3}
    1240:	0b3b0b3a 	bleq	ec3f30 <_etext+0xebc91c>
    1244:	0b381349 	bleq	e05f70 <_etext+0xdfe95c>
        }
        else if(i != 0 && i % 0x8 == 0)
    1248:	01080000 	mrseq	r0, (UNDEF: 8)
    124c:	01134901 	tsteq	r3, r1, lsl #18
        {
            debug_print(" ",0);
    1250:	09000013 	stmdbeq	r0, {r0, r1, r4}
        }
        debug_print("%02X ", data[i]);
    1254:	13490021 	movtne	r0, #36897	; 0x9021
    1258:	00000b2f 	andeq	r0, r0, pc, lsr #22
        cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
    125c:	03012e0a 	movweq	r2, #7690	; 0x1e0a
    1260:	3b0b3a0e 	blcc	2cfaa0 <_etext+0x2c848c>
    1264:	2019270b 	andscs	r2, r9, fp, lsl #14
    1268:	0013010b 	andseq	r0, r3, fp, lsl #2
    126c:	00050b00 	andeq	r0, r5, r0, lsl #22
    1270:	0b3a0803 	bleq	e83284 <_etext+0xe7bc70>
    }

    i = i % 0x10;
    if(i != 0)
    1274:	13490b3b 	movtne	r0, #39739	; 0x9b3b
        while(i++ < 0x10)
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
    1278:	0f0c0000 	svceq	0x000c0000
    127c:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
}
    1280:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
    }

    i = i % 0x10;
    if(i != 0)
    {
        if(i <= 0x8)
    1284:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
        {
            debug_print(" ",0);
    1288:	0b3b0b3a 	bleq	ec3f78 <_etext+0xebc964>
    128c:	00001349 	andeq	r1, r0, r9, asr #6
        }
        while(i++ < 0x10)
    1290:	0300340e 	movweq	r3, #1038	; 0x40e
        {
            debug_print("   ",0);
    1294:	3b0b3a08 	blcc	2cfabc <_etext+0x2c84a8>
    1298:	0013490b 	andseq	r4, r3, fp, lsl #18
    129c:	010b0f00 	tsteq	fp, r0, lsl #30
    12a0:	26100000 	ldrcs	r0, [r0], -r0
    12a4:	00134900 	andseq	r4, r3, r0, lsl #18
    12a8:	012e1100 	teqeq	lr, r0, lsl #2
    12ac:	0b3a0803 	bleq	e832c0 <_etext+0xe7bcac>
    }
    debug_print(" |%s|\n", cs);
}

void print_hash(unsigned char hash[])
{
    12b0:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
   int idx;
   for (idx=0; idx < 32; idx++)
    12b4:	13010b20 	movwne	r0, #6944	; 0x1b20
      debug_print("%02x",hash[idx]);
    12b8:	2e120000 	cdpcs	0, 1, cr0, cr2, cr0, {0}
    12bc:	03193f01 	tsteq	r9, #1, 30
}

void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
    12c0:	3b0b3a0e 	blcc	2cfb00 <_etext+0x2c84ec>
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12c4:	1119270b 	tstne	r9, fp, lsl #14
}
    12c8:	40061201 	andmi	r1, r6, r1, lsl #4
void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12cc:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
    12d0:	00001301 	andeq	r1, r0, r1, lsl #6
    12d4:	03000513 	movweq	r0, #1299	; 0x513
}

#endif
void uartInit(void) {
    12d8:	3b0b3a08 	blcc	2cfb00 <_etext+0x2c84ec>
    12dc:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    12e0:	14000017 	strne	r0, [r0], #-23
    12e4:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    12e8:	0b3b0b3a 	bleq	ec3fd8 <_etext+0xebc9c4>
    12ec:	17021349 	strne	r1, [r2, -r9, asr #6]
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    12f0:	34150000 	ldrcc	r0, [r5], #-0
    12f4:	3a0e0300 	bcc	381efc <_etext+0x37a8e8>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    12f8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    12fc:	00180213 	andseq	r0, r8, r3, lsl r2
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1300:	011d1600 	tsteq	sp, r0, lsl #12
    1304:	01521331 	cmpeq	r2, r1, lsr r3
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1308:	0b581755 	bleq	1607064 <_etext+0x15ffa50>
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    130c:	13010b59 	movwne	r0, #7001	; 0x1b59
    1310:	05170000 	ldreq	r0, [r7, #-0]
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1314:	02133100 	andseq	r3, r3, #0, 2
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1318:	18000017 	stmdane	r0, {r0, r1, r2, r4}
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    131c:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1320:	34190000 	ldrcc	r0, [r9], #-0
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1324:	02133100 	andseq	r3, r3, #0, 2
    1328:	1a000018 	bne	1390 <systemReset+0x30>
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    132c:	01018289 	smlabbeq	r1, r9, r2, r8
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    1330:	13310111 	teqne	r1, #1073741828	; 0x40000004
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1334:	00001301 	andeq	r1, r0, r1, lsl #6
    USART_InitStructure.USART_Parity = USART_Parity_No;
    1338:	01828a1b 	orreq	r8, r2, fp, lsl sl
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    133c:	91180200 	tstls	r8, r0, lsl #4
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1340:	00001842 	andeq	r1, r0, r2, asr #16
    1344:	0182891c 	orreq	r8, r2, ip, lsl r9
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    1348:	31011101 	tstcc	r1, r1, lsl #2
        
    USART_Init(USART1, &USART_InitStructure);
    134c:	1d000013 	stcne	0, cr0, [r0, #-76]	; 0xffffffb4
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    1350:	1331011d 	teqne	r1, #1073741831	; 0x40000007
    1354:	17550152 			; <UNDEFINED> instruction: 0x17550152
}
    1358:	0b590b58 	bleq	16440c0 <_etext+0x163caac>
    135c:	1d1e0000 	ldcne	0, cr0, [lr, #-0]

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    1360:	11133101 	tstne	r3, r1, lsl #2
    1364:	58061201 	stmdapl	r6, {r0, r9, ip}
    1368:	010b590b 	tsteq	fp, fp, lsl #18
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    136c:	1f000013 	svcne	0x00000013
    1370:	0111010b 	tsteq	r1, fp, lsl #2
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    1374:	00000612 	andeq	r0, r0, r2, lsl r6
    1378:	03003420 	movweq	r3, #1056	; 0x420
    137c:	3b0b3a0e 	blcc	2cfbbc <_etext+0x2c85a8>
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    1380:	0013490b 	andseq	r4, r3, fp, lsl #18
    1384:	012e2100 	teqeq	lr, r0, lsl #2
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    1388:	0b3a0803 	bleq	e8339c <_etext+0xe7bd88>
    138c:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    1390:	0b201349 	bleq	8060bc <_etext+0x7feaa8>
    1394:	00001301 	andeq	r1, r0, r1, lsl #6
    1398:	3f012e22 	svccc	0x00012e22
    139c:	3a0e0319 	bcc	382008 <_etext+0x37a9f4>
    13a0:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    13a4:	11134919 	tstne	r3, r9, lsl r9
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    13a8:	40061201 	andmi	r1, r6, r1, lsl #4
    13ac:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
    13b0:	00001301 	andeq	r1, r0, r1, lsl #6
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    13b4:	03003423 	movweq	r3, #1059	; 0x423
    13b8:	3b0b3a08 	blcc	2cfbe0 <_etext+0x2c85cc>

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    13bc:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    13c0:	24000018 	strcs	r0, [r0], #-24
    13c4:	08030034 	stmdaeq	r3, {r2, r4, r5}
    13c8:	0b3b0b3a 	bleq	ec40b8 <_etext+0xebcaa4>
    13cc:	17021349 	strne	r1, [r2, -r9, asr #6]
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    13d0:	05250000 	streq	r0, [r5, #-0]!
    13d4:	1c133100 	ldfnes	f3, [r3], {-0}

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    13d8:	2600000b 	strcs	r0, [r0], -fp
    13dc:	13310005 	teqne	r1, #5
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    13e0:	00001802 	andeq	r1, r0, r2, lsl #16
    13e4:	55010b27 	strpl	r0, [r1, #-2855]	; 0xb27
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    13e8:	00130117 	andseq	r0, r3, r7, lsl r1
    13ec:	00342800 	eorseq	r2, r4, r0, lsl #16
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    13f0:	17021331 	smladxne	r2, r1, r3, r1
    13f4:	34290000 	strtcc	r0, [r9], #-0
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    13f8:	3a0e0300 	bcc	382000 <_etext+0x37a9ec>
    13fc:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1400:	3c193f13 	ldccc	15, cr3, [r9], {19}
    1404:	2a000019 	bcs	1470 <nvicInit+0x20>

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    1408:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    140c:	0b3a0e03 	bleq	e84c20 <_etext+0xe7d60c>
    1410:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    1414:	1301193c 	movwne	r1, #6460	; 0x193c
    1418:	052b0000 	streq	r0, [fp, #-0]!
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    141c:	00134900 	andseq	r4, r3, r0, lsl #18
    1420:	012e2c00 	teqeq	lr, r0, lsl #24
        u32 rwmVal = pRCC->CR;
    1424:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
        rwmVal |= 0x01;
    1428:	13491927 	movtne	r1, #39207	; 0x9927
        pRCC->CR = rwmVal;
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    142c:	193c1934 	ldmdbne	ip!, {r2, r4, r5, r8, fp, ip}
    1430:	00001301 	andeq	r1, r0, r1, lsl #6
}   
    1434:	0000262d 	andeq	r2, r0, sp, lsr #12
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    1438:	012e2e00 	teqeq	lr, r0, lsl #28
void setMspAndJump(u32 usrAddr) {
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    143c:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1440:	0b3b0b3a 	bleq	ec4130 <_etext+0xebcb1c>

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1444:	13491927 	movtne	r1, #39207	; 0x9927
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    1448:	1301193c 	movwne	r1, #6460	; 0x193c
    144c:	2e2f0000 	cdpcs	0, 2, cr0, cr15, cr0, {0}
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    1450:	03193f01 	tsteq	r9, #1, 30
    1454:	3b0b3a0e 	blcc	2cfc94 <_etext+0x2c8680>
    1458:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    145c:	00193c13 	andseq	r3, r9, r3, lsl ip
    tmppre = (0x4 - tmppriority);
    1460:	11010000 	mrsne	r0, (UNDEF: 1)
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    1464:	130e2501 	movwne	r2, #58625	; 0xe501


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    1468:	1b0e030b 	blne	38209c <_etext+0x37aa88>

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    146c:	1117550e 	tstne	r7, lr, lsl #10
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    1470:	00171001 	andseq	r1, r7, r1

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1474:	00240200 	eoreq	r0, r4, r0, lsl #4
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    1478:	0b3e0b0b 	bleq	f840ac <_etext+0xf7ca98>
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    147c:	00000e03 	andeq	r0, r0, r3, lsl #28

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1480:	03001603 	movweq	r1, #1539	; 0x603
    1484:	3b0b3a0e 	blcc	2cfcc4 <_etext+0x2c86b0>
    1488:	0013490b 	andseq	r4, r3, fp, lsl #18
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    148c:	00240400 	eoreq	r0, r4, r0, lsl #8
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    1490:	0b3e0b0b 	bleq	f840c4 <_etext+0xf7cab0>
    tmppriority &= tmpmask;
    1494:	00000803 	andeq	r0, r0, r3, lsl #16
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    1498:	0b000f05 	bleq	50b4 <sha256_update+0x70>

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    149c:	0600000b 	streq	r0, [r0], -fp
    14a0:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    14a4:	0b3a0e03 	bleq	e84cb8 <_etext+0xe7d6a4>
    14a8:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    14ac:	13010b20 	movwne	r0, #6944	; 0x1b20
    14b0:	05070000 	streq	r0, [r7, #-0]
    14b4:	3a080300 	bcc	2020bc <_etext+0x1faaa8>
    14b8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    14bc:	08000013 	stmdaeq	r0, {r0, r1, r4}
    14c0:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    14c4:	0b3b0b3a 	bleq	ec41b4 <_etext+0xebcba0>
    rNVIC->ICER[1] = 0xFFFFFFFF;
    14c8:	00001349 	andeq	r1, r0, r9, asr #6
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    14cc:	03003409 	movweq	r3, #1033	; 0x409
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    14d0:	3b0b3a0e 	blcc	2cfd10 <_etext+0x2c86fc>

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    14d4:	0013490b 	andseq	r4, r3, fp, lsl #18
    14d8:	00340a00 	eorseq	r0, r4, r0, lsl #20
    14dc:	0b3a0803 	bleq	e834f0 <_etext+0xe7bedc>

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    14e0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    14e4:	0f0b0000 	svceq	0x000b0000
    nvicDisableInterrupts();
    14e8:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    14ec:	0c000013 	stceq	0, cr0, [r0], {19}
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    14f0:	13490026 	movtne	r0, #36902	; 0x9026
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14f4:	2e0d0000 	cdpcs	0, 0, cr0, cr13, cr0, {0}
}
    14f8:	3a0e0301 	bcc	382104 <_etext+0x37aaf0>
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14fc:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1500:	010b2019 	tsteq	fp, r9, lsl r0
    1504:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    1508:	1331012e 	teqne	r1, #-2147483637	; 0x8000000b
    150c:	06120111 			; <UNDEFINED> instruction: 0x06120111
    1510:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1514:	00130119 	andseq	r0, r3, r9, lsl r1
    1518:	00050f00 	andeq	r0, r5, r0, lsl #30
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    151c:	17021331 	smladxne	r2, r1, r3, r1

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1520:	34100000 	ldrcc	r0, [r0], #-0
    1524:	02133100 	andseq	r3, r3, #0, 2
    1528:	11000017 	tstne	r0, r7, lsl r0
    SET_REG(FLASH_AR, pageAddr);
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    152c:	01018289 	smlabbeq	r1, r9, r2, r8
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1530:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
    1534:	00133119 	andseq	r3, r3, r9, lsl r1

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    1538:	828a1200 	addhi	r1, sl, #0, 4

    return TRUE;
}
    153c:	18020001 	stmdane	r2, {r0}
    1540:	00184291 	mulseq	r8, r1, r2
    1544:	012e1300 	teqeq	lr, r0, lsl #6
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    1548:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    154c:	0b3b0b3a 	bleq	ec423c <_etext+0xebcc28>
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    1550:	01111927 	tsteq	r1, r7, lsr #18

    u32 rwmVal = GET_REG(FLASH_CR);
    SET_REG(FLASH_CR, FLASH_CR_PG);
    1554:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    1558:	01194297 			; <UNDEFINED> instruction: 0x01194297

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    155c:	14000013 	strne	r0, [r0], #-19
    1560:	08030005 	stmdaeq	r3, {r0, r2}
    *(flashAddr + 0x01) = (vu16)hhWord;
    1564:	0b3b0b3a 	bleq	ec4254 <_etext+0xebcc40>
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1568:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    156c:	34150000 	ldrcc	r0, [r5], #-0
    *(flashAddr) = (vu16)lhWord;
    1570:	3a0e0300 	bcc	382178 <_etext+0x37ab64>
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1574:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1578:	00180213 	andseq	r0, r8, r3, lsl r2

    rwmVal &= 0xFFFFFFFE;
    157c:	00341600 	eorseq	r1, r4, r0, lsl #12
    SET_REG(FLASH_CR, rwmVal);

    /* verify the write */
    if (*(vu32 *)addr != word) {
    1580:	0b3a0803 	bleq	e83594 <_etext+0xe7bf80>
        return FALSE;
    }

    return TRUE;
}
    1584:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1588:	00001702 	andeq	r1, r0, r2, lsl #14
    158c:	31011d17 	tstcc	r1, r7, lsl sp
    1590:	55015213 	strpl	r5, [r1, #-531]	; 0x213

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    1594:	590b5817 	stmdbpl	fp, {r0, r1, r2, r4, fp, ip, lr}
    1598:	1800000b 	stmdane	r0, {r0, r1, r3}
    159c:	13310005 	teqne	r1, #5
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    15a0:	00001802 	andeq	r1, r0, r2, lsl #16
    15a4:	55010b19 	strpl	r0, [r1, #-2841]	; 0xb19
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    15a8:	1a000017 	bne	160c <dfuInit+0x18>
    15ac:	13310034 	teqne	r1, #52	; 0x34
    15b0:	00001802 	andeq	r1, r0, r2, lsl #16
    15b4:	4901011b 	stmdbmi	r1, {r0, r1, r3, r4, r8}

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    15b8:	00130113 	andseq	r0, r3, r3, lsl r1
	{
		pin-=8;
    15bc:	00211c00 	eoreq	r1, r1, r0, lsl #24
	}
	mask = 0x0F << (pin<<2);
    15c0:	0b2f1349 	bleq	bc62ec <_etext+0xbbecd8>
    15c4:	2e1d0000 	cdpcs	0, 1, cr0, cr13, cr0, {0}
	return ~mask;
}	
    15c8:	03193f01 	tsteq	r9, #1, 30

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    15cc:	3b0b3a0e 	blcc	2cfe0c <_etext+0x2c87f8>
    15d0:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
}
    15d4:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    15d8:	97184006 	ldrls	r4, [r8, -r6]

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    15dc:	13011942 	movwne	r1, #6466	; 0x1942
	{
		return 0x800;
    15e0:	051e0000 	ldreq	r0, [lr, #-0]
	}
	else
	{
		return 0x400;
	}
}
    15e4:	3a080300 	bcc	2021ec <_etext+0x1fabd8>
    15e8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    15ec:	00170213 	andseq	r0, r7, r3, lsl r2
    15f0:	010b1f00 	tsteq	fp, r0, lsl #30

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15f4:	0b200000 	bleq	8015fc <_etext+0x7f9fe8>
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    15f8:	12011101 	andne	r1, r1, #1073741824	; 0x40000000

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15fc:	21000006 	tstcs	r0, r6
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1600:	08030034 	stmdaeq	r3, {r2, r4, r5}
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    1604:	0b3b0b3a 	bleq	ec42f4 <_etext+0xebcce0>
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    1608:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    160c:	1d220000 	stcne	0, cr0, [r2, #-0]
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1610:	52133101 	andspl	r3, r3, #1073741824	; 0x40000000
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1614:	58175501 	ldmdapl	r7, {r0, r8, sl, ip, lr}
    userAppEnd = RAM_END;
    1618:	010b590b 	tsteq	fp, fp, lsl #18
    161c:	23000013 	movwcs	r0, #19
    userUploadType=DFU_UPLOAD_NONE;
    1620:	1331011d 	teqne	r1, #1073741831	; 0x40000007
    1624:	06120111 			; <UNDEFINED> instruction: 0x06120111
    code_copy_lock = WAIT;
    1628:	0b590b58 	bleq	1644390 <_etext+0x163cd7c>
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    162c:	05240000 	streq	r0, [r4, #-0]!
    1630:	00133100 	andseq	r3, r3, r0, lsl #2
    1634:	011d2500 	tsteq	sp, r0, lsl #10
    memset(input, 0xFF, sizeof(input));
    1638:	01111331 	tsteq	r1, r1, lsr r3
    163c:	0b580612 	bleq	1602e8c <_etext+0x15fb878>

    sha256_starts(&ctx);
}
    1640:	13010b59 	movwne	r0, #7001	; 0x1b59
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1644:	1d260000 	stcne	0, cr0, [r6, #-0]
    1648:	11133101 	tstne	r3, r1, lsl #2
    164c:	58061201 	stmdapl	r6, {r0, r9, ip}
    1650:	0105590b 	tsteq	r5, fp, lsl #18
    1654:	27000013 	smladcs	r0, r3, r0, r0
    1658:	1331011d 	teqne	r1, #1073741831	; 0x40000007
    165c:	06120111 			; <UNDEFINED> instruction: 0x06120111
    1660:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xb58
    1664:	2e280000 	cdpcs	0, 2, cr0, cr8, cr0, {0}
    1668:	03193f01 	tsteq	r9, #1, 30
    166c:	3b0b3a0e 	blcc	2cfeac <_etext+0x2c8898>
    1670:	11192705 	tstne	r9, r5, lsl #14
    1674:	40061201 	andmi	r1, r6, r1, lsl #4
    1678:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    167c:	00001301 	andeq	r1, r0, r1, lsl #6
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    1680:	03000529 	movweq	r0, #1321	; 0x529
    1684:	3b0b3a08 	blcc	2cfeac <_etext+0x2c8898>

    if (startState == appDETACH) {
    1688:	02134905 	andseq	r4, r3, #81920	; 0x14000
    168c:	2a000017 	bcs	16f0 <dfuCopyDNLOAD>
        dfuAppStatus.bState = dfuIDLE;
    1690:	08030034 	stmdaeq	r3, {r2, r4, r5}
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
    1694:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1698:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    169c:	892b0000 	stmdbhi	fp!, {}	; <UNPREDICTABLE>
    } else if (startState == appIDLE || startState == dfuIDLE) {
    16a0:	11010182 	smlabbne	r1, r2, r1, r0
    16a4:	00133101 	andseq	r3, r3, r1, lsl #2
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    16a8:	012e2c00 	teqeq	lr, r0, lsl #24
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    16ac:	0b3a0e03 	bleq	e84ec0 <_etext+0xe7d8ac>
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    16b0:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
    16b4:	13010b20 	movwne	r0, #6944	; 0x1b20
    16b8:	052d0000 	streq	r0, [sp, #-0]!
    16bc:	3a080300 	bcc	2022c4 <_etext+0x1facb0>

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    16c0:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
        pInformation->Ctrl_Info.Usb_wLength = 1;
    16c4:	2e000013 	mcrcs	0, 0, r0, cr0, cr3, {0}
    16c8:	08030034 	stmdaeq	r3, {r2, r4, r5}
        return NULL;
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    16cc:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    }
}
    16d0:	00001349 	andeq	r1, r0, r9, asr #6
    16d4:	31011d2f 	tstcc	r1, pc, lsr #26

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    16d8:	55015213 	strpl	r5, [r1, #-531]	; 0x213
        pInformation->Ctrl_Info.Usb_wLength = 6;
    16dc:	590b5817 	stmdbpl	fp, {r0, r1, r2, r4, fp, ip, lr}
    16e0:	00130105 	andseq	r0, r3, r5, lsl #2
        return NULL;
    } else {
        return (u8*)(&dfuAppStatus);
    16e4:	00053000 	andeq	r3, r5, r0
    }
}
    16e8:	0b1c1331 	bleq	7063b4 <_etext+0x6feda0>
    16ec:	34310000 	ldrtcc	r0, [r1], #-0


u8 *dfuCopyDNLOAD(u16 length) {
    16f0:	00133100 	andseq	r3, r3, r0, lsl #2
    if (length == 0) {
    16f4:	00343200 	eorseq	r3, r4, r0, lsl #4
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    16f8:	0b3a0e03 	bleq	e84f0c <_etext+0xe7d8f8>
    16fc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
        thisBlockLen = pInformation->USBwLengths.w;
    1700:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
        return NULL;
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1704:	2e330000 	cdpcs	0, 3, cr0, cr3, cr0, {0}
    1708:	03193f01 	tsteq	r9, #1, 30
    }
}
    170c:	4919270e 	ldmdbmi	r9, {r1, r2, r3, r8, r9, sl, sp}
    1710:	3c193413 	cfldrscc	mvf3, [r9], {19}
    1714:	34000019 	strcc	r0, [r0], #-25

u8 *dfuCopyUPLOAD(u16 length) {
    1718:	13490005 	movtne	r0, #36869	; 0x9005
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    171c:	01000000 	mrseq	r0, (UNDEF: 0)
    1720:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
    1724:	0e030b13 	vmoveq.32	d3[0], r0
        return NULL;
    1728:	17550e1b 	smmlane	r5, fp, lr, r0
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    172c:	17100111 			; <UNDEFINED> instruction: 0x17100111
    1730:	24020000 	strcs	r0, [r2], #-0
    1734:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1738:	000e030b 	andeq	r0, lr, fp, lsl #6
    }
}
    173c:	00160300 	andseq	r0, r6, r0, lsl #6
    1740:	0b3a0e03 	bleq	e84f54 <_etext+0xe7d940>
    1744:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1748:	24040000 	strcs	r0, [r4], #-0

void dfuCopyBufferToExec() {
    174c:	3e0b0b00 	vmlacc.f64	d0, d11, d0
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    1750:	0008030b 	andeq	r0, r8, fp, lsl #6
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    1754:	000f0500 	andeq	r0, pc, r0, lsl #10
    1758:	00000b0b 	andeq	r0, r0, fp, lsl #22
    175c:	3f012e06 	svccc	0x00012e06
    1760:	3a0e0319 	bcc	3823cc <_etext+0x37adb8>
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    1764:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
	}

    flashErasePage((u32)(userSpace));
    1768:	010b2019 	tsteq	fp, r9, lsl r0

    for (i = 0; i < thisBlockLen; i = i + 4) {
    176c:	07000013 	smladeq	r0, r3, r0, r0
    1770:	08030005 	stmdaeq	r3, {r0, r2}
    1774:	0b3b0b3a 	bleq	ec4464 <_etext+0xebce50>
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    1778:	00001349 	andeq	r1, r0, r9, asr #6
    177c:	03000508 	movweq	r0, #1288	; 0x508
    1780:	3b0b3a0e 	blcc	2cffc0 <_etext+0x2c89ac>
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    1784:	0013490b 	andseq	r4, r3, fp, lsl #18
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    1788:	00340900 	eorseq	r0, r4, r0, lsl #18
    178c:	0b3a0e03 	bleq	e84fa0 <_etext+0xe7d98c>
    thisBlockLen = 0;
    1790:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1794:	340a0000 	strcc	r0, [sl], #-0
    1798:	3a080300 	bcc	2023a0 <_etext+0x1fad8c>
    179c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    17a0:	0b000013 	bleq	17f4 <dfuUpdateByRequest+0x4c>
    17a4:	0b0b000f 	bleq	2c17e8 <_etext+0x2ba1d4>
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    17a8:	00001349 	andeq	r1, r0, r9, asr #6
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    17ac:	4900260c 	stmdbmi	r0, {r2, r3, r9, sl, sp}
    17b0:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4

    u8 startState = dfuAppStatus.bState;
    17b4:	0e03012e 	adfeqsp	f0, f3, #0.5
    17b8:	0b3b0b3a 	bleq	ec44a8 <_etext+0xebce94>
    dfuAppStatus.bStatus = OK;
    17bc:	13491927 	movtne	r1, #39207	; 0x9927
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    17c0:	13010b20 	movwne	r0, #6944	; 0x1b20

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17c4:	2e0e0000 	cdpcs	0, 0, cr0, cr14, cr0, {0}
    17c8:	3a0e0301 	bcc	3823d4 <_etext+0x37adc0>
            if (pInformation->USBwLengths.w > 0) {
    17cc:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    17d0:	010b2019 	tsteq	fp, r9, lsl r0
                userFirmwareLen = 0;
    17d4:	0f000013 	svceq	0x00000013
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    17d8:	1331012e 	teqne	r1, #-2147483637	; 0x8000000b
    17dc:	06120111 			; <UNDEFINED> instruction: 0x06120111
    17e0:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
    17e4:	00130119 	andseq	r0, r3, r9, lsl r1
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    17e8:	00051000 	andeq	r1, r5, r0
						userAppAddr = USER_CODE_FLASH0X8002000;
    17ec:	17021331 	smladxne	r2, r1, r3, r1
    17f0:	34110000 	ldrcc	r0, [r1], #-0
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    17f4:	02133100 	andseq	r3, r3, #0, 2
    17f8:	12000017 	andne	r0, r0, #23
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    17fc:	01018289 	smlabbeq	r1, r9, r2, r8
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1800:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
						flashUnlock();
    1804:	00133119 	andseq	r3, r3, r9, lsl r1

						break;
    1808:	828a1300 	addhi	r1, sl, #0, 6

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    180c:	18020001 	stmdane	r2, {r0}
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1810:	00184291 	mulseq	r8, r1, r2
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1814:	01011400 	tsteq	r1, r0, lsl #8
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    1818:	13011349 	movwne	r1, #4937	; 0x1349
    181c:	21150000 	tstcs	r5, r0
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    1820:	2f134900 	svccs	0x00134900
    1824:	1600000b 	strne	r0, [r0], -fp
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1828:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    182c:	0b3a0e03 	bleq	e85040 <_etext+0xe7da2c>
    1830:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
			
            switch(pInformation->Current_AlternateSetting) {
    1834:	06120111 			; <UNDEFINED> instruction: 0x06120111
    1838:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    183c:	00130119 	andseq	r0, r3, r9, lsl r1
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1840:	00051700 	andeq	r1, r5, r0, lsl #14
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1844:	0b3a0803 	bleq	e83858 <_etext+0xe7c244>
					userAppEnd = getFlashEnd();
    1848:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    184c:	00001702 	andeq	r1, r0, r2, lsl #14

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    1850:	03000518 	movweq	r0, #1304	; 0x518
					dfuAppStatus.bStatus = errWRITE;
    1854:	3b0b3a0e 	blcc	2d0094 <_etext+0x2c8a80>
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    1858:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    185c:	19000017 	stmdbne	r0, {r0, r1, r2, r4}
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1860:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    1864:	0b3b0b3a 	bleq	ec4554 <_etext+0xebcf40>
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1868:	17021349 	strne	r1, [r2, -r9, asr #6]
    186c:	341a0000 	ldrcc	r0, [sl], #-0
    1870:	3a080300 	bcc	202478 <_etext+0x1fae64>

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    1874:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
                dfuCopyBufferToExec();
    1878:	00170213 	andseq	r0, r7, r3, lsl r2
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    187c:	011d1b00 	tsteq	sp, r0, lsl #22
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    1880:	01521331 	cmpeq	r2, r1, lsr r3
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    1884:	0b581755 	bleq	16075e0 <_etext+0x15fffcc>
    1888:	13010b59 	movwne	r0, #7001	; 0x1b59

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    188c:	0b1c0000 	bleq	701894 <_etext+0x6fa280>
    1890:	00175501 	andseq	r5, r7, r1, lsl #10
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    1894:	011d1d00 	tsteq	sp, r0, lsl #26
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    1898:	01111331 	tsteq	r1, r1, lsr r3
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    189c:	0b580612 	bleq	16030ec <_etext+0x15fbad8>
    18a0:	13010b59 	movwne	r0, #7001	; 0x1b59
    18a4:	051e0000 	ldreq	r0, [lr, #-0]
            if (pInformation->USBwLengths.w > 0) {
    18a8:	00133100 	andseq	r3, r3, r0, lsl #2
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    18ac:	010b1f00 	tsteq	fp, r0, lsl #30
                }*/
                ImageObjectHandle imageHandle;
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    18b0:	06120111 			; <UNDEFINED> instruction: 0x06120111
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    18b4:	0b200000 	bleq	8018bc <_etext+0x7fa2a8>
                }*/
                ImageObjectHandle imageHandle;
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    18b8:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
                }
                switch (ret)
    18bc:	00130106 	andseq	r0, r3, r6, lsl #2
    18c0:	011d2100 	tsteq	sp, r0, lsl #2
    18c4:	01521331 	cmpeq	r2, r1, lsr r3
                {
                    case kImageImageIsTrusted:
                        uart_printf("Uploaded signature verified!\n");
    18c8:	0b581755 	bleq	1607624 <_etext+0x1600010>
                        break;

                    case kImageImageMissingMagic:
                    case kImageImageRejectSignature:
                        uart_printf("Image unverified... wiped memory for clean reset.\n");
    18cc:	00000b59 	andeq	r0, r0, r9, asr fp
    18d0:	31003422 	tstcc	r0, r2, lsr #8
                        break;

                    default:
                        break;
                }
                flashLock();
    18d4:	00180213 	andseq	r0, r8, r3, lsl r2
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    18d8:	011d2300 	tsteq	sp, r0, lsl #6
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18dc:	01111331 	tsteq	r1, r1, lsr r3
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18e0:	0b580612 	bleq	1603130 <_etext+0x15fbb1c>
    18e4:	00000b59 	andeq	r0, r0, r9, asr fp
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuMANIFEST_SYNC) {
    18e8:	01828924 	orreq	r8, r2, r4, lsr #18
        /* device has received last block, waiting DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18ec:	31011101 	tstcc	r1, r1, lsl #2
    18f0:	25000013 	strcs	r0, [r0, #-19]
            dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    18f4:	08030034 	stmdaeq	r3, {r2, r4, r5}
            dfuAppStatus.bStatus = OK;
    18f8:	0b3b0b3a 	bleq	ec45e8 <_etext+0xebcfd4>
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18fc:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    1900:	05260000 	streq	r0, [r6, #-0]!
            dfuAppStatus.bState  = dfuMANIFEST_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuMANIFEST) {
    1904:	02133100 	andseq	r3, r3, #0, 2
        /* device is in manifestation phase */

        /* should never receive request while in manifest! */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
        dfuAppStatus.bStatus = OK;
    } else if (startState == dfuMANIFEST_WAIT_RESET) {
    1908:	27000018 	smladcs	r0, r8, r0, r0
        /* device has programmed new firmware but needs external
           usb reset or power on reset to run the new code */

        /* consider timing out and self-resetting */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    } else if (startState == dfuUPLOAD_IDLE) {
    190c:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
    1910:	0b3a0e03 	bleq	e85124 <_etext+0xe7db10>
    1914:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
            if (pInformation->USBwLengths.w > 0) {
    1918:	01111349 	tsteq	r1, r9, asr #6
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    191c:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    1920:	01194297 			; <UNDEFINED> instruction: 0x01194297
    1924:	28000013 	stmdacs	r0, {r0, r1, r4}
    1928:	08030005 	stmdaeq	r3, {r0, r2}
    192c:	0b3b0b3a 	bleq	ec461c <_etext+0xebd008>
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1930:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    1934:	34290000 	strtcc	r0, [r9], #-0
    1938:	3a0e0300 	bcc	382540 <_etext+0x37af2c>
    193c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1940:	00180213 	andseq	r0, r8, r3, lsl r2
    1944:	010b2a00 	tsteq	fp, r0, lsl #20
                    thisBlockLen = uploadBlockLen;
    1948:	13011755 	movwne	r1, #5973	; 0x1755
    194c:	892b0000 	stmdbhi	fp!, {}	; <UNPREDICTABLE>
                    dfuAppStatus.bState  = dfuUPLOAD_IDLE;
                } else {
                    /* if above comparison was just equal, thisBlockLen becomes zero
                    next time when USBWValue has been increased by one */
                    thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
    1950:	11010182 	smlabbne	r1, r2, r1, r0
    1954:	01133101 	tsteq	r3, r1, lsl #2
    1958:	2c000013 	stccs	0, cr0, [r0], {19}
    195c:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
                    
                    /* check for overflow due to USBwValue out of range */
                    if (thisBlockLen >= pInformation->USBwLengths.w) {
    1960:	0b3b0b3a 	bleq	ec4650 <_etext+0xebd03c>
    1964:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
                        thisBlockLen = 0;
    1968:	00001802 	andeq	r1, r0, r2, lsl #16
                    }
                    
                    dfuAppStatus.bState  = dfuIDLE;
                }
            } else {
                dfuAppStatus.bState  = dfuERROR;
    196c:	3f012e2d 	svccc	0x00012e2d
                dfuAppStatus.bStatus = errNOTDONE;
    1970:	270e0319 	smladcs	lr, r9, r3, r0
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    1974:	34134919 	ldrcc	r4, [r3], #-2329	; 0x919
            dfuAppStatus.bState  = dfuIDLE;
    1978:	00193c19 	andseq	r3, r9, r9, lsl ip
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    197c:	00052e00 	andeq	r2, r5, r0, lsl #28
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1980:	00001349 	andeq	r1, r0, r9, asr #6
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1984:	01110100 	tsteq	r1, r0, lsl #2
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuERROR)               {
    1988:	0b130e25 	bleq	4c5224 <_etext+0x4bdc10>
        /* status is in error, awaiting DFU_CLRSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    198c:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    1990:	01111755 	tsteq	r1, r5, asr r7
    1994:	00001710 	andeq	r1, r0, r0, lsl r7
            /* todo, add routine to wait for last block write to finish */
            dfuAppStatus.bState  = dfuERROR;
    1998:	0b002402 	bleq	a9a8 <_etext+0x3394>
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    199c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
            dfuAppStatus.bState  = dfuERROR;
        } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
    19a0:	0300000e 	movweq	r0, #14
            /* todo handle any cleanup we need here */
            dfuAppStatus.bState  = dfuIDLE;
    19a4:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
            dfuAppStatus.bStatus = OK;
    19a8:	0b3b0b3a 	bleq	ec4698 <_etext+0xebd084>
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else {
        /* some kind of error... */
        dfuAppStatus.bState  = dfuERROR;
    19ac:	00001349 	andeq	r1, r0, r9, asr #6
        dfuAppStatus.bStatus = errSTALLEDPKT;
    19b0:	0b002404 	bleq	a9c8 <_etext+0x33b4>
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}
    19b4:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    19b8:	05000008 	streq	r0, [r0, #-8]
    19bc:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    19c0:	0b3a0e03 	bleq	e851d4 <_etext+0xe7dbc0>
    19c4:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    19c8:	06120111 			; <UNDEFINED> instruction: 0x06120111
    19cc:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
    19d0:	00130119 	andseq	r0, r3, r9, lsl r1
    19d4:	00050600 	andeq	r0, r5, r0, lsl #12
    19d8:	0b3a0e03 	bleq	e851ec <_etext+0xe7dbd8>
    19dc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    19e0:	00001702 	andeq	r1, r0, r2, lsl #14
    19e4:	03000507 	movweq	r0, #1287	; 0x507
    19e8:	3b0b3a08 	blcc	2d0210 <_etext+0x2c8bfc>
    19ec:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    19f0:	08000017 	stmdaeq	r0, {r0, r1, r2, r4}
    19f4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    19f8:	0b3b0b3a 	bleq	ec46e8 <_etext+0xebd0d4>
    dfuAppStatus.bState = newState;
}

bool dfuUploadStarted()
{
    return dfuBusy;
    19fc:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
}
    1a00:	89090000 	stmdbhi	r9, {}	; <UNPREDICTABLE>
    1a04:	11010182 	smlabbne	r1, r2, r1, r0

void dfuFinishUpload() {

    while (1)
	{
		__asm__ __volatile__ ("");
    1a08:	01133101 	tsteq	r3, r1, lsl #2
};

/* Conversion to and from projective coordinates */
void ed25519_project(struct ed25519_pt *p,
		     const uint8_t *x, const uint8_t *y)
{
    1a0c:	0a000013 	beq	1a60 <ed25519_project+0x54>
    1a10:	0001828a 	andeq	r8, r1, sl, lsl #5
    1a14:	42911802 	addsmi	r1, r1, #131072	; 0x20000
    1a18:	0b000018 	bleq	1a80 <ed25519_unproject+0x4>
    1a1c:	01018289 	smlabbeq	r1, r9, r2, r8
    1a20:	13310111 	teqne	r1, #1073741828	; 0x40000004
    1a24:	0f0c0000 	svceq	0x000c0000
    1a28:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
    1a2c:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
    1a30:	13490026 	movtne	r0, #36902	; 0x9026
    1a34:	010e0000 	mrseq	r0, (UNDEF: 14)
    1a38:	01134901 	tsteq	r3, r1, lsl #18
    1a3c:	0f000013 	svceq	0x00000013
    1a40:	13490021 	movtne	r0, #36897	; 0x9021
    1a44:	00000b2f 	andeq	r0, r0, pc, lsr #22
    1a48:	03012e10 	movweq	r2, #7696	; 0x1e10
    1a4c:	3b0b3a0e 	blcc	2d028c <_etext+0x2c8c78>
    1a50:	2019270b 	andscs	r2, r9, fp, lsl #14
    1a54:	0013010b 	andseq	r0, r3, fp, lsl #2
    1a58:	00051100 	andeq	r1, r5, r0, lsl #2
    1a5c:	0b3a0803 	bleq	e83a70 <_etext+0xe7c45c>
    1a60:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1a64:	34120000 	ldrcc	r0, [r2], #-0
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
    1a68:	3a080300 	bcc	202670 <_etext+0x1fb05c>
	f25519_mul__distinct(p->t, x, y);
    1a6c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1a70:	13000013 	movwne	r0, #19
}
    1a74:	0e03012e 	adfeqsp	f0, f3, #0.5
		     const uint8_t *x, const uint8_t *y)
{
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
	f25519_mul__distinct(p->t, x, y);
    1a78:	0b3b0b3a 	bleq	ec4768 <_etext+0xebd154>
}

void ed25519_unproject(uint8_t *x, uint8_t *y,
		       const struct ed25519_pt *p)
{
    1a7c:	13491927 	movtne	r1, #39207	; 0x9927
    1a80:	13010b20 	movwne	r0, #6944	; 0x1b20
    1a84:	05140000 	ldreq	r0, [r4, #-0]
	uint8_t z1[F25519_SIZE];

	f25519_inv__distinct(z1, p->z);
    1a88:	3a0e0300 	bcc	382690 <_etext+0x37b07c>
    1a8c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	f25519_mul__distinct(x, p->x, z1);
    1a90:	15000013 	strne	r0, [r0, #-19]
    1a94:	08030034 	stmdaeq	r3, {r2, r4, r5}
    1a98:	0b3b0b3a 	bleq	ec4788 <_etext+0xebd174>
	f25519_mul__distinct(y, p->y, z1);
    1a9c:	0a1c1349 	beq	7067c8 <_etext+0x6ff1b4>
    1aa0:	2e160000 	cdpcs	0, 1, cr0, cr6, cr0, {0}
    1aa4:	03193f01 	tsteq	r9, #1, 30

	f25519_normalize(x);
    1aa8:	3b0b3a0e 	blcc	2d02e8 <_etext+0x2c8cd4>
	f25519_normalize(y);
    1aac:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
    1ab0:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
}
    1ab4:	97184006 	ldrls	r4, [r8, -r6]
	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
};

void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y)
{
    1ab8:	13011942 	movwne	r1, #6466	; 0x1942
    1abc:	1d170000 	ldcne	0, cr0, [r7, #-0]
    1ac0:	52133101 	andspl	r3, r3, #1073741824	; 0x40000000
    1ac4:	58175501 	ldmdapl	r7, {r0, r8, sl, ip, lr}
    1ac8:	010b590b 	tsteq	fp, fp, lsl #18
    1acc:	18000013 	stmdane	r0, {r0, r1, r4}
    1ad0:	13310005 	teqne	r1, #5
    1ad4:	00001702 	andeq	r1, r0, r2, lsl #14
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
    1ad8:	55010b19 	strpl	r0, [r1, #-2841]	; 0xb19
    1adc:	1a000017 	bne	1b40 <ed25519_try_unpack+0x28>
    1ae0:	13310034 	teqne	r1, #52	; 0x34
    1ae4:	00001802 	andeq	r1, r0, r2, lsl #16
    1ae8:	31011d1b 	tstcc	r1, fp, lsl sp
    1aec:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    1af0:	590b5806 	stmdbpl	fp, {r1, r2, fp, ip, lr}
    1af4:	0013010b 	andseq	r0, r3, fp, lsl #2
    1af8:	010b1c00 	tsteq	fp, r0, lsl #24
    1afc:	06120111 			; <UNDEFINED> instruction: 0x06120111
	parity = (tmp[0] & 1) << 7;
    1b00:	341d0000 	ldrcc	r0, [sp], #-0

	f25519_copy(c, y);
	f25519_normalize(c);
    1b04:	3a0e0300 	bcc	38270c <_etext+0x37b0f8>
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1b08:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    1b0c:	3c193f13 	ldccc	15, cr3, [r9], {19}

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1b10:	1e000019 	mcrne	0, 0, r0, cr0, cr9, {0}
}
    1b14:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b18:	0b3a0e03 	bleq	e8532c <_etext+0xe7dd18>
    1b1c:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    1b20:	1301193c 	movwne	r1, #6460	; 0x193c
    1b24:	051f0000 	ldreq	r0, [pc, #-0]	; 1b2c <ed25519_try_unpack+0x14>
	const int parity = comp[31] >> 7;
    1b28:	00134900 	andseq	r4, r3, r0, lsl #18
    1b2c:	012e2000 	teqeq	lr, r0
    1b30:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    1b34:	0b3b0b3a 	bleq	ec4824 <_etext+0xebd210>
    1b38:	13491927 	movtne	r1, #39207	; 0x9927
    1b3c:	0000193c 	andeq	r1, r0, ip, lsr r9
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b40:	01110100 	tsteq	r1, r0, lsl #2
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1b44:	0b130e25 	bleq	4c53e0 <_etext+0x4bddcc>
    1b48:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    1b4c:	01111755 	tsteq	r1, r5, asr r7
    1b50:	00001710 	andeq	r1, r0, r0, lsl r7
    1b54:	0b002402 	bleq	ab64 <_etext+0x3550>
	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
	f25519_add(a, b, f25519_one);
    1b58:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1b5c:	03000008 	movweq	r0, #8

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
    1b60:	0b0b0024 	bleq	2c1bf8 <_etext+0x2ba5e4>
    1b64:	0e030b3e 	vmoveq.16	d3[0], r0
	f25519_add(a, b, f25519_one);
    1b68:	0f040000 	svceq	0x00040000
    1b6c:	000b0b00 	andeq	r0, fp, r0, lsl #22
    1b70:	000f0500 	andeq	r0, pc, r0, lsl #10
	f25519_inv__distinct(b, a);
    1b74:	13490b0b 	movtne	r0, #39691	; 0x9b0b
    1b78:	13060000 	movwne	r0, #24576	; 0x6000

	/* Compute a = y^2-1 */
	f25519_sub(a, c, f25519_one);
    1b7c:	3a0b0b01 	bcc	2c4788 <_etext+0x2bd174>
    1b80:	010b3b0b 	tsteq	fp, fp, lsl #22

	/* Compute c = a*b = (y^2-1)/(1-dy^2) */
	f25519_mul__distinct(c, a, b);
    1b84:	07000013 	smladeq	r0, r3, r0, r0
    1b88:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    1b8c:	0b3b0b3a 	bleq	ec487c <_etext+0xebd268>

	/* Compute a, b = +/-sqrt(c), if c is square */
	f25519_sqrt(a, c);
    1b90:	0b381349 	bleq	e068bc <_etext+0xdff2a8>
    1b94:	01080000 	mrseq	r0, (UNDEF: 8)
	f25519_neg(b, a);
    1b98:	01134901 	tsteq	r3, r1, lsl #18
    1b9c:	09000013 	stmdbeq	r0, {r0, r1, r4}

	/* Select one of them, based on the compressed parity bit */
	f25519_select(x, a, b, (a[0] ^ parity) & 1);
    1ba0:	13490021 	movtne	r0, #36897	; 0x9021
    1ba4:	00000b2f 	andeq	r0, r0, pc, lsr #22
    1ba8:	0300160a 	movweq	r1, #1546	; 0x60a
    1bac:	3b0b3a0e 	blcc	2d03ec <_etext+0x2c8dd8>
    1bb0:	0013490b 	andseq	r4, r3, fp, lsl #18

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
    1bb4:	012e0b00 	teqeq	lr, r0, lsl #22
    1bb8:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    1bbc:	0b3b0b3a 	bleq	ec48ac <_etext+0xebd298>
	f25519_normalize(a);
    1bc0:	0b201927 	bleq	808064 <_etext+0x800a50>
	f25519_normalize(c);
    1bc4:	00001301 	andeq	r1, r0, r1, lsl #6
    1bc8:	0300050c 	movweq	r0, #1292	; 0x50c

	return f25519_eq(a, c);
    1bcc:	3b0b3a08 	blcc	2d03f4 <_etext+0x2c8de0>
    1bd0:	0013490b 	andseq	r4, r3, fp, lsl #18
}
    1bd4:	00050d00 	andeq	r0, r5, r0, lsl #26
    1bd8:	0b3a0e03 	bleq	e853ec <_etext+0xe7ddd8>
    1bdc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1be0:	340e0000 	strcc	r0, [lr], #-0
    1be4:	3a0e0300 	bcc	3827ec <_etext+0x37b1d8>
    1be8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bec:	0f000013 	svceq	0x00000013
    1bf0:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    1bf4:	0b3a0e03 	bleq	e85408 <_etext+0xe7ddf4>
	f25519_sub(d, p2->y, p2->x);
    1bf8:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bfc:	06120111 			; <UNDEFINED> instruction: 0x06120111
	f25519_sub(d, p2->y, p2->x);
    1c00:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
    1c04:	00130119 	andseq	r0, r3, r9, lsl r1
	f25519_mul__distinct(a, c, d);
    1c08:	00051000 	andeq	r1, r5, r0
    1c0c:	0b3a0803 	bleq	e83c20 <_etext+0xe7c60c>
    1c10:	13490b3b 	movtne	r0, #39739	; 0x9b3b

	/* B = (Y1+X1)(Y2+X2) */
	f25519_add(c, p1->y, p1->x);
    1c14:	00001802 	andeq	r1, r0, r2, lsl #16
    1c18:	03000511 	movweq	r0, #1297	; 0x511
	f25519_add(d, p2->y, p2->x);
    1c1c:	3b0b3a08 	blcc	2d0444 <_etext+0x2c8e30>
    1c20:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1c24:	12000017 	andne	r0, r0, #23
	f25519_mul__distinct(b, c, d);
    1c28:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
    1c2c:	0b3b0b3a 	bleq	ec491c <_etext+0xebd308>

	/* C = T1 k T2 */
	f25519_mul__distinct(d, p1->t, p2->t);
    1c30:	17021349 	strne	r1, [r2, -r9, asr #6]
    1c34:	34130000 	ldrcc	r0, [r3], #-0
    1c38:	3a0e0300 	bcc	382840 <_etext+0x37b22c>
    1c3c:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	f25519_mul__distinct(c, d, ed25519_k);
    1c40:	00170213 	andseq	r0, r7, r3, lsl r2
    1c44:	00341400 	eorseq	r1, r4, r0, lsl #8

	/* D = Z1 2 Z2 */
	f25519_mul__distinct(d, p1->z, p2->z);
    1c48:	0b3a0803 	bleq	e83c5c <_etext+0xe7c648>
    1c4c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1c50:	00001702 	andeq	r1, r0, r2, lsl #14
    1c54:	31012e15 	tstcc	r1, r5, lsl lr
	f25519_add(d, d, d);
    1c58:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    1c5c:	97184006 	ldrls	r4, [r8, -r6]

	/* E = B - A */
	f25519_sub(e, b, a);
    1c60:	13011942 	movwne	r1, #6466	; 0x1942
    1c64:	05160000 	ldreq	r0, [r6, #-0]
    1c68:	02133100 	andseq	r3, r3, #0, 2

	/* F = D - C */
	f25519_sub(f, d, c);
    1c6c:	17000017 	smladne	r0, r7, r0, r0
    1c70:	13310034 	teqne	r1, #52	; 0x34

	/* G = D + C */
	f25519_add(g, d, c);
    1c74:	0b180000 	bleq	601c7c <_etext+0x5fa668>
    1c78:	00175501 	andseq	r5, r7, r1, lsl #10
    1c7c:	00341900 	eorseq	r1, r4, r0, lsl #18

	/* H = B + A */
	f25519_add(h, b, a);
    1c80:	17021331 	smladxne	r2, r1, r3, r1
    1c84:	891a0000 	ldmdbhi	sl, {}	; <UNPREDICTABLE>

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1c88:	11010182 	smlabbne	r1, r2, r1, r0
    1c8c:	01133101 	tsteq	r3, r1, lsl #2
    1c90:	1b000013 	blne	1ce4 <ed25519_double+0x24>

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1c94:	0001828a 	andeq	r8, r1, sl, lsl #5
    1c98:	42911802 	addsmi	r1, r1, #131072	; 0x20000
    1c9c:	1c000018 	stcne	0, cr0, [r0], {24}

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1ca0:	00018289 	andeq	r8, r1, r9, lsl #5
    1ca4:	42950111 	addsmi	r0, r5, #1073741828	; 0x40000004
    1ca8:	00133119 	andseq	r3, r3, r9, lsl r1

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1cac:	82891d00 	addhi	r1, r9, #0, 26
    1cb0:	01110101 	tsteq	r1, r1, lsl #2
    1cb4:	00001331 	andeq	r1, r0, r1, lsr r3
}
    1cb8:	0300341e 	movweq	r3, #1054	; 0x41e
    1cbc:	3b0b3a0e 	blcc	2d04fc <_etext+0x2c8ee8>

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1cc0:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    1cc4:	1f000018 	svcne	0x00000018

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1cc8:	1331011d 	teqne	r1, #1073741831	; 0x40000007
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1ccc:	17550152 			; <UNDEFINED> instruction: 0x17550152
    1cd0:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xb58

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1cd4:	00001301 	andeq	r1, r0, r1, lsl #6
    1cd8:	31000520 	tstcc	r0, r0, lsr #10
    1cdc:	00180213 	andseq	r0, r8, r3, lsl r2

	/* C = 2 Z1^2 */
	f25519_mul__distinct(c, p->z, p->z);
    1ce0:	011d2100 	tsteq	sp, r0, lsl #2
    1ce4:	01521331 	cmpeq	r2, r1, lsr r3
    1ce8:	0b581755 	bleq	1607a44 <_etext+0x1600430>
	f25519_add(c, c, c);
    1cec:	00000559 	andeq	r0, r0, r9, asr r5
    1cf0:	03003422 	movweq	r3, #1058	; 0x422

	/* D = a A (alter sign) */
	/* E = (X1+Y1)^2-A-B */
	f25519_add(f, p->x, p->y);
    1cf4:	3b0b3a08 	blcc	2d051c <_etext+0x2c8f08>
    1cf8:	3f13490b 	svccc	0x0013490b
    1cfc:	00180219 	andseq	r0, r8, r9, lsl r2
	f25519_mul__distinct(e, f, f);
    1d00:	012e2300 	teqeq	lr, r0, lsl #6
    1d04:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
	f25519_sub(e, e, a);
    1d08:	13491927 	movtne	r1, #39207	; 0x9927
    1d0c:	193c1934 	ldmdbne	ip!, {r2, r4, r5, r8, fp, ip}
    1d10:	00001301 	andeq	r1, r0, r1, lsl #6
	f25519_sub(e, e, b);
    1d14:	49000524 	stmdbmi	r0, {r2, r5, r8, sl}
    1d18:	25000013 	strcs	r0, [r0, #-19]

	/* G = D + B */
	f25519_sub(g, b, a);
    1d1c:	00000026 	andeq	r0, r0, r6, lsr #32
    1d20:	01110100 	tsteq	r1, r0, lsl #2
    1d24:	0b130e25 	bleq	4c55c0 <_etext+0x4bdfac>

	/* F = G - C */
	f25519_sub(f, g, c);
    1d28:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
    1d2c:	01111755 	tsteq	r1, r5, asr r7

	/* H = D - B */
	f25519_neg(h, b);
    1d30:	00001710 	andeq	r1, r0, r0, lsl r7
    1d34:	0b002402 	bleq	ad44 <_etext+0x3730>
	f25519_sub(h, h, a);
    1d38:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    1d3c:	0300000e 	movweq	r0, #14
    1d40:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1d44:	0b3b0b3a 	bleq	ec4a34 <_etext+0xebd420>
    1d48:	00001349 	andeq	r1, r0, r9, asr #6

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1d4c:	0b002404 	bleq	ad64 <_etext+0x3750>
    1d50:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    1d54:	05000008 	streq	r0, [r0, #-8]

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1d58:	0b0b000f 	bleq	2c1d9c <_etext+0x2ba788>
    1d5c:	13060000 	movwne	r0, #24576	; 0x6000
    1d60:	0b0e0301 	bleq	38296c <_etext+0x37b358>

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1d64:	3b0b3a0b 	blcc	2d0598 <_etext+0x2c8f84>
    1d68:	0013010b 	andseq	r0, r3, fp, lsl #2
    1d6c:	000d0700 	andeq	r0, sp, r0, lsl #14
}
    1d70:	0b3a0803 	bleq	e83d84 <_etext+0xe7c770>

void ed25519_smult(struct ed25519_pt *r_out, const struct ed25519_pt *p,
		   const uint8_t *e)
{
    1d74:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1d78:	00000b38 	andeq	r0, r0, r8, lsr fp
    1d7c:	49010108 	stmdbmi	r1, {r3, r8}
    1d80:	00130113 	andseq	r0, r3, r3, lsl r1
    1d84:	00210900 	eoreq	r0, r1, r0, lsl #18
    1d88:	0b2f1349 	bleq	bc6ab4 <_etext+0xbbf4a0>
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1d8c:	2e0a0000 	cdpcs	0, 0, cr0, cr10, cr0, {0}
    1d90:	3a0e0301 	bcc	38299c <_etext+0x37b388>
    1d94:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
		struct ed25519_pt s;

		ed25519_double(&r, &r);
    1d98:	20134919 	andscs	r4, r3, r9, lsl r9
    1d9c:	0013010b 	andseq	r0, r3, fp, lsl #2
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1da0:	00050b00 	andeq	r0, r5, r0, lsl #22
		struct ed25519_pt s;

		ed25519_double(&r, &r);
		ed25519_add(&s, &r, p);
    1da4:	0b3a0803 	bleq	e83db8 <_etext+0xe7c7a4>
    1da8:	13490b3b 	movtne	r0, #39739	; 0x9b3b

		f25519_select(r.x, r.x, s.x, bit);
    1dac:	050c0000 	streq	r0, [ip, #-0]
    1db0:	3a0e0300 	bcc	3829b8 <_etext+0x37b3a4>
    1db4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
		f25519_select(r.y, r.y, s.y, bit);
    1db8:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
    1dbc:	0e03012e 	adfeqsp	f0, f3, #0.5
    1dc0:	0b3b0b3a 	bleq	ec4ab0 <_etext+0xebd49c>
		f25519_select(r.z, r.z, s.z, bit);
    1dc4:	0b201927 	bleq	808268 <_etext+0x800c54>
    1dc8:	00001301 	andeq	r1, r0, r1, lsl #6
    1dcc:	0b000f0e 	bleq	5a0c <sha512_get+0x204>
		f25519_select(r.t, r.t, s.t, bit);
    1dd0:	0013490b 	andseq	r4, r3, fp, lsl #18
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1dd4:	00340f00 	eorseq	r0, r4, r0, lsl #30
		ed25519_add(&s, &r, p);

		f25519_select(r.x, r.x, s.x, bit);
		f25519_select(r.y, r.y, s.y, bit);
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
    1dd8:	0b3a0803 	bleq	e83dec <_etext+0xe7c7d8>
    1ddc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1de0:	26100000 	ldrcs	r0, [r0], -r0
    1de4:	00134900 	andseq	r4, r3, r0, lsl #18
    1de8:	012e1100 	teqeq	lr, r0, lsl #2
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
	}

	ed25519_copy(r_out, &r);
}
    1dec:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    1df0:	0b3b0b3a 	bleq	ec4ae0 <_etext+0xebd4cc>
    1df4:	01111927 	tsteq	r1, r7, lsr #18
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1df8:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
    1dfc:	01194297 			; <UNDEFINED> instruction: 0x01194297
    1e00:	12000013 	andne	r0, r0, #19
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e04:	08030005 	stmdaeq	r3, {r0, r2}
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1e08:	0b3b0b3a 	bleq	ec4af8 <_etext+0xebd4e4>
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e0c:	17021349 	strne	r1, [r2, -r9, asr #6]
    1e10:	34130000 	ldrcc	r0, [r3], #-0
    1e14:	3a080300 	bcc	202a1c <_etext+0x1fb408>
    1e18:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	memcpy(block + 32, a, 32);
    1e1c:	00180213 	andseq	r0, r8, r3, lsl r2
    1e20:	00341400 	eorseq	r1, r4, r0, lsl #8
    1e24:	0b3a0803 	bleq	e83e38 <_etext+0xe7c824>
    1e28:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1e2c:	00001702 	andeq	r1, r0, r2, lsl #14
    1e30:	31011d15 	tstcc	r1, r5, lsl sp
    1e34:	55015213 	strpl	r5, [r1, #-531]	; 0x213
    1e38:	590b5817 	stmdbpl	fp, {r0, r1, r2, r4, fp, ip, lr}
    1e3c:	0013010b 	andseq	r0, r3, fp, lsl #2
    1e40:	00051600 	andeq	r1, r5, r0, lsl #12
    1e44:	17021331 	smladxne	r2, r1, r3, r1
    1e48:	0b170000 	bleq	5c1e50 <_etext+0x5ba83c>
{
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
    1e4c:	00175501 	andseq	r5, r7, r1, lsl #10
    1e50:	00341800 	eorseq	r1, r4, r0, lsl #16
    1e54:	17021331 	smladxne	r2, r1, r3, r1
		memcpy(init_block + prefix_size, message, len);
		sha512_final(&s, init_block, len + prefix_size);
	} else {
		size_t i;

		memcpy(init_block + prefix_size, message,
    1e58:	0b190000 	bleq	641e60 <_etext+0x63a84c>
    1e5c:	12011101 	andne	r1, r1, #1073741824	; 0x40000000
    1e60:	1a000006 	bne	1e80 <edsign_verify+0x88>
    1e64:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    1e68:	0b3b0b3a 	bleq	ec4b58 <_etext+0xebd544>
    1e6c:	17021349 	strne	r1, [r2, -r9, asr #6]
    1e70:	1d1b0000 	ldcne	0, cr0, [fp, #-0]
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);
    1e74:	52133101 	andspl	r3, r3, #1073741824	; 0x40000000
    1e78:	58175501 	ldmdapl	r7, {r0, r8, sl, ip, lr}

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e7c:	000b590b 	andeq	r5, fp, fp, lsl #18
    1e80:	00051c00 	andeq	r1, r5, r0, lsl #24
    1e84:	0b3a0e03 	bleq	e85698 <_etext+0xe7e084>
    1e88:	13490b3b 	movtne	r0, #39739	; 0x9b3b
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1e8c:	00001702 	andeq	r1, r0, r2, lsl #14
		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
		     i + SHA512_BLOCK_SIZE <= len;
    1e90:	0300341d 	movweq	r3, #1053	; 0x41d
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1e94:	3b0b3a0e 	blcc	2d06d4 <_etext+0x2c90c0>

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e98:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
    1e9c:	1e000018 	mcrne	0, 0, r0, cr0, cr8, {0}
    1ea0:	01018289 	smlabbeq	r1, r9, r2, r8
    1ea4:	13310111 	teqne	r1, #1073741828	; 0x40000004
    1ea8:	00001301 	andeq	r1, r0, r1, lsl #6
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
		memcpy(init_block + prefix_size, message, len);
    1eac:	01828a1f 	orreq	r8, r2, pc, lsl sl
    1eb0:	91180200 	tstls	r8, r0, lsl #4
    1eb4:	00001842 	andeq	r1, r0, r2, asr #16
		sha512_final(&s, init_block, len + prefix_size);
    1eb8:	01828920 	orreq	r8, r2, r0, lsr #18
    1ebc:	31011101 	tstcc	r1, r1, lsl #2
    1ec0:	21000013 	tstcs	r0, r3, lsl r0
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
	}

	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
    1ec4:	0111010b 	tsteq	r1, fp, lsl #2
    1ec8:	13010612 	movwne	r0, #5650	; 0x1612
    1ecc:	05220000 	streq	r0, [r2, #-0]!
	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
    1ed0:	00133100 	andseq	r3, r3, r0, lsl #2
    1ed4:	00342300 	eorseq	r2, r4, r0, lsl #6
    1ed8:	0b3a0e03 	bleq	e856ec <_etext+0xe7e0d8>

static void sm_pack(uint8_t *r, const uint8_t *k)
{
	struct ed25519_pt p;

	ed25519_smult(&p, &ed25519_base, k);
    1edc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    1ee0:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
    1ee4:	2e240000 	cdpcs	0, 2, cr0, cr4, cr0, {0}
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1ee8:	03193f01 	tsteq	r9, #1, 30
    1eec:	4919270e 	ldmdbmi	r9, {r1, r2, r3, r8, r9, sl, sp}
	ed25519_pack(packed, x, y);
    1ef0:	3c193413 	cfldrscc	mvf3, [r9], {19}
    1ef4:	00130119 	andseq	r0, r3, r9, lsl r1
    1ef8:	00052500 	andeq	r2, r5, r0, lsl #10

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1efc:	00001349 	andeq	r1, r0, r9, asr #6
    1f00:	00002626 	andeq	r2, r0, r6, lsr #12

	ed25519_project(p, x, y);
    1f04:	11010000 	mrsne	r0, (UNDEF: 1)
    1f08:	130e2501 	movwne	r2, #58625	; 0xe501
    1f0c:	1b0e030b 	blne	382b40 <_etext+0x37b52c>
	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
    1f10:	1117550e 	tstne	r7, lr, lsl #10
    1f14:	00171001 	andseq	r1, r7, r1
    1f18:	00160200 	andseq	r0, r6, r0, lsl #4

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1f1c:	0b3a0e03 	bleq	e85730 <_etext+0xe7e11c>
    1f20:	13490b3b 	movtne	r0, #39739	; 0x9b3b

	ed25519_project(p, x, y);
    1f24:	24030000 	strcs	r0, [r3], #-0
    1f28:	3e0b0b00 	vmlacc.f64	d0, d11, d0
    1f2c:	000e030b 	andeq	r0, lr, fp, lsl #6

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
    1f30:	000f0400 	andeq	r0, pc, r0, lsl #8
    1f34:	00000b0b 	andeq	r0, r0, fp, lsl #22
    1f38:	0b002405 	bleq	af54 <_etext+0x3940>
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1f3c:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
    1f40:	06000008 	streq	r0, [r0], -r8
	ed25519_pack(packed, x, y);
    1f44:	0b0b000f 	bleq	2c1f88 <_etext+0x2ba974>
    1f48:	00001349 	andeq	r1, r0, r9, asr #6
    1f4c:	49002607 	stmdbmi	r0, {r0, r1, r2, r9, sl, sp}
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
    1f50:	08000013 	stmdaeq	r0, {r0, r1, r4}
    1f54:	08030016 	stmdaeq	r3, {r1, r2, r4}
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
    1f58:	0b3b0b3a 	bleq	ec4c48 <_etext+0xebd634>
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
}
    1f5c:	00001349 	andeq	r1, r0, r9, asr #6
    1f60:	49003509 	stmdbmi	r0, {r0, r3, r8, sl, ip, sp}

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1f64:	0a000013 	beq	1fb8 <f25519_normalize+0x24>
    1f68:	0b0b0104 	bleq	2c2380 <_etext+0x2bad6c>
    1f6c:	0b3b0b3a 	bleq	ec4c5c <_etext+0xebd648>
    1f70:	00001301 	andeq	r1, r0, r1, lsl #6

const uint8_t f25519_zero[F25519_SIZE] = {0};
const uint8_t f25519_one[F25519_SIZE] = {1};

void f25519_load(uint8_t *x, uint32_t c)
{
    1f74:	0300280b 	movweq	r2, #2059	; 0x80b
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
		c >>= 8;
    1f78:	000d1c0e 	andeq	r1, sp, lr, lsl #24
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    1f7c:	01130c00 	tsteq	r3, r0, lsl #24
    1f80:	0b3a0b0b 	bleq	e84bb4 <_etext+0xe7d5a0>
    1f84:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    1f88:	0d0d0000 	stceq	0, cr0, [sp, #-0]
		c >>= 8;
	}

	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}
    1f8c:	3a0e0300 	bcc	382b94 <_etext+0x37b580>
    1f90:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}

void f25519_normalize(uint8_t *x)
{
    1f94:	000b3813 	andeq	r3, fp, r3, lsl r8
    1f98:	01010e00 	tsteq	r1, r0, lsl #28
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1f9c:	13011349 	movwne	r1, #4937	; 0x1349
	x[31] &= 127;
    1fa0:	210f0000 	mrscs	r0, CPSR

	for (i = 0; i < F25519_SIZE; i++) {
    1fa4:	2f134900 	svccs	0x00134900
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1fa8:	1000000b 	andne	r0, r0, fp
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
		c += x[i];
    1fac:	0e030113 	mcreq	1, 0, r0, cr3, cr3, {0}
		x[i] = c;
    1fb0:	0b3a0b0b 	bleq	e84be4 <_etext+0xe7d5d0>

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fb4:	13010b3b 	movwne	r0, #6971	; 0x1b3b
		c += x[i];
		x[i] = c;
		c >>= 8;
    1fb8:	21110000 	tstcs	r1, r0

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fbc:	00134900 	andseq	r4, r3, r0, lsl #18
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += x[i];
    1fc0:	012e1200 	teqeq	lr, r0, lsl #4
		minusp[i] = c;
    1fc4:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1fc8:	0b3b0b3a 	bleq	ec4cb8 <_etext+0xebd6a4>
		c += x[i];
		minusp[i] = c;
		c >>= 8;
    1fcc:	06120111 			; <UNDEFINED> instruction: 0x06120111
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1fd0:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fd4:	00130119 	andseq	r0, r3, r9, lsl r1
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1fd8:	82891300 	addhi	r1, r9, #0, 6

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1fdc:	01110101 	tsteq	r1, r1, lsl #2
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;
    1fe0:	13011331 	movwne	r1, #4913	; 0x1331

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1fe4:	8a140000 	bhi	501fec <_etext+0x4fa9d8>
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    1fe8:	02000182 	andeq	r0, r0, #-2147483616	; 0x80000020
    1fec:	18429118 	stmdane	r2, {r3, r4, r8, ip, pc}^
    1ff0:	89150000 	ldmdbhi	r5, {}	; <UNPREDICTABLE>
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1ff4:	11010182 	smlabbne	r1, r2, r1, r0
    1ff8:	19429501 	stmdbne	r2, {r0, r8, sl, ip, pc}^
	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;

	/* Load x-p if no underflow */
	f25519_select(x, minusp, x, (c >> 15) & 1);
}
    1ffc:	00001331 	andeq	r1, r0, r1, lsr r3
    2000:	3f012e16 	svccc	0x00012e16

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
    2004:	3a0e0319 	bcc	382c70 <_etext+0x37b65c>
    2008:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    200c:	11134919 	tstne	r3, r9, lsl r9
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    2010:	40061201 	andmi	r1, r6, r1, lsl #4
    2014:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
    2018:	00001301 	andeq	r1, r0, r1, lsl #6
    201c:	03000517 	movweq	r0, #1303	; 0x517
    2020:	3b0b3a0e 	blcc	2d0860 <_etext+0x2c924c>
    2024:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    2028:	18000017 	stmdane	r0, {r0, r1, r2, r4}
    202c:	08030034 	stmdaeq	r3, {r2, r4, r5}
    2030:	0b3b0b3a 	bleq	ec4d20 <_etext+0xebd70c>
    2034:	17021349 	strne	r1, [r2, -r9, asr #6]
    2038:	34190000 	ldrcc	r0, [r9], #-0
    203c:	3a0e0300 	bcc	382c44 <_etext+0x37b630>
    2040:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    2044:	00180213 	andseq	r0, r8, r3, lsl r2
    2048:	00341a00 	eorseq	r1, r4, r0, lsl #20
    204c:	0b3a0e03 	bleq	e85860 <_etext+0xe7e24c>
    2050:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2054:	00000b1c 	andeq	r0, r0, ip, lsl fp
    2058:	0300341b 	movweq	r3, #1051	; 0x41b
    205c:	3b0b3a0e 	blcc	2d089c <_etext+0x2c9288>
    2060:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
    2064:	1c000017 	stcne	0, cr0, [r0], {23}
    2068:	08030034 	stmdaeq	r3, {r2, r4, r5}
    206c:	0b3b0b3a 	bleq	ec4d5c <_etext+0xebd748>

	sum |= (sum >> 4);
    2070:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
	sum |= (sum >> 2);
    2074:	341d0000 	ldrcc	r0, [sp], #-0
	sum |= (sum >> 1);
    2078:	49193400 	ldmdbmi	r9, {sl, ip, sp}

	return (sum ^ 1) & 1;
    207c:	00170213 	andseq	r0, r7, r3, lsl r2
}
    2080:	00341e00 	eorseq	r1, r4, r0, lsl #28
    2084:	0b3a0e03 	bleq	e85898 <_etext+0xe7e284>
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2088:	13490b3b 	movtne	r0, #39739	; 0x9b3b
		sum |= x[i] ^ y[i];
    208c:	2e1f0000 	cdpcs	0, 1, cr0, cr15, cr0, {0}
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2090:	03193f01 	tsteq	r9, #1, 30
    2094:	3b0b3a0e 	blcc	2d08d4 <_etext+0x2c92c0>
		sum |= x[i] ^ y[i];
    2098:	3c13490b 	ldccc	9, cr4, [r3], {11}
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    209c:	00130119 	andseq	r0, r3, r9, lsl r1
}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
    20a0:	00182000 	andseq	r2, r8, r0
    20a4:	89210000 	stmdbhi	r1!, {}	; <UNPREDICTABLE>
    20a8:	11000182 	smlabbne	r0, r2, r1, r0
    20ac:	00133101 	andseq	r3, r3, r1, lsl #2
    20b0:	00212200 	eoreq	r2, r1, r0, lsl #4
    20b4:	182f1349 	stmdane	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
    20b8:	21230000 	teqcs	r3, r0
    20bc:	2f134900 	svccs	0x00134900
    20c0:	24000013 	strcs	r0, [r0], #-19
	const uint8_t mask = -condition;
    20c4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    20c8:	0b3b0b3a 	bleq	ec4db8 <_etext+0xebd7a4>
    20cc:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
    20d0:	00001802 	andeq	r1, r0, r2, lsl #16
    20d4:	3f012e25 	svccc	0x00012e25
    20d8:	3a0e0319 	bcc	382d44 <_etext+0x37b730>
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    20dc:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    20e0:	3c134919 	ldccc	9, cr4, [r3], {25}
    20e4:	00130119 	andseq	r0, r3, r9, lsl r1
    20e8:	00052600 	andeq	r2, r5, r0, lsl #12
    20ec:	00001349 	andeq	r1, r0, r9, asr #6
    20f0:	3f012e27 	svccc	0x00012e27
    20f4:	3a0e0319 	bcc	382d60 <_etext+0x37b74c>
    20f8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    20fc:	3c134919 	ldccc	9, cr4, [r3], {25}
    2100:	00130119 	andseq	r0, r3, r9, lsl r1
    2104:	012e2800 	teqeq	lr, r0, lsl #16
    2108:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    210c:	13491927 	movtne	r1, #39207	; 0x9927
    2110:	193c1934 	ldmdbne	ip!, {r2, r4, r5, r8, fp, ip}
    2114:	00001301 	andeq	r1, r0, r1, lsl #6
    2118:	00002629 	andeq	r2, r0, r9, lsr #12
    211c:	012e2a00 	teqeq	lr, r0, lsl #20
    2120:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
    2124:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    2128:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
    212c:	00001301 	andeq	r1, r0, r1, lsl #6
    2130:	3f012e2b 	svccc	0x00012e2b
    2134:	3a0e0319 	bcc	382da0 <_etext+0x37b78c>
    2138:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    213c:	01193c19 	tsteq	r9, r9, lsl ip
    2140:	00000013 	andeq	r0, r0, r3, lsl r0
    2144:	25011101 	strcs	r1, [r1, #-257]	; 0x101
}
    2148:	030b130e 	movweq	r1, #45838	; 0xb30e
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    214c:	550e1b0e 	strpl	r1, [lr, #-2830]	; 0xb0e
    2150:	10011117 	andne	r1, r1, r7, lsl r1
    2154:	02000017 	andeq	r0, r0, #23
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2158:	0b0b0024 	bleq	2c21f0 <_etext+0x2babdc>
    215c:	0e030b3e 	vmoveq.16	d3[0], r0
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}
    2160:	16030000 	strne	r0, [r3], -r0
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    2164:	3a080300 	bcc	202d6c <_etext+0x1fb758>
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}

void f25519_add(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint16_t c = 0;
    2168:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
    216c:	04000013 	streq	r0, [r0], #-19
    2170:	0e030104 	adfeqs	f0, f3, f4
		r[i] = c;
    2174:	0b3a0b0b 	bleq	e84da8 <_etext+0xe7d794>
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    2178:	13010b3b 	movwne	r0, #6971	; 0x1b3b
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;
    217c:	28050000 	stmdacs	r5, {}	; <UNPREDICTABLE>
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    2180:	1c0e0300 	stcne	3, cr0, [lr], {-0}
	c = (c >> 7) * 19;
    2184:	0600000d 	streq	r0, [r0], -sp
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    2188:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}
	c = (c >> 7) * 19;
    218c:	0b3b0b3a 	bleq	ec4e7c <_etext+0xebd868>
    2190:	00001349 	andeq	r1, r0, r9, asr #6

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2194:	3f012e07 	svccc	0x00012e07
    2198:	3a0e0319 	bcc	382e04 <_etext+0x37b7f0>

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    219c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
		c += r[i];
		r[i] = c;
		c >>= 8;
    21a0:	20134919 	andscs	r4, r3, r9, lsl r9

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21a4:	0013010b 	andseq	r0, r3, fp, lsl #2
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    21a8:	00050800 	andeq	r0, r5, r0, lsl #16

void f25519_sub(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    21ac:	0b3a0e03 	bleq	e859c0 <_etext+0xe7e3ac>
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
    21b0:	13490b3b 	movtne	r0, #39739	; 0x9b3b
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    21b4:	2e090000 	cdpcs	0, 0, cr0, cr9, cr0, {0}
    21b8:	03193f01 	tsteq	r9, #1, 30
    21bc:	3b0b3a0e 	blcc	2d09fc <_etext+0x2c93e8>
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21c0:	1119270b 	tstne	r9, fp, lsl #14
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    21c4:	40061201 	andmi	r1, r6, r1, lsl #4
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21c8:	19429718 	stmdbne	r2, {r3, r4, r8, r9, sl, ip, pc}^
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    21cc:	00001301 	andeq	r1, r0, r1, lsl #6
    21d0:	0300050a 	movweq	r0, #1290	; 0x50a
	r[31] = c & 127;
	c = (c >> 7) * 19;
    21d4:	3b0b3a0e 	blcc	2d0a14 <_etext+0x2c9400>
    21d8:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    21dc:	0b000018 	bleq	2244 <f25519_mul__distinct+0x4>
	c = (c >> 7) * 19;
    21e0:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    21e4:	0b3a0e03 	bleq	e859f8 <_etext+0xe7e3e4>
		r[i] = c;
    21e8:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21ec:	01111349 	tsteq	r1, r9, asr #6
		c += r[i];
		r[i] = c;
		c >>= 8;
    21f0:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
	}
}
    21f4:	00194297 	mulseq	r9, r7, r2

void f25519_neg(uint8_t *r, const uint8_t *a)
{
    21f8:	00050c00 	andeq	r0, r5, r0, lsl #24
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
    21fc:	0b3a0e03 	bleq	e85a10 <_etext+0xe7e3fc>
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 - ((uint32_t)a[i]);
    2200:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2204:	00001702 	andeq	r1, r0, r2, lsl #14
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2208:	31012e0d 	tstcc	r1, sp, lsl #28
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
    220c:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2210:	97184006 	ldrls	r4, [r8, -r6]

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2214:	13011942 	movwne	r1, #6466	; 0x1942
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2218:	050e0000 	streq	r0, [lr, #-0]
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    221c:	02133100 	andseq	r3, r3, #0, 2
	c = (c >> 7) * 19;
    2220:	0f000017 	svceq	0x00000017
    2224:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2228:	0b3a0e03 	bleq	e85a3c <_etext+0xe7e428>
		r[i] = c;
    222c:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2230:	01111349 	tsteq	r1, r9, asr #6
		c += r[i];
		r[i] = c;
		c >>= 8;
    2234:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
	}
}
    2238:	01194297 			; <UNDEFINED> instruction: 0x01194297
    223c:	10000013 	andne	r0, r0, r3, lsl r0

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2240:	0111010b 	tsteq	r1, fp, lsl #2
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2244:	00000612 	andeq	r0, r0, r2, lsl r6
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    2248:	03003411 	movweq	r3, #1041	; 0x411
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    224c:	3b0b3a0e 	blcc	2d0a8c <_etext+0x2c9478>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2250:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
		for (j = 0; j <= i; j++)
    2254:	12000018 	andne	r0, r0, #24
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2258:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    225c:	0b3b0b3a 	bleq	ec4f4c <_etext+0xebd938>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2260:	00001349 	andeq	r1, r0, r9, asr #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2264:	31011d13 	tstcc	r1, r3, lsl sp
    2268:	55015213 	strpl	r5, [r1, #-531]	; 0x213
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    226c:	590b5817 	stmdbpl	fp, {r0, r1, r2, r4, fp, ip, lr}
    2270:	1400000b 	strne	r0, [r0], #-11
    2274:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    2278:	0b3a0e03 	bleq	e85a8c <_etext+0xe7e478>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    227c:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2280:	06120111 			; <UNDEFINED> instruction: 0x06120111
    2284:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2288:	00130119 	andseq	r0, r3, r9, lsl r1
			c += ((uint32_t)a[j]) *
    228c:	00051500 	andeq	r1, r5, r0, lsl #10
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2290:	0b3a0e03 	bleq	e85aa4 <_etext+0xe7e490>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2294:	1349053b 	movtne	r0, #38203	; 0x953b
    2298:	00001702 	andeq	r1, r0, r2, lsl #14
    229c:	03003416 	movweq	r3, #1046	; 0x416

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    22a0:	3b0b3a0e 	blcc	2d0ae0 <_etext+0x2c94cc>
    22a4:	02134905 	andseq	r4, r3, #81920	; 0x14000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22a8:	17000017 	smladne	r0, r7, r0, r0
	c = (c >> 7) * 19;
    22ac:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
    22b0:	0b3a0e03 	bleq	e85ac4 <_etext+0xe7e4b0>
		c += r[i];
    22b4:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22b8:	01111349 	tsteq	r1, r9, asr #6
		c += r[i];
		r[i] = c;
		c >>= 8;
    22bc:	18400612 	stmdane	r0, {r1, r4, r9, sl}^
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22c0:	01194297 			; <UNDEFINED> instruction: 0x01194297
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    22c4:	18000013 	stmdane	r0, {r0, r1, r4}
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    22c8:	0e030005 	cdpeq	0, 0, cr0, cr3, cr5, {0}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    22cc:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    22d0:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22d4:	0f190000 	svceq	0x00190000
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    22d8:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22dc:	1a000013 	bne	2330 <f25519_inv__distinct+0x68>
    22e0:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22e4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22e8:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22ec:	0b1b0000 	bleq	6c22f4 <_etext+0x6bace0>
    22f0:	00175501 	andseq	r5, r7, r1, lsl #10
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22f4:	010b1c00 	tsteq	fp, r0, lsl #24
    22f8:	06120111 			; <UNDEFINED> instruction: 0x06120111
    22fc:	00001301 	andeq	r1, r0, r1, lsl #6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2300:	0300051d 	movweq	r0, #1309	; 0x51d
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2304:	3b0b3a08 	blcc	2d0b2c <_etext+0x2c9518>
    2308:	02134905 	andseq	r4, r3, #81920	; 0x14000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    230c:	1e000017 	mcrne	0, 0, r0, cr0, cr7, {0}
			c += ((uint32_t)a[j]) *
    2310:	08030005 	stmdaeq	r3, {r0, r2}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2314:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2318:	18021349 	stmdane	r2, {r0, r3, r6, r8, r9, ip}
    231c:	2e1f0000 	cdpcs	0, 1, cr0, cr15, cr0, {0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2320:	03193f01 	tsteq	r9, #1, 30
	c = (c >> 7) * 19;
    2324:	3b0b3a0e 	blcc	2d0b64 <_etext+0x2c9550>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2328:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
	c = (c >> 7) * 19;
    232c:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2330:	97184006 	ldrls	r4, [r8, -r6]
    2334:	00001942 	andeq	r1, r0, r2, asr #18
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2338:	01110100 	tsteq	r1, r0, lsl #2
		r[i] = c;
    233c:	0b130e25 	bleq	4c5bd8 <_etext+0x4be5c4>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2340:	0e1b0e03 	cdpeq	14, 1, cr0, cr11, cr3, {0}
		c += r[i];
		r[i] = c;
		c >>= 8;
    2344:	01111755 	tsteq	r1, r5, asr r7
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2348:	00001710 	andeq	r1, r0, r0, lsl r7
    234c:	0b002402 	bleq	b35c <_etext+0x3d48>
    2350:	030b3e0b 	movweq	r3, #48651	; 0xbe0b
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2354:	0300000e 	movweq	r0, #14
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2358:	08030016 	stmdaeq	r3, {r1, r2, r4}
		for (j = 0; j <= i; j++)
    235c:	0b3b0b3a 	bleq	ec504c <_etext+0xebda38>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2360:	00001349 	andeq	r1, r0, r9, asr #6
    2364:	27001504 	strcs	r1, [r0, -r4, lsl #10]

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2368:	05000019 	streq	r0, [r0, #-25]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    236c:	0b0b000f 	bleq	2c23b0 <_etext+0x2bad9c>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2370:	00001349 	andeq	r1, r0, r9, asr #6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2374:	3f012e06 	svccc	0x00012e06
    2378:	3a0e0319 	bcc	382fe4 <_etext+0x37b9d0>
    237c:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
    2380:	12011119 	andne	r1, r1, #1073741830	; 0x40000006
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2384:	96184006 	ldrls	r4, [r8], -r6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2388:	13011942 	movwne	r1, #6466	; 0x1942
    238c:	34070000 	strcc	r0, [r7], #-0
    2390:	3a0e0300 	bcc	382f98 <_etext+0x37b984>

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2394:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2398:	00170213 	andseq	r0, r7, r3, lsl r2
    239c:	010b0800 	tsteq	fp, r0, lsl #16

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    23a0:	06120111 			; <UNDEFINED> instruction: 0x06120111
    23a4:	00001301 	andeq	r1, r0, r1, lsl #6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    23a8:	01828909 	orreq	r8, r2, r9, lsl #18
	c = (c >> 7) * 19;
    23ac:	31011100 	mrscc	r1, (UNDEF: 17)

	for (i = 0; i < F25519_SIZE; i++) {
    23b0:	0a000013 	beq	2404 <f25519_inv__distinct+0x13c>
		c += r[i];
    23b4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23b8:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
		c += r[i];
		r[i] = c;
		c >>= 8;
    23bc:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23c0:	0000193c 	andeq	r1, r0, ip, lsr r9
    23c4:	4900350b 	stmdbmi	r0, {r0, r1, r3, r8, sl, ip, sp}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    23c8:	0c000013 	stceq	0, cr0, [r0], {19}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23cc:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
    23d0:	0b3b0b3a 	bleq	ec50c0 <_etext+0xebdaac>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    23d4:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
		for (j = 0; j <= i; j++)
    23d8:	00001802 	andeq	r1, r0, r2, lsl #16
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23dc:	0300340d 	movweq	r3, #1037	; 0x40d
    23e0:	3b0b3a0e 	blcc	2d0c20 <_etext+0x2c960c>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23e4:	3f13490b 	svccc	0x0013490b
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23e8:	00193c19 	andseq	r3, r9, r9, lsl ip

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23ec:	01010e00 	tsteq	r1, r0, lsl #28
    23f0:	13011349 	movwne	r1, #4937	; 0x1349
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23f4:	210f0000 	mrscs	r0, CPSR
    23f8:	2f134900 	svccs	0x00134900
    23fc:	1000000b 	andne	r0, r0, fp
    2400:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2404:	0b3a0e03 	bleq	e85c18 <_etext+0xe7e604>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2408:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    240c:	193c1349 	ldmdbne	ip!, {r0, r3, r6, r8, r9, ip}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2410:	01000000 	mrseq	r0, (UNDEF: 0)
			c += ((uint32_t)a[j]) *
    2414:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2418:	0e030b13 	vmoveq.32	d3[0], r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    241c:	17550e1b 	smmlane	r5, fp, lr, r0
    2420:	17100111 			; <UNDEFINED> instruction: 0x17100111
    2424:	24020000 	strcs	r0, [r2], #-0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2428:	3e0b0b00 	vmlacc.f64	d0, d11, d0
	c = (c >> 7) * 19;
    242c:	000e030b 	andeq	r0, lr, fp, lsl #6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2430:	00160300 	andseq	r0, r6, r0, lsl #6
	c = (c >> 7) * 19;
    2434:	0b3a0803 	bleq	e84448 <_etext+0xe7ce34>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2438:	13490b3b 	movtne	r0, #39739	; 0x9b3b
	c = (c >> 7) * 19;
    243c:	0f040000 	svceq	0x00040000

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2440:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
		r[i] = c;
    2444:	05000013 	streq	r0, [r0, #-19]
		c >>= 8;
    2448:	0e030104 	adfeqs	f0, f3, f4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    244c:	0b3a0b0b 	bleq	e85080 <_etext+0xe7da6c>
    2450:	13010b3b 	movwne	r0, #6971	; 0x1b3b
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2454:	28060000 	stmdacs	r6, {}	; <UNPREDICTABLE>
    2458:	1c0e0300 	stcne	3, cr0, [lr], {-0}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    245c:	0700000d 	streq	r0, [r0, -sp]
    2460:	0e030016 	mcreq	0, 0, r0, cr3, cr6, {0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2464:	0b3b0b3a 	bleq	ec5154 <_etext+0xebdb40>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2468:	00001349 	andeq	r1, r0, r9, asr #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    246c:	03011308 	movweq	r1, #4872	; 0x1308
    2470:	3a0b0b0e 	bcc	2c50b0 <_etext+0x2bda9c>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2474:	010b3b0b 	tsteq	fp, fp, lsl #22
    2478:	09000013 	stmdbeq	r0, {r0, r1, r4}
    247c:	0e03000d 	cdpeq	0, 0, cr0, cr3, cr13, {0}
    2480:	0b3b0b3a 	bleq	ec5170 <_etext+0xebdb5c>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2484:	0b381349 	bleq	e071b0 <_etext+0xdffb9c>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2488:	150a0000 	strne	r0, [sl, #-0]
    248c:	49192701 	ldmdbmi	r9, {r0, r8, r9, sl, sp}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2490:	00130113 	andseq	r0, r3, r3, lsl r1
			c += ((uint32_t)a[j]) *
    2494:	00050b00 	andeq	r0, r5, r0, lsl #22
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2498:	00001349 	andeq	r1, r0, r9, asr #6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    249c:	0301130c 	movweq	r1, #4876	; 0x130c
    24a0:	3a0b0b08 	bcc	2c50c8 <_etext+0x2bdab4>
    24a4:	010b3b0b 	tsteq	fp, fp, lsl #22

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    24a8:	0d000013 	stceq	0, cr0, [r0, #-76]	; 0xffffffb4
    24ac:	0803000d 	stmdaeq	r3, {r0, r2, r3}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    24b0:	0b3b0b3a 	bleq	ec51a0 <_etext+0xebdb8c>
	c = (c >> 7) * 19;
    24b4:	0b381349 	bleq	e071e0 <_etext+0xdffbcc>

	for (i = 0; i < F25519_SIZE; i++) {
    24b8:	170e0000 	strne	r0, [lr, -r0]
		c += r[i];
    24bc:	3a0b0b01 	bcc	2c50c8 <_etext+0x2bdab4>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24c0:	010b3b0b 	tsteq	fp, fp, lsl #22
		c += r[i];
		r[i] = c;
		c >>= 8;
    24c4:	0f000013 	svceq	0x00000013
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24c8:	0803000d 	stmdaeq	r3, {r0, r2, r3}
	/* 1 1 */
	f25519_mul__distinct(s, x, x);
	f25519_mul__distinct(r, s, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    24cc:	0b3b0b3a 	bleq	ec51bc <_etext+0xebdba8>
    24d0:	00001349 	andeq	r1, r0, r9, asr #6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24d4:	27001510 	smladcs	r0, r0, r5, r1
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    24d8:	11000019 	tstne	r0, r9, lsl r0
    24dc:	193f002e 	ldmdbne	pc!, {r1, r2, r3, r5}	; <UNPREDICTABLE>
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24e0:	0b3a0e03 	bleq	e85cf4 <_etext+0xe7e6e0>
    24e4:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24e8:	06120111 			; <UNDEFINED> instruction: 0x06120111
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24ec:	42961840 	addsmi	r1, r6, #64, 16	; 0x400000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24f0:	12000019 	andne	r0, r0, #25
    24f4:	0e030034 	mcreq	0, 0, r0, cr3, cr4, {1}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24f8:	0b3b0b3a 	bleq	ec51e8 <_etext+0xebdbd4>
    24fc:	193f1349 	ldmdbne	pc!, {r0, r3, r6, r8, r9, ip}	; <UNPREDICTABLE>
    2500:	0000193c 	andeq	r1, r0, ip, lsr r9
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2504:	03003413 	movweq	r3, #1043	; 0x413
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2508:	3b0b3a0e 	blcc	2d0d48 <_etext+0x2c9734>
    250c:	3f13490b 	svccc	0x0013490b

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2510:	00180219 	andseq	r0, r8, r9, lsl r2
			c += ((uint32_t)a[j]) *
    2514:	11010000 	mrsne	r0, (UNDEF: 1)

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2518:	130e2501 	movwne	r2, #58625	; 0xe501
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    251c:	1b0e030b 	blne	383150 <_etext+0x37bb3c>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2520:	1117550e 	tstne	r7, lr, lsl #10
    2524:	00171001 	andseq	r1, r7, r1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2528:	00240200 	eoreq	r0, r4, r0, lsl #4
	c = (c >> 7) * 19;
    252c:	0b3e0b0b 	bleq	f85160 <_etext+0xf7db4c>
    2530:	00000e03 	andeq	r0, r0, r3, lsl #28
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2534:	03001603 	movweq	r1, #1539	; 0x603
	c = (c >> 7) * 19;
    2538:	3b0b3a08 	blcc	2d0d60 <_etext+0x2c974c>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    253c:	0013490b 	andseq	r4, r3, fp, lsl #18
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2540:	00160400 	andseq	r0, r6, r0, lsl #8
		r[i] = c;
    2544:	0b3a0e03 	bleq	e85d58 <_etext+0xe7e744>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2548:	13490b3b 	movtne	r0, #39739	; 0x9b3b
		c += r[i];
		r[i] = c;
		c >>= 8;
    254c:	35050000 	strcc	r0, [r5, #-0]
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2550:	00134900 	andseq	r4, r3, r0, lsl #18
    2554:	01040600 	tsteq	r4, r0, lsl #12
    2558:	0b3a0b0b 	bleq	e8518c <_etext+0xe7db78>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    255c:	13010b3b 	movwne	r0, #6971	; 0x1b3b
    2560:	28070000 	stmdacs	r7, {}	; <UNPREDICTABLE>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2564:	1c0e0300 	stcne	3, cr0, [lr], {-0}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2568:	0800000d 	stmdaeq	r0, {r0, r2, r3}
    256c:	0e030104 	adfeqs	f0, f3, f4

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2570:	0b3a0b0b 	bleq	e851a4 <_etext+0xe7db90>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2574:	13010b3b 	movwne	r0, #6971	; 0x1b3b

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2578:	13090000 	movwne	r0, #36864	; 0x9000
    257c:	0b0e0301 	bleq	383188 <_etext+0x37bb74>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2580:	3b0b3a0b 	blcc	2d0db4 <_etext+0x2c97a0>
    2584:	0013010b 	andseq	r0, r3, fp, lsl #2
    2588:	000d0a00 	andeq	r0, sp, r0, lsl #20
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    258c:	0b3a0e03 	bleq	e85da0 <_etext+0xe7e78c>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2590:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2594:	00000b38 	andeq	r0, r0, r8, lsr fp

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2598:	0b000f0b 	bleq	61cc <Standard_ClearFeature+0xcc>
			c += ((uint32_t)a[j]) *
    259c:	0013490b 	andseq	r4, r3, fp, lsl #18
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    25a0:	01150c00 	tsteq	r5, r0, lsl #24
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    25a4:	13491927 	movtne	r1, #39207	; 0x9927
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25a8:	00001301 	andeq	r1, r0, r1, lsl #6
	c = (c >> 7) * 19;
    25ac:	4900050d 	stmdbmi	r0, {r0, r2, r3, r8, sl}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25b0:	0e000013 	mcreq	0, 0, r0, cr0, cr3, {0}
	c = (c >> 7) * 19;
    25b4:	08030113 	stmdaeq	r3, {r0, r1, r4, r8}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25b8:	0b3a0b0b 	bleq	e851ec <_etext+0xe7dbd8>
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    25bc:	13010b3b 	movwne	r0, #6971	; 0x1b3b
		r[i] = c;
    25c0:	0d0f0000 	stceq	0, cr0, [pc, #-0]	; 25c8 <f25519_inv__distinct+0x300>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    25c4:	3a080300 	bcc	2031cc <_etext+0x1fbbb8>
		c += r[i];
		r[i] = c;
		c >>= 8;
    25c8:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    25cc:	000b3813 	andeq	r3, fp, r3, lsl r8
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25d0:	01171000 	tsteq	r7, r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    25d4:	0b3a0b0b 	bleq	e85208 <_etext+0xe7dbf4>
		for (j = 0; j <= i; j++)
    25d8:	13010b3b 	movwne	r0, #6971	; 0x1b3b
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25dc:	0d110000 	ldceq	0, cr0, [r1, #-0]
    25e0:	3a080300 	bcc	2031e8 <_etext+0x1fbbd4>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25e4:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25e8:	12000013 	andne	r0, r0, #19

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25ec:	19270015 	stmdbne	r7!, {r0, r2, r4}
    25f0:	2e130000 	cdpcs	0, 1, cr0, cr3, cr0, {0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25f4:	03193f01 	tsteq	r9, #1, 30
    25f8:	3b0b3a0e 	blcc	2d0e38 <_etext+0x2c9824>
    25fc:	4919270b 	ldmdbmi	r9, {r0, r1, r3, r8, r9, sl, sp}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2600:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2604:	96184006 	ldrls	r4, [r8], -r6
    2608:	13011942 	movwne	r1, #6466	; 0x1942

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    260c:	05140000 	ldreq	r0, [r4, #-0]
			c += ((uint32_t)a[j]) *
    2610:	3a0e0300 	bcc	383218 <_etext+0x37bc04>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2614:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2618:	00170213 	andseq	r0, r7, r3, lsl r2
    261c:	010b1500 	tsteq	fp, r0, lsl #10
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2620:	06120111 			; <UNDEFINED> instruction: 0x06120111
	c = (c >> 7) * 19;
    2624:	00001301 	andeq	r1, r0, r1, lsl #6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2628:	03003416 	movweq	r3, #1046	; 0x416
	c = (c >> 7) * 19;
    262c:	3b0b3a0e 	blcc	2d0e6c <_etext+0x2c9858>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2630:	0213490b 	andseq	r4, r3, #180224	; 0x2c000
	c = (c >> 7) * 19;
    2634:	17000017 	smladne	r0, r7, r0, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2638:	0111010b 	tsteq	r1, fp, lsl #2
		r[i] = c;
    263c:	00000612 	andeq	r0, r0, r2, lsl r6
		c >>= 8;
    2640:	03003418 	movweq	r3, #1048	; 0x418
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2644:	3b0b3a0e 	blcc	2d0e84 <_etext+0x2c9870>
    2648:	0013490b 	andseq	r4, r3, fp, lsl #18
    264c:	012e1900 	teqeq	lr, r0, lsl #18
    2650:	0b3a0e03 	bleq	e85e64 <_etext+0xe7e850>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2654:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2658:	06120111 			; <UNDEFINED> instruction: 0x06120111
		for (j = 0; j <= i; j++)
    265c:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2660:	00130119 	andseq	r0, r3, r9, lsl r1
    2664:	00341a00 	eorseq	r1, r4, r0, lsl #20

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2668:	0b3a0e03 	bleq	e85e7c <_etext+0xe7e868>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    266c:	1349053b 	movtne	r0, #38203	; 0x953b

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2670:	00001702 	andeq	r1, r0, r2, lsl #14
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2674:	03000a1b 	movweq	r0, #2587	; 0xa1b
    2678:	3b0b3a0e 	blcc	2d0eb8 <_etext+0x2c98a4>
    267c:	00011105 	andeq	r1, r1, r5, lsl #2
    2680:	82891c00 	addhi	r1, r9, #0, 24
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2684:	01110101 	tsteq	r1, r1, lsl #2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2688:	00001301 	andeq	r1, r0, r1, lsl #6
    268c:	01828a1d 	orreq	r8, r2, sp, lsl sl
    2690:	91180200 	tstls	r8, r0, lsl #4

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2694:	00001842 	andeq	r1, r0, r2, asr #16
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2698:	0182891e 	orreq	r8, r2, lr, lsl r9
    269c:	31011101 	tstcc	r1, r1, lsl #2

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    26a0:	00130113 	andseq	r0, r3, r3, lsl r1
    26a4:	82891f00 	addhi	r1, r9, #0, 30
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26a8:	01110101 	tsteq	r1, r1, lsl #2
	c = (c >> 7) * 19;
    26ac:	00001331 	andeq	r1, r0, r1, lsr r3

	for (i = 0; i < F25519_SIZE; i++) {
    26b0:	3f002e20 	svccc	0x00002e20
		c += r[i];
    26b4:	3a0e0319 	bcc	383320 <_etext+0x37bd0c>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    26b8:	270b3b0b 	strcs	r3, [fp, -fp, lsl #22]
		c += r[i];
		r[i] = c;
		c >>= 8;
    26bc:	11134919 	tstne	r3, r9, lsl r9
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    26c0:	40061201 	andmi	r1, r6, r1, lsl #4
    26c4:	19429618 	stmdbne	r2, {r3, r4, r9, sl, ip, pc}^
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26c8:	34210000 	strtcc	r0, [r1], #-0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    26cc:	3a080300 	bcc	2032d4 <_etext+0x1fbcc0>
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26d0:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    26d4:	00170213 	andseq	r0, r7, r3, lsl r2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26d8:	82892200 	addhi	r2, r9, #0, 4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26dc:	01110001 	tsteq	r1, r1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26e0:	00001331 	andeq	r1, r0, r1, lsr r3
    26e4:	3f012e23 	svccc	0x00012e23
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26e8:	3a0e0319 	bcc	383354 <_etext+0x37bd40>
    26ec:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
    26f0:	11134919 	tstne	r3, r9, lsl r9
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    26f4:	40061201 	andmi	r1, r6, r1, lsl #4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26f8:	19429618 	stmdbne	r2, {r3, r4, r9, sl, ip, pc}^
    26fc:	00001301 	andeq	r1, r0, r1, lsl #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2700:	03003424 	movweq	r3, #1060	; 0x424
			c += ((uint32_t)a[j]) *
    2704:	3b0b3a08 	blcc	2d0f2c <_etext+0x2c9918>

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2708:	02134905 	andseq	r4, r3, #81920	; 0x14000
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    270c:	25000017 	strcs	r0, [r0, #-23]
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2710:	1755010b 	ldrbne	r0, [r5, -fp, lsl #2]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2714:	00001301 	andeq	r1, r0, r1, lsl #6
	c = (c >> 7) * 19;
    2718:	3f002e26 	svccc	0x00002e26
    271c:	3a0e0319 	bcc	383388 <_etext+0x37bd74>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2720:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
	c = (c >> 7) * 19;
    2724:	11134919 	tstne	r3, r9, lsl r9
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2728:	40061201 	andmi	r1, r6, r1, lsl #4
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    272c:	19429618 	stmdbne	r2, {r3, r4, r9, sl, ip, pc}^
		r[i] = c;
    2730:	2e270000 	cdpcs	0, 2, cr0, cr7, cr0, {0}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2734:	03193f01 	tsteq	r9, #1, 30
		c += r[i];
		r[i] = c;
		c >>= 8;
    2738:	3b0b3a0e 	blcc	2d0f78 <_etext+0x2c9964>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    273c:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
    2740:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
    2744:	97184006 	ldrls	r4, [r8, -r6]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2748:	13011942 	movwne	r1, #6466	; 0x1942
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    274c:	05280000 	streq	r0, [r8, #-0]!
		for (j = 0; j <= i; j++)
    2750:	3a0e0300 	bcc	383358 <_etext+0x37bd44>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2754:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
    2758:	00170213 	andseq	r0, r7, r3, lsl r2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    275c:	012e2900 	teqeq	lr, r0, lsl #18
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2760:	0b3a0e03 	bleq	e85f74 <_etext+0xe7e960>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2764:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2768:	13010b20 	movwne	r0, #6944	; 0x1b20
    276c:	342a0000 	strtcc	r0, [sl], #-0
    2770:	3a0e0300 	bcc	383378 <_etext+0x37bd64>
    2774:	49053b0b 	stmdbmi	r5, {r0, r1, r3, r8, r9, fp, ip, sp}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2778:	2b000013 	blcs	27cc <f25519_inv__distinct+0x504>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    277c:	0e03000a 	cdpeq	0, 0, cr0, cr3, cr10, {0}
    2780:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
    2784:	0b2c0000 	bleq	b0278c <_etext+0xafb178>

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2788:	00130101 	andseq	r0, r3, r1, lsl #2
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    278c:	010b2d00 	tsteq	fp, r0, lsl #26
    2790:	172e0000 	strne	r0, [lr, -r0]!

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2794:	3a0b0b01 	bcc	2c53a0 <_etext+0x2bdd8c>
    2798:	01053b0b 	tsteq	r5, fp, lsl #22
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    279c:	2f000013 	svccs	0x00000013
	c = (c >> 7) * 19;
    27a0:	0803000d 	stmdaeq	r3, {r0, r2, r3}

	for (i = 0; i < F25519_SIZE; i++) {
    27a4:	053b0b3a 	ldreq	r0, [fp, #-2874]!	; 0xb3a
		c += r[i];
    27a8:	00001349 	andeq	r1, r0, r9, asr #6
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27ac:	31011d30 	tstcc	r1, r0, lsr sp
		c += r[i];
		r[i] = c;
		c >>= 8;
    27b0:	12011113 	andne	r1, r1, #-1073741820	; 0xc0000004
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27b4:	590b5806 	stmdbpl	fp, {r1, r2, fp, ip, lr}
    27b8:	00130105 	andseq	r0, r3, r5, lsl #2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27bc:	00343100 	eorseq	r3, r4, r0, lsl #2
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    27c0:	17021331 	smladxne	r2, r1, r3, r1
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27c4:	0a320000 	beq	c827cc <_etext+0xc7b1b8>
    27c8:	11133100 	tstne	r3, r0, lsl #2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27cc:	33000001 	movwcc	r0, #1
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27d0:	1331011d 	teqne	r1, #1073741831	; 0x40000007

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27d4:	17550152 			; <UNDEFINED> instruction: 0x17550152
    27d8:	05590b58 	ldrbeq	r0, [r9, #-2904]	; 0xb58
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27dc:	00001301 	andeq	r1, r0, r1, lsl #6
    27e0:	55010b34 	strpl	r0, [r1, #-2868]	; 0xb34
    27e4:	35000017 	strcc	r0, [r0, #-23]
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    27e8:	13310034 	teqne	r1, #52	; 0x34
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27ec:	00001802 	andeq	r1, r0, r2, lsl #16
    27f0:	01828936 	orreq	r8, r2, r6, lsr r9

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27f4:	00011101 	andeq	r1, r1, r1, lsl #2
			c += ((uint32_t)a[j]) *
    27f8:	82893700 	addhi	r3, r9, #0, 14

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27fc:	01110001 	tsteq	r1, r1
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2800:	31194295 			; <UNDEFINED> instruction: 0x31194295
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2804:	38000013 	stmdacc	r0, {r0, r1, r4}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2808:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
	c = (c >> 7) * 19;
    280c:	0b3a0e03 	bleq	e86020 <_etext+0xe7ea0c>
    2810:	1927053b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, sl}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2814:	06120111 			; <UNDEFINED> instruction: 0x06120111
	c = (c >> 7) * 19;
    2818:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    281c:	00130119 	andseq	r0, r3, r9, lsl r1
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2820:	00053900 	andeq	r3, r5, r0, lsl #18
		r[i] = c;
    2824:	0b3a0803 	bleq	e84838 <_etext+0xe7d224>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2828:	1349053b 	movtne	r0, #38203	; 0x953b
		c += r[i];
		r[i] = c;
		c >>= 8;
    282c:	00001702 	andeq	r1, r0, r2, lsl #14
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2830:	3f002e3a 	svccc	0x00002e3a
    2834:	3a0e0319 	bcc	3834a0 <_etext+0x37be8c>
    2838:	27053b0b 	strcs	r3, [r5, -fp, lsl #22]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    283c:	12011119 	andne	r1, r1, #1073741830	; 0x40000006
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2840:	97184006 	ldrls	r4, [r8, -r6]
		for (j = 0; j <= i; j++)
    2844:	00001942 	andeq	r1, r0, r2, asr #18
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2848:	0300343b 	movweq	r3, #1083	; 0x43b
    284c:	3b0b3a0e 	blcc	2d108c <_etext+0x2c9a78>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2850:	3f13490b 	svccc	0x0013490b
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2854:	00193c19 	andseq	r3, r9, r9, lsl ip

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2858:	00343c00 	eorseq	r3, r4, r0, lsl #24
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    285c:	0b3a0e03 	bleq	e86070 <_etext+0xe7ea5c>
    2860:	13490b3b 	movtne	r0, #39739	; 0x9b3b
    2864:	1802193f 	stmdane	r2, {r0, r1, r2, r3, r4, r5, r8, fp, ip}
    2868:	2e3d0000 	cdpcs	0, 3, cr0, cr13, cr0, {0}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    286c:	03193f01 	tsteq	r9, #1, 30
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2870:	3b0b3a0e 	blcc	2d10b0 <_etext+0x2c9a9c>
    2874:	49192705 	ldmdbmi	r9, {r0, r2, r8, r9, sl, sp}
    2878:	01193c13 	tsteq	r9, r3, lsl ip

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    287c:	3e000013 	mcrcc	0, 0, r0, cr0, cr3, {0}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2880:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>
    2884:	0b3a0e03 	bleq	e86098 <_etext+0xe7ea84>

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2888:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}
    288c:	1301193c 	movwne	r1, #6460	; 0x193c
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2890:	2e3f0000 	cdpcs	0, 3, cr0, cr15, cr0, {0}
	c = (c >> 7) * 19;
    2894:	03193f01 	tsteq	r9, #1, 30

	for (i = 0; i < F25519_SIZE; i++) {
    2898:	3b0b3a0e 	blcc	2d10d8 <_etext+0x2c9ac4>
		c += r[i];
    289c:	3c192705 	ldccc	7, cr2, [r9], {5}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28a0:	00130119 	andseq	r0, r3, r9, lsl r1
		c += r[i];
		r[i] = c;
		c >>= 8;
    28a4:	012e4000 	teqeq	lr, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28a8:	0e03193f 	mcreq	9, 0, r1, cr3, cr15, {1}
	f25519_mul__distinct(r, s, x);

	/* 1 */
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}
    28ac:	0b3b0b3a 	bleq	ec559c <_etext+0xebdf88>
    28b0:	193c1927 	ldmdbne	ip!, {r0, r1, r2, r5, r8, fp, ip}
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    28b4:	01000000 	mrseq	r0, (UNDEF: 0)
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28b8:	0e250111 	mcreq	1, 1, r0, cr5, cr1, {0}
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    28bc:	0e030b13 	vmoveq.32	d3[0], r0
	f25519_copy(r, tmp);
}

void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
    28c0:	17550e1b 	smmlane	r5, fp, lr, r0
    28c4:	17100111 			; <UNDEFINED> instruction: 0x17100111
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += b * ((uint32_t)a[i]);
    28c8:	24020000 	strcs	r0, [r2], #-0
    28cc:	3e0b0b00 	vmlacc.f64	d0, d11, d0
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28d0:	000e030b 	andeq	r0, lr, fp, lsl #6
    28d4:	00160300 	andseq	r0, r6, r0, lsl #6
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    28d8:	0b3a0803 	bleq	e848ec <_etext+0xe7d2d8>
    28dc:	13490b3b 	movtne	r0, #39739	; 0x9b3b
	c >>= 7;
	c *= 19;
    28e0:	0f040000 	svceq	0x00040000
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    28e4:	490b0b00 	stmdbmi	fp, {r8, r9, fp}
	c >>= 7;
	c *= 19;
    28e8:	05000013 	streq	r0, [r0, #-19]
    28ec:	193f012e 	ldmdbne	pc!, {r1, r2, r3, r5, r8}	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    28f0:	0b3a0e03 	bleq	e86104 <_etext+0xe7eaf0>
		r[i] = c;
    28f4:	19270b3b 	stmdbne	r7!, {r0, r1, r3, r4, r5, r8, r9, fp}

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28f8:	06120111 			; <UNDEFINED> instruction: 0x06120111
		c += r[i];
		r[i] = c;
		c >>= 8;
    28fc:	42971840 	addsmi	r1, r7, #64, 16	; 0x400000

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2900:	00130119 	andseq	r0, r3, r9, lsl r1
    2904:	00050600 	andeq	r0, r5, r0, lsl #12
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2908:	0b3a0e03 	bleq	e8611c <_etext+0xe7eb08>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    290c:	13490b3b 	movtne	r0, #39739	; 0x9b3b
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2910:	00001702 	andeq	r1, r0, r2, lsl #14
    2914:	03003407 	movweq	r3, #1031	; 0x407

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2918:	3b0b3a08 	blcc	2d1140 <_etext+0x2c9b2c>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    291c:	0213490b 	andseq	r4, r3, #180224	; 0x2c000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2920:	08000018 	stmdaeq	r0, {r3, r4}
    2924:	08030034 	stmdaeq	r3, {r2, r4, r5}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2928:	0b3b0b3a 	bleq	ec5618 <_etext+0xebe004>
    292c:	17021349 	strne	r1, [r2, -r9, asr #6]
    2930:	34090000 	strcc	r0, [r9], #-0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2934:	3a0e0300 	bcc	38353c <_etext+0x37bf28>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2938:	490b3b0b 	stmdbmi	fp, {r0, r1, r3, r8, r9, fp, ip, sp}
    293c:	00170213 	andseq	r0, r7, r3, lsl r2
	...

Disassembly of section .debug_line:

00000000 <.debug_line>:
       0:	00000071 	andeq	r0, r0, r1, ror r0
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
       4:	00310002 	eorseq	r0, r1, r2
       8:	01020000 	mrseq	r0, (UNDEF: 2)
       c:	000d0efb 	strdeq	r0, [sp], -fp
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
      10:	01010101 	tsteq	r1, r1, lsl #2
      14:	01000000 	mrseq	r0, (UNDEF: 0)
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
      18:	73010000 	movwvc	r0, #4096	; 0x1000
      1c:	32336d74 	eorscc	r6, r3, #116, 26	; 0x1d00
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
      20:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
      24:	5f630000 	svcpl	0x00630000
      28:	796c6e6f 	stmdbvc	ip!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    if ((wEPVal & EP_CTR_RX) != 0)
      2c:	6174735f 	cmnvs	r4, pc, asr r3
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
      30:	70757472 	rsbsvc	r7, r5, r2, ror r4
      34:	0100732e 	tsteq	r0, lr, lsr #6
      38:	00000000 	andeq	r0, r0, r0

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
      3c:	0b4c0205 	bleq	1300858 <_etext+0x12f9244>

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
      40:	c1030000 	mrsgt	r0, (UNDEF: 3)
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
      44:	31210100 	teqcc	r1, r0, lsl #2
      48:	23212121 	teqcs	r1, #1073741832	; 0x40000008
      4c:	21212121 	teqcs	r1, r1, lsr #2

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
      50:	2131212f 	teqcs	r1, pc, lsr #2
      54:	30212131 	eorcc	r2, r1, r1, lsr r1
      58:	2068032f 	rsbcs	r0, r8, pc, lsr #6
      5c:	36322f34 	shasxcc	r2, r2, r4
      60:	01000202 	tsteq	r0, r2, lsl #4
      64:	02050001 	andeq	r0, r5, #1
      68:	00000b94 	muleq	r0, r4, fp
      6c:	0100eb03 	tsteq	r0, r3, lsl #22
      70:	01000202 	tsteq	r0, r2, lsl #4
      74:	0000a201 	andeq	sl, r0, r1, lsl #4
      78:	33000200 	movwcc	r0, #512	; 0x200
      7c:	02000000 	andeq	r0, r0, #0
      80:	0d0efb01 	vstreq	d15, [lr, #-4]
      84:	01010100 	mrseq	r0, (UNDEF: 17)
      88:	00000001 	andeq	r0, r0, r1
      8c:	01000001 	tsteq	r0, r1
      90:	74732f2e 	ldrbtvc	r2, [r3], #-3886	; 0xf2e
      94:	5f32336d 	svcpl	0x0032336d
      98:	0062696c 	rsbeq	r6, r2, ip, ror #18
      9c:	726f6300 	rsbvc	r6, pc, #0, 6
      a0:	6d786574 	cfldr64vs	mvdx6, [r8, #-464]!	; 0xfffffe30
      a4:	616d5f33 	cmnvs	sp, r3, lsr pc
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
      a8:	2e6f7263 	cdpcs	2, 6, cr7, cr15, cr3, {3}

	return f25519_eq(a, c);
      ac:	00010053 	andeq	r0, r1, r3, asr r0
      b0:	05000000 	streq	r0, [r0, #-0]
      b4:	00000002 	andeq	r0, r0, r2
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
      b8:	01370300 	teqeq	r7, r0, lsl #6
	f25519_normalize(ey);
      bc:	200b0321 	andcs	r0, fp, r1, lsr #6
      c0:	200b0321 	andcs	r0, fp, r1, lsr #6

	return ok;
}
      c4:	200b0321 	andcs	r0, fp, r1, lsr #6
      c8:	200b032f 	andcs	r0, fp, pc, lsr #6
      cc:	200b032f 	andcs	r0, fp, pc, lsr #6
      d0:	200b032f 	andcs	r0, fp, pc, lsr #6
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
      d4:	200b0321 	andcs	r0, fp, r1, lsr #6
      d8:	200b032f 	andcs	r0, fp, pc, lsr #6
		minusp[i] = c;
      dc:	0a032f2f 	beq	cbda0 <_etext+0xc478c>
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
      e0:	0b032f20 	bleq	cbd68 <_etext+0xc4754>
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
      e4:	0b032f20 	bleq	cbd6c <_etext+0xc4758>

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
      e8:	0b032f20 	bleq	cbd70 <_etext+0xc475c>
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
      ec:	0b032f20 	bleq	cbd74 <_etext+0xc4760>
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
      f0:	0b032120 	bleq	c8578 <_etext+0xc0f64>
      f4:	0b032120 	bleq	c857c <_etext+0xc0f68>
      f8:	0b032f20 	bleq	cbd80 <_etext+0xc476c>
      fc:	0b032120 	bleq	c8584 <_etext+0xc0f70>
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     100:	0b032120 	bleq	c8588 <_etext+0xc0f74>

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
     104:	0b032f20 	bleq	cbd8c <_etext+0xc4778>
     108:	0b032f20 	bleq	cbd90 <_etext+0xc477c>
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     10c:	0a032f20 	beq	cbd94 <_etext+0xc4780>
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
     110:	0b032120 	bleq	c8598 <_etext+0xc0f84>
     114:	01022120 	tsteq	r2, r0, lsr #2
     118:	a7010100 	strge	r0, [r1, -r0, lsl #2]
     11c:	02000003 	andeq	r0, r0, #3
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     120:	0000be00 	andeq	fp, r0, r0, lsl #28
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
     124:	fb010200 	blx	4092e <_etext+0x3931a>
     128:	01000d0e 	tsteq	r0, lr, lsl #26
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
     12c:	00010101 	andeq	r0, r1, r1, lsl #2

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
     130:	00010000 	andeq	r0, r1, r0
	i <<= 3;

	while (x) {
     134:	2f2e0100 	svccs	0x002e0100
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
     138:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
     13c:	696c5f32 	stmdbvs	ip!, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
     140:	2f2e0062 	svccs	0x002e0062
	f25519_mul_c(z3, x1sq, 4);
     144:	5f627375 	svcpl	0x00627375
     148:	0062696c 	rsbeq	r6, r2, ip, ror #18
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	62737500 	rsbsvs	r7, r3, #0, 10
     150:	0000632e 	andeq	r6, r0, lr, lsr #6
     154:	74730000 	ldrbtvc	r0, [r3], #-0
	f25519_sub(b, x3, z3); /* D */
     158:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
     15c:	5f783031 	svcpl	0x00783031
	f25519_mul__distinct(da, a, b);
     160:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0x974
     164:	0100682e 	tsteq	r0, lr, lsr #16
     168:	61680000 	cmnvs	r8, r0

	f25519_sub(b, x2, z2);
     16c:	61776472 	cmnvs	r7, r2, ror r4
     170:	682e6572 	stmdavs	lr!, {r1, r4, r5, r6, r8, sl, sp, lr}
	f25519_add(a, x3, z3); /* C */
     174:	00000000 	andeq	r0, r0, r0
     178:	5f627375 	svcpl	0x00627375
     17c:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xf63
	f25519_mul__distinct(cb, a, b);
     180:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
     184:	73750000 	cmnvc	r5, #0

	f25519_add(a, da, cb);
     188:	65645f62 	strbvs	r5, [r4, #-3938]!	; 0xf62
     18c:	00682e66 	rsbeq	r2, r8, r6, ror #28
     190:	75000002 	strvc	r0, [r0, #-2]
	f25519_mul__distinct(b, a, a);
     194:	682e6273 	stmdavs	lr!, {r0, r1, r4, r5, r6, r9, sp, lr}
     198:	00000000 	andeq	r0, r0, r0
	f25519_mul__distinct(x5, z1, b);
     19c:	5f627375 	svcpl	0x00627375
     1a0:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
     1a4:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000

	f25519_sub(a, da, cb);
     1a8:	73750000 	cmnvc	r5, #0
     1ac:	65645f62 	strbvs	r5, [r4, #-3938]!	; 0xf62
	f25519_mul__distinct(b, a, a);
     1b0:	69726373 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, r8, r9, sp, lr}^
     1b4:	726f7470 	rsbvc	r7, pc, #112, 8	; 0x70000000
     1b8:	0000682e 	andeq	r6, r0, lr, lsr #16

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	66640000 	strbtvs	r0, [r4], -r0
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	00682e75 	rsbeq	r2, r8, r5, ror lr
     1c4:	75000000 	strvc	r0, [r0, #-0]

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1c8:	725f6273 	subsvc	r6, pc, #805306375	; 0x30000007
     1cc:	2e736765 	cdpcs	7, 7, cr6, cr3, cr5, {3}
     1d0:	00020068 	andeq	r0, r2, r8, rrx
     1d4:	62737500 	rsbsvs	r7, r3, #0, 10
		f25519_select(zm1, zm1, zm, bit);
     1d8:	746e695f 	strbtvc	r6, [lr], #-2399	; 0x95f
     1dc:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
     1e0:	00000000 	andeq	r0, r0, r0
		f25519_select(xm, xm, xms, bit);
     1e4:	0b980205 	bleq	fe600a00 <BootRAM+0xd5711a1>
     1e8:	a7030000 	strge	r0, [r3, -r0]
     1ec:	01020101 	tsteq	r2, r1, lsl #2
		f25519_select(zm, zm, zms, bit);
     1f0:	00010100 	andeq	r0, r1, r0, lsl #2
     1f4:	0b9a0205 	bleq	fe680a10 <BootRAM+0xd5f11b1>
     1f8:	d7030000 	strle	r0, [r3, -r0]
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fc:	01020102 	tsteq	r2, r2, lsl #2
     200:	00010100 	andeq	r0, r1, r0, lsl #2
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     204:	0b9c0205 	bleq	fe700a20 <BootRAM+0xd6711c1>
     208:	dc030000 	stcle	0, cr0, [r3], {-0}
	f25519_mul__distinct(result, zm1, xm);
     20c:	01020102 	tsteq	r2, r2, lsl #2
     210:	00010100 	andeq	r0, r1, r0, lsl #2
	f25519_normalize(result);
     214:	0b9e0205 	bleq	fe780a30 <BootRAM+0xd6f11d1>
     218:	93030000 	movwls	r0, #12288	; 0x3000
}
     21c:	24150103 	ldrcs	r0, [r5], #-259	; 0x103
     220:	01000402 	tsteq	r0, r2, lsl #8
     224:	02050001 	andeq	r0, r5, #1
     228:	00000ba8 	andeq	r0, r0, r8, lsr #23
     22c:	0103bf03 	tsteq	r3, r3, lsl #30
     230:	01000102 	tsteq	r0, r2, lsl #2
     234:	02050001 	andeq	r0, r5, #1
     238:	00000bac 	andeq	r0, r0, ip, lsr #23
     23c:	0103c403 	tsteq	r3, r3, lsl #8
     240:	08024b13 	stmdaeq	r2, {r0, r1, r4, r8, r9, fp, lr}
     244:	00010100 	andeq	r0, r1, r0, lsl #2
     248:	0bc40205 	bleq	ff100a64 <BootRAM+0xe071205>
     24c:	cb030000 	blgt	c0254 <_etext+0xb8c40>
     250:	01020103 	tsteq	r2, r3, lsl #2
     254:	00010100 	andeq	r0, r1, r0, lsl #2
     258:	0bc60205 	bleq	ff180a74 <BootRAM+0xe0f1215>
     25c:	d0030000 	andle	r0, r3, r0
     260:	01020103 	tsteq	r2, r3, lsl #2
     264:	00010100 	andeq	r0, r1, r0, lsl #2
     268:	0bc80205 	bleq	ff200a84 <BootRAM+0xe171225>
     26c:	d5030000 	strle	r0, [r3, #-0]
     270:	01020103 	tsteq	r2, r3, lsl #2
     274:	00010100 	andeq	r0, r1, r0, lsl #2
     278:	0bca0205 	bleq	ff280a94 <BootRAM+0xe1f1235>
     27c:	da030000 	ble	c0284 <_etext+0xb8c70>
     280:	01020103 	tsteq	r2, r3, lsl #2
     284:	00010100 	andeq	r0, r1, r0, lsl #2
     288:	0bcc0205 	bleq	ff300aa4 <BootRAM+0xe271245>
     28c:	df030000 	svcle	0x00030000
     290:	01020103 	tsteq	r2, r3, lsl #2
     294:	00010100 	andeq	r0, r1, r0, lsl #2
     298:	0bce0205 	bleq	ff380ab4 <BootRAM+0xe2f1255>
     29c:	e4030000 	str	r0, [r3], #-0
     2a0:	01020103 	tsteq	r2, r3, lsl #2
     2a4:	00010100 	andeq	r0, r1, r0, lsl #2
     2a8:	0bd00205 	bleq	ff400ac4 <BootRAM+0xe371265>
     2ac:	e9030000 	stmdb	r3, {}	; <UNPREDICTABLE>
     2b0:	02130103 	andseq	r0, r3, #-1073741824	; 0xc0000000
     2b4:	01010006 	tsteq	r1, r6
     2b8:	dc020500 	cfstr32le	mvfx0, [r2], {-0}
     2bc:	0300000b 	movweq	r0, #11
     2c0:	210102bd 			; <UNDEFINED> instruction: 0x210102bd
     2c4:	2f1f2130 	svccs	0x001f2130
     2c8:	0b03211f 	bleq	c874c <_etext+0xc1138>
     2cc:	20750320 	rsbscs	r0, r5, r0, lsr #6
     2d0:	231d2322 	tstcs	sp, #-2013265920	; 0x88000000
     2d4:	92759291 	rsbsls	r9, r5, #268435465	; 0x10000009
     2d8:	2f3e7630 	svccs	0x003e7630
     2dc:	08212c21 	stmdaeq	r1!, {r0, r5, sl, fp, sp}
     2e0:	00010100 	andeq	r0, r1, r0, lsl #2
     2e4:	0c840205 	sfmeq	f0, 4, [r4], {5}
     2e8:	e0030000 	and	r0, r3, r0
     2ec:	1b250102 	blne	9406fc <_etext+0x9390e8>
     2f0:	8a3e7525 	bhi	f9d78c <_etext+0xf96178>
     2f4:	03212221 	teqeq	r1, #268435458	; 0x10000002
     2f8:	03312076 	teqeq	r1, #118	; 0x76
     2fc:	21212010 	teqcs	r1, r0, lsl r0
     300:	2221211e 	eorcs	r2, r1, #-2147483641	; 0x80000007
     304:	0b022131 	bleq	887d0 <_etext+0x811bc>
     308:	00010100 	andeq	r0, r1, r0, lsl #2
     30c:	0ce40205 	sfmeq	f0, 2, [r4], #20
     310:	9d030000 	stcls	0, cr0, [r3, #-0]
     314:	02130103 	andseq	r0, r3, #-1073741824	; 0xc0000000
     318:	01010006 	tsteq	r1, r6
     31c:	f0020500 			; <UNDEFINED> instruction: 0xf0020500
     320:	0300000c 	movweq	r0, #12
     324:	130103a2 	movwne	r0, #5026	; 0x13a2
     328:	01000602 	tsteq	r0, r2, lsl #12
     32c:	02050001 	andeq	r0, r5, #1
     330:	00000cfc 	strdeq	r0, [r0], -ip
     334:	0103a703 	tsteq	r3, r3, lsl #14
     338:	5a313d13 	bpl	c4f78c <_etext+0xc48178>
     33c:	01000602 	tsteq	r0, r2, lsl #12
     340:	02050001 	andeq	r0, r5, #1
     344:	00000d1c 	andeq	r0, r0, ip, lsl sp
     348:	0103b103 	tsteq	r3, r3, lsl #2
     34c:	00060213 	andeq	r0, r6, r3, lsl r2
     350:	05000101 	streq	r0, [r0, #-257]	; 0x101
     354:	000d2802 	andeq	r2, sp, r2, lsl #16
     358:	03880300 	orreq	r0, r8, #0, 6
     35c:	3d762101 	ldfcce	f2, [r6, #-4]!
     360:	0402214d 	streq	r2, [r2], #-333	; 0x14d
     364:	00010100 	andeq	r0, r1, r0, lsl #2
     368:	0d500205 	lfmeq	f0, 2, [r0, #-20]	; 0xffffffec
     36c:	ec030000 	stc	0, cr0, [r3], {-0}
     370:	18030100 	stmdane	r3, {r8}
     374:	2f1f3d20 	svccs	0x001f3d20
     378:	0402008a 	streq	r0, [r2], #-138	; 0x8a
     37c:	062e0602 	strteq	r0, [lr], -r2, lsl #12
     380:	211f3d6d 	tstcs	pc, sp, ror #26
     384:	302f2d21 	eorcc	r2, pc, r1, lsr #26
     388:	2016032f 	andscs	r0, r6, pc, lsr #6
     38c:	022e6d03 	eoreq	r6, lr, #3, 26	; 0xc0
     390:	0101000c 	tsteq	r1, ip
     394:	00020500 	andeq	r0, r2, r0, lsl #10
     398:	03000000 	movweq	r0, #0
     39c:	140101ad 	strne	r0, [r1], #-429	; 0x1ad
     3a0:	01000202 	tsteq	r0, r2, lsl #4
     3a4:	02050001 	andeq	r0, r5, #1
     3a8:	00000db8 			; <UNDEFINED> instruction: 0x00000db8
     3ac:	0101b303 	tsteq	r1, r3, lsl #6
     3b0:	023f3e14 	eorseq	r3, pc, #20, 28	; 0x140
     3b4:	01010008 	tsteq	r1, r8
     3b8:	d4020500 	strle	r0, [r2], #-1280	; 0x500
     3bc:	0300000d 	movweq	r0, #13
     3c0:	160101be 			; <UNDEFINED> instruction: 0x160101be
     3c4:	31222c22 	teqcc	r2, r2, lsr #24
     3c8:	01000602 	tsteq	r0, r2, lsl #12
     3cc:	02050001 	andeq	r0, r5, #1
     3d0:	00000dec 	andeq	r0, r0, ip, ror #27
     3d4:	0101cb03 	tsteq	r1, r3, lsl #22
     3d8:	84302131 	ldrthi	r2, [r0], #-305	; 0x131
     3dc:	2f312f40 	svccs	0x00312f40
     3e0:	312f4b31 	teqcc	pc, r1, lsr fp	; <UNPREDICTABLE>
     3e4:	2f2f3d3e 	svccs	0x002f3d3e
     3e8:	222f4b22 	eorcs	r4, pc, #34816	; 0x8800
     3ec:	502f222c 	eorpl	r2, pc, ip, lsr #4
     3f0:	01000702 	tsteq	r0, r2, lsl #14
     3f4:	02050001 	andeq	r0, r5, #1
     3f8:	00000e70 	andeq	r0, r0, r0, ror lr
     3fc:	0101fc03 	tsteq	r1, r3, lsl #24
     400:	24221e14 	strtcs	r1, [r2], #-3604	; 0xe14
     404:	1f4b3e1c 	svcne	0x004b3e1c
     408:	21211c24 	teqcs	r1, r4, lsr #24
     40c:	4f273d22 	svcmi	0x00273d22
     410:	01000b02 	tsteq	r0, r2, lsl #22
     414:	02050001 	andeq	r0, r5, #1
     418:	00000eb8 			; <UNDEFINED> instruction: 0x00000eb8
     41c:	01029303 	tsteq	r2, r3, lsl #6
     420:	21212d13 	teqcs	r1, r3, lsl sp
     424:	2e0c033d 	mcrcs	3, 0, r0, cr12, cr13, {1}
     428:	4d1d235d 	ldcmi	3, cr2, [sp, #-372]	; 0xfffffe8c
     42c:	01000a02 	tsteq	r0, r2, lsl #20
     430:	02050001 	andeq	r0, r5, #1
     434:	00000ef4 	strdeq	r0, [r0], -r4
     438:	0101a003 	tsteq	r1, r3
     43c:	00020213 	andeq	r0, r2, r3, lsl r2
     440:	05000101 	streq	r0, [r0, #-257]	; 0x101
     444:	000ef802 	andeq	pc, lr, r2, lsl #16
     448:	03f00300 	mvnseq	r0, #0, 6
     44c:	3d3d2301 	ldccc	3, cr2, [sp, #-4]!
     450:	2f3d1f30 	svccs	0x003d1f30
     454:	01000302 	tsteq	r0, r2, lsl #6
     458:	02050001 	andeq	r0, r5, #1
     45c:	00000f1c 	andeq	r0, r0, ip, lsl pc
     460:	0102ad03 	tsteq	r2, r3, lsl #26
     464:	304b3021 	subcc	r3, fp, r1, lsr #32
     468:	3d211f21 	stccc	15, cr1, [r1, #-132]!	; 0xffffff7c
     46c:	0d022f31 	stceq	15, cr2, [r2, #-196]	; 0xffffff3c
     470:	00010100 	andeq	r0, r1, r0, lsl #2
     474:	0f5c0205 	svceq	0x005c0205
     478:	fb030000 	blx	c0482 <_etext+0xb8e6e>
     47c:	40220103 	eormi	r0, r2, r3, lsl #2
     480:	2f2f3d1d 	svccs	0x002f3d1d
     484:	0003022f 	andeq	r0, r3, pc, lsr #4
     488:	05000101 	streq	r0, [r0, #-257]	; 0x101
     48c:	000f8002 	andeq	r8, pc, r2
     490:	04850300 	streq	r0, [r5], #768	; 0x300
     494:	1b412101 	blne	10488a0 <_etext+0x104128c>
     498:	59335b33 	ldmdbpl	r3!, {r0, r1, r4, r5, r8, r9, fp, ip, lr}
     49c:	3c0d033d 	stccc	3, cr0, [sp], {61}	; 0x3d
     4a0:	3d4b504b 	stclcc	0, cr5, [fp, #-300]	; 0xfffffed4
     4a4:	42345c42 	eorsmi	r5, r4, #16896	; 0x4200
     4a8:	4b5e3d59 	blmi	178fa14 <_etext+0x1788400>
     4ac:	022a243f 	eoreq	r2, sl, #1056964608	; 0x3f000000
     4b0:	0101000e 	tsteq	r1, lr
     4b4:	00020500 	andeq	r0, r2, r0, lsl #10
     4b8:	03000000 	movweq	r0, #0
     4bc:	130104d5 	movwne	r0, #5333	; 0x14d5
     4c0:	0004022f 	andeq	r0, r4, pc, lsr #4
     4c4:	006e0101 	rsbeq	r0, lr, r1, lsl #2
     4c8:	00020000 	andeq	r0, r2, r0
     4cc:	00000068 	andeq	r0, r0, r8, rrx
     4d0:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
     4d4:	0101000d 	tsteq	r1, sp
     4d8:	00000101 	andeq	r0, r0, r1, lsl #2
     4dc:	00000100 	andeq	r0, r0, r0, lsl #2
     4e0:	732f2e01 	teqvc	pc, #1, 28
     4e4:	32336d74 	eorscc	r6, r3, #116, 26	; 0x1d00
     4e8:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
     4ec:	752f2e00 	strvc	r2, [pc, #-3584]!	; fffff6f4 <BootRAM+0xef6fe95>
     4f0:	6c5f6273 	lfmvs	f6, 2, [pc], {115}	; 0x73
     4f4:	00006269 	andeq	r6, r0, r9, ror #4
     4f8:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
     4fc:	30316632 	eorscc	r6, r1, r2, lsr r6
     500:	79745f78 	ldmdbvc	r4!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
     504:	682e6570 	stmdavs	lr!, {r4, r5, r6, r8, sl, sp, lr}
     508:	00000100 	andeq	r0, r0, r0, lsl #2
     50c:	5f627375 	svcpl	0x00627375
     510:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xf63
     514:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
     518:	73750000 	cmnvc	r5, #0
     51c:	00682e62 	rsbeq	r2, r8, r2, ror #28
     520:	75000000 	strvc	r0, [r0, #-0]
     524:	645f6273 	ldrbvs	r6, [pc], #-627	; 52c <RCC_ITConfig+0x4>
     528:	72637365 	rsbvc	r7, r3, #-1811939327	; 0x94000001
     52c:	6f747069 	svcvs	0x00747069
     530:	00632e72 	rsbeq	r2, r3, r2, ror lr
     534:	00000000 	andeq	r0, r0, r0
     538:	000001e0 	andeq	r0, r0, r0, ror #3
     53c:	01970002 	orrseq	r0, r7, r2
     540:	01020000 	mrseq	r0, (UNDEF: 2)
     544:	000d0efb 	strdeq	r0, [sp], -fp
     548:	01010101 	tsteq	r1, r1, lsl #2
     54c:	01000000 	mrseq	r0, (UNDEF: 0)
     550:	63010000 	movwvs	r0, #4096	; 0x1000
     554:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
     558:	6172676f 	cmnvs	r2, pc, ror #14
     55c:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
     560:	2073656c 	rsbscs	r6, r3, ip, ror #10
     564:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
     568:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
     56c:	6f742075 	svcvs	0x00742075
     570:	20736c6f 	rsbscs	r6, r3, pc, ror #24
     574:	206d7261 	rsbcs	r7, sp, r1, ror #4
     578:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
     57c:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
     580:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
     584:	31303220 	teqcc	r0, r0, lsr #4
     588:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
     58c:	5c62696c 	stclpl	9, cr6, [r2], #-432	; 0xfffffe50
     590:	5c636367 	stclpl	3, cr6, [r3], #-412	; 0xfffffe64
     594:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     598:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
     59c:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     5a0:	2e345c69 	cdpcs	12, 3, cr5, cr4, cr9, {3}
     5a4:	5c342e38 	ldcpl	14, cr2, [r4], #-224	; 0xffffff20
     5a8:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
     5ac:	00656475 	rsbeq	r6, r5, r5, ror r4
     5b0:	705c3a63 	subsvc	r3, ip, r3, ror #20
     5b4:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
     5b8:	66206d61 	strtvs	r6, [r0], -r1, ror #26
     5bc:	73656c69 	cmnvc	r5, #26880	; 0x6900
     5c0:	38782820 	ldmdacc	r8!, {r5, fp, sp}^
     5c4:	675c2936 	smmlarvs	ip, r6, r9, r2
     5c8:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
     5cc:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
     5d0:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80
     5d4:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000
     5d8:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
     5dc:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}
     5e0:	30322038 	eorscc	r2, r2, r8, lsr r0
     5e4:	33713431 	cmncc	r1, #822083584	; 0x31000000
     5e8:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
     5ec:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     5f0:	61652d65 	cmnvs	r5, r5, ror #26
     5f4:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^
     5f8:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
     5fc:	6d5c6564 	cfldr64vs	mvdx6, [ip, #-400]	; 0xfffffe70
     600:	69686361 	stmdbvs	r8!, {r0, r5, r6, r8, r9, sp, lr}^
     604:	6300656e 	movwvs	r6, #1390	; 0x56e
     608:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
     60c:	6172676f 	cmnvs	r2, pc, ror #14
     610:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
     614:	2073656c 	rsbscs	r6, r3, ip, ror #10
     618:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
     61c:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
     620:	6f742075 	svcvs	0x00742075
     624:	20736c6f 	rsbscs	r6, r3, pc, ror #24
     628:	206d7261 	rsbcs	r7, sp, r1, ror #4
     62c:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
     630:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
     634:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
     638:	31303220 	teqcc	r0, r0, lsr #4
     63c:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
     640:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     644:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
     648:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     64c:	6e695c69 	cdpvs	12, 6, cr5, cr9, cr9, {3}
     650:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
     654:	2f2e0065 	svccs	0x002e0065
     658:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
     65c:	696c5f32 	stmdbvs	ip!, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
     660:	6d000062 	stcvs	0, cr0, [r0, #-392]	; 0xfffffe78
     664:	2e6e6961 	cdpcs	9, 6, cr6, cr14, cr1, {3}
     668:	00000063 	andeq	r0, r0, r3, rrx
     66c:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
     670:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
     674:	00010068 	andeq	r0, r1, r8, rrx
     678:	65645f00 	strbvs	r5, [r4, #-3840]!	; 0xf00
     67c:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
     680:	79745f74 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
     684:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
     688:	00020068 	andeq	r0, r2, r8, rrx
     68c:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
     690:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
     694:	00030068 	andeq	r0, r3, r8, rrx
     698:	6d747300 	ldclvs	3, cr7, [r4, #-0]
     69c:	31663233 	cmncc	r6, r3, lsr r2
     6a0:	745f7830 	ldrbvc	r7, [pc], #-2096	; 6a8 <RCC_APB1PeriphResetCmd+0x10>
     6a4:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
     6a8:	00040068 	andeq	r0, r4, r8, rrx
     6ac:	616d6900 	cmnvs	sp, r0, lsl #18
     6b0:	682e6567 	stmdavs	lr!, {r0, r1, r2, r5, r6, r8, sl, sp, lr}
     6b4:	00000000 	andeq	r0, r0, r0
     6b8:	64726168 	ldrbtvs	r6, [r2], #-360	; 0x168
     6bc:	65726177 	ldrbvs	r6, [r2, #-375]!	; 0x177
     6c0:	0000682e 	andeq	r6, r0, lr, lsr #16
     6c4:	73750000 	cmnvc	r5, #0
     6c8:	00682e62 	rsbeq	r2, r8, r2, ror #28
     6cc:	64000000 	strvs	r0, [r0], #-0
     6d0:	682e7566 	stmdavs	lr!, {r1, r2, r5, r6, r8, sl, ip, sp, lr}
     6d4:	00000000 	andeq	r0, r0, r0
     6d8:	02050000 	andeq	r0, r5, #0
     6dc:	00001034 	andeq	r1, r0, r4, lsr r0
     6e0:	32013d03 	andcc	r3, r1, #3, 26	; 0xc0
     6e4:	2f2f2f2f 	svccs	0x002f2f2f
     6e8:	3e2f2f2f 	cdpcc	15, 2, cr2, cr15, cr15, {1}
     6ec:	2f683f5d 	svccs	0x00683f5d
     6f0:	69032f1f 	stmdbvs	r3, {r0, r1, r2, r3, r4, r8, r9, sl, fp, sp}
     6f4:	581a0366 	ldmdapl	sl, {r1, r2, r5, r6, r8, r9}
     6f8:	3323213d 	teqcc	r3, #1073741839	; 0x4000000f
     6fc:	93263d33 	teqls	r6, #3264	; 0xcc0
     700:	01040200 	mrseq	r0, R12_usr
     704:	31062006 	tstcc	r6, r6
     708:	003d3e92 	mlaseq	sp, r2, lr, r3
     70c:	03020402 	movweq	r0, #9218	; 0x2402
     710:	0e034a78 	mcreq	10, 0, r4, cr3, cr8, {3}
     714:	02403d2e 	subeq	r3, r0, #2944	; 0xb80
     718:	0101001d 	tsteq	r1, sp, lsl r0
     71c:	00000532 	andeq	r0, r0, r2, lsr r5
     720:	01ac0002 			; <UNDEFINED> instruction: 0x01ac0002
     724:	01020000 	mrseq	r0, (UNDEF: 2)
     728:	000d0efb 	strdeq	r0, [sp], -fp
     72c:	01010101 	tsteq	r1, r1, lsl #2
     730:	01000000 	mrseq	r0, (UNDEF: 0)
     734:	63010000 	movwvs	r0, #4096	; 0x1000
     738:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
     73c:	6172676f 	cmnvs	r2, pc, ror #14
     740:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
     744:	2073656c 	rsbscs	r6, r3, ip, ror #10
     748:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
     74c:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
     750:	6f742075 	svcvs	0x00742075
     754:	20736c6f 	rsbscs	r6, r3, pc, ror #24
     758:	206d7261 	rsbcs	r7, sp, r1, ror #4
     75c:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
     760:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
     764:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
     768:	31303220 	teqcc	r0, r0, lsr #4
     76c:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
     770:	5c62696c 	stclpl	9, cr6, [r2], #-432	; 0xfffffe50
     774:	5c636367 	stclpl	3, cr6, [r3], #-412	; 0xfffffe64
     778:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     77c:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
     780:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     784:	2e345c69 	cdpcs	12, 3, cr5, cr4, cr9, {3}
     788:	5c342e38 	ldcpl	14, cr2, [r4], #-224	; 0xffffff20
     78c:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
     790:	00656475 	rsbeq	r6, r5, r5, ror r4
     794:	705c3a63 	subsvc	r3, ip, r3, ror #20
     798:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
     79c:	66206d61 	strtvs	r6, [r0], -r1, ror #26
     7a0:	73656c69 	cmnvc	r5, #26880	; 0x6900
     7a4:	38782820 	ldmdacc	r8!, {r5, fp, sp}^
     7a8:	675c2936 	smmlarvs	ip, r6, r9, r2
     7ac:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
     7b0:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
     7b4:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80
     7b8:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000
     7bc:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
     7c0:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}
     7c4:	30322038 	eorscc	r2, r2, r8, lsr r0
     7c8:	33713431 	cmncc	r1, #822083584	; 0x31000000
     7cc:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
     7d0:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
     7d4:	61652d65 	cmnvs	r5, r5, ror #26
     7d8:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^
     7dc:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
     7e0:	6d5c6564 	cfldr64vs	mvdx6, [ip, #-400]	; 0xfffffe70
     7e4:	69686361 	stmdbvs	r8!, {r0, r5, r6, r8, r9, sp, lr}^
     7e8:	6300656e 	movwvs	r6, #1390	; 0x56e
     7ec:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
     7f0:	6172676f 	cmnvs	r2, pc, ror #14
     7f4:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
     7f8:	2073656c 	rsbscs	r6, r3, ip, ror #10
     7fc:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
     800:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
     804:	6f742075 	svcvs	0x00742075
     808:	20736c6f 	rsbscs	r6, r3, pc, ror #24
     80c:	206d7261 	rsbcs	r7, sp, r1, ror #4
     810:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
     814:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
     818:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
     81c:	31303220 	teqcc	r0, r0, lsr #4
     820:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
     824:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     828:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
     82c:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     830:	6e695c69 	cdpvs	12, 6, cr5, cr9, cr9, {3}
     834:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
     838:	2f2e0065 	svccs	0x002e0065
     83c:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
     840:	696c5f32 	stmdbvs	ip!, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
     844:	68000062 	stmdavs	r0, {r1, r5, r6}
     848:	77647261 	strbvc	r7, [r4, -r1, ror #4]!
     84c:	2e657261 	cdpcs	2, 6, cr7, cr5, cr1, {3}
     850:	00000063 	andeq	r0, r0, r3, rrx
     854:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
     858:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
     85c:	00010068 	andeq	r0, r1, r8, rrx
     860:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
     864:	2e677261 	cdpcs	2, 6, cr7, cr7, cr1, {3}
     868:	00010068 	andeq	r0, r1, r8, rrx
     86c:	65645f00 	strbvs	r5, [r4, #-3840]!	; 0xf00
     870:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
     874:	79745f74 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
     878:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
     87c:	00020068 	andeq	r0, r2, r8, rrx
     880:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
     884:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
     888:	00030068 	andeq	r0, r3, r8, rrx
     88c:	6d747300 	ldclvs	3, cr7, [r4, #-0]
     890:	31663233 	cmncc	r6, r3, lsr r2
     894:	745f7830 	ldrbvc	r7, [pc], #-2096	; 89c <__Stack_Size+0x9c>
     898:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
     89c:	00040068 	andeq	r0, r4, r8, rrx
     8a0:	72616800 	rsbvc	r6, r1, #0, 16
     8a4:	72617764 	rsbvc	r7, r1, #100, 14	; 0x1900000
     8a8:	00682e65 	rsbeq	r2, r8, r5, ror #28
     8ac:	3c000000 	stccc	0, cr0, [r0], {-0}
     8b0:	6c697562 	cfstr64vs	mvdx7, [r9], #-392	; 0xfffffe78
     8b4:	6e692d74 	mcrvs	13, 3, r2, cr9, cr4, {3}
     8b8:	0000003e 	andeq	r0, r0, lr, lsr r0
     8bc:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
     8c0:	682e6f69 	stmdavs	lr!, {r0, r3, r5, r6, r8, r9, sl, fp, sp, lr}
     8c4:	00000300 	andeq	r0, r0, r0, lsl #6
     8c8:	2e627375 	mcrcs	3, 3, r7, cr2, cr5, {3}
     8cc:	00000068 	andeq	r0, r0, r8, rrx
     8d0:	05000000 	streq	r0, [r0, #-0]
     8d4:	00113802 	andseq	r3, r1, r2, lsl #16
     8d8:	01390300 	teqeq	r9, r0, lsl #6
     8dc:	024b3b14 	subeq	r3, fp, #20, 22	; 0x5000
     8e0:	01010004 	tsteq	r1, r4
     8e4:	4e020500 	cfsh32mi	mvfx0, mvfx2, #0
     8e8:	03000011 	movweq	r0, #17
     8ec:	5d14013e 	ldfpls	f0, [r4, #-248]	; 0xffffff08
     8f0:	01000402 	tsteq	r0, r2, lsl #8
     8f4:	02050001 	andeq	r0, r5, #1
     8f8:	00001160 	andeq	r1, r0, r0, ror #2
     8fc:	0100c803 	tsteq	r0, r3, lsl #16
     900:	3d493d2e 	stclcc	13, cr3, [r9, #-184]	; 0xffffff48
     904:	01040200 	mrseq	r0, R12_usr
     908:	00200631 	eoreq	r0, r0, r1, lsr r6
     90c:	06010402 	streq	r0, [r1], -r2, lsl #8
     910:	04020022 	streq	r0, [r2], #-34	; 0x22
     914:	02002202 	andeq	r2, r0, #536870912	; 0x20000000
     918:	331e0204 	tstcc	lr, #4, 4	; 0x40000000
     91c:	0402005a 	streq	r0, [r2], #-90	; 0x5a
     920:	00200601 	eoreq	r0, r0, r1, lsl #12
     924:	06020402 	streq	r0, [r2], -r2, lsl #8
     928:	04020022 	streq	r0, [r2], #-34	; 0x22
     92c:	02321e02 	eorseq	r1, r2, #2, 28
     930:	0101000a 	tsteq	r1, sl
     934:	b0020500 	andlt	r0, r2, r0, lsl #10
     938:	03000011 	movweq	r0, #17
     93c:	0001029f 	muleq	r1, pc, r2	; <UNPREDICTABLE>
     940:	13010402 	movwne	r0, #5122	; 0x1402
     944:	0002023d 	andeq	r0, r2, sp, lsr r2
     948:	05000101 	streq	r0, [r0, #-257]	; 0x101
     94c:	0011ba02 	andseq	fp, r1, r2, lsl #20
     950:	02a50300 	adceq	r0, r5, #0, 6
     954:	02002001 	andeq	r2, r0, #1
     958:	3e2f0104 	sufcce	f0, f7, f4
     95c:	0001024d 	andeq	r0, r1, sp, asr #4
     960:	05000101 	streq	r0, [r0, #-257]	; 0x101
     964:	0011d002 	andseq	sp, r1, r2
     968:	02ae0300 	adceq	r0, lr, #0, 6
     96c:	68223c01 	stmdavs	r2!, {r0, sl, fp, ip, sp}
     970:	0006024d 	andeq	r0, r6, sp, asr #4
     974:	05000101 	streq	r0, [r0, #-257]	; 0x101
     978:	0011f802 	andseq	pc, r1, r2, lsl #16
     97c:	02b80300 	adcseq	r0, r8, #0, 6
     980:	213e2e01 	teqcs	lr, r1, lsl #28
     984:	00050230 	andeq	r0, r5, r0, lsr r2
     988:	05000101 	streq	r0, [r0, #-257]	; 0x101
     98c:	00121402 	andseq	r1, r2, r2, lsl #8
     990:	02c00300 	sbceq	r0, r0, #0, 6
     994:	5a312e01 	bpl	c4c1a0 <_etext+0xc44b8c>
     998:	01040200 	mrseq	r0, R12_usr
     99c:	4c062006 	stcmi	0, cr2, [r6], {6}
     9a0:	01040200 	mrseq	r0, R12_usr
     9a4:	02002006 	andeq	r2, r0, #6
     9a8:	22060104 	andcs	r0, r6, #4, 2
     9ac:	01040200 	mrseq	r0, R12_usr
     9b0:	0402004b 	streq	r0, [r2], #-75	; 0x4b
     9b4:	02006801 	andeq	r6, r0, #65536	; 0x10000
     9b8:	003e0104 	eorseq	r0, lr, r4, lsl #2
     9bc:	3e010402 	cdpcc	4, 0, cr0, cr1, cr2, {0}
     9c0:	01040200 	mrseq	r0, R12_usr
     9c4:	0402004b 	streq	r0, [r2], #-75	; 0x4b
     9c8:	20740301 	rsbscs	r0, r4, r1, lsl #6
     9cc:	01040200 	mrseq	r0, R12_usr
     9d0:	a2200c03 	eorge	r0, r0, #768	; 0x300
     9d4:	4b200b03 	blmi	8035e8 <_etext+0x7fbfd4>
     9d8:	002e7603 	eoreq	r7, lr, r3, lsl #12
     9dc:	30010402 	andcc	r0, r1, r2, lsl #8
     9e0:	01040200 	mrseq	r0, R12_usr
     9e4:	0402004c 	streq	r0, [r2], #-76	; 0x4c
     9e8:	0f023001 	svceq	0x00023001
     9ec:	00010100 	andeq	r0, r1, r0, lsl #2
     9f0:	12b00205 	adcsne	r0, r0, #1342177280	; 0x50000000
     9f4:	e4030000 	str	r0, [r3], #-0
     9f8:	22200102 	eorcs	r0, r0, #-2147483648	; 0x80000000
     9fc:	01040200 	mrseq	r0, R12_usr
     a00:	04020021 	streq	r0, [r2], #-33	; 0x21
     a04:	02002d01 	andeq	r2, r0, #1, 26	; 0x40
     a08:	00210104 	eoreq	r0, r1, r4, lsl #2
     a0c:	2d010402 	cfstrscs	mvf0, [r1, #-8]
     a10:	01040200 	mrseq	r0, R12_usr
     a14:	04020030 	streq	r0, [r2], #-48	; 0x30
     a18:	02002f01 	andeq	r2, r0, #1, 30
     a1c:	022d0104 	eoreq	r0, sp, #4, 2
     a20:	01010006 	tsteq	r1, r6
     a24:	d8020500 	stmdale	r2, {r8, sl}
     a28:	03000012 	movweq	r0, #18
     a2c:	270102ec 	strcs	r0, [r1, -ip, ror #5]
     a30:	26207903 	strtcs	r7, [r0], -r3, lsl #18
     a34:	3e4b4e59 	mcrcc	14, 2, r4, cr11, cr9, {2}
     a38:	2f1f211f 	svccs	0x001f211f
     a3c:	3b214b31 	blcc	853708 <_etext+0x84c0f4>
     a40:	0343312f 	movteq	r3, #12591	; 0x312f
     a44:	2f3d2e7a 	svccs	0x003d2e7a
     a48:	221e312f 	andscs	r3, lr, #-1073741813	; 0xc000000b
     a4c:	4b31301e 	blmi	c4cacc <_etext+0xc454b8>
     a50:	01000502 	tsteq	r0, r2, lsl #10
     a54:	02050001 	andeq	r0, r5, #1
     a58:	00001360 	andeq	r1, r0, r0, ror #6
     a5c:	01038f03 	tsteq	r3, r3, lsl #30
     a60:	4b1f2113 	blmi	7c8eb4 <_etext+0x7c18a0>
     a64:	4c4b674b 	mcrrmi	7, 4, r6, fp, cr11
     a68:	01000c02 	tsteq	r0, r2, lsl #24
     a6c:	02050001 	andeq	r0, r5, #1
     a70:	000013a8 	andeq	r1, r0, r8, lsr #7
     a74:	01039903 	tsteq	r3, r3, lsl #18
     a78:	04020015 	streq	r0, [r2], #-21
     a7c:	424d5901 	submi	r5, sp, #16384	; 0x4000
     a80:	04020085 	streq	r0, [r2], #-133	; 0x85
     a84:	0b035101 	bleq	d4e90 <_etext+0xcd87c>
     a88:	0402004a 	streq	r0, [r2], #-74	; 0x4a
     a8c:	4b3e4b01 	blmi	f93698 <_etext+0xf8c084>
     a90:	01000902 	tsteq	r0, r2, lsl #18
     a94:	02050001 	andeq	r0, r5, #1
     a98:	00001408 	andeq	r1, r0, r8, lsl #8
     a9c:	0103c303 	tsteq	r3, r3, lsl #6
     aa0:	000a0213 	andeq	r0, sl, r3, lsl r2
     aa4:	05000101 	streq	r0, [r0, #-257]	; 0x101
     aa8:	00141c02 	andseq	r1, r4, r2, lsl #24
     aac:	03c70300 	biceq	r0, r7, #0, 6
     ab0:	214b1401 	cmpcs	fp, r1, lsl #8
     ab4:	0402002f 	streq	r0, [r2], #-47	; 0x2f
     ab8:	023d2401 	eorseq	r2, sp, #16777216	; 0x1000000
     abc:	01010003 	tsteq	r1, r3
     ac0:	00020500 	andeq	r0, r2, r0, lsl #10
     ac4:	03000000 	movweq	r0, #0
     ac8:	200103d5 	ldrdcs	r0, [r1], -r5
     acc:	0219083f 	andseq	r0, r9, #4128768	; 0x3f0000
     ad0:	01010002 	tsteq	r1, r2
     ad4:	38020500 	stmdacc	r2, {r8, sl}
     ad8:	03000014 	movweq	r0, #20
     adc:	030103e1 	movweq	r0, #5089	; 0x13e1
     ae0:	77030109 	strvc	r0, [r3, -r9, lsl #2]
     ae4:	23242520 	teqcs	r4, #32, 10	; 0x8000000
     ae8:	0502311f 	streq	r3, [r2, #-287]	; 0x11f
     aec:	00010100 	andeq	r0, r1, r0, lsl #2
     af0:	00000205 	andeq	r0, r0, r5, lsl #4
     af4:	88030000 	stmdahi	r3, {}	; <UNPREDICTABLE>
     af8:	5b140104 	blpl	500f10 <_etext+0x4f98fc>
     afc:	09023169 	stmdbeq	r2, {r0, r3, r5, r6, r8, ip, sp}
     b00:	00010100 	andeq	r0, r1, r0, lsl #2
     b04:	00000205 	andeq	r0, r0, r5, lsl #4
     b08:	97030000 	strls	r0, [r3, -r0]
     b0c:	22240104 	eorcs	r0, r4, #4, 2
     b10:	368b5a2c 	strcc	r5, [fp], ip, lsr #20
     b14:	4d3e2631 	ldcmi	6, cr2, [lr, #-196]!	; 0xffffff3c
     b18:	01000602 	tsteq	r0, r2, lsl #12
     b1c:	02050001 	andeq	r0, r5, #1
     b20:	00001450 	andeq	r1, r0, r0, asr r4
     b24:	0104b003 	tsteq	r4, r3
     b28:	03010c03 	movweq	r0, #7171	; 0x1c03
     b2c:	0c032074 	stceq	0, cr2, [r3], {116}	; 0x74
     b30:	3d1c2420 	cfldrscc	mvf2, [ip, #-128]	; 0xffffff80
     b34:	23312c31 	teqcs	r1, #12544	; 0x3100
     b38:	243b311d 	ldrtcs	r3, [fp], #-285	; 0x11d
     b3c:	3073231d 	rsbscc	r2, r3, sp, lsl r3
     b40:	3122212f 	teqcc	r2, pc, lsr #2
     b44:	49211f21 	stmdbmi	r1!, {r0, r5, r8, r9, sl, fp, ip}
     b48:	01000902 	tsteq	r0, r2, lsl #18
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	02050001 	andeq	r0, r5, #1
  b	LoopCopyDataInit
     b50:	000014bc 			; <UNDEFINED> instruction: 0x000014bc

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
     b54:	0104d303 	tsteq	r4, r3, lsl #6
	str	r3, [r0, r1]
	adds	r1, r1, #4
     b58:	2f2f5914 	svccs	0x002f5914

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
     b5c:	00070230 	andeq	r0, r7, r0, lsr r2
	adds	r2, r0, r1
	cmp	r2, r3
     b60:	05000101 	streq	r0, [r0, #-257]	; 0x101
	bcc	CopyDataInit
     b64:	0014e002 	andseq	lr, r4, r2
	ldr	r2, =_sbss
	b	LoopFillZerobss
     b68:	03f30300 	mvnseq	r0, #0, 6
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	2f272001 	svccs	0x00272001
	str	r3, [r2], #4
     b70:	21303231 	teqcs	r0, r1, lsr r2

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
     b74:	0002022d 	andeq	r0, r2, sp, lsr #4
	bcc	FillZerobss
     b78:	05000101 	streq	r0, [r0, #-257]	; 0x101
/* Call the application's entry point.*/
	bl	main
     b7c:	00150002 	andseq	r0, r5, r2
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	04dd0300 	ldrbeq	r0, [sp], #768	; 0x300
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	02001601 	andeq	r1, r0, #1048576	; 0x100000
	ldr	r3, =_edata
     b88:	02400104 	subeq	r0, r0, #4, 2
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	01010007 	tsteq	r1, r7
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	14020500 	strne	r0, [r2], #-1280	; 0x500
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	03000015 	movweq	r0, #21
}


/* dummy proc */
void nothingProc(void)
{
     b98:	130104e9 	movwne	r0, #5353	; 0x14e9
{
    return;
}

void usbStatusOut(void)
{
     b9c:	0022211f 	eoreq	r2, r2, pc, lsl r1
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
     ba0:	30010402 	andcc	r0, r1, r2, lsl #8
     ba4:	02002167 	andeq	r2, r0, #-1073741799	; 0xc0000019
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	4f2f0104 	svcmi	0x002f0104
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	00070223 	andeq	r0, r7, r3, lsr #4
     bb0:	05000101 	streq	r0, [r0, #-257]	; 0x101
        bDeviceState = CONFIGURED;
     bb4:	00000002 	andeq	r0, r0, r2
     bb8:	04fa0300 	ldrbteq	r0, [sl], #768	; 0x300
     bbc:	02002e01 	andeq	r2, r0, #1, 28
     bc0:	4b2f0104 	blmi	bc0fd8 <_etext+0xbb99c4>
    }
}

void usbGetInterface(void)
{
     bc4:	040221b1 	streq	r2, [r2], #-433	; 0x1b1
{
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	00010100 	andeq	r0, r1, r0, lsl #2
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	15480205 	strbne	r0, [r8, #-517]	; 0x205
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	84030000 	strhi	r0, [r3], #-0
     bd4:	2f220105 	svccs	0x00220105
     bd8:	211f2130 	tstcs	pc, r0, lsr r1	; <UNPREDICTABLE>
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	01040200 	mrseq	r0, R12_usr
    dfuUpdateByReset();
     be0:	02004b24 	andeq	r4, r0, #36, 22	; 0x9000

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	3d3d0104 	ldfccs	f0, [sp, #-16]!

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be8:	01040200 	mrseq	r0, R12_usr
     bec:	232f3e3d 	teqcs	pc, #976	; 0x3d0
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	00090225 	andeq	r0, r9, r5, lsr #4
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	05000101 	streq	r0, [r0, #-257]	; 0x101
     bf8:	00159402 	andseq	r9, r5, r2, lsl #8

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfc:	059f0300 	ldreq	r0, [pc, #768]	; f04 <usbEnbISR+0xc>
     c00:	06021601 	streq	r1, [r2], -r1, lsl #12
     c04:	00010100 	andeq	r0, r1, r0, lsl #2
     c08:	15a00205 	strne	r0, [r0, #517]!	; 0x205
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c0c:	a6030000 	strge	r0, [r3], -r0
     c10:	3d140105 	ldfccs	f0, [r4, #-20]	; 0xffffffec
     c14:	01000902 	tsteq	r0, r2, lsl #18
     c18:	02050001 	andeq	r0, r5, #1
     c1c:	000015b8 			; <UNDEFINED> instruction: 0x000015b8

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c20:	0105af03 	tsteq	r5, r3, lsl #30
     c24:	4c302214 	lfmmi	f2, 4, [r0], #-80	; 0xffffffb0
     c28:	01000202 	tsteq	r0, r2, lsl #4
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	02050001 	andeq	r0, r5, #1
     c30:	000015cc 	andeq	r1, r0, ip, asr #11
     c34:	0105bb03 	tsteq	r5, r3, lsl #22
     c38:	04024b14 	streq	r4, [r2], #-2836	; 0xb14
     c3c:	00010100 	andeq	r0, r1, r0, lsl #2

    Clear_Status_Out(ENDP0);
     c40:	15dc0205 	ldrbne	r0, [ip, #517]	; 0x205

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c44:	c1030000 	mrsgt	r0, (UNDEF: 3)
     c48:	30150105 	andscc	r0, r5, r5, lsl #2
     c4c:	00090226 	andeq	r0, r9, r6, lsr #4
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	03b80101 			; <UNDEFINED> instruction: 0x03b80101
     c54:	00020000 	andeq	r0, r2, r0

    bDeviceState = ATTACHED;
     c58:	000001dc 	ldrdeq	r0, [r0], -ip
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
     c5c:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	0101000d 	tsteq	r1, sp
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c64:	00000101 	andeq	r0, r0, r1, lsl #2
     c68:	00000100 	andeq	r0, r0, r0, lsl #2
     c6c:	5c3a6301 	ldcpl	3, cr6, [sl], #-4
     c70:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
     c74:	206d6172 	rsbcs	r6, sp, r2, ror r1
     c78:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966
     c7c:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
     c80:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	20756e67 	rsbscs	r6, r5, r7, ror #28
     c88:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; ac0 <USART_IrDACmd>
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8c:	72612073 	rsbvc	r2, r1, #115	; 0x73
     c90:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c
     c94:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
        if (dfuUpdateByRequest()) {
     c98:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465
     c9c:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
            // successfull state transition, handle the request
            switch (request) {
     ca0:	71343130 	teqvc	r4, r0, lsr r1
     ca4:	72615c33 	rsbvc	r5, r1, #13056	; 0x3300
     ca8:	6f6e2d6d 	svcvs	0x006e2d6d
     cac:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
     cb4:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
     cb8:	5c656475 	cfstrdpl	mvd6, [r5], #-468	; 0xfffffe2c
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	6863616d 	stmdavs	r3!, {r0, r2, r3, r5, r6, r8, sp, lr}^
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
     cc0:	00656e69 	rsbeq	r6, r5, r9, ror #28
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	705c3a63 	subsvc	r3, ip, r3, ror #20
        (*CopyRoutine)(0);

        return USB_SUCCESS;
     cc8:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
    }

    return USB_UNSUPPORT;
     ccc:	66206d61 	strtvs	r6, [r0], -r1, ror #26
}
     cd0:	73656c69 	cmnvc	r5, #26880	; 0x6900
     cd4:	38782820 	ldmdacc	r8!, {r5, fp, sp}^
     cd8:	675c2936 	smmlarvs	ip, r6, r9, r2
     cdc:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
     ce0:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80
     ce8:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000
     cec:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}
     cf4:	30322038 	eorscc	r2, r2, r8, lsr r0
     cf8:	33713431 	cmncc	r1, #822083584	; 0x31000000
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
     d00:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    if (strIndex > STR_DESC_LEN) {
     d04:	61652d65 	cmnvs	r5, r5, ror #26
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d08:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^
     d0c:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    }
}
     d10:	2e006564 	cfsh32cs	mvfx6, mvfx0, #52
     d14:	6d74732f 	ldclvs	3, cr7, [r4, #-188]!	; 0xffffff44
     d18:	6c5f3233 	lfmvs	f3, 2, [pc], {51}	; 0x33

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
     d1c:	63006269 	movwvs	r6, #617	; 0x269
     d20:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
     d24:	6172676f 	cmnvs	r2, pc, ror #14

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2c:	2073656c 	rsbscs	r6, r3, ip, ror #10
     d30:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
     d34:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	6f742075 	svcvs	0x00742075
     d3c:	20736c6f 	rsbscs	r6, r3, pc, ror #24
            return USB_SUCCESS;
     d40:	206d7261 	rsbcs	r7, sp, r1, ror #4
     d44:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
        }
    }
    return USB_UNSUPPORT;
}
     d48:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
     d4c:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	31303220 	teqcc	r0, r0, lsr #4
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d54:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	5c62696c 	stclpl	9, cr6, [r2], #-432	; 0xfffffe50
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5c:	5c636367 	stclpl	3, cr6, [r3], #-412	; 0xfffffe64
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d60:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
     d64:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
     d68:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
     d6c:	2e345c69 	cdpcs	12, 3, cr5, cr4, cr9, {3}
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d70:	5c342e38 	ldcpl	14, cr2, [r4], #-224	; 0xffffff20
     d74:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
     d78:	00656475 	rsbeq	r6, r5, r5, ror r4
     d7c:	73752f2e 	cmnvc	r5, #46, 30	; 0xb8
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d80:	696c5f62 	stmdbvs	ip!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	2f2e0062 	svccs	0x002e0062
     d88:	31353532 	teqcc	r5, r2, lsr r5
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8c:	64000039 	strvs	r0, [r0], #-57	; 0x39
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d90:	632e7566 	teqvs	lr, #427819008	; 0x19800000
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d94:	00000000 	andeq	r0, r0, r0
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d98:	6665645f 			; <UNDEFINED> instruction: 0x6665645f

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	746c7561 	strbtvc	r7, [ip], #-1377	; 0x561
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	7079745f 	rsbsvc	r7, r9, pc, asr r4
     da4:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
     da8:	00000100 	andeq	r0, r0, r0, lsl #2
     dac:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
     db0:	682e746e 	stmdavs	lr!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
     db4:	00000200 	andeq	r0, r0, r0, lsl #4
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
     dbc:	30316632 	eorscc	r6, r1, r2, lsr r6
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dc0:	79745f78 	ldmdbvc	r4!, {r3, r4, r5, r6, r8, r9, sl, fp, ip, lr}^

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	682e6570 	stmdavs	lr!, {r4, r5, r6, r8, sl, sp, lr}
     dc8:	00000300 	andeq	r0, r0, r0, lsl #6
     dcc:	64647473 	strbtvs	r7, [r4], #-1139	; 0x473
     dd0:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	00000400 	andeq	r0, r0, r0, lsl #8
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd8:	5f627375 	svcpl	0x00627375
     ddc:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xf63

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	0500682e 	streq	r6, [r0, #-2094]	; 0x82e
     de4:	66640000 	strbtvs	r0, [r4], -r0
     de8:	00682e75 	rsbeq	r2, r8, r5, ror lr
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	73000000 	movwvc	r0, #0
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	35326168 	ldrcc	r6, [r2, #-360]!	; 0x168
        ResumeS.eState = eResumeSetVal;
     df4:	00682e36 	rsbeq	r2, r8, r6, lsr lr

    switch (ResumeS.eState) {
     df8:	69000006 	stmdbvs	r0, {r1, r2}
     dfc:	6567616d 	strbvs	r6, [r7, #-365]!	; 0x16d
     e00:	0000682e 	andeq	r6, r0, lr, lsr #16
     e04:	73750000 	cmnvc	r5, #0
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	6e695f62 	cdpvs	15, 6, cr5, cr9, cr2, {3}
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	682e7469 	stmdavs	lr!, {r0, r3, r5, r6, sl, ip, sp, lr}
        ResumeS.eState = RESUME_START;
     e10:	00000500 	andeq	r0, r0, r0, lsl #10
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	2e627375 	mcrcs	3, 3, r7, cr2, cr5, {3}
        ResumeS.eState = RESUME_WAIT;
     e18:	00000068 	andeq	r0, r0, r8, rrx
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	72616800 	rsbvc	r6, r1, #0, 16
     e20:	72617764 	rsbvc	r7, r1, #100, 14	; 0x1900000
        if (ResumeS.bESOFcnt == 0)
     e24:	00682e65 	rsbeq	r2, r8, r5, ror #28
            ResumeS.eState = RESUME_START;
     e28:	73000000 	movwvc	r0, #0
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
     e30:	00682e67 	rsbeq	r2, r8, r7, ror #28
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e34:	00000002 	andeq	r0, r0, r2
        ResumeS.eState = RESUME_ON;
     e38:	f4020500 	vst3.8	{d0,d2,d4}, [r2], r0
        ResumeS.bESOFcnt = 10;
     e3c:	03000015 	movweq	r0, #21
        break;
     e40:	1f13013c 	svcne	0x0013013c
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e44:	212f1c25 	teqcs	pc, r5, lsr #24
     e48:	21212121 	teqcs	r1, r1, lsr #2
        if (ResumeS.bESOFcnt == 0) {
     e4c:	26211e22 	strtcs	r1, [r1], -r2, lsr #28
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	21207a03 	teqcs	r0, r3, lsl #20
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	1f214b2f 	svcne	0x00214b2f
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e58:	1f212f21 	svcne	0x00212f21
            ResumeS.eState = RESUME_OFF;
     e5c:	2d5b3d21 	ldclcs	13, cr3, [fp, #-132]	; 0xffffff7c
     e60:	01001c02 	tsteq	r0, r2, lsl #24
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e64:	02050001 	andeq	r0, r5, #1
     e68:	0000167c 	andeq	r1, r0, ip, ror r6
     e6c:	01038703 	tsteq	r3, r3, lsl #14
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	211f2121 	tstcs	pc, r1, lsr #2
     e74:	221e231f 	andscs	r2, lr, #2080374784	; 0x7c000000
     e78:	03222f21 	teqeq	r2, #33, 30	; 0x84
     e7c:	74032e0d 	strvc	r2, [r3], #-3597	; 0xe0d

    _SetCNTR(CNTR_FRES);
     e80:	2f422f2e 	svccs	0x00422f2e
     e84:	08022c24 	stmdaeq	r2, {r2, r5, sl, fp, sp}
     e88:	00010100 	andeq	r0, r1, r0, lsl #2
     e8c:	00000205 	andeq	r0, r0, r5, lsl #4
    _SetCNTR(0);
    _SetISTR(0);
     e90:	9e030000 	cdpls	0, 0, cr0, cr3, cr0, {0}

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e94:	01020103 	tsteq	r2, r3, lsl #2
    _SetCNTR(wInterrupt_Mask);
     e98:	00010100 	andeq	r0, r1, r0, lsl #2
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9c:	16c00205 	strbne	r0, [r0], r5, lsl #4
     ea0:	a1030000 	mrsge	r0, (UNDEF: 3)
#endif
#endif

    return USB_SUCCESS;
}
     ea4:	21130103 	tstcs	r3, r3, lsl #2
     ea8:	0222224b 	eoreq	r2, r2, #-1342177276	; 0xb0000004
     eac:	01010005 	tsteq	r1, r5
     eb0:	d8020500 	stmdale	r2, {r8, sl}
     eb4:	03000016 	movweq	r0, #22

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	130103aa 	movwne	r0, #5034	; 0x13aa
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	22224b21 	eorcs	r4, r2, #33792	; 0x8400
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
     ec0:	01000502 	tsteq	r0, r2, lsl #10
     ec4:	02050001 	andeq	r0, r5, #1
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec8:	000016f0 	strdeq	r1, [r0], -r0
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     ecc:	0103b403 	tsteq	r3, r3, lsl #8
     ed0:	4b211f22 	blmi	848b60 <_etext+0x84154c>
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	023e222f 	eorseq	r2, lr, #-268435454	; 0xf0000002
     ed8:	01010007 	tsteq	r1, r7
     edc:	18020500 	stmdane	r2, {r8, sl}

    return USB_SUCCESS;
}
     ee0:	03000017 	movweq	r0, #23
     ee4:	210103be 			; <UNDEFINED> instruction: 0x210103be
     ee8:	84226721 	strthi	r6, [r2], #-1825	; 0x721
     eec:	01000902 	tsteq	r0, r2, lsl #18
     ef0:	02050001 	andeq	r0, r5, #1
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	0000174c 	andeq	r1, r0, ip, asr #14
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	0103c703 	tsteq	r3, r3, lsl #14
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efc:	3d201303 	stccc	3, cr1, [r0, #-12]!
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	315b211f 	cmpcc	fp, pc, lsl r1
     f04:	0402003e 	streq	r0, [r2], #-62	; 0x3e
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f08:	00200601 	eoreq	r0, r0, r1, lsl #12
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	06020402 	streq	r0, [r2], -r2, lsl #8
     f10:	0402005d 	streq	r0, [r2], #-93	; 0x5d
    nvicInit(&NVIC_InitStructure);
     f14:	59365302 	ldmdbpl	r6!, {r1, r8, r9, ip, lr}
}
     f18:	01000c02 	tsteq	r0, r2, lsl #24

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	02050001 	andeq	r0, r5, #1
    dfuInit();
     f20:	000017a8 	andeq	r1, r0, r8, lsr #15

    pInformation->Current_Configuration = 0;
     f24:	0100d003 	tsteq	r0, r3
     f28:	301e2231 	andscc	r2, lr, r1, lsr r2
    usbPowerOn();
     f2c:	1c251f21 	stcne	15, cr1, [r5], #-132	; 0xffffff7c

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
     f30:	59222224 	stmdbpl	r2!, {r2, r5, r9, sp}
     f34:	211f304b 	tstcs	pc, fp, asr #32
     f38:	1803211f 	stmdane	r3, {r0, r1, r2, r3, r4, r8, sp}
    _SetCNTR(wInterrupt_Mask);
     f3c:	71033d3c 	tstvc	r3, ip, lsr sp

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f40:	11033d4a 	tstne	r3, sl, asr #26
    bDeviceState = UNCONNECTED;
     f44:	24302f3c 	ldrtcs	r2, [r0], #-3900	; 0xf3c
     f48:	2f3c0903 	svccs	0x003c0903
     f4c:	684d3d32 	stmdavs	sp, {r1, r4, r5, r8, sl, fp, ip, sp}^
     f50:	29580d03 	ldmdbcs	r8, {r0, r1, r8, sl, fp}^
     f54:	264b2f25 	strbcs	r2, [fp], -r5, lsr #30
     f58:	3031312f 	eorscc	r3, r1, pc, lsr #2
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	1d033035 	stcne	0, cr3, [r3, #-212]	; 0xffffff2c
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f60:	343f2f58 	ldrtcc	r2, [pc], #-3928	; f68 <usbDsbISR+0xc>
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	211f4d30 	tstcs	pc, r0, lsr sp	; <UNPREDICTABLE>

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f68:	59304021 	ldmdbpl	r0!, {r0, r5, lr}
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	1e03312f 	adfnesp	f3, f3, #10.0
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	2e620320 	cdpcs	3, 6, cr0, cr2, cr0, {1}
    nvicInit(&NVIC_InitStructure);
     f74:	32201e03 	eorcc	r1, r0, #3, 28	; 0x30
}
     f78:	3e423377 	mcrcc	3, 2, r3, cr2, cr7, {3}
     f7c:	30433030 	subcc	r3, r3, r0, lsr r0

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	422f2f59 	eormi	r2, pc, #356	; 0x164
    wIstr = _GetISTR();
     f84:	59303434 	ldmdbpl	r0!, {r2, r4, r5, sl, ip, sp}

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	3d1f3d30 	ldccc	13, cr3, [pc, #-192]	; ed0 <usbPowerOff+0x18>
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8c:	4fc9211f 	svcmi	0x00c9211f

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f90:	2f424b77 	svccs	0x00424b77
     f94:	302f2f30 	eorcc	r2, pc, r0, lsr pc	; <UNPREDICTABLE>
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	5a30332f 	bpl	c0dc5c <_etext+0xc06648>
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	2f30302f 	svccs	0x0030302f
     fa0:	21312f35 	teqcs	r1, r5, lsr pc
     fa4:	01002402 	tsteq	r0, r2, lsl #8
        _SetISTR((u16)CLR_RESET);
     fa8:	02050001 	andeq	r0, r5, #1
        Device_Property.Reset();
     fac:	00000000 	andeq	r0, r0, r0
     fb0:	0103f003 	tsteq	r3, r3
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb4:	04022f13 	streq	r2, [r2], #-3859	; 0xf13
     fb8:	00010100 	andeq	r0, r1, r0, lsl #2
        _SetISTR((u16)CLR_ERR);
     fbc:	00000205 	andeq	r0, r0, r5, lsl #4
     fc0:	f5030000 			; <UNDEFINED> instruction: 0xf5030000
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc4:	02130103 	andseq	r0, r3, #-1073741824	; 0xc0000000
     fc8:	01010006 	tsteq	r1, r6
        _SetISTR((u16)CLR_WKUP);
     fcc:	fc020500 	stc2	5, cr0, [r2], {-0}
        usbResume(RESUME_EXTERNAL);
     fd0:	03000019 	movweq	r0, #25
     fd4:	130103fa 	movwne	r0, #5114	; 0x13fa
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd8:	0004022f 	andeq	r0, r4, pc, lsr #4
     fdc:	05000101 	streq	r0, [r0, #-257]	; 0x101

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	00000002 	andeq	r0, r0, r2
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	03ff0300 	mvnseq	r0, #0, 6
     fe8:	002f1301 	eoreq	r1, pc, r1, lsl #6
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fec:	06010402 	streq	r0, [r1], -r2, lsl #8
     ff0:	2106662e 	tstcs	r6, lr, lsr #12
        _SetISTR((u16)CLR_SOF);
     ff4:	01000302 	tsteq	r0, r2, lsl #6
     ff8:	02050001 	andeq	r0, r5, #1
        bIntPackSOF++;
     ffc:	00001a08 	andeq	r1, r0, r8, lsl #20
    1000:	01048403 	tsteq	r4, r3, lsl #8
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	01040200 	mrseq	r0, R12_usr
    1008:	00010216 	andeq	r0, r1, r6, lsl r2
        _SetISTR((u16)CLR_ESOF);
    100c:	024f0101 	subeq	r0, pc, #1073741824	; 0x40000000
    1010:	00020000 	andeq	r0, r2, r0
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    }
#endif

}
    1014:	000000f7 	strdeq	r0, [r0], -r7
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    101c:	0101000d 	tsteq	r1, sp
    1020:	00000101 	andeq	r0, r0, r1, lsl #2
    1024:	00000100 	andeq	r0, r0, r0, lsl #2
    1028:	35353201 	ldrcc	r3, [r5, #-513]!	; 0x201
    102c:	63003931 	movwvs	r3, #2353	; 0x931
    1030:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
    1034:	6172676f 	cmnvs	r2, pc, ror #14
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    1038:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
    setupCLK();
    103c:	2073656c 	rsbscs	r6, r3, ip, ror #10
    setupLEDAndButton();
    1040:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
    setupUSB();
    1044:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
    setupFLASH();
    1048:	6f742075 	svcvs	0x00742075
    uartInit();
    104c:	20736c6f 	rsbscs	r6, r3, pc, ror #24
    usbReset();
    1050:	206d7261 	rsbcs	r7, sp, r1, ror #4
	uart_printf("\nBootloader init...\n");
    1054:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
    1058:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464

    if (readPin(GPIOB, 15) == 0x0)
    105c:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    1060:	31303220 	teqcc	r0, r0, lsr #4
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1064:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
    1068:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    106c:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
    1070:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    1074:	6e695c69 	cdpvs	12, 6, cr5, cr9, cr9, {3}
    
    debug_print("image check ret: %X\n", ret);
    1078:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
    107c:	616d5c65 	cmnvs	sp, r5, ror #24
	switch (ret)
    1080:	6e696863 	cdpvs	8, 6, cr6, cr9, cr3, {3}
    1084:	3a630065 	bcc	18c1220 <_etext+0x18b9c0c>
    1088:	6f72705c 	svcvs	0x0072705c

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
	bool no_user_jump = FALSE;
    108c:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64
    1090:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
    1094:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1098:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
			no_user_jump = FALSE;
    109c:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
			break;

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    10a0:	6f6f7420 	svcvs	0x006f7420
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    10a4:	6120736c 	teqvs	r0, ip, ror #6
			no_user_jump = TRUE;
			break;

		case kImageImageHashCalcFailed:
			uart_printf("Hash calculation failed... waiting in DFU\n");
    10a8:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
    10ac:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
			break;
			
		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10b0:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
    10b4:	20382e34 	eorscs	r2, r8, r4, lsr lr
    10b8:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
    10bc:	615c3371 	cmpvs	ip, r1, ror r3
    10c0:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10c4:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10c8:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    10cc:	636e695c 	cmnvs	lr, #92, 18	; 0x170000
    10d0:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
    10d4:	32630000 	rsbcc	r0, r3, #0
    10d8:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}

		if (dfuUploadStarted()) 
    10dc:	0100632e 	tsteq	r0, lr, lsr #6
		{
			uart_printf("DFU finished upload\n");
    10e0:	32660000 	rsbcc	r0, r6, #0
    10e4:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
			dfuFinishUpload(); // systemHardReset from DFU once done
    10e8:	0100682e 	tsteq	r0, lr, lsr #16
    10ec:	645f0000 	ldrbvs	r0, [pc], #-0	; 10f4 <main+0xc0>
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10f0:	75616665 	strbvc	r6, [r1, #-1637]!	; 0x665
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10f4:	745f746c 	ldrbvc	r7, [pc], #-1132	; 10fc <main+0xc8>
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10f8:	73657079 	cmnvc	r5, #121	; 0x79
    10fc:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
	}
	
	return 0;// Added to please the compiler
    1100:	74730000 	ldrbtvc	r0, [r3], #-0
    1104:	746e6964 	strbtvc	r6, [lr], #-2404	; 0x964
    1108:	0300682e 	movweq	r6, #2094	; 0x82e
    110c:	00000000 	andeq	r0, r0, r0
    1110:	00000205 	andeq	r0, r0, r5, lsl #4
    1114:	d3030000 	movwle	r0, #12288	; 0x3000
    1118:	02040100 	andeq	r0, r4, #0, 2
    111c:	044a5003 	strbeq	r5, [sl], #-3
    1120:	20300301 	eorscs	r0, r0, r1, lsl #6
    1124:	50030204 	andpl	r0, r3, r4, lsl #4
    1128:	0301042e 	movweq	r0, #5166	; 0x142e
    112c:	02043c33 	andeq	r3, r4, #13056	; 0x3300
    1130:	043c4d03 	ldrteq	r4, [ip], #-3331	; 0xd03
    1134:	20330301 	eorscs	r0, r3, r1, lsl #6
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1138:	75691d23 	strbvc	r1, [r9, #-3363]!	; 0xd23
    113c:	02043f7e 	andeq	r3, r4, #504	; 0x1f8
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    1140:	042e4a03 	strteq	r4, [lr], #-2563	; 0xa03
    1144:	663e0301 	ldrtvs	r0, [lr], -r1, lsl #6
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1148:	42030204 	andmi	r0, r3, #4, 4	; 0x40000000
    114c:	00010420 	andeq	r0, r1, r0, lsr #8
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    1150:	03020402 	movweq	r0, #9218	; 0x2402
    1154:	02002e3f 	andeq	r2, r0, #1008	; 0x3f0
        return TRUE;
    } else {
        return FALSE;
    }
}
    1158:	5f030204 	svcpl	0x00030204
    115c:	0402002e 	streq	r0, [r2], #-46	; 0x2e

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	20210302 	eorcs	r0, r1, r2, lsl #6
    1164:	02040200 	andeq	r0, r4, #0, 4
    1168:	002e5f03 	eoreq	r5, lr, r3, lsl #30
    gpio_write_bit( bank,pin,1-onState);
    116c:	03020402 	movweq	r0, #9218	; 0x2402
    1170:	02002e21 	andeq	r2, r0, #528	; 0x210
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1174:	5f030204 	svcpl	0x00030204
    gpio_write_bit( bank,pin,1-onState);
    1178:	04020020 	streq	r0, [r2], #-32

    u32 c;
    while (count-- > 0) 
    117c:	02002f02 	andeq	r2, r0, #2, 30
	{
        for (c = rate; c > 0; c--)
    1180:	00590204 	subseq	r0, r9, r4, lsl #4
    1184:	5a020402 	bpl	82194 <_etext+0x7ab80>
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1188:	02040200 	andeq	r0, r4, #0, 4
    118c:	04020059 	streq	r0, [r2], #-89	; 0x59
    1190:	02005902 	andeq	r5, r0, #32768	; 0x8000
		
        for (c = rate; c > 0; c--)
    1194:	005a0204 	subseq	r0, sl, r4, lsl #4
    1198:	59020402 	stmdbpl	r2, {r1, sl}
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    119c:	02040200 	andeq	r0, r4, #0, 4
    11a0:	04020059 	streq	r0, [r2], #-89	; 0x59
    11a4:	02005a02 	andeq	r5, r0, #8192	; 0x2000
    11a8:	00590204 	subseq	r0, r9, r4, lsl #4
    11ac:	59020402 	stmdbpl	r2, {r1, sl}

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    11b0:	02040200 	andeq	r0, r4, #0, 4
    11b4:	00584b03 	subseq	r4, r8, r3, lsl #22
  USARTx->DR = ch;  
    11b8:	59020402 	stmdbpl	r2, {r1, sl}
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11bc:	02040200 	andeq	r0, r4, #0, 4
  while(*str != 0)
    11c0:	04020059 	streq	r0, [r2], #-89	; 0x59
    11c4:	02005a02 	andeq	r5, r0, #8192	; 0x2000
  {
    UU_PutChar(USARTx, *str);
    11c8:	00590204 	subseq	r0, r9, r4, lsl #4
    11cc:	5a020402 	bpl	821dc <_etext+0x7abc8>
    str++;
  }
}

void vprint(const char *fmt, va_list argp)
{
    11d0:	02040200 	andeq	r0, r4, #0, 4
    11d4:	04020059 	streq	r0, [r2], #-89	; 0x59
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11d8:	02005902 	andeq	r5, r0, #32768	; 0x8000
    11dc:	00590204 	subseq	r0, r9, r4, lsl #4
    11e0:	59020402 	stmdbpl	r2, {r1, sl}
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11e4:	02040200 	andeq	r0, r4, #0, 4
    11e8:	00581c03 	subseq	r1, r8, r3, lsl #24

    }
}
    11ec:	59020402 	stmdbpl	r2, {r1, sl}
    11f0:	02040200 	andeq	r0, r4, #0, 4
    11f4:	04020059 	streq	r0, [r2], #-89	; 0x59

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11f8:	02005a02 	andeq	r5, r0, #8192	; 0x2000
    11fc:	00590204 	subseq	r0, r9, r4, lsl #4
    1200:	59020402 	stmdbpl	r2, {r1, sl}
    va_list argp;
    va_start(argp, fmt);
    vprint(fmt, argp);
    1204:	02040200 	andeq	r0, r4, #0, 4
    va_end(argp);
}
    1208:	0402005a 	streq	r0, [r2], #-90	; 0x5a
    120c:	02005902 	andeq	r5, r0, #32768	; 0x8000
    1210:	00590204 	subseq	r0, r9, r4, lsl #4

void hexdump(unsigned char *data, size_t size)
{
    1214:	5a020402 	bpl	82224 <_etext+0x7ac10>
    1218:	02040200 	andeq	r0, r4, #0, 4
    int i;
    char cs[17];
    memset(cs, 0, 17);
    121c:	04020059 	streq	r0, [r2], #-89	; 0x59
    1220:	58140302 	ldmdapl	r4, {r1, r8, r9}
    1224:	02040200 	andeq	r0, r4, #0, 4

    for(i = 0; i < size; i++)
    1228:	002e6d03 	eoreq	r6, lr, r3, lsl #26
    122c:	03020402 	movweq	r0, #9218	; 0x2402
    {
        if(i != 0 && i % 0x10 == 0)
    1230:	02005822 	andeq	r5, r0, #2228224	; 0x220000
        {
            debug_print(" |%s|\n", cs);
    1234:	00750204 	rsbseq	r0, r5, r4, lsl #4
    1238:	67020402 	strvs	r0, [r2, -r2, lsl #8]
            memset(cs, 0, 17);
    123c:	02040200 	andeq	r0, r4, #0, 4
    1240:	04020067 	streq	r0, [r2], #-103	; 0x67
    1244:	2e6d0302 	cdpcs	3, 6, cr0, cr13, cr2, {0}
        }
        else if(i != 0 && i % 0x8 == 0)
    1248:	02040200 	andeq	r0, r4, #0, 4
    124c:	00201303 	eoreq	r1, r0, r3, lsl #6
        {
            debug_print(" ",0);
    1250:	03020402 	movweq	r0, #9218	; 0x2402
        }
        debug_print("%02X ", data[i]);
    1254:	17034a6d 	strne	r4, [r3, -sp, ror #20]
    1258:	3d594b3c 	vldrcc	d20, [r9, #-240]	; 0xffffff10
        cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
    125c:	01000702 	tsteq	r0, r2, lsl #14
    1260:	00029e01 	andeq	r9, r2, r1, lsl #28
    1264:	05000200 	streq	r0, [r0, #-512]	; 0x200
    1268:	02000001 	andeq	r0, r0, #1
    126c:	0d0efb01 	vstreq	d15, [lr, #-4]
    1270:	01010100 	mrseq	r0, (UNDEF: 17)
    }

    i = i % 0x10;
    if(i != 0)
    1274:	00000001 	andeq	r0, r0, r1
        while(i++ < 0x10)
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
    1278:	01000001 	tsteq	r0, r1
    127c:	31353532 	teqcc	r5, r2, lsr r5
}
    1280:	3a630039 	bcc	18c136c <_etext+0x18b9d58>
    }

    i = i % 0x10;
    if(i != 0)
    {
        if(i <= 0x8)
    1284:	6f72705c 	svcvs	0x0072705c
        {
            debug_print(" ",0);
    1288:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64
    128c:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
        }
        while(i++ < 0x10)
    1290:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
        {
            debug_print("   ",0);
    1294:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
    1298:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
    129c:	6f6f7420 	svcvs	0x006f7420
    12a0:	6120736c 	teqvs	r0, ip, ror #6
    12a4:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
    12a8:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
    12ac:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
    }
    debug_print(" |%s|\n", cs);
}

void print_hash(unsigned char hash[])
{
    12b0:	20382e34 	eorscs	r2, r8, r4, lsr lr
   int idx;
   for (idx=0; idx < 32; idx++)
    12b4:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
      debug_print("%02x",hash[idx]);
    12b8:	615c3371 	cmpvs	ip, r1, ror r3
    12bc:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
}

void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
    12c0:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12c4:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
}
    12c8:	636e695c 	cmnvs	lr, #92, 18	; 0x170000
void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12cc:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
    12d0:	63616d5c 	cmnvs	r1, #92, 26	; 0x1700
    12d4:	656e6968 	strbvs	r6, [lr, #-2408]!	; 0x968
}

#endif
void uartInit(void) {
    12d8:	5c3a6300 	ldcpl	3, cr6, [sl], #-0
    12dc:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    12e0:	206d6172 	rsbcs	r6, sp, r2, ror r1
    12e4:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    12e8:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
    12ec:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    12f0:	20756e67 	rsbscs	r6, r5, r7, ror #28
    12f4:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; 112c <main+0xf8>
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    12f8:	72612073 	rsbvc	r2, r1, #115	; 0x73
    12fc:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1300:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
    1304:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1308:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    130c:	71343130 	teqvc	r4, r0, lsr r1
    1310:	72615c33 	rsbvc	r5, r1, #13056	; 0x3300
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1314:	6f6e2d6d 	svcvs	0x006e2d6d
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1318:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    131c:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1320:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1324:	00656475 	rsbeq	r6, r5, r5, ror r4
    1328:	32646500 	rsbcc	r6, r4, #0, 10
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    132c:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    1330:	0100632e 	tsteq	r0, lr, lsr #6
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1334:	32660000 	rsbcc	r0, r6, #0
    USART_InitStructure.USART_Parity = USART_Parity_No;
    1338:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    133c:	0100682e 	tsteq	r0, lr, lsr #16
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1340:	64650000 	strbtvs	r0, [r5], #-0
    1344:	31353532 	teqcc	r5, r2, lsr r5
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    1348:	00682e39 	rsbeq	r2, r8, r9, lsr lr
        
    USART_Init(USART1, &USART_InitStructure);
    134c:	5f000001 	svcpl	0x00000001
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    1350:	61666564 	cmnvs	r6, r4, ror #10
    1354:	5f746c75 	svcpl	0x00746c75
}
    1358:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0x974
    135c:	00682e73 	rsbeq	r2, r8, r3, ror lr

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    1360:	73000002 	movwvc	r0, #2
    1364:	6e696474 	mcrvs	4, 3, r6, cr9, cr4, {3}
    1368:	00682e74 	rsbeq	r2, r8, r4, ror lr
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    136c:	00000003 	andeq	r0, r0, r3
    1370:	0c020500 	cfstr32eq	mvfx0, [r2], {-0}
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    1374:	0300001a 	movweq	r0, #26
    1378:	04200133 	strteq	r0, [r0], #-307	; 0x133
    137c:	20700302 	rsbscs	r0, r0, r2, lsl #6
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    1380:	10030104 	andne	r0, r3, r4, lsl #2
    1384:	02047408 	andeq	r7, r4, #8, 8	; 0x8000000
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    1388:	04207003 	strteq	r7, [r0], #-3
    138c:	ac100301 	ldcge	3, cr0, [r0], {1}

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    1390:	70030204 	andvc	r0, r3, r4, lsl #4
    1394:	03010420 	movweq	r0, #5152	; 0x1420
    1398:	02042e13 	andeq	r2, r4, #304	; 0x130
    139c:	04206d03 	strteq	r6, [r0], #-3331	; 0xd03
    13a0:	3c130301 	ldccc	3, cr0, [r3], {1}
    13a4:	022d4b3d 	eoreq	r4, sp, #62464	; 0xf400
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    13a8:	01010002 	tsteq	r1, r2
    13ac:	7c020500 	cfstr32vc	mvfx0, [r2], {-0}
    13b0:	0300001a 	movweq	r0, #26
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    13b4:	3f2e013c 	svccc	0x002e013c
    13b8:	3d685959 	stclcc	9, cr5, [r8, #-356]!	; 0xfffffe9c

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    13bc:	0002023d 	andeq	r0, r2, sp, lsr r2
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    13c0:	05000101 	streq	r0, [r0, #-257]	; 0x101
    13c4:	001ab802 	andseq	fp, sl, r2, lsl #16
    13c8:	00de0300 	sbcseq	r0, lr, r0, lsl #6
    13cc:	03020401 	movweq	r0, #9217	; 0x2401
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    13d0:	01045845 	tsteq	r4, r5, asr #16
    13d4:	ac00c003 	stcge	0, cr12, [r0], {3}

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    13d8:	40030204 	andmi	r0, r3, r4, lsl #4
    13dc:	0301043c 	movweq	r0, #5180	; 0x143c
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    13e0:	1df200c4 	ldclne	0, cr0, [r2, #784]!	; 0x310
    13e4:	1c242b31 	stcne	11, cr2, [r4], #-196	; 0xffffff3c
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    13e8:	02022f24 	andeq	r2, r2, #36, 30	; 0x90
    13ec:	00010100 	andeq	r0, r1, r0, lsl #2
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    13f0:	1b180205 	blne	601c0c <_etext+0x5fa5f8>
    13f4:	ec030000 	stc	0, cr0, [r3], {-0}
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    13f8:	02040100 	andeq	r0, r4, #0, 2
    13fc:	2e7fb703 	cdpcs	7, 7, cr11, cr15, cr3, {0}
    1400:	c9030104 	stmdbgt	r3, {r2, r8}
    1404:	04215800 	strteq	r5, [r1], #-2048	; 0x800

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    1408:	7fb60302 	svcvc	0x00b60302
    140c:	0301042e 	movweq	r0, #5166	; 0x142e
    1410:	289e00c9 	ldmcs	lr, {r0, r3, r6, r7}
    1414:	af030204 	svcge	0x00030204
    1418:	01042e7f 	tsteq	r4, pc, ror lr
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    141c:	2e00c903 	cdpcs	9, 0, cr12, cr0, cr3, {0}
    1420:	20780328 	rsbscs	r0, r8, r8, lsr #6
        u32 rwmVal = pRCC->CR;
    1424:	b7030204 	strlt	r0, [r3, -r4, lsl #4]
        rwmVal |= 0x01;
    1428:	0104207f 	tsteq	r4, pc, ror r0
        pRCC->CR = rwmVal;
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    142c:	3c00d403 	cfstrscc	mvf13, [r0], {3}
    1430:	59311c24 	ldmdbpl	r1!, {r2, r5, sl, fp, ip}
}   
    1434:	5b5b4d59 	blpl	16d49a0 <_etext+0x16cd38c>
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    1438:	59af4d4b 	stmibpl	pc!, {r0, r1, r3, r6, r8, sl, fp, lr}	; <UNPREDICTABLE>
void setMspAndJump(u32 usrAddr) {
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    143c:	024b3e3d 	subeq	r3, fp, #976	; 0x3d0
  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1440:	01010007 	tsteq	r1, r7

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1444:	e0020500 	and	r0, r2, r0, lsl #10
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    1448:	0300001b 	movweq	r0, #27
    144c:	4a01019d 	bmi	41ac8 <_etext+0x3a4b4>
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    1450:	03201f03 	teqeq	r0, #3, 30
    1454:	1f032e61 	svcne	0x00032e61
    1458:	2f2d3d20 	svccs	0x002d3d20
    145c:	59595b59 	ldmdbpl	r9, {r0, r3, r4, r6, r8, r9, fp, ip, lr}^
    tmppre = (0x4 - tmppriority);
    1460:	755b755b 	ldrbvc	r7, [fp, #-1371]	; 0x55b
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    1464:	5b5b5b5b 	blpl	16d81d8 <_etext+0x16d0bc4>


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    1468:	69695b5b 	stmdbvs	r9!, {r0, r1, r3, r4, r6, r8, r9, fp, ip, lr}^

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    146c:	00050267 	andeq	r0, r5, r7, ror #4
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    1470:	05000101 	streq	r0, [r0, #-257]	; 0x101

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1474:	001cc002 	andseq	ip, ip, r2
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    1478:	01e70300 	mvneq	r0, r0, lsl #6
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    147c:	1e032e01 	cdpne	14, 0, cr2, cr3, cr1, {0}

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1480:	65032b20 	strvs	r2, [r3, #-2848]	; 0xb20
    1484:	201b032e 	andscs	r0, fp, lr, lsr #6
    1488:	5c675b31 	stclpl	11, cr5, [r7], #-196	; 0xffffff3c
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    148c:	5b595959 	blpl	16579f8 <_etext+0x16503e4>
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    1490:	5b4b5b5b 	blpl	12d8204 <_etext+0x12d0bf0>
    tmppriority &= tmpmask;
    1494:	6769695b 			; <UNDEFINED> instruction: 0x6769695b
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    1498:	01000202 	tsteq	r0, r2, lsl #4

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    149c:	02050001 	andeq	r0, r5, #1
    14a0:	00001d74 	andeq	r1, r0, r4, ror sp
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    14a4:	0102ab03 	tsteq	r2, r3, lsl #22
    14a8:	0303043c 	movweq	r0, #13372	; 0x343c
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    14ac:	043c7e9d 	ldrteq	r7, [ip], #-3741	; 0xe9d
    14b0:	01e90301 	mvneq	r0, r1, lsl #6
    14b4:	04020058 	streq	r0, [r2], #-88	; 0x58
    14b8:	02002102 	andeq	r2, r0, #-2147483648	; 0x80000000
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    14bc:	005b0204 	subseq	r0, fp, r4, lsl #4
    14c0:	47020402 	strmi	r0, [r2, -r2, lsl #8]
    14c4:	02040200 	andeq	r0, r4, #0, 4
    rNVIC->ICER[1] = 0xFFFFFFFF;
    14c8:	04020032 	streq	r0, [r2], #-50	; 0x32
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    14cc:	02005a02 	andeq	r5, r0, #8192	; 0x2000
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    14d0:	00670204 	rsbeq	r0, r7, r4, lsl #4

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    14d4:	67020402 	strvs	r0, [r2, -r2, lsl #8]
    14d8:	02040200 	andeq	r0, r4, #0, 4
    14dc:	04020067 	streq	r0, [r2], #-103	; 0x67

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    14e0:	2e760302 	cdpcs	3, 7, cr0, cr6, cr2, {0}
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    14e4:	02040200 	andeq	r0, r4, #0, 4
    nvicDisableInterrupts();
    14e8:	00200a03 	eoreq	r0, r0, r3, lsl #20
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    14ec:	03020402 	movweq	r0, #9218	; 0x2402
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    14f0:	03044a76 	movweq	r4, #19062	; 0x4a76
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14f4:	2e7e9703 	cdpcs	7, 7, cr9, cr14, cr3, {0}
}
    14f8:	f7030104 			; <UNDEFINED> instruction: 0xf7030104
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14fc:	06025801 	streq	r5, [r2], -r1, lsl #16

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1500:	6a010100 	bvs	41908 <_etext+0x3a2f4>
    1504:	02000002 	andeq	r0, r0, #2

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    1508:	00018500 	andeq	r8, r1, r0, lsl #10
    150c:	fb010200 	blx	41d16 <_etext+0x3a702>
    1510:	01000d0e 	tsteq	r0, lr, lsl #26
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1514:	00010101 	andeq	r0, r1, r1, lsl #2
    1518:	00010000 	andeq	r0, r1, r0
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    151c:	35320100 	ldrcc	r0, [r2, #-256]!	; 0x100

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1520:	00393135 	eorseq	r3, r9, r5, lsr r1
    1524:	705c3a63 	subsvc	r3, ip, r3, ror #20
    1528:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
    SET_REG(FLASH_AR, pageAddr);
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    152c:	66206d61 	strtvs	r6, [r0], -r1, ror #26
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1530:	73656c69 	cmnvc	r5, #26880	; 0x6900
    1534:	38782820 	ldmdacc	r8!, {r5, fp, sp}^

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    1538:	675c2936 	smmlarvs	ip, r6, r9, r2

    return TRUE;
}
    153c:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
    1540:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
    1544:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    1548:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    154c:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    1550:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}

    u32 rwmVal = GET_REG(FLASH_CR);
    SET_REG(FLASH_CR, FLASH_CR_PG);
    1554:	30322038 	eorscc	r2, r2, r8, lsr r0
    1558:	33713431 	cmncc	r1, #822083584	; 0x31000000

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    155c:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
    1560:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    *(flashAddr + 0x01) = (vu16)hhWord;
    1564:	61652d65 	cmnvs	r5, r5, ror #26
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1568:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^
    156c:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    *(flashAddr) = (vu16)lhWord;
    1570:	6d5c6564 	cfldr64vs	mvdx6, [ip, #-400]	; 0xfffffe70
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1574:	69686361 	stmdbvs	r8!, {r0, r5, r6, r8, r9, sp, lr}^
    1578:	6300656e 	movwvs	r6, #1390	; 0x56e

    rwmVal &= 0xFFFFFFFE;
    157c:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
    SET_REG(FLASH_CR, rwmVal);

    /* verify the write */
    if (*(vu32 *)addr != word) {
    1580:	6172676f 	cmnvs	r2, pc, ror #14
        return FALSE;
    }

    return TRUE;
}
    1584:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
    1588:	2073656c 	rsbscs	r6, r3, ip, ror #10
    158c:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
    1590:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    1594:	6f742075 	svcvs	0x00742075
    1598:	20736c6f 	rsbscs	r6, r3, pc, ror #24
    159c:	206d7261 	rsbcs	r7, sp, r1, ror #4
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    15a0:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
    15a4:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    15a8:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    15ac:	31303220 	teqcc	r0, r0, lsr #4
    15b0:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
    15b4:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    15b8:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
	{
		pin-=8;
    15bc:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
	}
	mask = 0x0F << (pin<<2);
    15c0:	6e695c69 	cdpvs	12, 6, cr5, cr9, cr9, {3}
    15c4:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
	return ~mask;
}	
    15c8:	3a630065 	bcc	18c1764 <_etext+0x18ba150>

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    15cc:	6f72705c 	svcvs	0x0072705c
    15d0:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64
}
    15d4:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
    15d8:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    15dc:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
	{
		return 0x800;
    15e0:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
	}
	else
	{
		return 0x400;
	}
}
    15e4:	6f6f7420 	svcvs	0x006f7420
    15e8:	6120736c 	teqvs	r0, ip, ror #6
    15ec:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
    15f0:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15f4:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    15f8:	20382e34 	eorscs	r2, r8, r4, lsr lr

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15fc:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1600:	6c5c3371 	mrrcvs	3, 7, r3, ip, cr1
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    1604:	675c6269 	ldrbvs	r6, [ip, -r9, ror #4]
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    1608:	615c6363 	cmpvs	ip, r3, ror #6
    160c:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1610:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1614:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
    userAppEnd = RAM_END;
    1618:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    161c:	695c342e 	ldmdbvs	ip, {r1, r2, r3, r5, sl, ip, sp}^
    userUploadType=DFU_UPLOAD_NONE;
    1620:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    1624:	00006564 	andeq	r6, r0, r4, ror #10
    code_copy_lock = WAIT;
    1628:	69736465 	ldmdbvs	r3!, {r0, r2, r5, r6, sl, sp, lr}^
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    162c:	632e6e67 	teqvs	lr, #1648	; 0x670
    1630:	00000100 	andeq	r0, r0, r0, lsl #2
    1634:	35616873 	strbcc	r6, [r1, #-2163]!	; 0x873
    memset(input, 0xFF, sizeof(input));
    1638:	682e3231 	stmdavs	lr!, {r0, r4, r5, r9, ip, sp}
    163c:	00000100 	andeq	r0, r0, r0, lsl #2

    sha256_starts(&ctx);
}
    1640:	35326465 	ldrcc	r6, [r2, #-1125]!	; 0x465
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1644:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}
    1648:	00010068 	andeq	r0, r1, r8, rrx
    164c:	65645f00 	strbvs	r5, [r4, #-3840]!	; 0xf00
    1650:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
    1654:	79745f74 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
    1658:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
    165c:	00020068 	andeq	r0, r2, r8, rrx
    1660:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
    1664:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    1668:	00030068 	andeq	r0, r3, r8, rrx
    166c:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
    1670:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
    1674:	00040068 	andeq	r0, r4, r8, rrx
    1678:	72706600 	rsbsvc	r6, r0, #0, 12
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    167c:	2e656d69 	cdpcs	13, 6, cr6, cr5, cr9, {3}
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    1680:	00010068 	andeq	r0, r1, r8, rrx
    1684:	35326600 	ldrcc	r6, [r2, #-1536]!	; 0x600

    if (startState == appDETACH) {
    1688:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}
    168c:	00010068 	andeq	r0, r1, r8, rrx
        dfuAppStatus.bState = dfuIDLE;
    1690:	05000000 	streq	r0, [r0, #-0]
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
    1694:	00000002 	andeq	r0, r0, r2
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1698:	013a0300 	teqeq	sl, r0, lsl #6
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    169c:	63030204 	movwvs	r0, #12804	; 0x3204
    } else if (startState == appIDLE || startState == dfuIDLE) {
    16a0:	03010420 	movweq	r0, #5152	; 0x1420
    16a4:	0204201d 	andeq	r2, r4, #29
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    16a8:	04206303 	strteq	r6, [r0], #-771	; 0x303
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    16ac:	201d0301 	andscs	r0, sp, r1, lsl #6
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    16b0:	63030204 	movwvs	r0, #12804	; 0x3204
    16b4:	9a01042e 	bls	42774 <_etext+0x3b160>
    16b8:	03030459 	movweq	r0, #13401	; 0x3459
    16bc:	2f2d6626 	svccs	0x002d6626

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    16c0:	0301042d 	movweq	r0, #5165	; 0x142d
        pInformation->Ctrl_Info.Usb_wLength = 1;
    16c4:	03042e76 	movweq	r2, #20086	; 0x4e76
    16c8:	042e0c03 	strteq	r0, [lr], #-3075	; 0xc03
        return NULL;
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    16cc:	2e740301 	cdpcs	3, 7, cr0, cr4, cr1, {0}
    }
}
    16d0:	0a030304 	beq	c22e8 <_etext+0xbacd4>
    16d4:	01043020 	tsteq	r4, r0, lsr #32

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    16d8:	032e7403 	teqeq	lr, #50331648	; 0x3000000
        pInformation->Ctrl_Info.Usb_wLength = 6;
    16dc:	03592e78 	cmpeq	r9, #120, 28	; 0x780
    16e0:	06025811 			; <UNDEFINED> instruction: 0x06025811
        return NULL;
    } else {
        return (u8*)(&dfuAppStatus);
    16e4:	00010100 	andeq	r0, r1, r0, lsl #2
    }
}
    16e8:	1df80205 	lfmne	f0, 2, [r8, #20]!
    16ec:	8d030000 	stchi	0, cr0, [r3, #-0]


u8 *dfuCopyDNLOAD(u16 length) {
    16f0:	60030101 	andvs	r0, r3, r1, lsl #2
    if (length == 0) {
    16f4:	2e200358 	mcrcs	3, 1, r0, cr0, cr8, {2}
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    16f8:	832e6003 	teqhi	lr, #3
    16fc:	0204212d 	andeq	r2, r4, #1073741835	; 0x4000000b
        thisBlockLen = pInformation->USBwLengths.w;
    1700:	4a7faf03 	bmi	1fed314 <_etext+0x1fe5d00>
        return NULL;
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1704:	d1030104 	tstle	r3, r4, lsl #2
    1708:	02042000 	andeq	r2, r4, #0
    }
}
    170c:	667faf03 	ldrbtvs	sl, [pc], -r3, lsl #30
    1710:	d1030104 	tstle	r3, r4, lsl #2
    1714:	02042000 	andeq	r2, r4, #0

u8 *dfuCopyUPLOAD(u16 length) {
    1718:	2e7faf03 	cdpcs	15, 7, cr10, cr15, cr3, {0}
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    171c:	2c030104 	stfcss	f0, [r3], {4}
    1720:	03020482 	movweq	r0, #9346	; 0x2482
    1724:	01042e54 	tsteq	r4, r4, asr lr
        return NULL;
    1728:	262e2c03 	strtcs	r2, [lr], -r3, lsl #24
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    172c:	1f3d4ce6 	svcne	0x003d4ce6
    1730:	302c223d 	eorcc	r2, ip, sp, lsr r2
    1734:	7203332b 	andvc	r3, r3, #-1409286144	; 0xac000000
    1738:	10035982 	andne	r5, r3, r2, lsl #19
    }
}
    173c:	59036766 	stmdbpl	r3, {r1, r2, r5, r6, r8, r9, sl, sp, lr}
    1740:	66780366 	ldrbtvs	r0, [r8], -r6, ror #6
    1744:	58740359 	ldmdapl	r4!, {r0, r3, r4, r6, r8, r9}^
    1748:	03221e5a 	teqeq	r2, #1440	; 0x5a0

void dfuCopyBufferToExec() {
    174c:	034a00f9 	movteq	r0, #41209	; 0xa0f9
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    1750:	5a587f85 	bpl	162156c <_etext+0x1619f58>
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    1754:	fb03221e 	blx	c9fd6 <_etext+0xc29c2>
    1758:	8e034a00 	vmlahi.f32	s8, s6, s0
    175c:	0359587f 	cmpeq	r9, #8323072	; 0x7f0000
    1760:	035800f5 	cmpeq	r8, #245	; 0xf5
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    1764:	34224a79 	strtcc	r4, [r2], #-2681	; 0xa79
	}

    flashErasePage((u32)(userSpace));
    1768:	4a7faf03 	bmi	1fed37c <_etext+0x1fe5d68>

    for (i = 0; i < thisBlockLen; i = i + 4) {
    176c:	01000802 	tsteq	r0, r2, lsl #16
    1770:	00070201 	andeq	r0, r7, r1, lsl #4
    1774:	f7000200 			; <UNDEFINED> instruction: 0xf7000200
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    1778:	02000000 	andeq	r0, r0, #0
    177c:	0d0efb01 	vstreq	d15, [lr, #-4]
    1780:	01010100 	mrseq	r0, (UNDEF: 17)
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    1784:	00000001 	andeq	r0, r0, r1
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    1788:	01000001 	tsteq	r0, r1
    178c:	31353532 	teqcc	r5, r2, lsr r5
    thisBlockLen = 0;
    1790:	3a630039 	bcc	18c187c <_etext+0x18ba268>
    1794:	6f72705c 	svcvs	0x0072705c
    1798:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64
    179c:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
    17a0:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
    17a4:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    17a8:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    17ac:	6f6f7420 	svcvs	0x006f7420
    17b0:	6120736c 	teqvs	r0, ip, ror #6

    u8 startState = dfuAppStatus.bState;
    17b4:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
    17b8:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
    dfuAppStatus.bStatus = OK;
    17bc:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    17c0:	20382e34 	eorscs	r2, r8, r4, lsr lr

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17c4:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
    17c8:	615c3371 	cmpvs	ip, r1, ror r3
            if (pInformation->USBwLengths.w > 0) {
    17cc:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    17d0:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
                userFirmwareLen = 0;
    17d4:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    17d8:	636e695c 	cmnvs	lr, #92, 18	; 0x170000
    17dc:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c
    17e0:	63616d5c 	cmnvs	r1, #92, 26	; 0x1700
    17e4:	656e6968 	strbvs	r6, [lr, #-2408]!	; 0x968
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    17e8:	5c3a6300 	ldcpl	3, cr6, [sl], #-0
						userAppAddr = USER_CODE_FLASH0X8002000;
    17ec:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
    17f0:	206d6172 	rsbcs	r6, sp, r2, ror r1
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    17f4:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966
    17f8:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    17fc:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1800:	20756e67 	rsbscs	r6, r5, r7, ror #28
						flashUnlock();
    1804:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; 163c <dfuInit+0x48>

						break;
    1808:	72612073 	rsbvc	r2, r1, #115	; 0x73

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    180c:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1810:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1814:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    1818:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
    181c:	71343130 	teqvc	r4, r0, lsr r1
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    1820:	72615c33 	rsbvc	r5, r1, #13056	; 0x3300
    1824:	6f6e2d6d 	svcvs	0x006e2d6d
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1828:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
    182c:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c
    1830:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
			
            switch(pInformation->Current_AlternateSetting) {
    1834:	00656475 	rsbeq	r6, r5, r5, ror r4
    1838:	35326600 	ldrcc	r6, [r2, #-1536]!	; 0x600
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    183c:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1840:	00010063 	andeq	r0, r1, r3, rrx
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1844:	35326600 	ldrcc	r6, [r2, #-1536]!	; 0x600
					userAppEnd = getFlashEnd();
    1848:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}
    184c:	00010068 	andeq	r0, r1, r8, rrx

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    1850:	65645f00 	strbvs	r5, [r4, #-3840]!	; 0xf00
					dfuAppStatus.bStatus = errWRITE;
    1854:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    1858:	79745f74 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    185c:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1860:	00020068 	andeq	r0, r2, r8, rrx
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    1864:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1868:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    186c:	00030068 	andeq	r0, r3, r8, rrx
    1870:	05000000 	streq	r0, [r0, #-0]

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    1874:	001f7402 	andseq	r7, pc, r2, lsl #8
                dfuCopyBufferToExec();
    1878:	010c0300 	mrseq	r0, LR_mon
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    187c:	027a3b25 	rsbseq	r3, sl, #37888	; 0x9400
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    1880:	01010004 	tsteq	r1, r4
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    1884:	94020500 	strls	r0, [r2], #-1280	; 0x500
    1888:	0300001f 	movweq	r0, #31

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    188c:	03260119 	teqeq	r6, #1073741830	; 0x40000006
    1890:	2f26207a 	svccs	0x0026207a
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    1894:	1f1e232d 	svcne	0x001e232d
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    1898:	02040200 	andeq	r0, r4, #0, 4
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    189c:	04020032 	streq	r0, [r2], #-50	; 0x32
    18a0:	02002f02 	andeq	r2, r0, #2, 30
    18a4:	001e0204 	andseq	r0, lr, r4, lsl #4
            if (pInformation->USBwLengths.w > 0) {
    18a8:	31020402 	tstcc	r2, r2, lsl #8
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    18ac:	02040200 	andeq	r0, r4, #0, 4
                }*/
                ImageObjectHandle imageHandle;
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    18b0:	0020062b 	eoreq	r0, r0, fp, lsr #12
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    18b4:	06020402 	streq	r0, [r2], -r2, lsl #8
                }*/
                ImageObjectHandle imageHandle;
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    18b8:	002e0d03 	eoreq	r0, lr, r3, lsl #26
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
                }
                switch (ret)
    18bc:	2f020402 	svccs	0x00020402
    18c0:	02040200 	andeq	r0, r4, #0, 4
    18c4:	0402002c 	streq	r0, [r2], #-44	; 0x2c
                {
                    case kImageImageIsTrusted:
                        uart_printf("Uploaded signature verified!\n");
    18c8:	02003102 	andeq	r3, r0, #-2147483648	; 0x80000000
                        break;

                    case kImageImageMissingMagic:
                    case kImageImageRejectSignature:
                        uart_printf("Image unverified... wiped memory for clean reset.\n");
    18cc:	262b0204 	strtcs	r0, [fp], -r4, lsl #4
    18d0:	03201d03 	teqeq	r0, #3, 26	; 0xc0
                        break;

                    default:
                        break;
                }
                flashLock();
    18d4:	1a032063 	bne	c9a68 <_etext+0xc2454>
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    18d8:	2e67033c 	mcrcs	3, 3, r0, cr7, cr12, {1}
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18dc:	242e1903 	strtcs	r1, [lr], #-2307	; 0x903
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18e0:	3c680373 	stclcc	3, cr0, [r8], #-460	; 0xfffffe34
    18e4:	01000402 	tsteq	r0, r2, lsl #8
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuMANIFEST_SYNC) {
    18e8:	02050001 	andeq	r0, r5, #1
        /* device has received last block, waiting DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18ec:	00002004 	andeq	r2, r0, r4
    18f0:	5d013c03 	stcpl	12, cr3, [r1, #-12]
            dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    18f4:	2f143102 	svccs	0x00143102
            dfuAppStatus.bStatus = OK;
    18f8:	032f302f 	teqeq	pc, #47	; 0x2f
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18fc:	241d4a78 	ldrcs	r4, [sp], #-2680	; 0xa78
    1900:	211f212d 	tstcs	pc, sp, lsr #2
            dfuAppStatus.bState  = dfuMANIFEST_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuMANIFEST) {
    1904:	0002022d 	andeq	r0, r2, sp, lsr #4
        /* device is in manifestation phase */

        /* should never receive request while in manifest! */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
        dfuAppStatus.bStatus = OK;
    } else if (startState == dfuMANIFEST_WAIT_RESET) {
    1908:	05000101 	streq	r0, [r0, #-257]	; 0x101
        /* device has programmed new firmware but needs external
           usb reset or power on reset to run the new code */

        /* consider timing out and self-resetting */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    } else if (startState == dfuUPLOAD_IDLE) {
    190c:	0020a002 	eoreq	sl, r0, r2
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
    1910:	00cd0300 	sbceq	r0, sp, r0, lsl #6
    1914:	be130801 	cdplt	8, 1, cr0, cr3, cr1, {0}
            if (pInformation->USBwLengths.w > 0) {
    1918:	1f133202 	svcne	0x00133202
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    191c:	65211e4b 	strvs	r1, [r1, #-3659]!	; 0xe4b
    1920:	0002023e 	andeq	r0, r2, lr, lsr r2
    1924:	05000101 	streq	r0, [r0, #-257]	; 0x101
    1928:	00216402 	eoreq	r6, r1, r2, lsl #8
    192c:	00d60300 	sbcseq	r0, r6, r0, lsl #6
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1930:	211b1701 	tstcs	fp, r1, lsl #14
    1934:	02040200 	andeq	r0, r4, #0, 4
    1938:	04020026 	streq	r0, [r2], #-38	; 0x26
    193c:	02005902 	andeq	r5, r0, #32768	; 0x8000
    1940:	441d0204 	ldrmi	r0, [sp], #-516	; 0x204
    1944:	2f2d212d 	svccs	0x002d212d
                    thisBlockLen = uploadBlockLen;
    1948:	0022212d 	eoreq	r2, r2, sp, lsr #2
    194c:	21020402 	tstcs	r2, r2, lsl #8
                    dfuAppStatus.bState  = dfuUPLOAD_IDLE;
                } else {
                    /* if above comparison was just equal, thisBlockLen becomes zero
                    next time when USBWValue has been increased by one */
                    thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
    1950:	02040200 	andeq	r0, r4, #0, 4
    1954:	0402003d 	streq	r0, [r2], #-61	; 0x3d
    1958:	02001e02 	andeq	r1, r0, #2, 28
    195c:	00310204 	eorseq	r0, r1, r4, lsl #4
                    
                    /* check for overflow due to USBwValue out of range */
                    if (thisBlockLen >= pInformation->USBwLengths.w) {
    1960:	2b020402 	blcs	82970 <_etext+0x7b35c>
    1964:	00020225 	andeq	r0, r2, r5, lsr #4
                        thisBlockLen = 0;
    1968:	05000101 	streq	r0, [r0, #-257]	; 0x101
                    }
                    
                    dfuAppStatus.bState  = dfuIDLE;
                }
            } else {
                dfuAppStatus.bState  = dfuERROR;
    196c:	0021ac02 	eoreq	sl, r1, r2, lsl #24
                dfuAppStatus.bStatus = errNOTDONE;
    1970:	00ed0300 	rsceq	r0, sp, r0, lsl #6
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    1974:	001f2601 	andseq	r2, pc, r1, lsl #12
            dfuAppStatus.bState  = dfuIDLE;
    1978:	22020402 	andcs	r0, r2, #33554432	; 0x2000000
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    197c:	02040200 	andeq	r0, r4, #0, 4
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1980:	04020067 	streq	r0, [r2], #-103	; 0x67
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1984:	02001e02 	andeq	r1, r0, #2, 28
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuERROR)               {
    1988:	00310204 	eorseq	r0, r1, r4, lsl #4
        /* status is in error, awaiting DFU_CLRSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    198c:	2b020402 	blcs	8299c <_etext+0x7b388>
    1990:	301c3226 	andscc	r3, ip, r6, lsr #4
    1994:	02003d3b 	andeq	r3, r0, #3776	; 0xec0
            /* todo, add routine to wait for last block write to finish */
            dfuAppStatus.bState  = dfuERROR;
    1998:	00310204 	eorseq	r0, r1, r4, lsl #4
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    199c:	2f020402 	svccs	0x00020402
            dfuAppStatus.bState  = dfuERROR;
        } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
    19a0:	02040200 	andeq	r0, r4, #0, 4
            /* todo handle any cleanup we need here */
            dfuAppStatus.bState  = dfuIDLE;
    19a4:	0402001e 	streq	r0, [r2], #-30
            dfuAppStatus.bStatus = OK;
    19a8:	02003102 	andeq	r3, r0, #-2147483648	; 0x80000000
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else {
        /* some kind of error... */
        dfuAppStatus.bState  = dfuERROR;
    19ac:	252b0204 	strcs	r0, [fp, #-516]!	; 0x204
        dfuAppStatus.bStatus = errSTALLEDPKT;
    19b0:	01000202 	tsteq	r0, r2, lsl #4
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}
    19b4:	02050001 	andeq	r0, r5, #1
    19b8:	000021f8 	strdeq	r2, [r0], -r8
    19bc:	01018503 	tsteq	r1, r3, lsl #10
    19c0:	02001f26 	andeq	r1, r0, #38, 30	; 0x98
    19c4:	00220204 	eoreq	r0, r2, r4, lsl #4
    19c8:	4b020402 	blmi	829d8 <_etext+0x7b3c4>
    19cc:	02040200 	andeq	r0, r4, #0, 4
    19d0:	0402001e 	streq	r0, [r2], #-30
    19d4:	02003102 	andeq	r3, r0, #-2147483648	; 0x80000000
    19d8:	262b0204 	strtcs	r0, [fp], -r4, lsl #4
    19dc:	1f221c24 	svcne	0x00221c24
    19e0:	00212d2f 	eoreq	r2, r1, pc, lsr #26
    19e4:	31020402 	tstcc	r2, r2, lsl #8
    19e8:	02040200 	andeq	r0, r4, #0, 4
    19ec:	0402002f 	streq	r0, [r2], #-47	; 0x2f
    19f0:	02001e02 	andeq	r1, r0, #2, 28
    19f4:	00310204 	eorseq	r0, r1, r4, lsl #4
    19f8:	2b020402 	blcs	82a08 <_etext+0x7b3f4>
    dfuAppStatus.bState = newState;
}

bool dfuUploadStarted()
{
    return dfuBusy;
    19fc:	00030225 	andeq	r0, r3, r5, lsr #4
}
    1a00:	05000101 	streq	r0, [r0, #-257]	; 0x101
    1a04:	00224002 	eoreq	r4, r2, r2

void dfuFinishUpload() {

    while (1)
	{
		__asm__ __volatile__ ("");
    1a08:	019d0300 	orrseq	r0, sp, r0, lsl #6
};

/* Conversion to and from projective coordinates */
void ed25519_project(struct ed25519_pt *p,
		     const uint8_t *x, const uint8_t *y)
{
    1a0c:	032b3201 	teqeq	fp, #268435456	; 0x10000000
    1a10:	3d29200b 	stccc	0, cr2, [r9, #-44]!	; 0xffffffd4
    1a14:	02040200 	andeq	r0, r4, #0, 4
    1a18:	04020021 	streq	r0, [r2], #-33	; 0x21
    1a1c:	02003b02 	andeq	r3, r0, #2048	; 0x800
    1a20:	002f0204 	eoreq	r0, pc, r4, lsl #4
    1a24:	2d020402 	cfstrscs	mvf0, [r2, #-8]
    1a28:	01040200 	mrseq	r0, R12_usr
    1a2c:	0402004d 	streq	r0, [r2], #-77	; 0x4d
    1a30:	02007602 	andeq	r7, r0, #2097152	; 0x200000
    1a34:	002d0204 	eoreq	r0, sp, r4, lsl #4
    1a38:	49020402 	stmdbmi	r2, {r1, sl}
    1a3c:	02040200 	andeq	r0, r4, #0, 4
    1a40:	0402002f 	streq	r0, [r2], #-47	; 0x2f
    1a44:	03242d02 	teqeq	r4, #2, 26	; 0x80
    1a48:	0e032e75 	mcreq	14, 0, r2, cr3, cr5, {3}
    1a4c:	2f3b2158 	svccs	0x003b2158
    1a50:	0200232d 	andeq	r2, r0, #-1275068416	; 0xb4000000
    1a54:	00210204 	eoreq	r0, r1, r4, lsl #4
    1a58:	2f020402 	svccs	0x00020402
    1a5c:	02040200 	andeq	r0, r4, #0, 4
    1a60:	0402001e 	streq	r0, [r2], #-30
    1a64:	02003102 	andeq	r3, r0, #-2147483648	; 0x80000000
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
    1a68:	252b0204 	strcs	r0, [fp, #-516]!	; 0x204
	f25519_mul__distinct(p->t, x, y);
    1a6c:	01000302 	tsteq	r0, r2, lsl #6
    1a70:	02050001 	andeq	r0, r5, #1
}
    1a74:	00000000 	andeq	r0, r0, r0
		     const uint8_t *x, const uint8_t *y)
{
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
	f25519_mul__distinct(p->t, x, y);
    1a78:	0101ba03 	tsteq	r1, r3, lsl #20
}

void ed25519_unproject(uint8_t *x, uint8_t *y,
		       const struct ed25519_pt *p)
{
    1a7c:	032e6703 	teqeq	lr, #786432	; 0xc0000
    1a80:	64032e19 	strvs	r2, [r3], #-3609	; 0xe19
    1a84:	200b032e 	andcs	r0, fp, lr, lsr #6
	uint8_t z1[F25519_SIZE];

	f25519_inv__distinct(z1, p->z);
    1a88:	3b213d1b 	blcc	850efc <_etext+0x8498e8>
    1a8c:	764d2d2f 	strbvc	r2, [sp], -pc, lsr #26
	f25519_mul__distinct(x, p->x, z1);
    1a90:	2d2f492d 	stccs	9, cr4, [pc, #-180]!	; 19e4 <dfuUpdateByRequest+0x23c>
    1a94:	2e750324 	cdpcs	3, 7, cr0, cr5, cr4, {1}
    1a98:	2f580e03 	svccs	0x00580e03
	f25519_mul__distinct(y, p->y, z1);
    1a9c:	4e2d2f3b 	mcrmi	15, 1, r2, cr13, cr11, {1}
    1aa0:	2b232c2f 	blcs	8ccb64 <_etext+0x8c5550>
    1aa4:	f1030204 			; <UNDEFINED> instruction: 0xf1030204

	f25519_normalize(x);
    1aa8:	0104207e 	tsteq	r4, lr, ror r0
	f25519_normalize(y);
    1aac:	08019c03 	stmdaeq	r1, {r0, r1, sl, fp, ip, pc}
    1ab0:	0004022e 	andeq	r0, r4, lr, lsr #4
}
    1ab4:	05000101 	streq	r0, [r0, #-257]	; 0x101
	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
};

void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y)
{
    1ab8:	00000002 	andeq	r0, r0, r2
    1abc:	01c20300 	biceq	r0, r2, r0, lsl #6
    1ac0:	211c1601 	tstcs	ip, r1, lsl #12
    1ac4:	02040200 	andeq	r0, r4, #0, 4
    1ac8:	04020025 	streq	r0, [r2], #-37	; 0x25
    1acc:	02005902 	andeq	r5, r0, #32768	; 0x8000
    1ad0:	421d0204 	andsmi	r0, sp, #4, 4	; 0x40000000
    1ad4:	2c301f21 	ldccs	15, cr1, [r0], #-132	; 0xffffff7c
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
    1ad8:	02003022 	andeq	r3, r0, #34	; 0x22
    1adc:	00210204 	eoreq	r0, r1, r4, lsl #4
    1ae0:	2f020402 	svccs	0x00020402
    1ae4:	02040200 	andeq	r0, r4, #0, 4
    1ae8:	0402001e 	streq	r0, [r2], #-30
    1aec:	02003102 	andeq	r3, r0, #-2147483648	; 0x80000000
    1af0:	252b0204 	strcs	r0, [fp, #-516]!	; 0x204
    1af4:	01000202 	tsteq	r0, r2, lsl #4
    1af8:	02050001 	andeq	r0, r5, #1
    1afc:	000022c8 	andeq	r2, r0, r8, asr #5
	parity = (tmp[0] & 1) << 7;
    1b00:	0101d803 	tsteq	r1, r3, lsl #16

	f25519_copy(c, y);
	f25519_normalize(c);
    1b04:	032e4903 	teqeq	lr, #49152	; 0xc000
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1b08:	46032037 			; <UNDEFINED> instruction: 0x46032037
    1b0c:	200b0320 	andcs	r0, fp, r0, lsr #6

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1b10:	3b212f29 	blcc	84d7bc <_etext+0x8461a8>
}
    1b14:	684d2d2f 	stmdavs	sp, {r0, r1, r2, r3, r5, r8, sl, fp, sp}^

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b18:	2d2f492d 	stccs	9, cr4, [pc, #-180]!	; 1a6c <ed25519_project+0x60>
    1b1c:	2e750324 	cdpcs	3, 7, cr0, cr5, cr4, {1}
    1b20:	2f3c0e03 	svccs	0x003c0e03
    1b24:	3d2d2f3b 	stccc	15, cr2, [sp, #-236]!	; 0xffffff14
	const int parity = comp[31] >> 7;
    1b28:	232c2f23 	teqcs	ip, #35, 30	; 0x8c
    1b2c:	7477032b 	ldrbtvc	r0, [r7], #-811	; 0x32b
    1b30:	49212f29 	stmdbmi	r1!, {r0, r3, r5, r8, r9, sl, fp, sp}
    1b34:	763f2d2f 	ldrtvc	r2, [pc], -pc, lsr #26
    1b38:	2d21492d 	stccs	9, cr4, [r1, #-180]!	; 0xffffff4c
    1b3c:	20750324 	rsbscs	r0, r5, r4, lsr #6
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b40:	213c0e03 	teqcs	ip, r3, lsl #28
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1b44:	232d2f3b 	teqcs	sp, #59, 30	; 0xec
    1b48:	311e2f21 	tstcc	lr, r1, lsr #30
    1b4c:	3c77032b 	ldclcc	3, cr0, [r7], #-172	; 0xffffff54
    1b50:	033c0903 	teqeq	ip, #49152	; 0xc000
    1b54:	213d3c72 	teqcs	sp, r2, ror ip
	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
	f25519_add(a, b, f25519_one);
    1b58:	4d2d2f49 	stcmi	15, cr2, [sp, #-292]!	; 0xfffffedc
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1b5c:	2f492d84 	svccs	0x00492d84

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
    1b60:	7503242d 	strvc	r2, [r3, #-1069]	; 0x42d
    1b64:	580e032e 	stmdapl	lr, {r1, r2, r3, r5, r8, r9}
	f25519_add(a, b, f25519_one);
    1b68:	2d2f3b2f 	fstmdbxcs	pc!, {d3-d25}	;@ Deprecated
    1b6c:	2c2f232f 	stccs	3, cr2, [pc], #-188	; 1ab8 <ed25519_pack>
    1b70:	72032b23 	andvc	r2, r3, #35840	; 0x8c00
	f25519_inv__distinct(b, a);
    1b74:	49213d4a 	stmdbmi	r1!, {r1, r3, r6, r8, sl, fp, ip, sp}
    1b78:	923f2d2f 	eorsls	r2, pc, #3008	; 0xbc0

	/* Compute a = y^2-1 */
	f25519_sub(a, c, f25519_one);
    1b7c:	2d21492d 	stccs	9, cr4, [r1, #-180]!	; 0xffffff4c
    1b80:	2e750324 	cdpcs	3, 7, cr0, cr5, cr4, {1}

	/* Compute c = a*b = (y^2-1)/(1-dy^2) */
	f25519_mul__distinct(c, a, b);
    1b84:	21580e03 	cmpcs	r8, r3, lsl #28
    1b88:	232d2f3b 	teqcs	sp, #59, 30	; 0xec
    1b8c:	311e2f21 	tstcc	lr, r1, lsr #30

	/* Compute a, b = +/-sqrt(c), if c is square */
	f25519_sqrt(a, c);
    1b90:	0402002b 	streq	r0, [r2], #-43	; 0x2b
    1b94:	203f0302 	eorscs	r0, pc, r2, lsl #6
	f25519_neg(b, a);
    1b98:	03064a06 	movweq	r4, #27142	; 0x6a06
    1b9c:	29207fb8 	stmdbcs	r0!, {r3, r4, r5, r7, r8, r9, sl, fp, ip, sp, lr}

	/* Select one of them, based on the compressed parity bit */
	f25519_select(x, a, b, (a[0] ^ parity) & 1);
    1ba0:	2f3b213d 	svccs	0x003b213d
    1ba4:	2d764d2d 	ldclcs	13, cr4, [r6, #-180]!	; 0xffffff4c
    1ba8:	242d2f49 	strtcs	r2, [sp], #-3913	; 0xf49
    1bac:	032e7503 	teqeq	lr, #12582912	; 0xc00000
    1bb0:	3b2f580e 	blcc	bd7bf0 <_etext+0xbd05dc>

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
    1bb4:	232f2d2f 	teqcs	pc, #3008	; 0xbc0
    1bb8:	2b232c2f 	blcs	8ccc7c <_etext+0x8c5668>
    1bbc:	37747703 	ldrbcc	r7, [r4, -r3, lsl #14]!
	f25519_normalize(a);
    1bc0:	2f49212f 	svccs	0x0049212f
	f25519_normalize(c);
    1bc4:	2d763f2d 	ldclcs	15, cr3, [r6, #-180]!	; 0xffffff4c
    1bc8:	242d2149 	strtcs	r2, [sp], #-329	; 0x149

	return f25519_eq(a, c);
    1bcc:	03207503 	teqeq	r0, #12582912	; 0xc00000
    1bd0:	3b213c0e 	blcc	850c10 <_etext+0x8495fc>
}
    1bd4:	21232d2f 	teqcs	r3, pc, lsr #26
    1bd8:	2b311e2f 	blcs	c4949c <_etext+0xc41e88>
    1bdc:	293c7703 	ldmdbcs	ip!, {r0, r1, r8, r9, sl, ip, sp, lr}
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1be0:	2f49212f 	svccs	0x0049212f
    1be4:	2d684d2d 	stclcs	13, cr4, [r8, #-180]!	; 0xffffff4c
    1be8:	242d2f49 	strtcs	r2, [sp], #-3913	; 0xf49
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bec:	032e7503 	teqeq	lr, #12582912	; 0xc00000
    1bf0:	3b2f3c0e 	blcc	bd0c30 <_etext+0xbc961c>
    1bf4:	232f2d2f 	teqcs	pc, #3008	; 0xbc0
	f25519_sub(d, p2->y, p2->x);
    1bf8:	2b232c2f 	blcs	8cccbc <_etext+0x8c56a8>
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bfc:	37747703 	ldrbcc	r7, [r4, -r3, lsl #14]!
	f25519_sub(d, p2->y, p2->x);
    1c00:	2f49212f 	svccs	0x0049212f
    1c04:	2d763f2d 	ldclcs	15, cr3, [r6, #-180]!	; 0xffffff4c
	f25519_mul__distinct(a, c, d);
    1c08:	242d2149 	strtcs	r2, [sp], #-329	; 0x149
    1c0c:	03207503 	teqeq	r0, #12582912	; 0xc00000
    1c10:	3b213c0e 	blcc	850c50 <_etext+0x84963c>

	/* B = (Y1+X1)(Y2+X2) */
	f25519_add(c, p1->y, p1->x);
    1c14:	21232d2f 	teqcs	r3, pc, lsr #26
    1c18:	2b311e2f 	blcs	c494dc <_etext+0xc41ec8>
	f25519_add(d, p2->y, p2->x);
    1c1c:	293c7703 	ldmdbcs	ip!, {r0, r1, r8, r9, sl, ip, sp, lr}
    1c20:	2f49212f 	svccs	0x0049212f
    1c24:	2d684d2d 	stclcs	13, cr4, [r8, #-180]!	; 0xffffff4c
	f25519_mul__distinct(b, c, d);
    1c28:	242d2f49 	strtcs	r2, [sp], #-3913	; 0xf49
    1c2c:	032e7503 	teqeq	lr, #12582912	; 0xc00000

	/* C = T1 k T2 */
	f25519_mul__distinct(d, p1->t, p2->t);
    1c30:	3b2f3c0e 	blcc	bd0c70 <_etext+0xbc965c>
    1c34:	232f2d2f 	teqcs	pc, #3008	; 0xbc0
    1c38:	2b232c2f 	blcs	8cccfc <_etext+0x8c56e8>
    1c3c:	29747703 	ldmdbcs	r4!, {r0, r1, r8, r9, sl, ip, sp, lr}^
	f25519_mul__distinct(c, d, ed25519_k);
    1c40:	2f49212f 	svccs	0x0049212f
    1c44:	2d763f2d 	ldclcs	15, cr3, [r6, #-180]!	; 0xffffff4c

	/* D = Z1 2 Z2 */
	f25519_mul__distinct(d, p1->z, p2->z);
    1c48:	242d2149 	strtcs	r2, [sp], #-329	; 0x149
    1c4c:	03207503 	teqeq	r0, #12582912	; 0xc00000
    1c50:	3b213c0e 	blcc	850c90 <_etext+0x84967c>
    1c54:	21232d2f 	teqcs	r3, pc, lsr #26
	f25519_add(d, d, d);
    1c58:	2b311e2f 	blcs	c4951c <_etext+0xc41f08>
    1c5c:	293c7703 	ldmdbcs	ip!, {r0, r1, r8, r9, sl, ip, sp, lr}

	/* E = B - A */
	f25519_sub(e, b, a);
    1c60:	2f49212f 	svccs	0x0049212f
    1c64:	2d684d2d 	stclcs	13, cr4, [r8, #-180]!	; 0xffffff4c
    1c68:	242d2f49 	strtcs	r2, [sp], #-3913	; 0xf49

	/* F = D - C */
	f25519_sub(f, d, c);
    1c6c:	032e7503 	teqeq	lr, #12582912	; 0xc00000
    1c70:	3b2f3c0e 	blcc	bd0cb0 <_etext+0xbc969c>

	/* G = D + C */
	f25519_add(g, d, c);
    1c74:	232f2d2f 	teqcs	pc, #3008	; 0xbc0
    1c78:	2b232c2f 	blcs	8ccd3c <_etext+0x8c5728>
    1c7c:	29747703 	ldmdbcs	r4!, {r0, r1, r8, r9, sl, ip, sp, lr}^

	/* H = B + A */
	f25519_add(h, b, a);
    1c80:	2f49212f 	svccs	0x0049212f
    1c84:	2d763f2d 	ldclcs	15, cr3, [r6, #-180]!	; 0xffffff4c

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1c88:	242d2149 	strtcs	r2, [sp], #-329	; 0x149
    1c8c:	03207503 	teqeq	r0, #12582912	; 0xc00000
    1c90:	3b213c0e 	blcc	850cd0 <_etext+0x8496bc>

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1c94:	21232d2f 	teqcs	r3, pc, lsr #26
    1c98:	2b311e2f 	blcs	c4955c <_etext+0xc41f48>
    1c9c:	2000d503 	andcs	sp, r0, r3, lsl #10

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1ca0:	01000402 	tsteq	r0, r2, lsl #8
    1ca4:	02050001 	andeq	r0, r5, #1
    1ca8:	00000000 	andeq	r0, r0, r0

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1cac:	01028a03 	tsteq	r2, r3, lsl #20
    1cb0:	0204232e 	andeq	r2, r4, #-1207959552	; 0xb8000000
    1cb4:	3c7e9603 	ldclcc	6, cr9, [lr], #-12
}
    1cb8:	ec030104 	stfs	f0, [r3], {4}
    1cbc:	0202ac01 	andeq	sl, r2, #256	; 0x100

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1cc0:	00010100 	andeq	r0, r1, r0, lsl #2
    1cc4:	28b40205 	ldmcs	r4!, {r0, r2, r9}

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1cc8:	b0030000 	andlt	r0, r3, r0
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1ccc:	96030102 	strls	r0, [r3], -r2, lsl #2
    1cd0:	ea032e7f 	b	cd6d4 <_etext+0xc60c0>

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1cd4:	03202000 	teqeq	r0, #0
    1cd8:	412e7f93 			; <UNDEFINED> instruction: 0x412e7f93
    1cdc:	2f421d4b 	svccs	0x00421d4b

	/* C = 2 Z1^2 */
	f25519_mul__distinct(c, p->z, p->z);
    1ce0:	302c301f 	eorcc	r3, ip, pc, lsl r0
    1ce4:	232c2f4d 	teqcs	ip, #308	; 0x134
    1ce8:	5859032b 	ldmdapl	r9, {r0, r1, r3, r5, r8, r9}^
	f25519_add(c, c, c);
    1cec:	49212f1b 	stmdbmi	r1!, {r0, r1, r3, r4, r8, r9, sl, fp, sp}
    1cf0:	683f2d2f 	ldmdavs	pc!, {r0, r1, r2, r3, r5, r8, sl, fp, sp}	; <UNPREDICTABLE>

	/* D = a A (alter sign) */
	/* E = (X1+Y1)^2-A-B */
	f25519_add(f, p->x, p->y);
    1cf4:	2d21492d 	stccs	9, cr4, [r1, #-180]!	; 0xffffff4c
    1cf8:	2e750324 	cdpcs	3, 7, cr0, cr5, cr4, {1}
    1cfc:	2f3c0e03 	svccs	0x003c0e03
	f25519_mul__distinct(e, f, f);
    1d00:	3d2d2f3b 	stccc	15, cr2, [sp, #-236]!	; 0xffffff14
    1d04:	232c2f23 	teqcs	ip, #35, 30	; 0x8c
	f25519_sub(e, e, a);
    1d08:	5877032b 	ldmdapl	r7!, {r0, r1, r3, r5, r8, r9}^
    1d0c:	65212f1b 	strvs	r2, [r1, #-3867]!	; 0xf1b
    1d10:	683f2d2f 	ldmdavs	pc!, {r0, r1, r2, r3, r5, r8, sl, fp, sp}	; <UNPREDICTABLE>
	f25519_sub(e, e, b);
    1d14:	2d21492d 	stccs	9, cr4, [r1, #-180]!	; 0xffffff4c
    1d18:	20750324 	rsbscs	r0, r5, r4, lsr #6

	/* G = D + B */
	f25519_sub(g, b, a);
    1d1c:	2f3c0e03 	svccs	0x003c0e03
    1d20:	4b2d2f57 	blmi	b4da84 <_etext+0xb46470>
    1d24:	232c2f31 	teqcs	ip, #49, 30	; 0xc4

	/* F = G - C */
	f25519_sub(f, g, c);
    1d28:	5877032b 	ldmdapl	r7!, {r0, r1, r3, r5, r8, r9}^
    1d2c:	3c740343 	ldclcc	3, cr0, [r4], #-268	; 0xfffffef4

	/* H = D - B */
	f25519_neg(h, b);
    1d30:	2f49213d 	svccs	0x0049213d
    1d34:	2d843f2d 	stccs	15, cr3, [r4, #180]	; 0xb4
	f25519_sub(h, h, a);
    1d38:	242d2149 	strtcs	r2, [sp], #-329	; 0x149
    1d3c:	034a7503 	movteq	r7, #42243	; 0xa503
    1d40:	3b2f580e 	blcc	bd7d80 <_etext+0xbd076c>

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1d44:	232f2d2f 	teqcs	pc, #3008	; 0xbc0
    1d48:	2b232c3d 	blcs	8cce44 <_etext+0x8c5830>

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1d4c:	3d4a7203 	sfmcc	f7, 2, [sl, #-12]
    1d50:	2d2f6521 	cfstr32cs	mvfx6, [pc, #-132]!	; 1cd4 <ed25519_double+0x14>
    1d54:	492d843f 	pushmi	{r0, r1, r2, r3, r4, r5, sl, pc}

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1d58:	03242d21 	teqeq	r4, #2112	; 0x840
    1d5c:	0e032e75 	mcreq	14, 0, r2, cr3, cr5, {3}
    1d60:	2f3b2f58 	svccs	0x003b2f58

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1d64:	3b232f2d 	blcc	8cda20 <_etext+0x8c640c>
    1d68:	2b232c30 	blcs	8cce30 <_etext+0x8c581c>
    1d6c:	2000f003 	andcs	pc, r0, r3
}
    1d70:	907f8703 	rsbsls	r8, pc, r3, lsl #14

void ed25519_smult(struct ed25519_pt *r_out, const struct ed25519_pt *p,
		   const uint8_t *e)
{
    1d74:	49212f1b 	stmdbmi	r1!, {r0, r1, r3, r4, r8, r9, sl, fp, sp}
    1d78:	683f2d2f 	ldmdavs	pc!, {r0, r1, r2, r3, r5, r8, sl, fp, sp}	; <UNPREDICTABLE>
    1d7c:	2d21492d 	stccs	9, cr4, [r1, #-180]!	; 0xffffff4c
    1d80:	4a750324 	bmi	1d42a18 <_etext+0x1d3b404>
    1d84:	2f3c0e03 	svccs	0x003c0e03
    1d88:	2f2d2f3b 	svccs	0x002d2f3b
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1d8c:	232c2f23 	teqcs	ip, #35, 30	; 0x8c
    1d90:	5877032b 	ldmdapl	r7!, {r0, r1, r3, r5, r8, r9}^
    1d94:	65212f29 	strvs	r2, [r1, #-3881]!	; 0xf29
		struct ed25519_pt s;

		ed25519_double(&r, &r);
    1d98:	683f2d2f 	ldmdavs	pc!, {r0, r1, r2, r3, r5, r8, sl, fp, sp}	; <UNPREDICTABLE>
    1d9c:	2d21492d 	stccs	9, cr4, [r1, #-180]!	; 0xffffff4c
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1da0:	20750324 	rsbscs	r0, r5, r4, lsr #6
		struct ed25519_pt s;

		ed25519_double(&r, &r);
		ed25519_add(&s, &r, p);
    1da4:	2f3c0e03 	svccs	0x003c0e03
    1da8:	2f2d2f3b 	svccs	0x002d2f3b

		f25519_select(r.x, r.x, s.x, bit);
    1dac:	2c222d23 	stccs	13, cr2, [r2], #-140	; 0xffffff74
    1db0:	77032b23 	strvc	r2, [r3, -r3, lsr #22]
    1db4:	212f1b58 	teqcs	pc, r8, asr fp	; <UNPREDICTABLE>
		f25519_select(r.y, r.y, s.y, bit);
    1db8:	3f2d2f49 	svccc	0x002d2f49
    1dbc:	21492d68 	cmpcs	r9, r8, ror #26
    1dc0:	7503242d 	strvc	r2, [r3, #-1069]	; 0x42d
		f25519_select(r.z, r.z, s.z, bit);
    1dc4:	3c0e032e 	stccc	3, cr0, [lr], {46}	; 0x2e
    1dc8:	2d2f3b2f 	fstmdbxcs	pc!, {d3-d25}	;@ Deprecated
    1dcc:	2c2f232f 	stccs	3, cr2, [pc], #-188	; 1d18 <ed25519_double+0x58>
		f25519_select(r.t, r.t, s.t, bit);
    1dd0:	77032b23 	strvc	r2, [r3, -r3, lsr #22]
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1dd4:	212f2958 	teqcs	pc, r8, asr r9	; <UNPREDICTABLE>
		ed25519_add(&s, &r, p);

		f25519_select(r.x, r.x, s.x, bit);
		f25519_select(r.y, r.y, s.y, bit);
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
    1dd8:	3f2d2f65 	svccc	0x002d2f65
    1ddc:	21492d68 	cmpcs	r9, r8, ror #26
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1de0:	7503242d 	strvc	r2, [r3, #-1069]	; 0x42d
    1de4:	3c0e0320 	stccc	3, cr0, [lr], {32}
    1de8:	2d4b3b2f 	vstrcs	d19, [fp, #-188]	; 0xffffff44
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
	}

	ed25519_copy(r_out, &r);
}
    1dec:	2c2f232f 	stccs	3, cr2, [pc], #-188	; 1d38 <ed25519_double+0x78>
    1df0:	77032b23 	strvc	r2, [r3, -r3, lsr #22]
    1df4:	212f1b58 	teqcs	pc, r8, asr fp	; <UNPREDICTABLE>
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1df8:	3f2d2f49 	svccc	0x002d2f49
    1dfc:	21492d68 	cmpcs	r9, r8, ror #26
    1e00:	7503242d 	strvc	r2, [r3, #-1069]	; 0x42d
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e04:	3c0e0320 	stccc	3, cr0, [lr], {32}
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1e08:	2d2f3b2f 	fstmdbxcs	pc!, {d3-d25}	;@ Deprecated
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e0c:	2c2f232f 	stccs	3, cr2, [pc], #-188	; 1d58 <ed25519_double+0x98>
    1e10:	de032b23 	vmlale.f64	d2, d3, d19
    1e14:	e4032e7e 	str	r2, [r3], #-3710	; 0xe7e
    1e18:	1e679e00 	cdpne	14, 6, cr9, cr7, cr0, {0}
	memcpy(block + 32, a, 32);
    1e1c:	4c262b31 	stcmi	11, cr2, [r6], #-196	; 0xffffff3c
    1e20:	4b3b301e 	blmi	ecdea0 <_etext+0xec688c>
    1e24:	232c2f31 	teqcs	ip, #49, 30	; 0xc4
    1e28:	2e2c032b 	cdpcs	3, 2, cr0, cr12, cr11, {1}
    1e2c:	032e5403 	teqeq	lr, #50331648	; 0x3000000
    1e30:	3d1b3c2c 	ldccc	12, cr3, [fp, #-176]	; 0xffffff50
    1e34:	2d2f6521 	cfstr32cs	mvfx6, [pc, #-132]!	; 1db8 <ed25519_smult+0x44>
    1e38:	492d683f 	pushmi	{r0, r1, r2, r3, r4, r5, fp, sp, lr}
    1e3c:	03242d21 	teqeq	r4, #2112	; 0x840
    1e40:	0e032075 	mcreq	0, 0, r2, cr3, cr5, {3}
    1e44:	2f3b2f3c 	svccs	0x003b2f3c
    1e48:	2f232f2d 	svccs	0x00232f2d
{
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
    1e4c:	032b232c 	teqeq	fp, #44, 6	; 0xb0000000
    1e50:	2f295877 	svccs	0x00295877
    1e54:	2d2f3b21 	fstmdbxcs	pc!, {d3-d18}	;@ Deprecated
		memcpy(init_block + prefix_size, message, len);
		sha512_final(&s, init_block, len + prefix_size);
	} else {
		size_t i;

		memcpy(init_block + prefix_size, message,
    1e58:	492d683f 	pushmi	{r0, r1, r2, r3, r4, r5, fp, sp, lr}
    1e5c:	03242d21 	teqeq	r4, #2112	; 0x840
    1e60:	0f032e75 	svceq	0x00032e75
    1e64:	49211f3c 	stmdbmi	r1!, {r2, r3, r4, r5, r8, r9, sl, fp, ip}
    1e68:	1e2f2f4d 	cdpne	15, 2, cr2, cr15, cr13, {2}
    1e6c:	91032b31 	tstls	r3, r1, lsr fp
    1e70:	04022001 	streq	r2, [r2], #-1
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);
    1e74:	fa010100 	blx	4227c <_etext+0x3ac68>
    1e78:	02000003 	andeq	r0, r0, #3

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e7c:	00016000 	andeq	r6, r1, r0
    1e80:	fb010200 	blx	4268a <_etext+0x3b076>
    1e84:	01000d0e 	tsteq	r0, lr, lsl #26
    1e88:	00010101 	andeq	r0, r1, r1, lsl #2
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1e8c:	00010000 	andeq	r0, r1, r0
		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
		     i + SHA512_BLOCK_SIZE <= len;
    1e90:	35320100 	ldrcc	r0, [r2, #-256]!	; 0x100
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1e94:	00393135 	eorseq	r3, r9, r5, lsr r1

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e98:	705c3a63 	subsvc	r3, ip, r3, ror #20
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
    1e9c:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
    1ea0:	66206d61 	strtvs	r6, [r0], -r1, ror #26
    1ea4:	73656c69 	cmnvc	r5, #26880	; 0x6900
    1ea8:	38782820 	ldmdacc	r8!, {r5, fp, sp}^
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
		memcpy(init_block + prefix_size, message, len);
    1eac:	675c2936 	smmlarvs	ip, r6, r9, r2
    1eb0:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
    1eb4:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
		sha512_final(&s, init_block, len + prefix_size);
    1eb8:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80
    1ebc:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000
    1ec0:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
	}

	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
    1ec4:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}
    1ec8:	30322038 	eorscc	r2, r2, r8, lsr r0
    1ecc:	33713431 	cmncc	r1, #822083584	; 0x31000000
	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
    1ed0:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
    1ed4:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    1ed8:	61652d65 	cmnvs	r5, r5, ror #26

static void sm_pack(uint8_t *r, const uint8_t *k)
{
	struct ed25519_pt p;

	ed25519_smult(&p, &ed25519_base, k);
    1edc:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^
    1ee0:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    1ee4:	6d5c6564 	cfldr64vs	mvdx6, [ip, #-400]	; 0xfffffe70
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1ee8:	69686361 	stmdbvs	r8!, {r0, r5, r6, r8, r9, sp, lr}^
    1eec:	6300656e 	movwvs	r6, #1390	; 0x56e
	ed25519_pack(packed, x, y);
    1ef0:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
    1ef4:	6172676f 	cmnvs	r2, pc, ror #14
    1ef8:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1efc:	2073656c 	rsbscs	r6, r3, ip, ror #10
    1f00:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16

	ed25519_project(p, x, y);
    1f04:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
    1f08:	6f742075 	svcvs	0x00742075
    1f0c:	20736c6f 	rsbscs	r6, r3, pc, ror #24
	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
    1f10:	206d7261 	rsbcs	r7, sp, r1, ror #4
    1f14:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
    1f18:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1f1c:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    1f20:	31303220 	teqcc	r0, r0, lsr #4

	ed25519_project(p, x, y);
    1f24:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
    1f28:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    1f2c:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
    1f30:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    1f34:	6e695c69 	cdpvs	12, 6, cr5, cr9, cr9, {3}
    1f38:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1f3c:	3a630065 	bcc	18c20d8 <_etext+0x18baac4>
    1f40:	6f72705c 	svcvs	0x0072705c
	ed25519_pack(packed, x, y);
    1f44:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64
    1f48:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
    1f4c:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
    1f50:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
    1f54:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
    1f58:	6f6f7420 	svcvs	0x006f7420
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
}
    1f5c:	6120736c 	teqvs	r0, ip, ror #6
    1f60:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1f64:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
    1f68:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
    1f6c:	20382e34 	eorscs	r2, r8, r4, lsr lr
    1f70:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32

const uint8_t f25519_zero[F25519_SIZE] = {0};
const uint8_t f25519_one[F25519_SIZE] = {1};

void f25519_load(uint8_t *x, uint32_t c)
{
    1f74:	6c5c3371 	mrrcvs	3, 7, r3, ip, cr1
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
		c >>= 8;
    1f78:	675c6269 	ldrbvs	r6, [ip, -r9, ror #4]
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    1f7c:	615c6363 	cmpvs	ip, r3, ror #6
    1f80:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
    1f84:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
    1f88:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
		c >>= 8;
	}

	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}
    1f8c:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    1f90:	695c342e 	ldmdbvs	ip, {r1, r2, r3, r5, sl, ip, sp}^

void f25519_normalize(uint8_t *x)
{
    1f94:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    1f98:	00006564 	andeq	r6, r0, r4, ror #10
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1f9c:	69727066 	ldmdbvs	r2!, {r1, r2, r5, r6, ip, sp, lr}^
	x[31] &= 127;
    1fa0:	632e656d 	teqvs	lr, #457179136	; 0x1b400000

	for (i = 0; i < F25519_SIZE; i++) {
    1fa4:	00000100 	andeq	r0, r0, r0, lsl #2
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1fa8:	69727066 	ldmdbvs	r2!, {r1, r2, r5, r6, ip, sp, lr}^
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
		c += x[i];
    1fac:	682e656d 	stmdavs	lr!, {r0, r2, r3, r5, r6, r8, sl, sp, lr}
		x[i] = c;
    1fb0:	00000100 	andeq	r0, r0, r0, lsl #2

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fb4:	6665645f 			; <UNDEFINED> instruction: 0x6665645f
		c += x[i];
		x[i] = c;
		c >>= 8;
    1fb8:	746c7561 	strbtvc	r7, [ip], #-1377	; 0x561

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fbc:	7079745f 	rsbsvc	r7, r9, pc, asr r4
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += x[i];
    1fc0:	682e7365 	stmdavs	lr!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
		minusp[i] = c;
    1fc4:	00000200 	andeq	r0, r0, r0, lsl #4
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1fc8:	69647473 	stmdbvs	r4!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
		c += x[i];
		minusp[i] = c;
		c >>= 8;
    1fcc:	682e746e 	stmdavs	lr!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1fd0:	00000300 	andeq	r0, r0, r0, lsl #6
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fd4:	64647473 	strbtvs	r7, [r4], #-1139	; 0x473
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1fd8:	682e6665 	stmdavs	lr!, {r0, r2, r5, r6, r9, sl, sp, lr}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1fdc:	00000400 	andeq	r0, r0, r0, lsl #8
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;
    1fe0:	02050000 	andeq	r0, r5, #0

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1fe4:	00000000 	andeq	r0, r0, r0
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    1fe8:	0100c903 	tsteq	r0, r3, lsl #18
    1fec:	027a3b25 	rsbseq	r3, sl, #37888	; 0x9400
    1ff0:	01010004 	tsteq	r1, r4
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1ff4:	e8020500 	stmda	r2, {r8, sl}
    1ff8:	0300002e 	movweq	r0, #46	; 0x2e
	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;

	/* Load x-p if no underflow */
	f25519_select(x, minusp, x, (c >> 15) & 1);
}
    1ffc:	4a0100dd 	bmi	42378 <_etext+0x3ad64>
    2000:	673c4f03 	ldrvs	r4, [ip, -r3, lsl #30]!

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
    2004:	2c222240 	sfmcs	f2, 4, [r2], #-256	; 0xffffff00
    2008:	032e2b03 	teqeq	lr, #3072	; 0xc00
    200c:	33522e79 	cmpcc	r2, #1936	; 0x790
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    2010:	342d295a 	strtcc	r2, [sp], #-2394	; 0x95a
    2014:	02040200 	andeq	r0, r4, #0, 4
    2018:	06132202 	ldreq	r2, [r3], -r2, lsl #4
    201c:	3d49069e 	stclcc	6, cr0, [r9, #-632]	; 0xfffffd88
    2020:	3d3b212d 	ldfccs	f2, [fp, #-180]!	; 0xffffff4c
    2024:	0368211f 	cmneq	r8, #-1073741817	; 0xc0000007
    2028:	1e4b3c59 	mcrne	12, 2, r3, cr11, cr9, {2}
    202c:	2a032b31 	bcs	cccf8 <_etext+0xc56e4>
    2030:	0200bd20 	andeq	fp, r0, #32, 26	; 0x800
    2034:	003d0204 	eorseq	r0, sp, r4, lsl #4
    2038:	03020402 	movweq	r0, #9218	; 0x2402
    203c:	0200664f 	andeq	r6, r0, #82837504	; 0x4f00000
    2040:	31030204 	tstcc	r3, r4, lsl #4
    2044:	04020020 	streq	r0, [r2], #-32
    2048:	2e520302 	cdpcs	3, 5, cr0, cr2, cr2, {0}
    204c:	311e3d21 	tstcc	lr, r1, lsr #26
    2050:	0402002b 	streq	r0, [r2], #-43	; 0x2b
    2054:	20310302 	eorscs	r0, r1, r2, lsl #6
    2058:	02040200 	andeq	r0, r4, #0, 4
    205c:	207fa803 	rsbscs	sl, pc, r3, lsl #16
    2060:	02040200 	andeq	r0, r4, #0, 4
    2064:	2000d803 	andcs	sp, r0, r3, lsl #16
    2068:	02040200 	andeq	r0, r4, #0, 4
    206c:	2e7fab03 	vaddcs.f64	d26, d15, d3

	sum |= (sum >> 4);
    2070:	312c5921 	teqcc	ip, r1, lsr #18
	sum |= (sum >> 2);
    2074:	00f5032b 	rscseq	r0, r5, fp, lsr #6
	sum |= (sum >> 1);
    2078:	73213120 	teqvc	r1, #32, 2

	return (sum ^ 1) & 1;
    207c:	433c5903 	teqmi	ip, #49152	; 0xc000
}
    2080:	3c7fbb03 	ldclcc	11, cr11, [pc], #-12	; 207c <f25519_eq+0x78>
    2084:	35031e31 	strcc	r1, [r3, #-3633]	; 0xe31
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2088:	032d213c 	teqeq	sp, #60, 2
		sum |= x[i] ^ y[i];
    208c:	03024a4d 	movweq	r4, #10829	; 0x2a4d
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2090:	00010100 	andeq	r0, r1, r0, lsl #2
    2094:	00000205 	andeq	r0, r0, r5, lsl #4
		sum |= x[i] ^ y[i];
    2098:	f8030000 			; <UNDEFINED> instruction: 0xf8030000
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    209c:	312e0100 	teqcc	lr, r0, lsl #2
}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
    20a0:	ac030204 	sfmge	f0, 4, [r3], {4}
    20a4:	0104587f 	tsteq	r4, pc, ror r8
    20a8:	ac00d603 	stcge	6, cr13, [r0], {3}
    20ac:	01000202 	tsteq	r0, r2, lsl #4
    20b0:	02050001 	andeq	r0, r5, #1
    20b4:	00000000 	andeq	r0, r0, r0
    20b8:	01018003 	tsteq	r1, r3
    20bc:	1431025d 	ldrtne	r0, [r1], #-605	; 0x25d
    20c0:	2f302f2f 	svccs	0x00302f2f
	const uint8_t mask = -condition;
    20c4:	1d4a7803 	stclne	8, cr7, [sl, #-12]
    20c8:	1f212d24 	svcne	0x00212d24
    20cc:	02022d21 	andeq	r2, r2, #2112	; 0x840
    20d0:	00010100 	andeq	r0, r1, r0, lsl #2
    20d4:	00000205 	andeq	r0, r0, r5, lsl #4
    20d8:	91030000 	mrsls	r0, (UNDEF: 3)
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    20dc:	13080101 	movwne	r0, #33025	; 0x8101
    20e0:	133202be 	teqne	r2, #-536870901	; 0xe000000b
    20e4:	211e4b1f 	tstcs	lr, pc, lsl fp
    20e8:	02023e65 	andeq	r3, r2, #1616	; 0x650
    20ec:	00010100 	andeq	r0, r1, r0, lsl #2
    20f0:	00000205 	andeq	r0, r0, r5, lsl #4
    20f4:	9a030000 	bls	c20fc <_etext+0xbaae8>
    20f8:	f3030101 	vrhadd.u8	d0, d3, d1
    20fc:	8d03207e 	stchi	0, cr2, [r3, #-504]	; 0xfffffe08
    2100:	f6032001 			; <UNDEFINED> instruction: 0xf6032001
    2104:	4b21207e 	blmi	84a304 <_etext+0x842cf0>
    2108:	032b311e 	teqeq	fp, #-2147483641	; 0x80000007
    210c:	2c593c0e 	mrrccs	12, 0, r3, r9, cr14
    2110:	f5032b31 			; <UNDEFINED> instruction: 0xf5032b31
    2114:	21312000 	teqcs	r1, r0
    2118:	03024473 	movweq	r4, #9331	; 0x2473
    211c:	00010100 	andeq	r0, r1, r0, lsl #2
    2120:	00000205 	andeq	r0, r0, r5, lsl #4
    2124:	a0030000 	andge	r0, r3, r0
    2128:	ed030101 	stfs	f0, [r3, #-4]
    212c:	9303207e 	movwls	r2, #12414	; 0x307e
    2130:	f0032001 			; <UNDEFINED> instruction: 0xf0032001
    2134:	4b21207e 	blmi	84a334 <_etext+0x842d20>
    2138:	032b311e 	teqeq	fp, #-2147483641	; 0x80000007
    213c:	2c593c0e 	mrrccs	12, 0, r3, r9, cr14
    2140:	f5032b31 			; <UNDEFINED> instruction: 0xf5032b31
    2144:	21312000 	teqcs	r1, r0
}
    2148:	7f850373 	svcvc	0x00850373
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    214c:	5921233c 	stmdbpl	r1!, {r2, r3, r4, r5, r8, r9, sp}
    2150:	032b312c 	teqeq	fp, #44, 2
    2154:	312000f5 	strdcc	r0, [r0, -r5]!
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2158:	0f037321 	svceq	0x00037321
    215c:	0003023c 	andeq	r0, r3, ip, lsr r2
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}
    2160:	05000101 	streq	r0, [r0, #-257]	; 0x101
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    2164:	00000002 	andeq	r0, r0, r2
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}

void f25519_add(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint16_t c = 0;
    2168:	01a80300 			; <UNDEFINED> instruction: 0x01a80300
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
    216c:	2b234a01 	blcs	8d4978 <_etext+0x8cd364>
    2170:	7f810331 	svcvc	0x00810331
		r[i] = c;
    2174:	2240672e 	subcs	r6, r0, #12058624	; 0xb80000
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    2178:	fa032c22 	blx	cd208 <_etext+0xc5bf4>
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;
    217c:	02002000 	andeq	r2, r0, #0
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    2180:	004b0204 	subeq	r0, fp, r4, lsl #4
	c = (c >> 7) * 19;
    2184:	03020402 	movweq	r0, #9218	; 0x2402
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    2188:	00827f90 	umulleq	r7, r2, r0, pc	; <UNPREDICTABLE>
	c = (c >> 7) * 19;
    218c:	03020402 	movweq	r0, #9218	; 0x2402
    2190:	002000f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2194:	03020402 	movweq	r0, #9218	; 0x2402
    2198:	212e7f93 			; <UNDEFINED> instruction: 0x212e7f93

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    219c:	2b311e3d 	blcs	c49a98 <_etext+0xc42484>
		c += r[i];
		r[i] = c;
		c >>= 8;
    21a0:	593c5d03 	ldmdbpl	ip!, {r0, r1, r8, sl, fp, ip, lr}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21a4:	032b311e 	teqeq	fp, #-2147483641	; 0x80000007
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    21a8:	312000f5 	strdcc	r0, [r0, -r5]!

void f25519_sub(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    21ac:	02046521 	andeq	r6, r4, #138412032	; 0x8400000
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
    21b0:	3c7f9203 	lfmcc	f1, 3, [pc], #-12	; 21ac <f25519_sub>
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    21b4:	66030104 	strvs	r0, [r3], -r4, lsl #2
    21b8:	0302049e 	movweq	r0, #9374	; 0x249e
    21bc:	01042e1a 	tsteq	r4, sl, lsl lr
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21c0:	21206903 	teqcs	r0, r3, lsl #18
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    21c4:	2b312c67 	blcs	c4d368 <_etext+0xc45d54>
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21c8:	673c0e03 	ldrvs	r0, [ip, -r3, lsl #28]!
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    21cc:	032b311e 	teqeq	fp, #-2147483641	; 0x80000007
    21d0:	312000f5 	strdcc	r0, [r0, -r5]!
	r[31] = c & 127;
	c = (c >> 7) * 19;
    21d4:	4d398121 	ldfmid	f0, [r9, #-132]!	; 0xffffff7c
    21d8:	02008121 	andeq	r8, r0, #1073741832	; 0x40000008
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    21dc:	18030204 	stmdane	r3, {r2, r9}
	c = (c >> 7) * 19;
    21e0:	3c0c033c 	stccc	3, cr0, [ip], {60}	; 0x3c

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    21e4:	3c7ef703 	ldclcc	7, cr15, [lr], #-12
		r[i] = c;
    21e8:	03022c31 	movweq	r2, #11313	; 0x2c31

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21ec:	00010100 	andeq	r0, r1, r0, lsl #2
		c += r[i];
		r[i] = c;
		c >>= 8;
    21f0:	00000205 	andeq	r0, r0, r5, lsl #4
	}
}
    21f4:	bc030000 	stclt	0, cr0, [r3], {-0}

void f25519_neg(uint8_t *r, const uint8_t *a)
{
    21f8:	02040101 	andeq	r0, r4, #1073741824	; 0x40000000
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
    21fc:	3c7eeb03 	ldclcc	11, cr14, [lr], #-12
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 - ((uint32_t)a[i]);
    2200:	95030104 	strls	r0, [r3, #-260]	; 0x104
    2204:	04202001 	strteq	r2, [r0], #-1
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2208:	7eeb0302 	cdpvc	3, 14, cr0, cr11, cr2, {0}
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
    220c:	0301042e 	movweq	r0, #5166	; 0x142e
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2210:	0490019c 	ldreq	r0, [r0], #412	; 0x19c

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2214:	7ee40302 	cdpvc	3, 14, cr0, cr4, cr2, {0}
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2218:	03010420 	movweq	r0, #5152	; 0x1420
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    221c:	00200197 	mlaeq	r0, r7, r1, r0
	c = (c >> 7) * 19;
    2220:	26020402 	strcs	r0, [r2], -r2, lsl #8
    2224:	02040200 	andeq	r0, r4, #0, 4

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2228:	0402003d 	streq	r0, [r2], #-61	; 0x3d
		r[i] = c;
    222c:	02002c02 	andeq	r2, r0, #512	; 0x200

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2230:	00310204 	eorseq	r0, r1, r4, lsl #4
		c += r[i];
		r[i] = c;
		c >>= 8;
    2234:	2b020402 	blcs	83244 <_etext+0x7bc30>
	}
}
    2238:	207f8a03 	rsbscs	r8, pc, r3, lsl #20
    223c:	2e5a03a3 	cdpcs	3, 5, cr0, cr10, cr3, {5}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2240:	2222403d 	eorcs	r4, r2, #61	; 0x3d
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2244:	0199032c 	orrseq	r0, r9, ip, lsr #6
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    2248:	03020420 	movweq	r0, #9248	; 0x2420
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    224c:	043c7edb 	ldrteq	r7, [ip], #-3803	; 0xedb
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2250:	01a50301 			; <UNDEFINED> instruction: 0x01a50301
		for (j = 0; j <= i; j++)
    2254:	03020420 	movweq	r0, #9248	; 0x2420
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2258:	042e7edb 	strteq	r7, [lr], #-3803	; 0xedb

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    225c:	01a50301 			; <UNDEFINED> instruction: 0x01a50301
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2260:	ad68239e 	stclge	3, cr2, [r8, #-632]!	; 0xfffffd88

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2264:	03667a03 	cmneq	r6, #12288	; 0x3000
    2268:	da033c0a 	ble	d1298 <_etext+0xc9c84>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    226c:	2c313c7e 	ldccs	12, cr3, [r1], #-504	; 0xfffffe08
    2270:	01000302 	tsteq	r0, r2, lsl #6
    2274:	00015201 	andeq	r5, r1, r1, lsl #4
    2278:	fb000200 	blx	2a82 <f25519_sqrt+0x1ce>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    227c:	02000000 	andeq	r0, r0, #0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2280:	0d0efb01 	vstreq	d15, [lr, #-4]
    2284:	01010100 	mrseq	r0, (UNDEF: 17)

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2288:	00000001 	andeq	r0, r0, r1
			c += ((uint32_t)a[j]) *
    228c:	01000001 	tsteq	r0, r1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2290:	31353532 	teqcc	r5, r2, lsr r5
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2294:	3a630039 	bcc	18c2380 <_etext+0x18bad6c>
    2298:	6f72705c 	svcvs	0x0072705c
    229c:	6d617267 	sfmvs	f7, 2, [r1, #-412]!	; 0xfffffe64

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    22a0:	6c696620 	stclvs	6, cr6, [r9], #-128	; 0xffffff80
    22a4:	28207365 	stmdacs	r0!, {r0, r2, r5, r6, r8, r9, ip, sp, lr}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22a8:	29363878 	ldmdbcs	r6!, {r3, r4, r5, r6, fp, ip, sp}
	c = (c >> 7) * 19;
    22ac:	756e675c 	strbvc	r6, [lr, #-1884]!	; 0x75c

	for (i = 0; i < F25519_SIZE; i++) {
    22b0:	6f6f7420 	svcvs	0x006f7420
		c += r[i];
    22b4:	6120736c 	teqvs	r0, ip, ror #6
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22b8:	65206d72 	strvs	r6, [r0, #-3442]!	; 0xd72
		c += r[i];
		r[i] = c;
		c >>= 8;
    22bc:	6465626d 	strbtvs	r6, [r5], #-621	; 0x26d
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22c0:	5c646564 	cfstr64pl	mvdx6, [r4], #-400	; 0xfffffe70
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    22c4:	20382e34 	eorscs	r2, r8, r4, lsr lr
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    22c8:	34313032 	ldrtcc	r3, [r1], #-50	; 0x32
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    22cc:	615c3371 	cmpvs	ip, r1, ror r3
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    22d0:	6e2d6d72 	mcrvs	13, 1, r6, cr13, cr2, {3}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22d4:	2d656e6f 	stclcs	14, cr6, [r5, #-444]!	; 0xfffffe44
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    22d8:	69626165 	stmdbvs	r2!, {r0, r2, r5, r6, r8, sp, lr}^
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22dc:	636e695c 	cmnvs	lr, #92, 18	; 0x170000
    22e0:	6564756c 	strbvs	r7, [r4, #-1388]!	; 0x56c

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22e4:	63616d5c 	cmnvs	r1, #92, 26	; 0x1700
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22e8:	656e6968 	strbvs	r6, [lr, #-2408]!	; 0x968

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22ec:	5c3a6300 	ldcpl	3, cr6, [sl], #-0
    22f0:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22f4:	206d6172 	rsbcs	r6, sp, r2, ror r1
    22f8:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966
    22fc:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2300:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2304:	20756e67 	rsbscs	r6, r5, r7, ror #28
    2308:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; 2140 <f25519_select+0xa0>

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    230c:	72612073 	rsbvc	r2, r1, #115	; 0x73
			c += ((uint32_t)a[j]) *
    2310:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2314:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2318:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465
    231c:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2320:	71343130 	teqvc	r4, r0, lsr r1
	c = (c >> 7) * 19;
    2324:	72615c33 	rsbvc	r5, r1, #13056	; 0x3300
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2328:	6f6e2d6d 	svcvs	0x006e2d6d
	c = (c >> 7) * 19;
    232c:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2330:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c
    2334:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2338:	00656475 	rsbeq	r6, r5, r5, ror r4
		r[i] = c;
    233c:	726f6d00 	rsbvc	r6, pc, #0, 26
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2340:	35326870 	ldrcc	r6, [r2, #-2160]!	; 0x870
		c += r[i];
		r[i] = c;
		c >>= 8;
    2344:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2348:	00010063 	andeq	r0, r1, r3, rrx
    234c:	65645f00 	strbvs	r5, [r4, #-3840]!	; 0xf00
    2350:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2354:	79745f74 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2358:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
		for (j = 0; j <= i; j++)
    235c:	00020068 	andeq	r0, r2, r8, rrx
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2360:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
    2364:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2368:	00030068 	andeq	r0, r3, r8, rrx
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    236c:	35326600 	ldrcc	r6, [r2, #-1536]!	; 0x600

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2370:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2374:	00010068 	andeq	r0, r1, r8, rrx
    2378:	05000000 	streq	r0, [r0, #-0]
    237c:	00000002 	andeq	r0, r0, r2
    2380:	010a0300 	mrseq	r0, (UNDEF: 58)
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2384:	24201c24 	strtcs	r1, [r0], #-3108	; 0xc24
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2388:	4b4b241c 	blmi	12cb400 <_etext+0x12c3dec>
    238c:	023d5959 	eorseq	r5, sp, #1458176	; 0x164000
    2390:	01010005 	tsteq	r1, r5

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2394:	00020500 	andeq	r0, r2, r0, lsl #10
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2398:	03000000 	movweq	r0, #0
    239c:	030100cc 	movweq	r0, #4300	; 0x10cc

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    23a0:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
    23a4:	4e032020 	cdpmi	0, 0, cr2, cr3, cr0, {1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    23a8:	3c32033c 	ldccc	3, cr0, [r2], #-240	; 0xffffff10
	c = (c >> 7) * 19;
    23ac:	2f204e03 	svccs	0x00204e03

	for (i = 0; i < F25519_SIZE; i++) {
    23b0:	1103594b 	tstne	r3, fp, asr #18
		c += r[i];
    23b4:	59595b58 	ldmdbpl	r9, {r3, r4, r6, r8, r9, fp, ip, lr}^
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23b8:	4b5b5b4d 	blmi	16d90f4 <_etext+0x16d1ae0>
		c += r[i];
		r[i] = c;
		c >>= 8;
    23bc:	3d59af4d 	ldclcc	15, cr10, [r9, #-308]	; 0xfffffecc
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23c0:	580b033e 	stmdapl	fp, {r1, r2, r3, r4, r5, r8, r9}
    23c4:	09023f3d 	stmdbeq	r2, {r0, r2, r3, r4, r5, r8, r9, sl, fp, ip, sp}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    23c8:	05010100 	streq	r0, [r1, #-256]	; 0x100
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23cc:	02000008 	andeq	r0, r0, #8
    23d0:	00003100 	andeq	r3, r0, r0, lsl #2
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    23d4:	fb010200 	blx	42bde <_etext+0x3b5ca>
		for (j = 0; j <= i; j++)
    23d8:	01000d0e 	tsteq	r0, lr, lsl #26
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23dc:	00010101 	andeq	r0, r1, r1, lsl #2
    23e0:	00010000 	andeq	r0, r1, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23e4:	35320100 	ldrcc	r0, [r2, #-256]!	; 0x100
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23e8:	00393135 	eorseq	r3, r9, r5, lsr r1

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23ec:	61687300 	cmnvs	r8, r0, lsl #6
    23f0:	2e363532 	mrccs	5, 1, r3, cr6, cr2, {1}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23f4:	00010063 	andeq	r0, r1, r3, rrx
    23f8:	61687300 	cmnvs	r8, r0, lsl #6
    23fc:	2e363532 	mrccs	5, 1, r3, cr6, cr2, {1}
    2400:	00010068 	andeq	r0, r1, r8, rrx
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2404:	05000000 	streq	r0, [r0, #-0]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2408:	00308802 	eorseq	r8, r0, r2, lsl #16
    240c:	012f0300 	teqeq	pc, r0, lsl #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2410:	21302d33 	teqcs	r0, r3, lsr sp
			c += ((uint32_t)a[j]) *
    2414:	21212121 	teqcs	r1, r1, lsr #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2418:	23207603 	teqcs	r0, #3145728	; 0x300000
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    241c:	21212130 	teqcs	r1, r0, lsr r1
    2420:	0321331c 	teqeq	r1, #28, 6	; 0x70000000
    2424:	03212076 	teqeq	r1, #118	; 0x76
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2428:	1302200a 	movwne	r2, #8202	; 0x200a
	c = (c >> 7) * 19;
    242c:	00010100 	andeq	r0, r1, r0, lsl #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2430:	30e00205 	rsccc	r0, r0, r5, lsl #4
	c = (c >> 7) * 19;
    2434:	3e030000 	cdpcc	0, 0, cr0, cr3, cr0, {0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2438:	34033c01 	strcc	r3, [r3], #-3073	; 0xc01
	c = (c >> 7) * 19;
    243c:	22211e20 	eorcs	r1, r1, #32, 28	; 0x200

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2440:	24207903 	strtcs	r7, [r0], #-2307	; 0x903
		r[i] = c;
    2444:	03241f22 	teqeq	r4, #34, 30	; 0x88
		c >>= 8;
    2448:	03262e78 	teqeq	r6, #120, 28	; 0x780
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    244c:	1f262079 	svcne	0x00262079
    2450:	22271f1c 	eorcs	r1, r7, #28, 30	; 0x70
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2454:	213c7803 	teqcs	ip, r3, lsl #16
    2458:	74790327 	ldrbtvc	r0, [r9], #-807	; 0x327
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    245c:	03205403 	teqeq	r0, #50331648	; 0x3000000
    2460:	4d032033 	stcmi	0, cr2, [r3, #-204]	; 0xffffff34

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2464:	2e2c0366 	cdpcs	3, 2, cr0, cr12, cr6, {3}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2468:	03205403 	teqeq	r0, #50331648	; 0x3000000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    246c:	4d032e33 	stcmi	14, cr2, [r3, #-204]	; 0xffffff34
    2470:	74330366 	ldrtvc	r0, [r3], #-870	; 0x366
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2474:	034a4d03 	movteq	r4, #44291	; 0xad03
    2478:	4e032e33 	mcrmi	14, 0, r2, cr3, cr3, {1}
    247c:	2e32034a 	cdpcs	3, 3, cr0, cr2, cr10, {2}
    2480:	1f2e4e03 	svcne	0x002e4e03
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2484:	262e2d03 	strtcs	r2, [lr], -r3, lsl #26
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2488:	26207a03 	strtcs	r7, [r0], -r3, lsl #20
    248c:	03204e03 	teqeq	r0, #3, 28	; 0x30

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2490:	4e033c32 	mcrmi	12, 0, r3, cr3, cr2, {1}
			c += ((uint32_t)a[j]) *
    2494:	3c2c032e 	stccc	3, cr0, [ip], #-184	; 0xffffff48
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2498:	204e0326 	subcs	r0, lr, r6, lsr #6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    249c:	1f2e3303 	svcne	0x002e3303
    24a0:	4e031f2f 	cdpmi	15, 0, cr1, cr3, cr15, {1}
    24a4:	2e320320 	cdpcs	3, 3, cr0, cr2, cr0, {1}

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    24a8:	033c4e03 	teqeq	ip, #3, 28	; 0x30
    24ac:	4e032033 	mcrmi	0, 0, r2, cr3, cr3, {1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    24b0:	32039e08 	andcc	r9, r3, #8, 28	; 0x80
	c = (c >> 7) * 19;
    24b4:	664e0320 	strbvs	r0, [lr], -r0, lsr #6

	for (i = 0; i < F25519_SIZE; i++) {
    24b8:	03203203 	teqeq	r0, #805306368	; 0x30000000
		c += r[i];
    24bc:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24c0:	204e0320 	subcs	r0, lr, r0, lsr #6
		c += r[i];
		r[i] = c;
		c >>= 8;
    24c4:	2f203203 	svccs	0x00203203
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24c8:	03204d03 	teqeq	r0, #3, 26	; 0xc0
	/* 1 1 */
	f25519_mul__distinct(s, x, x);
	f25519_mul__distinct(r, s, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    24cc:	03214a32 	teqeq	r1, #204800	; 0x32000
    24d0:	33032e4d 	movwcc	r2, #15949	; 0x3e4d
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24d4:	084e033c 	stmdaeq	lr, {r2, r3, r4, r5, r8, r9}^
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    24d8:	2032032e 	eorscs	r0, r2, lr, lsr #6
    24dc:	03664e03 	cmneq	r6, #3, 28	; 0x30
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24e0:	4e032032 	mcrmi	0, 0, r2, cr3, cr2, {1}
    24e4:	2e320366 	cdpcs	3, 3, cr0, cr2, cr6, {3}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24e8:	034a4e03 	movteq	r4, #44547	; 0xae03
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24ec:	4e033c32 	mcrmi	12, 0, r3, cr3, cr2, {1}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24f0:	20320320 	eorscs	r0, r2, r0, lsr #6
    24f4:	032e4e03 	teqeq	lr, #3, 28	; 0x30
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24f8:	4f032e32 	svcmi	0x00032e32
    24fc:	2032033c 	eorscs	r0, r2, ip, lsr r3
    2500:	03204d03 	teqeq	r0, #3, 26	; 0xc0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2504:	4e032033 	mcrmi	0, 0, r2, cr3, cr3, {1}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2508:	20320320 	eorscs	r0, r2, r0, lsr #6
    250c:	032e4e03 	teqeq	lr, #3, 28	; 0x30

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2510:	4e032032 	mcrmi	0, 0, r2, cr3, cr2, {1}
			c += ((uint32_t)a[j]) *
    2514:	2e320358 	mrccs	3, 1, r0, cr2, cr8, {2}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2518:	032e4e03 	teqeq	lr, #3, 28	; 0x30
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    251c:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2520:	2e3203ba 	mrccs	3, 1, r0, cr2, cr10, {5}
    2524:	03904e03 	orrseq	r4, r0, #3, 28	; 0x30
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2528:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
	c = (c >> 7) * 19;
    252c:	4a32032e 	bmi	c831ec <_etext+0xc7bbd8>
    2530:	032e4e03 	teqeq	lr, #3, 28	; 0x30
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2534:	4e032032 	mcrmi	0, 0, r2, cr3, cr2, {1}
	c = (c >> 7) * 19;
    2538:	2e32033c 	mrccs	3, 1, r0, cr2, cr12, {1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    253c:	03204f03 	teqeq	r0, #3, 30
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2540:	032d2032 	teqeq	sp, #50	; 0x32
		r[i] = c;
    2544:	031f2e4f 	tsteq	pc, #1264	; 0x4f0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2548:	4e032e33 	mcrmi	14, 0, r2, cr3, cr3, {1}
		c += r[i];
		r[i] = c;
		c >>= 8;
    254c:	20310358 	eorscs	r0, r1, r8, asr r3
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2550:	03204f03 	teqeq	r0, #3, 30
    2554:	212d2032 	teqcs	sp, r2, lsr r0
    2558:	03e44e03 	mvneq	r4, #3, 28	; 0x30
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    255c:	4e032032 	mcrmi	0, 0, r2, cr3, cr2, {1}
    2560:	20320358 	eorscs	r0, r2, r8, asr r3
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2564:	034a4e03 	movteq	r4, #44547	; 0xae03
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2568:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
    256c:	4a32034a 	bmi	c8329c <_etext+0xc7bc88>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2570:	03204e03 	teqeq	r0, #3, 28	; 0x30
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2574:	4e032032 	mcrmi	0, 0, r2, cr3, cr2, {1}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2578:	2e33032e 	cdpcs	3, 3, cr0, cr3, cr14, {1}
    257c:	2e4e031f 	mcrcs	3, 2, r0, cr14, cr15, {0}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2580:	2032032f 	eorscs	r0, r2, pc, lsr #6
    2584:	03204e03 	teqeq	r0, #3, 28	; 0x30
    2588:	2fab2032 	svccs	0x00ab2032
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    258c:	03584e03 	cmpeq	r8, #3, 28	; 0x30
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2590:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
    2594:	2e320366 	cdpcs	3, 3, cr0, cr2, cr6, {3}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2598:	03204e03 	teqeq	r0, #3, 28	; 0x30
			c += ((uint32_t)a[j]) *
    259c:	4e036632 	mcrmi	6, 0, r6, cr3, cr2, {1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    25a0:	4a32034a 	bmi	c832d0 <_etext+0xc7bcbc>
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    25a4:	1f3d3b75 	svcne	0x003d3b75
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25a8:	4f032d21 	svcmi	0x00032d21
	c = (c >> 7) * 19;
    25ac:	2e310320 	cdpcs	3, 3, cr0, cr1, cr0, {1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25b0:	744e032f 	strbvc	r0, [lr], #-815	; 0x32f
	c = (c >> 7) * 19;
    25b4:	212e3103 	teqcs	lr, r3, lsl #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25b8:	03584e03 	cmpeq	r8, #3, 28	; 0x30
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    25bc:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
		r[i] = c;
    25c0:	2e320366 	cdpcs	3, 3, cr0, cr2, cr6, {3}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    25c4:	03204e03 	teqeq	r0, #3, 28	; 0x30
		c += r[i];
		r[i] = c;
		c >>= 8;
    25c8:	4e035832 	mcrmi	8, 0, r5, cr3, cr2, {1}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    25cc:	2e320366 	cdpcs	3, 3, cr0, cr2, cr6, {3}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25d0:	032e4e03 	teqeq	lr, #3, 28	; 0x30
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    25d4:	67200832 			; <UNDEFINED> instruction: 0x67200832
		for (j = 0; j <= i; j++)
    25d8:	211f213b 	tstcs	pc, fp, lsr r1	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25dc:	3c4f032d 	mcrrcc	3, 2, r0, pc, cr13
    25e0:	032e3203 	teqeq	lr, #805306368	; 0x30000000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25e4:	3203824e 	andcc	r8, r3, #-536870908	; 0xe0000004
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25e8:	664e032e 	strbvs	r0, [lr], -lr, lsr #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25ec:	033c3203 	teqeq	ip, #805306368	; 0x30000000
    25f0:	3203ba4e 	andcc	fp, r3, #319488	; 0x4e000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25f4:	4a4e033c 	bmi	13832ec <_etext+0x137bcd8>
    25f8:	032e3203 	teqeq	lr, #805306368	; 0x30000000
    25fc:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2600:	2e4e0320 	cdpcs	3, 4, cr0, cr14, cr0, {1}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2604:	4b2e3203 	blmi	b8ee18 <_etext+0xb87804>
    2608:	033c4e03 	teqeq	ip, #3, 28	; 0x30

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    260c:	4d032e32 	stcmi	14, cr2, [r3, #-200]	; 0xffffff38
			c += ((uint32_t)a[j]) *
    2610:	032d2f20 	teqeq	sp, #32, 30	; 0x80
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2614:	4e032e33 	mcrmi	14, 0, r2, cr3, cr3, {1}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2618:	32032008 	andcc	r2, r3, #8
    261c:	904e033c 	subls	r0, lr, ip, lsr r3
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2620:	033c3203 	teqeq	ip, #805306368	; 0x30000000
	c = (c >> 7) * 19;
    2624:	32034a4e 	andcc	r4, r3, #319488	; 0x4e000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2628:	2e4e032e 	cdpcs	3, 4, cr0, cr14, cr14, {1}
	c = (c >> 7) * 19;
    262c:	032e3203 	teqeq	lr, #805306368	; 0x30000000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2630:	3203204e 	andcc	r2, r3, #78	; 0x4e
	c = (c >> 7) * 19;
    2634:	031f2120 	tsteq	pc, #32, 2

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2638:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
		r[i] = c;
    263c:	211f3d2e 	tstcs	pc, lr, lsr #26
		c >>= 8;
    2640:	2d3c4e03 	ldccs	14, cr4, [ip, #-12]!
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2644:	03203303 	teqeq	r0, #201326592	; 0xc000000
    2648:	3203584e 	andcc	r5, r3, #5111808	; 0x4e0000
    264c:	584e032e 	stmdapl	lr, {r1, r2, r3, r5, r8, r9}^
    2650:	03203203 	teqeq	r0, #805306368	; 0x30000000
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2654:	3203824e 	andcc	r8, r3, #-536870908	; 0xe0000004
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2658:	744e032e 	strbvc	r0, [lr], #-814	; 0x32e
		for (j = 0; j <= i; j++)
    265c:	033c3203 	teqeq	ip, #805306368	; 0x30000000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2660:	3203584e 	andcc	r5, r3, #5111808	; 0x4e0000
    2664:	204e032e 	subcs	r0, lr, lr, lsr #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2668:	213c3203 	teqcs	ip, r3, lsl #4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    266c:	031f211f 	tsteq	pc, #-1073741817	; 0xc0000007

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2670:	3303204e 	movwcc	r2, #12366	; 0x304e
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2674:	1f2f3b2e 	svcne	0x002f3b2e
    2678:	584e0321 	stmdapl	lr, {r0, r5, r8, r9}^
    267c:	032e3203 	teqeq	lr, #805306368	; 0x30000000
    2680:	3203664e 	andcc	r6, r3, #81788928	; 0x4e00000
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2684:	4a4d034a 	bmi	13433b4 <_etext+0x133bda0>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2688:	032e3303 	teqeq	lr, #201326592	; 0xc000000
    268c:	3203744e 	andcc	r7, r3, #1308622848	; 0x4e000000
    2690:	4a4e032e 	bmi	1383350 <_etext+0x137bd3c>

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2694:	033c3203 	teqeq	ip, #805306368	; 0x30000000
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2698:	32034a4e 	andcc	r4, r3, #319488	; 0x4e000
    269c:	2e4e032e 	cdpcs	3, 4, cr0, cr14, cr14, {1}

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    26a0:	032e3203 	teqeq	lr, #805306368	; 0x30000000
    26a4:	33032e4e 	movwcc	r2, #15950	; 0x3e4e
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26a8:	4e031f20 	cdpmi	15, 0, cr1, cr3, cr0, {1}
	c = (c >> 7) * 19;
    26ac:	2e33033c 	mrccs	3, 1, r0, cr3, cr12, {1}

	for (i = 0; i < F25519_SIZE; i++) {
    26b0:	03584d03 	cmpeq	r8, #3, 26	; 0xc0
		c += r[i];
    26b4:	4e032e33 	mcrmi	14, 0, r2, cr3, cr3, {1}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    26b8:	2e320366 	cdpcs	3, 3, cr0, cr2, cr6, {3}
		c += r[i];
		r[i] = c;
		c >>= 8;
    26bc:	03584e03 	cmpeq	r8, #3, 28	; 0x30
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    26c0:	4e033c32 	mcrmi	12, 0, r3, cr3, cr2, {1}
    26c4:	4a32039e 	bmi	c83544 <_etext+0xc7bf30>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26c8:	034a4e03 	movteq	r4, #44547	; 0xae03
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    26cc:	4e032032 	mcrmi	0, 0, r2, cr3, cr2, {1}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26d0:	4a32034a 	bmi	c83400 <_etext+0xc7bdec>
    26d4:	03204e03 	teqeq	r0, #3, 28	; 0x30

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26d8:	1f212032 	svcne	0x00212032
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26dc:	03204e03 	teqeq	r0, #3, 28	; 0x30

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26e0:	1f2f2e32 	svcne	0x002f2e32
    26e4:	584e0321 	stmdapl	lr, {r0, r5, r8, r9}^
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26e8:	032e3203 	teqeq	lr, #805306368	; 0x30000000
    26ec:	33033c4d 	movwcc	r3, #15437	; 0x3c4d
    26f0:	4a4e032e 	bmi	13833b0 <_etext+0x137bd9c>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    26f4:	032e3203 	teqeq	lr, #805306368	; 0x30000000
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26f8:	32034a4e 	andcc	r4, r3, #319488	; 0x4e000
    26fc:	2e4e0320 	cdpcs	3, 4, cr0, cr14, cr0, {1}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2700:	034a3203 	movteq	r3, #41475	; 0xa203
			c += ((uint32_t)a[j]) *
    2704:	3203584e 	andcc	r5, r3, #5111808	; 0x4e0000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2708:	744e034a 	strbvc	r0, [lr], #-842	; 0x34a
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    270c:	032e3203 	teqeq	lr, #805306368	; 0x30000000
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2710:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2714:	4e033d20 	cdpmi	13, 0, cr3, cr3, cr0, {1}
	c = (c >> 7) * 19;
    2718:	2e320374 	mrccs	3, 1, r0, cr2, cr4, {3}
    271c:	03584e03 	cmpeq	r8, #3, 28	; 0x30
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2720:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
	c = (c >> 7) * 19;
    2724:	2032032e 	eorscs	r0, r2, lr, lsr #6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2728:	032e4e03 	teqeq	lr, #3, 28	; 0x30
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    272c:	4e032e32 	mcrmi	14, 0, r2, cr3, cr2, {1}
		r[i] = c;
    2730:	4a32033c 	bmi	c83428 <_etext+0xc7be14>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2734:	034a4e03 	movteq	r4, #44547	; 0xae03
		c += r[i];
		r[i] = c;
		c >>= 8;
    2738:	4e032032 	mcrmi	0, 0, r2, cr3, cr2, {1}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    273c:	2e320374 	mrccs	3, 1, r0, cr2, cr4, {3}
    2740:	032e4e03 	teqeq	lr, #3, 28	; 0x30
    2744:	1f3d2032 	svcne	0x003d2032
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2748:	e44e0321 	strb	r0, [lr], #-801	; 0x321
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    274c:	032e3203 	teqeq	lr, #805306368	; 0x30000000
		for (j = 0; j <= i; j++)
    2750:	3203584e 	andcc	r5, r3, #5111808	; 0x4e0000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2754:	2e4e032e 	cdpcs	3, 4, cr0, cr14, cr14, {1}
    2758:	03203203 	teqeq	r0, #805306368	; 0x30000000

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    275c:	32032e4e 	andcc	r2, r3, #1248	; 0x4e0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2760:	3c4e034a 	mcrrcc	3, 4, r0, lr, cr10

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2764:	2f3c3203 	svccs	0x003c3203
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2768:	03204d03 	teqeq	r0, #3, 26	; 0xc0
    276c:	67082e32 	smladxvs	r8, r2, lr, r2
    2770:	03204d03 	teqeq	r0, #3, 26	; 0xc0
    2774:	213d2e32 	teqcs	sp, r2, lsr lr
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2778:	2f1f2f3b 	svccs	0x001f2f3b
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    277c:	4b2d751f 	blmi	b5fc00 <_etext+0xb585ec>
    2780:	2f1f592d 	svccs	0x001f592d
    2784:	2165672d 	cmncs	r5, sp, lsr #14

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2788:	211f212d 	tstcs	pc, sp, lsr #2
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    278c:	2d592d59 	ldclcs	13, cr2, [r9, #-356]	; 0xfffffe9c
    2790:	2d2f1f4b 	stccs	15, cr1, [pc, #-300]!	; 266c <f25519_inv__distinct+0x3a4>

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2794:	2d2f2d9f 	stccs	13, cr2, [pc, #-636]!	; 2520 <f25519_inv__distinct+0x258>
    2798:	492f1f2f 	stmdbmi	pc!, {r0, r1, r2, r3, r5, r8, r9, sl, fp, ip}	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    279c:	3b219d21 	blcc	869c28 <_etext+0x862614>
	c = (c >> 7) * 19;
    27a0:	3d2d9121 	stfccd	f1, [sp, #-132]!	; 0xffffff7c

	for (i = 0; i < F25519_SIZE; i++) {
    27a4:	2f1f831f 	svccs	0x001f831f
		c += r[i];
    27a8:	212d831f 	teqcs	sp, pc, lsl r3
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27ac:	211f21ff 			; <UNDEFINED> instruction: 0x211f21ff
		c += r[i];
		r[i] = c;
		c >>= 8;
    27b0:	2d4b2d59 	stclcs	13, cr2, [fp, #-356]	; 0xfffffe9c
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27b4:	2d2f1f2f 	stccs	15, cr1, [pc, #-188]!	; 2700 <f25519_inv__distinct+0x438>
    27b8:	2d2f2d91 	stccs	13, cr2, [pc, #-580]!	; 257c <f25519_inv__distinct+0x2b4>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27bc:	492f1f21 	stmdbmi	pc!, {r0, r5, r8, r9, sl, fp, ip}	; <UNPREDICTABLE>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    27c0:	81219d21 	teqhi	r1, r1, lsr #26
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27c4:	2f1f2121 	svccs	0x001f2121
    27c8:	2f1fad1f 	svccs	0x001fad1f

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27cc:	211f831f 	tstcs	pc, pc, lsl r3	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27d0:	2d224908 	stccs	9, cr4, [r2, #-32]!	; 0xffffffe0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27d4:	213b1f3d 	teqcs	fp, sp, lsr pc
    27d8:	1f2f1f21 	svcne	0x002f1f21
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27dc:	2dbb1f2f 	ldccs	15, cr1, [fp, #188]!	; 0xbc
    27e0:	492f2d2f 	stmdbmi	pc!, {r0, r1, r2, r3, r5, r8, sl, fp, sp}	; <UNPREDICTABLE>
    27e4:	1f218f21 	svcne	0x00218f21
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    27e8:	592d7521 	pushpl	{r0, r5, r8, sl, ip, sp, lr}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27ec:	2f1f4b2d 	svccs	0x001f4b2d
    27f0:	2f2d752d 	svccs	0x002d752d

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27f4:	2f1f212d 	svccs	0x001f212d
			c += ((uint32_t)a[j]) *
    27f8:	2fe32149 	svccs	0x00e32149

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27fc:	2d591f2f 	ldclcs	15, cr1, [r9, #-188]	; 0xffffff44
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2800:	2d3d2d3d 	ldccs	13, cr2, [sp, #-244]!	; 0xffffff0c
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2804:	3b4b2d4b 	blcc	12cdd38 <_etext+0x12c6724>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2808:	212f8f91 			; <UNDEFINED> instruction: 0x212f8f91
	c = (c >> 7) * 19;
    280c:	2f49831f 	svccs	0x0049831f
    2810:	833b212d 	teqhi	fp, #1073741835	; 0x4000000b
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2814:	671f831f 			; <UNDEFINED> instruction: 0x671f831f
	c = (c >> 7) * 19;
    2818:	2f2fe308 	svccs	0x002fe308
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    281c:	212d4b2d 	teqcs	sp, sp, lsr #22
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2820:	2f1f3d2d 	svccs	0x001f3d2d
		r[i] = c;
    2824:	591f4b2d 	ldmdbpl	pc, {r0, r2, r3, r5, r8, r9, fp, lr}	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2828:	2cd7832d 	ldclcs	3, cr8, [r7], {45}	; 0x2d
		c += r[i];
		r[i] = c;
		c >>= 8;
    282c:	21213b21 	teqcs	r1, r1, lsr #22
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2830:	2149213b 	cmpcs	r9, fp, lsr r1
    2834:	831f912d 	tsthi	pc, #1073741835	; 0x4000000b
    2838:	2fb9671f 	svccs	0x00b9671f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    283c:	2d3d1f21 	ldccs	15, cr1, [sp, #-132]!	; 0xffffff7c
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2840:	2d2f3b3d 	fstmdbxcs	pc!, {d3-d32}	;@ Deprecated
		for (j = 0; j <= i; j++)
    2844:	1f911f75 	svcne	0x00911f75
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2848:	212f5767 	teqcs	pc, r7, ror #14
    284c:	212d832d 	teqcs	sp, sp, lsr #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2850:	212d212d 	teqcs	sp, sp, lsr #2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2854:	752d211f 	strvc	r2, [sp, #-287]!	; 0x11f

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2858:	671f9f1f 			; <UNDEFINED> instruction: 0x671f9f1f
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    285c:	213b2fab 	teqcs	fp, fp, lsr #31
    2860:	2d591f2f 	ldclcs	15, cr1, [r9, #-188]	; 0xffffff44
    2864:	2d213b21 	fstmdbxcs	r1!, {d3-d18}	;@ Deprecated
    2868:	1f672d2f 	svcne	0x00672d2f
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    286c:	9d671f83 	stclls	15, cr1, [r7, #-524]!	; 0xfffffdf4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2870:	671f213d 			; <UNDEFINED> instruction: 0x671f213d
    2874:	212d212d 	teqcs	sp, sp, lsr #2
    2878:	831f913b 	tsthi	pc, #-1073741810	; 0xc000000e

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    287c:	308f672d 	addcc	r6, pc, sp, lsr #14
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2880:	2149911f 	cmpcs	r9, pc, lsl r1
    2884:	833b212d 	teqhi	fp, #1073741835	; 0x4000000b

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2888:	672d831f 			; <UNDEFINED> instruction: 0x672d831f
    288c:	1f212f8f 	svcne	0x00212f8f
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2890:	1f2f2d3d 	svcne	0x002f2d3d
	c = (c >> 7) * 19;
    2894:	2d4b3b3d 	vstrcs	d19, [fp, #-244]	; 0xffffff0c

	for (i = 0; i < F25519_SIZE; i++) {
    2898:	1f751f75 	svcne	0x00751f75
		c += r[i];
    289c:	1f30b94b 	svcne	0x0030b94b
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28a0:	2f3b0859 	svccs	0x003b0859
		c += r[i];
		r[i] = c;
		c >>= 8;
    28a4:	212d212d 	teqcs	sp, sp, lsr #2
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28a8:	831f833b 	tsthi	pc, #-335544320	; 0xec000000
	f25519_mul__distinct(r, s, x);

	/* 1 */
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}
    28ac:	1fbb672d 	svcne	0x00bb672d
    28b0:	212d211f 	teqcs	sp, pc, lsl r1
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    28b4:	2d4b2d21 	stclcs	13, cr2, [fp, #-132]	; 0xffffff7c
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28b8:	1f914921 	svcne	0x00914921
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    28bc:	ab672d83 	blge	19cded0 <_etext+0x19c68bc>
	f25519_copy(r, tmp);
}

void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
    28c0:	3d2d2f2f 	stccc	15, cr2, [sp, #-188]!	; 0xffffff44
    28c4:	2f2d3d2d 	svccs	0x002d3d2d
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += b * ((uint32_t)a[i]);
    28c8:	831f9149 	tsthi	pc, #1073741842	; 0x40000012
    28cc:	2f57672d 	svccs	0x0057672d
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28d0:	2d751f21 	ldclcs	15, cr1, [r5, #-132]!	; 0xffffff7c
    28d4:	3b212d4b 	blcc	84de08 <_etext+0x8467f4>
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    28d8:	2d9f1f91 	ldccs	15, cr1, [pc, #580]	; 2b24 <f25519_sqrt+0x270>
    28dc:	2f2fd567 	svccs	0x002fd567
	c >>= 7;
	c *= 19;
    28e0:	212d592d 	teqcs	sp, sp, lsr #18
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    28e4:	2f2d213b 	svccs	0x002d213b
	c >>= 7;
	c *= 19;
    28e8:	831f672d 	tsthi	pc, #11796480	; 0xb40000
    28ec:	2cbb672d 	ldccs	7, cr6, [fp], #180	; 0xb4

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    28f0:	2f212d21 	svccs	0x00212d21
		r[i] = c;
    28f4:	3d2d752d 	cfstr32cc	mvfx7, [sp, #-180]!	; 0xffffff4c

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28f8:	832d2f1f 	teqhi	sp, #31, 30	; 0x7c
		c += r[i];
		r[i] = c;
		c >>= 8;
    28fc:	30f1913b 	rscscc	r9, r1, fp, lsr r1

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2900:	212d752d 	teqcs	sp, sp, lsr #10
    2904:	2f49211f 	svccs	0x0049211f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2908:	831f672d 	tsthi	pc, #11796480	; 0xb40000
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    290c:	2dbb672d 	ldccs	7, cr6, [fp, #180]!	; 0xb4
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2910:	212d2149 	teqcs	sp, r9, asr #2
    2914:	2d4b2d21 	stclcs	13, cr2, [fp, #-132]	; 0xffffff7c

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2918:	2d212d21 	stccs	13, cr2, [r1, #-132]!	; 0xffffff7c
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    291c:	2d9f1f67 	ldccs	15, cr1, [pc, #412]	; 2ac0 <f25519_sqrt+0x20c>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2920:	2f2f9d67 	svccs	0x002f9d67
    2924:	212d592d 	teqcs	sp, sp, lsr #18
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2928:	7549592d 	strbvc	r5, [r9, #-2349]	; 0x92d
    292c:	592d671f 	pushpl	{r0, r1, r2, r3, r4, r8, r9, sl, sp, lr}
    2930:	2f2d2f2d 	svccs	0x002d2f2d
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2934:	2d213d3b 	stccs	13, cr3, [r1, #-236]!	; 0xffffff14
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2938:	21499108 	cmpcs	r9, r8, lsl #2
    293c:	211f212d 	tstcs	pc, sp, lsr #2
    2940:	9f1f752d 	svcls	0x001f752d

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2944:	30ab672d 	adccc	r6, fp, sp, lsr #14
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2948:	3d2d2f2d 	stccc	15, cr2, [sp, #-180]!	; 0xffffff4c
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    294c:	671f3d2d 	ldrvs	r3, [pc, -sp, lsr #26]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2950:	752d2f2d 	strvc	r2, [sp, #-3885]!	; 0xf2d
	c = (c >> 7) * 19;
    2954:	4b2d671f 	blmi	b5c5d8 <_etext+0xb54fc4>
    2958:	2d3d2f9d 	ldccs	15, cr2, [sp, #-628]!	; 0xfffffd8c
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    295c:	2d214959 	stccs	9, cr4, [r1, #-356]!	; 0xfffffe9c
	c = (c >> 7) * 19;
    2960:	1f833b21 	svcne	0x00833b21
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2964:	ab672d83 	blge	19cdf78 <_etext+0x19c6964>
	c = (c >> 7) * 19;
    2968:	3d1f212f 	ldfccs	f2, [pc, #-188]	; 28b4 <f25519_sqrt>

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    296c:	212d4b2d 	teqcs	sp, sp, lsr #22
		r[i] = c;
    2970:	9f1f753b 	svcls	0x001f753b
		c >>= 8;
    2974:	2fab672d 	svccs	0x00ab672d
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2978:	2d3d2d2f 	ldccs	13, cr2, [sp, #-188]!	; 0xffffff44
    297c:	2d2f2d3d 	stccs	13, cr2, [pc, #-244]!	; 2890 <f25519_inv__distinct+0x5c8>
    2980:	1f752d4b 	svcne	0x00752d4b
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2984:	654b2d83 	strbvs	r2, [fp, #-3459]	; 0xd83
		for (j = 0; j <= i; j++)
    2988:	751f212f 	ldrvc	r2, [pc, #-303]	; 2861 <f25519_inv__distinct+0x599>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    298c:	212d4b2d 	teqcs	sp, sp, lsr #22
    2990:	9f1f913b 	svcls	0x001f913b
    2994:	2fab672d 	svccs	0x00ab672d

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2998:	2d3d2d2f 	ldccs	13, cr2, [sp, #-188]!	; 0xffffff44
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    299c:	2d2f2d21 	stccs	13, cr2, [pc, #-132]!	; 2920 <f25519_sqrt+0x6c>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    29a0:	1f91492f 	svcne	0x0091492f
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29a4:	ad672d83 	stclge	13, cr2, [r7, #-524]!	; 0xfffffdf4
    29a8:	2d4b2f2c 	stclcs	15, cr2, [fp, #-176]	; 0xffffff50
    29ac:	2d2f2d3d 	stccs	13, cr2, [pc, #-244]!	; 28c0 <f25519_sqrt+0xc>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    29b0:	2d212d21 	stccs	13, cr2, [r1, #-132]!	; 0xffffff7c
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    29b4:	2d9f1f67 	ldccs	15, cr1, [pc, #412]	; 2b58 <f25519_sqrt+0x2a4>
    29b8:	212f9d67 	teqcs	pc, r7, ror #26

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29bc:	212d212d 	teqcs	sp, sp, lsr #2
			c += ((uint32_t)a[j]) *
    29c0:	2f492f1f 	svccs	0x00492f1f
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    29c4:	2f1f751f 	svccs	0x001f751f
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    29c8:	ad1f2f2d 	ldcge	15, cr2, [pc, #-180]	; 291c <f25519_sqrt+0x68>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29cc:	212d2f2d 	teqcs	sp, sp, lsr #30
	c = (c >> 7) * 19;
    29d0:	2d4b2157 	stfcse	f2, [fp, #-348]	; 0xfffffea4
    29d4:	57082d21 	strpl	r2, [r8, -r1, lsr #26]
    29d8:	212d2121 	teqcs	sp, r1, lsr #2
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29dc:	4b2d2f1f 	blmi	b4e660 <_etext+0xb4704c>
	c = (c >> 7) * 19;
    29e0:	f31f753b 	vqrshl.u16	d7, d27, d15
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29e4:	2d212dad 	stccs	13, cr2, [r1, #-692]!	; 0xfffffd4c
    29e8:	2d4b2f2d 	stclcs	15, cr2, [fp, #-180]	; 0xffffff4c
	c = (c >> 7) * 19;
    29ec:	3b3d3b2f 	blcc	f516b0 <_etext+0xf4a09c>

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    29f0:	2dad4967 	stccs	9, cr4, [sp, #412]!	; 0x19c
		r[i] = c;
    29f4:	57212d2f 	strpl	r2, [r1, -pc, lsr #26]!
		c >>= 8;
    29f8:	212d4b21 	teqcs	sp, r1, lsr #22
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    29fc:	21212d2d 	teqcs	r1, sp, lsr #26
    2a00:	2f1f212d 	svccs	0x001f212d
    2a04:	751f2149 	ldrvc	r2, [pc, #-329]	; 28c3 <f25519_sqrt+0xf>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a08:	2f2d211f 	svccs	0x002d211f

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2a0c:	2f2d9f1f 	svccs	0x002d9f1f
    2a10:	2157212d 	cmpcs	r7, sp, lsr #2
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2a14:	2d212d4b 	stccs	13, cr2, [r1, #-300]!	; 0xfffffed4
		for (j = 0; j <= i; j++)
    2a18:	2d59212d 	ldfcse	f2, [r9, #-180]	; 0xffffff4c
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a1c:	3b3d3b2f 	blcc	f516e0 <_etext+0xf4a0cc>
    2a20:	2dad4967 	stccs	9, cr4, [sp, #412]!	; 0x19c

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a24:	57212d2f 	strpl	r2, [r1, -pc, lsr #26]!
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a28:	1f224921 	svcne	0x00224921

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a2c:	1f4b2d21 	svcne	0x004b2d21
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a30:	2d4b3b21 	vstrcs	d19, [fp, #-132]	; 0xffffff7c
    2a34:	1f2f1f4b 	svcne	0x002f1f4b
    2a38:	1f2f2d21 	svcne	0x002f2d21
    2a3c:	2d2f2dad 	stccs	13, cr2, [pc, #-692]!	; 2790 <f25519_inv__distinct+0x4c8>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2a40:	2d215721 	stccs	7, cr5, [r1, #-132]!	; 0xffffff7c
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a44:	212c212f 	teqcs	ip, pc, lsr #2
    2a48:	2d212d2f 	stccs	13, cr2, [r1, #-188]!	; 0xffffff44

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a4c:	2d212d3d 	stccs	13, cr2, [r1, #-244]!	; 0xffffff0c
			c += ((uint32_t)a[j]) *
    2a50:	21081f4b 	tstcs	r8, fp, asr #30
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2a54:	21493d1f 	cmpcs	r9, pc, lsl sp
    2a58:	3d3b211f 	ldfccs	f2, [fp, #-124]!	; 0xffffff84
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2a5c:	3b832d75 	blcc	fe0ce038 <BootRAM+0xd03e7d9>
    2a60:	2d917367 	ldccs	3, cr7, [r1, #412]	; 0x19c
    2a64:	2d223b67 	fstmdbxcs	r2!, {d3-d53}	;@ Deprecated
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a68:	2d91212d 	ldfcss	f2, [r1, #180]	; 0xb4
	c = (c >> 7) * 19;
    2a6c:	2d912d2f 	ldccs	13, cr2, [r1, #188]	; 0xbc
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a70:	2d672d75 	stclcs	13, cr2, [r7, #-468]!	; 0xfffffe2c
	c = (c >> 7) * 19;
    2a74:	492f2d83 	stmdbmi	pc!, {r0, r1, r7, r8, sl, fp, sp}	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a78:	57212d3d 			; <UNDEFINED> instruction: 0x57212d3d
	c = (c >> 7) * 19;
    2a7c:	212f1f21 	teqcs	pc, r1, lsr #30

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2a80:	2d2f211e 	stfcss	f2, [pc, #-120]!	; 2a10 <f25519_sqrt+0x15c>
		r[i] = c;
    2a84:	2d212d4b 	stccs	13, cr2, [r1, #-300]!	; 0xfffffed4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a88:	2f2d7508 	svccs	0x002d7508
		c += r[i];
		r[i] = c;
		c >>= 8;
    2a8c:	ad3bc93b 	ldcge	9, cr12, [fp, #-236]!	; 0xffffff14
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a90:	2f2d2f3b 	svccs	0x002d2f3b
    2a94:	2d1f2249 	lfmcs	f2, 4, [pc, #-292]	; 2978 <f25519_sqrt+0xc4>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2a98:	2d3e1f2f 	ldccs	15, cr1, [lr, #-188]!	; 0xffffff44
		for (j = 0; j <= i; j++)
    2a9c:	2d2f2dbb 	stccs	13, cr2, [pc, #-748]!	; 27b8 <f25519_inv__distinct+0x4f0>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2aa0:	2d2f1f67 	stccs	15, cr1, [pc, #-412]!	; 290c <f25519_sqrt+0x58>
    2aa4:	2d2f1fd7 	stccs	15, cr1, [pc, #-860]!	; 2750 <f25519_inv__distinct+0x488>
    2aa8:	49211f3d 	stmdbmi	r1!, {r0, r2, r3, r4, r5, r8, r9, sl, fp, ip}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2aac:	2f2f3b21 	svccs	0x002f3b21
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2ab0:	4b2d3d2d 	blmi	b51f6c <_etext+0xb4a958>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2ab4:	1f2d221e 	svcne	0x002d221e
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ab8:	3d1fbb21 	vldrcc	d11, [pc, #-132]	; 2a3c <f25519_sqrt+0x188>
    2abc:	67572f2d 	ldrbvs	r2, [r7, -sp, lsr #30]
    2ac0:	2f3b4b3b 	svccs	0x003b4b3b
    2ac4:	301f211f 	andscc	r2, pc, pc, lsl r1	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2ac8:	d72d211f 			; <UNDEFINED> instruction: 0xd72d211f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2acc:	4b2d4b1f 	blmi	b55750 <_etext+0xb4e13c>
    2ad0:	2f1f2f2d 	svccs	0x001f2f2d

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ad4:	2f1f593b 	svccs	0x001f593b
			c += ((uint32_t)a[j]) *
    2ad8:	212d211f 	teqcs	sp, pc, lsl r1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2adc:	1fc92f2d 	svcne	0x00c92f2d
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2ae0:	1f672d9f 	svcne	0x00672d9f
    2ae4:	e32f499f 	teq	pc, #2605056	; 0x27c000
    2ae8:	2d213b2f 	fstmdbxcs	r1!, {d3-d25}	;@ Deprecated
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2aec:	08090321 	stmdaeq	r9, {r0, r5, r8, r9}
	c = (c >> 7) * 19;
    2af0:	207703c8 	rsbscs	r0, r7, r8, asr #7
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2af4:	1c2e0903 	stcne	9, cr0, [lr], #-12
	c = (c >> 7) * 19;
    2af8:	0323331b 	teqeq	r3, #1811939328	; 0x6c000000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2afc:	1c362078 	ldcne	0, cr2, [r6], #-480	; 0xfffffe20
	c = (c >> 7) * 19;
    2b00:	1f1f241c 	svcne	0x001f241c

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2b04:	251b242f 	ldrcs	r2, [fp, #-1071]	; 0x42f
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b08:	2f311c1f 	svccs	0x00311c1f
		c += r[i];
		r[i] = c;
    2b0c:	322b322b 	eorcc	r3, fp, #-1342177278	; 0xb0000002
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b10:	0f022f2f 	svceq	0x00022f2f
		c += r[i];
		r[i] = c;
		c >>= 8;
    2b14:	00010100 	andeq	r0, r1, r0, lsl #2
	/* 1 1 */
	f25519_mul__distinct(r, x, x);
	f25519_mul__distinct(s, r, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    2b18:	50440205 	subpl	r0, r4, r5, lsl #4
    2b1c:	c1030000 	mrsgt	r0, (UNDEF: 3)
    2b20:	1d310101 	ldfnes	f0, [r1, #-4]!
    2b24:	23232231 	teqcs	r3, #268435459	; 0x10000003
    2b28:	21341d1d 	teqcs	r4, sp, lsl sp
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2b2c:	200a033e 	andcs	r0, sl, lr, lsr r3
		for (j = 0; j <= i; j++)
    2b30:	3a1f214c 	bcc	7cb068 <_etext+0x7c3a54>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b34:	03972a24 	orrseq	r2, r7, #36, 20	; 0x24000
    2b38:	03363c67 	teqeq	r6, #26368	; 0x6700

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b3c:	2b5b2e13 	blcs	16ce390 <_etext+0x16c6d7c>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b40:	762e6f03 	strtvc	r6, [lr], -r3, lsl #30

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b44:	0b032159 	bleq	cb0b0 <_etext+0xc3a9c>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b48:	0002022e 	andeq	r0, r2, lr, lsr #4
    2b4c:	05000101 	streq	r0, [r0, #-257]	; 0x101
    2b50:	0050d402 	subseq	sp, r0, r2, lsl #8
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2b54:	01f00300 	mvnseq	r0, r0, lsl #6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b58:	252f3401 	strcs	r3, [pc, #-1025]!	; 275f <f25519_inv__distinct+0x497>
    2b5c:	032e7403 	teqeq	lr, #50331648	; 0x3000000

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b60:	1d31200a 	ldcne	0, cr2, [r1, #-40]!	; 0xffffffd8
			c += ((uint32_t)a[j]) *
    2b64:	58730331 	ldmdapl	r3!, {r0, r4, r5, r8, r9}^
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2b68:	20540325 	subscs	r0, r4, r5, lsr #6
    2b6c:	03202c03 	teqeq	r0, #768	; 0x300
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2b70:	2d032e57 	stccs	14, cr2, [r3, #-348]	; 0xfffffea4
    2b74:	53036720 	movwpl	r6, #14112	; 0x3720
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b78:	2e23034a 	cdpcs	3, 2, cr0, cr3, cr10, {2}
	c = (c >> 7) * 19;
    2b7c:	83200903 	teqhi	r0, #49152	; 0xc000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b80:	24664f03 	strbtcs	r4, [r6], #-3843	; 0xf03
	c = (c >> 7) * 19;
    2b84:	3c780330 	ldclcc	3, cr0, [r8], #-192	; 0xffffff40
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b88:	58110336 	ldmdapl	r1, {r1, r2, r4, r5, r8, r9}
	c = (c >> 7) * 19;
    2b8c:	66640322 	strbtvs	r0, [r4], -r2, lsr #6

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2b90:	1d1d3123 	ldfnes	f3, [sp, #-140]	; 0xffffff74
		r[i] = c;
    2b94:	033e2134 	teqeq	lr, #52, 2
		c >>= 8;
    2b98:	51363c78 	teqpl	r6, r8, ror ip
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b9c:	032e0c03 	teqeq	lr, #768	; 0x300
    2ba0:	91917420 	orrsls	r7, r1, r0, lsr #8
    2ba4:	91919191 			; <UNDEFINED> instruction: 0x91919191
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ba8:	47039f9f 			; <UNDEFINED> instruction: 0x47039f9f
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2bac:	2f3d923c 	svccs	0x003d923c
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2bb0:	215a341e 	cmpcs	sl, lr, lsl r4
    2bb4:	2a243a1f 	bcs	911438 <_etext+0x909e24>
    2bb8:	3eac7603 	cdpcc	6, 10, cr7, cr12, cr3, {0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2bbc:	3e1e2f77 	mrccc	15, 0, r2, cr14, cr7, {3}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2bc0:	262a341e 			; <UNDEFINED> instruction: 0x262a341e

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2bc4:	243a1f21 	ldrtcs	r1, [sl], #-3873	; 0xf21
    2bc8:	433f552a 	teqmi	pc, #176160768	; 0xa800000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2bcc:	023c7603 	eorseq	r7, ip, #3145728	; 0x300000
    2bd0:	01010006 	tsteq	r1, r6
    2bd4:	00000530 	andeq	r0, r0, r0, lsr r5
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2bd8:	01600002 	cmneq	r0, r2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2bdc:	01020000 	mrseq	r0, (UNDEF: 2)
    2be0:	000d0efb 	strdeq	r0, [sp], -fp
    2be4:	01010101 	tsteq	r1, r1, lsl #2

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2be8:	01000000 	mrseq	r0, (UNDEF: 0)
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2bec:	32010000 	andcc	r0, r1, #0
    2bf0:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bf4:	5c3a6300 	ldcpl	3, cr6, [sl], #-0
	c = (c >> 7) * 19;
    2bf8:	676f7270 			; <UNDEFINED> instruction: 0x676f7270
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bfc:	206d6172 	rsbcs	r6, sp, r2, ror r1
	c = (c >> 7) * 19;
    2c00:	656c6966 	strbvs	r6, [ip, #-2406]!	; 0x966
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c04:	78282073 	stmdavc	r8!, {r0, r1, r4, r5, r6, sp}
	c = (c >> 7) * 19;
    2c08:	5c293638 	stcpl	6, cr3, [r9], #-224	; 0xffffff20

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2c0c:	20756e67 	rsbscs	r6, r5, r7, ror #28
		r[i] = c;
    2c10:	6c6f6f74 	stclvs	15, cr6, [pc], #-464	; 2a48 <f25519_sqrt+0x194>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c14:	72612073 	rsbvc	r2, r1, #115	; 0x73
		c += r[i];
		r[i] = c;
		c >>= 8;
    2c18:	6d65206d 	stclvs	0, cr2, [r5, #-436]!	; 0xfffffe4c
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c1c:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
    2c20:	345c6465 	ldrbcc	r6, [ip], #-1125	; 0x465
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c24:	3220382e 	eorcc	r3, r0, #3014656	; 0x2e0000
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2c28:	71343130 	teqvc	r4, r0, lsr r1
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c2c:	72615c33 	rsbvc	r5, r1, #13056	; 0x3300
    2c30:	6f6e2d6d 	svcvs	0x006e2d6d

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c34:	652d656e 	strvs	r6, [sp, #-1390]!	; 0x56e
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c38:	5c696261 	sfmpl	f6, 2, [r9], #-388	; 0xfffffe7c

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c3c:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
    2c40:	5c656475 	cfstrdpl	mvd6, [r5], #-468	; 0xfffffe2c
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c44:	6863616d 	stmdavs	r3!, {r0, r2, r3, r5, r6, r8, sp, lr}^
    2c48:	00656e69 	rsbeq	r6, r5, r9, ror #28
    2c4c:	705c3a63 	subsvc	r3, ip, r3, ror #20
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2c50:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c54:	66206d61 	strtvs	r6, [r0], -r1, ror #26
    2c58:	73656c69 	cmnvc	r5, #26880	; 0x6900
    2c5c:	38782820 	ldmdacc	r8!, {r5, fp, sp}^

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c60:	675c2936 	smmlarvs	ip, r6, r9, r2
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2c64:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2c68:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c6c:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80
	c = (c >> 7) * 19;
    2c70:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000
    2c74:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c78:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}
	c = (c >> 7) * 19;
    2c7c:	30322038 	eorscc	r2, r2, r8, lsr r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c80:	33713431 	cmncc	r1, #822083584	; 0x31000000
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2c84:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
		r[i] = c;
    2c88:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c8c:	61652d65 	cmnvs	r5, r5, ror #26
		c += r[i];
		r[i] = c;
		c >>= 8;
    2c90:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c94:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    2c98:	63006564 	movwvs	r6, #1380	; 0x564
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c9c:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2ca0:	6172676f 	cmnvs	r2, pc, ror #14
		for (j = 0; j <= i; j++)
    2ca4:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2ca8:	2073656c 	rsbscs	r6, r3, ip, ror #10
    2cac:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
    2cb0:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2cb4:	6f742075 	svcvs	0x00742075
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2cb8:	20736c6f 	rsbscs	r6, r3, pc, ror #24

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2cbc:	206d7261 	rsbcs	r7, sp, r1, ror #4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cc0:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
    2cc4:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
    2cc8:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2ccc:	31303220 	teqcc	r0, r0, lsr #4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2cd0:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
    2cd4:	5c62696c 	stclpl	9, cr6, [r2], #-432	; 0xfffffe50

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cd8:	5c636367 	stclpl	3, cr6, [r3], #-412	; 0xfffffe64
			c += ((uint32_t)a[j]) *
    2cdc:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2ce0:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2ce4:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2ce8:	2e345c69 	cdpcs	12, 3, cr5, cr4, cr9, {3}
	c = (c >> 7) * 19;
    2cec:	5c342e38 	ldcpl	14, cr2, [r4], #-224	; 0xffffff20
    2cf0:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cf4:	00656475 	rsbeq	r6, r5, r5, ror r4
    2cf8:	61687300 	cmnvs	r8, r0, lsl #6
	c = (c >> 7) * 19;
    2cfc:	2e323135 	mrccs	1, 1, r3, cr2, cr5, {1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d00:	00010063 	andeq	r0, r1, r3, rrx
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2d04:	65645f00 	strbvs	r5, [r4, #-3840]!	; 0xf00
		r[i] = c;
    2d08:	6c756166 	ldfvse	f6, [r5], #-408	; 0xfffffe68
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d0c:	79745f74 	ldmdbvc	r4!, {r2, r4, r5, r6, r8, r9, sl, fp, ip, lr}^
		c += r[i];
		r[i] = c;
		c >>= 8;
    2d10:	2e736570 	mrccs	5, 3, r6, cr3, cr0, {3}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d14:	00020068 	andeq	r0, r2, r8, rrx
    2d18:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d1c:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2d20:	00030068 	andeq	r0, r3, r8, rrx
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d24:	64747300 	ldrbtvs	r7, [r4], #-768	; 0x300
    2d28:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d2c:	00040068 	andeq	r0, r4, r8, rrx
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d30:	61687300 	cmnvs	r8, r0, lsl #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d34:	2e323135 	mrccs	1, 1, r3, cr2, cr5, {1}
    2d38:	00010068 	andeq	r0, r1, r8, rrx
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d3c:	05000000 	streq	r0, [r0, #-0]
    2d40:	0052ec02 	subseq	lr, r2, r2, lsl #24
    2d44:	00e40300 	rsceq	r0, r4, r0, lsl #6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2d48:	5a033c01 	bpl	d1d54 <_etext+0xca740>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d4c:	839f2158 	orrshi	r2, pc, #88, 2
    2d50:	bb1308f3 	bllt	4c5124 <_etext+0x4bdb10>
    2d54:	662603bb 			; <UNDEFINED> instruction: 0x662603bb

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d58:	03205a03 	teqeq	r0, #12288	; 0x3000
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2d5c:	2d212e24 	stccs	14, cr2, [r1, #-144]!	; 0xffffff70
    2d60:	2d1f2127 	ldfcss	f2, [pc, #-156]	; 2ccc <f25519_sqrt+0x418>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d64:	2f2c2f21 	svccs	0x002c2f21
	c = (c >> 7) * 19;
    2d68:	46321c33 			; <UNDEFINED> instruction: 0x46321c33
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d6c:	7a03232f 	bvc	cba30 <_etext+0xc441c>
	c = (c >> 7) * 19;
    2d70:	2b2b2620 	blcs	acc5f8 <_etext+0xac4fe4>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d74:	1c222f32 	stcne	15, cr2, [r2], #-200	; 0xffffff38
	c = (c >> 7) * 19;
    2d78:	3246312f 	subcc	r3, r6, #-1073741813	; 0xc000000b

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2d7c:	03207903 	teqeq	r0, #49152	; 0xc000
		r[i] = c;
    2d80:	2f2a2009 	svccs	0x002a2009
		c >>= 8;
    2d84:	21494c1f 	cmpcs	r9, pc, lsl ip
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d88:	2f3b4d2b 	svccs	0x003b4d2b
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    2d8c:	08581903 	ldmdaeq	r8, {r0, r1, r8, fp, ip}^
    2d90:	0402006a 	streq	r0, [r2], #-106	; 0x6a
    2d94:	2e670302 	cdpcs	3, 6, cr0, cr7, cr2, {0}
    2d98:	02040200 	andeq	r0, r4, #0, 4
    2d9c:	003c6603 	eorseq	r6, ip, r3, lsl #12
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2da0:	03020402 	movweq	r0, #9218	; 0x2402
    2da4:	0200ba1b 	andeq	fp, r0, #110592	; 0x1b000
    2da8:	65030204 	strvs	r0, [r3, #-516]	; 0x204
		r[i] = c;
    2dac:	0402002e 	streq	r0, [r2], #-46	; 0x2e
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2db0:	2e1b0302 	cdpcs	3, 1, cr0, cr11, cr2, {0}
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2db4:	02040200 	andeq	r0, r4, #0, 4
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2db8:	002e6503 	eoreq	r6, lr, r3, lsl #10
    2dbc:	03020402 	movweq	r0, #9218	; 0x2402
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2dc0:	02003c1b 	andeq	r3, r0, #6912	; 0x1b00
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2dc4:	65030204 	strvs	r0, [r3, #-516]	; 0x204
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2dc8:	0402002e 	streq	r0, [r2], #-46	; 0x2e
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2dcc:	2e1b0302 	cdpcs	3, 1, cr0, cr11, cr2, {0}
    2dd0:	02040200 	andeq	r0, r4, #0, 4
	c = (c >> 7) * 19;
    2dd4:	002e6503 	eoreq	r6, lr, r3, lsl #10

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2dd8:	03020402 	movweq	r0, #9218	; 0x2402
		r[i] = c;
    2ddc:	0200201f 	andeq	r2, r0, #31

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2de0:	001c0204 	andseq	r0, ip, r4, lsl #4
		c += r[i];
		r[i] = c;
		c >>= 8;
    2de4:	03020402 	movweq	r0, #9218	; 0x2402

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2de8:	02002065 	andeq	r2, r0, #101	; 0x65
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2dec:	1f030204 	svcne	0x00030204

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2df0:	0402003c 	streq	r0, [r2], #-60	; 0x3c
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2df4:	2e610302 	cdpcs	3, 6, cr0, cr1, cr2, {0}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2df8:	02040200 	andeq	r0, r4, #0, 4
		for (j = 0; j <= i; j++)
    2dfc:	00661f03 	rsbeq	r1, r6, r3, lsl #30
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e00:	03020402 	movweq	r0, #9218	; 0x2402
    2e04:	02002061 	andeq	r2, r0, #97	; 0x61
    2e08:	1c030204 	sfmne	f0, 4, [r3], {4}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e0c:	0402003c 	streq	r0, [r2], #-60	; 0x3c
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e10:	3c640302 	stclcc	3, cr0, [r4], #-8

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e14:	02040200 	andeq	r0, r4, #0, 4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e18:	00581c03 	subseq	r1, r8, r3, lsl #24
    2e1c:	03020402 	movweq	r0, #9218	; 0x2402
    2e20:	02002e64 	andeq	r2, r0, #100, 28	; 0x640
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2e24:	1f030204 	svcne	0x00030204
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2e28:	0402002e 	streq	r0, [r2], #-46	; 0x2e
    2e2c:	20610302 	rsbcs	r0, r1, r2, lsl #6

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e30:	02040200 	andeq	r0, r4, #0, 4
			c += ((uint32_t)a[j]) *
    2e34:	00581c03 	subseq	r1, r8, r3, lsl #24
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2e38:	33020402 	movwcc	r0, #9218	; 0x2402
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2e3c:	02040200 	andeq	r0, r4, #0, 4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e40:	0402002c 	streq	r0, [r2], #-44	; 0x2c
	c = (c >> 7) * 19;
    2e44:	20610302 	rsbcs	r0, r1, r2, lsl #6
    2e48:	02040200 	andeq	r0, r4, #0, 4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e4c:	004a1f03 	subeq	r1, sl, r3, lsl #30
	c = (c >> 7) * 19;
    2e50:	5a020402 	bpl	83e60 <_etext+0x7c84c>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e54:	02040200 	andeq	r0, r4, #0, 4
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2e58:	0402001e 	streq	r0, [r2], #-30
		r[i] = c;
    2e5c:	02002202 	andeq	r2, r0, #536870912	; 0x20000000
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e60:	5f030204 	svcpl	0x00030204
		c += r[i];
		r[i] = c;
		c >>= 8;
    2e64:	0402003c 	streq	r0, [r2], #-60	; 0x3c
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e68:	d61e0302 	ldrle	r0, [lr], -r2, lsl #6
    2e6c:	02040200 	andeq	r0, r4, #0, 4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2e70:	0402006d 	streq	r0, [r2], #-109	; 0x6d
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2e74:	02002a02 	andeq	r2, r0, #8192	; 0x2000
		for (j = 0; j <= i; j++)
    2e78:	00320204 	eorseq	r0, r2, r4, lsl #4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e7c:	03020402 	movweq	r0, #9218	; 0x2402

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e80:	0200ba11 	andeq	fp, r0, #69632	; 0x11000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e84:	67030204 	strvs	r0, [r3, -r4, lsl #4]

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e88:	0402002e 	streq	r0, [r2], #-46	; 0x2e
    2e8c:	58190302 	ldmdapl	r9, {r1, r8, r9}
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e90:	02040200 	andeq	r0, r4, #0, 4
    2e94:	00ac4a03 	adceq	r4, ip, r3, lsl #20
    2e98:	03020402 	movweq	r0, #9218	; 0x2402
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2e9c:	02008236 	andeq	r8, r0, #1610612739	; 0x60000003
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ea0:	4a030204 	bmi	c36b8 <_etext+0xbc0a4>
    2ea4:	04020020 	streq	r0, [r2], #-32
    2ea8:	2e360302 	cdpcs	3, 3, cr0, cr6, cr2, {0}

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2eac:	02040200 	andeq	r0, r4, #0, 4
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2eb0:	002e4a03 	eoreq	r4, lr, r3, lsl #20
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2eb4:	03020402 	movweq	r0, #9218	; 0x2402

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2eb8:	02002e21 	andeq	r2, r0, #528	; 0x210
    2ebc:	00650204 	rsbeq	r0, r5, r4, lsl #4
    2ec0:	03020402 	movweq	r0, #9218	; 0x2402
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2ec4:	02003c16 	andeq	r3, r0, #5632	; 0x1600
    2ec8:	6a030204 	bvs	c36e0 <_etext+0xbc0cc>
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2ecc:	04020020 	streq	r0, [r2], #-32
		c += r[i];
    2ed0:	2e160302 	cdpcs	3, 1, cr0, cr6, cr2, {0}
		r[i] = c;
    2ed4:	02040200 	andeq	r0, r4, #0, 4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2ed8:	004a7003 	subeq	r7, sl, r3
		c += r[i];
		r[i] = c;
		c >>= 8;
    2edc:	03020402 	movweq	r0, #9218	; 0x2402
	f25519_sub(i, i, y);

	/* r = avi */
	f25519_mul__distinct(x, v, a);
	f25519_mul__distinct(r, x, i);
}
    2ee0:	0200d65a 	andeq	sp, r0, #94371840	; 0x5a00000
    2ee4:	27030204 	strcs	r0, [r3, -r4, lsl #4]
}

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
    2ee8:	0402002e 	streq	r0, [r2], #-46	; 0x2e
    2eec:	2e590302 	cdpcs	3, 5, cr0, cr9, cr2, {0}
    2ef0:	02040200 	andeq	r0, r4, #0, 4
    2ef4:	002e2703 	eoreq	r2, lr, r3, lsl #14
static int prime_msb(const uint8_t *p)
{
	int i;
	uint8_t x;

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
    2ef8:	03020402 	movweq	r0, #9218	; 0x2402
    2efc:	02003c59 	andeq	r3, r0, #22784	; 0x5900
    2f00:	27030204 	strcs	r0, [r3, -r4, lsl #4]
		if (p[i])
    2f04:	04020020 	streq	r0, [r2], #-32
			break;

	x = p[i];
	i <<= 3;
    2f08:	2e590302 	cdpcs	3, 5, cr0, cr9, cr2, {0}

	while (x) {
		x >>= 1;
		i++;
    2f0c:	02040200 	andeq	r0, r4, #0, 4
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    2f10:	002e2703 	eoreq	r2, lr, r3, lsl #14

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
    2f14:	03020402 	movweq	r0, #9218	; 0x2402
		x[i] = 0;
}

static inline int min_int(int a, int b)
{
	return a < b ? a : b;
    2f18:	02003c59 	andeq	r3, r0, #22784	; 0x5900
    2f1c:	28030204 	stmdacs	r3, {r2, r9}
void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
    2f20:	0402004a 	streq	r0, [r2], #-74	; 0x4a
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);
    2f24:	2e580302 	cdpcs	3, 5, cr0, cr8, cr2, {0}
    2f28:	02040200 	andeq	r0, r4, #0, 4
    2f2c:	003c2703 	eorseq	r2, ip, r3, lsl #14

	for (i = 0; i < preload_bytes; i++)
    2f30:	2f020402 	svccs	0x00020402
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
    2f34:	02040200 	andeq	r0, r4, #0, 4
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
    2f38:	002e5803 	eoreq	r5, lr, r3, lsl #16
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f3c:	03020402 	movweq	r0, #9218	; 0x2402
    2f40:	02002e28 	andeq	r2, r0, #40, 28	; 0x280
    2f44:	58030204 	stmdapl	r3, {r2, r9}
    2f48:	0402002e 	streq	r0, [r2], #-46	; 0x2e
    2f4c:	3c280302 	stccc	3, cr0, [r8], #-8
    2f50:	02040200 	andeq	r0, r4, #0, 4
    2f54:	00205803 	eoreq	r5, r0, r3, lsl #16
    2f58:	03020402 	movweq	r0, #9218	; 0x2402
    2f5c:	02003c24 	andeq	r3, r0, #36, 24	; 0x2400
    2f60:	12030204 	andne	r0, r3, #4, 4	; 0x40000000
    2f64:	040200ba 	streq	r0, [r2], #-186	; 0xba
    2f68:	2e710302 	cdpcs	3, 7, cr0, cr1, cr2, {0}
    2f6c:	02040200 	andeq	r0, r4, #0, 4
    2f70:	002e0f03 	eoreq	r0, lr, r3, lsl #30
    2f74:	03020402 	movweq	r0, #9218	; 0x2402
    2f78:	02002e71 	andeq	r2, r0, #1808	; 0x710
    2f7c:	004b0204 	subeq	r0, fp, r4, lsl #4
		n[i] = x[len - preload_bytes + i];
    2f80:	2d020402 	cfstrscs	mvf0, [r2, #-8]
    2f84:	02040200 	andeq	r0, r4, #0, 4
    2f88:	0402003d 	streq	r0, [r2], #-61	; 0x3d
    2f8c:	02009d02 	andeq	r9, r0, #2, 26	; 0x80
    2f90:	005a0204 	subseq	r0, sl, r4, lsl #4
    2f94:	5e020402 	cdppl	4, 0, cr0, cr2, cr2, {0}
    2f98:	02040200 	andeq	r0, r4, #0, 4
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f9c:	0402005c 	streq	r0, [r2], #-92	; 0x5c
		n[i] = x[len - preload_bytes + i];
    2fa0:	3c650302 	stclcc	3, cr0, [r5], #-8
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fa4:	59f22203 	ldmibpl	r2!, {r0, r1, r9, sp}^
		n[i] = x[len - preload_bytes + i];
    2fa8:	2f318067 	svccs	0x00318067
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fac:	3e59302b 	cdpcc	0, 5, cr3, cr9, cr11, {1}
    2fb0:	312b671f 	teqcc	fp, pc, lsl r7
    2fb4:	7a032d2f 	bvc	ce478 <_etext+0xc6e64>
		n[i] = x[len - preload_bytes + i];
    2fb8:	7d2f3420 	cfstrsvc	mvf3, [pc, #-128]!	; 2f40 <fprime_from_bytes+0x58>
    2fbc:	2f2b312c 	svccs	0x002b312c
    2fc0:	2f312c30 	svccs	0x00312c30

	if (preload_bits) {
    2fc4:	022f2f2f 	eoreq	r2, pc, #47, 30	; 0xbc
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c |= ((uint16_t)x[i]) << n;
    2fc8:	01010006 	tsteq	r1, r6
    2fcc:	80020500 	andhi	r0, r2, r0, lsl #10
		x[i] = c;
    2fd0:	03000057 	movweq	r0, #87	; 0x57
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2fd4:	2f0101a6 	svccs	0x000101a6
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    2fd8:	5b3d201f 	blpl	f4b05c <_etext+0xf43a48>
	for (i = 0; i < preload_bytes; i++)
		n[i] = x[len - preload_bytes + i];

	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
    2fdc:	9a03363e 	bls	d08dc <_etext+0xc92c8>
    2fe0:	1e22207f 	mcrne	0, 1, r2, cr2, cr15, {3}
    2fe4:	00e30324 	rsceq	r0, r3, r4, lsr #6
    2fe8:	7f98032e 	svcvc	0x0098032e
    2fec:	3030302e 	eorscc	r3, r0, lr, lsr #32
    2ff0:	30303030 	eorscc	r3, r0, r0, lsr r0
	}

	for (i = rbits - 1; i >= 0; i--) {
    2ff4:	2e00da03 	vmlacs.f32	s26, s0, s6
    2ff8:	3c75032f 	ldclcc	3, cr0, [r5], #-188	; 0xffffff44
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;
    2ffc:	301e3e59 	andscc	r3, lr, r9, asr lr
    3000:	06024b21 	streq	r4, [r2], -r1, lsr #22
    3004:	00010100 	andeq	r0, r1, r0, lsl #2
    3008:	58080205 	stmdapl	r8, {r0, r2, r9}
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    300c:	ba030000 	blt	c3014 <_etext+0xbba00>
		c |= ((uint16_t)x[i]) << n;
    3010:	1d310101 	ldfnes	f0, [r1, #-4]!
		x[i] = c;
    3014:	5c233120 	stfpls	f3, [r3], #-128	; 0xffffff80
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3018:	00243824 	eoreq	r3, r4, r4, lsr #16
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    301c:	03010402 	movweq	r0, #5122	; 0x1402

	for (i = rbits - 1; i >= 0; i--) {
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;

		shift_n_bits(n, 1);
		n[0] |= bit;
    3020:	08062e0e 	stmdaeq	r6, {r1, r2, r3, r9, sl, fp, sp}
    3024:	034b0612 	movteq	r0, #46610	; 0xb612
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3028:	84587ef7 	ldrbhi	r7, [r8], #-3831	; 0xef7
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
    302c:	20018703 	andcs	r8, r1, r3, lsl #14
    3030:	207ef903 	rsbscs	pc, lr, r3, lsl #18
		minusp[i] = c;
    3034:	3022483e 	eorcc	r4, r2, lr, lsr r8
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3038:	301e2646 	andscc	r2, lr, r6, asr #12
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
    303c:	7703683e 	smladxvc	r3, lr, r8, r6
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3040:	2e090374 	mcrcs	3, 0, r0, cr9, cr4, {3}

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    3044:	032e7703 	teqeq	lr, #786432	; 0xc0000
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    3048:	7203200a 	andvc	r2, r3, #10
    304c:	2e0c032e 	cdpcs	3, 0, cr0, cr12, cr14, {1}
    3050:	032e7403 	teqeq	lr, #50331648	; 0x3000000
    3054:	1e1e200a 	cdpne	0, 1, cr2, cr14, cr10, {0}
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
    3058:	0187032a 	orreq	r0, r7, sl, lsr #6
	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
	}

	for (i = rbits - 1; i >= 0; i--) {
    305c:	7f850320 	svcvc	0x00850320
    3060:	00fb0320 	rscseq	r0, fp, r0, lsr #6

		shift_n_bits(n, 1);
		n[0] |= bit;
		raw_try_sub(n, modulus);
	}
}
    3064:	4235082e 	eorsmi	r0, r5, #3014656	; 0x2e0000

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
    3068:	033c6c03 	teqeq	ip, #768	; 0x300
	i <<= 3;

	while (x) {
    306c:	4c587eff 	mrrcmi	14, 15, r7, r8, cr15
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
    3070:	2c302c5a 	ldccs	12, cr2, [r0], #-360	; 0xfffffe98
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    3074:	2c4c2c32 	mcrrcs	12, 3, r2, ip, cr2
		n[i] = x[len - preload_bytes + i];
    3078:	03302c32 	teqeq	r0, #12800	; 0x3200
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    307c:	0b034a77 	bleq	d5a60 <_etext+0xce44c>
    3080:	0334462e 	teqeq	r4, #48234496	; 0x2e00000
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    3084:	2c343c75 	ldccs	12, cr3, [r4], #-468	; 0xfffffe2c
    (b)[(i) + 2] = (uint8) ( (n) >>  8 );       \
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    3088:	2e7a0335 	mrccs	3, 3, r0, cr10, cr5, {1}
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    308c:	2e00f603 	cfmadd32cs	mvax0, mvfx15, mvfx0, mvfx3
void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    3090:	2e7f8703 	cdpcs	7, 7, cr8, cr15, cr3, {0}
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    3094:	03423030 	movteq	r3, #8240	; 0x2030
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    3098:	31342e76 	teqcc	r4, r6, ror lr
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    309c:	00f6032d 	rscseq	r0, r6, sp, lsr #6
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    30a0:	8b03212e 	blhi	cb560 <_etext+0xc3f4c>
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    30a4:	ef03207f 	svc	0x0003207f
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    30a8:	91032000 	mrsls	r2, (UNDEF: 3)
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    30ac:	f403587f 	vst2.16	{d5-d6}, [r3 :256]
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    30b0:	1f302e00 	svcne	0x00302e00
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
    30b4:	8a031f3d 	bhi	cadb0 <_etext+0xc379c>
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;
    30b8:	f6033c7f 			; <UNDEFINED> instruction: 0xf6033c7f
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
}
    30bc:	2b302e00 	blcs	c0e8c4 <_etext+0xc072b0>
    30c0:	11032b31 	tstne	r3, r1, lsr fp
    30c4:	7eee033c 	mcrvc	3, 7, r0, cr14, cr12, {1}
    30c8:	302c5a82 	eorcc	r5, ip, r2, lsl #21
    30cc:	4c4c684c 	mcrrmi	8, 4, r6, ip, cr12
    30d0:	2e73035a 	mrccs	3, 3, r0, cr3, cr10, {2}
    30d4:	302e0b03 	eorcc	r0, lr, r3, lsl #22
    30d8:	034a7303 	movteq	r7, #41731	; 0xa303
    30dc:	2c322e0a 	ldccs	14, cr2, [r2], #-40	; 0xffffffd8

void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    30e0:	032d1e30 	teqeq	sp, #48, 28	; 0x300
    30e4:	0b032e77 	bleq	ceac8 <_etext+0xc74b4>
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    30e8:	2e77032e 	cdpcs	3, 7, cr0, cr7, cr14, {1}
    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    30ec:	8c033030 	stchi	0, cr3, [r3], {48}	; 0x30
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    30f0:	fa032e01 	blx	ce8fc <_etext+0xc72e8>
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    30f4:	8603207e 			; <UNDEFINED> instruction: 0x8603207e
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30f8:	f9032e01 			; <UNDEFINED> instruction: 0xf9032e01
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    30fc:	8703207e 	smlsdxhi	r3, lr, r0, r2
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3100:	02302e01 	eorseq	r2, r0, #1, 28
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    3104:	01010003 	tsteq	r1, r3
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3108:	00000252 	andeq	r0, r0, r2, asr r2
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    310c:	01bb0002 			; <UNDEFINED> instruction: 0x01bb0002
    3110:	01020000 	mrseq	r0, (UNDEF: 2)
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3114:	000d0efb 	strdeq	r0, [sp], -fp
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3118:	01010101 	tsteq	r1, r1, lsl #2
    311c:	01000000 	mrseq	r0, (UNDEF: 0)
    3120:	63010000 	movwvs	r0, #4096	; 0x1000
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3124:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3128:	6172676f 	cmnvs	r2, pc, ror #14
    312c:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
    3130:	2073656c 	rsbscs	r6, r3, ip, ror #10
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3134:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3138:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    313c:	6f742075 	svcvs	0x00742075
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3140:	20736c6f 	rsbscs	r6, r3, pc, ror #24
    3144:	206d7261 	rsbcs	r7, sp, r1, ror #4
    3148:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    314c:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
    3150:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    3154:	31303220 	teqcc	r0, r0, lsr #4
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3158:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
    315c:	5c62696c 	stclpl	9, cr6, [r2], #-432	; 0xfffffe50
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3160:	5c636367 	stclpl	3, cr6, [r3], #-412	; 0xfffffe64
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3164:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    3168:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    316c:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3170:	2e345c69 	cdpcs	12, 3, cr5, cr4, cr9, {3}
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3174:	5c342e38 	ldcpl	14, cr2, [r4], #-224	; 0xffffff20
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3178:	6c636e69 	stclvs	14, cr6, [r3], #-420	; 0xfffffe5c
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    317c:	00656475 	rsbeq	r6, r5, r5, ror r4
    3180:	705c3a63 	subsvc	r3, ip, r3, ror #20
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3184:	72676f72 	rsbvc	r6, r7, #456	; 0x1c8
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3188:	66206d61 	strtvs	r6, [r0], -r1, ror #26
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    318c:	73656c69 	cmnvc	r5, #26880	; 0x6900
    3190:	38782820 	ldmdacc	r8!, {r5, fp, sp}^
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3194:	675c2936 	smmlarvs	ip, r6, r9, r2
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3198:	7420756e 	strtvc	r7, [r0], #-1390	; 0x56e
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    319c:	736c6f6f 	cmnvc	ip, #444	; 0x1bc
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31a0:	6d726120 	ldfvse	f6, [r2, #-128]!	; 0xffffff80
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    31a4:	626d6520 	rsbvs	r6, sp, #32, 10	; 0x8000000
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    31a8:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
    31ac:	2e345c64 	cdpcs	12, 3, cr5, cr4, cr4, {3}
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31b0:	30322038 	eorscc	r2, r2, r8, lsr r0
    31b4:	33713431 	cmncc	r1, #822083584	; 0x31000000
    31b8:	6d72615c 	ldfvse	f6, [r2, #-368]!	; 0xfffffe90
    31bc:	6e6f6e2d 	cdpvs	14, 6, cr6, cr15, cr13, {1}
    31c0:	61652d65 	cmnvs	r5, r5, ror #26
    31c4:	695c6962 	ldmdbvs	ip, {r1, r5, r6, r8, fp, sp, lr}^
    31c8:	756c636e 	strbvc	r6, [ip, #-878]!	; 0x36e
    31cc:	6d5c6564 	cfldr64vs	mvdx6, [ip, #-400]	; 0xfffffe70
    31d0:	69686361 	stmdbvs	r8!, {r0, r5, r6, r8, r9, sp, lr}^
    31d4:	6300656e 	movwvs	r6, #1390	; 0x56e
    31d8:	72705c3a 	rsbsvc	r5, r0, #14848	; 0x3a00
    31dc:	6172676f 	cmnvs	r2, pc, ror #14
    31e0:	6966206d 	stmdbvs	r6!, {r0, r2, r3, r5, r6, sp}^
    31e4:	2073656c 	rsbscs	r6, r3, ip, ror #10
    31e8:	36387828 	ldrtcc	r7, [r8], -r8, lsr #16
    31ec:	6e675c29 	cdpvs	12, 6, cr5, cr7, cr9, {1}
    31f0:	6f742075 	svcvs	0x00742075
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    31f4:	20736c6f 	rsbscs	r6, r3, pc, ror #24
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31f8:	206d7261 	rsbcs	r7, sp, r1, ror #4
    31fc:	65626d65 	strbvs	r6, [r2, #-3429]!	; 0xd65
    3200:	64656464 	strbtvs	r6, [r5], #-1124	; 0x464
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3204:	382e345c 	stmdacc	lr!, {r2, r3, r4, r6, sl, ip, sp}
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3208:	31303220 	teqcc	r0, r0, lsr #4
    320c:	5c337134 	ldfpls	f7, [r3], #-208	; 0xffffff30
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3210:	2d6d7261 	sfmcs	f7, 2, [sp, #-388]!	; 0xfffffe7c
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3214:	656e6f6e 	strbvs	r6, [lr, #-3950]!	; 0xf6e
    3218:	6261652d 	rsbvs	r6, r1, #188743680	; 0xb400000
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    321c:	6e695c69 	cdpvs	12, 6, cr5, cr9, cr9, {3}
    3220:	64756c63 	ldrbtvs	r6, [r5], #-3171	; 0xc63
    3224:	2f2e0065 	svccs	0x002e0065
    3228:	336d7473 	cmncc	sp, #1929379840	; 0x73000000
    322c:	696c5f32 	stmdbvs	ip!, {r1, r4, r5, r8, r9, sl, fp, ip, lr}^
    3230:	2f2e0062 	svccs	0x002e0062
    3234:	31353532 	teqcc	r5, r2, lsr r5
    3238:	69000039 	stmdbvs	r0, {r0, r3, r4, r5}
    323c:	6567616d 	strbvs	r6, [r7, #-365]!	; 0x16d
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3240:	0000632e 	andeq	r6, r0, lr, lsr #6
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3244:	74730000 	ldrbtvc	r0, [r3], #-0
    3248:	66656464 	strbtvs	r6, [r5], -r4, ror #8
    324c:	0100682e 	tsteq	r0, lr, lsr #16
    3250:	645f0000 	ldrbvs	r0, [pc], #-0	; 3258 <sha256_process+0x178>
    3254:	75616665 	strbvc	r6, [r1, #-1637]!	; 0x665
    3258:	745f746c 	ldrbvc	r7, [pc], #-1132	; 3260 <sha256_process+0x180>
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    325c:	73657079 	cmnvc	r5, #121	; 0x79
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3260:	0200682e 	andeq	r6, r0, #3014656	; 0x2e0000
    3264:	74730000 	ldrbtvc	r0, [r3], #-0
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3268:	746e6964 	strbtvc	r6, [lr], #-2404	; 0x964
    326c:	0300682e 	movweq	r6, #2094	; 0x82e
    3270:	74730000 	ldrbtvc	r0, [r3], #-0
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3274:	6632336d 	ldrtvs	r3, [r2], -sp, ror #6
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3278:	5f783031 	svcpl	0x00783031
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    327c:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0x974

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3280:	0400682e 	streq	r6, [r0], #-2094	; 0x82e
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3284:	68730000 	ldmdavs	r3!, {}^	; <UNPREDICTABLE>
    GET_UINT32( W[4],  data, 16 );
    3288:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    328c:	0500682e 	streq	r6, [r0, #-2094]	; 0x82e
    3290:	6d690000 	stclvs	0, cr0, [r9, #-0]
    3294:	2e656761 	cdpcs	7, 6, cr6, cr5, cr1, {3}
    3298:	00000068 	andeq	r0, r0, r8, rrx

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    329c:	62737500 	rsbsvs	r7, r3, #0, 10
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32a0:	0000682e 	andeq	r6, r0, lr, lsr #16

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32a4:	61680000 	cmnvs	r8, r0
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32a8:	61776472 	cmnvs	r7, r2, ror r4
    32ac:	682e6572 	stmdavs	lr!, {r1, r4, r5, r6, r8, sl, sp, lr}
    32b0:	00000000 	andeq	r0, r0, r0
    32b4:	69727473 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, sl, ip, sp, lr}^
    32b8:	682e676e 	stmdavs	lr!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
    32bc:	00000300 	andeq	r0, r0, r0, lsl #6

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32c0:	69736465 	ldmdbvs	r3!, {r0, r2, r5, r6, sl, sp, lr}^
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32c4:	682e6e67 	stmdavs	lr!, {r0, r1, r2, r5, r6, r9, sl, fp, sp, lr}
    32c8:	00000500 	andeq	r0, r0, r0, lsl #10
    32cc:	02050000 	andeq	r0, r5, #0
    32d0:	00005aa0 	andeq	r5, r0, r0, lsr #21

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32d4:	22012503 	andcs	r2, r1, #12582912	; 0xc00000
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32d8:	3d3d3d3d 	ldccc	13, cr3, [sp, #-244]!	; 0xffffff0c

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32dc:	10022d3e 	andne	r2, r2, lr, lsr sp
    32e0:	00010100 	andeq	r0, r1, r0, lsl #2
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32e4:	5ae40205 	bpl	ff903b00 <BootRAM+0xe8742a1>

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32e8:	30030000 	andcc	r0, r3, r0
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32ec:	1b333c01 	blne	cd22f8 <_etext+0xccace4>

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32f0:	591f4c25 	ldmdbpl	pc, {r0, r2, r5, sl, fp, lr}	; <UNPREDICTABLE>
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32f4:	00580c03 	subseq	r0, r8, r3, lsl #24
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32f8:	4b010402 	blmi	44308 <_etext+0x3ccf4>
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32fc:	002e0903 	eoreq	r0, lr, r3, lsl #18
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3300:	4c010402 	cfstrsmi	mvf0, [r1], {2}

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3304:	01040200 	mrseq	r0, R12_usr

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3308:	0402003d 	streq	r0, [r2], #-61	; 0x3d
    330c:	303e2f01 	eorscc	r2, lr, r1, lsl #30
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3310:	4c303021 	ldcmi	0, cr3, [r0], #-132	; 0xffffff7c
    3314:	1c252925 	stcne	9, cr2, [r5], #-148	; 0xffffff6c

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3318:	5a433140 	bpl	10cf820 <_etext+0x10c820c>
    331c:	53212d21 	teqpl	r1, #2112	; 0x840
    3320:	01040200 	mrseq	r0, R12_usr
    3324:	0c033126 	stfeqs	f3, [r3], {38}	; 0x26
    3328:	02006720 	andeq	r6, r0, #32, 14	; 0x800000
    332c:	00300104 	eorseq	r0, r0, r4, lsl #2
    3330:	59010402 	stmdbpl	r1, {r1, sl}
    3334:	01040200 	mrseq	r0, R12_usr
    3338:	04020059 	streq	r0, [r2], #-89	; 0x59
    333c:	02006801 	andeq	r6, r0, #65536	; 0x10000
    3340:	003e0104 	eorseq	r0, lr, r4, lsl #2
    3344:	21010402 	tstcs	r1, r2, lsl #8
    3348:	4e2e0d03 	cdpmi	13, 2, cr0, cr14, cr3, {0}
    334c:	311d231d 	tstcc	sp, sp, lsl r3
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3350:	3e2f75a0 	cfsh64cc	mvdx7, mvdx15, #-48

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3354:	21312130 	teqcs	r1, r0, lsr r1
    3358:	00160225 	andseq	r0, r6, r5, lsr #4
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    335c:	04c70101 	strbeq	r0, [r7], #257	; 0x101
    3360:	00020000 	andeq	r0, r2, r0

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3364:	00000045 	andeq	r0, r0, r5, asr #32
    3368:	0efb0102 	cdpeq	1, 15, cr0, cr11, cr2, {0}
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    336c:	0101000d 	tsteq	r1, sp
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3370:	00000101 	andeq	r0, r0, r1, lsl #2

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3374:	00000100 	andeq	r0, r0, r0, lsl #2
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3378:	62737501 	rsbsvs	r7, r3, #4194304	; 0x400000
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    337c:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
    3380:	73750000 	cmnvc	r5, #0
    3384:	65725f62 	ldrbvs	r5, [r2, #-3938]!	; 0xf62
    3388:	632e7367 	teqvs	lr, #-1677721599	; 0x9c000001
    338c:	00000100 	andeq	r0, r0, r0, lsl #2
    3390:	5f627375 	svcpl	0x00627375
    3394:	65707974 	ldrbvs	r7, [r0, #-2420]!	; 0x974

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3398:	0100682e 	tsteq	r0, lr, lsr #16
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    339c:	73750000 	cmnvc	r5, #0
    33a0:	65725f62 	ldrbvs	r5, [r2, #-3938]!	; 0xf62
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33a4:	682e7367 	stmdavs	lr!, {r0, r1, r2, r5, r6, r8, r9, ip, sp, lr}
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33a8:	00000100 	andeq	r0, r0, r0, lsl #2
    33ac:	02050000 	andeq	r0, r5, #0
    33b0:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33b4:	13012203 	movwne	r2, #4611	; 0x1203
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33b8:	01000602 	tsteq	r0, r2, lsl #12
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33bc:	02050001 	andeq	r0, r5, #1
    33c0:	00000000 	andeq	r0, r0, r0
    33c4:	13012e03 	movwne	r2, #7683	; 0x1e03
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33c8:	0004022f 	andeq	r0, r4, pc, lsr #4
    33cc:	05000101 	streq	r0, [r0, #-257]	; 0x101
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33d0:	00000002 	andeq	r0, r0, r2
    33d4:	013a0300 	teqeq	sl, r0, lsl #6
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33d8:	00060213 	andeq	r0, r6, r3, lsl r2
    33dc:	05000101 	streq	r0, [r0, #-257]	; 0x101
    33e0:	00000002 	andeq	r0, r0, r2
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33e4:	00c60300 	sbceq	r0, r6, r0, lsl #6
    33e8:	022f1301 	eoreq	r1, pc, #67108864	; 0x4000000
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33ec:	01010004 	tsteq	r1, r4
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33f0:	00020500 	andeq	r0, r2, r0, lsl #10
    33f4:	03000000 	movweq	r0, #0
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33f8:	130100d2 	movwne	r0, #4306	; 0x10d2
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    33fc:	0004022f 	andeq	r0, r4, pc, lsr #4
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3400:	05000101 	streq	r0, [r0, #-257]	; 0x101
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3404:	00000002 	andeq	r0, r0, r2
    3408:	00de0300 	sbcseq	r0, lr, r0, lsl #6
    340c:	06021301 	streq	r1, [r2], -r1, lsl #6
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3410:	00010100 	andeq	r0, r1, r0, lsl #2
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3414:	00000205 	andeq	r0, r0, r5, lsl #4
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3418:	ea030000 	b	c3420 <_etext+0xbbe0c>
    341c:	2f130100 	svccs	0x00130100
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3420:	01000402 	tsteq	r0, r2, lsl #8
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3424:	02050001 	andeq	r0, r5, #1
    3428:	00000000 	andeq	r0, r0, r0
    342c:	0100f603 	tsteq	r0, r3, lsl #12
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3430:	00080213 	andeq	r0, r8, r3, lsl r2
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3434:	05000101 	streq	r0, [r0, #-257]	; 0x101
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3438:	00000002 	andeq	r0, r0, r2
    343c:	01820300 	orreq	r0, r2, r0, lsl #6
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3440:	022f1301 	eoreq	r1, pc, #67108864	; 0x4000000
    3444:	01010004 	tsteq	r1, r4
    3448:	00020500 	andeq	r0, r2, r0, lsl #10
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    344c:	03000000 	movweq	r0, #0
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3450:	1301018f 	movwne	r0, #4495	; 0x118f
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3454:	01000702 	tsteq	r0, r2, lsl #14
    3458:	02050001 	andeq	r0, r5, #1
    345c:	00000000 	andeq	r0, r0, r0
    3460:	01019b03 	tsteq	r1, r3, lsl #22
    3464:	02026713 	andeq	r6, r2, #4980736	; 0x4c0000
    3468:	00010100 	andeq	r0, r1, r0, lsl #2
    346c:	00000205 	andeq	r0, r0, r5, lsl #4
    3470:	a8030000 	stmdage	r3, {}	; <UNPREDICTABLE>
    3474:	02130101 	andseq	r0, r3, #1073741824	; 0x40000000
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3478:	0101000e 	tsteq	r1, lr
    347c:	00020500 	andeq	r0, r2, r0, lsl #10
    3480:	03000000 	movweq	r0, #0
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3484:	130101b4 	movwne	r0, #4532	; 0x11b4
    3488:	00030267 	andeq	r0, r3, r7, ror #4
    348c:	05000101 	streq	r0, [r0, #-257]	; 0x101
    3490:	005c3c02 	subseq	r3, ip, r2, lsl #24
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3494:	01c10300 	biceq	r0, r1, r0, lsl #6
    3498:	15021301 	strne	r1, [r2, #-769]	; 0x301
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    349c:	00010100 	andeq	r0, r1, r0, lsl #2
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34a0:	00000205 	andeq	r0, r0, r5, lsl #4
    34a4:	ce030000 	cdpgt	0, 0, cr0, cr3, cr0, {0}
    34a8:	02130101 	andseq	r0, r3, #1073741824	; 0x40000000
    34ac:	01010015 	tsteq	r1, r5, lsl r0
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34b0:	00020500 	andeq	r0, r2, r0, lsl #10
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34b4:	03000000 	movweq	r0, #0
    34b8:	030101db 	movweq	r0, #4571	; 0x11db
    34bc:	c2030141 	andgt	r0, r3, #1073741840	; 0x40000010
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34c0:	be035800 	cdplt	8, 0, cr5, cr3, cr0, {0}
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34c4:	c203207f 	andgt	r2, r3, #127	; 0x7f
    34c8:	3e222000 	cdpcc	0, 2, cr2, cr2, cr0, {0}
    34cc:	00050230 	andeq	r0, r5, r0, lsr r2
    34d0:	05000101 	streq	r0, [r0, #-257]	; 0x101
    34d4:	00000002 	andeq	r0, r0, r2
    34d8:	01f00300 	mvnseq	r0, r0, lsl #6
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34dc:	02671301 	rsbeq	r1, r7, #67108864	; 0x4000000
    34e0:	01010003 	tsteq	r1, r3
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34e4:	00020500 	andeq	r0, r2, r0, lsl #10
    34e8:	03000000 	movweq	r0, #0
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34ec:	130101fc 	movwne	r0, #4604	; 0x11fc
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34f0:	00030267 	andeq	r0, r3, r7, ror #4
    34f4:	05000101 	streq	r0, [r0, #-257]	; 0x101
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34f8:	00000002 	andeq	r0, r0, r2
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34fc:	02880300 	addeq	r0, r8, #0, 6
    3500:	0f021301 	svceq	0x00021301
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3504:	00010100 	andeq	r0, r1, r0, lsl #2
    3508:	5c660205 	sfmpl	f0, 2, [r6], #-20	; 0xffffffec
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    350c:	94030000 	strls	r0, [r3], #-0
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3510:	02130102 	andseq	r0, r3, #-2147483648	; 0x80000000
    GET_UINT32( W[9],  data, 36 );
    3514:	0101000f 	tsteq	r1, pc
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3518:	00020500 	andeq	r0, r2, r0, lsl #10
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    351c:	03000000 	movweq	r0, #0
    3520:	130102a0 	movwne	r0, #4768	; 0x12a0
    3524:	01000f02 	tsteq	r0, r2, lsl #30
    3528:	02050001 	andeq	r0, r5, #1
    352c:	00000000 	andeq	r0, r0, r0
    3530:	0102ac03 	tsteq	r2, r3, lsl #24
    3534:	000e0213 	andeq	r0, lr, r3, lsl r2
    3538:	05000101 	streq	r0, [r0, #-257]	; 0x101
    353c:	005c8402 	subseq	r8, ip, r2, lsl #8
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3540:	02b70300 	adcseq	r0, r7, #0, 6
    3544:	0e021301 	cdpeq	3, 0, cr1, cr2, cr1, {0}
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3548:	00010100 	andeq	r0, r1, r0, lsl #2
    354c:	00000205 	andeq	r0, r0, r5, lsl #4
    3550:	c2030000 	andgt	r0, r3, #0
    3554:	02130102 	andseq	r0, r3, #-2147483648	; 0x80000000
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3558:	0101000f 	tsteq	r1, pc
    355c:	00020500 	andeq	r0, r2, r0, lsl #10
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3560:	03000000 	movweq	r0, #0
    3564:	130102cd 	movwne	r0, #4813	; 0x12cd
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3568:	01000f02 	tsteq	r0, r2, lsl #30
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    356c:	02050001 	andeq	r0, r5, #1
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3570:	00000000 	andeq	r0, r0, r0
    3574:	0102d803 	tsteq	r2, r3, lsl #16
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3578:	000e0213 	andeq	r0, lr, r3, lsl r2
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    357c:	05000101 	streq	r0, [r0, #-257]	; 0x101
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3580:	00000002 	andeq	r0, r0, r2
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3584:	02e30300 	rsceq	r0, r3, #0, 6
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3588:	02831301 	addeq	r1, r3, #67108864	; 0x4000000
    358c:	01010005 	tsteq	r1, r5
    3590:	00020500 	andeq	r0, r2, r0, lsl #10
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3594:	03000000 	movweq	r0, #0
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3598:	130102ee 	movwne	r0, #4846	; 0x12ee
    359c:	00050283 	andeq	r0, r5, r3, lsl #5
    35a0:	05000101 	streq	r0, [r0, #-257]	; 0x101
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35a4:	00000002 	andeq	r0, r0, r2
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35a8:	02f90300 	rscseq	r0, r9, #0, 6
    35ac:	0c021301 	stceq	3, cr1, [r2], {1}
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35b0:	00010100 	andeq	r0, r1, r0, lsl #2
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35b4:	00000205 	andeq	r0, r0, r5, lsl #4
    35b8:	84030000 	strhi	r0, [r3], #-0
    35bc:	02130103 	andseq	r0, r3, #-1073741824	; 0xc0000000
    35c0:	0101000e 	tsteq	r1, lr
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35c4:	00020500 	andeq	r0, r2, r0, lsl #10
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35c8:	03000000 	movweq	r0, #0
    35cc:	1301038f 	movwne	r0, #5007	; 0x138f
    35d0:	01001002 	tsteq	r0, r2
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35d4:	02050001 	andeq	r0, r5, #1
    35d8:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35dc:	01039a03 	tsteq	r3, r3, lsl #20
    35e0:	00100213 	andseq	r0, r0, r3, lsl r2
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35e4:	05000101 	streq	r0, [r0, #-257]	; 0x101
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35e8:	005ca002 	subseq	sl, ip, r2
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35ec:	03a50300 			; <UNDEFINED> instruction: 0x03a50300
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35f0:	02001301 	andeq	r1, r0, #67108864	; 0x4000000
    35f4:	82060104 	andhi	r0, r6, #4, 2
    35f8:	01000802 	tsteq	r0, r2, lsl #16
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35fc:	02050001 	andeq	r0, r5, #1
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3600:	00005cc0 	andeq	r5, r0, r0, asr #25
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3604:	0103b003 	tsteq	r3, r3
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3608:	04020013 	streq	r0, [r2], #-19
    360c:	02820601 	addeq	r0, r2, #1048576	; 0x100000
    3610:	01010008 	tsteq	r1, r8
    3614:	00020500 	andeq	r0, r2, r0, lsl #10
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3618:	03000000 	movweq	r0, #0
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    361c:	130103bc 	movwne	r0, #5052	; 0x13bc
    3620:	01000f02 	tsteq	r0, r2, lsl #30
    3624:	02050001 	andeq	r0, r5, #1
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3628:	00000000 	andeq	r0, r0, r0
    362c:	0103c703 	tsteq	r3, r3, lsl #14
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3630:	03026713 	movweq	r6, #10003	; 0x2713
    3634:	00010100 	andeq	r0, r1, r0, lsl #2
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3638:	00000205 	andeq	r0, r0, r5, lsl #4
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    363c:	d3030000 	movwle	r0, #12288	; 0x3000
    3640:	02130103 	andseq	r0, r3, #-1073741824	; 0xc0000000
    3644:	01010010 	tsteq	r1, r0, lsl r0
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3648:	00020500 	andeq	r0, r2, r0, lsl #10
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    364c:	03000000 	movweq	r0, #0
    3650:	130103df 	movwne	r0, #5087	; 0x13df
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3654:	01001002 	tsteq	r0, r2
    3658:	02050001 	andeq	r0, r5, #1
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    365c:	00005ce0 	andeq	r5, r0, r0, ror #25
    3660:	0103ea03 	tsteq	r3, r3, lsl #20
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3664:	04029f13 	streq	r9, [r2], #-3859	; 0xf13
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3668:	00010100 	andeq	r0, r1, r0, lsl #2
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    366c:	5cfc0205 	lfmpl	f0, 2, [ip], #20
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3670:	f5030000 			; <UNDEFINED> instruction: 0xf5030000
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3674:	83130103 	tsthi	r3, #-1073741824	; 0xc0000000
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3678:	01000602 	tsteq	r0, r2, lsl #12
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    367c:	02050001 	andeq	r0, r5, #1
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3680:	00005d18 	andeq	r5, r0, r8, lsl sp
    3684:	01048103 	tsteq	r4, r3, lsl #2
    3688:	000e0213 	andeq	r0, lr, r3, lsl r2
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    368c:	05000101 	streq	r0, [r0, #-257]	; 0x101
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3690:	00000002 	andeq	r0, r0, r2
    3694:	048d0300 	streq	r0, [sp], #768	; 0x300
    3698:	02001301 	andeq	r1, r0, #67108864	; 0x4000000
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    369c:	2e060104 	adfcss	f0, f6, f4
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36a0:	02040200 	andeq	r0, r4, #0, 4
    36a4:	0007029e 	muleq	r7, lr, r2
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36a8:	05000101 	streq	r0, [r0, #-257]	; 0x101
    36ac:	005d3402 	subseq	r3, sp, r2, lsl #8
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36b0:	04990300 	ldreq	r0, [r9], #768	; 0x300
    36b4:	02001301 	andeq	r1, r0, #67108864	; 0x4000000
    36b8:	ac060104 	stfges	f0, [r6], {4}
    36bc:	02040200 	andeq	r0, r4, #0, 4
    36c0:	000b029e 	muleq	fp, lr, r2
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36c4:	05000101 	streq	r0, [r0, #-257]	; 0x101
    36c8:	00000002 	andeq	r0, r0, r2
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36cc:	04a40300 	strteq	r0, [r4], #768	; 0x300
    36d0:	02911301 	addseq	r1, r1, #67108864	; 0x4000000
    36d4:	01010007 	tsteq	r1, r7
    36d8:	00020500 	andeq	r0, r2, r0, lsl #10
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36dc:	03000000 	movweq	r0, #0
    36e0:	130104af 	movwne	r0, #5295	; 0x14af
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36e4:	00070291 	muleq	r7, r1, r2
    36e8:	05000101 	streq	r0, [r0, #-257]	; 0x101
    36ec:	00000002 	andeq	r0, r0, r2
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36f0:	04bc0300 	ldrteq	r0, [ip], #768	; 0x300
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36f4:	1b022101 	blne	8bb00 <_etext+0x844ec>
    36f8:	00010100 	andeq	r0, r1, r0, lsl #2
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36fc:	00000205 	andeq	r0, r0, r5, lsl #4
    3700:	c8030000 	stmdagt	r3, {}	; <UNPREDICTABLE>
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3704:	02130104 	andseq	r0, r3, #4, 2
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3708:	01010010 	tsteq	r1, r0, lsl r0
    370c:	00020500 	andeq	r0, r2, r0, lsl #10
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3710:	03000000 	movweq	r0, #0
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3714:	130104d4 	movwne	r0, #5332	; 0x14d4
    3718:	01001002 	tsteq	r0, r2
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    371c:	02050001 	andeq	r0, r5, #1
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3720:	00000000 	andeq	r0, r0, r0
    3724:	0104df03 	tsteq	r4, r3, lsl #30
    3728:	04029f13 	streq	r9, [r2], #-3859	; 0xf13
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    372c:	00010100 	andeq	r0, r1, r0, lsl #2
    3730:	00000205 	andeq	r0, r0, r5, lsl #4
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3734:	ea030000 	b	c373c <_etext+0xbc128>
    3738:	83130104 	tsthi	r3, #4, 2
    373c:	01000602 	tsteq	r0, r2, lsl #12
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3740:	02050001 	andeq	r0, r5, #1
    3744:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3748:	0104f603 	tsteq	r4, r3, lsl #12
    374c:	00211f13 	eoreq	r1, r1, r3, lsl pc
    3750:	06010402 	streq	r0, [r1], -r2, lsl #8
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3754:	04020020 	streq	r0, [r2], #-32
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3758:	00580802 	subseq	r0, r8, r2, lsl #16
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    375c:	f2010402 	vshl.s8	d0, d2, d1
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3760:	02040200 	andeq	r0, r4, #0, 4
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3764:	0402009e 	streq	r0, [r2], #-158	; 0x9e
    3768:	02002e01 	andeq	r2, r0, #1, 28
    376c:	12080204 	andne	r0, r8, #4, 4	; 0x40000000
    3770:	01000e02 	tsteq	r0, r2, lsl #28
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3774:	02050001 	andeq	r0, r5, #1
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3778:	00000000 	andeq	r0, r0, r0
    377c:	01058203 	tsteq	r5, r3, lsl #4
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3780:	04020013 	streq	r0, [r2], #-19
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3784:	002e0601 	eoreq	r0, lr, r1, lsl #12
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3788:	08020402 	stmdaeq	r2, {r1, sl}
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    378c:	0402004a 	streq	r0, [r2], #-74	; 0x4a
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3790:	0e029001 	cdpeq	0, 0, cr9, cr2, cr1, {0}
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3794:	00010100 	andeq	r0, r1, r0, lsl #2
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3798:	00000205 	andeq	r0, r0, r5, lsl #4
    379c:	8e030000 	cdphi	0, 0, cr0, cr3, cr0, {0}
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37a0:	00130105 	andseq	r0, r3, r5, lsl #2
    37a4:	06010402 	streq	r0, [r1], -r2, lsl #8
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    37a8:	0402002e 	streq	r0, [r2], #-46	; 0x2e
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37ac:	004a0802 	subeq	r0, sl, r2, lsl #16
    37b0:	90010402 	andls	r0, r1, r2, lsl #8
    37b4:	01000e02 	tsteq	r0, r2, lsl #28
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    37b8:	02050001 	andeq	r0, r5, #1
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37bc:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    37c0:	01059a03 	tsteq	r5, r3, lsl #20
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37c4:	07029113 	smladeq	r2, r3, r1, r9
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37c8:	00010100 	andeq	r0, r1, r0, lsl #2
    37cc:	00000205 	andeq	r0, r0, r5, lsl #4
    37d0:	a6030000 	strge	r0, [r3], -r0
    37d4:	91130105 	tstls	r3, r5, lsl #2
    37d8:	01000702 	tsteq	r0, r2, lsl #14
    37dc:	02050001 	andeq	r0, r5, #1
    37e0:	00000000 	andeq	r0, r0, r0
    37e4:	0105b203 	tsteq	r5, r3, lsl #4
    37e8:	489fbc13 	ldmmi	pc, {r0, r1, r4, sl, fp, ip, sp, pc}	; <UNPREDICTABLE>
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    37ec:	00070225 	andeq	r0, r7, r5, lsr #4
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37f0:	05000101 	streq	r0, [r0, #-257]	; 0x101
    37f4:	00000002 	andeq	r0, r0, r2
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    37f8:	05c30300 	strbeq	r0, [r3, #768]	; 0x300
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37fc:	bc301301 	ldclt	3, cr1, [r0], #-4
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3800:	000d0230 	andeq	r0, sp, r0, lsr r2
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3804:	05000101 	streq	r0, [r0, #-257]	; 0x101
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3808:	00000002 	andeq	r0, r0, r2
    380c:	05d60300 	ldrbeq	r0, [r6, #768]	; 0x300
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3810:	03021601 	movweq	r1, #9729	; 0x2601
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3814:	00010100 	andeq	r0, r1, r0, lsl #2
    3818:	00000205 	andeq	r0, r0, r5, lsl #4
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    381c:	e3030000 	movw	r0, #12288	; 0x3000
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3820:	30160105 	andscc	r0, r6, r5, lsl #2
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3824:	01000302 	tsteq	r0, r2, lsl #6
    3828:	0000b401 	andeq	fp, r0, r1, lsl #8
    382c:	60000200 	andvs	r0, r0, r0, lsl #4
    3830:	02000000 	andeq	r0, r0, #0
    3834:	0d0efb01 	vstreq	d15, [lr, #-4]
    3838:	01010100 	mrseq	r0, (UNDEF: 17)
    383c:	00000001 	andeq	r0, r0, r1
    3840:	01000001 	tsteq	r0, r1
    3844:	5f627375 	svcpl	0x00627375
    3848:	0062696c 	rsbeq	r6, r2, ip, ror #18
    384c:	62737500 	rsbsvs	r7, r3, #0, 10
    3850:	746e695f 	strbtvc	r6, [lr], #-2399	; 0x95f
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3854:	0100632e 	tsteq	r0, lr, lsr #6
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3858:	73750000 	cmnvc	r5, #0
    385c:	79745f62 	ldmdbvc	r4!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3860:	682e6570 	stmdavs	lr!, {r4, r5, r6, r8, sl, sp, lr}
    3864:	00000100 	andeq	r0, r0, r0, lsl #2
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3868:	5f627375 	svcpl	0x00627375
    386c:	73676572 	cmnvc	r7, #478150656	; 0x1c800000
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3870:	0100682e 	tsteq	r0, lr, lsr #16
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3874:	73750000 	cmnvc	r5, #0
    3878:	6e695f62 	cdpvs	15, 6, cr5, cr9, cr2, {3}
    387c:	682e7469 	stmdavs	lr!, {r0, r3, r5, r6, sl, ip, sp, lr}
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3880:	00000100 	andeq	r0, r0, r0, lsl #2
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3884:	5f627375 	svcpl	0x00627375
    3888:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xf63
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    388c:	0100682e 	tsteq	r0, lr, lsr #16
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3890:	00000000 	andeq	r0, r0, r0
    3894:	5d740205 	lfmpl	f0, 2, [r4, #-20]!	; 0xffffffec
    3898:	29030000 	stmdbcs	r3, {}	; <UNPREDICTABLE>
    389c:	3e842301 	cdpcc	3, 8, cr2, cr4, cr1, {0}
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38a0:	1f3d3659 	svcne	0x003d3659
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    38a4:	95914b3d 	ldrls	r4, [r1, #2877]	; 0xb3d
    38a8:	213c1703 	teqcs	ip, r3, lsl #14
    38ac:	30425930 	subcc	r5, r2, r0, lsr r9
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38b0:	59304359 	ldmdbpl	r0!, {r0, r3, r4, r6, r8, r9, lr}
    38b4:	f3130830 	vceq.i16	d0, d3, d16
    38b8:	67200903 	strvs	r0, [r0, -r3, lsl #18]!
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    38bc:	3f5c5b31 	svccc	0x005c5b31
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38c0:	02311d93 	eorseq	r1, r1, #9408	; 0x24c0
    38c4:	01010016 	tsteq	r1, r6, lsl r0
    38c8:	00020500 	andeq	r0, r2, r0, lsl #10
    38cc:	03000000 	movweq	r0, #0
    38d0:	2301019e 	movwcs	r0, #4510	; 0x119e
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38d4:	675a3e76 			; <UNDEFINED> instruction: 0x675a3e76
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38d8:	313f5b31 	teqcc	pc, r1, lsr fp	; <UNPREDICTABLE>
    38dc:	0100085b 	tsteq	r0, fp, asr r8
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38e0:	00006301 	andeq	r6, r0, r1, lsl #6
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38e4:	45000200 	strmi	r0, [r0, #-512]	; 0x200
    38e8:	02000000 	andeq	r0, r0, #0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38ec:	0d0efb01 	vstreq	d15, [lr, #-4]
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38f0:	01010100 	mrseq	r0, (UNDEF: 17)
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38f4:	00000001 	andeq	r0, r0, r1
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38f8:	01000001 	tsteq	r0, r1
    38fc:	5f627375 	svcpl	0x00627375
    3900:	0062696c 	rsbeq	r6, r2, ip, ror #18
    3904:	62737500 	rsbsvs	r7, r3, #0, 10
    3908:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    390c:	00632e74 	rsbeq	r2, r3, r4, ror lr
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3910:	75000001 	strvc	r0, [r0, #-1]
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3914:	745f6273 	ldrbvc	r6, [pc], #-627	; 391c <sha256_process+0x83c>
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3918:	2e657079 	mcrcs	0, 3, r7, cr5, cr9, {3}
    391c:	00010068 	andeq	r0, r1, r8, rrx
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3920:	62737500 	rsbsvs	r7, r3, #0, 10
    3924:	726f635f 	rsbvc	r6, pc, #2080374785	; 0x7c000001
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3928:	00682e65 	rsbeq	r2, r8, r5, ror #28
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    392c:	00000001 	andeq	r0, r0, r1
    3930:	c8020500 	stmdagt	r2, {r8, sl}
    3934:	0300005e 	movweq	r0, #94	; 0x5e
    3938:	31210135 	teqcc	r1, r5, lsr r1
    393c:	3d2f211d 	stfccs	f2, [pc, #-116]!	; 38d0 <sha256_process+0x7f0>
    3940:	02231d23 	eoreq	r1, r3, #2240	; 0x8c0
    3944:	0101000f 	tsteq	r1, pc
    3948:	00000350 	andeq	r0, r0, r0, asr r3
    394c:	007b0002 	rsbseq	r0, fp, r2
    3950:	01020000 	mrseq	r0, (UNDEF: 2)
    3954:	000d0efb 	strdeq	r0, [sp], -fp
    3958:	01010101 	tsteq	r1, r1, lsl #2
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    395c:	01000000 	mrseq	r0, (UNDEF: 0)
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3960:	75010000 	strvc	r0, [r1, #-0]
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3964:	6c5f6273 	lfmvs	f6, 2, [pc], {115}	; 0x73
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3968:	00006269 	andeq	r6, r0, r9, ror #4
    396c:	5f627375 	svcpl	0x00627375
    3970:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xf63
    3974:	0100632e 	tsteq	r0, lr, lsr #6
    3978:	73750000 	cmnvc	r5, #0
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    397c:	79745f62 	ldmdbvc	r4!, {r1, r5, r6, r8, r9, sl, fp, ip, lr}^
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3980:	682e6570 	stmdavs	lr!, {r4, r5, r6, r8, sl, sp, lr}
    3984:	00000100 	andeq	r0, r0, r0, lsl #2
    3988:	5f627375 	svcpl	0x00627375
    398c:	2e666564 	cdpcs	5, 6, cr6, cr6, cr4, {3}
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3990:	00010068 	andeq	r0, r1, r8, rrx
    3994:	62737500 	rsbsvs	r7, r3, #0, 10
    3998:	726f635f 	rsbvc	r6, pc, #2080374785	; 0x7c000001
    399c:	00682e65 	rsbeq	r2, r8, r5, ror #28
    39a0:	75000001 	strvc	r0, [r0, #-1]
    39a4:	695f6273 	ldmdbvs	pc, {r0, r1, r4, r5, r6, r9, sp, lr}^	; <UNPREDICTABLE>
    39a8:	2e74696e 	cdpcs	9, 7, cr6, cr4, cr14, {3}
    39ac:	00010068 	andeq	r0, r1, r8, rrx
    39b0:	62737500 	rsbsvs	r7, r3, #0, 10
    39b4:	6d656d5f 	stclvs	13, cr6, [r5, #-380]!	; 0xfffffe84
    39b8:	0100682e 	tsteq	r0, lr, lsr #16
    39bc:	73750000 	cmnvc	r5, #0
    39c0:	65725f62 	ldrbvs	r5, [r2, #-3938]!	; 0xf62
    39c4:	682e7367 	stmdavs	lr!, {r0, r1, r2, r5, r6, r8, r9, ip, sp, lr}
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39c8:	00000100 	andeq	r0, r0, r0, lsl #2
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39cc:	02050000 	andeq	r0, r5, #0
    39d0:	00005f00 	andeq	r5, r0, r0, lsl #30
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39d4:	2f013503 	svccs	0x00013503
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39d8:	4b223e22 	blmi	893268 <_etext+0x88bc54>
    39dc:	0005022f 	andeq	r0, r5, pc, lsr #4
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39e0:	05000101 	streq	r0, [r0, #-257]	; 0x101
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39e4:	005f2402 	subseq	r2, pc, r2, lsl #8
    39e8:	00e30300 	rsceq	r0, r3, r0, lsl #6
    39ec:	3e222f01 	cdpcc	15, 2, cr2, cr2, cr1, {0}
    39f0:	022f4b22 	eoreq	r4, pc, #34816	; 0x8800
    39f4:	01010005 	tsteq	r1, r5
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39f8:	48020500 	stmdami	r2, {r8, sl}
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39fc:	0300005f 	movweq	r0, #95	; 0x5f
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a00:	2f01019b 	svccs	0x0001019b
    3a04:	23233d22 	teqcs	r3, #2176	; 0x880
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3a08:	235b311d 	cmpcs	fp, #1073741831	; 0x40000007
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a0c:	4e304022 	cdpmi	0, 3, cr4, cr0, cr2, {1}
    3a10:	22313340 	eorscs	r3, r1, #64, 6
    3a14:	1d314740 	ldcne	7, cr4, [r1, #-256]!	; 0xffffff00
    3a18:	03424c23 	movteq	r4, #11299	; 0x2c23
    3a1c:	034b580b 	movteq	r5, #47115	; 0xb80b
    3a20:	21032e60 	tstcs	r3, r0, ror #28
    3a24:	00070220 	andeq	r0, r7, r0, lsr #4
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3a28:	05000101 	streq	r0, [r0, #-257]	; 0x101
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a2c:	005fd802 	subseq	sp, pc, r2, lsl #16
    3a30:	03e00300 	mvneq	r0, #0, 6
    3a34:	2f1f1301 	svccs	0x001f1301
    3a38:	0033212f 	eorseq	r2, r3, pc, lsr #2
    3a3c:	06010402 	streq	r0, [r1], -r2, lsl #8
    3a40:	4d300620 	ldcmi	6, cr0, [r0, #-128]!	; 0xffffff80
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a44:	352d3492 	strcc	r3, [sp, #-1170]!	; 0x492
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a48:	84765121 	ldrbthi	r5, [r6], #-289	; 0x121
    3a4c:	2f2a244c 	svccs	0x002a244c
    3a50:	231d302f 	tstcs	sp, #47	; 0x2f
    3a54:	00120223 	andseq	r0, r2, r3, lsr #4
    3a58:	05000101 	streq	r0, [r0, #-257]	; 0x101
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a5c:	00608002 	rsbeq	r8, r0, r2
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a60:	00ca0300 	sbceq	r0, sl, r0, lsl #6
    3a64:	1f212201 	svcne	0x00212201
    3a68:	21302f59 	teqcs	r0, r9, asr pc
    3a6c:	0222324b 	eoreq	r3, r2, #-1342177276	; 0xb0000004
    3a70:	01010008 	tsteq	r1, r8
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a74:	b8020500 	stmdalt	r2, {r8, sl}
    3a78:	03000060 	movweq	r0, #96	; 0x60
    3a7c:	240100f8 	strcs	r0, [r1], #-248	; 0xf8
    3a80:	02003e84 	andeq	r3, r0, #132, 28	; 0x840
    3a84:	20060104 	andcs	r0, r6, r4, lsl #2
    3a88:	4b342f06 	blmi	d0f6a8 <_etext+0xd08094>
    3a8c:	2f2f1e22 	svccs	0x002f1e22
    3a90:	07022125 	streq	r2, [r2, -r5, lsr #2]
    3a94:	00010100 	andeq	r0, r1, r0, lsl #2
    3a98:	61000205 	tstvs	r0, r5, lsl #4
    3a9c:	e9030000 	stmdb	r3, {}	; <UNPREDICTABLE>
    3aa0:	40210101 	eormi	r0, r1, r1, lsl #2
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3aa4:	35224b3e 	strcc	r4, [r2, #-2878]!	; 0xb3e
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3aa8:	0f03423d 	svceq	0x0003423d
    3aac:	20720320 	rsbscs	r0, r2, r0, lsr #6
    3ab0:	75035f43 	strvc	r5, [r3, #-3907]	; 0xf43
    3ab4:	31403220 	cmpcc	r0, r0, lsr #4
    3ab8:	01040200 	mrseq	r0, R12_usr
    3abc:	2f062e06 	svccs	0x00062e06
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ac0:	472e0903 	strmi	r0, [lr, -r3, lsl #18]!
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3ac4:	4c231d23 	stcmi	13, cr1, [r3], #-140	; 0xffffff74
    3ac8:	235a5e4b 	cmpcs	sl, #1200	; 0x4b0
    3acc:	4b942f6b 	blmi	fe50f880 <BootRAM+0xd480021>
    3ad0:	0a022131 	beq	8bf9c <_etext+0x84988>
    3ad4:	00010100 	andeq	r0, r1, r0, lsl #2
    3ad8:	61d00205 	bicsvs	r0, r0, r5, lsl #4
    3adc:	c2030000 	andgt	r0, r3, #0
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ae0:	03260102 	teqeq	r6, #-2147483648	; 0x80000000
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3ae4:	7103200f 	tstvc	r3, pc
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ae8:	200f0320 	andcs	r0, pc, r0, lsr #6
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3aec:	21207103 	teqcs	r0, r3, lsl #2
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3af0:	40325443 	eorsmi	r5, r2, r3, asr #8
    3af4:	02002f31 	andeq	r2, r0, #49, 30	; 0xc4
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3af8:	2e060104 	adfcss	f0, f6, f4
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3afc:	09032106 	stmdbeq	r3, {r1, r2, r8, sp}
    3b00:	1d31472e 	ldcne	7, cr4, [r1, #-184]!	; 0xffffff48
    3b04:	4b858823 	blmi	fe165b98 <BootRAM+0xd0d6339>
    3b08:	032e6f03 	teqeq	lr, #3, 30
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3b0c:	07022012 	smladeq	r2, r2, r0, r2
    3b10:	00010100 	andeq	r0, r1, r0, lsl #2
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b14:	62540205 	subsvs	r0, r4, #1342177280	; 0x50000000
    3b18:	f8030000 			; <UNDEFINED> instruction: 0xf8030000
    3b1c:	67210102 	strvs	r0, [r1, -r2, lsl #2]!
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b20:	0007024c 	andeq	r0, r7, ip, asr #4
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b24:	05000101 	streq	r0, [r0, #-257]	; 0x101
    3b28:	00627802 	rsbeq	r7, r2, r2, lsl #16
    3b2c:	03920300 	orrseq	r0, r2, #0, 6
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b30:	223d1501 	eorscs	r1, sp, #4194304	; 0x400000
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b34:	022f233d 	eoreq	r2, pc, #-201326592	; 0xf4000000
    3b38:	01010004 	tsteq	r1, r4
    3b3c:	94020500 	strls	r0, [r2], #-1280	; 0x500
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b40:	03000062 	movweq	r0, #98	; 0x62
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b44:	210107c9 	smlabtcs	r1, r9, r7, r0
    3b48:	404b5a68 	submi	r5, fp, r8, ror #20
    3b4c:	01000d02 	tsteq	r0, r2, lsl #26
    3b50:	02050001 	andeq	r0, r5, #1
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b54:	000062d4 	ldrdeq	r6, [r0], -r4
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b58:	0106cc03 	tsteq	r6, r3, lsl #24
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b5c:	3e2c3e28 	cdpcc	14, 2, cr3, cr12, cr8, {1}
    3b60:	302f5c56 	eorcc	r5, pc, r6, asr ip	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b64:	2f313030 	svccs	0x00313030
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b68:	4a7dbd03 	bmi	1f72f7c <_etext+0x1f6b968>
    3b6c:	3040304e 	subcc	r3, r0, lr, asr #32
    3b70:	3d3d294f 	ldccc	9, cr2, [sp, #-316]!	; 0xfffffec4
    3b74:	304a0c03 	subcc	r0, sl, r3, lsl #24
    3b78:	593c3c03 	ldmdbpl	ip!, {r0, r1, sl, fp, ip, sp}
    3b7c:	3d3c4403 	cfldrscc	mvf4, [ip, #-12]!
    3b80:	3d30443e 	cfldrscc	mvf4, [r0, #-248]!	; 0xffffff08
    3b84:	0b033e3d 	bleq	d3480 <_etext+0xcbe6c>
    3b88:	4130313c 	teqmi	r0, ip, lsr r1
    3b8c:	03303331 	teqeq	r0, #-1006632960	; 0xc4000000
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b90:	0a032e09 	beq	cf3bc <_etext+0xc7da8>
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b94:	039c362e 	orrseq	r3, ip, #48234496	; 0x2e00000
    3b98:	10032e75 	andne	r2, r3, r5, ror lr
    3b9c:	3c190320 	ldccc	3, cr0, [r9], {32}
    3ba0:	302f3e30 	eorcc	r3, pc, r0, lsr lr	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3ba4:	303e303e 	eorscc	r3, lr, lr, lsr r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ba8:	5a42303d 	bpl	108fca4 <_etext+0x1088690>
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bac:	305e4b69 	subscc	r4, lr, r9, ror #22
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bb0:	03306d75 	teqeq	r0, #7488	; 0x1d40
    3bb4:	7203200e 	andvc	r2, r3, #14
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bb8:	035f4320 	cmpeq	pc, #32, 6	; 0x80000000
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bbc:	40322075 	eorsmi	r2, r2, r5, ror r0
    3bc0:	09035931 	stmdbeq	r3, {r0, r4, r5, r8, fp, ip, lr}
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bc4:	3050303c 	subscc	r3, r0, ip, lsr r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bc8:	89674b59 	stmdbhi	r7!, {r0, r3, r4, r6, r8, r9, fp, lr}^
    3bcc:	2f233d22 	svccs	0x00233d22
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bd0:	41306732 	teqmi	r0, r2, lsr r7
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bd4:	413f3169 	teqmi	pc, r9, ror #2
    3bd8:	084c314d 	stmdaeq	ip, {r0, r2, r3, r6, r8, ip, sp}^
    3bdc:	305a3023 	subscc	r3, sl, r3, lsr #32
    3be0:	404b405a 	submi	r4, fp, sl, asr r0
    3be4:	4a2f032f 	bmi	bc48a8 <_etext+0xbbd294>
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3be8:	7ed6032f 	cdpvc	3, 13, cr0, cr6, cr15, {1}
    3bec:	2e2c032e 	cdpcs	3, 2, cr0, cr12, cr14, {1}
    3bf0:	022e0b03 	eoreq	r0, lr, #3072	; 0xc00
    3bf4:	0101000c 	tsteq	r1, ip
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bf8:	b0020500 	andlt	r0, r2, r0, lsl #10
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bfc:	03000065 	movweq	r0, #101	; 0x65
    3c00:	210107a0 	smlatbcs	r1, r0, r7, r0
    3c04:	0402003e 	streq	r0, [r2], #-62	; 0x3e
    3c08:	062e0601 	strteq	r0, [lr], -r1, lsl #12
    3c0c:	2e7c8a03 	vaddcs.f32	s17, s24, s6
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c10:	2633221e 			; <UNDEFINED> instruction: 0x2633221e
    3c14:	2f211f59 	svccs	0x00211f59
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c18:	77301e22 	ldrvc	r1, [r0, -r2, lsr #28]!
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c1c:	2f1f2130 	svccs	0x001f2130
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c20:	3f2f211f 	svccc	0x002f211f
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c24:	4e22404c 	cdpmi	0, 2, cr4, cr2, cr12, {2}
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c28:	03d3033d 	bicseq	r0, r3, #-201326592	; 0xf4000000
    3c2c:	51303f9e 			; <UNDEFINED> instruction: 0x51303f9e
    3c30:	31200903 	teqcc	r0, r3, lsl #18
    3c34:	000f022d 	andeq	r0, pc, sp, lsr #4
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c38:	05000101 	streq	r0, [r0, #-257]	; 0x101
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c3c:	00667802 	rsbeq	r7, r6, r2, lsl #16
    3c40:	07dd0300 	ldrbeq	r0, [sp, r0, lsl #6]
    3c44:	00312201 	eorseq	r2, r1, r1, lsl #4
    3c48:	06010402 	streq	r0, [r1], -r2, lsl #8
    3c4c:	04020020 	streq	r0, [r2], #-32
    3c50:	00760602 	rsbseq	r0, r6, r2, lsl #12
    3c54:	64020402 	strvs	r0, [r2], #-1026	; 0x402
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c58:	00090232 	andeq	r0, r9, r2, lsr r2
    3c5c:	05000101 	streq	r0, [r0, #-257]	; 0x101
    3c60:	0066b002 	rsbeq	fp, r6, r2
    3c64:	06f80300 	ldrbteq	r0, [r8], r0, lsl #6
    3c68:	003e2101 	eorseq	r2, lr, r1, lsl #2
    3c6c:	06010402 	streq	r0, [r1], -r2, lsl #8
    3c70:	3030062e 	eorscc	r0, r0, lr, lsr #12
    3c74:	0200303f 	andeq	r3, r0, #63	; 0x3f
    3c78:	003d0104 	eorseq	r0, sp, r4, lsl #2
    3c7c:	1f010402 	svcne	0x00010402
    3c80:	504c3d31 	subpl	r3, ip, r1, lsr sp
    3c84:	022d3123 	eoreq	r3, sp, #-1073741816	; 0xc0000008
    3c88:	01010009 	tsteq	r1, r9
    3c8c:	00020500 	andeq	r0, r2, r0, lsl #10
    3c90:	03000000 	movweq	r0, #0
    3c94:	020107f1 	andeq	r0, r1, #63176704	; 0x3c40000
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c98:	01010001 	tsteq	r1, r1
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c9c:	0000008f 	andeq	r0, r0, pc, lsl #1
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3ca0:	00360002 	eorseq	r0, r6, r2
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3ca4:	01020000 	mrseq	r0, (UNDEF: 2)
    3ca8:	000d0efb 	strdeq	r0, [sp], -fp
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cac:	01010101 	tsteq	r1, r1, lsl #2
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cb0:	01000000 	mrseq	r0, (UNDEF: 0)
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cb4:	75010000 	strvc	r0, [r1, #-0]
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cb8:	6c5f6273 	lfmvs	f6, 2, [pc], {115}	; 0x73
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cbc:	00006269 	andeq	r6, r0, r9, ror #4
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cc0:	5f627375 	svcpl	0x00627375
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cc4:	2e6d656d 	cdpcs	5, 6, cr6, cr13, cr13, {3}
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cc8:	00010063 	andeq	r0, r1, r3, rrx
    3ccc:	62737500 	rsbsvs	r7, r3, #0, 10
    3cd0:	7079745f 	rsbsvc	r7, r9, pc, asr r4
    3cd4:	00682e65 	rsbeq	r2, r8, r5, ror #28
    3cd8:	00000001 	andeq	r0, r0, r1
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cdc:	0c020500 	cfstr32eq	mvfx0, [r2], {-0}
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3ce0:	03000067 	movweq	r0, #103	; 0x67
    3ce4:	2b240123 	blcs	904178 <_etext+0x8fcb64>
    3ce8:	21232b23 	teqcs	r3, r3, lsr #22
    3cec:	01040200 	mrseq	r0, R12_usr
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cf0:	02002006 	andeq	r2, r0, #6
    3cf4:	4e060204 	cdpmi	2, 0, cr0, cr6, cr4, {0}
    3cf8:	02040200 	andeq	r0, r4, #0, 4
    3cfc:	0402002c 	streq	r0, [r2], #-44	; 0x2c
    3d00:	02003002 	andeq	r3, r0, #2
    3d04:	4e2f0204 	cdpmi	2, 2, cr0, cr15, cr4, {0}
    3d08:	01000102 	tsteq	r0, r2, lsl #2
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d0c:	02050001 	andeq	r0, r5, #1
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d10:	0000673c 	andeq	r6, r0, ip, lsr r7
    3d14:	24013c03 	strcs	r3, [r1], #-3075	; 0xc03
    3d18:	232b232b 	teqcs	fp, #-1409286144	; 0xac000000
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d1c:	04020021 	streq	r0, [r2], #-33	; 0x21
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d20:	00200601 	eoreq	r0, r0, r1, lsl #12
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d24:	06020402 	streq	r0, [r2], -r2, lsl #8
    3d28:	01026930 	tsteq	r2, r0, lsr r9
    3d2c:	Address 0x00003d2c is out of bounds.


Disassembly of section .debug_frame:

00000000 <.debug_frame>:
       0:	0000000c 	andeq	r0, r0, ip
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
       4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
       8:	7c020001 	stcvc	0, cr0, [r2], {1}
       c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
      10:	0000000c 	andeq	r0, r0, ip
      14:	00000000 	andeq	r0, r0, r0
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
      18:	00000b98 	muleq	r0, r8, fp
      1c:	00000002 	andeq	r0, r0, r2
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
      20:	0000000c 	andeq	r0, r0, ip
      24:	00000000 	andeq	r0, r0, r0
      28:	00000b9a 	muleq	r0, sl, fp
    if ((wEPVal & EP_CTR_RX) != 0)
      2c:	00000002 	andeq	r0, r0, r2
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
      30:	0000000c 	andeq	r0, r0, ip
      34:	00000000 	andeq	r0, r0, r0
      38:	00000b9c 	muleq	r0, ip, fp

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
      3c:	00000002 	andeq	r0, r0, r2

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
      40:	0000000c 	andeq	r0, r0, ip
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
      44:	00000000 	andeq	r0, r0, r0
      48:	00000b9e 	muleq	r0, lr, fp
      4c:	0000000a 	andeq	r0, r0, sl

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
      50:	0000000c 	andeq	r0, r0, ip
      54:	00000000 	andeq	r0, r0, r0
      58:	00000ba8 	andeq	r0, r0, r8, lsr #23
      5c:	00000002 	andeq	r0, r0, r2
      60:	0000000c 	andeq	r0, r0, ip
      64:	00000000 	andeq	r0, r0, r0
      68:	00000bac 	andeq	r0, r0, ip, lsr #23
      6c:	00000018 	andeq	r0, r0, r8, lsl r0
      70:	0000000c 	andeq	r0, r0, ip
      74:	00000000 	andeq	r0, r0, r0
      78:	00000bc4 	andeq	r0, r0, r4, asr #23
      7c:	00000002 	andeq	r0, r0, r2
      80:	0000000c 	andeq	r0, r0, ip
      84:	00000000 	andeq	r0, r0, r0
      88:	00000bc6 	andeq	r0, r0, r6, asr #23
      8c:	00000002 	andeq	r0, r0, r2
      90:	0000000c 	andeq	r0, r0, ip
      94:	00000000 	andeq	r0, r0, r0
      98:	00000bc8 	andeq	r0, r0, r8, asr #23
      9c:	00000002 	andeq	r0, r0, r2
      a0:	0000000c 	andeq	r0, r0, ip
      a4:	00000000 	andeq	r0, r0, r0
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
      a8:	00000bca 	andeq	r0, r0, sl, asr #23

	return f25519_eq(a, c);
      ac:	00000002 	andeq	r0, r0, r2
      b0:	0000000c 	andeq	r0, r0, ip
      b4:	00000000 	andeq	r0, r0, r0
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
      b8:	00000bcc 	andeq	r0, r0, ip, asr #23
	f25519_normalize(ey);
      bc:	00000002 	andeq	r0, r0, r2
      c0:	0000000c 	andeq	r0, r0, ip

	return ok;
}
      c4:	00000000 	andeq	r0, r0, r0
      c8:	00000bce 	andeq	r0, r0, lr, asr #23
      cc:	00000002 	andeq	r0, r0, r2
      d0:	0000000c 	andeq	r0, r0, ip
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
      d4:	00000000 	andeq	r0, r0, r0
      d8:	00000bd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
		minusp[i] = c;
      dc:	0000000c 	andeq	r0, r0, ip
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
      e0:	00000018 	andeq	r0, r0, r8, lsl r0
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
      e4:	00000000 	andeq	r0, r0, r0

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
      e8:	00000bdc 	ldrdeq	r0, [r0], -ip
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
      ec:	000000a8 	andeq	r0, r0, r8, lsr #1
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
      f0:	40080e41 	andmi	r0, r8, r1, asr #28
      f4:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
      f8:	00000001 	andeq	r0, r0, r1
      fc:	0000001c 	andeq	r0, r0, ip, lsl r0
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     100:	00000000 	andeq	r0, r0, r0

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
     104:	00000c84 	andeq	r0, r0, r4, lsl #25
     108:	00000060 	andeq	r0, r0, r0, rrx
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     10c:	40100e41 	andsmi	r0, r0, r1, asr #28
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
     110:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
     114:	02854003 	addeq	r4, r5, #3
     118:	00018e40 	andeq	r8, r1, r0, asr #28
     11c:	0000000c 	andeq	r0, r0, ip
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     120:	00000000 	andeq	r0, r0, r0
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
     124:	00000ce4 	andeq	r0, r0, r4, ror #25
     128:	0000000c 	andeq	r0, r0, ip
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
     12c:	0000000c 	andeq	r0, r0, ip

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
     130:	00000000 	andeq	r0, r0, r0
	i <<= 3;

	while (x) {
     134:	00000cf0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
     138:	0000000c 	andeq	r0, r0, ip
     13c:	0000000c 	andeq	r0, r0, ip
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
     140:	00000000 	andeq	r0, r0, r0
	f25519_mul_c(z3, x1sq, 4);
     144:	00000cfc 	strdeq	r0, [r0], -ip
     148:	00000020 	andeq	r0, r0, r0, lsr #32
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	0000000c 	andeq	r0, r0, ip
     150:	00000000 	andeq	r0, r0, r0
     154:	00000d1c 	andeq	r0, r0, ip, lsl sp
	f25519_sub(b, x3, z3); /* D */
     158:	0000000c 	andeq	r0, r0, ip
     15c:	00000018 	andeq	r0, r0, r8, lsl r0
	f25519_mul__distinct(da, a, b);
     160:	00000000 	andeq	r0, r0, r0
     164:	00000d28 	andeq	r0, r0, r8, lsr #26
     168:	00000028 	andeq	r0, r0, r8, lsr #32

	f25519_sub(b, x2, z2);
     16c:	40080e41 	andmi	r0, r8, r1, asr #28
     170:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
	f25519_add(a, x3, z3); /* C */
     174:	00000001 	andeq	r0, r0, r1
     178:	00000024 	andeq	r0, r0, r4, lsr #32
     17c:	00000000 	andeq	r0, r0, r0
	f25519_mul__distinct(cb, a, b);
     180:	00000d50 	andeq	r0, r0, r0, asr sp
     184:	00000068 	andeq	r0, r0, r8, rrx

	f25519_add(a, da, cb);
     188:	40180e41 	andsmi	r0, r8, r1, asr #28
     18c:	81400680 	smlalbbhi	r0, r0, r0, r6	; <UNPREDICTABLE>
     190:	04824005 	streq	r4, [r2], #5
	f25519_mul__distinct(b, a, a);
     194:	40038440 	andmi	r8, r3, r0, asr #8
     198:	8e400285 	cdphi	2, 4, cr0, cr0, cr5, {4}
	f25519_mul__distinct(x5, z1, b);
     19c:	00000001 	andeq	r0, r0, r1
     1a0:	0000000c 	andeq	r0, r0, ip
	...

	f25519_sub(a, da, cb);
     1ac:	00000004 	andeq	r0, r0, r4
	f25519_mul__distinct(b, a, a);
     1b0:	0000000c 	andeq	r0, r0, ip
     1b4:	00000000 	andeq	r0, r0, r0
     1b8:	00000db8 			; <UNDEFINED> instruction: 0x00000db8

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	0000001c 	andeq	r0, r0, ip, lsl r0
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	0000000c 	andeq	r0, r0, ip
     1c4:	00000000 	andeq	r0, r0, r0

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1c8:	00000dd4 	ldrdeq	r0, [r0], -r4
     1cc:	00000018 	andeq	r0, r0, r8, lsl r0
     1d0:	00000018 	andeq	r0, r0, r8, lsl r0
     1d4:	00000000 	andeq	r0, r0, r0
		f25519_select(zm1, zm1, zm, bit);
     1d8:	00000dec 	andeq	r0, r0, ip, ror #27
     1dc:	00000084 	andeq	r0, r0, r4, lsl #1
     1e0:	40080e41 	andmi	r0, r8, r1, asr #28
		f25519_select(xm, xm, xms, bit);
     1e4:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
     1e8:	00000001 	andeq	r0, r0, r1
     1ec:	00000018 	andeq	r0, r0, r8, lsl r0
		f25519_select(zm, zm, zms, bit);
     1f0:	00000000 	andeq	r0, r0, r0
     1f4:	00000e70 	andeq	r0, r0, r0, ror lr
     1f8:	00000048 	andeq	r0, r0, r8, asr #32
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fc:	40080e42 	andmi	r0, r8, r2, asr #28
     200:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     204:	00000001 	andeq	r0, r0, r1
     208:	00000018 	andeq	r0, r0, r8, lsl r0
	f25519_mul__distinct(result, zm1, xm);
     20c:	00000000 	andeq	r0, r0, r0
     210:	00000eb8 			; <UNDEFINED> instruction: 0x00000eb8
	f25519_normalize(result);
     214:	0000003c 	andeq	r0, r0, ip, lsr r0
     218:	40080e43 	andmi	r0, r8, r3, asr #28
}
     21c:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
     220:	00000001 	andeq	r0, r0, r1
     224:	0000000c 	andeq	r0, r0, ip
     228:	00000000 	andeq	r0, r0, r0
     22c:	00000ef4 	strdeq	r0, [r0], -r4
     230:	00000004 	andeq	r0, r0, r4
     234:	0000001c 	andeq	r0, r0, ip, lsl r0
     238:	00000000 	andeq	r0, r0, r0
     23c:	00000ef8 	strdeq	r0, [r0], -r8
     240:	00000024 	andeq	r0, r0, r4, lsr #32
     244:	40100e41 	andsmi	r0, r0, r1, asr #28
     248:	81400480 	smlalbbhi	r0, r0, r0, r4	; <UNPREDICTABLE>
     24c:	02824003 	addeq	r4, r2, #3
     250:	00018e40 	andeq	r8, r1, r0, asr #28
     254:	00000018 	andeq	r0, r0, r8, lsl r0
     258:	00000000 	andeq	r0, r0, r0
     25c:	00000f1c 	andeq	r0, r0, ip, lsl pc
     260:	00000040 	andeq	r0, r0, r0, asr #32
     264:	40080e41 	andmi	r0, r8, r1, asr #28
     268:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
     26c:	00000001 	andeq	r0, r0, r1
     270:	0000001c 	andeq	r0, r0, ip, lsl r0
     274:	00000000 	andeq	r0, r0, r0
     278:	00000f5c 	andeq	r0, r0, ip, asr pc
     27c:	00000022 	andeq	r0, r0, r2, lsr #32
     280:	40100e41 	andsmi	r0, r0, r1, asr #28
     284:	81400480 	smlalbbhi	r0, r0, r0, r4	; <UNPREDICTABLE>
     288:	02824003 	addeq	r4, r2, #3
     28c:	00018e40 	andeq	r8, r1, r0, asr #28
     290:	0000001c 	andeq	r0, r0, ip, lsl r0
     294:	00000000 	andeq	r0, r0, r0
     298:	00000f80 	andeq	r0, r0, r0, lsl #31
     29c:	000000b4 	strheq	r0, [r0], -r4
     2a0:	40100e41 	andsmi	r0, r0, r1, asr #28
     2a4:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     2a8:	02864003 	addeq	r4, r6, #3
     2ac:	00018e40 	andeq	r8, r1, r0, asr #28
     2b0:	0000000c 	andeq	r0, r0, ip
	...
     2bc:	0000000c 	andeq	r0, r0, ip
     2c0:	0000000c 	andeq	r0, r0, ip
     2c4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     2c8:	7c020001 	stcvc	0, cr0, [r2], {1}
     2cc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     2d0:	0000001c 	andeq	r0, r0, ip, lsl r0
     2d4:	000002c0 	andeq	r0, r0, r0, asr #5
     2d8:	00001034 	andeq	r1, r0, r4, lsr r0
     2dc:	00000104 	andeq	r0, r0, r4, lsl #2
     2e0:	400c0e41 	andmi	r0, ip, r1, asr #28
     2e4:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     2e8:	018e4002 	orreq	r4, lr, r2
     2ec:	00200e41 	eoreq	r0, r0, r1, asr #28
     2f0:	0000000c 	andeq	r0, r0, ip
     2f4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     2f8:	7c020001 	stcvc	0, cr0, [r2], {1}
     2fc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     300:	0000000c 	andeq	r0, r0, ip
     304:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     308:	00001138 	andeq	r1, r0, r8, lsr r1
     30c:	00000016 	andeq	r0, r0, r6, lsl r0
     310:	0000000c 	andeq	r0, r0, ip
     314:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     318:	0000114e 	andeq	r1, r0, lr, asr #2
     31c:	00000012 	andeq	r0, r0, r2, lsl r0
     320:	00000028 	andeq	r0, r0, r8, lsr #32
     324:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     328:	00001160 	andeq	r1, r0, r0, ror #2
     32c:	00000050 	andeq	r0, r0, r0, asr r0
     330:	40200e42 	eormi	r0, r0, r2, asr #28
     334:	85400884 	strbhi	r0, [r0, #-2180]	; 0x884
     338:	06864007 	streq	r4, [r6], r7
     33c:	40058740 	andmi	r8, r5, r0, asr #14
     340:	89400488 	stmdbhi	r0, {r3, r7, sl}^
     344:	028a4003 	addeq	r4, sl, #3
     348:	00018e40 	andeq	r8, r1, r0, asr #28
     34c:	0000000c 	andeq	r0, r0, ip
     350:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     354:	000011b0 			; <UNDEFINED> instruction: 0x000011b0
     358:	0000000a 	andeq	r0, r0, sl
     35c:	0000001c 	andeq	r0, r0, ip, lsl r0
     360:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     364:	000011ba 			; <UNDEFINED> instruction: 0x000011ba
     368:	00000016 	andeq	r0, r0, r6, lsl r0
     36c:	40100e41 	andsmi	r0, r0, r1, asr #28
     370:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
     374:	02854003 	addeq	r4, r5, #3
     378:	00018e40 	andeq	r8, r1, r0, asr #28
     37c:	00000018 	andeq	r0, r0, r8, lsl r0
     380:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     384:	000011d0 	ldrdeq	r1, [r0], -r0
     388:	00000028 	andeq	r0, r0, r8, lsr #32
     38c:	40040e41 	andmi	r0, r4, r1, asr #28
     390:	0e42018e 	dvfeqd	f0, f2, #0.5
     394:	000001d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     398:	0000002c 	andeq	r0, r0, ip, lsr #32
     39c:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     3a0:	000011f8 	strdeq	r1, [r0], -r8
     3a4:	0000001a 	andeq	r0, r0, sl, lsl r0
     3a8:	40100e41 	andsmi	r0, r0, r1, asr #28
     3ac:	81400480 	smlalbbhi	r0, r0, r0, r4	; <UNPREDICTABLE>
     3b0:	02824003 	addeq	r4, r2, #3
     3b4:	41018340 	tstmi	r1, r0, asr #6
     3b8:	8040200e 	subhi	r2, r0, lr
     3bc:	07814008 	streq	r4, [r1, r8]
     3c0:	40068240 	andmi	r8, r6, r0, asr #4
     3c4:	0000058e 	andeq	r0, r0, lr, lsl #11
     3c8:	00000024 	andeq	r0, r0, r4, lsr #32
     3cc:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     3d0:	00001214 	andeq	r1, r0, r4, lsl r2
     3d4:	0000009c 	muleq	r0, ip, r0
     3d8:	40140e41 	andsmi	r0, r4, r1, asr #28
     3dc:	85400584 	strbhi	r0, [r0, #-1412]	; 0x584
     3e0:	03864004 	orreq	r4, r6, #4
     3e4:	40028740 	andmi	r8, r2, r0, asr #14
     3e8:	0e41018e 	dvfeqd	f0, f1, #0.5
     3ec:	00000030 	andeq	r0, r0, r0, lsr r0
     3f0:	0000001c 	andeq	r0, r0, ip, lsl r0
     3f4:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     3f8:	000012b0 			; <UNDEFINED> instruction: 0x000012b0
     3fc:	00000028 	andeq	r0, r0, r8, lsr #32
     400:	40100e41 	andsmi	r0, r0, r1, asr #28
     404:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
     408:	02854003 	addeq	r4, r5, #3
     40c:	00018e40 	andeq	r8, r1, r0, asr #28
     410:	00000018 	andeq	r0, r0, r8, lsl r0
     414:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     418:	000012d8 	ldrdeq	r1, [r0], -r8
     41c:	00000088 	andeq	r0, r0, r8, lsl #1
     420:	40080e41 	andmi	r0, r8, r1, asr #28
     424:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
     428:	200e4201 	andcs	r4, lr, r1, lsl #4
     42c:	0000000c 	andeq	r0, r0, ip
     430:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     434:	00001360 	andeq	r1, r0, r0, ror #6
     438:	00000048 	andeq	r0, r0, r8, asr #32
     43c:	0000000c 	andeq	r0, r0, ip
     440:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     444:	000013a8 	andeq	r1, r0, r8, lsr #7
     448:	00000060 	andeq	r0, r0, r0, rrx
     44c:	0000000c 	andeq	r0, r0, ip
     450:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     454:	00001408 	andeq	r1, r0, r8, lsl #8
     458:	00000014 	andeq	r0, r0, r4, lsl r0
     45c:	0000000c 	andeq	r0, r0, ip
     460:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     464:	0000141c 	andeq	r1, r0, ip, lsl r4
     468:	0000001c 	andeq	r0, r0, ip, lsl r0
     46c:	00000024 	andeq	r0, r0, r4, lsr #32
     470:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     474:	00000000 	andeq	r0, r0, r0
     478:	0000002e 	andeq	r0, r0, lr, lsr #32
     47c:	40180e41 	andsmi	r0, r8, r1, asr #28
     480:	81400680 	smlalbbhi	r0, r0, r0, r6	; <UNPREDICTABLE>
     484:	04824005 	streq	r4, [r2], #5
     488:	40038440 	andmi	r8, r3, r0, asr #8
     48c:	8e400285 	cdphi	2, 4, cr0, cr0, cr5, {4}
     490:	00000001 	andeq	r0, r0, r1
     494:	00000018 	andeq	r0, r0, r8, lsl r0
     498:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     49c:	00001438 	andeq	r1, r0, r8, lsr r4
     4a0:	00000018 	andeq	r0, r0, r8, lsl r0
     4a4:	40080e42 	andmi	r0, r8, r2, asr #28
     4a8:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
     4ac:	00000001 	andeq	r0, r0, r1
     4b0:	0000000c 	andeq	r0, r0, ip
     4b4:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     4b8:	00000000 	andeq	r0, r0, r0
     4bc:	0000002c 	andeq	r0, r0, ip, lsr #32
     4c0:	0000001c 	andeq	r0, r0, ip, lsl r0
     4c4:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     4c8:	00000000 	andeq	r0, r0, r0
     4cc:	00000048 	andeq	r0, r0, r8, asr #32
     4d0:	40100e41 	andsmi	r0, r0, r1, asr #28
     4d4:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
     4d8:	02854003 	addeq	r4, r5, #3
     4dc:	00018e40 	andeq	r8, r1, r0, asr #28
     4e0:	00000018 	andeq	r0, r0, r8, lsl r0
     4e4:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     4e8:	00001450 	andeq	r1, r0, r0, asr r4
     4ec:	0000006c 	andeq	r0, r0, ip, rrx
     4f0:	400c0e42 	andmi	r0, ip, r2, asr #28
     4f4:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     4f8:	018e4002 	orreq	r4, lr, r2
     4fc:	0000000c 	andeq	r0, r0, ip
     500:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     504:	000014bc 			; <UNDEFINED> instruction: 0x000014bc
     508:	00000024 	andeq	r0, r0, r4, lsr #32
     50c:	00000018 	andeq	r0, r0, r8, lsl r0
     510:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     514:	000014e0 	andeq	r1, r0, r0, ror #9
     518:	0000001e 	andeq	r0, r0, lr, lsl r0
     51c:	40080e41 	andmi	r0, r8, r1, asr #28
     520:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
     524:	00000001 	andeq	r0, r0, r1
     528:	0000000c 	andeq	r0, r0, ip
     52c:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     530:	00001500 	andeq	r1, r0, r0, lsl #10
     534:	00000014 	andeq	r0, r0, r4, lsl r0
     538:	00000018 	andeq	r0, r0, r8, lsl r0
     53c:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     540:	00001514 	andeq	r1, r0, r4, lsl r5
     544:	00000034 	andeq	r0, r0, r4, lsr r0
     548:	40080e42 	andmi	r0, r8, r2, asr #28
     54c:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
     550:	00000001 	andeq	r0, r0, r1
     554:	0000001c 	andeq	r0, r0, ip, lsl r0
     558:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     55c:	00000000 	andeq	r0, r0, r0
     560:	00000030 	andeq	r0, r0, r0, lsr r0
     564:	40100e42 	andsmi	r0, r0, r2, asr #28
     568:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
     56c:	02854003 	addeq	r4, r5, #3
     570:	00018e40 	andeq	r8, r1, r0, asr #28
     574:	00000024 	andeq	r0, r0, r4, lsr #32
     578:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     57c:	00001548 	andeq	r1, r0, r8, asr #10
     580:	0000004c 	andeq	r0, r0, ip, asr #32
     584:	40180e41 	andsmi	r0, r8, r1, asr #28
     588:	81400680 	smlalbbhi	r0, r0, r0, r6	; <UNPREDICTABLE>
     58c:	04824005 	streq	r4, [r2], #5
     590:	40038440 	andmi	r8, r3, r0, asr #8
     594:	8e400285 	cdphi	2, 4, cr0, cr0, cr5, {4}
     598:	00000001 	andeq	r0, r0, r1
     59c:	0000000c 	andeq	r0, r0, ip
     5a0:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     5a4:	00001594 	muleq	r0, r4, r5
     5a8:	0000000c 	andeq	r0, r0, ip
     5ac:	0000000c 	andeq	r0, r0, ip
     5b0:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     5b4:	000015a0 	andeq	r1, r0, r0, lsr #11
     5b8:	00000018 	andeq	r0, r0, r8, lsl r0
     5bc:	0000000c 	andeq	r0, r0, ip
     5c0:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     5c4:	000015b8 			; <UNDEFINED> instruction: 0x000015b8
     5c8:	00000012 	andeq	r0, r0, r2, lsl r0
     5cc:	0000000c 	andeq	r0, r0, ip
     5d0:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     5d4:	000015cc 	andeq	r1, r0, ip, asr #11
     5d8:	00000010 	andeq	r0, r0, r0, lsl r0
     5dc:	0000000c 	andeq	r0, r0, ip
     5e0:	000002f0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
     5e4:	000015dc 	ldrdeq	r1, [r0], -ip
     5e8:	00000018 	andeq	r0, r0, r8, lsl r0
     5ec:	0000000c 	andeq	r0, r0, ip
     5f0:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     5f4:	7c020001 	stcvc	0, cr0, [r2], {1}
     5f8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     5fc:	00000018 	andeq	r0, r0, r8, lsl r0
     600:	000005ec 	andeq	r0, r0, ip, ror #11
     604:	000015f4 	strdeq	r1, [r0], -r4
     608:	00000088 	andeq	r0, r0, r8, lsl #1
     60c:	40080e42 	andmi	r0, r8, r2, asr #28
     610:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
     614:	00000001 	andeq	r0, r0, r1
     618:	00000018 	andeq	r0, r0, r8, lsl r0
     61c:	000005ec 	andeq	r0, r0, ip, ror #11
     620:	0000167c 	andeq	r1, r0, ip, ror r6
     624:	00000044 	andeq	r0, r0, r4, asr #32
     628:	40080e41 	andmi	r0, r8, r1, asr #28
     62c:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
     630:	00000001 	andeq	r0, r0, r1
     634:	0000000c 	andeq	r0, r0, ip
     638:	000005ec 	andeq	r0, r0, ip, ror #11
     63c:	00000000 	andeq	r0, r0, r0
     640:	00000002 	andeq	r0, r0, r2
     644:	0000000c 	andeq	r0, r0, ip
     648:	000005ec 	andeq	r0, r0, ip, ror #11
     64c:	000016c0 	andeq	r1, r0, r0, asr #13
     650:	00000018 	andeq	r0, r0, r8, lsl r0
     654:	0000000c 	andeq	r0, r0, ip
     658:	000005ec 	andeq	r0, r0, ip, ror #11
     65c:	000016d8 	ldrdeq	r1, [r0], -r8
     660:	00000018 	andeq	r0, r0, r8, lsl r0
     664:	0000000c 	andeq	r0, r0, ip
     668:	000005ec 	andeq	r0, r0, ip, ror #11
     66c:	000016f0 	strdeq	r1, [r0], -r0
     670:	00000028 	andeq	r0, r0, r8, lsr #32
     674:	0000000c 	andeq	r0, r0, ip
     678:	000005ec 	andeq	r0, r0, ip, ror #11
     67c:	00001718 	andeq	r1, r0, r8, lsl r7
     680:	00000034 	andeq	r0, r0, r4, lsr r0
     684:	0000001c 	andeq	r0, r0, ip, lsl r0
     688:	000005ec 	andeq	r0, r0, ip, ror #11
     68c:	0000174c 	andeq	r1, r0, ip, asr #14
     690:	0000005c 	andeq	r0, r0, ip, asr r0
     694:	40100e41 	andsmi	r0, r0, r1, asr #28
     698:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     69c:	02864003 	addeq	r4, r6, #3
     6a0:	00018e40 	andeq	r8, r1, r0, asr #28
     6a4:	00000028 	andeq	r0, r0, r8, lsr #32
     6a8:	000005ec 	andeq	r0, r0, ip, ror #11
     6ac:	000017a8 	andeq	r1, r0, r8, lsr #15
     6b0:	00000254 	andeq	r0, r0, r4, asr r2
     6b4:	40200e42 	eormi	r0, r0, r2, asr #28
     6b8:	81400880 	smlalbbhi	r0, r0, r0, r8	; <UNPREDICTABLE>
     6bc:	06844007 	streq	r4, [r4], r7
     6c0:	40058540 	andmi	r8, r5, r0, asr #10
     6c4:	87400486 	strbhi	r0, [r0, -r6, lsl #9]
     6c8:	02884003 	addeq	r4, r8, #3
     6cc:	00018e40 	andeq	r8, r1, r0, asr #28
     6d0:	0000000c 	andeq	r0, r0, ip
     6d4:	000005ec 	andeq	r0, r0, ip, ror #11
     6d8:	00000000 	andeq	r0, r0, r0
     6dc:	0000000c 	andeq	r0, r0, ip
     6e0:	0000000c 	andeq	r0, r0, ip
     6e4:	000005ec 	andeq	r0, r0, ip, ror #11
     6e8:	00000000 	andeq	r0, r0, r0
     6ec:	0000000c 	andeq	r0, r0, ip
     6f0:	0000000c 	andeq	r0, r0, ip
     6f4:	000005ec 	andeq	r0, r0, ip, ror #11
     6f8:	000019fc 	strdeq	r1, [r0], -ip
     6fc:	0000000c 	andeq	r0, r0, ip
     700:	0000000c 	andeq	r0, r0, ip
     704:	000005ec 	andeq	r0, r0, ip, ror #11
     708:	00000000 	andeq	r0, r0, r0
     70c:	0000001c 	andeq	r0, r0, ip, lsl r0
     710:	0000000c 	andeq	r0, r0, ip
     714:	000005ec 	andeq	r0, r0, ip, ror #11
     718:	00001a08 	andeq	r1, r0, r8, lsl #20
     71c:	00000002 	andeq	r0, r0, r2
     720:	0000000c 	andeq	r0, r0, ip
     724:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     728:	7c020001 	stcvc	0, cr0, [r2], {1}
     72c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     730:	00000028 	andeq	r0, r0, r8, lsr #32
     734:	00000720 	andeq	r0, r0, r0, lsr #14
     738:	00000000 	andeq	r0, r0, r0
     73c:	00000228 	andeq	r0, r0, r8, lsr #4
     740:	40180e42 	andsmi	r0, r8, r2, asr #28
     744:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     748:	04864005 	streq	r4, [r6], #5
     74c:	40038740 	andmi	r8, r3, r0, asr #14
     750:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
     754:	d80e4201 	stmdale	lr, {r0, r9, lr}
     758:	00000002 	andeq	r0, r0, r2
     75c:	0000000c 	andeq	r0, r0, ip
     760:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     764:	7c020001 	stcvc	0, cr0, [r2], {1}
     768:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     76c:	00000024 	andeq	r0, r0, r4, lsr #32
     770:	0000075c 	andeq	r0, r0, ip, asr r7
     774:	00001a0c 	andeq	r1, r0, ip, lsl #20
     778:	00000070 	andeq	r0, r0, r0, ror r0
     77c:	40180e41 	andsmi	r0, r8, r1, asr #28
     780:	84400683 	strbhi	r0, [r0], #-1667	; 0x683
     784:	04854005 	streq	r4, [r5], #5
     788:	40038640 	andmi	r8, r3, r0, asr #12
     78c:	8e400287 	cdphi	2, 4, cr0, cr0, cr7, {4}
     790:	00000001 	andeq	r0, r0, r1
     794:	00000020 	andeq	r0, r0, r0, lsr #32
     798:	0000075c 	andeq	r0, r0, ip, asr r7
     79c:	00001a7c 	andeq	r1, r0, ip, ror sl
     7a0:	0000003a 	andeq	r0, r0, sl, lsr r0
     7a4:	40100e41 	andsmi	r0, r0, r1, asr #28
     7a8:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     7ac:	02864003 	addeq	r4, r6, #3
     7b0:	41018e40 	tstmi	r1, r0, asr #28
     7b4:	0000300e 	andeq	r3, r0, lr
     7b8:	00000024 	andeq	r0, r0, r4, lsr #32
     7bc:	0000075c 	andeq	r0, r0, ip, asr r7
     7c0:	00001ab8 			; <UNDEFINED> instruction: 0x00001ab8
     7c4:	0000005e 	andeq	r0, r0, lr, asr r0
     7c8:	40140e41 	andsmi	r0, r4, r1, asr #28
     7cc:	85400584 	strbhi	r0, [r0, #-1412]	; 0x584
     7d0:	03864004 	orreq	r4, r6, #4
     7d4:	40028740 	andmi	r8, r2, r0, asr #14
     7d8:	0e44018e 	dvfeqd	f0, f4, #0.5
     7dc:	00000038 	andeq	r0, r0, r8, lsr r0
     7e0:	00000024 	andeq	r0, r0, r4, lsr #32
     7e4:	0000075c 	andeq	r0, r0, ip, asr r7
     7e8:	00001b18 	andeq	r1, r0, r8, lsl fp
     7ec:	000000c8 	andeq	r0, r0, r8, asr #1
     7f0:	40180e42 	andsmi	r0, r8, r2, asr #28
     7f4:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     7f8:	04864005 	streq	r4, [r6], #5
     7fc:	40038740 	andmi	r8, r3, r0, asr #14
     800:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
     804:	780e5301 	stmdavc	lr, {r0, r8, r9, ip, lr}
     808:	00000028 	andeq	r0, r0, r8, lsr #32
     80c:	0000075c 	andeq	r0, r0, ip, asr r7
     810:	00001be0 	andeq	r1, r0, r0, ror #23
     814:	000000e0 	andeq	r0, r0, r0, ror #1
     818:	40180e42 	andsmi	r0, r8, r2, asr #28
     81c:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     820:	04864005 	streq	r4, [r6], #5
     824:	40038740 	andmi	r8, r3, r0, asr #14
     828:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
     82c:	980e4201 	stmdals	lr, {r0, r9, lr}
     830:	00000002 	andeq	r0, r0, r2
     834:	00000020 	andeq	r0, r0, r0, lsr #32
     838:	0000075c 	andeq	r0, r0, ip, asr r7
     83c:	00001cc0 	andeq	r1, r0, r0, asr #25
     840:	000000b4 	strheq	r0, [r0], -r4
     844:	40100e41 	andsmi	r0, r0, r1, asr #28
     848:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     84c:	02864003 	addeq	r4, r6, #3
     850:	41018e40 	tstmi	r1, r0, asr #28
     854:	0001f00e 	andeq	pc, r1, lr
     858:	00000028 	andeq	r0, r0, r8, lsr #32
     85c:	0000075c 	andeq	r0, r0, ip, asr r7
     860:	00001d74 	andeq	r1, r0, r4, ror sp
     864:	00000084 	andeq	r0, r0, r4, lsl #1
     868:	40180e42 	andsmi	r0, r8, r2, asr #28
     86c:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     870:	04864005 	streq	r4, [r6], #5
     874:	40038740 	andmi	r8, r3, r0, asr #14
     878:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
     87c:	980e4101 	stmdals	lr, {r0, r8, lr}
     880:	00000002 	andeq	r0, r0, r2
     884:	0000000c 	andeq	r0, r0, ip
     888:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     88c:	7c020001 	stcvc	0, cr0, [r2], {1}
     890:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     894:	00000024 	andeq	r0, r0, r4, lsr #32
     898:	00000884 	andeq	r0, r0, r4, lsl #17
     89c:	00000000 	andeq	r0, r0, r0
     8a0:	0000007c 	andeq	r0, r0, ip, ror r0
     8a4:	40140e41 	andsmi	r0, r4, r1, asr #28
     8a8:	85400584 	strbhi	r0, [r0, #-1412]	; 0x584
     8ac:	03864004 	orreq	r4, r6, #4
     8b0:	40028740 	andmi	r8, r2, r0, asr #14
     8b4:	0e42018e 	dvfeqd	f0, f2, #0.5
     8b8:	00000298 	muleq	r0, r8, r2
     8bc:	00000028 	andeq	r0, r0, r8, lsr #32
     8c0:	00000884 	andeq	r0, r0, r4, lsl #17
     8c4:	00001df8 	strdeq	r1, [r0], -r8
     8c8:	0000017c 	andeq	r0, r0, ip, ror r1
     8cc:	401c0e42 	andsmi	r0, ip, r2, asr #28
     8d0:	85400784 	strbhi	r0, [r0, #-1924]	; 0x784
     8d4:	05864006 	streq	r4, [r6, #6]
     8d8:	40048740 	andmi	r8, r4, r0, asr #14
     8dc:	89400388 	stmdbhi	r0, {r3, r7, r8, r9}^
     8e0:	018e4002 	orreq	r4, lr, r2
     8e4:	03c00e43 	biceq	r0, r0, #1072	; 0x430
     8e8:	0000000c 	andeq	r0, r0, ip
     8ec:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     8f0:	7c020001 	stcvc	0, cr0, [r2], {1}
     8f4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     8f8:	00000014 	andeq	r0, r0, r4, lsl r0
     8fc:	000008e8 	andeq	r0, r0, r8, ror #17
     900:	00001f74 	andeq	r1, r0, r4, ror pc
     904:	0000001e 	andeq	r0, r0, lr, lsl r0
     908:	40040e41 	andmi	r0, r4, r1, asr #28
     90c:	00000184 	andeq	r0, r0, r4, lsl #3
     910:	00000018 	andeq	r0, r0, r8, lsl r0
     914:	000008e8 	andeq	r0, r0, r8, ror #17
     918:	00001f94 	muleq	r0, r4, pc	; <UNPREDICTABLE>
     91c:	0000006e 	andeq	r0, r0, lr, rrx
     920:	40040e41 	andmi	r0, r4, r1, asr #28
     924:	0e420184 	dvfeqd	f0, f2, f4
     928:	00000028 	andeq	r0, r0, r8, lsr #32
     92c:	0000001c 	andeq	r0, r0, ip, lsl r0
     930:	000008e8 	andeq	r0, r0, r8, ror #17
     934:	00002004 	andeq	r2, r0, r4
     938:	0000009a 	muleq	r0, sl, r0
     93c:	40100e44 	andsmi	r0, r0, r4, asr #28
     940:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     944:	02864003 	addeq	r4, r6, #3
     948:	00018740 	andeq	r8, r1, r0, asr #14
     94c:	0000001c 	andeq	r0, r0, ip, lsl r0
     950:	000008e8 	andeq	r0, r0, r8, ror #17
     954:	000020a0 	andeq	r2, r0, r0, lsr #1
     958:	000000c2 	andeq	r0, r0, r2, asr #1
     95c:	40100e41 	andsmi	r0, r0, r1, asr #28
     960:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     964:	02864003 	addeq	r4, r6, #3
     968:	00018740 	andeq	r8, r1, r0, asr #14
     96c:	00000018 	andeq	r0, r0, r8, lsl r0
     970:	000008e8 	andeq	r0, r0, r8, ror #17
     974:	00002164 	andeq	r2, r0, r4, ror #2
     978:	00000046 	andeq	r0, r0, r6, asr #32
     97c:	400c0e42 	andmi	r0, ip, r2, asr #28
     980:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     984:	01864002 	orreq	r4, r6, r2
     988:	00000018 	andeq	r0, r0, r8, lsl r0
     98c:	000008e8 	andeq	r0, r0, r8, ror #17
     990:	000021ac 	andeq	r2, r0, ip, lsr #3
     994:	0000004c 	andeq	r0, r0, ip, asr #32
     998:	400c0e41 	andmi	r0, ip, r1, asr #28
     99c:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     9a0:	01864002 	orreq	r4, r6, r2
     9a4:	00000014 	andeq	r0, r0, r4, lsl r0
     9a8:	000008e8 	andeq	r0, r0, r8, ror #17
     9ac:	000021f8 	strdeq	r2, [r0], -r8
     9b0:	00000046 	andeq	r0, r0, r6, asr #32
     9b4:	40040e41 	andmi	r0, r4, r1, asr #28
     9b8:	00000184 	andeq	r0, r0, r4, lsl #3
     9bc:	00000024 	andeq	r0, r0, r4, lsr #32
     9c0:	000008e8 	andeq	r0, r0, r8, ror #17
     9c4:	00002240 	andeq	r2, r0, r0, asr #4
     9c8:	00000088 	andeq	r0, r0, r8, lsl #1
     9cc:	40180e42 	andsmi	r0, r8, r2, asr #28
     9d0:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     9d4:	04864005 	streq	r4, [r6], #5
     9d8:	40038740 	andmi	r8, r3, r0, asr #14
     9dc:	89400288 	stmdbhi	r0, {r3, r7, r9}^
     9e0:	00000001 	andeq	r0, r0, r1
     9e4:	00000024 	andeq	r0, r0, r4, lsr #32
     9e8:	000008e8 	andeq	r0, r0, r8, ror #17
     9ec:	00000000 	andeq	r0, r0, r0
     9f0:	000000b8 	strheq	r0, [r0], -r8
     9f4:	40180e42 	andsmi	r0, r8, r2, asr #28
     9f8:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     9fc:	04864005 	streq	r4, [r6], #5
     a00:	40038740 	andmi	r8, r3, r0, asr #14
     a04:	89400288 	stmdbhi	r0, {r3, r7, r9}^
     a08:	380e4401 	stmdacc	lr, {r0, sl, lr}
     a0c:	00000018 	andeq	r0, r0, r8, lsl r0
     a10:	000008e8 	andeq	r0, r0, r8, ror #17
     a14:	00000000 	andeq	r0, r0, r0
     a18:	00000040 	andeq	r0, r0, r0, asr #32
     a1c:	40080e42 	andmi	r0, r8, r2, asr #28
     a20:	85400284 	strbhi	r0, [r0, #-644]	; 0x284
     a24:	00000001 	andeq	r0, r0, r1
     a28:	0000002c 	andeq	r0, r0, ip, lsr #32
     a2c:	000008e8 	andeq	r0, r0, r8, ror #17
     a30:	000022c8 	andeq	r2, r0, r8, asr #5
     a34:	000005ea 	andeq	r0, r0, sl, ror #11
     a38:	40200e42 	eormi	r0, r0, r2, asr #28
     a3c:	85400884 	strbhi	r0, [r0, #-2180]	; 0x884
     a40:	06864007 	streq	r4, [r6], r7
     a44:	40058740 	andmi	r8, r5, r0, asr #14
     a48:	89400488 	stmdbhi	r0, {r3, r7, sl}^
     a4c:	028a4003 	addeq	r4, sl, #3
     a50:	42018b40 	andmi	r8, r1, #64, 22	; 0x10000
     a54:	0000400e 	andeq	r4, r0, lr
     a58:	0000001c 	andeq	r0, r0, ip, lsl r0
     a5c:	000008e8 	andeq	r0, r0, r8, ror #17
     a60:	00000000 	andeq	r0, r0, r0
     a64:	00000026 	andeq	r0, r0, r6, lsr #32
     a68:	400c0e41 	andmi	r0, ip, r1, asr #28
     a6c:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     a70:	018e4002 	orreq	r4, lr, r2
     a74:	00300e41 	eorseq	r0, r0, r1, asr #28
     a78:	0000002c 	andeq	r0, r0, ip, lsr #32
     a7c:	000008e8 	andeq	r0, r0, r8, ror #17
     a80:	000028b4 			; <UNDEFINED> instruction: 0x000028b4
     a84:	00000634 	andeq	r0, r0, r4, lsr r6
     a88:	40200e42 	eormi	r0, r0, r2, asr #28
     a8c:	85400884 	strbhi	r0, [r0, #-2180]	; 0x884
     a90:	06864007 	streq	r4, [r6], r7
     a94:	40058740 	andmi	r8, r5, r0, asr #14
     a98:	89400488 	stmdbhi	r0, {r3, r7, sl}^
     a9c:	028a4003 	addeq	r4, sl, #3
     aa0:	42018b40 	andmi	r8, r1, #64, 22	; 0x10000
     aa4:	0001b00e 	andeq	fp, r1, lr
     aa8:	0000000c 	andeq	r0, r0, ip
     aac:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     ab0:	7c020001 	stcvc	0, cr0, [r2], {1}
     ab4:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     ab8:	00000014 	andeq	r0, r0, r4, lsl r0
     abc:	00000aa8 	andeq	r0, r0, r8, lsr #21
     ac0:	00000000 	andeq	r0, r0, r0
     ac4:	0000001e 	andeq	r0, r0, lr, lsl r0
     ac8:	40040e41 	andmi	r0, r4, r1, asr #28
     acc:	00000184 	andeq	r0, r0, r4, lsl #3
     ad0:	00000030 	andeq	r0, r0, r0, lsr r0
     ad4:	00000aa8 	andeq	r0, r0, r8, lsr #21
     ad8:	00002ee8 	andeq	r2, r0, r8, ror #29
     adc:	000001a0 	andeq	r0, r0, r0, lsr #3
     ae0:	40240e42 	eormi	r0, r4, r2, asr #28
     ae4:	85400984 	strbhi	r0, [r0, #-2436]	; 0x984
     ae8:	07864008 	streq	r4, [r6, r8]
     aec:	40068740 	andmi	r8, r6, r0, asr #14
     af0:	89400588 	stmdbhi	r0, {r3, r7, r8, sl}^
     af4:	038a4004 	orreq	r4, sl, #4
     af8:	40028b40 	andmi	r8, r2, r0, asr #22
     afc:	0e42018e 	dvfeqd	f0, f2, #0.5
     b00:	00000050 	andeq	r0, r0, r0, asr r0
     b04:	0000001c 	andeq	r0, r0, ip, lsl r0
     b08:	00000aa8 	andeq	r0, r0, r8, lsr #21
     b0c:	00000000 	andeq	r0, r0, r0
     b10:	0000002c 	andeq	r0, r0, ip, lsr #32
     b14:	400c0e41 	andmi	r0, ip, r1, asr #28
     b18:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
     b1c:	018e4002 	orreq	r4, lr, r2
     b20:	00300e41 	eorseq	r0, r0, r1, asr #28
     b24:	0000001c 	andeq	r0, r0, ip, lsl r0
     b28:	00000aa8 	andeq	r0, r0, r8, lsr #21
     b2c:	00000000 	andeq	r0, r0, r0
     b30:	0000009a 	muleq	r0, sl, r0
     b34:	40100e44 	andsmi	r0, r0, r4, asr #28
     b38:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     b3c:	02864003 	addeq	r4, r6, #3
     b40:	00018740 	andeq	r8, r1, r0, asr #14
     b44:	0000001c 	andeq	r0, r0, ip, lsl r0
     b48:	00000aa8 	andeq	r0, r0, r8, lsr #21
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	00000000 	andeq	r0, r0, r0
  b	LoopCopyDataInit
     b50:	000000c2 	andeq	r0, r0, r2, asr #1

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
     b54:	40100e41 	andsmi	r0, r0, r1, asr #28
	str	r3, [r0, r1]
	adds	r1, r1, #4
     b58:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
     b5c:	02864003 	addeq	r4, r6, #3
	adds	r2, r0, r1
	cmp	r2, r3
     b60:	00018740 	andeq	r8, r1, r0, asr #14
	bcc	CopyDataInit
     b64:	0000001c 	andeq	r0, r0, ip, lsl r0
	ldr	r2, =_sbss
	b	LoopFillZerobss
     b68:	00000aa8 	andeq	r0, r0, r8, lsr #21
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	00000000 	andeq	r0, r0, r0
	str	r3, [r2], #4
     b70:	00000058 	andeq	r0, r0, r8, asr r0

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
     b74:	400c0e41 	andmi	r0, ip, r1, asr #28
	bcc	FillZerobss
     b78:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
/* Call the application's entry point.*/
	bl	main
     b7c:	01864002 	orreq	r4, r6, r2
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	00300e42 	eorseq	r0, r0, r2, asr #28
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	0000001c 	andeq	r0, r0, ip, lsl r0
	ldr	r3, =_edata
     b88:	00000aa8 	andeq	r0, r0, r8, lsr #21
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	00000000 	andeq	r0, r0, r0
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	0000008e 	andeq	r0, r0, lr, lsl #1
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	400c0e41 	andmi	r0, ip, r1, asr #28
}


/* dummy proc */
void nothingProc(void)
{
     b98:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
{
    return;
}

void usbStatusOut(void)
{
     b9c:	01864002 	orreq	r4, r6, r2
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
     ba0:	00300e42 	eorseq	r0, r0, r2, asr #28
     ba4:	00000030 	andeq	r0, r0, r0, lsr r0
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	00000aa8 	andeq	r0, r0, r8, lsr #21
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	00000000 	andeq	r0, r0, r0
     bb0:	0000013e 	andeq	r0, r0, lr, lsr r1
        bDeviceState = CONFIGURED;
     bb4:	40240e42 	eormi	r0, r4, r2, asr #28
     bb8:	85400984 	strbhi	r0, [r0, #-2436]	; 0x984
     bbc:	07864008 	streq	r4, [r6, r8]
     bc0:	40068740 	andmi	r8, r6, r0, asr #14
    }
}

void usbGetInterface(void)
{
     bc4:	89400588 	stmdbhi	r0, {r3, r7, r8, sl}^
{
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	038a4004 	orreq	r4, sl, #4
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	40028b40 	andmi	r8, r2, r0, asr #22
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	0e42018e 	dvfeqd	f0, f2, #0.5
     bd4:	00000068 	andeq	r0, r0, r8, rrx
     bd8:	00000024 	andeq	r0, r0, r4, lsr #32
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	00000aa8 	andeq	r0, r0, r8, lsr #21
    dfuUpdateByReset();
     be0:	00000000 	andeq	r0, r0, r0

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	000000d2 	ldrdeq	r0, [r0], -r2

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be8:	40180e42 	andsmi	r0, r8, r2, asr #28
     bec:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	04864005 	streq	r4, [r6], #5
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	40038740 	andmi	r8, r3, r0, asr #14
     bf8:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfc:	580e4301 	stmdapl	lr, {r0, r8, r9, lr}
     c00:	0000000c 	andeq	r0, r0, ip
     c04:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     c08:	7c020001 	stcvc	0, cr0, [r2], {1}
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c0c:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     c10:	00000020 	andeq	r0, r0, r0, lsr #32
     c14:	00000c00 	andeq	r0, r0, r0, lsl #24
     c18:	00000000 	andeq	r0, r0, r0
     c1c:	00000040 	andeq	r0, r0, r0, asr #32

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c20:	40100e41 	andsmi	r0, r0, r1, asr #28
     c24:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
     c28:	02864003 	addeq	r4, r6, #3
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	42018e40 	andmi	r8, r1, #64, 28	; 0x400
     c30:	0000500e 	andeq	r5, r0, lr
     c34:	00000024 	andeq	r0, r0, r4, lsr #32
     c38:	00000c00 	andeq	r0, r0, r0, lsl #24
     c3c:	00000000 	andeq	r0, r0, r0

    Clear_Status_Out(ENDP0);
     c40:	000000d4 	ldrdeq	r0, [r0], -r4

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c44:	40180e42 	andsmi	r0, r8, r2, asr #28
     c48:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     c4c:	04864005 	streq	r4, [r6], #5
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	40038740 	andmi	r8, r3, r0, asr #14
     c54:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}

    bDeviceState = ATTACHED;
     c58:	780e4201 	stmdavc	lr, {r0, r9, lr}
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
     c5c:	0000000c 	andeq	r0, r0, ip

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c64:	7c020001 	stcvc	0, cr0, [r2], {1}
     c68:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     c6c:	00000020 	andeq	r0, r0, r0, lsr #32
     c70:	00000c5c 	andeq	r0, r0, ip, asr ip
     c74:	00003088 	andeq	r3, r0, r8, lsl #1
     c78:	00000058 	andeq	r0, r0, r8, asr r0
     c7c:	40140e42 	andsmi	r0, r4, r2, asr #28
     c80:	85400584 	strbhi	r0, [r0, #-1412]	; 0x584
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	03864004 	orreq	r4, r6, #4
     c88:	40028740 	andmi	r8, r2, r0, asr #14
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8c:	00000188 	andeq	r0, r0, r8, lsl #3
     c90:	0000002c 	andeq	r0, r0, ip, lsr #32
     c94:	00000c5c 	andeq	r0, r0, ip, asr ip
        if (dfuUpdateByRequest()) {
     c98:	000030e0 	andeq	r3, r0, r0, ror #1
     c9c:	00001f64 	andeq	r1, r0, r4, ror #30
            // successfull state transition, handle the request
            switch (request) {
     ca0:	40200e42 	eormi	r0, r0, r2, asr #28
     ca4:	85400884 	strbhi	r0, [r0, #-2180]	; 0x884
     ca8:	06864007 	streq	r4, [r6], r7
     cac:	40058740 	andmi	r8, r5, r0, asr #14
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	89400488 	stmdbhi	r0, {r3, r7, sl}^
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
     cb4:	028a4003 	addeq	r4, sl, #3
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
     cb8:	41018b40 	tstmi	r1, r0, asr #22
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	0001900e 	andeq	r9, r1, lr
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
     cc0:	00000024 	andeq	r0, r0, r4, lsr #32
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	00000c5c 	andeq	r0, r0, ip, asr ip
        (*CopyRoutine)(0);

        return USB_SUCCESS;
     cc8:	00005044 	andeq	r5, r0, r4, asr #32
    }

    return USB_UNSUPPORT;
     ccc:	0000008e 	andeq	r0, r0, lr, lsl #1
}
     cd0:	40180e42 	andsmi	r0, r8, r2, asr #28
     cd4:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     cd8:	04864005 	streq	r4, [r6], #5
     cdc:	40038740 	andmi	r8, r3, r0, asr #14
     ce0:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	00000001 	andeq	r0, r0, r1
     ce8:	00000030 	andeq	r0, r0, r0, lsr r0
     cec:	00000c5c 	andeq	r0, r0, ip, asr ip
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	000050d4 	ldrdeq	r5, [r0], -r4
     cf4:	00000218 	andeq	r0, r0, r8, lsl r2
     cf8:	40240e42 	eormi	r0, r4, r2, asr #28
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	85400984 	strbhi	r0, [r0, #-2436]	; 0x984
     d00:	07864008 	streq	r4, [r6, r8]
    if (strIndex > STR_DESC_LEN) {
     d04:	40068740 	andmi	r8, r6, r0, asr #14
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d08:	89400588 	stmdbhi	r0, {r3, r7, r8, sl}^
     d0c:	038a4004 	orreq	r4, sl, #4
    }
}
     d10:	40028b40 	andmi	r8, r2, r0, asr #22
     d14:	0e46018e 	dvfeqd	f0, f6, #0.5
     d18:	00000030 	andeq	r0, r0, r0, lsr r0

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
     d1c:	0000000c 	andeq	r0, r0, ip
     d20:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     d24:	7c020001 	stcvc	0, cr0, [r2], {1}

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2c:	0000002c 	andeq	r0, r0, ip, lsr #32
     d30:	00000d1c 	andeq	r0, r0, ip, lsl sp
     d34:	000052ec 	andeq	r5, r0, ip, ror #5
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	00000494 	muleq	r0, r4, r4
     d3c:	40200e42 	eormi	r0, r0, r2, asr #28
            return USB_SUCCESS;
     d40:	85400884 	strbhi	r0, [r0, #-2180]	; 0x884
     d44:	06864007 	streq	r4, [r6], r7
        }
    }
    return USB_UNSUPPORT;
}
     d48:	40058740 	andmi	r8, r5, r0, asr #14
     d4c:	89400488 	stmdbhi	r0, {r3, r7, sl}^

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	028a4003 	addeq	r4, sl, #3
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d54:	41018b40 	tstmi	r1, r0, asr #22
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	0003b00e 	andeq	fp, r3, lr
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5c:	0000002c 	andeq	r0, r0, ip, lsr #32
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d60:	00000d1c 	andeq	r0, r0, ip, lsl sp
     d64:	00005780 	andeq	r5, r0, r0, lsl #15
     d68:	00000088 	andeq	r0, r0, r8, lsl #1
     d6c:	40200e42 	eormi	r0, r0, r2, asr #28
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d70:	85400884 	strbhi	r0, [r0, #-2180]	; 0x884
     d74:	06864007 	streq	r4, [r6], r7
     d78:	40058740 	andmi	r8, r5, r0, asr #14
     d7c:	89400488 	stmdbhi	r0, {r3, r7, sl}^
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d80:	028a4003 	addeq	r4, sl, #3
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	42018e40 	andmi	r8, r1, #64, 28	; 0x400
     d88:	0001a00e 	andeq	sl, r1, lr
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8c:	00000030 	andeq	r0, r0, r0, lsr r0
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d90:	00000d1c 	andeq	r0, r0, ip, lsl sp
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d94:	00005808 	andeq	r5, r0, r8, lsl #16
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d98:	00000296 	muleq	r0, r6, r2

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	40240e42 	eormi	r0, r4, r2, asr #28
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	85400984 	strbhi	r0, [r0, #-2436]	; 0x984
     da4:	07864008 	streq	r4, [r6, r8]
     da8:	40068740 	andmi	r8, r6, r0, asr #14
     dac:	89400588 	stmdbhi	r0, {r3, r7, r8, sl}^
     db0:	038a4004 	orreq	r4, sl, #4
     db4:	40028b40 	andmi	r8, r2, r0, asr #22
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	0e42018e 	dvfeqd	f0, f2, #0.5
     dbc:	00000190 	muleq	r0, r0, r1
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dc0:	0000000c 	andeq	r0, r0, ip

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     dc8:	7c020001 	stcvc	0, cr0, [r2], {1}
     dcc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
     dd0:	00000018 	andeq	r0, r0, r8, lsl r0
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	00000dc0 	andeq	r0, r0, r0, asr #27
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd8:	00005aa0 	andeq	r5, r0, r0, lsr #21
     ddc:	00000044 	andeq	r0, r0, r4, asr #32

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	40080e41 	andmi	r0, r8, r1, asr #28
     de4:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
     de8:	00000001 	andeq	r0, r0, r1
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	00000028 	andeq	r0, r0, r8, lsr #32
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	00000dc0 	andeq	r0, r0, r0, asr #27
        ResumeS.eState = eResumeSetVal;
     df4:	00005ae4 	andeq	r5, r0, r4, ror #21

    switch (ResumeS.eState) {
     df8:	00000158 	andeq	r0, r0, r8, asr r1
     dfc:	40180e42 	andsmi	r0, r8, r2, asr #28
     e00:	85400684 	strbhi	r0, [r0, #-1668]	; 0x684
     e04:	04864005 	streq	r4, [r6], #5
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	40038740 	andmi	r8, r3, r0, asr #14
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	8e400288 	cdphi	2, 4, cr0, cr0, cr8, {4}
        ResumeS.eState = RESUME_START;
     e10:	e80e4101 	stmda	lr, {r0, r8, lr}
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	00000002 	andeq	r0, r0, r2
        ResumeS.eState = RESUME_WAIT;
     e18:	0000000c 	andeq	r0, r0, ip
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
     e20:	7c020001 	stcvc	0, cr0, [r2], {1}
        if (ResumeS.bESOFcnt == 0)
     e24:	000d0c0e 	andeq	r0, sp, lr, lsl #24
            ResumeS.eState = RESUME_START;
     e28:	0000000c 	andeq	r0, r0, ip
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	00000e18 	andeq	r0, r0, r8, lsl lr
     e30:	00000000 	andeq	r0, r0, r0
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e34:	0000000c 	andeq	r0, r0, ip
        ResumeS.eState = RESUME_ON;
     e38:	0000000c 	andeq	r0, r0, ip
        ResumeS.bESOFcnt = 10;
     e3c:	00000e18 	andeq	r0, r0, r8, lsl lr
        break;
     e40:	00000000 	andeq	r0, r0, r0
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e44:	0000000c 	andeq	r0, r0, ip
     e48:	0000000c 	andeq	r0, r0, ip
        if (ResumeS.bESOFcnt == 0) {
     e4c:	00000e18 	andeq	r0, r0, r8, lsl lr
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	00000000 	andeq	r0, r0, r0
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	0000000c 	andeq	r0, r0, ip
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e58:	0000000c 	andeq	r0, r0, ip
            ResumeS.eState = RESUME_OFF;
     e5c:	00000e18 	andeq	r0, r0, r8, lsl lr
     e60:	00000000 	andeq	r0, r0, r0
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e64:	0000000c 	andeq	r0, r0, ip
     e68:	0000000c 	andeq	r0, r0, ip
     e6c:	00000e18 	andeq	r0, r0, r8, lsl lr
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	00000000 	andeq	r0, r0, r0
     e74:	0000000c 	andeq	r0, r0, ip
     e78:	0000000c 	andeq	r0, r0, ip
     e7c:	00000e18 	andeq	r0, r0, r8, lsl lr

    _SetCNTR(CNTR_FRES);
     e80:	00000000 	andeq	r0, r0, r0
     e84:	0000000c 	andeq	r0, r0, ip
     e88:	0000000c 	andeq	r0, r0, ip
     e8c:	00000e18 	andeq	r0, r0, r8, lsl lr
    _SetCNTR(0);
    _SetISTR(0);
     e90:	00000000 	andeq	r0, r0, r0

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e94:	0000000c 	andeq	r0, r0, ip
    _SetCNTR(wInterrupt_Mask);
     e98:	0000000c 	andeq	r0, r0, ip
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9c:	00000e18 	andeq	r0, r0, r8, lsl lr
     ea0:	00000000 	andeq	r0, r0, r0
#endif
#endif

    return USB_SUCCESS;
}
     ea4:	00000010 	andeq	r0, r0, r0, lsl r0
     ea8:	0000000c 	andeq	r0, r0, ip
     eac:	00000e18 	andeq	r0, r0, r8, lsl lr
     eb0:	00000000 	andeq	r0, r0, r0
     eb4:	0000000c 	andeq	r0, r0, ip

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	0000000c 	andeq	r0, r0, ip
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	00000e18 	andeq	r0, r0, r8, lsl lr
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
     ec0:	00000000 	andeq	r0, r0, r0
     ec4:	0000000e 	andeq	r0, r0, lr
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec8:	0000000c 	andeq	r0, r0, ip
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     ecc:	00000e18 	andeq	r0, r0, r8, lsl lr
     ed0:	00000000 	andeq	r0, r0, r0
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	00000010 	andeq	r0, r0, r0, lsl r0
     ed8:	0000000c 	andeq	r0, r0, ip
     edc:	00000e18 	andeq	r0, r0, r8, lsl lr

    return USB_SUCCESS;
}
     ee0:	00000000 	andeq	r0, r0, r0
     ee4:	0000001c 	andeq	r0, r0, ip, lsl r0
     ee8:	0000000c 	andeq	r0, r0, ip
     eec:	00000e18 	andeq	r0, r0, r8, lsl lr
     ef0:	00000000 	andeq	r0, r0, r0
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	00000012 	andeq	r0, r0, r2, lsl r0
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	0000000c 	andeq	r0, r0, ip
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efc:	00000e18 	andeq	r0, r0, r8, lsl lr
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	00005c3c 	andeq	r5, r0, ip, lsr ip
     f04:	0000002a 	andeq	r0, r0, sl, lsr #32
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f08:	0000000c 	andeq	r0, r0, ip
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	00000e18 	andeq	r0, r0, r8, lsl lr
     f10:	00000000 	andeq	r0, r0, r0
    nvicInit(&NVIC_InitStructure);
     f14:	0000002a 	andeq	r0, r0, sl, lsr #32
}
     f18:	0000000c 	andeq	r0, r0, ip

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	00000e18 	andeq	r0, r0, r8, lsl lr
    dfuInit();
     f20:	00000000 	andeq	r0, r0, r0

    pInformation->Current_Configuration = 0;
     f24:	00000024 	andeq	r0, r0, r4, lsr #32
     f28:	0000000c 	andeq	r0, r0, ip
    usbPowerOn();
     f2c:	00000e18 	andeq	r0, r0, r8, lsl lr

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
     f30:	00000000 	andeq	r0, r0, r0
     f34:	00000012 	andeq	r0, r0, r2, lsl r0
     f38:	0000000c 	andeq	r0, r0, ip
    _SetCNTR(wInterrupt_Mask);
     f3c:	00000e18 	andeq	r0, r0, r8, lsl lr

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f40:	00000000 	andeq	r0, r0, r0
    bDeviceState = UNCONNECTED;
     f44:	00000012 	andeq	r0, r0, r2, lsl r0
     f48:	0000000c 	andeq	r0, r0, ip
     f4c:	00000e18 	andeq	r0, r0, r8, lsl lr
     f50:	00000000 	andeq	r0, r0, r0
     f54:	0000001e 	andeq	r0, r0, lr, lsl r0
     f58:	0000000c 	andeq	r0, r0, ip
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	00000e18 	andeq	r0, r0, r8, lsl lr
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f60:	00005c66 	andeq	r5, r0, r6, ror #24
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	0000001e 	andeq	r0, r0, lr, lsl r0

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f68:	0000000c 	andeq	r0, r0, ip
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	00000e18 	andeq	r0, r0, r8, lsl lr
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	00000000 	andeq	r0, r0, r0
    nvicInit(&NVIC_InitStructure);
     f74:	0000001e 	andeq	r0, r0, lr, lsl r0
}
     f78:	0000000c 	andeq	r0, r0, ip
     f7c:	00000e18 	andeq	r0, r0, r8, lsl lr

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	00000000 	andeq	r0, r0, r0
    wIstr = _GetISTR();
     f84:	0000001c 	andeq	r0, r0, ip, lsl r0

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	0000000c 	andeq	r0, r0, ip
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8c:	00000e18 	andeq	r0, r0, r8, lsl lr

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f90:	00005c84 	andeq	r5, r0, r4, lsl #25
     f94:	0000001c 	andeq	r0, r0, ip, lsl r0
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	0000000c 	andeq	r0, r0, ip
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	00000e18 	andeq	r0, r0, r8, lsl lr
     fa0:	00000000 	andeq	r0, r0, r0
     fa4:	0000001e 	andeq	r0, r0, lr, lsl r0
        _SetISTR((u16)CLR_RESET);
     fa8:	0000000c 	andeq	r0, r0, ip
        Device_Property.Reset();
     fac:	00000e18 	andeq	r0, r0, r8, lsl lr
     fb0:	00000000 	andeq	r0, r0, r0
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb4:	0000001e 	andeq	r0, r0, lr, lsl r0
     fb8:	0000000c 	andeq	r0, r0, ip
        _SetISTR((u16)CLR_ERR);
     fbc:	00000e18 	andeq	r0, r0, r8, lsl lr
     fc0:	00000000 	andeq	r0, r0, r0
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc4:	0000001c 	andeq	r0, r0, ip, lsl r0
     fc8:	0000000c 	andeq	r0, r0, ip
        _SetISTR((u16)CLR_WKUP);
     fcc:	00000e18 	andeq	r0, r0, r8, lsl lr
        usbResume(RESUME_EXTERNAL);
     fd0:	00000000 	andeq	r0, r0, r0
     fd4:	0000001a 	andeq	r0, r0, sl, lsl r0
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd8:	0000000c 	andeq	r0, r0, ip
     fdc:	00000e18 	andeq	r0, r0, r8, lsl lr

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	00000000 	andeq	r0, r0, r0
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	0000001a 	andeq	r0, r0, sl, lsl r0
     fe8:	0000000c 	andeq	r0, r0, ip
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fec:	00000e18 	andeq	r0, r0, r8, lsl lr
     ff0:	00000000 	andeq	r0, r0, r0
        _SetISTR((u16)CLR_SOF);
     ff4:	00000018 	andeq	r0, r0, r8, lsl r0
     ff8:	0000000c 	andeq	r0, r0, ip
        bIntPackSOF++;
     ffc:	00000e18 	andeq	r0, r0, r8, lsl lr
    1000:	00000000 	andeq	r0, r0, r0
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	0000001c 	andeq	r0, r0, ip, lsl r0
    1008:	0000000c 	andeq	r0, r0, ip
        _SetISTR((u16)CLR_ESOF);
    100c:	00000e18 	andeq	r0, r0, r8, lsl lr
    1010:	00000000 	andeq	r0, r0, r0
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    }
#endif

}
    1014:	00000020 	andeq	r0, r0, r0, lsr #32
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	0000000c 	andeq	r0, r0, ip
    101c:	00000e18 	andeq	r0, r0, r8, lsl lr
    1020:	00000000 	andeq	r0, r0, r0
    1024:	00000020 	andeq	r0, r0, r0, lsr #32
    1028:	0000000c 	andeq	r0, r0, ip
    102c:	00000e18 	andeq	r0, r0, r8, lsl lr
    1030:	00005ca0 	andeq	r5, r0, r0, lsr #25
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
    1034:	00000020 	andeq	r0, r0, r0, lsr #32
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    1038:	0000000c 	andeq	r0, r0, ip
    setupCLK();
    103c:	00000e18 	andeq	r0, r0, r8, lsl lr
    setupLEDAndButton();
    1040:	00005cc0 	andeq	r5, r0, r0, asr #25
    setupUSB();
    1044:	00000020 	andeq	r0, r0, r0, lsr #32
    setupFLASH();
    1048:	0000000c 	andeq	r0, r0, ip
    uartInit();
    104c:	00000e18 	andeq	r0, r0, r8, lsl lr
    usbReset();
    1050:	00000000 	andeq	r0, r0, r0
	uart_printf("\nBootloader init...\n");
    1054:	0000001e 	andeq	r0, r0, lr, lsl r0
    1058:	0000000c 	andeq	r0, r0, ip

    if (readPin(GPIOB, 15) == 0x0)
    105c:	00000e18 	andeq	r0, r0, r8, lsl lr
    1060:	00000000 	andeq	r0, r0, r0
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1064:	00000012 	andeq	r0, r0, r2, lsl r0
    1068:	0000000c 	andeq	r0, r0, ip
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    106c:	00000e18 	andeq	r0, r0, r8, lsl lr
    1070:	00000000 	andeq	r0, r0, r0
    1074:	00000020 	andeq	r0, r0, r0, lsr #32
    
    debug_print("image check ret: %X\n", ret);
    1078:	0000000c 	andeq	r0, r0, ip
    107c:	00000e18 	andeq	r0, r0, r8, lsl lr
	switch (ret)
    1080:	00000000 	andeq	r0, r0, r0
    1084:	00000020 	andeq	r0, r0, r0, lsr #32
    1088:	0000000c 	andeq	r0, r0, ip

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
	bool no_user_jump = FALSE;
    108c:	00000e18 	andeq	r0, r0, r8, lsl lr
    1090:	00005ce0 	andeq	r5, r0, r0, ror #25
    1094:	0000001c 	andeq	r0, r0, ip, lsl r0
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1098:	0000000c 	andeq	r0, r0, ip
			no_user_jump = FALSE;
    109c:	00000e18 	andeq	r0, r0, r8, lsl lr
			break;

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    10a0:	00005cfc 	strdeq	r5, [r0], -ip
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    10a4:	0000001c 	andeq	r0, r0, ip, lsl r0
			no_user_jump = TRUE;
			break;

		case kImageImageHashCalcFailed:
			uart_printf("Hash calculation failed... waiting in DFU\n");
    10a8:	0000000c 	andeq	r0, r0, ip
    10ac:	00000e18 	andeq	r0, r0, r8, lsl lr
			break;
			
		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10b0:	00005d18 	andeq	r5, r0, r8, lsl sp
    10b4:	0000001c 	andeq	r0, r0, ip, lsl r0
    10b8:	0000000c 	andeq	r0, r0, ip
    10bc:	00000e18 	andeq	r0, r0, r8, lsl lr
    10c0:	00000000 	andeq	r0, r0, r0

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10c4:	00000026 	andeq	r0, r0, r6, lsr #32
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10c8:	0000000c 	andeq	r0, r0, ip
    10cc:	00000e18 	andeq	r0, r0, r8, lsl lr
    10d0:	00005d34 	andeq	r5, r0, r4, lsr sp
    10d4:	00000040 	andeq	r0, r0, r0, asr #32
    10d8:	0000000c 	andeq	r0, r0, ip

		if (dfuUploadStarted()) 
    10dc:	00000e18 	andeq	r0, r0, r8, lsl lr
		{
			uart_printf("DFU finished upload\n");
    10e0:	00000000 	andeq	r0, r0, r0
    10e4:	00000020 	andeq	r0, r0, r0, lsr #32
			dfuFinishUpload(); // systemHardReset from DFU once done
    10e8:	0000000c 	andeq	r0, r0, ip
    10ec:	00000e18 	andeq	r0, r0, r8, lsl lr
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10f0:	00000000 	andeq	r0, r0, r0
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10f4:	00000020 	andeq	r0, r0, r0, lsr #32
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10f8:	00000018 	andeq	r0, r0, r8, lsl r0
    10fc:	00000e18 	andeq	r0, r0, r8, lsl lr
	}
	
	return 0;// Added to please the compiler
    1100:	00000000 	andeq	r0, r0, r0
    1104:	00000038 	andeq	r0, r0, r8, lsr r0
    1108:	40080e41 	andmi	r0, r8, r1, asr #28
    110c:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
    1110:	00000001 	andeq	r0, r0, r1
    1114:	0000000c 	andeq	r0, r0, ip
    1118:	00000e18 	andeq	r0, r0, r8, lsl lr
    111c:	00000000 	andeq	r0, r0, r0
    1120:	00000020 	andeq	r0, r0, r0, lsr #32
    1124:	0000000c 	andeq	r0, r0, ip
    1128:	00000e18 	andeq	r0, r0, r8, lsl lr
    112c:	00000000 	andeq	r0, r0, r0
    1130:	00000020 	andeq	r0, r0, r0, lsr #32
    1134:	0000000c 	andeq	r0, r0, ip
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1138:	00000e18 	andeq	r0, r0, r8, lsl lr
    113c:	00000000 	andeq	r0, r0, r0
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    1140:	0000001c 	andeq	r0, r0, ip, lsl r0
    1144:	0000000c 	andeq	r0, r0, ip
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1148:	00000e18 	andeq	r0, r0, r8, lsl lr
    114c:	00000000 	andeq	r0, r0, r0
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    1150:	0000001c 	andeq	r0, r0, ip, lsl r0
    1154:	00000018 	andeq	r0, r0, r8, lsl r0
        return TRUE;
    } else {
        return FALSE;
    }
}
    1158:	00000e18 	andeq	r0, r0, r8, lsl lr
    115c:	00000000 	andeq	r0, r0, r0

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	000000a8 	andeq	r0, r0, r8, lsr #1
    1164:	40080e42 	andmi	r0, r8, r2, asr #28
    1168:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
    gpio_write_bit( bank,pin,1-onState);
    116c:	00000001 	andeq	r0, r0, r1
    1170:	0000000c 	andeq	r0, r0, ip
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1174:	00000e18 	andeq	r0, r0, r8, lsl lr
    gpio_write_bit( bank,pin,1-onState);
    1178:	00000000 	andeq	r0, r0, r0

    u32 c;
    while (count-- > 0) 
    117c:	0000005c 	andeq	r0, r0, ip, asr r0
	{
        for (c = rate; c > 0; c--)
    1180:	0000000c 	andeq	r0, r0, ip
    1184:	00000e18 	andeq	r0, r0, r8, lsl lr
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1188:	00000000 	andeq	r0, r0, r0
    118c:	0000005c 	andeq	r0, r0, ip, asr r0
    1190:	0000000c 	andeq	r0, r0, ip
		
        for (c = rate; c > 0; c--)
    1194:	00000e18 	andeq	r0, r0, r8, lsl lr
    1198:	00000000 	andeq	r0, r0, r0
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    119c:	00000020 	andeq	r0, r0, r0, lsr #32
    11a0:	0000000c 	andeq	r0, r0, ip
    11a4:	00000e18 	andeq	r0, r0, r8, lsl lr
    11a8:	00000000 	andeq	r0, r0, r0
    11ac:	00000020 	andeq	r0, r0, r0, lsr #32

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    11b0:	0000000c 	andeq	r0, r0, ip
    11b4:	00000e18 	andeq	r0, r0, r8, lsl lr
  USARTx->DR = ch;  
    11b8:	00000000 	andeq	r0, r0, r0
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11bc:	00000044 	andeq	r0, r0, r4, asr #32
  while(*str != 0)
    11c0:	0000000c 	andeq	r0, r0, ip
    11c4:	00000e18 	andeq	r0, r0, r8, lsl lr
  {
    UU_PutChar(USARTx, *str);
    11c8:	00000000 	andeq	r0, r0, r0
    11cc:	0000003a 	andeq	r0, r0, sl, lsr r0
    str++;
  }
}

void vprint(const char *fmt, va_list argp)
{
    11d0:	0000000c 	andeq	r0, r0, ip
    11d4:	00000e18 	andeq	r0, r0, r8, lsl lr
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11d8:	00000000 	andeq	r0, r0, r0
    11dc:	00000006 	andeq	r0, r0, r6
    11e0:	0000000c 	andeq	r0, r0, ip
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11e4:	00000e18 	andeq	r0, r0, r8, lsl lr
    11e8:	00000000 	andeq	r0, r0, r0

    }
}
    11ec:	0000000a 	andeq	r0, r0, sl
    11f0:	0000000c 	andeq	r0, r0, ip
    11f4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11f8:	7c020001 	stcvc	0, cr0, [r2], {1}
    11fc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    1200:	0000001c 	andeq	r0, r0, ip, lsl r0
    va_list argp;
    va_start(argp, fmt);
    vprint(fmt, argp);
    1204:	000011f0 	strdeq	r1, [r0], -r0
    va_end(argp);
}
    1208:	00005d74 	andeq	r5, r0, r4, ror sp
    120c:	00000154 	andeq	r0, r0, r4, asr r1
    1210:	40100e41 	andsmi	r0, r0, r1, asr #28

void hexdump(unsigned char *data, size_t size)
{
    1214:	85400484 	strbhi	r0, [r0, #-1156]	; 0x484
    1218:	02864003 	addeq	r4, r6, #3
    int i;
    char cs[17];
    memset(cs, 0, 17);
    121c:	00018e40 	andeq	r8, r1, r0, asr #28
    1220:	00000018 	andeq	r0, r0, r8, lsl r0
    1224:	000011f0 	strdeq	r1, [r0], -r0

    for(i = 0; i < size; i++)
    1228:	00000000 	andeq	r0, r0, r0
    122c:	00000070 	andeq	r0, r0, r0, ror r0
    {
        if(i != 0 && i % 0x10 == 0)
    1230:	40080e41 	andmi	r0, r8, r1, asr #28
        {
            debug_print(" |%s|\n", cs);
    1234:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
    1238:	00000001 	andeq	r0, r0, r1
            memset(cs, 0, 17);
    123c:	0000000c 	andeq	r0, r0, ip
    1240:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    1244:	7c020001 	stcvc	0, cr0, [r2], {1}
        }
        else if(i != 0 && i % 0x8 == 0)
    1248:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    124c:	00000018 	andeq	r0, r0, r8, lsl r0
        {
            debug_print(" ",0);
    1250:	0000123c 	andeq	r1, r0, ip, lsr r2
        }
        debug_print("%02X ", data[i]);
    1254:	00005ec8 	andeq	r5, r0, r8, asr #29
    1258:	00000038 	andeq	r0, r0, r8, lsr r0
        cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
    125c:	40080e41 	andmi	r0, r8, r1, asr #28
    1260:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
    1264:	00000001 	andeq	r0, r0, r1
    1268:	0000000c 	andeq	r0, r0, ip
    126c:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    1270:	7c020001 	stcvc	0, cr0, [r2], {1}
    }

    i = i % 0x10;
    if(i != 0)
    1274:	000d0c0e 	andeq	r0, sp, lr, lsl #24
        while(i++ < 0x10)
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
    1278:	00000018 	andeq	r0, r0, r8, lsl r0
    127c:	00001268 	andeq	r1, r0, r8, ror #4
}
    1280:	00005f00 	andeq	r5, r0, r0, lsl #30
    }

    i = i % 0x10;
    if(i != 0)
    {
        if(i <= 0x8)
    1284:	00000024 	andeq	r0, r0, r4, lsr #32
        {
            debug_print(" ",0);
    1288:	40080e41 	andmi	r0, r8, r1, asr #28
    128c:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
        }
        while(i++ < 0x10)
    1290:	00000001 	andeq	r0, r0, r1
        {
            debug_print("   ",0);
    1294:	00000018 	andeq	r0, r0, r8, lsl r0
    1298:	00001268 	andeq	r1, r0, r8, ror #4
    129c:	00005f24 	andeq	r5, r0, r4, lsr #30
    12a0:	00000024 	andeq	r0, r0, r4, lsr #32
    12a4:	40080e41 	andmi	r0, r8, r1, asr #28
    12a8:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
    12ac:	00000001 	andeq	r0, r0, r1
    }
    debug_print(" |%s|\n", cs);
}

void print_hash(unsigned char hash[])
{
    12b0:	00000018 	andeq	r0, r0, r8, lsl r0
   int idx;
   for (idx=0; idx < 32; idx++)
    12b4:	00001268 	andeq	r1, r0, r8, ror #4
      debug_print("%02x",hash[idx]);
    12b8:	00005f48 	andeq	r5, r0, r8, asr #30
    12bc:	00000090 	muleq	r0, r0, r0
}

void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
    12c0:	40080e41 	andmi	r0, r8, r1, asr #28
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12c4:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
}
    12c8:	00000001 	andeq	r0, r0, r1
void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12cc:	00000028 	andeq	r0, r0, r8, lsr #32
    12d0:	00001268 	andeq	r1, r0, r8, ror #4
    12d4:	00005fd8 	ldrdeq	r5, [r0], -r8
}

#endif
void uartInit(void) {
    12d8:	000000a8 	andeq	r0, r0, r8, lsr #1
    12dc:	40200e43 	eormi	r0, r0, r3, asr #28
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    12e0:	84400883 	strbhi	r0, [r0], #-2179	; 0x883
    12e4:	06854007 	streq	r4, [r5], r7
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    12e8:	40058640 	andmi	r8, r5, r0, asr #12
    12ec:	88400487 	stmdahi	r0, {r0, r1, r2, r7, sl}^
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    12f0:	02894003 	addeq	r4, r9, #3
    12f4:	00018e40 	andeq	r8, r1, r0, asr #28
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    12f8:	00000018 	andeq	r0, r0, r8, lsl r0
    12fc:	00001268 	andeq	r1, r0, r8, ror #4
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1300:	00006080 	andeq	r6, r0, r0, lsl #1
    1304:	00000038 	andeq	r0, r0, r8, lsr r0
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1308:	40080e41 	andmi	r0, r8, r1, asr #28
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    130c:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
    1310:	00000001 	andeq	r0, r0, r1
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1314:	0000001c 	andeq	r0, r0, ip, lsl r0
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1318:	00001268 	andeq	r1, r0, r8, ror #4
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    131c:	000060b8 	strheq	r6, [r0], -r8
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1320:	00000048 	andeq	r0, r0, r8, asr #32
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1324:	40100e41 	andsmi	r0, r0, r1, asr #28
    1328:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    132c:	02854003 	addeq	r4, r5, #3
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    1330:	00018e40 	andeq	r8, r1, r0, asr #28
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1334:	0000001c 	andeq	r0, r0, ip, lsl r0
    USART_InitStructure.USART_Parity = USART_Parity_No;
    1338:	00001268 	andeq	r1, r0, r8, ror #4
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    133c:	00006100 	andeq	r6, r0, r0, lsl #2
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1340:	000000d0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
    1344:	40100e41 	andsmi	r0, r0, r1, asr #28
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    1348:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
        
    USART_Init(USART1, &USART_InitStructure);
    134c:	02854003 	addeq	r4, r5, #3
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    1350:	00018e40 	andeq	r8, r1, r0, asr #28
    1354:	0000001c 	andeq	r0, r0, ip, lsl r0
}
    1358:	00001268 	andeq	r1, r0, r8, ror #4
    135c:	000061d0 	ldrdeq	r6, [r0], -r0

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    1360:	00000084 	andeq	r0, r0, r4, lsl #1
    1364:	40100e41 	andsmi	r0, r0, r1, asr #28
    1368:	84400483 	strbhi	r0, [r0], #-1155	; 0x483
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    136c:	02854003 	addeq	r4, r5, #3
    1370:	00018e40 	andeq	r8, r1, r0, asr #28
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    1374:	00000018 	andeq	r0, r0, r8, lsl r0
    1378:	00001268 	andeq	r1, r0, r8, ror #4
    137c:	00006254 	andeq	r6, r0, r4, asr r2
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    1380:	00000024 	andeq	r0, r0, r4, lsr #32
    1384:	40080e41 	andmi	r0, r8, r1, asr #28
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    1388:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
    138c:	00000001 	andeq	r0, r0, r1

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    1390:	0000000c 	andeq	r0, r0, ip
    1394:	00001268 	andeq	r1, r0, r8, ror #4
    1398:	00006278 	andeq	r6, r0, r8, ror r2
    139c:	0000001c 	andeq	r0, r0, ip, lsl r0
    13a0:	00000018 	andeq	r0, r0, r8, lsl r0
    13a4:	00001268 	andeq	r1, r0, r8, ror #4
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    13a8:	00006294 	muleq	r0, r4, r2
    13ac:	00000040 	andeq	r0, r0, r0, asr #32
    13b0:	40080e41 	andmi	r0, r8, r1, asr #28
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    13b4:	8e400283 	cdphi	2, 4, cr0, cr0, cr3, {4}
    13b8:	00000001 	andeq	r0, r0, r1

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    13bc:	00000024 	andeq	r0, r0, r4, lsr #32
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    13c0:	00001268 	andeq	r1, r0, r8, ror #4
    13c4:	000062d4 	ldrdeq	r6, [r0], -r4
    13c8:	000002dc 	ldrdeq	r0, [r0], -ip
    13cc:	40180e41 	andsmi	r0, r8, r1, asr #28
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    13d0:	81400680 	smlalbbhi	r0, r0, r0, r6	; <UNPREDICTABLE>
    13d4:	04844005 	streq	r4, [r4], #5

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    13d8:	40038540 	andmi	r8, r3, r0, asr #10
    13dc:	8e400286 	cdphi	2, 4, cr0, cr0, cr6, {4}
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    13e0:	00000001 	andeq	r0, r0, r1
    13e4:	00000024 	andeq	r0, r0, r4, lsr #32
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    13e8:	00001268 	andeq	r1, r0, r8, ror #4
    13ec:	000065b0 			; <UNDEFINED> instruction: 0x000065b0
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    13f0:	000000c8 	andeq	r0, r0, r8, asr #1
    13f4:	40180e41 	andsmi	r0, r8, r1, asr #28
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    13f8:	84400683 	strbhi	r0, [r0], #-1667	; 0x683
    13fc:	04854005 	streq	r4, [r5], #5
    1400:	40038640 	andmi	r8, r3, r0, asr #12
    1404:	8e400287 	cdphi	2, 4, cr0, cr0, cr7, {4}

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    1408:	00000001 	andeq	r0, r0, r1
    140c:	00000018 	andeq	r0, r0, r8, lsl r0
    1410:	00001268 	andeq	r1, r0, r8, ror #4
    1414:	00006678 	andeq	r6, r0, r8, ror r6
    1418:	00000038 	andeq	r0, r0, r8, lsr r0
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    141c:	400c0e41 	andmi	r0, ip, r1, asr #28
    1420:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
        u32 rwmVal = pRCC->CR;
    1424:	018e4002 	orreq	r4, lr, r2
        rwmVal |= 0x01;
    1428:	00000018 	andeq	r0, r0, r8, lsl r0
        pRCC->CR = rwmVal;
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    142c:	00001268 	andeq	r1, r0, r8, ror #4
    1430:	000066b0 			; <UNDEFINED> instruction: 0x000066b0
}   
    1434:	0000005c 	andeq	r0, r0, ip, asr r0
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    1438:	40080e41 	andmi	r0, r8, r1, asr #28
void setMspAndJump(u32 usrAddr) {
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    143c:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1440:	00000001 	andeq	r0, r0, r1

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1444:	0000000c 	andeq	r0, r0, ip
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    1448:	00001268 	andeq	r1, r0, r8, ror #4
    144c:	00000000 	andeq	r0, r0, r0
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    1450:	00000002 	andeq	r0, r0, r2
    1454:	0000000c 	andeq	r0, r0, ip
    1458:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    145c:	7c020001 	stcvc	0, cr0, [r2], {1}
    tmppre = (0x4 - tmppriority);
    1460:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    1464:	00000018 	andeq	r0, r0, r8, lsl r0


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    1468:	00001454 	andeq	r1, r0, r4, asr r4

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    146c:	0000670c 	andeq	r6, r0, ip, lsl #14
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    1470:	00000030 	andeq	r0, r0, r0, lsr r0

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1474:	400c0e41 	andmi	r0, ip, r1, asr #28
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    1478:	85400384 	strbhi	r0, [r0, #-900]	; 0x384
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    147c:	018e4002 	orreq	r4, lr, r2

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1480:	00000018 	andeq	r0, r0, r8, lsl r0
    1484:	00001454 	andeq	r1, r0, r4, asr r4
    1488:	0000673c 	andeq	r6, r0, ip, lsr r7
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    148c:	00000024 	andeq	r0, r0, r4, lsr #32
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    1490:	40080e41 	andmi	r0, r8, r1, asr #28
    tmppriority &= tmpmask;
    1494:	8e400284 	cdphi	2, 4, cr0, cr0, cr4, {4}
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    1498:	00000001 	andeq	r0, r0, r1

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    149c:	0000000c 	andeq	r0, r0, ip
    14a0:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    14a4:	7c020001 	stcvc	0, cr0, [r2], {1}
    14a8:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    14ac:	00000014 	andeq	r0, r0, r4, lsl r0
    14b0:	0000149c 	muleq	r0, ip, r4
    14b4:	00006760 	andeq	r6, r0, r0, ror #14
    14b8:	00000012 	andeq	r0, r0, r2, lsl r0
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    14bc:	84080e41 	strhi	r0, [r8], #-3649	; 0xe41
    14c0:	00018e02 	andeq	r8, r1, r2, lsl #28
    14c4:	0000000c 	andeq	r0, r0, ip
    rNVIC->ICER[1] = 0xFFFFFFFF;
    14c8:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    14cc:	7c020001 	stcvc	0, cr0, [r2], {1}
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    14d0:	000d0c0e 	andeq	r0, sp, lr, lsl #24

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    14d4:	0000000c 	andeq	r0, r0, ip
    14d8:	000014c4 	andeq	r1, r0, r4, asr #9
    14dc:	00006772 	andeq	r6, r0, r2, ror r7

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    14e0:	00000010 	andeq	r0, r0, r0, lsl r0
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    14e4:	0000000c 	andeq	r0, r0, ip
    nvicDisableInterrupts();
    14e8:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    14ec:	7c020001 	stcvc	0, cr0, [r2], {1}
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    14f0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14f4:	00000018 	andeq	r0, r0, r8, lsl r0
}
    14f8:	000014e4 	andeq	r1, r0, r4, ror #9
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14fc:	00006782 	andeq	r6, r0, r2, lsl #15

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1500:	00000030 	andeq	r0, r0, r0, lsr r0
    1504:	84080e41 	strhi	r0, [r8], #-3649	; 0xe41

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    1508:	41018e02 	tstmi	r1, r2, lsl #28
    150c:	0000700e 	andeq	r7, r0, lr
    1510:	00000018 	andeq	r0, r0, r8, lsl r0
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1514:	000014e4 	andeq	r1, r0, r4, ror #9
    1518:	000067b4 			; <UNDEFINED> instruction: 0x000067b4
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    151c:	0000001c 	andeq	r0, r0, ip, lsl r0

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1520:	840c0e41 	strhi	r0, [ip], #-3649	; 0xe41
    1524:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
    1528:	00000001 	andeq	r0, r0, r1
    SET_REG(FLASH_AR, pageAddr);
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    152c:	0000000c 	andeq	r0, r0, ip
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1530:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    1534:	7c020001 	stcvc	0, cr0, [r2], {1}

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    1538:	000d0c0e 	andeq	r0, sp, lr, lsl #24

    return TRUE;
}
    153c:	00000020 	andeq	r0, r0, r0, lsr #32
    1540:	0000152c 	andeq	r1, r0, ip, lsr #10
    1544:	000067d0 	ldrdeq	r6, [r0], -r0
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    1548:	000000b8 	strheq	r0, [r0], -r8
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    154c:	84200e42 	strthi	r0, [r0], #-3650	; 0xe42
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    1550:	86078508 	strhi	r8, [r7], -r8, lsl #10

    u32 rwmVal = GET_REG(FLASH_CR);
    SET_REG(FLASH_CR, FLASH_CR_PG);
    1554:	88058706 	stmdahi	r5, {r1, r2, r8, r9, sl, pc}
    1558:	8a038904 	bhi	e3970 <_etext+0xdc35c>

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    155c:	00018e02 	andeq	r8, r1, r2, lsl #28
    1560:	00000028 	andeq	r0, r0, r8, lsr #32
    *(flashAddr + 0x01) = (vu16)hhWord;
    1564:	0000152c 	andeq	r1, r0, ip, lsr #10
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1568:	00000000 	andeq	r0, r0, r0
    156c:	000000f2 	strdeq	r0, [r0], -r2
    *(flashAddr) = (vu16)lhWord;
    1570:	80300e42 	eorshi	r0, r0, r2, asr #28
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1574:	820b810c 	andhi	r8, fp, #12, 2
    1578:	8509840a 	strhi	r8, [r9, #-1034]	; 0x40a

    rwmVal &= 0xFFFFFFFE;
    157c:	87078608 	strhi	r8, [r7, -r8, lsl #12]
    SET_REG(FLASH_CR, rwmVal);

    /* verify the write */
    if (*(vu32 *)addr != word) {
    1580:	89058806 	stmdbhi	r5, {r1, r2, fp, pc}
        return FALSE;
    }

    return TRUE;
}
    1584:	8b038a04 	blhi	e3d9c <_etext+0xdc788>
    1588:	00018e02 	andeq	r8, r1, r2, lsl #28
    158c:	00000024 	andeq	r0, r0, r4, lsr #32
    1590:	0000152c 	andeq	r1, r0, ip, lsr #10

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    1594:	00006888 	andeq	r6, r0, r8, lsl #17
    1598:	000001d8 	ldrdeq	r0, [r0], -r8
    159c:	841c0e42 	ldrhi	r0, [ip], #-3650	; 0xe42
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    15a0:	86068507 	strhi	r8, [r6], -r7, lsl #10
    15a4:	88048705 	stmdahi	r4, {r0, r2, r8, r9, sl, pc}
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    15a8:	8e028903 	cdphi	9, 0, cr8, cr2, cr3, {0}
    15ac:	900e4101 	andls	r4, lr, r1, lsl #2
    15b0:	00000001 	andeq	r0, r0, r1
    15b4:	0000000c 	andeq	r0, r0, ip

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    15b8:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
	{
		pin-=8;
    15bc:	7c020001 	stcvc	0, cr0, [r2], {1}
	}
	mask = 0x0F << (pin<<2);
    15c0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    15c4:	00000020 	andeq	r0, r0, r0, lsr #32
	return ~mask;
}	
    15c8:	000015b4 			; <UNDEFINED> instruction: 0x000015b4

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    15cc:	00006a60 	andeq	r6, r0, r0, ror #20
    15d0:	000000e4 	andeq	r0, r0, r4, ror #1
}
    15d4:	83200e42 	teqhi	r0, #1056	; 0x420
    15d8:	85078408 	strhi	r8, [r7, #-1032]	; 0x408

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    15dc:	87058606 	strhi	r8, [r5, -r6, lsl #12]
	{
		return 0x800;
    15e0:	89038804 	stmdbhi	r3, {r2, fp, pc}
	}
	else
	{
		return 0x400;
	}
}
    15e4:	00018e02 	andeq	r8, r1, r2, lsl #28
    15e8:	00000028 	andeq	r0, r0, r8, lsr #32
    15ec:	000015b4 			; <UNDEFINED> instruction: 0x000015b4
    15f0:	00006b44 	andeq	r6, r0, r4, asr #22

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15f4:	00000228 	andeq	r0, r0, r8, lsr #4
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    15f8:	80300e42 	eorshi	r0, r0, r2, asr #28

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15fc:	820b810c 	andhi	r8, fp, #12, 2
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1600:	8409830a 	strhi	r8, [r9], #-778	; 0x30a
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    1604:	86078508 	strhi	r8, [r7], -r8, lsl #10
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    1608:	88058706 	stmdahi	r5, {r1, r2, r8, r9, sl, pc}
    160c:	8a038904 	bhi	e3a24 <_etext+0xdc410>
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1610:	00018e02 	andeq	r8, r1, r2, lsl #28
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1614:	0000000c 	andeq	r0, r0, ip
    userAppEnd = RAM_END;
    1618:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    161c:	7c020001 	stcvc	0, cr0, [r2], {1}
    userUploadType=DFU_UPLOAD_NONE;
    1620:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    1624:	00000014 	andeq	r0, r0, r4, lsl r0
    code_copy_lock = WAIT;
    1628:	00001614 	andeq	r1, r0, r4, lsl r6
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    162c:	00006d6c 	andeq	r6, r0, ip, ror #26
    1630:	0000001c 	andeq	r0, r0, ip, lsl r0
    1634:	84080e41 	strhi	r0, [r8], #-3649	; 0xe41
    memset(input, 0xFF, sizeof(input));
    1638:	00018e02 	andeq	r8, r1, r2, lsl #28
    163c:	0000000c 	andeq	r0, r0, ip

    sha256_starts(&ctx);
}
    1640:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1644:	7c020001 	stcvc	0, cr0, [r2], {1}
    1648:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    164c:	00000018 	andeq	r0, r0, r8, lsl r0
    1650:	0000163c 	andeq	r1, r0, ip, lsr r6
    1654:	00006d88 	andeq	r6, r0, r8, lsl #27
    1658:	00000036 	andeq	r0, r0, r6, lsr r0
    165c:	84100e42 	ldrhi	r0, [r0], #-3650	; 0xe42
    1660:	86038504 	strhi	r8, [r3], -r4, lsl #10
    1664:	00018e02 	andeq	r8, r1, r2, lsl #28
    1668:	0000000c 	andeq	r0, r0, ip
    166c:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    1670:	7c020001 	stcvc	0, cr0, [r2], {1}
    1674:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    1678:	00000018 	andeq	r0, r0, r8, lsl r0
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    167c:	00001668 	andeq	r1, r0, r8, ror #12
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    1680:	00006dc0 	andeq	r6, r0, r0, asr #27
    1684:	00000088 	andeq	r0, r0, r8, lsl #1

    if (startState == appDETACH) {
    1688:	840c0e41 	strhi	r0, [ip], #-3649	; 0xe41
    168c:	8e028503 	cfsh32hi	mvfx8, mvfx2, #3
        dfuAppStatus.bState = dfuIDLE;
    1690:	00000001 	andeq	r0, r0, r1
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
    1694:	0000000c 	andeq	r0, r0, ip
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1698:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    169c:	7c020001 	stcvc	0, cr0, [r2], {1}
    } else if (startState == appIDLE || startState == dfuIDLE) {
    16a0:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    16a4:	00000018 	andeq	r0, r0, r8, lsl r0
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    16a8:	00001694 	muleq	r0, r4, r6
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    16ac:	00006e48 	andeq	r6, r0, r8, asr #28
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    16b0:	000000a8 	andeq	r0, r0, r8, lsr #1
    16b4:	84100e41 	ldrhi	r0, [r0], #-3649	; 0xe41
    16b8:	86038504 	strhi	r8, [r3], -r4, lsl #10
    16bc:	00018e02 	andeq	r8, r1, r2, lsl #28

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    16c0:	0000000c 	andeq	r0, r0, ip
        pInformation->Ctrl_Info.Usb_wLength = 1;
    16c4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    16c8:	7c020001 	stcvc	0, cr0, [r2], {1}
        return NULL;
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    16cc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    }
}
    16d0:	0000001c 	andeq	r0, r0, ip, lsl r0
    16d4:	000016c0 	andeq	r1, r0, r0, asr #13

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    16d8:	00006ef0 	strdeq	r6, [r0], -r0
        pInformation->Ctrl_Info.Usb_wLength = 6;
    16dc:	0000004c 	andeq	r0, r0, ip, asr #32
    16e0:	83180e41 	tsthi	r8, #1040	; 0x410
        return NULL;
    } else {
        return (u8*)(&dfuAppStatus);
    16e4:	85058406 	strhi	r8, [r5, #-1030]	; 0x406
    }
}
    16e8:	87038604 	strhi	r8, [r3, -r4, lsl #12]
    16ec:	00018e02 	andeq	r8, r1, r2, lsl #28


u8 *dfuCopyDNLOAD(u16 length) {
    16f0:	0000000c 	andeq	r0, r0, ip
    if (length == 0) {
    16f4:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    16f8:	7c020001 	stcvc	0, cr0, [r2], {1}
    16fc:	000d0c0e 	andeq	r0, sp, lr, lsl #24
        thisBlockLen = pInformation->USBwLengths.w;
    1700:	00000018 	andeq	r0, r0, r8, lsl r0
        return NULL;
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1704:	000016f0 	strdeq	r1, [r0], -r0
    1708:	00006f3c 	andeq	r6, r0, ip, lsr pc
    }
}
    170c:	00000020 	andeq	r0, r0, r0, lsr #32
    1710:	83100e41 	tsthi	r0, #1040	; 0x410
    1714:	85038404 	strhi	r8, [r3, #-1028]	; 0x404

u8 *dfuCopyUPLOAD(u16 length) {
    1718:	00018e02 	andeq	r8, r1, r2, lsl #28
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    171c:	0000000c 	andeq	r0, r0, ip
    1720:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    1724:	7c020001 	stcvc	0, cr0, [r2], {1}
        return NULL;
    1728:	000d0c0e 	andeq	r0, sp, lr, lsl #24
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    172c:	0000000c 	andeq	r0, r0, ip
    1730:	0000171c 	andeq	r1, r0, ip, lsl r7
    1734:	00006f5c 	andeq	r6, r0, ip, asr pc
    1738:	00000010 	andeq	r0, r0, r0, lsl r0
    }
}
    173c:	0000000c 	andeq	r0, r0, ip
    1740:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    1744:	7c020001 	stcvc	0, cr0, [r2], {1}
    1748:	000d0c0e 	andeq	r0, sp, lr, lsl #24

void dfuCopyBufferToExec() {
    174c:	0000000c 	andeq	r0, r0, ip
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    1750:	0000173c 	andeq	r1, r0, ip, lsr r7
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    1754:	00006f6c 	andeq	r6, r0, ip, ror #30
    1758:	00000012 	andeq	r0, r0, r2, lsl r0
    175c:	0000000c 	andeq	r0, r0, ip
    1760:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    1764:	7c020001 	stcvc	0, cr0, [r2], {1}
	}

    flashErasePage((u32)(userSpace));
    1768:	000d0c0e 	andeq	r0, sp, lr, lsl #24

    for (i = 0; i < thisBlockLen; i = i + 4) {
    176c:	00000018 	andeq	r0, r0, r8, lsl r0
    1770:	0000175c 	andeq	r1, r0, ip, asr r7
    1774:	00000000 	andeq	r0, r0, r0
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    1778:	0000001a 	andeq	r0, r0, sl, lsl r0
    177c:	83100e41 	tsthi	r0, #1040	; 0x410
    1780:	85038404 	strhi	r8, [r3, #-1028]	; 0x404
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    1784:	00018e02 	andeq	r8, r1, r2, lsl #28
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    1788:	00000018 	andeq	r0, r0, r8, lsl r0
    178c:	0000175c 	andeq	r1, r0, ip, asr r7
    thisBlockLen = 0;
    1790:	00000000 	andeq	r0, r0, r0
    1794:	000000bc 	strheq	r0, [r0], -ip
    1798:	84100e42 	ldrhi	r0, [r0], #-3650	; 0xe42
    179c:	86038504 	strhi	r8, [r3], -r4, lsl #10
    17a0:	00018e02 	andeq	r8, r1, r2, lsl #28
    17a4:	0000000c 	andeq	r0, r0, ip
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    17a8:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    17ac:	7c020001 	stcvc	0, cr0, [r2], {1}
    17b0:	000d0c0e 	andeq	r0, sp, lr, lsl #24

    u8 startState = dfuAppStatus.bState;
    17b4:	0000000c 	andeq	r0, r0, ip
    17b8:	000017a4 	andeq	r1, r0, r4, lsr #15
    dfuAppStatus.bStatus = OK;
    17bc:	00006f80 	andeq	r6, r0, r0, lsl #31
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    17c0:	00000034 	andeq	r0, r0, r4, lsr r0

Disassembly of section .debug_str:

00000000 <.debug_str>:
       0:	31425041 	cmpcc	r2, r1, asr #32
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
       4:	00524e45 	subseq	r4, r2, r5, asr #28
       8:	55534552 	ldrbpl	r4, [r3, #-1362]	; 0x552
       c:	4c5f454d 	cfldr64mi	mvdx4, [pc], {77}	; 0x4d
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
      10:	52455441 	subpl	r5, r5, #1090519040	; 0x41000000
      14:	42535500 	subsmi	r5, r3, #0, 10
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
      18:	71655262 	cmnvc	r5, r2, ror #4
      1c:	74736575 	ldrbtvc	r6, [r3], #-1397	; 0x575
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
      20:	72747300 	rsbsvc	r7, r4, #0, 6
      24:	65646e49 	strbvs	r6, [r4, #-3657]!	; 0xe49
      28:	50410078 	subpl	r0, r1, r8, ror r0
    if ((wEPVal & EP_CTR_RX) != 0)
      2c:	53523242 	cmppl	r2, #536870916	; 0x20000004
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
      30:	4f005254 	svcmi	0x00005254
      34:	6544656e 	strbvs	r6, [r4, #-1390]	; 0x56e
      38:	69726373 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, r8, r9, sp, lr}^

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
      3c:	726f7470 	rsbvc	r7, pc, #112, 8	; 0x70000000

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
      40:	5f387500 	svcpl	0x00387500
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
      44:	43627375 	cmnmi	r2, #-738197503	; 0xd4000001
      48:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
      4c:	73654467 	cmnvc	r5, #1728053248	; 0x67000000

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
      50:	70697263 	rsbvc	r7, r9, r3, ror #4
      54:	44726f74 	ldrbtmi	r6, [r2], #-3956	; 0xf74
      58:	75005546 	strvc	r5, [r0, #-1350]	; 0x546
      5c:	6e496273 	mcrvs	2, 2, r6, cr9, cr3, {3}
      60:	69007469 	stmdbvs	r0, {r0, r3, r5, r6, sl, ip, sp, lr}
      64:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
      68:	65636166 	strbvs	r6, [r3, #-358]!	; 0x166
      6c:	616c4300 	cmnvs	ip, r0, lsl #6
      70:	4e5f7373 	mrcmi	3, 2, r7, cr15, cr3, {3}
      74:	7461446f 	strbtvc	r4, [r1], #-1135	; 0x46f
      78:	65535f61 	ldrbvs	r5, [r3, #-3937]	; 0xf61
      7c:	00707574 	rsbseq	r7, r0, r4, ror r5
      80:	44627375 	strbtmi	r7, [r2], #-885	; 0x375
      84:	53496273 	movtpl	r6, #37491	; 0x9273
      88:	555f0052 	ldrbpl	r0, [pc, #-82]	; 3e <g_pfnVectors+0x3e>
      8c:	5f524553 	svcpl	0x00524553
      90:	4e415453 	mcrmi	4, 2, r5, cr1, cr3, {2}
      94:	44524144 	ldrbmi	r4, [r2], #-324	; 0x144
      98:	5145525f 	cmppl	r5, pc, asr r2
      9c:	54534555 	ldrbpl	r4, [r3], #-1365	; 0x555
      a0:	73550053 	cmpvc	r5, #83	; 0x53
      a4:	475f7265 	ldrbmi	r7, [pc, -r5, ror #4]
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
      a8:	74537465 	ldrbvc	r7, [r3], #-1125	; 0x465

	return f25519_eq(a, c);
      ac:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
      b0:	72547700 	subsvc	r7, r4, #0, 14
      b4:	66736e61 	ldrbtvs	r6, [r3], -r1, ror #28
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
      b8:	69537265 	ldmdbvs	r3, {r0, r2, r5, r6, r9, ip, sp, lr}^
	f25519_normalize(ey);
      bc:	5500657a 	strpl	r6, [r0, #-1402]	; 0x57a
      c0:	4c5f4253 	lfmmi	f4, 2, [pc], {83}	; 0x53

	return ok;
}
      c4:	41435f50 	cmpmi	r3, r0, asr pc
      c8:	525f314e 	subspl	r3, pc, #-2147483629	; 0x80000013
      cc:	495f3058 	ldmdbmi	pc, {r3, r4, r6, ip, sp}^	; <UNPREDICTABLE>
      d0:	61485152 	cmpvs	r8, r2, asr r1
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
      d4:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
      d8:	73750072 	cmnvc	r5, #114	; 0x72
		minusp[i] = c;
      dc:	74654762 	strbtvc	r4, [r5], #-1890	; 0x762
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
      e0:	65746e49 	ldrbvs	r6, [r4, #-3657]!	; 0xe49
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
      e4:	63616672 	cmnvs	r1, #119537664	; 0x7200000

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
      e8:	74655365 	strbtvc	r5, [r5], #-869	; 0x365
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
      ec:	676e6974 			; <UNDEFINED> instruction: 0x676e6974
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
      f0:	50424100 	subpl	r4, r2, r0, lsl #2
      f4:	54535231 	ldrbpl	r5, [r3], #-561	; 0x231
      f8:	525f0052 	subspl	r0, pc, #82	; 0x52
      fc:	4d555345 	ldclmi	3, cr5, [r5, #-276]	; 0xfffffeec
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     100:	54535f45 	ldrbpl	r5, [r3], #-3909	; 0xf45

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
     104:	00455441 	subeq	r5, r5, r1, asr #8
     108:	68746f6e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     10c:	50676e69 	rsbpl	r6, r7, r9, ror #28
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
     110:	00636f72 	rsbeq	r6, r3, r2, ror pc
     114:	5645445f 			; <UNDEFINED> instruction: 0x5645445f
     118:	5f454349 	svcpl	0x00454349
     11c:	4f464e49 	svcmi	0x00464e49
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     120:	62737500 	rsbsvs	r7, r3, #0, 10
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
     124:	61446f4e 	cmpvs	r4, lr, asr #30
     128:	65536174 	ldrbvs	r6, [r3, #-372]	; 0x174
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
     12c:	00707574 	rsbseq	r7, r0, r4, ror r5

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
     130:	5f425355 	svcpl	0x00425355
	i <<= 3;

	while (x) {
     134:	55534e55 	ldrbpl	r4, [r3, #-3669]	; 0xe55
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
     138:	524f5050 	subpl	r5, pc, #80	; 0x50
     13c:	50700054 	rsbspl	r0, r0, r4, asr r0
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
     140:	65706f72 	ldrbvs	r6, [r0, #-3954]!	; 0xf72
	f25519_mul_c(z3, x1sq, 4);
     144:	00797472 	rsbseq	r7, r9, r2, ror r4
     148:	77425355 	smlsldvc	r5, r2, r5, r3
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	65646e49 	strbvs	r6, [r4, #-3657]!	; 0xe49
     150:	75007378 	strvc	r7, [r0, #-888]	; 0x378
     154:	65536273 	ldrbvs	r6, [r3, #-627]	; 0x273
	f25519_sub(b, x3, z3); /* D */
     158:	6e6f4374 	mcrvs	3, 3, r4, cr15, cr4, {3}
     15c:	75676966 	strbvc	r6, [r7, #-2406]!	; 0x966
	f25519_mul__distinct(da, a, b);
     160:	69746172 	ldmdbvs	r4!, {r1, r4, r5, r6, r8, sp, lr}^
     164:	52006e6f 	andpl	r6, r0, #1776	; 0x6f0
     168:	4d555345 	ldclmi	3, cr5, [r5, #-276]	; 0xfffffeec

	f25519_sub(b, x2, z2);
     16c:	41575f45 	cmpmi	r7, r5, asr #30
     170:	61005449 	tstvs	r0, r9, asr #8
	f25519_add(a, x3, z3); /* C */
     174:	6553746c 	ldrbvs	r7, [r3, #-1132]	; 0x46c
     178:	6e697474 	mcrvs	4, 3, r7, cr9, cr4, {3}
     17c:	4e450067 	cdpmi	0, 4, cr0, cr5, cr7, {3}
	f25519_mul__distinct(cb, a, b);
     180:	494f5044 	stmdbmi	pc, {r2, r6, ip, lr}^	; <UNPREDICTABLE>
     184:	525f544e 	subspl	r5, pc, #1308622848	; 0x4e000000

	f25519_add(a, da, cb);
     188:	50494345 	subpl	r4, r9, r5, asr #6
     18c:	544e4549 	strbpl	r4, [lr], #-1353	; 0x549
     190:	65735500 	ldrbvs	r5, [r3, #-1280]!	; 0x500
	f25519_mul__distinct(b, a, a);
     194:	65535f72 	ldrbvs	r5, [r3, #-3954]	; 0xf72
     198:	76654474 			; <UNDEFINED> instruction: 0x76654474
	f25519_mul__distinct(x5, z1, b);
     19c:	46656369 	strbtmi	r6, [r5], -r9, ror #6
     1a0:	75746165 	ldrbvc	r6, [r4, #-357]!	; 0x165
     1a4:	54006572 	strpl	r6, [r0], #-1394	; 0x572

	f25519_sub(a, da, cb);
     1a8:	00455552 	subeq	r5, r5, r2, asr r5
     1ac:	53627375 	cmnpl	r2, #-738197503	; 0xd4000001
	f25519_mul__distinct(b, a, a);
     1b0:	65447465 	strbvs	r7, [r4, #-1125]	; 0x465
     1b4:	65636976 	strbvs	r6, [r3, #-2422]!	; 0x976
     1b8:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	00737365 	rsbseq	r7, r3, r5, ror #6
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	47627375 			; <UNDEFINED> instruction: 0x47627375
     1c4:	74537465 	ldrbvc	r7, [r3], #-1125	; 0x465

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1c8:	676e6972 			; <UNDEFINED> instruction: 0x676e6972
     1cc:	63736544 	cmnvs	r3, #68, 10	; 0x11000000
     1d0:	74706972 	ldrbtvc	r6, [r0], #-2418	; 0x972
     1d4:	5500726f 	strpl	r7, [r0, #-623]	; 0x26f
		f25519_select(zm1, zm1, zm, bit);
     1d8:	775f6273 			; <UNDEFINED> instruction: 0x775f6273
     1dc:	676e654c 	strbvs	r6, [lr, -ip, asr #10]!
     1e0:	76006874 			; <UNDEFINED> instruction: 0x76006874
		f25519_select(xm, xm, xms, bit);
     1e4:	00363175 	eorseq	r3, r6, r5, ror r1
     1e8:	666e4970 			; <UNDEFINED> instruction: 0x666e4970
     1ec:	616d726f 	cmnvs	sp, pc, ror #4
		f25519_select(zm, zm, zms, bit);
     1f0:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
     1f4:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
     1f8:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fc:	79547469 	ldmdbvc	r4, {r0, r3, r5, r6, sl, ip, sp, lr}^
     200:	65446570 	strbvs	r6, [r4, #-1392]	; 0x570
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     204:	73750066 	cmnvc	r5, #102	; 0x66
     208:	74654762 	strbtvc	r4, [r5], #-1890	; 0x762
	f25519_mul__distinct(result, zm1, xm);
     20c:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
     210:	72756769 	rsbsvc	r6, r5, #27525120	; 0x1a40000
	f25519_normalize(result);
     214:	6f697461 	svcvs	0x00697461
     218:	6544006e 	strbvs	r0, [r4, #-110]	; 0x6e
}
     21c:	65636976 	strbvs	r6, [r3, #-2422]!	; 0x976
     220:	6261545f 	rsbvs	r5, r1, #1593835520	; 0x5f000000
     224:	7500656c 	strvc	r6, [r0, #-1388]	; 0x56c
     228:	65536273 	ldrbvs	r6, [r3, #-627]	; 0x273
     22c:	646e4574 	strbtvs	r4, [lr], #-1396	; 0x574
     230:	6e696f70 	mcrvs	15, 3, r6, cr9, cr0, {3}
     234:	61654674 	smcvs	21604	; 0x5464
     238:	65727574 	ldrbvs	r7, [r2, #-1396]!	; 0x574
     23c:	45525f00 	ldrbmi	r5, [r2, #-3840]	; 0xf00
     240:	49504943 	ldmdbmi	r0, {r0, r1, r6, r8, fp, lr}^
     244:	5f544e45 	svcpl	0x00544e45
     248:	45505954 	ldrbmi	r5, [r0, #-2388]	; 0x954
     24c:	6e6f6c00 	cdpvs	12, 6, cr6, cr15, cr0, {0}
     250:	6f6c2067 	svcvs	0x006c2067
     254:	7520676e 	strvc	r6, [r0, #-1902]!	; 0x76e
     258:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
     25c:	2064656e 	rsbcs	r6, r4, lr, ror #10
     260:	00746e69 	rsbseq	r6, r4, r9, ror #28
     264:	6e617453 	mcrvs	4, 3, r7, cr1, cr3, {2}
     268:	64726164 	ldrbtvs	r6, [r2], #-356	; 0x164
     26c:	7465475f 	strbtvc	r4, [r5], #-1887	; 0x75f
     270:	63736544 	cmnvs	r3, #68, 10	; 0x11000000
     274:	74706972 	ldrbtvc	r6, [r0], #-2418	; 0x972
     278:	6144726f 	cmpvs	r4, pc, ror #4
     27c:	63006174 	movwvs	r6, #372	; 0x174
     280:	73614d72 	cmnvc	r1, #7296	; 0x1c80
     284:	5355006b 	cmppl	r5, #107	; 0x6b
     288:	55535f42 	ldrbpl	r5, [r3, #-3906]	; 0xf42
     28c:	53454343 	movtpl	r4, #21315	; 0x5343
     290:	53550053 	cmppl	r5, #83	; 0x53
     294:	6e495f42 	cdpvs	15, 4, cr5, cr9, cr2, {2}
     298:	55007469 	strpl	r7, [r0, #-1129]	; 0x469
     29c:	5f726573 	svcpl	0x00726573
     2a0:	49746547 	ldmdbmi	r4!, {r0, r1, r2, r6, r8, sl, sp, lr}^
     2a4:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
     2a8:	65636166 	strbvs	r6, [r3, #-358]!	; 0x166
     2ac:	65735500 	ldrbvs	r5, [r3, #-1280]!	; 0x500
     2b0:	65535f72 	ldrbvs	r5, [r3, #-3954]	; 0xf72
     2b4:	76654474 			; <UNDEFINED> instruction: 0x76654474
     2b8:	41656369 	cmnmi	r5, r9, ror #6
     2bc:	65726464 	ldrbvs	r6, [r2, #-1124]!	; 0x464
     2c0:	43007373 	movwmi	r7, #883	; 0x373
     2c4:	7373616c 	cmnvc	r3, #108, 2
     2c8:	7461445f 	strbtvc	r4, [r1], #-1119	; 0x45f
     2cc:	65535f61 	ldrbvs	r5, [r3, #-3937]	; 0xf61
     2d0:	00707574 	rsbseq	r7, r0, r4, ror r5
     2d4:	47627375 			; <UNDEFINED> instruction: 0x47627375
     2d8:	65447465 	strbvs	r7, [r4, #-1125]	; 0x465
     2dc:	65636976 	strbvs	r6, [r3, #-2422]!	; 0x976
     2e0:	63736544 	cmnvs	r3, #68, 10	; 0x11000000
     2e4:	74706972 	ldrbtvc	r6, [r0], #-2418	; 0x972
     2e8:	4400726f 	strmi	r7, [r0], #-623	; 0x26f
     2ec:	63697665 	cmnvs	r9, #105906176	; 0x6500000
     2f0:	72505f65 	subsvc	r5, r0, #404	; 0x194
     2f4:	7265706f 	rsbvc	r7, r5, #111	; 0x6f
     2f8:	62007974 	andvs	r7, r0, #116, 18	; 0x1d0000
     2fc:	69766544 	ldmdbvs	r6!, {r2, r6, r8, sl, sp, lr}^
     300:	74536563 	ldrbvc	r6, [r3], #-1379	; 0x563
     304:	00657461 	rsbeq	r7, r5, r1, ror #8
     308:	4f534562 	svcmi	0x00534562
     30c:	746e6346 	strbtvc	r6, [lr], #-838	; 0x346
     310:	42535500 	subsmi	r5, r3, #0, 10
     314:	6c615677 	stclvs	6, cr5, [r1], #-476	; 0xfffffe24
     318:	00736575 	rsbseq	r6, r3, r5, ror r5
     31c:	55534552 	ldrbpl	r4, [r3, #-1362]	; 0x552
     320:	455f454d 	ldrbmi	r4, [pc, #-1357]	; fffffddb <BootRAM+0xef7057c>
     324:	00464f53 	subeq	r4, r6, r3, asr pc
     328:	41627375 	smcmi	10037	; 0x2735
     32c:	6e497070 	mcrvs	0, 2, r7, cr9, cr0, {3}
     330:	52007469 	andpl	r7, r0, #1761607680	; 0x69000000
     334:	545f4343 	ldrbpl	r4, [pc], #-835	; 33c <GPIO_PinRemapConfig+0x8>
     338:	44657079 	strbtmi	r7, [r5], #-121	; 0x79
     33c:	75006665 	strvc	r6, [r0, #-1637]	; 0x665
     340:	65476273 	strbvs	r6, [r7, #-627]	; 0x273
     344:	6e754674 	mrcvs	6, 3, r4, cr5, cr4, {3}
     348:	6f697463 	svcvs	0x00697463
     34c:	446c616e 	strbtmi	r6, [ip], #-366	; 0x16e
     350:	72637365 	rsbvc	r7, r3, #-1811939327	; 0x94000001
     354:	6f747069 	svcvs	0x00747069
     358:	75760072 	ldrbvc	r0, [r6, #-114]!	; 0x72
     35c:	67003233 	smladxvs	r0, r3, r2, r3
     360:	6c467465 	cfstrdvs	mvd7, [r6], {101}	; 0x65
     364:	50687361 	rsbpl	r7, r8, r1, ror #6
     368:	53656761 	cmnpl	r5, #25427968	; 0x1840000
     36c:	00657a69 	rsbeq	r7, r5, r9, ror #20
     370:	61746f54 	cmnvs	r4, r4, asr pc
     374:	6e455f6c 	cdpvs	15, 4, cr5, cr5, cr12, {3}
     378:	696f7064 	stmdbvs	pc!, {r2, r5, r6, ip, sp, lr}^	; <UNPREDICTABLE>
     37c:	5300746e 	movwpl	r7, #1134	; 0x46e
     380:	50457465 	subpl	r7, r5, r5, ror #8
     384:	61567852 	cmpvs	r6, r2, asr r8
     388:	0064696c 	rsbeq	r6, r4, ip, ror #18
     38c:	55534552 	ldrbpl	r4, [r3, #-1362]	; 0x552
     390:	4f5f454d 	svcmi	0x005f454d
     394:	564e004e 	strbpl	r0, [lr], -lr, asr #32
     398:	495f4349 	ldmdbmi	pc, {r0, r3, r6, r8, r9, lr}^	; <UNPREDICTABLE>
     39c:	68435152 	stmdavs	r3, {r1, r4, r6, r8, ip, lr}^
     3a0:	656e6e61 	strbvs	r6, [lr, #-3681]!	; 0xe61
     3a4:	646d436c 	strbtvs	r4, [sp], #-876	; 0x36c
     3a8:	45445f00 	strbmi	r5, [r4, #-3840]	; 0xf00
     3ac:	45434956 	strbmi	r4, [r3, #-2390]	; 0x956
     3b0:	4f52505f 	svcmi	0x0052505f
     3b4:	73750050 	cmnvc	r5, #80	; 0x50
     3b8:	74654762 	strbtvc	r4, [r5], #-1890	; 0x762
     3bc:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
     3c0:	65446769 	strbvs	r6, [r4, #-1897]	; 0x769
     3c4:	69726373 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, r8, r9, sp, lr}^
     3c8:	726f7470 	rsbvc	r7, pc, #112, 8	; 0x70000000
     3cc:	44444100 	strbmi	r4, [r4], #-256	; 0x100
     3d0:	53534552 	cmppl	r3, #343932928	; 0x14800000
     3d4:	75004445 	strvc	r4, [r0, #-1093]	; 0x445
     3d8:	74536273 	ldrbvc	r6, [r3], #-627	; 0x273
     3dc:	676e6972 			; <UNDEFINED> instruction: 0x676e6972
     3e0:	63736544 	cmnvs	r3, #68, 10	; 0x11000000
     3e4:	74706972 	ldrbtvc	r6, [r0], #-2418	; 0x972
     3e8:	7500726f 	strvc	r7, [r0, #-623]	; 0x26f
     3ec:	632e6273 	teqvs	lr, #805306375	; 0x30000007
     3f0:	73654400 	cmnvc	r5, #0, 8
     3f4:	70697263 	rsbvc	r7, r9, r3, ror #4
     3f8:	5f726f74 	svcpl	0x00726f74
     3fc:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
     400:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
     404:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
     408:	74537469 	ldrbvc	r7, [r3], #-1129	; 0x469
     40c:	74637572 	strbtvc	r7, [r3], #-1394	; 0x572
     410:	00657275 	rsbeq	r7, r5, r5, ror r2
     414:	5f434352 	svcpl	0x00434352
     418:	746f6c42 	strbtvc	r6, [pc], #-3138	; 420 <RCC_HSEConfig+0x8>
     41c:	65735500 	ldrbvs	r5, [r3, #-1280]!	; 0x500
     420:	65535f72 	ldrbvs	r5, [r3, #-3954]	; 0xf72
     424:	6e6f4374 	mcrvs	3, 3, r4, cr15, cr4, {3}
     428:	75676966 	strbvc	r6, [r7, #-2406]!	; 0x966
     42c:	69746172 	ldmdbvs	r4!, {r1, r4, r5, r6, r8, sp, lr}^
     430:	55006e6f 	strpl	r6, [r0, #-3695]	; 0xe6f
     434:	5f726573 	svcpl	0x00726573
     438:	49746553 	ldmdbmi	r4!, {r0, r1, r4, r6, r8, sl, sp, lr}^
     43c:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
     440:	65636166 	strbvs	r6, [r3, #-358]!	; 0x166
     444:	42484100 	submi	r4, r8, #0, 2
     448:	00524e45 	subseq	r4, r2, r5, asr #28
     44c:	50627375 	rsbpl	r7, r2, r5, ror r3
     450:	7265776f 	rsbvc	r7, r5, #29097984	; 0x1bc0000
     454:	52006e4f 	andpl	r6, r0, #1264	; 0x4f0
     458:	4d555345 	ldclmi	3, cr5, [r5, #-276]	; 0xfffffeec
     45c:	4e495f45 	cdpmi	15, 4, cr5, cr9, cr5, {2}
     460:	4e524554 	mrcmi	5, 2, r4, cr2, cr4, {2}
     464:	52004c41 	andpl	r4, r0, #16640	; 0x4100
     468:	5f504578 	svcpl	0x00504578
     46c:	66667562 	strbtvs	r7, [r6], -r2, ror #10
     470:	75007265 	strvc	r7, [r0, #-613]	; 0x265
     474:	6e456273 	mcrvs	2, 2, r6, cr5, cr3, {3}
     478:	52534962 	subspl	r4, r3, #1605632	; 0x188000
     47c:	62737500 	rsbsvs	r7, r3, #0, 10
     480:	75736552 	ldrbvc	r6, [r3, #-1362]!	; 0x552
     484:	6400656d 	strvs	r6, [r0], #-1389	; 0x56d
     488:	70557566 	subsvc	r7, r5, r6, ror #10
     48c:	65746164 	ldrbvs	r6, [r4, #-356]!	; 0x164
     490:	65527942 	ldrbvs	r7, [r2, #-2370]	; 0x942
     494:	73657571 	cmnvc	r5, #473956352	; 0x1c400000
     498:	73750074 	cmnvc	r5, #116	; 0x74
     49c:	61745362 	cmnvs	r4, r2, ror #6
     4a0:	4f737574 	svcmi	0x00737574
     4a4:	75007475 	strvc	r7, [r0, #-1141]	; 0x475
     4a8:	65526273 	ldrbvs	r6, [r2, #-627]	; 0x273
     4ac:	656d7573 	strbvs	r7, [sp, #-1395]!	; 0x573
     4b0:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
     4b4:	62737500 	rsbsvs	r7, r3, #0, 10
     4b8:	65736552 	ldrbvs	r6, [r3, #-1362]!	; 0x552
     4bc:	73750074 	cmnvc	r5, #116	; 0x74
     4c0:	61745362 	cmnvs	r4, r2, ror #6
     4c4:	49737574 	ldmdbmi	r3!, {r2, r4, r5, r6, r8, sl, ip, sp, lr}^
     4c8:	4552006e 	ldrbmi	r0, [r2, #-110]	; 0x6e
     4cc:	454d5553 	strbmi	r5, [sp, #-1363]	; 0x553
     4d0:	46464f5f 			; <UNDEFINED> instruction: 0x46464f5f
     4d4:	6e6f6c00 	cdpvs	12, 6, cr6, cr15, cr0, {0}
     4d8:	6f6c2067 	svcvs	0x006c2067
     4dc:	6920676e 	stmdbvs	r0!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}
     4e0:	5000746e 	andpl	r7, r0, lr, ror #8
     4e4:	5245574f 	subpl	r5, r5, #20709376	; 0x13c0000
     4e8:	55004445 	strpl	r4, [r0, #-1093]	; 0x445
     4ec:	4c774253 	lfmmi	f4, 2, [r7], #-332	; 0xfffffeb4
     4f0:	74676e65 	strbtvc	r6, [r7], #-3685	; 0xe65
     4f4:	75007368 	strvc	r7, [r0, #-872]	; 0x368
     4f8:	65536273 	ldrbvs	r6, [r3, #-627]	; 0x273
     4fc:	746e4974 	strbtvc	r4, [lr], #-2420	; 0x974
     500:	61667265 	cmnvs	r6, r5, ror #4
     504:	43006563 	movwmi	r6, #1379	; 0x563
     508:	65727275 	ldrbvs	r7, [r2, #-629]!	; 0x275
     50c:	435f746e 	cmpmi	pc, #1845493760	; 0x6e000000
     510:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
     514:	61727567 	cmnvs	r2, r7, ror #10
     518:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
     51c:	6e497700 	cdpvs	7, 4, cr7, cr9, cr0, {0}
     520:	72726574 	rsbsvc	r6, r2, #116, 10	; 0x1d000000
     524:	5f747075 	svcpl	0x00747075
     528:	6b73614d 	blvs	1cd8a64 <_etext+0x1cd1450>
     52c:	6f6f6200 	svcvs	0x006f6200
     530:	4544006c 	strbmi	r0, [r4, #-108]	; 0x6c
     534:	45434956 	strbmi	r4, [r3, #-2390]	; 0x956
     538:	4345525f 	movtmi	r5, #21087	; 0x525f
     53c:	45495049 	strbmi	r5, [r9, #-73]	; 0x49
     540:	7500544e 	strvc	r5, [r0, #-1102]	; 0x44e
     544:	65476273 	strbvs	r6, [r7, #-627]	; 0x273
     548:	61745374 	cmnvs	r4, r4, ror r3
     54c:	43006574 	movwmi	r6, #1396	; 0x574
     550:	65727275 	ldrbvs	r7, [r2, #-629]!	; 0x275
     554:	495f746e 	ldmdbmi	pc, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^	; <UNPREDICTABLE>
     558:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
     55c:	65636166 	strbvs	r6, [r3, #-358]!	; 0x166
     560:	4e437700 	cdpmi	7, 4, cr7, cr3, cr0, {0}
     564:	75005254 	strvc	r5, [r0, #-596]	; 0x254
     568:	73446273 	movtvc	r6, #17011	; 0x4273
     56c:	73754262 	cmnvc	r5, #536870918	; 0x20000006
     570:	4e4f5000 	cdpmi	0, 4, cr5, cr15, cr0, {0}
     574:	45445f45 	strbmi	r5, [r4, #-3909]	; 0xf45
     578:	49524353 	ldmdbmi	r2, {r0, r1, r4, r6, r8, r9, lr}^
     57c:	524f5450 	subpl	r5, pc, #80, 8	; 0x50000000
     580:	62737500 	rsbsvs	r7, r3, #0, 10
     584:	70737553 	rsbsvc	r7, r3, r3, asr r5
     588:	00646e65 	rsbeq	r6, r4, r5, ror #28
     58c:	61746f54 	cmnvs	r4, r4, asr pc
     590:	6f435f6c 	svcvs	0x00435f6c
     594:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
     598:	74617275 	strbtvc	r7, [r1], #-629	; 0x275
     59c:	006e6f69 	rsbeq	r6, lr, r9, ror #30
     5a0:	72657355 	rsbvc	r7, r5, #1409286145	; 0x54000001
     5a4:	7465475f 	strbtvc	r4, [r5], #-1887	; 0x75f
     5a8:	666e6f43 	strbtvs	r6, [lr], -r3, asr #30
     5ac:	72756769 	rsbsvc	r6, r5, #27525120	; 0x1a40000
     5b0:	6f697461 	svcvs	0x00697461
     5b4:	564e006e 	strbpl	r0, [lr], -lr, rrx
     5b8:	495f4349 	ldmdbmi	pc, {r0, r3, r6, r8, r9, lr}^	; <UNPREDICTABLE>
     5bc:	68435152 	stmdavs	r3, {r1, r4, r6, r8, ip, lr}^
     5c0:	656e6e61 	strbvs	r6, [lr, #-3681]!	; 0xe61
     5c4:	4552006c 	ldrbmi	r0, [r2, #-108]	; 0x6c
     5c8:	454d5553 	strbmi	r5, [sp, #-1363]	; 0x553
     5cc:	5458455f 	ldrbpl	r4, [r8], #-1375	; 0x55f
     5d0:	414e5245 	cmpmi	lr, r5, asr #4
     5d4:	7543004c 	strbvc	r0, [r3, #-76]	; 0x4c
     5d8:	6e657272 	mcrvs	2, 3, r7, cr5, cr2, {3}
     5dc:	6c415f74 	mcrrvs	15, 7, r5, r1, cr4
     5e0:	6e726574 	mrcvs	5, 3, r6, cr2, cr4, {3}
     5e4:	53657461 	cmnpl	r5, #1627389952	; 0x61000000
     5e8:	69747465 	ldmdbvs	r4!, {r0, r2, r5, r6, sl, ip, sp, lr}^
     5ec:	4100676e 	tstmi	r0, lr, ror #14
     5f0:	45324250 	ldrmi	r4, [r2, #-592]!	; 0x250
     5f4:	7200524e 	andvc	r5, r0, #-536870908	; 0xe0000004
     5f8:	65757165 	ldrbvs	r7, [r5, #-357]!	; 0x165
     5fc:	5f007473 	svcpl	0x00007473
     600:	50444e45 	subpl	r4, r4, r5, asr #28
     604:	544e494f 	strbpl	r4, [lr], #-2383	; 0x94f
     608:	464e495f 			; <UNDEFINED> instruction: 0x464e495f
     60c:	6f43004f 	svcvs	0x0043004f
     610:	6f527970 	svcvs	0x00527970
     614:	6e697475 	mcrvs	4, 3, r7, cr9, cr5, {3}
     618:	43520065 	cmpmi	r2, #101	; 0x65
     61c:	44425f43 	strbmi	r5, [r2], #-3907	; 0xf43
     620:	5f005243 	svcpl	0x00005243
     624:	49564544 	ldmdbmi	r6, {r2, r6, r8, sl, lr}^
     628:	55004543 	strpl	r4, [r0, #-1347]	; 0x543
     62c:	4e5f4253 	mrcmi	2, 2, r4, cr15, cr3, {2}
     630:	525f544f 	subspl	r5, pc, #1325400064	; 0x4f000000
     634:	59444145 	stmdbpl	r4, {r0, r2, r6, r8, lr}^
     638:	554e4700 	strbpl	r4, [lr, #-1792]	; 0x700
     63c:	34204320 	strtcc	r4, [r0], #-800	; 0x320
     640:	342e382e 	strtcc	r3, [lr], #-2094	; 0x82e
     644:	31303220 	teqcc	r0, r0, lsr #4
     648:	32373034 	eorscc	r3, r7, #52	; 0x34
     64c:	72282035 	eorvc	r2, r8, #53	; 0x35
     650:	61656c65 	cmnvs	r5, r5, ror #24
     654:	20296573 	eorcs	r6, r9, r3, ror r5
     658:	4d52415b 	ldfmie	f4, [r2, #-364]	; 0xfffffe94
     65c:	626d652f 	rsbvs	r6, sp, #197132288	; 0xbc00000
     660:	65646465 	strbvs	r6, [r4, #-1125]!	; 0x465
     664:	5f342d64 	svcpl	0x00342d64
     668:	72622d38 	rsbvc	r2, r2, #56, 26	; 0xe00
     66c:	68636e61 	stmdavs	r3!, {r0, r5, r6, r9, sl, fp, sp, lr}^
     670:	76657220 	strbtvc	r7, [r5], -r0, lsr #4
     674:	6f697369 	svcvs	0x00697369
     678:	3132206e 	teqcc	r2, lr, rrx
     67c:	37343133 			; <UNDEFINED> instruction: 0x37343133
     680:	6d2d205d 	stcvs	0, cr2, [sp, #-372]!	; 0xfffffe8c
     684:	6d756874 	ldclvs	8, cr6, [r5, #-464]!	; 0xfffffe30
     688:	6d2d2062 	stcvs	0, cr2, [sp, #-392]!	; 0xfffffe78
     68c:	3d757063 	ldclcc	0, cr7, [r5, #-396]!	; 0xfffffe74
     690:	74726f63 	ldrbtvc	r6, [r2], #-3939	; 0xf63
     694:	6d2d7865 	stcvs	8, cr7, [sp, #-404]!	; 0xfffffe6c
     698:	6d2d2033 	stcvs	0, cr2, [sp, #-204]!	; 0xffffff34
     69c:	6d756874 	ldclvs	8, cr6, [r5, #-464]!	; 0xfffffe30
     6a0:	6e692d62 	cdpvs	13, 6, cr2, cr9, cr2, {3}
     6a4:	77726574 			; <UNDEFINED> instruction: 0x77726574
     6a8:	206b726f 	rsbcs	r7, fp, pc, ror #4
     6ac:	2d20672d 	stccs	7, cr6, [r0, #-180]!	; 0xffffff4c
     6b0:	2d20734f 	stccs	3, cr7, [r0, #-316]!	; 0xfffffec4
     6b4:	6e756666 	cdpvs	6, 7, cr6, cr5, cr6, {3}
     6b8:	6f697463 	svcvs	0x00697463
     6bc:	65732d6e 	ldrbvs	r2, [r3, #-3438]!	; 0xd6e
     6c0:	6f697463 	svcvs	0x00697463
     6c4:	2d20736e 	stccs	3, cr7, [r0, #-440]!	; 0xfffffe48
     6c8:	74616466 	strbtvc	r6, [r1], #-1126	; 0x466
     6cc:	65732d61 	ldrbvs	r2, [r3, #-3425]!	; 0xd61
     6d0:	6f697463 	svcvs	0x00697463
     6d4:	6200736e 	andvs	r7, r0, #-1207959551	; 0xb8000001
     6d8:	50746e49 	rsbspl	r6, r4, r9, asr #28
     6dc:	536b6361 	cmnpl	fp, #-2080374783	; 0x84000001
     6e0:	7500464f 	strvc	r4, [r0, #-1615]	; 0x64f
     6e4:	6f506273 	svcvs	0x00506273
     6e8:	4f726577 	svcmi	0x00726577
     6ec:	43006666 	movwmi	r6, #1638	; 0x666
     6f0:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
     6f4:	74536c6f 	ldrbvc	r6, [r3], #-3183	; 0xc6f
     6f8:	00657461 	rsbeq	r7, r5, r1, ror #8
     6fc:	726f6873 	rsbvc	r6, pc, #7536640	; 0x730000
     700:	6e692074 	mcrvs	0, 3, r2, cr9, cr4, {3}
     704:	73750074 	cmnvc	r5, #116	; 0x74
     708:	74654762 	strbtvc	r4, [r5], #-1890	; 0x762
     70c:	65746e49 	ldrbvs	r6, [r4, #-3657]!	; 0xe49
     710:	63616672 	cmnvs	r1, #119537664	; 0x7200000
     714:	65520065 	ldrbvs	r0, [r2, #-101]	; 0x65
     718:	656d7573 	strbvs	r7, [sp, #-1395]!	; 0x573
     71c:	65640053 	strbvs	r0, [r4, #-83]!	; 0x53
     720:	0079616c 	rsbseq	r6, r9, ip, ror #2
     724:	45544e49 	ldrbmi	r4, [r4, #-3657]	; 0xe49
     728:	43414652 	movtmi	r4, #5714	; 0x1652
     72c:	45525f45 	ldrbmi	r5, [r2, #-3909]	; 0xf45
     730:	49504943 	ldmdbmi	r0, {r0, r1, r6, r8, fp, lr}^
     734:	00544e45 	subseq	r4, r4, r5, asr #28
     738:	79706f43 	ldmdbvc	r0!, {r0, r1, r6, r8, r9, sl, fp, sp, lr}^
     73c:	61746144 	cmnvs	r4, r4, asr #2
     740:	65735500 	ldrbvs	r5, [r3, #-1280]!	; 0x500
     744:	6c435f72 	mcrrvs	15, 7, r5, r3, cr2
     748:	46726165 	ldrbtmi	r6, [r2], -r5, ror #2
     74c:	75746165 	ldrbvc	r6, [r4, #-357]!	; 0x165
     750:	46006572 			; <UNDEFINED> instruction: 0x46006572
     754:	45534c41 	ldrbmi	r4, [r3, #-3137]	; 0xc41
     758:	47464300 	strbmi	r4, [r6, -r0, lsl #6]
     75c:	775f0052 			; <UNDEFINED> instruction: 0x775f0052
     760:	56676552 			; <UNDEFINED> instruction: 0x56676552
     764:	55006c61 	strpl	r6, [r0, #-3169]	; 0xc61
     768:	6d624253 	sfmvs	f4, 2, [r2, #-332]!	; 0xfffffeb4
     76c:	75716552 	ldrbvc	r6, [r1, #-1362]!	; 0x552
     770:	54747365 	ldrbtpl	r7, [r4], #-869	; 0x365
     774:	00657079 	rsbeq	r7, r5, r9, ror r0
     778:	636f7250 	cmnvs	pc, #80, 4
     77c:	5f737365 	svcpl	0x00737365
     780:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
     784:	4f5f7375 	svcmi	0x005f7375
     788:	73005455 	movwvc	r5, #1109	; 0x455
     78c:	74657a69 	strbtvc	r7, [r5], #-2665	; 0xa69
     790:	00657079 	rsbeq	r7, r5, r9, ror r0
     794:	61656c43 	cmnvs	r5, r3, asr #24
     798:	74535f72 	ldrbvc	r5, [r3], #-3954	; 0xf72
     79c:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
     7a0:	74754f5f 	ldrbtvc	r4, [r5], #-3935	; 0xf5f
     7a4:	5f387500 	svcpl	0x00387500
     7a8:	46627375 			; <UNDEFINED> instruction: 0x46627375
     7ac:	74636e75 	strbtvc	r6, [r3], #-3701	; 0xe75
     7b0:	616e6f69 	cmnvs	lr, r9, ror #30
     7b4:	7365446c 	cmnvc	r5, #108, 8	; 0x6c000000
     7b8:	70697263 	rsbvc	r7, r9, r3, ror #4
     7bc:	00726f74 	rsbseq	r6, r2, r4, ror pc
     7c0:	5345525f 	movtpl	r5, #21087	; 0x525f
     7c4:	00544c55 	subseq	r4, r4, r5, asr ip
     7c8:	6c727443 	cfldrdvs	mvd7, [r2], #-268	; 0xfffffef4
     7cc:	666e495f 			; <UNDEFINED> instruction: 0x666e495f
     7d0:	6573006f 	ldrbvs	r0, [r3, #-111]!	; 0x6f
     7d4:	55707574 	ldrbpl	r7, [r0, #-1396]!	; 0x574
     7d8:	67004253 	smlsdvs	r0, r3, r2, r4
     7dc:	5f6f6970 	svcpl	0x006f6970
     7e0:	74697277 	strbtvc	r7, [r9], #-631	; 0x277
     7e4:	69625f65 	stmdbvs	r2!, {r0, r2, r5, r6, r8, r9, sl, fp, ip, lr}^
     7e8:	73750074 	cmnvc	r5, #116	; 0x74
     7ec:	74614462 	strbtvc	r4, [r1], #-1122	; 0x462
     7f0:	74655361 	strbtvc	r5, [r5], #-865	; 0x361
     7f4:	43007075 	movwmi	r7, #117	; 0x75
     7f8:	49464e4f 	stmdbmi	r6, {r0, r1, r2, r3, r6, r9, sl, fp, lr}^
     7fc:	45525547 	ldrbmi	r5, [r2, #-1351]	; 0x547
     800:	49770044 	ldmdbmi	r7!, {r2, r6}^
     804:	00727473 	rsbseq	r7, r2, r3, ror r4
     808:	72727543 	rsbsvc	r7, r2, #281018368	; 0x10c00000
     80c:	5f746e65 	svcpl	0x00746e65
     810:	74616546 	strbtvc	r6, [r1], #-1350	; 0x546
     814:	00657275 	rsbeq	r7, r5, r5, ror r2
     818:	69736e75 	ldmdbvs	r3!, {r0, r2, r4, r5, r6, r9, sl, fp, sp, lr}^
     81c:	64656e67 	strbtvs	r6, [r5], #-3687	; 0xe67
     820:	61686320 	cmnvs	r8, r0, lsr #6
     824:	52650072 	rsbpl	r0, r5, #114	; 0x72
     828:	6d757365 	ldclvs	3, cr7, [r5, #-404]!	; 0xfffffe6c
     82c:	74655365 	strbtvc	r5, [r5], #-869	; 0x365
     830:	006c6156 	rsbeq	r6, ip, r6, asr r1
     834:	5f525443 	svcpl	0x00525443
     838:	6400504c 	strvs	r5, [r0], #-76	; 0x4c
     83c:	70557566 	subsvc	r7, r5, r6, ror #10
     840:	65746164 	ldrbvs	r6, [r4, #-356]!	; 0x164
     844:	65527942 	ldrbvs	r7, [r2, #-2370]	; 0x942
     848:	00746573 	rsbseq	r6, r4, r3, ror r5
     84c:	47627375 			; <UNDEFINED> instruction: 0x47627375
     850:	74537465 	ldrbvc	r7, [r3], #-1125	; 0x465
     854:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
     858:	62737500 	rsbsvs	r7, r3, #0, 10
     85c:	44746553 	ldrbtmi	r6, [r4], #-1363	; 0x553
     860:	63697665 	cmnvs	r9, #105906176	; 0x6500000
     864:	61654665 	cmnvs	r5, r5, ror #12
     868:	65727574 	ldrbvs	r7, [r2, #-1396]!	; 0x574
     86c:	62735500 	rsbsvs	r5, r3, #0, 10
     870:	664f775f 			; <UNDEFINED> instruction: 0x664f775f
     874:	74657366 	strbtvc	r7, [r5], #-870	; 0x366
     878:	45445f00 	strbmi	r5, [r4, #-3840]	; 0xf00
     87c:	45434956 	strbmi	r4, [r3, #-2390]	; 0x956
     880:	4154535f 	cmpmi	r4, pc, asr r3
     884:	55004554 	strpl	r4, [r0, #-1364]	; 0x554
     888:	4e4f434e 	cdpmi	3, 4, cr4, cr15, cr14, {2}
     88c:	5443454e 	strbpl	r4, [r3], #-1358	; 0x54e
     890:	43004445 	movwmi	r4, #1093	; 0x445
     894:	73555c3a 	cmpvc	r5, #14848	; 0x3a00
     898:	5c737265 	lfmpl	f7, 2, [r3], #-404	; 0xfffffe6c
     89c:	66696168 	strbtvs	r6, [r9], -r8, ror #2
     8a0:	68637369 	stmdavs	r3!, {r0, r3, r5, r6, r8, r9, ip, sp, lr}^
     8a4:	7365445c 	cmnvc	r5, #92, 8	; 0x5c000000
     8a8:	706f746b 	rsbvc	r7, pc, fp, ror #8
     8ac:	636e655c 	cmnvs	lr, #92, 10	; 0x17000000
     8b0:	6576616c 	ldrbvs	r6, [r6, #-364]!	; 0x16c
     8b4:	6f72705f 	svcvs	0x0072705f
     8b8:	7463656a 	strbtvc	r6, [r3], #-1386	; 0x56a
     8bc:	6f6f625c 	svcvs	0x006f625c
     8c0:	616f6c74 	smcvs	63172	; 0xf6c4
     8c4:	5c726564 	cfldr64pl	mvdx6, [r2], #-400	; 0xfffffe70
     8c8:	334d5453 	movtcc	r5, #54355	; 0xd453
     8cc:	00314632 	eorseq	r4, r1, r2, lsr r6
     8d0:	55534552 	ldrbpl	r4, [r3, #-1362]	; 0x552
     8d4:	535f454d 	cmppl	pc, #322961408	; 0x13400000
     8d8:	54524154 	ldrbpl	r4, [r2], #-340	; 0x154
     8dc:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
     8e0:	52495f43 	subpl	r5, r9, #268	; 0x10c
     8e4:	61684351 	cmnvs	r8, r1, asr r3
     8e8:	6c656e6e 	stclvs	14, cr6, [r5], #-440	; 0xfffffe48
     8ec:	50627553 	rsbpl	r7, r2, r3, asr r5
     8f0:	726f6972 	rsbvc	r6, pc, #1867776	; 0x1c8000
     8f4:	00797469 	rsbseq	r7, r9, r9, ror #8
     8f8:	72657355 	rsbvc	r7, r5, #1409286145	; 0x54000001
     8fc:	7465535f 	strbtvc	r5, [r5], #-863	; 0x35f
     900:	50646e45 	rsbpl	r6, r4, r5, asr #28
     904:	746e696f 	strbtvc	r6, [lr], #-2415	; 0x96f
     908:	74616546 	strbtvc	r6, [r1], #-1350	; 0x546
     90c:	00657275 	rsbeq	r7, r5, r5, ror r2
     910:	43627375 	cmnmi	r2, #-738197503	; 0xd4000001
     914:	7261656c 	rsbvc	r6, r1, #108, 10	; 0x1b000000
     918:	74616546 	strbtvc	r6, [r1], #-1350	; 0x546
     91c:	00657275 	rsbeq	r7, r5, r5, ror r2
     920:	4548544f 	strbmi	r5, [r8, #-1103]	; 0x44f
     924:	45525f52 	ldrbmi	r5, [r2, #-3922]	; 0xf52
     928:	49504943 	ldmdbmi	r0, {r0, r1, r6, r8, fp, lr}^
     92c:	00544e45 	subseq	r4, r4, r5, asr #28
     930:	5f363175 	svcpl	0x00363175
     934:	50003875 	andpl	r3, r0, r5, ror r8
     938:	65636f72 	strbvs	r6, [r3, #-3954]!	; 0xf72
     93c:	535f7373 	cmppl	pc, #-872415231	; 0xcc000001
     940:	75746174 	ldrbvc	r6, [r4, #-372]!	; 0x174
     944:	4e495f73 	mcrmi	15, 2, r5, cr9, cr3, {3}
     948:	6f687300 	svcvs	0x00687300
     94c:	75207472 	strvc	r7, [r0, #-1138]!	; 0x472
     950:	6769736e 	strbvs	r7, [r9, -lr, ror #6]!
     954:	2064656e 	rsbcs	r6, r4, lr, ror #10
     958:	00746e69 	rsbseq	r6, r4, r9, ror #28
     95c:	41545441 	cmpmi	r4, r1, asr #8
     960:	44454843 	strbmi	r4, [r5], #-2115	; 0x843
     964:	70457000 	subvc	r7, r5, r0
     968:	5f746e49 	svcpl	0x00746e49
     96c:	0054554f 	subseq	r5, r4, pc, asr #10
     970:	4349564e 	movtmi	r5, #38478	; 0x964e
     974:	5152495f 	cmppl	r2, pc, asr r9
     978:	6e616843 	cdpvs	8, 6, cr6, cr1, cr3, {2}
     97c:	506c656e 	rsbpl	r6, ip, lr, ror #10
     980:	6d656572 	cfstr64vs	mvdx6, [r5, #-456]!	; 0xfffffe38
     984:	6f697470 	svcvs	0x00697470
     988:	6972506e 	ldmdbvs	r2!, {r1, r2, r3, r5, r6, ip, lr}^
     98c:	7469726f 	strbtvc	r7, [r9], #-623	; 0x26f
     990:	55530079 	ldrbpl	r0, [r3, #-121]	; 0x79
     994:	4e455053 	mcrmi	0, 2, r5, cr5, cr3, {2}
     998:	00444544 	subeq	r4, r4, r4, asr #10
     99c:	45746553 	ldrbmi	r6, [r4, #-1363]!	; 0x553
     9a0:	43785250 	cmnmi	r8, #80, 4
     9a4:	746e756f 	strbtvc	r7, [lr], #-1391	; 0x56f
     9a8:	42535500 	subsmi	r5, r3, #0, 10
     9ac:	5252455f 	subspl	r4, r2, #398458880	; 0x17c00000
     9b0:	7000524f 	andvc	r5, r0, pc, asr #4
     9b4:	6e497045 	cdpvs	0, 4, cr7, cr9, cr5, {2}
     9b8:	4e495f74 	mcrmi	15, 2, r5, cr9, cr4, {3}
     9bc:	75666400 	strbvc	r6, [r6, #-1024]!	; 0x400
     9c0:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
     9c4:	616c4300 	cmnvs	ip, r0, lsl #6
     9c8:	475f7373 			; <UNDEFINED> instruction: 0x475f7373
     9cc:	495f7465 	ldmdbmi	pc, {r0, r2, r5, r6, sl, ip, sp, lr}^	; <UNPREDICTABLE>
     9d0:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
     9d4:	65636166 	strbvs	r6, [r3, #-358]!	; 0x166
     9d8:	7465535f 	strbtvc	r5, [r5], #-863	; 0x35f
     9dc:	676e6974 			; <UNDEFINED> instruction: 0x676e6974
     9e0:	69766e00 	ldmdbvs	r6!, {r9, sl, fp, sp, lr}^
     9e4:	696e4963 	stmdbvs	lr!, {r0, r1, r5, r6, r8, fp, lr}^
     9e8:	38750074 	ldmdacc	r5!, {r2, r4, r5, r6}^
     9ec:	6273755f 	rsbsvs	r7, r3, #398458880	; 0x17c00000
     9f0:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
     9f4:	6556676e 	ldrbvs	r6, [r6, #-1902]	; 0x76e
     9f8:	726f646e 	rsbvc	r6, pc, #1845493760	; 0x6e000000
     9fc:	5f387500 	svcpl	0x00387500
     a00:	53627375 	cmnpl	r2, #-738197503	; 0xd4000001
     a04:	6e697274 	mcrvs	2, 3, r7, cr9, cr4, {3}
     a08:	746e4967 	strbtvc	r4, [lr], #-2407	; 0x967
     a0c:	61667265 	cmnvs	r6, r5, ror #4
     a10:	75006563 	strvc	r6, [r0, #-1379]	; 0x563
     a14:	73755f38 	cmnvc	r5, #56, 30	; 0xe0
     a18:	72745362 	rsbsvc	r5, r4, #-2013265919	; 0x88000001
     a1c:	41676e69 	cmnmi	r7, r9, ror #28
     a20:	0031746c 	eorseq	r7, r1, ip, ror #8
     a24:	755f3875 	ldrbvc	r3, [pc, #-2165]	; 1b7 <_Minimum_Stack_Size+0xb7>
     a28:	65446273 	strbvs	r6, [r4, #-627]	; 0x273
     a2c:	65636976 	strbvs	r6, [r3, #-2422]!	; 0x976
     a30:	63736544 	cmnvs	r3, #68, 10	; 0x11000000
     a34:	74706972 	ldrbtvc	r6, [r0], #-2418	; 0x972
     a38:	4644726f 	strbmi	r7, [r4], -pc, ror #4
     a3c:	38750055 	ldmdacc	r5!, {r0, r2, r4, r6}^
     a40:	6273755f 	rsbsvs	r7, r3, #398458880	; 0x17c00000
     a44:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
     a48:	6c41676e 	mcrrvs	7, 6, r6, r1, cr14
     a4c:	75003274 	strvc	r3, [r0, #-628]	; 0x274
     a50:	73755f38 	cmnvc	r5, #56, 30	; 0xe0
     a54:	72745362 	rsbsvc	r5, r4, #-2013265919	; 0x88000001
     a58:	53676e69 	cmnpl	r7, #1680	; 0x690
     a5c:	61697265 	cmnvs	r9, r5, ror #4
     a60:	3875006c 	ldmdacc	r5!, {r2, r3, r5, r6}^
     a64:	6273755f 	rsbsvs	r7, r3, #398458880	; 0x17c00000
     a68:	69727453 	ldmdbvs	r2!, {r0, r1, r4, r6, sl, ip, sp, lr}^
     a6c:	6c41676e 	mcrrvs	7, 6, r6, r1, cr14
     a70:	75003074 	strvc	r3, [r0, #-116]	; 0x74
     a74:	73755f38 	cmnvc	r5, #56, 30	; 0xe0
     a78:	72745362 	rsbsvc	r5, r4, #-2013265919	; 0x88000001
     a7c:	50676e69 	rsbpl	r6, r7, r9, ror #28
     a80:	75646f72 	strbvc	r6, [r4, #-3954]!	; 0xf72
     a84:	75007463 	strvc	r7, [r0, #-1123]	; 0x463
     a88:	73755f38 	cmnvc	r5, #56, 30	; 0xe0
     a8c:	72745362 	rsbsvc	r5, r4, #-2013265919	; 0x88000001
     a90:	4c676e69 	stclmi	14, cr6, [r7], #-420	; 0xfffffe5c
     a94:	49676e61 	stmdbmi	r7!, {r0, r5, r6, r9, sl, fp, sp, lr}^
     a98:	73750064 	cmnvc	r5, #100	; 0x64
     a9c:	65645f62 	strbvs	r5, [r4, #-3938]!	; 0xf62
     aa0:	69726373 	ldmdbvs	r2!, {r0, r1, r4, r5, r6, r8, r9, sp, lr}^
     aa4:	726f7470 	rsbvc	r7, pc, #112, 8	; 0x70000000
     aa8:	7200632e 	andvc	r6, r0, #-1207959552	; 0xb8000000
     aac:	50646165 	rsbpl	r6, r4, r5, ror #2
     ab0:	75006e69 	strvc	r6, [r0, #-3689]	; 0xe69
     ab4:	5f747261 	svcpl	0x00747261
     ab8:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     abc:	5f006674 	svcpl	0x00006674
     ac0:	6e69755f 	mcrvs	5, 3, r7, cr9, cr15, {2}
     ac4:	5f323374 	svcpl	0x00323374
     ac8:	68690074 	stmdavs	r9!, {r2, r4, r5, r6}^
     acc:	66667542 	strbtvs	r7, [r6], -r2, asr #10
     ad0:	654c7265 	strbvs	r7, [ip, #-613]	; 0x265
     ad4:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
     ad8:	755f5f00 	ldrbvc	r5, [pc, #-3840]	; fffffbe0 <BootRAM+0xef70381>
     adc:	38746e69 	ldmdacc	r4!, {r0, r3, r5, r6, r9, sl, fp, sp, lr}^
     ae0:	7300745f 	movwvc	r7, #1119	; 0x45f
     ae4:	5f657a69 	svcpl	0x00657a69
     ae8:	66640074 			; <UNDEFINED> instruction: 0x66640074
     aec:	6e694675 	mcrvs	6, 3, r4, cr9, cr5, {3}
     af0:	55687369 	strbpl	r7, [r8, #-873]!	; 0x369
     af4:	616f6c70 	smcvs	63168	; 0xf6c0
     af8:	68690064 	stmdavs	r9!, {r2, r5, r6}^
     afc:	6e676953 	mcrvs	9, 3, r6, cr7, cr3, {2}
     b00:	654c6465 	strbvs	r6, [ip, #-1125]	; 0x465
     b04:	6874676e 	ldmdavs	r4!, {r1, r2, r3, r5, r6, r8, r9, sl, sp, lr}^
     b08:	53686900 	cmnpl	r8, #0, 18
     b0c:	4470696b 	ldrbtmi	r6, [r0], #-2411	; 0x96b
     b10:	61747369 	cmnvs	r4, r9, ror #6
     b14:	0065636e 	rsbeq	r6, r5, lr, ror #6
     b18:	67616d69 	strbvs	r6, [r1, -r9, ror #26]!
     b1c:	6e614865 	cdpvs	8, 6, cr4, cr1, cr5, {3}
     b20:	00656c64 	rsbeq	r6, r5, r4, ror #24
     b24:	75746573 	ldrbvc	r6, [r4, #-1395]!	; 0x573
     b28:	44454c70 	strbmi	r4, [r5], #-3184	; 0xc70
     b2c:	42646e41 	rsbmi	r6, r4, #1040	; 0x410
     b30:	6f747475 	svcvs	0x00747475
     b34:	616c006e 	cmnvs	ip, lr, rrx
     b38:	61547473 	cmpvs	r4, r3, ror r4
     b3c:	6f640067 	svcvs	0x00640067
     b40:	775f746e 	ldrbvc	r7, [pc, -lr, ror #8]
     b44:	00746961 	rsbseq	r6, r4, r1, ror #18
     b48:	74726175 	ldrbtvc	r6, [r2], #-373	; 0x175
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
  b	LoopCopyDataInit
     b50:	4d686900 	stclmi	9, cr6, [r8, #-0]

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
     b54:	63696761 	cmnvs	r9, #25427968	; 0x1840000
	str	r3, [r0, r1]
	adds	r1, r1, #4
     b58:	6d495f00 	stclvs	15, cr5, [r9, #-0]

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
     b5c:	4f656761 	svcmi	0x00656761
	adds	r2, r0, r1
	cmp	r2, r3
     b60:	63656a62 	cmnvs	r5, #401408	; 0x62000
	bcc	CopyDataInit
     b64:	61654874 	smcvs	21636	; 0x5484
	ldr	r2, =_sbss
	b	LoopFillZerobss
     b68:	00726564 	rsbseq	r6, r2, r4, ror #10
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	67616d69 	strbvs	r6, [r1, -r9, ror #26]!
	str	r3, [r2], #4
     b70:	65684365 	strbvs	r4, [r8, #-869]!	; 0x365

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
     b74:	72466b63 	subvc	r6, r6, #101376	; 0x18c00
	bcc	FillZerobss
     b78:	64416d6f 	strbvs	r6, [r1], #-3439	; 0xd6f
/* Call the application's entry point.*/
	bl	main
     b7c:	73657264 	cmnvc	r5, #100, 4	; 0x40000006
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
     b80:	74730073 	ldrbtvc	r0, [r3], #-115	; 0x73
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	65626f72 	strbvs	r6, [r2, #-3954]!	; 0xf72
	ldr	r3, =_edata
     b88:	006e6950 	rsbeq	r6, lr, r0, asr r9
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	67616d69 	strbvs	r6, [r1, -r9, ror #26]!
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	756a0065 	strbvc	r0, [sl, #-101]!	; 0x65
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	6f54706d 	svcvs	0x0054706d
}


/* dummy proc */
void nothingProc(void)
{
     b98:	72657355 	rsbvc	r7, r5, #1409286145	; 0x54000001
{
    return;
}

void usbStatusOut(void)
{
     b9c:	73797300 	cmnvc	r9, #0, 6
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
     ba0:	526d6574 	rsbpl	r6, sp, #116, 10	; 0x1d000000
     ba4:	74657365 	strbtvc	r7, [r5], #-869	; 0x365
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
     ba8:	72756300 	rsbsvc	r6, r5, #0, 6
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
     bac:	00726f73 	rsbseq	r6, r2, r3, ror pc
     bb0:	75426869 	strbvc	r6, [r2, #-2153]	; 0x869
        bDeviceState = CONFIGURED;
     bb4:	72656666 	rsbvc	r6, r5, #106954752	; 0x6600000
     bb8:	54686900 	strbtpl	r6, [r8], #-2304	; 0x900
     bbc:	00657079 	rsbeq	r7, r5, r9, ror r0
     bc0:	75746573 	ldrbvc	r6, [r4, #-1395]!	; 0x573
    }
}

void usbGetInterface(void)
{
     bc4:	414c4670 	hvcmi	50272	; 0xc460
{
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	66004853 			; <UNDEFINED> instruction: 0x66004853
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	7367616c 	cmnvc	r7, #108, 2
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	74657300 	strbtvc	r7, [r5], #-768	; 0x300
     bd4:	4c437075 	mcrrmi	0, 7, r7, r3, cr5
     bd8:	6f6e004b 	svcvs	0x006e004b
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	6573755f 	ldrbvs	r7, [r3, #-1375]!	; 0x55f
    dfuUpdateByReset();
     be0:	756a5f72 	strbvc	r5, [sl, #-3954]!	; 0xf72

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	5f00706d 	svcpl	0x0000706d

void usbReset(void)
{    
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
     be8:	67616d49 	strbvs	r6, [r1, -r9, asr #26]!
     bec:	746e4965 	strbtvc	r4, [lr], #-2405	; 0x965
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	616e7265 	cmnvs	lr, r5, ror #4
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	6174536c 	cmnvs	r4, ip, ror #6
     bf8:	6d006574 	cfstr32vs	mvfx6, [r0, #-464]	; 0xfffffe30

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfc:	2e6e6961 	cdpcs	9, 6, cr6, cr14, cr1, {3}
     c00:	616d0063 	cmnvs	sp, r3, rrx
     c04:	49006e69 	stmdbmi	r0, {r0, r3, r5, r6, r9, sl, fp, sp, lr}
     c08:	6567616d 	strbvs	r6, [r7, #-365]!	; 0x16d
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c0c:	656a624f 	strbvs	r6, [sl, #-591]!	; 0x24f
     c10:	61487463 	cmpvs	r8, r3, ror #8
     c14:	656c646e 	strbvs	r6, [ip, #-1134]!	; 0x46e
     c18:	6c656400 	cfstrdvs	mvd6, [r5], #-0
     c1c:	635f7961 	cmpvs	pc, #1589248	; 0x184000

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c20:	746e756f 	strbtvc	r7, [lr], #-1391	; 0x56f
     c24:	6c6c6100 	stfvse	f6, [ip], #-0
     c28:	6953636f 	ldmdbvs	r3, {r0, r1, r2, r3, r5, r6, r8, r9, sp, lr}^
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c2c:	6400657a 	strvs	r6, [r0], #-1402	; 0x57a
     c30:	70557566 	subsvc	r7, r5, r6, ror #10
     c34:	64616f6c 	strbtvs	r6, [r1], #-3948	; 0xf6c
     c38:	72617453 	rsbvc	r7, r1, #1392508928	; 0x53000000
     c3c:	00646574 	rsbeq	r6, r4, r4, ror r5

    Clear_Status_Out(ENDP0);
     c40:	73616c66 	cmnvc	r1, #26112	; 0x6600

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c44:	61724568 	cmnvs	r2, r8, ror #10
     c48:	61506573 	cmpvs	r0, r3, ror r5
     c4c:	42006567 	andmi	r6, r0, #432013312	; 0x19c00000
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	00525253 	subseq	r5, r2, r3, asr r2
     c54:	4f495047 	svcmi	0x00495047

    bDeviceState = ATTACHED;
     c58:	646f4d5f 	strbtvs	r4, [pc], #-3423	; c60 <usbReset+0x84>
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
     c5c:	50470065 	subpl	r0, r7, r5, rrx

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	505f4f49 	subspl	r4, pc, r9, asr #30
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c64:	73006e69 	movwvc	r6, #3689	; 0xe69
     c68:	65747379 	ldrbvs	r7, [r4, #-889]!	; 0x379
     c6c:	7261486d 	rsbvc	r4, r1, #7143424	; 0x6d0000
     c70:	73655264 	cmnvc	r5, #100, 4	; 0x40000006
     c74:	62007465 	andvs	r7, r0, #1694498816	; 0x65000000
     c78:	3031706b 	eorscc	r7, r1, fp, rrx
     c7c:	74697257 	strbtvc	r7, [r9], #-599	; 0x257
     c80:	4e720065 	cdpmi	0, 7, cr0, cr2, cr5, {3}
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
     c84:	00434956 	subeq	r4, r3, r6, asr r9
     c88:	636e7546 	cmnvs	lr, #293601280	; 0x11800000
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8c:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
     c90:	74536c61 	ldrbvc	r6, [r3], #-3169	; 0xc61
     c94:	00657461 	rsbeq	r7, r5, r1, ror #8
        if (dfuUpdateByRequest()) {
     c98:	63656863 	cmnvs	r5, #6488064	; 0x630000
     c9c:	646e416b 	strbtvs	r4, [lr], #-363	; 0x16b
            // successfull state transition, handle the request
            switch (request) {
     ca0:	61656c43 	cmnvs	r5, r3, asr #24
     ca4:	6f6f4272 	svcvs	0x006f4272
     ca8:	616f6c74 	smcvs	63172	; 0xf6c4
     cac:	46726564 	ldrbtmi	r6, [r2], -r4, ror #10
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	0067616c 	rsbeq	r6, r7, ip, ror #2
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
     cb4:	52534644 	subspl	r4, r3, #68, 12	; 0x4400000
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
     cb8:	69766e00 	ldmdbvs	r6!, {r9, sl, fp, sp, lr}^
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
     cbc:	73694463 	cmnvc	r9, #1660944384	; 0x63000000
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
     cc0:	656c6261 	strbvs	r6, [ip, #-609]!	; 0x261
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	65746e49 	ldrbvs	r6, [r4, #-3657]!	; 0xe49
        (*CopyRoutine)(0);

        return USB_SUCCESS;
     cc8:	70757272 	rsbsvc	r7, r5, r2, ror r2
    }

    return USB_UNSUPPORT;
     ccc:	55007374 	strpl	r7, [r0, #-884]	; 0x374
}
     cd0:	54524153 	ldrbpl	r4, [r2], #-339	; 0x153
     cd4:	726f575f 	rsbvc	r5, pc, #24903680	; 0x17c0000
     cd8:	6e654c64 	cdpvs	12, 6, cr4, cr5, cr4, {3}
     cdc:	00687467 	rsbeq	r7, r8, r7, ror #8
     ce0:	64726168 	ldrbtvs	r6, [r2], #-360	; 0x168
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	65726177 	ldrbvs	r6, [r2, #-375]!	; 0x177
     ce8:	5500632e 	strpl	r6, [r0, #-814]	; 0x32e
     cec:	54524153 	ldrbpl	r4, [r2], #-339	; 0x153
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
     cf0:	6f74535f 	svcvs	0x0074535f
     cf4:	74694270 	strbtvc	r4, [r9], #-624	; 0x270
     cf8:	77700073 			; <UNDEFINED> instruction: 0x77700073
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	65725f72 	ldrbvs	r5, [r2, #-3954]!	; 0xf72
     d00:	616d5f67 	cmnvs	sp, r7, ror #30
    if (strIndex > STR_DESC_LEN) {
     d04:	73760070 	cmnvc	r6, #112	; 0x70
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d08:	6e697270 	mcrvs	2, 3, r7, cr9, cr0, {3}
     d0c:	47006674 	smlsdxmi	r0, r4, r6, r6
    }
}
     d10:	5f4f4950 	svcpl	0x004f4950
     d14:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
     d18:	706d7400 	rsbvc	r7, sp, r0, lsl #8

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
     d1c:	6b73616d 	blvs	1cd92d8 <_etext+0x1cd1cc4>
     d20:	78656800 	stmdavc	r5!, {fp, sp, lr}^
     d24:	706d7564 	rsbvc	r7, sp, r4, ror #10

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
     d28:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2c:	70535f4f 	subsvc	r5, r3, pc, asr #30
     d30:	5f646565 	svcpl	0x00646565
     d34:	7a484d32 	bvc	1214204 <_etext+0x120cbf0>
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	50544700 	subspl	r4, r4, r0, lsl #14
     d3c:	6e6f0052 	mcrvs	0, 3, r0, cr15, cr2, {2}
            return USB_SUCCESS;
     d40:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
     d44:	53550065 	cmppl	r5, #101	; 0x65
        }
    }
    return USB_UNSUPPORT;
}
     d48:	5f545241 	svcpl	0x00545241
     d4c:	64756142 	ldrbtvs	r6, [r5], #-322	; 0x142

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	65746152 	ldrbvs	r6, [r4, #-338]!	; 0x152
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d54:	45534900 	ldrbmi	r4, [r3, #-2304]	; 0x900
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	53520052 	cmppl	r2, #82	; 0x52
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5c:	45565245 	ldrbmi	r5, [r6, #-581]	; 0x245
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d60:	47003144 	strmi	r3, [r0, -r4, asr #2]
     d64:	5f4f4950 	svcpl	0x004f4950
     d68:	65657053 	strbvs	r7, [r5, #-83]!	; 0x53
     d6c:	30315f64 	eorscc	r5, r1, r4, ror #30
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d70:	007a484d 	rsbseq	r4, sl, sp, asr #16
     d74:	5f706b62 	svcpl	0x00706b62
     d78:	5f676572 	svcpl	0x00676572
     d7c:	0070616d 	rsbseq	r6, r0, sp, ror #2
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d80:	5f646975 	svcpl	0x00646975
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	64616572 	strbtvs	r6, [r1], #-1394	; 0x572
     d88:	69727000 	ldmdbvs	r2!, {ip, sp, lr}^
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8c:	685f746e 	ldmdavs	pc, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^	; <UNPREDICTABLE>
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d90:	00687361 	rsbeq	r7, r8, r1, ror #6
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d94:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
     d98:	61505f54 	cmpvs	r0, r4, asr pc

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
     d9c:	79746972 	ldmdbvc	r4!, {r1, r4, r5, r6, r8, fp, sp, lr}^
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	755f5f00 	ldrbvc	r5, [pc, #-3840]	; fffffea8 <BootRAM+0xef70649>
     da4:	31746e69 	cmncc	r4, r9, ror #28
     da8:	00745f36 	rsbseq	r5, r4, r6, lsr pc
     dac:	52415355 	subpl	r5, r1, #1409286145	; 0x54000001
     db0:	6e495f54 	mcrvs	15, 2, r5, cr9, cr4, {2}
     db4:	47007469 	strmi	r7, [r0, -r9, ror #8]
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     db8:	5f4f4950 	svcpl	0x004f4950
     dbc:	65646f4d 	strbvs	r6, [r4, #-3917]!	; 0xf4d
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dc0:	4450495f 	ldrbmi	r4, [r0], #-2399	; 0x95f

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	6c617600 	stclvs	6, cr7, [r1], #-0
     dc8:	47006575 	smlsdxmi	r0, r5, r5, r6
     dcc:	5f4f4950 	svcpl	0x004f4950
     dd0:	65646f4d 	strbvs	r6, [r4, #-3917]!	; 0xf4d
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
     dd4:	5550495f 	ldrbpl	r4, [r0, #-2399]	; 0x95f
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd8:	675f5f00 	ldrbvs	r5, [pc, -r0, lsl #30]
     ddc:	5f63756e 	svcpl	0x0063756e

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	6c5f6176 	ldfvse	f6, [pc], {118}	; 0x76
     de4:	00747369 	rsbseq	r7, r4, r9, ror #6
     de8:	49555043 	ldmdbmi	r5, {r0, r1, r6, ip, lr}^
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	6d740044 	ldclvs	0, cr0, [r4, #-272]!	; 0xfffffef0
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	67657270 			; <UNDEFINED> instruction: 0x67657270
        ResumeS.eState = eResumeSetVal;
     df4:	50485300 	subpl	r5, r8, r0, lsl #6

    switch (ResumeS.eState) {
     df8:	46410052 			; <UNDEFINED> instruction: 0x46410052
     dfc:	55005253 	strpl	r5, [r0, #-595]	; 0x253
     e00:	54524153 	ldrbpl	r4, [r2], #-339	; 0x153
     e04:	7079545f 	rsbsvc	r5, r9, pc, asr r4
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	66654465 	strbtvs	r4, [r5], -r5, ror #8
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	42504100 	subsmi	r4, r0, #0, 2
        ResumeS.eState = RESUME_START;
     e10:	54535231 	ldrbpl	r5, [r3], #-561	; 0x231
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	46480052 			; <UNDEFINED> instruction: 0x46480052
        ResumeS.eState = RESUME_WAIT;
     e18:	66005253 			; <UNDEFINED> instruction: 0x66005253
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	6873616c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, sp, lr}^
     e20:	74697257 	strbtvc	r7, [r9], #-599	; 0x257
        if (ResumeS.bESOFcnt == 0)
     e24:	726f5765 	rsbvc	r5, pc, #26476544	; 0x1940000
            ResumeS.eState = RESUME_START;
     e28:	53550064 	cmppl	r5, #100	; 0x64
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	5f545241 	svcpl	0x00545241
     e30:	74696e49 	strbtvc	r6, [r9], #-3657	; 0xe49
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e34:	75727453 	ldrbvc	r7, [r2, #-1107]!	; 0x453
        ResumeS.eState = RESUME_ON;
     e38:	72757463 	rsbsvc	r7, r5, #1660944384	; 0x63000000
        ResumeS.bESOFcnt = 10;
     e3c:	50470065 	subpl	r0, r7, r5, rrx
        break;
     e40:	4d5f4f49 	ldclmi	15, cr4, [pc, #-292]	; d24 <usbGetFunctionalDescriptor+0x8>
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e44:	5f65646f 	svcpl	0x0065646f
     e48:	5f74754f 	svcpl	0x0074754f
        if (ResumeS.bESOFcnt == 0) {
     e4c:	72005050 	andvc	r5, r0, #80	; 0x50
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	00657461 	rsbeq	r7, r5, r1, ror #8
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	41534944 	cmpmi	r3, r4, asr #18
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e58:	00454c42 	subeq	r4, r5, r2, asr #24
            ResumeS.eState = RESUME_OFF;
     e5c:	43524941 	cmpmi	r2, #1064960	; 0x104000
     e60:	75660052 	strbvc	r0, [r6, #-82]!	; 0x52
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e64:	7450636e 	ldrbvc	r6, [r0], #-878	; 0x36e
     e68:	74730072 	ldrbtvc	r0, [r3], #-114	; 0x72
     e6c:	676e6972 			; <UNDEFINED> instruction: 0x676e6972
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	616c6600 	cmnvs	ip, r0, lsl #12
     e74:	6e556873 	mrcvs	8, 2, r6, cr5, cr3, {3}
     e78:	6b636f6c 	blvs	18dcc30 <_etext+0x18d561c>
     e7c:	74616400 	strbtvc	r6, [r1], #-1024	; 0x400

    _SetCNTR(CNTR_FRES);
     e80:	6d740061 	ldclvs	0, cr0, [r4, #-388]!	; 0xfffffe7c
     e84:	65727070 	ldrbvs	r7, [r2, #-112]!	; 0x70
     e88:	41535500 	cmpmi	r3, r0, lsl #10
     e8c:	4d5f5452 	cfldrdmi	mvd5, [pc, #-328]	; d4c <usbNoDataSetup+0x24>
    _SetCNTR(0);
    _SetISTR(0);
     e90:	0065646f 	rsbeq	r6, r5, pc, ror #8

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e94:	566d7772 			; <UNDEFINED> instruction: 0x566d7772
    _SetCNTR(wInterrupt_Mask);
     e98:	66006c61 	strvs	r6, [r0], -r1, ror #24
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9c:	5367616c 	cmnpl	r7, #108, 2
     ea0:	75007465 	strvc	r7, [r0, #-1125]	; 0x465
#endif
#endif

    return USB_SUCCESS;
}
     ea4:	64417273 	strbvs	r7, [r1], #-627	; 0x273
     ea8:	53007264 	movwpl	r7, #612	; 0x264
     eac:	52534348 	subspl	r4, r3, #72, 6	; 0x20000001
     eb0:	41535500 	cmpmi	r3, r0, lsl #10
     eb4:	485f5452 	ldmdami	pc, {r1, r4, r6, sl, ip, lr}^	; <UNPREDICTABLE>

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	77647261 	strbvc	r7, [r4, -r1, ror #4]!
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	46657261 	strbtmi	r7, [r5], -r1, ror #4
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
     ec0:	43776f6c 	cmnmi	r7, #108, 30	; 0x1b0
     ec4:	72746e6f 	rsbsvc	r6, r4, #1776	; 0x6f0
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec8:	43006c6f 	movwmi	r6, #3183	; 0xc6f
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     ecc:	00525346 	subseq	r5, r2, r6, asr #6
     ed0:	505f5555 	subspl	r5, pc, r5, asr r5	; <UNPREDICTABLE>
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	74537475 	ldrbvc	r7, [r3], #-1141	; 0x475
     ed8:	676e6972 			; <UNDEFINED> instruction: 0x676e6972
     edc:	615f5f00 	cmpvs	pc, r0, lsl #30

    return USB_SUCCESS;
}
     ee0:	73750070 	cmnvc	r5, #112	; 0x70
     ee4:	69614d72 	stmdbvs	r1!, {r1, r4, r5, r6, r8, sl, fp, lr}^
     ee8:	6567006e 	strbvs	r0, [r7, #-110]!	; 0x6e
     eec:	616c4674 	smcvs	50276	; 0xc464
     ef0:	6e456873 	mcrvs	8, 2, r6, cr5, cr3, {3}
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	6c660064 	stclvs	0, cr0, [r6], #-400	; 0xfffffe70
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	53687361 	cmnpl	r8, #-2080374783	; 0x84000001
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efc:	00657a69 	rsbeq	r7, r5, r9, ror #20
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	4f495047 	svcmi	0x00495047
     f04:	696e495f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, lr}^
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f08:	72745374 	rsbsvc	r5, r4, #116, 6	; 0xd0000001
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	75746375 	ldrbvc	r6, [r4, #-885]!	; 0x375
     f10:	44006572 	strmi	r6, [r0], #-1394	; 0x572
    nvicInit(&NVIC_InitStructure);
     f14:	00303152 	eorseq	r3, r0, r2, asr r1
}
     f18:	52504349 	subspl	r4, r0, #603979777	; 0x24000001

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	43435200 	movtmi	r5, #12800	; 0x3200
    dfuInit();
     f20:	6765525f 			; <UNDEFINED> instruction: 0x6765525f

    pInformation->Current_Configuration = 0;
     f24:	75727453 	ldrbvc	r7, [r2, #-1107]!	; 0x453
     f28:	47007463 	strmi	r7, [r0, -r3, ror #8]
    usbPowerOn();
     f2c:	5f4f4950 	svcpl	0x004f4950

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
     f30:	65646f4d 	strbvs	r6, [r4, #-3917]!	; 0xf4d
     f34:	5f46415f 	svcpl	0x0046415f
     f38:	7200444f 	andvc	r4, r0, #1325400064	; 0x4f000000
    _SetCNTR(wInterrupt_Mask);
     f3c:	00424353 	subeq	r4, r2, r3, asr r3

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f40:	70677261 	rsbvc	r7, r7, r1, ror #4
    bDeviceState = UNCONNECTED;
     f44:	695f7500 	ldmdbvs	pc, {r8, sl, ip, sp, lr}^	; <UNPREDICTABLE>
     f48:	6c660064 	stclvs	0, cr0, [r6], #-400	; 0xfffffe70
     f4c:	45687361 	strbmi	r7, [r8, #-865]!	; 0x361
     f50:	65736172 	ldrbvs	r6, [r3, #-370]!	; 0x172
     f54:	65676150 	strbvs	r6, [r7, #-336]!	; 0x150
     f58:	70760073 	rsbsvc	r0, r6, r3, ror r0
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	746e6972 	strbtvc	r6, [lr], #-2418	; 0x972
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f60:	41535500 	cmpmi	r3, r0, lsl #10
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	00785452 	rsbseq	r5, r8, r2, asr r4

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f68:	41464d4d 	cmpmi	r6, sp, asr #26
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	50470052 	subpl	r0, r7, r2, asr r0
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	4d5f4f49 	ldclmi	15, cr4, [pc, #-292]	; e54 <usbResume+0x68>
    nvicInit(&NVIC_InitStructure);
     f74:	5f65646f 	svcpl	0x0065646f
}
     f78:	004e4941 	subeq	r4, lr, r1, asr #18
     f7c:	45534552 	ldrbmi	r4, [r3, #-1362]	; 0x552

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	44455652 	strbmi	r5, [r5], #-1618	; 0x652
    wIstr = _GetISTR();
     f84:	45520030 	ldrbmi	r0, [r2, #-48]	; 0x30

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	56524553 			; <UNDEFINED> instruction: 0x56524553
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8c:	00314445 	eorseq	r4, r1, r5, asr #8

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f90:	45534552 	ldrbmi	r4, [r3, #-1362]	; 0x552
     f94:	44455652 	strbmi	r5, [r5], #-1618	; 0x652
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	45520032 	ldrbmi	r0, [r2, #-50]	; 0x32
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	56524553 			; <UNDEFINED> instruction: 0x56524553
     fa0:	00334445 	eorseq	r4, r3, r5, asr #8
     fa4:	45534552 	ldrbmi	r4, [r3, #-1362]	; 0x552
        _SetISTR((u16)CLR_RESET);
     fa8:	44455652 	strbmi	r5, [r5], #-1618	; 0x652
        Device_Property.Reset();
     fac:	45520034 	ldrbmi	r0, [r2, #-52]	; 0x34
     fb0:	56524553 			; <UNDEFINED> instruction: 0x56524553
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb4:	00354445 	eorseq	r4, r5, r5, asr #8
     fb8:	45534552 	ldrbmi	r4, [r3, #-1362]	; 0x552
        _SetISTR((u16)CLR_ERR);
     fbc:	44455652 	strbmi	r5, [r5], #-1618	; 0x652
     fc0:	45520036 	ldrbmi	r0, [r2, #-54]	; 0x36
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc4:	56524553 			; <UNDEFINED> instruction: 0x56524553
     fc8:	00384445 	eorseq	r4, r8, r5, asr #8
        _SetISTR((u16)CLR_WKUP);
     fcc:	45534552 	ldrbmi	r4, [r3, #-1362]	; 0x552
        usbResume(RESUME_EXTERNAL);
     fd0:	44455652 	strbmi	r5, [r5], #-1618	; 0x652
     fd4:	50470039 	subpl	r0, r7, r9, lsr r0
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd8:	4d5f4f49 	ldclmi	15, cr4, [pc, #-292]	; ebc <usbPowerOff+0x4>
     fdc:	5f65646f 	svcpl	0x0065646f

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	505f4641 	subspl	r4, pc, r1, asr #12
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	50470050 	subpl	r0, r7, r0, asr r0
     fe8:	535f4f49 	cmppl	pc, #292	; 0x124
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fec:	64656570 	strbtvs	r6, [r5], #-1392	; 0x570
     ff0:	6d656d00 	stclvs	13, cr6, [r5, #-0]
        _SetISTR((u16)CLR_SOF);
     ff4:	00746573 	rsbseq	r6, r4, r3, ror r5
     ff8:	505f5555 	subspl	r5, pc, r5, asr r5	; <UNPREDICTABLE>
        bIntPackSOF++;
     ffc:	68437475 	stmdavs	r3, {r0, r2, r4, r5, r6, sl, ip, sp, lr}^
    1000:	66007261 	strvs	r7, [r0], -r1, ror #4
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1004:	6873616c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, sp, lr}^
    1008:	6b636f4c 	blvs	18dcd40 <_etext+0x18d572c>
        _SetISTR((u16)CLR_ESOF);
    100c:	726f7700 	rsbvc	r7, pc, #0, 14
    1010:	666f0064 	strbtvs	r0, [pc], -r4, rrx
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    }
#endif

}
    1014:	73003266 	movwvc	r3, #614	; 0x266
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	734d7465 	movtvc	r7, #54373	; 0xd465
    101c:	646e4170 	strbtvs	r4, [lr], #-368	; 0x170
    1020:	706d754a 	rsbvc	r7, sp, sl, asr #10
    1024:	41464200 	mrsmi	r4, (UNDEF: 102)
    1028:	50470052 	subpl	r0, r7, r2, asr r0
    102c:	545f4f49 	ldrbpl	r4, [pc], #-3913	; 1034 <main>
    1030:	44657079 	strbtmi	r7, [r5], #-121	; 0x79
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
    1034:	56006665 	strpl	r6, [r0], -r5, ror #12
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    1038:	00524f54 	subseq	r4, r2, r4, asr pc
    setupCLK();
    103c:	4f495047 	svcmi	0x00495047
    setupLEDAndButton();
    1040:	65646f4d 	strbvs	r6, [r4, #-3917]!	; 0xf4d
    setupUSB();
    1044:	7079545f 	rsbsvc	r5, r9, pc, asr r4
    setupFLASH();
    1048:	66654465 	strbtvs	r4, [r5], -r5, ror #8
    uartInit();
    104c:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
    usbReset();
    1050:	79545f43 	ldmdbvc	r4, {r0, r1, r6, r8, r9, sl, fp, ip, lr}^
	uart_printf("\nBootloader init...\n");
    1054:	65446570 	strbvs	r6, [r4, #-1392]	; 0x570
    1058:	6d740066 	ldclvs	0, cr0, [r4, #-408]!	; 0xfffffe68

    if (readPin(GPIOB, 15) == 0x0)
    105c:	62757370 	rsbsvs	r7, r5, #112, 6	; 0xc0000001
    1060:	765f5f00 	ldrbvc	r5, [pc], -r0, lsl #30
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1064:	696c5f61 	stmdbvs	ip!, {r0, r5, r6, r8, r9, sl, fp, ip, lr}^
    1068:	45007473 	strmi	r7, [r0, #-1139]	; 0x473
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    106c:	4c42414e 	stfmie	f4, [r2], {78}	; 0x4e
    1070:	43490045 	movtmi	r0, #36933	; 0x9045
    1074:	6f005253 	svcvs	0x00005253
    
    debug_print("image check ret: %X\n", ret);
    1078:	00306666 	eorseq	r6, r0, r6, ror #12
    107c:	5f424353 	svcpl	0x00424353
	switch (ret)
    1080:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
    1084:	00666544 	rsbeq	r6, r6, r4, asr #10
    1088:	3466666f 	strbtcc	r6, [r6], #-1647	; 0x66f

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
	bool no_user_jump = FALSE;
    108c:	66666f00 	strbtvs	r6, [r6], -r0, lsl #30
    1090:	50470038 	subpl	r0, r7, r8, lsr r0
    1094:	495f4f49 	ldmdbmi	pc, {r0, r3, r6, r8, r9, sl, fp, lr}^	; <UNPREDICTABLE>
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1098:	5474696e 	ldrbtpl	r6, [r4], #-2414	; 0x96e
			no_user_jump = FALSE;
    109c:	44657079 	strbtmi	r7, [r5], #-121	; 0x79
			break;

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    10a0:	66006665 	strvs	r6, [r0], -r5, ror #12
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    10a4:	6873616c 	ldmdavs	r3!, {r2, r3, r5, r6, r8, sp, lr}^
			no_user_jump = TRUE;
			break;

		case kImageImageHashCalcFailed:
			uart_printf("Hash calculation failed... waiting in DFU\n");
    10a8:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
    10ac:	49564e00 	ldmdbmi	r6, {r9, sl, fp, lr}^
			break;
			
		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10b0:	6e495f43 	cdpvs	15, 4, cr5, cr9, cr3, {2}
    10b4:	74537469 	ldrbvc	r7, [r3], #-1129	; 0x469
    10b8:	74637572 	strbtvc	r7, [r3], #-1394	; 0x572
    10bc:	49504700 	ldmdbmi	r0, {r8, r9, sl, lr}^
    10c0:	70535f4f 	subsvc	r5, r3, pc, asr #30

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10c4:	5f646565 	svcpl	0x00646565
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10c8:	484d3035 	stmdami	sp, {r0, r2, r4, r5, ip, sp}^
    10cc:	5355007a 	cmppl	r5, #122	; 0x7a
    10d0:	5f545241 	svcpl	0x00545241
    10d4:	00646d43 	rsbeq	r6, r4, r3, asr #26
    10d8:	4f495047 	svcmi	0x00495047

		if (dfuUploadStarted()) 
    10dc:	646f4d5f 	strbtvs	r4, [pc], #-3423	; 10e4 <main+0xb0>
		{
			uart_printf("DFU finished upload\n");
    10e0:	754f5f65 	strbvc	r5, [pc, #-3941]	; 183 <_Minimum_Stack_Size+0x83>
    10e4:	444f5f74 	strbmi	r5, [pc], #-3956	; 10ec <main+0xb8>
			dfuFinishUpload(); // systemHardReset from DFU once done
    10e8:	53455200 	movtpl	r5, #20992	; 0x5200
    10ec:	45565245 	ldrbmi	r5, [r6, #-581]	; 0x245
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10f0:	00303144 	eorseq	r3, r0, r4, asr #2
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10f4:	45534552 	ldrbmi	r4, [r3, #-1362]	; 0x552
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10f8:	44455652 	strbmi	r5, [r5], #-1618	; 0x652
    10fc:	49003131 	stmdbmi	r0, {r0, r4, r5, r8, ip, sp}
	}
	
	return 0;// Added to please the compiler
    1100:	00524543 	subseq	r4, r2, r3, asr #10
    1104:	72646461 	rsbvc	r6, r4, #1627389952	; 0x61000000
    1108:	41535500 	cmpmi	r3, r0, lsl #10
    110c:	495f5452 	ldmdbmi	pc, {r1, r4, r6, sl, ip, lr}^	; <UNPREDICTABLE>
    1110:	5474696e 	ldrbtpl	r6, [r4], #-2414	; 0x96e
    1114:	44657079 	strbtmi	r7, [r5], #-121	; 0x79
    1118:	49006665 	stmdbmi	r0, {r0, r2, r5, r6, r9, sl, sp, lr}
    111c:	00524241 	subseq	r4, r2, r1, asr #4
    1120:	33637576 	cmncc	r3, #494927872	; 0x1d800000
    1124:	43520032 	cmpmi	r2, #50	; 0x32
    1128:	50415f43 	subpl	r5, r1, r3, asr #30
    112c:	65503242 	ldrbvs	r3, [r0, #-578]	; 0x242
    1130:	68706972 	ldmdavs	r0!, {r1, r4, r5, r6, r8, fp, sp, lr}^
    1134:	636f6c43 	cmnvs	pc, #17152	; 0x4300
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1138:	646d436b 	strbtvs	r4, [sp], #-875	; 0x36b
    113c:	43545200 	cmpmi	r4, #0, 4
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    1140:	47005243 	strmi	r5, [r0, -r3, asr #4]
    1144:	534f4950 	movtpl	r4, #63824	; 0xf950
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1148:	64656570 	strbtvs	r6, [r5], #-1392	; 0x570
    114c:	7079545f 	rsbsvc	r5, r9, pc, asr r4
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    1150:	66654465 	strbtvs	r4, [r5], -r5, ror #8
    1154:	6e616200 	cdpvs	2, 6, cr6, cr1, cr0, {0}
        return TRUE;
    } else {
        return FALSE;
    }
}
    1158:	6170006b 	cmnvs	r0, fp, rrx
    115c:	64416567 	strbvs	r6, [r1], #-1383	; 0x567

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	6c007264 	sfmvs	f7, 4, [r0], {100}	; 0x64
    1164:	726f5768 	rsbvc	r5, pc, #104, 14	; 0x1a00000
    1168:	53490064 	movtpl	r0, #36964	; 0x9064
    gpio_write_bit( bank,pin,1-onState);
    116c:	6a005250 	bvs	15ab4 <_etext+0xe4a0>
    1170:	41706d75 	cmnmi	r0, r5, ror sp
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1174:	00726464 	rsbseq	r6, r2, r4, ror #8
    gpio_write_bit( bank,pin,1-onState);
    1178:	4f495047 	svcmi	0x00495047

    u32 c;
    while (count-- > 0) 
    117c:	646f4d5f 	strbtvs	r4, [pc], #-3423	; 1184 <strobePin+0x24>
	{
        for (c = rate; c > 0; c--)
    1180:	4e495f65 	cdpmi	15, 4, cr5, cr9, cr5, {3}
    1184:	4f4c465f 	svcmi	0x004c465f
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1188:	4e495441 	cdpmi	4, 4, cr5, cr9, cr1, {2}
    118c:	45520047 	ldrbmi	r0, [r2, #-71]	; 0x47
    1190:	56524553 			; <UNDEFINED> instruction: 0x56524553
		
        for (c = rate; c > 0; c--)
    1194:	00374445 	eorseq	r4, r7, r5, asr #8
    1198:	6f576868 	svcvs	0x00576868
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    119c:	74006472 	strvc	r6, [r0], #-1138	; 0x472
    11a0:	7270706d 	rsbsvc	r7, r0, #109	; 0x6d
    11a4:	69726f69 	ldmdbvs	r2!, {r0, r3, r5, r6, r8, r9, sl, fp, sp, lr}^
    11a8:	53007974 	movwpl	r7, #2420	; 0x974
    11ac:	74726174 	ldrbtvc	r6, [r2], #-372	; 0x174

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    11b0:	6f437055 	svcvs	0x00437055
    11b4:	65746e75 	ldrbvs	r6, [r4, #-3701]!	; 0xe75
  USARTx->DR = ch;  
    11b8:	434c0072 	movtmi	r0, #49266	; 0xc072
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11bc:	4400524b 	strmi	r5, [r0], #-587	; 0x24b
  while(*str != 0)
    11c0:	555f5546 	ldrbpl	r5, [pc, #-1350]	; c82 <usbReset+0xa6>
    11c4:	414f4c50 	cmpmi	pc, r0, asr ip	; <UNPREDICTABLE>
  {
    UU_PutChar(USARTx, *str);
    11c8:	4c465f44 	mcrrmi	15, 4, r5, r6, cr4
    11cc:	5f485341 	svcpl	0x00485341
    str++;
  }
}

void vprint(const char *fmt, va_list argp)
{
    11d0:	30385830 	eorscc	r5, r8, r0, lsr r8
    11d4:	30303730 	eorscc	r3, r0, r0, lsr r7
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11d8:	6e690030 	mcrvs	0, 3, r0, cr9, cr0, {1}
    11dc:	00747570 	rsbseq	r7, r4, r0, ror r5
    11e0:	72617473 	rsbvc	r7, r1, #1929379840	; 0x73000000
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11e4:	61745374 	cmnvs	r4, r4, ror r3
    11e8:	75006574 	strvc	r6, [r0, #-1396]	; 0x574

    }
}
    11ec:	41726573 	cmnmi	r2, r3, ror r5
    11f0:	64417070 	strbvs	r7, [r1], #-112	; 0x70
    11f4:	44007264 	strmi	r7, [r0], #-612	; 0x264

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11f8:	555f5546 	ldrbpl	r5, [pc, #-1350]	; cba <usbDataSetup+0x36>
    11fc:	414f4c50 	cmpmi	pc, r0, asr ip	; <UNPREDICTABLE>
    1200:	4c465f44 	mcrrmi	15, 4, r5, r6, cr4
    va_list argp;
    va_start(argp, fmt);
    vprint(fmt, argp);
    1204:	5f485341 	svcpl	0x00485341
    va_end(argp);
}
    1208:	30385830 	eorscc	r5, r8, r0, lsr r8
    120c:	30303230 	eorscc	r3, r0, r0, lsr r2
    1210:	66640030 			; <UNDEFINED> instruction: 0x66640030

void hexdump(unsigned char *data, size_t size)
{
    1214:	74655375 	strbtvc	r5, [r5], #-885	; 0x375
    1218:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
    int i;
    char cs[17];
    memset(cs, 0, 17);
    121c:	66640065 	strbtvs	r0, [r4], -r5, rrx
    1220:	6c705575 	cfldr64vs	mvdx5, [r0], #-468	; 0xfffffe2c
    1224:	5464616f 	strbtpl	r6, [r4], #-367	; 0x16f

    for(i = 0; i < size; i++)
    1228:	73657079 	cmnvc	r5, #121	; 0x79
    122c:	6400745f 	strvs	r7, [r0], #-1119	; 0x45f
    {
        if(i != 0 && i % 0x10 == 0)
    1230:	70557566 	subsvc	r7, r5, r6, ror #10
        {
            debug_print(" |%s|\n", cs);
    1234:	64616f6c 	strbtvs	r6, [r1], #-3948	; 0xf6c
    1238:	656e6f44 	strbvs	r6, [lr, #-3908]!	; 0xf44
            memset(cs, 0, 17);
    123c:	55464400 	strbpl	r4, [r6, #-1024]	; 0x400
    1240:	4c50555f 	cfldr64mi	mvdx5, [r0], {95}	; 0x5f
    1244:	5f44414f 	svcpl	0x0044414f
        }
        else if(i != 0 && i % 0x8 == 0)
    1248:	004d4152 	subeq	r4, sp, r2, asr r1
    124c:	76636572 			; <UNDEFINED> instruction: 0x76636572
        {
            debug_print(" ",0);
    1250:	66667542 	strbtvs	r7, [r6], -r2, asr #10
        }
        debug_print("%02X ", data[i]);
    1254:	64007265 	strvs	r7, [r0], #-613	; 0x265
    1258:	6f437566 	svcvs	0x00437566
        cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
    125c:	50557970 	subspl	r7, r5, r0, ror r9
    1260:	44414f4c 	strbmi	r4, [r1], #-3916	; 0xf4c
    1264:	69687400 	stmdbvs	r8!, {sl, ip, sp, lr}^
    1268:	6f6c4273 	svcvs	0x006c4273
    126c:	654c6b63 	strbvs	r6, [ip, #-2915]	; 0xb63
    1270:	6873006e 	ldmdavs	r3!, {r1, r2, r3, r5, r6}^
    }

    i = i % 0x10;
    if(i != 0)
    1274:	36353261 	ldrtcc	r3, [r5], -r1, ror #4
        while(i++ < 0x10)
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
    1278:	006d7573 	rsbeq	r7, sp, r3, ror r5
    127c:	55756664 	ldrbpl	r6, [r5, #-1636]!	; 0x664
}
    1280:	74616470 	strbtvc	r6, [r1], #-1136	; 0x470
    }

    i = i % 0x10;
    if(i != 0)
    {
        if(i <= 0x8)
    1284:	54794265 	ldrbtpl	r4, [r9], #-613	; 0x265
        {
            debug_print(" ",0);
    1288:	6f656d69 	svcvs	0x00656d69
    128c:	64007475 	strvs	r7, [r0], #-1141	; 0x475
        }
        while(i++ < 0x10)
    1290:	75427566 	strbvc	r7, [r2, #-1382]	; 0x566
        {
            debug_print("   ",0);
    1294:	5f007973 	svcpl	0x00007973
    1298:	544f4c50 	strbpl	r4, [pc], #-3152	; 12a0 <hexdump+0x8c>
    129c:	55464400 	strbpl	r4, [r6, #-1024]	; 0x400
    12a0:	4c50555f 	cfldr64mi	mvdx5, [r0], {95}	; 0x5f
    12a4:	5f44414f 	svcpl	0x0044414f
    12a8:	53414c46 	movtpl	r4, #7238	; 0x1c46
    12ac:	58305f48 	ldmdapl	r0!, {r3, r6, r8, r9, sl, fp, ip, lr}
    }
    debug_print(" |%s|\n", cs);
}

void print_hash(unsigned char hash[])
{
    12b0:	36303038 			; <UNDEFINED> instruction: 0x36303038
   int idx;
   for (idx=0; idx < 32; idx++)
    12b4:	00303030 	eorseq	r3, r0, r0, lsr r0
      debug_print("%02x",hash[idx]);
    12b8:	2e756664 	cdpcs	6, 7, cr6, cr5, cr4, {3}
    12bc:	73750063 	cmnvc	r5, #99	; 0x63
}

void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
    12c0:	70537265 	subsvc	r7, r3, r5, ror #4
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12c4:	00656361 	rsbeq	r6, r5, r1, ror #6
}
    12c8:	72745369 	rsbsvc	r5, r4, #-1543503871	; 0xa4000001
void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12cc:	00676e69 	rsbeq	r6, r7, r9, ror #28
    12d0:	6f6c7075 	svcvs	0x006c7075
    12d4:	6c426461 	cfstrdvs	mvd6, [r2], {97}	; 0x61
}

#endif
void uartInit(void) {
    12d8:	4c6b636f 	stclmi	3, cr6, [fp], #-444	; 0xfffffe44
    12dc:	44006e65 	strmi	r6, [r0], #-3685	; 0xe65
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    12e0:	555f5546 	ldrbpl	r5, [pc, #-1350]	; da2 <setupUSB+0x52>
    12e4:	414f4c50 	cmpmi	pc, r0, asr ip	; <UNPREDICTABLE>
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    12e8:	4c465f44 	mcrrmi	15, 4, r5, r6, cr4
    12ec:	5f485341 	svcpl	0x00485341
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    12f0:	30385830 	eorscc	r5, r8, r0, lsr r8
    12f4:	30303830 	eorscc	r3, r0, r0, lsr r8
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    12f8:	46440030 			; <UNDEFINED> instruction: 0x46440030
    12fc:	50555f55 	subspl	r5, r5, r5, asr pc
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    1300:	44414f4c 	strbmi	r4, [r1], #-3916	; 0xf4c
    1304:	4e4f4e5f 	mcrmi	14, 2, r4, cr15, cr15, {2}
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1308:	73750045 	cmnvc	r5, #69	; 0x45
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    130c:	69467265 	stmdbvs	r6, {r0, r2, r5, r6, r9, ip, sp, lr}^
    1310:	61776d72 	cmnvs	r7, r2, ror sp
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1314:	654c6572 	strbvs	r6, [ip, #-1394]	; 0x572
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1318:	6664006e 	strbtvs	r0, [r4], -lr, rrx
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    131c:	70704175 	rsbsvc	r4, r0, r5, ror r1
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1320:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    1324:	73007375 	movwvc	r7, #885	; 0x375
    1328:	35326168 	ldrcc	r6, [r2, #-360]!	; 0x168
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    132c:	74735f36 	ldrbtvc	r5, [r3], #-3894	; 0xf36
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    1330:	73747261 	cmnvc	r4, #268435462	; 0x10000006
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1334:	46445f00 	strbmi	r5, [r4], -r0, lsl #30
    USART_InitStructure.USART_Parity = USART_Parity_No;
    1338:	61745355 	cmnvs	r4, r5, asr r3
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    133c:	00737574 	rsbseq	r7, r3, r4, ror r5
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1340:	676e656c 	strbvs	r6, [lr, -ip, ror #10]!
    1344:	64006874 	strvs	r6, [r0], #-2164	; 0x874
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    1348:	6f437566 	svcvs	0x00437566
        
    USART_Init(USART1, &USART_InitStructure);
    134c:	74537970 	ldrbvc	r7, [r3], #-2416	; 0x970
    
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
    1350:	00657461 	rsbeq	r7, r5, r1, ror #8
    1354:	61745362 	cmnvs	r4, r2, ror #6
}
    1358:	00737574 	rsbseq	r7, r3, r4, ror r5
    135c:	43756664 	cmnmi	r5, #100, 12	; 0x6400000

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    1360:	4479706f 	ldrbtmi	r7, [r9], #-111	; 0x6f
    1364:	414f4c4e 	cmpmi	pc, lr, asr #24
    1368:	77620044 	strbvc	r0, [r2, -r4, asr #32]!
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    136c:	6c6c6f50 	stclvs	15, cr6, [ip], #-320	; 0xfffffec0
    1370:	656d6954 	strbvs	r6, [sp, #-2388]!	; 0x954
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    1374:	3074756f 	rsbscc	r7, r4, pc, ror #10
    1378:	50776200 	rsbspl	r6, r7, r0, lsl #4
    137c:	546c6c6f 	strbtpl	r6, [ip], #-3183	; 0xc6f
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    1380:	6f656d69 	svcvs	0x00656d69
    1384:	00317475 	eorseq	r7, r1, r5, ror r4
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    1388:	6f507762 	svcvs	0x00507762
    138c:	69546c6c 	ldmdbvs	r4, {r2, r3, r5, r6, sl, fp, sp, lr}^

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    1390:	756f656d 	strbvc	r6, [pc, #-1389]!	; e2b <usbResume+0x3f>
    1394:	73003274 	movwvc	r3, #628	; 0x274
    1398:	35326168 	ldrcc	r6, [r2, #-360]!	; 0x168
    139c:	6f635f36 	svcvs	0x00635f36
    13a0:	7865746e 	stmdavc	r5!, {r1, r2, r3, r5, r6, sl, ip, sp, lr}^
    13a4:	45420074 	strbmi	r0, [r2, #-116]	; 0x74
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    13a8:	4e4e4947 	cdpmi	9, 4, cr4, cr14, cr7, {2}
    13ac:	00474e49 	subeq	r4, r7, r9, asr #28
    13b0:	43756664 	cmnmi	r5, #100, 12	; 0x6400000
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    13b4:	5379706f 	cmnpl	r9, #111	; 0x6f
    13b8:	75746174 	ldrbvc	r6, [r4, #-372]!	; 0x174

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    13bc:	6f630073 	svcvs	0x00630073
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    13c0:	635f6564 	cmpvs	pc, #100, 10	; 0x19000000
    13c4:	5f79706f 	svcpl	0x0079706f
    13c8:	6b636f6c 	blvs	18dd180 <_etext+0x18d5b6c>
    13cc:	55464400 	strbpl	r4, [r6, #-1024]	; 0x400
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    13d0:	4c50555f 	cfldr64mi	mvdx5, [r0], {95}	; 0x5f
    13d4:	5f44414f 	svcpl	0x0044414f

#if !defined  (HSE_STARTUP_TIMEOUT) 
  #define HSE_STARTUP_TIMEOUT    ((unsigned int)0x0500)   /*!< Time out for HSE start up */
#endif /* HSE_STARTUP_TIMEOUT */   

    while ((GET_REG(RCC_CR) & 0x03000000) == 0 && StartUpCounter < HSE_STARTUP_TIMEOUT)
    13d8:	53414c46 	movtpl	r4, #7238	; 0x1c46
    13dc:	58305f48 	ldmdapl	r0!, {r3, r6, r8, r9, sl, fp, ip, lr}
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    13e0:	35303038 	ldrcc	r3, [r0, #-56]!	; 0x38
    13e4:	00303030 	eorseq	r3, r0, r0, lsr r0
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    13e8:	47756664 	ldrbmi	r6, [r5, -r4, ror #12]!
    13ec:	74537465 	ldrbvc	r7, [r3], #-1125	; 0x465
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    13f0:	00657461 	rsbeq	r7, r5, r1, ror #8
    13f4:	72657375 	rsbvc	r7, r5, #-738197503	; 0xd4000001
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    13f8:	45707041 	ldrbmi	r7, [r0, #-65]!	; 0x41
    13fc:	4d00646e 	cfstrsmi	mvf6, [r0, #-440]	; 0xfffffe48
    1400:	4c444449 	cfstrdmi	mvd4, [r4], {73}	; 0x49
    1404:	73750045 	cmnvc	r5, #69	; 0x45

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    1408:	70557265 	subsvc	r7, r5, r5, ror #4
    140c:	64616f6c 	strbtvs	r6, [r1], #-3948	; 0xf6c
    1410:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954
    1414:	77656e00 	strbvc	r6, [r5, -r0, lsl #28]!
    1418:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    141c:	66640065 	strbtvs	r0, [r4], -r5, rrx
    1420:	706f4375 	rsbvc	r4, pc, r5, ror r3	; <UNPREDICTABLE>
        u32 rwmVal = pRCC->CR;
    1424:	66754279 			; <UNDEFINED> instruction: 0x66754279
        rwmVal |= 0x01;
    1428:	54726566 	ldrbtpl	r6, [r2], #-1382	; 0x566
        pRCC->CR = rwmVal;
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    142c:	6578456f 	ldrbvs	r4, [r8, #-1391]!	; 0x56f
    1430:	53620063 	cmnpl	r2, #99	; 0x63
}   
    1434:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0x174
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    1438:	35353200 	ldrcc	r3, [r5, #-512]!	; 0x200
void setMspAndJump(u32 usrAddr) {
  // Dedicated function with no call to any function (appart the last call)
  // This way, there is no manipulation of the stack here, ensuring that GGC
  // didn't insert any pop from the SP after having set the MSP.
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */
    143c:	632f3931 	teqvs	pc, #802816	; 0xc4000
  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
               (*(volatile u32 *)usrAddr));
    1440:	31353532 	teqcc	r5, r2, lsr r5

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));

  asm volatile("msr msp, %0"::"g"
    1444:	00632e39 	rsbeq	r2, r3, r9, lsr lr
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    1448:	645f6378 	ldrbvs	r6, [pc], #-888	; 1450 <nvicInit>
    144c:	6c62756f 	cfstr64vs	mvdx7, [r2], #-444	; 0xfffffe44
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    1450:	32660065 	rsbcc	r0, r6, #101	; 0x65
    1454:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    1458:	706f635f 	rsbvc	r6, pc, pc, asr r3	; <UNPREDICTABLE>
    145c:	32630079 	rsbcc	r0, r3, #121	; 0x79
    tmppre = (0x4 - tmppriority);
    1460:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    1464:	7361625f 	cmnvc	r1, #-268435451	; 0xf0000005


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    1468:	00785f65 	rsbseq	r5, r8, r5, ror #30

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    146c:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    1470:	615f3931 	cmpvs	pc, r1, lsr r9	; <UNPREDICTABLE>

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1474:	66006464 	strvs	r6, [r0], -r4, ror #8
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    1478:	31353532 	teqcc	r5, r2, lsr r5
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    147c:	756d5f39 	strbvc	r5, [sp, #-3897]!	; 0xf39

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1480:	00635f6c 	rsbeq	r5, r3, ip, ror #30
    1484:	71733178 	cmnvc	r3, r8, ror r1
    1488:	35326600 	ldrcc	r6, [r2, #-1536]!	; 0x600
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    148c:	5f393135 	svcpl	0x00393135
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    tmpreg &= ~tmpmask;
    1490:	00656e6f 	rsbeq	r6, r5, pc, ror #28
    tmppriority &= tmpmask;
    1494:	7173317a 	cmnvc	r3, sl, ror r1
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    1498:	35326300 	ldrcc	r6, [r2, #-768]!	; 0x300

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    149c:	5f393135 	svcpl	0x00393135
    14a0:	6c756d73 	ldclvs	13, cr6, [r5], #-460	; 0xfffffe34
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    14a4:	4e470074 	mcrmi	0, 2, r0, cr7, cr4, {3}
    14a8:	20432055 	subcs	r2, r3, r5, asr r0
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    14ac:	2e382e34 	mrccs	14, 1, r2, cr8, cr4, {1}
    14b0:	30322034 	eorscc	r2, r2, r4, lsr r0
    14b4:	37303431 			; <UNDEFINED> instruction: 0x37303431
    14b8:	28203532 	stmdacs	r0!, {r1, r4, r5, r8, sl, ip, sp}
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    14bc:	656c6572 	strbvs	r6, [ip, #-1394]!	; 0x572
    14c0:	29657361 	stmdbcs	r5!, {r0, r5, r6, r8, r9, ip, sp, lr}^
    14c4:	52415b20 	subpl	r5, r1, #32, 22	; 0x8000
    rNVIC->ICER[1] = 0xFFFFFFFF;
    14c8:	6d652f4d 	stclvs	15, cr2, [r5, #-308]!	; 0xfffffecc
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    14cc:	64646562 	strbtvs	r6, [r4], #-1378	; 0x562
    rNVIC->ICPR[1] = 0xFFFFFFFF;
    14d0:	342d6465 	strtcc	r6, [sp], #-1125	; 0x465

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    14d4:	622d385f 	eorvs	r3, sp, #6225920	; 0x5f0000
    14d8:	636e6172 	cmnvs	lr, #-2147483620	; 0x8000001c
    14dc:	65722068 	ldrbvs	r2, [r2, #-104]!	; 0x68

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    14e0:	69736976 	ldmdbvs	r3!, {r1, r2, r4, r5, r6, r8, fp, sp, lr}^
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    14e4:	32206e6f 	eorcc	r6, r0, #1776	; 0x6f0
    nvicDisableInterrupts();
    14e8:	34313331 	ldrtcc	r3, [r1], #-817	; 0x331
	
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
    14ec:	2d205d37 	stccs	13, cr5, [r0, #-220]!	; 0xffffff24
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    14f0:	7568746d 	strbvc	r7, [r8, #-1133]!	; 0x46d
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14f4:	2d20626d 	sfmcs	f6, 4, [r0, #-436]!	; 0xfffffe4c
}
    14f8:	7570636d 	ldrbvc	r6, [r0, #-877]!	; 0x36d
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14fc:	726f633d 	rsbvc	r6, pc, #-201326592	; 0xf4000000

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1500:	2d786574 	cfldr64cs	mvdx6, [r8, #-464]!	; 0xfffffe30
    1504:	2d20336d 	stccs	3, cr3, [r0, #-436]!	; 0xfffffe4c

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    1508:	7568746d 	strbvc	r7, [r8, #-1133]!	; 0x46d
    150c:	692d626d 	pushvs	{r0, r2, r3, r5, r6, r9, sp, lr}
    1510:	7265746e 	rsbvc	r7, r5, #1845493760	; 0x6e000000
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1514:	6b726f77 	blvs	1c9d2f8 <_etext+0x1c95ce4>
    1518:	20672d20 	rsbcs	r2, r7, r0, lsr #26
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);
    151c:	20334f2d 	eorscs	r4, r3, sp, lsr #30

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1520:	7566662d 	strbvc	r6, [r6, #-1581]!	; 0x62d
    1524:	6974636e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, r9, sp, lr}^
    1528:	732d6e6f 	teqvc	sp, #1776	; 0x6f0
    SET_REG(FLASH_AR, pageAddr);
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    152c:	69746365 	ldmdbvs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1530:	20736e6f 	rsbscs	r6, r3, pc, ror #28
    1534:	6164662d 	cmnvs	r4, sp, lsr #12

    /* todo: verify the page was erased */

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);
    1538:	732d6174 	teqvc	sp, #116, 2

    return TRUE;
}
    153c:	69746365 	ldmdbvs	r4!, {r0, r2, r5, r6, r8, r9, sp, lr}^
    1540:	00736e6f 	rsbseq	r6, r3, pc, ror #28
    1544:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    1548:	735f3931 	cmpvc	pc, #802816	; 0xc4000
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    154c:	78006275 	stmdavc	r0, {r0, r2, r4, r5, r6, r9, sp, lr}
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    1550:	00317a31 	eorseq	r7, r1, r1, lsr sl

    u32 rwmVal = GET_REG(FLASH_CR);
    SET_REG(FLASH_CR, FLASH_CR_PG);
    1554:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
    1558:	6e5f3931 	mrcvs	9, 2, r3, cr15, cr1, {1}

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    155c:	616d726f 	cmnvs	sp, pc, ror #4
    1560:	657a696c 	ldrbvs	r6, [sl, #-2412]!	; 0x96c
    *(flashAddr + 0x01) = (vu16)hhWord;
    1564:	35326600 	ldrcc	r6, [r2, #-1536]!	; 0x600
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1568:	5f393135 	svcpl	0x00393135
    156c:	5f6c756d 	svcpl	0x006c756d
    *(flashAddr) = (vu16)lhWord;
    1570:	7369645f 	cmnvc	r9, #1593835520	; 0x5f000000
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1574:	636e6974 	cmnvs	lr, #116, 18	; 0x1d0000
    1578:	32660074 	rsbcc	r0, r6, #116	; 0x74

    rwmVal &= 0xFFFFFFFE;
    157c:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    SET_REG(FLASH_CR, rwmVal);

    /* verify the write */
    if (*(vu32 *)addr != word) {
    1580:	766e695f 			; <UNDEFINED> instruction: 0x766e695f
        return FALSE;
    }

    return TRUE;
}
    1584:	69645f5f 	stmdbvs	r4!, {r0, r1, r2, r3, r4, r6, r8, r9, sl, fp, ip, lr}^
    1588:	6e697473 	mcrvs	4, 3, r7, cr9, cr3, {3}
    158c:	66007463 	strvs	r7, [r0], -r3, ror #8
    1590:	31353532 	teqcc	r5, r2, lsr r5

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    1594:	65735f39 	ldrbvs	r5, [r3, #-3897]!	; 0xf39
    1598:	7463656c 	strbtvc	r6, [r3], #-1388	; 0x56c
    159c:	73657200 	cmnvc	r5, #0, 4
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    15a0:	00746c75 	rsbseq	r6, r4, r5, ror ip
    15a4:	645f6378 	ldrbvs	r6, [pc], #-888	; 15ac <flashUnlock+0xc>
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    15a8:	61666669 	cmnvs	r6, r9, ror #12
    15ac:	63006464 	movwvs	r6, #1124	; 0x464
    15b0:	00706d6f 	rsbseq	r6, r0, pc, ror #26
    15b4:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    15b8:	655f3931 	ldrbvs	r3, [pc, #-2353]	; c8f <usbDataSetup+0xb>
	{
		pin-=8;
    15bc:	5f720071 	svcpl	0x00720071
	}
	mask = 0x0F << (pin<<2);
    15c0:	0074756f 	rsbseq	r7, r4, pc, ror #10
    15c4:	636d656d 	cmnvs	sp, #457179136	; 0x1b400000
	return ~mask;
}	
    15c8:	65007970 	strvs	r7, [r0, #-2416]	; 0x970

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    15cc:	35353264 	ldrcc	r3, [r5, #-612]!	; 0x264
    15d0:	705f3931 	subsvc	r3, pc, r1, lsr r9	; <UNPREDICTABLE>
}
    15d4:	006b6361 	rsbeq	r6, fp, r1, ror #6
    15d8:	69726170 	ldmdbvs	r2!, {r4, r5, r6, r8, sp, lr}^

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    15dc:	65007974 	strvs	r7, [r0, #-2420]	; 0x974
	{
		return 0x800;
    15e0:	35353264 	ldrcc	r3, [r5, #-612]!	; 0x264
	}
	else
	{
		return 0x400;
	}
}
    15e4:	615f3931 	cmpvs	pc, r1, lsr r9	; <UNPREDICTABLE>
    15e8:	65006464 	strvs	r6, [r0, #-1124]	; 0x464
    15ec:	35353264 	ldrcc	r3, [r5, #-612]!	; 0x264
    15f0:	745f3931 	ldrbvc	r3, [pc], #-2353	; 15f8 <dfuInit+0x4>

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15f4:	755f7972 	ldrbvc	r7, [pc, #-2418]	; c8a <usbDataSetup+0x6>
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    15f8:	6361706e 	cmnvs	r1, #110	; 0x6e

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15fc:	6465006b 	strbtvs	r0, [r5], #-107	; 0x6b
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1600:	31353532 	teqcc	r5, r2, lsr r5
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    1604:	72705f39 	rsbsvc	r5, r0, #57, 30	; 0xe4
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    1608:	63656a6f 	cmnvs	r5, #454656	; 0x6f000
    160c:	35320074 	ldrcc	r0, [r2, #-116]!	; 0x74
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1610:	2f393135 	svccs	0x00393135
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1614:	35326465 	ldrcc	r6, [r2, #-1125]!	; 0x465
    userAppEnd = RAM_END;
    1618:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}
    161c:	64650063 	strbtvs	r0, [r5], #-99	; 0x63
    userUploadType=DFU_UPLOAD_NONE;
    1620:	31353532 	teqcc	r5, r2, lsr r5
    1624:	6d735f39 	ldclvs	15, cr5, [r3, #-228]!	; 0xffffff1c
    code_copy_lock = WAIT;
    1628:	00746c75 	rsbseq	r6, r4, r5, ror ip
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    162c:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
    1630:	6c5f3931 	mrrcvs	9, 3, r3, pc, cr1	; <UNPREDICTABLE>
    1634:	0064616f 	rsbeq	r6, r4, pc, ror #2
    memset(input, 0xFF, sizeof(input));
    1638:	35326465 	ldrcc	r6, [r2, #-1125]!	; 0x465
    163c:	5f393135 	svcpl	0x00393135

    sha256_starts(&ctx);
}
    1640:	72706e75 	rsbsvc	r6, r0, #1872	; 0x750
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1644:	63656a6f 	cmnvs	r5, #454656	; 0x6f000
    1648:	64650074 	strbtvs	r0, [r5], #-116	; 0x74
    164c:	31353532 	teqcc	r5, r2, lsr r5
    1650:	656e5f39 	strbvs	r5, [lr, #-3897]!	; 0xf39
    1654:	61727475 	cmnvs	r2, r5, ror r4
    1658:	3266006c 	rsbcc	r0, r6, #108	; 0x6c
    165c:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    1660:	7271735f 	rsbsvc	r7, r1, #2080374785	; 0x7c000001
    1664:	32660074 	rsbcc	r0, r6, #116	; 0x74
    1668:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    166c:	67656e5f 			; <UNDEFINED> instruction: 0x67656e5f
    1670:	32646500 	rsbcc	r6, r4, #0, 10
    1674:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    1678:	756f645f 	strbvc	r6, [pc, #-1119]!	; 1221 <hexdump+0xd>
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    167c:	00656c62 	rsbeq	r6, r5, r2, ror #24
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    1680:	35326465 	ldrcc	r6, [r2, #-1125]!	; 0x465
    1684:	5f393135 	svcpl	0x00393135

    if (startState == appDETACH) {
    1688:	65007470 	strvs	r7, [r0, #-1136]	; 0x470
    168c:	35353264 	ldrcc	r3, [r5, #-612]!	; 0x264
        dfuAppStatus.bState = dfuIDLE;
    1690:	625f3931 	subsvs	r3, pc, #802816	; 0xc4000
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
    1694:	00657361 	rsbeq	r7, r5, r1, ror #6
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1698:	35326465 	ldrcc	r6, [r2, #-1125]!	; 0x465
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    169c:	5f393135 	svcpl	0x00393135
    } else if (startState == appIDLE || startState == dfuIDLE) {
    16a0:	79706f63 	ldmdbvc	r0!, {r0, r1, r5, r6, r8, r9, sl, fp, sp, lr}^
    16a4:	32646500 	rsbcc	r6, r4, #0, 10
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    16a8:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    16ac:	6500645f 	strvs	r6, [r0, #-1119]	; 0x45f
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    16b0:	35353264 	ldrcc	r3, [r5, #-612]!	; 0x264
    16b4:	6b5f3931 	blvs	17cfb80 <_etext+0x17c856c>
    16b8:	61687300 	cmnvs	r8, r0, lsl #6
    16bc:	5f323135 	svcpl	0x00323135

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    16c0:	616e6966 	cmnvs	lr, r6, ror #18
        pInformation->Ctrl_Info.Usb_wLength = 1;
    16c4:	6e69006c 	cdpvs	0, 6, cr0, cr9, cr12, {3}
    16c8:	625f7469 	subsvs	r7, pc, #1761607680	; 0x69000000
        return NULL;
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    16cc:	6b636f6c 	blvs	18dd484 <_etext+0x18d5e70>
    }
}
    16d0:	35353200 	ldrcc	r3, [r5, #-512]!	; 0x200
    16d4:	652f3931 	strvs	r3, [pc, #-2353]!	; dab <setupUSB+0x5b>

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    16d8:	67697364 	strbvs	r7, [r9, -r4, ror #6]!
        pInformation->Ctrl_Info.Usb_wLength = 6;
    16dc:	00632e6e 	rsbeq	r2, r3, lr, ror #28
    16e0:	35326465 	ldrcc	r6, [r2, #-1125]!	; 0x465
        return NULL;
    } else {
        return (u8*)(&dfuAppStatus);
    16e4:	5f393135 	svcpl	0x00393135
    }
}
    16e8:	70657270 	rsbvc	r7, r5, r0, ror r2
    16ec:	00657261 	rsbeq	r7, r5, r1, ror #4


u8 *dfuCopyDNLOAD(u16 length) {
    16f0:	35616873 	strbcc	r6, [r1, #-2163]!	; 0x873
    if (length == 0) {
    16f4:	695f3231 	ldmdbvs	pc, {r0, r4, r5, r9, ip, sp}^	; <UNPREDICTABLE>
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    16f8:	6974696e 	ldmdbvs	r4!, {r1, r2, r3, r5, r6, r8, fp, sp, lr}^
    16fc:	735f6c61 	cmpvc	pc, #24832	; 0x6100
        thisBlockLen = pInformation->USBwLengths.w;
    1700:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0x174
        return NULL;
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1704:	61687300 	cmnvs	r8, r0, lsl #6
    1708:	5f323135 	svcpl	0x00323135
    }
}
    170c:	00746567 	rsbseq	r6, r4, r7, ror #10
    1710:	6e676973 	mcrvs	9, 3, r6, cr7, cr3, {3}
    1714:	72757461 	rsbsvc	r7, r5, #1627389952	; 0x61000000

u8 *dfuCopyUPLOAD(u16 length) {
    1718:	78650065 	stmdavc	r5!, {r0, r2, r5, r6}^
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    171c:	646e6170 	strbtvs	r6, [lr], #-368	; 0x170
    1720:	79656b5f 	stmdbvc	r5!, {r0, r1, r2, r3, r4, r6, r8, r9, fp, sp, lr}^
    1724:	74756f00 	ldrbtvc	r6, [r5], #-3840	; 0xf00
        return NULL;
    1728:	0070665f 	rsbseq	r6, r0, pc, asr r6
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    172c:	72636573 	rsbvc	r6, r3, #482344960	; 0x1cc00000
    1730:	65007465 	strvs	r7, [r0, #-1125]	; 0x465
    1734:	6e617078 	mcrvs	0, 3, r7, cr1, cr8, {3}
    1738:	00646564 	rsbeq	r6, r4, r4, ror #10
    }
}
    173c:	6b636170 	blvs	18d9d04 <_etext+0x18d26f0>
    1740:	5f006465 	svcpl	0x00006465
    1744:	6e69755f 	mcrvs	5, 3, r7, cr9, cr15, {2}
    1748:	5f343674 	svcpl	0x00343674

void dfuCopyBufferToExec() {
    174c:	72700074 	rsbsvc	r0, r0, #116	; 0x74
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    1750:	78696665 	stmdavc	r9!, {r0, r2, r5, r6, r9, sl, sp, lr}^
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    1754:	7a69735f 	bvc	1a5e4d8 <_etext+0x1a56ec4>
    1758:	64650065 	strbtvs	r0, [r5], #-101	; 0x65
    175c:	31353532 	teqcc	r5, r2, lsr r5
    1760:	726f5f39 	rsbvc	r5, pc, #57, 30	; 0xe4
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    1764:	00726564 	rsbseq	r6, r2, r4, ror #10
	}

    flashErasePage((u32)(userSpace));
    1768:	69727066 	ldmdbvs	r2!, {r1, r2, r5, r6, ip, sp, lr}^

    for (i = 0; i < thisBlockLen; i = i + 4) {
    176c:	665f656d 	ldrbvs	r6, [pc], -sp, ror #10
    1770:	5f6d6f72 	svcpl	0x006d6f72
    1774:	65747962 	ldrbvs	r7, [r4, #-2402]!	; 0x962
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    1778:	61680073 	smcvs	32771	; 0x8003
    177c:	6d5f6873 	ldclvs	8, cr6, [pc, #-460]	; 15b8 <crMask>
    1780:	61737365 	cmnvs	r3, r5, ror #6
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    1784:	68006567 	stmdavs	r0, {r0, r1, r2, r5, r6, r8, sl, sp, lr}
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    1788:	5f687361 	svcpl	0x00687361
    178c:	68746977 	ldmdavs	r4!, {r0, r1, r2, r4, r5, r6, r8, fp, sp, lr}^
    thisBlockLen = 0;
    1790:	6572705f 	ldrbvs	r7, [r2, #-95]!	; 0x5f
    1794:	00786966 	rsbseq	r6, r8, r6, ror #18
    1798:	69736465 	ldmdbvs	r3!, {r0, r2, r5, r6, sl, sp, lr}^
    179c:	735f6e67 	cmpvc	pc, #1648	; 0x670
    17a0:	745f6365 	ldrbvc	r6, [pc], #-869	; 17a8 <dfuUpdateByRequest>
    17a4:	75705f6f 	ldrbvc	r5, [r0, #-3951]!	; 0xf6f
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    17a8:	6d730062 	ldclvs	0, cr0, [r3, #-392]!	; 0xfffffe78
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    17ac:	6361705f 	cmnvs	r1, #95	; 0x5f
    17b0:	6873006b 	ldmdavs	r3!, {r0, r1, r3, r5, r6}^

    u8 startState = dfuAppStatus.bState;
    17b4:	32313561 	eorscc	r3, r1, #406847488	; 0x18400000
    17b8:	6174735f 	cmnvs	r4, pc, asr r3
    dfuAppStatus.bStatus = OK;
    17bc:	65006574 	strvs	r6, [r0, #-1396]	; 0x574
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    17c0:	67697364 	strbvs	r7, [r9, -r4, ror #6]!

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17c4:	65765f6e 	ldrbvs	r5, [r6, #-3950]!	; 0xf6e
    17c8:	79666972 	stmdbvc	r6!, {r1, r4, r5, r6, r8, fp, sp, lr}^
            if (pInformation->USBwLengths.w > 0) {
    17cc:	61687300 	cmnvs	r8, r0, lsl #6
    17d0:	5f323135 	svcpl	0x00323135
                userFirmwareLen = 0;
    17d4:	74696e69 	strbtvc	r6, [r9], #-3689	; 0xe69
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    17d8:	61687300 	cmnvs	r8, r0, lsl #6
    17dc:	5f323135 	svcpl	0x00323135
    17e0:	636f6c62 	cmnvs	pc, #25088	; 0x6200
    17e4:	3266006b 	rsbcc	r0, r6, #107	; 0x6b
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    17e8:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
						userAppAddr = USER_CODE_FLASH0X8002000;
    17ec:	72657a5f 	rsbvc	r7, r5, #389120	; 0x5f000
    17f0:	7865006f 	stmdavc	r5!, {r0, r1, r2, r3, r5, r6}^
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    17f4:	32353270 	eorscc	r3, r5, #112, 4
    17f8:	35320033 	ldrcc	r0, [r2, #-51]!	; 0x33
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    17fc:	2f393135 	svccs	0x00393135
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1800:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
						flashUnlock();
    1804:	632e3931 	teqvs	lr, #802816	; 0xc4000

						break;
    1808:	35326600 	ldrcc	r6, [r2, #-1536]!	; 0x600

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    180c:	5f393135 	svcpl	0x00393135
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1810:	00766e69 	rsbseq	r6, r6, r9, ror #28
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1814:	35353266 	ldrcc	r3, [r5, #-614]!	; 0x266
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    1818:	6d5f3931 	ldclvs	9, cr3, [pc, #-196]	; 175c <dfuCopyBufferToExec+0x10>
    181c:	63006c75 	movwvs	r6, #3189	; 0xc75
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    1820:	69646e6f 	stmdbvs	r4!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    1824:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1828:	6e696d00 	cdpvs	13, 6, cr6, cr9, cr0, {0}
    182c:	00707375 	rsbseq	r7, r0, r5, ror r3
    1830:	6c657270 	sfmvs	f7, 2, [r5], #-448	; 0xfffffe40
			
            switch(pInformation->Current_AlternateSetting) {
    1834:	5f64616f 	svcpl	0x0064616f
    1838:	65747962 	ldrbvs	r7, [r4, #-2402]!	; 0x962
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    183c:	72700073 	rsbsvc	r0, r0, #115	; 0x73
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1840:	616f6c65 	cmnvs	pc, r5, ror #24
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1844:	69625f64 	stmdbvs	r2!, {r2, r5, r6, r8, r9, sl, fp, ip, lr}^
					userAppEnd = getFlashEnd();
    1848:	66007374 			; <UNDEFINED> instruction: 0x66007374
    184c:	6d697270 	sfmvs	f7, 2, [r9, #-448]!	; 0xfffffe40

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    1850:	6e695f65 	cdpvs	15, 6, cr5, cr9, cr5, {3}
					dfuAppStatus.bStatus = errWRITE;
    1854:	62720076 	rsbsvs	r0, r2, #118	; 0x76
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    1858:	00737469 	rsbseq	r7, r3, r9, ror #8
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    185c:	73756c70 	cmnvc	r5, #112, 24	; 0x7000
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1860:	68730061 	ldmdavs	r3!, {r0, r5, r6}^
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    1864:	5f746669 	svcpl	0x00746669
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1868:	69625f6e 	stmdbvs	r2!, {r1, r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
    186c:	66007374 			; <UNDEFINED> instruction: 0x66007374
    1870:	6d697270 	sfmvs	f7, 2, [r9, #-448]!	; 0xfffffe40

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    1874:	65735f65 	ldrbvs	r5, [r3, #-3941]!	; 0xf65
                dfuCopyBufferToExec();
    1878:	7463656c 	strbtvc	r6, [r3], #-1388	; 0x56c
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    187c:	72706600 	rsbsvc	r6, r0, #0, 12
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    1880:	5f656d69 	svcpl	0x00656d69
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    1884:	00627573 	rsbeq	r7, r2, r3, ror r5
    1888:	69727066 	ldmdbvs	r2!, {r1, r2, r5, r6, ip, sp, lr}^

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    188c:	615f656d 	cmpvs	pc, sp, ror #10
    1890:	6d006464 	cfstrsvs	mvf6, [r0, #-400]	; 0xfffffe70
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    1894:	695f6e69 	ldmdbvs	pc, {r0, r3, r5, r6, r9, sl, fp, sp, lr}^	; <UNPREDICTABLE>
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    1898:	6d00746e 	cfstrsvs	mvf7, [r0, #-440]	; 0xfffffe48
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    189c:	6c75646f 	cfldrdvs	mvd6, [r5], #-444	; 0xfffffe44
    18a0:	66007375 			; <UNDEFINED> instruction: 0x66007375
    18a4:	6d697270 	sfmvs	f7, 2, [r9, #-448]!	; 0xfffffe40
            if (pInformation->USBwLengths.w > 0) {
    18a8:	756d5f65 	strbvc	r5, [sp, #-3941]!	; 0xf65
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    18ac:	7066006c 	rsbvc	r0, r6, ip, rrx
                }*/
                ImageObjectHandle imageHandle;
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    18b0:	656d6972 	strbvs	r6, [sp, #-2418]!	; 0x972
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    18b4:	72657a5f 	rsbvc	r7, r5, #389120	; 0x5f000
                }*/
                ImageObjectHandle imageHandle;
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    18b8:	6172006f 	cmnvs	r2, pc, rrx
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
                }
                switch (ret)
    18bc:	72745f77 	rsbsvc	r5, r4, #476	; 0x1dc
    18c0:	75735f79 	ldrbvc	r5, [r3, #-3961]!	; 0xf79
    18c4:	72700062 	rsbsvc	r0, r0, #98	; 0x62
                {
                    case kImageImageIsTrusted:
                        uart_printf("Uploaded signature verified!\n");
    18c8:	5f656d69 	svcpl	0x00656d69
                        break;

                    case kImageImageMissingMagic:
                    case kImageImageRejectSignature:
                        uart_printf("Image unverified... wiped memory for clean reset.\n");
    18cc:	0062736d 	rsbeq	r7, r2, sp, ror #6
    18d0:	69727066 	ldmdbvs	r2!, {r1, r2, r5, r6, ip, sp, lr}^
                        break;

                    default:
                        break;
                }
                flashLock();
    18d4:	655f656d 	ldrbvs	r6, [pc, #-1389]	; 136f <systemReset+0xf>
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    18d8:	70660071 	rsbvc	r0, r6, r1, ror r0
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18dc:	656d6972 	strbvs	r6, [sp, #-2418]!	; 0x972
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18e0:	616f6c5f 	cmnvs	pc, pc, asr ip	; <UNPREDICTABLE>
    18e4:	70660064 	rsbvc	r0, r6, r4, rrx
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuMANIFEST_SYNC) {
    18e8:	656d6972 	strbvs	r6, [sp, #-2418]!	; 0x972
        /* device has received last block, waiting DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18ec:	706f635f 	rsbvc	r6, pc, pc, asr r3	; <UNPREDICTABLE>
    18f0:	35320079 	ldrcc	r0, [r2, #-121]!	; 0x79
            dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    18f4:	2f393135 	svccs	0x00393135
            dfuAppStatus.bStatus = OK;
    18f8:	69727066 	ldmdbvs	r2!, {r1, r2, r5, r6, ip, sp, lr}^
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18fc:	632e656d 	teqvs	lr, #457179136	; 0x1b400000
    1900:	65727000 	ldrbvs	r7, [r2, #-0]!
            dfuAppStatus.bState  = dfuMANIFEST_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuMANIFEST) {
    1904:	64616f6c 	strbtvs	r6, [r1], #-3948	; 0xf6c
        /* device is in manifestation phase */

        /* should never receive request while in manifest! */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
        dfuAppStatus.bStatus = OK;
    } else if (startState == dfuMANIFEST_WAIT_RESET) {
    1908:	746f745f 	strbtvc	r7, [pc], #-1119	; 1910 <dfuUpdateByRequest+0x168>
        /* device has programmed new firmware but needs external
           usb reset or power on reset to run the new code */

        /* consider timing out and self-resetting */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    } else if (startState == dfuUPLOAD_IDLE) {
    190c:	66006c61 	strvs	r6, [r0], -r1, ror #24
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
    1910:	6d697270 	sfmvs	f7, 2, [r9, #-448]!	; 0xfffffe40
    1914:	6f6e5f65 	svcvs	0x006e5f65
            if (pInformation->USBwLengths.w > 0) {
    1918:	6c616d72 	stclvs	13, cr6, [r1], #-456	; 0xfffffe38
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    191c:	00657a69 	rsbeq	r7, r5, r9, ror #20
    1920:	5f776172 	svcpl	0x00776172
    1924:	00646461 	rsbeq	r6, r4, r1, ror #8
    1928:	69727066 	ldmdbvs	r2!, {r1, r2, r5, r6, ip, sp, lr}^
    192c:	6f5f656d 	svcvs	0x005f656d
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1930:	3200656e 	andcc	r6, r0, #461373440	; 0x1b800000
    1934:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
    1938:	726f6d2f 	rsbvc	r6, pc, #3008	; 0xbc0
    193c:	35326870 	ldrcc	r6, [r2, #-2160]!	; 0x870
    1940:	2e393135 	mrccs	1, 1, r3, cr9, cr5, {1}
    1944:	70790063 	rsbsvc	r0, r9, r3, rrx
                    thisBlockLen = uploadBlockLen;
    1948:	0073756c 	rsbseq	r7, r3, ip, ror #10
    194c:	70726f6d 	rsbsvc	r6, r2, sp, ror #30
                    dfuAppStatus.bState  = dfuUPLOAD_IDLE;
                } else {
                    /* if above comparison was just equal, thisBlockLen becomes zero
                    next time when USBWValue has been increased by one */
                    thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
    1950:	35353268 	ldrcc	r3, [r5, #-616]!	; 0x268
    1954:	655f3931 	ldrbvs	r3, [pc, #-2353]	; 102b <USB_LP_CAN1_RX0_IRQHandler+0xab>
    1958:	6d006d32 	stcvs	13, cr6, [r0, #-200]	; 0xffffff38
    195c:	79653278 	stmdbvc	r5!, {r3, r4, r5, r6, r9, ip, sp}^
                    
                    /* check for overflow due to USBwValue out of range */
                    if (thisBlockLen >= pInformation->USBwLengths.w) {
    1960:	6e6f6d00 	cdpvs	13, 6, cr6, cr15, cr0, {0}
    1964:	6d6f6774 	stclvs	7, cr6, [pc, #-464]!	; 179c <dfuCopyBufferToExec+0x50>
                        thisBlockLen = 0;
    1968:	00797265 	rsbseq	r7, r9, r5, ror #4
                    }
                    
                    dfuAppStatus.bState  = dfuIDLE;
                }
            } else {
                dfuAppStatus.bState  = dfuERROR;
    196c:	65327965 	ldrvs	r7, [r2, #-2405]!	; 0x965
                dfuAppStatus.bStatus = errNOTDONE;
    1970:	6f6d0078 	svcvs	0x006d0078
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    1974:	32687072 	rsbcc	r7, r8, #114	; 0x72
            dfuAppStatus.bState  = dfuIDLE;
    1978:	39313535 	ldmdbcc	r1!, {r0, r2, r4, r5, r8, sl, ip, sp}
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    197c:	65326d5f 	ldrvs	r6, [r2, #-3423]!	; 0xd5f
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1980:	696d7900 	stmdbvs	sp!, {r8, fp, ip, sp, lr}^
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1984:	0073756e 	rsbseq	r7, r3, lr, ror #10
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuERROR)               {
    1988:	6c67736d 	stclvs	3, cr7, [r7], #-436	; 0xfffffe4c
        /* status is in error, awaiting DFU_CLRSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    198c:	6c006e65 	stcvs	14, cr6, [r0], {101}	; 0x65
    1990:	00746665 	rsbseq	r6, r4, r5, ror #12
    1994:	6c6c6966 	stclvs	9, cr6, [ip], #-408	; 0xfffffe68
            /* todo, add routine to wait for last block write to finish */
            dfuAppStatus.bState  = dfuERROR;
    1998:	61687300 	cmnvs	r8, r0, lsl #6
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    199c:	5f363532 	svcpl	0x00363532
            dfuAppStatus.bState  = dfuERROR;
        } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
    19a0:	696e6966 	stmdbvs	lr!, {r1, r2, r5, r6, r8, fp, sp, lr}^
            /* todo handle any cleanup we need here */
            dfuAppStatus.bState  = dfuIDLE;
    19a4:	70006873 	andvc	r6, r0, r3, ror r8
            dfuAppStatus.bStatus = OK;
    19a8:	006e6461 	rsbeq	r6, lr, r1, ror #8
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else {
        /* some kind of error... */
        dfuAppStatus.bState  = dfuERROR;
    19ac:	68676968 	stmdavs	r7!, {r3, r5, r6, r8, fp, sp, lr}^
        dfuAppStatus.bStatus = errSTALLEDPKT;
    19b0:	35353200 	ldrcc	r3, [r5, #-512]!	; 0x200
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}
    19b4:	732f3931 	teqvc	pc, #802816	; 0xc4000
    19b8:	35326168 	ldrcc	r6, [r2, #-360]!	; 0x168
    19bc:	00632e36 	rsbeq	r2, r3, r6, lsr lr
    19c0:	32616873 	rsbcc	r6, r1, #7536640	; 0x730000
    19c4:	705f3635 	subsvc	r3, pc, r5, lsr r6	; <UNPREDICTABLE>
    19c8:	65636f72 	strbvs	r6, [r3, #-3954]!	; 0xf72
    19cc:	73007373 	movwvc	r7, #883	; 0x373
    19d0:	35326168 	ldrcc	r6, [r2, #-360]!	; 0x168
    19d4:	70755f36 	rsbsvc	r5, r5, r6, lsr pc
    19d8:	65746164 	ldrbvs	r6, [r4, #-356]!	; 0x164
    19dc:	6d657400 	cfstrdvs	mvd7, [r5, #-0]
    19e0:	74003170 	strvc	r3, [r0], #-368	; 0x170
    19e4:	32706d65 	rsbscc	r6, r0, #6464	; 0x1940
    19e8:	61687300 	cmnvs	r8, r0, lsl #6
    19ec:	5f363532 	svcpl	0x00363532
    19f0:	64646170 	strbtvs	r6, [r4], #-368	; 0x170
    19f4:	00676e69 	rsbeq	r6, r7, r9, ror #28
    19f8:	65676964 	strbvs	r6, [r7, #-2404]!	; 0x964
    dfuAppStatus.bState = newState;
}

bool dfuUploadStarted()
{
    return dfuBusy;
    19fc:	6c007473 	cfstrsvs	mvf7, [r0], {115}	; 0x73
}
    1a00:	00747361 	rsbseq	r7, r4, r1, ror #6
    1a04:	61746f74 	cmnvs	r4, r4, ror pc

void dfuFinishUpload() {

    while (1)
	{
		__asm__ __volatile__ ("");
    1a08:	69735f6c 	ldmdbvs	r3!, {r2, r3, r5, r6, r8, r9, sl, fp, ip, lr}^
};

/* Conversion to and from projective coordinates */
void ed25519_project(struct ed25519_pt *p,
		     const uint8_t *x, const uint8_t *y)
{
    1a0c:	7700657a 	smlsdxvc	r0, sl, r5, r6
    1a10:	00353169 	eorseq	r3, r5, r9, ror #2
    1a14:	7473616c 	ldrbtvc	r6, [r3], #-364	; 0x16c
    1a18:	7a69735f 	bvc	1a5e79c <_etext+0x1a57188>
    1a1c:	666f0065 	strbtvs	r0, [pc], -r5, rrx
    1a20:	74657366 	strbtvc	r7, [r5], #-870	; 0x366
    1a24:	6d657400 	cfstrdvs	mvd7, [r5, #-0]
    1a28:	6f720070 	svcvs	0x00720070
    1a2c:	00343674 	eorseq	r3, r4, r4, ror r6
    1a30:	726f7473 	rsbvc	r7, pc, #1929379840	; 0x73000000
    1a34:	00343665 	eorseq	r3, r4, r5, ror #12
    1a38:	31353532 	teqcc	r5, r2, lsr r5
    1a3c:	68732f39 	ldmdavs	r3!, {r0, r3, r4, r5, r8, r9, sl, fp, sp}^
    1a40:	32313561 	eorscc	r3, r1, #406847488	; 0x18400000
    1a44:	6c00632e 	stcvs	3, cr6, [r0], {46}	; 0x2e
    1a48:	3664616f 	strbtcc	r6, [r4], -pc, ror #2
    1a4c:	6f720034 	svcvs	0x00720034
    1a50:	5f646e75 	svcpl	0x00646e75
    1a54:	6d69006b 	stclvs	0, cr0, [r9, #-428]!	; 0xfffffe54
    1a58:	2e656761 	cdpcs	7, 6, cr6, cr5, cr1, {3}
    1a5c:	65680063 	strbvs	r0, [r8, #-99]!	; 0x63
    1a60:	72656461 	rsbvc	r6, r5, #1627389952	; 0x61000000
    1a64:	77656e00 	strbvc	r6, [r5, -r0, lsl #28]!
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
    1a68:	646e6148 	strbtvs	r6, [lr], #-328	; 0x148
	f25519_mul__distinct(p->t, x, y);
    1a6c:	4900656c 	stmdbmi	r0, {r2, r3, r5, r6, r8, sl, sp, lr}
    1a70:	6567616d 	strbvs	r6, [r7, #-365]!	; 0x16d
}
    1a74:	746f6f52 	strbtvc	r6, [pc], #-3922	; 1a7c <ed25519_unproject>
		     const uint8_t *x, const uint8_t *y)
{
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
	f25519_mul__distinct(p->t, x, y);
    1a78:	64616548 	strbtvs	r6, [r1], #-1352	; 0x548
}

void ed25519_unproject(uint8_t *x, uint8_t *y,
		       const struct ed25519_pt *p)
{
    1a7c:	6d007265 	sfmvs	f7, 4, [r0, #-404]	; 0xfffffe6c
    1a80:	63696761 	cmnvs	r9, #25427968	; 0x1840000
    1a84:	706d6300 	rsbvc	r6, sp, r0, lsl #6
	uint8_t z1[F25519_SIZE];

	f25519_inv__distinct(z1, p->z);
    1a88:	00646e45 	rsbeq	r6, r4, r5, asr #28
    1a8c:	61746164 	cmnvs	r4, r4, ror #2
	f25519_mul__distinct(x, p->x, z1);
    1a90:	657a6953 	ldrbvs	r6, [sl, #-2387]!	; 0x953
    1a94:	66756200 	ldrbtvs	r6, [r5], -r0, lsl #4
    1a98:	7a695366 	bvc	1a56838 <_etext+0x1a4f224>
	f25519_mul__distinct(y, p->y, z1);
    1a9c:	6d690065 	stclvs	0, cr0, [r9, #-404]!	; 0xfffffe6c
    1aa0:	54656761 	strbtpl	r6, [r5], #-1889	; 0x761
    1aa4:	00657079 	rsbeq	r7, r5, r9, ror r0

	f25519_normalize(x);
    1aa8:	73616c66 	cmnvc	r1, #26112	; 0x6600
	f25519_normalize(y);
    1aac:	64644168 	strbtvs	r4, [r4], #-360	; 0x168
    1ab0:	73736572 	cmnvc	r3, #478150656	; 0x1c800000
}
    1ab4:	67697300 	strbvs	r7, [r9, -r0, lsl #6]!
	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
};

void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y)
{
    1ab8:	676e696e 	strbvs	r6, [lr, -lr, ror #18]!
    1abc:	6f6f7200 	svcvs	0x006f7200
    1ac0:	00414374 	subeq	r4, r1, r4, ror r3
    1ac4:	67616d49 	strbvs	r6, [r1, -r9, asr #26]!
    1ac8:	67695365 	strbvs	r5, [r9, -r5, ror #6]!
    1acc:	676e696e 	strbvs	r6, [lr, -lr, ror #18]!
    1ad0:	65747845 	ldrbvs	r7, [r4, #-2117]!	; 0x845
    1ad4:	6f69736e 	svcvs	0x0069736e
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
    1ad8:	6d69006e 	stclvs	0, cr0, [r9, #-440]!	; 0xfffffe48
    1adc:	42656761 	rsbmi	r6, r5, #25427968	; 0x1840000
    1ae0:	65666675 	strbvs	r6, [r6, #-1653]!	; 0x675
    1ae4:	68730072 	ldmdavs	r3!, {r1, r4, r5, r6}^
    1ae8:	646c756f 	strbtvs	r7, [ip], #-1391	; 0x56f
    1aec:	73617245 	cmnvc	r1, #1342177284	; 0x50000004
    1af0:	616c4665 	cmnvs	ip, r5, ror #12
    1af4:	6e4f6873 	mcrvs	8, 2, r6, cr15, cr3, {3}
    1af8:	6c696146 	stfvse	f6, [r9], #-280	; 0xfffffee8
    1afc:	67697300 	strbvs	r7, [r9, -r0, lsl #6]!
	parity = (tmp[0] & 1) << 7;
    1b00:	66667562 	strbtvs	r7, [r6], -r2, ror #10

	f25519_copy(c, y);
	f25519_normalize(c);
    1b04:	66756200 	ldrbtvs	r6, [r5], -r0, lsl #4
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1b08:	53726566 	cmnpl	r2, #427819008	; 0x19800000
    1b0c:	00657a69 	rsbeq	r7, r5, r9, ror #20

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1b10:	71696e75 	smcvc	38629	; 0x96e5
}
    1b14:	44496575 	strbmi	r6, [r9], #-1397	; 0x575

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b18:	616d6900 	cmnvs	sp, r0, lsl #18
    1b1c:	69536567 	ldmdbvs	r3, {r0, r1, r2, r5, r6, r8, sl, sp, lr}^
    1b20:	74616e67 	strbtvc	r6, [r1], #-3687	; 0xe67
    1b24:	00657275 	rsbeq	r7, r5, r5, ror r2
	const int parity = comp[31] >> 7;
    1b28:	6c696166 	stfvse	f6, [r9], #-408	; 0xfffffe68
    1b2c:	73617245 	cmnvc	r1, #1342177284	; 0x50000004
    1b30:	6d490065 	stclvs	0, cr0, [r9, #-404]	; 0xfffffe6c
    1b34:	48656761 	stmdami	r5!, {r0, r5, r6, r8, r9, sl, sp, lr}^
    1b38:	65646165 	strbvs	r6, [r4, #-357]!	; 0x165
    1b3c:	72460072 	subvc	r0, r6, #114	; 0x72
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b40:	73556565 	cmpvc	r5, #423624704	; 0x19400000
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1b44:	75427265 	strbvc	r7, [r2, #-613]	; 0x265
    1b48:	72656666 	rsbvc	r6, r5, #106954752	; 0x6600000
    1b4c:	74654700 	strbtvc	r4, [r5], #-1792	; 0x700
    1b50:	74537854 	ldrbvc	r7, [r3], #-2132	; 0x854
    1b54:	536c6c61 	cmnpl	ip, #24832	; 0x6100
	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
	f25519_add(a, b, f25519_one);
    1b58:	75746174 	ldrbvc	r6, [r4, #-372]!	; 0x174
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1b5c:	65530073 	ldrbvs	r0, [r3, #-115]	; 0x73

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
    1b60:	44504574 	ldrbmi	r4, [r0], #-1396	; 0x574
    1b64:	75426c62 	strbvc	r6, [r2, #-3170]	; 0xc62
	f25519_add(a, b, f25519_one);
    1b68:	64413166 	strbvs	r3, [r1], #-358	; 0x166
    1b6c:	53007264 	movwpl	r7, #612	; 0x264
    1b70:	50457465 	subpl	r7, r5, r5, ror #8
	f25519_inv__distinct(b, a);
    1b74:	61567854 	cmpvs	r6, r4, asr r8
    1b78:	0064696c 	rsbeq	r6, r4, ip, ror #18

	/* Compute a = y^2-1 */
	f25519_sub(a, c, f25519_one);
    1b7c:	44746553 	ldrbtmi	r6, [r4], #-1363	; 0x553
    1b80:	6c42756f 	cfstr64vs	mvdx7, [r2], {111}	; 0x6f

	/* Compute c = a*b = (y^2-1)/(1-dy^2) */
	f25519_mul__distinct(c, a, b);
    1b84:	66754265 	ldrbtvs	r4, [r5], -r5, ror #4
    1b88:	53504566 	cmppl	r0, #427819008	; 0x19800000
    1b8c:	6c6c6174 	stfvse	f6, [ip], #-464	; 0xfffffe30

	/* Compute a, b = +/-sqrt(c), if c is square */
	f25519_sqrt(a, c);
    1b90:	5f504500 	svcpl	0x00504500
    1b94:	46554244 	ldrbmi	r4, [r5], -r4, asr #4
	f25519_neg(b, a);
    1b98:	54554f5f 	ldrbpl	r4, [r5], #-3935	; 0xf5f
    1b9c:	74654700 	strbtvc	r4, [r5], #-1792	; 0x700

	/* Select one of them, based on the compressed parity bit */
	f25519_select(x, a, b, (a[0] ^ parity) & 1);
    1ba0:	78525045 	ldmdavc	r2, {r0, r2, r6, ip, lr}^
    1ba4:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
    1ba8:	54007375 	strpl	r7, [r0], #-885	; 0x375
    1bac:	6c67676f 	stclvs	7, cr6, [r7], #-444	; 0xfffffe44
    1bb0:	4f544465 	svcmi	0x00544465

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
    1bb4:	58545f47 	ldmdapl	r4, {r0, r1, r2, r6, r8, r9, sl, fp, ip, lr}^
    1bb8:	74654700 	strbtvc	r4, [r5], #-1792	; 0x700
    1bbc:	64415045 	strbvs	r5, [r1], #-69	; 0x45
	f25519_normalize(a);
    1bc0:	73657264 	cmnvc	r5, #100, 4	; 0x40000006
	f25519_normalize(c);
    1bc4:	455f0073 	ldrbmi	r0, [pc, #-115]	; 1b59 <ed25519_try_unpack+0x41>
    1bc8:	42445f50 	submi	r5, r4, #80, 30	; 0x140

	return f25519_eq(a, c);
    1bcc:	445f4655 	ldrbmi	r4, [pc], #-1621	; 1bd4 <ed25519_try_unpack+0xbc>
    1bd0:	53005249 	movwpl	r5, #585	; 0x249
}
    1bd4:	53497465 	movtpl	r7, #37989	; 0x9465
    1bd8:	42005254 	andmi	r5, r0, #84, 4	; 0x40000005
    1bdc:	53657479 	cmnpl	r5, #2030043136	; 0x79000000
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1be0:	00706177 	rsbseq	r6, r0, r7, ror r1
    1be4:	6c424e77 	mcrrvs	14, 7, r4, r2, cr7
    1be8:	736b636f 	cmnvc	fp, #-1140850687	; 0xbc000001
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bec:	656c4300 	strbvs	r4, [ip, #-768]!	; 0x300
    1bf0:	54447261 	strbpl	r7, [r4], #-609	; 0x261
    1bf4:	525f474f 	subspl	r4, pc, #20709376	; 0x13c0000
	f25519_sub(d, p2->y, p2->x);
    1bf8:	41620058 	qdsubmi	r0, r8, r2
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bfc:	00726464 	rsbseq	r6, r2, r4, ror #8
	f25519_sub(d, p2->y, p2->x);
    1c00:	43746547 	cmnmi	r4, #297795584	; 0x11c00000
    1c04:	0052544e 	subseq	r5, r2, lr, asr #8
	f25519_mul__distinct(a, c, d);
    1c08:	52746547 	rsbspl	r6, r4, #297795584	; 0x11c00000
    1c0c:	61745378 	cmnvs	r4, r8, ror r3
    1c10:	74536c6c 	ldrbvc	r6, [r3], #-3180	; 0xc6c

	/* B = (Y1+X1)(Y2+X2) */
	f25519_add(c, p1->y, p1->x);
    1c14:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
    1c18:	74654700 	strbtvc	r4, [r5], #-1792	; 0x700
	f25519_add(d, p2->y, p2->x);
    1c1c:	44444144 	strbmi	r4, [r4], #-324	; 0x144
    1c20:	43770052 	cmnmi	r7, #82	; 0x52
    1c24:	746e756f 	strbtvc	r7, [lr], #-1391	; 0x56f
	f25519_mul__distinct(b, c, d);
    1c28:	74655300 	strbtvc	r5, [r5], #-768	; 0x300
    1c2c:	64415045 	strbvs	r5, [r1], #-69	; 0x45

	/* C = T1 k T2 */
	f25519_mul__distinct(d, p1->t, p2->t);
    1c30:	73657264 	cmnvc	r5, #100, 4	; 0x40000006
    1c34:	65530073 	ldrbvs	r0, [r3, #-115]	; 0x73
    1c38:	52504574 	subspl	r4, r0, #116, 10	; 0x1d000000
    1c3c:	61745378 	cmnvs	r4, r8, ror r3
	f25519_mul__distinct(c, d, ed25519_k);
    1c40:	00737574 	rsbseq	r7, r3, r4, ror r5
    1c44:	67676f54 			; <UNDEFINED> instruction: 0x67676f54

	/* D = Z1 2 Z2 */
	f25519_mul__distinct(d, p1->z, p2->z);
    1c48:	5444656c 	strbpl	r6, [r4], #-1388	; 0x56c
    1c4c:	525f474f 	subspl	r4, pc, #20709376	; 0x13c0000
    1c50:	65530058 	ldrbvs	r0, [r3, #-88]	; 0x58
    1c54:	44504574 	ldrbmi	r4, [r0], #-1396	; 0x574
	f25519_add(d, d, d);
    1c58:	75426c62 	strbvc	r6, [r2, #-3170]	; 0xc62
    1c5c:	64416666 	strbvs	r6, [r1], #-1638	; 0x666

	/* E = B - A */
	f25519_sub(e, b, a);
    1c60:	53007264 	movwpl	r7, #612	; 0x264
    1c64:	50457465 	subpl	r7, r5, r5, ror #8
    1c68:	65707954 	ldrbvs	r7, [r0, #-2388]!	; 0x954

	/* F = D - C */
	f25519_sub(f, d, c);
    1c6c:	5f504500 	svcpl	0x00504500
    1c70:	46554244 	ldrbmi	r4, [r5], -r4, asr #4

	/* G = D + C */
	f25519_add(g, d, c);
    1c74:	004e495f 	subeq	r4, lr, pc, asr r9
    1c78:	74655277 	strbtvc	r5, [r5], #-631	; 0x277
    1c7c:	74654700 	strbtvc	r4, [r5], #-1792	; 0x700

	/* H = B + A */
	f25519_add(h, b, a);
    1c80:	78525045 	ldmdavc	r2, {r0, r2, r6, ip, lr}^
    1c84:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1c88:	74655300 	strbtvc	r5, [r5], #-768	; 0x300
    1c8c:	62445045 	subvs	r5, r4, #69	; 0x45
    1c90:	6675426c 	ldrbtvs	r4, [r5], -ip, ror #4

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1c94:	64644130 	strbtvs	r4, [r4], #-304	; 0x130
    1c98:	65470072 	strbvs	r0, [r7, #-114]	; 0x72
    1c9c:	54504574 	ldrbpl	r4, [r0], #-1396	; 0x574

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1ca0:	61745378 	cmnvs	r4, r8, ror r3
    1ca4:	00737574 	rsbseq	r7, r3, r4, ror r5
    1ca8:	72694462 	rsbvc	r4, r9, #1644167168	; 0x62000000

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1cac:	79547700 	ldmdbvc	r4, {r8, r9, sl, ip, sp, lr}^
    1cb0:	75006570 	strvc	r6, [r0, #-1392]	; 0x570
    1cb4:	6c5f6273 	lfmvs	f6, 2, [pc], {115}	; 0x73
}
    1cb8:	752f6269 	strvc	r6, [pc, #-617]!	; 1a57 <ed25519_project+0x4b>
    1cbc:	725f6273 	subsvc	r6, pc, #805306375	; 0x30000007

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1cc0:	2e736765 	cdpcs	7, 7, cr6, cr3, cr5, {3}
    1cc4:	50450063 	subpl	r0, r5, r3, rrx

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1cc8:	5542445f 	strbpl	r4, [r2, #-1119]	; 0x45f
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1ccc:	52455f46 	subpl	r5, r5, #280	; 0x118
    1cd0:	65470052 	strbvs	r0, [r7, #-82]	; 0x52

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1cd4:	44504574 	ldrbmi	r4, [r0], #-1396	; 0x574
    1cd8:	75426c62 	strbvc	r6, [r2, #-3170]	; 0xc62
    1cdc:	72694466 	rsbvc	r4, r9, #1711276032	; 0x66000000

	/* C = 2 Z1^2 */
	f25519_mul__distinct(c, p->z, p->z);
    1ce0:	75427700 	strbvc	r7, [r2, #-1792]	; 0x700
    1ce4:	64413166 	strbvs	r3, [r1], #-358	; 0x166
    1ce8:	77007264 	strvc	r7, [r0, -r4, ror #4]
	f25519_add(c, c, c);
    1cec:	00577753 	subseq	r7, r7, r3, asr r7
    1cf0:	45746553 	ldrbmi	r6, [r4, #-1363]!	; 0x553

	/* D = a A (alter sign) */
	/* E = (X1+Y1)^2-A-B */
	f25519_add(f, p->x, p->y);
    1cf4:	756f4450 	strbvc	r4, [pc, #-1104]!	; 18ac <dfuUpdateByRequest+0x104>
    1cf8:	42656c62 	rsbmi	r6, r5, #25088	; 0x6200
    1cfc:	00666675 	rsbeq	r6, r6, r5, ror r6
	f25519_mul__distinct(e, f, f);
    1d00:	6f576f54 	svcvs	0x00576f54
    1d04:	53006472 	movwpl	r6, #1138	; 0x472
	f25519_sub(e, e, a);
    1d08:	50457465 	subpl	r7, r5, r5, ror #8
    1d0c:	64417854 	strbvs	r7, [r1], #-2132	; 0x854
    1d10:	43007264 	movwmi	r7, #612	; 0x264
	f25519_sub(e, e, b);
    1d14:	7261656c 	rsbvc	r6, r1, #108, 10	; 0x1b000000
    1d18:	6f445045 	svcvs	0x00445045

	/* G = D + B */
	f25519_sub(g, b, a);
    1d1c:	656c6275 	strbvs	r6, [ip, #-629]!	; 0x275
    1d20:	66667542 	strbtvs	r7, [r6], -r2, asr #10
    1d24:	74654700 	strbtvc	r4, [r5], #-1792	; 0x700

	/* F = G - C */
	f25519_sub(f, g, c);
    1d28:	62445045 	subvs	r5, r4, #69	; 0x45
    1d2c:	6675426c 	ldrbtvs	r4, [r5], -ip, ror #4

	/* H = D - B */
	f25519_neg(h, b);
    1d30:	64644131 	strbtvs	r4, [r4], #-305	; 0x131
    1d34:	65470072 	strbvs	r0, [r7, #-114]	; 0x72
	f25519_sub(h, h, a);
    1d38:	54504574 	ldrbpl	r4, [r0], #-1396	; 0x574
    1d3c:	00657079 	rsbeq	r7, r5, r9, ror r0
    1d40:	61656c43 	cmnvs	r5, r3, asr #24

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1d44:	5f504572 	svcpl	0x00504572
    1d48:	5f525443 	svcpl	0x00525443

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1d4c:	53005852 	movwpl	r5, #2130	; 0x852
    1d50:	50457465 	subpl	r7, r5, r5, ror #8
    1d54:	426c6244 	rsbmi	r6, ip, #68, 4	; 0x40000004

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1d58:	43666675 	cmnmi	r6, #122683392	; 0x7500000
    1d5c:	746e756f 	strbtvc	r7, [lr], #-1391	; 0x56f
    1d60:	74655300 	strbtvc	r5, [r5], #-768	; 0x300

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1d64:	4b5f5045 	blmi	17d5e80 <_etext+0x17ce86c>
    1d68:	00444e49 	subeq	r4, r4, r9, asr #28
    1d6c:	45746553 	ldrbmi	r6, [r4, #-1363]!	; 0x553
}
    1d70:	43785450 	cmnmi	r8, #80, 8	; 0x50000000

void ed25519_smult(struct ed25519_pt *r_out, const struct ed25519_pt *p,
		   const uint8_t *e)
{
    1d74:	746e756f 	strbtvc	r7, [lr], #-1391	; 0x56f
    1d78:	656c4300 	strbvs	r4, [ip, #-768]!	; 0x300
    1d7c:	50457261 	subpl	r7, r5, r1, ror #4
    1d80:	4e494b5f 	vmovmi.8	d9[2], r4
    1d84:	65470044 	strbvs	r0, [r7, #-68]	; 0x44
    1d88:	41544274 	cmpmi	r4, r4, ror r2
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1d8c:	00454c42 	subeq	r4, r5, r2, asr #24
    1d90:	49746547 	ldmdbmi	r4!, {r0, r1, r2, r6, r8, sl, sp, lr}^
    1d94:	00525453 	subseq	r5, r2, r3, asr r4
		struct ed25519_pt s;

		ed25519_double(&r, &r);
    1d98:	67655277 			; <UNDEFINED> instruction: 0x67655277
    1d9c:	756c6156 	strbvc	r6, [ip, #-342]!	; 0x156
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1da0:	65470065 	strbvs	r0, [r7, #-101]	; 0x65
		struct ed25519_pt s;

		ed25519_double(&r, &r);
		ed25519_add(&s, &r, p);
    1da4:	444e4574 	strbmi	r4, [lr], #-1396	; 0x574
    1da8:	4e494f50 	mcrmi	15, 2, r4, cr9, cr0, {2}

		f25519_select(r.x, r.x, s.x, bit);
    1dac:	41770054 	cmnmi	r7, r4, asr r0
    1db0:	00726464 	rsbseq	r6, r2, r4, ror #8
    1db4:	45746547 	ldrbmi	r6, [r4, #-1351]!	; 0x547
		f25519_select(r.y, r.y, s.y, bit);
    1db8:	6c624450 	cfstrdvs	mvd4, [r2], #-320	; 0xfffffec0
    1dbc:	30667542 	rsbcc	r7, r6, r2, asr #10
    1dc0:	6e756f43 	cdpvs	15, 7, cr6, cr5, cr3, {2}
		f25519_select(r.z, r.z, s.z, bit);
    1dc4:	65530074 	ldrbvs	r0, [r3, #-116]	; 0x74
    1dc8:	44414474 	strbmi	r4, [r1], #-1140	; 0x474
    1dcc:	70005244 	andvc	r5, r0, r4, asr #4
		f25519_select(r.t, r.t, s.t, bit);
    1dd0:	65527764 	ldrbvs	r7, [r2, #-1892]	; 0x764
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1dd4:	65530067 	ldrbvs	r0, [r3, #-103]	; 0x67
		ed25519_add(&s, &r, p);

		f25519_select(r.x, r.x, s.x, bit);
		f25519_select(r.y, r.y, s.y, bit);
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
    1dd8:	43504574 	cmpmi	r0, #116, 10	; 0x1d000000
    1ddc:	746e756f 	strbtvc	r7, [lr], #-1391	; 0x56f
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1de0:	65527852 	ldrbvs	r7, [r2, #-2130]	; 0x852
    1de4:	65470067 	strbvs	r0, [r7, #-103]	; 0x67
    1de8:	52504574 	subspl	r4, r0, #116, 10	; 0x1d000000
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
	}

	ed25519_copy(r_out, &r);
}
    1dec:	756f4378 	strbvc	r4, [pc, #-888]!	; 1a7c <ed25519_unproject>
    1df0:	6200746e 	andvs	r7, r0, #1845493760	; 0x6e000000
    1df4:	706d6554 	rsbvc	r6, sp, r4, asr r5
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1df8:	74655300 	strbtvc	r5, [r5], #-768	; 0x300
    1dfc:	52544e43 	subspl	r4, r4, #1072	; 0x430
    1e00:	74655300 	strbtvc	r5, [r5], #-768	; 0x300
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e04:	42415442 	submi	r5, r1, #1107296256	; 0x42000000
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1e08:	4700454c 	strmi	r4, [r0, -ip, asr #10]
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e0c:	50457465 	subpl	r7, r5, r5, ror #8
    1e10:	6f437854 	svcvs	0x00437854
    1e14:	00746e75 	rsbseq	r6, r4, r5, ror lr
    1e18:	61656c43 	cmnvs	r5, r3, asr #24
	memcpy(block + 32, a, 32);
    1e1c:	5f504572 	svcpl	0x00504572
    1e20:	5f525443 	svcpl	0x00525443
    1e24:	47005854 	smlsdmi	r0, r4, r8, r5
    1e28:	50457465 	subpl	r7, r5, r5, ror #8
    1e2c:	426c6244 	rsbmi	r6, ip, #68, 4	; 0x40000004
    1e30:	43316675 	teqmi	r1, #122683392	; 0x7500000
    1e34:	746e756f 	strbtvc	r7, [lr], #-1391	; 0x56f
    1e38:	74655300 	strbtvc	r5, [r5], #-768	; 0x300
    1e3c:	62445045 	subvs	r5, r4, #69	; 0x45
    1e40:	6675426c 	ldrbtvs	r4, [r5], -ip, ror #4
    1e44:	756f4330 	strbvc	r4, [pc, #-816]!	; 1b1c <ed25519_try_unpack+0x4>
    1e48:	7700746e 	strvc	r7, [r0, -lr, ror #8]
{
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
    1e4c:	30667542 	rsbcc	r7, r6, r2, asr #10
    1e50:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
    1e54:	74655300 	strbtvc	r5, [r5], #-768	; 0x300
		memcpy(init_block + prefix_size, message, len);
		sha512_final(&s, init_block, len + prefix_size);
	} else {
		size_t i;

		memcpy(init_block + prefix_size, message,
    1e58:	6174535f 	cmnvs	r4, pc, asr r3
    1e5c:	5f737574 	svcpl	0x00737574
    1e60:	0074754f 	rsbseq	r7, r4, pc, asr #10
    1e64:	46746547 	ldrbtmi	r6, [r4], -r7, asr #10
    1e68:	4700524e 	strmi	r5, [r0, -lr, asr #4]
    1e6c:	50457465 	subpl	r7, r5, r5, ror #8
    1e70:	426c6244 	rsbmi	r6, ip, #68, 4	; 0x40000004
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);
    1e74:	41306675 	teqmi	r0, r5, ror r6
    1e78:	00726464 	rsbseq	r6, r2, r4, ror #8

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e7c:	70646e45 	rsbvc	r6, r4, r5, asr #28
    1e80:	746e696f 	strbtvc	r6, [lr], #-2415	; 0x96f
    1e84:	4f54445f 	svcmi	0x0054445f
    1e88:	74535f47 	ldrbvc	r5, [r3], #-3911	; 0xf47
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1e8c:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
		     i + SHA512_BLOCK_SIZE <= len;
    1e90:	74654700 	strbtvc	r4, [r5], #-1792	; 0x700
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1e94:	78545045 	ldmdavc	r4, {r0, r2, r6, ip, lr}^

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e98:	72646441 	rsbvc	r6, r4, #1090519040	; 0x41000000
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
    1e9c:	656c4300 	strbvs	r4, [ip, #-768]!	; 0x300
    1ea0:	54447261 	strbpl	r7, [r4], #-609	; 0x261
    1ea4:	545f474f 	ldrbpl	r4, [pc], #-1871	; 1eac <edsign_verify+0xb4>
    1ea8:	65530058 	ldrbvs	r0, [r3, #-88]	; 0x58
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
		memcpy(init_block + prefix_size, message, len);
    1eac:	54504574 	ldrbpl	r4, [r0], #-1396	; 0x574
    1eb0:	61745378 	cmnvs	r4, r8, ror r3
    1eb4:	00737574 	rsbseq	r7, r3, r4, ror r5
		sha512_final(&s, init_block, len + prefix_size);
    1eb8:	4e704562 	cdpmi	5, 7, cr4, cr0, cr2, {3}
    1ebc:	53006d75 	movwpl	r6, #3445	; 0xd75
    1ec0:	4e457465 	cdpmi	4, 4, cr7, cr5, cr5, {3}
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
	}

	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
    1ec4:	494f5044 	stmdbmi	pc, {r2, r6, ip, lr}^	; <UNPREDICTABLE>
    1ec8:	5300544e 	movwpl	r5, #1102	; 0x44e
    1ecc:	50457465 	subpl	r7, r5, r5, ror #8
	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
    1ed0:	64417852 	strbvs	r7, [r1], #-2130	; 0x852
    1ed4:	53007264 	movwpl	r7, #612	; 0x264
    1ed8:	50457465 	subpl	r7, r5, r5, ror #8

static void sm_pack(uint8_t *r, const uint8_t *k)
{
	struct ed25519_pt p;

	ed25519_smult(&p, &ed25519_base, k);
    1edc:	426c6244 	rsbmi	r6, ip, #68, 4	; 0x40000004
    1ee0:	43316675 	teqmi	r1, #122683392	; 0x7500000
    1ee4:	746e756f 	strbtvc	r7, [lr], #-1391	; 0x56f
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1ee8:	52544300 	subspl	r4, r4, #0, 6
    1eec:	0050485f 	subseq	r4, r0, pc, asr r8
	ed25519_pack(packed, x, y);
    1ef0:	75746553 	ldrbvc	r6, [r4, #-1363]!	; 0x553
    1ef4:	505f3070 	subspl	r3, pc, r0, ror r0	; <UNPREDICTABLE>
    1ef8:	65636f72 	strbvs	r6, [r3, #-3954]!	; 0xf72

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1efc:	53007373 	movwpl	r7, #883	; 0x373
    1f00:	52657661 	rsbpl	r7, r5, #101711872	; 0x6100000

	ed25519_project(p, x, y);
    1f04:	74617453 	strbtvc	r7, [r1], #-1107	; 0x453
    1f08:	61530065 	cmpvs	r3, r5, rrx
    1f0c:	53546576 	cmppl	r4, #494927872	; 0x1d800000
	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
    1f10:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0x174
    1f14:	50457700 	subpl	r7, r5, r0, lsl #14
    1f18:	006c6156 	rsbeq	r6, ip, r6, asr r1

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1f1c:	5f627375 	svcpl	0x00627375
    1f20:	2f62696c 	svccs	0x0062696c

	ed25519_project(p, x, y);
    1f24:	5f627375 	svcpl	0x00627375
    1f28:	2e746e69 	cdpcs	14, 7, cr6, cr4, cr9, {3}
    1f2c:	6e490063 	cdpvs	0, 4, cr0, cr9, cr3, {3}

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
    1f30:	72505f30 	subsvc	r5, r0, #48, 30	; 0xc0
    1f34:	7365636f 	cmnvc	r5, #-1140850687	; 0xbc000001
    1f38:	754f0073 	strbvc	r0, [pc, #-115]	; 1ecd <edsign_verify+0xd5>
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1f3c:	505f3074 	subspl	r3, pc, r4, ror r0	; <UNPREDICTABLE>
    1f40:	65636f72 	strbvs	r6, [r3, #-3954]!	; 0xf72
	ed25519_pack(packed, x, y);
    1f44:	45007373 	strmi	r7, [r0, #-883]	; 0x373
    1f48:	646e6950 	strbtvs	r6, [lr], #-2384	; 0x950
    1f4c:	53007865 	movwpl	r7, #2149	; 0x865
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
    1f50:	53657661 	cmnpl	r5, #101711872	; 0x6100000
    1f54:	65746174 	ldrbvs	r6, [r4, #-372]!	; 0x174
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
    1f58:	62737500 	rsbsvs	r7, r3, #0, 10
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
}
    1f5c:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
    1f60:	6273752f 	rsbsvs	r7, r3, #197132288	; 0xbc00000

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1f64:	696e695f 	stmdbvs	lr!, {r0, r1, r2, r3, r4, r6, r8, fp, sp, lr}^
    1f68:	00632e74 	rsbeq	r2, r3, r4, ror lr
    1f6c:	65735570 	ldrbvs	r5, [r3, #-1392]!	; 0x570
    1f70:	74535f72 	ldrbvc	r5, [r3], #-3954	; 0xf72

const uint8_t f25519_zero[F25519_SIZE] = {0};
const uint8_t f25519_one[F25519_SIZE] = {1};

void f25519_load(uint8_t *x, uint32_t c)
{
    1f74:	61646e61 	cmnvs	r4, r1, ror #28
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
		c >>= 8;
    1f78:	525f6472 	subspl	r6, pc, #1912602624	; 0x72000000
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    1f7c:	65757165 	ldrbvs	r7, [r5, #-357]!	; 0x165
    1f80:	00737473 	rsbseq	r7, r3, r3, ror r4
    1f84:	69766544 	ldmdbvs	r6!, {r2, r6, r8, sl, sp, lr}^
    1f88:	495f6563 	ldmdbmi	pc, {r0, r1, r5, r6, r8, sl, sp, lr}^	; <UNPREDICTABLE>
		c >>= 8;
	}

	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}
    1f8c:	006f666e 	rsbeq	r6, pc, lr, ror #12
    1f90:	5f627375 	svcpl	0x00627375

void f25519_normalize(uint8_t *x)
{
    1f94:	2f62696c 	svccs	0x0062696c
    1f98:	5f627375 	svcpl	0x00627375
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1f9c:	65726f63 	ldrbvs	r6, [r2, #-3939]!	; 0xf63
	x[31] &= 127;
    1fa0:	4500632e 	strmi	r6, [r0, #-814]	; 0x32e

	for (i = 0; i < F25519_SIZE; i++) {
    1fa4:	4f50444e 	svcmi	0x0050444e
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1fa8:	5f544e49 	svcpl	0x00544e49
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
		c += x[i];
    1fac:	4c415453 	cfstrdmi	mvd5, [r1], {83}	; 0x53
		x[i] = c;
    1fb0:	6552004c 	ldrbvs	r0, [r2, #-76]	; 0x4c

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fb4:	746c7573 	strbtvc	r7, [ip], #-1395	; 0x573
		c += x[i];
		x[i] = c;
		c >>= 8;
    1fb8:	736f5000 	cmnvc	pc, #0

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fbc:	505f3074 	subspl	r3, pc, r4, ror r0	; <UNPREDICTABLE>
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += x[i];
    1fc0:	65636f72 	strbvs	r6, [r3, #-3954]!	; 0xf72
		minusp[i] = c;
    1fc4:	44007373 	strmi	r7, [r0], #-883	; 0x373
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1fc8:	42617461 	rsbmi	r7, r1, #1627389952	; 0x61000000
		c += x[i];
		minusp[i] = c;
		c >>= 8;
    1fcc:	65666675 	strbvs	r6, [r6, #-1653]!	; 0x675
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1fd0:	65520072 	ldrbvs	r0, [r2, #-114]	; 0x72
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fd4:	76726573 			; <UNDEFINED> instruction: 0x76726573
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1fd8:	53006465 	movwpl	r6, #1125	; 0x465

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1fdc:	646e6174 	strbtvs	r6, [lr], #-372	; 0x174
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;
    1fe0:	5f647261 	svcpl	0x00647261

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1fe4:	43746553 	cmnmi	r4, #348127232	; 0x14c00000
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    1fe8:	69666e6f 	stmdbvs	r6!, {r0, r1, r2, r3, r5, r6, r9, sl, fp, sp, lr}^
    1fec:	61727567 	cmnvs	r2, r7, ror #10
    1ff0:	6e6f6974 	mcrvs	9, 3, r6, cr15, cr4, {3}
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1ff4:	74614400 	strbtvc	r4, [r1], #-1024	; 0x400
    1ff8:	61745361 	cmnvs	r4, r1, ror #6
	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;

	/* Load x-p if no underflow */
	f25519_select(x, minusp, x, (c >> 15) & 1);
}
    1ffc:	6e496567 	cdpvs	5, 4, cr6, cr9, cr7, {3}
    2000:	56454400 	strbpl	r4, [r5], -r0, lsl #8

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
    2004:	5f454349 	svcpl	0x00454349
    2008:	4f4d4552 	svcmi	0x004d4552
    200c:	575f4554 			; <UNDEFINED> instruction: 0x575f4554
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    2010:	55454b41 	strbpl	r4, [r5, #-2881]	; 0xb41
    2014:	54530050 	ldrbpl	r0, [r3], #-80	; 0x50
    2018:	454c4c41 	strbmi	r4, [ip, #-3137]	; 0xc41
    201c:	79540044 	ldmdbvc	r4, {r2, r6}^
    2020:	525f6570 	subspl	r6, pc, #112, 10	; 0x1c000000
    2024:	65006365 	strvs	r6, [r0, #-869]	; 0x365
    2028:	5f746978 	svcpl	0x00746978
    202c:	61446f4e 	cmpvs	r4, lr, asr #30
    2030:	535f6174 	cmppl	pc, #116, 2
    2034:	70757465 	rsbsvc	r7, r5, r5, ror #8
    2038:	56770030 			; <UNDEFINED> instruction: 0x56770030
    203c:	65756c61 	ldrbvs	r6, [r5, #-3169]!	; 0xc61
    2040:	45440031 	strbmi	r0, [r4, #-49]	; 0x31
    2044:	45434956 	strbmi	r4, [r3, #-2390]	; 0x956
    2048:	5345445f 	movtpl	r4, #21599	; 0x545f
    204c:	50495243 	subpl	r5, r9, r3, asr #4
    2050:	00524f54 	subseq	r4, r2, r4, asr pc
    2054:	49525453 	ldmdbmi	r2, {r0, r1, r4, r6, sl, ip, lr}^
    2058:	445f474e 	ldrbmi	r4, [pc], #-1870	; 2060 <f25519_eq+0x5c>
    205c:	52435345 	subpl	r5, r3, #335544321	; 0x14000001
    2060:	4f545049 	svcmi	0x00545049
    2064:	73550052 	cmpvc	r5, #82	; 0x52
    2068:	6f547265 	svcvs	0x00547265
    206c:	42414d50 	submi	r4, r1, #80, 26	; 0x1400

	sum |= (sum >> 4);
    2070:	65666675 	strbvs	r6, [r6, #-1653]!	; 0x675
	sum |= (sum >> 2);
    2074:	706f4372 	rsbvc	r4, pc, r2, ror r3	; <UNPREDICTABLE>
	sum |= (sum >> 1);
    2078:	61730079 	cmnvs	r3, r9, ror r0

	return (sum ^ 1) & 1;
    207c:	725f6576 	subsvc	r6, pc, #494927872	; 0x1d800000
}
    2080:	676e654c 	strbvs	r6, [lr, -ip, asr #10]!
    2084:	4c006874 	stcmi	8, cr6, [r0], {116}	; 0x74
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2088:	5f545341 	svcpl	0x00545341
		sum |= x[i] ^ y[i];
    208c:	445f4e49 	ldrbmi	r4, [pc], #-3657	; 2094 <f25519_eq+0x90>
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2090:	00415441 	subeq	r5, r1, r1, asr #8
    2094:	5f504f4e 	svcpl	0x00504f4e
		sum |= x[i] ^ y[i];
    2098:	636f7250 	cmnvs	pc, #80, 4
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    209c:	00737365 	rsbseq	r7, r3, r5, ror #6
}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
    20a0:	6e617453 	mcrvs	4, 3, r7, cr1, cr3, {2}
    20a4:	64726164 	ldrbtvs	r6, [r2], #-356	; 0x164
    20a8:	7465535f 	strbtvc	r5, [r5], #-863	; 0x35f
    20ac:	65746e49 	ldrbvs	r6, [r4, #-3657]!	; 0xe49
    20b0:	63616672 	cmnvs	r1, #119537664	; 0x7200000
    20b4:	78450065 	stmdavc	r5, {r0, r2, r5, r6}^
    20b8:	74636570 	strbtvc	r6, [r3], #-1392	; 0x570
    20bc:	6174535f 	cmnvs	r4, pc, asr r3
    20c0:	5f737574 	svcpl	0x00737574
	const uint8_t mask = -condition;
    20c4:	0074754f 	rsbseq	r7, r4, pc, asr #10
    20c8:	53554150 	cmppl	r5, #80, 2
    20cc:	65520045 	ldrbvs	r0, [r2, #-69]	; 0x45
    20d0:	73657571 	cmnvc	r5, #473956352	; 0x1c400000
    20d4:	006f4e74 	rsbeq	r4, pc, r4, ror lr	; <UNPREDICTABLE>
    20d8:	5f544547 	svcpl	0x00544547
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    20dc:	45544e49 	ldrbmi	r4, [r4, #-3657]	; 0xe49
    20e0:	43414652 	movtmi	r4, #5714	; 0x1652
    20e4:	74530045 	ldrbvc	r0, [r3], #-69	; 0x45
    20e8:	61646e61 	cmnvs	r4, r1, ror #28
    20ec:	535f6472 	cmppl	pc, #1912602624	; 0x72000000
    20f0:	6e457465 	cdpvs	4, 4, cr7, cr5, cr5, {3}
    20f4:	696f5064 	stmdbvs	pc!, {r2, r5, r6, ip, lr}^	; <UNPREDICTABLE>
    20f8:	6546746e 	strbvs	r7, [r6, #-1134]	; 0x46e
    20fc:	72757461 	rsbsvc	r7, r5, #1627389952	; 0x61000000
    2100:	45470065 	strbmi	r0, [r7, #-101]	; 0x65
    2104:	54535f54 	ldrbpl	r5, [r3], #-3924	; 0xf54
    2108:	53555441 	cmppl	r5, #1090519040	; 0x41000000
    210c:	54455300 	strbpl	r5, [r5], #-768	; 0x300
    2110:	4145465f 	cmpmi	r5, pc, asr r6
    2114:	45525554 	ldrbmi	r5, [r2, #-1364]	; 0x554
    2118:	74614400 	strbtvc	r4, [r1], #-1024	; 0x400
    211c:	754d5f61 	strbvc	r5, [sp, #-3937]	; 0xf61
    2120:	614d5f6c 	cmpvs	sp, ip, ror #30
    2124:	63615078 	cmnvs	r1, #120	; 0x78
    2128:	5374656b 	cmnpl	r4, #448790528	; 0x1ac00000
    212c:	00657a69 	rsbeq	r7, r5, r9, ror #20
    2130:	76654470 			; <UNDEFINED> instruction: 0x76654470
    2134:	61745300 	cmnvs	r4, r0, lsl #6
    2138:	7261646e 	rsbvc	r6, r1, #1845493760	; 0x6e000000
    213c:	65535f64 	ldrbvs	r5, [r3, #-3940]	; 0xf64
    2140:	76654474 			; <UNDEFINED> instruction: 0x76654474
    2144:	46656369 	strbtmi	r6, [r5], -r9, ror #6
}
    2148:	75746165 	ldrbvc	r6, [r4, #-357]!	; 0x165
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    214c:	70006572 	andvc	r6, r0, r2, ror r5
    2150:	63736544 	cmnvs	r3, #68, 10	; 0x11000000
    2154:	4e595300 	cdpmi	3, 5, cr5, cr9, cr0, {0}
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2158:	465f4843 	ldrbmi	r4, [pc], -r3, asr #16
    215c:	454d4152 	strbmi	r4, [sp, #-338]	; 0x152
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}
    2160:	61745300 	cmnvs	r4, r0, lsl #6
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    2164:	7261646e 	rsbvc	r6, r1, #1845493760	; 0x6e000000
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}

void f25519_add(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint16_t c = 0;
    2168:	65475f64 	strbvs	r5, [r7, #-3940]	; 0xf64
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
    216c:	746e4974 	strbtvc	r4, [lr], #-2420	; 0x974
    2170:	61667265 	cmnvs	r6, r5, ror #4
		r[i] = c;
    2174:	53006563 	movwpl	r6, #1379	; 0x563
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    2178:	445f5445 	ldrbmi	r5, [pc], #-1093	; 2180 <f25519_add+0x1c>
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;
    217c:	52435345 	subpl	r5, r3, #335544321	; 0x14000001
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    2180:	4f545049 	svcmi	0x00545049
	c = (c >> 7) * 19;
    2184:	45530052 	ldrbmi	r0, [r3, #-82]	; 0x52
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    2188:	4e495f54 	mcrmi	15, 2, r5, cr9, cr4, {2}
	c = (c >> 7) * 19;
    218c:	46524554 			; <UNDEFINED> instruction: 0x46524554
    2190:	00454341 	subeq	r4, r5, r1, asr #6

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2194:	4145465f 	cmpmi	r5, pc, asr r6
    2198:	45525554 	ldrbmi	r5, [r2, #-1364]	; 0x554

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    219c:	4c45535f 	mcrrmi	3, 5, r5, r5, cr15
		c += r[i];
		r[i] = c;
		c >>= 8;
    21a0:	4f544345 	svcmi	0x00544345

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21a4:	74530052 	ldrbvc	r0, [r3], #-82	; 0x52
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    21a8:	61646e61 	cmnvs	r4, r1, ror #28

void f25519_sub(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    21ac:	475f6472 			; <UNDEFINED> instruction: 0x475f6472
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
    21b0:	6f437465 	svcvs	0x00437465
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    21b4:	6769666e 	strbvs	r6, [r9, -lr, ror #12]!
    21b8:	74617275 	strbtvc	r7, [r1], #-629	; 0x275
    21bc:	006e6f69 	rsbeq	r6, lr, r9, ror #30
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21c0:	6e617453 	mcrvs	4, 3, r7, cr1, cr3, {2}
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    21c4:	64726164 	ldrbtvs	r6, [r2], #-356	; 0x164
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21c8:	656c435f 	strbvs	r4, [ip, #-863]!	; 0x35f
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    21cc:	65467261 	strbvs	r7, [r6, #-609]	; 0x261
    21d0:	72757461 	rsbsvc	r7, r5, #1627389952	; 0x61000000
	r[31] = c & 127;
	c = (c >> 7) * 19;
    21d4:	45470065 	strbmi	r0, [r7, #-101]	; 0x65
    21d8:	4f435f54 	svcmi	0x00435f54
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    21dc:	4749464e 	strbmi	r4, [r9, -lr, asr #12]
	c = (c >> 7) * 19;
    21e0:	54415255 	strbpl	r5, [r1], #-597	; 0x255

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    21e4:	004e4f49 	subeq	r4, lr, r9, asr #30
		r[i] = c;
    21e8:	4e4f435f 	mcrmi	3, 2, r4, cr15, cr15, {2}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21ec:	4c4f5254 	sfmmi	f5, 2, [pc], {84}	; 0x54
		c += r[i];
		r[i] = c;
		c >>= 8;
    21f0:	4154535f 	cmpmi	r4, pc, asr r3
	}
}
    21f4:	5f004554 	svcpl	0x00004554

void f25519_neg(uint8_t *r, const uint8_t *a)
{
    21f8:	43534544 	cmpmi	r3, #68, 10	; 0x11000000
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
    21fc:	54504952 	ldrbpl	r4, [r0], #-2386	; 0x952
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 - ((uint32_t)a[i]);
    2200:	545f524f 	ldrbpl	r5, [pc], #-591	; 2208 <f25519_neg+0x10>
    2204:	00455059 	subeq	r5, r5, r9, asr r0
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2208:	54544553 	ldrbpl	r4, [r4], #-1363	; 0x553
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
    220c:	5f474e49 	svcpl	0x00474e49
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2210:	50005055 	andpl	r5, r0, r5, asr r0

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2214:	6f54414d 	svcvs	0x0054414d
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2218:	72657355 	rsbvc	r7, r5, #1409286145	; 0x54000001
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    221c:	66667542 	strbtvs	r7, [r6], -r2, asr #10
	c = (c >> 7) * 19;
    2220:	6f437265 	svcvs	0x00437265
    2224:	53007970 	movwpl	r7, #2416	; 0x970

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2228:	435f5445 	cmpmi	pc, #1157627904	; 0x45000000
		r[i] = c;
    222c:	49464e4f 	stmdbmi	r6, {r0, r1, r2, r3, r6, r9, sl, fp, lr}^

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2230:	41525547 	cmpmi	r2, r7, asr #10
		c += r[i];
		r[i] = c;
		c >>= 8;
    2234:	4e4f4954 	mcrmi	9, 2, r4, cr15, cr4, {2}
	}
}
    2238:	49415700 	stmdbmi	r1, {r8, r9, sl, ip, lr}^
    223c:	54535f54 	ldrbpl	r5, [r3], #-3924	; 0xf54

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2240:	53555441 	cmppl	r5, #1090519040	; 0x41000000
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2244:	54554f5f 	ldrbpl	r4, [r5], #-3935	; 0xf5f
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    2248:	544f5400 	strbpl	r5, [pc], #-1024	; 2250 <f25519_mul__distinct+0x10>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    224c:	735f4c41 	cmpvc	pc, #16640	; 0x4100
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2250:	55514552 	ldrbpl	r4, [r1, #-1362]	; 0x552
		for (j = 0; j <= i; j++)
    2254:	00545345 	subseq	r5, r4, r5, asr #6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2258:	45544e49 	ldrbmi	r4, [r4, #-3657]	; 0xe49

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    225c:	43414652 	movtmi	r4, #5714	; 0x1652
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2260:	45445f45 	strbmi	r5, [r4, #-3909]	; 0xf45

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2264:	49524353 	ldmdbmi	r2, {r0, r1, r4, r6, r8, r9, lr}^
    2268:	524f5450 	subpl	r5, pc, #80, 8	; 0x50000000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    226c:	76617300 	strbtvc	r7, [r1], -r0, lsl #6
    2270:	4c775f65 	ldclmi	15, cr5, [r7], #-404	; 0xfffffe6c
    2274:	74676e65 	strbtvc	r6, [r7], #-3685	; 0xe65
    2278:	74530068 	ldrbvc	r0, [r3], #-104	; 0x68
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    227c:	61646e61 	cmnvs	r4, r1, ror #28
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2280:	475f6472 			; <UNDEFINED> instruction: 0x475f6472
    2284:	74537465 	ldrbvc	r7, [r3], #-1125	; 0x465

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2288:	73757461 	cmnvc	r5, #1627389952	; 0x61000000
			c += ((uint32_t)a[j]) *
    228c:	444e4500 	strbmi	r4, [lr], #-1280	; 0x500
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2290:	4e494f50 	mcrmi	15, 2, r4, cr9, cr0, {2}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2294:	45445f54 	strbmi	r5, [r4, #-3924]	; 0xf54
    2298:	49524353 	ldmdbmi	r2, {r0, r1, r4, r6, r8, r9, lr}^
    229c:	524f5450 	subpl	r5, pc, #80, 8	; 0x50000000

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    22a0:	4e4f4300 	cdpmi	3, 4, cr4, cr15, cr0, {0}
    22a4:	5f474946 	svcpl	0x00474946
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22a8:	43534544 	cmpmi	r3, #68, 10	; 0x11000000
	c = (c >> 7) * 19;
    22ac:	54504952 	ldrbpl	r4, [r0], #-2386	; 0x952

	for (i = 0; i < F25519_SIZE; i++) {
    22b0:	7000524f 	andvc	r5, r0, pc, asr #4
		c += r[i];
    22b4:	00667542 	rsbeq	r7, r6, r2, asr #10
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22b8:	69504570 	ldmdbvs	r0, {r4, r5, r6, r8, sl, lr}^
		c += r[i];
		r[i] = c;
		c >>= 8;
    22bc:	006f666e 	rsbeq	r6, pc, lr, ror #12
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22c0:	5f544553 	svcpl	0x00544553
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    22c4:	52444441 	subpl	r4, r4, #1090519040	; 0x41000000
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    22c8:	00535345 	subseq	r5, r3, r5, asr #6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    22cc:	616c6552 	cmnvs	ip, r2, asr r5
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    22d0:	5f646574 	svcpl	0x00646574
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22d4:	70646e45 	rsbvc	r6, r4, r5, asr #28
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    22d8:	746e696f 	strbtvc	r6, [lr], #-2415	; 0x96f
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22dc:	61745300 	cmnvs	r4, r0, lsl #6
    22e0:	49737574 	ldmdbmi	r3!, {r2, r4, r5, r6, r8, sl, ip, sp, lr}^

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22e4:	006f666e 	rsbeq	r6, pc, lr, ror #12
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22e8:	646e4977 	strbtvs	r4, [lr], #-2423	; 0x977

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22ec:	00307865 	eorseq	r7, r0, r5, ror #16
    22f0:	5f544547 	svcpl	0x00544547
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22f4:	43534544 	cmpmi	r3, #68, 10	; 0x11000000
    22f8:	54504952 	ldrbpl	r4, [r0], #-2386	; 0x952
    22fc:	4400524f 	strmi	r5, [r0], #-591	; 0x24f
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2300:	53617461 	cmnpl	r1, #1627389952	; 0x61000000
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2304:	65676174 	strbvs	r6, [r7, #-372]!	; 0x174
    2308:	0074754f 	rsbseq	r7, r4, pc, asr #10

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    230c:	54494157 	strbpl	r4, [r9], #-343	; 0x157
			c += ((uint32_t)a[j]) *
    2310:	5445535f 	strbpl	r5, [r5], #-863	; 0x35f
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2314:	52005055 	andpl	r5, r0, #85	; 0x55
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2318:	65757165 	ldrbvs	r7, [r5, #-357]!	; 0x165
    231c:	4e5f7473 	mrcmi	4, 2, r7, cr15, cr3, {3}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2320:	4157006f 	cmpmi	r7, pc, rrx
	c = (c >> 7) * 19;
    2324:	535f5449 	cmppl	pc, #1224736768	; 0x49000000
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2328:	55544154 	ldrbpl	r4, [r4, #-340]	; 0x154
	c = (c >> 7) * 19;
    232c:	4e495f53 	mcrmi	15, 2, r5, cr9, cr3, {2}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2330:	454c4300 	strbmi	r4, [ip, #-768]	; 0x300
    2334:	465f5241 	ldrbmi	r5, [pc], -r1, asr #4
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2338:	55544145 	ldrbpl	r4, [r4, #-325]	; 0x145
		r[i] = c;
    233c:	4c004552 	cfstr32mi	mvfx4, [r0], {82}	; 0x52
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2340:	5f545341 	svcpl	0x00545341
		c += r[i];
		r[i] = c;
		c >>= 8;
    2344:	5f54554f 	svcpl	0x0054554f
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2348:	41544144 	cmpmi	r4, r4, asr #2
    234c:	62737500 	rsbsvs	r7, r3, #0, 10
    2350:	62696c5f 	rsbvs	r6, r9, #24320	; 0x5f00
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2354:	6273752f 	rsbsvs	r7, r3, #197132288	; 0xbc00000
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2358:	6d656d5f 	stclvs	13, cr6, [r5, #-380]!	; 0xfffffe84
		for (j = 0; j <= i; j++)
    235c:	7700632e 	strvc	r6, [r0, -lr, lsr #6]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2360:	7479424e 	ldrbtvc	r4, [r9], #-590	; 0x24e
    2364:	70007365 	andvc	r7, r0, r5, ror #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2368:	72735562 	rsbsvc	r5, r3, #411041792	; 0x18800000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    236c:	00667542 	rsbeq	r7, r6, r2, asr #10

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2370:	414d5077 	hvcmi	54535	; 0xd507
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2374:	41667542 	cmnmi	r6, r2, asr #10
    2378:	00726464 	rsbseq	r6, r2, r4, ror #8
    237c:	56776470 			; <UNDEFINED> instruction: 0x56776470
    2380:	Address 0x00002380 is out of bounds.


Disassembly of section .debug_loc:

00000000 <.debug_loc>:
       0:	00000b9e 	muleq	r0, lr, fp
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
       4:	00000ba6 	andeq	r0, r0, r6, lsr #23
       8:	a6500001 	ldrbge	r0, [r0], -r1
       c:	a800000b 	stmdage	r0, {r0, r1, r3}
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
      10:	0400000b 	streq	r0, [r0], #-11
      14:	5001f300 	andpl	pc, r1, r0, lsl #6
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
      18:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
      1c:	00000000 	andeq	r0, r0, r0
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
      20:	000c1800 	andeq	r1, ip, r0, lsl #16
      24:	000c1c00 	andeq	r1, ip, r0, lsl #24
      28:	71000500 	tstvc	r0, r0, lsl #10
    if ((wEPVal & EP_CTR_RX) != 0)
      2c:	9f274000 	svcls	0x00274000
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
      30:	00000c1c 	andeq	r0, r0, ip, lsl ip
      34:	00000c20 	andeq	r0, r0, r0, lsr #24
      38:	00710007 	rsbseq	r0, r1, r7

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
      3c:	27402740 	strbcs	r2, [r0, -r0, asr #14]

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
      40:	000c209f 	muleq	ip, pc, r0	; <UNPREDICTABLE>
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
      44:	000c2200 	andeq	r2, ip, r0, lsl #4
      48:	73000800 	movwvc	r0, #2048	; 0x800
      4c:	27400600 	strbcs	r0, [r0, -r0, lsl #12]

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
      50:	229f2740 	addscs	r2, pc, #64, 14	; 0x1000000
      54:	4100000c 	tstmi	r0, ip
      58:	0b00000c 	bleq	90 <g_pfnVectors+0x90>
      5c:	5c000c00 	stcpl	12, cr0, [r0], {-0}
      60:	40064000 	andmi	r4, r6, r0
      64:	9f274027 	svcls	0x00274027
	...
      70:	00000c84 	andeq	r0, r0, r4, lsl #25
      74:	00000c9b 	muleq	r0, fp, ip
      78:	9b500001 	blls	1400084 <_etext+0x13f8a70>
      7c:	e400000c 	str	r0, [r0], #-12
      80:	0400000c 	streq	r0, [r0], #-12
      84:	5001f300 	andpl	pc, r1, r0, lsl #6
      88:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
      8c:	00000000 	andeq	r0, r0, r0
      90:	000c8400 	andeq	r8, ip, r0, lsl #8
      94:	000cae00 	andeq	sl, ip, r0, lsl #28
      98:	30000200 	andcc	r0, r0, r0, lsl #4
      9c:	000cb69f 	muleq	ip, pc, r6	; <UNPREDICTABLE>
      a0:	000cbc00 	andeq	fp, ip, r0, lsl #24
      a4:	30000200 	andcc	r0, r0, r0, lsl #4
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
      a8:	000cbc9f 	muleq	ip, pc, ip	; <UNPREDICTABLE>

	return f25519_eq(a, c);
      ac:	000cc700 	andeq	ip, ip, r0, lsl #14
      b0:	53000100 	movwpl	r0, #256	; 0x100
      b4:	00000ccc 	andeq	r0, r0, ip, asr #25
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
      b8:	00000ce4 	andeq	r0, r0, r4, ror #25
	f25519_normalize(ey);
      bc:	9f300002 	svcls	0x00300002
	...

	return ok;
}
      c8:	00000ce4 	andeq	r0, r0, r4, ror #25
      cc:	00000ce9 	andeq	r0, r0, r9, ror #25
      d0:	e9500001 	ldmdb	r0, {r0}^
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
      d4:	f000000c 			; <UNDEFINED> instruction: 0xf000000c
      d8:	0400000c 	streq	r0, [r0], #-12
		minusp[i] = c;
      dc:	5001f300 	andpl	pc, r1, r0, lsl #6
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
      e0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
      e4:	00000000 	andeq	r0, r0, r0

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
      e8:	000cf000 	andeq	pc, ip, r0
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
      ec:	000cf500 	andeq	pc, ip, r0, lsl #10
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
      f0:	50000100 	andpl	r0, r0, r0, lsl #2
      f4:	00000cf5 	strdeq	r0, [r0], -r5
      f8:	00000cfc 	strdeq	r0, [r0], -ip
      fc:	01f30004 	mvnseq	r0, r4
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     100:	00009f50 	andeq	r9, r0, r0, asr pc

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
     104:	00000000 	andeq	r0, r0, r0
     108:	0cfc0000 	ldcleq	0, cr0, [ip]
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     10c:	0d0f0000 	stceq	0, cr0, [pc, #-0]	; 114 <_Minimum_Stack_Size+0x14>
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
     110:	00010000 	andeq	r0, r1, r0
     114:	000d0f50 	andeq	r0, sp, r0, asr pc
     118:	000d1000 	andeq	r1, sp, r0
     11c:	f3000400 	vshl.u8	d0, d0, d0
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
     120:	109f5001 	addsne	r5, pc, r1
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
     124:	1200000d 	andne	r0, r0, #13
     128:	0100000d 	tsteq	r0, sp
		fprime_copy(plusa, r);
		fprime_add(plusa, a, modulus);

		fprime_select(r, r, plusa, bit);
	}
}
     12c:	0d125000 	ldceq	0, cr5, [r2, #-0]

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
     130:	0d1c0000 	ldceq	0, cr0, [ip, #-0]
	i <<= 3;

	while (x) {
     134:	00040000 	andeq	r0, r4, r0
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
     138:	9f5001f3 	svcls	0x005001f3
	...

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
	f25519_mul_c(z3, x1sq, 4);
     144:	00000d1c 	andeq	r0, r0, ip, lsl sp
     148:	00000d21 	andeq	r0, r0, r1, lsr #26
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
     14c:	21500001 	cmpcs	r0, r1
     150:	2800000d 	stmdacs	r0, {r0, r2, r3}
     154:	0400000d 	streq	r0, [r0], #-13
	f25519_sub(b, x3, z3); /* D */
     158:	5001f300 	andpl	pc, r1, r0, lsl #6
     15c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	f25519_mul__distinct(da, a, b);
     160:	00000000 	andeq	r0, r0, r0
     164:	000d2800 	andeq	r2, sp, r0, lsl #16
     168:	000d3b00 	andeq	r3, sp, r0, lsl #22

	f25519_sub(b, x2, z2);
     16c:	50000100 	andpl	r0, r0, r0, lsl #2
     170:	00000d3b 	andeq	r0, r0, fp, lsr sp
	f25519_add(a, x3, z3); /* C */
     174:	00000d46 	andeq	r0, r0, r6, asr #26
     178:	01f30004 	mvnseq	r0, r4
     17c:	0d469f50 	stcleq	15, cr9, [r6, #-320]	; 0xfffffec0
	f25519_mul__distinct(cb, a, b);
     180:	0d480000 	stcleq	0, cr0, [r8, #-0]
     184:	00010000 	andeq	r0, r1, r0

	f25519_add(a, da, cb);
     188:	000d4850 	andeq	r4, sp, r0, asr r8
     18c:	000d5000 	andeq	r5, sp, r0
     190:	f3000400 	vshl.u8	d0, d0, d0
	f25519_mul__distinct(b, a, a);
     194:	009f5001 	addseq	r5, pc, r1
     198:	00000000 	andeq	r0, r0, r0
	f25519_mul__distinct(x5, z1, b);
     19c:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
     1a0:	4600000d 	strmi	r0, [r0], -sp
     1a4:	0400000d 	streq	r0, [r0], #-13

	f25519_sub(a, da, cb);
     1a8:	5001f300 	andpl	pc, r1, r0, lsl #6
     1ac:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	f25519_mul__distinct(b, a, a);
     1b0:	00000000 	andeq	r0, r0, r0
     1b4:	000dbe00 	andeq	fp, sp, r0, lsl #28
     1b8:	000dc200 	andeq	ip, sp, r0, lsl #4

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
     1bc:	72000500 	andvc	r0, r0, #0, 10
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
     1c0:	9f213c00 	svcls	0x00213c00
	...

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
     1cc:	00000dec 	andeq	r0, r0, ip, ror #27
     1d0:	00000e09 	andeq	r0, r0, r9, lsl #28
     1d4:	09500001 	ldmdbeq	r0, {r0}^
		f25519_select(zm1, zm1, zm, bit);
     1d8:	0c00000e 	stceq	0, cr0, [r0], {14}
     1dc:	0400000e 	streq	r0, [r0], #-14
     1e0:	5001f300 	andpl	pc, r1, r0, lsl #6
		f25519_select(xm, xm, xms, bit);
     1e4:	000e0c9f 	muleq	lr, pc, ip	; <UNPREDICTABLE>
     1e8:	000e0f00 	andeq	r0, lr, r0, lsl #30
     1ec:	50000100 	andpl	r0, r0, r0, lsl #2
		f25519_select(zm, zm, zms, bit);
     1f0:	00000e0f 	andeq	r0, r0, pc, lsl #28
     1f4:	00000e14 	andeq	r0, r0, r4, lsl lr
     1f8:	01f30004 	mvnseq	r0, r4
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
     1fc:	0e149f50 	mrceq	15, 0, r9, cr4, cr0, {2}
     200:	0e620000 	cdpeq	0, 6, cr0, cr2, cr0, {0}
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
     204:	00010000 	andeq	r0, r1, r0
     208:	000e6250 	andeq	r6, lr, r0, asr r2
	f25519_mul__distinct(result, zm1, xm);
     20c:	000e7000 	andeq	r7, lr, r0
     210:	f3000400 	vshl.u8	d0, d0, d0
	f25519_normalize(result);
     214:	009f5001 	addseq	r5, pc, r1
     218:	00000000 	andeq	r0, r0, r0
}
     21c:	32000000 	andcc	r0, r0, #0
     220:	3600000e 	strcc	r0, [r0], -lr
     224:	0500000e 	streq	r0, [r0, #-14]
     228:	40007200 	andmi	r7, r0, r0, lsl #4
     22c:	0e569f21 	cdpeq	15, 5, cr9, cr6, cr1, {1}
     230:	0e5c0000 	cdpeq	0, 5, cr0, cr12, cr0, {0}
     234:	00060000 	andeq	r0, r6, r0
     238:	ef090071 	svc	0x00090071
     23c:	00009f1a 	andeq	r9, r0, sl, lsl pc
     240:	00000000 	andeq	r0, r0, r0
     244:	10340000 	eorsne	r0, r4, r0
     248:	10640000 	rsbne	r0, r4, r0
     24c:	00020000 	andeq	r0, r2, r0
     250:	10649f30 	rsbne	r9, r4, r0, lsr pc
     254:	10660000 	rsbne	r0, r6, r0
     258:	00070000 	andeq	r0, r7, r0
     25c:	24480070 	strbcs	r0, [r8], #-112	; 0x70
     260:	669f2930 			; <UNDEFINED> instruction: 0x669f2930
     264:	90000010 	andls	r0, r0, r0, lsl r0
     268:	07000010 	smladeq	r0, r0, r0, r0
     26c:	48007400 	stmdami	r0, {sl, ip, sp, lr}
     270:	9f293024 	svcls	0x00293024
     274:	00001096 	muleq	r0, r6, r0
     278:	0000109c 	muleq	r0, ip, r0
     27c:	00740007 	rsbseq	r0, r4, r7
     280:	29302448 	ldmdbcs	r0!, {r3, r6, sl, sp}
     284:	00109c9f 	mulseq	r0, pc, ip	; <UNPREDICTABLE>
     288:	0010a000 	andseq	sl, r0, r0
     28c:	30000200 	andcc	r0, r0, r0, lsl #4
     290:	0010a09f 	mulseq	r0, pc, r0	; <UNPREDICTABLE>
     294:	0010ae00 	andseq	sl, r0, r0, lsl #28
     298:	74000700 	strvc	r0, [r0], #-1792	; 0x700
     29c:	30244800 	eorcc	r4, r4, r0, lsl #16
     2a0:	10ae9f29 	adcne	r9, lr, r9, lsr #30
     2a4:	10b00000 	adcsne	r0, r0, r0
     2a8:	00020000 	andeq	r0, r2, r0
     2ac:	10b09f31 	adcsne	r9, r0, r1, lsr pc
     2b0:	11040000 	mrsne	r0, (UNDEF: 4)
     2b4:	00010000 	andeq	r0, r1, r0
     2b8:	00110454 	andseq	r0, r1, r4, asr r4
     2bc:	00113800 	andseq	r3, r1, r0, lsl #16
     2c0:	50000100 	andpl	r0, r0, r0, lsl #2
	...
     2cc:	00001076 	andeq	r1, r0, r6, ror r0
     2d0:	0000107a 	andeq	r1, r0, sl, ror r0
     2d4:	7a500001 	bvc	14002e0 <_etext+0x13f8ccc>
     2d8:	7f000010 	svcvc	0x00000010
     2dc:	01000010 	tsteq	r0, r0, lsl r0
     2e0:	107f5100 	rsbsne	r5, pc, r0, lsl #2
     2e4:	10c40000 	sbcne	r0, r4, r0
     2e8:	00030000 	andeq	r0, r3, r0
     2ec:	009f0275 	addseq	r0, pc, r5, ror r2	; <UNPREDICTABLE>
     2f0:	00000000 	andeq	r0, r0, r0
     2f4:	c2000000 	andgt	r0, r0, #0
     2f8:	c4000010 	strgt	r0, [r0], #-16
     2fc:	02000010 	andeq	r0, r0, #16
     300:	c49f3000 	ldrgt	r3, [pc], #0	; 308 <GPIO_EventOutputConfig>
     304:	ec000010 	stc	0, cr0, [r0], {16}
     308:	03000010 	movweq	r0, #16
     30c:	9f017500 	svcls	0x00017500
     310:	000010ec 	andeq	r1, r0, ip, ror #1
     314:	000010ee 	andeq	r1, r0, lr, ror #1
     318:	ee550001 	cdp	0, 5, cr0, cr5, cr1, {0}
     31c:	04000010 	streq	r0, [r0], #-16
     320:	03000011 	movweq	r0, #17
     324:	9f017500 	svcls	0x00017500
	...
     330:	00001138 	andeq	r1, r0, r8, lsr r1
     334:	0000113e 	andeq	r1, r0, lr, lsr r1
     338:	3e510001 	cdpcc	0, 5, cr0, cr1, cr1, {0}
     33c:	4e000011 	mcrmi	0, 0, r0, cr0, cr1, {0}
     340:	04000011 	streq	r0, [r0], #-17
     344:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
     348:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     34c:	00000000 	andeq	r0, r0, r0
     350:	00113800 	andseq	r3, r1, r0, lsl #16
     354:	00113800 	andseq	r3, r1, r0, lsl #16
     358:	52000100 	andpl	r0, r0, #0, 2
     35c:	00001138 	andeq	r1, r0, r8, lsr r1
     360:	00001142 	andeq	r1, r0, r2, asr #2
     364:	00720007 	rsbseq	r0, r2, r7
     368:	29302448 	ldmdbcs	r0!, {r3, r6, sl, sp}
     36c:	0011429f 	mulseq	r1, pc, r2	; <UNPREDICTABLE>
     370:	00114e00 	andseq	r4, r1, r0, lsl #28
     374:	f3000800 	vsub.i8	d0, d0, d0
     378:	24485201 	strbcs	r5, [r8], #-513	; 0x201
     37c:	009f2930 	addseq	r2, pc, r0, lsr r9	; <UNPREDICTABLE>
     380:	00000000 	andeq	r0, r0, r0
     384:	4e000000 	cdpmi	0, 0, cr0, cr0, cr0, {0}
     388:	5e000011 	mcrpl	0, 0, r0, cr0, cr1, {0}
     38c:	01000011 	tsteq	r0, r1, lsl r0
     390:	115e5000 	cmpne	lr, r0
     394:	11600000 	cmnne	r0, r0
     398:	00040000 	andeq	r0, r4, r0
     39c:	9f5001f3 	svcls	0x005001f3
	...
     3a8:	0000114e 	andeq	r1, r0, lr, asr #2
     3ac:	00001154 	andeq	r1, r0, r4, asr r1
     3b0:	54510001 	ldrbpl	r0, [r1], #-1
     3b4:	60000011 	andvs	r0, r0, r1, lsl r0
     3b8:	04000011 	streq	r0, [r0], #-17
     3bc:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
     3c0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     3c4:	00000000 	andeq	r0, r0, r0
     3c8:	00116000 	andseq	r6, r1, r0
     3cc:	00117b00 	andseq	r7, r1, r0, lsl #22
     3d0:	50000100 	andpl	r0, r0, r0, lsl #2
     3d4:	0000117b 	andeq	r1, r0, fp, ror r1
     3d8:	000011b0 			; <UNDEFINED> instruction: 0x000011b0
     3dc:	00580001 	subseq	r0, r8, r1
     3e0:	00000000 	andeq	r0, r0, r0
     3e4:	60000000 	andvs	r0, r0, r0
     3e8:	7b000011 	blvc	434 <RCC_HSEConfig+0x1c>
     3ec:	01000011 	tsteq	r0, r1, lsl r0
     3f0:	117b5100 	cmnne	fp, r0, lsl #2
     3f4:	11b00000 	movsne	r0, r0
     3f8:	00040000 	andeq	r0, r4, r0
     3fc:	9f5101f3 	svcls	0x005101f3
	...
     408:	00001160 	andeq	r1, r0, r0, ror #2
     40c:	00001172 	andeq	r1, r0, r2, ror r1
     410:	72520001 	subsvc	r0, r2, #1
     414:	7c000011 	stcvc	0, cr0, [r0], {17}
     418:	04000011 	streq	r0, [r0], #-17
     41c:	5201f300 	andpl	pc, r1, #0, 6
     420:	00117c9f 	mulseq	r1, pc, ip	; <UNPREDICTABLE>
     424:	0011a400 	andseq	sl, r1, r0, lsl #8
     428:	74000300 	strvc	r0, [r0], #-768	; 0x300
     42c:	11a49f7f 			; <UNDEFINED> instruction: 0x11a49f7f
     430:	11aa0000 			; <UNDEFINED> instruction: 0x11aa0000
     434:	00030000 	andeq	r0, r3, r0
     438:	ac9f0074 	ldcge	0, cr0, [pc], {116}	; 0x74
     43c:	b0000011 	andlt	r0, r0, r1, lsl r0
     440:	03000011 	movweq	r0, #17
     444:	9f7f7400 	svcls	0x007f7400
	...
     450:	00001160 	andeq	r1, r0, r0, ror #2
     454:	0000117b 	andeq	r1, r0, fp, ror r1
     458:	7b530001 	blvc	14c0464 <_etext+0x14b8e50>
     45c:	b0000011 	andlt	r0, r0, r1, lsl r0
     460:	01000011 	tsteq	r0, r1, lsl r0
     464:	00005600 	andeq	r5, r0, r0, lsl #12
     468:	00000000 	andeq	r0, r0, r0
     46c:	11800000 	orrne	r0, r0, r0
     470:	11920000 	orrsne	r0, r2, r0
     474:	00010000 	andeq	r0, r1, r0
     478:	00119255 	andseq	r9, r1, r5, asr r2
     47c:	00119400 	andseq	r9, r1, r0, lsl #8
     480:	56000100 	strpl	r0, [r0], -r0, lsl #2
     484:	00001194 	muleq	r0, r4, r1
     488:	000011ac 	andeq	r1, r0, ip, lsr #3
     48c:	00550001 	subseq	r0, r5, r1
     490:	00000000 	andeq	r0, r0, r0
     494:	ba000000 	blt	49c <RCC_HSICmd>
     498:	c0000011 	andgt	r0, r0, r1, lsl r0
     49c:	01000011 	tsteq	r0, r1, lsl r0
     4a0:	11c05000 	bicne	r5, r0, r0
     4a4:	11d00000 	bicsne	r0, r0, r0
     4a8:	00010000 	andeq	r0, r1, r0
     4ac:	00000055 	andeq	r0, r0, r5, asr r0
     4b0:	00000000 	andeq	r0, r0, r0
     4b4:	0011ba00 	andseq	fp, r1, r0, lsl #20
     4b8:	0011c000 	andseq	ip, r1, r0
     4bc:	51000100 	mrspl	r0, (UNDEF: 16)
     4c0:	000011c0 	andeq	r1, r0, r0, asr #3
     4c4:	000011c4 	andeq	r1, r0, r4, asr #3
     4c8:	01740003 	cmneq	r4, r3
     4cc:	0011c49f 	mulseq	r1, pc, r4	; <UNPREDICTABLE>
     4d0:	0011cc00 	andseq	ip, r1, r0, lsl #24
     4d4:	54000100 	strpl	r0, [r0], #-256	; 0x100
     4d8:	000011cc 	andeq	r1, r0, ip, asr #3
     4dc:	000011ce 	andeq	r1, r0, lr, asr #3
     4e0:	01740003 	cmneq	r4, r3
     4e4:	0011ce9f 	mulseq	r1, pc, lr	; <UNPREDICTABLE>
     4e8:	0011d000 	andseq	sp, r1, r0
     4ec:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
     4f8:	000011d0 	ldrdeq	r1, [r0], -r0
     4fc:	000011da 	ldrdeq	r1, [r0], -sl
     500:	da500001 	ble	140050c <_etext+0x13f8ef8>
     504:	df000011 	svcle	0x00000011
     508:	01000011 	tsteq	r0, r1, lsl r0
     50c:	11df5300 	bicsne	r5, pc, r0, lsl #6
     510:	11f80000 	mvnsne	r0, r0
     514:	00040000 	andeq	r0, r4, r0
     518:	9f5001f3 	svcls	0x005001f3
	...
     524:	000011d0 	ldrdeq	r1, [r0], -r0
     528:	000011dc 	ldrdeq	r1, [r0], -ip
     52c:	00510001 	subseq	r0, r1, r1
     530:	00000000 	andeq	r0, r0, r0
     534:	14000000 	strne	r0, [r0], #-0
     538:	1e000012 	mcrne	0, 0, r0, cr0, cr2, {0}
     53c:	01000012 	tsteq	r0, r2, lsl r0
     540:	121e5000 	andsne	r5, lr, #0
     544:	12b00000 	adcsne	r0, r0, #0
     548:	00010000 	andeq	r0, r1, r0
     54c:	00000056 	andeq	r0, r0, r6, asr r0
     550:	00000000 	andeq	r0, r0, r0
     554:	00121400 	andseq	r1, r2, r0, lsl #8
     558:	00122000 	andseq	r2, r2, r0
     55c:	51000100 	mrspl	r0, (UNDEF: 16)
     560:	00001220 	andeq	r1, r0, r0, lsr #4
     564:	000012b0 			; <UNDEFINED> instruction: 0x000012b0
     568:	00570001 	subseq	r0, r7, r1
     56c:	00000000 	andeq	r0, r0, r0
     570:	26000000 	strcs	r0, [r0], -r0
     574:	28000012 	stmdacs	r0, {r1, r4}
     578:	02000012 	andeq	r0, r0, #18
     57c:	289f3000 	ldmcs	pc, {ip, sp}	; <UNPREDICTABLE>
     580:	74000012 	strvc	r0, [r0], #-18
     584:	01000012 	tsteq	r0, r2, lsl r0
     588:	12745400 	rsbsne	r5, r4, #0, 8
     58c:	12760000 	rsbsne	r0, r6, #0
     590:	00010000 	andeq	r0, r1, r0
     594:	00128255 	andseq	r8, r2, r5, asr r2
     598:	00128e00 	andseq	r8, r2, r0, lsl #28
     59c:	55000100 	strpl	r0, [r0, #-256]	; 0x100
     5a0:	0000128e 	andeq	r1, r0, lr, lsl #5
     5a4:	0000129c 	muleq	r0, ip, r2
     5a8:	01750003 	cmneq	r5, r3
     5ac:	00129c9f 	mulseq	r2, pc, ip	; <UNPREDICTABLE>
     5b0:	0012b000 	andseq	fp, r2, r0
     5b4:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
     5c0:	000012b0 			; <UNDEFINED> instruction: 0x000012b0
     5c4:	000012b6 			; <UNDEFINED> instruction: 0x000012b6
     5c8:	b6500001 	ldrblt	r0, [r0], -r1
     5cc:	cc000012 	stcgt	0, cr0, [r0], {18}
     5d0:	01000012 	tsteq	r0, r2, lsl r0
     5d4:	12cc5500 	sbcne	r5, ip, #0, 10
     5d8:	12d80000 	sbcsne	r0, r8, #0
     5dc:	00040000 	andeq	r0, r4, r0
     5e0:	9f5001f3 	svcls	0x005001f3
	...
     5ec:	000012b0 			; <UNDEFINED> instruction: 0x000012b0
     5f0:	000012b6 			; <UNDEFINED> instruction: 0x000012b6
     5f4:	9f300002 	svcls	0x00300002
     5f8:	000012b6 			; <UNDEFINED> instruction: 0x000012b6
     5fc:	000012bc 			; <UNDEFINED> instruction: 0x000012bc
     600:	bc540001 	mrrclt	0, 0, r0, r4, cr1
     604:	c0000012 	andgt	r0, r0, r2, lsl r0
     608:	03000012 	movweq	r0, #18
     60c:	9f7f7400 	svcls	0x007f7400
     610:	000012c0 	andeq	r1, r0, r0, asr #5
     614:	000012cc 	andeq	r1, r0, ip, asr #5
     618:	00540001 	subseq	r0, r4, r1
     61c:	00000000 	andeq	r0, r0, r0
     620:	26000000 	strcs	r0, [r0], -r0
     624:	2c000014 	stccs	0, cr0, [r0], {20}
     628:	01000014 	tsteq	r0, r4, lsl r0
     62c:	00005200 	andeq	r5, r0, r0, lsl #4
	...
     63c:	00010000 	andeq	r0, r1, r0
     640:	00000050 	andeq	r0, r0, r0, asr r0
     644:	00000000 	andeq	r0, r0, r0
     648:	f3000400 	vshl.u8	d0, d0, d0
     64c:	009f5001 	addseq	r5, pc, r1
     650:	00000000 	andeq	r0, r0, r0
     654:	38000000 	stmdacc	r0, {}	; <UNPREDICTABLE>
     658:	47000014 	smladmi	r0, r4, r0, r0
     65c:	01000014 	tsteq	r0, r4, lsl r0
     660:	14475000 	strbne	r5, [r7], #-0
     664:	14500000 	ldrbne	r0, [r0], #-0
     668:	00040000 	andeq	r0, r4, r0
     66c:	9f5001f3 	svcls	0x005001f3
	...
     678:	0000143e 	andeq	r1, r0, lr, lsr r4
     67c:	00001447 	andeq	r1, r0, r7, asr #8
     680:	00530001 	subseq	r0, r3, r1
	...
     690:	02000000 	andeq	r0, r0, #0
     694:	009f3000 	addseq	r3, pc, r0
     698:	00000000 	andeq	r0, r0, r0
     69c:	01000000 	mrseq	r0, (UNDEF: 0)
     6a0:	00005400 	andeq	r5, r0, r0, lsl #8
     6a4:	00000000 	andeq	r0, r0, r0
     6a8:	14500000 	ldrbne	r0, [r0], #-0
     6ac:	145e0000 	ldrbne	r0, [lr], #-0
     6b0:	00020000 	andeq	r0, r2, r0
     6b4:	145e9f30 	ldrbne	r9, [lr], #-3888	; 0xf30
     6b8:	14660000 	strbtne	r0, [r6], #-0
     6bc:	00010000 	andeq	r0, r1, r0
     6c0:	00146653 	andseq	r6, r4, r3, asr r6
     6c4:	00147200 	andseq	r7, r4, r0, lsl #4
     6c8:	52000100 	andpl	r0, r0, #0, 2
     6cc:	00001472 	andeq	r1, r0, r2, ror r4
     6d0:	00001494 	muleq	r0, r4, r4
     6d4:	94540001 	ldrbls	r0, [r4], #-1
     6d8:	96000014 			; <UNDEFINED> instruction: 0x96000014
     6dc:	06000014 			; <UNDEFINED> instruction: 0x06000014
     6e0:	72007400 	andvc	r7, r0, #0, 8
     6e4:	969f1a00 	ldrls	r1, [pc], r0, lsl #20
     6e8:	98000014 	stmdals	r0, {r2, r4}
     6ec:	01000014 	tsteq	r0, r4, lsl r0
     6f0:	14985200 	ldrne	r5, [r8], #512	; 0x200
     6f4:	149c0000 	ldrne	r0, [ip], #0
     6f8:	00120000 	andseq	r0, r2, r0
     6fc:	0070ff08 	rsbseq	pc, r0, r8, lsl #30
     700:	1a330194 	bne	cc0d58 <_etext+0xcb9744>
     704:	331aff08 	tstcc	sl, #8, 30
     708:	00742424 	rsbseq	r2, r4, r4, lsr #8
     70c:	00009f1a 	andeq	r9, r0, sl, lsl pc
     710:	00000000 	andeq	r0, r0, r0
     714:	14500000 	ldrbne	r0, [r0], #-0
     718:	14900000 	ldrne	r0, [r0], #0
     71c:	00020000 	andeq	r0, r2, r0
     720:	14909f30 	ldrne	r9, [r0], #3888	; 0xf30
     724:	14940000 	ldrne	r0, [r4], #0
     728:	00010000 	andeq	r0, r1, r0
     72c:	00149455 	andseq	r9, r4, r5, asr r4
     730:	00149800 	andseq	r9, r4, r0, lsl #16
     734:	51000100 	mrspl	r0, (UNDEF: 16)
     738:	00001498 	muleq	r0, r8, r4
     73c:	000014a0 	andeq	r1, r0, r0, lsr #9
     740:	00520001 	subseq	r0, r2, r1
     744:	00000000 	andeq	r0, r0, r0
     748:	50000000 	andpl	r0, r0, r0
     74c:	90000014 	andls	r0, r0, r4, lsl r0
     750:	02000014 	andeq	r0, r0, #20
     754:	909f3000 	addsls	r3, pc, r0
     758:	96000014 			; <UNDEFINED> instruction: 0x96000014
     75c:	01000014 	tsteq	r0, r4, lsl r0
     760:	14965200 	ldrne	r5, [r6], #512	; 0x200
     764:	149c0000 	ldrne	r0, [ip], #0
     768:	000f0000 	andeq	r0, pc, r0
     76c:	0070ff08 	rsbseq	pc, r0, r8, lsl #30
     770:	1a330194 	bne	cc0dc8 <_etext+0xcb97b4>
     774:	331aff08 	tstcc	sl, #8, 30
     778:	009f2424 	addseq	r2, pc, r4, lsr #8
     77c:	00000000 	andeq	r0, r0, r0
     780:	50000000 	andpl	r0, r0, r0
     784:	5e000014 	mcrpl	0, 0, r0, cr0, cr4, {0}
     788:	02000014 	andeq	r0, r0, #20
     78c:	5e9f3000 	cdppl	0, 9, cr3, cr15, cr0, {0}
     790:	62000014 	andvs	r0, r0, #20
     794:	05000014 	streq	r0, [r0, #-20]
     798:	00733400 	rsbseq	r3, r3, r0, lsl #8
     79c:	14629f1c 	strbtne	r9, [r2], #-3868	; 0xf1c
     7a0:	14660000 	strbtne	r0, [r6], #-0
     7a4:	00010000 	andeq	r0, r1, r0
     7a8:	00146652 	andseq	r6, r4, r2, asr r6
     7ac:	00146e00 	andseq	r6, r4, r0, lsl #28
     7b0:	34000500 	strcc	r0, [r0], #-1280	; 0x500
     7b4:	9f1c0073 	svcls	0x001c0073
	...
     7c0:	00001450 	andeq	r1, r0, r0, asr r4
     7c4:	0000145e 	andeq	r1, r0, lr, asr r4
     7c8:	9f3f0002 	svcls	0x003f0002
     7cc:	0000145e 	andeq	r1, r0, lr, asr r4
     7d0:	0000146a 	andeq	r1, r0, sl, ror #8
     7d4:	733f0005 	teqvc	pc, #5
     7d8:	6a9f2500 	bvs	fe7c9be0 <BootRAM+0xd73a381>
     7dc:	70000014 	andvc	r0, r0, r4, lsl r0
     7e0:	01000014 	tsteq	r0, r4, lsl r0
     7e4:	00005400 	andeq	r5, r0, r0, lsl #8
     7e8:	00000000 	andeq	r0, r0, r0
     7ec:	14e00000 	strbtne	r0, [r0], #0
     7f0:	14e70000 	strbtne	r0, [r7], #0
     7f4:	00010000 	andeq	r0, r1, r0
     7f8:	0014e750 	andseq	lr, r4, r0, asr r7
     7fc:	0014fa00 	andseq	pc, r4, r0, lsl #20
     800:	54000100 	strpl	r0, [r0], #-256	; 0x100
     804:	000014fa 	strdeq	r1, [r0], -sl
     808:	000014fd 	strdeq	r1, [r0], -sp
     80c:	fd500001 	ldc2l	0, cr0, [r0, #-4]
     810:	fe000014 	mcr2	0, 0, r0, cr0, cr4, {0}
     814:	04000014 	streq	r0, [r0], #-20
     818:	5001f300 	andpl	pc, r1, r0, lsl #6
     81c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     820:	00000000 	andeq	r0, r0, r0
     824:	00151400 	andseq	r1, r5, r0, lsl #8
     828:	00153c00 	andseq	r3, r5, r0, lsl #24
     82c:	50000100 	andpl	r0, r0, r0, lsl #2
     830:	0000153c 	andeq	r1, r0, ip, lsr r5
     834:	00001548 	andeq	r1, r0, r8, asr #10
     838:	01f30004 	mvnseq	r0, r4
     83c:	00009f50 	andeq	r9, r0, r0, asr pc
     840:	00000000 	andeq	r0, r0, r0
     844:	151a0000 	ldrne	r0, [sl, #-0]
     848:	15380000 	ldrne	r0, [r8, #-0]!
     84c:	00020000 	andeq	r0, r2, r0
     850:	15389f32 	ldrne	r9, [r8, #-3890]!	; 0xf32
     854:	15480000 	strbne	r0, [r8, #-0]
     858:	00020000 	andeq	r0, r2, r0
     85c:	00009f30 	andeq	r9, r0, r0, lsr pc
	...
     86c:	00010000 	andeq	r0, r1, r0
     870:	00000050 	andeq	r0, r0, r0, asr r0
     874:	00000000 	andeq	r0, r0, r0
     878:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
     884:	01f30004 	mvnseq	r0, r4
     888:	00009f50 	andeq	r9, r0, r0, asr pc
	...
     898:	00010000 	andeq	r0, r1, r0
     89c:	00000051 	andeq	r0, r0, r1, asr r0
     8a0:	00000000 	andeq	r0, r0, r0
     8a4:	f3000400 	vshl.u8	d0, d0, d0
     8a8:	009f5101 	addseq	r5, pc, r1, lsl #2
     8ac:	00000000 	andeq	r0, r0, r0
     8b0:	01000000 	mrseq	r0, (UNDEF: 0)
     8b4:	00005400 	andeq	r5, r0, r0, lsl #8
     8b8:	00000000 	andeq	r0, r0, r0
     8bc:	00030000 	andeq	r0, r3, r0
     8c0:	009f0174 	addseq	r0, pc, r4, ror r1	; <UNPREDICTABLE>
     8c4:	00000000 	andeq	r0, r0, r0
     8c8:	01000000 	mrseq	r0, (UNDEF: 0)
     8cc:	00005400 	andeq	r5, r0, r0, lsl #8
     8d0:	00000000 	andeq	r0, r0, r0
     8d4:	15480000 	strbne	r0, [r8, #-0]
     8d8:	15820000 	strne	r0, [r2]
     8dc:	00010000 	andeq	r0, r1, r0
     8e0:	00158250 	andseq	r8, r5, r0, asr r2
     8e4:	00159400 	andseq	r9, r5, r0, lsl #8
     8e8:	f3000400 	vshl.u8	d0, d0, d0
     8ec:	009f5001 	addseq	r5, pc, r1
     8f0:	00000000 	andeq	r0, r0, r0
     8f4:	58000000 	stmdapl	r0, {}	; <UNPREDICTABLE>
     8f8:	7e000015 	mcrvc	0, 0, r0, cr0, cr5, {0}
     8fc:	01000015 	tsteq	r0, r5, lsl r0
     900:	157e5400 	ldrbne	r5, [lr, #-1024]!	; 0x400
     904:	15940000 	ldrne	r0, [r4]
     908:	00010000 	andeq	r0, r1, r0
     90c:	00000052 	andeq	r0, r0, r2, asr r0
     910:	00000000 	andeq	r0, r0, r0
     914:	0015b800 	andseq	fp, r5, r0, lsl #16
     918:	0015be00 	andseq	fp, r5, r0, lsl #28
     91c:	50000100 	andpl	r0, r0, r0, lsl #2
     920:	000015be 			; <UNDEFINED> instruction: 0x000015be
     924:	000015c2 	andeq	r1, r0, r2, asr #11
     928:	00500001 	subseq	r0, r0, r1
     92c:	00000000 	andeq	r0, r0, r0
     930:	be000000 	cdplt	0, 0, cr0, cr0, cr0, {0}
     934:	c2000015 	andgt	r0, r0, #21
     938:	07000015 	smladeq	r0, r5, r0, r0
     93c:	00703f00 	rsbseq	r3, r0, r0, lsl #30
     940:	9f242432 	svcls	0x00242432
     944:	000015c6 	andeq	r1, r0, r6, asr #11
     948:	000015c8 	andeq	r1, r0, r8, asr #11
     94c:	c8500001 	ldmdagt	r0, {r0}^
     950:	ca000015 	bgt	9ac <USART_LINBreakDetectLengthConfig+0x8>
     954:	04000015 	streq	r0, [r0], #-21
     958:	20007000 	andcs	r7, r0, r0
     95c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     960:	00000000 	andeq	r0, r0, r0
     964:	00168800 	andseq	r8, r6, r0, lsl #16
     968:	00169000 	andseq	r9, r6, r0
     96c:	51000100 	mrspl	r0, (UNDEF: 16)
     970:	000016a0 	andeq	r1, r0, r0, lsr #13
     974:	000016a8 	andeq	r1, r0, r8, lsr #13
     978:	b4510001 	ldrblt	r0, [r1], #-1
     97c:	c0000016 	andgt	r0, r0, r6, lsl r0
     980:	01000016 	tsteq	r0, r6, lsl r0
     984:	00005100 	andeq	r5, r0, r0, lsl #2
     988:	00000000 	andeq	r0, r0, r0
     98c:	16c00000 	strbne	r0, [r0], r0
     990:	16ce0000 	strbne	r0, [lr], r0
     994:	00010000 	andeq	r0, r1, r0
     998:	0016ce50 	andseq	ip, r6, r0, asr lr
     99c:	0016d800 	andseq	sp, r6, r0, lsl #16
     9a0:	f3000400 	vshl.u8	d0, d0, d0
     9a4:	009f5001 	addseq	r5, pc, r1
     9a8:	00000000 	andeq	r0, r0, r0
     9ac:	d8000000 	stmdale	r0, {}	; <UNPREDICTABLE>
     9b0:	e6000016 			; <UNDEFINED> instruction: 0xe6000016
     9b4:	01000016 	tsteq	r0, r6, lsl r0
     9b8:	16e65000 	strbtne	r5, [r6], r0
     9bc:	16f00000 	ldrbtne	r0, [r0], r0
     9c0:	00040000 	andeq	r0, r4, r0
     9c4:	9f5001f3 	svcls	0x005001f3
	...
     9d0:	000016f0 	strdeq	r1, [r0], -r0
     9d4:	00001708 	andeq	r1, r0, r8, lsl #14
     9d8:	08500001 	ldmdaeq	r0, {r0}^
     9dc:	18000017 	stmdane	r0, {r0, r1, r2, r4}
     9e0:	04000017 	streq	r0, [r0], #-23
     9e4:	5001f300 	andpl	pc, r1, r0, lsl #6
     9e8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     9ec:	00000000 	andeq	r0, r0, r0
     9f0:	00171800 	andseq	r1, r7, r0, lsl #16
     9f4:	00173400 	andseq	r3, r7, r0, lsl #8
     9f8:	50000100 	andpl	r0, r0, r0, lsl #2
     9fc:	00001734 	andeq	r1, r0, r4, lsr r7
     a00:	0000174c 	andeq	r1, r0, ip, asr #14
     a04:	01f30004 	mvnseq	r0, r4
     a08:	00009f50 	andeq	r9, r0, r0, asr pc
     a0c:	00000000 	andeq	r0, r0, r0
     a10:	176c0000 	strbne	r0, [ip, -r0]!
     a14:	176e0000 	strbne	r0, [lr, -r0]!
     a18:	00020000 	andeq	r0, r2, r0
     a1c:	176e9f30 			; <UNDEFINED> instruction: 0x176e9f30
     a20:	17960000 	ldrne	r0, [r6, r0]
     a24:	00010000 	andeq	r0, r1, r0
     a28:	00000055 	andeq	r0, r0, r5, asr r0
     a2c:	00000000 	andeq	r0, r0, r0
     a30:	0017ba00 	andseq	fp, r7, r0, lsl #20
     a34:	0017ce00 	andseq	ip, r7, r0, lsl #28
     a38:	53000100 	movwpl	r0, #256	; 0x100
     a3c:	00001810 	andeq	r1, r0, r0, lsl r8
     a40:	00001816 	andeq	r1, r0, r6, lsl r8
     a44:	58530001 	ldmdapl	r3, {r0}^
     a48:	74000018 	strvc	r0, [r0], #-24
     a4c:	01000018 	tsteq	r0, r8, lsl r0
     a50:	187c5300 	ldmdane	ip!, {r8, r9, ip, lr}^
     a54:	188e0000 	stmne	lr, {}	; <UNPREDICTABLE>
     a58:	00010000 	andeq	r0, r1, r0
     a5c:	00189853 	andseq	r9, r8, r3, asr r8
     a60:	00189e00 	andseq	r9, r8, r0, lsl #28
     a64:	53000100 	movwpl	r0, #256	; 0x100
     a68:	000018e6 	andeq	r1, r0, r6, ror #17
     a6c:	000018f6 	strdeq	r1, [r0], -r6
     a70:	fc530001 	mrrc2	0, 0, r0, r3, cr1
     a74:	10000018 	andne	r0, r0, r8, lsl r0
     a78:	01000019 	tsteq	r0, r9, lsl r0
     a7c:	19885300 	stmibne	r8, {r8, r9, ip, lr}
     a80:	198e0000 	stmibne	lr, {}	; <UNPREDICTABLE>
     a84:	00010000 	andeq	r0, r1, r0
     a88:	00000053 	andeq	r0, r0, r3, asr r0
     a8c:	00000000 	andeq	r0, r0, r0
     a90:	0018ba00 	andseq	fp, r8, r0, lsl #20
     a94:	0018ca00 	andseq	ip, r8, r0, lsl #20
     a98:	50000100 	andpl	r0, r0, r0, lsl #2
     a9c:	000018cc 	andeq	r1, r0, ip, asr #17
     aa0:	000018ce 	andeq	r1, r0, lr, asr #17
     aa4:	00500001 	subseq	r0, r0, r1
	...
     ab4:	01000000 	mrseq	r0, (UNDEF: 0)
     ab8:	00005000 	andeq	r5, r0, r0
     abc:	00000000 	andeq	r0, r0, r0
     ac0:	00010000 	andeq	r0, r1, r0
     ac4:	00000058 	andeq	r0, r0, r8, asr r0
     ac8:	00000000 	andeq	r0, r0, r0
     acc:	f3000400 	vshl.u8	d0, d0, d0
     ad0:	009f5001 	addseq	r5, pc, r1
	...
     ae0:	01000000 	mrseq	r0, (UNDEF: 0)
     ae4:	00005100 	andeq	r5, r0, r0, lsl #2
     ae8:	00000000 	andeq	r0, r0, r0
     aec:	00010000 	andeq	r0, r1, r0
     af0:	00000056 	andeq	r0, r0, r6, asr r0
     af4:	00000000 	andeq	r0, r0, r0
     af8:	f3000400 	vshl.u8	d0, d0, d0
     afc:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
     b0c:	01000000 	mrseq	r0, (UNDEF: 0)
     b10:	00005200 	andeq	r5, r0, r0, lsl #4
     b14:	00000000 	andeq	r0, r0, r0
     b18:	00010000 	andeq	r0, r1, r0
     b1c:	00000057 	andeq	r0, r0, r7, asr r0
     b20:	00000000 	andeq	r0, r0, r0
     b24:	f3000400 	vshl.u8	d0, d0, d0
     b28:	009f5201 	addseq	r5, pc, r1, lsl #4
	...
     b38:	01000000 	mrseq	r0, (UNDEF: 0)
     b3c:	00005400 	andeq	r5, r0, r0, lsl #8
     b40:	00000000 	andeq	r0, r0, r0
     b44:	00030000 	andeq	r0, r3, r0
     b48:	009f0174 	addseq	r0, pc, r4, ror r1	; <UNPREDICTABLE>
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
     b4c:	00000000 	andeq	r0, r0, r0
  b	LoopCopyDataInit
     b50:	01000000 	mrseq	r0, (UNDEF: 0)

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
     b54:	00005400 	andeq	r5, r0, r0, lsl #8
	...
LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
     b64:	00010000 	andeq	r0, r1, r0
	ldr	r2, =_sbss
	b	LoopFillZerobss
     b68:	00000056 	andeq	r0, r0, r6, asr r0
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
     b6c:	00000000 	andeq	r0, r0, r0
	str	r3, [r2], #4
     b70:	f3000400 	vshl.u8	d0, d0, d0

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
     b74:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
     b84:	01000000 	mrseq	r0, (UNDEF: 0)
	ldr	r3, =_edata
     b88:	00005d00 	andeq	r5, r0, r0, lsl #26
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
     b8c:	00000000 	andeq	r0, r0, r0
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
     b90:	00040000 	andeq	r0, r4, r0
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
     b94:	9f7da891 	svcls	0x007da891
	...
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
     ba0:	a87d0004 	ldmdage	sp!, {r2}^
     ba4:	00009f7d 	andeq	r9, r0, sp, ror pc
	...
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
        bDeviceState = CONFIGURED;
     bb4:	00010000 	andeq	r0, r1, r0
     bb8:	00000055 	andeq	r0, r0, r5, asr r0
	...
{
    /* nothing process */
}

void usbGetStatus(void)
{
     bc8:	91000400 	tstls	r0, r0, lsl #8
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
     bcc:	009f7e88 	addseq	r7, pc, r8, lsl #29
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
     bd0:	00000000 	andeq	r0, r0, r0
     bd4:	01000000 	mrseq	r0, (UNDEF: 0)
     bd8:	00005000 	andeq	r5, r0, r0
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
     bdc:	00000000 	andeq	r0, r0, r0
    dfuUpdateByReset();
     be0:	00040000 	andeq	r0, r4, r0

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
     be4:	9f7e8891 	svcls	0x007e8891
	...
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
     bf0:	00500001 	subseq	r0, r0, r1
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
     bf4:	00000000 	andeq	r0, r0, r0
     bf8:	04000000 	streq	r0, [r0], #-0

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
     bfc:	7e889100 	sinvce	f1, f0
     c00:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     c04:	00000000 	andeq	r0, r0, r0
     c08:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
     c14:	88910004 	ldmhi	r1, {r2}
     c18:	00009f7e 	andeq	r9, r0, lr, ror pc
     c1c:	00000000 	andeq	r0, r0, r0

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
     c20:	00040000 	andeq	r0, r4, r0
     c24:	9f7e887d 	svcls	0x007e887d
	...
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
     c38:	e8910004 	ldm	r1, {r2}
     c3c:	00009f7d 	andeq	r9, r0, sp, ror pc

    Clear_Status_Out(ENDP0);
     c40:	00000000 	andeq	r0, r0, r0

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
     c44:	00010000 	andeq	r0, r1, r0
     c48:	00000051 	andeq	r0, r0, r1, asr r0
     c4c:	00000000 	andeq	r0, r0, r0
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);
     c50:	91000400 	tstls	r0, r0, lsl #8
     c54:	009f7de8 	addseq	r7, pc, r8, ror #27

    bDeviceState = ATTACHED;
     c58:	00000000 	andeq	r0, r0, r0
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
     c5c:	01000000 	mrseq	r0, (UNDEF: 0)

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
     c60:	00005000 	andeq	r5, r0, r0
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
     c64:	00000000 	andeq	r0, r0, r0
     c68:	00040000 	andeq	r0, r4, r0
     c6c:	9f7de891 	svcls	0x007de891
	...
     c78:	e87d0004 	ldmda	sp!, {r2}^
     c7c:	00009f7d 	andeq	r9, r0, sp, ror pc
	...
RESULT usbDataSetup(u8 request) {
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     c8c:	00040000 	andeq	r0, r4, r0
     c90:	9f7dc891 	svcls	0x007dc891
	...
        if (dfuUpdateByRequest()) {
     c9c:	00520001 	subseq	r0, r2, r1
            // successfull state transition, handle the request
            switch (request) {
     ca0:	00000000 	andeq	r0, r0, r0
     ca4:	04000000 	streq	r0, [r0], #-0
     ca8:	7dc89100 	stfvcp	f1, [r8]
     cac:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
     cb0:	00000000 	andeq	r0, r0, r0
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
     cb4:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
     cc0:	c8910004 	ldmgt	r1, {r2}
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
     cc4:	00009f7d 	andeq	r9, r0, sp, ror pc
        (*CopyRoutine)(0);

        return USB_SUCCESS;
     cc8:	00000000 	andeq	r0, r0, r0
    }

    return USB_UNSUPPORT;
     ccc:	00010000 	andeq	r0, r1, r0
}
     cd0:	00000051 	andeq	r0, r0, r1, asr r0
     cd4:	00000000 	andeq	r0, r0, r0
     cd8:	91000400 	tstls	r0, r0, lsl #8
     cdc:	009f7dc8 	addseq	r7, pc, r8, asr #27
     ce0:	00000000 	andeq	r0, r0, r0
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
     ce4:	04000000 	streq	r0, [r0], #-0
     ce8:	7dc87d00 	stclvc	13, cr7, [r8]
     cec:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
     cfc:	5d000100 	stfpls	f0, [r0, #-0]
	...
    if (strIndex > STR_DESC_LEN) {
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
     d08:	a8910004 	ldmge	r1, {r2}
     d0c:	00009f7d 	andeq	r9, r0, sp, ror pc
    }
}
     d10:	00000000 	andeq	r0, r0, r0
     d14:	00040000 	andeq	r0, r4, r0
     d18:	9f7da87d 	svcls	0x007da87d
	...
    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
     d2c:	00560001 	subseq	r0, r6, r1
     d30:	00000000 	andeq	r0, r0, r0
     d34:	04000000 	streq	r0, [r0], #-0
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
     d38:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
     d3c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
            return USB_SUCCESS;
        }
    }
    return USB_UNSUPPORT;
}
     d4c:	91000400 	tstls	r0, r0, lsl #8

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
     d50:	009f7ec8 	addseq	r7, pc, r8, asr #29
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d54:	00000000 	andeq	r0, r0, r0
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d58:	01000000 	mrseq	r0, (UNDEF: 0)
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     d5c:	00005000 	andeq	r5, r0, r0
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
     d60:	00000000 	andeq	r0, r0, r0
     d64:	00040000 	andeq	r0, r4, r0
     d68:	9f7ec891 	svcls	0x007ec891
	...
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
     d74:	00520001 	subseq	r0, r2, r1
     d78:	00000000 	andeq	r0, r0, r0
     d7c:	04000000 	streq	r0, [r0], #-0
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
     d80:	7ec89100 	acsvce	f1, f0
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d84:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     d88:	00000000 	andeq	r0, r0, r0
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
     d8c:	7d000400 	cfstrsvc	mvf0, [r0, #-0]
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
     d90:	009f7ec8 	addseq	r7, pc, r8, asr #29
	...
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
     da0:	04000000 	streq	r0, [r0], #-0
     da4:	7ea89100 	tanvce	f1, f0
     da8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
     dac:	00000000 	andeq	r0, r0, r0
     db0:	52000100 	andpl	r0, r0, #0, 2
	...
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
     dbc:	a8910004 	ldmge	r1, {r2}
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
     dc0:	00009f7e 	andeq	r9, r0, lr, ror pc

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
     dc4:	00000000 	andeq	r0, r0, r0
     dc8:	00040000 	andeq	r0, r4, r0
     dcc:	9f7ea87d 	svcls	0x007ea87d
	...
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
     dd8:	00001a0c 	andeq	r1, r0, ip, lsl #20
     ddc:	00001a60 	andeq	r1, r0, r0, ror #20

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
     de0:	60500001 	subsvs	r0, r0, r1
     de4:	7800001a 	stmdavc	r0, {r1, r3, r4}
     de8:	0100001a 	tsteq	r0, sl, lsl r0
}

void usbResume(RESUME_STATE eResumeSetVal)
{
     dec:	1a785400 	bne	1e15df4 <_etext+0x1e0e7e0>
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
     df0:	1a7b0000 	bne	1ec0df8 <_etext+0x1eb97e4>
        ResumeS.eState = eResumeSetVal;
     df4:	00030000 	andeq	r0, r3, r0

    switch (ResumeS.eState) {
     df8:	7b9f4070 	blvc	fe7d0fc0 <BootRAM+0xd741761>
     dfc:	7c00001a 	stcvc	0, cr0, [r0], {26}
     e00:	0400001a 	streq	r0, [r0], #-26
     e04:	5001f300 	andpl	pc, r1, r0, lsl #6
    case RESUME_EXTERNAL:
        usbResumeInit();
     e08:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
     e0c:	00000000 	andeq	r0, r0, r0
        ResumeS.eState = RESUME_START;
     e10:	001a0c00 	andseq	r0, sl, r0, lsl #24
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
     e14:	001a1a00 	andseq	r1, sl, r0, lsl #20
        ResumeS.eState = RESUME_WAIT;
     e18:	51000100 	mrspl	r0, (UNDEF: 16)
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
     e1c:	00001a1a 	andeq	r1, r0, sl, lsl sl
     e20:	00001a78 	andeq	r1, r0, r8, ror sl
        if (ResumeS.bESOFcnt == 0)
     e24:	78550001 	ldmdavc	r5, {r0}^
            ResumeS.eState = RESUME_START;
     e28:	7b00001a 	blvc	e98 <usbPowerOn+0x28>
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
     e2c:	0100001a 	tsteq	r0, sl, lsl r0
     e30:	1a7b5100 	bne	1ed5238 <_etext+0x1ecdc24>
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
     e34:	1a7c0000 	bne	1f00e3c <_etext+0x1ef9828>
        ResumeS.eState = RESUME_ON;
     e38:	00040000 	andeq	r0, r4, r0
        ResumeS.bESOFcnt = 10;
     e3c:	9f5101f3 	svcls	0x005101f3
	...
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
     e48:	00001a0c 	andeq	r1, r0, ip, lsl #20
        if (ResumeS.bESOFcnt == 0) {
     e4c:	00001a44 	andeq	r1, r0, r4, asr #20
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e50:	44520001 	ldrbmi	r0, [r2], #-1
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
     e54:	7800001a 	stmdavc	r0, {r1, r3, r4}
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
     e58:	0100001a 	tsteq	r0, sl, lsl r0
            ResumeS.eState = RESUME_OFF;
     e5c:	1a785600 	bne	1e16664 <_etext+0x1e0f050>
     e60:	1a7b0000 	bne	1ec0e68 <_etext+0x1eb9854>
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
     e64:	00010000 	andeq	r0, r1, r0
     e68:	001a7b52 	andseq	r7, sl, r2, asr fp
     e6c:	001a7c00 	andseq	r7, sl, r0, lsl #24
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
     e70:	f3000400 	vshl.u8	d0, d0, d0
     e74:	009f5201 	addseq	r5, pc, r1, lsl #4
     e78:	00000000 	andeq	r0, r0, r0
     e7c:	5a000000 	bpl	e84 <usbPowerOn+0x14>

    _SetCNTR(CNTR_FRES);
     e80:	7800001a 	stmdavc	r0, {r1, r3, r4}
     e84:	0100001a 	tsteq	r0, sl, lsl r0
     e88:	1a785500 	bne	1e16290 <_etext+0x1e0ec7c>
     e8c:	1a7b0000 	bne	1ec0e94 <_etext+0x1eb9880>
    _SetCNTR(0);
    _SetISTR(0);
     e90:	00010000 	andeq	r0, r1, r0

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
     e94:	001a7b51 	andseq	r7, sl, r1, asr fp
    _SetCNTR(wInterrupt_Mask);
     e98:	001a7c00 	andseq	r7, sl, r0, lsl #24
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
     e9c:	f3000400 	vshl.u8	d0, d0, d0
     ea0:	009f5101 	addseq	r5, pc, r1, lsl #2
#endif
#endif

    return USB_SUCCESS;
}
     ea4:	00000000 	andeq	r0, r0, r0
     ea8:	5a000000 	bpl	eb0 <usbPowerOn+0x40>
     eac:	6000001a 	andvs	r0, r0, sl, lsl r0
     eb0:	0100001a 	tsteq	r0, sl, lsl r0
     eb4:	1a605000 	bne	1814ebc <_etext+0x180d8a8>

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
     eb8:	1a780000 	bne	1e00ec0 <_etext+0x1df98ac>
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
     ebc:	00010000 	andeq	r0, r1, r0
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
     ec0:	001a7854 	andseq	r7, sl, r4, asr r8
     ec4:	001a7b00 	andseq	r7, sl, r0, lsl #22
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
     ec8:	70000300 	andvc	r0, r0, r0, lsl #6
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
     ecc:	1a7b9f40 	bne	1ee8bd4 <_etext+0x1ee15c0>
     ed0:	1a7c0000 	bne	1f00ed8 <_etext+0x1ef98c4>
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
     ed4:	00040000 	andeq	r0, r4, r0
     ed8:	9f5001f3 	svcls	0x005001f3
	...

    return USB_SUCCESS;
}
     ee4:	00001a5a 	andeq	r1, r0, sl, asr sl
     ee8:	00001a60 	andeq	r1, r0, r0, ror #20
     eec:	20700003 	rsbscs	r0, r0, r3
     ef0:	001a609f 	mulseq	sl, pc, r0	; <UNPREDICTABLE>
}


void usbDsbBus(void)
{
    usbPowerOff();
     ef4:	001a7800 	andseq	r7, sl, r0, lsl #16
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
     ef8:	74000300 	strvc	r0, [r0], #-768	; 0x300
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     efc:	1a789f20 	bne	1e28b84 <_etext+0x1e21570>
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f00:	1a7b0000 	bne	1ec0f08 <_etext+0x1eb98f4>
     f04:	00030000 	andeq	r0, r3, r0
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f08:	7b9f6070 	blvc	fe7d90d0 <BootRAM+0xd749871>
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
     f0c:	7c00001a 	stcvc	0, cr0, [r0], {26}
     f10:	0600001a 			; <UNDEFINED> instruction: 0x0600001a
    nvicInit(&NVIC_InitStructure);
     f14:	5001f300 	andpl	pc, r1, r0, lsl #6
}
     f18:	009f2023 	addseq	r2, pc, r3, lsr #32

    return USB_SUCCESS;
}

void usbInit(void)
{
     f1c:	00000000 	andeq	r0, r0, r0
    dfuInit();
     f20:	7c000000 	stcvc	0, cr0, [r0], {-0}

    pInformation->Current_Configuration = 0;
     f24:	8800001a 	stmdahi	r0, {r1, r3, r4}
     f28:	0100001a 	tsteq	r0, sl, lsl r0
    usbPowerOn();
     f2c:	1a885000 	bne	fe214f34 <BootRAM+0xd1856d5>

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
     f30:	1ab60000 	bne	fed80f38 <BootRAM+0xdcf16d9>
     f34:	00010000 	andeq	r0, r1, r0
     f38:	00000056 	andeq	r0, r0, r6, asr r0
    _SetCNTR(wInterrupt_Mask);
     f3c:	00000000 	andeq	r0, r0, r0

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
     f40:	001a7c00 	andseq	r7, sl, r0, lsl #24
    bDeviceState = UNCONNECTED;
     f44:	001a8c00 	andseq	r8, sl, r0, lsl #24
     f48:	51000100 	mrspl	r0, (UNDEF: 16)
     f4c:	00001a8c 	andeq	r1, r0, ip, lsl #21
     f50:	00001ab6 			; <UNDEFINED> instruction: 0x00001ab6
     f54:	00550001 	subseq	r0, r5, r1
     f58:	00000000 	andeq	r0, r0, r0
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
     f5c:	7c000000 	stcvc	0, cr0, [r0], {-0}
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
     f60:	8f00001a 	svchi	0x0000001a
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
    nvicInit(&NVIC_InitStructure);
     f64:	0100001a 	tsteq	r0, sl, lsl r0

void usbDsbISR(void)
{
    NVIC_InitTypeDef NVIC_InitStructure;
    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
     f68:	1a8f5200 	bne	fe3d5770 <BootRAM+0xd345f11>
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
     f6c:	1ab60000 	bne	fed80f74 <BootRAM+0xdcf1715>
    NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
     f70:	00010000 	andeq	r0, r1, r0
    nvicInit(&NVIC_InitStructure);
     f74:	00000054 	andeq	r0, r0, r4, asr r0
}
     f78:	00000000 	andeq	r0, r0, r0
     f7c:	001ab800 	andseq	fp, sl, r0, lsl #16

void USB_LP_CAN1_RX0_IRQHandler(void)
{
     f80:	001ac400 	andseq	ip, sl, r0, lsl #8
    wIstr = _GetISTR();
     f84:	50000100 	andpl	r0, r0, r0, lsl #2

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f88:	00001ac4 	andeq	r1, r0, r4, asr #21
    nvicInit(&NVIC_InitStructure);
}

void USB_LP_CAN1_RX0_IRQHandler(void)
{
    wIstr = _GetISTR();
     f8c:	00001b16 	andeq	r1, r0, r6, lsl fp

    /* go nuts with the preproc switches since this is an ISTR and must be FAST */
    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_CTR)
    if (wIstr & ISTR_CTR & wInterrupt_Mask) {
     f90:	00550001 	subseq	r0, r5, r1
     f94:	00000000 	andeq	r0, r0, r0
        /* servicing of the endpoint correct transfer interrupt */
        /* clear of the CTR flag into the sub */
        CTR_LP(); /* low priority ISR defined in the usb core lib */
     f98:	b8000000 	stmdalt	r0, {}	; <UNPREDICTABLE>
    }
#endif

#if (ISR_MSK & ISTR_RESET)
    if (wIstr & ISTR_RESET & wInterrupt_Mask) {
     f9c:	ca00001a 	bgt	100c <USB_LP_CAN1_RX0_IRQHandler+0x8c>
     fa0:	0100001a 	tsteq	r0, sl, lsl r0
     fa4:	1aca5100 	bne	ff2953ac <BootRAM+0xe205b4d>
        _SetISTR((u16)CLR_RESET);
     fa8:	1b160000 	blne	580fb0 <_etext+0x57999c>
        Device_Property.Reset();
     fac:	00010000 	andeq	r0, r1, r0
     fb0:	00000057 	andeq	r0, r0, r7, asr r0
    }
#endif


#if (ISR_MSK & ISTR_ERR)
    if (wIstr & ISTR_ERR & wInterrupt_Mask) {
     fb4:	00000000 	andeq	r0, r0, r0
     fb8:	001ab800 	andseq	fp, sl, r0, lsl #16
        _SetISTR((u16)CLR_ERR);
     fbc:	001ac600 	andseq	ip, sl, r0, lsl #12
     fc0:	52000100 	andpl	r0, r0, #0, 2
    }
#endif


#if (ISR_MSK & ISTR_WKUP)
    if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
     fc4:	00001ac6 	andeq	r1, r0, r6, asr #21
     fc8:	00001b16 	andeq	r1, r0, r6, lsl fp
        _SetISTR((u16)CLR_WKUP);
     fcc:	00560001 	subseq	r0, r6, r1
        usbResume(RESUME_EXTERNAL);
     fd0:	00000000 	andeq	r0, r0, r0
     fd4:	0e000000 	cdpeq	0, 0, cr0, cr0, cr0, {0}
    }
#endif

    /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
#if (ISR_MSK & ISTR_SUSP)
    if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
     fd8:	1000001b 	andne	r0, r0, fp, lsl r0
     fdc:	0100001b 	tsteq	r0, fp, lsl r0

        // check if SUSPEND is possible
        if (F_SUSPEND_ENABLED) {
            usbSuspend();
     fe0:	00005400 	andeq	r5, r0, r0, lsl #8
        } else {
            // if not possible then resume after xx ms
            usbResume(RESUME_LATER);
        }
        // clear of the ISTR bit must be done after setting of CNTR_FSUSP
        _SetISTR((u16)CLR_SUSP);
     fe4:	00000000 	andeq	r0, r0, r0
     fe8:	1ac20000 	bne	ff080ff0 <BootRAM+0xdff1791>
    }
#endif


#if (ISR_MSK & ISTR_SOF)
    if (wIstr & ISTR_SOF & wInterrupt_Mask) {
     fec:	1aca0000 	bne	ff280ff4 <BootRAM+0xe1f1795>
     ff0:	00010000 	andeq	r0, r1, r0
        _SetISTR((u16)CLR_SOF);
     ff4:	001aca51 	andseq	ip, sl, r1, asr sl
     ff8:	001b1600 	andseq	r1, fp, r0, lsl #12
        bIntPackSOF++;
     ffc:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    }
#endif


#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
    1008:	00001ac2 	andeq	r1, r0, r2, asr #21
        _SetISTR((u16)CLR_ESOF);
    100c:	00001b14 	andeq	r1, r0, r4, lsl fp
    1010:	145d0001 	ldrbne	r0, [sp], #-1
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    }
#endif

}
    1014:	1600001b 			; <UNDEFINED> instruction: 0x1600001b
#if (ISR_MSK & ISTR_ESOF)
    if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
        _SetISTR((u16)CLR_ESOF);
        // resume handling timing is made with ESOFs
        // request without change of the machine state
        usbResume(RESUME_ESOF); 
    1018:	0300001b 	movweq	r0, #27
    101c:	9f489100 	svcls	0x00489100
	...
    1028:	00001b18 	andeq	r1, r0, r8, lsl fp
    102c:	00001b58 	andeq	r1, r0, r8, asr fp
    1030:	58500001 	ldmdapl	r0, {r0}^
#define USART1              ((USART_TypeDef *) USART1_BASE)

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
    1034:	d800001b 	stmdale	r0, {r0, r1, r3, r4}
	bool no_user_jump = FALSE;
	bool dont_wait=FALSE;
	
    systemReset(); // peripherals but not PC
    1038:	0100001b 	tsteq	r0, fp, lsl r0
    setupCLK();
    103c:	1bd85400 	blne	ff616044 <BootRAM+0xe5867e5>
    setupLEDAndButton();
    1040:	1be00000 	blne	ff801048 <BootRAM+0xe7717e9>
    setupUSB();
    1044:	00040000 	andeq	r0, r4, r0
    setupFLASH();
    1048:	9f5001f3 	svcls	0x005001f3
	...
    uartInit();
    usbReset();
	uart_printf("\nBootloader init...\n");
    1054:	00001b18 	andeq	r1, r0, r8, lsl fp
    1058:	00001b5d 	andeq	r1, r0, sp, asr fp

    if (readPin(GPIOB, 15) == 0x0)
    105c:	5d510001 	ldclpl	0, cr0, [r1, #-4]
    1060:	e000001b 	and	r0, r0, fp, lsl r0
	{
		no_user_jump = TRUE;
	} 

	uart_printf("checking chain...\n");
    1064:	0400001b 	streq	r0, [r0], #-27
    1068:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
	ImageObjectHandle imageHandle;

    int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    106c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    1070:	00000000 	andeq	r0, r0, r0
    1074:	001b1800 	andseq	r1, fp, r0, lsl #16
    
    debug_print("image check ret: %X\n", ret);
    1078:	001b5000 	andseq	r5, fp, r0
    107c:	52000100 	andpl	r0, r0, #0, 2
	switch (ret)
    1080:	00001b50 	andeq	r1, r0, r0, asr fp
    1084:	00001be0 	andeq	r1, r0, r0, ror #23
    1088:	01f30004 	mvnseq	r0, r4

extern volatile dfuUploadTypes_t userUploadType;

int main() 
{
	bool no_user_jump = FALSE;
    108c:	00009f52 	andeq	r9, r0, r2, asr pc
    1090:	00000000 	andeq	r0, r0, r0
    1094:	1b2c0000 	blne	b0109c <_etext+0xaf9a88>
    
    debug_print("image check ret: %X\n", ret);
	switch (ret)
	{
		case kImageImageIsTrusted:
			uart_printf("Boot OK\n");
    1098:	1bd80000 	blne	ff6010a0 <BootRAM+0xe571841>
			no_user_jump = FALSE;
    109c:	00080000 	andeq	r0, r8, r0
			break;

		case kImageImageMissingMagic:
			uart_printf("Firmware missing... waiting in DFU\n");
    10a0:	25370078 	ldrcs	r0, [r7, #-120]!	; 0x78
			no_user_jump = TRUE;
			break;

		case kImageImageRejectSignature:
			uart_printf("Signature unverified... waiting in DFU\n");
    10a4:	9f1aff08 	svcls	0x001aff08
	...
			break;
			
		default:
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
    10b0:	00001b2c 	andeq	r1, r0, ip, lsr #22
    10b4:	00001b50 	andeq	r1, r0, r0, asr fp
    10b8:	50520001 	subspl	r0, r2, r1
    10bc:	e000001b 	and	r0, r0, fp, lsl r0
    10c0:	0400001b 	streq	r0, [r0], #-27

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10c4:	5201f300 	andpl	pc, r1, #0, 6
	{

		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
    10c8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    10cc:	00000000 	andeq	r0, r0, r0
    10d0:	001b2c00 	andseq	r2, fp, r0, lsl #24
    10d4:	001b5d00 	andseq	r5, fp, r0, lsl #26
    10d8:	51000100 	mrspl	r0, (UNDEF: 16)

		if (dfuUploadStarted()) 
    10dc:	00001b5d 	andeq	r1, r0, sp, asr fp
		{
			uart_printf("DFU finished upload\n");
    10e0:	00001be0 	andeq	r1, r0, r0, ror #23
    10e4:	01f30004 	mvnseq	r0, r4
			dfuFinishUpload(); // systemHardReset from DFU once done
    10e8:	00009f51 	andeq	r9, r0, r1, asr pc
    10ec:	00000000 	andeq	r0, r0, r0
			break;
	}
	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);

	int delay_count = 0;
	while ((delay_count++ < BOOTLOADER_WAIT) || no_user_jump)
    10f0:	1be00000 	blne	ff8010f8 <BootRAM+0xe771899>
		}
	}

	if (no_user_jump == FALSE)
	{
		uart_printf("Jumping to OS.\n");
    10f4:	1bf60000 	blne	ffd810fc <BootRAM+0xecf189d>
		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
    10f8:	00010000 	andeq	r0, r1, r0
    10fc:	001bf650 	andseq	pc, fp, r0, asr r6	; <UNPREDICTABLE>
	}
	
	return 0;// Added to please the compiler
    1100:	001cbc00 	andseq	fp, ip, r0, lsl #24
    1104:	56000100 	strpl	r0, [r0], -r0, lsl #2
    1108:	00001cbc 			; <UNDEFINED> instruction: 0x00001cbc
    110c:	00001cc0 	andeq	r1, r0, r0, asr #25
    1110:	01f30004 	mvnseq	r0, r4
    1114:	00009f50 	andeq	r9, r0, r0, asr pc
    1118:	00000000 	andeq	r0, r0, r0
    111c:	1be00000 	blne	ff801124 <BootRAM+0xe7718c5>
    1120:	1bf20000 	blne	ffc81128 <BootRAM+0xebf18c9>
    1124:	00010000 	andeq	r0, r1, r0
    1128:	001bf251 	andseq	pc, fp, r1, asr r2	; <UNPREDICTABLE>
    112c:	001cbc00 	andseq	fp, ip, r0, lsl #24
    1130:	55000100 	strpl	r0, [r0, #-256]	; 0x100
    1134:	00001cbc 			; <UNDEFINED> instruction: 0x00001cbc
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1138:	00001cc0 	andeq	r1, r0, r0, asr #25
    113c:	01f30004 	mvnseq	r0, r4
    u32 pinMask = 0x1 << (16 + pin);
    SET_REG(GPIO_BSRR(bank), pinMask);
}
*/
void gpio_write_bit(u32 bank, u8 pin, u8 val) {
    val = !val;          // "set" bits are lower than "reset" bits  
    1140:	00009f51 	andeq	r9, r0, r1, asr pc
    1144:	00000000 	andeq	r0, r0, r0
    SET_REG(GPIO_BSRR(bank), (1U << pin) << (16 * val));
    1148:	1be00000 	blne	ff801150 <BootRAM+0xe7718f1>
    114c:	1bf40000 	blne	ffd01154 <BootRAM+0xec718f5>
}

bool readPin(u32 bank, u8 pin) {
    // todo, implement read
    if (GET_REG(GPIO_IDR(bank)) & (0x01 << pin)) {
    1150:	00010000 	andeq	r0, r1, r0
    1154:	001bf452 	andseq	pc, fp, r2, asr r4	; <UNPREDICTABLE>
        return TRUE;
    } else {
        return FALSE;
    }
}
    1158:	001cbc00 	andseq	fp, ip, r0, lsl #24
    115c:	54000100 	strpl	r0, [r0], #-256	; 0x100

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1160:	00001cbc 			; <UNDEFINED> instruction: 0x00001cbc
    1164:	00001cc0 	andeq	r1, r0, r0, asr #25
    1168:	01f30004 	mvnseq	r0, r4
    gpio_write_bit( bank,pin,1-onState);
    116c:	00009f52 	andeq	r9, r0, r2, asr pc
    1170:	00000000 	andeq	r0, r0, r0
        return FALSE;
    }
}

void strobePin(u32 bank, u8 pin, u8 count, u32 rate,u8 onState) 
{
    1174:	1cc00000 	stclne	0, cr0, [r0], {0}
    gpio_write_bit( bank,pin,1-onState);
    1178:	1cce0000 	stclne	0, cr0, [lr], {0}

    u32 c;
    while (count-- > 0) 
    117c:	00010000 	andeq	r0, r1, r0
	{
        for (c = rate; c > 0; c--)
    1180:	001cce50 	andseq	ip, ip, r0, asr lr
    1184:	001d7400 	andseq	r7, sp, r0, lsl #8
		{
            asm volatile("nop");
        }
		
        gpio_write_bit( bank,pin,onState);
    1188:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
		
        for (c = rate; c > 0; c--)
    1194:	00001cc0 	andeq	r1, r0, r0, asr #25
    1198:	00001cd3 	ldrdeq	r1, [r0], -r3
		{
            asm volatile("nop");
        }
        gpio_write_bit( bank,pin,1-onState);
    119c:	d3510001 	cmple	r1, #1
    11a0:	7400001c 	strvc	r0, [r0], #-28
    11a4:	0100001d 	tsteq	r0, sp, lsl r0
    11a8:	00005500 	andeq	r5, r0, r0, lsl #10
    11ac:	00000000 	andeq	r0, r0, r0

//DebugLog
#ifdef DEBUG
void UU_PutChar(USART_TypeDef* USARTx, uint8_t ch)
{
  while(!(USARTx->SR & USART_SR_TXE));
    11b0:	1d740000 	ldclne	0, cr0, [r4, #-0]
    11b4:	1d820000 	stcne	0, cr0, [r2]
  USARTx->DR = ch;  
    11b8:	00010000 	andeq	r0, r1, r0
}

void UU_PutString(USART_TypeDef* USARTx, uint8_t * str)
{
    11bc:	001d8250 	andseq	r8, sp, r0, asr r2
  while(*str != 0)
    11c0:	001df200 	andseq	pc, sp, r0, lsl #4
    11c4:	58000100 	stmdapl	r0, {r8}
  {
    UU_PutChar(USARTx, *str);
    11c8:	00001df2 	strdeq	r1, [r0], -r2
    11cc:	00001df8 	strdeq	r1, [r0], -r8
    str++;
  }
}

void vprint(const char *fmt, va_list argp)
{
    11d0:	01f30004 	mvnseq	r0, r4
    11d4:	00009f50 	andeq	r9, r0, r0, asr pc
    char string[200];
    if(0 < vsprintf(string,fmt,argp)) // build string
    11d8:	00000000 	andeq	r0, r0, r0
    11dc:	1d740000 	ldclne	0, cr0, [r4, #-0]
    11e0:	1d840000 	stcne	0, cr0, [r4]
    {
        UU_PutString(USART1, (uint8_t*)string); // send message via UART
    11e4:	00010000 	andeq	r0, r1, r0
    11e8:	001d8451 	andseq	r8, sp, r1, asr r4

    }
}
    11ec:	001df200 	andseq	pc, sp, r0, lsl #4
    11f0:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    11f4:	00001df2 	strdeq	r1, [r0], -r2

void uart_printf(const char *fmt, ...) // custom printf() function
{
    11f8:	00001df8 	strdeq	r1, [r0], -r8
    11fc:	01f30004 	mvnseq	r0, r4
    1200:	00009f51 	andeq	r9, r0, r1, asr pc
    va_list argp;
    va_start(argp, fmt);
    vprint(fmt, argp);
    1204:	00000000 	andeq	r0, r0, r0
    va_end(argp);
}
    1208:	1d740000 	ldclne	0, cr0, [r4, #-0]
    120c:	1d860000 	stcne	0, cr0, [r6]
    1210:	00010000 	andeq	r0, r1, r0

void hexdump(unsigned char *data, size_t size)
{
    1214:	001d8652 	andseq	r8, sp, r2, asr r6
    1218:	001df200 	andseq	pc, sp, r0, lsl #4
    int i;
    char cs[17];
    memset(cs, 0, 17);
    121c:	56000100 	strpl	r0, [r0], -r0, lsl #2
    1220:	00001df2 	strdeq	r1, [r0], -r2
    1224:	00001df8 	strdeq	r1, [r0], -r8

    for(i = 0; i < size; i++)
    1228:	01f30004 	mvnseq	r0, r4
    122c:	00009f52 	andeq	r9, r0, r2, asr pc
    {
        if(i != 0 && i % 0x10 == 0)
    1230:	00000000 	andeq	r0, r0, r0
        {
            debug_print(" |%s|\n", cs);
    1234:	1d8a0000 	stcne	0, cr0, [sl]
    1238:	1d8c0000 	stcne	0, cr0, [ip]
            memset(cs, 0, 17);
    123c:	00030000 	andeq	r0, r3, r0
    1240:	8c9fff08 	ldchi	15, cr15, [pc], {8}
    1244:	d600001d 			; <UNDEFINED> instruction: 0xd600001d
        }
        else if(i != 0 && i % 0x8 == 0)
    1248:	0100001d 	tsteq	r0, sp, lsl r0
    124c:	1dd65400 	cfldrdne	mvd5, [r6]
        {
            debug_print(" ",0);
    1250:	1dde0000 	ldclne	0, cr0, [lr]
        }
        debug_print("%02X ", data[i]);
    1254:	00030000 	andeq	r0, r3, r0
    1258:	de9f0174 	mrcle	1, 4, r0, cr15, cr4, {3}
        cs[(i % 0x10)] = (data[i] >= 0x20 && data[i] <= 0x7e) ? data[i] : '.';
    125c:	f200001d 	vqadd.s8	d0, d0, d13
    1260:	0100001d 	tsteq	r0, sp, lsl r0
    1264:	00005400 	andeq	r5, r0, r0, lsl #8
    1268:	00000000 	andeq	r0, r0, r0
    126c:	1d7a0000 	ldclne	0, cr0, [sl, #-0]
    1270:	1dee0000 	stclne	0, cr0, [lr]
    }

    i = i % 0x10;
    if(i != 0)
    1274:	00010000 	andeq	r0, r1, r0
        while(i++ < 0x10)
        {
            debug_print("   ",0);
        }
    }
    debug_print(" |%s|\n", cs);
    1278:	001dee5d 	andseq	lr, sp, sp, asr lr
    127c:	001df200 	andseq	pc, sp, r0, lsl #4
}
    1280:	91000400 	tstls	r0, r0, lsl #8
    }

    i = i % 0x10;
    if(i != 0)
    {
        if(i <= 0x8)
    1284:	f29f7de8 	vqrdmulh.s16	d7, d31, d0[3]
        {
            debug_print(" ",0);
    1288:	f800001d 			; <UNDEFINED> instruction: 0xf800001d
    128c:	0400001d 	streq	r0, [r0], #-29
        }
        while(i++ < 0x10)
    1290:	7de87d00 	stclvc	13, cr7, [r8]
        {
            debug_print("   ",0);
    1294:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    1298:	00000000 	andeq	r0, r0, r0
    129c:	001da200 	andseq	sl, sp, r0, lsl #4
    12a0:	001df200 	andseq	pc, sp, r0, lsl #4
    12a4:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    }
    debug_print(" |%s|\n", cs);
}

void print_hash(unsigned char hash[])
{
    12b0:	00001de2 	andeq	r1, r0, r2, ror #27
   int idx;
   for (idx=0; idx < 32; idx++)
    12b4:	00001dee 	andeq	r1, r0, lr, ror #27
      debug_print("%02x",hash[idx]);
    12b8:	ee5d0001 	cdp	0, 5, cr0, cr13, cr1, {0}
    12bc:	f200001d 	vqadd.s8	d0, d0, d13
}

void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
    12c0:	0400001d 	streq	r0, [r0], #-29
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12c4:	7de89100 	stfvcp	f1, [r8]
}
    12c8:	001df29f 	mulseq	sp, pc, r2	; <UNPREDICTABLE>
void print_hash(unsigned char hash[])
{
   int idx;
   for (idx=0; idx < 32; idx++)
      debug_print("%02x",hash[idx]);
   debug_print("\n", 0);
    12cc:	001df800 	andseq	pc, sp, r0, lsl #16
    12d0:	7d000400 	cfstrsvc	mvf0, [r0, #-0]
    12d4:	009f7de8 	addseq	r7, pc, r8, ror #27
}

#endif
void uartInit(void) {
    12d8:	00000000 	andeq	r0, r0, r0
    12dc:	e2000000 	and	r0, r0, #0
    GPIO_InitTypeDef GPIO_InitStructure;
    USART_InitTypeDef USART_InitStructure;
    
    /* Enable peripheral clocks for USART1 on GPIOA */
    //RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1 | GPIOA | RCC_APB2Periph_AFIO, ENABLE);
    RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
    12e0:	f200001d 	vqadd.s8	d0, d0, d13
    12e4:	0100001d 	tsteq	r0, sp, lsl r0
        RCC_APB2PeriphClockCmd(GPIOA, ENABLE);
    12e8:	1df25800 	ldclne	8, cr5, [r2]
    12ec:	1df80000 	ldclne	0, cr0, [r8]
    /* Configure PA9 and PA10 as USART1 TX/RX */
    
    /* PA9 = alternate function push/pull output */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
    12f0:	00040000 	andeq	r0, r4, r0
    12f4:	9f5001f3 	svcls	0x005001f3
	...
    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1308:	00500001 	subseq	r0, r0, r1
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    130c:	00000000 	andeq	r0, r0, r0
    1310:	01000000 	mrseq	r0, (UNDEF: 0)
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    1314:	00005600 	andeq	r5, r0, r0, lsl #12
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1318:	00000000 	andeq	r0, r0, r0
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    
    /* PA10 = floating input */
    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
    131c:	00040000 	andeq	r0, r4, r0
    GPIO_Init((GPIO_TypeDef*)GPIOA, &GPIO_InitStructure);
    1320:	9f5001f3 	svcls	0x005001f3
	...
    
    /* Configure and initialize usart... */
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    1334:	00510001 	subseq	r0, r1, r1
    USART_InitStructure.USART_Parity = USART_Parity_No;
    1338:	00000000 	andeq	r0, r0, r0
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    133c:	01000000 	mrseq	r0, (UNDEF: 0)
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
        
    USART_Init(USART1, &USART_InitStructure);
    1340:	00005700 	andeq	r5, r0, r0, lsl #14
    1344:	00000000 	andeq	r0, r0, r0
    USART_InitStructure.USART_BaudRate = 115200;
    USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    USART_InitStructure.USART_StopBits = USART_StopBits_1;
    USART_InitStructure.USART_Parity = USART_Parity_No;
    USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    1348:	00040000 	andeq	r0, r4, r0
        
    USART_Init(USART1, &USART_InitStructure);
    134c:	9f5101f3 	svcls	0x005101f3
	...
    /* Enable USART1 */
    USART_Cmd(USART1, ENABLE);   
}

void systemReset(void) {
    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x00000001);
    1360:	00510001 	subseq	r0, r1, r1
    1364:	00000000 	andeq	r0, r0, r0
    1368:	01000000 	mrseq	r0, (UNDEF: 0)
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xF8FF0000);
    136c:	00005700 	andeq	r5, r0, r0, lsl #14
    1370:	00000000 	andeq	r0, r0, r0
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFEF6FFFF);
    1374:	00040000 	andeq	r0, r4, r0
    1378:	9f5101f3 	svcls	0x005101f3
	...
    SET_REG(RCC_CR, GET_REG(RCC_CR)     & 0xFFFBFFFF);
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) & 0xFF80FFFF);
    138c:	a8910004 	ldmge	r1, {r2}

    SET_REG(RCC_CIR, 0x00000000);  /* disable all RCC interrupts */
    1390:	00009f7e 	andeq	r9, r0, lr, ror pc
    1394:	00000000 	andeq	r0, r0, r0
    1398:	00010000 	andeq	r0, r1, r0
    139c:	00000051 	andeq	r0, r0, r1, asr r0
    13a0:	00000000 	andeq	r0, r0, r0
    13a4:	91000400 	tstls	r0, r0, lsl #8
}

void setupCLK(void) {
	unsigned int StartUpCounter=0;
    /* enable HSE */
    SET_REG(RCC_CR, GET_REG(RCC_CR) | 0x00010001);
    13a8:	009f7ea8 	addseq	r7, pc, r8, lsr #29
    13ac:	00000000 	andeq	r0, r0, r0
    13b0:	01000000 	mrseq	r0, (UNDEF: 0)
    while ((GET_REG(RCC_CR) & 0x00020000) == 0); /* for it to come on */
    13b4:	00005200 	andeq	r5, r0, r0, lsl #4
    13b8:	00000000 	andeq	r0, r0, r0

    /* enable flash prefetch buffer */
    SET_REG(FLASH_ACR, 0x00000012);
    13bc:	00040000 	andeq	r0, r4, r0
	
     /* Configure PLL */
#ifdef XTAL12M
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00110400); /* pll=72Mhz(x6),APB1=36Mhz,AHB=72Mhz */
#else
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x001D0400); /* pll=72Mhz(x9),APB1=36Mhz,AHB=72Mhz */
    13c0:	9f7ea891 	svcls	0x007ea891
	...
    13cc:	a87d0004 	ldmdage	sp!, {r2}^
#endif	

    SET_REG(RCC_CR, GET_REG(RCC_CR)     | 0x01000000); /* enable the pll */
    13d0:	00009f7e 	andeq	r9, r0, lr, ror pc
	...
	{
		// HSE has not started. Try restarting the processor
		systemHardReset(); 
	}
    /* Set SYSCLK as PLL */
    SET_REG(RCC_CFGR, GET_REG(RCC_CFGR) | 0x00000002);
    13e0:	00010000 	andeq	r0, r1, r0
    13e4:	00000054 	andeq	r0, r0, r4, asr r0
    while ((GET_REG(RCC_CFGR) & 0x00000008) == 0); /* wait for it to come on */
    13e8:	00000000 	andeq	r0, r0, r0
    13ec:	74000300 	strvc	r0, [r0], #-768	; 0x300
	
    pRCC->APB2ENR |= 0B111111100;// Enable All GPIO channels (A to G)
    13f0:	00009f70 	andeq	r9, r0, r0, ror pc
    13f4:	00000000 	andeq	r0, r0, r0
	pRCC->APB1ENR |= RCC_APB1ENR_USB_CLK;
    13f8:	00030000 	andeq	r0, r3, r0
    13fc:	009f6074 	addseq	r6, pc, r4, ror r0	; <UNPREDICTABLE>
    1400:	00000000 	andeq	r0, r0, r0
    1404:	03000000 	movweq	r0, #0

}

void setupLEDAndButton (void) { 
  SET_REG(GPIO_CR(LED_BANK,LED_PIN),(GET_REG(GPIO_CR(LED_BANK,LED_PIN)) & crMask(LED_PIN)) | CR_OUTPUT_PP << CR_SHITF(LED_PIN));
    1408:	9f507400 	svcls	0x00507400
	...
    1414:	00500001 	subseq	r0, r0, r1
    1418:	00000000 	andeq	r0, r0, r0
}

void setupFLASH() {
    /* configure the HSI oscillator */
    if ((pRCC->CR & 0x01) == 0x00) {
    141c:	03000000 	movweq	r0, #0
    1420:	9f507400 	svcls	0x00507400
	...
        rwmVal |= 0x01;
        pRCC->CR = rwmVal;
    }

    /* wait for it to come on */
    while ((pRCC->CR & 0x02) == 0x00) {}
    142c:	00500001 	subseq	r0, r0, r1
    1430:	00000000 	andeq	r0, r0, r0
}   
    1434:	03000000 	movweq	r0, #0
  typedef void (*funcPtr)(void);
  u32 jumpAddr = *(vu32 *)(usrAddr + 0x04); /* reset ptr in vector table */

  funcPtr usrMain = (funcPtr) jumpAddr;

  SET_REG(SCB_VTOR, (vu32) (usrAddr));
    1438:	9f507400 	svcls	0x00507400
	...

  asm volatile("msr msp, %0"::"g"
    1444:	e8910004 	ldm	r1, {r2}
               (*(volatile u32 *)usrAddr));

  usrMain();                                /* go! */
    1448:	00009f7e 	andeq	r9, r0, lr, ror pc
    144c:	00000000 	andeq	r0, r0, r0
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    1450:	00010000 	andeq	r0, r1, r0
    1454:	00000050 	andeq	r0, r0, r0, asr r0
    1458:	00000000 	andeq	r0, r0, r0
    145c:	91000400 	tstls	r0, r0, lsl #8
    tmppre = (0x4 - tmppriority);
    1460:	009f7ee8 	addseq	r7, pc, r8, ror #29
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    1464:	00000000 	andeq	r0, r0, r0


    /* Compute the Corresponding IRQ Priority --------------------------------*/
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;
    1468:	01000000 	mrseq	r0, (UNDEF: 0)

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    146c:	00005200 	andeq	r5, r0, r0, lsl #4
    tmppriority = (0x700 - (rSCB->AIRCR & (u32)0x700)) >> 0x08;
    tmppre = (0x4 - tmppriority);
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;
    1470:	00000000 	andeq	r0, r0, r0

    tmppriority = tmppriority << 0x04;
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1474:	00040000 	andeq	r0, r4, r0
    tmpsub = tmpsub >> tmppriority;

    tmppriority = (u32)NVIC_InitStruct->NVIC_IRQChannelPreemptionPriority << tmppre;
    tmppriority |=  NVIC_InitStruct->NVIC_IRQChannelSubPriority & tmpsub;

    tmppriority = tmppriority << 0x04;
    1478:	9f7ee891 	svcls	0x007ee891
	...
    tmppriority = ((u32)tmppriority) << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);

    tmpreg = rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)];
    tmpmask = (u32)0xFF << ((NVIC_InitStruct->NVIC_IRQChannel & (u8)0x03) * 0x08);
    1484:	e87d0004 	ldmda	sp!, {r2}^
    1488:	00009f7e 	andeq	r9, r0, lr, ror pc
	...
    tmpreg &= ~tmpmask;
    tmppriority &= tmpmask;
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;
    1498:	00040000 	andeq	r0, r4, r0

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    149c:	9f7ea891 	svcls	0x007ea891
	...
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
    14a8:	00520001 	subseq	r0, r2, r1
    tmpreg |= tmppriority;

    rNVIC->IPR[(NVIC_InitStruct->NVIC_IRQChannel >> 0x02)] = tmpreg;

    /* Enable the Selected IRQ Channels --------------------------------------*/
    rNVIC->ISER[(NVIC_InitStruct->NVIC_IRQChannel >> 0x05)] =
    14ac:	00000000 	andeq	r0, r0, r0
    14b0:	04000000 	streq	r0, [r0], #-0
    14b4:	7ea89100 	tanvce	f1, f0
    14b8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
        (u32)0x01 << (NVIC_InitStruct->NVIC_IRQChannel & (u8)0x1F);
}

void nvicDisableInterrupts() {
    NVIC_TypeDef *rNVIC = (NVIC_TypeDef *) NVIC_BASE;
    rNVIC->ICER[0] = 0xFFFFFFFF;
    14bc:	00000000 	andeq	r0, r0, r0
    14c0:	7d000400 	cfstrsvc	mvf0, [r0, #-0]
    14c4:	009f7ea8 	addseq	r7, pc, r8, lsr #29
	...
    rNVIC->ICER[1] = 0xFFFFFFFF;
    rNVIC->ICPR[0] = 0xFFFFFFFF;
    rNVIC->ICPR[1] = 0xFFFFFFFF;

    SET_REG(STK_CTRL, 0x04); /* disable the systick, which operates separately from nvic */
    14d4:	01000000 	mrseq	r0, (UNDEF: 0)
    14d8:	00005200 	andeq	r5, r0, r0, lsl #4
    14dc:	00000000 	andeq	r0, r0, r0

  usrMain();                                /* go! */
}


void jumpToUser(u32 usrAddr) {
    14e0:	00040000 	andeq	r0, r4, r0
    /* tear down all the dfu related setup */
    // disable usb interrupts, clear them, turn off usb, set the disc pin
    // todo pick exactly what we want to do here, now its just a conservative

    //flashLock();
    usbDsbISR();
    14e4:	9f7ea891 	svcls	0x007ea891
	...
#ifndef HAS_MAPLE_HARDWARE	
	usbDsbBus();
#endif
	
// Does nothing, as PC12 is not connected on teh Maple mini according to the schemmatic     setPin(GPIOC, 12); // disconnect usb from host. todo, macroize pin
    systemReset(); // resets clocks and periphs, not core regs
    14f0:	a87d0004 	ldmdage	sp!, {r2}^
    //SET_REG(AFIO_MAPR,(GET_REG(AFIO_MAPR) & ~AFIO_MAPR_SWJ_CFG) | AFIO_MAPR_SWJ_CFG_NO_JTAG_NO_SW);// Try to disable SWD AND JTAG so we can use those pins (not sure if this works).
    setMspAndJump(usrAddr);
    14f4:	00009f7e 	andeq	r9, r0, lr, ror pc
	...

void systemHardReset(void) {
    SCB_TypeDef *rSCB = (SCB_TypeDef *) SCB_BASE;

    /* Reset  */
    rSCB->AIRCR = (u32)AIRCR_RESET_REQ;
    1504:	00010000 	andeq	r0, r1, r0

    /*  should never get here */
    while (1) {
        asm volatile("nop");
    1508:	00000056 	andeq	r0, r0, r6, asr r0
    150c:	00000000 	andeq	r0, r0, r0
    1510:	f3000400 	vshl.u8	d0, d0, d0
    }
}

bool flashErasePage(u32 pageAddr) {
    u32 rwmVal = GET_REG(FLASH_CR);
    1514:	009f5001 	addseq	r5, pc, r1
	...
    rwmVal = FLASH_CR_PER;
    SET_REG(FLASH_CR, rwmVal);

    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1524:	04000000 	streq	r0, [r0], #-0
    1528:	7ee89100 	urdvce	f1, f0
    SET_REG(FLASH_AR, pageAddr);
    SET_REG(FLASH_CR, FLASH_CR_START | FLASH_CR_PER);
    152c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1530:	00000000 	andeq	r0, r0, r0
    1534:	52000100 	andpl	r0, r0, #0, 2
	...

    rwmVal = 0x00;
    SET_REG(FLASH_CR, rwmVal);

    return TRUE;
}
    1540:	e8910004 	ldm	r1, {r2}
    1544:	00009f7e 	andeq	r9, r0, lr, ror pc
    }

    return TRUE;
}

bool flashWriteWord(u32 addr, u32 word) {
    1548:	00000000 	andeq	r0, r0, r0
    vu16 *flashAddr = (vu16 *)addr;
    vu32 lhWord = (vu32)word & 0x0000FFFF;
    154c:	00040000 	andeq	r0, r4, r0
    vu32 hhWord = ((vu32)word & 0xFFFF0000) >> 16;
    1550:	9f7ee87d 	svcls	0x007ee87d
	...
    SET_REG(FLASH_CR, FLASH_CR_PG);

    /* apparently we need not write to FLASH_AR and can
       simply do a native write of a half word */
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    *(flashAddr + 0x01) = (vu16)hhWord;
    1564:	00560001 	subseq	r0, r6, r1
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1568:	00000000 	andeq	r0, r0, r0
    156c:	04000000 	streq	r0, [r0], #-0
    *(flashAddr) = (vu16)lhWord;
    1570:	5001f300 	andpl	pc, r1, r0, lsl #6
    while (GET_REG(FLASH_SR) & FLASH_SR_BSY) {}
    1574:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    1578:	00000000 	andeq	r0, r0, r0

    rwmVal &= 0xFFFFFFFE;
    157c:	001df800 	andseq	pc, sp, r0, lsl #16
    SET_REG(FLASH_CR, rwmVal);

    /* verify the write */
    if (*(vu32 *)addr != word) {
    1580:	001e0400 	andseq	r0, lr, r0, lsl #8
        return FALSE;
    }

    return TRUE;
}
    1584:	50000100 	andpl	r0, r0, r0, lsl #2
    1588:	00001e04 	andeq	r1, r0, r4, lsl #28
    158c:	00001f74 	andeq	r1, r0, r4, ror pc
    1590:	00560001 	subseq	r0, r6, r1

void flashLock() {
    /* take down the HSI oscillator? it may be in use elsewhere */

    /* ensure all FPEC functions disabled and lock the FPEC */
    SET_REG(FLASH_CR, 0x00000080);
    1594:	00000000 	andeq	r0, r0, r0
    1598:	f8000000 			; <UNDEFINED> instruction: 0xf8000000
    159c:	0600001d 			; <UNDEFINED> instruction: 0x0600001d
}

void flashUnlock() {
    /* unlock the flash */
    SET_REG(FLASH_KEYR, FLASH_KEY1);
    15a0:	0100001e 	tsteq	r0, lr, lsl r0
    15a4:	1e065100 	adfnes	f5, f6, f0
    SET_REG(FLASH_KEYR, FLASH_KEY2);
    15a8:	1f740000 	svcne	0x00740000
    15ac:	00010000 	andeq	r0, r1, r0
    15b0:	00000057 	andeq	r0, r0, r7, asr r0
    15b4:	00000000 	andeq	r0, r0, r0

// Used to create the control register masking pattern, when setting control register mode.
unsigned int crMask(int pin)
{
	unsigned int mask;
	if (pin>=8)
    15b8:	001df800 	andseq	pc, sp, r0, lsl #16
	{
		pin-=8;
    15bc:	001e0e00 	andseq	r0, lr, r0, lsl #28
	}
	mask = 0x0F << (pin<<2);
    15c0:	52000100 	andpl	r0, r0, #0, 2
    15c4:	00001e0e 	andeq	r1, r0, lr, lsl #28
	return ~mask;
}	
    15c8:	00001f74 	andeq	r1, r0, r4, ror pc

#define FLASH_SIZE_REG 0x1FFFF7E0
int getFlashEnd(void)
{
	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	return ((int)(*flashSize & 0xffff) * 1024) + 0x08000000;
    15cc:	00590001 	subseq	r0, r9, r1
    15d0:	00000000 	andeq	r0, r0, r0
}
    15d4:	f8000000 			; <UNDEFINED> instruction: 0xf8000000
    15d8:	0c00001d 	stceq	0, cr0, [r0], {29}

int getFlashPageSize(void)
{

	unsigned short *flashSize = (unsigned short *) (FLASH_SIZE_REG);// Address register 
	if ((*flashSize & 0xffff) > 128)
    15dc:	0100001e 	tsteq	r0, lr, lsl r0
	{
		return 0x800;
    15e0:	1e0c5300 	cdpne	3, 0, cr5, cr12, cr0, {0}
	}
	else
	{
		return 0x400;
	}
}
    15e4:	1f740000 	svcne	0x00740000
    15e8:	00010000 	andeq	r0, r1, r0
    15ec:	00000058 	andeq	r0, r0, r8, asr r0
    15f0:	00000000 	andeq	r0, r0, r0

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15f4:	001df800 	andseq	pc, sp, r0, lsl #16
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    15f8:	001f1000 	andseq	r1, pc, r0

volatile PLOT code_copy_lock;

/* todo: force dfu globals to be singleton to avoid re-inits? */
void dfuInit(void) {
    dfuAppStatus.bStatus = OK;
    15fc:	31000200 	mrscc	r0, R8_usr
    dfuAppStatus.bwPollTimeout0 = 0x00;
    dfuAppStatus.bwPollTimeout1 = 0x00;
    1600:	001f109f 	mulseq	pc, pc, r0	; <UNPREDICTABLE>
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    1604:	001f3000 	andseq	r3, pc, r0
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    1608:	75000500 	strvc	r0, [r0, #-1280]	; 0x500
    160c:	9f1a3100 	svcls	0x001a3100
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    userAppEnd = RAM_END;
    userUploadType=DFU_UPLOAD_NONE;
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    1610:	00001f30 	andeq	r1, r0, r0, lsr pc
    dfuAppStatus.bwPollTimeout2 = 0x00;
    dfuAppStatus.bState = dfuIDLE;
    dfuAppStatus.iString = 0x00;          /* all strings must be 0x00 until we make them! */
    userFirmwareLen = 0;
    thisBlockLen = 0;;
    userAppAddr = USER_CODE_RAM; /* default RAM user code location */
    1614:	00001f64 	andeq	r1, r0, r4, ror #30
    userAppEnd = RAM_END;
    1618:	00750008 	rsbseq	r0, r5, r8
    161c:	311a0074 	tstcc	sl, r4, ror r0
    userUploadType=DFU_UPLOAD_NONE;
    1620:	1f649f1a 	svcne	0x00649f1a
    1624:	1f740000 	svcne	0x00740000
    code_copy_lock = WAIT;
    1628:	00020000 	andeq	r0, r2, r0
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    162c:	00009f31 	andeq	r9, r0, r1, lsr pc
    1630:	00000000 	andeq	r0, r0, r0
    1634:	1e0a0000 	cdpne	0, 0, cr0, cr10, cr0, {0}
    memset(input, 0xFF, sizeof(input));
    1638:	1e0c0000 	cdpne	0, 0, cr0, cr12, cr0, {0}
    163c:	00010000 	andeq	r0, r1, r0

    sha256_starts(&ctx);
}
    1640:	001e0c53 	andseq	r0, lr, r3, asr ip
    code_copy_lock = WAIT;
    dfuBusy = FALSE;
    memset(sha256sum, 0xFF, sizeof(sha256sum));
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
    1644:	001f7400 	andseq	r7, pc, r0, lsl #8
    1648:	58000100 	stmdapl	r0, {r8}
	...
    1654:	00001e0a 	andeq	r1, r0, sl, lsl #28
    1658:	00001e0e 	andeq	r1, r0, lr, lsl #28
    165c:	0e520001 	cdpeq	0, 5, cr0, cr2, cr1, {0}
    1660:	7400001e 	strvc	r0, [r0], #-30
    1664:	0100001f 	tsteq	r0, pc, lsl r0
    1668:	00005900 	andeq	r5, r0, r0, lsl #18
    166c:	00000000 	andeq	r0, r0, r0
    1670:	1e020000 	cdpne	0, 0, cr0, cr2, cr0, {0}
    1674:	1e060000 	cdpne	0, 0, cr0, cr6, cr0, {0}
    1678:	00010000 	andeq	r0, r1, r0
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}

void dfuUpdateByReset(void) {
    167c:	001e0651 	andseq	r0, lr, r1, asr r6
    u8 startState = dfuAppStatus.bState;
    userFirmwareLen = 0;
    1680:	001f7400 	andseq	r7, pc, r0, lsl #8
    1684:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...

    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
    1690:	00001e02 	andeq	r1, r0, r2, lsl #28
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
    1694:	00001e04 	andeq	r1, r0, r4, lsl #28
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    1698:	04500001 	ldrbeq	r0, [r0], #-1
    if (startState == appDETACH) {
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        nvicDisableInterrupts();
        usbEnbISR();
    169c:	7400001e 	strvc	r0, [r0], #-30
    } else if (startState == appIDLE || startState == dfuIDLE) {
    16a0:	0100001f 	tsteq	r0, pc, lsl r0
    16a4:	00005600 	andeq	r5, r0, r0, lsl #12
        /* do nothing...might be normal usb bus activity */
    } else {
        /* we reset from the dfu, reset everything and startover,
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
    16a8:	00000000 	andeq	r0, r0, r0
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    }
}
    16ac:	1e020000 	cdpne	0, 0, cr0, cr2, cr0, {0}
           which is the correct operation if this is an erroneous
           event or properly following a MANIFEST */
        dfuAppStatus.bState = dfuIDLE;
        dfuAppStatus.bStatus = OK;

        systemHardReset();
    16b0:	1ed20000 	cdpne	0, 13, cr0, cr2, cr0, {0}
    16b4:	00040000 	andeq	r0, r4, r0
    16b8:	9f7d8091 	svcls	0x007d8091
    16bc:	00001ed2 	ldrdeq	r1, [r0], -r2

void dfuUpdateByTimeout(void) {
}

u8 *dfuCopyState(u16 length) {
    if (length == 0) {
    16c0:	00001ed9 	ldrdeq	r1, [r0], -r9
        pInformation->Ctrl_Info.Usb_wLength = 1;
    16c4:	d9500001 	ldmdble	r0, {r0}^
    16c8:	1600001e 			; <UNDEFINED> instruction: 0x1600001e
        return NULL;
    } else {
        return (u8 *)(&(dfuAppStatus.bState));
    16cc:	0400001f 	streq	r0, [r0], #-31
    }
}
    16d0:	7d809100 	stfvcd	f1, [r0]
    16d4:	001f169f 	mulseq	pc, pc, r6	; <UNPREDICTABLE>

u8 *dfuCopyStatus(u16 length) {
    if (length == 0) {
    16d8:	001f1900 	andseq	r1, pc, r0, lsl #18
        pInformation->Ctrl_Info.Usb_wLength = 6;
    16dc:	52000100 	andpl	r0, r0, #0, 2
    16e0:	00001f19 	andeq	r1, r0, r9, lsl pc
        return NULL;
    } else {
        return (u8*)(&dfuAppStatus);
    16e4:	00001f74 	andeq	r1, r0, r4, ror pc
    }
}
    16e8:	80910004 	addshi	r0, r1, r4
    16ec:	00009f7d 	andeq	r9, r0, sp, ror pc


u8 *dfuCopyDNLOAD(u16 length) {
    16f0:	00000000 	andeq	r0, r0, r0
    if (length == 0) {
    16f4:	1e3c0000 	cdpne	0, 3, cr0, cr12, cr0, {0}
        pInformation->Ctrl_Info.Usb_wLength = pInformation->USBwLengths.w - pInformation->Ctrl_Info.Usb_wOffset;
    16f8:	1e780000 	cdpne	0, 7, cr0, cr8, cr0, {0}
    16fc:	00040000 	andeq	r0, r4, r0
        thisBlockLen = pInformation->USBwLengths.w;
    1700:	9f7ee091 	svcls	0x007ee091
        return NULL;
    } else {
        return ((u8 *)recvBuffer + pInformation->Ctrl_Info.Usb_wOffset);
    1704:	00001e78 	andeq	r1, r0, r8, ror lr
    1708:	00001e7b 	andeq	r1, r0, fp, ror lr
    }
}
    170c:	7b510001 	blvc	1441718 <_etext+0x143a104>
    1710:	ba00001e 	blt	1790 <dfuCopyBufferToExec+0x44>
    1714:	0400001e 	streq	r0, [r0], #-30

u8 *dfuCopyUPLOAD(u16 length) {
    1718:	7ee09100 	urdvcs	f1, f0
    if (length == 0) {
        pInformation->Ctrl_Info.Usb_wLength = thisBlockLen - pInformation->Ctrl_Info.Usb_wOffset;
    171c:	001eba9f 	mulseq	lr, pc, sl	; <UNPREDICTABLE>
    1720:	001ec100 	andseq	ip, lr, r0, lsl #2
    1724:	51000100 	mrspl	r0, (UNDEF: 16)
        return NULL;
    1728:	00001ec1 	andeq	r1, r0, r1, asr #29
    } else {
        return((u8*) userAppAddr + userFirmwareLen + pInformation->Ctrl_Info.Usb_wOffset);
    172c:	00001ec6 	andeq	r1, r0, r6, asr #29
    1730:	e0910004 	adds	r0, r1, r4
    1734:	1ec69f7e 	mcrne	15, 6, r9, cr6, cr14, {3}
    1738:	1ecd0000 	cdpne	0, 12, cr0, cr13, cr0, {0}
    }
}
    173c:	00010000 	andeq	r0, r1, r0
    1740:	001ecd51 	andseq	ip, lr, r1, asr sp
    1744:	001ed400 	andseq	sp, lr, r0, lsl #8
    1748:	91000400 	tstls	r0, r0, lsl #8

void dfuCopyBufferToExec() {
    174c:	d49f7ee0 	ldrle	r7, [pc], #3808	; 1754 <dfuCopyBufferToExec+0x8>
        }
    } 
	else 
*/
	
	if (userUploadType == DFU_UPLOAD_FLASH_0X8008000) {
    1750:	d900001e 	stmdble	r0, {r1, r2, r3, r4}
		userSpace = (u32 *)(USER_CODE_FLASH0X8008000 + userFirmwareLen);
    1754:	0100001e 	tsteq	r0, lr, lsl r0
    1758:	1ed95100 	cdpne	1, 13, cr5, cr9, cr0, {0}
    175c:	1edc0000 	cdpne	0, 13, cr0, cr12, cr0, {0}
    1760:	00040000 	andeq	r0, r4, r0
	}
	else {
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
    1764:	9f7ee091 	svcls	0x007ee091
	}

    flashErasePage((u32)(userSpace));
    1768:	00001edc 	ldrdeq	r1, [r0], -ip

    for (i = 0; i < thisBlockLen; i = i + 4) {
    176c:	00001ee5 	andeq	r1, r0, r5, ror #29
    1770:	e5500001 	ldrb	r0, [r0, #-1]
    1774:	ec00001e 	stc	0, cr0, [r0], {30}
        /*if ((u32)(userSpace) >= 0x8008074)
        {
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    1778:	0400001e 	streq	r0, [r0], #-30
    177c:	7ee09100 	urdvcs	f1, f0
    1780:	001eec9f 	mulseq	lr, pc, ip	; <UNPREDICTABLE>
		userSpace = (u32 *)(USER_CODE_FLASH0X8002000 + userFirmwareLen);		
	}

    flashErasePage((u32)(userSpace));

    for (i = 0; i < thisBlockLen; i = i + 4) {
    1784:	001eef00 	andseq	lr, lr, r0, lsl #30
            sha256_update(&ctx, recvBuffer +i, sizeof(u32));
        }*/
        flashWriteWord((u32)(userSpace++), *(u32 *)(recvBuffer +i));
    }
    
    userFirmwareLen += thisBlockLen;
    1788:	52000100 	andpl	r0, r0, #0, 2
    178c:	00001eef 	andeq	r1, r0, pc, ror #29
    thisBlockLen = 0;
    1790:	00001efc 	strdeq	r1, [r0], -ip
    1794:	e0910004 	adds	r0, r1, r4
    1798:	1efc9f7e 	mrcne	15, 7, r9, cr12, cr14, {3}
    179c:	1f030000 	svcne	0x00030000
    17a0:	00010000 	andeq	r0, r1, r0
    17a4:	001f0351 	andseq	r0, pc, r1, asr r3	; <UNPREDICTABLE>
    memset(input, 0xFF, sizeof(input));

    sha256_starts(&ctx);
}

bool dfuUpdateByRequest(void) {
    17a8:	001f0a00 	andseq	r0, pc, r0, lsl #20
    /* were using the global pInformation struct from usb_lib here,
       see comment in maple_dfu.h around DFUEvent struct */
    dfuBusy = TRUE;
    17ac:	91000400 	tstls	r0, r0, lsl #8
    17b0:	0a9f7ee0 	beq	fe7e1338 <BootRAM+0xd751ad9>

    u8 startState = dfuAppStatus.bState;
    17b4:	0f00001f 	svceq	0x0000001f
    17b8:	0100001f 	tsteq	r0, pc, lsl r0
    dfuAppStatus.bStatus = OK;
    17bc:	1f0f5200 	svcne	0x000f5200
    
    /* often leaner to nest if's then embed a switch/case */
    /* but who the fuck cares? use a better compiler. we have space */
    if (startState == dfuIDLE)  {
        /*  device running inside DFU mode */
        dfuBusy = TRUE; // signals the main loop to defer to the dfu write-loop
    17c0:	1f2c0000 	svcne	0x002c0000

        if (pInformation->USBbRequest == DFU_DNLOAD) {
    17c4:	00040000 	andeq	r0, r4, r0
    17c8:	9f7ee091 	svcls	0x007ee091
            if (pInformation->USBwLengths.w > 0) {
    17cc:	00001f2c 	andeq	r1, r0, ip, lsr #30
    17d0:	00001f2f 	andeq	r1, r0, pc, lsr #30
                userFirmwareLen = 0;
    17d4:	2f500001 	svccs	0x00500001
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
				switch(pInformation->Current_AlternateSetting) {
    17d8:	3600001f 			; <UNDEFINED> instruction: 0x3600001f
    17dc:	0400001f 	streq	r0, [r0], #-31
    17e0:	7ee09100 	urdvcs	f1, f0
    17e4:	001f369f 	mulseq	pc, pc, r6	; <UNPREDICTABLE>
						//flashErasePage((u32)USER_CODE_FLASH0X8002000);

						break;

					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
    17e8:	001f3900 	andseq	r3, pc, r0, lsl #18
						userAppAddr = USER_CODE_FLASH0X8002000;
    17ec:	52000100 	andpl	r0, r0, #0, 2
    17f0:	00001f39 	andeq	r1, r0, r9, lsr pc
						userUploadType = DFU_UPLOAD_RAM;
						break;
						*/

					case 1:
					    userAppAddr = USER_CODE_FLASH0X8008000;
    17f4:	00001f74 	andeq	r1, r0, r4, ror pc
    17f8:	e0910004 	adds	r0, r1, r4
						userUploadType = DFU_UPLOAD_FLASH_0X8008000;
    17fc:	00009f7e 	andeq	r9, r0, lr, ror pc
					case 2:
						userUploadType = DFU_UPLOAD_FLASH_0X8002000;
						userAppAddr = USER_CODE_FLASH0X8002000;
						
                        /* make sure the flash is setup properly, unlock it */
                        setupFLASH();
    1800:	00000000 	andeq	r0, r0, r0
						flashUnlock();
    1804:	1e3c0000 	cdpne	0, 3, cr0, cr12, cr0, {0}

						break;
    1808:	1ed20000 	cdpne	0, 13, cr0, cr2, cr0, {0}

					default:
					    // Roger Clark. Report error 
						dfuAppStatus.bState  = dfuERROR;
    180c:	00040000 	andeq	r0, r4, r0
				}
            } else {
                dfuAppStatus.bState  = dfuERROR;
                dfuAppStatus.bStatus = errNOTDONE;
            }
        } else if (pInformation->USBbRequest == DFU_UPLOAD) {
    1810:	9f7d8091 	svcls	0x007d8091
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1814:	00001ed2 	ldrdeq	r1, [r0], -r2
            
            /* record length of first block for calculating target
               address from wValue in consecutive blocks */
            uploadBlockLen = pInformation->USBwLengths.w;
    1818:	00001ed9 	ldrdeq	r1, [r0], -r9
    181c:	d9500001 	ldmdble	r0, {r0}^
            thisBlockLen = uploadBlockLen; /* for this first block as well */
    1820:	1600001e 			; <UNDEFINED> instruction: 0x1600001e
    1824:	0400001f 	streq	r0, [r0], #-31
            
            /* calculate where the data should be copied from */
            userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    1828:	7d809100 	stfvcd	f1, [r0]
    182c:	001f169f 	mulseq	pc, pc, r6	; <UNPREDICTABLE>
    1830:	001f1900 	andseq	r1, pc, r0, lsl #18
			
            switch(pInformation->Current_AlternateSetting) {
    1834:	52000100 	andpl	r0, r0, #0, 2
    1838:	00001f19 	andeq	r1, r0, r9, lsl pc
				    userAppAddr = USER_CODE_FLASH0X8008000;
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    183c:	00001f74 	andeq	r1, r0, r4, ror pc
					userAppAddr = USER_CODE_RAM;
					userAppEnd = RAM_END;
					*/

				case 1:
				    userAppAddr = USER_CODE_FLASH0X8008000;
    1840:	80910004 	addshi	r0, r1, r4
					userAppEnd = getFlashEnd();
					break;

				case 2: 
				    userAppAddr = USER_CODE_FLASH0X8002000;
    1844:	00009f7d 	andeq	r9, r0, sp, ror pc
					userAppEnd = getFlashEnd();
    1848:	00000000 	andeq	r0, r0, r0
    184c:	1e3c0000 	cdpne	0, 3, cr0, cr12, cr0, {0}

				default:
				// Roger Clark. 
				// Changed this to report error that its unable to write to this memory
				// However the code should never get here as only AlternateSetting 1 and 2 are allowed (see above)
					dfuAppStatus.bState  = dfuERROR;
    1850:	1e400000 	cdpne	0, 4, cr0, cr0, cr0, {0}
					dfuAppStatus.bStatus = errWRITE;
    1854:	00010000 	andeq	r0, r1, r0
					break;					
			}
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    1858:	001e4054 	andseq	r4, lr, r4, asr r0
            dfuAppStatus.bState  = dfuIDLE;
            dfuAppStatus.bStatus = OK;  /* are we really ok? we were just aborted */
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    185c:	001e4400 	andseq	r4, lr, r0, lsl #8
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1860:	74000300 	strvc	r0, [r0], #-768	; 0x300
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuDNLOAD_SYNC)         {
    1864:	1e449f70 	mcrne	15, 2, r9, cr4, cr0, {3}
        /* device received block, waiting for DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    1868:	1e480000 	cdpne	0, 4, cr0, cr8, cr0, {0}
    186c:	00030000 	andeq	r0, r3, r0
    1870:	489f6074 	ldmmi	pc, {r2, r4, r5, r6, sp, lr}	; <UNPREDICTABLE>

            } 
			else 
			*/
			{
                dfuAppStatus.bState = dfuDNLOAD_IDLE;
    1874:	5800001e 	stmdapl	r0, {r1, r2, r3, r4}
                dfuCopyBufferToExec();
    1878:	0300001e 	movweq	r0, #30
            }

        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    187c:	9f507400 	svcls	0x00507400
            dfuAppStatus.bState  = dfuDNLOAD_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuDNBUSY)              {
    1880:	00001e58 	andeq	r1, r0, r8, asr lr
        /* if were actually done writing, goto sync, else stay busy */
        if (code_copy_lock == END) {
    1884:	00001e76 	andeq	r1, r0, r6, ror lr
    1888:	e0910004 	adds	r0, r1, r4

            dfuAppStatus.bwPollTimeout0 = 0x00;
            code_copy_lock = WAIT;
    188c:	1e769f7d 	mrcne	15, 3, r9, cr6, cr13, {3}
    1890:	1e7b0000 	cdpne	0, 7, cr0, cr11, cr0, {0}
            dfuAppStatus.bState = dfuDNLOAD_IDLE;
    1894:	00010000 	andeq	r0, r1, r0
        } else {
            dfuAppStatus.bState = dfuDNBUSY;
        }
    } else if (startState == dfuDNLOAD_IDLE)         {
    1898:	001e7b50 	andseq	r7, lr, r0, asr fp
        /* device is expecting dfu_dnload requests */
        if (pInformation->USBbRequest == DFU_DNLOAD) {
    189c:	001e9000 	andseq	r9, lr, r0
    18a0:	91000400 	tstls	r0, r0, lsl #8
    18a4:	909f7de0 	addsls	r7, pc, r0, ror #27
            if (pInformation->USBwLengths.w > 0) {
    18a8:	9700001e 	smladls	r0, lr, r0, r0
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
    18ac:	0100001e 	tsteq	r0, lr, lsl r0
                }*/
                ImageObjectHandle imageHandle;
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    18b0:	1e975000 	cdpne	0, 9, cr5, cr7, cr0, {0}
        if (pInformation->USBbRequest == DFU_DNLOAD) {
            if (pInformation->USBwLengths.w > 0) {
                dfuAppStatus.bState  = dfuDNLOAD_SYNC;
            } else {
                /* todo, support "disagreement" if device expects more data than this */
                dfuAppStatus.bState  = dfuMANIFEST_SYNC;
    18b4:	1ea60000 	cdpne	0, 10, cr0, cr6, cr0, {0}
                }*/
                ImageObjectHandle imageHandle;
                int ret;
                if (DEBUG)
                {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
    18b8:	00040000 	andeq	r0, r4, r0
                } else {
                    ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 1);
                }
                switch (ret)
    18bc:	9f7de091 	svcls	0x007de091
    18c0:	00001ea6 	andeq	r1, r0, r6, lsr #29
    18c4:	00001ea9 	andeq	r1, r0, r9, lsr #29
                {
                    case kImageImageIsTrusted:
                        uart_printf("Uploaded signature verified!\n");
    18c8:	a9500001 	ldmdbge	r0, {r0}^
                        break;

                    case kImageImageMissingMagic:
                    case kImageImageRejectSignature:
                        uart_printf("Image unverified... wiped memory for clean reset.\n");
    18cc:	b800001e 	stmdalt	r0, {r1, r2, r3, r4}
    18d0:	0400001e 	streq	r0, [r0], #-30
                        break;

                    default:
                        break;
                }
                flashLock();
    18d4:	7de09100 	stfvcp	f1, [r0]
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    18d8:	001eb89f 	mulseq	lr, pc, r8	; <UNPREDICTABLE>
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18dc:	001ec100 	andseq	ip, lr, r0, lsl #2
            dfuAppStatus.bState  = dfuIDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18e0:	50000100 	andpl	r0, r0, r0, lsl #2
    18e4:	00001ec1 	andeq	r1, r0, r1, asr #29
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }

    } else if (startState == dfuMANIFEST_SYNC) {
    18e8:	00001ec2 	andeq	r1, r0, r2, asr #29
        /* device has received last block, waiting DFU_GETSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    18ec:	50740003 	rsbspl	r0, r4, r3
    18f0:	001ec29f 	mulseq	lr, pc, r2	; <UNPREDICTABLE>
            dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    18f4:	001ec400 	andseq	ip, lr, r0, lsl #8
            dfuAppStatus.bStatus = OK;
    18f8:	91000400 	tstls	r0, r0, lsl #8
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    18fc:	c49f7de0 	ldrgt	r7, [pc], #3552	; 1904 <dfuUpdateByRequest+0x15c>
    1900:	cd00001e 	stcgt	0, cr0, [r0, #-120]	; 0xffffff88
            dfuAppStatus.bState  = dfuMANIFEST_SYNC;
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuMANIFEST) {
    1904:	0100001e 	tsteq	r0, lr, lsl r0
        /* device is in manifestation phase */

        /* should never receive request while in manifest! */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
        dfuAppStatus.bStatus = OK;
    } else if (startState == dfuMANIFEST_WAIT_RESET) {
    1908:	1ecd5000 	cdpne	0, 12, cr5, cr13, cr0, {0}
        /* device has programmed new firmware but needs external
           usb reset or power on reset to run the new code */

        /* consider timing out and self-resetting */
        dfuAppStatus.bState  = dfuMANIFEST_WAIT_RESET;
    } else if (startState == dfuUPLOAD_IDLE) {
    190c:	1eea0000 	cdpne	0, 14, cr0, cr10, cr0, {0}
        /* device expecting further dfu_upload requests */
        if (pInformation->USBbRequest == DFU_UPLOAD) {
    1910:	00040000 	andeq	r0, r4, r0
    1914:	9f7de091 	svcls	0x007de091
            if (pInformation->USBwLengths.w > 0) {
    1918:	00001eea 	andeq	r1, r0, sl, ror #29
                /* check that this is not the last possible block */
                userFirmwareLen = uploadBlockLen * pInformation->USBwValue;
    191c:	00001eef 	andeq	r1, r0, pc, ror #29
    1920:	ef510001 	svc	0x00510001
    1924:	f600001e 			; <UNDEFINED> instruction: 0xf600001e
    1928:	0400001e 	streq	r0, [r0], #-30
    192c:	7de09100 	stfvcp	f1, [r0]
                if (userAppAddr + userFirmwareLen + uploadBlockLen <= userAppEnd) {
    1930:	001ef69f 	mulseq	lr, pc, r6	; <UNPREDICTABLE>
    1934:	001ef900 	andseq	pc, lr, r0, lsl #18
    1938:	52000100 	andpl	r0, r0, #0, 2
    193c:	00001ef9 	strdeq	r1, [r0], -r9
    1940:	00001f0c 	andeq	r1, r0, ip, lsl #30
    1944:	e0910004 	adds	r0, r1, r4
                    thisBlockLen = uploadBlockLen;
    1948:	1f0c9f7d 	svcne	0x000c9f7d
    194c:	1f0f0000 	svcne	0x000f0000
                    dfuAppStatus.bState  = dfuUPLOAD_IDLE;
                } else {
                    /* if above comparison was just equal, thisBlockLen becomes zero
                    next time when USBWValue has been increased by one */
                    thisBlockLen = userAppEnd - userAppAddr - userFirmwareLen;
    1950:	00010000 	andeq	r0, r1, r0
    1954:	001f0f50 	andseq	r0, pc, r0, asr pc	; <UNPREDICTABLE>
    1958:	001f1200 	andseq	r1, pc, r0, lsl #4
    195c:	91000400 	tstls	r0, r0, lsl #8
                    
                    /* check for overflow due to USBwValue out of range */
                    if (thisBlockLen >= pInformation->USBwLengths.w) {
    1960:	129f7de0 	addsne	r7, pc, #224, 26	; 0x3800
    1964:	1900001f 	stmdbne	r0, {r0, r1, r2, r3, r4}
                        thisBlockLen = 0;
    1968:	0100001f 	tsteq	r0, pc, lsl r0
                    }
                    
                    dfuAppStatus.bState  = dfuIDLE;
                }
            } else {
                dfuAppStatus.bState  = dfuERROR;
    196c:	1f195000 	svcne	0x00195000
                dfuAppStatus.bStatus = errNOTDONE;
    1970:	1f320000 	svcne	0x00320000
            }
        } else if (pInformation->USBbRequest == DFU_ABORT) {
    1974:	00040000 	andeq	r0, r4, r0
            dfuAppStatus.bState  = dfuIDLE;
    1978:	9f7de091 	svcls	0x007de091
        } else if (pInformation->USBbRequest == DFU_GETSTATUS) {
    197c:	00001f32 	andeq	r1, r0, r2, lsr pc
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    1980:	00001f39 	andeq	r1, r0, r9, lsr pc
            dfuAppStatus.bState  = dfuUPLOAD_IDLE;
    1984:	39500001 	ldmdbcc	r0, {r0}^
        } else {
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else if (startState == dfuERROR)               {
    1988:	4000001f 	andmi	r0, r0, pc, lsl r0
        /* status is in error, awaiting DFU_CLRSTATUS request */
        if (pInformation->USBbRequest == DFU_GETSTATUS) {
    198c:	0400001f 	streq	r0, [r0], #-31
    1990:	7de09100 	stfvcp	f1, [r0]
    1994:	001f409f 	mulseq	pc, pc, r0	; <UNPREDICTABLE>
            /* todo, add routine to wait for last block write to finish */
            dfuAppStatus.bState  = dfuERROR;
    1998:	001f4300 	andseq	r4, pc, r0, lsl #6
        } else if (pInformation->USBbRequest == DFU_GETSTATE) {
    199c:	52000100 	andpl	r0, r0, #0, 2
            dfuAppStatus.bState  = dfuERROR;
        } else if (pInformation->USBbRequest == DFU_CLRSTATUS) {
    19a0:	00001f43 	andeq	r1, r0, r3, asr #30
            /* todo handle any cleanup we need here */
            dfuAppStatus.bState  = dfuIDLE;
    19a4:	00001f74 	andeq	r1, r0, r4, ror pc
            dfuAppStatus.bStatus = OK;
    19a8:	e0910004 	adds	r0, r1, r4
            dfuAppStatus.bState  = dfuERROR;
            dfuAppStatus.bStatus = errSTALLEDPKT;
        }
    } else {
        /* some kind of error... */
        dfuAppStatus.bState  = dfuERROR;
    19ac:	00009f7d 	andeq	r9, r0, sp, ror pc
        dfuAppStatus.bStatus = errSTALLEDPKT;
    19b0:	00000000 	andeq	r0, r0, r0
    }

    return (dfuAppStatus.bStatus == OK) ? TRUE : FALSE;
}
    19b4:	1e7c0000 	cdpne	0, 7, cr0, cr12, cr0, {0}
    19b8:	1e880000 	cdpne	0, 8, cr0, cr8, cr0, {0}
    19bc:	00030000 	andeq	r0, r3, r0
    19c0:	889f4008 	ldmhi	pc, {r3, lr}	; <UNPREDICTABLE>
    19c4:	8c00001e 	stchi	0, cr0, [r0], {30}
    19c8:	0100001e 	tsteq	r0, lr, lsl r0
    19cc:	1e8c5400 	cdpne	4, 8, cr5, cr12, cr0, {0}
    19d0:	1e8e0000 	cdpne	0, 8, cr0, cr14, cr0, {0}
    19d4:	00010000 	andeq	r0, r1, r0
    19d8:	001e9851 	andseq	r9, lr, r1, asr r8
    19dc:	001e9c00 	andseq	r9, lr, r0, lsl #24
    19e0:	54000100 	strpl	r0, [r0], #-256	; 0x100
    19e4:	00001f64 	andeq	r1, r0, r4, ror #30
    19e8:	00001f74 	andeq	r1, r0, r4, ror pc
    19ec:	40080003 	andmi	r0, r8, r3
    19f0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    19f4:	00000000 	andeq	r0, r0, r0
    19f8:	001eda00 	andseq	sp, lr, r0, lsl #20
    dfuAppStatus.bState = newState;
}

bool dfuUploadStarted()
{
    return dfuBusy;
    19fc:	001ee000 	andseq	lr, lr, r0
}
    1a00:	76000300 	strvc	r0, [r0], -r0, lsl #6
    1a04:	1ee09f20 	cdpne	15, 14, cr9, cr0, cr0, {1}

void dfuFinishUpload() {

    while (1)
	{
		__asm__ __volatile__ ("");
    1a08:	1ee50000 	cdpne	0, 14, cr0, cr5, cr0, {0}
};

/* Conversion to and from projective coordinates */
void ed25519_project(struct ed25519_pt *p,
		     const uint8_t *x, const uint8_t *y)
{
    1a0c:	00010000 	andeq	r0, r1, r0
    1a10:	001ee552 	andseq	lr, lr, r2, asr r5
    1a14:	001f6400 	andseq	r6, pc, r0, lsl #8
    1a18:	76000300 	strvc	r0, [r0], -r0, lsl #6
    1a1c:	00009f20 	andeq	r9, r0, r0, lsr #30
    1a20:	00000000 	andeq	r0, r0, r0
    1a24:	1eda0000 	cdpne	0, 13, cr0, cr10, cr0, {0}
    1a28:	1f600000 	svcne	0x00600000
    1a2c:	00010000 	andeq	r0, r1, r0
    1a30:	001f605d 	andseq	r6, pc, sp, asr r0	; <UNPREDICTABLE>
    1a34:	001f6400 	andseq	r6, pc, r0, lsl #8
    1a38:	91000400 	tstls	r0, r0, lsl #8
    1a3c:	009f7cc0 	addseq	r7, pc, r0, asr #25
    1a40:	00000000 	andeq	r0, r0, r0
    1a44:	e6000000 	str	r0, [r0], -r0
    1a48:	ec00001e 	stc	0, cr0, [r0], {30}
    1a4c:	0400001e 	streq	r0, [r0], #-30
    1a50:	7ee09100 	urdvcs	f1, f0
    1a54:	001eec9f 	mulseq	lr, pc, ip	; <UNPREDICTABLE>
    1a58:	001eef00 	andseq	lr, lr, r0, lsl #30
    1a5c:	52000100 	andpl	r0, r0, #0, 2
    1a60:	00001eef 	andeq	r1, r0, pc, ror #29
    1a64:	00001efc 	strdeq	r1, [r0], -ip
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
    1a68:	e0910004 	adds	r0, r1, r4
	f25519_mul__distinct(p->t, x, y);
    1a6c:	1efc9f7e 	mrcne	15, 7, r9, cr12, cr14, {3}
    1a70:	1f030000 	svcne	0x00030000
}
    1a74:	00010000 	andeq	r0, r1, r0
		     const uint8_t *x, const uint8_t *y)
{
	f25519_copy(p->x, x);
	f25519_copy(p->y, y);
	f25519_load(p->z, 1);
	f25519_mul__distinct(p->t, x, y);
    1a78:	001f0351 	andseq	r0, pc, r1, asr r3	; <UNPREDICTABLE>
}

void ed25519_unproject(uint8_t *x, uint8_t *y,
		       const struct ed25519_pt *p)
{
    1a7c:	001f0a00 	andseq	r0, pc, r0, lsl #20
    1a80:	91000400 	tstls	r0, r0, lsl #8
    1a84:	0a9f7ee0 	beq	fe7e160c <BootRAM+0xd751dad>
	uint8_t z1[F25519_SIZE];

	f25519_inv__distinct(z1, p->z);
    1a88:	0f00001f 	svceq	0x0000001f
    1a8c:	0100001f 	tsteq	r0, pc, lsl r0
	f25519_mul__distinct(x, p->x, z1);
    1a90:	1f0f5200 	svcne	0x000f5200
    1a94:	1f2c0000 	svcne	0x002c0000
    1a98:	00040000 	andeq	r0, r4, r0
	f25519_mul__distinct(y, p->y, z1);
    1a9c:	9f7ee091 	svcls	0x007ee091
    1aa0:	00001f2c 	andeq	r1, r0, ip, lsr #30
    1aa4:	00001f2f 	andeq	r1, r0, pc, lsr #30

	f25519_normalize(x);
    1aa8:	2f500001 	svccs	0x00500001
	f25519_normalize(y);
    1aac:	3600001f 			; <UNDEFINED> instruction: 0x3600001f
    1ab0:	0400001f 	streq	r0, [r0], #-31
}
    1ab4:	7ee09100 	urdvcs	f1, f0
	0x98, 0xe8, 0x79, 0x77, 0x79, 0x40, 0xc7, 0x8c,
	0x73, 0xfe, 0x6f, 0x2b, 0xee, 0x6c, 0x03, 0x52
};

void ed25519_pack(uint8_t *c, const uint8_t *x, const uint8_t *y)
{
    1ab8:	001f369f 	mulseq	pc, pc, r6	; <UNPREDICTABLE>
    1abc:	001f3900 	andseq	r3, pc, r0, lsl #18
    1ac0:	52000100 	andpl	r0, r0, #0, 2
    1ac4:	00001f39 	andeq	r1, r0, r9, lsr pc
    1ac8:	00001f64 	andeq	r1, r0, r4, ror #30
    1acc:	e0910004 	adds	r0, r1, r4
    1ad0:	00009f7e 	andeq	r9, r0, lr, ror pc
    1ad4:	00000000 	andeq	r0, r0, r0
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
    1ad8:	1ee60000 	cdpne	0, 14, cr0, cr6, cr0, {0}
    1adc:	1f600000 	svcne	0x00600000
    1ae0:	00010000 	andeq	r0, r1, r0
    1ae4:	001f605d 	andseq	r6, pc, sp, asr r0	; <UNPREDICTABLE>
    1ae8:	001f6400 	andseq	r6, pc, r0, lsl #8
    1aec:	91000400 	tstls	r0, r0, lsl #8
    1af0:	009f7cc0 	addseq	r7, pc, r0, asr #25
    1af4:	00000000 	andeq	r0, r0, r0
    1af8:	fa000000 	blx	1b00 <ed25519_pack+0x48>
    1afc:	6400001e 	strvs	r0, [r0], #-30
	parity = (tmp[0] & 1) << 7;
    1b00:	0100001f 	tsteq	r0, pc, lsl r0

	f25519_copy(c, y);
	f25519_normalize(c);
    1b04:	00005700 	andeq	r5, r0, r0, lsl #14
	uint8_t tmp[F25519_SIZE];
	uint8_t parity;

	f25519_copy(tmp, x);
	f25519_normalize(tmp);
	parity = (tmp[0] & 1) << 7;
    1b08:	00000000 	andeq	r0, r0, r0
    1b0c:	1efa0000 	cdpne	0, 15, cr0, cr10, cr0, {0}

	f25519_copy(c, y);
	f25519_normalize(c);
	c[31] |= parity;
    1b10:	1f0c0000 	svcne	0x000c0000
}
    1b14:	00040000 	andeq	r0, r4, r0

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b18:	9f7de091 	svcls	0x007de091
    1b1c:	00001f0c 	andeq	r1, r0, ip, lsl #30
    1b20:	00001f0f 	andeq	r1, r0, pc, lsl #30
    1b24:	0f500001 	svceq	0x00500001
	const int parity = comp[31] >> 7;
    1b28:	1200001f 	andne	r0, r0, #31
    1b2c:	0400001f 	streq	r0, [r0], #-31
    1b30:	7de09100 	stfvcp	f1, [r0]
    1b34:	001f129f 	mulseq	pc, pc, r2	; <UNPREDICTABLE>
    1b38:	001f1900 	andseq	r1, pc, r0, lsl #18
    1b3c:	50000100 	andpl	r0, r0, r0, lsl #2
	f25519_normalize(c);
	c[31] |= parity;
}

uint8_t ed25519_try_unpack(uint8_t *x, uint8_t *y, const uint8_t *comp)
{
    1b40:	00001f19 	andeq	r1, r0, r9, lsl pc
	uint8_t b[F25519_SIZE];
	uint8_t c[F25519_SIZE];

	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;
    1b44:	00001f32 	andeq	r1, r0, r2, lsr pc
    1b48:	e0910004 	adds	r0, r1, r4
    1b4c:	1f329f7d 	svcne	0x00329f7d
    1b50:	1f390000 	svcne	0x00390000
    1b54:	00010000 	andeq	r0, r1, r0
	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
	f25519_add(a, b, f25519_one);
    1b58:	001f3950 	andseq	r3, pc, r0, asr r9	; <UNPREDICTABLE>
	/* Unpack y */
	f25519_copy(y, comp);
	y[31] &= 127;

	/* Compute c = y^2 */
	f25519_mul__distinct(c, y, y);
    1b5c:	001f4000 	andseq	r4, pc, r0

	/* Compute b = (1+dy^2)^-1 */
	f25519_mul__distinct(b, c, ed25519_d);
    1b60:	91000400 	tstls	r0, r0, lsl #8
    1b64:	409f7de0 	addsmi	r7, pc, r0, ror #27
	f25519_add(a, b, f25519_one);
    1b68:	4300001f 	movwmi	r0, #31
    1b6c:	0100001f 	tsteq	r0, pc, lsl r0
    1b70:	1f435200 	svcne	0x00435200
	f25519_inv__distinct(b, a);
    1b74:	1f640000 	svcne	0x00640000
    1b78:	00040000 	andeq	r0, r4, r0

	/* Compute a = y^2-1 */
	f25519_sub(a, c, f25519_one);
    1b7c:	9f7de091 	svcls	0x007de091
	...

	/* Compute c = a*b = (y^2-1)/(1-dy^2) */
	f25519_mul__distinct(c, a, b);
    1b88:	00001f08 	andeq	r1, r0, r8, lsl #30
    1b8c:	00001f0c 	andeq	r1, r0, ip, lsl #30

	/* Compute a, b = +/-sqrt(c), if c is square */
	f25519_sqrt(a, c);
    1b90:	0c500001 	mrrceq	0, 0, r0, r0, cr1	; <UNPREDICTABLE>
    1b94:	6400001f 	strvs	r0, [r0], #-31
	f25519_neg(b, a);
    1b98:	0100001f 	tsteq	r0, pc, lsl r0
    1b9c:	00005500 	andeq	r5, r0, r0, lsl #10

	/* Select one of them, based on the compressed parity bit */
	f25519_select(x, a, b, (a[0] ^ parity) & 1);
    1ba0:	00000000 	andeq	r0, r0, r0
    1ba4:	1f1a0000 	svcne	0x001a0000
    1ba8:	1f640000 	svcne	0x00640000
    1bac:	00010000 	andeq	r0, r1, r0
    1bb0:	00000056 	andeq	r0, r0, r6, asr r0

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
    1bb4:	00000000 	andeq	r0, r0, r0
    1bb8:	001f1a00 	andseq	r1, pc, r0, lsl #20
    1bbc:	001f2c00 	andseq	r2, pc, r0, lsl #24
	f25519_normalize(a);
    1bc0:	91000400 	tstls	r0, r0, lsl #8
	f25519_normalize(c);
    1bc4:	2c9f7ee0 	ldccs	14, cr7, [pc], {224}	; 0xe0
    1bc8:	2f00001f 	svccs	0x0000001f

	return f25519_eq(a, c);
    1bcc:	0100001f 	tsteq	r0, pc, lsl r0
    1bd0:	1f2f5000 	svcne	0x002f5000
}
    1bd4:	1f360000 	svcne	0x00360000
    1bd8:	00040000 	andeq	r0, r4, r0
    1bdc:	9f7ee091 	svcls	0x007ee091
	0xe7, 0xfc, 0xdf, 0x56, 0xdc, 0xd9, 0x06, 0x24
};

void ed25519_add(struct ed25519_pt *r,
		 const struct ed25519_pt *p1, const struct ed25519_pt *p2)
{
    1be0:	00001f36 	andeq	r1, r0, r6, lsr pc
    1be4:	00001f39 	andeq	r1, r0, r9, lsr pc
    1be8:	39520001 	ldmdbcc	r2, {r0}^
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bec:	6400001f 	strvs	r0, [r0], #-31
    1bf0:	0400001f 	streq	r0, [r0], #-31
    1bf4:	7ee09100 	urdvcs	f1, f0
	f25519_sub(d, p2->y, p2->x);
    1bf8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = (Y1-X1)(Y2-X2) */
	f25519_sub(c, p1->y, p1->x);
    1bfc:	00000000 	andeq	r0, r0, r0
	f25519_sub(d, p2->y, p2->x);
    1c00:	001f2800 	andseq	r2, pc, r0, lsl #16
    1c04:	001f2c00 	andseq	r2, pc, r0, lsl #24
	f25519_mul__distinct(a, c, d);
    1c08:	50000100 	andpl	r0, r0, r0, lsl #2
    1c0c:	00001f2c 	andeq	r1, r0, ip, lsr #30
    1c10:	00001f64 	andeq	r1, r0, r4, ror #30

	/* B = (Y1+X1)(Y2+X2) */
	f25519_add(c, p1->y, p1->x);
    1c14:	00540001 	subseq	r0, r4, r1
    1c18:	00000000 	andeq	r0, r0, r0
	f25519_add(d, p2->y, p2->x);
    1c1c:	3a000000 	bcc	1c24 <ed25519_add+0x44>
    1c20:	4000001f 	andmi	r0, r0, pc, lsl r0
    1c24:	0400001f 	streq	r0, [r0], #-31
	f25519_mul__distinct(b, c, d);
    1c28:	7de09100 	stfvcp	f1, [r0]
    1c2c:	001f409f 	mulseq	pc, pc, r0	; <UNPREDICTABLE>

	/* C = T1 k T2 */
	f25519_mul__distinct(d, p1->t, p2->t);
    1c30:	001f4300 	andseq	r4, pc, r0, lsl #6
    1c34:	52000100 	andpl	r0, r0, #0, 2
    1c38:	00001f43 	andeq	r1, r0, r3, asr #30
    1c3c:	00001f64 	andeq	r1, r0, r4, ror #30
	f25519_mul__distinct(c, d, ed25519_k);
    1c40:	e0910004 	adds	r0, r1, r4
    1c44:	00009f7d 	andeq	r9, r0, sp, ror pc

	/* D = Z1 2 Z2 */
	f25519_mul__distinct(d, p1->z, p2->z);
    1c48:	00000000 	andeq	r0, r0, r0
    1c4c:	1f3a0000 	svcne	0x003a0000
    1c50:	1f4a0000 	svcne	0x004a0000
    1c54:	00040000 	andeq	r0, r4, r0
	f25519_add(d, d, d);
    1c58:	9f7ce091 	svcls	0x007ce091
    1c5c:	00001f4a 	andeq	r1, r0, sl, asr #30

	/* E = B - A */
	f25519_sub(e, b, a);
    1c60:	00001f4d 	andeq	r1, r0, sp, asr #30
    1c64:	4d500001 	ldclmi	0, cr0, [r0, #-4]
    1c68:	5200001f 	andpl	r0, r0, #31

	/* F = D - C */
	f25519_sub(f, d, c);
    1c6c:	0400001f 	streq	r0, [r0], #-31
    1c70:	7ce09100 	stfvcp	f1, [r0]

	/* G = D + C */
	f25519_add(g, d, c);
    1c74:	001f529f 	mulseq	pc, pc, r2	; <UNPREDICTABLE>
    1c78:	001f5500 	andseq	r5, pc, r0, lsl #10
    1c7c:	51000100 	mrspl	r0, (UNDEF: 16)

	/* H = B + A */
	f25519_add(h, b, a);
    1c80:	00001f55 	andeq	r1, r0, r5, asr pc
    1c84:	00001f64 	andeq	r1, r0, r4, ror #30

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1c88:	e0910004 	adds	r0, r1, r4
    1c8c:	00009f7c 	andeq	r9, r0, ip, ror pc
    1c90:	00000000 	andeq	r0, r0, r0

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1c94:	1f740000 	svcne	0x00740000
    1c98:	1f880000 	svcne	0x00880000
    1c9c:	00010000 	andeq	r0, r1, r0

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1ca0:	001f8850 	andseq	r8, pc, r0, asr r8	; <UNPREDICTABLE>
    1ca4:	001f9100 	andseq	r9, pc, r0, lsl #2
    1ca8:	70000300 	andvc	r0, r0, r0, lsl #6

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1cac:	1f919f7c 	svcne	0x00919f7c
    1cb0:	1f920000 	svcne	0x00920000
    1cb4:	00040000 	andeq	r0, r4, r0
}
    1cb8:	9f5001f3 	svcls	0x005001f3
	...

void ed25519_double(struct ed25519_pt *r, const struct ed25519_pt *p)
{
    1cc4:	00001f74 	andeq	r1, r0, r4, ror pc

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1cc8:	00001f7a 	andeq	r1, r0, sl, ror pc
	uint8_t f[F25519_SIZE];
	uint8_t g[F25519_SIZE];
	uint8_t h[F25519_SIZE];

	/* A = X1^2 */
	f25519_mul__distinct(a, p->x, p->x);
    1ccc:	7a510001 	bvc	1441cd8 <_etext+0x143a6c4>
    1cd0:	8000001f 	andhi	r0, r0, pc, lsl r0

	/* B = Y1^2 */
	f25519_mul__distinct(b, p->y, p->y);
    1cd4:	0100001f 	tsteq	r0, pc, lsl r0
    1cd8:	1f805200 	svcne	0x00805200
    1cdc:	1f840000 	svcne	0x00840000

	/* C = 2 Z1^2 */
	f25519_mul__distinct(c, p->z, p->z);
    1ce0:	00050000 	andeq	r0, r5, r0
    1ce4:	25380072 	ldrcs	r0, [r8, #-114]!	; 0x72
    1ce8:	001f849f 	mulseq	pc, pc, r4	; <UNPREDICTABLE>
	f25519_add(c, c, c);
    1cec:	001f8a00 	andseq	r8, pc, r0, lsl #20
    1cf0:	72000700 	andvc	r0, r0, #0, 14

	/* D = a A (alter sign) */
	/* E = (X1+Y1)^2-A-B */
	f25519_add(f, p->x, p->y);
    1cf4:	38253800 	stmdacc	r5!, {fp, ip, sp}
    1cf8:	1f8a9f25 	svcne	0x008a9f25
    1cfc:	1f920000 	svcne	0x00920000
	f25519_mul__distinct(e, f, f);
    1d00:	000a0000 	andeq	r0, sl, r0
    1d04:	405101f3 	ldrshmi	r0, [r1], #-19	; 0xffffffed
	f25519_sub(e, e, a);
    1d08:	38253825 	stmdacc	r5!, {r0, r2, r5, fp, ip, sp}
    1d0c:	00009f25 	andeq	r9, r0, r5, lsr #30
    1d10:	00000000 	andeq	r0, r0, r0
	f25519_sub(e, e, b);
    1d14:	1f740000 	svcne	0x00740000
    1d18:	1f7a0000 	svcne	0x007a0000

	/* G = D + B */
	f25519_sub(g, b, a);
    1d1c:	00020000 	andeq	r0, r2, r0
    1d20:	1f7a9f30 	svcne	0x007a9f30
    1d24:	1f800000 	svcne	0x00800000

	/* F = G - C */
	f25519_sub(f, g, c);
    1d28:	00020000 	andeq	r0, r2, r0
    1d2c:	1f809f32 	svcne	0x00809f32

	/* H = D - B */
	f25519_neg(h, b);
    1d30:	1f840000 	svcne	0x00840000
    1d34:	00020000 	andeq	r0, r2, r0
	f25519_sub(h, h, a);
    1d38:	1f849f33 	svcne	0x00849f33
    1d3c:	1f920000 	svcne	0x00920000
    1d40:	00020000 	andeq	r0, r2, r0

	/* X3 = E F */
	f25519_mul__distinct(r->x, e, f);
    1d44:	00009f34 	andeq	r9, r0, r4, lsr pc
    1d48:	00000000 	andeq	r0, r0, r0

	/* Y3 = G H */
	f25519_mul__distinct(r->y, g, h);
    1d4c:	1fac0000 	svcne	0x00ac0000
    1d50:	1fda0000 	svcne	0x00da0000
    1d54:	00010000 	andeq	r0, r1, r0

	/* T3 = E H */
	f25519_mul__distinct(r->t, e, h);
    1d58:	001fdc52 	andseq	sp, pc, r2, asr ip	; <UNPREDICTABLE>
    1d5c:	001fe600 	andseq	lr, pc, r0, lsl #12
    1d60:	52000100 	andpl	r0, r0, #0, 2
	...

	/* Z3 = F G */
	f25519_mul__distinct(r->z, f, g);
    1d6c:	00001fac 	andeq	r1, r0, ip, lsr #31
}
    1d70:	00001fb4 			; <UNDEFINED> instruction: 0x00001fb4

void ed25519_smult(struct ed25519_pt *r_out, const struct ed25519_pt *p,
		   const uint8_t *e)
{
    1d74:	b4530001 	ldrblt	r0, [r3], #-1
    1d78:	ba00001f 	blt	1dfc <edsign_verify+0x4>
    1d7c:	0300001f 	movweq	r0, #31
    1d80:	9f7f7300 	svcls	0x007f7300
    1d84:	00001fba 			; <UNDEFINED> instruction: 0x00001fba
    1d88:	00001fbe 			; <UNDEFINED> instruction: 0x00001fbe
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1d8c:	c0530001 	subsgt	r0, r3, r1
    1d90:	ca00001f 	bgt	1e14 <edsign_verify+0x1c>
    1d94:	0100001f 	tsteq	r0, pc, lsl r0
		struct ed25519_pt s;

		ed25519_double(&r, &r);
    1d98:	1fca5300 	svcne	0x00ca5300
    1d9c:	1fd00000 	svcne	0x00d00000
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
		const uint8_t bit = (e[i >> 3] >> (i & 7)) & 1;
    1da0:	00030000 	andeq	r0, r3, r0
		struct ed25519_pt s;

		ed25519_double(&r, &r);
		ed25519_add(&s, &r, p);
    1da4:	d09f7f73 	addsle	r7, pc, r3, ror pc	; <UNPREDICTABLE>
    1da8:	d600001f 			; <UNDEFINED> instruction: 0xd600001f

		f25519_select(r.x, r.x, s.x, bit);
    1dac:	0100001f 	tsteq	r0, pc, lsl r0
    1db0:	00005300 	andeq	r5, r0, r0, lsl #6
    1db4:	00000000 	andeq	r0, r0, r0
		f25519_select(r.y, r.y, s.y, bit);
    1db8:	1fe40000 	svcne	0x00e40000
    1dbc:	1fe60000 	svcne	0x00e60000
    1dc0:	00050000 	andeq	r0, r5, r0
		f25519_select(r.z, r.z, s.z, bit);
    1dc4:	253f0072 	ldrcs	r0, [pc, #-114]!	; 1d5a <ed25519_double+0x9a>
    1dc8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    1dcc:	00000000 	andeq	r0, r0, r0
		f25519_select(r.t, r.t, s.t, bit);
    1dd0:	001fe400 	andseq	lr, pc, r0, lsl #8
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1dd4:	001ffc00 	andseq	pc, pc, r0, lsl #24
		ed25519_add(&s, &r, p);

		f25519_select(r.x, r.x, s.x, bit);
		f25519_select(r.y, r.y, s.y, bit);
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
    1dd8:	5d000100 	stfpls	f0, [r0, #-0]
    1ddc:	00001ffc 	strdeq	r1, [r0], -ip
	struct ed25519_pt r;
	int i;

	ed25519_copy(&r, &ed25519_neutral);

	for (i = 255; i >= 0; i--) {
    1de0:	00002002 	andeq	r2, r0, r2
    1de4:	58910003 	ldmpl	r1, {r0, r1}
    1de8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
		f25519_select(r.z, r.z, s.z, bit);
		f25519_select(r.t, r.t, s.t, bit);
	}

	ed25519_copy(r_out, &r);
}
    1dec:	00000000 	andeq	r0, r0, r0
    1df0:	001fe600 	andseq	lr, pc, r0, lsl #12
    1df4:	00200000 	eoreq	r0, r0, r0
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1df8:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e04:	00002004 	andeq	r2, r0, r4
	memcpy(signature + 32, s, 32);
}
*/
uint8_t edsign_verify(const uint8_t *signature, const uint8_t *pub,
		      const uint8_t *message, size_t len)
{
    1e08:	0000204e 	andeq	r2, r0, lr, asr #32
static void hash_message(uint8_t *z, const uint8_t *r, const uint8_t *a,
			 const uint8_t *m, size_t len)
{
	uint8_t block[SHA512_BLOCK_SIZE];

	memcpy(block, r, 32);
    1e0c:	4e500001 	cdpmi	0, 5, cr0, cr0, cr1, {0}
    1e10:	88000020 	stmdahi	r0, {r5}
    1e14:	04000020 	streq	r0, [r0], #-32
    1e18:	5001f300 	andpl	pc, r1, r0, lsl #6
	memcpy(block + 32, a, 32);
    1e1c:	0020889f 	mlaeq	r0, pc, r8, r8	; <UNPREDICTABLE>
    1e20:	00209e00 	eoreq	r9, r0, r0, lsl #28
    1e24:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    1e30:	00002004 	andeq	r2, r0, r4
    1e34:	00002050 	andeq	r2, r0, r0, asr r0
    1e38:	50510001 	subspl	r0, r1, r1
    1e3c:	88000020 	stmdahi	r0, {r5}
    1e40:	04000020 	streq	r0, [r0], #-32
    1e44:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    1e48:	0020889f 	mlaeq	r0, pc, r8, r8	; <UNPREDICTABLE>
{
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
    1e4c:	00209e00 	eoreq	r9, r0, r0, lsl #28
    1e50:	51000100 	mrspl	r0, (UNDEF: 16)
	...
		memcpy(init_block + prefix_size, message, len);
		sha512_final(&s, init_block, len + prefix_size);
	} else {
		size_t i;

		memcpy(init_block + prefix_size, message,
    1e5c:	00002004 	andeq	r2, r0, r4
    1e60:	0000200e 	andeq	r2, r0, lr
    1e64:	9f300002 	svcls	0x00300002
    1e68:	00002074 	andeq	r2, r0, r4, ror r0
    1e6c:	00002078 	andeq	r2, r0, r8, ror r0
    1e70:	78520001 	ldmdavc	r2, {r0}^
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);
    1e74:	7c000020 	stcvc	0, cr0, [r0], {32}
    1e78:	08000020 	stmdaeq	r0, {r5}

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e7c:	31007200 	mrscc	r7, R8_usr
    1e80:	21007225 	tstcs	r0, r5, lsr #4
    1e84:	0020889f 	mlaeq	r0, pc, r8, r8	; <UNPREDICTABLE>
    1e88:	00208c00 	eoreq	r8, r0, r0, lsl #24
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1e8c:	30000200 	andcc	r0, r0, r0, lsl #4
		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
		     i + SHA512_BLOCK_SIZE <= len;
    1e90:	00208c9f 	mlaeq	r0, pc, ip, r8	; <UNPREDICTABLE>
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);
    1e94:	00209e00 	eoreq	r9, r0, r0, lsl #28

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1e98:	52000100 	andpl	r0, r0, #0, 2
	...
		     i + SHA512_BLOCK_SIZE <= len;
		     i += SHA512_BLOCK_SIZE)
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
    1ea4:	00002004 	andeq	r2, r0, r4
    1ea8:	0000200e 	andeq	r2, r0, lr
	struct sha512_state s;

	sha512_init(&s);

	if (len < SHA512_BLOCK_SIZE - prefix_size) {
		memcpy(init_block + prefix_size, message, len);
    1eac:	9f300002 	svcls	0x00300002
    1eb0:	00002088 	andeq	r2, r0, r8, lsl #1
    1eb4:	0000208c 	andeq	r2, r0, ip, lsl #1
		sha512_final(&s, init_block, len + prefix_size);
    1eb8:	9f300002 	svcls	0x00300002
    1ebc:	0000208c 	andeq	r2, r0, ip, lsl #1
    1ec0:	00002092 	muleq	r0, r2, r0
			sha512_block(&s, message + i);

		sha512_final(&s, message + i, len + prefix_size);
	}

	sha512_get(&s, init_block, 0, SHA512_HASH_SIZE);
    1ec4:	92530001 	subsls	r0, r3, #1
    1ec8:	9a000020 	bls	1f50 <edsign_verify+0x158>
    1ecc:	03000020 	movweq	r0, #32
	fprime_from_bytes(out_fp, init_block, SHA512_HASH_SIZE, ed25519_order);
    1ed0:	9f7f7300 	svcls	0x007f7300
    1ed4:	0000209a 	muleq	r0, sl, r0
    1ed8:	0000209e 	muleq	r0, lr, r0

static void sm_pack(uint8_t *r, const uint8_t *k)
{
	struct ed25519_pt p;

	ed25519_smult(&p, &ed25519_base, k);
    1edc:	00530001 	subseq	r0, r3, r1
    1ee0:	00000000 	andeq	r0, r0, r0
    1ee4:	a0000000 	andge	r0, r0, r0
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1ee8:	3c000020 	stccc	0, cr0, [r0], {32}
    1eec:	01000021 	tsteq	r0, r1, lsr #32
	ed25519_pack(packed, x, y);
    1ef0:	213c5100 	teqcs	ip, r0, lsl #2
    1ef4:	214a0000 	mrscs	r0, (UNDEF: 74)
    1ef8:	00040000 	andeq	r0, r4, r0

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1efc:	9f5101f3 	svcls	0x005101f3
    1f00:	0000214a 	andeq	r2, r0, sl, asr #2

	ed25519_project(p, x, y);
    1f04:	00002162 	andeq	r2, r0, r2, ror #2
    1f08:	00510001 	subseq	r0, r1, r1
    1f0c:	00000000 	andeq	r0, r0, r0
	/* sB = (ze + k)B = ... */
	sm_pack(lhs, signature + 32);

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
    1f10:	a0000000 	andge	r0, r0, r0
    1f14:	3e000020 	cdpcc	0, 0, cr0, cr0, cr0, {1}
    1f18:	01000021 	tsteq	r0, r1, lsr #32

static uint8_t upp(struct ed25519_pt *p, const uint8_t *packed)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];
	uint8_t ok = ed25519_try_unpack(x, y, packed);
    1f1c:	213e5200 	teqcs	lr, r0, lsl #4
    1f20:	214a0000 	mrscs	r0, (UNDEF: 74)

	ed25519_project(p, x, y);
    1f24:	00040000 	andeq	r0, r4, r0
    1f28:	9f5201f3 	svcls	0x005201f3
    1f2c:	0000214a 	andeq	r2, r0, sl, asr #2

	/* ... = zA + R */
	ok &= upp(&p, pub);
	ed25519_smult(&p, &p, z);
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
    1f30:	00002162 	andeq	r2, r0, r2, ror #2
    1f34:	00520001 	subseq	r0, r2, r1
    1f38:	00000000 	andeq	r0, r0, r0
static void pp(uint8_t *packed, const struct ed25519_pt *p)
{
	uint8_t x[F25519_SIZE];
	uint8_t y[F25519_SIZE];

	ed25519_unproject(x, y, p);
    1f3c:	a0000000 	andge	r0, r0, r0
    1f40:	c4000020 	strgt	r0, [r0], #-32
	ed25519_pack(packed, x, y);
    1f44:	01000020 	tsteq	r0, r0, lsr #32
    1f48:	20c45300 	sbccs	r5, r4, r0, lsl #6
    1f4c:	21620000 	cmncs	r2, r0
	ok &= upp(&q, signature);
	ed25519_add(&p, &p, &q);
	pp(rhs, &p);

	/* Equal? */
	return ok & f25519_eq(lhs, rhs);
    1f50:	00040000 	andeq	r0, r4, r0
    1f54:	9f5301f3 	svcls	0x005301f3
	...
}
    1f60:	000020c8 	andeq	r2, r0, r8, asr #1

		memcpy(init_block + prefix_size, message,
		       SHA512_BLOCK_SIZE - prefix_size);
		sha512_block(&s, init_block);

		for (i = SHA512_BLOCK_SIZE - prefix_size;
    1f64:	000020ce 	andeq	r2, r0, lr, asr #1
    1f68:	ce530001 	cdpgt	0, 5, cr0, cr3, cr1, {0}
    1f6c:	40000020 	andmi	r0, r0, r0, lsr #32
    1f70:	01000021 	tsteq	r0, r1, lsr #32

const uint8_t f25519_zero[F25519_SIZE] = {0};
const uint8_t f25519_one[F25519_SIZE] = {1};

void f25519_load(uint8_t *x, uint32_t c)
{
    1f74:	214a5600 	cmpcs	sl, r0, lsl #12
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
		c >>= 8;
    1f78:	21600000 	cmncs	r0, r0
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    1f7c:	00010000 	andeq	r0, r1, r0
    1f80:	00000056 	andeq	r0, r0, r6, asr r0
    1f84:	00000000 	andeq	r0, r0, r0
    1f88:	0020c800 	eoreq	ip, r0, r0, lsl #16
		c >>= 8;
	}

	for (; i < F25519_SIZE; i++)
		x[i] = 0;
}
    1f8c:	0020ea00 	eoreq	lr, r0, r0, lsl #20
    1f90:	30000200 	andcc	r0, r0, r0, lsl #4

void f25519_normalize(uint8_t *x)
{
    1f94:	00214a9f 	mlaeq	r1, pc, sl, r4	; <UNPREDICTABLE>
    1f98:	00214c00 	eoreq	r4, r1, r0, lsl #24
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1f9c:	30000200 	andcc	r0, r0, r0, lsl #4
	x[31] &= 127;
    1fa0:	00214c9f 	mlaeq	r1, pc, ip, r4	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
    1fa4:	00216200 	eoreq	r6, r1, r0, lsl #4
	uint8_t minusp[F25519_SIZE];
	uint16_t c;
	int i;

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
    1fa8:	53000100 	movwpl	r0, #256	; 0x100
	...
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fb4:	00002164 	andeq	r2, r0, r4, ror #2
		c += x[i];
		x[i] = c;
		c >>= 8;
    1fb8:	00002194 	muleq	r0, r4, r1

	/* Reduce using 2^255 = 19 mod p */
	c = (x[31] >> 7) * 19;
	x[31] &= 127;

	for (i = 0; i < F25519_SIZE; i++) {
    1fbc:	94510001 	ldrbls	r0, [r1], #-1
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += x[i];
    1fc0:	aa000021 	bge	204c <f25519_eq+0x48>
		minusp[i] = c;
    1fc4:	04000021 	streq	r0, [r0], #-33	; 0x21
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1fc8:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
		c += x[i];
		minusp[i] = c;
		c >>= 8;
    1fcc:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	 * 2p. Try subtracting p, and conditionally load the subtracted
	 * value if underflow did not occur.
	 */
	c = 19;

	for (i = 0; i + 1 < F25519_SIZE; i++) {
    1fd0:	00000000 	andeq	r0, r0, r0
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1fd4:	00216400 	eoreq	r6, r1, r0, lsl #8
		c += x[i];
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
    1fd8:	00218600 	eoreq	r8, r1, r0, lsl #12

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1fdc:	52000100 	andpl	r0, r0, #0, 2
		minusp[i] = c;
		c >>= 8;
	}

	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;
    1fe0:	00002186 	andeq	r2, r0, r6, lsl #3

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    1fe4:	000021aa 	andeq	r2, r0, sl, lsr #3
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    1fe8:	01f30004 	mvnseq	r0, r4
    1fec:	00009f52 	andeq	r9, r0, r2, asr pc
    1ff0:	00000000 	andeq	r0, r0, r0
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    1ff4:	21640000 	cmncs	r4, r0
    1ff8:	216a0000 	cmncs	sl, r0
	c += ((uint16_t)x[i]) - 128;
	minusp[31] = c;

	/* Load x-p if no underflow */
	f25519_select(x, minusp, x, (c >> 15) & 1);
}
    1ffc:	00020000 	andeq	r0, r2, r0
    2000:	216a9f30 	cmncs	sl, r0, lsr pc

uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
    2004:	21740000 	cmncs	r4, r0
    2008:	00050000 	andeq	r0, r5, r0
    200c:	25380074 	ldrcs	r0, [r8, #-116]!	; 0x74
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		sum |= x[i] ^ y[i];
    2010:	0021749f 	mlaeq	r1, pc, r4, r7	; <UNPREDICTABLE>
    2014:	00218000 	eoreq	r8, r1, r0
    2018:	54000100 	strpl	r0, [r0], #-256	; 0x100
    201c:	00002192 	muleq	r0, r2, r1
    2020:	00002198 	muleq	r0, r8, r1
    2024:	9a520001 	bls	1482030 <_etext+0x147aa1c>
    2028:	aa000021 	bge	20b4 <f25519_select+0x14>
    202c:	01000021 	tsteq	r0, r1, lsr #32
    2030:	00005200 	andeq	r5, r0, r0, lsl #4
    2034:	00000000 	andeq	r0, r0, r0
    2038:	21640000 	cmncs	r4, r0
    203c:	216a0000 	cmncs	sl, r0
    2040:	00020000 	andeq	r0, r2, r0
    2044:	216a9f30 	cmncs	sl, r0, lsr pc
    2048:	21820000 	orrcs	r0, r2, r0
    204c:	00010000 	andeq	r0, r1, r0
    2050:	00219253 	eoreq	r9, r1, r3, asr r2
    2054:	00219400 	eoreq	r9, r1, r0, lsl #8
    2058:	30000200 	andcc	r0, r0, r0, lsl #4
    205c:	0021949f 	mlaeq	r1, pc, r4, r9	; <UNPREDICTABLE>
    2060:	00219e00 	eoreq	r9, r1, r0, lsl #28
    2064:	53000100 	movwpl	r0, #256	; 0x100
    2068:	0000219e 	muleq	r0, lr, r1
    206c:	000021a4 	andeq	r2, r0, r4, lsr #3

	sum |= (sum >> 4);
    2070:	7f730003 	svcvc	0x00730003
	sum |= (sum >> 2);
    2074:	0021a49f 	mlaeq	r1, pc, r4, sl	; <UNPREDICTABLE>
	sum |= (sum >> 1);
    2078:	0021aa00 	eoreq	sl, r1, r0, lsl #20

	return (sum ^ 1) & 1;
    207c:	53000100 	movwpl	r0, #256	; 0x100
	...
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2088:	000021ac 	andeq	r2, r0, ip, lsr #3
		sum |= x[i] ^ y[i];
    208c:	000021cc 	andeq	r2, r0, ip, asr #3
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2090:	cc510001 	mrrcgt	0, 0, r0, r1, cr1
    2094:	f8000021 			; <UNDEFINED> instruction: 0xf8000021
		sum |= x[i] ^ y[i];
    2098:	04000021 	streq	r0, [r0], #-33	; 0x21
uint8_t f25519_eq(const uint8_t *x, const uint8_t *y)
{
	uint8_t sum = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    209c:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
}

void f25519_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
    20a0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    20a4:	00000000 	andeq	r0, r0, r0
    20a8:	0021ac00 	eoreq	sl, r1, r0, lsl #24
    20ac:	0021ce00 	eoreq	ip, r1, r0, lsl #28
    20b0:	52000100 	andpl	r0, r0, #0, 2
    20b4:	000021ce 	andeq	r2, r0, lr, asr #3
    20b8:	000021f8 	strdeq	r2, [r0], -r8
    20bc:	01f30004 	mvnseq	r0, r4
    20c0:	00009f52 	andeq	r9, r0, r2, asr pc
	const uint8_t mask = -condition;
    20c4:	00000000 	andeq	r0, r0, r0
    20c8:	21ac0000 			; <UNDEFINED> instruction: 0x21ac0000
    20cc:	21b20000 			; <UNDEFINED> instruction: 0x21b20000
    20d0:	00030000 	andeq	r0, r3, r0
    20d4:	b29fda08 	addslt	sp, pc, #8, 20	; 0x8000
    20d8:	de000021 	cdple	0, 0, cr0, cr0, cr1, {1}
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    20dc:	01000021 	tsteq	r0, r1, lsr #32
    20e0:	21e45400 	mvncs	r5, r0, lsl #8
    20e4:	21f80000 	mvnscs	r0, r0
    20e8:	00010000 	andeq	r0, r1, r0
    20ec:	00000052 	andeq	r0, r0, r2, asr r0
    20f0:	00000000 	andeq	r0, r0, r0
    20f4:	0021ac00 	eoreq	sl, r1, r0, lsl #24
    20f8:	0021b200 	eoreq	fp, r1, r0, lsl #4
    20fc:	30000200 	andcc	r0, r0, r0, lsl #4
    2100:	0021b29f 	mlaeq	r1, pc, r2, fp	; <UNPREDICTABLE>
    2104:	0021c200 	eoreq	ip, r1, r0, lsl #4
    2108:	53000100 	movwpl	r0, #256	; 0x100
    210c:	000021c2 	andeq	r2, r0, r2, asr #3
    2110:	000021c8 	andeq	r2, r0, r8, asr #3
    2114:	7f730003 	svcvc	0x00730003
    2118:	0021c89f 	mlaeq	r1, pc, r8, ip	; <UNPREDICTABLE>
    211c:	0021d000 	eoreq	sp, r1, r0
    2120:	53000100 	movwpl	r0, #256	; 0x100
    2124:	000021e4 	andeq	r2, r0, r4, ror #3
    2128:	000021ec 	andeq	r2, r0, ip, ror #3
    212c:	ec530001 	mrrc	0, 0, r0, r3, cr1
    2130:	f2000021 	vhadd.s8	d0, d0, d17
    2134:	03000021 	movweq	r0, #33	; 0x21
    2138:	9f7f7300 	svcls	0x007f7300
    213c:	000021f2 	strdeq	r2, [r0], -r2	; <UNPREDICTABLE>
    2140:	000021f8 	strdeq	r2, [r0], -r8
    2144:	00530001 	subseq	r0, r3, r1
}
    2148:	00000000 	andeq	r0, r0, r0
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    214c:	f8000000 			; <UNDEFINED> instruction: 0xf8000000
    2150:	14000021 	strne	r0, [r0], #-33	; 0x21
    2154:	01000022 	tsteq	r0, r2, lsr #32
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < F25519_SIZE; i++)
    2158:	22145100 	andscs	r5, r4, #0, 2
    215c:	223e0000 	eorscs	r0, lr, #0
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
}
    2160:	00040000 	andeq	r0, r4, r0
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    2164:	9f5101f3 	svcls	0x005101f3
	...
		c >>= 8;
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
    2170:	000021f8 	strdeq	r2, [r0], -r8
		r[i] = c;
    2174:	000021fe 	strdeq	r2, [r0], -lr
{
	uint16_t c = 0;
	int i;

	/* Add */
	for (i = 0; i < F25519_SIZE; i++) {
    2178:	da080003 	ble	20218c <_etext+0x1fab78>
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;
    217c:	0021fe9f 	mlaeq	r1, pc, lr, pc	; <UNPREDICTABLE>
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    2180:	00222200 	eoreq	r2, r2, r0, lsl #4
	c = (c >> 7) * 19;
    2184:	52000100 	andpl	r0, r0, #0, 2
		c += ((uint16_t)a[i]) + ((uint16_t)b[i]);
		r[i] = c;
	}

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
    2188:	00002228 	andeq	r2, r0, r8, lsr #4
	c = (c >> 7) * 19;
    218c:	0000223e 	andeq	r2, r0, lr, lsr r2
    2190:	00520001 	subseq	r0, r2, r1

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2194:	00000000 	andeq	r0, r0, r0
    2198:	f8000000 			; <UNDEFINED> instruction: 0xf8000000

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    219c:	fe000021 	cdp2	0, 0, cr0, cr0, cr1, {1}
		c += r[i];
		r[i] = c;
		c >>= 8;
    21a0:	02000021 	andeq	r0, r0, #33	; 0x21

	/* Reduce with 2^255 = 19 mod p */
	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21a4:	fe9f3000 	cdp2	0, 9, cr3, cr15, cr0, {0}
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    21a8:	0a000021 	beq	2234 <f25519_neg+0x3c>

void f25519_sub(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    21ac:	01000022 	tsteq	r0, r2, lsr #32
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
    21b0:	220a5300 	andcs	r5, sl, #0, 6
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    21b4:	22100000 	andscs	r0, r0, #0
    21b8:	00030000 	andeq	r0, r3, r0
    21bc:	109f7f73 	addsne	r7, pc, r3, ror pc	; <UNPREDICTABLE>
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21c0:	16000022 	strne	r0, [r0], -r2, lsr #32
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    21c4:	01000022 	tsteq	r0, r2, lsr #32
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    21c8:	22285300 	eorcs	r5, r8, #0, 6
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    21cc:	22300000 	eorscs	r0, r0, #0
    21d0:	00010000 	andeq	r0, r1, r0
	r[31] = c & 127;
	c = (c >> 7) * 19;
    21d4:	00223053 	eoreq	r3, r2, r3, asr r0
    21d8:	00223600 	eoreq	r3, r2, r0, lsl #12
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    21dc:	73000300 	movwvc	r0, #768	; 0x300
	c = (c >> 7) * 19;
    21e0:	22369f7f 	eorscs	r9, r6, #508	; 0x1fc

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    21e4:	223e0000 	eorscs	r0, lr, #0
		r[i] = c;
    21e8:	00010000 	andeq	r0, r1, r0

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    21ec:	00000053 	andeq	r0, r0, r3, asr r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    21f0:	00000000 	andeq	r0, r0, r0
	}
}
    21f4:	00224000 	eoreq	r4, r2, r0

void f25519_neg(uint8_t *r, const uint8_t *a)
{
    21f8:	0022a000 	eoreq	sl, r2, r0
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
    21fc:	51000100 	mrspl	r0, (UNDEF: 16)
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 - ((uint32_t)a[i]);
    2200:	000022a0 	andeq	r2, r0, r0, lsr #5
    2204:	000022c8 	andeq	r2, r0, r8, asr #5
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2208:	01f30004 	mvnseq	r0, r4
		c += 65280 - ((uint32_t)a[i]);
		r[i] = c;
		c >>= 8;
    220c:	00009f51 	andeq	r9, r0, r1, asr pc
	uint32_t c = 0;
	int i;

	/* Calculate 2p - a, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2210:	00000000 	andeq	r0, r0, r0

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2214:	22400000 	subcs	r0, r0, #0
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2218:	22a60000 	adccs	r0, r6, #0
		r[i] = c;
		c >>= 8;
	}

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
    221c:	00010000 	andeq	r0, r1, r0
	c = (c >> 7) * 19;
    2220:	0022a652 	eoreq	sl, r2, r2, asr r6
    2224:	0022c800 	eoreq	ip, r2, r0, lsl #16

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2228:	f3000400 	vshl.u8	d0, d0, d0
		r[i] = c;
    222c:	009f5201 	addseq	r5, pc, r1, lsl #4

	c -= ((uint32_t)a[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2230:	00000000 	andeq	r0, r0, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    2234:	40000000 	andmi	r0, r0, r0
	}
}
    2238:	4e000022 	cdpmi	0, 0, cr0, cr0, cr2, {1}
    223c:	02000022 	andeq	r0, r0, #34	; 0x22

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
    2240:	4e9f3000 	cdpmi	0, 9, cr3, cr15, cr0, {0}
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2244:	a2000022 	andge	r0, r0, #34	; 0x22
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    2248:	01000022 	tsteq	r0, r2, lsr #32
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    224c:	22ae5300 	adccs	r5, lr, #0, 6
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2250:	22c80000 	sbccs	r0, r8, #0
		for (j = 0; j <= i; j++)
    2254:	00010000 	andeq	r0, r1, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2258:	00000052 	andeq	r0, r0, r2, asr r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    225c:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2260:	00224000 	eoreq	r4, r2, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2264:	00224e00 	eoreq	r4, r2, r0, lsl #28
    2268:	30000200 	andcc	r0, r0, r0, lsl #4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    226c:	00224e9f 	mlaeq	r2, pc, lr, r4	; <UNPREDICTABLE>
    2270:	0022ae00 	eoreq	sl, r2, r0, lsl #28
    2274:	58000100 	stmdapl	r0, {r8}
    2278:	000022ae 	andeq	r2, r0, lr, lsr #5
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    227c:	000022b2 			; <UNDEFINED> instruction: 0x000022b2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2280:	9f300002 	svcls	0x00300002
    2284:	000022b2 			; <UNDEFINED> instruction: 0x000022b2

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2288:	000022ba 			; <UNDEFINED> instruction: 0x000022ba
			c += ((uint32_t)a[j]) *
    228c:	ba530001 	blt	14c2298 <_etext+0x14bac84>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2290:	c0000022 	andgt	r0, r0, r2, lsr #32
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2294:	03000022 	movweq	r0, #34	; 0x22
    2298:	9f7f7300 	svcls	0x007f7300
    229c:	000022c0 	andeq	r2, r0, r0, asr #5

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    22a0:	000022c8 	andeq	r2, r0, r8, asr #5
    22a4:	00530001 	subseq	r0, r3, r1
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    22a8:	00000000 	andeq	r0, r0, r0
	c = (c >> 7) * 19;
    22ac:	50000000 	andpl	r0, r0, r0

	for (i = 0; i < F25519_SIZE; i++) {
    22b0:	56000022 	strpl	r0, [r0], -r2, lsr #32
		c += r[i];
    22b4:	02000022 	andeq	r0, r0, #34	; 0x22
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22b8:	569f3000 	ldrpl	r3, [pc], r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    22bc:	5e000022 	cdppl	0, 0, cr0, cr0, cr2, {1}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    22c0:	01000022 	tsteq	r0, r2, lsr #32
		c += r[i];
		r[i] = c;
		c >>= 8;
	}
}
    22c4:	225e5400 	subscs	r5, lr, #0, 8
		c >>= 8;
	}
}

void f25519_inv__distinct(uint8_t *r, const uint8_t *x)
{
    22c8:	22640000 	rsbcs	r0, r4, #0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    22cc:	00030000 	andeq	r0, r3, r0
	}
}

void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
    22d0:	649f7f74 	ldrvs	r7, [pc], #3956	; 22d8 <f25519_inv__distinct+0x10>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    22d4:	88000022 	stmdahi	r0, {r1, r5}
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    22d8:	01000022 	tsteq	r0, r2, lsr #32
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22dc:	22885400 	addcs	r5, r8, #0, 8
    22e0:	228e0000 	addcs	r0, lr, #0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22e4:	00030000 	andeq	r0, r3, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    22e8:	8e9f7f74 	mrchi	15, 4, r7, cr15, cr4, {3}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    22ec:	c6000022 	strgt	r0, [r0], -r2, lsr #32
    22f0:	01000022 	tsteq	r0, r2, lsr #32
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    22f4:	00005400 	andeq	r5, r0, r0, lsl #8
	...
			c += ((uint32_t)a[j]) *
    2304:	00010000 	andeq	r0, r1, r0
    2308:	00000050 	andeq	r0, r0, r0, asr r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    230c:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) *
    2310:	58000100 	stmdapl	r0, {r8}
	...
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    231c:	01f30004 	mvnseq	r0, r4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2320:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    2330:	00010000 	andeq	r0, r1, r0
    2334:	00000051 	andeq	r0, r0, r1, asr r0
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2338:	00000000 	andeq	r0, r0, r0
		r[i] = c;
    233c:	f3000400 	vshl.u8	d0, d0, d0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2340:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
    2350:	01000000 	mrseq	r0, (UNDEF: 0)
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2354:	00005200 	andeq	r5, r0, r0, lsl #4
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2358:	00000000 	andeq	r0, r0, r0
		for (j = 0; j <= i; j++)
    235c:	00040000 	andeq	r0, r4, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2360:	9f5201f3 	svcls	0x005201f3
	...

		for (; j < F25519_SIZE; j++)
    2374:	00520001 	subseq	r0, r2, r1
    2378:	00000000 	andeq	r0, r0, r0
    237c:	04000000 	streq	r0, [r0], #-0
    2380:	5201f300 	andpl	pc, r1, #0, 6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2384:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2394:	51000100 	mrspl	r0, (UNDEF: 16)
	...

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    23a0:	01f30004 	mvnseq	r0, r4
    23a4:	00009f51 	andeq	r9, r0, r1, asr pc
	...

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    23b4:	00010000 	andeq	r0, r1, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23b8:	0000005d 	andeq	r0, r0, sp, asr r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    23bc:	00000000 	andeq	r0, r0, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23c0:	74000300 	strvc	r0, [r0], #-768	; 0x300
    23c4:	00009f60 	andeq	r9, r0, r0, ror #30
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    23c8:	00000000 	andeq	r0, r0, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    23cc:	00030000 	andeq	r0, r3, r0
    23d0:	009f487d 	addseq	r4, pc, sp, ror r8	; <UNPREDICTABLE>
	...
	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23e0:	02000000 	andeq	r0, r0, #0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23e4:	009f3000 	addseq	r3, pc, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    23e8:	00000000 	andeq	r0, r0, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    23ec:	01000000 	mrseq	r0, (UNDEF: 0)
    23f0:	00005300 	andeq	r5, r0, r0, lsl #6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    23f4:	00000000 	andeq	r0, r0, r0
    23f8:	00010000 	andeq	r0, r1, r0
    23fc:	00000052 	andeq	r0, r0, r2, asr r0
	...
			c += ((uint32_t)a[j]) *
    240c:	30000200 	andcc	r0, r0, r0, lsl #4

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2410:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) *
    2414:	00000000 	andeq	r0, r0, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2418:	59000100 	stmdbpl	r0, {r8}
	...
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2424:	9f300002 	svcls	0x00300002
	...
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2430:	00730008 	rsbseq	r0, r3, r8
	c = (c >> 7) * 19;
    2434:	231c0091 	tstcs	ip, #145	; 0x91
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2438:	00009f38 	andeq	r9, r0, r8, lsr pc
	c = (c >> 7) * 19;
    243c:	00000000 	andeq	r0, r0, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2440:	00080000 	andeq	r0, r8, r0
		r[i] = c;
    2444:	00910073 	addseq	r0, r1, r3, ror r0
		c >>= 8;
    2448:	9f37231c 	svcls	0x0037231c
	...
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2454:	00730008 	rsbseq	r0, r3, r8
    2458:	231c0091 	tstcs	ip, #145	; 0x91
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    245c:	00009f38 	andeq	r9, r0, r8, lsr pc
	...

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    246c:	00020000 	andeq	r0, r2, r0
    2470:	00009f30 	andeq	r9, r0, r0, lsr pc
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2474:	00000000 	andeq	r0, r0, r0
    2478:	00010000 	andeq	r0, r1, r0
    247c:	00000054 	andeq	r0, r0, r4, asr r0
    2480:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2484:	74000300 	strvc	r0, [r0], #-768	; 0x300
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2488:	00009f7f 	andeq	r9, r0, pc, ror pc
    248c:	00000000 	andeq	r0, r0, r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2490:	00010000 	andeq	r0, r1, r0
			c += ((uint32_t)a[j]) *
    2494:	00000054 	andeq	r0, r0, r4, asr r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2498:	00000000 	andeq	r0, r0, r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    249c:	74000300 	strvc	r0, [r0], #-768	; 0x300
    24a0:	00009f7f 	andeq	r9, r0, pc, ror pc
    24a4:	00000000 	andeq	r0, r0, r0

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    24a8:	00010000 	andeq	r0, r1, r0
    24ac:	00000054 	andeq	r0, r0, r4, asr r0
	...

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    24bc:	5d000100 	stfpls	f0, [r0, #-0]
	...
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    24c8:	60740003 	rsbsvs	r0, r4, r3
	/* 1 1 */
	f25519_mul__distinct(s, x, x);
	f25519_mul__distinct(r, s, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    24cc:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    24d0:	00000000 	andeq	r0, r0, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    24d4:	7d000300 	stcvc	3, cr0, [r0, #-0]
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    24d8:	00009f48 	andeq	r9, r0, r8, asr #30
	...
		for (j = 0; j <= i; j++)
    24e8:	00010000 	andeq	r0, r1, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    24ec:	00000058 	andeq	r0, r0, r8, asr r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    24f0:	00000000 	andeq	r0, r0, r0
    24f4:	f3000400 	vshl.u8	d0, d0, d0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    24f8:	009f5001 	addseq	r5, pc, r1
	...
			c += ((uint32_t)a[j]) *
    2508:	01000000 	mrseq	r0, (UNDEF: 0)
    250c:	00005200 	andeq	r5, r0, r0, lsl #4

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2510:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) *
    2514:	00040000 	andeq	r0, r4, r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2518:	9f5201f3 	svcls	0x005201f3
	...

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    252c:	9f300002 	svcls	0x00300002
	...
    2538:	00740005 	rsbseq	r0, r4, r5
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    253c:	009f2538 	addseq	r2, pc, r8, lsr r5	; <UNPREDICTABLE>
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2540:	00000000 	andeq	r0, r0, r0
		r[i] = c;
    2544:	01000000 	mrseq	r0, (UNDEF: 0)
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2548:	00005400 	andeq	r5, r0, r0, lsl #8
	...
    2558:	00020000 	andeq	r0, r2, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    255c:	00009f30 	andeq	r9, r0, r0, lsr pc
    2560:	00000000 	andeq	r0, r0, r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2564:	00010000 	andeq	r0, r1, r0
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2568:	00000053 	andeq	r0, r0, r3, asr r0
    256c:	00000000 	andeq	r0, r0, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2570:	30000200 	andcc	r0, r0, r0, lsl #4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2574:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2578:	00000000 	andeq	r0, r0, r0
    257c:	53000100 	movwpl	r0, #256	; 0x100
	...
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2588:	7f730003 	svcvc	0x00730003
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    258c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2590:	00000000 	andeq	r0, r0, r0
    2594:	53000100 	movwpl	r0, #256	; 0x100
	...
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    25a0:	000022c8 	andeq	r2, r0, r8, asr #5
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    25a4:	00002888 	andeq	r2, r0, r8, lsl #17
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25a8:	88510001 	ldmdahi	r1, {r0}^
	c = (c >> 7) * 19;
    25ac:	b2000028 	andlt	r0, r0, #40	; 0x28
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25b0:	04000028 	streq	r0, [r0], #-40	; 0x28
	c = (c >> 7) * 19;
    25b4:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    25b8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    25bc:	00000000 	andeq	r0, r0, r0
		r[i] = c;
    25c0:	0022d000 	eoreq	sp, r2, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    25c4:	00288800 	eoreq	r8, r8, r0, lsl #16
		c += r[i];
		r[i] = c;
		c >>= 8;
    25c8:	51000100 	mrspl	r0, (UNDEF: 16)
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    25cc:	00002888 	andeq	r2, r0, r8, lsl #17
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    25d0:	000028b2 			; <UNDEFINED> instruction: 0x000028b2
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    25d4:	01f30004 	mvnseq	r0, r4
		for (j = 0; j <= i; j++)
    25d8:	00009f51 	andeq	r9, r0, r1, asr pc
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25dc:	00000000 	andeq	r0, r0, r0
    25e0:	22d00000 	sbcscs	r0, r0, #0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25e4:	28ac0000 	stmiacs	ip!, {}	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    25e8:	00010000 	andeq	r0, r1, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    25ec:	0028ac5d 	eoreq	sl, r8, sp, asr ip
    25f0:	0028b000 	eoreq	fp, r8, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    25f4:	91000300 	mrsls	r0, LR_irq
    25f8:	28b09f40 	ldmcs	r0!, {r6, r8, r9, sl, fp, ip, pc}
    25fc:	28b20000 	ldmcs	r2!, {}	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2600:	00030000 	andeq	r0, r3, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2604:	009f407d 	addseq	r4, pc, sp, ror r0	; <UNPREDICTABLE>
    2608:	00000000 	andeq	r0, r0, r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    260c:	d0000000 	andle	r0, r0, r0
			c += ((uint32_t)a[j]) *
    2610:	d6000022 	strle	r0, [r0], -r2, lsr #32
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2614:	02000022 	andeq	r0, r0, #34	; 0x22
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2618:	d69f3000 	ldrle	r3, [pc], r0
    261c:	24000022 	strcs	r0, [r0], #-34	; 0x22
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2620:	01000023 	tsteq	r0, r3, lsr #32
	c = (c >> 7) * 19;
    2624:	23305300 	teqcs	r0, #0, 6
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2628:	234e0000 	movtcs	r0, #57344	; 0xe000
	c = (c >> 7) * 19;
    262c:	00010000 	andeq	r0, r1, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2630:	00000052 	andeq	r0, r0, r2, asr r0
	c = (c >> 7) * 19;
    2634:	00000000 	andeq	r0, r0, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2638:	0022d000 	eoreq	sp, r2, r0
		r[i] = c;
    263c:	0022d600 	eoreq	sp, r2, r0, lsl #12
		c >>= 8;
    2640:	30000200 	andcc	r0, r0, r0, lsl #4
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2644:	0022d69f 	mlaeq	r2, pc, r6, sp	; <UNPREDICTABLE>
    2648:	00233000 	eoreq	r3, r3, r0
    264c:	56000100 	strpl	r0, [r0], -r0, lsl #2
    2650:	00002330 	andeq	r2, r0, r0, lsr r3
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2654:	00002338 	andeq	r2, r0, r8, lsr r3
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2658:	9f300002 	svcls	0x00300002
		for (j = 0; j <= i; j++)
    265c:	00002338 	andeq	r2, r0, r8, lsr r3
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2660:	00002340 	andeq	r2, r0, r0, asr #6
    2664:	00730008 	rsbseq	r0, r3, r8

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2668:	231c0091 	tstcs	ip, #145	; 0x91
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    266c:	23409f40 	movtcs	r9, #3904	; 0xf40

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2670:	23460000 	movtcs	r0, #24576	; 0x6000
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2674:	00080000 	andeq	r0, r8, r0
    2678:	00910073 	addseq	r0, r1, r3, ror r0
    267c:	9f3f231c 	svcls	0x003f231c
    2680:	00002346 	andeq	r2, r0, r6, asr #6
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2684:	00002350 	andeq	r2, r0, r0, asr r3
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2688:	00730008 	rsbseq	r0, r3, r8
    268c:	231c0091 	tstcs	ip, #145	; 0x91
    2690:	00009f40 	andeq	r9, r0, r0, asr #30

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2694:	00000000 	andeq	r0, r0, r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2698:	22d80000 	sbcscs	r0, r8, #0
    269c:	22dc0000 	sbcscs	r0, ip, #0

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    26a0:	00020000 	andeq	r0, r2, r0
    26a4:	22dc9f30 	sbcscs	r9, ip, #48, 30	; 0xc0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    26a8:	22e40000 	rsccs	r0, r4, #0
	c = (c >> 7) * 19;
    26ac:	00010000 	andeq	r0, r1, r0

	for (i = 0; i < F25519_SIZE; i++) {
    26b0:	0022e452 	eoreq	lr, r2, r2, asr r4
		c += r[i];
    26b4:	0022ea00 	eoreq	lr, r2, r0, lsl #20
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    26b8:	72000300 	andvc	r0, r0, #0, 6
		c += r[i];
		r[i] = c;
		c >>= 8;
    26bc:	22ea9f7f 	rsccs	r9, sl, #508	; 0x1fc
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    26c0:	230c0000 	movwcs	r0, #49152	; 0xc000
    26c4:	00010000 	andeq	r0, r1, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26c8:	00230c52 	eoreq	r0, r3, r2, asr ip
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    26cc:	00231200 	eoreq	r1, r3, r0, lsl #4
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26d0:	72000300 	andvc	r0, r0, #0, 6
    26d4:	23129f7f 	tstcs	r2, #508	; 0x1fc

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26d8:	23280000 	teqcs	r8, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    26dc:	00010000 	andeq	r0, r1, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    26e0:	00000052 	andeq	r0, r0, r2, asr r0
    26e4:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    26e8:	00235800 	eoreq	r5, r3, r0, lsl #16
    26ec:	0023a200 	eoreq	sl, r3, r0, lsl #4
    26f0:	53000100 	movwpl	r0, #256	; 0x100
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    26f4:	000023ae 	andeq	r2, r0, lr, lsr #7
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    26f8:	000023cc 	andeq	r2, r0, ip, asr #7
    26fc:	00520001 	subseq	r0, r2, r1

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2700:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) *
    2704:	58000000 	stmdapl	r0, {}	; <UNPREDICTABLE>

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2708:	ae000023 	cdpge	0, 0, cr0, cr0, cr3, {1}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    270c:	01000023 	tsteq	r0, r3, lsr #32
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2710:	23ae5500 			; <UNDEFINED> instruction: 0x23ae5500
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2714:	23b20000 			; <UNDEFINED> instruction: 0x23b20000
	c = (c >> 7) * 19;
    2718:	00020000 	andeq	r0, r2, r0
    271c:	23b29f30 			; <UNDEFINED> instruction: 0x23b29f30
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2720:	23ba0000 			; <UNDEFINED> instruction: 0x23ba0000
	c = (c >> 7) * 19;
    2724:	00010000 	andeq	r0, r1, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2728:	0023ba53 	eoreq	fp, r3, r3, asr sl
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    272c:	0023c000 	eoreq	ip, r3, r0
		r[i] = c;
    2730:	73000300 	movwvc	r0, #768	; 0x300
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2734:	23c09f7f 	biccs	r9, r0, #508	; 0x1fc
		c += r[i];
		r[i] = c;
		c >>= 8;
    2738:	23cc0000 	biccs	r0, ip, #0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    273c:	00010000 	andeq	r0, r1, r0
    2740:	00000053 	andeq	r0, r0, r3, asr r0
    2744:	00000000 	andeq	r0, r0, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2748:	00235a00 	eoreq	r5, r3, r0, lsl #20
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    274c:	00235e00 	eoreq	r5, r3, r0, lsl #28
		for (j = 0; j <= i; j++)
    2750:	30000200 	andcc	r0, r0, r0, lsl #4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2754:	00235e9f 	mlaeq	r3, pc, lr, r5	; <UNPREDICTABLE>
    2758:	00236800 	eoreq	r6, r3, r0, lsl #16

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    275c:	52000100 	andpl	r0, r0, #0, 2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2760:	00002368 	andeq	r2, r0, r8, ror #6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2764:	0000236e 	andeq	r2, r0, lr, ror #6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2768:	7f720003 	svcvc	0x00720003
    276c:	00236e9f 	mlaeq	r3, pc, lr, r6	; <UNPREDICTABLE>
    2770:	00237400 	eoreq	r7, r3, r0, lsl #8
    2774:	52000100 	andpl	r0, r0, #0, 2
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2778:	00002374 	andeq	r2, r0, r4, ror r3
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    277c:	00002382 	andeq	r2, r0, r2, lsl #7
    2780:	01720003 	cmneq	r2, r3
    2784:	0023829f 	mlaeq	r3, pc, r2, r8	; <UNPREDICTABLE>

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2788:	00238a00 	eoreq	r8, r3, r0, lsl #20
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    278c:	72000800 	andvc	r0, r0, #0, 16
    2790:	1c009100 	stfned	f1, [r0], {-0}

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2794:	8a9f4123 	bhi	fe7d2c28 <BootRAM+0xd7433c9>
    2798:	94000023 	strls	r0, [r0], #-35	; 0x23
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    279c:	08000023 	stmdaeq	r0, {r0, r1, r5}
	c = (c >> 7) * 19;
    27a0:	91007200 	mrsls	r7, R8_usr

	for (i = 0; i < F25519_SIZE; i++) {
    27a4:	40231c00 	eormi	r1, r3, r0, lsl #24
		c += r[i];
    27a8:	0023949f 	mlaeq	r3, pc, r4, r9	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27ac:	00239600 	eoreq	r9, r3, r0, lsl #12
		c += r[i];
		r[i] = c;
		c >>= 8;
    27b0:	72000800 	andvc	r0, r0, #0, 16
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    27b4:	1c009100 	stfned	f1, [r0], {-0}
    27b8:	009f4123 	addseq	r4, pc, r3, lsr #2
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27bc:	00000000 	andeq	r0, r0, r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    27c0:	cc000000 	stcgt	0, cr0, [r0], {-0}
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27c4:	d2000023 	andle	r0, r0, #35	; 0x23
    27c8:	02000023 	andeq	r0, r0, #35	; 0x23

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27cc:	d29f3000 	addsle	r3, pc, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    27d0:	2c000023 	stccs	0, cr0, [r0], {35}	; 0x23

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    27d4:	01000024 	tsteq	r0, r4, lsr #32
    27d8:	24385300 	ldrtcs	r5, [r8], #-768	; 0x300
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27dc:	24540000 	ldrbcs	r0, [r4], #-0
    27e0:	00010000 	andeq	r0, r1, r0
    27e4:	00000052 	andeq	r0, r0, r2, asr r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    27e8:	00000000 	andeq	r0, r0, r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    27ec:	0023cc00 	eoreq	ip, r3, r0, lsl #24
    27f0:	0023d200 	eoreq	sp, r3, r0, lsl #4

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27f4:	30000200 	andcc	r0, r0, r0, lsl #4
			c += ((uint32_t)a[j]) *
    27f8:	0023d29f 	mlaeq	r3, pc, r2, sp	; <UNPREDICTABLE>

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    27fc:	00243800 	eoreq	r3, r4, r0, lsl #16
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2800:	59000100 	stmdbpl	r0, {r8}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2804:	00002438 	andeq	r2, r0, r8, lsr r4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2808:	0000243e 	andeq	r2, r0, lr, lsr r4
	c = (c >> 7) * 19;
    280c:	9f300002 	svcls	0x00300002
    2810:	0000243e 	andeq	r2, r0, lr, lsr r4
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2814:	00002446 	andeq	r2, r0, r6, asr #8
	c = (c >> 7) * 19;
    2818:	00730008 	rsbseq	r0, r3, r8
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    281c:	231c0091 	tstcs	ip, #145	; 0x91
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2820:	24469f40 	strbcs	r9, [r6], #-3904	; 0xf40
		r[i] = c;
    2824:	244c0000 	strbcs	r0, [ip], #-0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2828:	00080000 	andeq	r0, r8, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    282c:	00910073 	addseq	r0, r1, r3, ror r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2830:	9f3f231c 	svcls	0x003f231c
    2834:	0000244c 	andeq	r2, r0, ip, asr #8
    2838:	00002454 	andeq	r2, r0, r4, asr r4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    283c:	00730008 	rsbseq	r0, r3, r8
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2840:	231c0091 	tstcs	ip, #145	; 0x91
		for (j = 0; j <= i; j++)
    2844:	00009f40 	andeq	r9, r0, r0, asr #30
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2848:	00000000 	andeq	r0, r0, r0
    284c:	23d40000 	bicscs	r0, r4, #0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2850:	23da0000 	bicscs	r0, sl, #0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2854:	00020000 	andeq	r0, r2, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2858:	23da9f30 	bicscs	r9, sl, #48, 30	; 0xc0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    285c:	23e40000 	mvncs	r0, #0
    2860:	00010000 	andeq	r0, r1, r0
    2864:	0023e452 	eoreq	lr, r3, r2, asr r4
    2868:	0023ea00 	eoreq	lr, r3, r0, lsl #20
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    286c:	72000300 	andvc	r0, r0, #0, 6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2870:	23ea9f7f 	mvncs	r9, #508	; 0x1fc
    2874:	24100000 	ldrcs	r0, [r0], #-0
    2878:	00010000 	andeq	r0, r1, r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    287c:	00241052 	eoreq	r1, r4, r2, asr r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2880:	00241600 	eoreq	r1, r4, r0, lsl #12
    2884:	72000300 	andvc	r0, r0, #0, 6

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2888:	24169f7f 	ldrcs	r9, [r6], #-3967	; 0xf7f
    288c:	24300000 	ldrtcs	r0, [r0], #-0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2890:	00010000 	andeq	r0, r1, r0
	c = (c >> 7) * 19;
    2894:	00000052 	andeq	r0, r0, r2, asr r0

	for (i = 0; i < F25519_SIZE; i++) {
    2898:	00000000 	andeq	r0, r0, r0
		c += r[i];
    289c:	00245400 	eoreq	r5, r4, r0, lsl #8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28a0:	0024aa00 	eoreq	sl, r4, r0, lsl #20
		c += r[i];
		r[i] = c;
		c >>= 8;
    28a4:	53000100 	movwpl	r0, #256	; 0x100
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28a8:	000024b6 			; <UNDEFINED> instruction: 0x000024b6
	f25519_mul__distinct(r, s, x);

	/* 1 */
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}
    28ac:	000024d8 	ldrdeq	r2, [r0], -r8
    28b0:	00520001 	subseq	r0, r2, r1
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    28b4:	00000000 	andeq	r0, r0, r0
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28b8:	54000000 	strpl	r0, [r0], #-0
	f25519_mul__distinct(s, r, r);
	f25519_mul__distinct(r, s, x);
}

void f25519_sqrt(uint8_t *r, const uint8_t *a)
{
    28bc:	b6000024 	strlt	r0, [r0], -r4, lsr #32
	f25519_copy(r, tmp);
}

void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
    28c0:	01000024 	tsteq	r0, r4, lsr #32
    28c4:	24b65900 	ldrtcs	r5, [r6], #2304	; 0x900
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		c >>= 8;
		c += b * ((uint32_t)a[i]);
    28c8:	24ba0000 	ldrtcs	r0, [sl], #0
    28cc:	00020000 	andeq	r0, r2, r0
void f25519_mul_c(uint8_t *r, const uint8_t *a, uint32_t b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    28d0:	24ba9f30 	ldrtcs	r9, [sl], #3888	; 0xf30
    28d4:	24c20000 	strbcs	r0, [r2], #0
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    28d8:	00010000 	andeq	r0, r1, r0
    28dc:	0024c253 	eoreq	ip, r4, r3, asr r2
	c >>= 7;
	c *= 19;
    28e0:	0024c800 	eoreq	ip, r4, r0, lsl #16
		c >>= 8;
		c += b * ((uint32_t)a[i]);
		r[i] = c;
	}

	r[31] &= 127;
    28e4:	73000300 	movwvc	r0, #768	; 0x300
	c >>= 7;
	c *= 19;
    28e8:	24c89f7f 	strbcs	r9, [r8], #3967	; 0xf7f
    28ec:	24d40000 	ldrbcs	r0, [r4], #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    28f0:	00010000 	andeq	r0, r1, r0
		r[i] = c;
    28f4:	00000053 	andeq	r0, r0, r3, asr r0

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    28f8:	00000000 	andeq	r0, r0, r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    28fc:	00245600 	eoreq	r5, r4, r0, lsl #12

	r[31] &= 127;
	c >>= 7;
	c *= 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2900:	00245c00 	eoreq	r5, r4, r0, lsl #24
    2904:	30000200 	andcc	r0, r0, r0, lsl #4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2908:	00245c9f 	mlaeq	r4, pc, ip, r5	; <UNPREDICTABLE>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    290c:	00246600 	eoreq	r6, r4, r0, lsl #12
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2910:	52000100 	andpl	r0, r0, #0, 2
    2914:	00002466 	andeq	r2, r0, r6, ror #8

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2918:	0000246c 	andeq	r2, r0, ip, ror #8
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    291c:	7f720003 	svcvc	0x00720003

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2920:	00246c9f 	mlaeq	r4, pc, ip, r6	; <UNPREDICTABLE>
    2924:	00247200 	eoreq	r7, r4, r0, lsl #4
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2928:	52000100 	andpl	r0, r0, #0, 2
    292c:	00002472 	andeq	r2, r0, r2, ror r4
    2930:	00002484 	andeq	r2, r0, r4, lsl #9
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2934:	01720003 	cmneq	r2, r3
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2938:	0024849f 	mlaeq	r4, pc, r4, r8	; <UNPREDICTABLE>
    293c:	00248c00 	eoreq	r8, r4, r0, lsl #24
    2940:	72000800 	andvc	r0, r0, #0, 16

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2944:	1c009100 	stfned	f1, [r0], {-0}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2948:	8c9f4123 	ldfhis	f4, [pc], {35}	; 0x23
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    294c:	96000024 	strls	r0, [r0], -r4, lsr #32
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2950:	08000024 	stmdaeq	r0, {r2, r5}
	c = (c >> 7) * 19;
    2954:	91007200 	mrsls	r7, R8_usr
    2958:	40231c00 	eormi	r1, r3, r0, lsl #24
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    295c:	0024969f 	mlaeq	r4, pc, r6, r9	; <UNPREDICTABLE>
	c = (c >> 7) * 19;
    2960:	00249800 	eoreq	r9, r4, r0, lsl #16
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2964:	72000800 	andvc	r0, r0, #0, 16
	c = (c >> 7) * 19;
    2968:	1c009100 	stfned	f1, [r0], {-0}

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    296c:	009f4123 	addseq	r4, pc, r3, lsr #2
		r[i] = c;
    2970:	00000000 	andeq	r0, r0, r0
		c >>= 8;
    2974:	d8000000 	stmdale	r0, {}	; <UNPREDICTABLE>
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2978:	2e000024 	cdpcs	0, 0, cr0, cr0, cr4, {1}
    297c:	01000025 	tsteq	r0, r5, lsr #32
    2980:	253a5300 	ldrcs	r5, [sl, #-768]!	; 0x300
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2984:	25560000 	ldrbcs	r0, [r6, #-0]
		for (j = 0; j <= i; j++)
    2988:	00010000 	andeq	r0, r1, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    298c:	00000052 	andeq	r0, r0, r2, asr r0
    2990:	00000000 	andeq	r0, r0, r0
    2994:	0024d800 	eoreq	sp, r4, r0, lsl #16

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2998:	00253a00 	eoreq	r3, r5, r0, lsl #20
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    299c:	5c000100 	stfpls	f0, [r0], {-0}

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    29a0:	0000253a 	andeq	r2, r0, sl, lsr r5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29a4:	00002540 	andeq	r2, r0, r0, asr #10
    29a8:	9f300002 	svcls	0x00300002
    29ac:	00002540 	andeq	r2, r0, r0, asr #10
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    29b0:	00002548 	andeq	r2, r0, r8, asr #10
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    29b4:	00730008 	rsbseq	r0, r3, r8
    29b8:	231c0091 	tstcs	ip, #145	; 0x91

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    29bc:	25489f40 	strbcs	r9, [r8, #-3904]	; 0xf40
			c += ((uint32_t)a[j]) *
    29c0:	254e0000 	strbcs	r0, [lr, #-0]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    29c4:	00080000 	andeq	r0, r8, r0
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    29c8:	00910073 	addseq	r0, r1, r3, ror r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29cc:	9f3f231c 	svcls	0x003f231c
	c = (c >> 7) * 19;
    29d0:	0000254e 	andeq	r2, r0, lr, asr #10
    29d4:	00002558 	andeq	r2, r0, r8, asr r5
    29d8:	00730008 	rsbseq	r0, r3, r8
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29dc:	231c0091 	tstcs	ip, #145	; 0x91
	c = (c >> 7) * 19;
    29e0:	00009f40 	andeq	r9, r0, r0, asr #30
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    29e4:	00000000 	andeq	r0, r0, r0
    29e8:	24da0000 	ldrbcs	r0, [sl], #0
	c = (c >> 7) * 19;
    29ec:	24e00000 	strbtcs	r0, [r0], #0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    29f0:	00020000 	andeq	r0, r2, r0
		r[i] = c;
    29f4:	24e09f30 	strbtcs	r9, [r0], #3888	; 0xf30
		c >>= 8;
    29f8:	24e80000 	strbtcs	r0, [r8], #0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    29fc:	00010000 	andeq	r0, r1, r0
    2a00:	0024e852 	eoreq	lr, r4, r2, asr r8
    2a04:	0024ee00 	eoreq	lr, r4, r0, lsl #28
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a08:	72000300 	andvc	r0, r0, #0, 6

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2a0c:	24ee9f7f 	strbtcs	r9, [lr], #3967	; 0xf7f
    2a10:	25120000 	ldrcs	r0, [r2, #-0]
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2a14:	00010000 	andeq	r0, r1, r0
		for (j = 0; j <= i; j++)
    2a18:	00251252 	eoreq	r1, r5, r2, asr r2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a1c:	00251800 	eoreq	r1, r5, r0, lsl #16
    2a20:	72000300 	andvc	r0, r0, #0, 6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a24:	25189f7f 	ldrcs	r9, [r8, #-3967]	; 0xf7f
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2a28:	25320000 	ldrcs	r0, [r2, #-0]!

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2a2c:	00010000 	andeq	r0, r1, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a30:	00000052 	andeq	r0, r0, r2, asr r0
    2a34:	00000000 	andeq	r0, r0, r0
    2a38:	00256000 	eoreq	r6, r5, r0
    2a3c:	0025ac00 	eoreq	sl, r5, r0, lsl #24
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2a40:	53000100 	movwpl	r0, #256	; 0x100
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2a44:	000025b8 			; <UNDEFINED> instruction: 0x000025b8
    2a48:	000025d4 	ldrdeq	r2, [r0], -r4

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2a4c:	00520001 	subseq	r0, r2, r1
			c += ((uint32_t)a[j]) *
    2a50:	00000000 	andeq	r0, r0, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2a54:	60000000 	andvs	r0, r0, r0
    2a58:	b8000025 	stmdalt	r0, {r0, r2, r5}
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2a5c:	01000025 	tsteq	r0, r5, lsr #32
    2a60:	25b85500 	ldrcs	r5, [r8, #1280]!	; 0x500
    2a64:	25bc0000 	ldrcs	r0, [ip, #0]!
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a68:	00020000 	andeq	r0, r2, r0
	c = (c >> 7) * 19;
    2a6c:	25bc9f30 	ldrcs	r9, [ip, #3888]!	; 0xf30
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a70:	25c40000 	strbcs	r0, [r4]
	c = (c >> 7) * 19;
    2a74:	00010000 	andeq	r0, r1, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2a78:	0025c453 	eoreq	ip, r5, r3, asr r4
	c = (c >> 7) * 19;
    2a7c:	0025ca00 	eoreq	ip, r5, r0, lsl #20

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2a80:	73000300 	movwvc	r0, #768	; 0x300
		r[i] = c;
    2a84:	25ca9f7f 	strbcs	r9, [sl, #3967]	; 0xf7f
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a88:	25d00000 	ldrbcs	r0, [r0]
		c += r[i];
		r[i] = c;
		c >>= 8;
    2a8c:	00010000 	andeq	r0, r1, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2a90:	00000053 	andeq	r0, r0, r3, asr r0
    2a94:	00000000 	andeq	r0, r0, r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2a98:	00256400 	eoreq	r6, r5, r0, lsl #8
		for (j = 0; j <= i; j++)
    2a9c:	00256800 	eoreq	r6, r5, r0, lsl #16
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2aa0:	30000200 	andcc	r0, r0, r0, lsl #4
    2aa4:	0025689f 	mlaeq	r5, pc, r8, r6	; <UNPREDICTABLE>
    2aa8:	00257200 	eoreq	r7, r5, r0, lsl #4

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2aac:	52000100 	andpl	r0, r0, #0, 2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2ab0:	00002572 	andeq	r2, r0, r2, ror r5

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2ab4:	00002578 	andeq	r2, r0, r8, ror r5
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ab8:	7f720003 	svcvc	0x00720003
    2abc:	0025789f 	mlaeq	r5, pc, r8, r7	; <UNPREDICTABLE>
    2ac0:	00257e00 	eoreq	r7, r5, r0, lsl #28
    2ac4:	52000100 	andpl	r0, r0, #0, 2
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2ac8:	0000257e 	andeq	r2, r0, lr, ror r5
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2acc:	0000258c 	andeq	r2, r0, ip, lsl #11
    2ad0:	01720003 	cmneq	r2, r3

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2ad4:	00258c9f 	mlaeq	r5, pc, ip, r8	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) *
    2ad8:	00259400 	eoreq	r9, r5, r0, lsl #8
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2adc:	72000800 	andvc	r0, r0, #0, 16
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2ae0:	1c009100 	stfned	f1, [r0], {-0}
    2ae4:	949f4123 	ldrls	r4, [pc], #291	; 2aec <f25519_sqrt+0x238>
    2ae8:	9e000025 	cdpls	0, 0, cr0, cr0, cr5, {1}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2aec:	08000025 	stmdaeq	r0, {r0, r2, r5}
	c = (c >> 7) * 19;
    2af0:	91007200 	mrsls	r7, R8_usr
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2af4:	40231c00 	eormi	r1, r3, r0, lsl #24
	c = (c >> 7) * 19;
    2af8:	00259e9f 	mlaeq	r5, pc, lr, r9	; <UNPREDICTABLE>
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2afc:	0025a000 	eoreq	sl, r5, r0
	c = (c >> 7) * 19;
    2b00:	72000800 	andvc	r0, r0, #0, 16

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2b04:	1c009100 	stfned	f1, [r0], {-0}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b08:	009f4123 	addseq	r4, pc, r3, lsr #2
		c += r[i];
		r[i] = c;
    2b0c:	00000000 	andeq	r0, r0, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b10:	d4000000 	strle	r0, [r0], #-0
		c += r[i];
		r[i] = c;
		c >>= 8;
    2b14:	24000025 	strcs	r0, [r0], #-37	; 0x25
	/* 1 1 */
	f25519_mul__distinct(r, x, x);
	f25519_mul__distinct(s, r, x);

	/* 1 x 248 */
	for (i = 0; i < 248; i++) {
    2b18:	01000026 	tsteq	r0, r6, lsr #32
    2b1c:	26305300 	ldrtcs	r5, [r0], -r0, lsl #6
    2b20:	26560000 	ldrbcs	r0, [r6], -r0
    2b24:	00010000 	andeq	r0, r1, r0
    2b28:	00000052 	andeq	r0, r0, r2, asr r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2b2c:	00000000 	andeq	r0, r0, r0
		for (j = 0; j <= i; j++)
    2b30:	0025d400 	eoreq	sp, r5, r0, lsl #8
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b34:	00263000 	eoreq	r3, r6, r0
    2b38:	56000100 	strpl	r0, [r0], -r0, lsl #2

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b3c:	00002630 	andeq	r2, r0, r0, lsr r6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2b40:	00002636 	andeq	r2, r0, r6, lsr r6

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2b44:	9f300002 	svcls	0x00300002
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b48:	00002636 	andeq	r2, r0, r6, lsr r6
    2b4c:	0000263e 	andeq	r2, r0, lr, lsr r6
    2b50:	00730008 	rsbseq	r0, r3, r8
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2b54:	231c0091 	tstcs	ip, #145	; 0x91
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2b58:	263e9f40 	ldrtcs	r9, [lr], -r0, asr #30
    2b5c:	26440000 	strbcs	r0, [r4], -r0

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2b60:	00080000 	andeq	r0, r8, r0
			c += ((uint32_t)a[j]) *
    2b64:	00910073 	addseq	r0, r1, r3, ror r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2b68:	9f3f231c 	svcls	0x003f231c
    2b6c:	00002644 	andeq	r2, r0, r4, asr #12
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2b70:	00002652 	andeq	r2, r0, r2, asr r6
    2b74:	00730008 	rsbseq	r0, r3, r8
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b78:	231c0091 	tstcs	ip, #145	; 0x91
	c = (c >> 7) * 19;
    2b7c:	00009f40 	andeq	r9, r0, r0, asr #30
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b80:	00000000 	andeq	r0, r0, r0
	c = (c >> 7) * 19;
    2b84:	25d60000 	ldrbcs	r0, [r6]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2b88:	25da0000 	ldrbcs	r0, [sl]
	c = (c >> 7) * 19;
    2b8c:	00020000 	andeq	r0, r2, r0

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2b90:	25da9f30 	ldrbcs	r9, [sl, #3888]	; 0xf30
		r[i] = c;
    2b94:	25e40000 	strbcs	r0, [r4, #0]!
		c >>= 8;
    2b98:	00010000 	andeq	r0, r1, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2b9c:	0025e452 	eoreq	lr, r5, r2, asr r4
    2ba0:	0025ea00 	eoreq	lr, r5, r0, lsl #20
    2ba4:	72000300 	andvc	r0, r0, #0, 6
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ba8:	25ea9f7f 	strbcs	r9, [sl, #3967]!	; 0xf7f
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2bac:	260c0000 	strcs	r0, [ip], -r0
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2bb0:	00010000 	andeq	r0, r1, r0
    2bb4:	00260c52 	eoreq	r0, r6, r2, asr ip
    2bb8:	00261200 	eoreq	r1, r6, r0, lsl #4

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2bbc:	72000300 	andvc	r0, r0, #0, 6
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2bc0:	26129f7f 	ssub16cs	r9, r2, pc	; <UNPREDICTABLE>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2bc4:	26280000 	strtcs	r0, [r8], -r0
    2bc8:	00010000 	andeq	r0, r1, r0
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2bcc:	00000052 	andeq	r0, r0, r2, asr r0
    2bd0:	00000000 	andeq	r0, r0, r0
    2bd4:	00265600 	eoreq	r5, r6, r0, lsl #12
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2bd8:	0026a200 	eoreq	sl, r6, r0, lsl #4
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2bdc:	53000100 	movwpl	r0, #256	; 0x100
    2be0:	000026ae 	andeq	r2, r0, lr, lsr #13
    2be4:	000026ca 	andeq	r2, r0, sl, asr #13

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2be8:	00520001 	subseq	r0, r2, r1
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2bec:	00000000 	andeq	r0, r0, r0
    2bf0:	56000000 	strpl	r0, [r0], -r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bf4:	ae000026 	cdpge	0, 0, cr0, cr0, cr6, {1}
	c = (c >> 7) * 19;
    2bf8:	01000026 	tsteq	r0, r6, lsr #32
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2bfc:	26ae5500 	strtcs	r5, [lr], r0, lsl #10
	c = (c >> 7) * 19;
    2c00:	26b20000 	ldrtcs	r0, [r2], r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c04:	00020000 	andeq	r0, r2, r0
	c = (c >> 7) * 19;
    2c08:	26b29f30 			; <UNDEFINED> instruction: 0x26b29f30

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2c0c:	26ba0000 	ldrtcs	r0, [sl], r0
		r[i] = c;
    2c10:	00010000 	andeq	r0, r1, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c14:	0026ba53 	eoreq	fp, r6, r3, asr sl
		c += r[i];
		r[i] = c;
		c >>= 8;
    2c18:	0026c000 	eoreq	ip, r6, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c1c:	73000300 	movwvc	r0, #768	; 0x300
    2c20:	26c09f7f 			; <UNDEFINED> instruction: 0x26c09f7f
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c24:	26c60000 	strbcs	r0, [r6], r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2c28:	00010000 	andeq	r0, r1, r0
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c2c:	00000053 	andeq	r0, r0, r3, asr r0
    2c30:	00000000 	andeq	r0, r0, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c34:	00265a00 	eoreq	r5, r6, r0, lsl #20
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2c38:	00265e00 	eoreq	r5, r6, r0, lsl #28

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2c3c:	30000200 	andcc	r0, r0, r0, lsl #4
    2c40:	00265e9f 	mlaeq	r6, pc, lr, r5	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c44:	00266800 	eoreq	r6, r6, r0, lsl #16
    2c48:	52000100 	andpl	r0, r0, #0, 2
    2c4c:	00002668 	andeq	r2, r0, r8, ror #12
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2c50:	0000266e 	andeq	r2, r0, lr, ror #12
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c54:	7f720003 	svcvc	0x00720003
    2c58:	00266e9f 	mlaeq	r6, pc, lr, r6	; <UNPREDICTABLE>
    2c5c:	00267400 	eoreq	r7, r6, r0, lsl #8

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2c60:	52000100 	andpl	r0, r0, #0, 2
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2c64:	00002674 	andeq	r2, r0, r4, ror r6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2c68:	00002682 	andeq	r2, r0, r2, lsl #13
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c6c:	01720003 	cmneq	r2, r3
	c = (c >> 7) * 19;
    2c70:	0026829f 	mlaeq	r6, pc, r2, r8	; <UNPREDICTABLE>
    2c74:	00268a00 	eoreq	r8, r6, r0, lsl #20
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c78:	72000800 	andvc	r0, r0, #0, 16
	c = (c >> 7) * 19;
    2c7c:	1c009100 	stfned	f1, [r0], {-0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2c80:	8a9f4123 	bhi	fe7d3114 <BootRAM+0xd7438b5>
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2c84:	94000026 	strls	r0, [r0], #-38	; 0x26
		r[i] = c;
    2c88:	08000026 	stmdaeq	r0, {r1, r2, r5}
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c8c:	91007200 	mrsls	r7, R8_usr
		c += r[i];
		r[i] = c;
		c >>= 8;
    2c90:	40231c00 	eormi	r1, r3, r0, lsl #24
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2c94:	0026949f 	mlaeq	r6, pc, r4, r9	; <UNPREDICTABLE>
    2c98:	00269600 	eoreq	r9, r6, r0, lsl #12
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2c9c:	72000800 	andvc	r0, r0, #0, 16
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2ca0:	1c009100 	stfned	f1, [r0], {-0}
		for (j = 0; j <= i; j++)
    2ca4:	009f4123 	addseq	r4, pc, r3, lsr #2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2ca8:	00000000 	andeq	r0, r0, r0
    2cac:	ca000000 	bgt	2cb4 <f25519_sqrt+0x400>
    2cb0:	1a000026 	bne	2d50 <f25519_sqrt+0x49c>

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2cb4:	01000027 	tsteq	r0, r7, lsr #32
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2cb8:	27265300 	strcs	r5, [r6, -r0, lsl #6]!

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2cbc:	274c0000 	strbcs	r0, [ip, -r0]
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cc0:	00010000 	andeq	r0, r1, r0
    2cc4:	00000052 	andeq	r0, r0, r2, asr r0
    2cc8:	00000000 	andeq	r0, r0, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2ccc:	0026ca00 	eoreq	ip, r6, r0, lsl #20
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2cd0:	00272600 	eoreq	r2, r7, r0, lsl #12
    2cd4:	56000100 	strpl	r0, [r0], -r0, lsl #2

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2cd8:	00002726 	andeq	r2, r0, r6, lsr #14
			c += ((uint32_t)a[j]) *
    2cdc:	0000272c 	andeq	r2, r0, ip, lsr #14
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2ce0:	9f300002 	svcls	0x00300002
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2ce4:	0000272c 	andeq	r2, r0, ip, lsr #14
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2ce8:	00002734 	andeq	r2, r0, r4, lsr r7
	c = (c >> 7) * 19;
    2cec:	00730008 	rsbseq	r0, r3, r8
    2cf0:	231c0091 	tstcs	ip, #145	; 0x91
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2cf4:	27349f40 	ldrcs	r9, [r4, -r0, asr #30]!
    2cf8:	273a0000 	ldrcs	r0, [sl, -r0]!
	c = (c >> 7) * 19;
    2cfc:	00080000 	andeq	r0, r8, r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d00:	00910073 	addseq	r0, r1, r3, ror r0
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2d04:	9f3f231c 	svcls	0x003f231c
		r[i] = c;
    2d08:	0000273a 	andeq	r2, r0, sl, lsr r7
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d0c:	00002748 	andeq	r2, r0, r8, asr #14
		c += r[i];
		r[i] = c;
		c >>= 8;
    2d10:	00730008 	rsbseq	r0, r3, r8
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d14:	231c0091 	tstcs	ip, #145	; 0x91
    2d18:	00009f40 	andeq	r9, r0, r0, asr #30
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d1c:	00000000 	andeq	r0, r0, r0
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2d20:	26cc0000 	strbcs	r0, [ip], r0
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d24:	26d00000 	ldrbcs	r0, [r0], r0
    2d28:	00020000 	andeq	r0, r2, r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d2c:	26d09f30 			; <UNDEFINED> instruction: 0x26d09f30
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2d30:	26da0000 	ldrbcs	r0, [sl], r0

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2d34:	00010000 	andeq	r0, r1, r0
    2d38:	0026da52 	eoreq	sp, r6, r2, asr sl
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d3c:	0026e000 	eoreq	lr, r6, r0
    2d40:	72000300 	andvc	r0, r0, #0, 6
    2d44:	26e09f7f 			; <UNDEFINED> instruction: 0x26e09f7f
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2d48:	27020000 	strcs	r0, [r2, -r0]
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2d4c:	00010000 	andeq	r0, r1, r0
    2d50:	00270252 	eoreq	r0, r7, r2, asr r2
    2d54:	00270800 	eoreq	r0, r7, r0, lsl #16

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2d58:	72000300 	andvc	r0, r0, #0, 6
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2d5c:	27089f7f 	smlsdxcs	r8, pc, pc, r9	; <UNPREDICTABLE>
    2d60:	271e0000 	ldrcs	r0, [lr, -r0]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d64:	00010000 	andeq	r0, r1, r0
	c = (c >> 7) * 19;
    2d68:	00000052 	andeq	r0, r0, r2, asr r0
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d6c:	00000000 	andeq	r0, r0, r0
	c = (c >> 7) * 19;
    2d70:	00274c00 	eoreq	r4, r7, r0, lsl #24
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2d74:	00279600 	eoreq	r9, r7, r0, lsl #12
	c = (c >> 7) * 19;
    2d78:	53000100 	movwpl	r0, #256	; 0x100

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2d7c:	000027a2 	andeq	r2, r0, r2, lsr #15
		r[i] = c;
    2d80:	000027be 			; <UNDEFINED> instruction: 0x000027be
		c >>= 8;
    2d84:	00520001 	subseq	r0, r2, r1
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2d88:	00000000 	andeq	r0, r0, r0
void f25519_load(uint8_t *x, uint32_t c)
{
	int i;

	for (i = 0; i < sizeof(c); i++) {
		x[i] = c;
    2d8c:	4c000000 	stcmi	0, cr0, [r0], {-0}
    2d90:	a2000027 	andge	r0, r0, #39	; 0x27
    2d94:	01000027 	tsteq	r0, r7, lsr #32
    2d98:	27a25500 	strcs	r5, [r2, r0, lsl #10]!
    2d9c:	27a60000 	strcs	r0, [r6, r0]!
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
    2da0:	00020000 	andeq	r0, r2, r0
    2da4:	27a69f30 			; <UNDEFINED> instruction: 0x27a69f30
    2da8:	27ae0000 	strcs	r0, [lr, r0]!
		r[i] = c;
    2dac:	00010000 	andeq	r0, r1, r0
	uint32_t c = 0;
	int i;

	/* Calculate a + 2p - b, to avoid underflow */
	c = 218;
	for (i = 0; i + 1 < F25519_SIZE; i++) {
    2db0:	0027ae53 	eoreq	sl, r7, r3, asr lr
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
    2db4:	0027b400 	eoreq	fp, r7, r0, lsl #8
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2db8:	73000300 	movwvc	r0, #768	; 0x300
    2dbc:	27b49f7f 			; <UNDEFINED> instruction: 0x27b49f7f
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2dc0:	27ba0000 	ldrcs	r0, [sl, r0]!
		c += 65280 + ((uint32_t)a[i]) - ((uint32_t)b[i]);
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
    2dc4:	00010000 	andeq	r0, r1, r0
	r[31] = c & 127;
	c = (c >> 7) * 19;
    2dc8:	00000053 	andeq	r0, r0, r3, asr r0
		r[i] = c;
		c >>= 8;
	}

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
    2dcc:	00000000 	andeq	r0, r0, r0
    2dd0:	00274e00 	eoreq	r4, r7, r0, lsl #28
	c = (c >> 7) * 19;
    2dd4:	00275200 	eoreq	r5, r7, r0, lsl #4

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2dd8:	30000200 	andcc	r0, r0, r0, lsl #4
		r[i] = c;
    2ddc:	0027529f 	mlaeq	r7, pc, r2, r5	; <UNPREDICTABLE>

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2de0:	00275c00 	eoreq	r5, r7, r0, lsl #24
		c += r[i];
		r[i] = c;
		c >>= 8;
    2de4:	52000100 	andpl	r0, r0, #0, 2

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2de8:	0000275c 	andeq	r2, r0, ip, asr r7
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2dec:	00002762 	andeq	r2, r0, r2, ror #14

	c += ((uint32_t)a[31]) - ((uint32_t)b[31]);
	r[31] = c & 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2df0:	7f720003 	svcvc	0x00720003
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2df4:	0027629f 	mlaeq	r7, pc, r2, r6	; <UNPREDICTABLE>
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2df8:	00276800 	eoreq	r6, r7, r0, lsl #16
		for (j = 0; j <= i; j++)
    2dfc:	52000100 	andpl	r0, r0, #0, 2
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e00:	00002768 	andeq	r2, r0, r8, ror #14
    2e04:	00002776 	andeq	r2, r0, r6, ror r7
    2e08:	01720003 	cmneq	r2, r3

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e0c:	0027769f 	mlaeq	r7, pc, r6, r7	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e10:	00277e00 	eoreq	r7, r7, r0, lsl #28

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e14:	72000800 	andvc	r0, r0, #0, 16
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e18:	1c009100 	stfned	f1, [r0], {-0}
    2e1c:	7e9f4123 	fmlvcep	f4, f7, f3
    2e20:	88000027 	stmdahi	r0, {r0, r1, r2, r5}
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2e24:	08000027 	stmdaeq	r0, {r0, r1, r2, r5}
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2e28:	91007200 	mrsls	r7, R8_usr
    2e2c:	40231c00 	eormi	r1, r3, r0, lsl #24

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e30:	0027889f 	mlaeq	r7, pc, r8, r8	; <UNPREDICTABLE>
			c += ((uint32_t)a[j]) *
    2e34:	00278a00 	eoreq	r8, r7, r0, lsl #20
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2e38:	72000800 	andvc	r0, r0, #0, 16
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2e3c:	1c009100 	stfned	f1, [r0], {-0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e40:	009f4123 	addseq	r4, pc, r3, lsr #2
	c = (c >> 7) * 19;
    2e44:	00000000 	andeq	r0, r0, r0
    2e48:	be000000 	cdplt	0, 0, cr0, cr0, cr0, {0}
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e4c:	0e000027 	cdpeq	0, 0, cr0, cr0, cr7, {1}
	c = (c >> 7) * 19;
    2e50:	01000028 	tsteq	r0, r8, lsr #32
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2e54:	281a5300 	ldmdacs	sl, {r8, r9, ip, lr}
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
		c += r[i];
    2e58:	28360000 	ldmdacs	r6!, {}	; <UNPREDICTABLE>
		r[i] = c;
    2e5c:	00010000 	andeq	r0, r1, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e60:	00000052 	andeq	r0, r0, r2, asr r0
		c += r[i];
		r[i] = c;
		c >>= 8;
    2e64:	00000000 	andeq	r0, r0, r0
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2e68:	0027be00 	eoreq	fp, r7, r0, lsl #28
    2e6c:	00281a00 	eoreq	r1, r8, r0, lsl #20
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2e70:	56000100 	strpl	r0, [r0], -r0, lsl #2
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
    2e74:	0000281a 	andeq	r2, r0, sl, lsl r8
		for (j = 0; j <= i; j++)
    2e78:	00002820 	andeq	r2, r0, r0, lsr #16
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e7c:	9f300002 	svcls	0x00300002

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e80:	00002820 	andeq	r2, r0, r0, lsr #16
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);
    2e84:	00002828 	andeq	r2, r0, r8, lsr #16

	for (i = 0; i < F25519_SIZE; i++) {
		int j;

		c >>= 8;
		for (j = 0; j <= i; j++)
    2e88:	00730008 	rsbseq	r0, r3, r8
    2e8c:	231c0091 	tstcs	ip, #145	; 0x91
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2e90:	28289f40 	stmdacs	r8!, {r6, r8, r9, sl, fp, ip, pc}
    2e94:	282e0000 	stmdacs	lr!, {}	; <UNPREDICTABLE>
    2e98:	00080000 	andeq	r0, r8, r0
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;
    2e9c:	00910073 	addseq	r0, r1, r3, ror r0
		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
			c += ((uint32_t)a[j]) *
    2ea0:	9f3f231c 	svcls	0x003f231c
    2ea4:	0000282e 	andeq	r2, r0, lr, lsr #16
    2ea8:	00002838 	andeq	r2, r0, r8, lsr r8

		c >>= 8;
		for (j = 0; j <= i; j++)
			c += ((uint32_t)a[j]) * ((uint32_t)b[i - j]);

		for (; j < F25519_SIZE; j++)
    2eac:	00730008 	rsbseq	r0, r3, r8
			c += ((uint32_t)a[j]) *
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
    2eb0:	231c0091 	tstcs	ip, #145	; 0x91
void f25519_mul__distinct(uint8_t *r, const uint8_t *a, const uint8_t *b)
{
	uint32_t c = 0;
	int i;

	for (i = 0; i < F25519_SIZE; i++) {
    2eb4:	00009f40 	andeq	r9, r0, r0, asr #30

		r[i] = c;
	}

	r[31] &= 127;
	c = (c >> 7) * 19;
    2eb8:	00000000 	andeq	r0, r0, r0
    2ebc:	27c00000 	strbcs	r0, [r0, r0]
    2ec0:	27c40000 	strbcs	r0, [r4, r0]
			     ((uint32_t)b[i + F25519_SIZE - j]) * 38;

		r[i] = c;
	}

	r[31] &= 127;
    2ec4:	00020000 	andeq	r0, r2, r0
    2ec8:	27c49f30 			; <UNDEFINED> instruction: 0x27c49f30
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2ecc:	27ce0000 	strbcs	r0, [lr, r0]
		c += r[i];
    2ed0:	00010000 	andeq	r0, r1, r0
		r[i] = c;
    2ed4:	0027ce52 	eoreq	ip, r7, r2, asr lr
	}

	r[31] &= 127;
	c = (c >> 7) * 19;

	for (i = 0; i < F25519_SIZE; i++) {
    2ed8:	0027d400 	eoreq	sp, r7, r0, lsl #8
		c += r[i];
		r[i] = c;
		c >>= 8;
    2edc:	72000300 	andvc	r0, r0, #0, 6
	f25519_sub(i, i, y);

	/* r = avi */
	f25519_mul__distinct(x, v, a);
	f25519_mul__distinct(r, x, i);
}
    2ee0:	27d49f7f 			; <UNDEFINED> instruction: 0x27d49f7f
    2ee4:	27f60000 	ldrbcs	r0, [r6, r0]!
}

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
    2ee8:	00010000 	andeq	r0, r1, r0
    2eec:	0027f652 	eoreq	pc, r7, r2, asr r6	; <UNPREDICTABLE>
    2ef0:	0027fc00 	eoreq	pc, r7, r0, lsl #24
    2ef4:	72000300 	andvc	r0, r0, #0, 6
static int prime_msb(const uint8_t *p)
{
	int i;
	uint8_t x;

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
    2ef8:	27fc9f7f 			; <UNDEFINED> instruction: 0x27fc9f7f
    2efc:	28120000 	ldmdacs	r2, {}	; <UNPREDICTABLE>
    2f00:	00010000 	andeq	r0, r1, r0
		if (p[i])
    2f04:	00000052 	andeq	r0, r0, r2, asr r0
			break;

	x = p[i];
	i <<= 3;
    2f08:	00000000 	andeq	r0, r0, r0

	while (x) {
		x >>= 1;
		i++;
    2f0c:	00284000 	eoreq	r4, r8, r0
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    2f10:	00288a00 	eoreq	r8, r8, r0, lsl #20

void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
    2f14:	53000100 	movwpl	r0, #256	; 0x100
		x[i] = 0;
}

static inline int min_int(int a, int b)
{
	return a < b ? a : b;
    2f18:	00002896 	muleq	r0, r6, r8
    2f1c:	000028b2 			; <UNDEFINED> instruction: 0x000028b2
void fprime_from_bytes(uint8_t *n,
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
    2f20:	00520001 	subseq	r0, r2, r1
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);
    2f24:	00000000 	andeq	r0, r0, r0
    2f28:	40000000 	andmi	r0, r0, r0
    2f2c:	96000028 	strls	r0, [r0], -r8, lsr #32

	for (i = 0; i < preload_bytes; i++)
    2f30:	01000028 	tsteq	r0, r8, lsr #32
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
	const int rbits = (len << 3) - preload_total;
    2f34:	28965500 	ldmcs	r6, {r8, sl, ip, lr}
		       const uint8_t *x, size_t len,
		       const uint8_t *modulus)
{
	const int preload_total = min_int(prime_msb(modulus) - 1, len << 3);
	const int preload_bytes = preload_total >> 3;
	const int preload_bits = preload_total & 7;
    2f38:	289a0000 	ldmcs	sl, {}	; <UNPREDICTABLE>
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f3c:	00020000 	andeq	r0, r2, r0
    2f40:	289a9f30 	ldmcs	sl, {r4, r5, r8, r9, sl, fp, ip, pc}
    2f44:	28a20000 	stmiacs	r2!, {}	; <UNPREDICTABLE>
    2f48:	00010000 	andeq	r0, r1, r0
    2f4c:	0028a253 	eoreq	sl, r8, r3, asr r2
    2f50:	0028a800 	eoreq	sl, r8, r0, lsl #16
    2f54:	73000300 	movwvc	r0, #768	; 0x300
    2f58:	28a89f7f 	stmiacs	r8!, {r0, r1, r2, r3, r4, r5, r6, r8, r9, sl, fp, ip, pc}
    2f5c:	28b20000 	ldmcs	r2!, {}	; <UNPREDICTABLE>
    2f60:	00010000 	andeq	r0, r1, r0
    2f64:	00000053 	andeq	r0, r0, r3, asr r0
    2f68:	00000000 	andeq	r0, r0, r0
    2f6c:	00284200 	eoreq	r4, r8, r0, lsl #4
    2f70:	00284600 	eoreq	r4, r8, r0, lsl #12
    2f74:	30000200 	andcc	r0, r0, r0, lsl #4
    2f78:	0028469f 	mlaeq	r8, pc, r6, r4	; <UNPREDICTABLE>
    2f7c:	00285000 	eoreq	r5, r8, r0
		n[i] = x[len - preload_bytes + i];
    2f80:	52000100 	andpl	r0, r0, #0, 2
    2f84:	00002850 	andeq	r2, r0, r0, asr r8
    2f88:	00002856 	andeq	r2, r0, r6, asr r8
    2f8c:	7f720003 	svcvc	0x00720003
    2f90:	0028569f 	mlaeq	r8, pc, r6, r5	; <UNPREDICTABLE>
    2f94:	00285c00 	eoreq	r5, r8, r0, lsl #24
    2f98:	52000100 	andpl	r0, r0, #0, 2
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2f9c:	0000285c 	andeq	r2, r0, ip, asr r8
		n[i] = x[len - preload_bytes + i];
    2fa0:	0000286a 	andeq	r2, r0, sl, ror #16
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fa4:	01720003 	cmneq	r2, r3
		n[i] = x[len - preload_bytes + i];
    2fa8:	00286a9f 	mlaeq	r8, pc, sl, r6	; <UNPREDICTABLE>
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    2fac:	00287200 	eoreq	r7, r8, r0, lsl #4
    2fb0:	72000800 	andvc	r0, r0, #0, 16
    2fb4:	1c009100 	stfned	f1, [r0], {-0}
		n[i] = x[len - preload_bytes + i];
    2fb8:	729f4123 	addsvc	r4, pc, #-1073741816	; 0xc0000008
    2fbc:	7c000028 	stcvc	0, cr0, [r0], {40}	; 0x28
    2fc0:	08000028 	stmdaeq	r0, {r3, r5}

	if (preload_bits) {
    2fc4:	91007200 	mrsls	r7, R8_usr
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c |= ((uint16_t)x[i]) << n;
    2fc8:	40231c00 	eormi	r1, r3, r0, lsl #24
    2fcc:	00287c9f 	mlaeq	r8, pc, ip, r7	; <UNPREDICTABLE>
		x[i] = c;
    2fd0:	00287e00 	eoreq	r7, r8, r0, lsl #28
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    2fd4:	72000800 	andvc	r0, r0, #0, 16
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    2fd8:	1c009100 	stfned	f1, [r0], {-0}
	for (i = 0; i < preload_bytes; i++)
		n[i] = x[len - preload_bytes + i];

	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
    2fdc:	009f4123 	addseq	r4, pc, r3, lsr #2
	...
    2fec:	01000000 	mrseq	r0, (UNDEF: 0)
    2ff0:	00005000 	andeq	r5, r0, r0
	}

	for (i = rbits - 1; i >= 0; i--) {
    2ff4:	00000000 	andeq	r0, r0, r0
    2ff8:	00010000 	andeq	r0, r1, r0
		const uint8_t bit = (x[i >> 3] >> (i & 7)) & 1;
    2ffc:	00000055 	andeq	r0, r0, r5, asr r0
	...
static void shift_n_bits(uint8_t *x, int n)
{
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    300c:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    3018:	01f30004 	mvnseq	r0, r4
		c |= ((uint16_t)x[i]) << n;
		x[i] = c;
		c >>= 8;
    301c:	00009f51 	andeq	r9, r0, r1, asr pc
	...
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
    302c:	00010000 	andeq	r0, r1, r0
    3030:	0000005d 	andeq	r0, r0, sp, asr r0
		minusp[i] = c;
    3034:	00000000 	andeq	r0, r0, r0
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3038:	74000300 	strvc	r0, [r0], #-768	; 0x300
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
    303c:	00009f60 	andeq	r9, r0, r0, ror #30
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
    3040:	00000000 	andeq	r0, r0, r0

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
    3044:	28b40000 	ldmcs	r4!, {}	; <UNPREDICTABLE>
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
    3048:	28c60000 	stmiacs	r6, {}^	; <UNPREDICTABLE>
    304c:	00010000 	andeq	r0, r1, r0
    3050:	0028c650 	eoreq	ip, r8, r0, asr r6
    3054:	002ee600 	eoreq	lr, lr, r0, lsl #12
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
    3058:	91000300 	mrsls	r0, LR_irq
	if (preload_bits) {
		shift_n_bits(n, preload_bits);
		n[0] |= x[len - preload_bytes - 1] >> (8 - preload_bits);
	}

	for (i = rbits - 1; i >= 0; i--) {
    305c:	2ee67ed8 	mcrcs	14, 7, r7, cr6, cr8, {6}
    3060:	2ee80000 	cdpcs	0, 14, cr0, cr8, cr0, {0}

		shift_n_bits(n, 1);
		n[0] |= bit;
		raw_try_sub(n, modulus);
	}
}
    3064:	00030000 	andeq	r0, r3, r0

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
    3068:	007ed87d 	rsbseq	sp, lr, sp, ror r8
	i <<= 3;

	while (x) {
    306c:	00000000 	andeq	r0, r0, r0
	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
	i <<= 3;
    3070:	b4000000 	strlt	r0, [r0], #-0
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    3074:	c6000028 	strgt	r0, [r0], -r8, lsr #32
		n[i] = x[len - preload_bytes + i];
    3078:	01000028 	tsteq	r0, r8, lsr #32
	const int rbits = (len << 3) - preload_total;
	int i;

	memset(n, 0, FPRIME_SIZE);

	for (i = 0; i < preload_bytes; i++)
    307c:	28c65100 	stmiacs	r6, {r8, ip, lr}^
    3080:	28ee0000 	stmiacs	lr!, {}^	; <UNPREDICTABLE>
			break;

	x = p[i];
	i <<= 3;

	while (x) {
    3084:	00010000 	andeq	r0, r1, r0
    (b)[(i) + 2] = (uint8) ( (n) >>  8 );       \
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    3088:	0028ee50 	eoreq	lr, r8, r0, asr lr
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    308c:	002ee600 	eoreq	lr, lr, r0, lsl #12
void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    3090:	91000300 	mrsls	r0, LR_irq
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    3094:	2ee67edc 	mcrcs	14, 7, r7, cr6, cr12, {6}
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    3098:	2ee80000 	cdpcs	0, 14, cr0, cr8, cr0, {0}
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    309c:	00030000 	andeq	r0, r3, r0
    (b)[(i) + 3] = (uint8) ( (n)       );       \
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    30a0:	007edc7d 	rsbseq	sp, lr, sp, ror ip
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    30a4:	00000000 	andeq	r0, r0, r0
    ctx->state[1] = 0xBB67AE85;
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    30a8:	c0000000 	andgt	r0, r0, r0
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    30ac:	c6000028 	strgt	r0, [r0], -r8, lsr #32
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;

    ctx->state[0] = 0x6A09E667;
    ctx->state[1] = 0xBB67AE85;
    30b0:	01000028 	tsteq	r0, r8, lsr #32
    ctx->state[2] = 0x3C6EF372;
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
    30b4:	28c65100 	stmiacs	r6, {r8, ip, lr}^
}

void sha256_starts( sha256_context *ctx )
{
    ctx->total[0] = 0;
    ctx->total[1] = 0;
    30b8:	28ee0000 	stmiacs	lr!, {}^	; <UNPREDICTABLE>
    ctx->state[3] = 0xA54FF53A;
    ctx->state[4] = 0x510E527F;
    ctx->state[5] = 0x9B05688C;
    ctx->state[6] = 0x1F83D9AB;
    ctx->state[7] = 0x5BE0CD19;
}
    30bc:	00010000 	andeq	r0, r1, r0
    30c0:	0028ee50 	eoreq	lr, r8, r0, asr lr
    30c4:	002ee600 	eoreq	lr, lr, r0, lsl #12
    30c8:	91000300 	mrsls	r0, LR_irq
    30cc:	2ee67edc 	mcrcs	14, 7, r7, cr6, cr12, {6}
    30d0:	2ee80000 	cdpcs	0, 14, cr0, cr8, cr0, {0}
    30d4:	00030000 	andeq	r0, r3, r0
    30d8:	007edc7d 	rsbseq	sp, lr, sp, ror ip
    30dc:	00000000 	andeq	r0, r0, r0

void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    30e0:	bc000000 	stclt	0, cr0, [r0], {-0}
    30e4:	c4000028 	strgt	r0, [r0], #-40	; 0x28
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    30e8:	04000028 	streq	r0, [r0], #-40	; 0x28
    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    30ec:	7fa09100 	svcvc	0x00a09100
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    30f0:	0028c49f 	mlaeq	r8, pc, r4, ip	; <UNPREDICTABLE>
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    30f4:	002ee600 	eoreq	lr, lr, r0, lsl #12
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    30f8:	56000100 	strpl	r0, [r0], -r0, lsl #2
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    30fc:	00002ee6 	andeq	r2, r0, r6, ror #29
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3100:	00002ee8 	andeq	r2, r0, r8, ror #29
    B = ctx->state[1];
    C = ctx->state[2];
    D = ctx->state[3];
    E = ctx->state[4];
    F = ctx->state[5];
    3104:	a07d0004 	rsbsge	r0, sp, r4
    temp1 = h + S3(e) + F1(e,f,g) + K + x;      \
    temp2 = S2(a) + F0(a,b,c);                  \
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    3108:	00009f7f 	andeq	r9, r0, pc, ror pc
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    310c:	00000000 	andeq	r0, r0, r0
    3110:	28c00000 	stmiacs	r0, {}^	; <UNPREDICTABLE>
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3114:	28c60000 	stmiacs	r6, {}^	; <UNPREDICTABLE>
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3118:	00020000 	andeq	r0, r2, r0
    311c:	28c69f30 	stmiacs	r6, {r4, r5, r8, r9, sl, fp, ip, pc}^
    3120:	28ce0000 	stmiacs	lr, {}^	; <UNPREDICTABLE>
    d += temp1; h = temp1 + temp2;              \
}

    A = ctx->state[0];
    B = ctx->state[1];
    C = ctx->state[2];
    3124:	00050000 	andeq	r0, r5, r0
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3128:	25380072 	ldrcs	r0, [r8, #-114]!	; 0x72
    312c:	0028ce9f 	mlaeq	r8, pc, lr, ip	; <UNPREDICTABLE>
    3130:	00290a00 	eoreq	r0, r9, r0, lsl #20
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3134:	52000100 	andpl	r0, r0, #0, 2
	...
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3140:	000028c0 	andeq	r2, r0, r0, asr #17
    3144:	000028c6 	andeq	r2, r0, r6, asr #17
    3148:	9f300002 	svcls	0x00300002
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    314c:	000028c6 	andeq	r2, r0, r6, asr #17
    3150:	000028da 	ldrdeq	r2, [r0], -sl
    3154:	ec530001 	mrrc	0, 0, r0, r3, cr1
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3158:	f0000028 			; <UNDEFINED> instruction: 0xf0000028
    315c:	02000028 	andeq	r0, r0, #40	; 0x28
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3160:	f09f3000 			; <UNDEFINED> instruction: 0xf09f3000
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3164:	f8000028 			; <UNDEFINED> instruction: 0xf8000028
    3168:	08000028 	stmdaeq	r0, {r3, r5}
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    316c:	91007300 	mrsls	r7, LR_irq
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3170:	60231c00 	eorvs	r1, r3, r0, lsl #24
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3174:	0028f89f 	mlaeq	r8, pc, r8, pc	; <UNPREDICTABLE>
void sha256_process( sha256_context *ctx, uint8 data[64] )
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    3178:	0028fe00 	eoreq	pc, r8, r0, lsl #28
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    317c:	73000800 	movwvc	r0, #2048	; 0x800
    3180:	1c009100 	stfned	f1, [r0], {-0}
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3184:	fe9f5f23 	cdp2	15, 9, cr5, cr15, cr3, {1}
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3188:	04000028 	streq	r0, [r0], #-40	; 0x28
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    318c:	08000029 	stmdaeq	r0, {r0, r3, r5}
    3190:	91007300 	mrsls	r7, LR_irq
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    3194:	60231c00 	eorvs	r1, r3, r0, lsl #24
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    3198:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    319c:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31a0:	00290a00 	eoreq	r0, r9, r0, lsl #20
{
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    31a4:	00295600 	eoreq	r5, r9, r0, lsl #12
    E = ctx->state[4];
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    31a8:	53000100 	movwpl	r0, #256	; 0x100
    31ac:	00002962 	andeq	r2, r0, r2, ror #18
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31b0:	00002984 	andeq	r2, r0, r4, lsl #19
    31b4:	00520001 	subseq	r0, r2, r1
    31b8:	00000000 	andeq	r0, r0, r0
    31bc:	0a000000 	beq	31c4 <sha256_process+0xe4>
    31c0:	62000029 	andvs	r0, r0, #41	; 0x29
    31c4:	01000029 	tsteq	r0, r9, lsr #32
    31c8:	29625400 	stmdbcs	r2!, {sl, ip, lr}^
    31cc:	296a0000 	stmdbcs	sl!, {}^	; <UNPREDICTABLE>
    31d0:	00020000 	andeq	r0, r2, r0
    31d4:	296a9f30 	stmdbcs	sl!, {r4, r5, r8, r9, sl, fp, ip, pc}^
    31d8:	29720000 	ldmdbcs	r2!, {}^	; <UNPREDICTABLE>
    31dc:	00090000 	andeq	r0, r9, r0
    31e0:	00910073 	addseq	r0, r1, r3, ror r0
    31e4:	01a0231c 	lsleq	r2, ip, r3
    31e8:	0029729f 	mlaeq	r9, pc, r2, r7	; <UNPREDICTABLE>
    31ec:	00297800 	eoreq	r7, r9, r0, lsl #16
    31f0:	73000900 	movwvc	r0, #2304	; 0x900
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    31f4:	1c009100 	stfned	f1, [r0], {-0}
    F = ctx->state[5];
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    31f8:	9f019f23 	svcls	0x00019f23
    31fc:	00002978 	andeq	r2, r0, r8, ror r9
    3200:	0000297e 	andeq	r2, r0, lr, ror r9
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3204:	00730009 	rsbseq	r0, r3, r9
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3208:	231c0091 	tstcs	ip, #145	; 0x91
    320c:	009f01a0 	addseq	r0, pc, r0, lsr #3
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3210:	00000000 	andeq	r0, r0, r0
    uint32 temp1, temp2, W[64];
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    3214:	0c000000 	stceq	0, cr0, [r0], {-0}
    3218:	10000029 	andne	r0, r0, r9, lsr #32
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    321c:	02000029 	andeq	r0, r0, #41	; 0x29
    3220:	109f3000 	addsne	r3, pc, r0
    3224:	1a000029 	bne	32d0 <sha256_process+0x1f0>
    3228:	01000029 	tsteq	r0, r9, lsr #32
    322c:	291a5200 	ldmdbcs	sl, {r9, ip, lr}
    3230:	29200000 	stmdbcs	r0!, {}	; <UNPREDICTABLE>
    3234:	00030000 	andeq	r0, r3, r0
    3238:	209f7f72 	addscs	r7, pc, r2, ror pc	; <UNPREDICTABLE>
    323c:	26000029 	strcs	r0, [r0], -r9, lsr #32
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3240:	01000029 	tsteq	r0, r9, lsr #32
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3244:	29265200 	stmdbcs	r6!, {r9, ip, lr}
    3248:	29320000 	ldmdbcs	r2!, {}	; <UNPREDICTABLE>
    324c:	00030000 	andeq	r0, r3, r0
    3250:	329f0172 	addscc	r0, pc, #-2147483620	; 0x8000001c
    3254:	3a000029 	bcc	3300 <sha256_process+0x220>
    3258:	08000029 	stmdaeq	r0, {r0, r3, r5}
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    325c:	91007200 	mrsls	r7, R8_usr
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3260:	61231c00 	teqvs	r3, r0, lsl #24
    3264:	00293a9f 	mlaeq	r9, pc, sl, r3	; <UNPREDICTABLE>
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3268:	00294400 	eoreq	r4, r9, r0, lsl #8
    326c:	72000800 	andvc	r0, r0, #0, 16
    3270:	1c009100 	stfned	f1, [r0], {-0}
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    3274:	449f6023 	ldrmi	r6, [pc], #35	; 327c <sha256_process+0x19c>
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3278:	46000029 	strmi	r0, [r0], -r9, lsr #32
    G = ctx->state[6];
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    327c:	08000029 	stmdaeq	r0, {r0, r3, r5}

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3280:	91007200 	mrsls	r7, R8_usr
    uint32 A, B, C, D, E, F, G, H;

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    3284:	61231c00 	teqvs	r3, r0, lsl #24
    GET_UINT32( W[4],  data, 16 );
    3288:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    328c:	00000000 	andeq	r0, r0, r0
    3290:	00298400 	eoreq	r8, r9, r0, lsl #8
    3294:	0029d200 	eoreq	sp, r9, r0, lsl #4
    3298:	53000100 	movwpl	r0, #256	; 0x100

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    329c:	000029e2 	andeq	r2, r0, r2, ror #19
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32a0:	00002a0c 	andeq	r2, r0, ip, lsl #20

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32a4:	00520001 	subseq	r0, r2, r1
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32a8:	00000000 	andeq	r0, r0, r0
    32ac:	84000000 	strhi	r0, [r0], #-0
    32b0:	e2000029 	and	r0, r0, #41	; 0x29
    32b4:	01000029 	tsteq	r0, r9, lsr #32
    32b8:	29e25400 	stmibcs	r2!, {sl, ip, lr}^
    32bc:	29ee0000 	stmibcs	lr!, {}^	; <UNPREDICTABLE>

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32c0:	00020000 	andeq	r0, r2, r0
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32c4:	29ee9f30 	stmibcs	lr!, {r4, r5, r8, r9, sl, fp, ip, pc}^
    32c8:	29f60000 	ldmibcs	r6!, {}^	; <UNPREDICTABLE>
    32cc:	00080000 	andeq	r0, r8, r0
    32d0:	00910073 	addseq	r0, r1, r3, ror r0

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32d4:	9f40231c 	svcls	0x0040231c
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32d8:	000029f6 	strdeq	r2, [r0], -r6

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32dc:	000029fc 	strdeq	r2, [r0], -ip
    32e0:	00730008 	rsbseq	r0, r3, r8
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32e4:	231c0091 	tstcs	ip, #145	; 0x91

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32e8:	29fc9f3f 	ldmibcs	ip!, {r0, r1, r2, r3, r4, r5, r8, r9, sl, fp, ip, pc}^
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32ec:	2a0c0000 	bcs	3032f4 <_etext+0x2fbce0>

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    32f0:	00080000 	andeq	r0, r8, r0
    H = ctx->state[7];

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    32f4:	00910073 	addseq	r0, r1, r3, ror r0
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    32f8:	9f40231c 	svcls	0x0040231c
	...

    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    3304:	00002986 	andeq	r2, r0, r6, lsl #19

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3308:	0000298a 	andeq	r2, r0, sl, lsl #19
    330c:	9f300002 	svcls	0x00300002
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3310:	0000298a 	andeq	r2, r0, sl, lsl #19
    3314:	00002998 	muleq	r0, r8, r9

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3318:	98520001 	ldmdals	r2, {r0}^
    331c:	9e000029 	cdpls	0, 0, cr0, cr0, cr9, {1}
    3320:	03000029 	movweq	r0, #41	; 0x29
    3324:	9f7f7200 	svcls	0x007f7200
    3328:	0000299e 	muleq	r0, lr, r9
    332c:	000029a4 	andeq	r2, r0, r4, lsr #19
    3330:	a4520001 	ldrbge	r0, [r2], #-1
    3334:	b0000029 	andlt	r0, r0, r9, lsr #32
    3338:	03000029 	movweq	r0, #41	; 0x29
    333c:	9f017200 	svcls	0x00017200
    3340:	000029b0 			; <UNDEFINED> instruction: 0x000029b0
    3344:	000029b8 			; <UNDEFINED> instruction: 0x000029b8
    3348:	00720009 	rsbseq	r0, r2, r9
    334c:	231c0091 	tstcs	ip, #145	; 0x91
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3350:	b89f01a1 	ldmlt	pc, {r0, r5, r7, r8}	; <UNPREDICTABLE>

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3354:	c2000029 	andgt	r0, r0, #41	; 0x29
    3358:	09000029 	stmdbeq	r0, {r0, r3, r5}
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    335c:	91007200 	mrsls	r7, R8_usr
    3360:	a0231c00 	eorge	r1, r3, r0, lsl #24

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3364:	29c29f01 	stmibcs	r2, {r0, r8, r9, sl, fp, ip, pc}^
    3368:	29c40000 	stmibcs	r4, {}^	; <UNPREDICTABLE>
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    336c:	00090000 	andeq	r0, r9, r0
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3370:	00910072 	addseq	r0, r1, r2, ror r0

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3374:	01a1231c 			; <UNDEFINED> instruction: 0x01a1231c
    GET_UINT32( W[0],  data,  0 );
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    3378:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    337c:	00000000 	andeq	r0, r0, r0
    3380:	002a0c00 	eoreq	r0, sl, r0, lsl #24
    3384:	002a1200 	eoreq	r1, sl, r0, lsl #4
    3388:	30000200 	andcc	r0, r0, r0, lsl #4
    338c:	002a129f 	mlaeq	sl, pc, r2, r1	; <UNPREDICTABLE>
    3390:	002a6c00 	eoreq	r6, sl, r0, lsl #24
    3394:	53000100 	movwpl	r0, #256	; 0x100

    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    3398:	00002a78 	andeq	r2, r0, r8, ror sl
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    339c:	00002a96 	muleq	r0, r6, sl
    33a0:	00520001 	subseq	r0, r2, r1
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33a4:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33a8:	0c000000 	stceq	0, cr0, [r0], {-0}
    33ac:	1200002a 	andne	r0, r0, #42	; 0x2a
    33b0:	0200002a 	andeq	r0, r0, #42	; 0x2a
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33b4:	129f3000 	addsne	r3, pc, #0
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33b8:	7800002a 	stmdavc	r0, {r1, r3, r5}
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33bc:	0100002a 	tsteq	r0, sl, lsr #32
    33c0:	2a785900 	bcs	1e197c8 <_etext+0x1e121b4>
    33c4:	2a7e0000 	bcs	1f833cc <_etext+0x1f7bdb8>
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33c8:	00020000 	andeq	r0, r2, r0
    33cc:	2a7e9f30 	bcs	1fab094 <_etext+0x1fa3a80>
    GET_UINT32( W[1],  data,  4 );
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    33d0:	2a880000 	bcs	fe2033d8 <BootRAM+0xd173b79>
    33d4:	00090000 	andeq	r0, r9, r0
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33d8:	00910073 	addseq	r0, r1, r3, ror r0
    33dc:	01a0231c 	lsleq	r2, ip, r3
    33e0:	002a889f 	mlaeq	sl, pc, r8, r8	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33e4:	002a8e00 	eoreq	r8, sl, r0, lsl #28
    33e8:	73000900 	movwvc	r0, #2304	; 0x900
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33ec:	1c009100 	stfned	f1, [r0], {-0}
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    33f0:	9f019f23 	svcls	0x00019f23
    33f4:	00002a8e 	andeq	r2, r0, lr, lsl #21
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    33f8:	00002a96 	muleq	r0, r6, sl
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    33fc:	00730009 	rsbseq	r0, r3, r9
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3400:	231c0091 	tstcs	ip, #145	; 0x91
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3404:	009f01a0 	addseq	r0, pc, r0, lsr #3
    3408:	00000000 	andeq	r0, r0, r0
    340c:	14000000 	strne	r0, [r0], #-0
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3410:	1a00002a 	bne	34c0 <sha256_process+0x3e0>
    P( A, B, C, D, E, F, G, H, W[ 0], 0x428A2F98 );
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    3414:	0200002a 	andeq	r0, r0, #42	; 0x2a
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3418:	1a9f3000 	bne	fe7cf420 <BootRAM+0xd73fbc1>
    341c:	2400002a 	strcs	r0, [r0], #-42	; 0x2a
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3420:	0100002a 	tsteq	r0, sl, lsr #32
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3424:	2a245200 	bcs	917c2c <_etext+0x910618>
    3428:	2a2a0000 	bcs	a83430 <_etext+0xa7be1c>
    342c:	00030000 	andeq	r0, r3, r0
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3430:	2a9f7f72 	bcs	fe7e3200 <BootRAM+0xd7539a1>
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3434:	3000002a 	andcc	r0, r0, sl, lsr #32
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3438:	0100002a 	tsteq	r0, sl, lsr #32
    343c:	2a305200 	bcs	c17c44 <_etext+0xc10630>
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3440:	2a400000 	bcs	1003448 <_etext+0xffbe34>
    3444:	00030000 	andeq	r0, r3, r0
    3448:	409f0172 	addsmi	r0, pc, r2, ror r1	; <UNPREDICTABLE>
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    344c:	4800002a 	stmdami	r0, {r1, r3, r5}
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3450:	0800002a 	stmdaeq	r0, {r1, r3, r5}
    GET_UINT32( W[2],  data,  8 );
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    3454:	91007200 	mrsls	r7, R8_usr
    3458:	41231c00 	teqmi	r3, r0, lsl #24
    345c:	002a489f 	mlaeq	sl, pc, r8, r4	; <UNPREDICTABLE>
    3460:	002a5200 	eoreq	r5, sl, r0, lsl #4
    3464:	72000800 	andvc	r0, r0, #0, 16
    3468:	1c009100 	stfned	f1, [r0], {-0}
    346c:	529f4023 	addspl	r4, pc, #35	; 0x23
    3470:	5400002a 	strpl	r0, [r0], #-42	; 0x2a
    3474:	0800002a 	stmdaeq	r0, {r1, r3, r5}
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3478:	91007200 	mrsls	r7, R8_usr
    347c:	41231c00 	teqmi	r3, r0, lsl #24
    3480:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    3484:	00000000 	andeq	r0, r0, r0
    3488:	002a9600 	eoreq	r9, sl, r0, lsl #12
    348c:	002af000 	eoreq	pc, sl, r0
    3490:	53000100 	movwpl	r0, #256	; 0x100
    P( H, A, B, C, D, E, F, G, W[ 1], 0x71374491 );
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    3494:	00002afc 	strdeq	r2, [r0], -ip
    3498:	00002b1a 	andeq	r2, r0, sl, lsl fp
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    349c:	00520001 	subseq	r0, r2, r1
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34a0:	00000000 	andeq	r0, r0, r0
    34a4:	96000000 	strls	r0, [r0], -r0
    34a8:	fc00002a 	stc2	0, cr0, [r0], {42}	; 0x2a
    34ac:	0100002a 	tsteq	r0, sl, lsr #32
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34b0:	2afc5900 	bcs	fff198b8 <BootRAM+0xee8a059>
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34b4:	2b020000 	blcs	834bc <_etext+0x7bea8>
    34b8:	00020000 	andeq	r0, r2, r0
    34bc:	2b029f30 	blcs	ab184 <_etext+0xa3b70>
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34c0:	2b100000 	blcs	4034c8 <_etext+0x3fbeb4>
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34c4:	00080000 	andeq	r0, r8, r0
    34c8:	00910073 	addseq	r0, r1, r3, ror r0
    34cc:	9f40231c 	svcls	0x0040231c
    34d0:	00002b10 	andeq	r2, r0, r0, lsl fp
    34d4:	00002b16 	andeq	r2, r0, r6, lsl fp
    34d8:	00730008 	rsbseq	r0, r3, r8
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34dc:	231c0091 	tstcs	ip, #145	; 0x91
    34e0:	2b169f3f 	blcs	5ab1e4 <_etext+0x5a3bd0>
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34e4:	2b260000 	blcs	9834ec <_etext+0x97bed8>
    34e8:	00080000 	andeq	r0, r8, r0
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    34ec:	00910073 	addseq	r0, r1, r3, ror r0
    P( G, H, A, B, C, D, E, F, W[ 2], 0xB5C0FBCF );
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    34f0:	9f40231c 	svcls	0x0040231c
	...
    34fc:	00002a98 	muleq	r0, r8, sl
    3500:	00002a9e 	muleq	r0, lr, sl
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3504:	9f300002 	svcls	0x00300002
    3508:	00002a9e 	muleq	r0, lr, sl
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    350c:	00002aac 	andeq	r2, r0, ip, lsr #21
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3510:	ac520001 	mrrcge	0, 0, r0, r2, cr1
    GET_UINT32( W[9],  data, 36 );
    3514:	b200002a 	andlt	r0, r0, #42	; 0x2a
    GET_UINT32( W[3],  data, 12 );
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    3518:	0300002a 	movweq	r0, #42	; 0x2a
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    351c:	9f7f7200 	svcls	0x007f7200
    3520:	00002ab2 			; <UNDEFINED> instruction: 0x00002ab2
    3524:	00002ab8 			; <UNDEFINED> instruction: 0x00002ab8
    3528:	b8520001 	ldmdalt	r2, {r0}^
    352c:	c800002a 	stmdagt	r0, {r1, r3, r5}
    3530:	0300002a 	movweq	r0, #42	; 0x2a
    3534:	9f017200 	svcls	0x00017200
    3538:	00002ac8 	andeq	r2, r0, r8, asr #21
    353c:	00002ad0 	ldrdeq	r2, [r0], -r0
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3540:	00720009 	rsbseq	r0, r2, r9
    3544:	231c0091 	tstcs	ip, #145	; 0x91
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3548:	d09f01a1 	addsle	r0, pc, r1, lsr #3
    354c:	da00002a 	ble	35fc <sha256_process+0x51c>
    3550:	0900002a 	stmdbeq	r0, {r1, r3, r5}
    3554:	91007200 	mrsls	r7, R8_usr
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3558:	a0231c00 	eorge	r1, r3, r0, lsl #24
    355c:	2ada9f01 	bcs	ff6ab168 <BootRAM+0xe61b909>
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3560:	2adc0000 	bcs	ff703568 <BootRAM+0xe673d09>
    3564:	00090000 	andeq	r0, r9, r0
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3568:	00910072 	addseq	r0, r1, r2, ror r0
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    356c:	01a1231c 			; <UNDEFINED> instruction: 0x01a1231c
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3570:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    3574:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3578:	002b2c00 	eoreq	r2, fp, r0, lsl #24
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    357c:	002b7c00 	eoreq	r7, fp, r0, lsl #24
    GET_UINT32( W[4],  data, 16 );
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    3580:	53000100 	movwpl	r0, #256	; 0x100
    P( F, G, H, A, B, C, D, E, W[ 3], 0xE9B5DBA5 );
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    3584:	00002b88 	andeq	r2, r0, r8, lsl #23
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3588:	00002ba8 	andeq	r2, r0, r8, lsr #23
    358c:	00520001 	subseq	r0, r2, r1
    3590:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3594:	2c000000 	stccs	0, cr0, [r0], {-0}
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3598:	8800002b 	stmdahi	r0, {r0, r1, r3, r5}
    359c:	0100002b 	tsteq	r0, fp, lsr #32
    35a0:	2b885400 	blcs	fe2185a8 <BootRAM+0xd188d49>
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35a4:	2b8e0000 	blcs	fe3835ac <BootRAM+0xd2f3d4d>
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35a8:	00020000 	andeq	r0, r2, r0
    35ac:	2b8e9f30 	blcs	fe3ab274 <BootRAM+0xd31ba15>
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35b0:	2b960000 	blcs	fe5835b8 <BootRAM+0xd4f3d59>
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35b4:	00090000 	andeq	r0, r9, r0
    35b8:	00910073 	addseq	r0, r1, r3, ror r0
    35bc:	01a0231c 	lsleq	r2, ip, r3
    35c0:	002b969f 	mlaeq	fp, pc, r6, r9	; <UNPREDICTABLE>
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35c4:	002b9c00 	eoreq	r9, fp, r0, lsl #24
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35c8:	73000900 	movwvc	r0, #2304	; 0x900
    35cc:	1c009100 	stfned	f1, [r0], {-0}
    35d0:	9f019f23 	svcls	0x00019f23
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35d4:	00002b9c 	muleq	r0, ip, fp
    35d8:	00002ba2 	andeq	r2, r0, r2, lsr #23
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35dc:	00730009 	rsbseq	r0, r3, r9
    35e0:	231c0091 	tstcs	ip, #145	; 0x91
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35e4:	009f01a0 	addseq	r0, pc, r0, lsr #3
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35e8:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35ec:	2e000000 	cdpcs	0, 0, cr0, cr0, cr0, {0}
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    35f0:	3200002b 	andcc	r0, r0, #43	; 0x2b
    35f4:	0200002b 	andeq	r0, r0, #43	; 0x2b
    35f8:	329f3000 	addscc	r3, pc, #0
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    35fc:	3c00002b 	stccc	0, cr0, [r0], {43}	; 0x2b
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3600:	0100002b 	tsteq	r0, fp, lsr #32
    P( E, F, G, H, A, B, C, D, W[ 4], 0x3956C25B );
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    3604:	2b3c5200 	blcs	f17e0c <_etext+0xf107f8>
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3608:	2b420000 	blcs	1083610 <_etext+0x107bffc>
    360c:	00030000 	andeq	r0, r3, r0
    3610:	429f7f72 	addsmi	r7, pc, #456	; 0x1c8
    3614:	4800002b 	stmdami	r0, {r0, r1, r3, r5}
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3618:	0100002b 	tsteq	r0, fp, lsr #32
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    361c:	2b485200 	blcs	1217e24 <_etext+0x1210810>
    3620:	2b540000 	blcs	1503628 <_etext+0x14fc014>
    3624:	00030000 	andeq	r0, r3, r0
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3628:	549f0172 	ldrpl	r0, [pc], #370	; 3630 <sha256_process+0x550>
    362c:	5c00002b 	stcpl	0, cr0, [r0], {43}	; 0x2b
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3630:	0800002b 	stmdaeq	r0, {r0, r1, r3, r5}
    3634:	91007200 	mrsls	r7, R8_usr
    GET_UINT32( W[5],  data, 20 );
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    3638:	41231c00 	teqmi	r3, r0, lsl #24
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    363c:	002b5c9f 	mlaeq	fp, pc, ip, r5	; <UNPREDICTABLE>
    3640:	002b6600 	eoreq	r6, fp, r0, lsl #12
    3644:	72000800 	andvc	r0, r0, #0, 16
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3648:	1c009100 	stfned	f1, [r0], {-0}
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    364c:	669f4023 	ldrvs	r4, [pc], r3, lsr #32
    3650:	6800002b 	stmdavs	r0, {r0, r1, r3, r5}
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3654:	0800002b 	stmdaeq	r0, {r0, r1, r3, r5}
    3658:	91007200 	mrsls	r7, R8_usr
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    365c:	41231c00 	teqmi	r3, r0, lsl #24
    3660:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    3664:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3668:	002ba800 	eoreq	sl, fp, r0, lsl #16
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    366c:	002bf800 	eoreq	pc, fp, r0, lsl #16
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3670:	53000100 	movwpl	r0, #256	; 0x100
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3674:	00002c04 	andeq	r2, r0, r4, lsl #24
    P( D, E, F, G, H, A, B, C, W[ 5], 0x59F111F1 );
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    3678:	00002c26 	andeq	r2, r0, r6, lsr #24
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    367c:	00520001 	subseq	r0, r2, r1
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3680:	00000000 	andeq	r0, r0, r0
    3684:	a8000000 	stmdage	r0, {}	; <UNPREDICTABLE>
    3688:	0400002b 	streq	r0, [r0], #-43	; 0x2b
    GET_UINT32( W[6],  data, 24 );
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    368c:	0100002c 	tsteq	r0, ip, lsr #32
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    3690:	2c045400 	cfstrscs	mvf5, [r4], {-0}
    3694:	2c0a0000 	stccs	0, cr0, [sl], {-0}
    3698:	00020000 	andeq	r0, r2, r0
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    369c:	2c0a9f30 	stccs	15, cr9, [sl], {48}	; 0x30
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36a0:	2c140000 	ldccs	0, cr0, [r4], {-0}
    36a4:	00080000 	andeq	r0, r8, r0
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36a8:	00910073 	addseq	r0, r1, r3, ror r0
    36ac:	9f40231c 	svcls	0x0040231c
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36b0:	00002c14 	andeq	r2, r0, r4, lsl ip
    36b4:	00002c1a 	andeq	r2, r0, sl, lsl ip
    36b8:	00730008 	rsbseq	r0, r3, r8
    36bc:	231c0091 	tstcs	ip, #145	; 0x91
    36c0:	2c1a9f3f 	ldccs	15, cr9, [sl], {63}	; 0x3f
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36c4:	2c200000 	stccs	0, cr0, [r0], #-0
    36c8:	00080000 	andeq	r0, r8, r0
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36cc:	00910073 	addseq	r0, r1, r3, ror r0
    36d0:	9f40231c 	svcls	0x0040231c
	...
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36dc:	00002bac 	andeq	r2, r0, ip, lsr #23
    36e0:	00002bb0 			; <UNDEFINED> instruction: 0x00002bb0
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36e4:	9f300002 	svcls	0x00300002
    36e8:	00002bb0 			; <UNDEFINED> instruction: 0x00002bb0
    36ec:	00002bbe 			; <UNDEFINED> instruction: 0x00002bbe
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    36f0:	be520001 	cdplt	0, 5, cr0, cr2, cr1, {0}
    P( C, D, E, F, G, H, A, B, W[ 6], 0x923F82A4 );
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    36f4:	c400002b 	strgt	r0, [r0], #-43	; 0x2b
    36f8:	0300002b 	movweq	r0, #43	; 0x2b
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    36fc:	9f7f7200 	svcls	0x007f7200
    3700:	00002bc4 	andeq	r2, r0, r4, asr #23
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3704:	00002bca 	andeq	r2, r0, sl, asr #23
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3708:	ca520001 	bgt	1483714 <_etext+0x147c100>
    370c:	d600002b 	strle	r0, [r0], -fp, lsr #32
    GET_UINT32( W[7],  data, 28 );
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    3710:	0300002b 	movweq	r0, #43	; 0x2b
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3714:	9f017200 	svcls	0x00017200
    3718:	00002bd6 	ldrdeq	r2, [r0], -r6
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    371c:	00002bde 	ldrdeq	r2, [r0], -lr
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3720:	00720009 	rsbseq	r0, r2, r9
    3724:	231c0091 	tstcs	ip, #145	; 0x91
    3728:	de9f01a1 	fmlle<illegal precision>p	f0, f7, f1
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    372c:	e800002b 	stmda	r0, {r0, r1, r3, r5}
    3730:	0900002b 	stmdbeq	r0, {r0, r1, r3, r5}
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3734:	91007200 	mrsls	r7, R8_usr
    3738:	a0231c00 	eorge	r1, r3, r0, lsl #24
    373c:	2be89f01 	blcs	ffa2b348 <BootRAM+0xe99bae9>
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3740:	2bea0000 	blcs	ffa83748 <BootRAM+0xe9f3ee9>
    3744:	00090000 	andeq	r0, r9, r0
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3748:	00910072 	addseq	r0, r1, r2, ror r0
    374c:	01a1231c 			; <UNDEFINED> instruction: 0x01a1231c
    3750:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    3754:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3758:	002c2600 	eoreq	r2, ip, r0, lsl #12
    GET_UINT32( W[8],  data, 32 );
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    375c:	002c7200 	eoreq	r7, ip, r0, lsl #4
    P( B, C, D, E, F, G, H, A, W[ 7], 0xAB1C5ED5 );
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    3760:	53000100 	movwpl	r0, #256	; 0x100
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3764:	00002c7e 	andeq	r2, r0, lr, ror ip
    3768:	00002c9e 	muleq	r0, lr, ip
    376c:	00520001 	subseq	r0, r2, r1
    3770:	00000000 	andeq	r0, r0, r0
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3774:	26000000 	strcs	r0, [r0], -r0
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3778:	7e00002c 	cdpvc	0, 0, cr0, cr0, cr12, {1}
    377c:	0100002c 	tsteq	r0, ip, lsr #32
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3780:	2c7e5400 	cfldrdcs	mvd5, [lr], #-0
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3784:	2c840000 	stccs	0, cr0, [r4], {0}
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3788:	00020000 	andeq	r0, r2, r0
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    378c:	2c849f30 	stccs	15, cr9, [r4], {48}	; 0x30
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3790:	2c8c0000 	stccs	0, cr0, [ip], {0}
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    3794:	00090000 	andeq	r0, r9, r0
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    3798:	00910073 	addseq	r0, r1, r3, ror r0
    379c:	01a0231c 	lsleq	r2, ip, r3
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37a0:	002c8c9f 	mlaeq	ip, pc, ip, r8	; <UNPREDICTABLE>
    37a4:	002c9200 	eoreq	r9, ip, r0, lsl #4
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    37a8:	73000900 	movwvc	r0, #2304	; 0x900
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37ac:	1c009100 	stfned	f1, [r0], {-0}
    37b0:	9f019f23 	svcls	0x00019f23
    37b4:	00002c92 	muleq	r0, r2, ip
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    37b8:	00002c98 	muleq	r0, r8, ip
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37bc:	00730009 	rsbseq	r0, r3, r9
    GET_UINT32( W[9],  data, 36 );
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    37c0:	231c0091 	tstcs	ip, #145	; 0x91
    P( A, B, C, D, E, F, G, H, W[ 8], 0xD807AA98 );
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    37c4:	009f01a0 	addseq	r0, pc, r0, lsr #3
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37c8:	00000000 	andeq	r0, r0, r0
    37cc:	28000000 	stmdacs	r0, {}	; <UNPREDICTABLE>
    37d0:	2c00002c 	stccs	0, cr0, [r0], {44}	; 0x2c
    37d4:	0200002c 	andeq	r0, r0, #44	; 0x2c
    37d8:	2c9f3000 	ldccs	0, cr3, [pc], {0}
    37dc:	3600002c 	strcc	r0, [r0], -ip, lsr #32
    37e0:	0100002c 	tsteq	r0, ip, lsr #32
    37e4:	2c365200 	lfmcs	f5, 4, [r6], #-0
    37e8:	2c3c0000 	ldccs	0, cr0, [ip], #-0
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    37ec:	00030000 	andeq	r0, r3, r0
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37f0:	3c9f7f72 	ldccc	15, cr7, [pc], {114}	; 0x72
    37f4:	4200002c 	andmi	r0, r0, #44	; 0x2c
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    37f8:	0100002c 	tsteq	r0, ip, lsr #32
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    37fc:	2c425200 	sfmcs	f5, 2, [r2], {-0}
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3800:	2c4e0000 	marcs	acc0, r0, lr
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3804:	00030000 	andeq	r0, r3, r0
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3808:	4e9f0172 	mrcmi	1, 4, r0, cr15, cr2, {3}
    380c:	5600002c 	strpl	r0, [r0], -ip, lsr #32
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3810:	0800002c 	stmdaeq	r0, {r2, r3, r5}
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3814:	91007200 	mrsls	r7, R8_usr
    3818:	41231c00 	teqmi	r3, r0, lsl #24
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    381c:	002c569f 	mlaeq	ip, pc, r6, r5	; <UNPREDICTABLE>
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3820:	002c6000 	eoreq	r6, ip, r0
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3824:	72000800 	andvc	r0, r0, #0, 16
    3828:	1c009100 	stfned	f1, [r0], {-0}
    382c:	609f4023 	addsvs	r4, pc, r3, lsr #32
    3830:	6200002c 	andvs	r0, r0, #44	; 0x2c
    3834:	0800002c 	stmdaeq	r0, {r2, r3, r5}
    3838:	91007200 	mrsls	r7, R8_usr
    383c:	41231c00 	teqmi	r3, r0, lsl #24
    3840:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    3844:	00000000 	andeq	r0, r0, r0
    3848:	002c9e00 	eoreq	r9, ip, r0, lsl #28
    384c:	002cee00 	eoreq	lr, ip, r0, lsl #28
    3850:	53000100 	movwpl	r0, #256	; 0x100
    GET_UINT32( W[10], data, 40 );
    GET_UINT32( W[11], data, 44 );
    GET_UINT32( W[12], data, 48 );
    GET_UINT32( W[13], data, 52 );
    GET_UINT32( W[14], data, 56 );
    GET_UINT32( W[15], data, 60 );
    3854:	00002cfe 	strdeq	r2, [r0], -lr
    P( H, A, B, C, D, E, F, G, W[ 9], 0x12835B01 );
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    3858:	00002d1e 	andeq	r2, r0, lr, lsl sp
    385c:	00520001 	subseq	r0, r2, r1
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3860:	00000000 	andeq	r0, r0, r0
    3864:	9e000000 	cdpls	0, 0, cr0, cr0, cr0, {0}
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3868:	fe00002c 	cdp2	0, 0, cr0, cr0, cr12, {1}
    386c:	0100002c 	tsteq	r0, ip, lsr #32
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3870:	2cfe5400 	cfldrdcs	mvd5, [lr]
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3874:	2d040000 	stccs	0, cr0, [r4, #-0]
    3878:	00020000 	andeq	r0, r2, r0
    387c:	2d049f30 	stccs	15, cr9, [r4, #-192]	; 0xffffff40
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3880:	2d0c0000 	stccs	0, cr0, [ip, #-0]
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3884:	00080000 	andeq	r0, r8, r0
    3888:	00910073 	addseq	r0, r1, r3, ror r0
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    388c:	9f40231c 	svcls	0x0040231c
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    3890:	00002d0c 	andeq	r2, r0, ip, lsl #26
    3894:	00002d12 	andeq	r2, r0, r2, lsl sp
    3898:	00730008 	rsbseq	r0, r3, r8
    389c:	231c0091 	tstcs	ip, #145	; 0x91
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38a0:	2d129f3f 	ldccs	15, cr9, [r2, #-252]	; 0xffffff04
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    38a4:	2d180000 	ldccs	0, cr0, [r8, #-0]
    38a8:	00080000 	andeq	r0, r8, r0
    38ac:	00910073 	addseq	r0, r1, r3, ror r0
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38b0:	9f40231c 	svcls	0x0040231c
	...
    P( G, H, A, B, C, D, E, F, W[10], 0x243185BE );
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    38bc:	00002ca2 	andeq	r2, r0, r2, lsr #25
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38c0:	00002ca6 	andeq	r2, r0, r6, lsr #25
    38c4:	9f300002 	svcls	0x00300002
    38c8:	00002ca6 	andeq	r2, r0, r6, lsr #25
    38cc:	00002cb4 			; <UNDEFINED> instruction: 0x00002cb4
    38d0:	b4520001 	ldrblt	r0, [r2], #-1
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38d4:	ba00002c 	blt	398c <sha256_process+0x8ac>
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38d8:	0300002c 	movweq	r0, #44	; 0x2c
    38dc:	9f7f7200 	svcls	0x007f7200
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38e0:	00002cba 			; <UNDEFINED> instruction: 0x00002cba
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38e4:	00002cc0 	andeq	r2, r0, r0, asr #25
    38e8:	c0520001 	subsgt	r0, r2, r1
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38ec:	cc00002c 	stcgt	0, cr0, [r0], {44}	; 0x2c
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38f0:	0300002c 	movweq	r0, #44	; 0x2c
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    38f4:	9f017200 	svcls	0x00017200
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    38f8:	00002ccc 	andeq	r2, r0, ip, asr #25
    38fc:	00002cd4 	ldrdeq	r2, [r0], -r4
    3900:	00720009 	rsbseq	r0, r2, r9
    3904:	231c0091 	tstcs	ip, #145	; 0x91
    3908:	d49f01a1 	ldrle	r0, [pc], #417	; 3910 <sha256_process+0x830>
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    390c:	de00002c 	cdple	0, 0, cr0, cr0, cr12, {1}
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3910:	0900002c 	stmdbeq	r0, {r2, r3, r5}
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3914:	91007200 	mrsls	r7, R8_usr
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3918:	a0231c00 	eorge	r1, r3, r0, lsl #24
    391c:	2cde9f01 	ldclcs	15, cr9, [lr], {1}
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3920:	2ce00000 	stclcs	0, cr0, [r0]
    3924:	00090000 	andeq	r0, r9, r0
    P( F, G, H, A, B, C, D, E, W[11], 0x550C7DC3 );
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    3928:	00910072 	addseq	r0, r1, r2, ror r0
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    392c:	01a1231c 			; <UNDEFINED> instruction: 0x01a1231c
    3930:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    3934:	00000000 	andeq	r0, r0, r0
    3938:	002d1e00 	eoreq	r1, sp, r0, lsl #28
    393c:	002d6800 	eoreq	r6, sp, r0, lsl #16
    3940:	53000100 	movwpl	r0, #256	; 0x100
    3944:	00002d74 	andeq	r2, r0, r4, ror sp
    3948:	00002d8e 	andeq	r2, r0, lr, lsl #27
    394c:	00520001 	subseq	r0, r2, r1
    3950:	00000000 	andeq	r0, r0, r0
    3954:	1e000000 	cdpne	0, 0, cr0, cr0, cr0, {0}
    3958:	7400002d 	strvc	r0, [r0], #-45	; 0x2d
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    395c:	0100002d 	tsteq	r0, sp, lsr #32
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3960:	2d745400 	cfldrdcs	mvd5, [r4, #-0]
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3964:	2d7a0000 	ldclcs	0, cr0, [sl, #-0]
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3968:	00020000 	andeq	r0, r2, r0
    396c:	2d7a9f30 	ldclcs	15, cr9, [sl, #-192]!	; 0xffffff40
    3970:	2d820000 	stccs	0, cr0, [r2]
    3974:	00090000 	andeq	r0, r9, r0
    3978:	00910073 	addseq	r0, r1, r3, ror r0
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    397c:	0180231c 	orreq	r2, r0, ip, lsl r3
    P( E, F, G, H, A, B, C, D, W[12], 0x72BE5D74 );
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    3980:	002d829f 	mlaeq	sp, pc, r2, r8	; <UNPREDICTABLE>
    3984:	002d8800 	eoreq	r8, sp, r0, lsl #16
    3988:	73000800 	movwvc	r0, #2048	; 0x800
    398c:	1c009100 	stfned	f1, [r0], {-0}
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3990:	889f7f23 	ldmhi	pc, {r0, r1, r5, r8, r9, sl, fp, ip, sp, lr}	; <UNPREDICTABLE>
    3994:	8c00002d 	stchi	0, cr0, [r0], {45}	; 0x2d
    3998:	0900002d 	stmdbeq	r0, {r0, r2, r3, r5}
    399c:	91007300 	mrsls	r7, LR_irq
    39a0:	80231c00 	eorhi	r1, r3, r0, lsl #24
    39a4:	00009f01 	andeq	r9, r0, r1, lsl #30
    39a8:	00000000 	andeq	r0, r0, r0
    39ac:	2d200000 	stccs	0, cr0, [r0, #-0]
    39b0:	2d240000 	stccs	0, cr0, [r4, #-0]
    39b4:	00020000 	andeq	r0, r2, r0
    39b8:	2d249f30 	stccs	15, cr9, [r4, #-192]!	; 0xffffff40
    39bc:	2d2e0000 	stccs	0, cr0, [lr, #-0]
    39c0:	00010000 	andeq	r0, r1, r0
    39c4:	002d2e52 	eoreq	r2, sp, r2, asr lr
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39c8:	002d3400 	eoreq	r3, sp, r0, lsl #8
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39cc:	72000300 	andvc	r0, r0, #0, 6
    39d0:	2d349f7f 	ldccs	15, cr9, [r4, #-508]!	; 0xfffffe04
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39d4:	2d3a0000 	ldccs	0, cr0, [sl, #-0]
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39d8:	00010000 	andeq	r0, r1, r0
    39dc:	002d3a52 	eoreq	r3, sp, r2, asr sl
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39e0:	002d4600 	eoreq	r4, sp, r0, lsl #12
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39e4:	72000300 	andvc	r0, r0, #0, 6
    39e8:	2d469f01 	stclcs	15, cr9, [r6, #-4]
    39ec:	2d4e0000 	stclcs	0, cr0, [lr, #-0]
    39f0:	00080000 	andeq	r0, r8, r0
    39f4:	00910072 	addseq	r0, r1, r2, ror r0
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    39f8:	9f61231c 	svcls	0x0061231c
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    39fc:	00002d4e 	andeq	r2, r0, lr, asr #26
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a00:	00002d58 	andeq	r2, r0, r8, asr sp
    3a04:	00720008 	rsbseq	r0, r2, r8
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3a08:	231c0091 	tstcs	ip, #145	; 0x91
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a0c:	2d589f60 	ldclcs	15, cr9, [r8, #-384]	; 0xfffffe80
    3a10:	2d5a0000 	ldclcs	0, cr0, [sl, #-0]
    3a14:	00080000 	andeq	r0, r8, r0
    3a18:	00910072 	addseq	r0, r1, r2, ror r0
    3a1c:	9f61231c 	svcls	0x0061231c
	...
    P( D, E, F, G, H, A, B, C, W[13], 0x80DEB1FE );
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    3a28:	00002d8a 	andeq	r2, r0, sl, lsl #27
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a2c:	00002d90 	muleq	r0, r0, sp
    3a30:	9f330002 	svcls	0x00330002
    3a34:	00002d90 	muleq	r0, r0, sp
    3a38:	00002ee8 	andeq	r2, r0, r8, ror #29
    3a3c:	9f340002 	svcls	0x00340002
	...
    3a48:	00002da0 	andeq	r2, r0, r0, lsr #27
    3a4c:	00002dc6 	andeq	r2, r0, r6, asr #27
    3a50:	c6520001 	ldrbgt	r0, [r2], -r1
    3a54:	d000002d 	andle	r0, r0, sp, lsr #32
    3a58:	0100002d 	tsteq	r0, sp, lsr #32
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a5c:	2dd85100 	ldfcse	f5, [r8]
    P( C, D, E, F, G, H, A, B, W[14], 0x9BDC06A7 );
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    3a60:	2df60000 	ldclcs	0, cr0, [r6]
    3a64:	00010000 	andeq	r0, r1, r0
    3a68:	00000052 	andeq	r0, r0, r2, asr r0
    3a6c:	00000000 	andeq	r0, r0, r0
    3a70:	002da000 	eoreq	sl, sp, r0
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3a74:	002db000 	eoreq	fp, sp, r0
    3a78:	53000100 	movwpl	r0, #256	; 0x100
    3a7c:	00002db0 			; <UNDEFINED> instruction: 0x00002db0
    3a80:	00002db6 			; <UNDEFINED> instruction: 0x00002db6
    3a84:	7f730003 	svcvc	0x00730003
    3a88:	002db69f 	mlaeq	sp, pc, r6, fp	; <UNPREDICTABLE>
    3a8c:	002dc200 	eoreq	ip, sp, r0, lsl #4
    3a90:	53000100 	movwpl	r0, #256	; 0x100
    3a94:	00002dd8 	ldrdeq	r2, [r0], -r8
    3a98:	00002de0 	andeq	r2, r0, r0, ror #27
    3a9c:	00730009 	rsbseq	r0, r3, r9
    3aa0:	231c0091 	tstcs	ip, #145	; 0x91
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3aa4:	e09f0180 	adds	r0, pc, r0, lsl #3
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3aa8:	e600002d 	str	r0, [r0], -sp, lsr #32
    3aac:	0800002d 	stmdaeq	r0, {r0, r2, r3, r5}
    3ab0:	91007300 	mrsls	r7, LR_irq
    3ab4:	7f231c00 	svcvc	0x00231c00
    3ab8:	002de69f 	mlaeq	sp, pc, r6, lr	; <UNPREDICTABLE>
    3abc:	002df000 	eoreq	pc, sp, r0
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ac0:	73000900 	movwvc	r0, #2304	; 0x900
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3ac4:	1c009100 	stfned	f1, [r0], {-0}
    3ac8:	9f018023 	svcls	0x00018023
	...
    3ad4:	00002df6 	strdeq	r2, [r0], -r6
    3ad8:	00002e46 	andeq	r2, r0, r6, asr #28
    3adc:	52530001 	subspl	r0, r3, #1
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ae0:	7400002e 	strvc	r0, [r0], #-46	; 0x2e
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3ae4:	0100002e 	tsteq	r0, lr, lsr #32
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3ae8:	00005200 	andeq	r5, r0, r0, lsl #4
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3aec:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3af0:	2df60000 	ldclcs	0, cr0, [r6]
    3af4:	2e520000 	cdpcs	0, 5, cr0, cr2, cr0, {0}
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3af8:	00010000 	andeq	r0, r1, r0
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3afc:	002e5254 	eoreq	r5, lr, r4, asr r2
    3b00:	002e5800 	eoreq	r5, lr, r0, lsl #16
    3b04:	30000200 	andcc	r0, r0, r0, lsl #4
    3b08:	002e589f 	mlaeq	lr, pc, r8, r5	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, W[15], 0xC19BF174 );
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    3b0c:	002e6000 	eoreq	r6, lr, r0
    3b10:	73000800 	movwvc	r0, #2048	; 0x800
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b14:	1c009100 	stfned	f1, [r0], {-0}
    3b18:	609f6023 	addsvs	r6, pc, r3, lsr #32
    3b1c:	6600002e 	strvs	r0, [r0], -lr, lsr #32
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b20:	0800002e 	stmdaeq	r0, {r1, r2, r3, r5}
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b24:	91007300 	mrsls	r7, LR_irq
    3b28:	5f231c00 	svcpl	0x00231c00
    3b2c:	002e669f 	mlaeq	lr, pc, r6, r6	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b30:	002e6c00 	eoreq	r6, lr, r0, lsl #24
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b34:	73000800 	movwvc	r0, #2048	; 0x800
    3b38:	1c009100 	stfned	f1, [r0], {-0}
    3b3c:	009f6023 	addseq	r6, pc, r3, lsr #32
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b40:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b44:	f8000000 			; <UNDEFINED> instruction: 0xf8000000
    3b48:	fe00002d 	cdp2	0, 0, cr0, cr0, cr13, {1}
    3b4c:	0200002d 	andeq	r0, r0, #45	; 0x2d
    3b50:	fe9f3000 	cdp2	0, 9, cr3, cr15, cr0, {0}
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b54:	0c00002d 	stceq	0, cr0, [r0], {45}	; 0x2d
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b58:	0100002e 	tsteq	r0, lr, lsr #32
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b5c:	2e0c5200 	cdpcs	2, 0, cr5, cr12, cr0, {0}
    3b60:	2e120000 	cdpcs	0, 1, cr0, cr2, cr0, {0}
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b64:	00030000 	andeq	r0, r3, r0
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b68:	129f7f72 	addsne	r7, pc, #456	; 0x1c8
    3b6c:	1800002e 	stmdane	r0, {r1, r2, r3, r5}
    3b70:	0100002e 	tsteq	r0, lr, lsr #32
    3b74:	2e185200 	cdpcs	2, 1, cr5, cr8, cr0, {0}
    3b78:	2e240000 	cdpcs	0, 2, cr0, cr4, cr0, {0}
    3b7c:	00030000 	andeq	r0, r3, r0
    3b80:	249f0172 	ldrcs	r0, [pc], #370	; 3b88 <sha256_process+0xaa8>
    3b84:	2c00002e 	stccs	0, cr0, [r0], {46}	; 0x2e
    3b88:	0900002e 	stmdbeq	r0, {r1, r2, r3, r5}
    3b8c:	91007200 	mrsls	r7, R8_usr
    P( A, B, C, D, E, F, G, H, R(16), 0xE49B69C1 );
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    3b90:	a1231c00 	teqge	r3, r0, lsl #24
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3b94:	2e2c9f01 	cdpcs	15, 2, cr9, cr12, cr1, {0}
    3b98:	2e360000 	cdpcs	0, 3, cr0, cr6, cr0, {0}
    3b9c:	00090000 	andeq	r0, r9, r0
    3ba0:	00910072 	addseq	r0, r1, r2, ror r0
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3ba4:	01a0231c 	lsleq	r2, ip, r3
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3ba8:	002e369f 	mlaeq	lr, pc, r6, r3	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bac:	002e3800 	eoreq	r3, lr, r0, lsl #16
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bb0:	72000900 	andvc	r0, r0, #0, 18
    3bb4:	1c009100 	stfned	f1, [r0], {-0}
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bb8:	9f01a123 	svcls	0x0001a123
	...
    3bc4:	00002e74 	andeq	r2, r0, r4, ror lr
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bc8:	00002eba 			; <UNDEFINED> instruction: 0x00002eba
    3bcc:	c4530001 	ldrbgt	r0, [r3], #-1
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bd0:	e800002e 	stmda	r0, {r1, r2, r3, r5}
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bd4:	0100002e 	tsteq	r0, lr, lsr #32
    3bd8:	00005200 	andeq	r5, r0, r0, lsl #4
    3bdc:	00000000 	andeq	r0, r0, r0
    3be0:	2e740000 	cdpcs	0, 7, cr0, cr4, cr0, {0}
    3be4:	2ec40000 	cdpcs	0, 12, cr0, cr4, cr0, {0}
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3be8:	00010000 	andeq	r0, r1, r0
    3bec:	002ec450 	eoreq	ip, lr, r0, asr r4
    3bf0:	002ed000 	eoreq	sp, lr, r0
    3bf4:	30000200 	andcc	r0, r0, r0, lsl #4
    P( H, A, B, C, D, E, F, G, R(17), 0xEFBE4786 );
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    3bf8:	002ed09f 	mlaeq	lr, pc, r0, sp	; <UNPREDICTABLE>
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3bfc:	002ed800 	eoreq	sp, lr, r0, lsl #16
    3c00:	53000100 	movwpl	r0, #256	; 0x100
    3c04:	00002ed8 	ldrdeq	r2, [r0], -r8
    3c08:	00002ede 	ldrdeq	r2, [r0], -lr
    3c0c:	7f730003 	svcvc	0x00730003
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c10:	002ede9f 	mlaeq	lr, pc, lr, sp	; <UNPREDICTABLE>
    3c14:	002ee800 	eoreq	lr, lr, r0, lsl #16
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c18:	53000100 	movwpl	r0, #256	; 0x100
	...
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c24:	00002e76 	andeq	r2, r0, r6, ror lr
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c28:	00002e7a 	andeq	r2, r0, sl, ror lr
    3c2c:	9f300002 	svcls	0x00300002
    3c30:	00002e7a 	andeq	r2, r0, sl, ror lr
    3c34:	00002e82 	andeq	r2, r0, r2, lsl #29
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c38:	82520001 	subshi	r0, r2, #1
    P( G, H, A, B, C, D, E, F, R(18), 0x0FC19DC6 );
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    3c3c:	8800002e 	stmdahi	r0, {r1, r2, r3, r5}
    3c40:	0300002e 	movweq	r0, #46	; 0x2e
    3c44:	9f7f7200 	svcls	0x007f7200
    3c48:	00002e88 	andeq	r2, r0, r8, lsl #29
    3c4c:	00002e8e 	andeq	r2, r0, lr, lsl #29
    3c50:	8e520001 	cdphi	0, 5, cr0, cr2, cr1, {0}
    3c54:	9a00002e 	bls	3d14 <sha256_process+0xc34>
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3c58:	0300002e 	movweq	r0, #46	; 0x2e
    3c5c:	9f017200 	svcls	0x00017200
    3c60:	00002e9a 	muleq	r0, sl, lr
    3c64:	00002ea2 	andeq	r2, r0, r2, lsr #29
    3c68:	00720008 	rsbseq	r0, r2, r8
    3c6c:	231c0091 	tstcs	ip, #145	; 0x91
    3c70:	2ea29f61 	cdpcs	15, 10, cr9, cr2, cr1, {3}
    3c74:	2eac0000 	cdpcs	0, 10, cr0, cr12, cr0, {0}
    3c78:	00080000 	andeq	r0, r8, r0
    3c7c:	00910072 	addseq	r0, r1, r2, ror r0
    3c80:	9f60231c 	svcls	0x0060231c
    3c84:	00002eac 	andeq	r2, r0, ip, lsr #29
    3c88:	00002eae 	andeq	r2, r0, lr, lsr #29
    3c8c:	00720008 	rsbseq	r0, r2, r8
    3c90:	231c0091 	tstcs	ip, #145	; 0x91
    3c94:	00009f61 	andeq	r9, r0, r1, ror #30
	...
    3ca4:	00010000 	andeq	r0, r1, r0
    3ca8:	00000050 	andeq	r0, r0, r0, asr r0
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cac:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cb0:	70000300 	andvc	r0, r0, r0, lsl #6
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cb4:	00009f7c 	andeq	r9, r0, ip, ror pc
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cb8:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cbc:	00040000 	andeq	r0, r4, r0
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3cc0:	9f5001f3 	svcls	0x005001f3
	...
    3cd4:	00510001 	subseq	r0, r1, r1
    3cd8:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cdc:	01000000 	mrseq	r0, (UNDEF: 0)
    P( F, G, H, A, B, C, D, E, R(19), 0x240CA1CC );
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    3ce0:	00005200 	andeq	r5, r0, r0, lsl #4
    3ce4:	00000000 	andeq	r0, r0, r0
    3ce8:	00050000 	andeq	r0, r5, r0
    3cec:	25380072 	ldrcs	r0, [r8, #-114]!	; 0x72
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3cf0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    3cf4:	00000000 	andeq	r0, r0, r0
    3cf8:	72000700 	andvc	r0, r0, #0, 14
    3cfc:	38253800 	stmdacc	r5!, {fp, ip, sp}
    3d00:	00009f25 	andeq	r9, r0, r5, lsr #30
    3d04:	00000000 	andeq	r0, r0, r0
    3d08:	000a0000 	andeq	r0, sl, r0
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d0c:	405101f3 	ldrshmi	r0, [r1], #-19	; 0xffffffed
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d10:	38253825 	stmdacc	r5!, {r0, r2, r5, fp, ip, sp}
    3d14:	00009f25 	andeq	r9, r0, r5, lsr #30
	...
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d24:	00020000 	andeq	r0, r2, r0
    3d28:	00009f30 	andeq	r9, r0, r0, lsr pc
    3d2c:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d30:	00020000 	andeq	r0, r2, r0
    3d34:	00009f32 	andeq	r9, r0, r2, lsr pc
    3d38:	00000000 	andeq	r0, r0, r0
    3d3c:	00020000 	andeq	r0, r2, r0
    3d40:	00009f33 	andeq	r9, r0, r3, lsr pc
    3d44:	00000000 	andeq	r0, r0, r0
    3d48:	00020000 	andeq	r0, r2, r0
    3d4c:	00009f34 	andeq	r9, r0, r4, lsr pc
    3d50:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d54:	2ee80000 	cdpcs	0, 14, cr0, cr8, cr0, {0}
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d58:	2f260000 	svccs	0x00260000
    3d5c:	00010000 	andeq	r0, r1, r0
    3d60:	002f2650 	eoreq	r2, pc, r0, asr r6	; <UNPREDICTABLE>
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d64:	00306800 	eorseq	r6, r0, r0, lsl #16
    3d68:	54000100 	strpl	r0, [r0], #-256	; 0x100
    3d6c:	00003068 	andeq	r3, r0, r8, rrx
    3d70:	00003074 	andeq	r3, r0, r4, ror r0
    3d74:	74500001 	ldrbvc	r0, [r0], #-1
    3d78:	82000030 	andhi	r0, r0, #48	; 0x30
    P( E, F, G, H, A, B, C, D, R(20), 0x2DE92C6F );
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    3d7c:	01000030 	tsteq	r0, r0, lsr r0
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d80:	30825400 	addcc	r5, r2, r0, lsl #8
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d84:	30880000 	addcc	r0, r8, r0
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d88:	00010000 	andeq	r0, r1, r0
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d8c:	00000050 	andeq	r0, r0, r0, asr r0
    3d90:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d94:	002ee800 	eoreq	lr, lr, r0, lsl #16
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3d98:	002f2800 	eoreq	r2, pc, r0, lsl #16
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3d9c:	51000100 	mrspl	r0, (UNDEF: 16)
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3da0:	00002f28 	andeq	r2, r0, r8, lsr #30
    3da4:	00003068 	andeq	r3, r0, r8, rrx
    3da8:	68570001 	ldmdavs	r7, {r0}^
    3dac:	74000030 	strvc	r0, [r0], #-48	; 0x30
    3db0:	01000030 	tsteq	r0, r0, lsr r0
    3db4:	30745100 	rsbscc	r5, r4, r0, lsl #2
    3db8:	30820000 	addcc	r0, r2, r0
    3dbc:	00010000 	andeq	r0, r1, r0
    3dc0:	00308257 	eorseq	r8, r0, r7, asr r2
    3dc4:	00308800 	eorseq	r8, r0, r0, lsl #16
    3dc8:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3dd4:	00002ee8 	andeq	r2, r0, r8, ror #29
    3dd8:	00002ef8 	strdeq	r2, [r0], -r8
    P( D, E, F, G, H, A, B, C, R(21), 0x4A7484AA );
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    3ddc:	f8520001 			; <UNDEFINED> instruction: 0xf8520001
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3de0:	e000002e 	and	r0, r0, lr, lsr #32
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3de4:	0100002f 	tsteq	r0, pc, lsr #32
    3de8:	2fe05900 	svccs	0x00e05900
    3dec:	2ff40000 	svccs	0x00f40000
    3df0:	00030000 	andeq	r0, r3, r0
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3df4:	f49f0179 			; <UNDEFINED> instruction: 0xf49f0179
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3df8:	6800002f 	stmdavs	r0, {r0, r1, r2, r3, r5}
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3dfc:	04000030 	streq	r0, [r0], #-48	; 0x30
    3e00:	5201f300 	andpl	pc, r1, #0, 6
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e04:	0030689f 	mlaseq	r0, pc, r8, r6	; <UNPREDICTABLE>
    3e08:	00308800 	eorseq	r8, r0, r0, lsl #16
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e0c:	59000100 	stmdbpl	r0, {r8}
	...
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e18:	00002ee8 	andeq	r2, r0, r8, ror #29
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e1c:	00002efa 	strdeq	r2, [r0], -sl
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e20:	fa530001 	blx	14c3e2c <_etext+0x14bc818>
    3e24:	7e00002e 	cdpvc	0, 0, cr0, cr0, cr14, {1}
    3e28:	0100002f 	tsteq	r0, pc, lsr #32
    3e2c:	2f7e5500 	svccs	0x007e5500
    3e30:	2fc20000 	svccs	0x00c20000
    3e34:	00030000 	andeq	r0, r3, r0
    3e38:	c27fb491 	rsbsgt	fp, pc, #-1862270976	; 0x91000000
    3e3c:	6800002f 	stmdavs	r0, {r0, r1, r2, r3, r5}
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e40:	04000030 	streq	r0, [r0], #-48	; 0x30
    3e44:	5301f300 	movwpl	pc, #4864	; 0x1300	; <UNPREDICTABLE>
    3e48:	0030689f 	mlaseq	r0, pc, r8, r6	; <UNPREDICTABLE>
    3e4c:	00308800 	eorseq	r8, r0, r0, lsl #16
    3e50:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    3e5c:	00002f24 	andeq	r2, r0, r4, lsr #30
    P( C, D, E, F, G, H, A, B, R(22), 0x5CB0A9DC );
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    3e60:	00002fe4 	andeq	r2, r0, r4, ror #31
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e64:	74580001 	ldrbvc	r0, [r8], #-1
    3e68:	82000030 	andhi	r0, r0, #48	; 0x30
    3e6c:	01000030 	tsteq	r0, r0, lsr r0
    3e70:	00005800 	andeq	r5, r0, r0, lsl #16
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e74:	00000000 	andeq	r0, r0, r0
    3e78:	2f3a0000 	svccs	0x003a0000
    3e7c:	2fec0000 	svccs	0x00ec0000
    3e80:	00010000 	andeq	r0, r1, r0
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e84:	00307456 	eorseq	r7, r0, r6, asr r4
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e88:	00308200 	eorseq	r8, r0, r0, lsl #4
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e8c:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3e98:	00002f3a 	andeq	r2, r0, sl, lsr pc
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3e9c:	00002ff8 	strdeq	r2, [r0], -r8
    3ea0:	f85a0001 			; <UNDEFINED> instruction: 0xf85a0001
    3ea4:	fa00002f 	blx	3f68 <sha256_process+0xe88>
    3ea8:	0300002f 	movweq	r0, #47	; 0x2f
    3eac:	9f017a00 	svcls	0x00017a00
    3eb0:	00003074 	andeq	r3, r0, r4, ror r0
    3eb4:	00003082 	andeq	r3, r0, r2, lsl #1
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3eb8:	005a0001 	subseq	r0, sl, r1
    3ebc:	00000000 	andeq	r0, r0, r0
    3ec0:	3a000000 	bcc	3ec8 <sha256_process+0xde8>
    3ec4:	7e00002f 	cdpvc	0, 0, cr0, cr0, cr15, {1}
    3ec8:	0200002f 	andeq	r0, r0, #47	; 0x2f
    P( B, C, D, E, F, G, H, A, R(23), 0x76F988DA );
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    3ecc:	929f3000 	addsls	r3, pc, #0
    3ed0:	9e00002f 	cdpls	0, 0, cr0, cr0, cr15, {1}
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ed4:	0100002f 	tsteq	r0, pc, lsr #32
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3ed8:	2f9e5b00 	svccs	0x009e5b00
    3edc:	2fb40000 	svccs	0x00b40000
    3ee0:	00010000 	andeq	r0, r1, r0
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ee4:	002fb453 	eoreq	fp, pc, r3, asr r4	; <UNPREDICTABLE>
    3ee8:	002fc200 	eoreq	ip, pc, r0, lsl #4
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3eec:	78000900 	stmdavc	r0, {r8, fp}
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3ef0:	32253200 	eorcc	r3, r5, #0, 4
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3ef4:	9f022324 	svcls	0x00022324
    3ef8:	00002ff4 	strdeq	r2, [r0], -r4
    3efc:	00002ff8 	strdeq	r2, [r0], -r8
    3f00:	7f7a0003 	svcvc	0x007a0003
    3f04:	002ff89f 	mlaeq	pc, pc, r8, pc	; <UNPREDICTABLE>
    3f08:	00306000 	eorseq	r6, r0, r0
    3f0c:	5a000100 	bpl	4314 <sha256_process+0x1234>
    3f10:	00003060 	andeq	r3, r0, r0, rrx
    3f14:	00003062 	andeq	r3, r0, r2, rrx
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f18:	017a0003 	cmneq	sl, r3
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3f1c:	0030749f 	mlaseq	r0, pc, r4, r7	; <UNPREDICTABLE>
    3f20:	00307600 	eorseq	r7, r0, r0, lsl #12
    3f24:	30000200 	andcc	r0, r0, r0, lsl #4
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f28:	0030769f 	mlaseq	r0, pc, r6, r7	; <UNPREDICTABLE>
    3f2c:	00308200 	eorseq	r8, r0, r0, lsl #4
    3f30:	52000100 	andpl	r0, r0, #0, 2
	...
    P( A, B, C, D, E, F, G, H, R(24), 0x983E5152 );
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    3f3c:	00002ef6 	strdeq	r2, [r0], -r6
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f40:	00002efa 	strdeq	r2, [r0], -sl
    3f44:	fa530001 	blx	14c3f50 <_etext+0x14bc93c>
    3f48:	7e00002e 	cdpvc	0, 0, cr0, cr0, cr14, {1}
    3f4c:	0100002f 	tsteq	r0, pc, lsr #32
    3f50:	2f7e5500 	svccs	0x007e5500
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f54:	2fc20000 	svccs	0x00c20000
    3f58:	00030000 	andeq	r0, r3, r0
    3f5c:	c27fb491 	rsbsgt	fp, pc, #-1862270976	; 0x91000000
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f60:	6800002f 	stmdavs	r0, {r0, r1, r2, r3, r5}
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f64:	04000030 	streq	r0, [r0], #-48	; 0x30
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f68:	5301f300 	movwpl	pc, #4864	; 0x1300	; <UNPREDICTABLE>
    3f6c:	0030689f 	mlaseq	r0, pc, r8, r6	; <UNPREDICTABLE>
    3f70:	00308800 	eorseq	r8, r0, r0, lsl #16
    3f74:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    3f80:	00002ef6 	strdeq	r2, [r0], -r6
    3f84:	00002efa 	strdeq	r2, [r0], -sl
    3f88:	9f4f0002 	svcls	0x004f0002
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f8c:	00002efa 	strdeq	r2, [r0], -sl
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3f90:	00002efe 	strdeq	r2, [r0], -lr
    3f94:	fe520001 	cdp2	0, 5, cr0, cr2, cr1, {0}
    3f98:	0200002e 	andeq	r0, r0, #46	; 0x2e
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3f9c:	0300002f 	movweq	r0, #47	; 0x2f
    3fa0:	9f017200 	svcls	0x00017200
    3fa4:	00002f02 	andeq	r2, r0, r2, lsl #30
    3fa8:	00002f14 	andeq	r2, r0, r4, lsl pc
    P( H, A, B, C, D, E, F, G, R(25), 0xA831C66D );
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    3fac:	68520001 	ldmdavs	r2, {r0}^
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fb0:	6c000030 	stcvs	0, cr0, [r0], {48}	; 0x30
    3fb4:	03000030 	movweq	r0, #48	; 0x30
    3fb8:	9f017200 	svcls	0x00017200
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fbc:	0000306c 	andeq	r3, r0, ip, rrx
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fc0:	00003074 	andeq	r3, r0, r4, ror r0
    3fc4:	f8090003 			; <UNDEFINED> instruction: 0xf8090003
    3fc8:	0030829f 	mlaseq	r0, pc, r2, r8	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fcc:	00308800 	eorseq	r8, r0, r0, lsl #16
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fd0:	09000300 	stmdbeq	r0, {r8, r9}
    3fd4:	00009ff8 	strdeq	r9, [r0], -r8
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    3fd8:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    3fdc:	2f080000 	svccs	0x00080000
    3fe0:	2f0a0000 	svccs	0x000a0000
    3fe4:	00050000 	andeq	r0, r5, r0
    3fe8:	00720075 	rsbseq	r0, r2, r5, ror r0
    3fec:	002f0a22 	eoreq	r0, pc, r2, lsr #20
    3ff0:	002f0c00 	eoreq	r0, pc, r0, lsl #24
    3ff4:	73000500 	movwvc	r0, #1280	; 0x500
    3ff8:	9f253100 	svcls	0x00253100
    3ffc:	0000306c 	andeq	r3, r0, ip, rrx
    4000:	00003074 	andeq	r3, r0, r4, ror r0
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4004:	7f750002 	svcvc	0x00750002
    4008:	00003082 	andeq	r3, r0, r2, lsl #1
    400c:	00003088 	andeq	r3, r0, r8, lsl #1
    4010:	7f750002 	svcvc	0x00750002
	...
    P( G, H, A, B, C, D, E, F, R(26), 0xB00327C8 );
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    401c:	00002f18 	andeq	r2, r0, r8, lsl pc
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4020:	00002f36 	andeq	r2, r0, r6, lsr pc
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4024:	365a0001 	ldrbcc	r0, [sl], -r1
    4028:	e000002f 	and	r0, r0, pc, lsr #32
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    402c:	0500002f 	streq	r0, [r0, #-47]	; 0x2f
    4030:	33007900 	movwcc	r7, #2304	; 0x900
    4034:	2fe09f24 	svccs	0x00e09f24
    4038:	2ff40000 	svccs	0x00f40000
    403c:	00050000 	andeq	r0, r5, r0
    4040:	24330179 	ldrtcs	r0, [r3], #-377	; 0x179
    4044:	002ff49f 	mlaeq	pc, pc, r4, pc	; <UNPREDICTABLE>
    4048:	00306800 	eorseq	r6, r0, r0, lsl #16
    404c:	f3000600 	vmax.u8	d0, d0, d0
    4050:	24335201 	ldrtcs	r5, [r3], #-513	; 0x201
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4054:	0030749f 	mlaseq	r0, pc, r4, r7	; <UNPREDICTABLE>
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4058:	00308200 	eorseq	r8, r0, r0, lsl #4
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    405c:	79000500 	stmdbvc	r0, {r8, sl}
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4060:	9f243300 	svcls	0x00243300
	...
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    406c:	00002f18 	andeq	r2, r0, r8, lsl pc
    4070:	00002f2a 	andeq	r2, r0, sl, lsr #30
    4074:	00520001 	subseq	r0, r2, r1
    4078:	00000000 	andeq	r0, r0, r0
    407c:	c8000000 	stmdagt	r0, {}	; <UNPREDICTABLE>
    4080:	ce00002f 	cdpgt	0, 0, cr0, cr0, cr15, {1}
    4084:	0100002f 	tsteq	r0, pc, lsr #32
    4088:	2fd05200 	svccs	0x00d05200
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    408c:	2fe80000 	svccs	0x00e80000
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    4090:	00010000 	andeq	r0, r1, r0
    4094:	00000052 	andeq	r0, r0, r2, asr r0
    4098:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    409c:	002fc800 	eoreq	ip, pc, r0, lsl #16
    40a0:	002fd400 	eoreq	sp, pc, r0, lsl #8
    40a4:	53000100 	movwpl	r0, #256	; 0x100
    40a8:	00002fd4 	ldrdeq	r2, [r0], -r4
    40ac:	00002fda 	ldrdeq	r2, [r0], -sl
    40b0:	7f730003 	svcvc	0x00730003
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40b4:	002fda9f 	mlaeq	pc, pc, sl, sp	; <UNPREDICTABLE>
    P( F, G, H, A, B, C, D, E, R(27), 0xBF597FC7 );
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    40b8:	002ff000 	eoreq	pc, pc, r0
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    40bc:	53000100 	movwpl	r0, #256	; 0x100
	...
    40c8:	0000300c 	andeq	r3, r0, ip
    40cc:	0000302a 	andeq	r3, r0, sl, lsr #32
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    40d0:	00500001 	subseq	r0, r0, r1
    40d4:	00000000 	andeq	r0, r0, r0
    40d8:	0c000000 	stceq	0, cr0, [r0], {-0}
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    40dc:	62000030 	andvs	r0, r0, #48	; 0x30
    40e0:	02000030 	andeq	r0, r0, #48	; 0x30
    40e4:	009f3100 	addseq	r3, pc, r0, lsl #2
    40e8:	00000000 	andeq	r0, r0, r0
    40ec:	0c000000 	stceq	0, cr0, [r0], {-0}
    40f0:	0e000030 	mcreq	0, 0, r0, cr0, cr0, {1}
    40f4:	02000030 	andeq	r0, r0, #48	; 0x30
    40f8:	0e9f3000 	cdpeq	0, 9, cr3, cr15, cr0, {0}
    40fc:	24000030 	strcs	r0, [r0], #-48	; 0x30
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4100:	01000030 	tsteq	r0, r0, lsr r0
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4104:	00005200 	andeq	r5, r0, r0, lsl #4
    4108:	00000000 	andeq	r0, r0, r0
    410c:	300c0000 	andcc	r0, ip, r0
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4110:	300e0000 	andcc	r0, lr, r0
    4114:	00020000 	andeq	r0, r2, r0
    4118:	300e9f30 	andcc	r9, lr, r0, lsr pc
    411c:	30180000 	andscc	r0, r8, r0
    4120:	00010000 	andeq	r0, r1, r0
    4124:	00301853 	eorseq	r1, r0, r3, asr r8
    P( E, F, G, H, A, B, C, D, R(28), 0xC6E00BF3 );
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    4128:	00301e00 	eorseq	r1, r0, r0, lsl #28
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    412c:	73000300 	movwvc	r0, #768	; 0x300
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4130:	301e9f7f 	andscc	r9, lr, pc, ror pc
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4134:	30220000 	eorcc	r0, r2, r0
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4138:	00010000 	andeq	r0, r1, r0
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    413c:	00000053 	andeq	r0, r0, r3, asr r0
    4140:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4144:	00302800 	eorseq	r2, r0, r0, lsl #16
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4148:	00306200 	eorseq	r6, r0, r0, lsl #4
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    414c:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4158:	00003028 	andeq	r3, r0, r8, lsr #32
    415c:	0000302a 	andeq	r3, r0, sl, lsr #32
    4160:	9f300002 	svcls	0x00300002
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4164:	0000302a 	andeq	r3, r0, sl, lsr #32
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    4168:	00003032 	andeq	r3, r0, r2, lsr r0
    416c:	34520001 	ldrbcc	r0, [r2], #-1
    4170:	44000030 	strmi	r0, [r0], #-48	; 0x30
    4174:	01000030 	tsteq	r0, r0, lsr r0
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4178:	30445200 	subcc	r5, r4, r0, lsl #4
    P( D, E, F, G, H, A, B, C, R(29), 0xD5A79147 );
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    417c:	30460000 	subcc	r0, r6, r0
    4180:	00040000 	andeq	r0, r4, r0
    4184:	9f1f0072 	svcls	0x001f0072
	...
    4190:	00003028 	andeq	r3, r0, r8, lsr #32
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4194:	0000302a 	andeq	r3, r0, sl, lsr #32
    4198:	9f300002 	svcls	0x00300002
    419c:	0000302a 	andeq	r3, r0, sl, lsr #32
    41a0:	0000303a 	andeq	r3, r0, sl, lsr r0
    41a4:	3a530001 	bcc	14c41b0 <_etext+0x14bcb9c>
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41a8:	40000030 	andmi	r0, r0, r0, lsr r0
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41ac:	03000030 	movweq	r0, #48	; 0x30
    41b0:	9f7f7300 	svcls	0x007f7300
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41b4:	00003040 	andeq	r3, r0, r0, asr #32
    41b8:	00003048 	andeq	r3, r0, r8, asr #32
    41bc:	00530001 	subseq	r0, r3, r1
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41c0:	00000000 	andeq	r0, r0, r0
    41c4:	42000000 	andmi	r0, r0, #0
    41c8:	44000030 	strmi	r0, [r0], #-48	; 0x30
    41cc:	01000030 	tsteq	r0, r0, lsr r0
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41d0:	30445200 	subcc	r5, r4, r0, lsl #4
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41d4:	30460000 	subcc	r0, r6, r0
    41d8:	00040000 	andeq	r0, r4, r0
    41dc:	9f1f0072 	svcls	0x001f0072
	...
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41e8:	00003042 	andeq	r3, r0, r2, asr #32
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    41ec:	00003062 	andeq	r3, r0, r2, rrx
    41f0:	005d0001 	subseq	r0, sp, r1
    41f4:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    41f8:	46000000 	strmi	r0, [r0], -r0
    41fc:	62000030 	andvs	r0, r0, #48	; 0x30
    4200:	01000030 	tsteq	r0, r0, lsr r0
    4204:	00005200 	andeq	r5, r0, r0, lsl #4
    4208:	00000000 	andeq	r0, r0, r0
    420c:	30460000 	subcc	r0, r6, r0
    4210:	30480000 	subcc	r0, r8, r0
    P( C, D, E, F, G, H, A, B, R(30), 0x06CA6351 );
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    4214:	00020000 	andeq	r0, r2, r0
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4218:	30489f30 	subcc	r9, r8, r0, lsr pc
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    421c:	30620000 	rsbcc	r0, r2, r0
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4220:	00010000 	andeq	r0, r1, r0
    4224:	00000053 	andeq	r0, r0, r3, asr r0
	...
    4234:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4240:	00510001 	subseq	r0, r1, r1
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4244:	00000000 	andeq	r0, r0, r0
    4248:	01000000 	mrseq	r0, (UNDEF: 0)
    424c:	00005500 	andeq	r5, r0, r0, lsl #10
	...
    425c:	00010000 	andeq	r0, r1, r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4260:	00000051 	andeq	r0, r0, r1, asr r0
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    4264:	00000000 	andeq	r0, r0, r0
    4268:	53000100 	movwpl	r0, #256	; 0x100
	...
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4274:	01f30004 	mvnseq	r0, r4
    4278:	00009f51 	andeq	r9, r0, r1, asr pc
	...
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4288:	00010000 	andeq	r0, r1, r0
    P( B, C, D, E, F, G, H, A, R(31), 0x14292967 );
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    428c:	0000005d 	andeq	r0, r0, sp, asr r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4290:	00000000 	andeq	r0, r0, r0
    4294:	74000300 	strvc	r0, [r0], #-768	; 0x300
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4298:	00009f60 	andeq	r9, r0, r0, ror #30
	...
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    42a8:	00010000 	andeq	r0, r1, r0
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42ac:	00000050 	andeq	r0, r0, r0, asr r0
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    42b0:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42b4:	f3000400 	vshl.u8	d0, d0, d0
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    42b8:	009f5001 	addseq	r5, pc, r1
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42bc:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    42c0:	01000000 	mrseq	r0, (UNDEF: 0)
    42c4:	00005000 	andeq	r5, r0, r0
	...
    42d4:	00010000 	andeq	r0, r1, r0
    42d8:	00000051 	andeq	r0, r0, r1, asr r0
    42dc:	00000000 	andeq	r0, r0, r0
    42e0:	f3000400 	vshl.u8	d0, d0, d0
    42e4:	009f5101 	addseq	r5, pc, r1, lsl #2
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    42e8:	00000000 	andeq	r0, r0, r0
    42ec:	01000000 	mrseq	r0, (UNDEF: 0)
    42f0:	00005100 	andeq	r5, r0, r0, lsl #2
	...
    4300:	00020000 	andeq	r0, r2, r0
    4304:	00009f30 	andeq	r9, r0, r0, lsr pc
    P( A, B, C, D, E, F, G, H, R(32), 0x27B70A85 );
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    4308:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    430c:	00010000 	andeq	r0, r1, r0
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4310:	00000052 	andeq	r0, r0, r2, asr r0
    4314:	00000000 	andeq	r0, r0, r0
    4318:	72000800 	andvc	r0, r0, #0, 16
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    431c:	72253100 	eorvc	r3, r5, #0, 2
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4320:	009f2100 	addseq	r2, pc, r0, lsl #2
    4324:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4328:	02000000 	andeq	r0, r0, #0
    432c:	009f3000 	addseq	r3, pc, r0
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4330:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4334:	01000000 	mrseq	r0, (UNDEF: 0)
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4338:	00005200 	andeq	r5, r0, r0, lsl #4
	...
    4348:	00020000 	andeq	r0, r2, r0
    434c:	00009f30 	andeq	r9, r0, r0, lsr pc
    4350:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4354:	00020000 	andeq	r0, r2, r0
    P( H, A, B, C, D, E, F, G, R(33), 0x2E1B2138 );
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    4358:	00009f30 	andeq	r9, r0, r0, lsr pc
    435c:	00000000 	andeq	r0, r0, r0
    4360:	00010000 	andeq	r0, r1, r0
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    4364:	00000053 	andeq	r0, r0, r3, asr r0
    4368:	00000000 	andeq	r0, r0, r0
    436c:	73000300 	movwvc	r0, #768	; 0x300
    4370:	00009f7f 	andeq	r9, r0, pc, ror pc
    4374:	00000000 	andeq	r0, r0, r0
    4378:	00010000 	andeq	r0, r1, r0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    437c:	00000053 	andeq	r0, r0, r3, asr r0
	...
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    438c:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    4398:	01f30004 	mvnseq	r0, r4
    439c:	00009f51 	andeq	r9, r0, r1, asr pc
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43a0:	00000000 	andeq	r0, r0, r0
    43a4:	00010000 	andeq	r0, r1, r0
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43a8:	00000051 	andeq	r0, r0, r1, asr r0
	...
    43b8:	52000100 	andpl	r0, r0, #0, 2
	...
    43c4:	01f30004 	mvnseq	r0, r4
    43c8:	00009f52 	andeq	r9, r0, r2, asr pc
    43cc:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43d0:	00010000 	andeq	r0, r1, r0
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43d4:	00000052 	andeq	r0, r0, r2, asr r0
	...
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    43e4:	53000100 	movwpl	r0, #256	; 0x100
	...
    43f0:	01f30004 	mvnseq	r0, r4
    P( G, H, A, B, C, D, E, F, R(34), 0x4D2C6DFC );
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    43f4:	00009f53 	andeq	r9, r0, r3, asr pc
	...
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4404:	00010000 	andeq	r0, r1, r0
    4408:	00000053 	andeq	r0, r0, r3, asr r0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    440c:	00000000 	andeq	r0, r0, r0
    4410:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    441c:	00560001 	subseq	r0, r6, r1
	...
    442c:	02000000 	andeq	r0, r0, #0
    4430:	009f3000 	addseq	r3, pc, r0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4434:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4438:	02000000 	andeq	r0, r0, #0
    443c:	009f3000 	addseq	r3, pc, r0
    4440:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4444:	01000000 	mrseq	r0, (UNDEF: 0)
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4448:	00005300 	andeq	r5, r0, r0, lsl #6
	...
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4458:	00010000 	andeq	r0, r1, r0
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    445c:	00000051 	andeq	r0, r0, r1, asr r0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4460:	00000000 	andeq	r0, r0, r0
    4464:	f3000400 	vshl.u8	d0, d0, d0
    P( F, G, H, A, B, C, D, E, R(35), 0x53380D13 );
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    4468:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    4478:	01000000 	mrseq	r0, (UNDEF: 0)
    447c:	00005200 	andeq	r5, r0, r0, lsl #4
    4480:	00000000 	andeq	r0, r0, r0
    4484:	00040000 	andeq	r0, r4, r0
    4488:	9f5201f3 	svcls	0x005201f3
	...
    449c:	00510001 	subseq	r0, r1, r1
    44a0:	00000000 	andeq	r0, r0, r0
    44a4:	04000000 	streq	r0, [r0], #-0
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44a8:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    44ac:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    44bc:	30000200 	andcc	r0, r0, r0, lsl #4
    P( E, F, G, H, A, B, C, D, R(36), 0x650A7354 );
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    44c0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    44c4:	00000000 	andeq	r0, r0, r0
    44c8:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    44dc:	9f300002 	svcls	0x00300002
	...
    44e8:	00530001 	subseq	r0, r3, r1
    44ec:	00000000 	andeq	r0, r0, r0
    44f0:	03000000 	movweq	r0, #0
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    44f4:	9f7f7300 	svcls	0x007f7300
	...
    4500:	00530001 	subseq	r0, r3, r1
	...
    4510:	01000000 	mrseq	r0, (UNDEF: 0)
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4514:	00005100 	andeq	r5, r0, r0, lsl #2
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4518:	00000000 	andeq	r0, r0, r0
    451c:	00010000 	andeq	r0, r1, r0
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4520:	00000051 	andeq	r0, r0, r1, asr r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4524:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4528:	71000400 	tstvc	r0, r0, lsl #8
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    452c:	009f1f00 	addseq	r1, pc, r0, lsl #30
	...
    453c:	01000000 	mrseq	r0, (UNDEF: 0)
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4540:	00005300 	andeq	r5, r0, r0, lsl #6
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4544:	00000000 	andeq	r0, r0, r0
    4548:	00030000 	andeq	r0, r3, r0
    454c:	009f7f73 	addseq	r7, pc, r3, ror pc	; <UNPREDICTABLE>
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    4550:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(37), 0x766A0ABB );
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    4554:	01000000 	mrseq	r0, (UNDEF: 0)
    4558:	00005300 	andeq	r5, r0, r0, lsl #6
	...
    4568:	00010000 	andeq	r0, r1, r0
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    456c:	00000051 	andeq	r0, r0, r1, asr r0
    4570:	00000000 	andeq	r0, r0, r0
    4574:	71000400 	tstvc	r0, r0, lsl #8
    4578:	009f1f00 	addseq	r1, pc, r0, lsl #30
	...
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4588:	01000000 	mrseq	r0, (UNDEF: 0)
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    458c:	00005d00 	andeq	r5, r0, r0, lsl #26
    4590:	00000000 	andeq	r0, r0, r0
    4594:	00030000 	andeq	r0, r3, r0
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4598:	009f5091 	umullseq	r5, pc, r1, r0	; <UNPREDICTABLE>
    459c:	00000000 	andeq	r0, r0, r0
    45a0:	03000000 	movweq	r0, #0
    P( C, D, E, F, G, H, A, B, R(38), 0x81C2C92E );
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    45a4:	9f507d00 	svcls	0x00507d00
	...
    45b8:	9f300002 	svcls	0x00300002
	...
    45c4:	00530001 	subseq	r0, r3, r1
	...
    45d4:	01000000 	mrseq	r0, (UNDEF: 0)
    45d8:	00005100 	andeq	r5, r0, r0, lsl #2
    45dc:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    45e0:	00040000 	andeq	r0, r4, r0
    45e4:	9f5101f3 	svcls	0x005101f3
	...
    45f8:	00520001 	subseq	r0, r2, r1
    45fc:	00000000 	andeq	r0, r0, r0
    4600:	04000000 	streq	r0, [r0], #-0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4604:	5201f300 	andpl	pc, r1, #0, 6
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4608:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4618:	52000100 	andpl	r0, r0, #0, 2
	...
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4624:	01f30004 	mvnseq	r0, r4
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4628:	00009f52 	andeq	r9, r0, r2, asr pc
	...
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4638:	00020000 	andeq	r0, r2, r0
    463c:	00009f30 	andeq	r9, r0, r0, lsr pc
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4640:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4644:	00010000 	andeq	r0, r1, r0
    4648:	00000054 	andeq	r0, r0, r4, asr r0
	...
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4658:	30000200 	andcc	r0, r0, r0, lsl #4
    465c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4660:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(39), 0x92722C85 );
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    4664:	53000100 	movwpl	r0, #256	; 0x100
	...
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4670:	7f730003 	svcvc	0x00730003
    4674:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4678:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    467c:	53000100 	movwpl	r0, #256	; 0x100
	...
    4690:	00540001 	subseq	r0, r4, r1
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4694:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(40), 0xA2BFE8A1 );
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    4698:	01000000 	mrseq	r0, (UNDEF: 0)
    469c:	00005400 	andeq	r5, r0, r0, lsl #8
    46a0:	00000000 	andeq	r0, r0, r0
    46a4:	00040000 	andeq	r0, r4, r0
    46a8:	9f1f0074 	svcls	0x001f0074
	...
    46bc:	00530001 	subseq	r0, r3, r1
    46c0:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46c4:	03000000 	movweq	r0, #0
    46c8:	9f7f7300 	svcls	0x007f7300
	...
    46d4:	00530001 	subseq	r0, r3, r1
	...
    46e4:	01000000 	mrseq	r0, (UNDEF: 0)
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46e8:	00005400 	andeq	r5, r0, r0, lsl #8
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    46ec:	00000000 	andeq	r0, r0, r0
    46f0:	00040000 	andeq	r0, r4, r0
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    46f4:	9f1f0074 	svcls	0x001f0074
	...
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4708:	005d0001 	subseq	r0, sp, r1
    470c:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4710:	03000000 	movweq	r0, #0
    P( H, A, B, C, D, E, F, G, R(41), 0xA81A664B );
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    4714:	9f509100 	svcls	0x00509100
	...
    4720:	507d0003 	rsbspl	r0, sp, r3
    4724:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    4734:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4748:	9f300002 	svcls	0x00300002
	...
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4754:	00530001 	subseq	r0, r3, r1
	...
    4764:	01000000 	mrseq	r0, (UNDEF: 0)
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4768:	00005200 	andeq	r5, r0, r0, lsl #4
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    476c:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4770:	00040000 	andeq	r0, r4, r0
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4774:	9f5201f3 	svcls	0x005201f3
	...
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    4788:	9f300002 	svcls	0x00300002
	...
    4794:	00510001 	subseq	r0, r1, r1
    4798:	00000000 	andeq	r0, r0, r0
    479c:	01000000 	mrseq	r0, (UNDEF: 0)
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47a0:	00005100 	andeq	r5, r0, r0, lsl #2
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    47a4:	00000000 	andeq	r0, r0, r0
    47a8:	00040000 	andeq	r0, r4, r0
    47ac:	9f1f0071 	svcls	0x001f0071
	...
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47c0:	9f300002 	svcls	0x00300002
	...
    P( G, H, A, B, C, D, E, F, R(42), 0xC24B8B70 );
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    47cc:	00530001 	subseq	r0, r3, r1
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47d0:	00000000 	andeq	r0, r0, r0
    47d4:	03000000 	movweq	r0, #0
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47d8:	9f7f7300 	svcls	0x007f7300
	...
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47e4:	00530001 	subseq	r0, r3, r1
	...
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    47f4:	01000000 	mrseq	r0, (UNDEF: 0)
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    47f8:	00005100 	andeq	r5, r0, r0, lsl #2
    47fc:	00000000 	andeq	r0, r0, r0
    4800:	00040000 	andeq	r0, r4, r0
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4804:	9f1f0071 	svcls	0x001f0071
	...
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4818:	005d0001 	subseq	r0, sp, r1
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    481c:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(43), 0xC76C51A3 );
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    4820:	03000000 	movweq	r0, #0
    4824:	9f509100 	svcls	0x00509100
	...
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4830:	507d0003 	rsbspl	r0, sp, r3
    4834:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4844:	30000200 	andcc	r0, r0, r0, lsl #4
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4848:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    484c:	00000000 	andeq	r0, r0, r0
    4850:	53000100 	movwpl	r0, #256	; 0x100
	...
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4864:	00500001 	subseq	r0, r0, r1
    4868:	00000000 	andeq	r0, r0, r0
    486c:	01000000 	mrseq	r0, (UNDEF: 0)
    4870:	00005500 	andeq	r5, r0, r0, lsl #10
	...
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4880:	00010000 	andeq	r0, r1, r0
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    4884:	00000051 	andeq	r0, r0, r1, asr r0
    4888:	00000000 	andeq	r0, r0, r0
    488c:	58000100 	stmdapl	r0, {r8}
	...
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48a0:	00520001 	subseq	r0, r2, r1
    P( E, F, G, H, A, B, C, D, R(44), 0xD192E819 );
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    48a4:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48a8:	01000000 	mrseq	r0, (UNDEF: 0)
    48ac:	00005a00 	andeq	r5, r0, r0, lsl #20
	...
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48bc:	00010000 	andeq	r0, r1, r0
    48c0:	00000053 	andeq	r0, r0, r3, asr r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48c4:	00000000 	andeq	r0, r0, r0
    48c8:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    48dc:	7f720003 	svcvc	0x00720003
    48e0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    48e4:	00000000 	andeq	r0, r0, r0
    48e8:	5c000100 	stfpls	f0, [r0], {-0}
	...
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    48f4:	017c0003 	cmneq	ip, r3
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    48f8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    4908:	4f000200 	svcmi	0x00000200
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    490c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4910:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4914:	52000100 	andpl	r0, r0, #0, 2
	...
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4920:	01720003 	cmneq	r2, r3
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4924:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4928:	00000000 	andeq	r0, r0, r0
    492c:	52000100 	andpl	r0, r0, #0, 2
	...
    4938:	01720003 	cmneq	r2, r3
    493c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4940:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4944:	09000300 	stmdbeq	r0, {r8, r9}
    4948:	00009ff8 	strdeq	r9, [r0], -r8
	...
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4958:	00050000 	andeq	r0, r5, r0
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    495c:	00720077 	rsbseq	r0, r2, r7, ror r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4960:	00000022 	andeq	r0, r0, r2, lsr #32
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    4964:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(45), 0xD6990624 );
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    4968:	73000500 	movwvc	r0, #1280	; 0x500
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    496c:	9f253100 	svcls	0x00253100
	...
    4978:	7f770002 	svcvc	0x00770002
	...
    498c:	00590001 	subseq	r0, r9, r1
    4990:	00000000 	andeq	r0, r0, r0
    4994:	04000000 	streq	r0, [r0], #-0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4998:	1f007900 	svcne	0x00007900
    499c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    P( C, D, E, F, G, H, A, B, R(46), 0xF40E3585 );
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    49ac:	31000200 	mrscc	r0, R8_usr
    49b0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49c0:	30000200 	andcc	r0, r0, r0, lsl #4
    49c4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    49c8:	00000000 	andeq	r0, r0, r0
    49cc:	52000100 	andpl	r0, r0, #0, 2
	...
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49e0:	9f300002 	svcls	0x00300002
	...
    49ec:	00530001 	subseq	r0, r3, r1
    49f0:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    49f4:	03000000 	movweq	r0, #0
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    49f8:	9f7f7300 	svcls	0x007f7300
	...
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a04:	00530001 	subseq	r0, r3, r1
	...
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a14:	01000000 	mrseq	r0, (UNDEF: 0)
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a18:	00005200 	andeq	r5, r0, r0, lsl #4
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a1c:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(47), 0x106AA070 );
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    4a20:	00010000 	andeq	r0, r1, r0
    4a24:	00000052 	andeq	r0, r0, r2, asr r0
    4a28:	00000000 	andeq	r0, r0, r0
    4a2c:	72000400 	andvc	r0, r0, #0, 8
    4a30:	009f1f00 	addseq	r1, pc, r0, lsl #30
	...
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a40:	01000000 	mrseq	r0, (UNDEF: 0)
    4a44:	00005300 	andeq	r5, r0, r0, lsl #6
    4a48:	00000000 	andeq	r0, r0, r0
    4a4c:	00030000 	andeq	r0, r3, r0
    4a50:	009f7f73 	addseq	r7, pc, r3, ror pc	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a54:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a58:	01000000 	mrseq	r0, (UNDEF: 0)
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a5c:	00005300 	andeq	r5, r0, r0, lsl #6
	...
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a6c:	00010000 	andeq	r0, r1, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a70:	00000052 	andeq	r0, r0, r2, asr r0
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a74:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4a78:	72000400 	andvc	r0, r0, #0, 8
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4a7c:	009f1f00 	addseq	r1, pc, r0, lsl #30
	...
    4a8c:	01000000 	mrseq	r0, (UNDEF: 0)
    4a90:	00005600 	andeq	r5, r0, r0, lsl #12
	...
    4aa0:	00010000 	andeq	r0, r1, r0
    4aa4:	00000052 	andeq	r0, r0, r2, asr r0
	...
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4ab4:	30000200 	andcc	r0, r0, r0, lsl #4
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4ab8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4abc:	00000000 	andeq	r0, r0, r0
    4ac0:	53000100 	movwpl	r0, #256	; 0x100
	...
    P( A, B, C, D, E, F, G, H, R(48), 0x19A4C116 );
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    4ad4:	00550001 	subseq	r0, r5, r1
	...
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4ae4:	01000000 	mrseq	r0, (UNDEF: 0)
    4ae8:	00005d00 	andeq	r5, r0, r0, lsl #26
	...
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4af8:	00010000 	andeq	r0, r1, r0
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4afc:	0000005d 	andeq	r0, r0, sp, asr r0
	...
    4b0c:	30000200 	andcc	r0, r0, r0, lsl #4
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b10:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b14:	00000000 	andeq	r0, r0, r0
    4b18:	5b000100 	blpl	4f20 <sha256_process+0x1e40>
	...
    4b24:	00530001 	subseq	r0, r3, r1
    4b28:	00000000 	andeq	r0, r0, r0
    4b2c:	01000000 	mrseq	r0, (UNDEF: 0)
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b30:	00005b00 	andeq	r5, r0, r0, lsl #22
	...
    4b40:	00020000 	andeq	r0, r2, r0
    4b44:	00009f30 	andeq	r9, r0, r0, lsr pc
    4b48:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(49), 0x1E376C08 );
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    4b4c:	00010000 	andeq	r0, r1, r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b50:	00000054 	andeq	r0, r0, r4, asr r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b54:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b58:	74000300 	strvc	r0, [r0], #-768	; 0x300
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b5c:	00009f7f 	andeq	r9, r0, pc, ror pc
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b60:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4b64:	00010000 	andeq	r0, r1, r0
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4b68:	00000054 	andeq	r0, r0, r4, asr r0
	...
    4b78:	53000100 	movwpl	r0, #256	; 0x100
	...
    4b84:	00530001 	subseq	r0, r3, r1
    4b88:	00000000 	andeq	r0, r0, r0
    4b8c:	04000000 	streq	r0, [r0], #-0
    4b90:	1f007300 	svcne	0x00007300
    4b94:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4ba4:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    4bb0:	7f740003 	svcvc	0x00740003
    P( G, H, A, B, C, D, E, F, R(50), 0x2748774C );
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    4bb4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4bb8:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bbc:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    4bd0:	00530001 	subseq	r0, r3, r1
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4bd4:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4bd8:	04000000 	streq	r0, [r0], #-0
    4bdc:	1f007300 	svcne	0x00007300
    4be0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    4bf0:	5d000100 	stfpls	f0, [r0, #-0]
	...
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c04:	00560001 	subseq	r0, r6, r1
	...
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4c14:	01000000 	mrseq	r0, (UNDEF: 0)
    4c18:	00005300 	andeq	r5, r0, r0, lsl #6
	...
    4c28:	00020000 	andeq	r0, r2, r0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c2c:	00009f30 	andeq	r9, r0, r0, lsr pc
    P( F, G, H, A, B, C, D, E, R(51), 0x34B0BCB5 );
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    4c30:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c34:	00010000 	andeq	r0, r1, r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c38:	00000052 	andeq	r0, r0, r2, asr r0
	...
    4c48:	59000100 	stmdbpl	r0, {r8}
	...
    4c54:	00790004 	rsbseq	r0, r9, r4
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c58:	00009f1f 	andeq	r9, r0, pc, lsl pc
	...
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c68:	00010000 	andeq	r0, r1, r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c6c:	0000005d 	andeq	r0, r0, sp, asr r0
	...
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c7c:	59000100 	stmdbpl	r0, {r8}
	...
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4c90:	9f300002 	svcls	0x00300002
	...
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4c9c:	00530001 	subseq	r0, r3, r1
	...
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cac:	01000000 	mrseq	r0, (UNDEF: 0)
    4cb0:	00005000 	andeq	r5, r0, r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4cb4:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cb8:	00010000 	andeq	r0, r1, r0
    P( E, F, G, H, A, B, C, D, R(52), 0x391C0CB3 );
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    4cbc:	00000056 	andeq	r0, r0, r6, asr r0
	...
    4ccc:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cd8:	00580001 	subseq	r0, r8, r1
	...
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4ce8:	01000000 	mrseq	r0, (UNDEF: 0)
    4cec:	00005200 	andeq	r5, r0, r0, lsl #4
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4cf0:	00000000 	andeq	r0, r0, r0
    4cf4:	00010000 	andeq	r0, r1, r0
    4cf8:	00000057 	andeq	r0, r0, r7, asr r0
	...
    4d08:	32000200 	andcc	r0, r0, #0, 4
    4d0c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4d10:	00000000 	andeq	r0, r0, r0
    4d14:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d20:	00550001 	subseq	r0, r5, r1
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d24:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d28:	01000000 	mrseq	r0, (UNDEF: 0)
    4d2c:	00005500 	andeq	r5, r0, r0, lsl #10
	...
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d3c:	00020000 	andeq	r0, r2, r0
    4d40:	00009f30 	andeq	r9, r0, r0, lsr pc
    4d44:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d48:	00010000 	andeq	r0, r1, r0
    4d4c:	00000054 	andeq	r0, r0, r4, asr r0
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d50:	00000000 	andeq	r0, r0, r0
    4d54:	74000300 	strvc	r0, [r0], #-768	; 0x300
    4d58:	00009f7f 	andeq	r9, r0, pc, ror pc
    4d5c:	00000000 	andeq	r0, r0, r0
    4d60:	00010000 	andeq	r0, r1, r0
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d64:	00000054 	andeq	r0, r0, r4, asr r0
    4d68:	00000000 	andeq	r0, r0, r0
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d6c:	75000300 	strvc	r0, [r0, #-768]	; 0x300
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d70:	00009f7f 	andeq	r9, r0, pc, ror pc
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d74:	00000000 	andeq	r0, r0, r0
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d78:	00010000 	andeq	r0, r1, r0
    4d7c:	00000055 	andeq	r0, r0, r5, asr r0
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d80:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d84:	75000300 	strvc	r0, [r0, #-768]	; 0x300
    P( D, E, F, G, H, A, B, C, R(53), 0x4ED8AA4A );
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    4d88:	00009f01 	andeq	r9, r0, r1, lsl #30
    4d8c:	00000000 	andeq	r0, r0, r0
    4d90:	00010000 	andeq	r0, r1, r0
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4d94:	00000055 	andeq	r0, r0, r5, asr r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4d98:	00000000 	andeq	r0, r0, r0
    4d9c:	75000300 	strvc	r0, [r0, #-768]	; 0x300
    4da0:	00009f01 	andeq	r9, r0, r1, lsl #30
    4da4:	00000000 	andeq	r0, r0, r0
    4da8:	00010000 	andeq	r0, r1, r0
    4dac:	00000054 	andeq	r0, r0, r4, asr r0
	...
    4dbc:	52000100 	andpl	r0, r0, #0, 2
	...
    4dc8:	00570001 	subseq	r0, r7, r1
	...
    4dd8:	01000000 	mrseq	r0, (UNDEF: 0)
    4ddc:	00005d00 	andeq	r5, r0, r0, lsl #26
    4de0:	00000000 	andeq	r0, r0, r0
    4de4:	00040000 	andeq	r0, r4, r0
    4de8:	9f7fa891 	svcls	0x007fa891
	...
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4df4:	005d0001 	subseq	r0, sp, r1
	...
    4e04:	02000000 	andeq	r0, r0, #0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4e08:	009f3100 	addseq	r3, pc, r0, lsl #2
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e0c:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4e10:	02000000 	andeq	r0, r0, #0
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e14:	009f3000 	addseq	r3, pc, r0
	...
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e24:	02000000 	andeq	r0, r0, #0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e28:	009f3000 	addseq	r3, pc, r0
    4e2c:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4e30:	02000000 	andeq	r0, r0, #0
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e34:	009f3100 	addseq	r3, pc, r0, lsl #2
    P( C, D, E, F, G, H, A, B, R(54), 0x5B9CCA4F );
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    4e38:	00000000 	andeq	r0, r0, r0
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e3c:	02000000 	andeq	r0, r0, #0
    4e40:	009f3200 	addseq	r3, pc, r0, lsl #4
    4e44:	00000000 	andeq	r0, r0, r0
    4e48:	02000000 	andeq	r0, r0, #0
    4e4c:	009f3300 	addseq	r3, pc, r0, lsl #6
    4e50:	00000000 	andeq	r0, r0, r0
    4e54:	02000000 	andeq	r0, r0, #0
    4e58:	009f3400 	addseq	r3, pc, r0, lsl #8
	...
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e68:	01000000 	mrseq	r0, (UNDEF: 0)
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e6c:	00005200 	andeq	r5, r0, r0, lsl #4
    4e70:	00000000 	andeq	r0, r0, r0
    4e74:	00030000 	andeq	r0, r3, r0
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e78:	009f0172 	addseq	r0, pc, r2, ror r1	; <UNPREDICTABLE>
    4e7c:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e80:	01000000 	mrseq	r0, (UNDEF: 0)
    4e84:	00005200 	andeq	r5, r0, r0, lsl #4
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e88:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e8c:	00010000 	andeq	r0, r1, r0
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e90:	00000055 	andeq	r0, r0, r5, asr r0
    4e94:	00000000 	andeq	r0, r0, r0
    P( B, C, D, E, F, G, H, A, R(55), 0x682E6FF3 );
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    4e98:	75000300 	strvc	r0, [r0, #-768]	; 0x300
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4e9c:	00009f01 	andeq	r9, r0, r1, lsl #30
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ea0:	00000000 	andeq	r0, r0, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ea4:	00030000 	andeq	r0, r3, r0
    4ea8:	009f0172 	addseq	r0, pc, r2, ror r1	; <UNPREDICTABLE>
    4eac:	00000000 	andeq	r0, r0, r0
    4eb0:	03000000 	movweq	r0, #0
    4eb4:	9ff80900 	svcls	0x00f80900
	...
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ec8:	00770005 	rsbseq	r0, r7, r5
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ecc:	00220072 	eoreq	r0, r2, r2, ror r0
    4ed0:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ed4:	05000000 	streq	r0, [r0, #-0]
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ed8:	31007300 	mrscc	r7, LR_irq
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4edc:	00009f25 	andeq	r9, r0, r5, lsr #30
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ee0:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ee4:	00020000 	andeq	r0, r2, r0
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4ee8:	00007f77 	andeq	r7, r0, r7, ror pc
	...
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4ef8:	00030000 	andeq	r0, r3, r0
    4efc:	009f4891 	umullseq	r4, pc, r1, r8	; <UNPREDICTABLE>
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4f00:	00000000 	andeq	r0, r0, r0
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f04:	01000000 	mrseq	r0, (UNDEF: 0)
    P( A, B, C, D, E, F, G, H, R(56), 0x748F82EE );
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    4f08:	00005400 	andeq	r5, r0, r0, lsl #8
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f0c:	00000000 	andeq	r0, r0, r0
    4f10:	00030000 	andeq	r0, r3, r0
    4f14:	009f7074 	addseq	r7, pc, r4, ror r0	; <UNPREDICTABLE>
    4f18:	00000000 	andeq	r0, r0, r0
    4f1c:	03000000 	movweq	r0, #0
    4f20:	9f607400 	svcls	0x00607400
	...
    4f2c:	48910003 	ldmmi	r1, {r0, r1}
    4f30:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    4f34:	00000000 	andeq	r0, r0, r0
    4f38:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    4f44:	48910003 	ldmmi	r1, {r0, r1}
    4f48:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    4f58:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f64:	00560001 	subseq	r0, r6, r1
	...
    4f74:	01000000 	mrseq	r0, (UNDEF: 0)
    4f78:	00005000 	andeq	r5, r0, r0
    4f7c:	00000000 	andeq	r0, r0, r0
    4f80:	00010000 	andeq	r0, r1, r0
    4f84:	00000054 	andeq	r0, r0, r4, asr r0
    4f88:	00000000 	andeq	r0, r0, r0
    P( H, A, B, C, D, E, F, G, R(57), 0x78A5636F );
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    4f8c:	f3000400 	vshl.u8	d0, d0, d0
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4f90:	009f5001 	addseq	r5, pc, r1
	...
    4fa0:	01000000 	mrseq	r0, (UNDEF: 0)
    4fa4:	00005100 	andeq	r5, r0, r0, lsl #2
    4fa8:	00000000 	andeq	r0, r0, r0
    4fac:	00010000 	andeq	r0, r1, r0
    4fb0:	00000052 	andeq	r0, r0, r2, asr r0
    4fb4:	00000000 	andeq	r0, r0, r0
    4fb8:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    4fc4:	01f30004 	mvnseq	r0, r4
    4fc8:	00009f51 	andeq	r9, r0, r1, asr pc
	...
    ctx->state[2] += C;
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    ctx->state[7] += H;
    4fd8:	00010000 	andeq	r0, r1, r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4fdc:	00000050 	andeq	r0, r0, r0, asr r0

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    4fe0:	00000000 	andeq	r0, r0, r0
    P( G, H, A, B, C, D, E, F, R(58), 0x84C87814 );
    P( F, G, H, A, B, C, D, E, R(59), 0x8CC70208 );
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );
    4fe4:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    4ff0:	01f30004 	mvnseq	r0, r4
    4ff4:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    ctx->state[3] += D;
    ctx->state[4] += E;
    5004:	00010000 	andeq	r0, r1, r0
    P( E, F, G, H, A, B, C, D, R(60), 0x90BEFFFA );
    P( D, E, F, G, H, A, B, C, R(61), 0xA4506CEB );
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    5008:	00000051 	andeq	r0, r0, r1, asr r0
    ctx->state[1] += B;
    ctx->state[2] += C;
    ctx->state[3] += D;
    500c:	00000000 	andeq	r0, r0, r0
    ctx->state[4] += E;
    5010:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    P( C, D, E, F, G, H, A, B, R(62), 0xBEF9A3F7 );
    P( B, C, D, E, F, G, H, A, R(63), 0xC67178F2 );

    ctx->state[0] += A;
    ctx->state[1] += B;
    ctx->state[2] += C;
    501c:	01f30004 	mvnseq	r0, r4
    ctx->state[3] += D;
    ctx->state[4] += E;
    ctx->state[5] += F;
    ctx->state[6] += G;
    5020:	00009f51 	andeq	r9, r0, r1, asr pc
	...
    ctx->state[7] += H;
}
    5030:	00010000 	andeq	r0, r1, r0
    5034:	00000052 	andeq	r0, r0, r2, asr r0
    5038:	00000000 	andeq	r0, r0, r0
    503c:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...

void sha256_update( sha256_context *ctx, uint8 *input, uint32 length )
{
    uint32 left, fill;

    if( ! length ) return;
    5048:	01f30004 	mvnseq	r0, r4
    ctx->state[6] += G;
    ctx->state[7] += H;
}

void sha256_update( sha256_context *ctx, uint8 *input, uint32 length )
{
    504c:	00009f52 	andeq	r9, r0, r2, asr pc
	...
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    505c:	00010000 	andeq	r0, r1, r0
        ctx->total[1]++;
    5060:	00000053 	andeq	r0, r0, r3, asr r0

    if( left && length >= fill )
    5064:	00000000 	andeq	r0, r0, r0
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5068:	58000100 	stmdapl	r0, {r8}
	...
    {
        sha256_process( ctx, input );
    5074:	01f30004 	mvnseq	r0, r4
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5078:	00009f53 	andeq	r9, r0, r3, asr pc
	...
    5088:	00010000 	andeq	r0, r1, r0
    508c:	00000052 	andeq	r0, r0, r2, asr r0
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    5090:	00000000 	andeq	r0, r0, r0
    5094:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    {
        memcpy( (void *) (ctx->buffer + left),
    50a0:	01f30004 	mvnseq	r0, r4
    50a4:	00009f52 	andeq	r9, r0, r2, asr pc
	...
    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
    50b4:	00010000 	andeq	r0, r1, r0
    50b8:	00000051 	andeq	r0, r0, r1, asr r0
    50bc:	00000000 	andeq	r0, r0, r0
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    50c0:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
        length -= fill;
        input  += fill;
    50cc:	01f30004 	mvnseq	r0, r4
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    50d0:	00009f51 	andeq	r9, r0, r1, asr pc
	...
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );

    last = ctx->total[0] & 0x3F;
    50e0:	00010000 	andeq	r0, r1, r0
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    50e4:	00000058 	andeq	r0, r0, r8, asr r0

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    50e8:	00000000 	andeq	r0, r0, r0
    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    PUT_UINT32( low,  msglen, 4 );
    50ec:	f3000400 	vshl.u8	d0, d0, d0

    last = ctx->total[0] & 0x3F;
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );
    50f0:	009f5301 	addseq	r5, pc, r1, lsl #6
	...
{
    uint32 last, padn;
    uint32 high, low;
    uint8 msglen[8];

    high = ( ctx->total[0] >> 29 )
    5100:	01000000 	mrseq	r0, (UNDEF: 0)
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    5104:	00005400 	andeq	r5, r0, r0, lsl #8
    5108:	00000000 	andeq	r0, r0, r0
    510c:	00040000 	andeq	r0, r4, r0
    PUT_UINT32( low,  msglen, 4 );
    5110:	9f5101f3 	svcls	0x005101f3
	...

    high = ( ctx->total[0] >> 29 )
         | ( ctx->total[1] <<  3 );
    low  = ( ctx->total[0] <<  3 );

    PUT_UINT32( high, msglen, 0 );
    5124:	00550001 	subseq	r0, r5, r1
    5128:	00000000 	andeq	r0, r0, r0
    512c:	04000000 	streq	r0, [r0], #-0
    PUT_UINT32( low,  msglen, 4 );
    5130:	5001f300 	andpl	pc, r1, r0, lsl #6
    5134:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    5138:	00000000 	andeq	r0, r0, r0

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;
    513c:	0030e000 	eorseq	lr, r0, r0

    if( left && length >= fill )
    5140:	0030ec00 	eorseq	lr, r0, r0, lsl #24
    5144:	50000100 	andpl	r0, r0, r0, lsl #2
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    5148:	000030ec 	andeq	r3, r0, ip, ror #1
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    514c:	000030f6 	strdeq	r3, [r0], -r6
    5150:	f6520001 			; <UNDEFINED> instruction: 0xf6520001
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    5154:	f8000030 			; <UNDEFINED> instruction: 0xf8000030
    {
        memcpy( (void *) (ctx->buffer + left),
    5158:	01000030 	tsteq	r0, r0, lsr r0
    515c:	30f85300 	rscscc	r5, r8, r0, lsl #6
    5160:	31000000 	mrscc	r0, (UNDEF: 0)
    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;

    ctx->total[0] += length;
    5164:	00010000 	andeq	r0, r1, r0
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    5168:	00310054 	eorseq	r0, r1, r4, asr r0
{
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    516c:	00310800 	eorseq	r0, r1, r0, lsl #16
    fill = 64 - left;

    ctx->total[0] += length;
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
    5170:	50000100 	andpl	r0, r0, r0, lsl #2
        ctx->total[1]++;
    5174:	00003108 	andeq	r3, r0, r8, lsl #2

    if( left && length >= fill )
    5178:	0000502c 	andeq	r5, r0, ip, lsr #32
    517c:	54910002 	ldrpl	r0, [r1], #2
    uint32 left, fill;

    if( ! length ) return;

    left = ctx->total[0] & 0x3F;
    fill = 64 - left;
    5180:	0000502c 	andeq	r5, r0, ip, lsr #32
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    5184:	00005044 	andeq	r5, r0, r4, asr #32
    5188:	547d0002 	ldrbtpl	r0, [sp], #-2
	...
        input  += 64;
    }

    if( length )
    {
        memcpy( (void *) (ctx->buffer + left),
    5194:	000030e0 	andeq	r3, r0, r0, ror #1
    5198:	00003820 	andeq	r3, r0, r0, lsr #16
    padn = ( last < 56 ) ? ( 56 - last ) : ( 120 - last );

    sha256_update( ctx, sha256_padding, padn );
    sha256_update( ctx, msglen, 8 );

    PUT_UINT32( ctx->state[0], digest,  0 );
    519c:	20510001 	subscs	r0, r1, r1
    51a0:	44000038 	strmi	r0, [r0], #-56	; 0x38
    51a4:	04000050 	streq	r0, [r0], #-80	; 0x50
    51a8:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    51ac:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    PUT_UINT32( ctx->state[1], digest,  4 );
    51b0:	00000000 	andeq	r0, r0, r0
    51b4:	00385c00 	eorseq	r5, r8, r0, lsl #24
    51b8:	00386400 	eorseq	r6, r8, r0, lsl #8
    51bc:	5a000100 	bpl	55c4 <sha512_block+0x2d8>
    PUT_UINT32( ctx->state[2], digest,  8 );
    51c0:	00003896 	muleq	r0, r6, r8
    51c4:	000038ce 	andeq	r3, r0, lr, asr #17
    51c8:	fe5c0001 	cdp2	0, 5, cr0, cr12, cr1, {0}
    51cc:	4e000038 	mcrmi	0, 0, r0, cr0, cr8, {1}
    51d0:	01000039 	tsteq	r0, r9, lsr r0
    PUT_UINT32( ctx->state[3], digest, 12 );
    51d4:	39765000 	ldmdbcc	r6!, {ip, lr}^
    51d8:	39c20000 	stmibcc	r2, {}^	; <UNPREDICTABLE>
    51dc:	00010000 	andeq	r0, r1, r0
    51e0:	0039ec52 	eorseq	lr, r9, r2, asr ip
    PUT_UINT32( ctx->state[4], digest, 16 );
    51e4:	003a4000 	eorseq	r4, sl, r0
    51e8:	53000100 	movwpl	r0, #256	; 0x100
    51ec:	00003a5c 	andeq	r3, r0, ip, asr sl
    51f0:	00003ac6 	andeq	r3, r0, r6, asr #21
    51f4:	d0500001 	subsle	r0, r0, r1
    PUT_UINT32( ctx->state[5], digest, 20 );
    51f8:	1a00003a 	bne	52e8 <sha256_finish+0x214>
    51fc:	0100003b 	tsteq	r0, fp, lsr r0
    5200:	3b485c00 	blcc	121c208 <_etext+0x1214bf4>
    5204:	3b980000 	blcc	fe60520c <BootRAM+0xd5759ad>
    PUT_UINT32( ctx->state[6], digest, 24 );
    5208:	00010000 	andeq	r0, r1, r0
    520c:	003bcc56 	eorseq	ip, fp, r6, asr ip
    5210:	003c0000 	eorseq	r0, ip, r0
    5214:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    5218:	00003c56 	andeq	r3, r0, r6, asr ip
    PUT_UINT32( ctx->state[7], digest, 28 );
    521c:	00003ca4 	andeq	r3, r0, r4, lsr #25
    5220:	d6590001 	ldrble	r0, [r9], -r1
    5224:	1e00003c 	mcrne	0, 0, r0, cr0, cr12, {1}
    5228:	0100003d 	tsteq	r0, sp, lsr r0
    522c:	3d605800 	stclcc	8, cr5, [r0, #-0]
    5230:	3d820000 	stccc	0, cr0, [r2]
    5234:	00010000 	andeq	r0, r1, r0
    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
    5238:	003dce57 	eorseq	ip, sp, r7, asr lr
    523c:	003de400 	eorseq	lr, sp, r0, lsl #8
    5240:	58000100 	stmdapl	r0, {r8}
    5244:	00003e3e 	andeq	r3, r0, lr, lsr lr
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    5248:	00003e68 	andeq	r3, r0, r8, ror #28
    524c:	b6570001 	ldrblt	r0, [r7], -r1
        length -= fill;
    5250:	d600003e 			; <UNDEFINED> instruction: 0xd600003e

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    5254:	0100003e 	tsteq	r0, lr, lsr r0
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5258:	3f265000 	svccc	0x00265000
    525c:	3f460000 	svccc	0x00460000
    5260:	00010000 	andeq	r0, r1, r0
    {
        sha256_process( ctx, input );
        length -= 64;
    5264:	003f9852 	eorseq	r9, pc, r2, asr r8	; <UNPREDICTABLE>
        left = 0;
    }

    while( length >= 64 )
    {
        sha256_process( ctx, input );
    5268:	003fb400 	eorseq	fp, pc, r0, lsl #8
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    526c:	53000100 	movwpl	r0, #256	; 0x100
    {
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    5270:	00004002 	andeq	r4, r0, r2
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    5274:	00004026 	andeq	r4, r0, r6, lsr #32
    5278:	9a520001 	bls	1485284 <_etext+0x147dc70>
    527c:	c6000040 	strgt	r0, [r0], -r0, asr #32
    5280:	01000040 	tsteq	r0, r0, asr #32
    5284:	410e5300 	mrsmi	r5, ELR_hyp
    ctx->total[0] &= 0xFFFFFFFF;

    if( ctx->total[0] < length )
        ctx->total[1]++;

    if( left && length >= fill )
    5288:	412e0000 	teqmi	lr, r0
    528c:	00010000 	andeq	r0, r1, r0
    {
        memcpy( (void *) (ctx->buffer + left),
    5290:	00418452 	subeq	r8, r1, r2, asr r4
    5294:	00419800 	subeq	r9, r1, r0, lsl #16
    5298:	53000100 	movwpl	r0, #256	; 0x100
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
    529c:	000041f4 	strdeq	r4, [r0], -r4	; <UNPREDICTABLE>
        input  += fill;
    52a0:	0000421e 	andeq	r4, r0, lr, lsl r2

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    52a4:	6e590001 	cdpvs	0, 5, cr0, cr9, cr1, {0}
        length -= fill;
        input  += fill;
    52a8:	9c000042 	stcls	0, cr0, [r0], {66}	; 0x42

    if( left && length >= fill )
    {
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
    52ac:	01000042 	tsteq	r0, r2, asr #32
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    52b0:	42ca5c00 	sbcmi	r5, sl, #0, 24
    {
        sha256_process( ctx, input );
    52b4:	43120000 	tstmi	r2, #0
    52b8:	00010000 	andeq	r0, r1, r0
    52bc:	00436258 	subeq	r6, r3, r8, asr r2
        length -= 64;
        input  += 64;
    52c0:	00439600 	subeq	r9, r3, r0, lsl #12
        length -= fill;
        input  += fill;
        left = 0;
    }

    while( length >= 64 )
    52c4:	5a000100 	bpl	56cc <sha512_block+0x3e0>
    52c8:	000043de 	ldrdeq	r4, [r0], -lr
    52cc:	00004400 	andeq	r4, r0, r0, lsl #8
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    52d0:	4c5c0001 	mrrcmi	0, 0, r0, ip, cr1
    }

    while( length >= 64 )
    52d4:	72000044 	andvc	r0, r0, #68	; 0x44
    52d8:	01000044 	tsteq	r0, r4, asr #32
        sha256_process( ctx, input );
        length -= 64;
        input  += 64;
    }

    if( length )
    52dc:	44f05a00 	ldrbtmi	r5, [r0], #2560	; 0xa00
        memcpy( (void *) (ctx->buffer + left),
                (void *) input, fill );
        sha256_process( ctx, ctx->buffer );
        length -= fill;
        input  += fill;
        left = 0;
    52e0:	45120000 	ldrmi	r0, [r2, #-0]
    52e4:	00010000 	andeq	r0, r1, r0
    52e8:	00456854 	subeq	r6, r5, r4, asr r8
{
	return (x >> bits) | (x << (64 - bits));
}

void sha512_block(struct sha512_state *s, const uint8_t *blk)
{
    52ec:	00458800 	subeq	r8, r5, r0, lsl #16
    52f0:	51000100 	mrspl	r0, (UNDEF: 16)
    52f4:	000045dc 	ldrdeq	r4, [r0], -ip
    52f8:	000045fc 	strdeq	r4, [r0], -ip

static inline uint64_t load64(const uint8_t *x)
{
	uint64_t r;

	r = *(x++);
    52fc:	4c570001 	mrrcmi	0, 0, r0, r7, cr1
	r = (r << 8) | *(x++);
    5300:	6c000046 	stcvs	0, cr0, [r0], {70}	; 0x46
    5304:	01000046 	tsteq	r0, r6, asr #32
    5308:	46c25300 	strbmi	r5, [r2], r0, lsl #6
    530c:	46d80000 	ldrbmi	r0, [r8], r0
    5310:	00010000 	andeq	r0, r1, r0
	r = (r << 8) | *(x++);
    5314:	00473457 	subeq	r3, r7, r7, asr r4
    5318:	00475400 	subeq	r5, r7, r0, lsl #8
    531c:	56000100 	strpl	r0, [r0], -r0, lsl #2
    5320:	000047ae 	andeq	r4, r0, lr, lsr #15
	r = (r << 8) | *(x++);
    5324:	000047d2 	ldrdeq	r4, [r0], -r2
    5328:	28590001 	ldmdacs	r9, {r0}^
    532c:	48000048 	stmdami	r0, {r3, r6}
    5330:	01000048 	tsteq	r0, r8, asr #32
    5334:	48845800 	stmmi	r4, {fp, ip, lr}
    5338:	49000000 	stmdbmi	r0, {}	; <UNPREDICTABLE>
    533c:	00010000 	andeq	r0, r1, r0
    5340:	00492c58 	subeq	r2, r9, r8, asr ip
	r = (r << 8) | *(x++);
    5344:	00496e00 	subeq	r6, r9, r0, lsl #28
    5348:	54000100 	strpl	r0, [r0], #-256	; 0x100
    534c:	000049a2 	andeq	r4, r0, r2, lsr #19
    5350:	000049f6 	strdeq	r4, [r0], -r6
    5354:	20570001 	subscs	r0, r7, r1
    5358:	6800004a 	stmdavs	r0, {r1, r3, r6}
    535c:	0100004a 	tsteq	r0, sl, asr #32
    5360:	4a9e5700 	bmi	fe79af68 <BootRAM+0xd70b709>
	r = (r << 8) | *(x++);
    5364:	4ad80000 	bmi	ff60536c <BootRAM+0xe575b0d>
    5368:	00010000 	andeq	r0, r1, r0
    536c:	004b1a53 	subeq	r1, fp, r3, asr sl
    5370:	004b5c00 	subeq	r5, fp, r0, lsl #24
    5374:	50000100 	andpl	r0, r0, r0, lsl #2
    5378:	00004bac 	andeq	r4, r0, ip, lsr #23
	r = (r << 8) | *(x++);
    537c:	00004bcc 	andeq	r4, r0, ip, asr #23
    5380:	26560001 	ldrbcs	r0, [r6], -r1
    5384:	4400004c 	strmi	r0, [r0], #-76	; 0x4c
    5388:	0100004c 	tsteq	r0, ip, asr #32
    538c:	4cbe5c00 	ldcmi	12, cr5, [lr]
    5390:	4cde0000 	ldclmi	0, cr0, [lr], {0}
	r = (r << 8) | *(x++);
    5394:	00010000 	andeq	r0, r1, r0
    5398:	004d7650 	subeq	r7, sp, r0, asr r6
    539c:	004d9a00 	subeq	r9, sp, r0, lsl #20
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
		w[i] = load64(blk);
		blk += 8;
    53a0:	58000100 	stmdapl	r0, {r8}
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
	r = (r << 8) | *(x++);
    53a4:	00004d9a 	muleq	r0, sl, sp
	uint64_t w[16];
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
		w[i] = load64(blk);
    53a8:	00004daa 	andeq	r4, r0, sl, lsr #27
{
	uint64_t w[16];
	uint64_t a, b, c, d, e, f, g, h;
	int i;

	for (i = 0; i < 16; i++) {
    53ac:	007a0006 	rsbseq	r0, sl, r6
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    53b0:	9f220079 	svcls	0x00220079
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
    53b4:	00004daa 	andeq	r4, r0, sl, lsr #27
    53b8:	00004dde 	ldrdeq	r4, [r0], -lr
	c = s->h[2];
    53bc:	0074002a 	rsbseq	r0, r4, sl, lsr #32
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    53c0:	24141445 	ldrcs	r1, [r4], #-1093	; 0x445
	b = s->h[1];
    53c4:	20231f17 	eorcs	r1, r3, r7, lsl pc
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    53c8:	00742125 	rsbseq	r2, r4, r5, lsr #2
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    53cc:	1f141436 	svcne	0x00141436
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    53d0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    53d4:	74272125 	strtvc	r2, [r7], #-293	; 0x125
	}

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
    53d8:	14143700 	ldrne	r3, [r4], #-1792	; 0x700
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    53dc:	231f1724 	tstcs	pc, #36, 14	; 0x900000
    53e0:	27212520 	strcs	r2, [r1, -r0, lsr #10]!

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    53e4:	9f22007a 	svcls	0x0022007a
		w[i] = load64(blk);
		blk += 8;
	}

	/* Load state */
	a = s->h[0];
    53e8:	00004e00 	andeq	r4, r0, r0, lsl #28
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
    53ec:	00004e62 	andeq	r4, r0, r2, ror #28
	f = s->h[5];
    53f0:	905a0001 	subsls	r0, sl, r1

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    53f4:	9c00004e 	stcls	0, cr0, [r0], {78}	; 0x4e
	e = s->h[4];
    53f8:	0100004e 	tsteq	r0, lr, asr #32
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    53fc:	4ef85100 	cdpmi	1, 15, cr5, cr8, cr0, {0}
    5400:	4f0c0000 	svcmi	0x000c0000

	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
    5404:	00010000 	andeq	r0, r1, r0
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    5408:	004f6c54 	subeq	r6, pc, r4, asr ip	; <UNPREDICTABLE>

	for (i = 0; i < 80; i++) {
    540c:	004f9c00 	subeq	r9, pc, r0, lsl #24
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
    5410:	56000100 	strpl	r0, [r0], -r0, lsl #2
	g = s->h[6];
    5414:	00004ff4 	strdeq	r4, [r0], -r4	; <UNPREDICTABLE>
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
    5418:	00005006 	andeq	r5, r0, r6
    541c:	00570001 	subseq	r0, r7, r1
	g = s->h[6];
	h = s->h[7];
    5420:	00000000 	andeq	r0, r0, r0
    5424:	5c000000 	stcpl	0, cr0, [r0], {-0}
    5428:	96000038 			; <UNDEFINED> instruction: 0x96000038
	/* Load state */
	a = s->h[0];
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
    542c:	38000038 	stmdacc	r0, {r3, r4, r5}
    5430:	7b007600 	blvc	22c38 <_etext+0x1b624>
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];
    5434:	94912100 	ldrls	r2, [r1], #256	; 0x100
    5438:	761a067f 			; <UNDEFINED> instruction: 0x761a067f
	b = s->h[1];
	c = s->h[2];
	d = s->h[3];
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
    543c:	1a007b00 	bne	24044 <_etext+0x1ca30>
	h = s->h[7];
    5440:	3d007621 	stccc	6, cr7, [r0, #-132]	; 0xffffff7c
    5444:	231f1414 	tstcs	pc, #20, 8	; 0x14000000

		/* Update round state */
		h = g;
		g = f;
		f = e;
		e = d + temp1;
    5448:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    544c:	32007621 	andcc	r7, r0, #34603008	; 0x2100000
    5450:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5454:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5458:	00762721 	rsbseq	r2, r6, r1, lsr #14
    545c:	1f141446 	svcne	0x00141446
    5460:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5464:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5468:	0038969f 	mlaseq	r8, pc, r6, r9	; <UNPREDICTABLE>
    546c:	0038fe00 	eorseq	pc, r8, r0, lsl #28
    5470:	77003600 	strvc	r3, [r0, -r0, lsl #12]
    5474:	21007600 	tstcs	r0, r0, lsl #12
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
    5478:	771a007b 			; <UNDEFINED> instruction: 0x771a007b
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
    547c:	1a007600 	bne	22c84 <_etext+0x1b670>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5480:	3d007721 	stccc	7, cr7, [r0, #-132]	; 0xffffff7c
    5484:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5488:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    548c:	32007721 	andcc	r7, r0, #8650752	; 0x840000
    5490:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5494:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    5498:	00772721 	rsbseq	r2, r7, r1, lsr #14
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    549c:	1f141446 	svcne	0x00141446
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    54a0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54a4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    54a8:	0038fe9f 	mlaseq	r8, pc, lr, pc	; <UNPREDICTABLE>
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    54ac:	00397600 	eorseq	r7, r9, r0, lsl #12
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54b0:	75003600 	strvc	r3, [r0, #-1536]	; 0x600
	h = s->h[7];

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
    54b4:	21007700 	tstcs	r0, r0, lsl #14
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    54b8:	751a0076 	ldrvc	r0, [sl, #-118]	; 0x76
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54bc:	1a007700 	bne	230c4 <_etext+0x1bab0>
    54c0:	3d007521 	cfstr32cc	mvfx7, [r0, #-132]	; 0xffffff7c
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    54c4:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54c8:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    54cc:	32007521 	andcc	r7, r0, #138412032	; 0x8400000
    54d0:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    54d4:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    54d8:	00752721 	rsbseq	r2, r5, r1, lsr #14

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    54dc:	1f141446 	svcne	0x00141446
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54e0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    54e4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    54e8:	0039769f 	mlaseq	r9, pc, r6, r7	; <UNPREDICTABLE>

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    54ec:	0039ec00 	eorseq	lr, r9, r0, lsl #24
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    54f0:	78003600 	stmdavc	r0, {r9, sl, ip, sp}
    54f4:	21007500 	tstcs	r0, r0, lsl #10
    54f8:	781a0077 	ldmdavc	sl, {r0, r1, r2, r4, r5, r6}
    54fc:	1a007500 	bne	22904 <_etext+0x1b2f0>

	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
    5500:	3d007821 	stccc	8, cr7, [r0, #-132]	; 0xffffff7c
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5504:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5508:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    550c:	32007821 	andcc	r7, r0, #2162688	; 0x210000
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
    5510:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5514:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5518:	00782721 	rsbseq	r2, r8, r1, lsr #14
    551c:	1f141446 	svcne	0x00141446
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5520:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5524:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5528:	0039ec9f 	mlaseq	r9, pc, ip, lr	; <UNPREDICTABLE>
    552c:	003a5c00 	eorseq	r5, sl, r0, lsl #24
    5530:	7a003600 	bvc	12d38 <_etext+0xb724>
    5534:	21007800 	tstcs	r0, r0, lsl #16
    5538:	7a1a0075 	bvc	685714 <_etext+0x67e100>
    553c:	1a007800 	bne	23544 <_etext+0x1bf30>
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
    5540:	3d007a21 	vstrcc	s14, [r0, #-132]	; 0xffffff7c
    5544:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5548:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
    554c:	32007a21 	andcc	r7, r0, #135168	; 0x21000
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    5550:	231f1414 	tstcs	pc, #20, 8	; 0x14000000

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
    5554:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5558:	007a2721 	rsbseq	r2, sl, r1, lsr #14
    555c:	1f141446 	svcne	0x00141446
    5560:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5564:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5568:	003a5c9f 	mlaseq	sl, pc, ip, r5	; <UNPREDICTABLE>
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    556c:	003ad000 	eorseq	sp, sl, r0
	for (i = 0; i < 80; i++) {
		/* Compute value of w[i + 16]. w[wrap(i)] is currently w[i] */
		const uint64_t wi = w[i & 15];
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
    5570:	71003600 	tstvc	r0, r0, lsl #12
    5574:	21007a00 	tstcs	r0, r0, lsl #20
    5578:	711a0078 	tstvc	sl, r8, ror r0
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    557c:	1a007a00 	bne	23d84 <_etext+0x1c770>
    5580:	3d007121 	stfccs	f7, [r0, #-132]	; 0xffffff7c
    5584:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5588:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    558c:	32007121 	andcc	r7, r0, #1073741832	; 0x40000008
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5590:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5594:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5598:	00712721 	rsbseq	r2, r1, r1, lsr #14
    559c:	1f141446 	svcne	0x00141446
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55a0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55a4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55a8:	003ad09f 	mlaseq	sl, pc, r0, sp	; <UNPREDICTABLE>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55ac:	003b4800 	eorseq	r4, fp, r0, lsl #16
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);
    55b0:	74003600 	strvc	r3, [r0], #-1536	; 0x600
    55b4:	21007100 	mrscs	r7, (UNDEF: 16)
    55b8:	741a007a 	ldrvc	r0, [sl], #-122	; 0x7a
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
    55bc:	1a007100 	bne	219c4 <_etext+0x1a3b0>
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55c0:	3d007421 	cfstrscc	mvf7, [r0, #-132]	; 0xffffff7c
		const uint64_t wi15 = w[(i + 1) & 15];
		const uint64_t wi2 = w[(i + 14) & 15];
		const uint64_t wi7 = w[(i + 9) & 15];
		const uint64_t s0 =
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
    55c4:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    55c8:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    55cc:	32007421 	andcc	r7, r0, #553648128	; 0x21000000
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
    55d0:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    55d4:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    55d8:	00742721 	rsbseq	r2, r4, r1, lsr #14
    55dc:	1f141446 	svcne	0x00141446
    55e0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    55e4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    55e8:	003b489f 	mlaseq	fp, pc, r8, r4	; <UNPREDICTABLE>
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55ec:	003bcc00 	eorseq	ip, fp, r0, lsl #24

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55f0:	70003600 	andvc	r3, r0, r0, lsl #12
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55f4:	21007400 	tstcs	r0, r0, lsl #8

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    55f8:	701a0071 	andsvc	r0, sl, r1, ror r0
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    55fc:	1a007400 	bne	22604 <_etext+0x1aff0>

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5600:	3d007021 	stccc	0, cr7, [r0, #-132]	; 0xffffff7c
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5604:	231f1414 	tstcs	pc, #20, 8	; 0x14000000

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5608:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    560c:	32007021 	andcc	r7, r0, #33	; 0x21
    5610:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5614:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5618:	00702721 	rsbseq	r2, r0, r1, lsr #14
    561c:	1f141446 	svcne	0x00141446

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5620:	17242023 	strne	r2, [r4, -r3, lsr #32]!
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5624:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5628:	003bcc9f 	mlaseq	fp, pc, ip, ip	; <UNPREDICTABLE>
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    562c:	003c5600 	eorseq	r5, ip, r0, lsl #12
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5630:	72003600 	andvc	r3, r0, #0, 12
		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5634:	21007000 	mrscs	r7, (UNDEF: 0)
	*(x--) = v;
}

static inline uint64_t rot64(uint64_t x, int bits)
{
	return (x >> bits) | (x << (64 - bits));
    5638:	721a0074 	andsvc	r0, sl, #116	; 0x74
			rot64(wi15, 1) ^ rot64(wi15, 8) ^ (wi15 >> 7);
		const uint64_t s1 =
			rot64(wi2, 19) ^ rot64(wi2, 61) ^ (wi2 >> 6);

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
    563c:	1a007000 	bne	21644 <_etext+0x1a030>
    5640:	3d007221 	sfmcc	f7, 4, [r0, #-132]	; 0xffffff7c
    5644:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5648:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    564c:	32007221 	andcc	r7, r0, #268435458	; 0x10000002
    5650:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    5654:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5658:	00722721 	rsbseq	r2, r2, r1, lsr #14
		c = b;
		b = a;
		a = temp1 + temp2;

		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
    565c:	1f141446 	svcne	0x00141446

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5660:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5664:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5668:	003c569f 	mlaseq	ip, pc, r6, r5	; <UNPREDICTABLE>

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    566c:	003cd600 	eorseq	sp, ip, r0, lsl #12
    5670:	73003600 	movwvc	r3, #1536	; 0x600
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
    5674:	21007200 	mrscs	r7, R8_usr
    5678:	731a0070 	tstvc	sl, #112	; 0x70
    567c:	1a007200 	bne	21e84 <_etext+0x1a870>
    5680:	3d007321 	stccc	3, cr7, [r0, #-132]	; 0xffffff7c
    5684:	231f1414 	tstcs	pc, #20, 8	; 0x14000000

		/* Round calculations */
		const uint64_t S0 = rot64(a, 28) ^ rot64(a, 34) ^ rot64(a, 39);
		const uint64_t S1 = rot64(e, 14) ^ rot64(e, 18) ^ rot64(e, 41);
		const uint64_t ch = (e & f) ^ ((~e) & g);
		const uint64_t temp1 = h + S1 + ch + round_k[i] + wi;
    5688:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    568c:	32007321 	andcc	r7, r0, #-2080374784	; 0x84000000
		const uint64_t maj = (a & b) ^ (a & c) ^ (b & c);
		const uint64_t temp2 = S0 + maj;
    5690:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5694:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5698:	00732721 	rsbseq	r2, r3, r1, lsr #14

		/* Update round state */
		h = g;
		g = f;
		f = e;
		e = d + temp1;
    569c:	1f141446 	svcne	0x00141446
    56a0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
		d = c;
		c = b;
		b = a;
		a = temp1 + temp2;
    56a4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    56a8:	003cd69f 	mlaseq	ip, pc, r6, sp	; <UNPREDICTABLE>
	e = s->h[4];
	f = s->h[5];
	g = s->h[6];
	h = s->h[7];

	for (i = 0; i < 80; i++) {
    56ac:	003d6000 	eorseq	r6, sp, r0
    56b0:	7c003600 	stcvc	6, cr3, [r0], {-0}
    56b4:	21007300 	mrscs	r7, LR_irq
    56b8:	7c1a0072 	ldcvc	0, cr0, [sl], {114}	; 0x72
    56bc:	1a007300 	bne	222c4 <_etext+0x1acb0>
    56c0:	3d007c21 	stccc	12, cr7, [r0, #-132]	; 0xffffff7c
    56c4:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    56c8:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    56cc:	32007c21 	andcc	r7, r0, #8448	; 0x2100
    56d0:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	s->h[1] += b;
    56d4:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    56d8:	007c2721 	rsbseq	r2, ip, r1, lsr #14
    56dc:	1f141446 	svcne	0x00141446
	s->h[2] += c;
    56e0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    56e4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    56e8:	003d609f 	mlaseq	sp, pc, r0, r6	; <UNPREDICTABLE>
    56ec:	003dce00 	eorseq	ip, sp, r0, lsl #28
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    56f0:	76003600 	strvc	r3, [r0], -r0, lsl #12
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    56f4:	21007c00 	tstcs	r0, r0, lsl #24
	s->h[4] += e;
    56f8:	761a0073 			; <UNDEFINED> instruction: 0x761a0073
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
    56fc:	1a007c00 	bne	24704 <_etext+0x1d0f0>
	s->h[2] += c;
	s->h[3] += d;
    5700:	3d007621 	stccc	6, cr7, [r0, #-132]	; 0xffffff7c
    5704:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5708:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	s->h[4] += e;
    570c:	32007621 	andcc	r7, r0, #34603008	; 0x2100000
	s->h[5] += f;
	s->h[6] += g;
    5710:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
    5714:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5718:	00762721 	rsbseq	r2, r6, r1, lsr #14
    571c:	1f141446 	svcne	0x00141446
	s->h[6] += g;
    5720:	17242023 	strne	r2, [r4, -r3, lsr #32]!

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    5724:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    5728:	003dce9f 	mlaseq	sp, pc, lr, ip	; <UNPREDICTABLE>
	s->h[7] += h;
    572c:	003e3e00 	eorseq	r3, lr, r0, lsl #28
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5730:	7a003600 	bvc	12f38 <_etext+0xb924>
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
	s->h[5] += f;
	s->h[6] += g;
    5734:	21007600 	tstcs	r0, r0, lsl #12
	s->h[7] += h;
    5738:	7a1a007c 	bvc	685930 <_etext+0x67e31c>
    573c:	1a007600 	bne	22f44 <_etext+0x1b930>
    5740:	3d007a21 	vstrcc	s14, [r0, #-132]	; 0xffffff7c
    5744:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
	s->h[2] += c;
    5748:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    574c:	32007a21 	andcc	r7, r0, #135168	; 0x21000
	s->h[1] += b;
	s->h[2] += c;
	s->h[3] += d;
    5750:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
		/* w[wrap(i)] becomes w[i + 16] */
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
    5754:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	s->h[1] += b;
    5758:	007a2721 	rsbseq	r2, sl, r1, lsr #14
	s->h[2] += c;
	s->h[3] += d;
    575c:	1f141446 	svcne	0x00141446
		w[i & 15] = wi + s0 + wi7 + s1;
	}

	/* Store state */
	s->h[0] += a;
	s->h[1] += b;
    5760:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	s->h[2] += c;
	s->h[3] += d;
	s->h[4] += e;
    5764:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
	s->h[5] += f;
    5768:	003e3e9f 	mlaseq	lr, pc, lr, r3	; <UNPREDICTABLE>
	s->h[6] += g;
    576c:	003eb600 	eorseq	fp, lr, r0, lsl #12
	s->h[7] += h;
    5770:	71003600 	tstvc	r0, r0, lsl #12
}
    5774:	21007a00 	tstcs	r0, r0, lsl #20
    5778:	711a0076 	tstvc	sl, r6, ror r0
    577c:	1a007a00 	bne	23f84 <_etext+0x1c970>

void sha512_final(struct sha512_state *s, const uint8_t *blk,
		  size_t total_size)
{
    5780:	3d007121 	stfccs	f7, [r0, #-132]	; 0xffffff7c
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
    5784:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	s->h[7] += h;
}

void sha512_final(struct sha512_state *s, const uint8_t *blk,
		  size_t total_size)
{
    5788:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    578c:	32007121 	andcc	r7, r0, #1073741832	; 0x40000008
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
    5790:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5794:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
    5798:	00712721 	rsbseq	r2, r1, r1, lsr #14
    579c:	1f141446 	svcne	0x00141446
		memcpy(temp, blk, last_size);
	temp[last_size] = 0x80;
    57a0:	17242023 	strne	r2, [r4, -r3, lsr #32]!

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    57a4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    57a8:	003eb69f 	mlaseq	lr, pc, r6, fp	; <UNPREDICTABLE>
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    57ac:	003f2600 	eorseq	r2, pc, r0, lsl #12
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
	sha512_block(s, temp);
    57b0:	79003600 	stmdbvc	r0, {r9, sl, ip, sp}
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    57b4:	21007100 	mrscs	r7, (UNDEF: 16)
	v >>= 8;
	*(x--) = v;
    57b8:	791a007a 	ldmdbvc	sl, {r1, r3, r4, r5, r6}
	v >>= 8;
	*(x--) = v;
    57bc:	1a007100 	bne	21bc4 <_etext+0x1a5b0>
	v >>= 8;
	*(x--) = v;
    57c0:	3d007921 	stccc	9, cr7, [r0, #-132]	; 0xffffff7c
	v >>= 8;
	*(x--) = v;
    57c4:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	v >>= 8;
	*(x--) = v;
    57c8:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	v >>= 8;
	*(x--) = v;
    57cc:	32007921 	andcc	r7, r0, #540672	; 0x84000
	v >>= 8;
	*(x--) = v;
    57d0:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
		memset(temp, 0, sizeof(temp));
	}

	/* Note: we assume total_size fits in 61 bits */
	store64(temp + SHA512_BLOCK_SIZE - 8, total_size << 3);
	sha512_block(s, temp);
    57d4:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
}
    57d8:	00792721 	rsbseq	r2, r9, r1, lsr #14
{
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
		memcpy(temp, blk, last_size);
    57dc:	1f141446 	svcne	0x00141446
    57e0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    57e4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
	temp[last_size] = 0x80;
    57e8:	003f269f 	mlaseq	pc, pc, r6, r2	; <UNPREDICTABLE>

	if (last_size > 111) {
    57ec:	003f9800 	eorseq	r9, pc, r0, lsl #16
	uint8_t temp[SHA512_BLOCK_SIZE] = {0};
	const size_t last_size = total_size & (SHA512_BLOCK_SIZE - 1);

	if (last_size)
		memcpy(temp, blk, last_size);
	temp[last_size] = 0x80;
    57f0:	7c003600 	stcvc	6, cr3, [r0], {-0}

	if (last_size > 111) {
		sha512_block(s, temp);
    57f4:	21007900 	tstcs	r0, r0, lsl #18
    57f8:	7c1a0071 	ldcvc	0, cr0, [sl], {113}	; 0x71
		memset(temp, 0, sizeof(temp));
    57fc:	1a007900 	bne	23c04 <_etext+0x1c5f0>
    5800:	3d007c21 	stccc	12, cr7, [r0, #-132]	; 0xffffff7c
    5804:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	sha512_block(s, temp);
}

void sha512_get(const struct sha512_state *s, uint8_t *hash,
		unsigned int offset, unsigned int len)
{
    5808:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	int i;

	if (offset > SHA512_BLOCK_SIZE)
    580c:	32007c21 	andcc	r7, r0, #8448	; 0x2100
	sha512_block(s, temp);
}

void sha512_get(const struct sha512_state *s, uint8_t *hash,
		unsigned int offset, unsigned int len)
{
    5810:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	int i;

	if (offset > SHA512_BLOCK_SIZE)
    5814:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
		return;

	if (len > SHA512_BLOCK_SIZE - offset)
    5818:	007c2721 	rsbseq	r2, ip, r1, lsr #14
    581c:	1f141446 	svcne	0x00141446
		len = SHA512_BLOCK_SIZE - offset;

	/* Skip whole words */
	i = offset >> 3;
    5820:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
    5824:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009

	if (len > SHA512_BLOCK_SIZE - offset)
		len = SHA512_BLOCK_SIZE - offset;

	/* Skip whole words */
	i = offset >> 3;
    5828:	003f989f 	mlaseq	pc, pc, r8, r9	; <UNPREDICTABLE>
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
    582c:	00400200 	subeq	r0, r0, r0, lsl #4
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    5830:	70003600 	andvc	r3, r0, r0, lsl #12
    5834:	21007c00 	tstcs	r0, r0, lsl #24
    5838:	701a0079 	andsvc	r0, sl, r9, ror r0
    583c:	1a007c00 	bne	24844 <_etext+0x1d230>
    5840:	3d007021 	stccc	0, cr7, [r0, #-132]	; 0xffffff7c
    5844:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5848:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    584c:	32007021 	andcc	r7, r0, #33	; 0x21
    5850:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5854:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
		store64(hash, s->h[i++]);
    5858:	00702721 	rsbseq	r2, r0, r1, lsr #14
    585c:	1f141446 	svcne	0x00141446
    5860:	17242023 	strne	r2, [r4, -r3, lsr #32]!

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5864:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5868:	0040029f 	umaaleq	r0, r0, pc, r2	; <UNPREDICTABLE>
    586c:	00409a00 	subeq	r9, r0, r0, lsl #20
    5870:	76003600 	strvc	r3, [r0], -r0, lsl #12
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
		store64(hash, s->h[i++]);
    5874:	21007000 	mrscs	r7, (UNDEF: 0)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5878:	761a007c 			; <UNDEFINED> instruction: 0x761a007c
	*(x--) = v;
	v >>= 8;
    587c:	1a007000 	bne	21884 <_etext+0x1a270>
    5880:	3d007621 	stccc	6, cr7, [r0, #-132]	; 0xffffff7c
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5884:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	*(x--) = v;
	v >>= 8;
    5888:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	*(x--) = v;
	v >>= 8;
    588c:	32007621 	andcc	r7, r0, #34603008	; 0x2100000
    5890:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	*(x--) = v;
	v >>= 8;
    5894:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5898:	00762721 	rsbseq	r2, r6, r1, lsr #14
	*(x--) = v;
	v >>= 8;
    589c:	1f141446 	svcne	0x00141446
	*(x--) = v;
	v >>= 8;
    58a0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    58a4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    58a8:	00409a9f 	umaaleq	r9, r0, pc, sl	; <UNPREDICTABLE>
	*(x--) = v;
	v >>= 8;
    58ac:	00410e00 	subeq	r0, r1, r0, lsl #28
    58b0:	77003600 	strvc	r3, [r0, -r0, lsl #12]
    58b4:	21007600 	tstcs	r0, r0, lsl #12
    58b8:	771a0070 			; <UNDEFINED> instruction: 0x771a0070
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58bc:	1a007600 	bne	230c4 <_etext+0x1bab0>
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    58c0:	3d007721 	stccc	7, cr7, [r0, #-132]	; 0xffffff7c
	*(x--) = v;
    58c4:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    58c8:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58cc:	32007721 	andcc	r7, r0, #8650752	; 0x840000
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    58d0:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d4:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58d8:	00772721 	rsbseq	r2, r7, r1, lsr #14
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    58dc:	1f141446 	svcne	0x00141446
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    58e0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
		len -= c;
		hash += c;
	}

	/* Read out whole words */
	while (len >= 8) {
    58e4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    58e8:	00410e9f 	umaaleq	r0, r1, pc, lr	; <UNPREDICTABLE>
    58ec:	00418400 	subeq	r8, r1, r0, lsl #8
    58f0:	75003600 	strvc	r3, [r0, #-1536]	; 0x600
    58f4:	21007700 	tstcs	r0, r0, lsl #14
    58f8:	751a0076 	ldrvc	r0, [sl, #-118]	; 0x76
    58fc:	1a007700 	bne	23504 <_etext+0x1bef0>
    5900:	3d007521 	cfstr32cc	mvfx7, [r0, #-132]	; 0xffffff7c
    5904:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
		hash += 8;
		len -= 8;
	}

	/* Read out bytes */
	if (len) {
    5908:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    590c:	32007521 	andcc	r7, r0, #138412032	; 0x8400000
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
	}
}
    5910:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    5914:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5918:	00752721 	rsbseq	r2, r5, r1, lsr #14
    591c:	1f141446 	svcne	0x00141446

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5920:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5924:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
	*(x--) = v;
	v >>= 8;
    5928:	0041849f 	umaaleq	r8, r1, pc, r4	; <UNPREDICTABLE>
    592c:	0041f400 	subeq	pc, r1, r0, lsl #8
	*(x--) = v;
	v >>= 8;
    5930:	74003600 	strvc	r3, [r0], #-1536	; 0x600
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5934:	21007500 	tstcs	r0, r0, lsl #10
	*(x--) = v;
	v >>= 8;
    5938:	741a0077 	ldrvc	r0, [sl], #-119	; 0x77
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    593c:	1a007500 	bne	22d44 <_etext+0x1b730>
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5940:	3d007421 	cfstrscc	mvf7, [r0, #-132]	; 0xffffff7c
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5944:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5948:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	*(x--) = v;
	v >>= 8;
    594c:	32007421 	andcc	r7, r0, #553648128	; 0x21000000
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5950:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5954:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5958:	00742721 	rsbseq	r2, r4, r1, lsr #14
	*(x--) = v;
	v >>= 8;
    595c:	1f141446 	svcne	0x00141446
    5960:	17242023 	strne	r2, [r4, -r3, lsr #32]!
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5964:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5968:	0041f49f 	umaaleq	pc, r1, pc, r4	; <UNPREDICTABLE>
    596c:	00426e00 	subeq	r6, r2, r0, lsl #28
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5970:	71003600 	tstvc	r0, r0, lsl #12
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5974:	21007400 	tstcs	r0, r0, lsl #8
    5978:	711a0075 	tstvc	sl, r5, ror r0
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    597c:	1a007400 	bne	22984 <_etext+0x1b370>
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5980:	3d007121 	stfccs	f7, [r0, #-132]	; 0xffffff7c
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5984:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5988:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    598c:	32007121 	andcc	r7, r0, #1073741832	; 0x40000008
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
		uint8_t tmp[8];
		unsigned int c = 8 - offset;
    5990:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5994:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	v >>= 8;
	*(x--) = v;
    5998:	00712721 	rsbseq	r2, r1, r1, lsr #14
	v >>= 8;
	*(x--) = v;
    599c:	1f141446 	svcne	0x00141446
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59a0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59a4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59a8:	00426e9f 	umaaleq	r6, r2, pc, lr	; <UNPREDICTABLE>
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59ac:	0042ca00 	subeq	ip, r2, r0, lsl #20
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59b0:	72003600 	andvc	r3, r0, #0, 12
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    59b4:	21007100 	mrscs	r7, (UNDEF: 16)
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59b8:	721a0074 	andsvc	r0, sl, #116	; 0x74
	offset &= 7;

	/* Skip/read out bytes */
	if (offset) {
		uint8_t tmp[8];
		unsigned int c = 8 - offset;
    59bc:	1a007100 	bne	21dc4 <_etext+0x1a7b0>
    59c0:	3d007221 	sfmcc	f7, 4, [r0, #-132]	; 0xffffff7c
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    59c4:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    59c8:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
		memcpy(hash, tmp + offset, c);
		len -= c;
    59cc:	32007221 	andcc	r7, r0, #268435458	; 0x10000002

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    59d0:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
		len -= c;
    59d4:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    59d8:	00722721 	rsbseq	r2, r2, r1, lsr #14
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    59dc:	1f141446 	svcne	0x00141446

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
		memcpy(hash, tmp + offset, c);
    59e0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
		len -= c;
		hash += c;
    59e4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    59e8:	0042ca9f 	umaaleq	ip, r2, pc, sl	; <UNPREDICTABLE>
		memcpy(hash, tmp + offset, c);
		len -= c;
		hash += c;
    59ec:	00436200 	subeq	r6, r3, r0, lsl #4
		unsigned int c = 8 - offset;

		if (c > len)
			c = len;

		store64(tmp, s->h[i++]);
    59f0:	73003600 	movwvc	r3, #1536	; 0x600
    59f4:	21007200 	mrscs	r7, R8_usr

	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
    59f8:	731a0071 	tstvc	sl, #113	; 0x71
    59fc:	1a007200 	bne	22204 <_etext+0x1abf0>
    5a00:	3d007321 	stccc	3, cr7, [r0, #-132]	; 0xffffff7c
    5a04:	231f1414 	tstcs	pc, #20, 8	; 0x14000000

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5a08:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5a0c:	32007321 	andcc	r7, r0, #-2080374784	; 0x84000000
	*(x--) = v;
	v >>= 8;
    5a10:	231f1414 	tstcs	pc, #20, 8	; 0x14000000

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
    5a14:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	*(x--) = v;
	v >>= 8;
    5a18:	00732721 	rsbseq	r2, r3, r1, lsr #14
    5a1c:	1f141446 	svcne	0x00141446
	*(x--) = v;
	v >>= 8;
    5a20:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5a24:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5a28:	0043629f 	umaaleq	r6, r3, pc, r2	; <UNPREDICTABLE>
	*(x--) = v;
	v >>= 8;
    5a2c:	0043de00 	subeq	sp, r3, r0, lsl #28
    5a30:	70003600 	andvc	r3, r0, r0, lsl #12
	*(x--) = v;
	v >>= 8;
    5a34:	21007300 	mrscs	r7, LR_irq
    5a38:	701a0072 	andsvc	r0, sl, r2, ror r0
	*(x--) = v;
	v >>= 8;
    5a3c:	1a007300 	bne	22644 <_etext+0x1b030>
    5a40:	3d007021 	stccc	0, cr7, [r0, #-132]	; 0xffffff7c
    5a44:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	*(x--) = v;
	v >>= 8;
    5a48:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5a4c:	32007021 	andcc	r7, r0, #33	; 0x21
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5a50:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	*(x--) = v;
	v >>= 8;
    5a54:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5a58:	00702721 	rsbseq	r2, r0, r1, lsr #14
}

static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
    5a5c:	1f141446 	svcne	0x00141446
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a60:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a64:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a68:	0043de9f 	umaaleq	sp, r3, pc, lr	; <UNPREDICTABLE>
    5a6c:	00444c00 	subeq	r4, r4, r0, lsl #24
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5a70:	76003600 	strvc	r3, [r0], -r0, lsl #12
static inline void store64(uint8_t *x, uint64_t v)
{
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a74:	21007000 	mrscs	r7, (UNDEF: 0)
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5a78:	761a0073 			; <UNDEFINED> instruction: 0x761a0073
	x += 7;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a7c:	1a007000 	bne	21a84 <_etext+0x1a470>
	v >>= 8;
	*(x--) = v;
    5a80:	3d007621 	stccc	6, cr7, [r0, #-132]	; 0xffffff7c
	v >>= 8;
	*(x--) = v;
    5a84:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    5a88:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
    5a8c:	32007621 	andcc	r7, r0, #34603008	; 0x2100000
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
	*(x--) = v;
	v >>= 8;
    5a90:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	/* Read out bytes */
	if (len) {
		uint8_t tmp[8];

		store64(tmp, s->h[i]);
		memcpy(hash, tmp, len);
    5a94:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	}
}
    5a98:	00762721 	rsbseq	r2, r6, r1, lsr #14
    5a9c:	1f141446 	svcne	0x00141446
    for (i = 0; i < len; i++)
        uart_printf("%02x", data[i]);
    uart_printf("\n");
}

void failErase () {
    5aa0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	// for whatever reason this only flashes upto 0x08008800
	flashErasePage((u32)(0x08008000));
    5aa4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
	flashErasePage((u32)(0x08008000+1024));
    5aa8:	00444c9f 	umaaleq	r4, r4, pc, ip	; <UNPREDICTABLE>
    5aac:	0044f000 	subeq	pc, r4, r0
	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
    5ab0:	78003600 	stmdavc	r0, {r9, sl, ip, sp}
	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
    5ab4:	21007600 	tstcs	r0, r0, lsl #12
    5ab8:	781a0070 	ldmdavc	sl, {r4, r5, r6}
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
    5abc:	1a007600 	bne	232c4 <_etext+0x1bcb0>
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
}
    5ac0:	3d007821 	stccc	8, cr7, [r0, #-132]	; 0xffffff7c
	flashErasePage((u32)(0x08008000));
	flashErasePage((u32)(0x08008000+1024));
	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
    5ac4:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5ac8:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5acc:	32007821 	andcc	r7, r0, #2162688	; 0x210000
    5ad0:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5ad4:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5ad8:	00782721 	rsbseq	r2, r8, r1, lsr #14
    5adc:	1f141446 	svcne	0x00141446
    5ae0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
}

int imageCheckFromAddress(ImageObjectHandle *newHandle, vu32 flashAddress, bool shouldEraseFlashOnFail)
{
    5ae4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5ae8:	0044f09f 	umaaleq	pc, r4, pc, r0	; <UNPREDICTABLE>
    5aec:	00456800 	subeq	r6, r5, r0, lsl #16
    5af0:	7c003600 	stcvc	6, cr3, [r0], {-0}
	ImageRootHeader		*hdr;
	ImageInternalState		state;
	int bufferSize = 0x28+0x40;
	unsigned char imageBuffer[bufferSize];
    memset(imageBuffer, 0xFF, sizeof(imageBuffer));
    5af4:	21007800 	tstcs	r0, r0, lsl #16
    5af8:	7c1a0076 	ldcvc	0, cr0, [sl], {118}	; 0x76
    memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
    5afc:	1a007800 	bne	23b04 <_etext+0x1c4f0>
    5b00:	3d007c21 	stccc	12, cr7, [r0, #-132]	; 0xffffff7c
    5b04:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    memset(&state, 0, sizeof(state));
    5b08:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5b0c:	32007c21 	andcc	r7, r0, #8448	; 0x2100
		{
			failErase();
		}
		return(EINVAL);		/* buffer too small to really contain header */
	}
	if ((hdr->header.magic) != kImageHeaderMagic) {
    5b10:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5b14:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
		debug_print("bad magic 0x%08x expecting 0x%08x\n", (hdr->header.magic), kImageHeaderMagic);
    5b18:	007c2721 	rsbseq	r2, ip, r1, lsr #14
			failErase();
		}
		*newHandle = &state;
		return(kImageImageMissingMagic);		/* magic must match */
	}
	if ((hdr->signing.imageType) != 0x45444f53)
    5b1c:	1f141446 	svcne	0x00141446
    5b20:	17242023 	strne	r2, [r4, -r3, lsr #32]!
	{
		debug_print("bad magic 0x%08x expecting 0x%X\n", (hdr->signing.imageType), 0x45444f53);
    5b24:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5b28:	0045689f 	umaaleq	r6, r5, pc, r8	; <UNPREDICTABLE>
		state.flags = kImageImageMissingMagic;
    5b2c:	0045dc00 	subeq	sp, r5, r0, lsl #24
		if (shouldEraseFlashOnFail)
    5b30:	75003600 	strvc	r3, [r0, #-1536]	; 0x600
		{
			failErase();
    5b34:	21007c00 	tstcs	r0, r0, lsl #24
		}
		*newHandle = &state;
    5b38:	751a0078 	ldrvc	r0, [sl, #-120]	; 0x78
		return(kImageImageMissingMagic);		/* magic must match */
    5b3c:	1a007c00 	bne	24b44 <_etext+0x1d530>
	}
	state.flags = kImageImageWasInstantiated;
    5b40:	3d007521 	cfstr32cc	mvfx7, [r0, #-132]	; 0xffffff7c

	debug_print("dataSize: 0x%X\n", (hdr->header.dataSize));
    5b44:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5b48:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
	state.cursor = hdr->header.dataSize;
	state.lastTag = -1;

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5b4c:	32007521 	andcc	r7, r0, #138412032	; 0x8400000
	}
	state.flags = kImageImageWasInstantiated;

	debug_print("dataSize: 0x%X\n", (hdr->header.dataSize));

	state.cursor = hdr->header.dataSize;
    5b50:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
	state.lastTag = -1;
    5b54:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5b58:	00752721 	rsbseq	r2, r5, r1, lsr #14

	unsigned char sha256sum[32];

    memset(sha256sum, 0xFF, sizeof(sha256sum));
    5b5c:	1f141446 	svcne	0x00141446

    sha256_context ctx;
    sha256_starts(&ctx);
    5b60:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    int buffSize = 0x1;
    char buff[buffSize];

    int i = 0x84;
    char cmpEnd[5] = {0x01, 0x00, 0x00, 0x00, 0x00}; 
    hexdump((flashAddress+i), 0x10);
    5b64:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5b68:	0045dc9f 	umaaleq	sp, r5, pc, ip	; <UNPREDICTABLE>
    5b6c:	00464c00 	subeq	r4, r6, r0, lsl #24

    int finish = hdr->header.dataSize + 0x84;
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
    5b70:	74003600 	strvc	r3, [r0], #-1536	; 0x600

    int i = 0x84;
    char cmpEnd[5] = {0x01, 0x00, 0x00, 0x00, 0x00}; 
    hexdump((flashAddress+i), 0x10);

    int finish = hdr->header.dataSize + 0x84;
    5b74:	21007500 	tstcs	r0, r0, lsl #10
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
    5b78:	741a007c 	ldrvc	r0, [sl], #-124	; 0x7c
    5b7c:	1a007500 	bne	22f84 <_etext+0x1b970>
    sha256_starts(&ctx);

    int buffSize = 0x1;
    char buff[buffSize];

    int i = 0x84;
    5b80:	3d007421 	cfstrscc	mvf7, [r0, #-132]	; 0xffffff7c
    char cmpEnd[5] = {0x01, 0x00, 0x00, 0x00, 0x00}; 
    hexdump((flashAddress+i), 0x10);

    int finish = hdr->header.dataSize + 0x84;
    debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
    while (i < finish)
    5b84:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
		  	debug_print("Last block: %X\n", (flashAddress+i));
		  	break;
			}
		hexdump((vu32 *)(flashAddress+i), buffSize);
		}*/
		sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
    5b88:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5b8c:	32007421 	andcc	r7, r0, #553648128	; 0x21000000
    5b90:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
		i += 0x1;
    5b94:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    }
    debug_print("Ended at: %X\n", (flashAddress+i));
    5b98:	00742721 	rsbseq	r2, r4, r1, lsr #14
    5b9c:	1f141446 	svcne	0x00141446
    5ba0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    hexdump((vu32 *)(flashAddress+i), 0x10);
    5ba4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5ba8:	00464c9f 	umaaleq	r4, r6, pc, ip	; <UNPREDICTABLE>
    if ((flashAddress+i) != (flashAddress+finish))
    5bac:	0046c200 	subeq	ip, r6, r0, lsl #4
    5bb0:	72003600 	andvc	r3, r0, #0, 12
    5bb4:	21007400 	tstcs	r0, r0, lsl #8
    {
    	debug_print("Calculated hash is probably wrong...\n");
    5bb8:	721a0075 	andsvc	r0, sl, #117	; 0x75
    5bbc:	1a007400 	bne	22bc4 <_etext+0x1b5b0>
    	state.flags = kImageImageHashCalcFailed;
    	*newHandle = &state;
		return(kImageImageHashCalcFailed);
    5bc0:	3d007221 	sfmcc	f7, 4, [r0, #-132]	; 0xffffff7c
	    sha256_update(&ctx, uniqueID, 0x17);
    }

    //debug_print("%s\n", uniqueID);
    
    sha256_finish(&ctx, sha256sum);
    5bc4:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5bc8:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    print_hash(sha256sum);
    // verify signature against recalc hash
    uint8_t sigbuff[0x40];
    memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
    5bcc:	32007221 	andcc	r7, r0, #268435458	; 0x10000002
    5bd0:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    }

    //debug_print("%s\n", uniqueID);
    
    sha256_finish(&ctx, sha256sum);
    print_hash(sha256sum);
    5bd4:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    // verify signature against recalc hash
    uint8_t sigbuff[0x40];
    memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
    5bd8:	00722721 	rsbseq	r2, r2, r1, lsr #14
    5bdc:	1f141446 	svcne	0x00141446
    5be0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5be4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5be8:	0046c29f 	umaaleq	ip, r6, pc, r2	; <UNPREDICTABLE>

    if (edsign_verify(sigbuff, rootCA, sha256sum, 32) <= 0) {
    5bec:	00473400 	subeq	r3, r7, r0, lsl #8
    5bf0:	71003600 	tstvc	r0, r0, lsl #12
    5bf4:	21007200 	mrscs	r7, R8_usr
    	state.flags = kImageImageRejectSignature;
    5bf8:	711a0074 	tstvc	sl, r4, ror r0
    	if (shouldEraseFlashOnFail)
    5bfc:	1a007200 	bne	22404 <_etext+0x1adf0>
    5c00:	3d007121 	stfccs	f7, [r0, #-132]	; 0xffffff7c
		{
			failErase();
    5c04:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
		}
    	*newHandle = &state;
    	return kImageImageRejectSignature;
    5c08:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    } else {
    	state.flags = kImageImageIsTrusted;
    	*newHandle = &state;
    5c0c:	32007121 	andcc	r7, r0, #1073741832	; 0x40000008
    	return kImageImageIsTrusted;
    }
	
	*newHandle = &state;
	return(0);
}
    5c10:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5c14:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5c18:	00712721 	rsbseq	r2, r1, r1, lsr #14
    5c1c:	1f141446 	svcne	0x00141446
    5c20:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5c24:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5c28:	0047349f 	umaaleq	r3, r7, pc, r4	; <UNPREDICTABLE>
    5c2c:	0047ae00 	subeq	sl, r7, r0, lsl #28
    5c30:	73003600 	movwvc	r3, #1536	; 0x600
    5c34:	21007100 	mrscs	r7, (UNDEF: 16)
    5c38:	731a0072 	tstvc	sl, #114	; 0x72
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxStatus(u8 bEpNum, u16 wState)
{
  _SetEPTxStatus(bEpNum, wState);
    5c3c:	1a007100 	bne	22044 <_etext+0x1aa30>
    5c40:	3d007321 	stccc	3, cr7, [r0, #-132]	; 0xffffff7c
    5c44:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5c48:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5c4c:	32007321 	andcc	r7, r0, #-2080374784	; 0x84000000
    5c50:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5c54:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5c58:	00732721 	rsbseq	r2, r3, r1, lsr #14
    5c5c:	1f141446 	svcne	0x00141446
    5c60:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5c64:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxValid(u8 bEpNum)
{
  _SetEPRxStatus(bEpNum, EP_RX_VALID);
    5c68:	0047ae9f 	umaaleq	sl, r7, pc, lr	; <UNPREDICTABLE>
    5c6c:	00482800 	subeq	r2, r8, r0, lsl #16
    5c70:	70003600 	andvc	r3, r0, r0, lsl #12
    5c74:	21007300 	mrscs	r7, LR_irq
    5c78:	701a0071 	andsvc	r0, sl, r1, ror r0
    5c7c:	1a007300 	bne	22884 <_etext+0x1b270>
    5c80:	3d007021 	stccc	0, cr7, [r0, #-132]	; 0xffffff7c
* Output         : None.
* Return         : None.
*******************************************************************************/
void Clear_Status_Out(u8 bEpNum)
{
  _ClearEP_KIND(bEpNum);
    5c84:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5c88:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5c8c:	32007021 	andcc	r7, r0, #33	; 0x21
    5c90:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5c94:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5c98:	00702721 	rsbseq	r2, r0, r1, lsr #14
    5c9c:	1f141446 	svcne	0x00141446
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_RX(u8 bEpNum)
{
  _ClearDTOG_RX(bEpNum);
    5ca0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5ca4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5ca8:	0048289f 	umaaleq	r2, r8, pc, r8	; <UNPREDICTABLE>
    5cac:	00488400 	subeq	r8, r8, r0, lsl #8
    5cb0:	76003600 	strvc	r3, [r0], -r0, lsl #12
    5cb4:	21007000 	mrscs	r7, (UNDEF: 0)
    5cb8:	761a0073 			; <UNDEFINED> instruction: 0x761a0073
    5cbc:	1a007000 	bne	21cc4 <_etext+0x1a6b0>
* Output         : None.
* Return         : None.
*******************************************************************************/
void ClearDTOG_TX(u8 bEpNum)
{
  _ClearDTOG_TX(bEpNum);
    5cc0:	3d007621 	stccc	6, cr7, [r0, #-132]	; 0xffffff7c
    5cc4:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5cc8:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5ccc:	32007621 	andcc	r7, r0, #34603008	; 0x2100000
    5cd0:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5cd4:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5cd8:	00762721 	rsbseq	r2, r6, r1, lsr #14
    5cdc:	1f141446 	svcne	0x00141446
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
u16 GetEPTxAddr(u8 bEpNum)
{
  return(_GetEPTxAddr(bEpNum));
    5ce0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5ce4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5ce8:	0048849f 	umaaleq	r8, r8, pc, r4	; <UNPREDICTABLE>
    5cec:	00492c00 	subeq	r2, r9, r0, lsl #24
    5cf0:	7c003600 	stcvc	6, cr3, [r0], {-0}
}
    5cf4:	21007600 	tstcs	r0, r0, lsl #12
    5cf8:	7c1a0070 	ldcvc	0, cr0, [sl], {112}	; 0x70
* Output         : None.
* Return         : Rx buffer address.
*******************************************************************************/
u16 GetEPRxAddr(u8 bEpNum)
{
  return(_GetEPRxAddr(bEpNum));
    5cfc:	1a007600 	bne	23504 <_etext+0x1bef0>
    5d00:	3d007c21 	stccc	12, cr7, [r0, #-132]	; 0xffffff7c
    5d04:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5d08:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
}
    5d0c:	32007c21 	andcc	r7, r0, #8448	; 0x2100
    5d10:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5d14:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPTxCount(u8 bEpNum, u16 wCount)
{
  _SetEPTxCount(bEpNum, wCount);
    5d18:	007c2721 	rsbseq	r2, ip, r1, lsr #14
    5d1c:	1f141446 	svcne	0x00141446
    5d20:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5d24:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5d28:	00492c9f 	umaaleq	r2, r9, pc, ip	; <UNPREDICTABLE>
    5d2c:	0049a200 	subeq	sl, r9, r0, lsl #4
    5d30:	75003600 	strvc	r3, [r0, #-1536]	; 0x600
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPRxCount(u8 bEpNum, u16 wCount)
{
  _SetEPRxCount(bEpNum, wCount);
    5d34:	21007c00 	tstcs	r0, r0, lsl #24
    5d38:	751a0076 	ldrvc	r0, [sl, #-118]	; 0x76
    5d3c:	1a007c00 	bne	24d44 <_etext+0x1d730>
    5d40:	3d007521 	cfstr32cc	mvfx7, [r0, #-132]	; 0xffffff7c
    5d44:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5d48:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5d4c:	32007521 	andcc	r7, r0, #138412032	; 0x8400000
    5d50:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5d54:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5d58:	00752721 	rsbseq	r2, r5, r1, lsr #14
    5d5c:	1f141446 	svcne	0x00141446
    5d60:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5d64:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5d68:	0049a29f 	umaaleq	sl, r9, pc, r2	; <UNPREDICTABLE>
    5d6c:	004a2000 	subeq	r2, sl, r0
    5d70:	78003600 	stmdavc	r0, {r9, sl, ip, sp}
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void CTR_LP(void)
{
    5d74:	21007500 	tstcs	r0, r0, lsl #10
  u32 wEPVal = 0;
  /* stay in loop while pending ints */
  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
    5d78:	781a007c 	ldmdavc	sl, {r2, r3, r4, r5, r6}
    5d7c:	1a007500 	bne	23184 <_etext+0x1bb70>
    5d80:	3d007821 	stccc	8, cr7, [r0, #-132]	; 0xffffff7c
    5d84:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
    5d88:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
    5d8c:	32007821 	andcc	r7, r0, #2162688	; 0x210000
    5d90:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5d94:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    if (EPindex == 0)
    5d98:	00782721 	rsbseq	r2, r8, r1, lsr #14
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */
      SaveRState = _GetEPRxStatus(ENDP0);
    5d9c:	1f141446 	svcne	0x00141446
      SaveTState = _GetEPTxStatus(ENDP0);
    5da0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
      /* calling related service routine */
      /* (Setup0_Process, In0_Process, Out0_Process) */

      /* save RX & TX status */
      /* and set both to NAK */
      SaveRState = _GetEPRxStatus(ENDP0);
    5da4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
      SaveTState = _GetEPTxStatus(ENDP0);
    5da8:	004a209f 	umaaleq	r2, sl, pc, r0	; <UNPREDICTABLE>
    5dac:	004a9e00 	subeq	r9, sl, r0, lsl #28
      _SetEPRxStatus(ENDP0, EP_RX_NAK);
    5db0:	72003600 	andvc	r3, r0, #0, 12
    5db4:	21007800 	tstcs	r0, r0, lsl #16
    5db8:	721a0075 	andsvc	r0, sl, #117	; 0x75
    5dbc:	1a007800 	bne	23dc4 <_etext+0x1c7b0>
    5dc0:	3d007221 	sfmcc	f7, 4, [r0, #-132]	; 0xffffff7c
      _SetEPTxStatus(ENDP0, EP_TX_NAK);
    5dc4:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5dc8:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5dcc:	32007221 	andcc	r7, r0, #268435458	; 0x10000002
    5dd0:	231f1414 	tstcs	pc, #20, 8	; 0x14000000


      /* DIR bit = origin of the interrupt */

      if ((wIstr & ISTR_DIR) == 0)
    5dd4:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5dd8:	00722721 	rsbseq	r2, r2, r1, lsr #14

        /* DIR = 1 & CTR_RX       => SETUP or OUT int */
        /* DIR = 1 & (CTR_TX | CTR_RX) => 2 int pending */

        wEPVal = _GetENDPOINT(ENDP0);
        if ((wEPVal & EP_CTR_TX) != 0)
    5ddc:	1f141446 	svcne	0x00141446
        {
          _ClearEP_CTR_TX(ENDP0);
    5de0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5de4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5de8:	004a9e9f 	umaaleq	r9, sl, pc, lr	; <UNPREDICTABLE>
          In0_Process();
    5dec:	004b1a00 	subeq	r1, fp, r0, lsl #20
          /* before terminate set Tx & Rx status */
          _SetEPRxStatus(ENDP0, SaveRState);
          _SetEPTxStatus(ENDP0, SaveTState);
          return;
        }
        else if ((wEPVal &EP_SETUP) != 0)
    5df0:	71003600 	tstvc	r0, r0, lsl #12
        {
          _ClearEP_CTR_RX(ENDP0); /* SETUP bit kept frozen while CTR_RX = 1 */
    5df4:	21007200 	mrscs	r7, R8_usr
    5df8:	711a0078 	tstvc	sl, r8, ror r0
    5dfc:	1a007200 	bne	22604 <_etext+0x1aff0>
          Setup0_Process();
    5e00:	3d007121 	stfccs	f7, [r0, #-132]	; 0xffffff7c
          _SetEPRxStatus(ENDP0, SaveRState);
          _SetEPTxStatus(ENDP0, SaveTState);
          return;
        }

        else if ((wEPVal & EP_CTR_RX) != 0)
    5e04:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
        {
          _ClearEP_CTR_RX(ENDP0);
    5e08:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5e0c:	32007121 	andcc	r7, r0, #1073741832	; 0x40000008
    5e10:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
          Out0_Process();
    5e14:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
          /* before terminate set Tx & Rx status */
          _SetEPRxStatus(ENDP0, SaveRState);
    5e18:	00712721 	rsbseq	r2, r1, r1, lsr #14
    5e1c:	1f141446 	svcne	0x00141446
    5e20:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5e24:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    5e28:	004b1a9f 	umaaleq	r1, fp, pc, sl	; <UNPREDICTABLE>
    5e2c:	004bac00 	subeq	sl, fp, r0, lsl #24
    5e30:	74003600 	strvc	r3, [r0], #-1536	; 0x600
    5e34:	21007100 	mrscs	r7, (UNDEF: 16)
          _SetEPTxStatus(ENDP0, SaveTState);
    5e38:	741a0072 	ldrvc	r0, [sl], #-114	; 0x72
    5e3c:	1a007100 	bne	22244 <_etext+0x1ac30>
    5e40:	3d007421 	cfstrscc	mvf7, [r0, #-132]	; 0xffffff7c
    5e44:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5e48:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5e4c:	32007421 	andcc	r7, r0, #553648128	; 0x21000000
    5e50:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5e54:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
          return;
    5e58:	00742721 	rsbseq	r2, r4, r1, lsr #14
    else
    {
      /* Decode and service non control endpoints interrupt  */

      /* process related endpoint register */
      wEPVal = _GetENDPOINT(EPindex);
    5e5c:	1f141446 	svcne	0x00141446
    5e60:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5e64:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
      if ((wEPVal & EP_CTR_RX) != 0)
    5e68:	004bac9f 	umaaleq	sl, fp, pc, ip	; <UNPREDICTABLE>
      {
        /* clear int flag */
        _ClearEP_CTR_RX(EPindex);
    5e6c:	004c2600 	subeq	r2, ip, r0, lsl #12
    5e70:	91004000 	mrsls	r4, (UNDEF: 0)

        /* call OUT service function */
        (*pEpInt_OUT[EPindex-1])();
    5e74:	74067f94 	strvc	r7, [r6], #-3988	; 0xf94
    5e78:	00712100 	rsbseq	r2, r1, r0, lsl #2
    5e7c:	7f94911a 	svcvc	0x0094911a

      } /* if((wEPVal & EP_CTR_RX) */

      if ((wEPVal & EP_CTR_TX) != 0)
    5e80:	1a007406 	bne	22ea0 <_etext+0x1b88c>
      {
        /* clear int flag */
        _ClearEP_CTR_TX(EPindex);
    5e84:	7f949121 	svcvc	0x00949121
    5e88:	14143d06 	ldrne	r3, [r4], #-3334	; 0xd06
    5e8c:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5e90:	91212517 	teqls	r1, r7, lsl r5
    5e94:	32067f94 	andcc	r7, r6, #148, 30	; 0x250
    5e98:	231f1414 	tstcs	pc, #20, 8	; 0x14000000

        /* call IN service function */
        (*pEpInt_IN[EPindex-1])();
    5e9c:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5ea0:	94912721 	ldrls	r2, [r1], #1825	; 0x721
    5ea4:	1446067f 	strbne	r0, [r6], #-1663	; 0x67f
    5ea8:	20231f14 	eorcs	r1, r3, r4, lsl pc
    5eac:	21251724 	teqcs	r5, r4, lsr #14
    5eb0:	269f2227 	ldrcs	r2, [pc], r7, lsr #4
    5eb4:	be00004c 	cdplt	0, 0, cr0, cr0, cr12, {2}
    5eb8:	4400004c 	strmi	r0, [r0], #-76	; 0x4c
    5ebc:	7f989100 	svcvc	0x00989100
    5ec0:	7f949106 	svcvc	0x00949106
    5ec4:	00742106 	rsbseq	r2, r4, r6, lsl #2
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void USB_Init(void)
{
    5ec8:	7f98911a 	svcvc	0x0098911a
  pInformation = &Device_Info;
    5ecc:	7f949106 	svcvc	0x00949106
    5ed0:	91211a06 	teqls	r1, r6, lsl #20
  pInformation->ControlState = 2;
    5ed4:	3d067f98 	stccc	15, cr7, [r6, #-608]	; 0xfffffda0
  pProperty = &Device_Property;
    5ed8:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
  pUser_Standard_Requests = &User_Standard_Requests;
    5edc:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5ee0:	7f989121 	svcvc	0x00989121
  /* Initialize devices one by one */

  pProperty->Init();
    5ee4:	14143206 	ldrne	r3, [r4], #-518	; 0x206
    5ee8:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    5eec:	27212517 			; <UNDEFINED> instruction: 0x27212517
    5ef0:	067f9891 			; <UNDEFINED> instruction: 0x067f9891
    5ef4:	1f141446 	svcne	0x00141446
    5ef8:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5efc:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
* Output         : None.
* Return         : Return 1 , if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
u8 *Standard_GetConfiguration(u16 Length)
{
    5f00:	004cbe9f 	umaaleq	fp, ip, pc, lr	; <UNPREDICTABLE>
  if (Length == 0)
    5f04:	004d7600 	subeq	r7, sp, r0, lsl #12
  {
    pInformation->Ctrl_Info.Usb_wLength =
    5f08:	91004600 	tstls	r0, r0, lsl #12
      sizeof(pInformation->Current_Configuration);
    return 0;
    5f0c:	91067fa4 	smlatbls	r6, r4, pc, r7	; <UNPREDICTABLE>
  }
  pUser_Standard_Requests->User_GetConfiguration();
    5f10:	21067f98 			; <UNDEFINED> instruction: 0x21067f98
    5f14:	067f9491 			; <UNDEFINED> instruction: 0x067f9491
  return (u8 *)&pInformation->Current_Configuration;
    5f18:	7fa4911a 	svcvc	0x00a4911a
}
    5f1c:	7f989106 	svcvc	0x00989106
    5f20:	91211a06 	teqls	r1, r6, lsl #20
* Output         : None.
* Return         : Return 0, if the request is invalid when "Length" is 0.
*                  Return "Buffer" if the "Length" is not 0.
*******************************************************************************/
u8 *Standard_GetInterface(u16 Length)
{
    5f24:	3d067fa4 	stccc	15, cr7, [r6, #-656]	; 0xfffffd70
  if (Length == 0)
    5f28:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
  {
    pInformation->Ctrl_Info.Usb_wLength =
    5f2c:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
      sizeof(pInformation->Current_AlternateSetting);
    return 0;
    5f30:	7fa49121 	svcvc	0x00a49121
  }
  pUser_Standard_Requests->User_GetInterface();
    5f34:	14143206 	ldrne	r3, [r4], #-518	; 0x206
    5f38:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
  return (u8 *)&pInformation->Current_AlternateSetting;
    5f3c:	27212517 			; <UNDEFINED> instruction: 0x27212517
}
    5f40:	067fa491 			; <UNDEFINED> instruction: 0x067fa491
    5f44:	1f141446 	svcne	0x00141446
* Output         : None.
* Return         : Return 0, if the request is at end of data block,
*                  or is invalid when "Length" is 0.
*******************************************************************************/
u8 *Standard_GetStatus(u16 Length)
{
    5f48:	17242023 	strne	r2, [r4, -r3, lsr #32]!
  if (Length == 0)
    5f4c:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
    5f50:	004d769f 	umaaleq	r7, sp, pc, r6	; <UNPREDICTABLE>
    return 0;
    5f54:	004e0000 	subeq	r0, lr, r0
  }

  StatusInfo.w = 0;
  /* Reset Status Information */

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    5f58:	91004600 	tstls	r0, r0, lsl #12
  {
    pInformation->Ctrl_Info.Usb_wLength = 2;
    return 0;
  }

  StatusInfo.w = 0;
    5f5c:	91067fa8 	smlatbls	r6, r8, pc, r7	; <UNPREDICTABLE>
  /* Reset Status Information */

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    5f60:	21067fa4 	smlatbcs	r6, r4, pc, r7	; <UNPREDICTABLE>
    5f64:	067f9891 			; <UNDEFINED> instruction: 0x067f9891
  {
    /*Get Device Status */
    u8 Feature = pInformation->Current_Feature;
    5f68:	7fa8911a 	svcvc	0x00a8911a

    /* Remote Wakeup enabled */
    if (ValBit(Feature, 5))
    {
      SetBit(StatusInfo0, 1);
    5f6c:	7fa49106 	svcvc	0x00a49106
    5f70:	91211a06 	teqls	r1, r6, lsl #20
    }

    /* Bus-powered */
    if (ValBit(Feature, 6))
    5f74:	3d067fa8 	stccc	15, cr7, [r6, #-672]	; 0xfffffd60
    {
      ClrBit(StatusInfo0, 0);
    5f78:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    5f7c:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    }
    else /* Self-powered */
    {
      SetBit(StatusInfo0, 0);
    5f80:	7fa89121 	svcvc	0x00a89121
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    5f84:	14143206 	ldrne	r3, [r4], #-518	; 0x206
  {
    return (u8 *)&StatusInfo;
  }
  /*Get EndPoint Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    5f88:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;
    5f8c:	27212517 			; <UNDEFINED> instruction: 0x27212517

    Related_Endpoint = (wIndex0 & 0x0f);
    5f90:	067fa891 			; <UNDEFINED> instruction: 0x067fa891
    if (ValBit(wIndex0, 7))
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5f94:	1f141446 	svcne	0x00141446
    5f98:	17242023 	strne	r2, [r4, -r3, lsr #32]!
  {
    u8 Related_Endpoint;
    u8 wIndex0 = pInformation->USBwIndex0;

    Related_Endpoint = (wIndex0 & 0x0f);
    if (ValBit(wIndex0, 7))
    5f9c:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint))
    5fa0:	004e009f 	umaaleq	r0, lr, pc, r0	; <UNPREDICTABLE>
    5fa4:	004e9000 	subeq	r9, lr, r0
    5fa8:	91004600 	tstls	r0, r0, lsl #12
      {
        SetBit(StatusInfo0, 0); /* IN Endpoint stalled */
    5fac:	91067f94 			; <UNDEFINED> instruction: 0x91067f94
    5fb0:	21067fa8 	smlatbcs	r6, r8, pc, r7	; <UNPREDICTABLE>
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
    5fb4:	067fa491 			; <UNDEFINED> instruction: 0x067fa491
    5fb8:	7f94911a 	svcvc	0x0094911a
  }
  else
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
    5fbc:	7fa89106 	svcvc	0x00a89106
    5fc0:	91211a06 	teqls	r1, r6, lsl #20
  return (u8 *)&StatusInfo;
    5fc4:	3d067f94 	stccc	15, cr7, [r6, #-592]	; 0xfffffdb0
    }
  }
  /*Interface Status*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
  {
    return (u8 *)&StatusInfo;
    5fc8:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
  {
    return NULL;
  }
  pUser_Standard_Requests->User_GetStatus();
  return (u8 *)&StatusInfo;
}
    5fcc:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    5fd0:	7f949121 	svcvc	0x00949121
    5fd4:	14143206 	ldrne	r3, [r4], #-518	; 0x206
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
    5fd8:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void DataStageIn(void)
{
    5fdc:	27212517 			; <UNDEFINED> instruction: 0x27212517
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
    5fe0:	067f9491 			; <UNDEFINED> instruction: 0x067f9491
  u32 save_wLength = pEPinfo->Usb_wLength;
  u32 ControlState = pInformation->ControlState;
    5fe4:	1f141446 	svcne	0x00141446

  u8 *DataBuffer;
  u32 Length;

  if ((save_wLength == 0) && (ControlState == LAST_IN_DATA))
    5fe8:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    5fec:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
  {
    if(Data_Mul_MaxPacketSize == TRUE)
    5ff0:	004e909f 	umaaleq	r9, lr, pc, r0	; <UNPREDICTABLE>
    5ff4:	004ef800 	subeq	pc, lr, r0, lsl #16
    {
      /* No more data to send and empty packet */
      Send0LengthData();
    5ff8:	91004600 	tstls	r0, r0, lsl #12
    5ffc:	91067fb0 			; <UNDEFINED> instruction: 0x91067fb0
    6000:	21067f94 			; <UNDEFINED> instruction: 0x21067f94
    6004:	067fa891 			; <UNDEFINED> instruction: 0x067fa891
      ControlState = LAST_IN_DATA;
      Data_Mul_MaxPacketSize = FALSE;
    6008:	7fb0911a 	svcvc	0x00b0911a
    }
    else
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
      vSetEPTxStatus(EP_TX_STALL);
    600c:	7f949106 	svcvc	0x00949106
      Data_Mul_MaxPacketSize = FALSE;
    }
    else
    {
      /* No more data to send so STALL the TX Status*/
      ControlState = WAIT_STATUS_OUT;
    6010:	91211a06 	teqls	r1, r6, lsl #20
    }

    goto Expect_Status_Out;
  }

  Length = pEPinfo->PacketSize;
    6014:	3d067fb0 	stccc	15, cr7, [r6, #-704]	; 0xfffffd40
  ControlState = (save_wLength <= Length) ? LAST_IN_DATA : IN_DATA;
    6018:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    601c:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
  if (Length > save_wLength)
  {
    Length = save_wLength;
  }

  DataBuffer = (*pEPinfo->CopyData)(Length);
    6020:	7fb09121 	svcvc	0x00b09121
    6024:	14143206 	ldrne	r3, [r4], #-518	; 0x206
    6028:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f

  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);
    602c:	27212517 			; <UNDEFINED> instruction: 0x27212517
    6030:	067fb091 			; <UNDEFINED> instruction: 0x067fb091
    6034:	1f141446 	svcne	0x00141446
    6038:	17242023 	strne	r2, [r4, -r3, lsr #32]!

  SetEPTxCount(ENDP0, Length);
    603c:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    6040:	004ef89f 	umaaleq	pc, lr, pc, r8	; <UNPREDICTABLE>

  pEPinfo->Usb_wLength -= Length;
    6044:	004f6c00 	subeq	r6, pc, r0, lsl #24
  pEPinfo->Usb_wOffset += Length;
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */
    6048:	73003c00 	movwvc	r3, #3072	; 0xc00

  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
    604c:	7fb09100 	svcvc	0x00b09100
  pEPinfo->Usb_wOffset += Length;
    6050:	94912106 	ldrls	r2, [r1], #262	; 0x106
  vSetEPTxStatus(EP_TX_VALID);
    6054:	731a067f 	tstvc	sl, #133169152	; 0x7f00000
  UserToPMABufferCopy(DataBuffer, GetEPTxAddr(ENDP0), Length);

  SetEPTxCount(ENDP0, Length);

  pEPinfo->Usb_wLength -= Length;
  pEPinfo->Usb_wOffset += Length;
    6058:	7fb09100 	svcvc	0x00b09100
  vSetEPTxStatus(EP_TX_VALID);

  USB_StatusOut();/* Expect the host to abort the data IN stage */

Expect_Status_Out:
  pInformation->ControlState = ControlState;
    605c:	73211a06 	teqvc	r1, #24576	; 0x6000
    6060:	14143d00 	ldrne	r3, [r4], #-3328	; 0xd00
    6064:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    6068:	73212517 	teqvc	r1, #96468992	; 0x5c00000
    606c:	14143200 	ldrne	r3, [r4], #-512	; 0x200
    6070:	2420231f 	strtcs	r2, [r0], #-799	; 0x31f
    6074:	27212517 			; <UNDEFINED> instruction: 0x27212517
    6078:	14460073 	strbne	r0, [r6], #-115	; 0x73
    607c:	20231f14 	eorcs	r1, r3, r4, lsl pc
* Output         : None.
* Return         : Return USB_SUCCESS, if the request is performed.
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{
    6080:	21251724 	teqcs	r5, r4, lsr #14

  if ((pInformation->USBwValue0 <=
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
    6084:	6c9f2227 	lfmvs	f2, 4, [pc], {39}	; 0x27
*                  Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetConfiguration(void)
{

  if ((pInformation->USBwValue0 <=
    6088:	e800004f 	stmda	r0, {r0, r1, r2, r3, r6}
    608c:	3800004f 	stmdacc	r0, {r0, r1, r2, r3, r6}
      Device_Table.Total_Configuration) && (pInformation->USBwValue1 == 0)
    6090:	73007100 	movwvc	r7, #256	; 0x100
      && (pInformation->USBwIndex == 0)) /*call Back usb spec 2.0*/
    6094:	b0912100 	addslt	r2, r1, r0, lsl #2
  {
    pInformation->Current_Configuration = pInformation->USBwValue0;
    6098:	711a067f 	tstvc	sl, pc, ror r6
    pUser_Standard_Requests->User_SetConfiguration();
    609c:	1a007300 	bne	22ca4 <_etext+0x1b690>
    60a0:	3d007121 	stfccs	f7, [r0, #-132]	; 0xffffff7c
    return USB_SUCCESS;
    60a4:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
  }
  else
  {
    return USB_UNSUPPORT;
  }
}
    60a8:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
    60ac:	32007121 	andcc	r7, r0, #1073741832	; 0x40000008
    60b0:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    60b4:	25172420 	ldrcs	r2, [r7, #-1056]	; 0x420
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetInterface(void)
{
    60b8:	00712721 	rsbseq	r2, r1, r1, lsr #14
  RESULT Re;
  /*Test if the specified Interface and Alternate Setting are supported by
    the application Firmware*/
  Re = (*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, pInformation->USBwValue0);
    60bc:	1f141446 	svcne	0x00141446
    60c0:	17242023 	strne	r2, [r4, -r3, lsr #32]!
    60c4:	22272125 	eorcs	r2, r7, #1073741833	; 0x40000009
    60c8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>

  if (pInformation->Current_Configuration != 0)
    60cc:	00000000 	andeq	r0, r0, r0
  {
    if ((Re != USB_SUCCESS) || (pInformation->USBwIndex1 != 0)
    60d0:	00317a00 	eorseq	r7, r1, r0, lsl #20
    60d4:	0031b000 	eorseq	fp, r1, r0
        || (pInformation->USBwValue1 != 0))
    60d8:	59000600 	stmdbpl	r0, {r9, sl}
    {
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
    60dc:	fc930493 	ldc2	4, cr0, [r3], {147}	; 0x93
    60e0:	0031b001 	eorseq	fp, r1, r1
      pInformation->Current_Interface = pInformation->USBwIndex0;
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
      return USB_SUCCESS;
    60e4:	0031b400 	eorseq	fp, r1, r0, lsl #8
      return  USB_UNSUPPORT;
    }
    else if (Re == USB_SUCCESS)
    {
      pUser_Standard_Requests->User_SetInterface();
      pInformation->Current_Interface = pInformation->USBwIndex0;
    60e8:	59000900 	stmdbpl	r0, {r8, fp}
      pInformation->Current_AlternateSetting = pInformation->USBwValue0;
    60ec:	93540493 	cmpls	r4, #-1828716544	; 0x93000000
      return USB_SUCCESS;
    }

  }

  return USB_UNSUPPORT;
    60f0:	01f89304 	mvnseq	r9, r4, lsl #6
}
    60f4:	000031b4 			; <UNDEFINED> instruction: 0x000031b4
    60f8:	000031c4 	andeq	r3, r0, r4, asr #3
    60fc:	9359000b 	cmpls	r9, #11
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_ClearFeature(void)
{
    6100:	7fa49104 	svcvc	0x00a49104
  u32     Type_Rec = Type_Recipient;
    6104:	f8930493 			; <UNDEFINED> instruction: 0xf8930493
  u32     Status;


  if (Type_Rec == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6108:	0031c401 	eorseq	ip, r1, r1, lsl #8
    610c:	00321a00 	eorseq	r1, r2, r0, lsl #20
  {/*Device Clear Feature*/
    ClrBit(pInformation->Current_Feature, 5);
    6110:	91000c00 	tstls	r0, r0, lsl #24
    6114:	9104935c 	tstls	r4, ip, asr r3
    return USB_SUCCESS;
  }
  else if (Type_Rec == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    6118:	04937fa4 	ldreq	r7, [r3], #4004	; 0xfa4
    DEVICE* pDev;
    u32 Related_Endpoint;
    u32 wIndex0;
    u32 rEP;

    if ((pInformation->USBwValue != ENDPOINT_STALL)
    611c:	1a01f893 	bne	84370 <_etext+0x7cd5c>
    6120:	38000032 	stmdacc	r0, {r1, r4, r5}
        || (pInformation->USBwIndex1 != 0))
    6124:	0f000032 	svceq	0x00000032
    {
      return USB_UNSUPPORT;
    }

    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    6128:	935c9100 	cmpls	ip, #0, 2
    rEP = wIndex0 & ~0x80;
    612c:	7fa49104 	svcvc	0x00a49104
    6130:	93540493 	cmpls	r4, #-1828716544	; 0x93000000

    if (ValBit(pInformation->USBwIndex0, 7))
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
    6134:	01f49304 	mvnseq	r9, r4, lsl #6
    6138:	00003238 	andeq	r3, r0, r8, lsr r2
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    613c:	0000323e 	andeq	r3, r0, lr, lsr r2
    pDev = &Device_Table;
    wIndex0 = pInformation->USBwIndex0;
    rEP = wIndex0 & ~0x80;
    Related_Endpoint = ENDP0 + rEP;

    if (ValBit(pInformation->USBwIndex0, 7))
    6140:	5c91000f 	ldcpl	0, cr0, [r1], {15}
    {
      /*Get Status of endpoint & stall the request if the related_ENdpoint
      is Disabled*/
      Status = _GetEPTxStatus(Related_Endpoint);
    6144:	a4910493 	ldrge	r0, [r1], #1171	; 0x493
    }
    else
    {
      Status = _GetEPRxStatus(Related_Endpoint);
    6148:	5704937f 	smlsdxpl	r4, pc, r3, r9	; <UNPREDICTABLE>
    }

    if ((rEP >= pDev->Total_Endpoint) || (Status == 0)
    614c:	f4930493 			; <UNDEFINED> instruction: 0xf4930493
    6150:	00323e01 	eorseq	r3, r2, r1, lsl #28
        || (pInformation->Current_Configuration == 0))
    6154:	00328600 	eorseq	r8, r2, r0, lsl #12


    if (wIndex0 & 0x80)
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    6158:	91001100 	mrsls	r1, (UNDEF: 16)
    615c:	9104935c 	tstls	r4, ip, asr r3
    {
      return USB_UNSUPPORT;
    }


    if (wIndex0 & 0x80)
    6160:	04937fa4 	ldreq	r7, [r3], #4004	; 0xfa4
    6164:	937fa891 	cmnls	pc, #9502720	; 0x910000
    {
      /* IN endpoint */
      if (_GetTxStallStatus(Related_Endpoint ))
    6168:	01f49304 	mvnseq	r9, r4, lsl #6
    616c:	00003286 	andeq	r3, r0, r6, lsl #5
      {
        ClearDTOG_TX(Related_Endpoint);
    6170:	00003296 	muleq	r0, r6, r2
    6174:	5c910014 	ldcpl	0, cr0, [r1], {20}
        SetEPTxStatus(Related_Endpoint, EP_TX_VALID);
    6178:	a4910493 	ldrge	r0, [r1], #1171	; 0x493
    617c:	9104937f 	tstls	r4, pc, ror r3
      }
    }
    else
    {
      /* OUT endpoint */
      if (_GetRxStallStatus(Related_Endpoint))
    6180:	04937fa8 	ldreq	r7, [r3], #4008	; 0xfa8
    6184:	93049354 	movwls	r9, #17236	; 0x4354
    6188:	329601f0 	addscc	r0, r6, #240, 2	; 0x3c
      {
        if (Related_Endpoint == ENDP0)
        {
          /* After clear the STALL, enable the default endpoint receiver */
          SetEPRxCount(Related_Endpoint, Device_Property.MaxPacketSize);
    618c:	32a00000 	adccc	r0, r0, #0
    6190:	00140000 	andseq	r0, r4, r0
    6194:	04935c91 	ldreq	r5, [r3], #3217	; 0xc91
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
        }
        else
        {
          ClearDTOG_RX(Related_Endpoint);
    6198:	937fa491 	cmnls	pc, #-1862270976	; 0x91000000
          _SetEPRxStatus(Related_Endpoint, EP_RX_VALID);
    619c:	7fa89104 	svcvc	0x00a89104
    61a0:	93530493 	cmpls	r3, #-1828716544	; 0x93000000
    61a4:	01f09304 	mvnseq	r9, r4, lsl #6
    61a8:	000032a0 	andeq	r3, r0, r0, lsr #5
    61ac:	00003306 	andeq	r3, r0, r6, lsl #6
        }
      }
    }
    pUser_Standard_Requests->User_ClearFeature();
    61b0:	5c910016 	ldcpl	0, cr0, [r1], {22}
    61b4:	a4910493 	ldrge	r0, [r1], #1171	; 0x493
    return USB_SUCCESS;
    61b8:	9104937f 	tstls	r4, pc, ror r3
  }

  return USB_UNSUPPORT;
}
    61bc:	04937fa8 	ldreq	r7, [r3], #4008	; 0xfa8
    61c0:	937fac91 	cmnls	pc, #37120	; 0x9100
    61c4:	01f09304 	mvnseq	r9, r4, lsl #6
    61c8:	00003306 	andeq	r3, r0, r6, lsl #6
    61cc:	00003310 	andeq	r3, r0, r0, lsl r3
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetEndPointFeature(void)
{
    61d0:	5c910019 	ldcpl	0, cr0, [r1], {25}
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    61d4:	a4910493 	ldrge	r0, [r1], #1171	; 0x493
    61d8:	9104937f 	tstls	r4, pc, ror r3
  u32    Related_Endpoint;
  u32    rEP;
  u32   Status;

  wIndex0 = pInformation->USBwIndex0;
  rEP = wIndex0 & ~0x80;
    61dc:	04937fa8 	ldreq	r7, [r3], #4008	; 0xfa8
    61e0:	937fac91 	cmnls	pc, #37120	; 0x9100

  if (ValBit(pInformation->USBwIndex0, 7))
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
    61e4:	04935804 	ldreq	r5, [r3], #2052	; 0x804
    61e8:	1001ec93 	mulne	r1, r3, ip

  wIndex0 = pInformation->USBwIndex0;
  rEP = wIndex0 & ~0x80;
  Related_Endpoint = ENDP0 + rEP;

  if (ValBit(pInformation->USBwIndex0, 7))
    61ec:	9a000033 	bls	62c0 <Post0_Process+0x2c>
  {
    /* get Status of endpoint & stall the request if the related_ENdpoint
    is Disabled*/
    Status = _GetEPTxStatus(Related_Endpoint);
    61f0:	1b000033 	blne	62c4 <Post0_Process+0x30>
    61f4:	935c9100 	cmpls	ip, #0, 2
  }
  else
  {
    Status = _GetEPRxStatus(Related_Endpoint);
    61f8:	7fa49104 	svcvc	0x00a49104
  }

  if (Related_Endpoint >= Device_Table.Total_Endpoint
    61fc:	a8910493 	ldmge	r1, {r0, r1, r4, r7, sl}
      || pInformation->USBwValue != 0 || Status == 0
    6200:	9104937f 	tstls	r4, pc, ror r3
      || pInformation->Current_Configuration == 0)
    6204:	04937fac 	ldreq	r7, [r3], #4012	; 0xfac
  else
  {
    if (wIndex0 & 0x80)
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6208:	937fb091 	cmnls	pc, #145	; 0x91
    620c:	01ec9304 	mvneq	r9, r4, lsl #6
  {
    return USB_UNSUPPORT;
  }
  else
  {
    if (wIndex0 & 0x80)
    6210:	0000339a 	muleq	r0, sl, r3
    {
      /* IN endpoint */
      _SetEPTxStatus(Related_Endpoint, EP_TX_STALL);
    6214:	00003416 	andeq	r3, r0, r6, lsl r4
    6218:	5c910020 	ldcpl	0, cr0, [r1], {32}
    621c:	a4910493 	ldrge	r0, [r1], #1171	; 0x493
    6220:	9104937f 	tstls	r4, pc, ror r3
    6224:	04937fa8 	ldreq	r7, [r3], #4008	; 0xfa8
    }

    else
    {
      /* OUT endpoint */
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    6228:	937fac91 	cmnls	pc, #37120	; 0x9100
    622c:	7fb09104 	svcvc	0x00b09104
    6230:	b4910493 	ldrlt	r0, [r1], #1171	; 0x493
    6234:	9304937f 	movwls	r9, #17279	; 0x437f
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
    6238:	341601e8 	ldrcc	r0, [r6], #-488	; 0x1e8
    623c:	341a0000 	ldrcc	r0, [sl], #-0
  return USB_SUCCESS;
    6240:	00230000 	eoreq	r0, r3, r0

  if (Related_Endpoint >= Device_Table.Total_Endpoint
      || pInformation->USBwValue != 0 || Status == 0
      || pInformation->Current_Configuration == 0)
  {
    return USB_UNSUPPORT;
    6244:	04935c91 	ldreq	r5, [r3], #3217	; 0xc91
      _SetEPRxStatus(Related_Endpoint, EP_RX_STALL);
    }
  }
  pUser_Standard_Requests->User_SetEndPointFeature();
  return USB_SUCCESS;
}
    6248:	937fa491 	cmnls	pc, #-1862270976	; 0x91000000
    624c:	7fa89104 	svcvc	0x00a89104
    6250:	ac910493 	cfldrsge	mvf0, [r1], {147}	; 0x93
* Output         : None.
* Return         : - Return USB_SUCCESS, if the request is performed.
*                  - Return USB_UNSUPPORT, if the request is invalid.
*******************************************************************************/
RESULT Standard_SetDeviceFeature(void)
{
    6254:	9104937f 	tstls	r4, pc, ror r3
  SetBit(pInformation->Current_Feature, 5);
    6258:	04937fb0 	ldreq	r7, [r3], #4016	; 0xfb0
    625c:	937fb491 	cmnls	pc, #-1862270976	; 0x91000000
    6260:	04935b04 	ldreq	r5, [r3], #2820	; 0xb04
  pUser_Standard_Requests->User_SetDeviceFeature();
    6264:	1a01e493 	bne	7f4b8 <_etext+0x77ea4>
    6268:	96000034 			; <UNDEFINED> instruction: 0x96000034
  return USB_SUCCESS;
}
    626c:	25000034 	strcs	r0, [r0, #-52]	; 0x34
    6270:	935c9100 	cmpls	ip, #0, 2
    6274:	7fa49104 	svcvc	0x00a49104
*******************************************************************************/
u8 *Standard_GetDescriptorData(u16 Length, ONE_DESCRIPTOR *pDesc)
{
  u32  wOffset;

  wOffset = pInformation->Ctrl_Info.Usb_wOffset;
    6278:	a8910493 	ldmge	r1, {r0, r1, r4, r7, sl}
    627c:	9104937f 	tstls	r4, pc, ror r3
  if (Length == 0)
  {
    pInformation->Ctrl_Info.Usb_wLength = pDesc->Descriptor_Size - wOffset;
    6280:	04937fac 	ldreq	r7, [r3], #4012	; 0xfac
    6284:	937fb091 	cmnls	pc, #145	; 0x91
    return 0;
  }

  return pDesc->Descriptor + wOffset;
    6288:	7fb49104 	svcvc	0x00b49104
}
    628c:	b8910493 	ldmlt	r1, {r0, r1, r4, r7, sl}
    6290:	9304937f 	movwls	r9, #17279	; 0x437f
* Output         : None.
* Return         : - 0 if the control State is in PAUSE
*                  - 1 if not.
*******************************************************************************/
u8 Post0_Process(void)
{
    6294:	349601e4 	ldrcc	r0, [r6], #484	; 0x1e4
  SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
    6298:	34b60000 	ldrtcc	r0, [r6], #0
    629c:	00280000 	eoreq	r0, r8, r0
    62a0:	04935c91 	ldreq	r5, [r3], #3217	; 0xc91

  if (pInformation->ControlState == STALLED)
    62a4:	937fa491 	cmnls	pc, #-1862270976	; 0x91000000
    62a8:	7fa89104 	svcvc	0x00a89104
  {
    vSetEPRxStatus(EP_RX_STALL);
    62ac:	ac910493 	cfldrsge	mvf0, [r1], {147}	; 0x93
    62b0:	9104937f 	tstls	r4, pc, ror r3
    vSetEPTxStatus(EP_TX_STALL);
    62b4:	04937fb0 	ldreq	r7, [r3], #4016	; 0xfb0
    62b8:	937fb491 	cmnls	pc, #-1862270976	; 0x91000000
  }

  return (pInformation->ControlState == PAUSE);
}
    62bc:	7fb89104 	svcvc	0x00b89104
    62c0:	935b0493 	cmpls	fp, #-1828716544	; 0x93000000
    62c4:	01e09304 	mvneq	r9, r4, lsl #6
    62c8:	000034b6 			; <UNDEFINED> instruction: 0x000034b6
    62cc:	00003992 	muleq	r0, r2, r9
    62d0:	5c91002a 	ldcpl	0, cr0, [r1], {42}	; 0x2a
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 Setup0_Process(void)
{
    62d4:	a4910493 	ldrge	r0, [r1], #1171	; 0x493
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    62d8:	9104937f 	tstls	r4, pc, ror r3

  if (pInformation->ControlState != PAUSE)
    62dc:	04937fa8 	ldreq	r7, [r3], #4008	; 0xfa8
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    62e0:	937fac91 	cmnls	pc, #37120	; 0x9100
    62e4:	7fb09104 	svcvc	0x00b09104

  if (pInformation->ControlState != PAUSE)
    62e8:	b4910493 	ldrlt	r0, [r1], #1171	; 0x493
    62ec:	9104937f 	tstls	r4, pc, ror r3
  {
    u8* b;
    u16* w;
  } pBuf;

  pBuf.b = PMAAddr + (u8 *)(_GetEPRxAddr(ENDP0) * 2); /* *2 for 32 bits addr */
    62f0:	04937fb8 	ldreq	r7, [r3], #4024	; 0xfb8
    62f4:	937fbc91 	cmnls	pc, #37120	; 0x9100
    62f8:	01e09304 	mvneq	r9, r4, lsl #6

  if (pInformation->ControlState != PAUSE)
  {
    pInformation->USBbmRequestType = *pBuf.b++; /* bmRequestType */
    62fc:	00003992 	muleq	r0, r2, r9
    pInformation->USBbRequest = *pBuf.b++; /* bRequest */
    6300:	000039fa 	strdeq	r3, [r0], -sl
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwValue = *pBuf.w++; /* wValue in Little Endian */
    6304:	5c910059 	ldcpl	0, cr0, [r1], {89}	; 0x59
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwIndex  = *pBuf.w++; /* wIndex in Little Endian */
    6308:	01f30493 			; <UNDEFINED> instruction: 0x01f30493
    pBuf.w++;  /* word not accessed because of 32 bits addressing */
    pInformation->USBwLength = *pBuf.w; /* wLength in Little Endian */
    630c:	94042351 	strls	r2, [r4], #-849	; 0x351
  }

  pInformation->ControlState = SETTING_UP;
    6310:	1aff0801 	bne	fffc831c <BootRAM+0xef38abd>
  if (pInformation->USBwLength == 0)
    6314:	01f32448 	mvnseq	r2, r8, asr #8
    6318:	94052351 	strls	r2, [r5], #-849	; 0x351
{
  RESULT Result = USB_UNSUPPORT;
  u32 RequestNo = pInformation->USBbRequest;
  u32 ControlState;

  if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    631c:	1aff0801 	bne	fffc8328 <BootRAM+0xef38ac9>
    6320:	f3212440 	vshl.u32	q1, q0, <illegal reg q0.5>
  {
    /* Device Request*/
    /* SET_CONFIGURATION*/
    if (RequestNo == SET_CONFIGURATION)
    6324:	06235101 	strteq	r5, [r3], -r1, lsl #2
    {
      Result = Standard_SetConfiguration();
    6328:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    632c:	2124381a 	teqcs	r4, sl, lsl r8
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
    6330:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6334:	08019407 	stmdaeq	r1, {r0, r1, r2, sl, ip, pc}
          || (pInformation->USBwIndex != 0)
          || (pInformation->Current_Configuration != 0))
        /* Device Address should be 127 or less*/
      {
        ControlState = STALLED;
    6338:	9f211aff 	svcls	0x00211aff
    }

    /*SET ADDRESS*/
    else if (RequestNo == SET_ADDRESS)
    {
      if ((pInformation->USBwValue0 > 127) || (pInformation->USBwValue1 != 0)
    633c:	a8910493 	ldmge	r1, {r0, r1, r4, r7, sl}
    6340:	9104937f 	tstls	r4, pc, ror r3
          || (pInformation->USBwIndex != 0)
    6344:	04937fac 	ldreq	r7, [r3], #4012	; 0xfac
          || (pInformation->Current_Configuration != 0))
    6348:	937fb091 	cmnls	pc, #145	; 0x91
    634c:	7fb49104 	svcvc	0x00b49104
      {
        Result = USB_SUCCESS;
      }
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    6350:	b8910493 	ldmlt	r1, {r0, r1, r4, r7, sl}
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
    6354:	9104937f 	tstls	r4, pc, ror r3
    6358:	04937fbc 	ldreq	r7, [r3], #4028	; 0xfbc
  }


  if (Result != USB_SUCCESS)
  {
    Result = (*pProperty->Class_NoData_Setup)(RequestNo);
    635c:	fa01e093 	blx	7e5b0 <_etext+0x76f9c>
    6360:	76000039 			; <UNDEFINED> instruction: 0x76000039
    if (Result == USB_NOT_READY)
    6364:	8800003a 	stmdahi	r0, {r1, r3, r4, r5}
    6368:	935c9100 	cmpls	ip, #0, 2
    }
    /*SET FEATURE for Device*/
    else if (RequestNo == SET_FEATURE)
    {
      if ((pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP)
          && (pInformation->USBwIndex == 0)
    636c:	5101f304 	tstpl	r1, r4, lsl #6
          && (ValBit(pInformation->Current_Feature, 5)))
    6370:	01940423 	orrseq	r0, r4, r3, lsr #8
    6374:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
      {
        Result = Standard_SetDeviceFeature();
    6378:	5101f324 	tstpl	r1, r4, lsr #6
      {
        Result = USB_UNSUPPORT;
      }
    }
    /*Clear FEATURE for Device */
    else if (RequestNo == CLEAR_FEATURE)
    637c:	01940523 	orrseq	r0, r4, r3, lsr #10
    {
      if (pInformation->USBwValue0 == DEVICE_REMOTE_WAKEUP
    6380:	401aff08 	andsmi	pc, sl, r8, lsl #30
    6384:	01f32124 	mvnseq	r2, r4, lsr #2
          && pInformation->USBwIndex == 0
    6388:	94062351 	strls	r2, [r6], #-849	; 0x351
          && ValBit(pInformation->Current_Feature, 5))
    638c:	1aff0801 	bne	fffc8398 <BootRAM+0xef38b39>
    6390:	f3212438 	vqshl.u32	d2, d24, d1
      {
        Result = Standard_ClearFeature();
    6394:	07235101 	streq	r5, [r3, -r1, lsl #2]!
    }

  }

  /* Interface Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    6398:	ff080194 			; <UNDEFINED> instruction: 0xff080194
  {
    /*SET INTERFACE*/
    if (RequestNo == SET_INTERFACE)
    639c:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
    {
      Result = Standard_SetInterface();
    63a0:	5101f304 	tstpl	r1, r4, lsl #6
    63a4:	01940823 	orrseq	r0, r4, r3, lsr #16
    }
  }

  /* EndPoint Request*/
  else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    63a8:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
  {
    /*CLEAR FEATURE for EndPoint*/
    if (RequestNo == CLEAR_FEATURE)
    63ac:	5101f324 	tstpl	r1, r4, lsr #6
    {
      Result = Standard_ClearFeature();
    }
    /* SET FEATURE for EndPoint*/
    else if (RequestNo == SET_FEATURE)
    63b0:	01940923 	orrseq	r0, r4, r3, lsr #18
    {
      Result = Standard_SetEndPointFeature();
    63b4:	401aff08 	andsmi	pc, sl, r8, lsl #30
  {
    Result = USB_UNSUPPORT;
  }


  if (Result != USB_SUCCESS)
    63b8:	01f32124 	mvnseq	r2, r4, lsr #2
      ControlState = PAUSE;
      goto exit_NoData_Setup0;
    }
  }

  if (Result != USB_SUCCESS)
    63bc:	940a2351 	strls	r2, [sl], #-849	; 0x351
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */

  USB_StatusIn();
    63c0:	1aff0801 	bne	fffc83cc <BootRAM+0xef38b6d>
    63c4:	f3212438 	vqshl.u32	d2, d24, d1
    63c8:	0b235101 	bleq	8da7d4 <_etext+0x8d31c0>
    63cc:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    63d0:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
  {
    ControlState = STALLED;
    goto exit_NoData_Setup0;
  }

  ControlState = WAIT_STATUS_IN;/* After no data stage SETUP */
    63d4:	7fac9104 	svcvc	0x00ac9104

  USB_StatusIn();

exit_NoData_Setup0:
  pInformation->ControlState = ControlState;
    63d8:	b0910493 	umullslt	r0, r1, r3, r4
    63dc:	9104937f 	tstls	r4, pc, ror r3


  CopyRoutine = NULL;
  wOffset = 0;

  if (Request_No == GET_DESCRIPTOR)
    63e0:	04937fb4 	ldreq	r7, [r3], #4020	; 0xfb4
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    63e4:	937fb891 	cmnls	pc, #9502720	; 0x910000
    {
      u8 wValue1 = pInformation->USBwValue1;
    63e8:	7fbc9104 	svcvc	0x00bc9104
      if (wValue1 == DEVICE_DESCRIPTOR)
    63ec:	e0930493 	umulls	r0, r3, r3, r4
      {
        CopyRoutine = pProperty->GetDeviceDescriptor;
    63f0:	003a7601 	eorseq	r7, sl, r1, lsl #12
    63f4:	003ac200 	eorseq	ip, sl, r0, lsl #4
      }
      else if (wValue1 == CONFIG_DESCRIPTOR)
    63f8:	9100b700 	tstls	r0, r0, lsl #14
      {
        CopyRoutine = pProperty->GetConfigDescriptor;
    63fc:	f304935c 	vcge.u8	<illegal reg q4.5>, q2, q6
      }
      else if (wValue1 == STRING_DESCRIPTOR)
    6400:	04235101 	strteq	r5, [r3], #-257	; 0x101
      {
        CopyRoutine = pProperty->GetStringDescriptor;
    6404:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6408:	f324481a 	vceq.i32	d4, d4, d10
      } else if (wValue1 == 0x21) /* added to support functional descriptors */
    640c:	05235101 	streq	r5, [r3, #-257]!	; 0x101
      {
	CopyRoutine = pProperty->GetFunctionalDescriptor;
    6410:	ff080194 			; <UNDEFINED> instruction: 0xff080194
      } /* End of GET_DESCRIPTOR */
    }
  }

  /*GET STATUS*/
  else if ((Request_No == GET_STATUS) && (pInformation->USBwValue == 0)
    6414:	2124401a 	teqcs	r4, sl, lsl r0
    6418:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    641c:	08019406 	stmdaeq	r1, {r1, r2, sl, ip, pc}
           && (pInformation->USBwLength == 0x0002)
           && (pInformation->USBwIndex1 == 0))
    6420:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
    6424:	5101f321 	tstpl	r1, r1, lsr #6
    6428:	01940723 	orrseq	r0, r4, r3, lsr #14
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    642c:	211aff08 	tstcs	sl, r8, lsl #30
    6430:	f304939f 	vcge.u8	d9, d20, d15
        && (pInformation->USBwIndex == 0))
    6434:	08235101 	stmdaeq	r3!, {r0, r8, ip, lr}
    6438:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    {
      CopyRoutine = Standard_GetStatus;
    }

    /* GET STATUS for Interface*/
    else if (Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    643c:	f324481a 	vceq.i32	d4, d4, d10
    {
      if (((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS)
    6440:	09235101 	stmdbeq	r3!, {r0, r8, ip, lr}
    6444:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6448:	2124401a 	teqcs	r4, sl, lsl r0
    644c:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
          && (pInformation->Current_Configuration != 0))
    6450:	0801940a 	stmdaeq	r1, {r1, r3, sl, ip, pc}
    6454:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
    6458:	5101f321 	tstpl	r1, r1, lsr #6
        CopyRoutine = Standard_GetStatus;
      }
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    645c:	01940b23 	orrseq	r0, r4, r3, lsr #22
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    6460:	211aff08 	tstcs	sl, r8, lsl #30
    }

    /* GET STATUS for EndPoint*/
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
    6464:	f304939f 	vcge.u8	d9, d20, d15

      if (ValBit(pInformation->USBwIndex0, 7))
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
    6468:	0c235101 	stfeqs	f5, [r3], #-4
    646c:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6470:	f324481a 	vceq.i32	d4, d4, d10
    else if (Type_Recipient == (STANDARD_REQUEST | ENDPOINT_RECIPIENT))
    {
      Related_Endpoint = (pInformation->USBwIndex0 & 0x0f);
      Reserved = pInformation->USBwIndex0 & 0x70;

      if (ValBit(pInformation->USBwIndex0, 7))
    6474:	0d235101 	stfeqs	f5, [r3, #-4]!
      {
        /*Get Status of endpoint & stall the request if the related_ENdpoint
        is Disabled*/
        Status = _GetEPTxStatus(Related_Endpoint);
    6478:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    647c:	2124401a 	teqcs	r4, sl, lsl r0
      }
      else
      {
        Status = _GetEPRxStatus(Related_Endpoint);
    6480:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
      }

      if ((Related_Endpoint < Device_Table.Total_Endpoint) && (Reserved == 0)
    6484:	0801940e 	stmdaeq	r1, {r1, r2, r3, sl, ip, pc}
    6488:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
          && (Status != 0))
    648c:	5101f321 	tstpl	r1, r1, lsr #6
    6490:	01940f23 	orrseq	r0, r4, r3, lsr #30
    }

  }

  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
    6494:	211aff08 	tstcs	sl, r8, lsl #30
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    6498:	9104939f 			; <UNDEFINED> instruction: 0x9104939f
    649c:	04937fb0 	ldreq	r7, [r3], #4016	; 0xfb0
    {
      CopyRoutine = Standard_GetConfiguration;
    }
  }
  /*GET INTERFACE*/
  else if (Request_No == GET_INTERFACE)
    64a0:	937fb491 	cmnls	pc, #-1862270976	; 0x91000000
  {
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
    64a4:	7fb89104 	svcvc	0x00b89104
    64a8:	bc910493 	cfldrslt	mvf0, [r1], {147}	; 0x93
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
    64ac:	9304937f 	movwls	r9, #17279	; 0x437f
    64b0:	3ac201e0 	bcc	ff086c38 <BootRAM+0xdff73d9>
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
    64b4:	3b560000 	blcc	15864bc <_etext+0x157eea8>
    64b8:	00e60000 	rsceq	r0, r6, r0
    64bc:	04935c91 	ldreq	r5, [r3], #3217	; 0xc91
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
    64c0:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    64c4:	08019404 	stmdaeq	r1, {r2, sl, ip, pc}
    64c8:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
    64cc:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
      CopyRoutine = Standard_GetInterface;
    }

  }

  if (CopyRoutine)
    64d0:	08019405 	stmdaeq	r1, {r0, r2, sl, ip, pc}
  {
    pInformation->Ctrl_Info.Usb_wOffset = wOffset;
    64d4:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    pInformation->Ctrl_Info.CopyData = CopyRoutine;
    64d8:	5101f321 	tstpl	r1, r1, lsr #6
    /* sb in the original the cast to word was directly */
    /* now the cast is made step by step */
    (*CopyRoutine)(0);
    64dc:	01940623 	orrseq	r0, r4, r3, lsr #12
    Result = USB_SUCCESS;
    64e0:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
  }
  else
  {
    Result = (*pProperty->Class_Data_Setup)(pInformation->USBbRequest);
    64e4:	01f32124 	mvnseq	r2, r4, lsr #2
    64e8:	94072351 	strls	r2, [r7], #-849	; 0x351
    64ec:	1aff0801 	bne	fffc84f8 <BootRAM+0xef38c99>
    if (Result == USB_NOT_READY)
    64f0:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
    {
      pInformation->ControlState = PAUSE;
    64f4:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
      return;
    }
  }

  if (pInformation->Ctrl_Info.Usb_wLength == 0xFFFF)
    64f8:	08019408 	stmdaeq	r1, {r3, sl, ip, pc}
    64fc:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
    6500:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
  {
    /* Data is not ready, wait it */
    pInformation->ControlState = PAUSE;
    6504:	08019409 	stmdaeq	r1, {r0, r3, sl, ip, pc}
    return;
  }
  if ((Result == USB_UNSUPPORT) || (pInformation->Ctrl_Info.Usb_wLength == 0))
    6508:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    650c:	5101f321 	tstpl	r1, r1, lsr #6
  {
    /* Unsupported request */
    pInformation->ControlState = STALLED;
    6510:	01940a23 	orrseq	r0, r4, r3, lsr #20
    return;
  }


  if (ValBit(pInformation->USBbmRequestType, 7))
    6514:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    6518:	01f32124 	mvnseq	r2, r4, lsr #2
  {
    /* Device ==> Host */
    vu32 wLength = pInformation->USBwLength;
    651c:	940b2351 	strls	r2, [fp], #-849	; 0x351

    /* Restrict the data length to be the one host asks */
    if (pInformation->Ctrl_Info.Usb_wLength > wLength)
    6520:	1aff0801 	bne	fffc852c <BootRAM+0xef38ccd>
    6524:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
    {
      pInformation->Ctrl_Info.Usb_wLength = wLength;
    6528:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    652c:	0801940c 	stmdaeq	r1, {r2, r3, sl, ip, pc}
    6530:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
    6534:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6538:	0801940d 	stmdaeq	r1, {r0, r2, r3, sl, ip, pc}
    653c:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    6540:	5101f321 	tstpl	r1, r1, lsr #6
    6544:	01940e23 	orrseq	r0, r4, r3, lsr #28
    6548:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    }

    else if (pInformation->Ctrl_Info.Usb_wLength < pInformation->USBwLength)
    654c:	01f32124 	mvnseq	r2, r4, lsr #2
    {
      if (pInformation->Ctrl_Info.Usb_wLength < pProperty->MaxPacketSize)
    6550:	940f2351 	strls	r2, [pc], #-849	; 6558 <Setup0_Process+0x284>
    6554:	1aff0801 	bne	fffc8560 <BootRAM+0xef38d01>
    6558:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
      {
        Data_Mul_MaxPacketSize = FALSE;
    655c:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
      }
      else if ((pInformation->Ctrl_Info.Usb_wLength % pProperty->MaxPacketSize) == 0)
    6560:	08019410 	stmdaeq	r1, {r4, sl, ip, pc}
    6564:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
      {
        Data_Mul_MaxPacketSize = TRUE;
    6568:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    656c:	08019411 	stmdaeq	r1, {r0, r4, sl, ip, pc}
      }
    }

    pInformation->Ctrl_Info.PacketSize = pProperty->MaxPacketSize;
    6570:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    6574:	5101f321 	tstpl	r1, r1, lsr #6
    DataStageIn();
    6578:	01941223 	orrseq	r1, r4, r3, lsr #4
  }
  else
  {
    pInformation->ControlState = OUT_DATA;
    657c:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    vSetEPRxStatus(EP_RX_VALID); /* enable for next data reception */
    6580:	01f32124 	mvnseq	r2, r4, lsr #2
    6584:	94132351 	ldrls	r2, [r3], #-849	; 0x351
  else
  {
    /* Setup with data stage */
    Data_Setup0();
  }
  return Post0_Process();
    6588:	1aff0801 	bne	fffc8594 <BootRAM+0xef38d35>
}
    658c:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
  {
    /* GET STATUS for Device*/
    if ((Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
        && (pInformation->USBwIndex == 0))
    {
      CopyRoutine = Standard_GetStatus;
    6590:	937fb491 	cmnls	pc, #-1862270976	; 0x91000000
  /*GET CONFIGURATION*/
  else if (Request_No == GET_CONFIGURATION)
  {
    if (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT))
    {
      CopyRoutine = Standard_GetConfiguration;
    6594:	7fb89104 	svcvc	0x00b89104
    if ((Type_Recipient == (STANDARD_REQUEST | INTERFACE_RECIPIENT))
        && (pInformation->Current_Configuration != 0) && (pInformation->USBwValue == 0)
        && (pInformation->USBwIndex1 == 0) && (pInformation->USBwLength == 0x0001)
        && ((*pProperty->Class_Get_Interface_Setting)(pInformation->USBwIndex0, 0) == USB_SUCCESS))
    {
      CopyRoutine = Standard_GetInterface;
    6598:	bc910493 	cfldrslt	mvf0, [r1], {147}	; 0x93
    659c:	9304937f 	movwls	r9, #17279	; 0x437f
    65a0:	3b5601e0 	blcc	1586d28 <_etext+0x157f714>
    65a4:	3c0e0000 	stccc	0, cr0, [lr], {-0}
    65a8:	01150000 	tsteq	r5, r0
    65ac:	04935c91 	ldreq	r5, [r3], #3217	; 0xc91
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 Out0_Process(void)
{
    65b0:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
  u32 ControlState = pInformation->ControlState;
    65b4:	08019404 	stmdaeq	r1, {r2, sl, ip, pc}

  if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
    65b8:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
    65bc:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
  ENDPOINT_INFO *pEPinfo = &pInformation->Ctrl_Info;
  u32 save_rLength;

  save_rLength = pEPinfo->Usb_rLength;

  if (pEPinfo->CopyData && save_rLength)
    65c0:	08019405 	stmdaeq	r1, {r0, r2, sl, ip, pc}
    65c4:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
  {
    u8 *Buffer;
    u32 Length;

    Length = pEPinfo->PacketSize;
    65c8:	5101f321 	tstpl	r1, r1, lsr #6
    if (Length > save_rLength)
    {
      Length = save_rLength;
    }

    Buffer = (*pEPinfo->CopyData)(Length);
    65cc:	01940623 	orrseq	r0, r4, r3, lsr #12
    65d0:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    pEPinfo->Usb_rLength -= Length;
    65d4:	01f32124 	mvnseq	r2, r4, lsr #2
    65d8:	94072351 	strls	r2, [r7], #-849	; 0x351
    pEPinfo->Usb_rOffset += Length;
    65dc:	1aff0801 	bne	fffc85e8 <BootRAM+0xef38d89>
    65e0:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21

    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
    65e4:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    65e8:	08019408 	stmdaeq	r1, {r3, sl, ip, pc}
    65ec:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
    65f0:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
  }

  if (pEPinfo->Usb_rLength != 0)
    65f4:	08019409 	stmdaeq	r1, {r0, r3, sl, ip, pc}
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    SetEPTxCount(ENDP0, 0);
    65f8:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    PMAToUserBufferCopy(Buffer, GetEPRxAddr(ENDP0), Length);
  }

  if (pEPinfo->Usb_rLength != 0)
  {
    vSetEPRxStatus(EP_RX_VALID);/* re-enable for next data reception */
    65fc:	5101f321 	tstpl	r1, r1, lsr #6
    6600:	01940a23 	orrseq	r0, r4, r3, lsr #20
    SetEPTxCount(ENDP0, 0);
    6604:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    vSetEPTxStatus(EP_TX_VALID);/* Expect the host to abort the data OUT stage */
    6608:	01f32124 	mvnseq	r2, r4, lsr #2
  }
  /* Set the next State*/
  if (pEPinfo->Usb_rLength >= pEPinfo->PacketSize)
    660c:	940b2351 	strls	r2, [fp], #-849	; 0x351
    6610:	1aff0801 	bne	fffc861c <BootRAM+0xef38dbd>
  {
    pInformation->ControlState = OUT_DATA;
    6614:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
    6618:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
  }
  else
  {
    if (pEPinfo->Usb_rLength > 0)
    {
      pInformation->ControlState = LAST_OUT_DATA;
    661c:	0801940c 	stmdaeq	r1, {r2, r3, sl, ip, pc}
    6620:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
    }
    else if (pEPinfo->Usb_rLength == 0)
    {
      pInformation->ControlState = WAIT_STATUS_IN;
    6624:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6628:	0801940d 	stmdaeq	r1, {r0, r2, r3, sl, ip, pc}
      USB_StatusIn();
    662c:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    6630:	5101f321 	tstpl	r1, r1, lsr #6
    6634:	01940e23 	orrseq	r0, r4, r3, lsr #28
    6638:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    663c:	01f32124 	mvnseq	r2, r4, lsr #2
  u32 ControlState = pInformation->ControlState;

  if ((ControlState == OUT_DATA) || (ControlState == LAST_OUT_DATA))
  {
    DataStageOut();
    ControlState = pInformation->ControlState; /* may be changed outside the function */
    6640:	940f2351 	strls	r2, [pc], #-849	; 6648 <Out0_Process+0x98>
  }

  else if (ControlState == WAIT_STATUS_OUT)
    6644:	1aff0801 	bne	fffc8650 <BootRAM+0xef38df1>
  {
    (*pProperty->Process_Status_OUT)();
    6648:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
    664c:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
  }

  else if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
  {
    /* host aborts the transfer before finish */
    ControlState = STALLED;
    6650:	08019410 	stmdaeq	r1, {r4, sl, ip, pc}
  else
  {
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;
    6654:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff

  return Post0_Process();
}
    6658:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
    665c:	08019411 	stmdaeq	r1, {r0, r4, sl, ip, pc}
    6660:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    6664:	5101f321 	tstpl	r1, r1, lsr #6
    6668:	01941223 	orrseq	r1, r4, r3, lsr #4
    666c:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    6670:	01f32124 	mvnseq	r2, r4, lsr #2
    6674:	94132351 	ldrls	r2, [r3], #-849	; 0x351
* Input          : - Val: device adress.
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetDeviceAddress(u8 Val)
{
    6678:	1aff0801 	bne	fffc8684 <BootRAM+0xef38e25>
  u32 i;
  u32 nEP = Device_Table.Total_Endpoint;
    667c:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
    6680:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6684:	08019414 	stmdaeq	r1, {r2, r4, sl, ip, pc}
    6688:	24481aff 	strbcs	r1, [r8], #-2815	; 0xaff
    668c:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
  {
    _SetEPAddress((u8)i, (u8)i);
    6690:	08019415 	stmdaeq	r1, {r0, r2, r4, sl, ip, pc}
    6694:	24401aff 	strbcs	r1, [r0], #-2815	; 0xaff
    6698:	5101f321 	tstpl	r1, r1, lsr #6
{
  u32 i;
  u32 nEP = Device_Table.Total_Endpoint;

  /* set address in every used endpoint */
  for (i = 0; i < nEP; i++)
    669c:	01941623 	orrseq	r1, r4, r3, lsr #12
  {
    _SetEPAddress((u8)i, (u8)i);
  } /* for */
  _SetDADDR(Val | DADDR_EF); /* set device address and enable function */
    66a0:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    66a4:	01f32124 	mvnseq	r2, r4, lsr #2
    66a8:	94172351 	ldrls	r2, [r7], #-849	; 0x351
    66ac:	1aff0801 	bne	fffc86b8 <BootRAM+0xef38e59>
* Input          : None.
* Output         : None.
* Return         : Post0_Process.
*******************************************************************************/
u8 In0_Process(void)
{
    66b0:	04939f21 	ldreq	r9, [r3], #3873	; 0xf21
  u32 ControlState = pInformation->ControlState;
    66b4:	937fb891 	cmnls	pc, #9502720	; 0x910000

  if ((ControlState == IN_DATA) || (ControlState == LAST_IN_DATA))
    66b8:	7fbc9104 	svcvc	0x00bc9104
    66bc:	e0930493 	umulls	r0, r3, r3, r4
  {
    DataStageIn();
    66c0:	003c0e01 	eorseq	r0, ip, r1, lsl #28
    /* ControlState may be changed outside the function */
    ControlState = pInformation->ControlState;
    66c4:	003c9200 	eorseq	r9, ip, r0, lsl #4
    66c8:	91014400 	tstls	r1, r0, lsl #8
  }

  else if (ControlState == WAIT_STATUS_IN)
    66cc:	f304935c 	vcge.u8	<illegal reg q4.5>, q2, q6
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
    66d0:	04235101 	strteq	r5, [r3], #-257	; 0x101
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    66d4:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    ControlState = pInformation->ControlState;
  }

  else if (ControlState == WAIT_STATUS_IN)
  {
    if ((pInformation->USBbRequest == SET_ADDRESS) &&
    66d8:	f324481a 	vceq.i32	d4, d4, d10
        (Type_Recipient == (STANDARD_REQUEST | DEVICE_RECIPIENT)))
    {
      SetDeviceAddress(pInformation->USBwValue0);
    66dc:	05235101 	streq	r5, [r3, #-257]!	; 0x101
      pUser_Standard_Requests->User_SetDeviceAddress();
    66e0:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    66e4:	2124401a 	teqcs	r4, sl, lsl r0
    }
    (*pProperty->Process_Status_IN)();
    66e8:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    66ec:	08019406 	stmdaeq	r1, {r1, r2, sl, ip, pc}
    ControlState = STALLED;
  }

  else
  {
    ControlState = STALLED;
    66f0:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
  }

  pInformation->ControlState = ControlState;
    66f4:	5101f321 	tstpl	r1, r1, lsr #6

  return Post0_Process();
}
    66f8:	01940723 	orrseq	r0, r4, r3, lsr #14
    ControlState = STALLED;
  }

  pInformation->ControlState = ControlState;

  return Post0_Process();
    66fc:	211aff08 	tstcs	sl, r8, lsl #30
    6700:	f304939f 	vcge.u8	d9, d20, d15
    6704:	08235101 	stmdaeq	r3!, {r0, r8, ip, lr}
    6708:	ff080194 			; <UNDEFINED> instruction: 0xff080194
*                  - wNBytes: no. of bytes to be copied.
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
    670c:	f324481a 	vceq.i32	d4, d4, d10
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
    6710:	09235101 	stmdbeq	r3!, {r0, r8, ip, lr}
    6714:	ff080194 			; <UNDEFINED> instruction: 0xff080194
* Output         : None.
* Return         : None	.
*******************************************************************************/
void UserToPMABufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;   /* n = (wNBytes + 1) / 2 */
    6718:	2124401a 	teqcs	r4, sl, lsl r0
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
    671c:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6720:	0801940a 	stmdaeq	r1, {r1, r3, sl, ip, pc}
    6724:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
  {
    temp1 = (u16) * pbUsrBuf;
    pbUsrBuf++;
    temp2 = temp1 | (u16) * pbUsrBuf << 8;
    6728:	5101f321 	tstpl	r1, r1, lsr #6
  u32 i, temp1, temp2;
  u16 *pdwVal;
  pdwVal = (u16 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
  {
    temp1 = (u16) * pbUsrBuf;
    672c:	01940b23 	orrseq	r0, r4, r3, lsr #22
    pbUsrBuf++;
    temp2 = temp1 | (u16) * pbUsrBuf << 8;
    6730:	211aff08 	tstcs	sl, r8, lsl #30
    *pdwVal++ = temp2;
    6734:	f304939f 	vcge.u8	d9, d20, d15
    6738:	0c235101 	stfeqs	f5, [r3], #-4
*                  - wNBytes     = no. of bytes to be copied.
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
    673c:	ff080194 			; <UNDEFINED> instruction: 0xff080194
  u32 n = (wNBytes + 1) >> 1;/* /2*/
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
    6740:	f324481a 	vceq.i32	d4, d4, d10
    6744:	0d235101 	stfeqs	f5, [r3, #-4]!
* Output         : None.
* Return         : None.
*******************************************************************************/
void PMAToUserBufferCopy(u8 *pbUsrBuf, u16 wPMABufAddr, u16 wNBytes)
{
  u32 n = (wNBytes + 1) >> 1;/* /2*/
    6748:	ff080194 			; <UNDEFINED> instruction: 0xff080194
  u32 i;
  u32 *pdwVal;
  pdwVal = (u32 *)(wPMABufAddr * 2 + PMAAddr);
  for (i = n; i != 0; i--)
    674c:	2124401a 	teqcs	r4, sl, lsl r0
    6750:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
  {
    *(u16*)pbUsrBuf++ = *pdwVal++;
    6754:	0801940e 	stmdaeq	r1, {r1, r2, r3, sl, ip, pc}
    6758:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
    675c:	5101f321 	tstpl	r1, r1, lsr #6
    6760:	01940f23 	orrseq	r0, r4, r3, lsr #30
    6764:	211aff08 	tstcs	sl, r8, lsl #30
    6768:	f304939f 	vcge.u8	d9, d20, d15
    676c:	10235101 	eorne	r5, r3, r1, lsl #2
    6770:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6774:	f324481a 	vceq.i32	d4, d4, d10
    6778:	11235101 	teqne	r3, r1, lsl #2
    677c:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6780:	2124401a 	teqcs	r4, sl, lsl r0
    6784:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    6788:	08019412 	stmdaeq	r1, {r1, r4, sl, ip, pc}
    678c:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
    6790:	5101f321 	tstpl	r1, r1, lsr #6
    6794:	01941323 	orrseq	r1, r4, r3, lsr #6
    6798:	211aff08 	tstcs	sl, r8, lsl #30
    679c:	f304939f 	vcge.u8	d9, d20, d15
    67a0:	14235101 	strtne	r5, [r3], #-257	; 0x101
    67a4:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    67a8:	f324481a 	vceq.i32	d4, d4, d10
    67ac:	15235101 	strne	r5, [r3, #-257]!	; 0x101
    67b0:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    67b4:	2124401a 	teqcs	r4, sl, lsl r0
    67b8:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    67bc:	08019416 	stmdaeq	r1, {r1, r2, r4, sl, ip, pc}
    67c0:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
    67c4:	5101f321 	tstpl	r1, r1, lsr #6
    67c8:	01941723 	orrseq	r1, r4, r3, lsr #14
    67cc:	211aff08 	tstcs	sl, r8, lsl #30
    67d0:	f304939f 	vcge.u8	d9, d20, d15
    67d4:	18235101 	stmdane	r3!, {r0, r8, ip, lr}
    67d8:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    67dc:	f324481a 	vceq.i32	d4, d4, d10
    67e0:	19235101 	stmdbne	r3!, {r0, r8, ip, lr}
    67e4:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    67e8:	2124401a 	teqcs	r4, sl, lsl r0
    67ec:	235101f3 	cmpcs	r1, #-1073741764	; 0xc000003c
    67f0:	0801941a 	stmdaeq	r1, {r1, r3, r4, sl, ip, pc}
    67f4:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
    67f8:	5101f321 	tstpl	r1, r1, lsr #6
    67fc:	01941b23 	orrseq	r1, r4, r3, lsr #22
    6800:	211aff08 	tstcs	sl, r8, lsl #30
    6804:	9104939f 			; <UNDEFINED> instruction: 0x9104939f
    6808:	04937fbc 	ldreq	r7, [r3], #4028	; 0xfbc
    680c:	9201e093 	andls	lr, r1, #147	; 0x93
    6810:	0a00003c 	beq	6908 <_svfiprintf_r+0x80>
    6814:	73000050 	movwvc	r0, #80	; 0x50
    6818:	935c9101 	cmpls	ip, #1073741824	; 0x40000000
    681c:	5101f304 	tstpl	r1, r4, lsl #6
    6820:	01940423 	orrseq	r0, r4, r3, lsr #8
    6824:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    6828:	5101f324 	tstpl	r1, r4, lsr #6
    682c:	01940523 	orrseq	r0, r4, r3, lsr #10
    6830:	401aff08 	andsmi	pc, sl, r8, lsl #30
    6834:	01f32124 	mvnseq	r2, r4, lsr #2
    6838:	94062351 	strls	r2, [r6], #-849	; 0x351
    683c:	1aff0801 	bne	fffc8848 <BootRAM+0xef38fe9>
    6840:	f3212438 	vqshl.u32	d2, d24, d1
    6844:	07235101 	streq	r5, [r3, -r1, lsl #2]!
    6848:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    684c:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
    6850:	5101f304 	tstpl	r1, r4, lsl #6
    6854:	01940823 	orrseq	r0, r4, r3, lsr #16
    6858:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    685c:	5101f324 	tstpl	r1, r4, lsr #6
    6860:	01940923 	orrseq	r0, r4, r3, lsr #18
    6864:	401aff08 	andsmi	pc, sl, r8, lsl #30
    6868:	01f32124 	mvnseq	r2, r4, lsr #2
    686c:	940a2351 	strls	r2, [sl], #-849	; 0x351
    6870:	1aff0801 	bne	fffc887c <BootRAM+0xef3901d>
    6874:	f3212438 	vqshl.u32	d2, d24, d1
    6878:	0b235101 	bleq	8dac84 <_etext+0x8d3670>
    687c:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6880:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
    6884:	5101f304 	tstpl	r1, r4, lsl #6
    6888:	01940c23 	orrseq	r0, r4, r3, lsr #24
    688c:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    6890:	5101f324 	tstpl	r1, r4, lsr #6
    6894:	01940d23 	orrseq	r0, r4, r3, lsr #26
    6898:	401aff08 	andsmi	pc, sl, r8, lsl #30
    689c:	01f32124 	mvnseq	r2, r4, lsr #2
    68a0:	940e2351 	strls	r2, [lr], #-849	; 0x351
    68a4:	1aff0801 	bne	fffc88b0 <BootRAM+0xef39051>
    68a8:	f3212438 	vqshl.u32	d2, d24, d1
    68ac:	0f235101 	svceq	0x00235101
    68b0:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    68b4:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
    68b8:	5101f304 	tstpl	r1, r4, lsl #6
    68bc:	01941023 	orrseq	r1, r4, r3, lsr #32
    68c0:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    68c4:	5101f324 	tstpl	r1, r4, lsr #6
    68c8:	01941123 	orrseq	r1, r4, r3, lsr #2
    68cc:	401aff08 	andsmi	pc, sl, r8, lsl #30
    68d0:	01f32124 	mvnseq	r2, r4, lsr #2
    68d4:	94122351 	ldrls	r2, [r2], #-849	; 0x351
    68d8:	1aff0801 	bne	fffc88e4 <BootRAM+0xef39085>
    68dc:	f3212438 	vqshl.u32	d2, d24, d1
    68e0:	13235101 	teqne	r3, #1073741824	; 0x40000000
    68e4:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    68e8:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
    68ec:	5101f304 	tstpl	r1, r4, lsl #6
    68f0:	01941423 	orrseq	r1, r4, r3, lsr #8
    68f4:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    68f8:	5101f324 	tstpl	r1, r4, lsr #6
    68fc:	01941523 	orrseq	r1, r4, r3, lsr #10
    6900:	401aff08 	andsmi	pc, sl, r8, lsl #30
    6904:	01f32124 	mvnseq	r2, r4, lsr #2
    6908:	94162351 	ldrls	r2, [r6], #-849	; 0x351
    690c:	1aff0801 	bne	fffc8918 <BootRAM+0xef390b9>
    6910:	f3212438 	vqshl.u32	d2, d24, d1
    6914:	17235101 	strne	r5, [r3, -r1, lsl #2]!
    6918:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    691c:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
    6920:	5101f304 	tstpl	r1, r4, lsl #6
    6924:	01941823 	orrseq	r1, r4, r3, lsr #16
    6928:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    692c:	5101f324 	tstpl	r1, r4, lsr #6
    6930:	01941923 	orrseq	r1, r4, r3, lsr #18
    6934:	401aff08 	andsmi	pc, sl, r8, lsl #30
    6938:	01f32124 	mvnseq	r2, r4, lsr #2
    693c:	941a2351 	ldrls	r2, [sl], #-849	; 0x351
    6940:	1aff0801 	bne	fffc894c <BootRAM+0xef390ed>
    6944:	f3212438 	vqshl.u32	d2, d24, d1
    6948:	1b235101 	blne	8dad54 <_etext+0x8d3740>
    694c:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6950:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
    6954:	5101f304 	tstpl	r1, r4, lsl #6
    6958:	01941c23 	orrseq	r1, r4, r3, lsr #24
    695c:	481aff08 	ldmdami	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    6960:	5101f324 	tstpl	r1, r4, lsr #6
    6964:	01941d23 	orrseq	r1, r4, r3, lsr #26
    6968:	401aff08 	andsmi	pc, sl, r8, lsl #30
    696c:	01f32124 	mvnseq	r2, r4, lsr #2
    6970:	941e2351 	ldrls	r2, [lr], #-849	; 0x351
    6974:	1aff0801 	bne	fffc8980 <BootRAM+0xef39121>
    6978:	f3212438 	vqshl.u32	d2, d24, d1
    697c:	1f235101 	svcne	0x00235101
    6980:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    6984:	939f211a 	orrsls	r2, pc, #-2147483642	; 0x80000006
    6988:	01e09304 	mvneq	r9, r4, lsl #6
    698c:	0000500a 	andeq	r5, r0, sl
    6990:	0000502c 	andeq	r5, r0, ip, lsr #32
    6994:	5c910007 	ldcpl	0, cr0, [r1], {7}
    6998:	fc930493 	ldc2	4, cr0, [r3], {147}	; 0x93
    699c:	00502c01 	subseq	r2, r0, r1, lsl #24
    69a0:	00504400 	subseq	r4, r0, r0, lsl #8
    69a4:	7d000700 	stcvc	7, cr0, [r0, #-0]
    69a8:	9304935c 	movwls	r9, #17244	; 0x435c
    69ac:	000001fc 	strdeq	r0, [r0], -ip
    69b0:	00000000 	andeq	r0, r0, r0
    69b4:	385c0000 	ldmdacc	ip, {}^	; <UNPREDICTABLE>
    69b8:	38600000 	stmdacc	r0!, {}^	; <UNPREDICTABLE>
    69bc:	00010000 	andeq	r0, r1, r0
    69c0:	0038c854 	eorseq	ip, r8, r4, asr r8
    69c4:	003c1000 	eorseq	r1, ip, r0
    69c8:	55000100 	strpl	r0, [r0, #-256]	; 0x100
    69cc:	00003c9c 	muleq	r0, ip, ip
    69d0:	00003e5a 	andeq	r3, r0, sl, asr lr
    69d4:	5a5c0001 	bpl	17069e0 <_etext+0x16ff3cc>
    69d8:	c400003e 	strgt	r0, [r0], #-62	; 0x3e
    69dc:	0100003f 	tsteq	r0, pc, lsr r0
    69e0:	40205400 	eormi	r5, r0, r0, lsl #8
    69e4:	43a40000 			; <UNDEFINED> instruction: 0x43a40000
    69e8:	00010000 	andeq	r0, r1, r0
    69ec:	0043f857 	subeq	pc, r3, r7, asr r8	; <UNPREDICTABLE>
    69f0:	00476800 	subeq	r6, r7, r0, lsl #16
    69f4:	58000100 	stmdapl	r0, {r8}
    69f8:	000047ce 	andeq	r4, r0, lr, asr #15
    69fc:	00004b6c 	andeq	r4, r0, ip, ror #22
    6a00:	c6560001 	ldrbgt	r0, [r6], -r1
    6a04:	d800004b 	stmdale	r0, {r0, r1, r3, r6}
    6a08:	0100004b 	tsteq	r0, fp, asr #32
    6a0c:	4bd85900 	blmi	ff61ce14 <BootRAM+0xe58d5b5>
    6a10:	4c020000 	stcmi	0, cr0, [r2], {-0}
    6a14:	00010000 	andeq	r0, r1, r0
    6a18:	004c025a 	subeq	r0, ip, sl, asr r2
    6a1c:	004e3a00 	subeq	r3, lr, r0, lsl #20
    6a20:	91000300 	mrsls	r0, LR_irq
    6a24:	4e3a7f98 	mrcmi	15, 1, r7, cr10, cr8, {4}
    6a28:	4fb20000 	svcmi	0x00b20000
    6a2c:	00010000 	andeq	r0, r1, r0
    6a30:	00000052 	andeq	r0, r0, r2, asr r0
    6a34:	00000000 	andeq	r0, r0, r0
    6a38:	00385e00 	eorseq	r5, r8, r0, lsl #28
    6a3c:	003ba800 	eorseq	sl, fp, r0, lsl #16
    6a40:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    6a44:	00003bfc 	strdeq	r3, [r0], -ip
    6a48:	00003f5c 	andeq	r3, r0, ip, asr pc
    6a4c:	b0530001 	subslt	r0, r3, r1
    6a50:	2400003f 	strcs	r0, [r0], #-63	; 0x3f
    6a54:	01000043 	tsteq	r0, r3, asr #32
    6a58:	43905600 	orrsmi	r5, r0, #0, 12
    6a5c:	46f80000 	ldrbtmi	r0, [r8], r0
    6a60:	00010000 	andeq	r0, r1, r0
    6a64:	00475056 	subeq	r5, r7, r6, asr r0
    6a68:	004aea00 	subeq	lr, sl, r0, lsl #20
    6a6c:	50000100 	andpl	r0, r0, r0, lsl #2
    6a70:	00004b58 	andeq	r4, r0, r8, asr fp
    6a74:	00004d90 	muleq	r0, r0, sp
    6a78:	94910003 	ldrls	r0, [r1], #3
    6a7c:	004d907f 	subeq	r9, sp, pc, ror r0
    6a80:	004f3e00 	subeq	r3, pc, r0, lsl #28
    6a84:	5c000100 	stfpls	f0, [r0], {-0}
    6a88:	00004f9c 	muleq	r0, ip, pc	; <UNPREDICTABLE>
    6a8c:	00004ffe 	strdeq	r4, [r0], -lr
    6a90:	00540001 	subseq	r0, r4, r1
    6a94:	00000000 	andeq	r0, r0, r0
    6a98:	5c000000 	stcpl	0, cr0, [r0], {-0}
    6a9c:	2a000038 	bcs	6b84 <_printf_i+0x40>
    6aa0:	0100003b 	tsteq	r0, fp, lsr r0
    6aa4:	3b925600 	blcc	fe49c2ac <BootRAM+0xd40ca4d>
    6aa8:	3ee80000 	cdpcc	0, 14, cr0, cr8, cr0, {0}
    6aac:	00010000 	andeq	r0, r1, r0
    6ab0:	003f3e52 	eorseq	r3, pc, r2, asr lr	; <UNPREDICTABLE>
    6ab4:	0042b600 	subeq	fp, r2, r0, lsl #12
    6ab8:	50000100 	andpl	r0, r0, r0, lsl #2
    6abc:	0000430a 	andeq	r4, r0, sl, lsl #6
    6ac0:	00004682 	andeq	r4, r0, r2, lsl #13
    6ac4:	d4500001 	ldrble	r0, [r0], #-1
    6ac8:	76000046 	strvc	r0, [r0], -r6, asr #32
    6acc:	0100004a 	tsteq	r0, sl, asr #32
    6ad0:	4ad65300 	bmi	ff59b6d8 <BootRAM+0xe50be79>
    6ad4:	4eac0000 	cdpmi	0, 10, cr0, cr12, cr0, {0}
    6ad8:	00010000 	andeq	r0, r1, r0
    6adc:	004f0a54 	subeq	r0, pc, r4, asr sl	; <UNPREDICTABLE>
    6ae0:	004ff600 	subeq	pc, pc, r0, lsl #12
    6ae4:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    6af0:	0000385c 	andeq	r3, r0, ip, asr r8
    6af4:	00003aae 	andeq	r3, r0, lr, lsr #21
    6af8:	125b0001 	subsne	r0, fp, #1
    6afc:	7800003b 	stmdavc	r0, {r0, r1, r3, r4, r5}
    6b00:	0100003e 	tsteq	r0, lr, lsr r0
    6b04:	3ed25000 	cdpcc	0, 13, cr5, cr2, cr0, {0}
    6b08:	422e0000 	eormi	r0, lr, #0
    6b0c:	00010000 	andeq	r0, r1, r0
    6b10:	0042945c 	subeq	r9, r2, ip, asr r4
    6b14:	00461400 	subeq	r1, r6, r0, lsl #8
    6b18:	53000100 	movwpl	r0, #256	; 0x100
    6b1c:	00004668 	andeq	r4, r0, r8, ror #12
    6b20:	000049f0 	strdeq	r4, [r0], -r0
    6b24:	64510001 	ldrbvs	r0, [r1], #-1
    6b28:	4400004a 	strmi	r0, [r0], #-74	; 0x4a
    6b2c:	0100004e 	tsteq	r0, lr, asr #32
    6b30:	4e9a5100 	fmlmie	f5, f2, f0
    6b34:	4fe80000 	svcmi	0x00e80000
    6b38:	00010000 	andeq	r0, r1, r0
    6b3c:	00000053 	andeq	r0, r0, r3, asr r0
    6b40:	00000000 	andeq	r0, r0, r0
    6b44:	00385c00 	eorseq	r5, r8, r0, lsl #24
    6b48:	0038c400 	eorseq	ip, r8, r0, lsl #8
    6b4c:	91000300 	mrsls	r0, LR_irq
    6b50:	38c47f94 	stmiacc	r4, {r2, r4, r7, r8, r9, sl, fp, ip, sp, lr}^
    6b54:	3a500000 	bcc	1406b5c <_etext+0x13ff548>
    6b58:	00010000 	andeq	r0, r1, r0
    6b5c:	003ab854 	eorseq	fp, sl, r4, asr r8
    6b60:	003e0800 	eorseq	r0, lr, r0, lsl #16
    6b64:	54000100 	strpl	r0, [r0], #-256	; 0x100
    6b68:	00003e62 	andeq	r3, r0, r2, ror #28
    6b6c:	000041b8 			; <UNDEFINED> instruction: 0x000041b8
    6b70:	16590001 	ldrbne	r0, [r9], -r1
    6b74:	b8000042 	stmdalt	r0, {r1, r6}
    6b78:	01000045 	tsteq	r0, r5, asr #32
    6b7c:	45f85200 	ldrbmi	r5, [r8, #512]!	; 0x200
    6b80:	497c0000 	ldmdbmi	ip!, {}^	; <UNPREDICTABLE>
    6b84:	00010000 	andeq	r0, r1, r0
    6b88:	0049e852 	subeq	lr, r9, r2, asr r8
    6b8c:	004da400 	subeq	sl, sp, r0, lsl #8
    6b90:	52000100 	andpl	r0, r0, #0, 2
    6b94:	00004e3a 	andeq	r4, r0, sl, lsr lr
    6b98:	00004e54 	andeq	r4, r0, r4, asr lr
    6b9c:	54530001 	ldrbpl	r0, [r3], #-1
    6ba0:	f400004e 	vst4.16	{d0-d3}, [r0], lr
    6ba4:	0300004f 	movweq	r0, #79	; 0x4f
    6ba8:	7fb09100 	svcvc	0x00b09100
    6bac:	00004ff4 	strdeq	r4, [r0], -r4	; <UNPREDICTABLE>
    6bb0:	00005006 	andeq	r5, r0, r6
    6bb4:	b0910008 	addslt	r0, r1, r8
    6bb8:	0077067f 	rsbseq	r0, r7, pc, ror r6
    6bbc:	00009f22 	andeq	r9, r0, r2, lsr #30
    6bc0:	00000000 	andeq	r0, r0, r0
    6bc4:	385c0000 	ldmdacc	ip, {}^	; <UNPREDICTABLE>
    6bc8:	39ce0000 	stmibcc	lr, {}^	; <UNPREDICTABLE>
    6bcc:	00010000 	andeq	r0, r1, r0
    6bd0:	003a3c53 	eorseq	r3, sl, r3, asr ip
    6bd4:	003d9200 	eorseq	r9, sp, r0, lsl #4
    6bd8:	51000100 	mrspl	r0, (UNDEF: 16)
    6bdc:	00003dde 	ldrdeq	r3, [r0], -lr
    6be0:	00004144 	andeq	r4, r0, r4, asr #2
    6be4:	94510001 	ldrbls	r0, [r1], #-1
    6be8:	24000041 	strcs	r0, [r0], #-65	; 0x41
    6bec:	01000045 	tsteq	r0, r5, asr #32
    6bf0:	45825100 	strmi	r5, [r2, #256]	; 0x100
    6bf4:	48fa0000 	ldmmi	sl!, {}^	; <UNPREDICTABLE>
    6bf8:	00010000 	andeq	r0, r1, r0
    6bfc:	00496a54 	subeq	r6, r9, r4, asr sl
    6c00:	004d2800 	subeq	r2, sp, r0, lsl #16
    6c04:	58000100 	stmdapl	r0, {r8}
    6c08:	00004d92 	muleq	r0, r2, sp
    6c0c:	00004db6 			; <UNDEFINED> instruction: 0x00004db6
    6c10:	b65b0001 	ldrblt	r0, [fp], -r1
    6c14:	c000004d 	andgt	r0, r0, sp, asr #32
    6c18:	0100004d 	tsteq	r0, sp, asr #32
    6c1c:	4dc05200 	sfmmi	f5, 2, [r0]
    6c20:	4f9c0000 	svcmi	0x009c0000
    6c24:	00030000 	andeq	r0, r3, r0
    6c28:	9c7f9491 	cfldrdls	mvd9, [pc], #-580	; 69ec <_svfiprintf_r+0x164>
    6c2c:	0400004f 	streq	r0, [r0], #-79	; 0x4f
    6c30:	01000050 	qaddeq	r0, r0, r0
    6c34:	00005600 	andeq	r5, r0, r0, lsl #12
    6c38:	00000000 	andeq	r0, r0, r0
    6c3c:	385c0000 	ldmdacc	ip, {}^	; <UNPREDICTABLE>
    6c40:	39600000 	stmdbcc	r0!, {}^	; <UNPREDICTABLE>
    6c44:	00010000 	andeq	r0, r1, r0
    6c48:	0039bc52 	eorseq	fp, r9, r2, asr ip
    6c4c:	003d1a00 	eorseq	r1, sp, r0, lsl #20
    6c50:	5a000100 	bpl	7058 <_sbrk+0xd8>
    6c54:	00003d7e 	andeq	r3, r0, lr, ror sp
    6c58:	000040d8 	ldrdeq	r4, [r0], -r8
    6c5c:	2a5a0001 	bcs	1686c68 <_etext+0x167f654>
    6c60:	b6000041 	strlt	r0, [r0], -r1, asr #32
    6c64:	01000044 	tsteq	r0, r4, asr #32
    6c68:	450c5400 	strmi	r5, [ip, #-1024]	; 0x400
    6c6c:	48500000 	ldmdami	r0, {}^	; <UNPREDICTABLE>
    6c70:	00010000 	andeq	r0, r1, r0
    6c74:	0048f255 	subeq	pc, r8, r5, asr r2	; <UNPREDICTABLE>
    6c78:	004c7600 	subeq	r7, ip, r0, lsl #12
    6c7c:	55000100 	strpl	r0, [r0, #-256]	; 0x100
    6c80:	00004cd6 	ldrdeq	r4, [r0], -r6
    6c84:	00004d3c 	andeq	r4, r0, ip, lsr sp
    6c88:	3c5a0001 	mrrccc	0, 0, r0, sl, cr1
    6c8c:	4e00004d 	cdpmi	0, 0, cr0, cr0, cr13, {2}
    6c90:	0100004d 	tsteq	r0, sp, asr #32
    6c94:	4d4e5000 	stclmi	0, cr5, [lr, #-0]
    6c98:	4f020000 	svcmi	0x00020000
    6c9c:	00030000 	andeq	r0, r3, r0
    6ca0:	027fa891 	rsbseq	sl, pc, #9502720	; 0x910000
    6ca4:	f000004f 			; <UNDEFINED> instruction: 0xf000004f
    6ca8:	0100004f 	tsteq	r0, pc, asr #32
    6cac:	00005500 	andeq	r5, r0, r0, lsl #10
    6cb0:	00000000 	andeq	r0, r0, r0
    6cb4:	385c0000 	ldmdacc	ip, {}^	; <UNPREDICTABLE>
    6cb8:	38dc0000 	ldmcc	ip, {}^	; <UNPREDICTABLE>
    6cbc:	00010000 	andeq	r0, r1, r0
    6cc0:	00394850 	eorseq	r4, r9, r0, asr r8
    6cc4:	003cb200 	eorseq	fp, ip, r0, lsl #4
    6cc8:	58000100 	stmdapl	r0, {r8}
    6ccc:	00003d18 	andeq	r3, r0, r8, lsl sp
    6cd0:	00003ed0 	ldrdeq	r3, [r0], -r0
    6cd4:	d0560001 	subsle	r0, r6, r1
    6cd8:	6a00003e 	bvs	6dd8 <_free_r+0x18>
    6cdc:	01000040 	tsteq	r0, r0, asr #32
    6ce0:	40c05b00 	sbcmi	r5, r0, r0, lsl #22
    6ce4:	441e0000 	ldrmi	r0, [lr], #-0
    6ce8:	00010000 	andeq	r0, r1, r0
    6cec:	00446c55 	subeq	r6, r4, r5, asr ip
    6cf0:	0047f200 	subeq	pc, r7, r0, lsl #4
    6cf4:	5c000100 	stfpls	f0, [r0], {-0}
    6cf8:	00004842 	andeq	r4, r0, r2, asr #16
    6cfc:	00004bdc 	ldrdeq	r4, [r0], -ip
    6d00:	3c5c0001 	mrrccc	0, 0, r0, ip, cr1
    6d04:	9a00004c 	bls	6e3c <_free_r+0x7c>
    6d08:	0100004c 	tsteq	r0, ip, asr #32
    6d0c:	4c9a5000 	ldcmi	0, cr5, [sl], {0}
    6d10:	4ca60000 	stcmi	0, cr0, [r6]
    6d14:	00010000 	andeq	r0, r1, r0
    6d18:	004ca65b 	subeq	sl, ip, fp, asr r6
    6d1c:	004e9600 	subeq	r9, lr, r0, lsl #12
    6d20:	91000300 	mrsls	r0, LR_irq
    6d24:	4e967fa4 	cdpmi	15, 9, cr7, cr6, cr4, {5}
    6d28:	4fe00000 	svcmi	0x00e00000
    6d2c:	00010000 	andeq	r0, r1, r0
    6d30:	00000050 	andeq	r0, r0, r0, asr r0
    6d34:	00000000 	andeq	r0, r0, r0
    6d38:	00504400 	subseq	r4, r0, r0, lsl #8
    6d3c:	00506600 	subseq	r6, r0, r0, lsl #12
    6d40:	50000100 	andpl	r0, r0, r0, lsl #2
    6d44:	00005066 	andeq	r5, r0, r6, rrx
    6d48:	00005096 	muleq	r0, r6, r0
    6d4c:	96560001 	ldrbls	r0, [r6], -r1
    6d50:	9e000050 	mcrls	0, 0, r0, cr0, cr0, {2}
    6d54:	01000050 	qaddeq	r0, r0, r0
    6d58:	509e5000 	addspl	r5, lr, r0
    6d5c:	50ac0000 	adcpl	r0, ip, r0
    6d60:	00010000 	andeq	r0, r1, r0
    6d64:	0050ac56 	subseq	sl, r0, r6, asr ip
    6d68:	0050b000 	subseq	fp, r0, r0
    6d6c:	f3000400 	vshl.u8	d0, d0, d0
    6d70:	b09f5001 	addslt	r5, pc, r1
    6d74:	b4000050 	strlt	r0, [r0], #-80	; 0x50
    6d78:	01000050 	qaddeq	r0, r0, r0
    6d7c:	50b45000 	adcspl	r5, r4, r0
    6d80:	50d20000 	sbcspl	r0, r2, r0
    6d84:	00010000 	andeq	r0, r1, r0
    6d88:	00000056 	andeq	r0, r0, r6, asr r0
    6d8c:	00000000 	andeq	r0, r0, r0
    6d90:	00504400 	subseq	r4, r0, r0, lsl #8
    6d94:	00506600 	subseq	r6, r0, r0, lsl #12
    6d98:	51000100 	mrspl	r0, (UNDEF: 16)
    6d9c:	00005066 	andeq	r5, r0, r6, rrx
    6da0:	00005096 	muleq	r0, r6, r0
    6da4:	01f30004 	mvnseq	r0, r4
    6da8:	50969f51 	addspl	r9, r6, r1, asr pc
    6dac:	509e0000 	addspl	r0, lr, r0
    6db0:	00010000 	andeq	r0, r1, r0
    6db4:	00509e51 	subseq	r9, r0, r1, asr lr
    6db8:	0050b000 	subseq	fp, r0, r0
    6dbc:	f3000400 	vshl.u8	d0, d0, d0
    6dc0:	b09f5101 	addslt	r5, pc, r1, lsl #2
    6dc4:	b6000050 			; <UNDEFINED> instruction: 0xb6000050
    6dc8:	01000050 	qaddeq	r0, r0, r0
    6dcc:	50b65100 	adcspl	r5, r6, r0, lsl #2
    6dd0:	50cc0000 	sbcpl	r0, ip, r0
    6dd4:	00010000 	andeq	r0, r1, r0
    6dd8:	0050cc58 	subseq	ip, r0, r8, asr ip
    6ddc:	0050d200 	subseq	sp, r0, r0, lsl #4
    6de0:	f3000400 	vshl.u8	d0, d0, d0
    6de4:	009f5101 	addseq	r5, pc, r1, lsl #2
    6de8:	00000000 	andeq	r0, r0, r0
    6dec:	44000000 	strmi	r0, [r0], #-0
    6df0:	54000050 	strpl	r0, [r0], #-80	; 0x50
    6df4:	01000050 	qaddeq	r0, r0, r0
    6df8:	50545200 	subspl	r5, r4, r0, lsl #4
    6dfc:	50660000 	rsbpl	r0, r6, r0
    6e00:	00010000 	andeq	r0, r1, r0
    6e04:	00506657 	subseq	r6, r0, r7, asr r6
    6e08:	00509600 	subseq	r9, r0, r0, lsl #12
    6e0c:	f3000400 	vshl.u8	d0, d0, d0
    6e10:	969f5201 	ldrls	r5, [pc], r1, lsl #4
    6e14:	9e000050 	mcrls	0, 0, r0, cr0, cr0, {2}
    6e18:	01000050 	qaddeq	r0, r0, r0
    6e1c:	509e5700 	addspl	r5, lr, r0, lsl #14
    6e20:	50b00000 	adcspl	r0, r0, r0
    6e24:	00040000 	andeq	r0, r4, r0
    6e28:	9f5201f3 	svcls	0x005201f3
    6e2c:	000050b0 	strheq	r5, [r0], -r0
    6e30:	000050ca 	andeq	r5, r0, sl, asr #1
    6e34:	ca570001 	bgt	15c6e40 <_etext+0x15bf82c>
    6e38:	d2000050 	andle	r0, r0, #80	; 0x50
    6e3c:	04000050 	streq	r0, [r0], #-80	; 0x50
    6e40:	5201f300 	andpl	pc, r1, #0, 6
    6e44:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    6e48:	00000000 	andeq	r0, r0, r0
    6e4c:	00505000 	subseq	r5, r0, r0
    6e50:	00505400 	subseq	r5, r0, r0, lsl #8
    6e54:	52000100 	andpl	r0, r0, #0, 2
    6e58:	00005054 	andeq	r5, r0, r4, asr r0
    6e5c:	0000506e 	andeq	r5, r0, lr, rrx
    6e60:	6e570001 	cdpvs	0, 5, cr0, cr7, cr1, {0}
    6e64:	72000050 	andvc	r0, r0, #80	; 0x50
    6e68:	01000050 	qaddeq	r0, r0, r0
    6e6c:	50725500 	rsbspl	r5, r2, r0, lsl #10
    6e70:	50780000 	rsbspl	r0, r8, r0
    6e74:	00040000 	andeq	r0, r4, r0
    6e78:	9f00c075 	svcls	0x0000c075
    6e7c:	00005078 	andeq	r5, r0, r8, ror r0
    6e80:	00005090 	muleq	r0, r0, r0
    6e84:	96550001 	ldrbls	r0, [r5], -r1
    6e88:	9e000050 	mcrls	0, 0, r0, cr0, cr0, {2}
    6e8c:	01000050 	qaddeq	r0, r0, r0
    6e90:	50b05700 	adcspl	r5, r0, r0, lsl #14
    6e94:	50ce0000 	sbcpl	r0, lr, r0
    6e98:	00010000 	andeq	r0, r1, r0
    6e9c:	00000057 	andeq	r0, r0, r7, asr r0
    6ea0:	00000000 	andeq	r0, r0, r0
    6ea4:	00505000 	subseq	r5, r0, r0
    6ea8:	00506600 	subseq	r6, r0, r0, lsl #12
    6eac:	51000100 	mrspl	r0, (UNDEF: 16)
    6eb0:	00005066 	andeq	r5, r0, r6, rrx
    6eb4:	0000506e 	andeq	r5, r0, lr, rrx
    6eb8:	6e580001 	cdpvs	0, 5, cr0, cr8, cr1, {0}
    6ebc:	90000050 	andls	r0, r0, r0, asr r0
    6ec0:	01000050 	qaddeq	r0, r0, r0
    6ec4:	50965400 	addspl	r5, r6, r0, lsl #8
    6ec8:	509e0000 	addspl	r0, lr, r0
    6ecc:	00010000 	andeq	r0, r1, r0
    6ed0:	0050b051 	subseq	fp, r0, r1, asr r0
    6ed4:	0050b600 	subseq	fp, r0, r0, lsl #12
    6ed8:	51000100 	mrspl	r0, (UNDEF: 16)
    6edc:	000050b6 	strheq	r5, [r0], -r6
    6ee0:	000050ce 	andeq	r5, r0, lr, asr #1
    6ee4:	00580001 	subseq	r0, r8, r1
    6ee8:	00000000 	andeq	r0, r0, r0
    6eec:	50000000 	andpl	r0, r0, r0
    6ef0:	66000050 			; <UNDEFINED> instruction: 0x66000050
    6ef4:	01000050 	qaddeq	r0, r0, r0
    6ef8:	50665000 	rsbpl	r5, r6, r0
    6efc:	50920000 	addspl	r0, r2, r0
    6f00:	00010000 	andeq	r0, r1, r0
    6f04:	00509656 	subseq	r9, r0, r6, asr r6
    6f08:	00509e00 	subseq	r9, r0, r0, lsl #28
    6f0c:	50000100 	andpl	r0, r0, r0, lsl #2
    6f10:	0000509e 	muleq	r0, lr, r0
    6f14:	000050ac 	andeq	r5, r0, ip, lsr #1
    6f18:	ac560001 	mrrcge	0, 0, r0, r6, cr1
    6f1c:	b0000050 	andlt	r0, r0, r0, asr r0
    6f20:	04000050 	streq	r0, [r0], #-80	; 0x50
    6f24:	5001f300 	andpl	pc, r1, r0, lsl #6
    6f28:	0050b09f 			; <UNDEFINED> instruction: 0x0050b09f
    6f2c:	0050b400 	subseq	fp, r0, r0, lsl #8
    6f30:	50000100 	andpl	r0, r0, r0, lsl #2
    6f34:	000050b4 	strheq	r5, [r0], -r4
    6f38:	000050d2 	ldrdeq	r5, [r0], -r2
    6f3c:	00560001 	subseq	r0, r6, r1
    6f40:	00000000 	andeq	r0, r0, r0
    6f44:	5c000000 	stcpl	0, cr0, [r0], {-0}
    6f48:	66000050 			; <UNDEFINED> instruction: 0x66000050
    6f4c:	01000050 	qaddeq	r0, r0, r0
    6f50:	50665300 	rsbpl	r5, r6, r0, lsl #6
    6f54:	50920000 	addspl	r0, r2, r0
    6f58:	00020000 	andeq	r0, r2, r0
    6f5c:	50969f30 	addspl	r9, r6, r0, lsr pc
    6f60:	509e0000 	addspl	r0, lr, r0
    6f64:	00010000 	andeq	r0, r1, r0
    6f68:	0050b053 	subseq	fp, r0, r3, asr r0
    6f6c:	0050bd00 	subseq	fp, r0, r0, lsl #26
    6f70:	53000100 	movwpl	r0, #256	; 0x100
    6f74:	000050cc 	andeq	r5, r0, ip, asr #1
    6f78:	000050d2 	ldrdeq	r5, [r0], -r2
    6f7c:	9f300002 	svcls	0x00300002
	...
    6f88:	0000505c 	andeq	r5, r0, ip, asr r0
    6f8c:	00005066 	andeq	r5, r0, r6, rrx
    6f90:	40080006 	andmi	r0, r8, r6
    6f94:	9f1c0073 	svcls	0x001c0073
    6f98:	00005096 	muleq	r0, r6, r0
    6f9c:	0000509e 	muleq	r0, lr, r0
    6fa0:	40080006 	andmi	r0, r8, r6
    6fa4:	9f1c0073 	svcls	0x001c0073
    6fa8:	000050b0 	strheq	r5, [r0], -r0
    6fac:	000050bd 	strheq	r5, [r0], -sp
    6fb0:	40080006 	andmi	r0, r8, r6
    6fb4:	9f1c0073 	svcls	0x001c0073
	...
    6fc0:	000050d4 	ldrdeq	r5, [r0], -r4
    6fc4:	000050fc 	strdeq	r5, [r0], -ip
    6fc8:	fc500001 	mrrc2	0, 0, r0, r0, cr1	; <UNPREDICTABLE>
    6fcc:	ec000050 	stc	0, cr0, [r0], {80}	; 0x50
    6fd0:	01000052 	qaddeq	r0, r2, r0
    6fd4:	00005400 	andeq	r5, r0, r0, lsl #8
    6fd8:	00000000 	andeq	r0, r0, r0
    6fdc:	50d40000 	sbcspl	r0, r4, r0
    6fe0:	51540000 	cmppl	r4, r0
    6fe4:	00010000 	andeq	r0, r1, r0
    6fe8:	00515451 	subseq	r5, r1, r1, asr r4
    6fec:	00523600 	subseq	r3, r2, r0, lsl #12
    6ff0:	55000100 	strpl	r0, [r0, #-256]	; 0x100
    6ff4:	00005236 	andeq	r5, r0, r6, lsr r2
    6ff8:	00005240 	andeq	r5, r0, r0, asr #4
    6ffc:	40510001 	subsmi	r0, r1, r1
    7000:	88000052 	stmdahi	r0, {r1, r4, r6}
    7004:	01000052 	qaddeq	r0, r2, r0
    7008:	52885500 	addpl	r5, r8, #0, 10
    700c:	528e0000 	addpl	r0, lr, #0
    7010:	00010000 	andeq	r0, r1, r0
    7014:	00528e51 	subseq	r8, r2, r1, asr lr
    7018:	0052ec00 	subseq	lr, r2, r0, lsl #24
    701c:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    7028:	00005102 	andeq	r5, r0, r2, lsl #2
    702c:	00005154 	andeq	r5, r0, r4, asr r1
    7030:	36560001 	ldrbcc	r0, [r6], -r1
    7034:	62000052 	andvs	r0, r0, #82	; 0x52
    7038:	01000052 	qaddeq	r0, r2, r0
    703c:	52885600 	addpl	r5, r8, #0, 12
    7040:	528e0000 	addpl	r0, lr, #0
    7044:	00010000 	andeq	r0, r1, r0
    7048:	0052d456 	subseq	sp, r2, r6, asr r4
    704c:	0052d800 	subseq	sp, r2, r0, lsl #16
    7050:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    705c:	00005102 	andeq	r5, r0, r2, lsl #2
    7060:	00005154 	andeq	r5, r0, r4, asr r1
    7064:	36580001 	ldrbcc	r0, [r8], -r1
    7068:	52000052 	andpl	r0, r0, #82	; 0x52
    706c:	01000052 	qaddeq	r0, r2, r0
    7070:	52885800 	addpl	r5, r8, #0, 16
    7074:	528e0000 	addpl	r0, lr, #0
    7078:	00010000 	andeq	r0, r1, r0
    707c:	00000058 	andeq	r0, r0, r8, asr r0
    7080:	00000000 	andeq	r0, r0, r0
    7084:	00510200 	subseq	r0, r1, r0, lsl #4
    7088:	00515400 	subseq	r5, r1, r0, lsl #8
    708c:	50000100 	andpl	r0, r0, r0, lsl #2
    7090:	00005236 	andeq	r5, r0, r6, lsr r2
    7094:	0000523e 	andeq	r5, r0, lr, lsr r2
    7098:	88500001 	ldmdahi	r0, {r0}^
    709c:	8e000052 	mcrhi	0, 0, r0, cr0, cr2, {2}
    70a0:	01000052 	qaddeq	r0, r2, r0
    70a4:	00005000 	andeq	r5, r0, r0
    70a8:	00000000 	andeq	r0, r0, r0
    70ac:	51020000 	mrspl	r0, (UNDEF: 2)
    70b0:	51540000 	cmppl	r4, r0
    70b4:	00010000 	andeq	r0, r1, r0
    70b8:	00523652 	subseq	r3, r2, r2, asr r6
    70bc:	00524400 	subseq	r4, r2, r0, lsl #8
    70c0:	52000100 	andpl	r0, r0, #0, 2
    70c4:	00005288 	andeq	r5, r0, r8, lsl #5
    70c8:	0000528e 	andeq	r5, r0, lr, lsl #5
    70cc:	00520001 	subseq	r0, r2, r1
    70d0:	00000000 	andeq	r0, r0, r0
    70d4:	02000000 	andeq	r0, r0, #0
    70d8:	54000051 	strpl	r0, [r0], #-81	; 0x51
    70dc:	01000051 	qaddeq	r0, r1, r0
    70e0:	52365800 	eorspl	r5, r6, #0, 16
    70e4:	52520000 	subspl	r0, r2, #0
    70e8:	00010000 	andeq	r0, r1, r0
    70ec:	00525858 	subseq	r5, r2, r8, asr r8
    70f0:	00526200 	subseq	r6, r2, r0, lsl #4
    70f4:	58000100 	stmdapl	r0, {r8}
    70f8:	00005262 	andeq	r5, r0, r2, ror #4
    70fc:	00005266 	andeq	r5, r0, r6, ror #4
    7100:	66570001 	ldrbvs	r0, [r7], -r1
    7104:	6c000052 	stcvs	0, cr0, [r0], {82}	; 0x52
    7108:	04000052 	streq	r0, [r0], #-82	; 0x52
    710c:	00c07700 	sbceq	r7, r0, r0, lsl #14
    7110:	00526c9f 			; <UNDEFINED> instruction: 0x00526c9f
    7114:	00528800 	subseq	r8, r2, r0, lsl #16
    7118:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    711c:	00005288 	andeq	r5, r0, r8, lsl #5
    7120:	0000528e 	andeq	r5, r0, lr, lsl #5
    7124:	d4580001 	ldrble	r0, [r8], #-1
    7128:	da000052 	ble	7278 <f25519_one+0x18>
    712c:	01000052 	qaddeq	r0, r2, r0
    7130:	00005800 	andeq	r5, r0, r0, lsl #16
    7134:	00000000 	andeq	r0, r0, r0
    7138:	51020000 	mrspl	r0, (UNDEF: 2)
    713c:	51540000 	cmppl	r4, r0
    7140:	00060000 	andeq	r0, r6, r0
    7144:	0002c403 	andeq	ip, r2, r3, lsl #8
    7148:	52369f20 	eorspl	r9, r6, #32, 30	; 0x80
    714c:	52580000 	subspl	r0, r8, #0
    7150:	00060000 	andeq	r0, r6, r0
    7154:	0002c403 	andeq	ip, r2, r3, lsl #8
    7158:	52589f20 	subspl	r9, r8, #32, 30	; 0x80
    715c:	52620000 	rsbpl	r0, r2, #0
    7160:	00010000 	andeq	r0, r1, r0
    7164:	00526259 	subseq	r6, r2, r9, asr r2
    7168:	00528600 	subseq	r8, r2, r0, lsl #12
    716c:	56000100 	strpl	r0, [r0], -r0, lsl #2
    7170:	00005288 	andeq	r5, r0, r8, lsl #5
    7174:	0000528e 	andeq	r5, r0, lr, lsl #5
    7178:	c4030006 	strgt	r0, [r3], #-6
    717c:	9f200002 	svcls	0x00200002
    7180:	000052d4 	ldrdeq	r5, [r0], -r4
    7184:	000052da 	ldrdeq	r5, [r0], -sl
    7188:	00590001 	subseq	r0, r9, r1
    718c:	00000000 	andeq	r0, r0, r0
    7190:	02000000 	andeq	r0, r0, #0
    7194:	54000051 	strpl	r0, [r0], #-81	; 0x51
    7198:	01000051 	qaddeq	r0, r1, r0
    719c:	52365600 	eorspl	r5, r6, #0, 12
    71a0:	52580000 	subspl	r0, r8, #0
    71a4:	00010000 	andeq	r0, r1, r0
    71a8:	00525856 	subseq	r5, r2, r6, asr r8
    71ac:	00528800 	subseq	r8, r2, r0, lsl #16
    71b0:	30000200 	andcc	r0, r0, r0, lsl #4
    71b4:	0052889f 			; <UNDEFINED> instruction: 0x0052889f
    71b8:	00528e00 	subseq	r8, r2, r0, lsl #28
    71bc:	56000100 	strpl	r0, [r0], -r0, lsl #2
    71c0:	000052d4 	ldrdeq	r5, [r0], -r4
    71c4:	000052da 	ldrdeq	r5, [r0], -sl
    71c8:	9f300002 	svcls	0x00300002
	...
    71d4:	00005102 	andeq	r5, r0, r2, lsl #2
    71d8:	0000514a 	andeq	r5, r0, sl, asr #2
    71dc:	40080006 	andmi	r0, r8, r6
    71e0:	9f1c0076 	svcls	0x001c0076
    71e4:	0000514a 	andeq	r5, r0, sl, asr #2
    71e8:	00005154 	andeq	r5, r0, r4, asr r1
    71ec:	36570001 	ldrbcc	r0, [r7], -r1
    71f0:	58000052 	stmdapl	r0, {r1, r4, r6}
    71f4:	01000052 	qaddeq	r0, r2, r0
    71f8:	52585700 	subspl	r5, r8, #0, 14
    71fc:	52620000 	rsbpl	r0, r2, #0
    7200:	00060000 	andeq	r0, r6, r0
    7204:	00764008 	rsbseq	r4, r6, r8
    7208:	52889f1c 	addpl	r9, r8, #28, 30	; 0x70
    720c:	528e0000 	addpl	r0, lr, #0
    7210:	00060000 	andeq	r0, r6, r0
    7214:	00764008 	rsbseq	r4, r6, r8
    7218:	52d49f1c 	sbcspl	r9, r4, #28, 30	; 0x70
    721c:	52d80000 	sbcspl	r0, r8, #0
    7220:	00060000 	andeq	r0, r6, r0
    7224:	00764008 	rsbseq	r4, r6, r8
    7228:	00009f1c 	andeq	r9, r0, ip, lsl pc
    722c:	00000000 	andeq	r0, r0, r0
    7230:	51620000 	cmnpl	r2, r0
    7234:	52360000 	eorspl	r0, r6, #0
    7238:	00020000 	andeq	r0, r2, r0
    723c:	528e9f38 	addpl	r9, lr, #56, 30	; 0xe0
    7240:	52d40000 	sbcspl	r0, r4, #0
    7244:	00020000 	andeq	r0, r2, r0
    7248:	52da9f38 	sbcspl	r9, sl, #56, 30	; 0xe0
    724c:	52ec0000 	rscpl	r0, ip, #0
    7250:	00020000 	andeq	r0, r2, r0
    7254:	00009f38 	andeq	r9, r0, r8, lsr pc
    7258:	00000000 	andeq	r0, r0, r0
    725c:	51620000 	cmnpl	r2, r0
    7260:	52320000 	eorspl	r0, r2, #0
    7264:	00010000 	andeq	r0, r1, r0
    7268:	0052325d 	subseq	r3, r2, sp, asr r2
    726c:	00523600 	subseq	r3, r2, r0, lsl #12
    7270:	91000300 	mrsls	r0, LR_irq
    7274:	528e9f50 	addpl	r9, lr, #80, 30	; 0x140
    7278:	52d40000 	sbcspl	r0, r4, #0
    727c:	00010000 	andeq	r0, r1, r0
    7280:	0052da5d 	subseq	sp, r2, sp, asr sl
    7284:	0052ec00 	subseq	lr, r2, r0, lsl #24
    7288:	5d000100 	stfpls	f0, [r0, #-0]
	...
    7294:	00005162 	andeq	r5, r0, r2, ror #2
    7298:	00005236 	andeq	r5, r0, r6, lsr r2
    729c:	8e540001 	cdphi	0, 5, cr0, cr4, cr1, {0}
    72a0:	d4000052 	strle	r0, [r0], #-82	; 0x52
    72a4:	01000052 	qaddeq	r0, r2, r0
    72a8:	52da5400 	sbcspl	r5, sl, #0, 8
    72ac:	52ec0000 	rscpl	r0, ip, #0
    72b0:	00010000 	andeq	r0, r1, r0
    72b4:	00000054 	andeq	r0, r0, r4, asr r0
    72b8:	00000000 	andeq	r0, r0, r0
    72bc:	00516200 	subseq	r6, r1, r0, lsl #4
    72c0:	00518e00 	subseq	r8, r1, r0, lsl #28
    72c4:	38000200 	stmdacc	r0, {r9}
    72c8:	00528e9f 			; <UNDEFINED> instruction: 0x00528e9f
    72cc:	0052ae00 	subseq	sl, r2, r0, lsl #28
    72d0:	38000200 	stmdacc	r0, {r9}
    72d4:	0052ae9f 			; <UNDEFINED> instruction: 0x0052ae9f
    72d8:	0052b800 	subseq	fp, r2, r0, lsl #16
    72dc:	56000100 	strpl	r0, [r0], -r0, lsl #2
    72e0:	000052b8 			; <UNDEFINED> instruction: 0x000052b8
    72e4:	000052be 			; <UNDEFINED> instruction: 0x000052be
    72e8:	c0760004 	rsbsgt	r0, r6, r4
    72ec:	52be9f00 	adcspl	r9, lr, #0, 30
    72f0:	52ca0000 	sbcpl	r0, sl, #0
    72f4:	00010000 	andeq	r0, r1, r0
    72f8:	0052da56 	subseq	sp, r2, r6, asr sl
    72fc:	0052ec00 	subseq	lr, r2, r0, lsl #24
    7300:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    730c:	00005162 	andeq	r5, r0, r2, ror #2
    7310:	0000518e 	andeq	r5, r0, lr, lsl #3
    7314:	8e5d0001 	cdphi	0, 5, cr0, cr13, cr1, {0}
    7318:	ae000052 	mcrge	0, 0, r0, cr0, cr2, {2}
    731c:	01000052 	qaddeq	r0, r2, r0
    7320:	52ae5d00 	adcpl	r5, lr, #0, 26
    7324:	52b40000 	adcspl	r0, r4, #0
    7328:	00010000 	andeq	r0, r1, r0
    732c:	0052b459 	subseq	fp, r2, r9, asr r4
    7330:	0052d400 	subseq	sp, r2, r0, lsl #8
    7334:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    7338:	000052da 	ldrdeq	r5, [r0], -sl
    733c:	000052ec 	andeq	r5, r0, ip, ror #5
    7340:	00590001 	subseq	r0, r9, r1
    7344:	00000000 	andeq	r0, r0, r0
    7348:	70000000 	andvc	r0, r0, r0
    734c:	8e000051 	mcrhi	0, 0, r0, cr0, cr1, {2}
    7350:	01000051 	qaddeq	r0, r1, r0
    7354:	528e5800 	addpl	r5, lr, #0, 16
    7358:	52ae0000 	adcpl	r0, lr, #0
    735c:	00010000 	andeq	r0, r1, r0
    7360:	0052ae58 	subseq	sl, r2, r8, asr lr
    7364:	0052d400 	subseq	sp, r2, r0, lsl #8
    7368:	30000200 	andcc	r0, r0, r0, lsl #4
    736c:	0052da9f 			; <UNDEFINED> instruction: 0x0052da9f
    7370:	0052ec00 	subseq	lr, r2, r0, lsl #24
    7374:	30000200 	andcc	r0, r0, r0, lsl #4
    7378:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    737c:	00000000 	andeq	r0, r0, r0
    7380:	00517000 	subseq	r7, r1, r0
    7384:	00518e00 	subseq	r8, r1, r0, lsl #28
    7388:	08000600 	stmdaeq	r0, {r9, sl}
    738c:	1c007840 	stcne	8, cr7, [r0], {64}	; 0x40
    7390:	00528e9f 			; <UNDEFINED> instruction: 0x00528e9f
    7394:	0052d200 	subseq	sp, r2, r0, lsl #4
    7398:	08000600 	stmdaeq	r0, {r9, sl}
    739c:	1c007840 	stcne	8, cr7, [r0], {64}	; 0x40
    73a0:	0052d29f 			; <UNDEFINED> instruction: 0x0052d29f
    73a4:	0052d400 	subseq	sp, r2, r0, lsl #8
    73a8:	08000600 	stmdaeq	r0, {r9, sl}
    73ac:	1c007648 	stcne	6, cr7, [r0], {72}	; 0x48
    73b0:	0052da9f 			; <UNDEFINED> instruction: 0x0052da9f
    73b4:	0052e400 	subseq	lr, r2, r0, lsl #8
    73b8:	08000600 	stmdaeq	r0, {r9, sl}
    73bc:	1c007840 	stcne	8, cr7, [r0], {64}	; 0x40
    73c0:	0052e49f 			; <UNDEFINED> instruction: 0x0052e49f
    73c4:	0052ec00 	subseq	lr, r2, r0, lsl #24
    73c8:	38000500 	stmdacc	r0, {r8, sl}
    73cc:	9f1c0076 	svcls	0x001c0076
	...
    73d8:	000052ec 	andeq	r5, r0, ip, ror #5
    73dc:	000052fc 	strdeq	r5, [r0], -ip
    73e0:	fc500001 	mrrc2	0, 0, r0, r0, cr1	; <UNPREDICTABLE>
    73e4:	7a000052 	bvc	7534 <round_k+0x274>
    73e8:	03000057 	movweq	r0, #87	; 0x57
    73ec:	7e9c9100 	cosvce	f1, f0
    73f0:	0000577a 	andeq	r5, r0, sl, ror r7
    73f4:	00005780 	andeq	r5, r0, r0, lsl #15
    73f8:	9c7d0003 	ldclls	0, cr0, [sp], #-12
    73fc:	0000007e 	andeq	r0, r0, lr, ror r0
    7400:	00000000 	andeq	r0, r0, r0
    7404:	0052ec00 	subseq	lr, r2, r0, lsl #24
    7408:	0052fc00 	subseq	pc, r2, r0, lsl #24
    740c:	51000100 	mrspl	r0, (UNDEF: 16)
    7410:	000052fc 	strdeq	r5, [r0], -ip
    7414:	000053c0 	andeq	r5, r0, r0, asr #7
    7418:	00540001 	subseq	r0, r4, r1
    741c:	00000000 	andeq	r0, r0, r0
    7420:	ec000000 	stc	0, cr0, [r0], {-0}
    7424:	14000053 	strne	r0, [r0], #-83	; 0x53
    7428:	06000054 			; <UNDEFINED> instruction: 0x06000054
    742c:	04935000 	ldreq	r5, [r3], #0
    7430:	14049351 	strne	r9, [r4], #-849	; 0x351
    7434:	2a000054 	bcs	758c <round_k+0x2cc>
    7438:	02000054 	andeq	r0, r0, #84	; 0x54
    743c:	2a007100 	bcs	23844 <_etext+0x1c230>
    7440:	48000054 	stmdami	r0, {r2, r4, r6}
    7444:	02000054 	andeq	r0, r0, #84	; 0x54
    7448:	48007500 	stmdami	r0, {r8, sl, ip, sp, lr}
    744c:	7a000054 	bvc	75a4 <round_k+0x2e4>
    7450:	06000054 			; <UNDEFINED> instruction: 0x06000054
    7454:	04935000 	ldreq	r5, [r3], #0
    7458:	7a049351 	bvc	12c1a4 <_etext+0x124b90>
    745c:	aa000054 	bge	75b4 <round_k+0x2f4>
    7460:	06000056 			; <UNDEFINED> instruction: 0x06000056
    7464:	04935a00 	ldreq	r5, [r3], #2560	; 0xa00
    7468:	aa04935b 	bge	12c1dc <_etext+0x124bc8>
    746c:	bc000056 	stclt	0, cr0, [r0], {86}	; 0x56
    7470:	06000056 			; <UNDEFINED> instruction: 0x06000056
    7474:	04935000 	ldreq	r5, [r3], #0
    7478:	00049351 	andeq	r9, r4, r1, asr r3
    747c:	00000000 	andeq	r0, r0, r0
    7480:	ec000000 	stc	0, cr0, [r0], {-0}
    7484:	48000053 	stmdami	r0, {r0, r1, r4, r6}
    7488:	03000054 	movweq	r0, #84	; 0x54
    748c:	7d809100 	stfvcd	f1, [r0]
    7490:	00005448 	andeq	r5, r0, r8, asr #8
    7494:	00005478 	andeq	r5, r0, r8, ror r4
    7498:	935a0006 	cmpls	sl, #6
    749c:	04935b04 	ldreq	r5, [r3], #2820	; 0xb04
    74a0:	00005478 	andeq	r5, r0, r8, ror r4
    74a4:	000056a4 	andeq	r5, r0, r4, lsr #13
    74a8:	80910003 	addshi	r0, r1, r3
    74ac:	0056a47d 	subseq	sl, r6, sp, ror r4
    74b0:	0056c400 	subseq	ip, r6, r0, lsl #8
    74b4:	5a000600 	bpl	8cbc <_etext+0x16a8>
    74b8:	935b0493 	cmpls	fp, #-1828716544	; 0x93000000
    74bc:	00000004 	andeq	r0, r0, r4
    74c0:	00000000 	andeq	r0, r0, r0
    74c4:	0053ec00 	subseq	lr, r3, r0, lsl #24
    74c8:	00544800 	subseq	r4, r4, r0, lsl #16
    74cc:	91000300 	mrsls	r0, LR_irq
    74d0:	54487d88 	strbpl	r7, [r8], #-3464	; 0xd88
    74d4:	54740000 	ldrbtpl	r0, [r4], #-0
    74d8:	00030000 	andeq	r0, r3, r0
    74dc:	7a7d8091 	bvc	1f67728 <_etext+0x1f60114>
    74e0:	a4000054 	strge	r0, [r0], #-84	; 0x54
    74e4:	03000056 	movweq	r0, #86	; 0x56
    74e8:	7d889100 	stfvcd	f1, [r8]
    74ec:	000056a4 	andeq	r5, r0, r4, lsr #13
    74f0:	0000577a 	andeq	r5, r0, sl, ror r7
    74f4:	80910003 	addshi	r0, r1, r3
    74f8:	00577a7d 	subseq	r7, r7, sp, ror sl
    74fc:	00578000 	subseq	r8, r7, r0
    7500:	7d000300 	stcvc	3, cr0, [r0, #-0]
    7504:	00007d80 	andeq	r7, r0, r0, lsl #27
    7508:	00000000 	andeq	r0, r0, r0
    750c:	53f80000 	mvnspl	r0, #0
    7510:	540a0000 	strpl	r0, [sl], #-0
    7514:	00060000 	andeq	r0, r6, r0
    7518:	57049356 	smlsdpl	r4, r6, r3, r9
    751c:	540a0493 	strpl	r0, [sl], #-1171	; 0x493
    7520:	542a0000 	strtpl	r0, [sl], #-0
    7524:	00020000 	andeq	r0, r2, r0
    7528:	542a1871 	strtpl	r1, [sl], #-2161	; 0x871
    752c:	54480000 	strbpl	r0, [r8], #-0
    7530:	00020000 	andeq	r0, r2, r0
    7534:	54481875 	strbpl	r1, [r8], #-2165	; 0x875
    7538:	54680000 	strbtpl	r0, [r8], #-0
    753c:	00030000 	andeq	r0, r3, r0
    7540:	7a7d8891 	bvc	1f6978c <_etext+0x1f62178>
    7544:	a4000054 	strge	r0, [r0], #-84	; 0x54
    7548:	03000056 	movweq	r0, #86	; 0x56
    754c:	7df89100 	ldfvcp	f1, [r8]
    7550:	000056a4 	andeq	r5, r0, r4, lsr #13
    7554:	0000577a 	andeq	r5, r0, sl, ror r7
    7558:	88910003 	ldmhi	r1, {r0, r1}
    755c:	00577a7d 	subseq	r7, r7, sp, ror sl
    7560:	00578000 	subseq	r8, r7, r0
    7564:	7d000300 	stcvc	3, cr0, [r0, #-0]
    7568:	00007d88 	andeq	r7, r0, r8, lsl #27
    756c:	00000000 	andeq	r0, r0, r0
    7570:	54300000 	ldrtpl	r0, [r0], #-0
    7574:	54360000 	ldrtpl	r0, [r6], #-0
    7578:	00060000 	andeq	r0, r6, r0
    757c:	5b04935a 	blpl	12c2ec <_etext+0x124cd8>
    7580:	54360493 	ldrtpl	r0, [r6], #-1171	; 0x493
    7584:	54480000 	strbpl	r0, [r8], #-0
    7588:	00020000 	andeq	r0, r2, r0
    758c:	54482075 	strbpl	r2, [r8], #-117	; 0x75
    7590:	54700000 	ldrbtpl	r0, [r0], #-0
    7594:	00060000 	andeq	r0, r6, r0
    7598:	53049352 	movwpl	r9, #17234	; 0x4352
    759c:	547a0493 	ldrbtpl	r0, [sl], #-1171	; 0x493
    75a0:	56a40000 	strtpl	r0, [r4], r0
    75a4:	00060000 	andeq	r0, r6, r0
    75a8:	59049358 	stmdbpl	r4, {r3, r4, r6, r8, r9, ip, pc}
    75ac:	56a40493 	ssatpl	r0, #5, r3, lsl #9
    75b0:	56b80000 	ldrtpl	r0, [r8], r0
    75b4:	00060000 	andeq	r0, r6, r0
    75b8:	53049352 	movwpl	r9, #17234	; 0x4352
    75bc:	00000493 	muleq	r0, r3, r4
    75c0:	00000000 	andeq	r0, r0, r0
    75c4:	54300000 	ldrtpl	r0, [r0], #-0
    75c8:	54480000 	strbpl	r0, [r8], #-0
    75cc:	00020000 	andeq	r0, r2, r0
    75d0:	54482875 	strbpl	r2, [r8], #-2165	; 0x875
    75d4:	546e0000 	strbtpl	r0, [lr], #-0
    75d8:	00060000 	andeq	r0, r6, r0
    75dc:	59049358 	stmdbpl	r4, {r3, r4, r6, r8, r9, ip, pc}
    75e0:	546e0493 	strbtpl	r0, [lr], #-1171	; 0x493
    75e4:	569a0000 	ldrpl	r0, [sl], r0
    75e8:	00030000 	andeq	r0, r3, r0
    75ec:	9a7da091 	bls	1f6f838 <_etext+0x1f68224>
    75f0:	c0000056 	andgt	r0, r0, r6, asr r0
    75f4:	06000056 			; <UNDEFINED> instruction: 0x06000056
    75f8:	04935800 	ldreq	r5, [r3], #2048	; 0x800
    75fc:	00049359 	andeq	r9, r4, r9, asr r3
    7600:	00000000 	andeq	r0, r0, r0
    7604:	30000000 	andcc	r0, r0, r0
    7608:	48000054 	stmdami	r0, {r2, r4, r6}
    760c:	02000054 	andeq	r0, r0, #84	; 0x54
    7610:	48307500 	ldmdami	r0!, {r8, sl, ip, sp, lr}
    7614:	6c000054 	stcvs	0, cr0, [r0], {84}	; 0x54
    7618:	03000054 	movweq	r0, #84	; 0x54
    761c:	7da09100 	stfvcd	f1, [r0]
    7620:	0000547a 	andeq	r5, r0, sl, ror r4
    7624:	0000569a 	muleq	r0, sl, r6
    7628:	98910003 	ldmls	r1, {r0, r1}
    762c:	00569a7d 	subseq	r9, r6, sp, ror sl
    7630:	00577a00 	subseq	r7, r7, r0, lsl #20
    7634:	91000300 	mrsls	r0, LR_irq
    7638:	577a7da0 	ldrbpl	r7, [sl, -r0, lsr #27]!
    763c:	57800000 	strpl	r0, [r0, r0]
    7640:	00030000 	andeq	r0, r3, r0
    7644:	007da07d 	rsbseq	sl, sp, sp, ror r0
    7648:	00000000 	andeq	r0, r0, r0
    764c:	30000000 	andcc	r0, r0, r0
    7650:	48000054 	stmdami	r0, {r2, r4, r6}
    7654:	06000054 			; <UNDEFINED> instruction: 0x06000054
    7658:	04935400 	ldreq	r5, [r3], #1024	; 0x400
    765c:	48049355 	stmdami	r4, {r0, r2, r4, r6, r8, r9, ip, pc}
    7660:	64000054 	strvs	r0, [r0], #-84	; 0x54
    7664:	03000054 	movweq	r0, #84	; 0x54
    7668:	7d989100 	ldfvcd	f1, [r8]
    766c:	0000547a 	andeq	r5, r0, sl, ror r4
    7670:	0000569a 	muleq	r0, sl, r6
    7674:	80910003 	addshi	r0, r1, r3
    7678:	00569a7e 	subseq	r9, r6, lr, ror sl
    767c:	00577a00 	subseq	r7, r7, r0, lsl #20
    7680:	91000300 	mrsls	r0, LR_irq
    7684:	577a7d98 			; <UNDEFINED> instruction: 0x577a7d98
    7688:	57800000 	strpl	r0, [r0, r0]
    768c:	00030000 	andeq	r0, r3, r0
    7690:	007d987d 	rsbseq	r9, sp, sp, ror r8
    7694:	00000000 	andeq	r0, r0, r0
    7698:	ec000000 	stc	0, cr0, [r0], {-0}
    769c:	fc000052 	stc2	0, cr0, [r0], {82}	; 0x52
    76a0:	02000052 	andeq	r0, r0, #82	; 0x52
    76a4:	309f3000 	addscc	r3, pc, r0
    76a8:	48000054 	stmdami	r0, {r2, r4, r6}
    76ac:	02000054 	andeq	r0, r0, #84	; 0x54
    76b0:	489f3000 	ldmmi	pc, {ip, sp}	; <UNPREDICTABLE>
    76b4:	9c000054 	stcls	0, cr0, [r0], {84}	; 0x54
    76b8:	01000054 	qaddeq	r0, r4, r0
    76bc:	549c5c00 	ldrpl	r5, [ip], #3072	; 0xc00
    76c0:	56aa0000 	strtpl	r0, [sl], r0
    76c4:	00030000 	andeq	r0, r3, r0
    76c8:	aa9f7f7c 	bge	fe7e74c0 <BootRAM+0xd757c61>
    76cc:	34000056 	strcc	r0, [r0], #-86	; 0x56
    76d0:	01000057 	qaddeq	r0, r7, r0
    76d4:	00005c00 	andeq	r5, r0, r0, lsl #24
    76d8:	00000000 	andeq	r0, r0, r0
    76dc:	52fc0000 	rscspl	r0, ip, #0
    76e0:	530a0000 	movwpl	r0, #40960	; 0xa000
    76e4:	00030000 	andeq	r0, r3, r0
    76e8:	0a9f0174 	beq	fe7c7cc0 <BootRAM+0xd738461>
    76ec:	1a000053 	bne	7840 <_etext+0x22c>
    76f0:	03000053 	movweq	r0, #83	; 0x53
    76f4:	9f027400 	svcls	0x00027400
    76f8:	0000531a 	andeq	r5, r0, sl, lsl r3
    76fc:	00005338 	andeq	r5, r0, r8, lsr r3
    7700:	03740003 	cmneq	r4, #3
    7704:	0053389f 			; <UNDEFINED> instruction: 0x0053389f
    7708:	00535600 	subseq	r5, r3, r0, lsl #12
    770c:	74000300 	strvc	r0, [r0], #-768	; 0x300
    7710:	53569f04 	cmppl	r6, #4, 30
    7714:	53700000 	cmnpl	r0, #0
    7718:	00030000 	andeq	r0, r3, r0
    771c:	709f0574 	addsvc	r0, pc, r4, ror r5	; <UNPREDICTABLE>
    7720:	88000053 	stmdahi	r0, {r0, r1, r4, r6}
    7724:	03000053 	movweq	r0, #83	; 0x53
    7728:	9f067400 	svcls	0x00067400
    772c:	00005388 	andeq	r5, r0, r8, lsl #7
    7730:	0000539c 	muleq	r0, ip, r3
    7734:	07740003 	ldrbeq	r0, [r4, -r3]!
    7738:	00539c9f 			; <UNDEFINED> instruction: 0x00539c9f
    773c:	0053a200 	subseq	sl, r3, r0, lsl #4
    7740:	74000300 	strvc	r0, [r0], #-768	; 0x300
    7744:	53a29f08 			; <UNDEFINED> instruction: 0x53a29f08
    7748:	53c00000 	bicpl	r0, r0, #0
    774c:	00010000 	andeq	r0, r1, r0
    7750:	00000054 	andeq	r0, r0, r4, asr r0
    7754:	00000000 	andeq	r0, r0, r0
    7758:	0052fc00 	subseq	pc, r2, r0, lsl #24
    775c:	00530a00 	subseq	r0, r3, r0, lsl #20
    7760:	74000900 	strvc	r0, [r0], #-2304	; 0x900
    7764:	f7019400 			; <UNDEFINED> instruction: 0xf7019400
    7768:	9f25f72c 	svcls	0x0025f72c
    776c:	0000530a 	andeq	r5, r0, sl, lsl #6
    7770:	0000531a 	andeq	r5, r0, sl, lsl r3
    7774:	01740010 	cmneq	r4, r0, lsl r0
    7778:	2cf70194 	ldfcse	f0, [r7], #592	; 0x250
    777c:	909125f7 			; <UNDEFINED> instruction: 0x909125f7
    7780:	2508f67d 	strcs	pc, [r8, #-1661]	; 0x67d
    7784:	531a9f21 	tstpl	sl, #33, 30	; 0x84
    7788:	53380000 	teqpl	r8, #0
    778c:	000d0000 	andeq	r0, sp, r0
    7790:	01940274 	orrseq	r0, r4, r4, ror r2
    7794:	25f72cf7 	ldrbcs	r2, [r7, #3319]!	; 0xcf7
    7798:	212506f5 	strdcs	r0, [r5, -r5]!
    779c:	0053389f 			; <UNDEFINED> instruction: 0x0053389f
    77a0:	00535600 	subseq	r5, r3, r0, lsl #12
    77a4:	74001000 	strvc	r1, [r0], #-0
    77a8:	f7019403 			; <UNDEFINED> instruction: 0xf7019403
    77ac:	9125f72c 	msrls	SP_abt, ip
    77b0:	08f67d80 	ldmeq	r6!, {r7, r8, sl, fp, ip, sp, lr}^
    77b4:	569f2125 	ldrpl	r2, [pc], r5, lsr #2
    77b8:	70000053 	andvc	r0, r0, r3, asr r0
    77bc:	10000053 	andne	r0, r0, r3, asr r0
    77c0:	94047400 	strls	r7, [r4], #-1024	; 0x400
    77c4:	f72cf701 			; <UNDEFINED> instruction: 0xf72cf701
    77c8:	7d889125 	stfvcd	f1, [r8, #148]	; 0x94
    77cc:	212508f6 	strdcs	r0, [r5, -r6]!
    77d0:	0053709f 			; <UNDEFINED> instruction: 0x0053709f
    77d4:	00538800 	subseq	r8, r3, r0, lsl #16
    77d8:	74000d00 	strvc	r0, [r0], #-3328	; 0xd00
    77dc:	f7019405 			; <UNDEFINED> instruction: 0xf7019405
    77e0:	f525f72c 			; <UNDEFINED> instruction: 0xf525f72c
    77e4:	9f21250a 	svcls	0x0021250a
    77e8:	00005388 	andeq	r5, r0, r8, lsl #7
    77ec:	0000539c 	muleq	r0, ip, r3
    77f0:	0674000d 	ldrbteq	r0, [r4], -sp
    77f4:	2cf70194 	ldfcse	f0, [r7], #592	; 0x250
    77f8:	08f525f7 	ldmeq	r5!, {r0, r1, r2, r4, r5, r6, r7, r8, sl, sp}^
    77fc:	9c9f2125 	ldflss	f2, [pc], {37}	; 0x25
    7800:	a2000053 	andge	r0, r0, #83	; 0x53
    7804:	0d000053 	stceq	0, cr0, [r0, #-332]	; 0xfffffeb4
    7808:	94077400 	strls	r7, [r7], #-1024	; 0x400
    780c:	f72cf701 			; <UNDEFINED> instruction: 0xf72cf701
    7810:	2502f525 	strcs	pc, [r2, #-1317]	; 0x525
    7814:	53a29f21 			; <UNDEFINED> instruction: 0x53a29f21
    7818:	53b60000 			; <UNDEFINED> instruction: 0x53b60000
    781c:	000d0000 	andeq	r0, sp, r0
    7820:	01947f74 	orrseq	r7, r4, r4, ror pc
    7824:	25f72cf7 	ldrbcs	r2, [r7, #3319]!	; 0xcf7
    7828:	212502f5 	strdcs	r0, [r5, -r5]!
    782c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    7830:	00000000 	andeq	r0, r0, r0
    7834:	00550600 	subseq	r0, r5, r0, lsl #12
    7838:	00566000 	subseq	r6, r6, r0
    783c:	75000300 	strvc	r0, [r0, #-768]	; 0x300
    7840:	00007f80 	andeq	r7, r0, r0, lsl #31
    7844:	00000000 	andeq	r0, r0, r0
    7848:	55060000 	strpl	r0, [r6, #-0]
    784c:	55180000 	ldrpl	r0, [r8, #-0]
    7850:	00060000 	andeq	r0, r6, r0
    7854:	51049350 	tstpl	r4, r0, asr r3
    7858:	55180493 	ldrpl	r0, [r8, #-1171]	; 0x493
    785c:	55720000 	ldrbpl	r0, [r2, #-0]!
    7860:	000c0000 	andeq	r0, ip, r0
    7864:	067d9091 			; <UNDEFINED> instruction: 0x067d9091
    7868:	00912433 	addseq	r2, r1, r3, lsr r4
    786c:	1ca00822 	stcne	8, cr0, [r0], #136	; 0x88
    7870:	00005572 	andeq	r5, r0, r2, ror r5
    7874:	000055ba 			; <UNDEFINED> instruction: 0x000055ba
    7878:	9091000c 	addsls	r0, r1, ip
    787c:	2433067d 	ldrtcs	r0, [r3], #-1661	; 0x67d
    7880:	08220077 	stmdaeq	r2!, {r0, r1, r2, r4, r5, r6}
    7884:	55ba1c80 	ldrpl	r1, [sl, #3200]!	; 0xc80
    7888:	56600000 	strbtpl	r0, [r0], -r0
    788c:	000c0000 	andeq	r0, ip, r0
    7890:	067d9091 			; <UNDEFINED> instruction: 0x067d9091
    7894:	00912433 	addseq	r2, r1, r3, lsr r4
    7898:	1ca00822 	stcne	8, cr0, [r0], #136	; 0x88
	...
    78a4:	00005506 	andeq	r5, r0, r6, lsl #10
    78a8:	000055b6 			; <UNDEFINED> instruction: 0x000055b6
    78ac:	93520006 	cmpls	r2, #6
    78b0:	04935304 	ldreq	r5, [r3], #772	; 0x304
    78b4:	000055b6 			; <UNDEFINED> instruction: 0x000055b6
    78b8:	000055ba 			; <UNDEFINED> instruction: 0x000055ba
    78bc:	0d7c000c 	ldcleq	0, cr0, [ip, #-48]!	; 0xffffffd0
    78c0:	24331a3f 	ldrtcs	r1, [r3], #-2623	; 0xa3f
    78c4:	08220077 	stmdaeq	r2!, {r0, r1, r2, r4, r5, r6}
    78c8:	55ba1c80 	ldrpl	r1, [sl, #3200]!	; 0xc80
    78cc:	56600000 	strbtpl	r0, [r0], -r0
    78d0:	000c0000 	andeq	r0, ip, r0
    78d4:	1a3f0d7c 	bne	fcaecc <_etext+0xfc38b8>
    78d8:	00912433 	addseq	r2, r1, r3, lsr r4
    78dc:	1ca00822 	stcne	8, cr0, [r0], #136	; 0x88
	...
    78e8:	00005506 	andeq	r5, r0, r6, lsl #10
    78ec:	00005576 	andeq	r5, r0, r6, ror r5
    78f0:	087c000c 	ldmdaeq	ip!, {r2, r3}^
    78f4:	24331a3f 	ldrtcs	r1, [r3], #-2623	; 0xa3f
    78f8:	08220091 	stmdaeq	r2!, {r0, r4, r7}
    78fc:	55761ca8 	ldrbpl	r1, [r6, #-3240]!	; 0xca8
    7900:	557a0000 	ldrbpl	r0, [sl, #-0]!
    7904:	000a0000 	andeq	r0, sl, r0
    7908:	24330074 	ldrtcs	r0, [r3], #-116	; 0x74
    790c:	08220091 	stmdaeq	r2!, {r0, r4, r7}
    7910:	557a1ca8 	ldrbpl	r1, [sl, #-3240]!	; 0xca8
    7914:	56600000 	strbtpl	r0, [r0], -r0
    7918:	000c0000 	andeq	r0, ip, r0
    791c:	1a3f087c 	bne	fc9b14 <_etext+0xfc2500>
    7920:	00912433 	addseq	r2, r1, r3, lsr r4
    7924:	1ca80822 	stcne	8, cr0, [r8], #136	; 0x88
	...
    7930:	00005506 	andeq	r5, r0, r6, lsl #10
    7934:	00005518 	andeq	r5, r0, r8, lsl r5
    7938:	00f50028 	rscseq	r0, r5, r8, lsr #32
    793c:	25f73125 	ldrbcs	r3, [r7, #293]!	; 0x125
    7940:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    7944:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    7948:	2500f521 	strcs	pc, [r0, #-1313]	; 0x521
    794c:	2525f737 	strcs	pc, [r5, #-1847]!	; 0x737
    7950:	2500f527 	strcs	pc, [r0, #-1319]	; 0x527
    7954:	1425f738 	strtne	pc, [r5], #-1848	; 0x738
    7958:	40231f14 	eormi	r1, r3, r4, lsl pc
    795c:	21251724 	teqcs	r5, r4, lsr #14
    7960:	55189f27 	ldrpl	r9, [r8, #-3879]	; 0xf27
    7964:	55720000 	ldrbpl	r0, [r2, #-0]!
    7968:	004c0000 	subeq	r0, ip, r0
    796c:	067d9091 			; <UNDEFINED> instruction: 0x067d9091
    7970:	00912433 	addseq	r2, r1, r3, lsr r4
    7974:	1ca00822 	stcne	8, cr0, [r0], #136	; 0x88
    7978:	312508f6 	strdcc	r0, [r5, -r6]!
    797c:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7980:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7984:	91212517 	teqls	r1, r7, lsl r5
    7988:	33067d90 	movwcc	r7, #28048	; 0x6d90
    798c:	22009124 	andcs	r9, r0, #36, 2
    7990:	f61ca008 			; <UNDEFINED> instruction: 0xf61ca008
    7994:	f7372508 			; <UNDEFINED> instruction: 0xf7372508
    7998:	91272525 	teqls	r7, r5, lsr #10
    799c:	33067d90 	movwcc	r7, #28048	; 0x6d90
    79a0:	22009124 	andcs	r9, r0, #36, 2
    79a4:	f61ca008 			; <UNDEFINED> instruction: 0xf61ca008
    79a8:	f7382508 			; <UNDEFINED> instruction: 0xf7382508
    79ac:	1f141425 	svcne	0x00141425
    79b0:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    79b4:	9f272125 	svcls	0x00272125
    79b8:	00005572 	andeq	r5, r0, r2, ror r5
    79bc:	000055ba 			; <UNDEFINED> instruction: 0x000055ba
    79c0:	9091004c 	addsls	r0, r1, ip, asr #32
    79c4:	2433067d 	ldrtcs	r0, [r3], #-1661	; 0x67d
    79c8:	08220077 	stmdaeq	r2!, {r0, r1, r2, r4, r5, r6}
    79cc:	08f61c80 	ldmeq	r6!, {r7, sl, fp, ip}^
    79d0:	25f73125 	ldrbcs	r3, [r7, #293]!	; 0x125
    79d4:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    79d8:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    79dc:	7d909121 	ldfvcd	f1, [r0, #132]	; 0x84
    79e0:	77243306 	strvc	r3, [r4, -r6, lsl #6]!
    79e4:	80082200 	andhi	r2, r8, r0, lsl #4
    79e8:	2508f61c 	strcs	pc, [r8, #-1564]	; 0x61c
    79ec:	2525f737 	strcs	pc, [r5, #-1847]!	; 0x737
    79f0:	7d909127 	ldfvcd	f1, [r0, #156]	; 0x9c
    79f4:	77243306 	strvc	r3, [r4, -r6, lsl #6]!
    79f8:	80082200 	andhi	r2, r8, r0, lsl #4
    79fc:	2508f61c 	strcs	pc, [r8, #-1564]	; 0x61c
    7a00:	1425f738 	strtne	pc, [r5], #-1848	; 0x738
    7a04:	40231f14 	eormi	r1, r3, r4, lsl pc
    7a08:	21251724 	teqcs	r5, r4, lsr #14
    7a0c:	55ba9f27 	ldrpl	r9, [sl, #3879]!	; 0xf27
    7a10:	56600000 	strbtpl	r0, [r0], -r0
    7a14:	004c0000 	subeq	r0, ip, r0
    7a18:	067d9091 			; <UNDEFINED> instruction: 0x067d9091
    7a1c:	00912433 	addseq	r2, r1, r3, lsr r4
    7a20:	1ca00822 	stcne	8, cr0, [r0], #136	; 0x88
    7a24:	312508f6 	strdcc	r0, [r5, -r6]!
    7a28:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7a2c:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7a30:	91212517 	teqls	r1, r7, lsl r5
    7a34:	33067d90 	movwcc	r7, #28048	; 0x6d90
    7a38:	22009124 	andcs	r9, r0, #36, 2
    7a3c:	f61ca008 			; <UNDEFINED> instruction: 0xf61ca008
    7a40:	f7372508 			; <UNDEFINED> instruction: 0xf7372508
    7a44:	91272525 	teqls	r7, r5, lsr #10
    7a48:	33067d90 	movwcc	r7, #28048	; 0x6d90
    7a4c:	22009124 	andcs	r9, r0, #36, 2
    7a50:	f61ca008 			; <UNDEFINED> instruction: 0xf61ca008
    7a54:	f7382508 			; <UNDEFINED> instruction: 0xf7382508
    7a58:	1f141425 	svcne	0x00141425
    7a5c:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    7a60:	9f272125 	svcls	0x00272125
	...
    7a6c:	00005506 	andeq	r5, r0, r6, lsl #10
    7a70:	000055b6 			; <UNDEFINED> instruction: 0x000055b6
    7a74:	02f50029 	rscseq	r0, r5, #41	; 0x29
    7a78:	25f74325 	ldrbcs	r4, [r7, #805]!	; 0x325
    7a7c:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    7a80:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    7a84:	2502f521 	strcs	pc, [r2, #-1313]	; 0x521
    7a88:	2525f736 	strcs	pc, [r5, #-1846]!	; 0x736
    7a8c:	2502f527 	strcs	pc, [r2, #-1319]	; 0x527
    7a90:	25f73d08 	ldrbcs	r3, [r7, #3336]!	; 0xd08
    7a94:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    7a98:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    7a9c:	b69f2721 	ldrlt	r2, [pc], r1, lsr #14
    7aa0:	ba000055 	blt	7bfc <_etext+0x5e8>
    7aa4:	4d000055 	stcmi	0, cr0, [r0, #-340]	; 0xfffffeac
    7aa8:	3f0d7c00 	svccc	0x000d7c00
    7aac:	7724331a 			; <UNDEFINED> instruction: 0x7724331a
    7ab0:	80082200 	andhi	r2, r8, r0, lsl #4
    7ab4:	2508f61c 	strcs	pc, [r8, #-1564]	; 0x61c
    7ab8:	1425f743 	strtne	pc, [r5], #-1859	; 0x743
    7abc:	40231f14 	eormi	r1, r3, r4, lsl pc
    7ac0:	21251724 	teqcs	r5, r4, lsr #14
    7ac4:	1a3f0d7c 	bne	fcb0bc <_etext+0xfc3aa8>
    7ac8:	00772433 	rsbseq	r2, r7, r3, lsr r4
    7acc:	1c800822 	stcne	8, cr0, [r0], {34}	; 0x22
    7ad0:	362508f6 			; <UNDEFINED> instruction: 0x362508f6
    7ad4:	272525f7 			; <UNDEFINED> instruction: 0x272525f7
    7ad8:	1a3f0d7c 	bne	fcb0d0 <_etext+0xfc3abc>
    7adc:	00772433 	rsbseq	r2, r7, r3, lsr r4
    7ae0:	1c800822 	stcne	8, cr0, [r0], {34}	; 0x22
    7ae4:	082508f6 	stmdaeq	r5!, {r1, r2, r4, r5, r6, r7, fp}
    7ae8:	1425f73d 	strtne	pc, [r5], #-1853	; 0x73d
    7aec:	40231f14 	eormi	r1, r3, r4, lsl pc
    7af0:	21251724 	teqcs	r5, r4, lsr #14
    7af4:	55ba9f27 	ldrpl	r9, [sl, #3879]!	; 0xf27
    7af8:	56600000 	strbtpl	r0, [r0], -r0
    7afc:	004d0000 	subeq	r0, sp, r0
    7b00:	1a3f0d7c 	bne	fcb0f8 <_etext+0xfc3ae4>
    7b04:	00912433 	addseq	r2, r1, r3, lsr r4
    7b08:	1ca00822 	stcne	8, cr0, [r0], #136	; 0x88
    7b0c:	432508f6 	teqmi	r5, #16121856	; 0xf60000
    7b10:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7b14:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7b18:	7c212517 	cfstr32vc	mvfx2, [r1], #-92	; 0xffffffa4
    7b1c:	331a3f0d 	tstcc	sl, #13, 30	; 0x34
    7b20:	22009124 	andcs	r9, r0, #36, 2
    7b24:	f61ca008 			; <UNDEFINED> instruction: 0xf61ca008
    7b28:	f7362508 			; <UNDEFINED> instruction: 0xf7362508
    7b2c:	7c272525 	cfstr32vc	mvfx2, [r7], #-148	; 0xffffff6c
    7b30:	331a3f0d 	tstcc	sl, #13, 30	; 0x34
    7b34:	22009124 	andcs	r9, r0, #36, 2
    7b38:	f61ca008 			; <UNDEFINED> instruction: 0xf61ca008
    7b3c:	3d082508 	cfstr32cc	mvfx2, [r8, #-32]	; 0xffffffe0
    7b40:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7b44:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7b48:	27212517 			; <UNDEFINED> instruction: 0x27212517
    7b4c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    7b50:	00000000 	andeq	r0, r0, r0
    7b54:	00544800 	subseq	r4, r4, r0, lsl #16
    7b58:	00547800 	subseq	r7, r4, r0, lsl #16
    7b5c:	f5003200 			; <UNDEFINED> instruction: 0xf5003200
    7b60:	2208250a 	andcs	r2, r8, #41943040	; 0x2800000
    7b64:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7b68:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7b6c:	f5212517 			; <UNDEFINED> instruction: 0xf5212517
    7b70:	f74c250a 			; <UNDEFINED> instruction: 0xf74c250a
    7b74:	1f141425 	svcne	0x00141425
    7b78:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    7b7c:	f5272125 			; <UNDEFINED> instruction: 0xf5272125
    7b80:	2708250a 	strcs	r2, [r8, -sl, lsl #10]
    7b84:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7b88:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7b8c:	27212517 			; <UNDEFINED> instruction: 0x27212517
    7b90:	0054789f 			; <UNDEFINED> instruction: 0x0054789f
    7b94:	00547a00 	subseq	r7, r4, r0, lsl #20
    7b98:	91003b00 	tstls	r0, r0, lsl #22
    7b9c:	08f67d80 	ldmeq	r6!, {r7, r8, sl, fp, ip, sp, lr}^
    7ba0:	f7220825 			; <UNDEFINED> instruction: 0xf7220825
    7ba4:	1f141425 	svcne	0x00141425
    7ba8:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    7bac:	80912125 	addshi	r2, r1, r5, lsr #2
    7bb0:	2508f67d 	strcs	pc, [r8, #-1661]	; 0x67d
    7bb4:	1425f74c 	strtne	pc, [r5], #-1868	; 0x74c
    7bb8:	40231f14 	eormi	r1, r3, r4, lsl pc
    7bbc:	21251724 	teqcs	r5, r4, lsr #14
    7bc0:	7d809127 	stfvcd	f1, [r0, #156]	; 0x9c
    7bc4:	082508f6 	stmdaeq	r5!, {r1, r2, r4, r5, r6, r7, fp}
    7bc8:	1425f727 	strtne	pc, [r5], #-1831	; 0x727
    7bcc:	40231f14 	eormi	r1, r3, r4, lsl pc
    7bd0:	21251724 	teqcs	r5, r4, lsr #14
    7bd4:	55069f27 	strpl	r9, [r6, #-3879]	; 0xf27
    7bd8:	56c40000 	strbpl	r0, [r4], r0
    7bdc:	00320000 	eorseq	r0, r2, r0
    7be0:	08250af5 	stmdaeq	r5!, {r0, r2, r4, r5, r6, r7, r9, fp}
    7be4:	1425f722 	strtne	pc, [r5], #-1826	; 0x722
    7be8:	40231f14 	eormi	r1, r3, r4, lsl pc
    7bec:	21251724 	teqcs	r5, r4, lsr #14
    7bf0:	4c250af5 	stcmi	10, cr0, [r5], #-980	; 0xfffffc2c
    7bf4:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7bf8:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7bfc:	27212517 			; <UNDEFINED> instruction: 0x27212517
    7c00:	08250af5 	stmdaeq	r5!, {r0, r2, r4, r5, r6, r7, r9, fp}
    7c04:	1425f727 	strtne	pc, [r5], #-1831	; 0x727
    7c08:	40231f14 	eormi	r1, r3, r4, lsl pc
    7c0c:	21251724 	teqcs	r5, r4, lsr #14
    7c10:	00009f27 	andeq	r9, r0, r7, lsr #30
    7c14:	00000000 	andeq	r0, r0, r0
    7c18:	54480000 	strbpl	r0, [r8], #-0
    7c1c:	546e0000 	strbtpl	r0, [lr], #-0
    7c20:	00310000 	eorseq	r0, r1, r0
    7c24:	422508f5 	eormi	r0, r5, #16056320	; 0xf50000
    7c28:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7c2c:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7c30:	f5212517 			; <UNDEFINED> instruction: 0xf5212517
    7c34:	f73e2508 			; <UNDEFINED> instruction: 0xf73e2508
    7c38:	1f141425 	svcne	0x00141425
    7c3c:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    7c40:	f5272125 			; <UNDEFINED> instruction: 0xf5272125
    7c44:	29082508 	stmdbcs	r8, {r3, r8, sl, sp}
    7c48:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7c4c:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7c50:	27212517 			; <UNDEFINED> instruction: 0x27212517
    7c54:	00546e9f 			; <UNDEFINED> instruction: 0x00546e9f
    7c58:	00547a00 	subseq	r7, r4, r0, lsl #20
    7c5c:	91003a00 	tstls	r0, r0, lsl #20
    7c60:	08f67da0 	ldmeq	r6!, {r5, r7, r8, sl, fp, ip, sp, lr}^
    7c64:	25f74225 	ldrbcs	r4, [r7, #549]!	; 0x225
    7c68:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    7c6c:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    7c70:	7da09121 	stfvcd	f1, [r0, #132]!	; 0x84
    7c74:	3e2508f6 	mcrcc	8, 1, r0, cr5, cr6, {7}
    7c78:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7c7c:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7c80:	27212517 			; <UNDEFINED> instruction: 0x27212517
    7c84:	f67da091 			; <UNDEFINED> instruction: 0xf67da091
    7c88:	29082508 	stmdbcs	r8, {r3, r8, sl, sp}
    7c8c:	141425f7 	ldrne	r2, [r4], #-1527	; 0x5f7
    7c90:	2440231f 	strbcs	r2, [r0], #-799	; 0x31f
    7c94:	27212517 			; <UNDEFINED> instruction: 0x27212517
    7c98:	0055069f 			; <UNDEFINED> instruction: 0x0055069f
    7c9c:	0056c000 	subseq	ip, r6, r0
    7ca0:	f5003100 			; <UNDEFINED> instruction: 0xf5003100
    7ca4:	f7422508 			; <UNDEFINED> instruction: 0xf7422508
    7ca8:	1f141425 	svcne	0x00141425
    7cac:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    7cb0:	08f52125 	ldmeq	r5!, {r0, r2, r5, r8, sp}^
    7cb4:	25f73e25 	ldrbcs	r3, [r7, #3621]!	; 0xe25
    7cb8:	231f1414 	tstcs	pc, #20, 8	; 0x14000000
    7cbc:	25172440 	ldrcs	r2, [r7, #-1088]	; 0x440
    7cc0:	08f52721 	ldmeq	r5!, {r0, r5, r8, r9, sl, sp}^
    7cc4:	f7290825 			; <UNDEFINED> instruction: 0xf7290825
    7cc8:	1f141425 	svcne	0x00141425
    7ccc:	17244023 	strne	r4, [r4, -r3, lsr #32]!
    7cd0:	9f272125 	svcls	0x00272125
	...
    7cdc:	00005448 	andeq	r5, r0, r8, asr #8
    7ce0:	00005464 	andeq	r5, r0, r4, ror #8
    7ce4:	08f50017 	ldmeq	r5!, {r0, r1, r2, r4}^
    7ce8:	98912025 	ldmls	r1, {r0, r2, r5, sp}
    7cec:	2508f67d 	strcs	pc, [r8, #-1661]	; 0x67d
    7cf0:	7da0911a 	stfvcd	f1, [r0, #104]!	; 0x68
    7cf4:	f52508f6 			; <UNDEFINED> instruction: 0xf52508f6
    7cf8:	271a2508 	ldrcs	r2, [sl, -r8, lsl #10]
    7cfc:	0055069f 			; <UNDEFINED> instruction: 0x0055069f
    7d00:	0056c000 	subseq	ip, r6, r0
    7d04:	f5001700 			; <UNDEFINED> instruction: 0xf5001700
    7d08:	91202508 	teqls	r0, r8, lsl #10
    7d0c:	08f67d98 	ldmeq	r6!, {r3, r4, r7, r8, sl, fp, ip, sp, lr}^
    7d10:	a0911a25 	addsge	r1, r1, r5, lsr #20
    7d14:	2508f67d 	strcs	pc, [r8, #-1661]	; 0x67d
    7d18:	1a2508f5 	bne	94a0f4 <_etext+0x942ae0>
    7d1c:	00009f27 	andeq	r9, r0, r7, lsr #30
    7d20:	00000000 	andeq	r0, r0, r0
    7d24:	56900000 	ldrpl	r0, [r0], r0
    7d28:	56a60000 	strtpl	r0, [r6], r0
    7d2c:	00060000 	andeq	r0, r6, r0
    7d30:	51049350 	tstpl	r4, r0, asr r3
    7d34:	00000493 	muleq	r0, r3, r4
    7d38:	00000000 	andeq	r0, r0, r0
    7d3c:	54480000 	strbpl	r0, [r8], #-0
    7d40:	54680000 	strbtpl	r0, [r8], #-0
    7d44:	00200000 	eoreq	r0, r0, r0
    7d48:	f67d8891 			; <UNDEFINED> instruction: 0xf67d8891
    7d4c:	80912508 	addshi	r2, r1, r8, lsl #10
    7d50:	2508f67d 	strcs	pc, [r8, #-1661]	; 0x67d
    7d54:	250af527 	strcs	pc, [sl, #-1319]	; 0x527
    7d58:	7d88911a 	stfvcd	f1, [r8, #104]	; 0x68
    7d5c:	912508f6 	strdls	r0, [r5, -r6]!
    7d60:	08f67d80 	ldmeq	r6!, {r7, r8, sl, fp, ip, sp, lr}^
    7d64:	9f271a25 	svcls	0x00271a25
    7d68:	00005690 	muleq	r0, r0, r6
    7d6c:	000056c4 	andeq	r5, r0, r4, asr #13
    7d70:	88910020 	ldmhi	r1, {r5}
    7d74:	2508f67d 	strcs	pc, [r8, #-1661]	; 0x67d
    7d78:	f67d8091 			; <UNDEFINED> instruction: 0xf67d8091
    7d7c:	f5272508 			; <UNDEFINED> instruction: 0xf5272508
    7d80:	911a250a 	tstls	sl, sl, lsl #10
    7d84:	08f67d88 	ldmeq	r6!, {r3, r7, r8, sl, fp, ip, sp, lr}^
    7d88:	7d809125 	stfvcd	f1, [r0, #148]	; 0x94
    7d8c:	1a2508f6 	bne	94a16c <_etext+0x942b58>
    7d90:	00009f27 	andeq	r9, r0, r7, lsr #30
    7d94:	00000000 	andeq	r0, r0, r0
    7d98:	54480000 	strbpl	r0, [r8], #-0
    7d9c:	544c0000 	strbpl	r0, [ip], #-0
    7da0:	00060000 	andeq	r0, r6, r0
    7da4:	55049354 	strpl	r9, [r4, #-852]	; 0x354
    7da8:	569a0493 			; <UNDEFINED> instruction: 0x569a0493
    7dac:	56b40000 	ldrtpl	r0, [r4], r0
    7db0:	00060000 	andeq	r0, r6, r0
    7db4:	55049354 	strpl	r9, [r4, #-852]	; 0x354
    7db8:	00000493 	muleq	r0, r3, r4
    7dbc:	00000000 	andeq	r0, r0, r0
    7dc0:	54480000 	strbpl	r0, [r8], #-0
    7dc4:	547a0000 	ldrbtpl	r0, [sl], #-0
    7dc8:	00020000 	andeq	r0, r2, r0
    7dcc:	55069f42 	strpl	r9, [r6, #-3906]	; 0xf42
    7dd0:	57800000 	strpl	r0, [r0, r0]
    7dd4:	00020000 	andeq	r0, r2, r0
    7dd8:	00009f42 	andeq	r9, r0, r2, asr #30
    7ddc:	00000000 	andeq	r0, r0, r0
    7de0:	54480000 	strbpl	r0, [r8], #-0
    7de4:	546e0000 	strbtpl	r0, [lr], #-0
    7de8:	00060000 	andeq	r0, r6, r0
    7dec:	59049358 	stmdbpl	r4, {r3, r4, r6, r8, r9, ip, pc}
    7df0:	546e0493 	strbtpl	r0, [lr], #-1171	; 0x493
    7df4:	547a0000 	ldrbtpl	r0, [sl], #-0
    7df8:	00030000 	andeq	r0, r3, r0
    7dfc:	067da091 			; <UNDEFINED> instruction: 0x067da091
    7e00:	c0000055 	andgt	r0, r0, r5, asr r0
    7e04:	06000056 			; <UNDEFINED> instruction: 0x06000056
    7e08:	04935800 	ldreq	r5, [r3], #2048	; 0x800
    7e0c:	00049359 	andeq	r9, r4, r9, asr r3
    7e10:	00000000 	andeq	r0, r0, r0
    7e14:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
    7e18:	7a000054 	bvc	7f70 <_etext+0x95c>
    7e1c:	02000054 	andeq	r0, r0, #84	; 0x54
    7e20:	069f3e00 	ldreq	r3, [pc], r0, lsl #28
    7e24:	80000055 	andhi	r0, r0, r5, asr r0
    7e28:	02000057 	andeq	r0, r0, #87	; 0x57
    7e2c:	009f3e00 	addseq	r3, pc, r0, lsl #28
    7e30:	00000000 	andeq	r0, r0, r0
    7e34:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
    7e38:	7a000054 	bvc	7f90 <_etext+0x97c>
    7e3c:	03000054 	movweq	r0, #84	; 0x54
    7e40:	9f290800 	svcls	0x00290800
    7e44:	00005506 	andeq	r5, r0, r6, lsl #10
    7e48:	00005780 	andeq	r5, r0, r0, lsl #15
    7e4c:	29080003 	stmdbcs	r8, {r0, r1}
    7e50:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    7e54:	00000000 	andeq	r0, r0, r0
    7e58:	00544800 	subseq	r4, r4, r0, lsl #16
    7e5c:	00547a00 	subseq	r7, r4, r0, lsl #20
    7e60:	31000200 	mrscc	r0, R8_usr
    7e64:	0055069f 			; <UNDEFINED> instruction: 0x0055069f
    7e68:	00578000 	subseq	r8, r7, r0
    7e6c:	31000200 	mrscc	r0, R8_usr
    7e70:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    7e74:	00000000 	andeq	r0, r0, r0
    7e78:	00544800 	subseq	r4, r4, r0, lsl #16
    7e7c:	00547a00 	subseq	r7, r4, r0, lsl #20
    7e80:	38000200 	stmdacc	r0, {r9}
    7e84:	0055069f 			; <UNDEFINED> instruction: 0x0055069f
    7e88:	00578000 	subseq	r8, r7, r0
    7e8c:	38000200 	stmdacc	r0, {r9}
    7e90:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    7e94:	00000000 	andeq	r0, r0, r0
    7e98:	00544800 	subseq	r4, r4, r0, lsl #16
    7e9c:	00547a00 	subseq	r7, r4, r0, lsl #20
    7ea0:	43000200 	movwmi	r0, #512	; 0x200
    7ea4:	0055069f 			; <UNDEFINED> instruction: 0x0055069f
    7ea8:	00578000 	subseq	r8, r7, r0
    7eac:	43000200 	movwmi	r0, #512	; 0x200
    7eb0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    7eb4:	00000000 	andeq	r0, r0, r0
    7eb8:	00544800 	subseq	r4, r4, r0, lsl #16
    7ebc:	00547a00 	subseq	r7, r4, r0, lsl #20
    7ec0:	08000300 	stmdaeq	r0, {r8, r9}
    7ec4:	55069f22 	strpl	r9, [r6, #-3874]	; 0xf22
    7ec8:	57800000 	strpl	r0, [r0, r0]
    7ecc:	00030000 	andeq	r0, r3, r0
    7ed0:	009f2208 	addseq	r2, pc, r8, lsl #4
    7ed4:	00000000 	andeq	r0, r0, r0
    7ed8:	48000000 	stmdami	r0, {}	; <UNPREDICTABLE>
    7edc:	78000054 	stmdavc	r0, {r2, r4, r6}
    7ee0:	06000054 			; <UNDEFINED> instruction: 0x06000054
    7ee4:	04935a00 	ldreq	r5, [r3], #2560	; 0xa00
    7ee8:	7804935b 	stmdavc	r4, {r0, r1, r3, r4, r6, r8, r9, ip, pc}
    7eec:	7a000054 	bvc	8044 <_etext+0xa30>
    7ef0:	03000054 	movweq	r0, #84	; 0x54
    7ef4:	7d809100 	stfvcd	f1, [r0]
    7ef8:	00005506 	andeq	r5, r0, r6, lsl #10
    7efc:	000056c4 	andeq	r5, r0, r4, asr #13
    7f00:	935a0006 	cmpls	sl, #6
    7f04:	04935b04 	ldreq	r5, [r3], #2820	; 0xb04
	...
    7f10:	00005448 	andeq	r5, r0, r8, asr #8
    7f14:	0000547a 	andeq	r5, r0, sl, ror r4
    7f18:	9f4c0002 	svcls	0x004c0002
    7f1c:	00005506 	andeq	r5, r0, r6, lsl #10
    7f20:	00005780 	andeq	r5, r0, r0, lsl #15
    7f24:	9f4c0002 	svcls	0x004c0002
	...
    7f30:	00005448 	andeq	r5, r0, r8, asr #8
    7f34:	0000547a 	andeq	r5, r0, sl, ror r4
    7f38:	3d080003 	stccc	0, cr0, [r8, #-12]
    7f3c:	0055069f 			; <UNDEFINED> instruction: 0x0055069f
    7f40:	00578000 	subseq	r8, r7, r0
    7f44:	08000300 	stmdaeq	r0, {r8, r9}
    7f48:	00009f3d 	andeq	r9, r0, sp, lsr pc
    7f4c:	00000000 	andeq	r0, r0, r0
    7f50:	54480000 	strbpl	r0, [r8], #-0
    7f54:	547a0000 	ldrbtpl	r0, [sl], #-0
    7f58:	00030000 	andeq	r0, r3, r0
    7f5c:	069f2708 	ldreq	r2, [pc], r8, lsl #14
    7f60:	80000055 	andhi	r0, r0, r5, asr r0
    7f64:	03000057 	movweq	r0, #87	; 0x57
    7f68:	9f270800 	svcls	0x00270800
	...
    7f74:	00005780 	andeq	r5, r0, r0, lsl #15
    7f78:	00005790 	muleq	r0, r0, r7
    7f7c:	90500001 	subsls	r0, r0, r1
    7f80:	08000057 	stmdaeq	r0, {r0, r1, r2, r4, r6}
    7f84:	01000058 	qaddeq	r0, r8, r0
    7f88:	00005a00 	andeq	r5, r0, r0, lsl #20
    7f8c:	00000000 	andeq	r0, r0, r0
    7f90:	57800000 	strpl	r0, [r0, r0]
    7f94:	57940000 	ldrpl	r0, [r4, r0]
    7f98:	00010000 	andeq	r0, r1, r0
    7f9c:	00579451 	subseq	r9, r7, r1, asr r4
    7fa0:	00580800 	subseq	r0, r8, r0, lsl #16
    7fa4:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    7fb0:	00005780 	andeq	r5, r0, r0, lsl #15
    7fb4:	00005792 	muleq	r0, r2, r7
    7fb8:	92520001 	subsls	r0, r2, #1
    7fbc:	a6000057 			; <UNDEFINED> instruction: 0xa6000057
    7fc0:	01000057 	qaddeq	r0, r7, r0
    7fc4:	57a65400 	strpl	r5, [r6, r0, lsl #8]!
    7fc8:	57dc0000 	ldrbpl	r0, [ip, r0]
    7fcc:	00040000 	andeq	r0, r4, r0
    7fd0:	9f5201f3 	svcls	0x005201f3
    7fd4:	000057dc 	ldrdeq	r5, [r0], -ip
    7fd8:	00005808 	andeq	r5, r0, r8, lsl #16
    7fdc:	00540001 	subseq	r0, r4, r1
    7fe0:	00000000 	andeq	r0, r0, r0
    7fe4:	98000000 	stmdals	r0, {}	; <UNPREDICTABLE>
    7fe8:	9c000057 	stcls	0, cr0, [r0], {87}	; 0x57
    7fec:	06000057 			; <UNDEFINED> instruction: 0x06000057
    7ff0:	08007400 	stmdaeq	r0, {sl, ip, sp, lr}
    7ff4:	9c9f1a7f 	vldmials	pc, {s2-s128}
    7ff8:	a8000057 	stmdage	r0, {r0, r1, r2, r4, r6}
    7ffc:	01000057 	qaddeq	r0, r7, r0
    8000:	57a85600 	strpl	r5, [r8, r0, lsl #12]!
    8004:	57dc0000 	ldrbpl	r0, [ip, r0]
    8008:	00070000 	andeq	r0, r7, r0
    800c:	085201f3 	ldmdaeq	r2, {r0, r1, r4, r5, r6, r7, r8}^
    8010:	dc9f1a7f 	vldmiale	pc, {s2-s128}
    8014:	08000057 	stmdaeq	r0, {r0, r1, r2, r4, r6}
    8018:	01000058 	qaddeq	r0, r8, r0
    801c:	00005600 	andeq	r5, r0, r0, lsl #12
    8020:	00000000 	andeq	r0, r0, r0
    8024:	57a40000 	strpl	r0, [r4, r0]!
    8028:	57aa0000 	strpl	r0, [sl, r0]!
    802c:	00070000 	andeq	r0, r7, r0
    8030:	33f70072 	mvnscc	r0, #114	; 0x72
    8034:	c29f25f7 	addsgt	r2, pc, #1035993088	; 0x3dc00000
    8038:	dc000057 	stcle	0, cr0, [r0], {87}	; 0x57
    803c:	0a000057 	beq	81a0 <_etext+0xb8c>
    8040:	00089e00 	andeq	r9, r8, r0, lsl #28
	...
    8050:	a4000000 	strge	r0, [r0], #-0
    8054:	aa000057 	bge	81b8 <_etext+0xba4>
    8058:	03000057 	movweq	r0, #87	; 0x57
    805c:	9f5e9100 	svcls	0x005e9100
    8060:	000057aa 	andeq	r5, r0, sl, lsr #15
    8064:	000057be 			; <UNDEFINED> instruction: 0x000057be
    8068:	5c910003 	ldcpl	0, cr0, [r1], {3}
    806c:	0057be9f 			; <UNDEFINED> instruction: 0x0057be9f
    8070:	0057c200 	subseq	ip, r7, r0, lsl #4
    8074:	91000300 	mrsls	r0, LR_irq
    8078:	57c29f5b 			; <UNDEFINED> instruction: 0x57c29f5b
    807c:	57c60000 	strbpl	r0, [r6, r0]
    8080:	00030000 	andeq	r0, r3, r0
    8084:	c69f5a91 			; <UNDEFINED> instruction: 0xc69f5a91
    8088:	ca000057 	bgt	81ec <_etext+0xbd8>
    808c:	03000057 	movweq	r0, #87	; 0x57
    8090:	9f599100 	svcls	0x00599100
    8094:	000057ca 	andeq	r5, r0, sl, asr #15
    8098:	000057ce 	andeq	r5, r0, lr, asr #15
    809c:	58910003 	ldmpl	r1, {r0, r1}
    80a0:	0057ce9f 			; <UNDEFINED> instruction: 0x0057ce9f
    80a4:	0057dc00 	subseq	sp, r7, r0, lsl #24
    80a8:	91000300 	mrsls	r0, LR_irq
    80ac:	00009f57 	andeq	r9, r0, r7, asr pc
    80b0:	00000000 	andeq	r0, r0, r0
    80b4:	58080000 	stmdapl	r8, {}	; <UNPREDICTABLE>
    80b8:	58220000 	stmdapl	r2!, {}	; <UNPREDICTABLE>
    80bc:	00010000 	andeq	r0, r1, r0
    80c0:	00582250 	subseq	r2, r8, r0, asr r2
    80c4:	005a9e00 	subseq	r9, sl, r0, lsl #28
    80c8:	91000200 	mrsls	r0, R8_usr
    80cc:	00000040 	andeq	r0, r0, r0, asr #32
    80d0:	00000000 	andeq	r0, r0, r0
    80d4:	00580800 	subseq	r0, r8, r0, lsl #16
    80d8:	00581a00 	subseq	r1, r8, r0, lsl #20
    80dc:	51000100 	mrspl	r0, (UNDEF: 16)
    80e0:	0000581a 	andeq	r5, r0, sl, lsl r8
    80e4:	00005858 	andeq	r5, r0, r8, asr r8
    80e8:	ac910003 	ldcge	0, cr0, [r1], {3}
    80ec:	0058587f 	subseq	r5, r8, pc, ror r8
    80f0:	0058ee00 	subseq	lr, r8, r0, lsl #28
    80f4:	51000100 	mrspl	r0, (UNDEF: 16)
    80f8:	00005914 	andeq	r5, r0, r4, lsl r9
    80fc:	000059f0 	strdeq	r5, [r0], -r0
    8100:	ac910003 	ldcge	0, cr0, [r1], {3}
    8104:	0059f07f 	subseq	pc, r9, pc, ror r0	; <UNPREDICTABLE>
    8108:	0059f600 	subseq	pc, r9, r0, lsl #12
    810c:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    8118:	00005808 	andeq	r5, r0, r8, lsl #16
    811c:	00005826 	andeq	r5, r0, r6, lsr #16
    8120:	26520001 	ldrbcs	r0, [r2], -r1
    8124:	2a000058 	bcs	828c <_etext+0xc78>
    8128:	04000058 	streq	r0, [r0], #-88	; 0x58
    812c:	5201f300 	andpl	pc, r1, #0, 6
    8130:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8134:	00000000 	andeq	r0, r0, r0
    8138:	00580800 	subseq	r0, r8, r0, lsl #16
    813c:	00582800 	subseq	r2, r8, r0, lsl #16
    8140:	53000100 	movwpl	r0, #256	; 0x100
    8144:	00005828 	andeq	r5, r0, r8, lsr #16
    8148:	0000582e 	andeq	r5, r0, lr, lsr #16
    814c:	2e510001 	cdpcs	0, 5, cr0, cr1, cr1, {0}
    8150:	58000058 	stmdapl	r0, {r3, r4, r6}
    8154:	03000058 	movweq	r0, #88	; 0x58
    8158:	7fa49100 	svcvc	0x00a49100
    815c:	00005914 	andeq	r5, r0, r4, lsl r9
    8160:	00005928 	andeq	r5, r0, r8, lsr #18
    8164:	28510001 	ldmdacs	r1, {r0}^
    8168:	d6000059 			; <UNDEFINED> instruction: 0xd6000059
    816c:	03000059 	movweq	r0, #89	; 0x59
    8170:	7fa49100 	svcvc	0x00a49100
    8174:	000059d6 	ldrdeq	r5, [r0], -r6
    8178:	000059e4 	andeq	r5, r0, r4, ror #19
    817c:	8008001b 	andhi	r0, r8, fp, lsl r0
    8180:	1c5201f3 	ldfnee	f0, [r2], {243}	; 0xf3
    8184:	244b4012 	strbcs	r4, [fp], #-18
    8188:	5301f322 	movwpl	pc, #4898	; 0x1322	; <UNPREDICTABLE>
    818c:	4b401416 	blmi	100d1ec <_etext+0x1005bd8>
    8190:	282d2224 	stmdacs	sp!, {r2, r5, r9, sp}
    8194:	13160001 	tstne	r6, #1
    8198:	0059e49f 			; <UNDEFINED> instruction: 0x0059e49f
    819c:	0059f600 	subseq	pc, r9, r0, lsl #12
    81a0:	91000300 	mrsls	r0, LR_irq
    81a4:	00007fa4 	andeq	r7, r0, r4, lsr #31
    81a8:	00000000 	andeq	r0, r0, r0
    81ac:	59e00000 	stmibpl	r0!, {}^	; <UNPREDICTABLE>
    81b0:	59e30000 	stmibpl	r3!, {}^	; <UNPREDICTABLE>
    81b4:	00010000 	andeq	r0, r1, r0
    81b8:	0059e35c 	subseq	lr, r9, ip, asr r3
    81bc:	0059f400 	subseq	pc, r9, r0, lsl #8
    81c0:	91000700 	tstls	r0, r0, lsl #14
    81c4:	23067fa8 	movwcs	r7, #28584	; 0x6fa8
    81c8:	00009f01 	andeq	r9, r0, r1, lsl #30
    81cc:	00000000 	andeq	r0, r0, r0
    81d0:	58620000 	stmdapl	r2!, {}^	; <UNPREDICTABLE>
    81d4:	586a0000 	stmdapl	sl!, {}^	; <UNPREDICTABLE>
    81d8:	00060000 	andeq	r0, r6, r0
    81dc:	53049352 	movwpl	r9, #17234	; 0x4352
    81e0:	586a0493 	stmdapl	sl!, {r0, r1, r4, r7, sl}^
    81e4:	58720000 	ldmdapl	r2!, {}^	; <UNPREDICTABLE>
    81e8:	00040000 	andeq	r0, r4, r0
    81ec:	067fb891 			; <UNDEFINED> instruction: 0x067fb891
    81f0:	00005872 	andeq	r5, r0, r2, ror r8
    81f4:	00005894 	muleq	r0, r4, r8
    81f8:	93520006 	cmpls	r2, #6
    81fc:	04935304 	ldreq	r5, [r3], #772	; 0x304
    8200:	00005894 	muleq	r0, r4, r8
    8204:	0000589a 	muleq	r0, sl, r8
    8208:	935a0006 	cmpls	sl, #6
    820c:	04935b04 	ldreq	r5, [r3], #2820	; 0xb04
    8210:	0000589a 	muleq	r0, sl, r8
    8214:	000058a0 	andeq	r5, r0, r0, lsr #17
    8218:	93540006 	cmpls	r4, #6
    821c:	04935504 	ldreq	r5, [r3], #1284	; 0x504
    8220:	000058a0 	andeq	r5, r0, r0, lsr #17
    8224:	000058ac 	andeq	r5, r0, ip, lsr #17
    8228:	93560006 	cmpls	r6, #6
    822c:	04935704 	ldreq	r5, [r3], #1796	; 0x704
    8230:	000058ac 	andeq	r5, r0, ip, lsr #17
    8234:	000058d0 	ldrdeq	r5, [r0], -r0
    8238:	93580006 	cmpls	r8, #6
    823c:	04935904 	ldreq	r5, [r3], #2308	; 0x904
	...
    8248:	00005862 	andeq	r5, r0, r2, ror #16
    824c:	00005872 	andeq	r5, r0, r2, ror r8
    8250:	06710003 	ldrbteq	r0, [r1], -r3
    8254:	0058729f 			; <UNDEFINED> instruction: 0x0058729f
    8258:	00589400 	subseq	r9, r8, r0, lsl #8
    825c:	71000300 	mrsvc	r0, LR_irq
    8260:	58949f05 	ldmpl	r4, {r0, r2, r8, r9, sl, fp, ip, pc}
    8264:	589a0000 	ldmpl	sl, {}	; <UNPREDICTABLE>
    8268:	00030000 	andeq	r0, r3, r0
    826c:	9a9f0371 	bls	fe7c9038 <BootRAM+0xd7397d9>
    8270:	a0000058 	andge	r0, r0, r8, asr r0
    8274:	03000058 	movweq	r0, #88	; 0x58
    8278:	9f027100 	svcls	0x00027100
    827c:	000058a0 	andeq	r5, r0, r0, lsr #17
    8280:	000058ac 	andeq	r5, r0, ip, lsr #17
    8284:	01710003 	cmneq	r1, r3
    8288:	0058ac9f 			; <UNDEFINED> instruction: 0x0058ac9f
    828c:	0058d000 	subseq	sp, r8, r0
    8290:	51000100 	mrspl	r0, (UNDEF: 16)
    8294:	000058d0 	ldrdeq	r5, [r0], -r0
    8298:	000058e2 	andeq	r5, r0, r2, ror #17
    829c:	7f710003 	svcvc	0x00710003
    82a0:	0058e29f 			; <UNDEFINED> instruction: 0x0058e29f
    82a4:	0058ee00 	subseq	lr, r8, r0, lsl #28
    82a8:	71000300 	mrsvc	r0, LR_irq
    82ac:	00009f77 	andeq	r9, r0, r7, ror pc
    82b0:	00000000 	andeq	r0, r0, r0
    82b4:	59e00000 	stmibpl	r0!, {}^	; <UNPREDICTABLE>
    82b8:	59e30000 	stmibpl	r3!, {}^	; <UNPREDICTABLE>
    82bc:	00010000 	andeq	r0, r1, r0
    82c0:	00000052 	andeq	r0, r0, r2, asr r0
    82c4:	00000000 	andeq	r0, r0, r0
    82c8:	0059e000 	subseq	lr, r9, r0
    82cc:	0059f600 	subseq	pc, r9, r0, lsl #12
    82d0:	91000300 	mrsls	r0, LR_irq
    82d4:	00009f47 	andeq	r9, r0, r7, asr #30
    82d8:	00000000 	andeq	r0, r0, r0
    82dc:	5a060000 	bpl	1882e4 <_etext+0x180cd0>
    82e0:	5a180000 	bpl	6082e8 <_etext+0x600cd4>
    82e4:	00060000 	andeq	r0, r6, r0
    82e8:	51049350 	tstpl	r4, r0, asr r3
    82ec:	5a180493 	bpl	609540 <_etext+0x601f2c>
    82f0:	5a200000 	bpl	8082f8 <_etext+0x800ce4>
    82f4:	00060000 	andeq	r0, r6, r0
    82f8:	5b04935a 	blpl	12d068 <_etext+0x125a54>
    82fc:	5a200493 	bpl	809550 <_etext+0x801f3c>
    8300:	5a2c0000 	bpl	b08308 <_etext+0xb00cf4>
    8304:	00060000 	andeq	r0, r6, r0
    8308:	59049358 	stmdbpl	r4, {r3, r4, r6, r8, r9, ip, pc}
    830c:	5a2c0493 	bpl	b09560 <_etext+0xb01f4c>
    8310:	5a340000 	bpl	d08318 <_etext+0xd00d04>
    8314:	00060000 	andeq	r0, r6, r0
    8318:	57049356 	smlsdpl	r4, r6, r3, r9
    831c:	5a340493 	bpl	d09570 <_etext+0xd01f5c>
    8320:	5a3c0000 	bpl	f08328 <_etext+0xf00d14>
    8324:	00060000 	andeq	r0, r6, r0
    8328:	55049354 	strpl	r9, [r4, #-852]	; 0x354
    832c:	5a3c0493 	bpl	f09580 <_etext+0xf01f6c>
    8330:	5a6a0000 	bpl	1a88338 <_etext+0x1a80d24>
    8334:	00060000 	andeq	r0, r6, r0
    8338:	51049350 	tstpl	r4, r0, asr r3
    833c:	5a740493 	bpl	1d09590 <_etext+0x1d01f7c>
    8340:	5a9e0000 	bpl	fe788348 <BootRAM+0xd6f8ae9>
    8344:	000b0000 	andeq	r0, fp, r0
    8348:	f67f8891 			; <UNDEFINED> instruction: 0xf67f8891
    834c:	f7382508 			; <UNDEFINED> instruction: 0xf7382508
    8350:	009f2525 	addseq	r2, pc, r5, lsr #10
    8354:	00000000 	andeq	r0, r0, r0
    8358:	06000000 	streq	r0, [r0], -r0
    835c:	1800005a 	stmdane	r0, {r1, r3, r4, r6}
    8360:	0300005a 	movweq	r0, #90	; 0x5a
    8364:	9f4e9100 	svcls	0x004e9100
    8368:	00005a18 	andeq	r5, r0, r8, lsl sl
    836c:	00005a20 	andeq	r5, r0, r0, lsr #20
    8370:	4d910003 	ldcmi	0, cr0, [r1, #12]
    8374:	005a209f 			; <UNDEFINED> instruction: 0x005a209f
    8378:	005a2c00 	subseq	r2, sl, r0, lsl #24
    837c:	91000300 	mrsls	r0, LR_irq
    8380:	5a2c9f4c 	bpl	b300b8 <_etext+0xb28aa4>
    8384:	5a340000 	bpl	d0838c <_etext+0xd00d78>
    8388:	00030000 	andeq	r0, r3, r0
    838c:	349f4b91 	ldrcc	r4, [pc], #2961	; 8394 <_etext+0xd80>
    8390:	3c00005a 	stccc	0, cr0, [r0], {90}	; 0x5a
    8394:	0300005a 	movweq	r0, #90	; 0x5a
    8398:	9f4a9100 	svcls	0x004a9100
    839c:	00005a3c 	andeq	r5, r0, ip, lsr sl
    83a0:	00005a74 	andeq	r5, r0, r4, ror sl
    83a4:	49910003 	ldmibmi	r1, {r0, r1}
    83a8:	005a749f 			; <UNDEFINED> instruction: 0x005a749f
    83ac:	005a9e00 	subseq	r9, sl, r0, lsl #28
    83b0:	91000300 	mrsls	r0, LR_irq
    83b4:	00009f47 	andeq	r9, r0, r7, asr #30
    83b8:	00000000 	andeq	r0, r0, r0
    83bc:	5ae40000 	bpl	ff9083c4 <BootRAM+0xe878b65>
    83c0:	5af40000 	bpl	ffd083c8 <BootRAM+0xec78b69>
    83c4:	00010000 	andeq	r0, r1, r0
    83c8:	005af450 	subseq	pc, sl, r0, asr r4	; <UNPREDICTABLE>
    83cc:	005c1600 	subseq	r1, ip, r0, lsl #12
    83d0:	57000100 	strpl	r0, [r0, -r0, lsl #2]
    83d4:	00005c16 	andeq	r5, r0, r6, lsl ip
    83d8:	00005c3c 	andeq	r5, r0, ip, lsr ip
    83dc:	01f30004 	mvnseq	r0, r4
    83e0:	00009f50 	andeq	r9, r0, r0, asr pc
    83e4:	00000000 	andeq	r0, r0, r0
    83e8:	5ae40000 	bpl	ff9083f0 <BootRAM+0xe878b91>
    83ec:	5af00000 	bpl	ffc083f4 <BootRAM+0xeb78b95>
    83f0:	00010000 	andeq	r0, r1, r0
    83f4:	005af051 	subseq	pc, sl, r1, asr r0	; <UNPREDICTABLE>
    83f8:	005c1600 	subseq	r1, ip, r0, lsl #12
    83fc:	91000300 	mrsls	r0, LR_irq
    8400:	5c167d9c 	ldcpl	13, cr7, [r6], {156}	; 0x9c
    8404:	5c3c0000 	ldcpl	0, cr0, [ip], #-0
    8408:	00030000 	andeq	r0, r3, r0
    840c:	007d9c7d 	rsbseq	r9, sp, sp, ror ip
    8410:	00000000 	andeq	r0, r0, r0
    8414:	e4000000 	str	r0, [r0], #-0
    8418:	f600005a 			; <UNDEFINED> instruction: 0xf600005a
    841c:	0100005a 	qaddeq	r0, sl, r0
    8420:	5af65200 	bpl	ffd9cc28 <BootRAM+0xed0d3c9>
    8424:	5c3c0000 	ldcpl	0, cr0, [ip], #-0
    8428:	00040000 	andeq	r0, r4, r0
    842c:	9f5201f3 	svcls	0x005201f3
	...
    8438:	00005b10 	andeq	r5, r0, r0, lsl fp
    843c:	00005c16 	andeq	r5, r0, r6, lsl ip
    8440:	80910004 	addshi	r0, r1, r4
    8444:	5c169f7f 	ldcpl	15, cr9, [r6], {127}	; 0x7f
    8448:	5c3c0000 	ldcpl	0, cr0, [ip], #-0
    844c:	00040000 	andeq	r0, r4, r0
    8450:	9f7f807d 	svcls	0x007f807d
	...
    845c:	00005aea 	andeq	r5, r0, sl, ror #21
    8460:	00005af4 	strdeq	r5, [r0], -r4
    8464:	80910003 	addshi	r0, r1, r3
    8468:	005af47f 	subseq	pc, sl, pc, ror r4	; <UNPREDICTABLE>
    846c:	005af900 	subseq	pc, sl, r0, lsl #18
    8470:	70000200 	andvc	r0, r0, r0, lsl #4
    8474:	005af900 	subseq	pc, sl, r0, lsl #18
    8478:	005b0200 	subseq	r0, fp, r0, lsl #4
    847c:	91000300 	mrsls	r0, LR_irq
    8480:	5b027f80 	blpl	a8288 <_etext+0xa0c74>
    8484:	5b050000 	blpl	14848c <_etext+0x140e78>
    8488:	00020000 	andeq	r0, r2, r0
    848c:	5b050070 	blpl	148654 <_etext+0x141040>
    8490:	5c160000 	ldcpl	0, cr0, [r6], {-0}
    8494:	00030000 	andeq	r0, r3, r0
    8498:	167f8091 			; <UNDEFINED> instruction: 0x167f8091
    849c:	3c00005c 	stccc	0, cr0, [r0], {92}	; 0x5c
    84a0:	0300005c 	movweq	r0, #92	; 0x5c
    84a4:	7f807d00 	svcvc	0x00807d00
	...
    84b0:	00005b64 	andeq	r5, r0, r4, ror #22
    84b4:	00005c10 	andeq	r5, r0, r0, lsl ip
    84b8:	9f310002 	svcls	0x00310002
	...
    84c4:	00005b64 	andeq	r5, r0, r4, ror #22
    84c8:	00005c10 	andeq	r5, r0, r0, lsl ip
    84cc:	9f300002 	svcls	0x00300002
	...
    84d8:	00005b64 	andeq	r5, r0, r4, ror #22
    84dc:	00005b82 	andeq	r5, r0, r2, lsl #23
    84e0:	84080003 	strhi	r0, [r8], #-3
    84e4:	005b829f 			; <UNDEFINED> instruction: 0x005b829f
    84e8:	005bb200 	subseq	fp, fp, r0, lsl #4
    84ec:	54000100 	strpl	r0, [r0], #-256	; 0x100
	...
    84f8:	00005b64 	andeq	r5, r0, r4, ror #22
    84fc:	00005c10 	andeq	r5, r0, r0, lsl ip
    8500:	9f310014 	svcls	0x00310014
    8504:	9f300193 	svcls	0x00300193
    8508:	9f300193 	svcls	0x00300193
    850c:	9f300193 	svcls	0x00300193
    8510:	9f300193 	svcls	0x00300193
    8514:	00000193 	muleq	r0, r3, r1
    8518:	00000000 	andeq	r0, r0, r0
    851c:	5b760000 	blpl	1d88524 <_etext+0x1d80f10>
    8520:	5bb40000 	blpl	fed08528 <BootRAM+0xdc78cc9>
    8524:	00010000 	andeq	r0, r1, r0
    8528:	00000055 	andeq	r0, r0, r5, asr r0
	...
    8538:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8544:	01f30004 	mvnseq	r0, r4
    8548:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8558:	00010000 	andeq	r0, r1, r0
    855c:	00000050 	andeq	r0, r0, r0, asr r0
    8560:	00000000 	andeq	r0, r0, r0
    8564:	f3000400 	vshl.u8	d0, d0, d0
    8568:	009f5001 	addseq	r5, pc, r1
	...
    8578:	01000000 	mrseq	r0, (UNDEF: 0)
    857c:	00005000 	andeq	r5, r0, r0
    8580:	00000000 	andeq	r0, r0, r0
    8584:	00040000 	andeq	r0, r4, r0
    8588:	9f5001f3 	svcls	0x005001f3
	...
    859c:	00510001 	subseq	r0, r1, r1
    85a0:	00000000 	andeq	r0, r0, r0
    85a4:	04000000 	streq	r0, [r0], #-0
    85a8:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    85ac:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    85bc:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    85c8:	01f30004 	mvnseq	r0, r4
    85cc:	00009f50 	andeq	r9, r0, r0, asr pc
    85d0:	00000000 	andeq	r0, r0, r0
    85d4:	5c3c0000 	ldcpl	0, cr0, [ip], #-0
    85d8:	5c3e0000 	ldcpl	0, cr0, [lr], #-0
    85dc:	00010000 	andeq	r0, r1, r0
    85e0:	005c3e50 	subseq	r3, ip, r0, asr lr
    85e4:	005c6600 	subseq	r6, ip, r0, lsl #12
    85e8:	f3000400 	vshl.u8	d0, d0, d0
    85ec:	009f5001 	addseq	r5, pc, r1
	...
    85fc:	01000000 	mrseq	r0, (UNDEF: 0)
    8600:	00005000 	andeq	r5, r0, r0
    8604:	00000000 	andeq	r0, r0, r0
    8608:	00040000 	andeq	r0, r4, r0
    860c:	9f5001f3 	svcls	0x005001f3
	...
    8620:	00500001 	subseq	r0, r0, r1
    8624:	00000000 	andeq	r0, r0, r0
    8628:	04000000 	streq	r0, [r0], #-0
    862c:	5001f300 	andpl	pc, r1, r0, lsl #6
    8630:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8640:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    864c:	01f30004 	mvnseq	r0, r4
    8650:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8660:	00010000 	andeq	r0, r1, r0
    8664:	00000050 	andeq	r0, r0, r0, asr r0
    8668:	00000000 	andeq	r0, r0, r0
    866c:	f3000400 	vshl.u8	d0, d0, d0
    8670:	009f5001 	addseq	r5, pc, r1
	...
    8680:	01000000 	mrseq	r0, (UNDEF: 0)
    8684:	00005000 	andeq	r5, r0, r0
    8688:	00000000 	andeq	r0, r0, r0
    868c:	00040000 	andeq	r0, r4, r0
    8690:	9f5001f3 	svcls	0x005001f3
	...
    86a4:	00730006 	rsbseq	r0, r3, r6
    86a8:	9f273008 	svcls	0x00273008
	...
    86b4:	00730009 	rsbseq	r0, r3, r9
    86b8:	08273008 	stmdaeq	r7!, {r3, ip, sp}
    86bc:	009f2730 	addseq	r2, pc, r0, lsr r7	; <UNPREDICTABLE>
    86c0:	00000000 	andeq	r0, r0, r0
    86c4:	66000000 	strvs	r0, [r0], -r0
    86c8:	6800005c 	stmdavs	r0, {r2, r3, r4, r6}
    86cc:	0100005c 	qaddeq	r0, ip, r0
    86d0:	5c685000 	stclpl	0, cr5, [r8], #-0
    86d4:	5c840000 	stcpl	0, cr0, [r4], {0}
    86d8:	00040000 	andeq	r0, r4, r0
    86dc:	9f5001f3 	svcls	0x005001f3
	...
    86e8:	00005c7c 	andeq	r5, r0, ip, ror ip
    86ec:	00005c80 	andeq	r5, r0, r0, lsl #25
    86f0:	00730007 	rsbseq	r0, r3, r7
    86f4:	2730000a 	ldrcs	r0, [r0, -sl]!
    86f8:	005c809f 			; <UNDEFINED> instruction: 0x005c809f
    86fc:	005c8400 	subseq	r8, ip, r0, lsl #8
    8700:	73000b00 	movwvc	r0, #2816	; 0xb00
    8704:	30000a00 	andcc	r0, r0, r0, lsl #20
    8708:	30000a27 	andcc	r0, r0, r7, lsr #20
    870c:	00009f27 	andeq	r9, r0, r7, lsr #30
	...
    871c:	00010000 	andeq	r0, r1, r0
    8720:	00000050 	andeq	r0, r0, r0, asr r0
    8724:	00000000 	andeq	r0, r0, r0
    8728:	f3000400 	vshl.u8	d0, d0, d0
    872c:	009f5001 	addseq	r5, pc, r1
	...
    873c:	01000000 	mrseq	r0, (UNDEF: 0)
    8740:	00005000 	andeq	r5, r0, r0
    8744:	00000000 	andeq	r0, r0, r0
    8748:	00040000 	andeq	r0, r4, r0
    874c:	9f5001f3 	svcls	0x005001f3
	...
    8758:	00005c84 	andeq	r5, r0, r4, lsl #25
    875c:	00005c86 	andeq	r5, r0, r6, lsl #25
    8760:	86500001 	ldrbhi	r0, [r0], -r1
    8764:	a000005c 	andge	r0, r0, ip, asr r0
    8768:	0400005c 	streq	r0, [r0], #-92	; 0x5c
    876c:	5001f300 	andpl	pc, r1, r0, lsl #6
    8770:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8780:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    878c:	01f30004 	mvnseq	r0, r4
    8790:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    87a0:	00010000 	andeq	r0, r1, r0
    87a4:	00000050 	andeq	r0, r0, r0, asr r0
    87a8:	00000000 	andeq	r0, r0, r0
    87ac:	f3000400 	vshl.u8	d0, d0, d0
    87b0:	009f5001 	addseq	r5, pc, r1
	...
    87c0:	01000000 	mrseq	r0, (UNDEF: 0)
    87c4:	00005000 	andeq	r5, r0, r0
    87c8:	00000000 	andeq	r0, r0, r0
    87cc:	00040000 	andeq	r0, r4, r0
    87d0:	9f5001f3 	svcls	0x005001f3
	...
    87e4:	00500001 	subseq	r0, r0, r1
    87e8:	00000000 	andeq	r0, r0, r0
    87ec:	04000000 	streq	r0, [r0], #-0
    87f0:	5001f300 	andpl	pc, r1, r0, lsl #6
    87f4:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8804:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8810:	01f30004 	mvnseq	r0, r4
    8814:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8824:	00010000 	andeq	r0, r1, r0
    8828:	00000050 	andeq	r0, r0, r0, asr r0
    882c:	00000000 	andeq	r0, r0, r0
    8830:	f3000400 	vshl.u8	d0, d0, d0
    8834:	009f5001 	addseq	r5, pc, r1
	...
    8844:	01000000 	mrseq	r0, (UNDEF: 0)
    8848:	00005000 	andeq	r5, r0, r0
    884c:	00000000 	andeq	r0, r0, r0
    8850:	00040000 	andeq	r0, r4, r0
    8854:	9f5001f3 	svcls	0x005001f3
	...
    8868:	00500001 	subseq	r0, r0, r1
    886c:	00000000 	andeq	r0, r0, r0
    8870:	04000000 	streq	r0, [r0], #-0
    8874:	5001f300 	andpl	pc, r1, r0, lsl #6
    8878:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8888:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8894:	01f30004 	mvnseq	r0, r4
    8898:	00009f50 	andeq	r9, r0, r0, asr pc
    889c:	00000000 	andeq	r0, r0, r0
    88a0:	5ca00000 	stcpl	0, cr0, [r0]
    88a4:	5ca20000 	stcpl	0, cr0, [r2]
    88a8:	00010000 	andeq	r0, r1, r0
    88ac:	005ca250 	subseq	sl, ip, r0, asr r2
    88b0:	005cc000 	subseq	ip, ip, r0
    88b4:	f3000400 	vshl.u8	d0, d0, d0
    88b8:	009f5001 	addseq	r5, pc, r1
    88bc:	00000000 	andeq	r0, r0, r0
    88c0:	c0000000 	andgt	r0, r0, r0
    88c4:	c200005c 	andgt	r0, r0, #92	; 0x5c
    88c8:	0100005c 	qaddeq	r0, ip, r0
    88cc:	5cc25000 	stclpl	0, cr5, [r2], {0}
    88d0:	5ce00000 	stclpl	0, cr0, [r0]
    88d4:	00040000 	andeq	r0, r4, r0
    88d8:	9f5001f3 	svcls	0x005001f3
	...
    88ec:	00500001 	subseq	r0, r0, r1
    88f0:	00000000 	andeq	r0, r0, r0
    88f4:	04000000 	streq	r0, [r0], #-0
    88f8:	5001f300 	andpl	pc, r1, r0, lsl #6
    88fc:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    890c:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    8918:	01f30004 	mvnseq	r0, r4
    891c:	00009f51 	andeq	r9, r0, r1, asr pc
	...
    892c:	00010000 	andeq	r0, r1, r0
    8930:	00000050 	andeq	r0, r0, r0, asr r0
    8934:	00000000 	andeq	r0, r0, r0
    8938:	f3000400 	vshl.u8	d0, d0, d0
    893c:	009f5001 	addseq	r5, pc, r1
	...
    894c:	01000000 	mrseq	r0, (UNDEF: 0)
    8950:	00005000 	andeq	r5, r0, r0
    8954:	00000000 	andeq	r0, r0, r0
    8958:	00040000 	andeq	r0, r4, r0
    895c:	9f5001f3 	svcls	0x005001f3
	...
    8970:	00510001 	subseq	r0, r1, r1
    8974:	00000000 	andeq	r0, r0, r0
    8978:	04000000 	streq	r0, [r0], #-0
    897c:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    8980:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8990:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    899c:	01f30004 	mvnseq	r0, r4
    89a0:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    89b0:	00010000 	andeq	r0, r1, r0
    89b4:	00000051 	andeq	r0, r0, r1, asr r0
    89b8:	00000000 	andeq	r0, r0, r0
    89bc:	f3000400 	vshl.u8	d0, d0, d0
    89c0:	009f5101 	addseq	r5, pc, r1, lsl #2
    89c4:	00000000 	andeq	r0, r0, r0
    89c8:	e0000000 	and	r0, r0, r0
    89cc:	ea00005c 	b	8b44 <_etext+0x1530>
    89d0:	0100005c 	qaddeq	r0, ip, r0
    89d4:	5cea5000 	stclpl	0, cr5, [sl]
    89d8:	5cfc0000 	ldclpl	0, cr0, [ip]
    89dc:	00040000 	andeq	r0, r4, r0
    89e0:	9f5001f3 	svcls	0x005001f3
	...
    89ec:	00005cfc 	strdeq	r5, [r0], -ip
    89f0:	00005d06 	andeq	r5, r0, r6, lsl #26
    89f4:	06500001 	ldrbeq	r0, [r0], -r1
    89f8:	1800005d 	stmdane	r0, {r0, r2, r3, r4, r6}
    89fc:	0400005d 	streq	r0, [r0], #-93	; 0x5d
    8a00:	5001f300 	andpl	pc, r1, r0, lsl #6
    8a04:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8a08:	00000000 	andeq	r0, r0, r0
    8a0c:	005d1800 	subseq	r1, sp, r0, lsl #16
    8a10:	005d2200 	subseq	r2, sp, r0, lsl #4
    8a14:	50000100 	andpl	r0, r0, r0, lsl #2
    8a18:	00005d22 	andeq	r5, r0, r2, lsr #26
    8a1c:	00005d34 	andeq	r5, r0, r4, lsr sp
    8a20:	01f30004 	mvnseq	r0, r4
    8a24:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8a34:	00010000 	andeq	r0, r1, r0
    8a38:	00000051 	andeq	r0, r0, r1, asr r0
    8a3c:	00000000 	andeq	r0, r0, r0
    8a40:	f3000400 	vshl.u8	d0, d0, d0
    8a44:	009f5101 	addseq	r5, pc, r1, lsl #2
    8a48:	00000000 	andeq	r0, r0, r0
    8a4c:	01000000 	mrseq	r0, (UNDEF: 0)
    8a50:	00005100 	andeq	r5, r0, r0, lsl #2
    8a54:	00000000 	andeq	r0, r0, r0
    8a58:	00040000 	andeq	r0, r4, r0
    8a5c:	9f5101f3 	svcls	0x005101f3
	...
    8a70:	00530001 	subseq	r0, r3, r1
    8a74:	00000000 	andeq	r0, r0, r0
    8a78:	01000000 	mrseq	r0, (UNDEF: 0)
    8a7c:	00005300 	andeq	r5, r0, r0, lsl #6
    8a80:	00000000 	andeq	r0, r0, r0
    8a84:	00010000 	andeq	r0, r1, r0
    8a88:	00000053 	andeq	r0, r0, r3, asr r0
    8a8c:	00000000 	andeq	r0, r0, r0
    8a90:	005d3400 	subseq	r3, sp, r0, lsl #8
    8a94:	005d4000 	subseq	r4, sp, r0
    8a98:	50000100 	andpl	r0, r0, r0, lsl #2
    8a9c:	00005d40 	andeq	r5, r0, r0, asr #26
    8aa0:	00005d74 	andeq	r5, r0, r4, ror sp
    8aa4:	01f30004 	mvnseq	r0, r4
    8aa8:	00009f50 	andeq	r9, r0, r0, asr pc
    8aac:	00000000 	andeq	r0, r0, r0
    8ab0:	5d340000 	ldcpl	0, cr0, [r4, #-0]
    8ab4:	5d620000 	stclpl	0, cr0, [r2, #-0]
    8ab8:	00010000 	andeq	r0, r1, r0
    8abc:	005d6251 	subseq	r6, sp, r1, asr r2
    8ac0:	005d7400 	subseq	r7, sp, r0, lsl #8
    8ac4:	f3000400 	vshl.u8	d0, d0, d0
    8ac8:	009f5101 	addseq	r5, pc, r1, lsl #2
    8acc:	00000000 	andeq	r0, r0, r0
    8ad0:	4c000000 	stcmi	0, cr0, [r0], {-0}
    8ad4:	5400005d 	strpl	r0, [r0], #-93	; 0x5d
    8ad8:	0100005d 	qaddeq	r0, sp, r0
    8adc:	5d545300 	ldclpl	3, cr5, [r4, #-0]
    8ae0:	5d560000 	ldclpl	0, cr0, [r6, #-0]
    8ae4:	00050000 	andeq	r0, r5, r0
    8ae8:	25350071 	ldrcs	r0, [r5, #-113]!	; 0x71
    8aec:	005d569f 			; <UNDEFINED> instruction: 0x005d569f
    8af0:	005d5800 	subseq	r5, sp, r0, lsl #16
    8af4:	53000100 	movwpl	r0, #256	; 0x100
    8af8:	00005d60 	andeq	r5, r0, r0, ror #26
    8afc:	00005d68 	andeq	r5, r0, r8, ror #26
    8b00:	00530001 	subseq	r0, r3, r1
	...
    8b10:	01000000 	mrseq	r0, (UNDEF: 0)
    8b14:	00005000 	andeq	r5, r0, r0
    8b18:	00000000 	andeq	r0, r0, r0
    8b1c:	00040000 	andeq	r0, r4, r0
    8b20:	9f5001f3 	svcls	0x005001f3
	...
    8b34:	00500001 	subseq	r0, r0, r1
    8b38:	00000000 	andeq	r0, r0, r0
    8b3c:	04000000 	streq	r0, [r0], #-0
    8b40:	5001f300 	andpl	pc, r1, r0, lsl #6
    8b44:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8b54:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8b60:	01f30004 	mvnseq	r0, r4
    8b64:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8b74:	00010000 	andeq	r0, r1, r0
    8b78:	00000051 	andeq	r0, r0, r1, asr r0
    8b7c:	00000000 	andeq	r0, r0, r0
    8b80:	f3000400 	vshl.u8	d0, d0, d0
    8b84:	009f5101 	addseq	r5, pc, r1, lsl #2
	...
    8b94:	01000000 	mrseq	r0, (UNDEF: 0)
    8b98:	00005200 	andeq	r5, r0, r0, lsl #4
    8b9c:	00000000 	andeq	r0, r0, r0
    8ba0:	00040000 	andeq	r0, r4, r0
    8ba4:	9f5201f3 	svcls	0x005201f3
	...
    8bb8:	00500001 	subseq	r0, r0, r1
    8bbc:	00000000 	andeq	r0, r0, r0
    8bc0:	04000000 	streq	r0, [r0], #-0
    8bc4:	5001f300 	andpl	pc, r1, r0, lsl #6
    8bc8:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8bd8:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    8be4:	01f30004 	mvnseq	r0, r4
    8be8:	00009f51 	andeq	r9, r0, r1, asr pc
	...
    8bf8:	00010000 	andeq	r0, r1, r0
    8bfc:	00000050 	andeq	r0, r0, r0, asr r0
    8c00:	00000000 	andeq	r0, r0, r0
    8c04:	f3000400 	vshl.u8	d0, d0, d0
    8c08:	009f5001 	addseq	r5, pc, r1
	...
    8c18:	01000000 	mrseq	r0, (UNDEF: 0)
    8c1c:	00005100 	andeq	r5, r0, r0, lsl #2
    8c20:	00000000 	andeq	r0, r0, r0
    8c24:	00040000 	andeq	r0, r4, r0
    8c28:	9f5101f3 	svcls	0x005101f3
	...
    8c3c:	00500001 	subseq	r0, r0, r1
    8c40:	00000000 	andeq	r0, r0, r0
    8c44:	04000000 	streq	r0, [r0], #-0
    8c48:	5001f300 	andpl	pc, r1, r0, lsl #6
    8c4c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8c5c:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8c68:	01f30004 	mvnseq	r0, r4
    8c6c:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8c7c:	00010000 	andeq	r0, r1, r0
    8c80:	00000050 	andeq	r0, r0, r0, asr r0
    8c84:	00000000 	andeq	r0, r0, r0
    8c88:	f3000400 	vshl.u8	d0, d0, d0
    8c8c:	009f5001 	addseq	r5, pc, r1
    8c90:	00000000 	andeq	r0, r0, r0
    8c94:	01000000 	mrseq	r0, (UNDEF: 0)
    8c98:	00005000 	andeq	r5, r0, r0
    8c9c:	00000000 	andeq	r0, r0, r0
    8ca0:	00040000 	andeq	r0, r4, r0
    8ca4:	9f5001f3 	svcls	0x005001f3
	...
    8cb0:	00500001 	subseq	r0, r0, r1
	...
    8cc0:	01000000 	mrseq	r0, (UNDEF: 0)
    8cc4:	00005100 	andeq	r5, r0, r0, lsl #2
    8cc8:	00000000 	andeq	r0, r0, r0
    8ccc:	00040000 	andeq	r0, r4, r0
    8cd0:	9f5101f3 	svcls	0x005101f3
	...
    8cdc:	00510001 	subseq	r0, r1, r1
    8ce0:	00000000 	andeq	r0, r0, r0
    8ce4:	04000000 	streq	r0, [r0], #-0
    8ce8:	5101f300 	mrspl	pc, SP_irq	; <UNPREDICTABLE>
    8cec:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8cf0:	00000000 	andeq	r0, r0, r0
    8cf4:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    8d08:	00520001 	subseq	r0, r2, r1
    8d0c:	00000000 	andeq	r0, r0, r0
    8d10:	04000000 	streq	r0, [r0], #-0
    8d14:	5201f300 	andpl	pc, r1, #0, 6
    8d18:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8d1c:	00000000 	andeq	r0, r0, r0
    8d20:	52000100 	andpl	r0, r0, #0, 2
	...
    8d34:	00510001 	subseq	r0, r1, r1
    8d38:	00000000 	andeq	r0, r0, r0
    8d3c:	01000000 	mrseq	r0, (UNDEF: 0)
    8d40:	00005100 	andeq	r5, r0, r0, lsl #2
	...
    8d50:	00010000 	andeq	r0, r1, r0
    8d54:	00000053 	andeq	r0, r0, r3, asr r0
    8d58:	00000000 	andeq	r0, r0, r0
    8d5c:	72000500 	andvc	r0, r0, #0, 10
    8d60:	9f253500 	svcls	0x00253500
	...
    8d6c:	00530001 	subseq	r0, r3, r1
    8d70:	00000000 	andeq	r0, r0, r0
    8d74:	01000000 	mrseq	r0, (UNDEF: 0)
    8d78:	00005300 	andeq	r5, r0, r0, lsl #6
	...
    8d88:	00010000 	andeq	r0, r1, r0
    8d8c:	00000053 	andeq	r0, r0, r3, asr r0
    8d90:	00000000 	andeq	r0, r0, r0
    8d94:	53000100 	movwpl	r0, #256	; 0x100
	...
    8da8:	00510001 	subseq	r0, r1, r1
    8dac:	00000000 	andeq	r0, r0, r0
    8db0:	05000000 	streq	r0, [r0, #-0]
    8db4:	35007200 	strcc	r7, [r0, #-512]	; 0x200
    8db8:	00009f25 	andeq	r9, r0, r5, lsr #30
    8dbc:	00000000 	andeq	r0, r0, r0
    8dc0:	00010000 	andeq	r0, r1, r0
    8dc4:	00000051 	andeq	r0, r0, r1, asr r0
    8dc8:	00000000 	andeq	r0, r0, r0
    8dcc:	51000100 	mrspl	r0, (UNDEF: 16)
	...
    8de0:	00500001 	subseq	r0, r0, r1
    8de4:	00000000 	andeq	r0, r0, r0
    8de8:	04000000 	streq	r0, [r0], #-0
    8dec:	5001f300 	andpl	pc, r1, r0, lsl #6
    8df0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    8df4:	00000000 	andeq	r0, r0, r0
    8df8:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8e04:	01f30004 	mvnseq	r0, r4
    8e08:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    8e18:	00010000 	andeq	r0, r1, r0
    8e1c:	00000051 	andeq	r0, r0, r1, asr r0
    8e20:	00000000 	andeq	r0, r0, r0
    8e24:	f3000400 	vshl.u8	d0, d0, d0
    8e28:	009f5101 	addseq	r5, pc, r1, lsl #2
    8e2c:	00000000 	andeq	r0, r0, r0
    8e30:	01000000 	mrseq	r0, (UNDEF: 0)
    8e34:	00005100 	andeq	r5, r0, r0, lsl #2
	...
    8e44:	00010000 	andeq	r0, r1, r0
    8e48:	00000052 	andeq	r0, r0, r2, asr r0
    8e4c:	00000000 	andeq	r0, r0, r0
    8e50:	f3000400 	vshl.u8	d0, d0, d0
    8e54:	009f5201 	addseq	r5, pc, r1, lsl #4
    8e58:	00000000 	andeq	r0, r0, r0
    8e5c:	01000000 	mrseq	r0, (UNDEF: 0)
    8e60:	00005200 	andeq	r5, r0, r0, lsl #4
	...
    8e70:	00010000 	andeq	r0, r1, r0
    8e74:	00000051 	andeq	r0, r0, r1, asr r0
	...
    8e84:	53000100 	movwpl	r0, #256	; 0x100
	...
    8e90:	00720005 	rsbseq	r0, r2, r5
    8e94:	009f2535 	addseq	r2, pc, r5, lsr r5	; <UNPREDICTABLE>
    8e98:	00000000 	andeq	r0, r0, r0
    8e9c:	01000000 	mrseq	r0, (UNDEF: 0)
    8ea0:	00005300 	andeq	r5, r0, r0, lsl #6
    8ea4:	00000000 	andeq	r0, r0, r0
    8ea8:	00010000 	andeq	r0, r1, r0
    8eac:	00000053 	andeq	r0, r0, r3, asr r0
	...
    8ebc:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    8ec8:	01f30004 	mvnseq	r0, r4
    8ecc:	00009f50 	andeq	r9, r0, r0, asr pc
    8ed0:	00000000 	andeq	r0, r0, r0
    8ed4:	00010000 	andeq	r0, r1, r0
    8ed8:	00000050 	andeq	r0, r0, r0, asr r0
    8edc:	00000000 	andeq	r0, r0, r0
    8ee0:	f3000400 	vshl.u8	d0, d0, d0
    8ee4:	009f5001 	addseq	r5, pc, r1
	...
    8ef4:	01000000 	mrseq	r0, (UNDEF: 0)
    8ef8:	00005100 	andeq	r5, r0, r0, lsl #2
    8efc:	00000000 	andeq	r0, r0, r0
    8f00:	00040000 	andeq	r0, r4, r0
    8f04:	9f5101f3 	svcls	0x005101f3
	...
    8f10:	00510001 	subseq	r0, r1, r1
	...
    8f20:	01000000 	mrseq	r0, (UNDEF: 0)
    8f24:	00005200 	andeq	r5, r0, r0, lsl #4
    8f28:	00000000 	andeq	r0, r0, r0
    8f2c:	00040000 	andeq	r0, r4, r0
    8f30:	9f5201f3 	svcls	0x005201f3
	...
    8f3c:	00520001 	subseq	r0, r2, r1
	...
    8f4c:	01000000 	mrseq	r0, (UNDEF: 0)
    8f50:	00005100 	andeq	r5, r0, r0, lsl #2
	...
    8f60:	00010000 	andeq	r0, r1, r0
    8f64:	00000053 	andeq	r0, r0, r3, asr r0
    8f68:	00000000 	andeq	r0, r0, r0
    8f6c:	72000500 	andvc	r0, r0, #0, 10
    8f70:	9f253500 	svcls	0x00253500
	...
    8f7c:	00530001 	subseq	r0, r3, r1
    8f80:	00000000 	andeq	r0, r0, r0
    8f84:	01000000 	mrseq	r0, (UNDEF: 0)
    8f88:	00005300 	andeq	r5, r0, r0, lsl #6
	...
    8f98:	00010000 	andeq	r0, r1, r0
    8f9c:	00000050 	andeq	r0, r0, r0, asr r0
    8fa0:	00000000 	andeq	r0, r0, r0
    8fa4:	f3000400 	vshl.u8	d0, d0, d0
    8fa8:	009f5001 	addseq	r5, pc, r1
	...
    8fb8:	01000000 	mrseq	r0, (UNDEF: 0)
    8fbc:	00005000 	andeq	r5, r0, r0
    8fc0:	00000000 	andeq	r0, r0, r0
    8fc4:	00040000 	andeq	r0, r4, r0
    8fc8:	9f5001f3 	svcls	0x005001f3
	...
    8fdc:	00500001 	subseq	r0, r0, r1
    8fe0:	00000000 	andeq	r0, r0, r0
    8fe4:	04000000 	streq	r0, [r0], #-0
    8fe8:	5001f300 	andpl	pc, r1, r0, lsl #6
    8fec:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    8ffc:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    9008:	01f30004 	mvnseq	r0, r4
    900c:	00009f50 	andeq	r9, r0, r0, asr pc
    9010:	00000000 	andeq	r0, r0, r0
    9014:	00010000 	andeq	r0, r1, r0
    9018:	00000050 	andeq	r0, r0, r0, asr r0
    901c:	00000000 	andeq	r0, r0, r0
    9020:	f3000400 	vshl.u8	d0, d0, d0
    9024:	009f5001 	addseq	r5, pc, r1
	...
    9034:	01000000 	mrseq	r0, (UNDEF: 0)
    9038:	00005000 	andeq	r5, r0, r0
    903c:	00000000 	andeq	r0, r0, r0
    9040:	00040000 	andeq	r0, r4, r0
    9044:	9f5001f3 	svcls	0x005001f3
	...
    9058:	0070000e 	rsbseq	r0, r0, lr
    905c:	381aff08 	ldmdacc	sl, {r3, r8, r9, sl, fp, ip, sp, lr, pc}
    9060:	08007124 	stmdaeq	r0, {r2, r5, r8, ip, sp, lr}
    9064:	9f211aff 	svcls	0x00211aff
	...
    9070:	01f3000f 	mvnseq	r0, pc
    9074:	1aff0850 	bne	fffcb1bc <BootRAM+0xef3b95d>
    9078:	00712438 	rsbseq	r2, r1, r8, lsr r4
    907c:	211aff08 	tstcs	sl, r8, lsl #30
    9080:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
	...
    9090:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    909c:	01f30004 	mvnseq	r0, r4
    90a0:	00009f50 	andeq	r9, r0, r0, asr pc
	...
    90b0:	00010000 	andeq	r0, r1, r0
    90b4:	00000050 	andeq	r0, r0, r0, asr r0
	...
    90c4:	70000d00 	andvc	r0, r0, r0, lsl #26
    90c8:	70253800 	eorvc	r3, r5, r0, lsl #16
    90cc:	1aff0800 	bne	fffcb0d4 <BootRAM+0xef3b875>
    90d0:	9f212438 	svcls	0x00212438
	...
    90dc:	00005d76 	andeq	r5, r0, r6, ror sp
    90e0:	00005ddc 	ldrdeq	r5, [r0], -ip
    90e4:	9f300002 	svcls	0x00300002
    90e8:	00005ddc 	ldrdeq	r5, [r0], -ip
    90ec:	00005de0 	andeq	r5, r0, r0, ror #27
    90f0:	00730007 	rsbseq	r0, r3, r7
    90f4:	1affff0a 	bne	8d24 <_etext+0x1710>
    90f8:	005df09f 			; <UNDEFINED> instruction: 0x005df09f
    90fc:	005dfa00 	subseq	pc, sp, r0, lsl #20
    9100:	73000700 	movwvc	r0, #1792	; 0x700
    9104:	ffff0a00 			; <UNDEFINED> instruction: 0xffff0a00
    9108:	5e049f1a 	mcrpl	15, 0, r9, cr4, cr10, {0}
    910c:	5e0e0000 	cdppl	0, 0, cr0, cr14, cr0, {0}
    9110:	00070000 	andeq	r0, r7, r0
    9114:	ff0a0073 			; <UNDEFINED> instruction: 0xff0a0073
    9118:	5a9f1aff 	bpl	fe7cfd1c <BootRAM+0xd7404bd>
    911c:	6600005e 			; <UNDEFINED> instruction: 0x6600005e
    9120:	0200005e 	andeq	r0, r0, #94	; 0x5e
    9124:	669f3000 	ldrvs	r3, [pc], r0
    9128:	a600005e 			; <UNDEFINED> instruction: 0xa600005e
    912c:	0700005e 	smlsdeq	r0, lr, r0, r0
    9130:	0a007500 	beq	26538 <_etext+0x1ef24>
    9134:	9f1affff 	svcls	0x001affff
    9138:	00005ea6 	andeq	r5, r0, r6, lsr #29
    913c:	00005ec8 	andeq	r5, r0, r8, asr #29
    9140:	9f300002 	svcls	0x00300002
	...
    914c:	00005dbc 			; <UNDEFINED> instruction: 0x00005dbc
    9150:	00005dc0 	andeq	r5, r0, r0, asr #27
    9154:	00720007 	rsbseq	r0, r2, r7
    9158:	2720000a 	strcs	r0, [r0, -sl]!
    915c:	005dc09f 			; <UNDEFINED> instruction: 0x005dc09f
    9160:	005dc400 	subseq	ip, sp, r0, lsl #8
    9164:	72000b00 	andvc	r0, r0, #0, 22
    9168:	20000a00 	andcs	r0, r0, r0, lsl #20
    916c:	20000a27 	andcs	r0, r0, r7, lsr #20
    9170:	5dc49f27 	stclpl	15, cr9, [r4, #156]	; 0x9c
    9174:	5dd40000 	ldclpl	0, cr0, [r4]
    9178:	000c0000 	andeq	r0, ip, r0
    917c:	0a060074 	beq	189354 <_etext+0x181d40>
    9180:	0a272000 	beq	9d1188 <_etext+0x9c9b74>
    9184:	9f272000 	svcls	0x00272000
	...
    9190:	00005dce 	andeq	r5, r0, lr, asr #27
    9194:	00005dd2 	ldrdeq	r5, [r0], -r2
    9198:	00720006 	rsbseq	r0, r2, r6
    919c:	9f272008 	svcls	0x00272008
    91a0:	00005dd2 	ldrdeq	r5, [r0], -r2
    91a4:	00005de2 	andeq	r5, r0, r2, ror #27
    91a8:	00720009 	rsbseq	r0, r2, r9
    91ac:	08272008 	stmdaeq	r7!, {r3, sp}
    91b0:	e29f2720 	adds	r2, pc, #32, 14	; 0x800000
    91b4:	ea00005d 	b	9330 <_etext+0x1d1c>
    91b8:	0a00005d 	beq	9334 <_etext+0x1d20>
    91bc:	06007400 	streq	r7, [r0], -r0, lsl #8
    91c0:	08272008 	stmdaeq	r7!, {r3, sp}
    91c4:	f09f2720 			; <UNDEFINED> instruction: 0xf09f2720
    91c8:	f200005d 	vqadd.s8	q0, q0, <illegal reg q6.5>
    91cc:	0900005d 	stmdbeq	r0, {r0, r2, r3, r4, r6}
    91d0:	08007200 	stmdaeq	r0, {r9, ip, sp, lr}
    91d4:	20082720 	andcs	r2, r8, r0, lsr #14
    91d8:	5df29f27 	ldclpl	15, cr9, [r2, #156]!	; 0x9c
    91dc:	5dfe0000 	ldclpl	0, cr0, [lr]
    91e0:	000a0000 	andeq	r0, sl, r0
    91e4:	08060074 	stmdaeq	r6, {r2, r4, r5, r6}
    91e8:	20082720 	andcs	r2, r8, r0, lsr #14
    91ec:	5e049f27 	cdppl	15, 0, cr9, cr4, cr7, {1}
    91f0:	5e120000 	cdppl	0, 1, cr0, cr2, cr0, {0}
    91f4:	000a0000 	andeq	r0, sl, r0
    91f8:	08060074 	stmdaeq	r6, {r2, r4, r5, r6}
    91fc:	20082720 	andcs	r2, r8, r0, lsr #14
    9200:	00009f27 	andeq	r9, r0, r7, lsr #30
    9204:	00000000 	andeq	r0, r0, r0
    9208:	5e240000 	cdppl	0, 2, cr0, cr4, cr0, {0}
    920c:	5e3a0000 	cdppl	0, 3, cr0, cr10, cr0, {0}
    9210:	00010000 	andeq	r0, r1, r0
    9214:	005e3a53 	subseq	r3, lr, r3, asr sl
    9218:	005e5800 	subseq	r5, lr, r0, lsl #16
    921c:	72000400 	andvc	r0, r0, #0, 8
    9220:	009f0600 	addseq	r0, pc, r0, lsl #12
    9224:	00000000 	andeq	r0, r0, r0
    9228:	46000000 	strmi	r0, [r0], -r0
    922c:	5a00005e 	bpl	93ac <_etext+0x1d98>
    9230:	0100005e 	qaddeq	r0, lr, r0
    9234:	00005300 	andeq	r5, r0, r0, lsl #6
	...
    9244:	00020000 	andeq	r0, r2, r0
    9248:	00009f30 	andeq	r9, r0, r0, lsr pc
    924c:	00000000 	andeq	r0, r0, r0
    9250:	00070000 	andeq	r0, r7, r0
    9254:	ff0a0071 			; <UNDEFINED> instruction: 0xff0a0071
    9258:	009f1aff 			; <UNDEFINED> instruction: 0x009f1aff
    925c:	00000000 	andeq	r0, r0, r0
    9260:	07000000 	streq	r0, [r0, -r0]
    9264:	0a007100 	beq	2566c <_etext+0x1e058>
    9268:	9f1affff 	svcls	0x001affff
	...
    9274:	9f300002 	svcls	0x00300002
	...
    9280:	00005f00 	andeq	r5, r0, r0, lsl #30
    9284:	00005f15 	andeq	r5, r0, r5, lsl pc
    9288:	15500001 	ldrbne	r0, [r0, #-1]
    928c:	2400005f 	strcs	r0, [r0], #-95	; 0x5f
    9290:	0400005f 	streq	r0, [r0], #-95	; 0x5f
    9294:	5001f300 	andpl	pc, r1, r0, lsl #6
    9298:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    929c:	00000000 	andeq	r0, r0, r0
    92a0:	005f2400 	subseq	r2, pc, r0, lsl #8
    92a4:	005f3900 	subseq	r3, pc, r0, lsl #18
    92a8:	50000100 	andpl	r0, r0, r0, lsl #2
    92ac:	00005f39 	andeq	r5, r0, r9, lsr pc
    92b0:	00005f48 	andeq	r5, r0, r8, asr #30
    92b4:	01f30004 	mvnseq	r0, r4
    92b8:	00009f50 	andeq	r9, r0, r0, asr pc
    92bc:	00000000 	andeq	r0, r0, r0
    92c0:	5f480000 	svcpl	0x00480000
    92c4:	5f5c0000 	svcpl	0x005c0000
    92c8:	00010000 	andeq	r0, r1, r0
    92cc:	005f5c50 	subseq	r5, pc, r0, asr ip	; <UNPREDICTABLE>
    92d0:	005fd800 	subseq	sp, pc, r0, lsl #16
    92d4:	f3000400 	vshl.u8	d0, d0, d0
    92d8:	009f5001 	addseq	r5, pc, r1
    92dc:	00000000 	andeq	r0, r0, r0
    92e0:	6a000000 	bvs	92e8 <_etext+0x1cd4>
    92e4:	6c00005f 	stcvs	0, cr0, [r0], {95}	; 0x5f
    92e8:	0200005f 	andeq	r0, r0, #95	; 0x5f
    92ec:	00097100 	andeq	r7, r9, r0, lsl #2
    92f0:	00000000 	andeq	r0, r0, r0
    92f4:	92000000 	andls	r0, r0, #0
    92f8:	9400005f 	strls	r0, [r0], #-95	; 0x5f
    92fc:	0100005f 	qaddeq	r0, pc, r0	; <UNPREDICTABLE>
    9300:	5f945200 	svcpl	0x00945200
    9304:	5fae0000 	svcpl	0x00ae0000
    9308:	00050000 	andeq	r0, r5, r0
    930c:	1a3f0071 	bne	fc94d8 <_etext+0xfc1ec4>
    9310:	005fb29f 			; <UNDEFINED> instruction: 0x005fb29f
    9314:	005fbc00 	subseq	fp, pc, r0, lsl #24
    9318:	71000500 	tstvc	r0, r0, lsl #10
    931c:	9f1a3f00 	svcls	0x001a3f00
	...
    9328:	00005fe0 	andeq	r5, r0, r0, ror #31
    932c:	00006066 	andeq	r6, r0, r6, rrx
    9330:	10740003 	rsbsne	r0, r4, r3
    9334:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    9338:	00000000 	andeq	r0, r0, r0
    933c:	005fe400 	subseq	lr, pc, r0, lsl #8
    9340:	00600e00 	rsbeq	r0, r0, r0, lsl #28
    9344:	53000100 	movwpl	r0, #256	; 0x100
    9348:	0000600e 	andeq	r6, r0, lr
    934c:	00006014 	andeq	r6, r0, r4, lsl r0
    9350:	10740009 	rsbsne	r0, r4, r9
    9354:	ff0a0294 			; <UNDEFINED> instruction: 0xff0a0294
    9358:	149f1aff 	ldrne	r1, [pc], #2815	; 9360 <_etext+0x1d4c>
    935c:	28000060 	stmdacs	r0, {r5, r6}
    9360:	01000060 	tsteq	r0, r0, rrx
    9364:	60285300 	eorvs	r5, r8, r0, lsl #6
    9368:	60290000 	eorvs	r0, r9, r0
    936c:	00090000 	andeq	r0, r9, r0
    9370:	02941074 	addseq	r1, r4, #116	; 0x74
    9374:	1affff0a 	bne	8fa4 <_etext+0x1990>
    9378:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    937c:	00000000 	andeq	r0, r0, r0
    9380:	005fe600 	subseq	lr, pc, r0, lsl #12
    9384:	00600800 	rsbeq	r0, r0, r0, lsl #16
    9388:	76000600 	strvc	r0, [r0], -r0, lsl #12
    938c:	1aff0800 	bne	fffcb394 <BootRAM+0xef3bb35>
    9390:	0060089f 	mlseq	r0, pc, r8, r0	; <UNPREDICTABLE>
    9394:	00600c00 	rsbeq	r0, r0, r0, lsl #24
    9398:	34000200 	strcc	r0, [r0], #-512	; 0x200
    939c:	00600c9f 	mlseq	r0, pc, ip, r0	; <UNPREDICTABLE>
    93a0:	00601400 	rsbeq	r1, r0, r0, lsl #8
    93a4:	37000200 	strcc	r0, [r0, -r0, lsl #4]
    93a8:	0060149f 	mlseq	r0, pc, r4, r1	; <UNPREDICTABLE>
    93ac:	00601e00 	rsbeq	r1, r0, r0, lsl #28
    93b0:	76000600 	strvc	r0, [r0], -r0, lsl #12
    93b4:	1aff0800 	bne	fffcb3bc <BootRAM+0xef3bb5d>
    93b8:	00601e9f 	mlseq	r0, pc, lr, r1	; <UNPREDICTABLE>
    93bc:	00606600 	rsbeq	r6, r0, r0, lsl #12
    93c0:	56000100 	strpl	r0, [r0], -r0, lsl #2
	...
    93cc:	0000602c 	andeq	r6, r0, ip, lsr #32
    93d0:	0000602e 	andeq	r6, r0, lr, lsr #32
    93d4:	2e500001 	cdpcs	0, 5, cr0, cr0, cr1, {0}
    93d8:	5c000060 	stcpl	0, cr0, [r0], {96}	; 0x60
    93dc:	01000060 	tsteq	r0, r0, rrx
    93e0:	00005900 	andeq	r5, r0, r0, lsl #18
    93e4:	00000000 	andeq	r0, r0, r0
    93e8:	60160000 	andsvs	r0, r6, r0
    93ec:	601e0000 	andsvs	r0, lr, r0
    93f0:	00010000 	andeq	r0, r1, r0
    93f4:	00601e55 	rsbeq	r1, r0, r5, asr lr
    93f8:	00602400 	rsbeq	r2, r0, r0, lsl #8
    93fc:	75001600 	strvc	r1, [r0, #-1536]	; 0x600
    9400:	4b401200 	blmi	100dc08 <_etext+0x10065f4>
    9404:	00732224 	rsbseq	r2, r3, r4, lsr #4
    9408:	4b401416 	blmi	100e468 <_etext+0x1006e54>
    940c:	282d2224 	stmdacs	sp!, {r2, r5, r9, sp}
    9410:	13160001 	tstne	r6, #1
    9414:	0060249f 	mlseq	r0, pc, r4, r2	; <UNPREDICTABLE>
    9418:	00605200 	rsbeq	r5, r0, r0, lsl #4
    941c:	55000100 	strpl	r0, [r0, #-256]	; 0x100
	...
    9428:	000060ca 	andeq	r6, r0, sl, asr #1
    942c:	000060e1 	andeq	r6, r0, r1, ror #1
    9430:	f0500001 			; <UNDEFINED> instruction: 0xf0500001
    9434:	f2000060 	vhadd.s8	q0, q0, q8
    9438:	01000060 	tsteq	r0, r0, rrx
    943c:	00005000 	andeq	r5, r0, r0
    9440:	00000000 	andeq	r0, r0, r0
    9444:	61080000 	mrsvs	r0, (UNDEF: 8)
    9448:	610c0000 	mrsvs	r0, (UNDEF: 12)
    944c:	00060000 	andeq	r0, r6, r0
    9450:	7f080070 	svcvc	0x00080070
    9454:	610c9f1a 	tstvs	ip, sl, lsl pc
    9458:	61300000 	teqvs	r0, r0
    945c:	00010000 	andeq	r0, r1, r0
    9460:	00613050 	rsbeq	r3, r1, r0, asr r0
    9464:	00615600 	rsbeq	r5, r1, r0, lsl #12
    9468:	73000b00 	movwvc	r0, #2816	; 0xb00
    946c:	08019400 	stmdaeq	r1, {sl, ip, pc}
    9470:	ff081a7f 			; <UNDEFINED> instruction: 0xff081a7f
    9474:	00009f1a 	andeq	r9, r0, sl, lsl pc
    9478:	00000000 	andeq	r0, r0, r0
    947c:	61480000 	mrsvs	r0, (UNDEF: 72)
    9480:	61750000 	cmnvs	r5, r0
    9484:	00010000 	andeq	r0, r1, r0
    9488:	00618051 	rsbeq	r8, r1, r1, asr r0
    948c:	00619200 	rsbeq	r9, r1, r0, lsl #4
    9490:	51000100 	mrspl	r0, (UNDEF: 16)
    9494:	00006198 	muleq	r0, r8, r1
    9498:	0000619b 	muleq	r0, fp, r1
    949c:	00510001 	subseq	r0, r1, r1
    94a0:	00000000 	andeq	r0, r0, r0
    94a4:	30000000 	andcc	r0, r0, r0
    94a8:	72000061 	andvc	r0, r0, #97	; 0x61
    94ac:	01000061 	tsteq	r0, r1, rrx
    94b0:	61805000 	orrvs	r5, r0, r0
    94b4:	61950000 	orrsvs	r0, r5, r0
    94b8:	00010000 	andeq	r0, r1, r0
    94bc:	00619850 	rsbeq	r9, r1, r0, asr r8
    94c0:	00619b00 	rsbeq	r9, r1, r0, lsl #22
    94c4:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    94d0:	0000612a 	andeq	r6, r0, sl, lsr #2
    94d4:	00006162 	andeq	r6, r0, r2, ror #2
    94d8:	00720006 	rsbseq	r0, r2, r6
    94dc:	9f1aff08 	svcls	0x001aff08
	...
    94e8:	000061a8 	andeq	r6, r0, r8, lsr #3
    94ec:	000061ac 	andeq	r6, r0, ip, lsr #3
    94f0:	00730007 	rsbseq	r0, r3, r7
    94f4:	2730000a 	ldrcs	r0, [r0, -sl]!
    94f8:	0061ac9f 	mlseq	r1, pc, ip, sl	; <UNPREDICTABLE>
    94fc:	0061ae00 	rsbeq	sl, r1, r0, lsl #28
    9500:	73000b00 	movwvc	r0, #2816	; 0xb00
    9504:	30000a00 	andcc	r0, r0, r0, lsl #20
    9508:	30000a27 	andcc	r0, r0, r7, lsr #20
    950c:	00009f27 	andeq	r9, r0, r7, lsr #30
    9510:	00000000 	andeq	r0, r0, r0
    9514:	61dc0000 	bicsvs	r0, ip, r0
    9518:	62160000 	andsvs	r0, r6, #0
    951c:	00060000 	andeq	r0, r6, r0
    9520:	ff080072 			; <UNDEFINED> instruction: 0xff080072
    9524:	62449f1a 	subvs	r9, r4, #26, 30	; 0x68
    9528:	62540000 	subsvs	r0, r4, #0
    952c:	00060000 	andeq	r0, r6, r0
    9530:	ff080072 			; <UNDEFINED> instruction: 0xff080072
    9534:	00009f1a 	andeq	r9, r0, sl, lsl pc
    9538:	00000000 	andeq	r0, r0, r0
    953c:	61e00000 	mvnvs	r0, r0
    9540:	62000000 	andvs	r0, r0, #0
    9544:	00010000 	andeq	r0, r1, r0
    9548:	00620054 	rsbeq	r0, r2, r4, asr r0
    954c:	00621600 	rsbeq	r1, r2, r0, lsl #12
    9550:	72000700 	andvc	r0, r0, #0, 14
    9554:	ff7f0b00 			; <UNDEFINED> instruction: 0xff7f0b00
    9558:	62449f1a 	subvs	r9, r4, #26, 30	; 0x68
    955c:	62540000 	subsvs	r0, r4, #0
    9560:	00070000 	andeq	r0, r7, r0
    9564:	7f0b0072 	svcvc	0x000b0072
    9568:	009f1aff 			; <UNDEFINED> instruction: 0x009f1aff
    956c:	00000000 	andeq	r0, r0, r0
    9570:	f6000000 			; <UNDEFINED> instruction: 0xf6000000
    9574:	3f000061 	svccc	0x00000061
    9578:	01000062 	tsteq	r0, r2, rrx
    957c:	62445000 	subvs	r5, r4, #0
    9580:	62460000 	subvs	r0, r6, #0
    9584:	00010000 	andeq	r0, r1, r0
    9588:	00000050 	andeq	r0, r0, r0, asr r0
    958c:	00000000 	andeq	r0, r0, r0
    9590:	00622200 	rsbeq	r2, r2, r0, lsl #4
    9594:	00622600 	rsbeq	r2, r2, r0, lsl #12
    9598:	72000500 	andvc	r0, r0, #0, 10
    959c:	9f274000 	svcls	0x00274000
    95a0:	00006226 	andeq	r6, r0, r6, lsr #4
    95a4:	00006228 	andeq	r6, r0, r8, lsr #4
    95a8:	00720007 	rsbseq	r0, r2, r7
    95ac:	27402740 	strbcs	r2, [r0, -r0, asr #14]
    95b0:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    95b4:	00000000 	andeq	r0, r0, r0
    95b8:	00623200 	rsbeq	r3, r2, r0, lsl #4
    95bc:	00623600 	rsbeq	r3, r2, r0, lsl #12
    95c0:	72000700 	andvc	r0, r0, #0, 14
    95c4:	10000a00 	andne	r0, r0, r0, lsl #20
    95c8:	00009f27 	andeq	r9, r0, r7, lsr #30
    95cc:	00000000 	andeq	r0, r0, r0
    95d0:	62780000 	rsbsvs	r0, r8, #0
    95d4:	628a0000 	addvs	r0, sl, #0
    95d8:	00010000 	andeq	r0, r1, r0
    95dc:	00628a50 	rsbeq	r8, r2, r0, asr sl
    95e0:	00629400 	rsbeq	r9, r2, r0, lsl #8
    95e4:	f3000400 	vshl.u8	d0, d0, d0
    95e8:	009f5001 	addseq	r5, pc, r1
    95ec:	00000000 	andeq	r0, r0, r0
    95f0:	78000000 	stmdavc	r0, {}	; <UNPREDICTABLE>
    95f4:	82000062 	andhi	r0, r0, #98	; 0x62
    95f8:	01000062 	tsteq	r0, r2, rrx
    95fc:	62825100 	addvs	r5, r2, #0, 2
    9600:	62880000 	addvs	r0, r8, #0
    9604:	00040000 	andeq	r0, r4, r0
    9608:	9f5101f3 	svcls	0x005101f3
    960c:	00006288 	andeq	r6, r0, r8, lsl #5
    9610:	00006294 	muleq	r0, r4, r2
    9614:	00510001 	subseq	r0, r1, r1
    9618:	00000000 	andeq	r0, r0, r0
    961c:	7e000000 	cdpvc	0, 0, cr0, cr0, cr0, {0}
    9620:	84000062 	strhi	r0, [r0], #-98	; 0x62
    9624:	01000062 	tsteq	r0, r2, rrx
    9628:	62845300 	addvs	r5, r4, #0, 6
    962c:	62880000 	addvs	r0, r8, #0
    9630:	00090000 	andeq	r0, r9, r0
    9634:	02941272 	addseq	r1, r4, #536870919	; 0x20000007
    9638:	1affff0a 	bne	9268 <_etext+0x1c54>
    963c:	0062889f 	mlseq	r2, pc, r8, r8	; <UNPREDICTABLE>
    9640:	00629400 	rsbeq	r9, r2, r0, lsl #8
    9644:	53000100 	movwpl	r0, #256	; 0x100
	...
    9650:	000062e6 	andeq	r6, r0, r6, ror #5
    9654:	000062f0 	strdeq	r6, [r0], -r0
    9658:	00720011 	rsbseq	r0, r2, r1, lsl r0
    965c:	1affff0a 	bne	928c <_etext+0x1c78>
    9660:	80232431 	eorhi	r2, r3, r1, lsr r4
    9664:	048081c0 	streq	r8, [r0], #448	; 0x1c0
    9668:	0004939f 	muleq	r4, pc, r3	; <UNPREDICTABLE>
    966c:	00000000 	andeq	r0, r0, r0
    9670:	1a000000 	bne	9678 <_etext+0x2064>
    9674:	2a000063 	bcs	9808 <_etext+0x21f4>
    9678:	02000063 	andeq	r0, r0, #99	; 0x63
    967c:	2a9f3200 	bcs	fe7d5e84 <BootRAM+0xd746625>
    9680:	2c000063 	stccs	0, cr0, [r0], {99}	; 0x63
    9684:	01000063 	tsteq	r0, r3, rrx
    9688:	632c5000 	teqvs	ip, #0
    968c:	63380000 	teqvs	r8, #0
    9690:	00020000 	andeq	r0, r2, r0
    9694:	633c9f32 	teqvs	ip, #50, 30	; 0xc8
    9698:	635a0000 	cmpvs	sl, #0
    969c:	00020000 	andeq	r0, r2, r0
    96a0:	63649f32 	cmnvs	r4, #50, 30	; 0xc8
    96a4:	636a0000 	cmnvs	sl, #0
    96a8:	00010000 	andeq	r0, r1, r0
    96ac:	00636a50 	rsbeq	r6, r3, r0, asr sl
    96b0:	00637a00 	rsbeq	r7, r3, r0, lsl #20
    96b4:	32000200 	andcc	r0, r0, #0, 4
    96b8:	00637a9f 	mlseq	r3, pc, sl, r7	; <UNPREDICTABLE>
    96bc:	00637c00 	rsbeq	r7, r3, r0, lsl #24
    96c0:	50000100 	andpl	r0, r0, r0, lsl #2
    96c4:	0000637c 	andeq	r6, r0, ip, ror r3
    96c8:	00006396 	muleq	r0, r6, r3
    96cc:	9f320002 	svcls	0x00320002
    96d0:	00006396 	muleq	r0, r6, r3
    96d4:	00006398 	muleq	r0, r8, r3
    96d8:	98500001 	ldmdals	r0, {r0}^
    96dc:	a4000063 	strge	r0, [r0], #-99	; 0x63
    96e0:	02000063 	andeq	r0, r0, #99	; 0x63
    96e4:	a49f3200 	ldrge	r3, [pc], #512	; 96ec <_etext+0x20d8>
    96e8:	a6000063 	strge	r0, [r0], -r3, rrx
    96ec:	01000063 	tsteq	r0, r3, rrx
    96f0:	63a65000 			; <UNDEFINED> instruction: 0x63a65000
    96f4:	63b60000 			; <UNDEFINED> instruction: 0x63b60000
    96f8:	00020000 	andeq	r0, r2, r0
    96fc:	63b69f32 			; <UNDEFINED> instruction: 0x63b69f32
    9700:	63be0000 			; <UNDEFINED> instruction: 0x63be0000
    9704:	00010000 	andeq	r0, r1, r0
    9708:	0063d650 	rsbeq	sp, r3, r0, asr r6
    970c:	0063d800 	rsbeq	sp, r3, r0, lsl #16
    9710:	50000100 	andpl	r0, r0, r0, lsl #2
	...
    971c:	0000631a 	andeq	r6, r0, sl, lsl r3
    9720:	000063de 	ldrdeq	r6, [r0], -lr
    9724:	00540001 	subseq	r0, r4, r1
    9728:	00000000 	andeq	r0, r0, r0
    972c:	be000000 	cdplt	0, 0, cr0, cr0, cr0, {0}
    9730:	d6000063 	strle	r0, [r0], -r3, rrx
    9734:	02000063 	andeq	r0, r0, #99	; 0x63
    9738:	d89f3600 	ldmle	pc, {r9, sl, ip, sp}	; <UNPREDICTABLE>
    973c:	de000063 	cdple	0, 0, cr0, cr0, cr3, {3}
    9740:	01000063 	tsteq	r0, r3, rrx
    9744:	00005300 	andeq	r5, r0, r0, lsl #6
    9748:	00000000 	andeq	r0, r0, r0
    974c:	63de0000 	bicsvs	r0, lr, #0
    9750:	63f40000 	mvnsvs	r0, #0
    9754:	00020000 	andeq	r0, r2, r0
    9758:	63f49f30 	mvnsvs	r9, #48, 30	; 0xc0
    975c:	63f60000 	mvnsvs	r0, #0
    9760:	00010000 	andeq	r0, r1, r0
    9764:	0063f653 	rsbeq	pc, r3, r3, asr r6	; <UNPREDICTABLE>
    9768:	0063fe00 	rsbeq	pc, r3, r0, lsl #28
    976c:	30000200 	andcc	r0, r0, r0, lsl #4
    9770:	0063fe9f 	mlseq	r3, pc, lr, pc	; <UNPREDICTABLE>
    9774:	00640000 	rsbeq	r0, r4, r0
    9778:	53000100 	movwpl	r0, #256	; 0x100
    977c:	00006400 	andeq	r6, r0, r0, lsl #8
    9780:	00006408 	andeq	r6, r0, r8, lsl #8
    9784:	9f300002 	svcls	0x00300002
    9788:	00006408 	andeq	r6, r0, r8, lsl #8
    978c:	0000640a 	andeq	r6, r0, sl, lsl #8
    9790:	0a530001 	beq	14c979c <_etext+0x14c2188>
    9794:	12000064 	andne	r0, r0, #100	; 0x64
    9798:	02000064 	andeq	r0, r0, #100	; 0x64
    979c:	129f3000 	addsne	r3, pc, #0
    97a0:	14000064 	strne	r0, [r0], #-100	; 0x64
    97a4:	01000064 	tsteq	r0, r4, rrx
    97a8:	64145300 	ldrvs	r5, [r4], #-768	; 0x300
    97ac:	64d00000 	ldrbvs	r0, [r0], #0
    97b0:	00020000 	andeq	r0, r2, r0
    97b4:	64d09f30 	ldrbvs	r9, [r0], #3888	; 0xf30
    97b8:	64dd0000 	ldrbvs	r0, [sp], #0
    97bc:	00010000 	andeq	r0, r1, r0
    97c0:	00659053 	rsbeq	r9, r5, r3, asr r0
    97c4:	00659a00 	rsbeq	r9, r5, r0, lsl #20
    97c8:	30000200 	andcc	r0, r0, r0, lsl #4
    97cc:	00659a9f 	mlseq	r5, pc, sl, r9	; <UNPREDICTABLE>
    97d0:	0065b000 	rsbeq	fp, r5, r0
    97d4:	03000600 	movweq	r0, #1536	; 0x600
    97d8:	00005f25 	andeq	r5, r0, r5, lsr #30
    97dc:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    97e0:	00000000 	andeq	r0, r0, r0
    97e4:	0064de00 	rsbeq	sp, r4, r0, lsl #28
    97e8:	0064e200 	rsbeq	lr, r4, r0, lsl #4
    97ec:	30000200 	andcc	r0, r0, r0, lsl #4
    97f0:	0064ee9f 	mlseq	r4, pc, lr, lr	; <UNPREDICTABLE>
    97f4:	00650400 	rsbeq	r0, r5, r0, lsl #8
    97f8:	50000100 	andpl	r0, r0, r0, lsl #2
    97fc:	00006508 	andeq	r6, r0, r8, lsl #10
    9800:	00006510 	andeq	r6, r0, r0, lsl r5
    9804:	14500001 	ldrbne	r0, [r0], #-1
    9808:	22000065 	andcs	r0, r0, #101	; 0x65
    980c:	01000065 	tsteq	r0, r5, rrx
    9810:	657c5000 	ldrbvs	r5, [ip, #-0]!
    9814:	65880000 	strvs	r0, [r8]
    9818:	00010000 	andeq	r0, r1, r0
    981c:	00000050 	andeq	r0, r0, r0, asr r0
    9820:	00000000 	andeq	r0, r0, r0
    9824:	0063de00 	rsbeq	sp, r3, r0, lsl #28
    9828:	0064d600 	rsbeq	sp, r4, r0, lsl #12
    982c:	54000100 	strpl	r0, [r0], #-256	; 0x100
    9830:	000064e2 	andeq	r6, r0, r2, ror #9
    9834:	000064f8 	strdeq	r6, [r0], -r8
    9838:	90540001 	subsls	r0, r4, r1
    983c:	b0000065 	andlt	r0, r0, r5, rrx
    9840:	01000065 	tsteq	r0, r5, rrx
    9844:	00005400 	andeq	r5, r0, r0, lsl #8
    9848:	00000000 	andeq	r0, r0, r0
    984c:	64660000 	strbtvs	r0, [r6], #-0
    9850:	64920000 	ldrvs	r0, [r2], #0
    9854:	00010000 	andeq	r0, r1, r0
    9858:	00000051 	andeq	r0, r0, r1, asr r0
    985c:	00000000 	andeq	r0, r0, r0
    9860:	00646600 	rsbeq	r6, r4, r0, lsl #12
    9864:	00649200 	rsbeq	r9, r4, r0, lsl #4
    9868:	73000900 	movwvc	r0, #2304	; 0x900
    986c:	1a700800 	bne	1c0b874 <_etext+0x1c04260>
    9870:	9f1aff08 	svcls	0x001aff08
	...
    987c:	000063de 	ldrdeq	r6, [r0], -lr
    9880:	00006588 	andeq	r6, r0, r8, lsl #11
    9884:	9f300002 	svcls	0x00300002
    9888:	00006590 	muleq	r0, r0, r5
    988c:	000065b0 			; <UNDEFINED> instruction: 0x000065b0
    9890:	9f300002 	svcls	0x00300002
	...
    989c:	0000647e 	andeq	r6, r0, lr, ror r4
    98a0:	00006492 	muleq	r0, r2, r4
    98a4:	00520001 	subseq	r0, r2, r1
    98a8:	00000000 	andeq	r0, r0, r0
    98ac:	ea000000 	b	98b4 <_etext+0x22a0>
    98b0:	ec000063 	stc	0, cr0, [r0], {99}	; 0x63
    98b4:	02000063 	andeq	r0, r0, #99	; 0x63
    98b8:	ec037300 	stc	3, cr7, [r3], {-0}
    98bc:	14000063 	strne	r0, [r0], #-99	; 0x63
    98c0:	01000064 	tsteq	r0, r4, rrx
    98c4:	64d05200 	ldrbvs	r5, [r0], #512	; 0x200
    98c8:	64d20000 	ldrbvs	r0, [r2], #0
    98cc:	00010000 	andeq	r0, r1, r0
    98d0:	00000052 	andeq	r0, r0, r2, asr r0
    98d4:	00000000 	andeq	r0, r0, r0
    98d8:	0065b800 	rsbeq	fp, r5, r0, lsl #16
    98dc:	0065c200 	rsbeq	ip, r5, r0, lsl #4
    98e0:	53000100 	movwpl	r0, #256	; 0x100
    98e4:	000065c2 	andeq	r6, r0, r2, asr #11
    98e8:	000065d3 	ldrdeq	r6, [r0], -r3
    98ec:	08740008 	ldmdaeq	r4!, {r3}^
    98f0:	ff080194 			; <UNDEFINED> instruction: 0xff080194
    98f4:	66429f1a 			; <UNDEFINED> instruction: 0x66429f1a
    98f8:	664a0000 	strbvs	r0, [sl], -r0
    98fc:	00010000 	andeq	r0, r1, r0
    9900:	00664a53 	rsbeq	r4, r6, r3, asr sl
    9904:	00664f00 	rsbeq	r4, r6, r0, lsl #30
    9908:	74000800 	strvc	r0, [r0], #-2048	; 0x800
    990c:	08019408 	stmdaeq	r1, {r3, sl, ip, pc}
    9910:	529f1aff 	addspl	r1, pc, #1044480	; 0xff000
    9914:	5a000066 	bpl	9ab4 <_etext+0x24a0>
    9918:	01000066 	tsteq	r0, r6, rrx
    991c:	00005300 	andeq	r5, r0, r0, lsl #6
    9920:	00000000 	andeq	r0, r0, r0
    9924:	65c00000 	strbvs	r0, [r0]
    9928:	66440000 	strbvs	r0, [r4], -r0
    992c:	00030000 	andeq	r0, r3, r0
    9930:	009f1074 	addseq	r1, pc, r4, ror r0	; <UNPREDICTABLE>
    9934:	00000000 	andeq	r0, r0, r0
    9938:	c4000000 	strgt	r0, [r0], #-0
    993c:	d3000065 	movwle	r0, #101	; 0x65
    9940:	01000065 	tsteq	r0, r5, rrx
    9944:	00005200 	andeq	r5, r0, r0, lsl #4
    9948:	00000000 	andeq	r0, r0, r0
    994c:	65d80000 	ldrbvs	r0, [r8]
    9950:	65e00000 	strbvs	r0, [r0, #0]!
    9954:	00010000 	andeq	r0, r1, r0
    9958:	0065e050 	rsbeq	lr, r5, r0, asr r0
    995c:	0065f200 	rsbeq	pc, r5, r0, lsl #4
    9960:	57000100 	strpl	r0, [r0, -r0, lsl #2]
	...
    996c:	000065ca 	andeq	r6, r0, sl, asr #11
    9970:	000065d0 	ldrdeq	r6, [r0], -r0
    9974:	00760016 	rsbseq	r0, r6, r6, lsl r0
    9978:	244b4012 	strbcs	r4, [fp], #-18
    997c:	16007222 	strne	r7, [r0], -r2, lsr #4
    9980:	244b4014 	strbcs	r4, [fp], #-20
    9984:	01282d22 	teqeq	r8, r2, lsr #26
    9988:	9f131600 	svcls	0x00131600
    998c:	000065d0 	ldrdeq	r6, [r0], -r0
    9990:	000065f2 	strdeq	r6, [r0], -r2
    9994:	00560001 	subseq	r0, r6, r1
    9998:	00000000 	andeq	r0, r0, r0
    999c:	78000000 	stmdavc	r0, {}	; <UNPREDICTABLE>
    99a0:	a4000066 	strge	r0, [r0], #-102	; 0x66
    99a4:	01000066 	tsteq	r0, r6, rrx
    99a8:	66a45000 	strtvs	r5, [r4], r0
    99ac:	66b00000 	ldrtvs	r0, [r0], r0
    99b0:	00040000 	andeq	r0, r4, r0
    99b4:	9f5001f3 	svcls	0x005001f3
	...
    99c0:	0000667e 	andeq	r6, r0, lr, ror r6
    99c4:	00006680 	andeq	r6, r0, r0, lsl #13
    99c8:	9f300002 	svcls	0x00300002
    99cc:	00006680 	andeq	r6, r0, r0, lsl #13
    99d0:	000066a0 	andeq	r6, r0, r0, lsr #13
    99d4:	00530001 	subseq	r0, r3, r1
    99d8:	00000000 	andeq	r0, r0, r0
    99dc:	7e000000 	cdpvc	0, 0, cr0, cr0, cr0, {0}
    99e0:	a8000066 	stmdage	r0, {r1, r2, r5, r6}
    99e4:	01000066 	tsteq	r0, r6, rrx
    99e8:	00005400 	andeq	r5, r0, r0, lsl #8
    99ec:	00000000 	andeq	r0, r0, r0
    99f0:	66b80000 	ldrtvs	r0, [r8], r0
    99f4:	66c30000 	strbvs	r0, [r3], r0
    99f8:	00010000 	andeq	r0, r1, r0
    99fc:	0066c852 	rsbeq	ip, r6, r2, asr r8
    9a00:	0066ca00 	rsbeq	ip, r6, r0, lsl #20
    9a04:	53000100 	movwpl	r0, #256	; 0x100
    9a08:	000066ca 	andeq	r6, r0, sl, asr #13
    9a0c:	000066d0 	ldrdeq	r6, [r0], -r0
    9a10:	d0520001 	subsle	r0, r2, r1
    9a14:	df000066 	svcle	0x00000066
    9a18:	08000066 	stmdaeq	r0, {r1, r2, r5, r6}
    9a1c:	94087300 	strls	r7, [r8], #-768	; 0x300
    9a20:	1aff0801 	bne	fffcba2c <BootRAM+0xef3c1cd>
    9a24:	0066f29f 	mlseq	r6, pc, r2, pc	; <UNPREDICTABLE>
    9a28:	0066fd00 	rsbeq	pc, r6, r0, lsl #26
    9a2c:	53000100 	movwpl	r0, #256	; 0x100
	...
    9a38:	0000670c 	andeq	r6, r0, ip, lsl #14
    9a3c:	00006724 	andeq	r6, r0, r4, lsr #14
    9a40:	24500001 	ldrbcs	r0, [r0], #-1
    9a44:	26000067 	strcs	r0, [r0], -r7, rrx
    9a48:	03000067 	movweq	r0, #103	; 0x67
    9a4c:	9f7e7000 	svcls	0x007e7000
    9a50:	00006726 	andeq	r6, r0, r6, lsr #14
    9a54:	00006736 	andeq	r6, r0, r6, lsr r7
    9a58:	7f700003 	svcvc	0x00700003
    9a5c:	0067369f 	mlseq	r7, pc, r6, r3	; <UNPREDICTABLE>
    9a60:	00673a00 	rsbeq	r3, r7, r0, lsl #20
    9a64:	50000100 	andpl	r0, r0, r0, lsl #2
    9a68:	0000673a 	andeq	r6, r0, sl, lsr r7
    9a6c:	0000673c 	andeq	r6, r0, ip, lsr r7
    9a70:	7e700003 	cdpvc	0, 7, cr0, cr0, cr3, {0}
    9a74:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    9a78:	00000000 	andeq	r0, r0, r0
    9a7c:	00670c00 	rsbeq	r0, r7, r0, lsl #24
    9a80:	00671200 	rsbeq	r1, r7, r0, lsl #4
    9a84:	51000100 	mrspl	r0, (UNDEF: 16)
    9a88:	00006712 	andeq	r6, r0, r2, lsl r7
    9a8c:	0000673c 	andeq	r6, r0, ip, lsr r7
    9a90:	01f30004 	mvnseq	r0, r4
    9a94:	00009f51 	andeq	r9, r0, r1, asr pc
    9a98:	00000000 	andeq	r0, r0, r0
    9a9c:	670c0000 	strvs	r0, [ip, -r0]
    9aa0:	67140000 	ldrvs	r0, [r4, -r0]
    9aa4:	00010000 	andeq	r0, r1, r0
    9aa8:	00671452 	rsbeq	r1, r7, r2, asr r4
    9aac:	00673c00 	rsbeq	r3, r7, r0, lsl #24
    9ab0:	f3000400 	vshl.u8	d0, d0, d0
    9ab4:	009f5201 	addseq	r5, pc, r1, lsl #4
    9ab8:	00000000 	andeq	r0, r0, r0
    9abc:	1c000000 	stcne	0, cr0, [r0], {-0}
    9ac0:	1e000067 	cdpne	0, 0, cr0, cr0, cr7, {3}
    9ac4:	01000067 	tsteq	r0, r7, rrx
    9ac8:	671e5200 	ldrvs	r5, [lr, -r0, lsl #4]
    9acc:	67360000 	ldrvs	r0, [r6, -r0]!
    9ad0:	000f0000 	andeq	r0, pc, r0
    9ad4:	0a5201f3 	beq	148a2a8 <_etext+0x1482c94>
    9ad8:	231affff 	tstcs	sl, #1020	; 0x3fc
    9adc:	73263101 	teqvc	r6, #1073741824	; 0x40000000
    9ae0:	369f1c00 	ldrcc	r1, [pc], r0, lsl #24
    9ae4:	38000067 	stmdacc	r0, {r0, r1, r2, r5, r6}
    9ae8:	10000067 	andne	r0, r0, r7, rrx
    9aec:	5201f300 	andpl	pc, r1, #0, 6
    9af0:	1affff0a 	bne	9720 <_etext+0x210c>
    9af4:	26310123 	ldrtcs	r0, [r1], -r3, lsr #2
    9af8:	22200073 	eorcs	r0, r0, #115	; 0x73
    9afc:	0067389f 	mlseq	r7, pc, r8, r3	; <UNPREDICTABLE>
    9b00:	00673c00 	rsbeq	r3, r7, r0, lsl #24
    9b04:	f3000f00 	vpmax.f32	d0, d0, d0
    9b08:	ff0a5201 			; <UNDEFINED> instruction: 0xff0a5201
    9b0c:	01231aff 	strdeq	r1, [r3, -pc]!
    9b10:	00732631 	rsbseq	r2, r3, r1, lsr r6
    9b14:	00009f1c 	andeq	r9, r0, ip, lsl pc
    9b18:	00000000 	andeq	r0, r0, r0
    9b1c:	67260000 	strvs	r0, [r6, -r0]!
    9b20:	672e0000 	strvs	r0, [lr, -r0]!
    9b24:	00080000 	andeq	r0, r8, r0
    9b28:	01947e70 	orrseq	r7, r4, r0, ror lr
    9b2c:	9f1aff08 	svcls	0x001aff08
    9b30:	0000672e 	andeq	r6, r0, lr, lsr #14
    9b34:	00006732 	andeq	r6, r0, r2, lsr r7
    9b38:	32540001 	subscc	r0, r4, #1
    9b3c:	36000067 	strcc	r0, [r0], -r7, rrx
    9b40:	08000067 	stmdaeq	r0, {r0, r1, r2, r5, r6}
    9b44:	947e7000 	ldrbtls	r7, [lr], #-0
    9b48:	1aff0801 	bne	fffcbb54 <BootRAM+0xef3c2f5>
    9b4c:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    9b50:	00000000 	andeq	r0, r0, r0
    9b54:	00672600 	rsbeq	r2, r7, r0, lsl #12
    9b58:	00673600 	rsbeq	r3, r7, r0, lsl #12
    9b5c:	70001200 	andvc	r1, r0, r0, lsl #4
    9b60:	0801947f 	stmdaeq	r1, {r0, r1, r2, r3, r4, r5, r6, sl, ip, pc}
    9b64:	24381aff 	ldrtcs	r1, [r8], #-2815	; 0xaff
    9b68:	01947e70 	orrseq	r7, r4, r0, ror lr
    9b6c:	211aff08 	tstcs	sl, r8, lsl #30
    9b70:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    9b74:	00000000 	andeq	r0, r0, r0
    9b78:	00671c00 	rsbeq	r1, r7, r0, lsl #24
    9b7c:	00671e00 	rsbeq	r1, r7, r0, lsl #28
    9b80:	51000100 	mrspl	r0, (UNDEF: 16)
    9b84:	00006736 	andeq	r6, r0, r6, lsr r7
    9b88:	00006738 	andeq	r6, r0, r8, lsr r7
    9b8c:	0073000a 	rsbseq	r0, r3, sl
    9b90:	00712432 	rsbseq	r2, r1, r2, lsr r4
    9b94:	9f042322 	svcls	0x00042322
    9b98:	00006738 	andeq	r6, r0, r8, lsr r7
    9b9c:	0000673a 	andeq	r6, r0, sl, lsr r7
    9ba0:	7f73000a 	svcvc	0x0073000a
    9ba4:	00712432 	rsbseq	r2, r1, r2, lsr r4
    9ba8:	9f042322 	svcls	0x00042322
	...
    9bb4:	0000673c 	andeq	r6, r0, ip, lsr r7
    9bb8:	0000674e 	andeq	r6, r0, lr, asr #14
    9bbc:	5a500001 	bpl	1409bc8 <_etext+0x14025b4>
    9bc0:	5c000067 	stcpl	0, cr0, [r0], {103}	; 0x67
    9bc4:	0a000067 	beq	9d68 <_etext+0x2754>
    9bc8:	31007300 	mrscc	r7, LR_irq
    9bcc:	22007024 	andcs	r7, r0, #36	; 0x24
    9bd0:	5c9f0223 	lfmpl	f0, 4, [pc], {35}	; 0x23
    9bd4:	5e000067 	cdppl	0, 0, cr0, cr0, cr7, {3}
    9bd8:	0a000067 	beq	9d7c <_etext+0x2768>
    9bdc:	317f7300 	cmncc	pc, r0, lsl #6
    9be0:	22007024 	andcs	r7, r0, #36	; 0x24
    9be4:	009f0223 	addseq	r0, pc, r3, lsr #4
    9be8:	00000000 	andeq	r0, r0, r0
    9bec:	3c000000 	stccc	0, cr0, [r0], {-0}
    9bf0:	42000067 	andmi	r0, r0, #103	; 0x67
    9bf4:	01000067 	tsteq	r0, r7, rrx
    9bf8:	67425100 	strbvs	r5, [r2, -r0, lsl #2]
    9bfc:	67600000 	strbvs	r0, [r0, -r0]!
    9c00:	00040000 	andeq	r0, r4, r0
    9c04:	9f5101f3 	svcls	0x005101f3
	...
    9c10:	0000673c 	andeq	r6, r0, ip, lsr r7
    9c14:	00006744 	andeq	r6, r0, r4, asr #14
    9c18:	44520001 	ldrbmi	r0, [r2], #-1
    9c1c:	60000067 	andvs	r0, r0, r7, rrx
    9c20:	04000067 	streq	r0, [r0], #-103	; 0x67
    9c24:	5201f300 	andpl	pc, r1, #0, 6
    9c28:	0000009f 	muleq	r0, pc, r0	; <UNPREDICTABLE>
    9c2c:	00000000 	andeq	r0, r0, r0
    9c30:	00674c00 	rsbeq	r4, r7, r0, lsl #24
    9c34:	00674e00 	rsbeq	r4, r7, r0, lsl #28
    9c38:	52000100 	andpl	r0, r0, #0, 2
    9c3c:	0000674e 	andeq	r6, r0, lr, asr #14
    9c40:	0000675a 	andeq	r6, r0, sl, asr r7
    9c44:	01f3000f 	mvnseq	r0, pc
    9c48:	ffff0a52 			; <UNDEFINED> instruction: 0xffff0a52
    9c4c:	3101231a 	tstcc	r1, sl, lsl r3
    9c50:	1c007326 	stcne	3, cr7, [r0], {38}	; 0x26
    9c54:	00675a9f 	mlseq	r7, pc, sl, r5	; <UNPREDICTABLE>
    9c58:	00675c00 	rsbeq	r5, r7, r0, lsl #24
    9c5c:	f3001000 	vhadd.u8	d1, d0, d0
    9c60:	ff0a5201 			; <UNDEFINED> instruction: 0xff0a5201
    9c64:	01231aff 	strdeq	r1, [r3, -pc]!
    9c68:	00732631 	rsbseq	r2, r3, r1, lsr r6
    9c6c:	5c9f2220 	lfmpl	f2, 4, [pc], {32}
    9c70:	60000067 	andvs	r0, r0, r7, rrx
    9c74:	0f000067 	svceq	0x00000067
    9c78:	5201f300 	andpl	pc, r1, #0, 6
    9c7c:	1affff0a 	bne	98ac <_etext+0x2298>
    9c80:	26310123 	ldrtcs	r0, [r1], -r3, lsr #2
    9c84:	9f1c0073 	svcls	0x001c0073
	...
    9c90:	0000674c 	andeq	r6, r0, ip, asr #14
    9c94:	0000674e 	andeq	r6, r0, lr, asr #14
    9c98:	52510001 	subspl	r0, r1, #1
    9c9c:	5c000067 	stcpl	0, cr0, [r0], {103}	; 0x67
    9ca0:	0a000067 	beq	9e44 <_etext+0x2830>
    9ca4:	32007300 	andcc	r7, r0, #0, 6
    9ca8:	22007124 	andcs	r7, r0, #36, 2
    9cac:	5c9f0423 	cfldrspl	mvf0, [pc], {35}	; 0x23
    9cb0:	5e000067 	cdppl	0, 0, cr0, cr0, cr7, {3}
    9cb4:	0a000067 	beq	9e58 <_etext+0x2844>
    9cb8:	327f7300 	rsbscc	r7, pc, #0, 6
    9cbc:	22007124 	andcs	r7, r0, #36, 2
    9cc0:	009f0423 	addseq	r0, pc, r3, lsr #8
    9cc4:	00000000 	andeq	r0, r0, r0
    9cc8:	Address 0x00009cc8 is out of bounds.


Disassembly of section .debug_ranges:

00000000 <.debug_ranges>:
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
void NOP_Process(void)
{
   0:	ffffffff 			; <UNDEFINED> instruction: 0xffffffff
*******************************************************************************/
void CTR_HP(void)
{
  u32 wEPVal = 0;

  while (((wIstr = _GetISTR()) & ISTR_CTR) != 0)
   4:	00000000 	andeq	r0, r0, r0
   8:	00000b4c 	andeq	r0, r0, ip, asr #22
   c:	00000b94 	muleq	r0, r4, fp
  {
    _SetISTR((u16)CLR_CTR); /* clear CTR flag */
  10:	00000b94 	muleq	r0, r4, fp
  14:	00000b98 	muleq	r0, r8, fp
	...
    /* extract highest priority endpoint number */
    EPindex = (u8)(wIstr & ISTR_EP_ID);
    /* process related endpoint register */
    wEPVal = _GetENDPOINT(EPindex);
  20:	00000b98 	muleq	r0, r8, fp
  24:	00000b9a 	muleq	r0, sl, fp
  28:	00000b9a 	muleq	r0, sl, fp
    if ((wEPVal & EP_CTR_RX) != 0)
  2c:	00000b9c 	muleq	r0, ip, fp
    {
      /* clear int flag */
      _ClearEP_CTR_RX(EPindex);
  30:	00000b9c 	muleq	r0, ip, fp
  34:	00000b9e 	muleq	r0, lr, fp
  38:	00000b9e 	muleq	r0, lr, fp

      /* call OUT service function */
      (*pEpInt_OUT[EPindex-1])();
  3c:	00000ba8 	andeq	r0, r0, r8, lsr #23

    } /* if((wEPVal & EP_CTR_RX) */
    else if ((wEPVal & EP_CTR_TX) != 0)
  40:	00000ba8 	andeq	r0, r0, r8, lsr #23
    {
      /* clear int flag */
      _ClearEP_CTR_TX(EPindex);
  44:	00000baa 	andeq	r0, r0, sl, lsr #23
  48:	00000bac 	andeq	r0, r0, ip, lsr #23
  4c:	00000bc4 	andeq	r0, r0, r4, asr #23

      /* call IN service function */
      (*pEpInt_IN[EPindex-1])();
  50:	00000bc4 	andeq	r0, r0, r4, asr #23
  54:	00000bc6 	andeq	r0, r0, r6, asr #23
  58:	00000bc6 	andeq	r0, r0, r6, asr #23
  5c:	00000bc8 	andeq	r0, r0, r8, asr #23
  60:	00000bc8 	andeq	r0, r0, r8, asr #23
  64:	00000bca 	andeq	r0, r0, sl, asr #23
  68:	00000bca 	andeq	r0, r0, sl, asr #23
  6c:	00000bcc 	andeq	r0, r0, ip, asr #23
* Output         : None.
* Return         : None.
*******************************************************************************/
void SetEPDblBuffCount(u8 bEpNum, u8 bDir, u16 wCount)
{
  _SetEPDblBuffCount(bEpNum, bDir, wCount);
  70:	00000bcc 	andeq	r0, r0, ip, asr #23
  74:	00000bce 	andeq	r0, r0, lr, asr #23
  78:	00000bce 	andeq	r0, r0, lr, asr #23
  7c:	00000bd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
  80:	00000bd0 	ldrdeq	r0, [r0], -r0	; <UNPREDICTABLE>
  84:	00000bdc 	ldrdeq	r0, [r0], -ip
  88:	00000bdc 	ldrdeq	r0, [r0], -ip
  8c:	00000c84 	andeq	r0, r0, r4, lsl #25
  90:	00000c84 	andeq	r0, r0, r4, lsl #25
  94:	00000ce4 	andeq	r0, r0, r4, ror #25
  98:	00000ce4 	andeq	r0, r0, r4, ror #25
  9c:	00000cf0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
  a0:	00000cf0 	strdeq	r0, [r0], -r0	; <UNPREDICTABLE>
  a4:	00000cfc 	strdeq	r0, [r0], -ip
	f25519_select(x, a, b, (a[0] ^ parity) & 1);

	/* Verify that x^2 = c */
	f25519_mul__distinct(a, x, x);
	f25519_normalize(a);
	f25519_normalize(c);
  a8:	00000cfc 	strdeq	r0, [r0], -ip

	return f25519_eq(a, c);
  ac:	00000d1c 	andeq	r0, r0, ip, lsl sp
  b0:	00000d1c 	andeq	r0, r0, ip, lsl sp
  b4:	00000d28 	andeq	r0, r0, r8, lsr #26
	uint8_t ok;

	mx2ey(ey, mx);
	ok = ey2ex(ex, ey, parity);

	f25519_normalize(ex);
  b8:	00000d28 	andeq	r0, r0, r8, lsr #26
	f25519_normalize(ey);
  bc:	00000d50 	andeq	r0, r0, r0, asr sp
  c0:	00000d50 	andeq	r0, r0, r0, asr sp

	return ok;
}
  c4:	00000db8 			; <UNDEFINED> instruction: 0x00000db8
  c8:	00000001 	andeq	r0, r0, r1
  cc:	00000001 	andeq	r0, r0, r1
  d0:	00000db8 			; <UNDEFINED> instruction: 0x00000db8
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
  d4:	00000dd4 	ldrdeq	r0, [r0], -r4
  d8:	00000dd4 	ldrdeq	r0, [r0], -r4
		minusp[i] = c;
  dc:	00000dec 	andeq	r0, r0, ip, ror #27
{
	uint8_t minusp[FPRIME_SIZE];
	uint16_t c = 0;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++) {
  e0:	00000dec 	andeq	r0, r0, ip, ror #27
		c = ((uint16_t)x[i]) - ((uint16_t)p[i]) - c;
		minusp[i] = c;
		c = (c >> 8) & 1;
  e4:	00000e70 	andeq	r0, r0, r0, ror lr

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
  e8:	00000e70 	andeq	r0, r0, r0, ror lr
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
  ec:	00000eb8 			; <UNDEFINED> instruction: 0x00000eb8
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
  f0:	00000eb8 			; <UNDEFINED> instruction: 0x00000eb8
  f4:	00000ef4 	strdeq	r0, [r0], -r4
  f8:	00000ef4 	strdeq	r0, [r0], -r4
  fc:	00000ef8 	strdeq	r0, [r0], -r8
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
 100:	00000ef8 	strdeq	r0, [r0], -r8

void fprime_select(uint8_t *dst,
		   const uint8_t *zero, const uint8_t *one,
		   uint8_t condition)
{
	const uint8_t mask = -condition;
 104:	00000f1c 	andeq	r0, r0, ip, lsl pc
 108:	00000f1c 	andeq	r0, r0, ip, lsl pc
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
 10c:	00000f5c 	andeq	r0, r0, ip, asr pc
		dst[i] = zero[i] ^ (mask & (one[i] ^ zero[i]));
 110:	00000f5c 	andeq	r0, r0, ip, asr pc
 114:	00000f7e 	andeq	r0, r0, lr, ror pc
 118:	00000f80 	andeq	r0, r0, r0, lsl #31
 11c:	00001034 	andeq	r1, r0, r4, lsr r0
		   uint8_t condition)
{
	const uint8_t mask = -condition;
	int i;

	for (i = 0; i < FPRIME_SIZE; i++)
 120:	00000001 	andeq	r0, r0, r1
{
	int i;

	memset(r, 0, FPRIME_SIZE);

	for (i = prime_msb(modulus); i >= 0; i--) {
 124:	00000001 	andeq	r0, r0, r1
	...

	for (i = FPRIME_SIZE - 1; i >= 0; i--)
		if (p[i])
			break;

	x = p[i];
 130:	00001034 	andeq	r1, r0, r4, lsr r0
	i <<= 3;

	while (x) {
 134:	00001138 	andeq	r1, r0, r8, lsr r1
	...
	f25519_mul__distinct(x3, a, a);

	f25519_mul_c(a, x1z1, 486662);
	f25519_add(a, x1sq, a);
	f25519_add(a, z1sq, a);
	f25519_mul__distinct(x1sq, x1z1, a);
 140:	00001138 	andeq	r1, r0, r8, lsr r1
	f25519_mul_c(z3, x1sq, 4);
 144:	0000114e 	andeq	r1, r0, lr, asr #2
 148:	0000114e 	andeq	r1, r0, lr, asr #2
	uint8_t da[F25519_SIZE];
	uint8_t cb[F25519_SIZE];
	uint8_t a[F25519_SIZE];
	uint8_t b[F25519_SIZE];

	f25519_add(a, x2, z2);
 14c:	00001160 	andeq	r1, r0, r0, ror #2
 150:	00001160 	andeq	r1, r0, r0, ror #2
 154:	000011b0 			; <UNDEFINED> instruction: 0x000011b0
	f25519_sub(b, x3, z3); /* D */
 158:	000011b0 			; <UNDEFINED> instruction: 0x000011b0
 15c:	000011ba 			; <UNDEFINED> instruction: 0x000011ba
	f25519_mul__distinct(da, a, b);
 160:	000011ba 			; <UNDEFINED> instruction: 0x000011ba
 164:	000011d0 	ldrdeq	r1, [r0], -r0
 168:	000011d0 	ldrdeq	r1, [r0], -r0

	f25519_sub(b, x2, z2);
 16c:	000011f8 	strdeq	r1, [r0], -r8
 170:	000011f8 	strdeq	r1, [r0], -r8
	f25519_add(a, x3, z3); /* C */
 174:	00001212 	andeq	r1, r0, r2, lsl r2
 178:	00001214 	andeq	r1, r0, r4, lsl r2
 17c:	000012b0 			; <UNDEFINED> instruction: 0x000012b0
	f25519_mul__distinct(cb, a, b);
 180:	000012b0 			; <UNDEFINED> instruction: 0x000012b0
 184:	000012d8 	ldrdeq	r1, [r0], -r8

	f25519_add(a, da, cb);
 188:	000012d8 	ldrdeq	r1, [r0], -r8
 18c:	00001360 	andeq	r1, r0, r0, ror #6
 190:	00001360 	andeq	r1, r0, r0, ror #6
	f25519_mul__distinct(b, a, a);
 194:	000013a8 	andeq	r1, r0, r8, lsr #7
 198:	000013a8 	andeq	r1, r0, r8, lsr #7
	f25519_mul__distinct(x5, z1, b);
 19c:	00001408 	andeq	r1, r0, r8, lsl #8
 1a0:	00001408 	andeq	r1, r0, r8, lsl #8
 1a4:	0000141c 	andeq	r1, r0, ip, lsl r4

	f25519_sub(a, da, cb);
 1a8:	0000141c 	andeq	r1, r0, ip, lsl r4
 1ac:	00001438 	andeq	r1, r0, r8, lsr r4
	f25519_mul__distinct(b, a, a);
 1b0:	00000001 	andeq	r0, r0, r1
 1b4:	00000001 	andeq	r0, r0, r1
 1b8:	00001438 	andeq	r1, r0, r8, lsr r4

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
		const int bit = (e[i >> 3] >> (i & 7)) & 1;
 1bc:	00001450 	andeq	r1, r0, r0, asr r4
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(x5, z1, b);

	f25519_sub(a, da, cb);
	f25519_mul__distinct(b, a, a);
	f25519_mul__distinct(z5, x1, b);
 1c0:	00000001 	andeq	r0, r0, r1
 1c4:	00000001 	andeq	r0, r0, r1

		/* Select:
		 *   bit = 1 --> (P_(2m+1), P_(2m))
		 *   bit = 0 --> (P_(2m), P_(2m-1))
		 */
		f25519_select(xm1, xm1, xm, bit);
 1c8:	00000001 	andeq	r0, r0, r1
 1cc:	00000001 	andeq	r0, r0, r1
 1d0:	00001450 	andeq	r1, r0, r0, asr r4
 1d4:	000014bc 			; <UNDEFINED> instruction: 0x000014bc
		f25519_select(zm1, zm1, zm, bit);
 1d8:	000014bc 			; <UNDEFINED> instruction: 0x000014bc
 1dc:	000014e0 	andeq	r1, r0, r0, ror #9
 1e0:	000014e0 	andeq	r1, r0, r0, ror #9
		f25519_select(xm, xm, xms, bit);
 1e4:	000014fe 	strdeq	r1, [r0], -lr
 1e8:	00001500 	andeq	r1, r0, r0, lsl #10
 1ec:	00001514 	andeq	r1, r0, r4, lsl r5
		f25519_select(zm, zm, zms, bit);
 1f0:	00001514 	andeq	r1, r0, r4, lsl r5
 1f4:	00001548 	andeq	r1, r0, r8, asr #10
 1f8:	00000001 	andeq	r0, r0, r1
	int i;

	/* Note: bit 254 is assumed to be 1 */
	f25519_copy(xm, q);

	for (i = 253; i >= 0; i--) {
 1fc:	00000001 	andeq	r0, r0, r1
 200:	00001548 	andeq	r1, r0, r8, asr #10
		f25519_select(xm, xm, xms, bit);
		f25519_select(zm, zm, zms, bit);
	}

	/* Freeze out of projective coordinates */
	f25519_inv__distinct(zm1, zm);
 204:	00001594 	muleq	r0, r4, r5
 208:	00001594 	muleq	r0, r4, r5
	f25519_mul__distinct(result, zm1, xm);
 20c:	000015a0 	andeq	r1, r0, r0, lsr #11
 210:	000015a0 	andeq	r1, r0, r0, lsr #11
	f25519_normalize(result);
 214:	000015b8 			; <UNDEFINED> instruction: 0x000015b8
 218:	000015b8 			; <UNDEFINED> instruction: 0x000015b8
}
 21c:	000015ca 	andeq	r1, r0, sl, asr #11
 220:	000015cc 	andeq	r1, r0, ip, asr #11
 224:	000015dc 	ldrdeq	r1, [r0], -ip
 228:	000015dc 	ldrdeq	r1, [r0], -ip
 22c:	000015f4 	strdeq	r1, [r0], -r4
	...
 238:	000015f4 	strdeq	r1, [r0], -r4
 23c:	0000167c 	andeq	r1, r0, ip, ror r6
 240:	0000167c 	andeq	r1, r0, ip, ror r6
 244:	000016c0 	andeq	r1, r0, r0, asr #13
 248:	00000001 	andeq	r0, r0, r1
 24c:	00000001 	andeq	r0, r0, r1
 250:	000016c0 	andeq	r1, r0, r0, asr #13
 254:	000016d8 	ldrdeq	r1, [r0], -r8
 258:	000016d8 	ldrdeq	r1, [r0], -r8
 25c:	000016f0 	strdeq	r1, [r0], -r0
 260:	000016f0 	strdeq	r1, [r0], -r0
 264:	00001718 	andeq	r1, r0, r8, lsl r7
 268:	00001718 	andeq	r1, r0, r8, lsl r7
 26c:	0000174c 	andeq	r1, r0, ip, asr #14
 270:	0000174c 	andeq	r1, r0, ip, asr #14
 274:	000017a8 	andeq	r1, r0, r8, lsr #15
 278:	000017a8 	andeq	r1, r0, r8, lsr #15
 27c:	000019fc 	strdeq	r1, [r0], -ip
 280:	00000001 	andeq	r0, r0, r1
 284:	00000001 	andeq	r0, r0, r1
 288:	00000001 	andeq	r0, r0, r1
 28c:	00000001 	andeq	r0, r0, r1
 290:	000019fc 	strdeq	r1, [r0], -ip
 294:	00001a08 	andeq	r1, r0, r8, lsl #20
 298:	00000001 	andeq	r0, r0, r1
 29c:	00000001 	andeq	r0, r0, r1
 2a0:	00001a08 	andeq	r1, r0, r8, lsl #20
 2a4:	00001a0a 	andeq	r1, r0, sl, lsl #20
	...
 2b0:	00000001 	andeq	r0, r0, r1
 2b4:	00000001 	andeq	r0, r0, r1
 2b8:	00000001 	andeq	r0, r0, r1
 2bc:	00000001 	andeq	r0, r0, r1
 2c0:	00000001 	andeq	r0, r0, r1
 2c4:	00000001 	andeq	r0, r0, r1
 2c8:	00000001 	andeq	r0, r0, r1
 2cc:	00000001 	andeq	r0, r0, r1
 2d0:	00000001 	andeq	r0, r0, r1
 2d4:	00000001 	andeq	r0, r0, r1
	...
 2e0:	00000001 	andeq	r0, r0, r1
 2e4:	00000001 	andeq	r0, r0, r1
 2e8:	00000001 	andeq	r0, r0, r1
 2ec:	00000001 	andeq	r0, r0, r1
	...
 2f8:	00000001 	andeq	r0, r0, r1
 2fc:	00000001 	andeq	r0, r0, r1
 300:	00000001 	andeq	r0, r0, r1
 304:	00000001 	andeq	r0, r0, r1
 308:	00000001 	andeq	r0, r0, r1
 30c:	00000001 	andeq	r0, r0, r1
	...
 318:	00000001 	andeq	r0, r0, r1
 31c:	00000001 	andeq	r0, r0, r1
 320:	00000001 	andeq	r0, r0, r1
 324:	00000001 	andeq	r0, r0, r1
	...
 330:	00000001 	andeq	r0, r0, r1
 334:	00000001 	andeq	r0, r0, r1
	...
 340:	00001a38 	andeq	r1, r0, r8, lsr sl
 344:	00001a40 	andeq	r1, r0, r0, asr #20
 348:	00001a42 	andeq	r1, r0, r2, asr #20
 34c:	00001a58 	andeq	r1, r0, r8, asr sl
 350:	00001a5a 	andeq	r1, r0, sl, asr sl
 354:	00001a5e 	andeq	r1, r0, lr, asr sl
 358:	00001a60 	andeq	r1, r0, r0, ror #20
 35c:	00001a66 	andeq	r1, r0, r6, ror #20
	...
 368:	00001b1c 	andeq	r1, r0, ip, lsl fp
 36c:	00001b26 	andeq	r1, r0, r6, lsr #22
 370:	00001b2c 	andeq	r1, r0, ip, lsr #22
 374:	00001b40 	andeq	r1, r0, r0, asr #22
 378:	00001b46 	andeq	r1, r0, r6, asr #22
 37c:	00001b4a 	andeq	r1, r0, sl, asr #22
 380:	00001b50 	andeq	r1, r0, r0, asr fp
 384:	00001b56 	andeq	r1, r0, r6, asr fp
	...
 390:	00001d8c 	andeq	r1, r0, ip, lsl #27
 394:	00001dd4 	ldrdeq	r1, [r0], -r4
 398:	00001dd6 	ldrdeq	r1, [r0], -r6
 39c:	00001dde 	ldrdeq	r1, [r0], -lr
	...
 3a8:	00001a0c 	andeq	r1, r0, ip, lsl #20
 3ac:	00001a7c 	andeq	r1, r0, ip, ror sl
 3b0:	00001a7c 	andeq	r1, r0, ip, ror sl
 3b4:	00001ab6 			; <UNDEFINED> instruction: 0x00001ab6
 3b8:	00001ab8 			; <UNDEFINED> instruction: 0x00001ab8
 3bc:	00001b16 	andeq	r1, r0, r6, lsl fp
 3c0:	00001b18 	andeq	r1, r0, r8, lsl fp
 3c4:	00001be0 	andeq	r1, r0, r0, ror #23
 3c8:	00001be0 	andeq	r1, r0, r0, ror #23
 3cc:	00001cc0 	andeq	r1, r0, r0, asr #25
 3d0:	00001cc0 	andeq	r1, r0, r0, asr #25
 3d4:	00001d74 	andeq	r1, r0, r4, ror sp
 3d8:	00001d74 	andeq	r1, r0, r4, ror sp
 3dc:	00001df8 	strdeq	r1, [r0], -r8
	...
 3e8:	00000001 	andeq	r0, r0, r1
 3ec:	00000001 	andeq	r0, r0, r1
 3f0:	00000001 	andeq	r0, r0, r1
 3f4:	00000001 	andeq	r0, r0, r1
 3f8:	00000001 	andeq	r0, r0, r1
 3fc:	00000001 	andeq	r0, r0, r1
 400:	00000001 	andeq	r0, r0, r1
 404:	00000001 	andeq	r0, r0, r1
 408:	00000001 	andeq	r0, r0, r1
 40c:	00000001 	andeq	r0, r0, r1
	...
 418:	00000001 	andeq	r0, r0, r1
 41c:	00000001 	andeq	r0, r0, r1
 420:	00000001 	andeq	r0, r0, r1
 424:	00000001 	andeq	r0, r0, r1
 428:	00000001 	andeq	r0, r0, r1
 42c:	00000001 	andeq	r0, r0, r1
	...
 438:	00000001 	andeq	r0, r0, r1
 43c:	00000001 	andeq	r0, r0, r1
 440:	00000001 	andeq	r0, r0, r1
 444:	00000001 	andeq	r0, r0, r1
 448:	00000001 	andeq	r0, r0, r1
 44c:	00000001 	andeq	r0, r0, r1
	...
 458:	00000001 	andeq	r0, r0, r1
 45c:	00000001 	andeq	r0, r0, r1
 460:	00000001 	andeq	r0, r0, r1
 464:	00000001 	andeq	r0, r0, r1
 468:	00000001 	andeq	r0, r0, r1
 46c:	00000001 	andeq	r0, r0, r1
	...
 478:	00001e02 	andeq	r1, r0, r2, lsl #28
 47c:	00001e06 	andeq	r1, r0, r6, lsl #28
 480:	00001e0a 	andeq	r1, r0, sl, lsl #28
 484:	00001eda 	ldrdeq	r1, [r0], -sl
 488:	00001f64 	andeq	r1, r0, r4, ror #30
 48c:	00001f74 	andeq	r1, r0, r4, ror pc
	...
 498:	00001e28 	andeq	r1, r0, r8, lsr #28
 49c:	00001e2a 	andeq	r1, r0, sl, lsr #28
 4a0:	00001e36 	andeq	r1, r0, r6, lsr lr
 4a4:	00001e38 	andeq	r1, r0, r8, lsr lr
 4a8:	00001e3c 	andeq	r1, r0, ip, lsr lr
 4ac:	00001eda 	ldrdeq	r1, [r0], -sl
 4b0:	00001f64 	andeq	r1, r0, r4, ror #30
 4b4:	00001f74 	andeq	r1, r0, r4, ror pc
	...
 4c0:	00001e28 	andeq	r1, r0, r8, lsr #28
 4c4:	00001e2a 	andeq	r1, r0, sl, lsr #28
 4c8:	00001e36 	andeq	r1, r0, r6, lsr lr
 4cc:	00001e38 	andeq	r1, r0, r8, lsr lr
 4d0:	00001e3c 	andeq	r1, r0, ip, lsr lr
 4d4:	00001e4c 	andeq	r1, r0, ip, asr #28
 4d8:	00001e50 	andeq	r1, r0, r0, asr lr
 4dc:	00001e54 	andeq	r1, r0, r4, asr lr
	...
 4e8:	00001e56 	andeq	r1, r0, r6, asr lr
 4ec:	00001eac 	andeq	r1, r0, ip, lsr #29
 4f0:	00001f64 	andeq	r1, r0, r4, ror #30
 4f4:	00001f74 	andeq	r1, r0, r4, ror pc
	...
 500:	00000001 	andeq	r0, r0, r1
 504:	00000001 	andeq	r0, r0, r1
 508:	00001df8 	strdeq	r1, [r0], -r8
 50c:	00001f74 	andeq	r1, r0, r4, ror pc
	...
 518:	00001fd4 	ldrdeq	r1, [r0], -r4
 51c:	00001fd6 	ldrdeq	r1, [r0], -r6
 520:	00001fdc 	ldrdeq	r1, [r0], -ip
 524:	00001fe0 	andeq	r1, r0, r0, ror #31
 528:	00001fe4 	andeq	r1, r0, r4, ror #31
 52c:	00001ffa 	strdeq	r1, [r0], -sl
	...
 538:	00000001 	andeq	r0, r0, r1
 53c:	00000001 	andeq	r0, r0, r1
 540:	00000001 	andeq	r0, r0, r1
 544:	00000001 	andeq	r0, r0, r1
	...
 550:	000022cc 	andeq	r2, r0, ip, asr #5
 554:	000022ce 	andeq	r2, r0, lr, asr #5
 558:	000022d0 	ldrdeq	r2, [r0], -r0
 55c:	00002354 	andeq	r2, r0, r4, asr r3
	...
 568:	00002354 	andeq	r2, r0, r4, asr r3
 56c:	000023c6 	andeq	r2, r0, r6, asr #7
 570:	000023cc 	andeq	r2, r0, ip, asr #7
 574:	000023d2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>
	...
 580:	000023c6 	andeq	r2, r0, r6, asr #7
 584:	000023cc 	andeq	r2, r0, ip, asr #7
 588:	000023d2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>
 58c:	00002454 	andeq	r2, r0, r4, asr r4
	...
 598:	000023c6 	andeq	r2, r0, r6, asr #7
 59c:	000023cc 	andeq	r2, r0, ip, asr #7
 5a0:	000023d2 	ldrdeq	r2, [r0], -r2	; <UNPREDICTABLE>
 5a4:	0000241c 	andeq	r2, r0, ip, lsl r4
	...
 5b0:	000028b8 			; <UNDEFINED> instruction: 0x000028b8
 5b4:	000028ba 			; <UNDEFINED> instruction: 0x000028ba
 5b8:	000028c0 	andeq	r2, r0, r0, asr #17
 5bc:	00002908 	andeq	r2, r0, r8, lsl #18
	...
 5c8:	00002982 	andeq	r2, r0, r2, lsl #19
 5cc:	00002a06 	andeq	r2, r0, r6, lsl #20
 5d0:	00002a0c 	andeq	r2, r0, ip, lsl #20
 5d4:	00002a12 	andeq	r2, r0, r2, lsl sl
	...
 5e0:	00002a06 	andeq	r2, r0, r6, lsl #20
 5e4:	00002a0c 	andeq	r2, r0, ip, lsl #20
 5e8:	00002a12 	andeq	r2, r0, r2, lsl sl
 5ec:	00002a96 	muleq	r0, r6, sl
	...
 5f8:	00002a06 	andeq	r2, r0, r6, lsl #20
 5fc:	00002a0c 	andeq	r2, r0, ip, lsl #20
 600:	00002a12 	andeq	r2, r0, r2, lsl sl
 604:	00002a5c 	andeq	r2, r0, ip, asr sl
	...
 610:	00002da0 	andeq	r2, r0, r0, lsr #27
 614:	00002dea 	andeq	r2, r0, sl, ror #27
 618:	00002dee 	andeq	r2, r0, lr, ror #27
 61c:	00002df4 	strdeq	r2, [r0], -r4
	...
 628:	00002dea 	andeq	r2, r0, sl, ror #27
 62c:	00002dee 	andeq	r2, r0, lr, ror #27
 630:	00002df4 	strdeq	r2, [r0], -r4
 634:	00002e70 	andeq	r2, r0, r0, ror lr
	...
 640:	00002dea 	andeq	r2, r0, sl, ror #27
 644:	00002dee 	andeq	r2, r0, lr, ror #27
 648:	00002df4 	strdeq	r2, [r0], -r4
 64c:	00002e3a 	andeq	r2, r0, sl, lsr lr
	...
 658:	00001f74 	andeq	r1, r0, r4, ror pc
 65c:	00001f92 	muleq	r0, r2, pc	; <UNPREDICTABLE>
 660:	00001f94 	muleq	r0, r4, pc	; <UNPREDICTABLE>
 664:	00002002 	andeq	r2, r0, r2
 668:	00002004 	andeq	r2, r0, r4
 66c:	0000209e 	muleq	r0, lr, r0
 670:	000020a0 	andeq	r2, r0, r0, lsr #1
 674:	00002162 	andeq	r2, r0, r2, ror #2
 678:	00002164 	andeq	r2, r0, r4, ror #2
 67c:	000021aa 	andeq	r2, r0, sl, lsr #3
 680:	000021ac 	andeq	r2, r0, ip, lsr #3
 684:	000021f8 	strdeq	r2, [r0], -r8
 688:	000021f8 	strdeq	r2, [r0], -r8
 68c:	0000223e 	andeq	r2, r0, lr, lsr r2
 690:	00002240 	andeq	r2, r0, r0, asr #4
 694:	000022c8 	andeq	r2, r0, r8, asr #5
 698:	00000001 	andeq	r0, r0, r1
 69c:	00000001 	andeq	r0, r0, r1
 6a0:	00000001 	andeq	r0, r0, r1
 6a4:	00000001 	andeq	r0, r0, r1
 6a8:	000022c8 	andeq	r2, r0, r8, asr #5
 6ac:	000028b2 			; <UNDEFINED> instruction: 0x000028b2
 6b0:	00000001 	andeq	r0, r0, r1
 6b4:	00000001 	andeq	r0, r0, r1
 6b8:	000028b4 			; <UNDEFINED> instruction: 0x000028b4
 6bc:	00002ee8 	andeq	r2, r0, r8, ror #29
	...
 6c8:	00002ef6 	strdeq	r2, [r0], -r6
 6cc:	00002f14 	andeq	r2, r0, r4, lsl pc
 6d0:	00003068 	andeq	r3, r0, r8, rrx
 6d4:	00003074 	andeq	r3, r0, r4, ror r0
 6d8:	00003082 	andeq	r3, r0, r2, lsl #1
 6dc:	00003088 	andeq	r3, r0, r8, lsl #1
	...
 6e8:	00003006 	andeq	r3, r0, r6
 6ec:	00003008 	andeq	r3, r0, r8
 6f0:	0000300c 	andeq	r3, r0, ip
 6f4:	00003020 	andeq	r3, r0, r0, lsr #32
	...
 700:	00003022 	andeq	r3, r0, r2, lsr #32
 704:	00003024 	andeq	r3, r0, r4, lsr #32
 708:	00003028 	andeq	r3, r0, r8, lsr #32
 70c:	0000305c 	andeq	r3, r0, ip, asr r0
	...
 718:	00000001 	andeq	r0, r0, r1
 71c:	00000001 	andeq	r0, r0, r1
 720:	00000001 	andeq	r0, r0, r1
 724:	00000001 	andeq	r0, r0, r1
	...
 730:	00000001 	andeq	r0, r0, r1
 734:	00000001 	andeq	r0, r0, r1
 738:	00000001 	andeq	r0, r0, r1
 73c:	00000001 	andeq	r0, r0, r1
	...
 748:	00000001 	andeq	r0, r0, r1
 74c:	00000001 	andeq	r0, r0, r1
 750:	00000001 	andeq	r0, r0, r1
 754:	00000001 	andeq	r0, r0, r1
	...
 760:	00000001 	andeq	r0, r0, r1
 764:	00000001 	andeq	r0, r0, r1
 768:	00000001 	andeq	r0, r0, r1
 76c:	00000001 	andeq	r0, r0, r1
	...
 778:	00000001 	andeq	r0, r0, r1
 77c:	00000001 	andeq	r0, r0, r1
 780:	00000001 	andeq	r0, r0, r1
 784:	00000001 	andeq	r0, r0, r1
	...
 790:	00000001 	andeq	r0, r0, r1
 794:	00000001 	andeq	r0, r0, r1
 798:	00000001 	andeq	r0, r0, r1
 79c:	00000001 	andeq	r0, r0, r1
	...
 7a8:	00000001 	andeq	r0, r0, r1
 7ac:	00000001 	andeq	r0, r0, r1
 7b0:	00000001 	andeq	r0, r0, r1
 7b4:	00000001 	andeq	r0, r0, r1
	...
 7c0:	00000001 	andeq	r0, r0, r1
 7c4:	00000001 	andeq	r0, r0, r1
 7c8:	00000001 	andeq	r0, r0, r1
 7cc:	00000001 	andeq	r0, r0, r1
 7d0:	00000001 	andeq	r0, r0, r1
 7d4:	00000001 	andeq	r0, r0, r1
	...
 7e0:	00000001 	andeq	r0, r0, r1
 7e4:	00000001 	andeq	r0, r0, r1
 7e8:	00000001 	andeq	r0, r0, r1
 7ec:	00000001 	andeq	r0, r0, r1
	...
 7f8:	00000001 	andeq	r0, r0, r1
 7fc:	00000001 	andeq	r0, r0, r1
 800:	00000001 	andeq	r0, r0, r1
 804:	00000001 	andeq	r0, r0, r1
 808:	00000001 	andeq	r0, r0, r1
 80c:	00000001 	andeq	r0, r0, r1
	...
 818:	00000001 	andeq	r0, r0, r1
 81c:	00000001 	andeq	r0, r0, r1
 820:	00000001 	andeq	r0, r0, r1
 824:	00000001 	andeq	r0, r0, r1
	...
 830:	00000001 	andeq	r0, r0, r1
 834:	00000001 	andeq	r0, r0, r1
 838:	00002ee8 	andeq	r2, r0, r8, ror #29
 83c:	00003088 	andeq	r3, r0, r8, lsl #1
 840:	00000001 	andeq	r0, r0, r1
 844:	00000001 	andeq	r0, r0, r1
 848:	00000001 	andeq	r0, r0, r1
 84c:	00000001 	andeq	r0, r0, r1
 850:	00000001 	andeq	r0, r0, r1
 854:	00000001 	andeq	r0, r0, r1
 858:	00000001 	andeq	r0, r0, r1
 85c:	00000001 	andeq	r0, r0, r1
 860:	00000001 	andeq	r0, r0, r1
 864:	00000001 	andeq	r0, r0, r1
 868:	00000001 	andeq	r0, r0, r1
 86c:	00000001 	andeq	r0, r0, r1
 870:	00000001 	andeq	r0, r0, r1
 874:	00000001 	andeq	r0, r0, r1
	...
 880:	00000001 	andeq	r0, r0, r1
 884:	00000001 	andeq	r0, r0, r1
 888:	00000001 	andeq	r0, r0, r1
 88c:	00000001 	andeq	r0, r0, r1
 890:	00000001 	andeq	r0, r0, r1
 894:	00000001 	andeq	r0, r0, r1
	...
 8a0:	00000001 	andeq	r0, r0, r1
 8a4:	00000001 	andeq	r0, r0, r1
 8a8:	00000001 	andeq	r0, r0, r1
 8ac:	00000001 	andeq	r0, r0, r1
	...
 8b8:	00005050 	andeq	r5, r0, r0, asr r0
 8bc:	000050a8 	andeq	r5, r0, r8, lsr #1
 8c0:	000050ac 	andeq	r5, r0, ip, lsr #1
 8c4:	000050d2 	ldrdeq	r5, [r0], -r2
	...
 8d0:	000050fc 	strdeq	r5, [r0], -ip
 8d4:	000050fe 	strdeq	r5, [r0], -lr
 8d8:	00005102 	andeq	r5, r0, r2, lsl #2
 8dc:	00005104 	andeq	r5, r0, r4, lsl #2
 8e0:	00005118 	andeq	r5, r0, r8, lsl r1
 8e4:	0000511c 	andeq	r5, r0, ip, lsl r1
 8e8:	0000513a 	andeq	r5, r0, sl, lsr r1
 8ec:	00005162 	andeq	r5, r0, r2, ror #2
 8f0:	00005236 	andeq	r5, r0, r6, lsr r2
 8f4:	0000528e 	andeq	r5, r0, lr, lsl #5
 8f8:	000052d4 	ldrdeq	r5, [r0], -r4
 8fc:	000052da 	ldrdeq	r5, [r0], -sl
	...
 908:	00005162 	andeq	r5, r0, r2, ror #2
 90c:	0000519c 	muleq	r0, ip, r1
 910:	0000528e 	andeq	r5, r0, lr, lsl #5
 914:	000052d4 	ldrdeq	r5, [r0], -r4
 918:	000052da 	ldrdeq	r5, [r0], -sl
 91c:	000052ec 	andeq	r5, r0, ip, ror #5
	...
 928:	00003088 	andeq	r3, r0, r8, lsl #1
 92c:	000030e0 	andeq	r3, r0, r0, ror #1
 930:	000030e0 	andeq	r3, r0, r0, ror #1
 934:	00005044 	andeq	r5, r0, r4, asr #32
 938:	00005044 	andeq	r5, r0, r4, asr #32
 93c:	000050d2 	ldrdeq	r5, [r0], -r2
 940:	000050d4 	ldrdeq	r5, [r0], -r4
 944:	000052ec 	andeq	r5, r0, ip, ror #5
	...
 950:	000052fc 	strdeq	r5, [r0], -ip
 954:	000053a0 	andeq	r5, r0, r0, lsr #7
 958:	000053a2 	andeq	r5, r0, r2, lsr #7
 95c:	000053a6 	andeq	r5, r0, r6, lsr #7
	...
 968:	00005480 	andeq	r5, r0, r0, lsl #9
 96c:	0000548a 	andeq	r5, r0, sl, lsl #9
 970:	00005494 	muleq	r0, r4, r4
 974:	00005498 	muleq	r0, r8, r4
 978:	0000549c 	muleq	r0, ip, r4
 97c:	000054a0 	andeq	r5, r0, r0, lsr #9
 980:	000054a4 	andeq	r5, r0, r4, lsr #9
 984:	000054a6 	andeq	r5, r0, r6, lsr #9
	...
 990:	0000548a 	andeq	r5, r0, sl, lsl #9
 994:	00005494 	muleq	r0, r4, r4
 998:	000054a6 	andeq	r5, r0, r6, lsr #9
 99c:	000054aa 	andeq	r5, r0, sl, lsr #9
 9a0:	000054ae 	andeq	r5, r0, lr, lsr #9
 9a4:	000054b2 			; <UNDEFINED> instruction: 0x000054b2
 9a8:	000054b6 			; <UNDEFINED> instruction: 0x000054b6
 9ac:	000054b8 			; <UNDEFINED> instruction: 0x000054b8
	...
 9b8:	000054bc 			; <UNDEFINED> instruction: 0x000054bc
 9bc:	000054c0 	andeq	r5, r0, r0, asr #9
 9c0:	000054ca 	andeq	r5, r0, sl, asr #9
 9c4:	000054d2 	ldrdeq	r5, [r0], -r2
 9c8:	000054d6 	ldrdeq	r5, [r0], -r6
 9cc:	000054d8 	ldrdeq	r5, [r0], -r8
 9d0:	000054e0 	andeq	r5, r0, r0, ror #9
 9d4:	000054e4 	andeq	r5, r0, r4, ror #9
 9d8:	000054ee 	andeq	r5, r0, lr, ror #9
 9dc:	000054f2 	strdeq	r5, [r0], -r2
 9e0:	000054fa 	strdeq	r5, [r0], -sl
 9e4:	000054fc 	strdeq	r5, [r0], -ip
	...
 9f0:	000054c0 	andeq	r5, r0, r0, asr #9
 9f4:	000054c2 	andeq	r5, r0, r2, asr #9
 9f8:	000054c6 	andeq	r5, r0, r6, asr #9
 9fc:	000054ca 	andeq	r5, r0, sl, asr #9
 a00:	000054d4 	ldrdeq	r5, [r0], -r4
 a04:	000054d6 	ldrdeq	r5, [r0], -r6
 a08:	000054e8 	andeq	r5, r0, r8, ror #9
 a0c:	000054ea 	andeq	r5, r0, sl, ror #9
 a10:	000054f4 	strdeq	r5, [r0], -r4
 a14:	000054f8 	strdeq	r5, [r0], -r8
 a18:	00005508 	andeq	r5, r0, r8, lsl #10
 a1c:	0000550a 	andeq	r5, r0, sl, lsl #10
	...
 a28:	000054d8 	ldrdeq	r5, [r0], -r8
 a2c:	000054da 	ldrdeq	r5, [r0], -sl
 a30:	000054e4 	andeq	r5, r0, r4, ror #9
 a34:	000054e8 	andeq	r5, r0, r8, ror #9
 a38:	000054f8 	strdeq	r5, [r0], -r8
 a3c:	000054fa 	strdeq	r5, [r0], -sl
 a40:	000054fc 	strdeq	r5, [r0], -ip
 a44:	000054fe 	strdeq	r5, [r0], -lr
 a48:	0000550a 	andeq	r5, r0, sl, lsl #10
 a4c:	00005510 	andeq	r5, r0, r0, lsl r5
	...
 a58:	00005524 	andeq	r5, r0, r4, lsr #10
 a5c:	0000552c 	andeq	r5, r0, ip, lsr #10
 a60:	00005590 	muleq	r0, r0, r5
 a64:	00005598 	muleq	r0, r8, r5
	...
 a70:	0000552c 	andeq	r5, r0, ip, lsr #10
 a74:	00005536 	andeq	r5, r0, r6, lsr r5
 a78:	000055ea 	andeq	r5, r0, sl, ror #11
 a7c:	000055ee 	andeq	r5, r0, lr, ror #11
 a80:	000055f2 	strdeq	r5, [r0], -r2
 a84:	000055f6 	strdeq	r5, [r0], -r6
 a88:	000055fc 	strdeq	r5, [r0], -ip
 a8c:	000055fe 	strdeq	r5, [r0], -lr
	...
 a98:	00005536 	andeq	r5, r0, r6, lsr r5
 a9c:	00005540 	andeq	r5, r0, r0, asr #10
 aa0:	00005610 	andeq	r5, r0, r0, lsl r6
 aa4:	00005614 	andeq	r5, r0, r4, lsl r6
 aa8:	00005618 	andeq	r5, r0, r8, lsl r6
 aac:	0000561c 	andeq	r5, r0, ip, lsl r6
 ab0:	0000562e 	andeq	r5, r0, lr, lsr #12
 ab4:	00005630 	andeq	r5, r0, r0, lsr r6
	...
 ac0:	00005598 	muleq	r0, r8, r5
 ac4:	000055a0 	andeq	r5, r0, r0, lsr #11
 ac8:	000055a2 	andeq	r5, r0, r2, lsr #11
 acc:	000055a6 	andeq	r5, r0, r6, lsr #11
 ad0:	000055aa 	andeq	r5, r0, sl, lsr #11
 ad4:	000055ae 	andeq	r5, r0, lr, lsr #11
	...
 ae0:	00005602 	andeq	r5, r0, r2, lsl #12
 ae4:	00005606 	andeq	r5, r0, r6, lsl #12
 ae8:	0000560c 	andeq	r5, r0, ip, lsl #12
 aec:	00005610 	andeq	r5, r0, r0, lsl r6
 af0:	0000561c 	andeq	r5, r0, ip, lsl r6
 af4:	0000561e 	andeq	r5, r0, lr, lsl r6
 af8:	00005626 	andeq	r5, r0, r6, lsr #12
 afc:	0000562a 	andeq	r5, r0, sl, lsr #12
 b00:	00005630 	andeq	r5, r0, r0, lsr r6
 b04:	00005634 	andeq	r5, r0, r4, lsr r6
 b08:	00005636 	andeq	r5, r0, r6, lsr r6
 b0c:	0000563c 	andeq	r5, r0, ip, lsr r6
	...
 b18:	000057a4 	andeq	r5, r0, r4, lsr #15
 b1c:	000057ae 	andeq	r5, r0, lr, lsr #15
 b20:	000057b2 			; <UNDEFINED> instruction: 0x000057b2
 b24:	000057d2 	ldrdeq	r5, [r0], -r2
	...
 b30:	00005862 	andeq	r5, r0, r2, ror #16
 b34:	00005874 	andeq	r5, r0, r4, ror r8
 b38:	00005876 	andeq	r5, r0, r6, ror r8
 b3c:	000058dc 	ldrdeq	r5, [r0], -ip
 b40:	000058de 	ldrdeq	r5, [r0], -lr
 b44:	000058e2 	andeq	r5, r0, r2, ror #17
	...
	.type	Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit
 b50:	0000591e 	andeq	r5, r0, lr, lsl r9

CopyDataInit:
	ldr	r3, =_sidata
	ldr	r3, [r3, r1]
 b54:	0000598e 	andeq	r5, r0, lr, lsl #19
	str	r3, [r0, r1]
	adds	r1, r1, #4
 b58:	00005992 	muleq	r0, r2, r9

LoopCopyDataInit:
	ldr	r0, =_sdata
	ldr	r3, =_edata
 b5c:	000059b4 			; <UNDEFINED> instruction: 0x000059b4
	adds	r2, r0, r1
	cmp	r2, r3
 b60:	000059b8 			; <UNDEFINED> instruction: 0x000059b8
	bcc	CopyDataInit
 b64:	000059ba 			; <UNDEFINED> instruction: 0x000059ba
	ldr	r2, =_sbss
	b	LoopFillZerobss
 b68:	000059c4 	andeq	r5, r0, r4, asr #19
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 b6c:	000059c8 	andeq	r5, r0, r8, asr #19
	str	r3, [r2], #4
 b70:	000059dc 	ldrdeq	r5, [r0], -ip

LoopFillZerobss:
	ldr	r3, = _ebss
	cmp	r2, r3
 b74:	000059e0 	andeq	r5, r0, r0, ror #19
	...
/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
  b	LoopCopyDataInit

CopyDataInit:
	ldr	r3, =_sidata
 b80:	00005a06 	andeq	r5, r0, r6, lsl #20
	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
	adds	r1, r1, #4

LoopCopyDataInit:
	ldr	r0, =_sdata
 b84:	00005a88 	andeq	r5, r0, r8, lsl #21
	ldr	r3, =_edata
 b88:	00005a8a 	andeq	r5, r0, sl, lsl #21
	adds	r2, r0, r1
	cmp	r2, r3
	bcc	CopyDataInit
	ldr	r2, =_sbss
 b8c:	00005a8e 	andeq	r5, r0, lr, lsl #21
FillZerobss:
	movs	r3, #0
	str	r3, [r2], #4

LoopFillZerobss:
	ldr	r3, = _ebss
 b90:	00005a90 	muleq	r0, r0, sl
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 b94:	00005a94 	muleq	r0, r4, sl
	...
    if (interface > NUM_ALT_SETTINGS) {
        return USB_UNSUPPORT;
    }

    return USB_SUCCESS;
}
 ba0:	000052ec 	andeq	r5, r0, ip, ror #5
 ba4:	00005780 	andeq	r5, r0, r0, lsl #15
 * in the core but we are given these callbacks at the
 * application level
 *******************************************/

void usbGetConfiguration(void)
{
 ba8:	00005780 	andeq	r5, r0, r0, lsl #15
    /* nothing process */
}

void usbSetConfiguration(void)
{
    if (pInformation->Current_Configuration != 0) {
 bac:	00005808 	andeq	r5, r0, r8, lsl #16
 bb0:	00005808 	andeq	r5, r0, r8, lsl #16
        bDeviceState = CONFIGURED;
 bb4:	00005a9e 	muleq	r0, lr, sl
	...
 bc0:	00005aa0 	andeq	r5, r0, r0, lsr #21
    }
}

void usbGetInterface(void)
{
 bc4:	00005ae4 	andeq	r5, r0, r4, ror #21
{
    /* nothing process */
}

void usbGetStatus(void)
{
 bc8:	00005ae4 	andeq	r5, r0, r4, ror #21
{
    /* nothing process */
}

void usbSetEndpointFeature(void)
{
 bcc:	00005c3c 	andeq	r5, r0, ip, lsr ip
	...
    /* nothing process */
}

void usbSetDeviceAddress(void)
{
    bDeviceState = ADDRESSED;
 bd8:	00000001 	andeq	r0, r0, r1
    usbEnbISR();
    bDeviceState = UNCONNECTED;
}

void usbReset(void)
{    
 bdc:	00000001 	andeq	r0, r0, r1
    dfuUpdateByReset();
 be0:	00000001 	andeq	r0, r0, r1

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 be4:	00000001 	andeq	r0, r0, r1
	...
    _SetEPTxStatus(ENDP0, EP_TX_STALL);

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);

    Clear_Status_Out(ENDP0);
 bf0:	00005d36 	andeq	r5, r0, r6, lsr sp
    dfuUpdateByReset();

    pInformation->Current_Configuration = 0;
    pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];

    _SetBTABLE(BTABLE_ADDRESS);
 bf4:	00005d38 	andeq	r5, r0, r8, lsr sp
 bf8:	00005d48 	andeq	r5, r0, r8, asr #26

    // set up the ctrl endpoint
    _SetEPType(ENDP0, EP_CONTROL);
 bfc:	00005d74 	andeq	r5, r0, r4, ror sp
	...
 c08:	00000001 	andeq	r0, r0, r1
    _SetEPTxStatus(ENDP0, EP_TX_STALL);
 c0c:	00000001 	andeq	r0, r0, r1
 c10:	00000001 	andeq	r0, r0, r1
 c14:	00000001 	andeq	r0, r0, r1
	...

    _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
 c20:	00000001 	andeq	r0, r0, r1
 c24:	00000001 	andeq	r0, r0, r1
 c28:	00000001 	andeq	r0, r0, r1
    _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 c2c:	00000001 	andeq	r0, r0, r1
	...
 c38:	00000001 	andeq	r0, r0, r1
 c3c:	00000001 	andeq	r0, r0, r1

    Clear_Status_Out(ENDP0);
 c40:	00000001 	andeq	r0, r0, r1

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 c44:	00000001 	andeq	r0, r0, r1
 c48:	00000001 	andeq	r0, r0, r1
 c4c:	00000001 	andeq	r0, r0, r1
	...
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
 c58:	00000001 	andeq	r0, r0, r1
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
}
 c5c:	00000001 	andeq	r0, r0, r1

    SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
    //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
    SetEPRxValid(ENDP0);

    bDeviceState = ATTACHED;
 c60:	00000001 	andeq	r0, r0, r1
    SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
 c64:	00000001 	andeq	r0, r0, r1
	...
 c70:	00000001 	andeq	r0, r0, r1
 c74:	00000001 	andeq	r0, r0, r1
 c78:	00000001 	andeq	r0, r0, r1
 c7c:	00000001 	andeq	r0, r0, r1
	...
void usbStatusOut(void)
{
    return;
}

RESULT usbDataSetup(u8 request) {
 c88:	00000001 	andeq	r0, r0, r1
    u8 *(*CopyRoutine)(u16);
    CopyRoutine = NULL;

    // handle dfu class requests
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
 c8c:	00000001 	andeq	r0, r0, r1
 c90:	00000001 	andeq	r0, r0, r1
 c94:	00000001 	andeq	r0, r0, r1
        if (dfuUpdateByRequest()) {
 c98:	00000001 	andeq	r0, r0, r1
 c9c:	00000001 	andeq	r0, r0, r1
            // successfull state transition, handle the request
            switch (request) {
 ca0:	00000001 	andeq	r0, r0, r1
 ca4:	00000001 	andeq	r0, r0, r1
 ca8:	00000001 	andeq	r0, r0, r1
 cac:	00000001 	andeq	r0, r0, r1
            case(DFU_GETSTATE):
                CopyRoutine = dfuCopyState;
                break;
            case(DFU_DNLOAD):
                CopyRoutine = dfuCopyDNLOAD;
                break;
 cb0:	00000001 	andeq	r0, r0, r1
            case(DFU_UPLOAD):
                CopyRoutine = dfuCopyUPLOAD;
                break;
 cb4:	00000001 	andeq	r0, r0, r1
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
        if (dfuUpdateByRequest()) {
            // successfull state transition, handle the request
            switch (request) {
            case(DFU_GETSTATUS):
                CopyRoutine = dfuCopyStatus;
 cb8:	00000001 	andeq	r0, r0, r1
            }
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
 cbc:	00000001 	andeq	r0, r0, r1
        pInformation->Ctrl_Info.Usb_wOffset = 0;
        (*CopyRoutine)(0);
 cc0:	00000001 	andeq	r0, r0, r1
        }
    }

    if (CopyRoutine != NULL) {
        pInformation->Ctrl_Info.CopyData = CopyRoutine;
        pInformation->Ctrl_Info.Usb_wOffset = 0;
 cc4:	00000001 	andeq	r0, r0, r1
        (*CopyRoutine)(0);

        return USB_SUCCESS;
 cc8:	00000001 	andeq	r0, r0, r1
    }

    return USB_UNSUPPORT;
 ccc:	00000001 	andeq	r0, r0, r1
}
 cd0:	00000001 	andeq	r0, r0, r1
 cd4:	00000001 	andeq	r0, r0, r1
 cd8:	00000001 	andeq	r0, r0, r1
 cdc:	00000001 	andeq	r0, r0, r1
 ce0:	00000001 	andeq	r0, r0, r1
    return USB_SUCCESS;
}

u8 *usbGetDeviceDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
 ce4:	00000001 	andeq	r0, r0, r1
 ce8:	00000001 	andeq	r0, r0, r1
 cec:	00000001 	andeq	r0, r0, r1
}

u8 *usbGetConfigDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
 cf0:	00005c3c 	andeq	r5, r0, ip, lsr ip
 cf4:	00005c66 	andeq	r5, r0, r6, ror #24
 cf8:	00000001 	andeq	r0, r0, r1
}

u8 *usbGetStringDescriptor(u16 len)
{
    u8 strIndex = pInformation->USBwValue0;
 cfc:	00000001 	andeq	r0, r0, r1
 d00:	00000001 	andeq	r0, r0, r1
    if (strIndex > STR_DESC_LEN) {
 d04:	00000001 	andeq	r0, r0, r1
        return NULL;
    } else {
        return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
 d08:	00000001 	andeq	r0, r0, r1
 d0c:	00000001 	andeq	r0, r0, r1
    }
}
 d10:	00000001 	andeq	r0, r0, r1
 d14:	00000001 	andeq	r0, r0, r1
 d18:	00000001 	andeq	r0, r0, r1

u8 *usbGetFunctionalDescriptor(u16 len)
{
    return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
 d1c:	00000001 	andeq	r0, r0, r1
 d20:	00005c66 	andeq	r5, r0, r6, ror #24
 d24:	00005c84 	andeq	r5, r0, r4, lsl #25

    return USB_UNSUPPORT;
}

RESULT usbNoDataSetup(u8 request)
{
 d28:	00000001 	andeq	r0, r0, r1
    if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE_RECIPIENT)) {
 d2c:	00000001 	andeq	r0, r0, r1
 d30:	00000001 	andeq	r0, r0, r1
 d34:	00000001 	andeq	r0, r0, r1
        // todo, keep track of the destination interface, often stored in wIndex
        if (dfuUpdateByRequest()) {
 d38:	00005c84 	andeq	r5, r0, r4, lsl #25
 d3c:	00005ca0 	andeq	r5, r0, r0, lsr #25
            return USB_SUCCESS;
 d40:	00000001 	andeq	r0, r0, r1
 d44:	00000001 	andeq	r0, r0, r1
        }
    }
    return USB_UNSUPPORT;
}
 d48:	00000001 	andeq	r0, r0, r1
 d4c:	00000001 	andeq	r0, r0, r1

static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;


void setupUSB (void)
{
 d50:	00000001 	andeq	r0, r0, r1
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 d54:	00000001 	andeq	r0, r0, r1
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 d58:	00000001 	andeq	r0, r0, r1
    #ifndef USB_DISC_PIN  
    #define USB_DISC_PIN    12
    #endif

    // set up pin in host disconnected state
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 d5c:	00000001 	andeq	r0, r0, r1
    SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 d60:	00000001 	andeq	r0, r0, r1
 d64:	00000001 	andeq	r0, r0, r1
 d68:	00000001 	andeq	r0, r0, r1
 d6c:	00000001 	andeq	r0, r0, r1
            | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
        );

    // wait a while to make sure host disconnects us
    volatile u32 delay;
    for(delay = 256; delay; delay--);
 d70:	00000001 	andeq	r0, r0, r1
 d74:	00000001 	andeq	r0, r0, r1
 d78:	00000001 	andeq	r0, r0, r1
 d7c:	00000001 	andeq	r0, r0, r1
    #endif
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
 d80:	00000001 	andeq	r0, r0, r1
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
 d84:	00000001 	andeq	r0, r0, r1
 d88:	00005ca0 	andeq	r5, r0, r0, lsr #25
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
 d8c:	00005cc0 	andeq	r5, r0, r0, asr #25
#endif
#endif

  // initialize the usb application  
  wTransferSize = getFlashPageSize();
  u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
 d90:	00005cc0 	andeq	r5, r0, r0, asr #25
  u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
 d94:	00005ce0 	andeq	r5, r0, r0, ror #25
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
 d98:	00000001 	andeq	r0, r0, r1

/* application function definitions */
void usbAppInit(void)
{
    // hook in to usb_core, depends on all those damn non encapsulated externs!
    USB_Init();
 d9c:	00000001 	andeq	r0, r0, r1
  
  u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
  u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
  
  usbAppInit();
}
 da0:	00000001 	andeq	r0, r0, r1
 da4:	00000001 	andeq	r0, r0, r1
 da8:	00000001 	andeq	r0, r0, r1
 dac:	00000001 	andeq	r0, r0, r1
 db0:	00000001 	andeq	r0, r0, r1
 db4:	00000001 	andeq	r0, r0, r1
}

void usbSuspend(void)
{
    u16 wCNTR;
    wCNTR = _GetCNTR();
 db8:	00005ce0 	andeq	r5, r0, r0, ror #25
 dbc:	00005cfc 	strdeq	r5, [r0], -ip
    wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
    _SetCNTR(wCNTR);
 dc0:	00005cfc 	strdeq	r5, [r0], -ip

    // run any power reduction handlers
    bDeviceState = SUSPENDED;
 dc4:	00005d18 	andeq	r5, r0, r8, lsl sp
 dc8:	00005d18 	andeq	r5, r0, r8, lsl sp
 dcc:	00005d34 	andeq	r5, r0, r4, lsr sp
 dd0:	00000001 	andeq	r0, r0, r1
void usbResumeInit(void)
{
    u16 wCNTR;

    // restart any clocks that had been stopped
    wCNTR = _GetCNTR();
 dd4:	00000001 	andeq	r0, r0, r1
    wCNTR &= (~CNTR_LPMODE);
    _SetCNTR(wCNTR);
 dd8:	00005d34 	andeq	r5, r0, r4, lsr sp
 ddc:	00005d74 	andeq	r5, r0, r4, ror sp

    // undo power reduction handlers here
    _SetCNTR(ISR_MSK);
 de0:	00000001 	andeq	r0, r0, r1
 de4:	00000001 	andeq	r0, r0, r1
 de8:	00000001 	andeq	r0, r0, r1
}

void usbResume(RESUME_STATE eResumeSetVal)
{
 dec:	00000001 	andeq	r0, r0, r1
    u16 wCNTR;

    if (eResumeSetVal != RESUME_ESOF)
 df0:	00000001 	andeq	r0, r0, r1
        ResumeS.eState = eResumeSetVal;
 df4:	00000001 	andeq	r0, r0, r1

    switch (ResumeS.eState) {
 df8:	00000001 	andeq	r0, r0, r1
 dfc:	00000001 	andeq	r0, r0, r1
 e00:	00000001 	andeq	r0, r0, r1
 e04:	00000001 	andeq	r0, r0, r1
    case RESUME_EXTERNAL:
        usbResumeInit();
 e08:	00000001 	andeq	r0, r0, r1
        ResumeS.eState = RESUME_OFF;
        break;
    case RESUME_INTERNAL:
        usbResumeInit();
 e0c:	00000001 	andeq	r0, r0, r1
        ResumeS.eState = RESUME_START;
 e10:	00000001 	andeq	r0, r0, r1
        break;
    case RESUME_LATER:
        ResumeS.bESOFcnt = 2;
 e14:	00000001 	andeq	r0, r0, r1
        ResumeS.eState = RESUME_WAIT;
 e18:	00000001 	andeq	r0, r0, r1
        break;
    case RESUME_WAIT:
        ResumeS.bESOFcnt--;
 e1c:	00000001 	andeq	r0, r0, r1
 e20:	00000001 	andeq	r0, r0, r1
        if (ResumeS.bESOFcnt == 0)
 e24:	00000001 	andeq	r0, r0, r1
            ResumeS.eState = RESUME_START;
 e28:	00000001 	andeq	r0, r0, r1
        break;
    case RESUME_START:
        wCNTR = _GetCNTR();
 e2c:	00000001 	andeq	r0, r0, r1
 e30:	00000001 	andeq	r0, r0, r1
        wCNTR |= CNTR_RESUME;
        _SetCNTR(wCNTR);
 e34:	00000001 	andeq	r0, r0, r1
        ResumeS.eState = RESUME_ON;
 e38:	00000001 	andeq	r0, r0, r1
        ResumeS.bESOFcnt = 10;
 e3c:	00000001 	andeq	r0, r0, r1
        break;
 e40:	00000001 	andeq	r0, r0, r1
    case RESUME_ON:
        ResumeS.bESOFcnt--;
 e44:	00000001 	andeq	r0, r0, r1
 e48:	00000001 	andeq	r0, r0, r1
        if (ResumeS.bESOFcnt == 0) {
 e4c:	00000001 	andeq	r0, r0, r1
            wCNTR = _GetCNTR();
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
 e50:	00000001 	andeq	r0, r0, r1
        ResumeS.bESOFcnt = 10;
        break;
    case RESUME_ON:
        ResumeS.bESOFcnt--;
        if (ResumeS.bESOFcnt == 0) {
            wCNTR = _GetCNTR();
 e54:	00000001 	andeq	r0, r0, r1
            wCNTR &= (~CNTR_RESUME);
            _SetCNTR(wCNTR);
 e58:	00000001 	andeq	r0, r0, r1
            ResumeS.eState = RESUME_OFF;
 e5c:	00000001 	andeq	r0, r0, r1
	...
        }
        break;
    case RESUME_OFF:
    case RESUME_ESOF:
    default:
        ResumeS.eState = RESUME_OFF;
 e68:	00005d74 	andeq	r5, r0, r4, ror sp
 e6c:	00005ec8 	andeq	r5, r0, r8, asr #29
}

RESULT usbPowerOn(void)
{
    // Enable USB clock
    RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
 e70:	00000001 	andeq	r0, r0, r1
 e74:	00000001 	andeq	r0, r0, r1
	...

    _SetCNTR(CNTR_FRES);
 e80:	00005ec8 	andeq	r5, r0, r8, asr #29
 e84:	00005f00 	andeq	r5, r0, r0, lsl #30
	...
    _SetCNTR(0);
    _SetISTR(0);
 e90:	00006208 	andeq	r6, r0, r8, lsl #4

    wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
 e94:	00006210 	andeq	r6, r0, r0, lsl r2
    _SetCNTR(wInterrupt_Mask);
 e98:	00006214 	andeq	r6, r0, r4, lsl r2
    // present to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 e9c:	00006216 	andeq	r6, r0, r6, lsl r2
 ea0:	00006218 	andeq	r6, r0, r8, lsl r2
#endif
#endif

    return USB_SUCCESS;
}
 ea4:	00006228 	andeq	r6, r0, r8, lsr #4
	...
 eb0:	000063de 	ldrdeq	r6, [r0], -lr
 eb4:	00006588 	andeq	r6, r0, r8, lsl #11

RESULT usbPowerOff(void) {
    _SetCNTR(CNTR_FRES);
 eb8:	00006590 	muleq	r0, r0, r5
#endif

    return USB_SUCCESS;
}

RESULT usbPowerOff(void) {
 ebc:	000065b0 			; <UNDEFINED> instruction: 0x000065b0
	...
    _SetCNTR(CNTR_FRES);
    _SetISTR(0);
    _SetCNTR(CNTR_FRES + CNTR_PDWN);
 ec8:	00005f00 	andeq	r5, r0, r0, lsl #30
    // act unplugged to host
#ifndef USB_DISC_HARDWIRED
#ifdef HAS_MAPLE_HARDWARE
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
#else
    gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 ecc:	00005f24 	andeq	r5, r0, r4, lsr #30
 ed0:	00005f24 	andeq	r5, r0, r4, lsr #30
#endif
#endif

    // Disable USB clock
    RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
 ed4:	00005f48 	andeq	r5, r0, r8, asr #30
 ed8:	00005f48 	andeq	r5, r0, r8, asr #30
 edc:	00005fd8 	ldrdeq	r5, [r0], -r8

    return USB_SUCCESS;
}
 ee0:	00005fd8 	ldrdeq	r5, [r0], -r8
 ee4:	00006080 	andeq	r6, r0, r0, lsl #1
 ee8:	00006080 	andeq	r6, r0, r0, lsl #1
 eec:	000060b8 	strheq	r6, [r0], -r8
 ef0:	000060b8 	strheq	r6, [r0], -r8
}


void usbDsbBus(void)
{
    usbPowerOff();
 ef4:	00006100 	andeq	r6, r0, r0, lsl #2
}
/***** end of USER STANDARD REQUESTS *****/


void usbEnbISR(void)
{
 ef8:	00006100 	andeq	r6, r0, r0, lsl #2
    NVIC_InitTypeDef NVIC_InitStructure;

    NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
 efc:	000061d0 	ldrdeq	r6, [r0], -r0
    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 f00:	000061d0 	ldrdeq	r6, [r0], -r0
 f04:	00006254 	andeq	r6, r0, r4, asr r2
    NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 f08:	00006254 	andeq	r6, r0, r4, asr r2
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
 f0c:	00006278 	andeq	r6, r0, r8, ror r2
 f10:	00006278 	andeq	r6, r0, r8, ror r2
    nvicInit(&NVIC_InitStructure);
 f14:	00006294 	muleq	r0, r4, r2
}
 f18:	00006294 	muleq	r0, r4, r2

    return USB_SUCCESS;
}

void usbInit(void)
{
 f1c:	000062d4 	ldrdeq	r6, [r0], -r4
    dfuInit();
 f20:	000062d4 	ldrdeq	r6, [r0], -r4

    pInformation->Current_Configuration = 0;
 f24:	000065b0 			; <UNDEFINED> instruction: 0x000065b0
 f28:	000065b0 			; <UNDEFINED> instruction: 0x000065b0
    usbPowerOn();
 f2c:	00006678 	andeq	r6, r0, r8, ror r6

    _SetISTR(0);
    wInterrupt_Mask = ISR_MSK;
 f30:	00006678 	andeq	r6, r0, r8, ror r6
 f34:	000066b0 			; <UNDEFINED> instruction: 0x000066b0
 f38:	000066b0 			; <UNDEFINED> instruction: 0x000066b0
    _SetCNTR(wInterrupt_Mask);
 f3c:	0000670c 	andeq	r6, r0, ip, lsl #14

    // configure the cortex M3 private peripheral NVIC
    usbEnbISR();
 f40:	00000001 	andeq	r0, r0, r1
    bDeviceState = UNCONNECTED;
 f44:	00000001 	andeq	r0, r0, r1
	...
 f50:	0000670c 	andeq	r6, r0, ip, lsl #14
 f54:	0000673c 	andeq	r6, r0, ip, lsr r7
 f58:	0000673c 	andeq	r6, r0, ip, lsr r7
    NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
    nvicInit(&NVIC_InitStructure);
}

void usbDsbISR(void)
{
 f5c:	00006760 	andeq	r6, r0, r0, ror #14
	...
