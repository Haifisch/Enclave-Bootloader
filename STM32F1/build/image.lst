   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"image.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.failErase,"ax",%progbits
  19              		.align	1
  20              		.global	failErase
  21              		.thumb
  22              		.thumb_func
  24              	failErase:
  25              	.LFB1:
  26              		.file 1 "image.c"
   1:image.c       **** /*
   2:image.c       ****  * Copyright (C) 2016-2017 Sun Tzu Security, LLC. All rights reserved.
   3:image.c       ****  *
   4:image.c       ****  * This document is the property of Sun Tzu Security, LLC.
   5:image.c       ****  * It is considered confidential and proprietary.
   6:image.c       ****  *
   7:image.c       ****  * This document may not be reproduced or transmitted in any form,
   8:image.c       ****  * in whole or in part, without the express written permission of
   9:image.c       ****  * Sun Tzu Security, LLC.
  10:image.c       ****  */
  11:image.c       **** #include <stdio.h>
  12:image.c       **** #include <stdint.h>
  13:image.c       **** #include <string.h>
  14:image.c       **** #include <limits.h>
  15:image.c       **** #include <unistd.h>
  16:image.c       **** #include <errno.h>
  17:image.c       **** #include <stdarg.h>
  18:image.c       **** 
  19:image.c       **** #include "hardware.h"
  20:image.c       **** #include "sha256.h"
  21:image.c       **** #include "edsign.h"
  22:image.c       **** #include "image.h"
  23:image.c       **** 
  24:image.c       **** uint8_t rootCA[32] = {
  25:image.c       ****        0xbd, 0x0c, 0x2d, 0x04, 0x2e, 0x5a, 0x95, 0xc6, 0xb6, 0x28, 0xfc, 0x3f, 0x85, 0x6c, 0xa1, 0x
  26:image.c       ****     };
  27:image.c       **** 
  28:image.c       **** static void print_hex(const char *label, const uint8_t *data, int len)
  29:image.c       **** {
  30:image.c       ****     int i;
  31:image.c       **** 
  32:image.c       ****     uart_printf("%s: ", label);
  33:image.c       ****     for (i = 0; i < len; i++)
  34:image.c       ****         uart_printf("%02x", data[i]);
  35:image.c       ****     uart_printf("\n");
  36:image.c       **** }
  37:image.c       **** 
  38:image.c       **** void failErase () {
  27              		.loc 1 38 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 08B5     		push	{r3, lr}
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  39:image.c       **** 	// for whatever reason this only flashes upto 0x08008800
  40:image.c       **** 	flashErasePage((u32)(0x08008000));
  35              		.loc 1 40 0
  36 0002 0A48     		ldr	r0, .L2
  37 0004 FFF7FEFF 		bl	flashErasePage
  38              	.LVL0:
  41:image.c       **** 	flashErasePage((u32)(0x08008000+1024));
  39              		.loc 1 41 0
  40 0008 0948     		ldr	r0, .L2+4
  41 000a FFF7FEFF 		bl	flashErasePage
  42              	.LVL1:
  42:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
  43              		.loc 1 42 0
  44 000e 0948     		ldr	r0, .L2+8
  45 0010 FFF7FEFF 		bl	flashErasePage
  46              	.LVL2:
  43:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
  47              		.loc 1 43 0
  48 0014 0848     		ldr	r0, .L2+12
  49 0016 FFF7FEFF 		bl	flashErasePage
  50              	.LVL3:
  44:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
  51              		.loc 1 44 0
  52 001a 0848     		ldr	r0, .L2+16
  53 001c FFF7FEFF 		bl	flashErasePage
  54              	.LVL4:
  45:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
  46:image.c       **** }
  55              		.loc 1 46 0
  56 0020 BDE80840 		pop	{r3, lr}
  45:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
  57              		.loc 1 45 0
  58 0024 0648     		ldr	r0, .L2+20
  59 0026 FFF7FEBF 		b	flashErasePage
  60              	.LVL5:
  61              	.L3:
  62 002a 00BF     		.align	2
  63              	.L2:
  64 002c 00800008 		.word	134250496
  65 0030 00840008 		.word	134251520
  66 0034 20830008 		.word	134251296
  67 0038 B0840008 		.word	134251696
  68 003c 40860008 		.word	134252096
  69 0040 D0870008 		.word	134252496
  70              		.cfi_endproc
  71              	.LFE1:
  73              		.section	.text.imageCheckFromAddress,"ax",%progbits
  74              		.align	1
  75              		.global	imageCheckFromAddress
  76              		.thumb
  77              		.thumb_func
  79              	imageCheckFromAddress:
  80              	.LFB2:
  47:image.c       **** 
  48:image.c       **** int imageCheckFromAddress(ImageObjectHandle *newHandle, vu32 flashAddress, bool shouldEraseFlashOnF
  49:image.c       **** {
  81              		.loc 1 49 0
  82              		.cfi_startproc
  83              		@ args = 0, pretend = 0, frame = 336
  84              		@ frame_needed = 0, uses_anonymous_args = 0
  85              	.LVL6:
  86 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  87              		.cfi_def_cfa_offset 24
  88              		.cfi_offset 4, -24
  89              		.cfi_offset 5, -20
  90              		.cfi_offset 6, -16
  91              		.cfi_offset 7, -12
  92              		.cfi_offset 8, -8
  93              		.cfi_offset 14, -4
  94 0004 D4B0     		sub	sp, sp, #336
  95              		.cfi_def_cfa_offset 360
  96              	.LVL7:
  97              		.loc 1 49 0
  98 0006 0191     		str	r1, [sp, #4]
  99 0008 0746     		mov	r7, r0
  50:image.c       **** 	ImageRootHeader		*hdr;
  51:image.c       **** 	ImageInternalState		state;
  52:image.c       **** 	int bufferSize = 0x28+0x40;
  53:image.c       **** 	unsigned char imageBuffer[bufferSize];
  54:image.c       ****     memset(imageBuffer, 0xFF, sizeof(imageBuffer));
 100              		.loc 1 54 0
 101 000a FF21     		movs	r1, #255
 102              	.LVL8:
  49:image.c       **** {
 103              		.loc 1 49 0
 104 000c 9046     		mov	r8, r2
 105              		.loc 1 54 0
 106 000e 3AA8     		add	r0, sp, #232
 107              	.LVL9:
 108 0010 6822     		movs	r2, #104
 109              	.LVL10:
 110 0012 FFF7FEFF 		bl	memset
 111              	.LVL11:
  55:image.c       ****     memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
  56:image.c       ****     memset(&state, 0, sizeof(state));
 112              		.loc 1 56 0
 113 0016 03AE     		add	r6, sp, #12
  55:image.c       ****     memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
 114              		.loc 1 55 0
 115 0018 0199     		ldr	r1, [sp, #4]
 116 001a 6822     		movs	r2, #104
 117 001c 3AA8     		add	r0, sp, #232
 118              	.LVL12:
 119 001e FFF7FEFF 		bl	memcpy
 120              	.LVL13:
 121              		.loc 1 56 0
 122 0022 0021     		movs	r1, #0
 123 0024 1422     		movs	r2, #20
 124 0026 3046     		mov	r0, r6
 125 0028 FFF7FEFF 		bl	memset
 126              	.LVL14:
  57:image.c       **** 
  58:image.c       **** 	hdr = (ImageRootHeader *)imageBuffer;
  59:image.c       **** 
  60:image.c       **** 	if (bufferSize < sizeof(hdr)) {
  61:image.c       **** 		debug_print("buffer size %X too small for header size %X\n", bufferSize, sizeof(*hdr));
  62:image.c       **** 		if (shouldEraseFlashOnFail)
  63:image.c       **** 		{
  64:image.c       **** 			failErase();
  65:image.c       **** 		}
  66:image.c       **** 		return(EINVAL);		/* buffer too small to really contain header */
  67:image.c       **** 	}
  68:image.c       **** 	if ((hdr->header.magic) != kImageHeaderMagic) {
 127              		.loc 1 68 0
 128 002c 3A99     		ldr	r1, [sp, #232]
 129 002e 414A     		ldr	r2, .L29
 130 0030 9142     		cmp	r1, r2
 131 0032 01D0     		beq	.L5
  69:image.c       **** 		debug_print("bad magic 0x%08x expecting 0x%08x\n", (hdr->header.magic), kImageHeaderMagic);
 132              		.loc 1 69 0 discriminator 1
 133 0034 4048     		ldr	r0, .L29+4
 134 0036 04E0     		b	.L26
 135              	.L5:
  70:image.c       **** 		state.flags = kImageImageMissingMagic;
  71:image.c       **** 		if (shouldEraseFlashOnFail)
  72:image.c       **** 		{
  73:image.c       **** 			failErase();
  74:image.c       **** 		}
  75:image.c       **** 		*newHandle = &state;
  76:image.c       **** 		return(kImageImageMissingMagic);		/* magic must match */
  77:image.c       **** 	}
  78:image.c       **** 	if ((hdr->signing.imageType) != 0x45444f53)
 136              		.loc 1 78 0
 137 0038 3E99     		ldr	r1, [sp, #248]
 138 003a 404A     		ldr	r2, .L29+8
 139 003c 9142     		cmp	r1, r2
 140 003e 0CD0     		beq	.L8
  79:image.c       **** 	{
  80:image.c       **** 		debug_print("bad magic 0x%08x expecting 0x%X\n", (hdr->signing.imageType), 0x45444f53);
 141              		.loc 1 80 0 discriminator 1
 142 0040 3F48     		ldr	r0, .L29+12
 143              	.L26:
 144 0042 FFF7FEFF 		bl	uart_printf
 145              	.LVL15:
  81:image.c       **** 		state.flags = kImageImageMissingMagic;
 146              		.loc 1 81 0 discriminator 1
 147 0046 0423     		movs	r3, #4
 148 0048 7360     		str	r3, [r6, #4]
  82:image.c       **** 		if (shouldEraseFlashOnFail)
 149              		.loc 1 82 0 discriminator 1
 150 004a B8F1000F 		cmp	r8, #0
 151 004e 01D0     		beq	.L9
  83:image.c       **** 		{
  84:image.c       **** 			failErase();
 152              		.loc 1 84 0
 153 0050 FFF7FEFF 		bl	failErase
 154              	.LVL16:
 155              	.L9:
  85:image.c       **** 		}
  86:image.c       **** 		*newHandle = &state;
 156              		.loc 1 86 0
 157 0054 3E60     		str	r6, [r7]
  87:image.c       **** 		return(kImageImageMissingMagic);		/* magic must match */
 158              		.loc 1 87 0
 159 0056 0420     		movs	r0, #4
 160 0058 68E0     		b	.L7
 161              	.L8:
  88:image.c       **** 	}
  89:image.c       **** 	state.flags = kImageImageWasInstantiated;
 162              		.loc 1 89 0
 163 005a 0123     		movs	r3, #1
 164 005c 7360     		str	r3, [r6, #4]
  90:image.c       **** 
  91:image.c       **** 	debug_print("dataSize: 0x%X\n", (hdr->header.dataSize));
 165              		.loc 1 91 0
 166 005e 3948     		ldr	r0, .L29+16
 167 0060 3C99     		ldr	r1, [sp, #240]
 168 0062 FFF7FEFF 		bl	uart_printf
 169              	.LVL17:
  92:image.c       **** 
  93:image.c       **** 	state.cursor = hdr->header.dataSize;
 170              		.loc 1 93 0
 171 0066 3C9B     		ldr	r3, [sp, #240]
  94:image.c       **** 	state.lastTag = -1;
  95:image.c       **** 
  96:image.c       **** 	unsigned char sha256sum[32];
  97:image.c       **** 
  98:image.c       ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
 172              		.loc 1 98 0
 173 0068 2022     		movs	r2, #32
 174 006a FF21     		movs	r1, #255
  93:image.c       **** 	state.cursor = hdr->header.dataSize;
 175              		.loc 1 93 0
 176 006c F360     		str	r3, [r6, #12]
 177              		.loc 1 98 0
 178 006e 08A8     		add	r0, sp, #32
  94:image.c       **** 	state.lastTag = -1;
 179              		.loc 1 94 0
 180 0070 4FF0FF33 		mov	r3, #-1
 181 0074 3361     		str	r3, [r6, #16]
 182              		.loc 1 98 0
 183 0076 FFF7FEFF 		bl	memset
 184              	.LVL18:
  99:image.c       **** 
 100:image.c       ****     sha256_context ctx;
 101:image.c       ****     sha256_starts(&ctx);
 185              		.loc 1 101 0
 186 007a 20A8     		add	r0, sp, #128
 187 007c FFF7FEFF 		bl	sha256_starts
 188              	.LVL19:
 102:image.c       **** 
 103:image.c       ****     int buffSize = 0x1;
 104:image.c       ****     char buff[buffSize];
 105:image.c       **** 
 106:image.c       ****     int i = 0x84;
 107:image.c       ****     char cmpEnd[5] = {0x01, 0x00, 0x00, 0x00, 0x00}; 
 108:image.c       ****     hexdump((flashAddress+i), 0x10);
 189              		.loc 1 108 0
 190 0080 0198     		ldr	r0, [sp, #4]
 191 0082 1021     		movs	r1, #16
 192 0084 8430     		adds	r0, r0, #132
 193 0086 FFF7FEFF 		bl	hexdump
 194              	.LVL20:
 109:image.c       **** 
 110:image.c       ****     int finish = hdr->header.dataSize + 0x84;
 195              		.loc 1 110 0
 196 008a 3C9D     		ldr	r5, [sp, #240]
 111:image.c       ****     debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
 197              		.loc 1 111 0
 198 008c 0199     		ldr	r1, [sp, #4]
 199 008e 019A     		ldr	r2, [sp, #4]
 110:image.c       ****     int finish = hdr->header.dataSize + 0x84;
 200              		.loc 1 110 0
 201 0090 8435     		adds	r5, r5, #132
 202              	.LVL21:
 203              		.loc 1 111 0
 204 0092 2D48     		ldr	r0, .L29+20
 205 0094 8431     		adds	r1, r1, #132
 206 0096 2A44     		add	r2, r2, r5
 207 0098 FFF7FEFF 		bl	uart_printf
 208              	.LVL22:
 106:image.c       ****     int i = 0x84;
 209              		.loc 1 106 0
 210 009c 8424     		movs	r4, #132
 211              	.LVL23:
 212              	.L10:
 112:image.c       ****     while (i < finish)
 213              		.loc 1 112 0 discriminator 1
 214 009e AC42     		cmp	r4, r5
 215 00a0 08DA     		bge	.L28
 113:image.c       ****     {
 114:image.c       ****     	memset(buff, 0xFF, buffSize);
 115:image.c       ****     	memcpy(buff, (unsigned char *)(flashAddress+i), buffSize);
 216              		.loc 1 115 0
 217 00a2 019B     		ldr	r3, [sp, #4]
 116:image.c       **** 		/*
 117:image.c       **** 		if ((flashAddress+i) >= (flashAddress + (hdr->header.dataSize))) // our end of image should be so
 118:image.c       **** 		{
 119:image.c       **** 			if ((memmem(&buff, buffSize, &cmpEnd, buffSize) > 0)) {
 120:image.c       **** 				sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize-1);
 121:image.c       **** 		  	hexdump((vu32 *)(flashAddress+i), buffSize-1);
 122:image.c       **** 		  	debug_print("Last block: %X\n", (flashAddress+i));
 123:image.c       **** 		  	break;
 124:image.c       **** 			}
 125:image.c       **** 		hexdump((vu32 *)(flashAddress+i), buffSize);
 126:image.c       **** 		}*/
 127:image.c       **** 		sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
 218              		.loc 1 127 0
 219 00a4 0199     		ldr	r1, [sp, #4]
 220 00a6 20A8     		add	r0, sp, #128
 221 00a8 2144     		add	r1, r1, r4
 222 00aa 0122     		movs	r2, #1
 223 00ac FFF7FEFF 		bl	sha256_update
 224              	.LVL24:
 128:image.c       **** 		i += 0x1;
 225              		.loc 1 128 0
 226 00b0 0134     		adds	r4, r4, #1
 227              	.LVL25:
 228 00b2 F4E7     		b	.L10
 229              	.L28:
 129:image.c       ****     }
 130:image.c       ****     debug_print("Ended at: %X\n", (flashAddress+i));
 230              		.loc 1 130 0 discriminator 1
 231 00b4 0199     		ldr	r1, [sp, #4]
 232 00b6 2548     		ldr	r0, .L29+24
 233 00b8 2144     		add	r1, r1, r4
 234 00ba FFF7FEFF 		bl	uart_printf
 235              	.LVL26:
 131:image.c       ****     hexdump((vu32 *)(flashAddress+i), 0x10);
 236              		.loc 1 131 0 discriminator 1
 237 00be 0198     		ldr	r0, [sp, #4]
 238 00c0 1021     		movs	r1, #16
 239 00c2 2044     		add	r0, r0, r4
 240 00c4 FFF7FEFF 		bl	hexdump
 241              	.LVL27:
 132:image.c       ****     if ((flashAddress+i) != (flashAddress+finish))
 242              		.loc 1 132 0 discriminator 1
 243 00c8 019A     		ldr	r2, [sp, #4]
 244 00ca 019B     		ldr	r3, [sp, #4]
 245 00cc 1444     		add	r4, r4, r2
 246              	.LVL28:
 247 00ce 1D44     		add	r5, r5, r3
 248              	.LVL29:
 249 00d0 AC42     		cmp	r4, r5
 250 00d2 05D0     		beq	.L12
 133:image.c       ****     {
 134:image.c       ****     	debug_print("Calculated hash is probably wrong...\n");
 251              		.loc 1 134 0 discriminator 1
 252 00d4 1E48     		ldr	r0, .L29+28
 253 00d6 FFF7FEFF 		bl	uart_printf
 254              	.LVL30:
 135:image.c       ****     	state.flags = kImageImageHashCalcFailed;
 136:image.c       ****     	*newHandle = &state;
 255              		.loc 1 136 0 discriminator 1
 256 00da 3E60     		str	r6, [r7]
 137:image.c       **** 		return(kImageImageHashCalcFailed);
 257              		.loc 1 137 0 discriminator 1
 258 00dc 0520     		movs	r0, #5
 259 00de 25E0     		b	.L7
 260              	.L12:
 138:image.c       ****     }
 139:image.c       ****     unsigned char uniqueID[0x17];
 140:image.c       ****     if (!QEMU_BUILD)
 141:image.c       ****     {
 142:image.c       ****     	struct u_id id;
 143:image.c       **** 	    uid_read(&id);
 144:image.c       **** 	    sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
 145:image.c       **** 	    sha256_update(&ctx, uniqueID, 0x17);
 146:image.c       ****     }
 147:image.c       **** 
 148:image.c       ****     //debug_print("%s\n", uniqueID);
 149:image.c       ****     
 150:image.c       ****     sha256_finish(&ctx, sha256sum);
 261              		.loc 1 150 0
 262 00e0 08A9     		add	r1, sp, #32
 263 00e2 20A8     		add	r0, sp, #128
 264 00e4 FFF7FEFF 		bl	sha256_finish
 265              	.LVL31:
 151:image.c       ****     print_hash(sha256sum);
 152:image.c       ****     // verify signature against recalc hash
 153:image.c       ****     uint8_t sigbuff[0x40];
 154:image.c       ****     memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
 266              		.loc 1 154 0
 267 00e8 10AC     		add	r4, sp, #64
 151:image.c       ****     print_hash(sha256sum);
 268              		.loc 1 151 0
 269 00ea 08A8     		add	r0, sp, #32
 270              		.loc 1 154 0
 271 00ec 3FAD     		add	r5, sp, #252
 151:image.c       ****     print_hash(sha256sum);
 272              		.loc 1 151 0
 273 00ee FFF7FEFF 		bl	print_hash
 274              	.LVL32:
 275              		.loc 1 154 0
 276 00f2 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 277 00f4 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 278 00f6 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 279 00f8 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 280 00fa 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 281 00fc 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 282 00fe 95E80F00 		ldmia	r5, {r0, r1, r2, r3}
 283 0102 84E80F00 		stmia	r4, {r0, r1, r2, r3}
 155:image.c       **** 
 156:image.c       ****     if (edsign_verify(sigbuff, rootCA, sha256sum, 32) <= 0) {
 284              		.loc 1 156 0
 285 0106 10A8     		add	r0, sp, #64
 286 0108 1249     		ldr	r1, .L29+32
 287 010a 08AA     		add	r2, sp, #32
 288 010c 2023     		movs	r3, #32
 289 010e FFF7FEFF 		bl	edsign_verify
 290              	.LVL33:
 291 0112 48B9     		cbnz	r0, .L13
 157:image.c       ****     	state.flags = kImageImageRejectSignature;
 292              		.loc 1 157 0
 293 0114 0223     		movs	r3, #2
 294 0116 7360     		str	r3, [r6, #4]
 158:image.c       ****     	if (shouldEraseFlashOnFail)
 295              		.loc 1 158 0
 296 0118 B8F1000F 		cmp	r8, #0
 297 011c 01D0     		beq	.L14
 159:image.c       **** 		{
 160:image.c       **** 			failErase();
 298              		.loc 1 160 0
 299 011e FFF7FEFF 		bl	failErase
 300              	.LVL34:
 301              	.L14:
 161:image.c       **** 		}
 162:image.c       ****     	*newHandle = &state;
 302              		.loc 1 162 0
 303 0122 3E60     		str	r6, [r7]
 163:image.c       ****     	return kImageImageRejectSignature;
 304              		.loc 1 163 0
 305 0124 0220     		movs	r0, #2
 306 0126 01E0     		b	.L7
 307              	.L13:
 164:image.c       ****     } else {
 165:image.c       ****     	state.flags = kImageImageIsTrusted;
 166:image.c       ****     	*newHandle = &state;
 308              		.loc 1 166 0
 309 0128 3E60     		str	r6, [r7]
 167:image.c       ****     	return kImageImageIsTrusted;
 310              		.loc 1 167 0
 311 012a 0320     		movs	r0, #3
 312              	.LVL35:
 313              	.L7:
 168:image.c       ****     }
 169:image.c       **** 	
 170:image.c       **** 	*newHandle = &state;
 171:image.c       **** 	return(0);
 172:image.c       **** }
 314              		.loc 1 172 0
 315 012c 54B0     		add	sp, sp, #336
 316              		@ sp needed
 317 012e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 318              	.LVL36:
 319              	.L30:
 320 0132 00BF     		.align	2
 321              	.L29:
 322 0134 32636245 		.word	1164075826
 323 0138 00000000 		.word	.LC0
 324 013c 534F4445 		.word	1162104659
 325 0140 23000000 		.word	.LC1
 326 0144 44000000 		.word	.LC2
 327 0148 54000000 		.word	.LC3
 328 014c 6A000000 		.word	.LC4
 329 0150 78000000 		.word	.LC5
 330 0154 00000000 		.word	.LANCHOR0
 331              		.cfi_endproc
 332              	.LFE2:
 334              		.global	rootCA
 335              		.comm	wTransferSize,4,4
 336              		.section	.data.rootCA,"aw",%progbits
 337              		.set	.LANCHOR0,. + 0
 340              	rootCA:
 341 0000 BD       		.byte	-67
 342 0001 0C       		.byte	12
 343 0002 2D       		.byte	45
 344 0003 04       		.byte	4
 345 0004 2E       		.byte	46
 346 0005 5A       		.byte	90
 347 0006 95       		.byte	-107
 348 0007 C6       		.byte	-58
 349 0008 B6       		.byte	-74
 350 0009 28       		.byte	40
 351 000a FC       		.byte	-4
 352 000b 3F       		.byte	63
 353 000c 85       		.byte	-123
 354 000d 6C       		.byte	108
 355 000e A1       		.byte	-95
 356 000f FB       		.byte	-5
 357 0010 B5       		.byte	-75
 358 0011 25       		.byte	37
 359 0012 07       		.byte	7
 360 0013 38       		.byte	56
 361 0014 C0       		.byte	-64
 362 0015 05       		.byte	5
 363 0016 9D       		.byte	-99
 364 0017 44       		.byte	68
 365 0018 04       		.byte	4
 366 0019 A7       		.byte	-89
 367 001a E3       		.byte	-29
 368 001b A6       		.byte	-90
 369 001c AC       		.byte	-84
 370 001d 3B       		.byte	59
 371 001e B8       		.byte	-72
 372 001f 41       		.byte	65
 373              		.section	.rodata.str1.1,"aMS",%progbits,1
 374              	.LC0:
 375 0000 62616420 		.ascii	"bad magic 0x%08x expecting 0x%08x\012\000"
 375      6D616769 
 375      63203078 
 375      25303878 
 375      20657870 
 376              	.LC1:
 377 0023 62616420 		.ascii	"bad magic 0x%08x expecting 0x%X\012\000"
 377      6D616769 
 377      63203078 
 377      25303878 
 377      20657870 
 378              	.LC2:
 379 0044 64617461 		.ascii	"dataSize: 0x%X\012\000"
 379      53697A65 
 379      3A203078 
 379      25580A00 
 380              	.LC3:
 381 0054 53746172 		.ascii	"Start: %X\012Finish: %X\012\000"
 381      743A2025 
 381      580A4669 
 381      6E697368 
 381      3A202558 
 382              	.LC4:
 383 006a 456E6465 		.ascii	"Ended at: %X\012\000"
 383      64206174 
 383      3A202558 
 383      0A00
 384              	.LC5:
 385 0078 43616C63 		.ascii	"Calculated hash is probably wrong...\012\000"
 385      756C6174 
 385      65642068 
 385      61736820 
 385      69732070 
 386              		.text
 387              	.Letext0:
 388              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 389              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\mach
 390              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdi
 391              		.file 5 "./stm32_lib/stm32f10x_type.h"
 392              		.file 6 "./25519/sha256.h"
 393              		.file 7 "image.h"
 394              		.file 8 "usb.h"
 395              		.file 9 "hardware.h"
 396              		.file 10 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\str
 397              		.file 11 "./25519/edsign.h"
DEFINED SYMBOLS
                            *ABS*:00000000 image.c
C:\Users\haifisch\AppData\Local\Temp\ccUv3MQ6.s:19     .text.failErase:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccUv3MQ6.s:24     .text.failErase:00000000 failErase
C:\Users\haifisch\AppData\Local\Temp\ccUv3MQ6.s:64     .text.failErase:0000002c $d
C:\Users\haifisch\AppData\Local\Temp\ccUv3MQ6.s:74     .text.imageCheckFromAddress:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccUv3MQ6.s:79     .text.imageCheckFromAddress:00000000 imageCheckFromAddress
C:\Users\haifisch\AppData\Local\Temp\ccUv3MQ6.s:322    .text.imageCheckFromAddress:00000134 $d
C:\Users\haifisch\AppData\Local\Temp\ccUv3MQ6.s:340    .data.rootCA:00000000 rootCA
                            *COM*:00000004 wTransferSize
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
flashErasePage
memset
memcpy
uart_printf
sha256_starts
hexdump
sha256_update
sha256_finish
print_hash
edsign_verify
