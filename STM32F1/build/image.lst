   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"image.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.imageCheckFromAddress,"ax",%progbits
  19              		.align	2
  20              		.global	imageCheckFromAddress
  21              		.thumb
  22              		.thumb_func
  24              	imageCheckFromAddress:
  25              	.LFB1:
  26              		.file 1 "image.c"
   1:image.c       **** /*
   2:image.c       ****  * Copyright (C) 2016-2017 Sun Tzu Security, LLC. All rights reserved.
   3:image.c       ****  *
   4:image.c       ****  * This document is the property of Sun Tzu Security, LLC.
   5:image.c       ****  * It is considered confidential and proprietary.
   6:image.c       ****  *
   7:image.c       ****  * This document may not be reproduced or transmitted in any form,
   8:image.c       ****  * in whole or in part, without the express written permission of
   9:image.c       ****  * Sun Tzu Security, LLC.
  10:image.c       ****  */
  11:image.c       **** #include <stdio.h>
  12:image.c       **** #include <stdint.h>
  13:image.c       **** #include <string.h>
  14:image.c       **** #include <limits.h>
  15:image.c       **** #include <unistd.h>
  16:image.c       **** #include <errno.h>
  17:image.c       **** #include <stdarg.h>
  18:image.c       **** 
  19:image.c       **** #include "hardware.h"
  20:image.c       **** #include "sha256.h"
  21:image.c       **** #include "edsign.h"
  22:image.c       **** #include "image.h"
  23:image.c       **** 
  24:image.c       **** static void print_hex(const char *label, const uint8_t *data, int len)
  25:image.c       **** {
  26:image.c       ****     int i;
  27:image.c       **** 
  28:image.c       ****     uart_printf("%s: ", label);
  29:image.c       ****     for (i = 0; i < len; i++)
  30:image.c       ****         uart_printf("%02x", data[i]);
  31:image.c       ****     uart_printf("\n");
  32:image.c       **** }
  33:image.c       **** 
  34:image.c       **** 
  35:image.c       **** int imageCheckFromAddress(ImageObjectHandle *newHandle, uint32_t flashAddress, bool shouldEraseFlas
  36:image.c       **** {
  27              		.loc 1 36 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 400
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  33              		.cfi_def_cfa_offset 24
  34              		.cfi_offset 4, -24
  35              		.cfi_offset 5, -20
  36              		.cfi_offset 6, -16
  37              		.cfi_offset 7, -12
  38              		.cfi_offset 8, -8
  39              		.cfi_offset 14, -4
  40 0004 E6B0     		sub	sp, sp, #408
  41              		.cfi_def_cfa_offset 432
  42              	.LVL1:
  43              		.loc 1 36 0
  44 0006 0E46     		mov	r6, r1
  45 0008 0546     		mov	r5, r0
  37:image.c       **** 	ImageObjectHeader		*hdr;
  38:image.c       **** 	ImageInternalState		state;
  39:image.c       **** 	int bufferSize = 0x28+0x40;
  40:image.c       **** 	unsigned char imageBuffer[bufferSize];
  41:image.c       ****     memset(imageBuffer, 0xFF, sizeof(imageBuffer));
  46              		.loc 1 41 0
  47 000a FF21     		movs	r1, #255
  48              	.LVL2:
  36:image.c       **** {
  49              		.loc 1 36 0
  50 000c 9046     		mov	r8, r2
  51              		.loc 1 41 0
  52 000e 4CA8     		add	r0, sp, #304
  53              	.LVL3:
  54 0010 6822     		movs	r2, #104
  55              	.LVL4:
  56 0012 FFF7FEFF 		bl	memset
  57              	.LVL5:
  42:image.c       ****     memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
  58              		.loc 1 42 0
  59 0016 3146     		mov	r1, r6
  60 0018 6822     		movs	r2, #104
  61 001a 4CA8     		add	r0, sp, #304
  62              	.LVL6:
  63 001c FFF7FEFF 		bl	memcpy
  64              	.LVL7:
  43:image.c       ****     flashUnlock();
  65              		.loc 1 43 0
  66 0020 FFF7FEFF 		bl	flashUnlock
  67              	.LVL8:
  44:image.c       ****     memset(&state, 0, sizeof(state));
  45:image.c       **** 
  46:image.c       **** 	hdr = (ImageObjectHeader *)imageBuffer;
  47:image.c       **** 	u32 flashCnt = 0x0;
  48:image.c       **** 
  49:image.c       **** 	if (bufferSize < sizeof(hdr)) {
  50:image.c       **** 		uart_printf("buffer size %X too small for header size %X\n", bufferSize, sizeof(*hdr));
  51:image.c       **** 		if (shouldEraseFlashOnFail)
  52:image.c       **** 		{
  53:image.c       **** 			flashCnt = 0x0;
  54:image.c       **** 			while ((flashAddress+flashCnt) <= ((hdr->ihBufferLength)+0x10)) {
  55:image.c       **** 				flashErasePage((u32)(0x08008000+flashCnt));
  56:image.c       **** 				flashCnt += 0x3F0;
  57:image.c       **** 			}
  58:image.c       **** 		}
  59:image.c       **** 		return(EINVAL);		/* buffer too small to really contain header */
  60:image.c       **** 	}
  61:image.c       **** 	if ((hdr->ihMagic) != kImageHeaderMagic) {
  68              		.loc 1 61 0
  69 0024 4C99     		ldr	r1, [sp, #304]
  70 0026 584A     		ldr	r2, .L23
  44:image.c       ****     memset(&state, 0, sizeof(state));
  71              		.loc 1 44 0
  72 0028 0020     		movs	r0, #0
  73              		.loc 1 61 0
  74 002a 9142     		cmp	r1, r2
  44:image.c       ****     memset(&state, 0, sizeof(state));
  75              		.loc 1 44 0
  76 002c 0790     		str	r0, [sp, #28]
  77 002e 0890     		str	r0, [sp, #32]
  78 0030 0990     		str	r0, [sp, #36]
  79 0032 0A90     		str	r0, [sp, #40]
  80 0034 0B90     		str	r0, [sp, #44]
  81              	.LVL9:
  82              		.loc 1 61 0
  83 0036 1ED0     		beq	.L2
  62:image.c       **** 		uart_printf("bad magic 0x%08x expecting 0x%08x\n", (hdr->ihMagic), kImageHeaderMagic);
  84              		.loc 1 62 0
  85 0038 5448     		ldr	r0, .L23+4
  86 003a FFF7FEFF 		bl	uart_printf
  87              	.LVL10:
  63:image.c       **** 		state.flags = kImageImageMissingMagic;
  88              		.loc 1 63 0
  89 003e 0423     		movs	r3, #4
  90 0040 0893     		str	r3, [sp, #32]
  64:image.c       **** 		if (shouldEraseFlashOnFail)
  91              		.loc 1 64 0
  92 0042 B8F1000F 		cmp	r8, #0
  93 0046 10D0     		beq	.L5
  65:image.c       **** 		{
  66:image.c       **** 			flashCnt = 0x0;
  67:image.c       **** 			while ((flashAddress+flashCnt) <= ((hdr->ihBufferLength)+0x10)) {
  94              		.loc 1 67 0 discriminator 1
  95 0048 4E9B     		ldr	r3, [sp, #312]
  96 004a 1033     		adds	r3, r3, #16
  97 004c 9E42     		cmp	r6, r3
  98 004e 0CD8     		bhi	.L5
  99 0050 4F4F     		ldr	r7, .L23+8
 100              		.loc 1 67 0 is_stmt 0
 101 0052 504C     		ldr	r4, .L23+12
 102 0054 3744     		add	r7, r7, r6
 103              	.LVL11:
 104              	.L6:
  68:image.c       **** 				flashErasePage((u32)(0x08008000+flashCnt));
 105              		.loc 1 68 0 is_stmt 1
 106 0056 2046     		mov	r0, r4
 107 0058 FFF7FEFF 		bl	flashErasePage
 108              	.LVL12:
  67:image.c       **** 			while ((flashAddress+flashCnt) <= ((hdr->ihBufferLength)+0x10)) {
 109              		.loc 1 67 0
 110 005c 4E9B     		ldr	r3, [sp, #312]
 111 005e 3A19     		adds	r2, r7, r4
 112 0060 1033     		adds	r3, r3, #16
 113 0062 9342     		cmp	r3, r2
 114 0064 04F57C74 		add	r4, r4, #1008
 115              	.LVL13:
 116 0068 F5D2     		bcs	.L6
 117              	.LVL14:
 118              	.L5:
  69:image.c       **** 				flashCnt += 0x3F0;
  70:image.c       **** 			}
  71:image.c       **** 		}
  72:image.c       **** 		
  73:image.c       **** 		*newHandle = &state;
 119              		.loc 1 73 0
 120 006a 07AB     		add	r3, sp, #28
  74:image.c       **** 		return(kImageImageMissingMagic);		/* magic must match */
 121              		.loc 1 74 0
 122 006c 0420     		movs	r0, #4
  73:image.c       **** 		*newHandle = &state;
 123              		.loc 1 73 0
 124 006e 2B60     		str	r3, [r5]
  75:image.c       **** 	}
  76:image.c       **** 
  77:image.c       **** 	state.flags = kImageImageWasInstantiated;
  78:image.c       **** 
  79:image.c       **** 	state.cursor = (hdr->ihBufferLength)+0x10;
  80:image.c       **** 	state.lastTag = -1;
  81:image.c       **** 
  82:image.c       **** 	unsigned char sha256sum[32];
  83:image.c       **** 
  84:image.c       ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
  85:image.c       **** 
  86:image.c       ****     sha256_context ctx;
  87:image.c       ****     sha256_starts(&ctx);
  88:image.c       ****     char buff[0x4];
  89:image.c       **** 
  90:image.c       ****     int i = 0x84;
  91:image.c       **** 
  92:image.c       ****     while ((flashAddress+i) <= (flashAddress+state.cursor))
  93:image.c       ****     {
  94:image.c       ****       memset(buff, 0xFF, 0x4);
  95:image.c       ****       memcpy(buff, (char *)(flashAddress+i), 0x4);
  96:image.c       ****       sha256_update(&ctx, (vu32 *)(flashAddress+i), 0x4);
  97:image.c       ****       i += 0x4;
  98:image.c       ****     }
  99:image.c       **** 
 100:image.c       ****     // hash in our unique ID
 101:image.c       ****     struct u_id id;
 102:image.c       ****     uid_read(&id);
 103:image.c       ****     unsigned char uniqueID[23];
 104:image.c       ****     sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
 105:image.c       ****     sha256_update(&ctx, uniqueID, 23);
 106:image.c       ****     sha256_finish(&ctx, sha256sum);
 107:image.c       **** 
 108:image.c       ****  	uint8_t rootCA[32] = {
 109:image.c       ****        0xbd, 0x0c, 0x2d, 0x04, 0x2e, 0x5a, 0x95, 0xc6, 0xb6, 0x28, 0xfc, 0x3f, 0x85, 0x6c, 0xa1, 0x
 110:image.c       ****     };
 111:image.c       ****     // verify signature against recalc hash
 112:image.c       **** 
 113:image.c       ****     uint8_t sigbuff[0x40];
 114:image.c       ****     memcpy(sigbuff, (uint8_t*)(hdr->ihBuffer), 0x40);
 115:image.c       **** 
 116:image.c       ****     if (edsign_verify(sigbuff, rootCA, sha256sum, 32) <= 0) {
 117:image.c       ****     	state.flags = kImageImageRejectSignature;
 118:image.c       ****     	if (shouldEraseFlashOnFail)
 119:image.c       **** 		{
 120:image.c       **** 			flashCnt = 0x0;
 121:image.c       **** 			while ((flashAddress+flashCnt) <= ((hdr->ihBufferLength)+0x10)) {
 122:image.c       **** 				flashErasePage((u32)(0x08008000+flashCnt));
 123:image.c       **** 				flashCnt += 0x3F0;
 124:image.c       **** 			}
 125:image.c       **** 			uart_printf("finished: %X\n", flashCnt);
 126:image.c       **** 		}
 127:image.c       ****     	*newHandle = &state;
 128:image.c       ****     	return kImageImageRejectSignature;
 129:image.c       ****     } else {
 130:image.c       ****     	state.flags = kImageImageIsTrusted;
 131:image.c       ****     	*newHandle = &state;
 132:image.c       ****     	return kImageImageIsTrusted;
 133:image.c       ****     }
 134:image.c       **** 	
 135:image.c       **** 	*newHandle = &state;
 136:image.c       **** 	return(0);
 137:image.c       **** }
 125              		.loc 1 137 0
 126 0070 66B0     		add	sp, sp, #408
 127              		@ sp needed
 128 0072 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 129              	.LVL15:
 130              	.L2:
  79:image.c       **** 	state.cursor = (hdr->ihBufferLength)+0x10;
 131              		.loc 1 79 0
 132 0076 4E9B     		ldr	r3, [sp, #312]
  84:image.c       ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
 133              		.loc 1 84 0
 134 0078 FF21     		movs	r1, #255
  79:image.c       **** 	state.cursor = (hdr->ihBufferLength)+0x10;
 135              		.loc 1 79 0
 136 007a 1033     		adds	r3, r3, #16
  80:image.c       **** 	state.lastTag = -1;
 137              		.loc 1 80 0
 138 007c 4FF0FF34 		mov	r4, #-1
  84:image.c       ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
 139              		.loc 1 84 0
 140 0080 2022     		movs	r2, #32
 141 0082 12A8     		add	r0, sp, #72
  77:image.c       **** 	state.flags = kImageImageWasInstantiated;
 142              		.loc 1 77 0
 143 0084 0127     		movs	r7, #1
  79:image.c       **** 	state.cursor = (hdr->ihBufferLength)+0x10;
 144              		.loc 1 79 0
 145 0086 0A93     		str	r3, [sp, #40]
  80:image.c       **** 	state.lastTag = -1;
 146              		.loc 1 80 0
 147 0088 0B94     		str	r4, [sp, #44]
  77:image.c       **** 	state.flags = kImageImageWasInstantiated;
 148              		.loc 1 77 0
 149 008a 0897     		str	r7, [sp, #32]
  84:image.c       ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
 150              		.loc 1 84 0
 151 008c FFF7FEFF 		bl	memset
 152              	.LVL16:
  87:image.c       ****     sha256_starts(&ctx);
 153              		.loc 1 87 0
 154 0090 32A8     		add	r0, sp, #200
 155 0092 FFF7FEFF 		bl	sha256_starts
 156              	.LVL17:
  92:image.c       ****     while ((flashAddress+i) <= (flashAddress+state.cursor))
 157              		.loc 1 92 0
 158 0096 0A9B     		ldr	r3, [sp, #40]
 159 0098 06F18401 		add	r1, r6, #132
 160 009c 3344     		add	r3, r3, r6
 161 009e 9942     		cmp	r1, r3
 162 00a0 98BF     		it	ls
 163 00a2 06F18804 		addls	r4, r6, #136
 164 00a6 02D9     		bls	.L11
 165 00a8 0CE0     		b	.L10
 166              	.LVL18:
 167              	.L21:
 168 00aa 2146     		mov	r1, r4
 169 00ac 1446     		mov	r4, r2
 170              	.LVL19:
 171              	.L11:
  95:image.c       ****       memcpy(buff, (char *)(flashAddress+i), 0x4);
 172              		.loc 1 95 0
 173 00ae 0868     		ldr	r0, [r1]	@ unaligned
  96:image.c       ****       sha256_update(&ctx, (vu32 *)(flashAddress+i), 0x4);
 174              		.loc 1 96 0
 175 00b0 0422     		movs	r2, #4
  95:image.c       ****       memcpy(buff, (char *)(flashAddress+i), 0x4);
 176              		.loc 1 95 0
 177 00b2 0390     		str	r0, [sp, #12]	@ unaligned
  96:image.c       ****       sha256_update(&ctx, (vu32 *)(flashAddress+i), 0x4);
 178              		.loc 1 96 0
 179 00b4 32A8     		add	r0, sp, #200
 180 00b6 FFF7FEFF 		bl	sha256_update
 181              	.LVL20:
  92:image.c       ****     while ((flashAddress+i) <= (flashAddress+state.cursor))
 182              		.loc 1 92 0
 183 00ba 0A9B     		ldr	r3, [sp, #40]
 184 00bc 221D     		adds	r2, r4, #4
 185 00be 3344     		add	r3, r3, r6
 186 00c0 A342     		cmp	r3, r4
 187 00c2 F2D2     		bcs	.L21
 188              	.LVL21:
 189              	.L10:
 102:image.c       ****     uid_read(&id);
 190              		.loc 1 102 0
 191 00c4 04A8     		add	r0, sp, #16
 192 00c6 FFF7FEFF 		bl	uid_read
 193              	.LVL22:
 104:image.c       ****     sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
 194              		.loc 1 104 0
 195 00ca 0598     		ldr	r0, [sp, #20]
 196 00cc 0699     		ldr	r1, [sp, #24]
 197 00ce BDF81230 		ldrh	r3, [sp, #18]
 198 00d2 8DE80300 		stmia	sp, {r0, r1}
 199 00d6 BDF81020 		ldrh	r2, [sp, #16]
 200 00da 2F49     		ldr	r1, .L23+16
 201 00dc 0CA8     		add	r0, sp, #48
 108:image.c       ****  	uint8_t rootCA[32] = {
 202              		.loc 1 108 0
 203 00de 2F4C     		ldr	r4, .L23+20
 104:image.c       ****     sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
 204              		.loc 1 104 0
 205 00e0 FFF7FEFF 		bl	sprintf
 206              	.LVL23:
 105:image.c       ****     sha256_update(&ctx, uniqueID, 23);
 207              		.loc 1 105 0
 208 00e4 1722     		movs	r2, #23
 209 00e6 32A8     		add	r0, sp, #200
 210 00e8 0CA9     		add	r1, sp, #48
 211 00ea FFF7FEFF 		bl	sha256_update
 212              	.LVL24:
 106:image.c       ****     sha256_finish(&ctx, sha256sum);
 213              		.loc 1 106 0
 214 00ee 32A8     		add	r0, sp, #200
 215 00f0 12A9     		add	r1, sp, #72
 216 00f2 FFF7FEFF 		bl	sha256_finish
 217              	.LVL25:
 108:image.c       ****  	uint8_t rootCA[32] = {
 218              		.loc 1 108 0
 219 00f6 2068     		ldr	r0, [r4]	@ unaligned
 220 00f8 6168     		ldr	r1, [r4, #4]	@ unaligned
 221 00fa A268     		ldr	r2, [r4, #8]	@ unaligned
 222 00fc E368     		ldr	r3, [r4, #12]	@ unaligned
 223 00fe 0DF1680E 		add	lr, sp, #104
 224 0102 AEE80F00 		stmia	lr!, {r0, r1, r2, r3}
 225 0106 2069     		ldr	r0, [r4, #16]	@ unaligned
 226 0108 6169     		ldr	r1, [r4, #20]	@ unaligned
 227 010a A269     		ldr	r2, [r4, #24]	@ unaligned
 228 010c E369     		ldr	r3, [r4, #28]	@ unaligned
 114:image.c       ****     memcpy(sigbuff, (uint8_t*)(hdr->ihBuffer), 0x40);
 229              		.loc 1 114 0
 230 010e 51AF     		add	r7, sp, #324
 231 0110 22AC     		add	r4, sp, #136
 108:image.c       ****  	uint8_t rootCA[32] = {
 232              		.loc 1 108 0
 233 0112 AEE80F00 		stmia	lr!, {r0, r1, r2, r3}
 114:image.c       ****     memcpy(sigbuff, (uint8_t*)(hdr->ihBuffer), 0x40);
 234              		.loc 1 114 0
 235 0116 0FCF     		ldmia	r7!, {r0, r1, r2, r3}
 236 0118 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 237 011a 0FCF     		ldmia	r7!, {r0, r1, r2, r3}
 238 011c 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 239 011e 0FCF     		ldmia	r7!, {r0, r1, r2, r3}
 240 0120 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 241 0122 97E80F00 		ldmia	r7, {r0, r1, r2, r3}
 242 0126 84E80F00 		stmia	r4, {r0, r1, r2, r3}
 116:image.c       ****     if (edsign_verify(sigbuff, rootCA, sha256sum, 32) <= 0) {
 243              		.loc 1 116 0
 244 012a 22A8     		add	r0, sp, #136
 245 012c 1AA9     		add	r1, sp, #104
 246 012e 12AA     		add	r2, sp, #72
 247 0130 2023     		movs	r3, #32
 248 0132 FFF7FEFF 		bl	edsign_verify
 249              	.LVL26:
 250 0136 00BB     		cbnz	r0, .L22
 117:image.c       ****     	state.flags = kImageImageRejectSignature;
 251              		.loc 1 117 0
 252 0138 0223     		movs	r3, #2
 253 013a 0893     		str	r3, [sp, #32]
 118:image.c       ****     	if (shouldEraseFlashOnFail)
 254              		.loc 1 118 0
 255 013c B8F1000F 		cmp	r8, #0
 256 0140 15D0     		beq	.L12
 121:image.c       **** 			while ((flashAddress+flashCnt) <= ((hdr->ihBufferLength)+0x10)) {
 257              		.loc 1 121 0 discriminator 1
 258 0142 4E9B     		ldr	r3, [sp, #312]
 259 0144 0446     		mov	r4, r0
 260 0146 1033     		adds	r3, r3, #16
 261 0148 9E42     		cmp	r6, r3
 262 014a 0CD8     		bhi	.L13
 263              	.LVL27:
 264              	.L14:
 122:image.c       **** 				flashErasePage((u32)(0x08008000+flashCnt));
 265              		.loc 1 122 0
 266 014c 04F10060 		add	r0, r4, #134217728
 267 0150 00F50040 		add	r0, r0, #32768
 268 0154 FFF7FEFF 		bl	flashErasePage
 269              	.LVL28:
 121:image.c       **** 			while ((flashAddress+flashCnt) <= ((hdr->ihBufferLength)+0x10)) {
 270              		.loc 1 121 0
 271 0158 4E9B     		ldr	r3, [sp, #312]
 123:image.c       **** 				flashCnt += 0x3F0;
 272              		.loc 1 123 0
 273 015a 04F57C74 		add	r4, r4, #1008
 274              	.LVL29:
 275 015e A219     		adds	r2, r4, r6
 121:image.c       **** 			while ((flashAddress+flashCnt) <= ((hdr->ihBufferLength)+0x10)) {
 276              		.loc 1 121 0
 277 0160 1033     		adds	r3, r3, #16
 278 0162 9A42     		cmp	r2, r3
 279 0164 F2D9     		bls	.L14
 280              	.LVL30:
 281              	.L13:
 125:image.c       **** 			uart_printf("finished: %X\n", flashCnt);
 282              		.loc 1 125 0
 283 0166 2146     		mov	r1, r4
 284 0168 0D48     		ldr	r0, .L23+24
 285 016a FFF7FEFF 		bl	uart_printf
 286              	.LVL31:
 287              	.L12:
 127:image.c       ****     	*newHandle = &state;
 288              		.loc 1 127 0
 289 016e 07AB     		add	r3, sp, #28
 128:image.c       ****     	return kImageImageRejectSignature;
 290              		.loc 1 128 0
 291 0170 0220     		movs	r0, #2
 127:image.c       ****     	*newHandle = &state;
 292              		.loc 1 127 0
 293 0172 2B60     		str	r3, [r5]
 294              		.loc 1 137 0
 295 0174 66B0     		add	sp, sp, #408
 296              		@ sp needed
 297 0176 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 298              	.LVL32:
 299              	.L22:
 131:image.c       ****     	*newHandle = &state;
 300              		.loc 1 131 0
 301 017a 07AB     		add	r3, sp, #28
 132:image.c       ****     	return kImageImageIsTrusted;
 302              		.loc 1 132 0
 303 017c 0320     		movs	r0, #3
 131:image.c       ****     	*newHandle = &state;
 304              		.loc 1 131 0
 305 017e 2B60     		str	r3, [r5]
 306              		.loc 1 137 0
 307 0180 66B0     		add	sp, sp, #408
 308              		@ sp needed
 309 0182 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 310              	.LVL33:
 311              	.L24:
 312 0186 00BF     		.align	2
 313              	.L23:
 314 0188 32636245 		.word	1164075826
 315 018c 00000000 		.word	.LC1
 316 0190 F083FFF7 		.word	-134249488
 317 0194 00800008 		.word	134250496
 318 0198 24000000 		.word	.LC2
 319 019c 00000000 		.word	.LANCHOR0
 320 01a0 30000000 		.word	.LC3
 321              		.cfi_endproc
 322              	.LFE1:
 324              		.comm	wTransferSize,4,4
 325              		.section	.rodata
 326              		.align	2
 327              		.set	.LANCHOR0,. + 0
 328              	.LC0:
 329 0000 BD       		.byte	-67
 330 0001 0C       		.byte	12
 331 0002 2D       		.byte	45
 332 0003 04       		.byte	4
 333 0004 2E       		.byte	46
 334 0005 5A       		.byte	90
 335 0006 95       		.byte	-107
 336 0007 C6       		.byte	-58
 337 0008 B6       		.byte	-74
 338 0009 28       		.byte	40
 339 000a FC       		.byte	-4
 340 000b 3F       		.byte	63
 341 000c 85       		.byte	-123
 342 000d 6C       		.byte	108
 343 000e A1       		.byte	-95
 344 000f FB       		.byte	-5
 345 0010 B5       		.byte	-75
 346 0011 25       		.byte	37
 347 0012 07       		.byte	7
 348 0013 38       		.byte	56
 349 0014 C0       		.byte	-64
 350 0015 05       		.byte	5
 351 0016 9D       		.byte	-99
 352 0017 44       		.byte	68
 353 0018 04       		.byte	4
 354 0019 A7       		.byte	-89
 355 001a E3       		.byte	-29
 356 001b A6       		.byte	-90
 357 001c AC       		.byte	-84
 358 001d 3B       		.byte	59
 359 001e B8       		.byte	-72
 360 001f 41       		.byte	65
 361              		.section	.rodata.str1.4,"aMS",%progbits,1
 362              		.align	2
 363              	.LC1:
 364 0000 62616420 		.ascii	"bad magic 0x%08x expecting 0x%08x\012\000"
 364      6D616769 
 364      63203078 
 364      25303878 
 364      20657870 
 365 0023 00       		.space	1
 366              	.LC2:
 367 0024 25582558 		.ascii	"%X%X%X%X\000"
 367      25582558 
 367      00
 368 002d 000000   		.space	3
 369              	.LC3:
 370 0030 66696E69 		.ascii	"finished: %X\012\000"
 370      73686564 
 370      3A202558 
 370      0A00
 371 003e 0000     		.text
 372              	.Letext0:
 373              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 374              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\mach
 375              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdi
 376              		.file 5 "./stm32_lib/stm32f10x_type.h"
 377              		.file 6 "hardware.h"
 378              		.file 7 "./25519/sha256.h"
 379              		.file 8 "image.h"
 380              		.file 9 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stri
 381              		.file 10 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\std
 382              		.file 11 "./25519/edsign.h"
 383              		.file 12 "usb.h"
DEFINED SYMBOLS
                            *ABS*:00000000 image.c
C:\Users\haifisch\AppData\Local\Temp\ccClZ9UR.s:19     .text.imageCheckFromAddress:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccClZ9UR.s:24     .text.imageCheckFromAddress:00000000 imageCheckFromAddress
C:\Users\haifisch\AppData\Local\Temp\ccClZ9UR.s:314    .text.imageCheckFromAddress:00000188 $d
                            *COM*:00000004 wTransferSize
C:\Users\haifisch\AppData\Local\Temp\ccClZ9UR.s:326    .rodata:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccClZ9UR.s:362    .rodata.str1.4:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
memset
memcpy
flashUnlock
uart_printf
flashErasePage
sha256_starts
sha256_update
uid_read
sprintf
sha256_finish
edsign_verify
