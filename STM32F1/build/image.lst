   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"image.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.failErase,"ax",%progbits
  19              		.align	1
  20              		.global	failErase
  21              		.thumb
  22              		.thumb_func
  24              	failErase:
  25              	.LFB1:
  26              		.file 1 "image.c"
   1:image.c       **** /*
   2:image.c       ****  * Copyright (C) 2016-2017 Sun Tzu Security, LLC. All rights reserved.
   3:image.c       ****  *
   4:image.c       ****  * This document is the property of Sun Tzu Security, LLC.
   5:image.c       ****  * It is considered confidential and proprietary.
   6:image.c       ****  *
   7:image.c       ****  * This document may not be reproduced or transmitted in any form,
   8:image.c       ****  * in whole or in part, without the express written permission of
   9:image.c       ****  * Sun Tzu Security, LLC.
  10:image.c       ****  */
  11:image.c       **** #include <stdio.h>
  12:image.c       **** #include <stdint.h>
  13:image.c       **** #include <string.h>
  14:image.c       **** #include <limits.h>
  15:image.c       **** #include <unistd.h>
  16:image.c       **** #include <errno.h>
  17:image.c       **** #include <stdarg.h>
  18:image.c       **** 
  19:image.c       **** #include "hardware.h"
  20:image.c       **** #include "sha256.h"
  21:image.c       **** #include "edsign.h"
  22:image.c       **** #include "image.h"
  23:image.c       **** 
  24:image.c       **** uint8_t rootCA[32] = {
  25:image.c       ****        0xbd, 0x0c, 0x2d, 0x04, 0x2e, 0x5a, 0x95, 0xc6, 0xb6, 0x28, 0xfc, 0x3f, 0x85, 0x6c, 0xa1, 0x
  26:image.c       ****     };
  27:image.c       **** 
  28:image.c       **** static void print_hex(const char *label, const uint8_t *data, int len)
  29:image.c       **** {
  30:image.c       ****     int i;
  31:image.c       **** 
  32:image.c       ****     uart_printf("%s: ", label);
  33:image.c       ****     for (i = 0; i < len; i++)
  34:image.c       ****         uart_printf("%02x", data[i]);
  35:image.c       ****     uart_printf("\n");
  36:image.c       **** }
  37:image.c       **** 
  38:image.c       **** void failErase () {
  27              		.loc 1 38 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 08B5     		push	{r3, lr}
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  39:image.c       **** 	// for whatever reason this only flashes upto 0x08008800
  40:image.c       **** 	flashErasePage((u32)(0x08008000));
  35              		.loc 1 40 0
  36 0002 0A48     		ldr	r0, .L2
  37 0004 FFF7FEFF 		bl	flashErasePage
  38              	.LVL0:
  41:image.c       **** 	flashErasePage((u32)(0x08008000+1024));
  39              		.loc 1 41 0
  40 0008 0948     		ldr	r0, .L2+4
  41 000a FFF7FEFF 		bl	flashErasePage
  42              	.LVL1:
  42:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
  43              		.loc 1 42 0
  44 000e 0948     		ldr	r0, .L2+8
  45 0010 FFF7FEFF 		bl	flashErasePage
  46              	.LVL2:
  43:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
  47              		.loc 1 43 0
  48 0014 0848     		ldr	r0, .L2+12
  49 0016 FFF7FEFF 		bl	flashErasePage
  50              	.LVL3:
  44:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
  51              		.loc 1 44 0
  52 001a 0848     		ldr	r0, .L2+16
  53 001c FFF7FEFF 		bl	flashErasePage
  54              	.LVL4:
  45:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
  46:image.c       **** }
  55              		.loc 1 46 0
  56 0020 BDE80840 		pop	{r3, lr}
  45:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
  57              		.loc 1 45 0
  58 0024 0648     		ldr	r0, .L2+20
  59 0026 FFF7FEBF 		b	flashErasePage
  60              	.LVL5:
  61              	.L3:
  62 002a 00BF     		.align	2
  63              	.L2:
  64 002c 00800008 		.word	134250496
  65 0030 00840008 		.word	134251520
  66 0034 20830008 		.word	134251296
  67 0038 B0840008 		.word	134251696
  68 003c 40860008 		.word	134252096
  69 0040 D0870008 		.word	134252496
  70              		.cfi_endproc
  71              	.LFE1:
  73              		.section	.text.imageCheckFromAddress,"ax",%progbits
  74              		.align	1
  75              		.global	imageCheckFromAddress
  76              		.thumb
  77              		.thumb_func
  79              	imageCheckFromAddress:
  80              	.LFB2:
  47:image.c       **** 
  48:image.c       **** int imageCheckFromAddress(ImageObjectHandle *newHandle, vu32 flashAddress, bool shouldEraseFlashOnF
  49:image.c       **** {
  81              		.loc 1 49 0
  82              		.cfi_startproc
  83              		@ args = 0, pretend = 0, frame = 368
  84              		@ frame_needed = 0, uses_anonymous_args = 0
  85              	.LVL6:
  86 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  87              		.cfi_def_cfa_offset 24
  88              		.cfi_offset 4, -24
  89              		.cfi_offset 5, -20
  90              		.cfi_offset 6, -16
  91              		.cfi_offset 7, -12
  92              		.cfi_offset 8, -8
  93              		.cfi_offset 14, -4
  94 0004 DCB0     		sub	sp, sp, #368
  95              		.cfi_def_cfa_offset 392
  96              	.LVL7:
  97              		.loc 1 49 0
  98 0006 0191     		str	r1, [sp, #4]
  99 0008 0746     		mov	r7, r0
  50:image.c       **** 	ImageRootHeader		*hdr;
  51:image.c       **** 	ImageInternalState		state;
  52:image.c       **** 	int bufferSize = 0x28+0x40;
  53:image.c       **** 	unsigned char imageBuffer[bufferSize];
  54:image.c       ****     memset(imageBuffer, 0xFF, sizeof(imageBuffer));
 100              		.loc 1 54 0
 101 000a FF21     		movs	r1, #255
 102              	.LVL8:
  49:image.c       **** {
 103              		.loc 1 49 0
 104 000c 9046     		mov	r8, r2
 105              		.loc 1 54 0
 106 000e 42A8     		add	r0, sp, #264
 107              	.LVL9:
 108 0010 6822     		movs	r2, #104
 109              	.LVL10:
 110 0012 FFF7FEFF 		bl	memset
 111              	.LVL11:
  55:image.c       ****     memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
  56:image.c       ****     flashUnlock();
  57:image.c       ****     memset(&state, 0, sizeof(state));
 112              		.loc 1 57 0
 113 0016 05AE     		add	r6, sp, #20
  55:image.c       ****     memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
 114              		.loc 1 55 0
 115 0018 0199     		ldr	r1, [sp, #4]
 116 001a 6822     		movs	r2, #104
 117 001c 42A8     		add	r0, sp, #264
 118              	.LVL12:
 119 001e FFF7FEFF 		bl	memcpy
 120              	.LVL13:
  56:image.c       ****     flashUnlock();
 121              		.loc 1 56 0
 122 0022 FFF7FEFF 		bl	flashUnlock
 123              	.LVL14:
 124              		.loc 1 57 0
 125 0026 1422     		movs	r2, #20
 126 0028 3046     		mov	r0, r6
 127 002a 0021     		movs	r1, #0
 128 002c FFF7FEFF 		bl	memset
 129              	.LVL15:
  58:image.c       **** 
  59:image.c       **** 	hdr = (ImageRootHeader *)imageBuffer;
  60:image.c       **** 
  61:image.c       **** 	if (bufferSize < sizeof(hdr)) {
  62:image.c       **** 		debug_print("buffer size %X too small for header size %X\n", bufferSize, sizeof(*hdr));
  63:image.c       **** 		if (shouldEraseFlashOnFail)
  64:image.c       **** 		{
  65:image.c       **** 			failErase();
  66:image.c       **** 		}
  67:image.c       **** 		return(EINVAL);		/* buffer too small to really contain header */
  68:image.c       **** 	}
  69:image.c       **** 	if ((hdr->header.magic) != kImageHeaderMagic) {
 130              		.loc 1 69 0
 131 0030 429B     		ldr	r3, [sp, #264]
 132 0032 504A     		ldr	r2, .L34
 133 0034 9342     		cmp	r3, r2
 134 0036 03D1     		bne	.L32
  70:image.c       **** 		debug_print("bad magic 0x%08x expecting 0x%08x\n", (hdr->header.magic), kImageHeaderMagic);
  71:image.c       **** 		state.flags = kImageImageMissingMagic;
  72:image.c       **** 		if (shouldEraseFlashOnFail)
  73:image.c       **** 		{
  74:image.c       **** 			failErase();
  75:image.c       **** 		}
  76:image.c       **** 		*newHandle = &state;
  77:image.c       **** 		return(kImageImageMissingMagic);		/* magic must match */
  78:image.c       **** 	}
  79:image.c       **** 	if ((hdr->signing.imageType) != 0x45444f53)
 135              		.loc 1 79 0
 136 0038 469B     		ldr	r3, [sp, #280]
 137 003a 4F4A     		ldr	r2, .L34+4
 138 003c 9342     		cmp	r3, r2
 139 003e 09D0     		beq	.L8
 140              	.L32:
  80:image.c       **** 	{
  81:image.c       **** 		debug_print("bad magic 0x%08x expecting 0x%X\n", (hdr->signing.imageType), 0x45444f53);
  82:image.c       **** 		state.flags = kImageImageMissingMagic;
 141              		.loc 1 82 0
 142 0040 0423     		movs	r3, #4
 143 0042 7360     		str	r3, [r6, #4]
  83:image.c       **** 		if (shouldEraseFlashOnFail)
 144              		.loc 1 83 0
 145 0044 B8F1000F 		cmp	r8, #0
 146 0048 01D0     		beq	.L9
  84:image.c       **** 		{
  85:image.c       **** 			failErase();
 147              		.loc 1 85 0
 148 004a FFF7FEFF 		bl	failErase
 149              	.LVL16:
 150              	.L9:
  86:image.c       **** 		}
  87:image.c       **** 		*newHandle = &state;
 151              		.loc 1 87 0
 152 004e 3E60     		str	r6, [r7]
  88:image.c       **** 		return(kImageImageMissingMagic);		/* magic must match */
 153              		.loc 1 88 0
 154 0050 0420     		movs	r0, #4
 155 0052 8CE0     		b	.L7
 156              	.L8:
  89:image.c       **** 	}
  90:image.c       **** 	state.flags = kImageImageWasInstantiated;
 157              		.loc 1 90 0
 158 0054 0124     		movs	r4, #1
 159 0056 7460     		str	r4, [r6, #4]
  91:image.c       **** 
  92:image.c       **** 	debug_print("dataSize: 0x0%X\n", (0x08008000+(hdr->header.dataSize)));
  93:image.c       **** 
  94:image.c       **** 	state.cursor = (hdr->header.dataSize)+0x200;
 160              		.loc 1 94 0
 161 0058 449B     		ldr	r3, [sp, #272]
  95:image.c       **** 	state.lastTag = -1;
  96:image.c       **** 
  97:image.c       **** 	unsigned char sha256sum[32];
  98:image.c       **** 
  99:image.c       ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
 162              		.loc 1 99 0
 163 005a FF21     		movs	r1, #255
  94:image.c       **** 	state.cursor = (hdr->header.dataSize)+0x200;
 164              		.loc 1 94 0
 165 005c 03F50073 		add	r3, r3, #512
 166              		.loc 1 99 0
 167 0060 2022     		movs	r2, #32
  94:image.c       **** 	state.cursor = (hdr->header.dataSize)+0x200;
 168              		.loc 1 94 0
 169 0062 F360     		str	r3, [r6, #12]
 170              		.loc 1 99 0
 171 0064 10A8     		add	r0, sp, #64
  95:image.c       **** 	state.lastTag = -1;
 172              		.loc 1 95 0
 173 0066 4FF0FF33 		mov	r3, #-1
 174 006a 3361     		str	r3, [r6, #16]
 175              		.loc 1 99 0
 176 006c FFF7FEFF 		bl	memset
 177              	.LVL17:
 100:image.c       **** 
 101:image.c       ****     sha256_context ctx;
 102:image.c       ****     sha256_starts(&ctx);
 178              		.loc 1 102 0
 179 0070 28A8     		add	r0, sp, #160
 180 0072 FFF7FEFF 		bl	sha256_starts
 181              	.LVL18:
 103:image.c       **** 
 104:image.c       ****     int buffSize = 0x4;
 105:image.c       ****     char buff[buffSize];
 106:image.c       **** 
 107:image.c       ****     int i = 0x84;
 108:image.c       ****     char cmpEnd[4] = {0x01, 0x00, 0x00, 0x00,}; 
 109:image.c       ****     hexdump((flashAddress+i), 0x20);
 182              		.loc 1 109 0
 183 0076 0198     		ldr	r0, [sp, #4]
 108:image.c       ****     char cmpEnd[4] = {0x01, 0x00, 0x00, 0x00,}; 
 184              		.loc 1 108 0
 185 0078 0023     		movs	r3, #0
 186              		.loc 1 109 0
 187 007a 8430     		adds	r0, r0, #132
 188 007c 2021     		movs	r1, #32
 108:image.c       ****     char cmpEnd[4] = {0x01, 0x00, 0x00, 0x00,}; 
 189              		.loc 1 108 0
 190 007e 8DF80C40 		strb	r4, [sp, #12]
 191 0082 8DF80D30 		strb	r3, [sp, #13]
 192 0086 8DF80E30 		strb	r3, [sp, #14]
 193 008a 8DF80F30 		strb	r3, [sp, #15]
 194              		.loc 1 109 0
 195 008e FFF7FEFF 		bl	hexdump
 196              	.LVL19:
 107:image.c       ****     int i = 0x84;
 197              		.loc 1 107 0
 198 0092 8424     		movs	r4, #132
 199              	.LVL20:
 200              	.L10:
 110:image.c       ****     debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), ((hdr->header.dataSize) - 0x40));
 111:image.c       ****     while ((flashAddress+i) <= (flashAddress+state.cursor))
 201              		.loc 1 111 0 discriminator 1
 202 0094 019A     		ldr	r2, [sp, #4]
 203 0096 F368     		ldr	r3, [r6, #12]
 204 0098 0199     		ldr	r1, [sp, #4]
 205 009a 2244     		add	r2, r2, r4
 206 009c 0B44     		add	r3, r3, r1
 207 009e 9A42     		cmp	r2, r3
 208 00a0 28D8     		bhi	.L12
 112:image.c       ****     {
 113:image.c       ****       memset(buff, 0xFF, buffSize);
 209              		.loc 1 113 0
 210 00a2 4FF0FF33 		mov	r3, #-1
 211 00a6 0493     		str	r3, [sp, #16]
 114:image.c       ****       memcpy(buff, (unsigned char *)(flashAddress+i), buffSize);
 212              		.loc 1 114 0
 213 00a8 019B     		ldr	r3, [sp, #4]
 115:image.c       ****       if ((memmem(&buff, buffSize, &cmpEnd, buffSize) > 0) && ((flashAddress + hdr->header.dataSize
 214              		.loc 1 115 0
 215 00aa 0421     		movs	r1, #4
 114:image.c       ****       memcpy(buff, (unsigned char *)(flashAddress+i), buffSize);
 216              		.loc 1 114 0
 217 00ac E058     		ldr	r0, [r4, r3]	@ unaligned
 218              		.loc 1 115 0
 219 00ae 03AA     		add	r2, sp, #12
 114:image.c       ****       memcpy(buff, (unsigned char *)(flashAddress+i), buffSize);
 220              		.loc 1 114 0
 221 00b0 0490     		str	r0, [sp, #16]	@ unaligned
 222              		.loc 1 115 0
 223 00b2 0B46     		mov	r3, r1
 224 00b4 04A8     		add	r0, sp, #16
 225              	.LVL21:
 226 00b6 FFF7FEFF 		bl	memmem
 227              	.LVL22:
 228 00ba 98B1     		cbz	r0, .L11
 229              		.loc 1 115 0 is_stmt 0 discriminator 1
 230 00bc 0199     		ldr	r1, [sp, #4]
 231 00be 449B     		ldr	r3, [sp, #272]
 232 00c0 019A     		ldr	r2, [sp, #4]
 233 00c2 0B44     		add	r3, r3, r1
 234 00c4 403B     		subs	r3, r3, #64
 235 00c6 2244     		add	r2, r2, r4
 236 00c8 9342     		cmp	r3, r2
 237 00ca 0BD2     		bcs	.L11
 116:image.c       ****       {
 117:image.c       ****       	sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
 238              		.loc 1 117 0 is_stmt 1
 239 00cc 0199     		ldr	r1, [sp, #4]
 240 00ce 28A8     		add	r0, sp, #160
 241 00d0 2144     		add	r1, r1, r4
 242 00d2 0422     		movs	r2, #4
 243 00d4 FFF7FEFF 		bl	sha256_update
 244              	.LVL23:
 118:image.c       ****       	debug_print("Hash Finish: %X\n", (flashAddress+i));
 119:image.c       ****       	hexdump((flashAddress+i), 0xC);
 245              		.loc 1 119 0
 246 00d8 0198     		ldr	r0, [sp, #4]
 247 00da 0C21     		movs	r1, #12
 248 00dc 2044     		add	r0, r0, r4
 249 00de FFF7FEFF 		bl	hexdump
 250              	.LVL24:
 120:image.c       ****       	break;
 251              		.loc 1 120 0
 252 00e2 07E0     		b	.L12
 253              	.L11:
 121:image.c       ****       }
 122:image.c       ****       sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
 254              		.loc 1 122 0
 255 00e4 0199     		ldr	r1, [sp, #4]
 256 00e6 28A8     		add	r0, sp, #160
 257 00e8 2144     		add	r1, r1, r4
 258 00ea 0422     		movs	r2, #4
 259 00ec FFF7FEFF 		bl	sha256_update
 260              	.LVL25:
 123:image.c       ****       i += 0x4;
 261              		.loc 1 123 0
 262 00f0 0434     		adds	r4, r4, #4
 263              	.LVL26:
 264 00f2 CFE7     		b	.L10
 265              	.L12:
 124:image.c       ****     }
 125:image.c       **** 
 126:image.c       ****     unsigned char uniqueID[0x17];
 127:image.c       ****     if (!QEMU_BUILD)
 128:image.c       ****     {
 129:image.c       ****     	struct u_id id;
 130:image.c       **** 	    uid_read(&id);
 131:image.c       **** 	    sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
 132:image.c       **** 	    sha256_update(&ctx, uniqueID, 0x17);
 133:image.c       ****     } else {
 134:image.c       ****     	// QEMU builds get FF ECIDs
 135:image.c       ****     	memcpy(&uniqueID, (unsigned char*)"FFFFFFFFFFFFFFFFFFFFFFF", 0x17);
 266              		.loc 1 135 0
 267 00f4 214B     		ldr	r3, .L34+8
 268 00f6 0AAC     		add	r4, sp, #40
 269              	.LVL27:
 270 00f8 03F11005 		add	r5, r3, #16
 271              	.L14:
 272 00fc 1868     		ldr	r0, [r3]	@ unaligned
 273 00fe 5968     		ldr	r1, [r3, #4]	@ unaligned
 274 0100 2246     		mov	r2, r4
 275 0102 03C2     		stmia	r2!, {r0, r1}
 276 0104 0833     		adds	r3, r3, #8
 277 0106 AB42     		cmp	r3, r5
 278 0108 1446     		mov	r4, r2
 279 010a F7D1     		bne	.L14
 280 010c 1868     		ldr	r0, [r3]	@ unaligned
 136:image.c       **** 	    sha256_update(&ctx, uniqueID, 0x17);
 281              		.loc 1 136 0
 282 010e 0AA9     		add	r1, sp, #40
 135:image.c       ****     	memcpy(&uniqueID, (unsigned char*)"FFFFFFFFFFFFFFFFFFFFFFF", 0x17);
 283              		.loc 1 135 0
 284 0110 1060     		str	r0, [r2]	@ unaligned
 285 0112 9A88     		ldrh	r2, [r3, #4]	@ unaligned
 286 0114 9B79     		ldrb	r3, [r3, #6]	@ zero_extendqisi2
 287 0116 A280     		strh	r2, [r4, #4]	@ unaligned
 288 0118 A371     		strb	r3, [r4, #6]
 289              		.loc 1 136 0
 290 011a 1722     		movs	r2, #23
 291 011c 28A8     		add	r0, sp, #160
 292 011e FFF7FEFF 		bl	sha256_update
 293              	.LVL28:
 137:image.c       ****     }
 138:image.c       **** 
 139:image.c       ****     debug_print("%s\n", uniqueID);
 140:image.c       ****     
 141:image.c       ****     sha256_finish(&ctx, sha256sum);
 294              		.loc 1 141 0
 295 0122 10A9     		add	r1, sp, #64
 296 0124 28A8     		add	r0, sp, #160
 297 0126 FFF7FEFF 		bl	sha256_finish
 298              	.LVL29:
 142:image.c       ****     print_hash(sha256sum);
 143:image.c       ****     // verify signature against recalc hash
 144:image.c       ****     uint8_t sigbuff[0x40];
 145:image.c       ****     memcpy(sigbuff, (uint8_t*)(hdr->signing.imageSignature), 0x40);
 299              		.loc 1 145 0
 300 012a 18AC     		add	r4, sp, #96
 142:image.c       ****     print_hash(sha256sum);
 301              		.loc 1 142 0
 302 012c 10A8     		add	r0, sp, #64
 303              		.loc 1 145 0
 304 012e 47AD     		add	r5, sp, #284
 142:image.c       ****     print_hash(sha256sum);
 305              		.loc 1 142 0
 306 0130 FFF7FEFF 		bl	print_hash
 307              	.LVL30:
 308              		.loc 1 145 0
 309 0134 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 310 0136 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 311 0138 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 312 013a 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 313 013c 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 314 013e 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 315 0140 95E80F00 		ldmia	r5, {r0, r1, r2, r3}
 316 0144 84E80F00 		stmia	r4, {r0, r1, r2, r3}
 146:image.c       **** 
 147:image.c       ****     if (edsign_verify(sigbuff, rootCA, sha256sum, 32) <= 0) {
 317              		.loc 1 147 0
 318 0148 18A8     		add	r0, sp, #96
 319 014a 0D49     		ldr	r1, .L34+12
 320 014c 10AA     		add	r2, sp, #64
 321 014e 2023     		movs	r3, #32
 322 0150 FFF7FEFF 		bl	edsign_verify
 323              	.LVL31:
 324 0154 48B9     		cbnz	r0, .L15
 148:image.c       ****     	state.flags = kImageImageRejectSignature;
 325              		.loc 1 148 0
 326 0156 0223     		movs	r3, #2
 327 0158 7360     		str	r3, [r6, #4]
 149:image.c       ****     	if (shouldEraseFlashOnFail)
 328              		.loc 1 149 0
 329 015a B8F1000F 		cmp	r8, #0
 330 015e 01D0     		beq	.L16
 150:image.c       **** 		{
 151:image.c       **** 			failErase();
 331              		.loc 1 151 0
 332 0160 FFF7FEFF 		bl	failErase
 333              	.LVL32:
 334              	.L16:
 152:image.c       **** 		}
 153:image.c       ****     	*newHandle = &state;
 335              		.loc 1 153 0
 336 0164 3E60     		str	r6, [r7]
 154:image.c       ****     	return kImageImageRejectSignature;
 337              		.loc 1 154 0
 338 0166 0220     		movs	r0, #2
 339 0168 01E0     		b	.L7
 340              	.L15:
 155:image.c       ****     } else {
 156:image.c       ****     	state.flags = kImageImageIsTrusted;
 157:image.c       ****     	*newHandle = &state;
 341              		.loc 1 157 0
 342 016a 3E60     		str	r6, [r7]
 158:image.c       ****     	return kImageImageIsTrusted;
 343              		.loc 1 158 0
 344 016c 0320     		movs	r0, #3
 345              	.LVL33:
 346              	.L7:
 159:image.c       ****     }
 160:image.c       **** 	
 161:image.c       **** 	*newHandle = &state;
 162:image.c       **** 	return(0);
 163:image.c       **** }
 347              		.loc 1 163 0
 348 016e 5CB0     		add	sp, sp, #368
 349              		@ sp needed
 350 0170 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 351              	.LVL34:
 352              	.L35:
 353              		.align	2
 354              	.L34:
 355 0174 32636245 		.word	1164075826
 356 0178 534F4445 		.word	1162104659
 357 017c 00000000 		.word	.LC0
 358 0180 00000000 		.word	.LANCHOR0
 359              		.cfi_endproc
 360              	.LFE2:
 362              		.global	rootCA
 363              		.comm	wTransferSize,4,4
 364              		.section	.data.rootCA,"aw",%progbits
 365              		.set	.LANCHOR0,. + 0
 368              	rootCA:
 369 0000 BD       		.byte	-67
 370 0001 0C       		.byte	12
 371 0002 2D       		.byte	45
 372 0003 04       		.byte	4
 373 0004 2E       		.byte	46
 374 0005 5A       		.byte	90
 375 0006 95       		.byte	-107
 376 0007 C6       		.byte	-58
 377 0008 B6       		.byte	-74
 378 0009 28       		.byte	40
 379 000a FC       		.byte	-4
 380 000b 3F       		.byte	63
 381 000c 85       		.byte	-123
 382 000d 6C       		.byte	108
 383 000e A1       		.byte	-95
 384 000f FB       		.byte	-5
 385 0010 B5       		.byte	-75
 386 0011 25       		.byte	37
 387 0012 07       		.byte	7
 388 0013 38       		.byte	56
 389 0014 C0       		.byte	-64
 390 0015 05       		.byte	5
 391 0016 9D       		.byte	-99
 392 0017 44       		.byte	68
 393 0018 04       		.byte	4
 394 0019 A7       		.byte	-89
 395 001a E3       		.byte	-29
 396 001b A6       		.byte	-90
 397 001c AC       		.byte	-84
 398 001d 3B       		.byte	59
 399 001e B8       		.byte	-72
 400 001f 41       		.byte	65
 401              		.section	.rodata.str1.1,"aMS",%progbits,1
 402              	.LC0:
 403 0000 46464646 		.ascii	"FFFFFFFFFFFFFFFFFFFFFFF\000"
 403      46464646 
 403      46464646 
 403      46464646 
 403      46464646 
 404              		.text
 405              	.Letext0:
 406              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 407              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\mach
 408              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdi
 409              		.file 5 "./stm32_lib/stm32f10x_type.h"
 410              		.file 6 "./25519/sha256.h"
 411              		.file 7 "image.h"
 412              		.file 8 "usb.h"
 413              		.file 9 "hardware.h"
 414              		.file 10 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\str
 415              		.file 11 "./25519/edsign.h"
DEFINED SYMBOLS
                            *ABS*:00000000 image.c
C:\Users\haifisch\AppData\Local\Temp\ccpHIg1r.s:19     .text.failErase:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccpHIg1r.s:24     .text.failErase:00000000 failErase
C:\Users\haifisch\AppData\Local\Temp\ccpHIg1r.s:64     .text.failErase:0000002c $d
C:\Users\haifisch\AppData\Local\Temp\ccpHIg1r.s:74     .text.imageCheckFromAddress:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccpHIg1r.s:79     .text.imageCheckFromAddress:00000000 imageCheckFromAddress
C:\Users\haifisch\AppData\Local\Temp\ccpHIg1r.s:355    .text.imageCheckFromAddress:00000174 $d
C:\Users\haifisch\AppData\Local\Temp\ccpHIg1r.s:368    .data.rootCA:00000000 rootCA
                            *COM*:00000004 wTransferSize
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
flashErasePage
memset
memcpy
flashUnlock
sha256_starts
hexdump
memmem
sha256_update
sha256_finish
print_hash
edsign_verify
