   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"image.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.failErase,"ax",%progbits
  16              		.align	1
  17              		.global	failErase
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	failErase:
  24              	.LFB4:
  25              		.file 1 "image.c"
   1:image.c       **** /*
   2:image.c       ****  * Copyright (C) 2016-2017 Sun Tzu Security, LLC. All rights reserved.
   3:image.c       ****  *
   4:image.c       ****  * This document is the property of Sun Tzu Security, LLC.
   5:image.c       ****  * It is considered confidential and proprietary.
   6:image.c       ****  *
   7:image.c       ****  * This document may not be reproduced or transmitted in any form,
   8:image.c       ****  * in whole or in part, without the express written permission of
   9:image.c       ****  * Sun Tzu Security, LLC.
  10:image.c       ****  */
  11:image.c       **** #include <stdio.h>
  12:image.c       **** #include <stdint.h>
  13:image.c       **** #include <string.h>
  14:image.c       **** #include <limits.h>
  15:image.c       **** #include <unistd.h>
  16:image.c       **** #include <errno.h>
  17:image.c       **** #include <stdarg.h>
  18:image.c       **** 
  19:image.c       **** #include "hardware.h"
  20:image.c       **** #include "sha256.h"
  21:image.c       **** #include "edsign.h"
  22:image.c       **** #include "image.h"
  23:image.c       **** 
  24:image.c       **** uint8_t rootCA[32] = {
  25:image.c       ****       0x0f, 0x72, 0xeb, 0xd1, 0x64, 0x3e, 0xab, 0x54, 0xc8, 0xcf, 0x60, 0xe6, 0x6f, 0xc3, 0x9d, 0x6
  26:image.c       ****     };
  27:image.c       **** 
  28:image.c       **** static void print_hex(const char *label, const uint8_t *data, int len)
  29:image.c       **** {
  30:image.c       ****     int i;
  31:image.c       **** 
  32:image.c       ****     uart_printf("%s: ", label);
  33:image.c       ****     for (i = 0; i < len; i++)
  34:image.c       ****         uart_printf("%02x", data[i]);
  35:image.c       ****     uart_printf("\n");
  36:image.c       **** }
  37:image.c       **** 
  38:image.c       **** void failErase () {
  26              		.loc 1 38 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30 0000 08B5     		push	{r3, lr}
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 3, -8
  33              		.cfi_offset 14, -4
  39:image.c       **** 	// for whatever reason this only flashes upto 0x08008800
  40:image.c       **** 	flashErasePage((u32)(0x08008000));
  34              		.loc 1 40 0
  35 0002 0A48     		ldr	r0, .L2
  36 0004 FFF7FEFF 		bl	flashErasePage
  37              	.LVL0:
  41:image.c       **** 	flashErasePage((u32)(0x08008000+1024));
  38              		.loc 1 41 0
  39 0008 0948     		ldr	r0, .L2+4
  40 000a FFF7FEFF 		bl	flashErasePage
  41              	.LVL1:
  42:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
  42              		.loc 1 42 0
  43 000e 0948     		ldr	r0, .L2+8
  44 0010 FFF7FEFF 		bl	flashErasePage
  45              	.LVL2:
  43:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
  46              		.loc 1 43 0
  47 0014 0848     		ldr	r0, .L2+12
  48 0016 FFF7FEFF 		bl	flashErasePage
  49              	.LVL3:
  44:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
  50              		.loc 1 44 0
  51 001a 0848     		ldr	r0, .L2+16
  52 001c FFF7FEFF 		bl	flashErasePage
  53              	.LVL4:
  45:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
  46:image.c       **** }
  54              		.loc 1 46 0
  55 0020 BDE80840 		pop	{r3, lr}
  56              		.cfi_restore 14
  57              		.cfi_restore 3
  58              		.cfi_def_cfa_offset 0
  45:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
  59              		.loc 1 45 0
  60 0024 0648     		ldr	r0, .L2+20
  61 0026 FFF7FEBF 		b	flashErasePage
  62              	.LVL5:
  63              	.L3:
  64 002a 00BF     		.align	2
  65              	.L2:
  66 002c 00800008 		.word	134250496
  67 0030 00840008 		.word	134251520
  68 0034 20830008 		.word	134251296
  69 0038 B0840008 		.word	134251696
  70 003c 40860008 		.word	134252096
  71 0040 D0870008 		.word	134252496
  72              		.cfi_endproc
  73              	.LFE4:
  75              		.section	.text.imageCheckFromAddress,"ax",%progbits
  76              		.align	1
  77              		.global	imageCheckFromAddress
  78              		.syntax unified
  79              		.thumb
  80              		.thumb_func
  81              		.fpu softvfp
  83              	imageCheckFromAddress:
  84              	.LFB5:
  47:image.c       **** 
  48:image.c       **** int imageCheckFromAddress(ImageObjectHandle *newHandle, vu32 flashAddress, bool shouldEraseFlashOnF
  49:image.c       **** {
  85              		.loc 1 49 0
  86              		.cfi_startproc
  87              		@ args = 0, pretend = 0, frame = 336
  88              		@ frame_needed = 0, uses_anonymous_args = 0
  89              	.LVL6:
  90 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  91              		.cfi_def_cfa_offset 24
  92              		.cfi_offset 4, -24
  93              		.cfi_offset 5, -20
  94              		.cfi_offset 6, -16
  95              		.cfi_offset 7, -12
  96              		.cfi_offset 8, -8
  97              		.cfi_offset 14, -4
  98 0004 D4B0     		sub	sp, sp, #336
  99              		.cfi_def_cfa_offset 360
 100              	.LVL7:
 101              		.loc 1 49 0
 102 0006 0191     		str	r1, [sp, #4]
  50:image.c       **** 	ImageRootHeader		*hdr;
  51:image.c       **** 	ImageInternalState		state;
  52:image.c       **** 	int bufferSize = 0x28+0x40;
  53:image.c       **** 	unsigned char imageBuffer[bufferSize];
  54:image.c       ****     memset(imageBuffer, 0xFF, sizeof(imageBuffer));
  55:image.c       ****     memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
 103              		.loc 1 55 0
 104 0008 0199     		ldr	r1, [sp, #4]
 105              	.LVL8:
  49:image.c       **** 	ImageRootHeader		*hdr;
 106              		.loc 1 49 0
 107 000a 0746     		mov	r7, r0
 108 000c 9046     		mov	r8, r2
 109              		.loc 1 55 0
 110 000e 3AA8     		add	r0, sp, #232
 111              	.LVL9:
 112 0010 6822     		movs	r2, #104
 113              	.LVL10:
  56:image.c       ****     memset(&state, 0, sizeof(state));
 114              		.loc 1 56 0
 115 0012 03AE     		add	r6, sp, #12
  55:image.c       ****     memset(&state, 0, sizeof(state));
 116              		.loc 1 55 0
 117 0014 FFF7FEFF 		bl	memcpy
 118              	.LVL11:
 119              		.loc 1 56 0
 120 0018 1422     		movs	r2, #20
 121 001a 0021     		movs	r1, #0
 122 001c 3046     		mov	r0, r6
 123 001e FFF7FEFF 		bl	memset
 124              	.LVL12:
  57:image.c       **** 
  58:image.c       **** 	hdr = (ImageRootHeader *)imageBuffer;
  59:image.c       **** 	if (bufferSize < sizeof(hdr)) {
  60:image.c       **** 		debug_print("buffer size %X too small for header size %X\n", bufferSize, sizeof(*hdr));
  61:image.c       **** 		if (shouldEraseFlashOnFail)
  62:image.c       **** 		{
  63:image.c       **** 			failErase();
  64:image.c       **** 		}
  65:image.c       **** 		return(EINVAL);		/* buffer too small to really contain header */
  66:image.c       **** 	}
  67:image.c       **** 	if ((hdr->header.magic) != kImageHeaderMagic) {
 125              		.loc 1 67 0
 126 0022 3A99     		ldr	r1, [sp, #232]
 127 0024 464A     		ldr	r2, .L21
 128 0026 9142     		cmp	r1, r2
 129 0028 0ED0     		beq	.L5
  68:image.c       **** 		debug_print("bad magic 0x%08x expecting 0x%08x\n", (hdr->header.magic), kImageHeaderMagic);
 130              		.loc 1 68 0 discriminator 1
 131 002a 4648     		ldr	r0, .L21+4
 132              	.L20:
 133 002c FFF7FEFF 		bl	uart_printf
 134              	.LVL13:
  69:image.c       **** 		state.flags = kImageImageMissingMagic;
 135              		.loc 1 69 0 discriminator 1
 136 0030 0423     		movs	r3, #4
 137 0032 7360     		str	r3, [r6, #4]
  70:image.c       **** 		if (shouldEraseFlashOnFail)
 138              		.loc 1 70 0 discriminator 1
 139 0034 B8F1000F 		cmp	r8, #0
 140 0038 01D0     		beq	.L7
  71:image.c       **** 		{
  72:image.c       **** 			failErase();
 141              		.loc 1 72 0
 142 003a FFF7FEFF 		bl	failErase
 143              	.LVL14:
 144              	.L7:
  73:image.c       **** 		}
  74:image.c       **** 		*newHandle = &state;
  75:image.c       **** 		return(kImageImageMissingMagic);		/* magic must match */
 145              		.loc 1 75 0
 146 003e 0420     		movs	r0, #4
  74:image.c       **** 		return(kImageImageMissingMagic);		/* magic must match */
 147              		.loc 1 74 0
 148 0040 3E60     		str	r6, [r7]
 149              	.L4:
  76:image.c       **** 	}
  77:image.c       **** 	if ((hdr->signing.imageType) != 0x45444f53)
  78:image.c       **** 	{
  79:image.c       **** 		debug_print("bad magic 0x%08x expecting 0x%X\n", (hdr->signing.imageType), 0x45444f53);
  80:image.c       **** 		state.flags = kImageImageMissingMagic;
  81:image.c       **** 		if (shouldEraseFlashOnFail)
  82:image.c       **** 		{
  83:image.c       **** 			failErase();
  84:image.c       **** 		}
  85:image.c       **** 		*newHandle = &state;
  86:image.c       **** 		return(kImageImageMissingMagic);		/* magic must match */
  87:image.c       **** 	}
  88:image.c       **** 	state.flags = kImageImageWasInstantiated;
  89:image.c       **** 
  90:image.c       **** 	debug_print("dataSize: 0x%X\n", (hdr->header.dataSize));
  91:image.c       **** 
  92:image.c       **** 	state.cursor = hdr->header.dataSize;
  93:image.c       **** 	state.lastTag = -1;
  94:image.c       **** 
  95:image.c       **** 	unsigned char sha256sum[32];
  96:image.c       **** 
  97:image.c       ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
  98:image.c       **** 
  99:image.c       ****     sha256_context ctx;
 100:image.c       ****     sha256_starts(&ctx);
 101:image.c       **** 
 102:image.c       ****     int buffSize = 0x1;
 103:image.c       ****     char buff[buffSize];
 104:image.c       **** 
 105:image.c       ****     int i = 0x84;
 106:image.c       ****     hexdump((flashAddress+i), 0x10);
 107:image.c       **** 
 108:image.c       ****     int finish = hdr->header.dataSize + 0x84;
 109:image.c       ****     debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
 110:image.c       ****     while (i < finish)
 111:image.c       ****     {
 112:image.c       ****     	memset(buff, 0xFF, buffSize);
 113:image.c       ****     	memcpy(buff, (unsigned char *)(flashAddress+i), buffSize);
 114:image.c       **** 		sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
 115:image.c       **** 		i += 0x1;
 116:image.c       ****     }
 117:image.c       ****     debug_print("Ended at: %X\n", (flashAddress+i));
 118:image.c       ****     hexdump((vu32 *)(flashAddress+i), 0x10);
 119:image.c       ****     if ((flashAddress+i) != (flashAddress+finish))
 120:image.c       ****     {
 121:image.c       ****     	debug_print("Calculated hash is probably wrong...\n");
 122:image.c       ****     	state.flags = kImageImageHashCalcFailed;
 123:image.c       ****     	*newHandle = &state;
 124:image.c       **** 		return(kImageImageHashCalcFailed);
 125:image.c       ****     }
 126:image.c       **** 
 127:image.c       ****     if (!QEMU_BUILD)
 128:image.c       ****     {
 129:image.c       ****     	struct u_id id;
 130:image.c       **** 		unsigned char uniqueID[0x17];
 131:image.c       **** 		unsigned char temp_sha256sum[32];  
 132:image.c       **** 		uint8_t publickey[EDSIGN_PUBLIC_KEY_SIZE];
 133:image.c       **** 		// read our unique id
 134:image.c       **** 		uid_read(&id);
 135:image.c       **** 		sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
 136:image.c       **** 		// start sha256 context
 137:image.c       **** 		sha256_context ctx2;
 138:image.c       **** 		sha256_starts(&ctx2);
 139:image.c       **** 		// hash in our unique id
 140:image.c       **** 		sha256_update(&ctx2, uniqueID, 0x17);
 141:image.c       **** 		sha256_finish(&ctx2, temp_sha256sum);
 142:image.c       **** 		// get our public key
 143:image.c       **** 		memset(publickey, 0, EDSIGN_PUBLIC_KEY_SIZE);
 144:image.c       **** 		edsign_sec_to_pub(publickey, temp_sha256sum);
 145:image.c       **** 		debug_print("publickey:\n");
 146:image.c       **** 		hexdump(publickey, 32);
 147:image.c       ****     	/*
 148:image.c       ****     	struct u_id id;
 149:image.c       **** 	    uid_read(&id);
 150:image.c       **** 	    sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
 151:image.c       **** 	    */
 152:image.c       **** 	    sha256_update(&ctx, (unsigned char*)publickey, 32);
 153:image.c       ****     }
 154:image.c       **** 
 155:image.c       ****     //debug_print("%s\n", uniqueID);
 156:image.c       ****     
 157:image.c       ****     sha256_finish(&ctx, sha256sum);
 158:image.c       ****     // verify signature against recalc hash
 159:image.c       ****     debug_print("Signature:\n");
 160:image.c       ****     hexdump(hdr->signing.imageSignature, 0x40);
 161:image.c       **** 	debug_print("sha256sum:\n");
 162:image.c       **** 	print_hash(sha256sum);
 163:image.c       **** 
 164:image.c       **** 	char sigbuff[64];
 165:image.c       **** 	memcpy(sigbuff, hdr->signing.imageSignature, 64);
 166:image.c       **** 
 167:image.c       ****     if (edsign_verify(sigbuff, rootCA, sha256sum, 32) <= 0) {
 168:image.c       ****     	state.flags = kImageImageRejectSignature;
 169:image.c       ****     	if (shouldEraseFlashOnFail)
 170:image.c       **** 		{
 171:image.c       **** 			failErase();
 172:image.c       **** 		}
 173:image.c       ****     	*newHandle = &state;
 174:image.c       ****     	return kImageImageRejectSignature;
 175:image.c       ****     } else {
 176:image.c       ****     	state.flags = kImageImageIsTrusted;
 177:image.c       ****     	*newHandle = &state;
 178:image.c       ****     	return kImageImageIsTrusted;
 179:image.c       ****     }
 180:image.c       **** 	*newHandle = &state;
 181:image.c       **** 	return(0);
 182:image.c       **** }
 150              		.loc 1 182 0
 151 0042 54B0     		add	sp, sp, #336
 152              		.cfi_remember_state
 153              		.cfi_def_cfa_offset 24
 154              		@ sp needed
 155 0044 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 156              	.LVL15:
 157              	.L5:
 158              		.cfi_restore_state
  77:image.c       **** 	{
 159              		.loc 1 77 0
 160 0048 3E99     		ldr	r1, [sp, #248]
 161 004a 3F4A     		ldr	r2, .L21+8
 162 004c 9142     		cmp	r1, r2
 163 004e 01D0     		beq	.L9
  79:image.c       **** 		state.flags = kImageImageMissingMagic;
 164              		.loc 1 79 0 discriminator 1
 165 0050 3E48     		ldr	r0, .L21+12
 166 0052 EBE7     		b	.L20
 167              	.L9:
  88:image.c       **** 
 168              		.loc 1 88 0
 169 0054 0123     		movs	r3, #1
 170 0056 7360     		str	r3, [r6, #4]
  90:image.c       **** 
 171              		.loc 1 90 0
 172 0058 3C99     		ldr	r1, [sp, #240]
 173 005a 3D48     		ldr	r0, .L21+16
 174 005c FFF7FEFF 		bl	uart_printf
 175              	.LVL16:
  92:image.c       **** 	state.lastTag = -1;
 176              		.loc 1 92 0
 177 0060 3C9B     		ldr	r3, [sp, #240]
  97:image.c       **** 
 178              		.loc 1 97 0
 179 0062 2022     		movs	r2, #32
  92:image.c       **** 	state.lastTag = -1;
 180              		.loc 1 92 0
 181 0064 F360     		str	r3, [r6, #12]
  93:image.c       **** 
 182              		.loc 1 93 0
 183 0066 4FF0FF33 		mov	r3, #-1
  97:image.c       **** 
 184              		.loc 1 97 0
 185 006a 0DEB0200 		add	r0, sp, r2
 186 006e FF21     		movs	r1, #255
  93:image.c       **** 
 187              		.loc 1 93 0
 188 0070 3361     		str	r3, [r6, #16]
  97:image.c       **** 
 189              		.loc 1 97 0
 190 0072 FFF7FEFF 		bl	memset
 191              	.LVL17:
 100:image.c       **** 
 192              		.loc 1 100 0
 193 0076 20A8     		add	r0, sp, #128
 194 0078 FFF7FEFF 		bl	sha256_starts
 195              	.LVL18:
 106:image.c       **** 
 196              		.loc 1 106 0
 197 007c 0198     		ldr	r0, [sp, #4]
 198 007e 1021     		movs	r1, #16
 199 0080 8430     		adds	r0, r0, #132
 200 0082 FFF7FEFF 		bl	hexdump
 201              	.LVL19:
 108:image.c       ****     debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
 202              		.loc 1 108 0
 203 0086 3C9D     		ldr	r5, [sp, #240]
 109:image.c       ****     while (i < finish)
 204              		.loc 1 109 0
 205 0088 0199     		ldr	r1, [sp, #4]
 206 008a 019A     		ldr	r2, [sp, #4]
 108:image.c       ****     debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
 207              		.loc 1 108 0
 208 008c 8435     		adds	r5, r5, #132
 209              	.LVL20:
 109:image.c       ****     while (i < finish)
 210              		.loc 1 109 0
 211 008e 2A44     		add	r2, r2, r5
 212 0090 8431     		adds	r1, r1, #132
 213 0092 3048     		ldr	r0, .L21+20
 214 0094 FFF7FEFF 		bl	uart_printf
 215              	.LVL21:
 105:image.c       ****     hexdump((flashAddress+i), 0x10);
 216              		.loc 1 105 0
 217 0098 8424     		movs	r4, #132
 218              	.LVL22:
 219              	.L11:
 110:image.c       ****     {
 220              		.loc 1 110 0
 221 009a AC42     		cmp	r4, r5
 222 009c 15DB     		blt	.L12
 117:image.c       ****     hexdump((vu32 *)(flashAddress+i), 0x10);
 223              		.loc 1 117 0 discriminator 1
 224 009e 0199     		ldr	r1, [sp, #4]
 225 00a0 2D48     		ldr	r0, .L21+24
 226 00a2 2144     		add	r1, r1, r4
 227 00a4 FFF7FEFF 		bl	uart_printf
 228              	.LVL23:
 118:image.c       ****     if ((flashAddress+i) != (flashAddress+finish))
 229              		.loc 1 118 0 discriminator 1
 230 00a8 0198     		ldr	r0, [sp, #4]
 231 00aa 1021     		movs	r1, #16
 232 00ac 2044     		add	r0, r0, r4
 233 00ae FFF7FEFF 		bl	hexdump
 234              	.LVL24:
 119:image.c       ****     {
 235              		.loc 1 119 0 discriminator 1
 236 00b2 019A     		ldr	r2, [sp, #4]
 237 00b4 019B     		ldr	r3, [sp, #4]
 238 00b6 1444     		add	r4, r4, r2
 239              	.LVL25:
 240 00b8 1D44     		add	r5, r5, r3
 241              	.LVL26:
 242 00ba AC42     		cmp	r4, r5
 243 00bc 0ED0     		beq	.L13
 121:image.c       ****     	state.flags = kImageImageHashCalcFailed;
 244              		.loc 1 121 0 discriminator 1
 245 00be 2748     		ldr	r0, .L21+28
 246 00c0 FFF7FEFF 		bl	uart_printf
 247              	.LVL27:
 123:image.c       **** 		return(kImageImageHashCalcFailed);
 248              		.loc 1 123 0 discriminator 1
 249 00c4 3E60     		str	r6, [r7]
 124:image.c       ****     }
 250              		.loc 1 124 0 discriminator 1
 251 00c6 0520     		movs	r0, #5
 252 00c8 BBE7     		b	.L4
 253              	.LVL28:
 254              	.L12:
 113:image.c       **** 		sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
 255              		.loc 1 113 0
 256 00ca 019B     		ldr	r3, [sp, #4]
 114:image.c       **** 		i += 0x1;
 257              		.loc 1 114 0
 258 00cc 0199     		ldr	r1, [sp, #4]
 259 00ce 0122     		movs	r2, #1
 260 00d0 2144     		add	r1, r1, r4
 261 00d2 20A8     		add	r0, sp, #128
 262 00d4 FFF7FEFF 		bl	sha256_update
 263              	.LVL29:
 115:image.c       ****     }
 264              		.loc 1 115 0
 265 00d8 0134     		adds	r4, r4, #1
 266              	.LVL30:
 267 00da DEE7     		b	.L11
 268              	.LVL31:
 269              	.L13:
 157:image.c       ****     // verify signature against recalc hash
 270              		.loc 1 157 0
 271 00dc 08A9     		add	r1, sp, #32
 272 00de 20A8     		add	r0, sp, #128
 273 00e0 FFF7FEFF 		bl	sha256_finish
 274              	.LVL32:
 159:image.c       ****     hexdump(hdr->signing.imageSignature, 0x40);
 275              		.loc 1 159 0
 276 00e4 1E48     		ldr	r0, .L21+32
 277 00e6 FFF7FEFF 		bl	uart_printf
 278              	.LVL33:
 160:image.c       **** 	debug_print("sha256sum:\n");
 279              		.loc 1 160 0
 280 00ea 4021     		movs	r1, #64
 281 00ec 3FA8     		add	r0, sp, #252
 282 00ee FFF7FEFF 		bl	hexdump
 283              	.LVL34:
 161:image.c       **** 	print_hash(sha256sum);
 284              		.loc 1 161 0
 285 00f2 1C48     		ldr	r0, .L21+36
 286 00f4 FFF7FEFF 		bl	uart_printf
 287              	.LVL35:
 165:image.c       **** 
 288              		.loc 1 165 0
 289 00f8 10AD     		add	r5, sp, #64
 162:image.c       **** 
 290              		.loc 1 162 0
 291 00fa 08A8     		add	r0, sp, #32
 165:image.c       **** 
 292              		.loc 1 165 0
 293 00fc 3FAC     		add	r4, sp, #252
 162:image.c       **** 
 294              		.loc 1 162 0
 295 00fe FFF7FEFF 		bl	print_hash
 296              	.LVL36:
 165:image.c       **** 
 297              		.loc 1 165 0
 298 0102 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 299 0104 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 300 0106 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 301 0108 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 302 010a 0FCC     		ldmia	r4!, {r0, r1, r2, r3}
 303 010c 0FC5     		stmia	r5!, {r0, r1, r2, r3}
 304 010e 94E80F00 		ldm	r4, {r0, r1, r2, r3}
 305 0112 85E80F00 		stm	r5, {r0, r1, r2, r3}
 167:image.c       ****     	state.flags = kImageImageRejectSignature;
 306              		.loc 1 167 0
 307 0116 2023     		movs	r3, #32
 308 0118 1349     		ldr	r1, .L21+40
 309 011a 0DEB0302 		add	r2, sp, r3
 310 011e 10A8     		add	r0, sp, #64
 311 0120 FFF7FEFF 		bl	edsign_verify
 312              	.LVL37:
 313 0124 48B9     		cbnz	r0, .L14
 168:image.c       ****     	if (shouldEraseFlashOnFail)
 314              		.loc 1 168 0
 315 0126 0223     		movs	r3, #2
 316 0128 7360     		str	r3, [r6, #4]
 169:image.c       **** 		{
 317              		.loc 1 169 0
 318 012a B8F1000F 		cmp	r8, #0
 319 012e 01D0     		beq	.L15
 171:image.c       **** 		}
 320              		.loc 1 171 0
 321 0130 FFF7FEFF 		bl	failErase
 322              	.LVL38:
 323              	.L15:
 173:image.c       ****     	return kImageImageRejectSignature;
 324              		.loc 1 173 0
 325 0134 3E60     		str	r6, [r7]
 174:image.c       ****     } else {
 326              		.loc 1 174 0
 327 0136 0220     		movs	r0, #2
 328 0138 83E7     		b	.L4
 329              	.L14:
 177:image.c       ****     	return kImageImageIsTrusted;
 330              		.loc 1 177 0
 331 013a 3E60     		str	r6, [r7]
 178:image.c       ****     }
 332              		.loc 1 178 0
 333 013c 0320     		movs	r0, #3
 334 013e 80E7     		b	.L4
 335              	.L22:
 336              		.align	2
 337              	.L21:
 338 0140 32636245 		.word	1164075826
 339 0144 00000000 		.word	.LC0
 340 0148 534F4445 		.word	1162104659
 341 014c 23000000 		.word	.LC1
 342 0150 44000000 		.word	.LC2
 343 0154 54000000 		.word	.LC3
 344 0158 6A000000 		.word	.LC4
 345 015c 78000000 		.word	.LC5
 346 0160 9E000000 		.word	.LC6
 347 0164 AA000000 		.word	.LC7
 348 0168 00000000 		.word	.LANCHOR0
 349              		.cfi_endproc
 350              	.LFE5:
 352              		.global	rootCA
 353              		.comm	wTransferSize,4,4
 354              		.section	.data.rootCA,"aw",%progbits
 355              		.set	.LANCHOR0,. + 0
 358              	rootCA:
 359 0000 0F       		.byte	15
 360 0001 72       		.byte	114
 361 0002 EB       		.byte	-21
 362 0003 D1       		.byte	-47
 363 0004 64       		.byte	100
 364 0005 3E       		.byte	62
 365 0006 AB       		.byte	-85
 366 0007 54       		.byte	84
 367 0008 C8       		.byte	-56
 368 0009 CF       		.byte	-49
 369 000a 60       		.byte	96
 370 000b E6       		.byte	-26
 371 000c 6F       		.byte	111
 372 000d C3       		.byte	-61
 373 000e 9D       		.byte	-99
 374 000f 64       		.byte	100
 375 0010 A4       		.byte	-92
 376 0011 CF       		.byte	-49
 377 0012 43       		.byte	67
 378 0013 77       		.byte	119
 379 0014 46       		.byte	70
 380 0015 7B       		.byte	123
 381 0016 09       		.byte	9
 382 0017 52       		.byte	82
 383 0018 19       		.byte	25
 384 0019 C7       		.byte	-57
 385 001a 06       		.byte	6
 386 001b 6C       		.byte	108
 387 001c 72       		.byte	114
 388 001d 1D       		.byte	29
 389 001e 3C       		.byte	60
 390 001f 86       		.byte	-122
 391              		.section	.rodata.imageCheckFromAddress.str1.1,"aMS",%progbits,1
 392              	.LC0:
 393 0000 62616420 		.ascii	"bad magic 0x%08x expecting 0x%08x\012\000"
 393      6D616769 
 393      63203078 
 393      25303878 
 393      20657870 
 394              	.LC1:
 395 0023 62616420 		.ascii	"bad magic 0x%08x expecting 0x%X\012\000"
 395      6D616769 
 395      63203078 
 395      25303878 
 395      20657870 
 396              	.LC2:
 397 0044 64617461 		.ascii	"dataSize: 0x%X\012\000"
 397      53697A65 
 397      3A203078 
 397      25580A00 
 398              	.LC3:
 399 0054 53746172 		.ascii	"Start: %X\012Finish: %X\012\000"
 399      743A2025 
 399      580A4669 
 399      6E697368 
 399      3A202558 
 400              	.LC4:
 401 006a 456E6465 		.ascii	"Ended at: %X\012\000"
 401      64206174 
 401      3A202558 
 401      0A00
 402              	.LC5:
 403 0078 43616C63 		.ascii	"Calculated hash is probably wrong...\012\000"
 403      756C6174 
 403      65642068 
 403      61736820 
 403      69732070 
 404              	.LC6:
 405 009e 5369676E 		.ascii	"Signature:\012\000"
 405      61747572 
 405      653A0A00 
 406              	.LC7:
 407 00aa 73686132 		.ascii	"sha256sum:\012\000"
 407      35367375 
 407      6D3A0A00 
 408              		.text
 409              	.Letext0:
 410              		.file 2 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/machine/_d
 411              		.file 3 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/incl
 412              		.file 4 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/lock.h
 413              		.file 5 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types
 414              		.file 6 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/reent.
 415              		.file 7 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_stdin
 416              		.file 8 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/unistd
 417              		.file 9 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/errno.
 418              		.file 10 "./stm32_lib/stm32f10x_type.h"
 419              		.file 11 "./usb_lib/usb_regs.h"
 420              		.file 12 "./usb_lib/usb_core.h"
 421              		.file 13 "./usb_lib/usb_init.h"
 422              		.file 14 "usb_descriptor.h"
 423              		.file 15 "usb.h"
 424              		.file 16 "hardware.h"
 425              		.file 17 "./25519/sha256.h"
 426              		.file 18 "image.h"
 427              		.file 19 "<built-in>"
 428              		.file 20 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/string.h"
 429              		.file 21 "./25519/edsign.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 image.c
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc7ZiS7x.s:16     .text.failErase:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc7ZiS7x.s:23     .text.failErase:0000000000000000 failErase
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc7ZiS7x.s:66     .text.failErase:000000000000002c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc7ZiS7x.s:76     .text.imageCheckFromAddress:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc7ZiS7x.s:83     .text.imageCheckFromAddress:0000000000000000 imageCheckFromAddress
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc7ZiS7x.s:338    .text.imageCheckFromAddress:0000000000000140 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//cc7ZiS7x.s:358    .data.rootCA:0000000000000000 rootCA
                            *COM*:0000000000000004 wTransferSize

UNDEFINED SYMBOLS
flashErasePage
memcpy
memset
uart_printf
sha256_starts
hexdump
sha256_update
sha256_finish
print_hash
edsign_verify
