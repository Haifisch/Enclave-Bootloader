   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"image.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.failErase,"ax",%progbits
  19              		.align	1
  20              		.global	failErase
  21              		.thumb
  22              		.thumb_func
  24              	failErase:
  25              	.LFB1:
  26              		.file 1 "image.c"
   1:image.c       **** /*
   2:image.c       ****  * Copyright (C) 2016-2017 Sun Tzu Security, LLC. All rights reserved.
   3:image.c       ****  *
   4:image.c       ****  * This document is the property of Sun Tzu Security, LLC.
   5:image.c       ****  * It is considered confidential and proprietary.
   6:image.c       ****  *
   7:image.c       ****  * This document may not be reproduced or transmitted in any form,
   8:image.c       ****  * in whole or in part, without the express written permission of
   9:image.c       ****  * Sun Tzu Security, LLC.
  10:image.c       ****  */
  11:image.c       **** #include <stdio.h>
  12:image.c       **** #include <stdint.h>
  13:image.c       **** #include <string.h>
  14:image.c       **** #include <limits.h>
  15:image.c       **** #include <unistd.h>
  16:image.c       **** #include <errno.h>
  17:image.c       **** #include <stdarg.h>
  18:image.c       **** 
  19:image.c       **** #include "hardware.h"
  20:image.c       **** #include "sha256.h"
  21:image.c       **** #include "edsign.h"
  22:image.c       **** #include "image.h"
  23:image.c       **** 
  24:image.c       **** uint8_t rootCA[32] = {
  25:image.c       ****       0x0f, 0x72, 0xeb, 0xd1, 0x64, 0x3e, 0xab, 0x54, 0xc8, 0xcf, 0x60, 0xe6, 0x6f, 0xc3, 0x9d, 0x6
  26:image.c       ****     };
  27:image.c       **** 
  28:image.c       **** static void print_hex(const char *label, const uint8_t *data, int len)
  29:image.c       **** {
  30:image.c       ****     int i;
  31:image.c       **** 
  32:image.c       ****     uart_printf("%s: ", label);
  33:image.c       ****     for (i = 0; i < len; i++)
  34:image.c       ****         uart_printf("%02x", data[i]);
  35:image.c       ****     uart_printf("\n");
  36:image.c       **** }
  37:image.c       **** 
  38:image.c       **** void failErase () {
  27              		.loc 1 38 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 08B5     		push	{r3, lr}
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
  39:image.c       **** 	// for whatever reason this only flashes upto 0x08008800
  40:image.c       **** 	flashErasePage((u32)(0x08008000));
  35              		.loc 1 40 0
  36 0002 0A48     		ldr	r0, .L2
  37 0004 FFF7FEFF 		bl	flashErasePage
  38              	.LVL0:
  41:image.c       **** 	flashErasePage((u32)(0x08008000+1024));
  39              		.loc 1 41 0
  40 0008 0948     		ldr	r0, .L2+4
  41 000a FFF7FEFF 		bl	flashErasePage
  42              	.LVL1:
  42:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*2)));
  43              		.loc 1 42 0
  44 000e 0948     		ldr	r0, .L2+8
  45 0010 FFF7FEFF 		bl	flashErasePage
  46              	.LVL2:
  43:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*3)));
  47              		.loc 1 43 0
  48 0014 0848     		ldr	r0, .L2+12
  49 0016 FFF7FEFF 		bl	flashErasePage
  50              	.LVL3:
  44:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*4)));
  51              		.loc 1 44 0
  52 001a 0848     		ldr	r0, .L2+16
  53 001c FFF7FEFF 		bl	flashErasePage
  54              	.LVL4:
  45:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
  46:image.c       **** }
  55              		.loc 1 46 0
  56 0020 BDE80840 		pop	{r3, lr}
  45:image.c       **** 	flashErasePage((u32)(0x08008000+(u32)(0x190*5)));
  57              		.loc 1 45 0
  58 0024 0648     		ldr	r0, .L2+20
  59 0026 FFF7FEBF 		b	flashErasePage
  60              	.LVL5:
  61              	.L3:
  62 002a 00BF     		.align	2
  63              	.L2:
  64 002c 00800008 		.word	134250496
  65 0030 00840008 		.word	134251520
  66 0034 20830008 		.word	134251296
  67 0038 B0840008 		.word	134251696
  68 003c 40860008 		.word	134252096
  69 0040 D0870008 		.word	134252496
  70              		.cfi_endproc
  71              	.LFE1:
  73              		.section	.text.imageCheckFromAddress,"ax",%progbits
  74              		.align	1
  75              		.global	imageCheckFromAddress
  76              		.thumb
  77              		.thumb_func
  79              	imageCheckFromAddress:
  80              	.LFB2:
  47:image.c       **** 
  48:image.c       **** int imageCheckFromAddress(ImageObjectHandle *newHandle, vu32 flashAddress, bool shouldEraseFlashOnF
  49:image.c       **** {
  81              		.loc 1 49 0
  82              		.cfi_startproc
  83              		@ args = 0, pretend = 0, frame = 472
  84              		@ frame_needed = 0, uses_anonymous_args = 0
  85              	.LVL6:
  86 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
  87              		.cfi_def_cfa_offset 24
  88              		.cfi_offset 4, -24
  89              		.cfi_offset 5, -20
  90              		.cfi_offset 6, -16
  91              		.cfi_offset 7, -12
  92              		.cfi_offset 8, -8
  93              		.cfi_offset 14, -4
  94 0004 F8B0     		sub	sp, sp, #480
  95              		.cfi_def_cfa_offset 504
  96              	.LVL7:
  97              		.loc 1 49 0
  98 0006 0391     		str	r1, [sp, #12]
  99 0008 0746     		mov	r7, r0
  50:image.c       **** 	ImageRootHeader		*hdr;
  51:image.c       **** 	ImageInternalState		state;
  52:image.c       **** 	int bufferSize = 0x28+0x40;
  53:image.c       **** 	unsigned char imageBuffer[bufferSize];
  54:image.c       ****     memset(imageBuffer, 0xFF, sizeof(imageBuffer));
 100              		.loc 1 54 0
 101 000a FF21     		movs	r1, #255
 102              	.LVL8:
  49:image.c       **** {
 103              		.loc 1 49 0
 104 000c 9046     		mov	r8, r2
 105              		.loc 1 54 0
 106 000e 5EA8     		add	r0, sp, #376
 107              	.LVL9:
 108 0010 6822     		movs	r2, #104
 109              	.LVL10:
 110 0012 FFF7FEFF 		bl	memset
 111              	.LVL11:
  55:image.c       ****     memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
  56:image.c       ****     memset(&state, 0, sizeof(state));
 112              		.loc 1 56 0
 113 0016 07AE     		add	r6, sp, #28
  55:image.c       ****     memcpy(imageBuffer, (vu32 *)flashAddress, bufferSize);
 114              		.loc 1 55 0
 115 0018 0399     		ldr	r1, [sp, #12]
 116 001a 6822     		movs	r2, #104
 117 001c 5EA8     		add	r0, sp, #376
 118              	.LVL12:
 119 001e FFF7FEFF 		bl	memcpy
 120              	.LVL13:
 121              		.loc 1 56 0
 122 0022 0021     		movs	r1, #0
 123 0024 1422     		movs	r2, #20
 124 0026 3046     		mov	r0, r6
 125 0028 FFF7FEFF 		bl	memset
 126              	.LVL14:
  57:image.c       **** 
  58:image.c       **** 	hdr = (ImageRootHeader *)imageBuffer;
  59:image.c       **** 	if (bufferSize < sizeof(hdr)) {
  60:image.c       **** 		debug_print("buffer size %X too small for header size %X\n", bufferSize, sizeof(*hdr));
  61:image.c       **** 		if (shouldEraseFlashOnFail)
  62:image.c       **** 		{
  63:image.c       **** 			failErase();
  64:image.c       **** 		}
  65:image.c       **** 		return(EINVAL);		/* buffer too small to really contain header */
  66:image.c       **** 	}
  67:image.c       **** 	if ((hdr->header.magic) != kImageHeaderMagic) {
 127              		.loc 1 67 0
 128 002c 5E99     		ldr	r1, [sp, #376]
 129 002e 5E4A     		ldr	r2, .L29
 130 0030 9142     		cmp	r1, r2
 131 0032 01D0     		beq	.L5
  68:image.c       **** 		debug_print("bad magic 0x%08x expecting 0x%08x\n", (hdr->header.magic), kImageHeaderMagic);
 132              		.loc 1 68 0 discriminator 1
 133 0034 5D48     		ldr	r0, .L29+4
 134 0036 04E0     		b	.L26
 135              	.L5:
  69:image.c       **** 		state.flags = kImageImageMissingMagic;
  70:image.c       **** 		if (shouldEraseFlashOnFail)
  71:image.c       **** 		{
  72:image.c       **** 			failErase();
  73:image.c       **** 		}
  74:image.c       **** 		*newHandle = &state;
  75:image.c       **** 		return(kImageImageMissingMagic);		/* magic must match */
  76:image.c       **** 	}
  77:image.c       **** 	if ((hdr->signing.imageType) != 0x45444f53)
 136              		.loc 1 77 0
 137 0038 6299     		ldr	r1, [sp, #392]
 138 003a 5D4A     		ldr	r2, .L29+8
 139 003c 9142     		cmp	r1, r2
 140 003e 0CD0     		beq	.L8
  78:image.c       **** 	{
  79:image.c       **** 		debug_print("bad magic 0x%08x expecting 0x%X\n", (hdr->signing.imageType), 0x45444f53);
 141              		.loc 1 79 0 discriminator 1
 142 0040 5C48     		ldr	r0, .L29+12
 143              	.L26:
 144 0042 FFF7FEFF 		bl	uart_printf
 145              	.LVL15:
  80:image.c       **** 		state.flags = kImageImageMissingMagic;
 146              		.loc 1 80 0 discriminator 1
 147 0046 0423     		movs	r3, #4
 148 0048 7360     		str	r3, [r6, #4]
  81:image.c       **** 		if (shouldEraseFlashOnFail)
 149              		.loc 1 81 0 discriminator 1
 150 004a B8F1000F 		cmp	r8, #0
 151 004e 01D0     		beq	.L9
  82:image.c       **** 		{
  83:image.c       **** 			failErase();
 152              		.loc 1 83 0
 153 0050 FFF7FEFF 		bl	failErase
 154              	.LVL16:
 155              	.L9:
  84:image.c       **** 		}
  85:image.c       **** 		*newHandle = &state;
 156              		.loc 1 85 0
 157 0054 3E60     		str	r6, [r7]
  86:image.c       **** 		return(kImageImageMissingMagic);		/* magic must match */
 158              		.loc 1 86 0
 159 0056 0420     		movs	r0, #4
 160 0058 A2E0     		b	.L7
 161              	.L8:
  87:image.c       **** 	}
  88:image.c       **** 	state.flags = kImageImageWasInstantiated;
 162              		.loc 1 88 0
 163 005a 0123     		movs	r3, #1
 164 005c 7360     		str	r3, [r6, #4]
  89:image.c       **** 
  90:image.c       **** 	debug_print("dataSize: 0x%X\n", (hdr->header.dataSize));
 165              		.loc 1 90 0
 166 005e 5648     		ldr	r0, .L29+16
 167 0060 6099     		ldr	r1, [sp, #384]
 168 0062 FFF7FEFF 		bl	uart_printf
 169              	.LVL17:
  91:image.c       **** 
  92:image.c       **** 	state.cursor = hdr->header.dataSize;
 170              		.loc 1 92 0
 171 0066 609B     		ldr	r3, [sp, #384]
  93:image.c       **** 	state.lastTag = -1;
  94:image.c       **** 
  95:image.c       **** 	unsigned char sha256sum[32];
  96:image.c       **** 
  97:image.c       ****     memset(sha256sum, 0xFF, sizeof(sha256sum));
 172              		.loc 1 97 0
 173 0068 2022     		movs	r2, #32
 174 006a FF21     		movs	r1, #255
  92:image.c       **** 	state.cursor = hdr->header.dataSize;
 175              		.loc 1 92 0
 176 006c F360     		str	r3, [r6, #12]
 177              		.loc 1 97 0
 178 006e 12A8     		add	r0, sp, #72
  93:image.c       **** 	state.lastTag = -1;
 179              		.loc 1 93 0
 180 0070 4FF0FF33 		mov	r3, #-1
 181 0074 3361     		str	r3, [r6, #16]
 182              		.loc 1 97 0
 183 0076 FFF7FEFF 		bl	memset
 184              	.LVL18:
  98:image.c       **** 
  99:image.c       ****     sha256_context ctx;
 100:image.c       ****     sha256_starts(&ctx);
 185              		.loc 1 100 0
 186 007a 2AA8     		add	r0, sp, #168
 187 007c FFF7FEFF 		bl	sha256_starts
 188              	.LVL19:
 101:image.c       **** 
 102:image.c       ****     int buffSize = 0x1;
 103:image.c       ****     char buff[buffSize];
 104:image.c       **** 
 105:image.c       ****     int i = 0x84;
 106:image.c       ****     hexdump((flashAddress+i), 0x10);
 189              		.loc 1 106 0
 190 0080 0398     		ldr	r0, [sp, #12]
 191 0082 1021     		movs	r1, #16
 192 0084 8430     		adds	r0, r0, #132
 193 0086 FFF7FEFF 		bl	hexdump
 194              	.LVL20:
 107:image.c       **** 
 108:image.c       ****     int finish = hdr->header.dataSize + 0x84;
 195              		.loc 1 108 0
 196 008a 609D     		ldr	r5, [sp, #384]
 109:image.c       ****     debug_print("Start: %X\nFinish: %X\n", (flashAddress+i), (flashAddress+ finish));
 197              		.loc 1 109 0
 198 008c 0399     		ldr	r1, [sp, #12]
 199 008e 039A     		ldr	r2, [sp, #12]
 108:image.c       ****     int finish = hdr->header.dataSize + 0x84;
 200              		.loc 1 108 0
 201 0090 8435     		adds	r5, r5, #132
 202              	.LVL21:
 203              		.loc 1 109 0
 204 0092 4A48     		ldr	r0, .L29+20
 205 0094 8431     		adds	r1, r1, #132
 206 0096 2A44     		add	r2, r2, r5
 207 0098 FFF7FEFF 		bl	uart_printf
 208              	.LVL22:
 105:image.c       ****     int i = 0x84;
 209              		.loc 1 105 0
 210 009c 8424     		movs	r4, #132
 211              	.LVL23:
 212              	.L10:
 110:image.c       ****     while (i < finish)
 213              		.loc 1 110 0 discriminator 1
 214 009e AC42     		cmp	r4, r5
 215 00a0 08DA     		bge	.L28
 111:image.c       ****     {
 112:image.c       ****     	memset(buff, 0xFF, buffSize);
 113:image.c       ****     	memcpy(buff, (unsigned char *)(flashAddress+i), buffSize);
 216              		.loc 1 113 0
 217 00a2 039B     		ldr	r3, [sp, #12]
 114:image.c       **** 		sha256_update(&ctx, (vu32 *)(flashAddress+i), buffSize);
 218              		.loc 1 114 0
 219 00a4 0399     		ldr	r1, [sp, #12]
 220 00a6 2AA8     		add	r0, sp, #168
 221 00a8 2144     		add	r1, r1, r4
 222 00aa 0122     		movs	r2, #1
 223 00ac FFF7FEFF 		bl	sha256_update
 224              	.LVL24:
 115:image.c       **** 		i += 0x1;
 225              		.loc 1 115 0
 226 00b0 0134     		adds	r4, r4, #1
 227              	.LVL25:
 228 00b2 F4E7     		b	.L10
 229              	.L28:
 116:image.c       ****     }
 117:image.c       ****     debug_print("Ended at: %X\n", (flashAddress+i));
 230              		.loc 1 117 0 discriminator 1
 231 00b4 0399     		ldr	r1, [sp, #12]
 232 00b6 4248     		ldr	r0, .L29+24
 233 00b8 2144     		add	r1, r1, r4
 234 00ba FFF7FEFF 		bl	uart_printf
 235              	.LVL26:
 118:image.c       ****     hexdump((vu32 *)(flashAddress+i), 0x10);
 236              		.loc 1 118 0 discriminator 1
 237 00be 0398     		ldr	r0, [sp, #12]
 238 00c0 1021     		movs	r1, #16
 239 00c2 2044     		add	r0, r0, r4
 240 00c4 FFF7FEFF 		bl	hexdump
 241              	.LVL27:
 119:image.c       ****     if ((flashAddress+i) != (flashAddress+finish))
 242              		.loc 1 119 0 discriminator 1
 243 00c8 039A     		ldr	r2, [sp, #12]
 244 00ca 039B     		ldr	r3, [sp, #12]
 245 00cc 1444     		add	r4, r4, r2
 246              	.LVL28:
 247 00ce 1D44     		add	r5, r5, r3
 248              	.LVL29:
 249 00d0 AC42     		cmp	r4, r5
 250 00d2 05D0     		beq	.L12
 120:image.c       ****     {
 121:image.c       ****     	debug_print("Calculated hash is probably wrong...\n");
 251              		.loc 1 121 0 discriminator 1
 252 00d4 3B48     		ldr	r0, .L29+28
 253 00d6 FFF7FEFF 		bl	uart_printf
 254              	.LVL30:
 122:image.c       ****     	state.flags = kImageImageHashCalcFailed;
 123:image.c       ****     	*newHandle = &state;
 255              		.loc 1 123 0 discriminator 1
 256 00da 3E60     		str	r6, [r7]
 124:image.c       **** 		return(kImageImageHashCalcFailed);
 257              		.loc 1 124 0 discriminator 1
 258 00dc 0520     		movs	r0, #5
 259 00de 5FE0     		b	.L7
 260              	.L12:
 261              	.LBB2:
 125:image.c       ****     }
 126:image.c       **** 
 127:image.c       ****     if (!QEMU_BUILD)
 128:image.c       ****     {
 129:image.c       ****     	struct u_id id;
 130:image.c       **** 		unsigned char uniqueID[0x17];
 131:image.c       **** 		unsigned char temp_sha256sum[32];  
 132:image.c       **** 		uint8_t publickey[EDSIGN_PUBLIC_KEY_SIZE];
 133:image.c       **** 		// read our unique id
 134:image.c       **** 		uid_read(&id);
 262              		.loc 1 134 0
 263 00e0 04A8     		add	r0, sp, #16
 264 00e2 FFF7FEFF 		bl	uid_read
 265              	.LVL31:
 135:image.c       **** 		sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
 266              		.loc 1 135 0
 267 00e6 0599     		ldr	r1, [sp, #20]
 268 00e8 BDF81230 		ldrh	r3, [sp, #18]
 269 00ec 0091     		str	r1, [sp]
 270 00ee 0699     		ldr	r1, [sp, #24]
 271 00f0 BDF81020 		ldrh	r2, [sp, #16]
 272 00f4 0191     		str	r1, [sp, #4]
 273 00f6 0CA8     		add	r0, sp, #48
 274 00f8 3349     		ldr	r1, .L29+32
 275 00fa FFF7FEFF 		bl	sprintf
 276              	.LVL32:
 136:image.c       **** 		// start sha256 context
 137:image.c       **** 		sha256_context ctx2;
 138:image.c       **** 		sha256_starts(&ctx2);
 277              		.loc 1 138 0
 278 00fe 44A8     		add	r0, sp, #272
 279 0100 FFF7FEFF 		bl	sha256_starts
 280              	.LVL33:
 139:image.c       **** 		// hash in our unique id
 140:image.c       **** 		sha256_update(&ctx2, uniqueID, 0x17);
 281              		.loc 1 140 0
 282 0104 1722     		movs	r2, #23
 283 0106 44A8     		add	r0, sp, #272
 284 0108 0CA9     		add	r1, sp, #48
 285 010a FFF7FEFF 		bl	sha256_update
 286              	.LVL34:
 141:image.c       **** 		sha256_finish(&ctx2, temp_sha256sum);
 287              		.loc 1 141 0
 288 010e 44A8     		add	r0, sp, #272
 289 0110 1AA9     		add	r1, sp, #104
 290 0112 FFF7FEFF 		bl	sha256_finish
 291              	.LVL35:
 142:image.c       **** 		// get our public key
 143:image.c       **** 		memset(publickey, 0, EDSIGN_PUBLIC_KEY_SIZE);
 292              		.loc 1 143 0
 293 0116 2022     		movs	r2, #32
 294 0118 0021     		movs	r1, #0
 295 011a 22A8     		add	r0, sp, #136
 296 011c FFF7FEFF 		bl	memset
 297              	.LVL36:
 144:image.c       **** 		edsign_sec_to_pub(publickey, temp_sha256sum);
 298              		.loc 1 144 0
 299 0120 1AA9     		add	r1, sp, #104
 300 0122 22A8     		add	r0, sp, #136
 301 0124 FFF7FEFF 		bl	edsign_sec_to_pub
 302              	.LVL37:
 145:image.c       **** 		debug_print("publickey:\n");
 303              		.loc 1 145 0
 304 0128 2848     		ldr	r0, .L29+36
 305 012a FFF7FEFF 		bl	uart_printf
 306              	.LVL38:
 146:image.c       **** 		hexdump(publickey, 32);
 307              		.loc 1 146 0
 308 012e 22A8     		add	r0, sp, #136
 309 0130 2021     		movs	r1, #32
 310 0132 FFF7FEFF 		bl	hexdump
 311              	.LVL39:
 147:image.c       ****     	/*
 148:image.c       ****     	struct u_id id;
 149:image.c       **** 	    uid_read(&id);
 150:image.c       **** 	    sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
 151:image.c       **** 	    */
 152:image.c       **** 	    sha256_update(&ctx, (unsigned char*)publickey, 32);
 312              		.loc 1 152 0
 313 0136 2022     		movs	r2, #32
 314 0138 2AA8     		add	r0, sp, #168
 315 013a 22A9     		add	r1, sp, #136
 316 013c FFF7FEFF 		bl	sha256_update
 317              	.LVL40:
 318              	.LBE2:
 153:image.c       ****     }
 154:image.c       **** 
 155:image.c       ****     //debug_print("%s\n", uniqueID);
 156:image.c       ****     
 157:image.c       ****     sha256_finish(&ctx, sha256sum);
 319              		.loc 1 157 0
 320 0140 12A9     		add	r1, sp, #72
 321 0142 2AA8     		add	r0, sp, #168
 322 0144 FFF7FEFF 		bl	sha256_finish
 323              	.LVL41:
 158:image.c       ****     // verify signature against recalc hash
 159:image.c       ****     debug_print("Signature:\n");
 324              		.loc 1 159 0
 325 0148 2148     		ldr	r0, .L29+40
 326 014a FFF7FEFF 		bl	uart_printf
 327              	.LVL42:
 160:image.c       ****     hexdump(hdr->signing.imageSignature, 0x40);
 328              		.loc 1 160 0
 329 014e 4021     		movs	r1, #64
 330 0150 63A8     		add	r0, sp, #396
 331 0152 FFF7FEFF 		bl	hexdump
 332              	.LVL43:
 161:image.c       **** 	debug_print("sha256sum:\n");
 333              		.loc 1 161 0
 334 0156 1F48     		ldr	r0, .L29+44
 335 0158 FFF7FEFF 		bl	uart_printf
 336              	.LVL44:
 162:image.c       **** 	print_hash(sha256sum);
 163:image.c       **** 
 164:image.c       **** 	char sigbuff[64];
 165:image.c       **** 	memcpy(sigbuff, hdr->signing.imageSignature, 64);
 337              		.loc 1 165 0
 338 015c 44AC     		add	r4, sp, #272
 162:image.c       **** 	print_hash(sha256sum);
 339              		.loc 1 162 0
 340 015e 12A8     		add	r0, sp, #72
 341              		.loc 1 165 0
 342 0160 63AD     		add	r5, sp, #396
 162:image.c       **** 	print_hash(sha256sum);
 343              		.loc 1 162 0
 344 0162 FFF7FEFF 		bl	print_hash
 345              	.LVL45:
 346              		.loc 1 165 0
 347 0166 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 348 0168 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 349 016a 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 350 016c 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 351 016e 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 352 0170 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 353 0172 95E80F00 		ldmia	r5, {r0, r1, r2, r3}
 354 0176 84E80F00 		stmia	r4, {r0, r1, r2, r3}
 166:image.c       **** 
 167:image.c       ****     if (edsign_verify(sigbuff, rootCA, sha256sum, 32) <= 0) {
 355              		.loc 1 167 0
 356 017a 44A8     		add	r0, sp, #272
 357 017c 1649     		ldr	r1, .L29+48
 358 017e 12AA     		add	r2, sp, #72
 359 0180 2023     		movs	r3, #32
 360 0182 FFF7FEFF 		bl	edsign_verify
 361              	.LVL46:
 362 0186 48B9     		cbnz	r0, .L13
 168:image.c       ****     	state.flags = kImageImageRejectSignature;
 363              		.loc 1 168 0
 364 0188 0223     		movs	r3, #2
 365 018a 7360     		str	r3, [r6, #4]
 169:image.c       ****     	if (shouldEraseFlashOnFail)
 366              		.loc 1 169 0
 367 018c B8F1000F 		cmp	r8, #0
 368 0190 01D0     		beq	.L14
 170:image.c       **** 		{
 171:image.c       **** 			failErase();
 369              		.loc 1 171 0
 370 0192 FFF7FEFF 		bl	failErase
 371              	.LVL47:
 372              	.L14:
 172:image.c       **** 		}
 173:image.c       ****     	*newHandle = &state;
 373              		.loc 1 173 0
 374 0196 3E60     		str	r6, [r7]
 174:image.c       ****     	return kImageImageRejectSignature;
 375              		.loc 1 174 0
 376 0198 0220     		movs	r0, #2
 377 019a 01E0     		b	.L7
 378              	.L13:
 175:image.c       ****     } else {
 176:image.c       ****     	state.flags = kImageImageIsTrusted;
 177:image.c       ****     	*newHandle = &state;
 379              		.loc 1 177 0
 380 019c 3E60     		str	r6, [r7]
 178:image.c       ****     	return kImageImageIsTrusted;
 381              		.loc 1 178 0
 382 019e 0320     		movs	r0, #3
 383              	.LVL48:
 384              	.L7:
 179:image.c       ****     }
 180:image.c       **** 	*newHandle = &state;
 181:image.c       **** 	return(0);
 182:image.c       **** }
 385              		.loc 1 182 0
 386 01a0 78B0     		add	sp, sp, #480
 387              		@ sp needed
 388 01a2 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 389              	.LVL49:
 390              	.L30:
 391 01a6 00BF     		.align	2
 392              	.L29:
 393 01a8 32636245 		.word	1164075826
 394 01ac 00000000 		.word	.LC0
 395 01b0 534F4445 		.word	1162104659
 396 01b4 23000000 		.word	.LC1
 397 01b8 44000000 		.word	.LC2
 398 01bc 54000000 		.word	.LC3
 399 01c0 6A000000 		.word	.LC4
 400 01c4 78000000 		.word	.LC5
 401 01c8 9E000000 		.word	.LC6
 402 01cc A7000000 		.word	.LC7
 403 01d0 B3000000 		.word	.LC8
 404 01d4 BF000000 		.word	.LC9
 405 01d8 00000000 		.word	.LANCHOR0
 406              		.cfi_endproc
 407              	.LFE2:
 409              		.global	rootCA
 410              		.comm	wTransferSize,4,4
 411              		.section	.data.rootCA,"aw",%progbits
 412              		.set	.LANCHOR0,. + 0
 415              	rootCA:
 416 0000 0F       		.byte	15
 417 0001 72       		.byte	114
 418 0002 EB       		.byte	-21
 419 0003 D1       		.byte	-47
 420 0004 64       		.byte	100
 421 0005 3E       		.byte	62
 422 0006 AB       		.byte	-85
 423 0007 54       		.byte	84
 424 0008 C8       		.byte	-56
 425 0009 CF       		.byte	-49
 426 000a 60       		.byte	96
 427 000b E6       		.byte	-26
 428 000c 6F       		.byte	111
 429 000d C3       		.byte	-61
 430 000e 9D       		.byte	-99
 431 000f 64       		.byte	100
 432 0010 A4       		.byte	-92
 433 0011 CF       		.byte	-49
 434 0012 43       		.byte	67
 435 0013 77       		.byte	119
 436 0014 46       		.byte	70
 437 0015 7B       		.byte	123
 438 0016 09       		.byte	9
 439 0017 52       		.byte	82
 440 0018 19       		.byte	25
 441 0019 C7       		.byte	-57
 442 001a 06       		.byte	6
 443 001b 6C       		.byte	108
 444 001c 72       		.byte	114
 445 001d 1D       		.byte	29
 446 001e 3C       		.byte	60
 447 001f 86       		.byte	-122
 448              		.section	.rodata.str1.1,"aMS",%progbits,1
 449              	.LC0:
 450 0000 62616420 		.ascii	"bad magic 0x%08x expecting 0x%08x\012\000"
 450      6D616769 
 450      63203078 
 450      25303878 
 450      20657870 
 451              	.LC1:
 452 0023 62616420 		.ascii	"bad magic 0x%08x expecting 0x%X\012\000"
 452      6D616769 
 452      63203078 
 452      25303878 
 452      20657870 
 453              	.LC2:
 454 0044 64617461 		.ascii	"dataSize: 0x%X\012\000"
 454      53697A65 
 454      3A203078 
 454      25580A00 
 455              	.LC3:
 456 0054 53746172 		.ascii	"Start: %X\012Finish: %X\012\000"
 456      743A2025 
 456      580A4669 
 456      6E697368 
 456      3A202558 
 457              	.LC4:
 458 006a 456E6465 		.ascii	"Ended at: %X\012\000"
 458      64206174 
 458      3A202558 
 458      0A00
 459              	.LC5:
 460 0078 43616C63 		.ascii	"Calculated hash is probably wrong...\012\000"
 460      756C6174 
 460      65642068 
 460      61736820 
 460      69732070 
 461              	.LC6:
 462 009e 25582558 		.ascii	"%X%X%X%X\000"
 462      25582558 
 462      00
 463              	.LC7:
 464 00a7 7075626C 		.ascii	"publickey:\012\000"
 464      69636B65 
 464      793A0A00 
 465              	.LC8:
 466 00b3 5369676E 		.ascii	"Signature:\012\000"
 466      61747572 
 466      653A0A00 
 467              	.LC9:
 468 00bf 73686132 		.ascii	"sha256sum:\012\000"
 468      35367375 
 468      6D3A0A00 
 469              		.text
 470              	.Letext0:
 471              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 472              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\mach
 473              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdi
 474              		.file 5 "./stm32_lib/stm32f10x_type.h"
 475              		.file 6 "hardware.h"
 476              		.file 7 "./25519/sha256.h"
 477              		.file 8 "image.h"
 478              		.file 9 "usb.h"
 479              		.file 10 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\std
 480              		.file 11 "./25519/edsign.h"
 481              		.file 12 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\str
DEFINED SYMBOLS
                            *ABS*:00000000 image.c
C:\Users\haifisch\AppData\Local\Temp\ccFXqMnP.s:19     .text.failErase:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccFXqMnP.s:24     .text.failErase:00000000 failErase
C:\Users\haifisch\AppData\Local\Temp\ccFXqMnP.s:64     .text.failErase:0000002c $d
C:\Users\haifisch\AppData\Local\Temp\ccFXqMnP.s:74     .text.imageCheckFromAddress:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccFXqMnP.s:79     .text.imageCheckFromAddress:00000000 imageCheckFromAddress
C:\Users\haifisch\AppData\Local\Temp\ccFXqMnP.s:393    .text.imageCheckFromAddress:000001a8 $d
C:\Users\haifisch\AppData\Local\Temp\ccFXqMnP.s:415    .data.rootCA:00000000 rootCA
                            *COM*:00000004 wTransferSize
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
flashErasePage
memset
memcpy
uart_printf
sha256_starts
hexdump
sha256_update
uid_read
sprintf
sha256_finish
edsign_sec_to_pub
print_hash
edsign_verify
