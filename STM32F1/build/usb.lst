   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"usb.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.usbStatusIn,"ax",%progbits
  16              		.align	1
  17              		.global	usbStatusIn
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	usbStatusIn:
  24              	.LFB14:
  25              		.file 1 "usb.c"
   1:usb.c         **** /* *****************************************************************************
   2:usb.c         ****  * The MIT License
   3:usb.c         ****  *
   4:usb.c         ****  * Copyright (c) 2010 LeafLabs LLC.
   5:usb.c         ****  *
   6:usb.c         ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:usb.c         ****  * of this software and associated documentation files (the "Software"), to deal
   8:usb.c         ****  * in the Software without restriction, including without limitation the rights
   9:usb.c         ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:usb.c         ****  * copies of the Software, and to permit persons to whom the Software is
  11:usb.c         ****  * furnished to do so, subject to the following conditions:
  12:usb.c         ****  *
  13:usb.c         ****  * The above copyright notice and this permission notice shall be included in
  14:usb.c         ****  * all copies or substantial portions of the Software.
  15:usb.c         ****  *
  16:usb.c         ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:usb.c         ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:usb.c         ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:usb.c         ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:usb.c         ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:usb.c         ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:usb.c         ****  * THE SOFTWARE.
  23:usb.c         ****  * ****************************************************************************/
  24:usb.c         **** 
  25:usb.c         **** /**
  26:usb.c         ****  *  @file usb.c
  27:usb.c         ****  *
  28:usb.c         ****  *  @brief usb-specific hardware setup, NVIC, clocks, and usb activities
  29:usb.c         ****  *  in the pre-attached state. includes some of the lower level callbacks
  30:usb.c         ****  *  needed by the usb library, like suspend,resume,init,etc
  31:usb.c         ****  */
  32:usb.c         **** 
  33:usb.c         **** #include "usb.h"
  34:usb.c         **** #include "dfu.h"
  35:usb.c         **** 
  36:usb.c         **** 
  37:usb.c         **** extern u8 u8_usbConfigDescriptorDFU[];
  38:usb.c         **** extern u8 u8_usbFunctionalDescriptor[];
  39:usb.c         **** 
  40:usb.c         **** vu32 bDeviceState = UNCONNECTED;
  41:usb.c         **** 
  42:usb.c         **** /* tracks sequential behavior of the ISTR */
  43:usb.c         **** vu16 wIstr;
  44:usb.c         **** vu8 bIntPackSOF = 0;
  45:usb.c         **** 
  46:usb.c         **** DEVICE Device_Table = {
  47:usb.c         ****     NUM_ENDPTS,
  48:usb.c         ****     1
  49:usb.c         **** };
  50:usb.c         **** 
  51:usb.c         **** DEVICE_PROP Device_Property = {
  52:usb.c         ****     usbInit,
  53:usb.c         ****     usbReset,
  54:usb.c         ****     usbStatusIn,
  55:usb.c         ****     usbStatusOut,
  56:usb.c         ****     usbDataSetup,
  57:usb.c         ****     usbNoDataSetup,
  58:usb.c         ****     usbGetInterfaceSetting,
  59:usb.c         ****     usbGetDeviceDescriptor,
  60:usb.c         ****     usbGetConfigDescriptor,
  61:usb.c         ****     usbGetStringDescriptor,
  62:usb.c         ****     usbGetFunctionalDescriptor,
  63:usb.c         ****     0,
  64:usb.c         ****     bMaxPacketSize
  65:usb.c         **** };
  66:usb.c         **** 
  67:usb.c         **** USER_STANDARD_REQUESTS User_Standard_Requests = {
  68:usb.c         ****     usbGetConfiguration,
  69:usb.c         ****     usbSetConfiguration,
  70:usb.c         ****     usbGetInterface,
  71:usb.c         ****     usbSetInterface,
  72:usb.c         ****     usbGetStatus,
  73:usb.c         ****     usbClearFeature,
  74:usb.c         ****     usbSetEndpointFeature,
  75:usb.c         ****     usbSetDeviceFeature,
  76:usb.c         ****     usbSetDeviceAddress
  77:usb.c         **** };
  78:usb.c         **** 
  79:usb.c         **** void (*pEpInt_IN[7])(void) = {
  80:usb.c         ****     nothingProc,
  81:usb.c         ****     nothingProc,
  82:usb.c         ****     nothingProc,
  83:usb.c         ****     nothingProc,
  84:usb.c         ****     nothingProc,
  85:usb.c         ****     nothingProc,
  86:usb.c         ****     nothingProc,
  87:usb.c         **** };
  88:usb.c         **** 
  89:usb.c         **** void (*pEpInt_OUT[7])(void) = {
  90:usb.c         ****     nothingProc,
  91:usb.c         ****     nothingProc,
  92:usb.c         ****     nothingProc,
  93:usb.c         ****     nothingProc,
  94:usb.c         ****     nothingProc,
  95:usb.c         ****     nothingProc,
  96:usb.c         ****     nothingProc,
  97:usb.c         **** };
  98:usb.c         **** 
  99:usb.c         **** struct {
 100:usb.c         ****     volatile RESUME_STATE eState;
 101:usb.c         ****     volatile u8 bESOFcnt;
 102:usb.c         **** } ResumeS;
 103:usb.c         **** 
 104:usb.c         **** 
 105:usb.c         **** static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;
 106:usb.c         **** 
 107:usb.c         **** 
 108:usb.c         **** void setupUSB (void)
 109:usb.c         **** {
 110:usb.c         **** #ifndef USB_DISC_HARDWIRED
 111:usb.c         **** #ifdef HAS_MAPLE_HARDWARE	
 112:usb.c         ****     // set up USB DISC pin as output open drain
 113:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 114:usb.c         ****     SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 115:usb.c         ****             (GET_REG(
 116:usb.c         ****                 GPIO_CR(USB_DISC_BANK,USB_DISC_PIN)) & crMask(USB_DISC_PIN))
 117:usb.c         ****                 | CR_OUTPUT_OD << CR_SHITF(USB_DISC_PIN)
 118:usb.c         ****             );
 119:usb.c         **** #else
 120:usb.c         ****     #ifndef USB_DISC_HARDWIRED
 121:usb.c         ****     
 122:usb.c         ****     // Generic boards don't have disconnect hardware, so we drive PA12 (or defined pin) high.
 123:usb.c         ****     // this is connected to the usb D+ line. driving high will signal usb full speed to host
 124:usb.c         ****     #ifndef USB_DISC_BANK
 125:usb.c         ****     #define USB_DISC_BANK   GPIOA
 126:usb.c         ****     #endif
 127:usb.c         **** 
 128:usb.c         ****     #ifndef USB_DISC_PIN  
 129:usb.c         ****     #define USB_DISC_PIN    12
 130:usb.c         ****     #endif
 131:usb.c         **** 
 132:usb.c         ****     // set up pin in host disconnected state
 133:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 134:usb.c         ****     SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 135:usb.c         ****         (GET_REG(
 136:usb.c         ****             GPIO_CR(USB_DISC_BANK, USB_DISC_PIN)) & crMask(USB_DISC_PIN))
 137:usb.c         ****             | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
 138:usb.c         ****         );
 139:usb.c         **** 
 140:usb.c         ****     // wait a while to make sure host disconnects us
 141:usb.c         ****     volatile u32 delay;
 142:usb.c         ****     for(delay = 256; delay; delay--);
 143:usb.c         **** 
 144:usb.c         ****     #endif
 145:usb.c         **** #endif
 146:usb.c         **** #endif
 147:usb.c         **** 
 148:usb.c         ****   // initialize the usb application  
 149:usb.c         ****   wTransferSize = getFlashPageSize();
 150:usb.c         ****   u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
 151:usb.c         ****   u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
 152:usb.c         ****   
 153:usb.c         ****   u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
 154:usb.c         ****   u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
 155:usb.c         ****   
 156:usb.c         ****   usbAppInit();
 157:usb.c         **** }
 158:usb.c         **** 
 159:usb.c         **** 
 160:usb.c         **** void usbDsbBus(void)
 161:usb.c         **** {
 162:usb.c         ****     usbPowerOff();
 163:usb.c         **** }
 164:usb.c         **** 
 165:usb.c         **** 
 166:usb.c         **** /* dummy proc */
 167:usb.c         **** void nothingProc(void)
 168:usb.c         **** {
 169:usb.c         ****     return;
 170:usb.c         **** }
 171:usb.c         **** 
 172:usb.c         **** /* application function definitions */
 173:usb.c         **** void usbAppInit(void)
 174:usb.c         **** {
 175:usb.c         ****     // hook in to usb_core, depends on all those damn non encapsulated externs!
 176:usb.c         ****     USB_Init();
 177:usb.c         **** }
 178:usb.c         **** 
 179:usb.c         **** void usbSuspend(void)
 180:usb.c         **** {
 181:usb.c         ****     u16 wCNTR;
 182:usb.c         ****     wCNTR = _GetCNTR();
 183:usb.c         ****     wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
 184:usb.c         ****     _SetCNTR(wCNTR);
 185:usb.c         **** 
 186:usb.c         ****     // run any power reduction handlers
 187:usb.c         ****     bDeviceState = SUSPENDED;
 188:usb.c         **** }
 189:usb.c         **** 
 190:usb.c         **** void usbResumeInit(void)
 191:usb.c         **** {
 192:usb.c         ****     u16 wCNTR;
 193:usb.c         **** 
 194:usb.c         ****     // restart any clocks that had been stopped
 195:usb.c         ****     wCNTR = _GetCNTR();
 196:usb.c         ****     wCNTR &= (~CNTR_LPMODE);
 197:usb.c         ****     _SetCNTR(wCNTR);
 198:usb.c         **** 
 199:usb.c         ****     // undo power reduction handlers here
 200:usb.c         ****     _SetCNTR(ISR_MSK);
 201:usb.c         **** }
 202:usb.c         **** 
 203:usb.c         **** void usbResume(RESUME_STATE eResumeSetVal)
 204:usb.c         **** {
 205:usb.c         ****     u16 wCNTR;
 206:usb.c         **** 
 207:usb.c         ****     if (eResumeSetVal != RESUME_ESOF)
 208:usb.c         ****         ResumeS.eState = eResumeSetVal;
 209:usb.c         **** 
 210:usb.c         ****     switch (ResumeS.eState) {
 211:usb.c         ****     case RESUME_EXTERNAL:
 212:usb.c         ****         usbResumeInit();
 213:usb.c         ****         ResumeS.eState = RESUME_OFF;
 214:usb.c         ****         break;
 215:usb.c         ****     case RESUME_INTERNAL:
 216:usb.c         ****         usbResumeInit();
 217:usb.c         ****         ResumeS.eState = RESUME_START;
 218:usb.c         ****         break;
 219:usb.c         ****     case RESUME_LATER:
 220:usb.c         ****         ResumeS.bESOFcnt = 2;
 221:usb.c         ****         ResumeS.eState = RESUME_WAIT;
 222:usb.c         ****         break;
 223:usb.c         ****     case RESUME_WAIT:
 224:usb.c         ****         ResumeS.bESOFcnt--;
 225:usb.c         ****         if (ResumeS.bESOFcnt == 0)
 226:usb.c         ****             ResumeS.eState = RESUME_START;
 227:usb.c         ****         break;
 228:usb.c         ****     case RESUME_START:
 229:usb.c         ****         wCNTR = _GetCNTR();
 230:usb.c         ****         wCNTR |= CNTR_RESUME;
 231:usb.c         ****         _SetCNTR(wCNTR);
 232:usb.c         ****         ResumeS.eState = RESUME_ON;
 233:usb.c         ****         ResumeS.bESOFcnt = 10;
 234:usb.c         ****         break;
 235:usb.c         ****     case RESUME_ON:
 236:usb.c         ****         ResumeS.bESOFcnt--;
 237:usb.c         ****         if (ResumeS.bESOFcnt == 0) {
 238:usb.c         ****             wCNTR = _GetCNTR();
 239:usb.c         ****             wCNTR &= (~CNTR_RESUME);
 240:usb.c         ****             _SetCNTR(wCNTR);
 241:usb.c         ****             ResumeS.eState = RESUME_OFF;
 242:usb.c         ****         }
 243:usb.c         ****         break;
 244:usb.c         ****     case RESUME_OFF:
 245:usb.c         ****     case RESUME_ESOF:
 246:usb.c         ****     default:
 247:usb.c         ****         ResumeS.eState = RESUME_OFF;
 248:usb.c         ****         break;
 249:usb.c         ****     }
 250:usb.c         **** }
 251:usb.c         **** 
 252:usb.c         **** RESULT usbPowerOn(void)
 253:usb.c         **** {
 254:usb.c         ****     // Enable USB clock
 255:usb.c         ****     RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
 256:usb.c         **** 
 257:usb.c         ****     _SetCNTR(CNTR_FRES);
 258:usb.c         ****     _SetCNTR(0);
 259:usb.c         ****     _SetISTR(0);
 260:usb.c         **** 
 261:usb.c         ****     wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
 262:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 263:usb.c         **** 
 264:usb.c         ****     // present to host
 265:usb.c         **** #ifndef USB_DISC_HARDWIRED
 266:usb.c         **** #ifdef HAS_MAPLE_HARDWARE
 267:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 268:usb.c         **** #else
 269:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 270:usb.c         **** #endif
 271:usb.c         **** #endif
 272:usb.c         **** 
 273:usb.c         ****     return USB_SUCCESS;
 274:usb.c         **** }
 275:usb.c         **** 
 276:usb.c         **** RESULT usbPowerOff(void) {
 277:usb.c         ****     _SetCNTR(CNTR_FRES);
 278:usb.c         ****     _SetISTR(0);
 279:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 280:usb.c         **** 
 281:usb.c         ****     /* note that all weve done here is powerdown the
 282:usb.c         ****        usb peripheral, set USB_DISC_PIN to signal
 283:usb.c         ****        disconnect, and stopped USB clocks.
 284:usb.c         ****        we have not reset the application state machines */
 285:usb.c         **** 
 286:usb.c         ****     // act unplugged to host
 287:usb.c         **** #ifndef USB_DISC_HARDWIRED
 288:usb.c         **** #ifdef HAS_MAPLE_HARDWARE
 289:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 290:usb.c         **** #else
 291:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 292:usb.c         **** #endif
 293:usb.c         **** #endif
 294:usb.c         **** 
 295:usb.c         ****     // Disable USB clock
 296:usb.c         ****     RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
 297:usb.c         **** 
 298:usb.c         ****     return USB_SUCCESS;
 299:usb.c         **** }
 300:usb.c         **** 
 301:usb.c         **** void usbInit(void)
 302:usb.c         **** {
 303:usb.c         ****     dfuInit();
 304:usb.c         **** 
 305:usb.c         ****     pInformation->Current_Configuration = 0;
 306:usb.c         ****     usbPowerOn();
 307:usb.c         **** 
 308:usb.c         ****     _SetISTR(0);
 309:usb.c         ****     wInterrupt_Mask = ISR_MSK;
 310:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 311:usb.c         **** 
 312:usb.c         ****     // configure the cortex M3 private peripheral NVIC
 313:usb.c         ****     usbEnbISR();
 314:usb.c         ****     bDeviceState = UNCONNECTED;
 315:usb.c         **** }
 316:usb.c         **** 
 317:usb.c         **** void usbReset(void)
 318:usb.c         **** {    
 319:usb.c         ****     dfuUpdateByReset();
 320:usb.c         **** 
 321:usb.c         ****     pInformation->Current_Configuration = 0;
 322:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 323:usb.c         **** 
 324:usb.c         ****     _SetBTABLE(BTABLE_ADDRESS);
 325:usb.c         **** 
 326:usb.c         ****     // set up the ctrl endpoint
 327:usb.c         ****     _SetEPType(ENDP0, EP_CONTROL);
 328:usb.c         ****     _SetEPTxStatus(ENDP0, EP_TX_STALL);
 329:usb.c         **** 
 330:usb.c         ****     _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
 331:usb.c         ****     _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 332:usb.c         **** 
 333:usb.c         ****     Clear_Status_Out(ENDP0);
 334:usb.c         **** 
 335:usb.c         ****     SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 336:usb.c         ****     //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
 337:usb.c         ****     SetEPRxValid(ENDP0);
 338:usb.c         **** 
 339:usb.c         ****     bDeviceState = ATTACHED;
 340:usb.c         ****     SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
 341:usb.c         **** }
 342:usb.c         **** 
 343:usb.c         **** void usbStatusIn(void)
 344:usb.c         **** {
  26              		.loc 1 344 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
 345:usb.c         ****     return;
 346:usb.c         **** }
  31              		.loc 1 346 0
  32 0000 7047     		bx	lr
  33              		.cfi_endproc
  34              	.LFE14:
  36              		.section	.text.usbGetInterfaceSetting,"ax",%progbits
  37              		.align	1
  38              		.global	usbGetInterfaceSetting
  39              		.syntax unified
  40              		.thumb
  41              		.thumb_func
  42              		.fpu softvfp
  44              	usbGetInterfaceSetting:
  45              	.LFB18:
 347:usb.c         **** 
 348:usb.c         **** void usbStatusOut(void)
 349:usb.c         **** {
 350:usb.c         ****     return;
 351:usb.c         **** }
 352:usb.c         **** 
 353:usb.c         **** RESULT usbDataSetup(u8 request) {
 354:usb.c         ****     u8 *(*CopyRoutine)(u16);
 355:usb.c         ****     CopyRoutine = NULL;
 356:usb.c         **** 
 357:usb.c         ****     // handle dfu class requests
 358:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 359:usb.c         ****         if (dfuUpdateByRequest()) {
 360:usb.c         ****             // successfull state transition, handle the request
 361:usb.c         ****             switch (request) {
 362:usb.c         ****             case(DFU_GETSTATUS):
 363:usb.c         ****                 CopyRoutine = dfuCopyStatus;
 364:usb.c         ****                 break;
 365:usb.c         ****             case(DFU_GETSTATE):
 366:usb.c         ****                 CopyRoutine = dfuCopyState;
 367:usb.c         ****                 break;
 368:usb.c         ****             case(DFU_DNLOAD):
 369:usb.c         ****                 CopyRoutine = dfuCopyDNLOAD;
 370:usb.c         ****                 break;
 371:usb.c         ****             case(DFU_UPLOAD):
 372:usb.c         ****                 CopyRoutine = dfuCopyUPLOAD;
 373:usb.c         ****                 break;
 374:usb.c         ****             default:
 375:usb.c         ****                 // leave copy routine null
 376:usb.c         ****                 break;
 377:usb.c         ****             }
 378:usb.c         ****         }
 379:usb.c         ****     }
 380:usb.c         **** 
 381:usb.c         ****     if (CopyRoutine != NULL) {
 382:usb.c         ****         pInformation->Ctrl_Info.CopyData = CopyRoutine;
 383:usb.c         ****         pInformation->Ctrl_Info.Usb_wOffset = 0;
 384:usb.c         ****         (*CopyRoutine)(0);
 385:usb.c         **** 
 386:usb.c         ****         return USB_SUCCESS;
 387:usb.c         ****     }
 388:usb.c         **** 
 389:usb.c         ****     return USB_UNSUPPORT;
 390:usb.c         **** }
 391:usb.c         **** 
 392:usb.c         **** RESULT usbNoDataSetup(u8 request)
 393:usb.c         **** {
 394:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 395:usb.c         ****         // todo, keep track of the destination interface, often stored in wIndex
 396:usb.c         ****         if (dfuUpdateByRequest()) {
 397:usb.c         ****             return USB_SUCCESS;
 398:usb.c         ****         }
 399:usb.c         ****     }
 400:usb.c         ****     return USB_UNSUPPORT;
 401:usb.c         **** }
 402:usb.c         **** 
 403:usb.c         **** RESULT usbGetInterfaceSetting(u8 interface, u8 altSetting)
 404:usb.c         **** {
  46              		.loc 1 404 0
  47              		.cfi_startproc
  48              		@ args = 0, pretend = 0, frame = 0
  49              		@ frame_needed = 0, uses_anonymous_args = 0
  50              		@ link register save eliminated.
  51              	.LVL0:
 405:usb.c         ****     // alt setting 0 -> program RAM, alt setting 1 or higher -> FLASH
 406:usb.c         ****     if (interface > NUM_ALT_SETTINGS) {
  52              		.loc 1 406 0
  53 0000 0328     		cmp	r0, #3
 407:usb.c         ****         return USB_UNSUPPORT;
 408:usb.c         ****     }
 409:usb.c         **** 
 410:usb.c         ****     return USB_SUCCESS;
 411:usb.c         **** }
  54              		.loc 1 411 0
  55 0002 8CBF     		ite	hi
  56 0004 0220     		movhi	r0, #2
  57              	.LVL1:
  58 0006 0020     		movls	r0, #0
  59 0008 7047     		bx	lr
  60              		.cfi_endproc
  61              	.LFE18:
  63              		.section	.text.usbSetConfiguration,"ax",%progbits
  64              		.align	1
  65              		.global	usbSetConfiguration
  66              		.syntax unified
  67              		.thumb
  68              		.thumb_func
  69              		.fpu softvfp
  71              	usbSetConfiguration:
  72              	.LFB24:
 412:usb.c         **** 
 413:usb.c         **** u8 *usbGetDeviceDescriptor(u16 len)
 414:usb.c         **** {
 415:usb.c         ****     return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
 416:usb.c         **** }
 417:usb.c         **** 
 418:usb.c         **** u8 *usbGetConfigDescriptor(u16 len)
 419:usb.c         **** {
 420:usb.c         ****     return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
 421:usb.c         **** }
 422:usb.c         **** 
 423:usb.c         **** u8 *usbGetStringDescriptor(u16 len)
 424:usb.c         **** {
 425:usb.c         ****     u8 strIndex = pInformation->USBwValue0;
 426:usb.c         ****     if (strIndex > STR_DESC_LEN) {
 427:usb.c         ****         return NULL;
 428:usb.c         ****     } else {
 429:usb.c         ****         return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
 430:usb.c         ****     }
 431:usb.c         **** }
 432:usb.c         **** 
 433:usb.c         **** u8 *usbGetFunctionalDescriptor(u16 len)
 434:usb.c         **** {
 435:usb.c         ****     return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
 436:usb.c         **** }
 437:usb.c         **** 
 438:usb.c         **** 
 439:usb.c         **** 
 440:usb.c         **** /***** start of USER STANDARD REQUESTS ******
 441:usb.c         ****  *
 442:usb.c         ****  * These are the USER STANDARD REQUESTS, they are handled
 443:usb.c         ****  * in the core but we are given these callbacks at the
 444:usb.c         ****  * application level
 445:usb.c         ****  *******************************************/
 446:usb.c         **** 
 447:usb.c         **** void usbGetConfiguration(void)
 448:usb.c         **** {
 449:usb.c         ****     /* nothing process */
 450:usb.c         **** }
 451:usb.c         **** 
 452:usb.c         **** void usbSetConfiguration(void)
 453:usb.c         **** {
  73              		.loc 1 453 0
  74              		.cfi_startproc
  75              		@ args = 0, pretend = 0, frame = 0
  76              		@ frame_needed = 0, uses_anonymous_args = 0
  77              		@ link register save eliminated.
 454:usb.c         ****     if (pInformation->Current_Configuration != 0) {
  78              		.loc 1 454 0
  79 0000 034B     		ldr	r3, .L10
  80 0002 1B68     		ldr	r3, [r3]
  81 0004 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
  82 0006 13B1     		cbz	r3, .L5
 455:usb.c         ****         bDeviceState = CONFIGURED;
  83              		.loc 1 455 0
  84 0008 0522     		movs	r2, #5
  85 000a 024B     		ldr	r3, .L10+4
  86 000c 1A60     		str	r2, [r3]
  87              	.L5:
 456:usb.c         ****     }
 457:usb.c         **** }
  88              		.loc 1 457 0
  89 000e 7047     		bx	lr
  90              	.L11:
  91              		.align	2
  92              	.L10:
  93 0010 00000000 		.word	pInformation
  94 0014 00000000 		.word	.LANCHOR0
  95              		.cfi_endproc
  96              	.LFE24:
  98              		.section	.text.usbSetDeviceAddress,"ax",%progbits
  99              		.align	1
 100              		.global	usbSetDeviceAddress
 101              		.syntax unified
 102              		.thumb
 103              		.thumb_func
 104              		.fpu softvfp
 106              	usbSetDeviceAddress:
 107              	.LFB31:
 458:usb.c         **** 
 459:usb.c         **** void usbGetInterface(void)
 460:usb.c         **** {
 461:usb.c         ****     /* nothing process */
 462:usb.c         **** }
 463:usb.c         **** 
 464:usb.c         **** void usbSetInterface(void)
 465:usb.c         **** {
 466:usb.c         ****     /* nothing process */
 467:usb.c         **** }
 468:usb.c         **** 
 469:usb.c         **** void usbGetStatus(void)
 470:usb.c         **** {
 471:usb.c         ****     /* nothing process */
 472:usb.c         **** }
 473:usb.c         **** 
 474:usb.c         **** void usbClearFeature(void)
 475:usb.c         **** {
 476:usb.c         ****     /* nothing process */
 477:usb.c         **** }
 478:usb.c         **** 
 479:usb.c         **** void usbSetEndpointFeature(void)
 480:usb.c         **** {
 481:usb.c         ****     /* nothing process */
 482:usb.c         **** }
 483:usb.c         **** 
 484:usb.c         **** void usbSetDeviceFeature(void)
 485:usb.c         **** {
 486:usb.c         ****     /* nothing process */
 487:usb.c         **** }
 488:usb.c         **** 
 489:usb.c         **** void usbSetDeviceAddress(void)
 490:usb.c         **** {
 108              		.loc 1 490 0
 109              		.cfi_startproc
 110              		@ args = 0, pretend = 0, frame = 0
 111              		@ frame_needed = 0, uses_anonymous_args = 0
 112              		@ link register save eliminated.
 491:usb.c         ****     bDeviceState = ADDRESSED;
 113              		.loc 1 491 0
 114 0000 0422     		movs	r2, #4
 115 0002 014B     		ldr	r3, .L13
 116 0004 1A60     		str	r2, [r3]
 492:usb.c         **** }
 117              		.loc 1 492 0
 118 0006 7047     		bx	lr
 119              	.L14:
 120              		.align	2
 121              	.L13:
 122 0008 00000000 		.word	.LANCHOR0
 123              		.cfi_endproc
 124              	.LFE31:
 126              		.section	.text.usbReset,"ax",%progbits
 127              		.align	1
 128              		.global	usbReset
 129              		.syntax unified
 130              		.thumb
 131              		.thumb_func
 132              		.fpu softvfp
 134              	usbReset:
 135              	.LFB13:
 318:usb.c         ****     dfuUpdateByReset();
 136              		.loc 1 318 0
 137              		.cfi_startproc
 138              		@ args = 0, pretend = 0, frame = 0
 139              		@ frame_needed = 0, uses_anonymous_args = 0
 140 0000 10B5     		push	{r4, lr}
 141              		.cfi_def_cfa_offset 8
 142              		.cfi_offset 4, -8
 143              		.cfi_offset 14, -4
 321:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 144              		.loc 1 321 0
 145 0002 0024     		movs	r4, #0
 319:usb.c         **** 
 146              		.loc 1 319 0
 147 0004 FFF7FEFF 		bl	dfuUpdateByReset
 148              	.LVL2:
 321:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 149              		.loc 1 321 0
 150 0008 204B     		ldr	r3, .L16
 322:usb.c         **** 
 151              		.loc 1 322 0
 152 000a 214A     		ldr	r2, .L16+4
 321:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 153              		.loc 1 321 0
 154 000c 1B68     		ldr	r3, [r3]
 322:usb.c         **** 
 155              		.loc 1 322 0
 156 000e 1268     		ldr	r2, [r2]
 321:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 157              		.loc 1 321 0
 158 0010 9C72     		strb	r4, [r3, #10]
 322:usb.c         **** 
 159              		.loc 1 322 0
 160 0012 D279     		ldrb	r2, [r2, #7]	@ zero_extendqisi2
 324:usb.c         **** 
 161              		.loc 1 324 0
 162 0014 1F49     		ldr	r1, .L16+8
 322:usb.c         **** 
 163              		.loc 1 322 0
 164 0016 5A72     		strb	r2, [r3, #9]
 327:usb.c         ****     _SetEPTxStatus(ENDP0, EP_TX_STALL);
 165              		.loc 1 327 0
 166 0018 1F4A     		ldr	r2, .L16+12
 324:usb.c         **** 
 167              		.loc 1 324 0
 168 001a 0C60     		str	r4, [r1]
 327:usb.c         ****     _SetEPTxStatus(ENDP0, EP_TX_STALL);
 169              		.loc 1 327 0
 170 001c 1368     		ldr	r3, [r2]
 333:usb.c         **** 
 171              		.loc 1 333 0
 172 001e 2046     		mov	r0, r4
 327:usb.c         ****     _SetEPTxStatus(ENDP0, EP_TX_STALL);
 173              		.loc 1 327 0
 174 0020 23F4EC43 		bic	r3, r3, #30208
 175 0024 23F07003 		bic	r3, r3, #112
 176 0028 43F40073 		orr	r3, r3, #512
 177 002c 9BB2     		uxth	r3, r3
 178 002e 1360     		str	r3, [r2]
 179              	.LBB4:
 328:usb.c         **** 
 180              		.loc 1 328 0
 181 0030 1368     		ldr	r3, [r2]
 182 0032 23F4E043 		bic	r3, r3, #28672
 183 0036 23F04003 		bic	r3, r3, #64
 184 003a 9BB2     		uxth	r3, r3
 185              	.LVL3:
 186 003c 83F01003 		eor	r3, r3, #16
 187              	.LVL4:
 188 0040 1360     		str	r3, [r2]
 189              	.LBE4:
 330:usb.c         ****     _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 190              		.loc 1 330 0
 191 0042 0A68     		ldr	r2, [r1]
 192 0044 154B     		ldr	r3, .L16+16
 193              	.LVL5:
 194 0046 92B2     		uxth	r2, r2
 195 0048 1344     		add	r3, r3, r2
 196 004a 4022     		movs	r2, #64
 197 004c 5B00     		lsls	r3, r3, #1
 198 004e 1A60     		str	r2, [r3]
 331:usb.c         **** 
 199              		.loc 1 331 0
 200 0050 8022     		movs	r2, #128
 201 0052 0B68     		ldr	r3, [r1]
 202 0054 9BB2     		uxth	r3, r3
 203 0056 03F10053 		add	r3, r3, #536870912
 204 005a 03F54053 		add	r3, r3, #12288
 205 005e 5B00     		lsls	r3, r3, #1
 206 0060 1A60     		str	r2, [r3]
 333:usb.c         **** 
 207              		.loc 1 333 0
 208 0062 FFF7FEFF 		bl	Clear_Status_Out
 209              	.LVL6:
 335:usb.c         ****     //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
 210              		.loc 1 335 0
 211 0066 0E4B     		ldr	r3, .L16+20
 212 0068 2046     		mov	r0, r4
 213 006a 1B68     		ldr	r3, [r3]
 214 006c 93F83010 		ldrb	r1, [r3, #48]	@ zero_extendqisi2
 215 0070 FFF7FEFF 		bl	SetEPRxCount
 216              	.LVL7:
 337:usb.c         **** 
 217              		.loc 1 337 0
 218 0074 2046     		mov	r0, r4
 219 0076 FFF7FEFF 		bl	SetEPRxValid
 220              	.LVL8:
 339:usb.c         ****     SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
 221              		.loc 1 339 0
 222 007a 0122     		movs	r2, #1
 223 007c 094B     		ldr	r3, .L16+24
 340:usb.c         **** }
 224              		.loc 1 340 0
 225 007e 2046     		mov	r0, r4
 341:usb.c         **** 
 226              		.loc 1 341 0
 227 0080 BDE81040 		pop	{r4, lr}
 228              		.cfi_restore 14
 229              		.cfi_restore 4
 230              		.cfi_def_cfa_offset 0
 339:usb.c         ****     SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
 231              		.loc 1 339 0
 232 0084 1A60     		str	r2, [r3]
 340:usb.c         **** }
 233              		.loc 1 340 0
 234 0086 FFF7FEBF 		b	SetDeviceAddress
 235              	.LVL9:
 236              	.L17:
 237 008a 00BF     		.align	2
 238              	.L16:
 239 008c 00000000 		.word	pInformation
 240 0090 00000000 		.word	usbConfigDescriptorDFU
 241 0094 505C0040 		.word	1073765456
 242 0098 005C0040 		.word	1073765376
 243 009c 04300020 		.word	536883204
 244 00a0 00000000 		.word	pProperty
 245 00a4 00000000 		.word	.LANCHOR0
 246              		.cfi_endproc
 247              	.LFE13:
 249              		.section	.text.usbGetDeviceDescriptor,"ax",%progbits
 250              		.align	1
 251              		.global	usbGetDeviceDescriptor
 252              		.syntax unified
 253              		.thumb
 254              		.thumb_func
 255              		.fpu softvfp
 257              	usbGetDeviceDescriptor:
 258              	.LFB19:
 414:usb.c         ****     return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
 259              		.loc 1 414 0
 260              		.cfi_startproc
 261              		@ args = 0, pretend = 0, frame = 0
 262              		@ frame_needed = 0, uses_anonymous_args = 0
 263              		@ link register save eliminated.
 264              	.LVL10:
 415:usb.c         **** }
 265              		.loc 1 415 0
 266 0000 0149     		ldr	r1, .L19
 267 0002 FFF7FEBF 		b	Standard_GetDescriptorData
 268              	.LVL11:
 269              	.L20:
 270 0006 00BF     		.align	2
 271              	.L19:
 272 0008 00000000 		.word	usbDeviceDescriptorDFU
 273              		.cfi_endproc
 274              	.LFE19:
 276              		.section	.text.usbGetConfigDescriptor,"ax",%progbits
 277              		.align	1
 278              		.global	usbGetConfigDescriptor
 279              		.syntax unified
 280              		.thumb
 281              		.thumb_func
 282              		.fpu softvfp
 284              	usbGetConfigDescriptor:
 285              	.LFB20:
 419:usb.c         ****     return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
 286              		.loc 1 419 0
 287              		.cfi_startproc
 288              		@ args = 0, pretend = 0, frame = 0
 289              		@ frame_needed = 0, uses_anonymous_args = 0
 290              		@ link register save eliminated.
 291              	.LVL12:
 420:usb.c         **** }
 292              		.loc 1 420 0
 293 0000 0149     		ldr	r1, .L22
 294 0002 FFF7FEBF 		b	Standard_GetDescriptorData
 295              	.LVL13:
 296              	.L23:
 297 0006 00BF     		.align	2
 298              	.L22:
 299 0008 00000000 		.word	usbConfigDescriptorDFU
 300              		.cfi_endproc
 301              	.LFE20:
 303              		.section	.text.usbGetStringDescriptor,"ax",%progbits
 304              		.align	1
 305              		.global	usbGetStringDescriptor
 306              		.syntax unified
 307              		.thumb
 308              		.thumb_func
 309              		.fpu softvfp
 311              	usbGetStringDescriptor:
 312              	.LFB21:
 424:usb.c         ****     u8 strIndex = pInformation->USBwValue0;
 313              		.loc 1 424 0
 314              		.cfi_startproc
 315              		@ args = 0, pretend = 0, frame = 0
 316              		@ frame_needed = 0, uses_anonymous_args = 0
 317              		@ link register save eliminated.
 318              	.LVL14:
 425:usb.c         ****     if (strIndex > STR_DESC_LEN) {
 319              		.loc 1 425 0
 320 0000 054B     		ldr	r3, .L26
 321 0002 1B68     		ldr	r3, [r3]
 322 0004 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 323              	.LVL15:
 426:usb.c         ****         return NULL;
 324              		.loc 1 426 0
 325 0006 072B     		cmp	r3, #7
 326 0008 04D8     		bhi	.L25
 429:usb.c         ****     }
 327              		.loc 1 429 0
 328 000a 0449     		ldr	r1, .L26+4
 329 000c 01EBC301 		add	r1, r1, r3, lsl #3
 330 0010 FFF7FEBF 		b	Standard_GetDescriptorData
 331              	.LVL16:
 332              	.L25:
 431:usb.c         **** 
 333              		.loc 1 431 0
 334 0014 0020     		movs	r0, #0
 335              	.LVL17:
 336 0016 7047     		bx	lr
 337              	.L27:
 338              		.align	2
 339              	.L26:
 340 0018 00000000 		.word	pInformation
 341 001c 00000000 		.word	usbStringDescriptor
 342              		.cfi_endproc
 343              	.LFE21:
 345              		.section	.text.usbGetFunctionalDescriptor,"ax",%progbits
 346              		.align	1
 347              		.global	usbGetFunctionalDescriptor
 348              		.syntax unified
 349              		.thumb
 350              		.thumb_func
 351              		.fpu softvfp
 353              	usbGetFunctionalDescriptor:
 354              	.LFB22:
 434:usb.c         ****     return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
 355              		.loc 1 434 0
 356              		.cfi_startproc
 357              		@ args = 0, pretend = 0, frame = 0
 358              		@ frame_needed = 0, uses_anonymous_args = 0
 359              		@ link register save eliminated.
 360              	.LVL18:
 435:usb.c         **** }
 361              		.loc 1 435 0
 362 0000 0149     		ldr	r1, .L29
 363 0002 FFF7FEBF 		b	Standard_GetDescriptorData
 364              	.LVL19:
 365              	.L30:
 366 0006 00BF     		.align	2
 367              	.L29:
 368 0008 00000000 		.word	usbFunctionalDescriptor
 369              		.cfi_endproc
 370              	.LFE22:
 372              		.section	.text.usbDataSetup,"ax",%progbits
 373              		.align	1
 374              		.global	usbDataSetup
 375              		.syntax unified
 376              		.thumb
 377              		.thumb_func
 378              		.fpu softvfp
 380              	usbDataSetup:
 381              	.LFB16:
 353:usb.c         ****     u8 *(*CopyRoutine)(u16);
 382              		.loc 1 353 0
 383              		.cfi_startproc
 384              		@ args = 0, pretend = 0, frame = 0
 385              		@ frame_needed = 0, uses_anonymous_args = 0
 386              	.LVL20:
 387 0000 38B5     		push	{r3, r4, r5, lr}
 388              		.cfi_def_cfa_offset 16
 389              		.cfi_offset 3, -16
 390              		.cfi_offset 4, -12
 391              		.cfi_offset 5, -8
 392              		.cfi_offset 14, -4
 358:usb.c         ****         if (dfuUpdateByRequest()) {
 393              		.loc 1 358 0
 394 0002 174C     		ldr	r4, .L45
 353:usb.c         ****     u8 *(*CopyRoutine)(u16);
 395              		.loc 1 353 0
 396 0004 0546     		mov	r5, r0
 358:usb.c         ****         if (dfuUpdateByRequest()) {
 397              		.loc 1 358 0
 398 0006 2268     		ldr	r2, [r4]
 399 0008 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 400 000a 02F07F02 		and	r2, r2, #127
 401 000e 212A     		cmp	r2, #33
 402 0010 01D0     		beq	.L32
 403              	.LVL21:
 404              	.L40:
 405              	.LBB7:
 406              	.LBB8:
 389:usb.c         **** }
 407              		.loc 1 389 0
 408 0012 0220     		movs	r0, #2
 409 0014 1CE0     		b	.L33
 410              	.LVL22:
 411              	.L32:
 412              	.LBE8:
 413              	.LBE7:
 359:usb.c         ****             // successfull state transition, handle the request
 414              		.loc 1 359 0
 415 0016 FFF7FEFF 		bl	dfuUpdateByRequest
 416              	.LVL23:
 417 001a 0028     		cmp	r0, #0
 418 001c F9D0     		beq	.L40
 419              	.LVL24:
 420              	.LBB11:
 421              	.LBB9:
 361:usb.c         ****             case(DFU_GETSTATUS):
 422              		.loc 1 361 0
 423 001e 681E     		subs	r0, r5, #1
 424 0020 0428     		cmp	r0, #4
 425 0022 F6D8     		bhi	.L40
 426 0024 01A3     		adr	r3, .L36
 427 0026 53F820F0 		ldr	pc, [r3, r0, lsl #2]
 428 002a 00BF     		.p2align 2
 429              	.L36:
 430 002c 53000000 		.word	.L35+1
 431 0030 57000000 		.word	.L37+1
 432 0034 5B000000 		.word	.L41+1
 433 0038 13000000 		.word	.L40+1
 434 003c 41000000 		.word	.L39+1
 435              		.p2align 1
 436              	.L39:
 366:usb.c         ****                 break;
 437              		.loc 1 366 0
 438 0040 084B     		ldr	r3, .L45+4
 439              	.L38:
 440              	.LVL25:
 382:usb.c         ****         pInformation->Ctrl_Info.Usb_wOffset = 0;
 441              		.loc 1 382 0
 442 0042 2268     		ldr	r2, [r4]
 383:usb.c         ****         (*CopyRoutine)(0);
 443              		.loc 1 383 0
 444 0044 0024     		movs	r4, #0
 382:usb.c         ****         pInformation->Ctrl_Info.Usb_wOffset = 0;
 445              		.loc 1 382 0
 446 0046 9361     		str	r3, [r2, #24]
 383:usb.c         ****         (*CopyRoutine)(0);
 447              		.loc 1 383 0
 448 0048 5482     		strh	r4, [r2, #18]	@ movhi
 384:usb.c         **** 
 449              		.loc 1 384 0
 450 004a 2046     		mov	r0, r4
 451 004c 9847     		blx	r3
 452              	.LVL26:
 386:usb.c         ****     }
 453              		.loc 1 386 0
 454 004e 2046     		mov	r0, r4
 455              	.LVL27:
 456              	.L33:
 457              	.LBE9:
 458              	.LBE11:
 390:usb.c         **** 
 459              		.loc 1 390 0
 460 0050 38BD     		pop	{r3, r4, r5, pc}
 461              	.LVL28:
 462              	.L35:
 463              	.LBB12:
 464              	.LBB10:
 369:usb.c         ****                 break;
 465              		.loc 1 369 0
 466 0052 054B     		ldr	r3, .L45+8
 467 0054 F5E7     		b	.L38
 468              	.LVL29:
 469              	.L37:
 372:usb.c         ****                 break;
 470              		.loc 1 372 0
 471 0056 054B     		ldr	r3, .L45+12
 472 0058 F3E7     		b	.L38
 473              	.LVL30:
 474              	.L41:
 363:usb.c         ****                 break;
 475              		.loc 1 363 0
 476 005a 054B     		ldr	r3, .L45+16
 477 005c F1E7     		b	.L38
 478              	.L46:
 479 005e 00BF     		.align	2
 480              	.L45:
 481 0060 00000000 		.word	pInformation
 482 0064 00000000 		.word	dfuCopyState
 483 0068 00000000 		.word	dfuCopyDNLOAD
 484 006c 00000000 		.word	dfuCopyUPLOAD
 485 0070 00000000 		.word	dfuCopyStatus
 486              	.LBE10:
 487              	.LBE12:
 488              		.cfi_endproc
 489              	.LFE16:
 491              		.section	.text.usbNoDataSetup,"ax",%progbits
 492              		.align	1
 493              		.global	usbNoDataSetup
 494              		.syntax unified
 495              		.thumb
 496              		.thumb_func
 497              		.fpu softvfp
 499              	usbNoDataSetup:
 500              	.LFB17:
 393:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 501              		.loc 1 393 0
 502              		.cfi_startproc
 503              		@ args = 0, pretend = 0, frame = 0
 504              		@ frame_needed = 0, uses_anonymous_args = 0
 505              	.LVL31:
 506 0000 08B5     		push	{r3, lr}
 507              		.cfi_def_cfa_offset 8
 508              		.cfi_offset 3, -8
 509              		.cfi_offset 14, -4
 394:usb.c         ****         // todo, keep track of the destination interface, often stored in wIndex
 510              		.loc 1 394 0
 511 0002 074B     		ldr	r3, .L51
 512 0004 1B68     		ldr	r3, [r3]
 513 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 514 0008 03F07F03 		and	r3, r3, #127
 515 000c 212B     		cmp	r3, #33
 516 000e 02D1     		bne	.L48
 517              	.LVL32:
 518              	.LBB15:
 519              	.LBB16:
 396:usb.c         ****             return USB_SUCCESS;
 520              		.loc 1 396 0
 521 0010 FFF7FEFF 		bl	dfuUpdateByRequest
 522              	.LVL33:
 523 0014 08B9     		cbnz	r0, .L50
 524              	.LVL34:
 525              	.L48:
 400:usb.c         **** }
 526              		.loc 1 400 0
 527 0016 0220     		movs	r0, #2
 528              	.L49:
 529              	.LBE16:
 530              	.LBE15:
 401:usb.c         **** 
 531              		.loc 1 401 0
 532 0018 08BD     		pop	{r3, pc}
 533              	.LVL35:
 534              	.L50:
 535              	.LBB18:
 536              	.LBB17:
 397:usb.c         ****         }
 537              		.loc 1 397 0
 538 001a 0020     		movs	r0, #0
 539 001c FCE7     		b	.L49
 540              	.L52:
 541 001e 00BF     		.align	2
 542              	.L51:
 543 0020 00000000 		.word	pInformation
 544              	.LBE17:
 545              	.LBE18:
 546              		.cfi_endproc
 547              	.LFE17:
 549              		.section	.text.usbSetDeviceFeature,"ax",%progbits
 550              		.align	1
 551              		.global	usbSetDeviceFeature
 552              		.syntax unified
 553              		.thumb
 554              		.thumb_func
 555              		.fpu softvfp
 557              	usbSetDeviceFeature:
 558              	.LFB53:
 559              		.cfi_startproc
 560              		@ args = 0, pretend = 0, frame = 0
 561              		@ frame_needed = 0, uses_anonymous_args = 0
 562              		@ link register save eliminated.
 563 0000 7047     		bx	lr
 564              		.cfi_endproc
 565              	.LFE53:
 567              		.section	.text.nothingProc,"ax",%progbits
 568              		.align	1
 569              		.global	nothingProc
 570              		.syntax unified
 571              		.thumb
 572              		.thumb_func
 573              		.fpu softvfp
 575              	nothingProc:
 576              	.LFB55:
 577              		.cfi_startproc
 578              		@ args = 0, pretend = 0, frame = 0
 579              		@ frame_needed = 0, uses_anonymous_args = 0
 580              		@ link register save eliminated.
 581 0000 7047     		bx	lr
 582              		.cfi_endproc
 583              	.LFE55:
 585              		.section	.text.usbStatusOut,"ax",%progbits
 586              		.align	1
 587              		.global	usbStatusOut
 588              		.syntax unified
 589              		.thumb
 590              		.thumb_func
 591              		.fpu softvfp
 593              	usbStatusOut:
 594              	.LFB39:
 595              		.cfi_startproc
 596              		@ args = 0, pretend = 0, frame = 0
 597              		@ frame_needed = 0, uses_anonymous_args = 0
 598              		@ link register save eliminated.
 599 0000 7047     		bx	lr
 600              		.cfi_endproc
 601              	.LFE39:
 603              		.section	.text.usbGetConfiguration,"ax",%progbits
 604              		.align	1
 605              		.global	usbGetConfiguration
 606              		.syntax unified
 607              		.thumb
 608              		.thumb_func
 609              		.fpu softvfp
 611              	usbGetConfiguration:
 612              	.LFB41:
 613              		.cfi_startproc
 614              		@ args = 0, pretend = 0, frame = 0
 615              		@ frame_needed = 0, uses_anonymous_args = 0
 616              		@ link register save eliminated.
 617 0000 7047     		bx	lr
 618              		.cfi_endproc
 619              	.LFE41:
 621              		.section	.text.usbGetInterface,"ax",%progbits
 622              		.align	1
 623              		.global	usbGetInterface
 624              		.syntax unified
 625              		.thumb
 626              		.thumb_func
 627              		.fpu softvfp
 629              	usbGetInterface:
 630              	.LFB43:
 631              		.cfi_startproc
 632              		@ args = 0, pretend = 0, frame = 0
 633              		@ frame_needed = 0, uses_anonymous_args = 0
 634              		@ link register save eliminated.
 635 0000 7047     		bx	lr
 636              		.cfi_endproc
 637              	.LFE43:
 639              		.section	.text.usbSetInterface,"ax",%progbits
 640              		.align	1
 641              		.global	usbSetInterface
 642              		.syntax unified
 643              		.thumb
 644              		.thumb_func
 645              		.fpu softvfp
 647              	usbSetInterface:
 648              	.LFB45:
 649              		.cfi_startproc
 650              		@ args = 0, pretend = 0, frame = 0
 651              		@ frame_needed = 0, uses_anonymous_args = 0
 652              		@ link register save eliminated.
 653 0000 7047     		bx	lr
 654              		.cfi_endproc
 655              	.LFE45:
 657              		.section	.text.usbGetStatus,"ax",%progbits
 658              		.align	1
 659              		.global	usbGetStatus
 660              		.syntax unified
 661              		.thumb
 662              		.thumb_func
 663              		.fpu softvfp
 665              	usbGetStatus:
 666              	.LFB47:
 667              		.cfi_startproc
 668              		@ args = 0, pretend = 0, frame = 0
 669              		@ frame_needed = 0, uses_anonymous_args = 0
 670              		@ link register save eliminated.
 671 0000 7047     		bx	lr
 672              		.cfi_endproc
 673              	.LFE47:
 675              		.section	.text.usbClearFeature,"ax",%progbits
 676              		.align	1
 677              		.global	usbClearFeature
 678              		.syntax unified
 679              		.thumb
 680              		.thumb_func
 681              		.fpu softvfp
 683              	usbClearFeature:
 684              	.LFB49:
 685              		.cfi_startproc
 686              		@ args = 0, pretend = 0, frame = 0
 687              		@ frame_needed = 0, uses_anonymous_args = 0
 688              		@ link register save eliminated.
 689 0000 7047     		bx	lr
 690              		.cfi_endproc
 691              	.LFE49:
 693              		.section	.text.usbSetEndpointFeature,"ax",%progbits
 694              		.align	1
 695              		.global	usbSetEndpointFeature
 696              		.syntax unified
 697              		.thumb
 698              		.thumb_func
 699              		.fpu softvfp
 701              	usbSetEndpointFeature:
 702              	.LFB51:
 703              		.cfi_startproc
 704              		@ args = 0, pretend = 0, frame = 0
 705              		@ frame_needed = 0, uses_anonymous_args = 0
 706              		@ link register save eliminated.
 707 0000 7047     		bx	lr
 708              		.cfi_endproc
 709              	.LFE51:
 711              		.section	.text.setupUSB,"ax",%progbits
 712              		.align	1
 713              		.global	setupUSB
 714              		.syntax unified
 715              		.thumb
 716              		.thumb_func
 717              		.fpu softvfp
 719              	setupUSB:
 720              	.LFB3:
 109:usb.c         **** #ifndef USB_DISC_HARDWIRED
 721              		.loc 1 109 0
 722              		.cfi_startproc
 723              		@ args = 0, pretend = 0, frame = 8
 724              		@ frame_needed = 0, uses_anonymous_args = 0
 109:usb.c         **** #ifndef USB_DISC_HARDWIRED
 725              		.loc 1 109 0
 726 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
 727              		.cfi_def_cfa_offset 24
 728              		.cfi_offset 4, -12
 729              		.cfi_offset 5, -8
 730              		.cfi_offset 14, -4
 133:usb.c         ****     SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 731              		.loc 1 133 0
 732 0002 0022     		movs	r2, #0
 733 0004 0C21     		movs	r1, #12
 734 0006 1448     		ldr	r0, .L66
 134:usb.c         ****         (GET_REG(
 735              		.loc 1 134 0
 736 0008 144D     		ldr	r5, .L66+4
 133:usb.c         ****     SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 737              		.loc 1 133 0
 738 000a FFF7FEFF 		bl	gpio_write_bit
 739              	.LVL36:
 134:usb.c         ****         (GET_REG(
 740              		.loc 1 134 0
 741 000e 0C20     		movs	r0, #12
 742 0010 2C68     		ldr	r4, [r5]
 743 0012 FFF7FEFF 		bl	crMask
 744              	.LVL37:
 142:usb.c         **** 
 745              		.loc 1 142 0
 746 0016 4FF48073 		mov	r3, #256
 134:usb.c         ****         (GET_REG(
 747              		.loc 1 134 0
 748 001a 2040     		ands	r0, r0, r4
 749 001c 40F48030 		orr	r0, r0, #65536
 750 0020 2860     		str	r0, [r5]
 751              	.L65:
 142:usb.c         **** 
 752              		.loc 1 142 0 discriminator 3
 753 0022 0193     		str	r3, [sp, #4]
 754 0024 019B     		ldr	r3, [sp, #4]
 755 0026 9BB9     		cbnz	r3, .L64
 149:usb.c         ****   u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
 756              		.loc 1 149 0
 757 0028 FFF7FEFF 		bl	getFlashPageSize
 758              	.LVL38:
 759 002c 0C4B     		ldr	r3, .L66+8
 150:usb.c         ****   u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
 760              		.loc 1 150 0
 761 002e C2B2     		uxtb	r2, r0
 149:usb.c         ****   u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
 762              		.loc 1 149 0
 763 0030 1860     		str	r0, [r3]
 150:usb.c         ****   u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
 764              		.loc 1 150 0
 765 0032 0C4B     		ldr	r3, .L66+12
 151:usb.c         ****   
 766              		.loc 1 151 0
 767 0034 C0F30720 		ubfx	r0, r0, #8, #8
 150:usb.c         ****   u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
 768              		.loc 1 150 0
 769 0038 83F82920 		strb	r2, [r3, #41]
 151:usb.c         ****   
 770              		.loc 1 151 0
 771 003c 83F82A00 		strb	r0, [r3, #42]
 153:usb.c         ****   u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
 772              		.loc 1 153 0
 773 0040 094B     		ldr	r3, .L66+16
 774 0042 5A71     		strb	r2, [r3, #5]
 154:usb.c         ****   
 775              		.loc 1 154 0
 776 0044 9871     		strb	r0, [r3, #6]
 157:usb.c         **** 
 777              		.loc 1 157 0
 778 0046 03B0     		add	sp, sp, #12
 779              		.cfi_remember_state
 780              		.cfi_def_cfa_offset 12
 781              		@ sp needed
 782 0048 BDE83040 		pop	{r4, r5, lr}
 783              		.cfi_restore 14
 784              		.cfi_restore 5
 785              		.cfi_restore 4
 786              		.cfi_def_cfa_offset 0
 787              	.LBB19:
 788              	.LBB20:
 176:usb.c         **** }
 789              		.loc 1 176 0
 790 004c FFF7FEBF 		b	USB_Init
 791              	.LVL39:
 792              	.L64:
 793              		.cfi_restore_state
 794              	.LBE20:
 795              	.LBE19:
 142:usb.c         **** 
 796              		.loc 1 142 0 discriminator 3
 797 0050 019B     		ldr	r3, [sp, #4]
 798 0052 013B     		subs	r3, r3, #1
 799 0054 E5E7     		b	.L65
 800              	.L67:
 801 0056 00BF     		.align	2
 802              	.L66:
 803 0058 00080140 		.word	1073809408
 804 005c 04080140 		.word	1073809412
 805 0060 00000000 		.word	wTransferSize
 806 0064 00000000 		.word	u8_usbConfigDescriptorDFU
 807 0068 00000000 		.word	u8_usbFunctionalDescriptor
 808              		.cfi_endproc
 809              	.LFE3:
 811              		.section	.text.usbAppInit,"ax",%progbits
 812              		.align	1
 813              		.global	usbAppInit
 814              		.syntax unified
 815              		.thumb
 816              		.thumb_func
 817              		.fpu softvfp
 819              	usbAppInit:
 820              	.LFB6:
 174:usb.c         ****     // hook in to usb_core, depends on all those damn non encapsulated externs!
 821              		.loc 1 174 0
 822              		.cfi_startproc
 823              		@ args = 0, pretend = 0, frame = 0
 824              		@ frame_needed = 0, uses_anonymous_args = 0
 825              		@ link register save eliminated.
 176:usb.c         **** }
 826              		.loc 1 176 0
 827 0000 FFF7FEBF 		b	USB_Init
 828              	.LVL40:
 829              		.cfi_endproc
 830              	.LFE6:
 832              		.section	.text.usbSuspend,"ax",%progbits
 833              		.align	1
 834              		.global	usbSuspend
 835              		.syntax unified
 836              		.thumb
 837              		.thumb_func
 838              		.fpu softvfp
 840              	usbSuspend:
 841              	.LFB7:
 180:usb.c         ****     u16 wCNTR;
 842              		.loc 1 180 0
 843              		.cfi_startproc
 844              		@ args = 0, pretend = 0, frame = 0
 845              		@ frame_needed = 0, uses_anonymous_args = 0
 846              		@ link register save eliminated.
 182:usb.c         ****     wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
 847              		.loc 1 182 0
 848 0000 044A     		ldr	r2, .L70
 849 0002 1368     		ldr	r3, [r2]
 850 0004 9BB2     		uxth	r3, r3
 851              	.LVL41:
 184:usb.c         **** 
 852              		.loc 1 184 0
 853 0006 43F00C03 		orr	r3, r3, #12
 854              	.LVL42:
 855 000a 1360     		str	r3, [r2]
 187:usb.c         **** }
 856              		.loc 1 187 0
 857 000c 0322     		movs	r2, #3
 858 000e 024B     		ldr	r3, .L70+4
 859 0010 1A60     		str	r2, [r3]
 188:usb.c         **** 
 860              		.loc 1 188 0
 861 0012 7047     		bx	lr
 862              	.L71:
 863              		.align	2
 864              	.L70:
 865 0014 405C0040 		.word	1073765440
 866 0018 00000000 		.word	.LANCHOR0
 867              		.cfi_endproc
 868              	.LFE7:
 870              		.section	.text.usbResumeInit,"ax",%progbits
 871              		.align	1
 872              		.global	usbResumeInit
 873              		.syntax unified
 874              		.thumb
 875              		.thumb_func
 876              		.fpu softvfp
 878              	usbResumeInit:
 879              	.LFB8:
 191:usb.c         ****     u16 wCNTR;
 880              		.loc 1 191 0
 881              		.cfi_startproc
 882              		@ args = 0, pretend = 0, frame = 0
 883              		@ frame_needed = 0, uses_anonymous_args = 0
 884              		@ link register save eliminated.
 197:usb.c         **** 
 885              		.loc 1 197 0
 886 0000 4FF6FB72 		movw	r2, #65531
 195:usb.c         ****     wCNTR &= (~CNTR_LPMODE);
 887              		.loc 1 195 0
 888 0004 034B     		ldr	r3, .L73
 889 0006 1968     		ldr	r1, [r3]
 890              	.LVL43:
 197:usb.c         **** 
 891              		.loc 1 197 0
 892 0008 0A40     		ands	r2, r2, r1
 893 000a 1A60     		str	r2, [r3]
 200:usb.c         **** }
 894              		.loc 1 200 0
 895 000c 4FF43F42 		mov	r2, #48896
 896 0010 1A60     		str	r2, [r3]
 201:usb.c         **** 
 897              		.loc 1 201 0
 898 0012 7047     		bx	lr
 899              	.L74:
 900              		.align	2
 901              	.L73:
 902 0014 405C0040 		.word	1073765440
 903              		.cfi_endproc
 904              	.LFE8:
 906              		.section	.text.usbResume,"ax",%progbits
 907              		.align	1
 908              		.global	usbResume
 909              		.syntax unified
 910              		.thumb
 911              		.thumb_func
 912              		.fpu softvfp
 914              	usbResume:
 915              	.LFB9:
 204:usb.c         ****     u16 wCNTR;
 916              		.loc 1 204 0
 917              		.cfi_startproc
 918              		@ args = 0, pretend = 0, frame = 0
 919              		@ frame_needed = 0, uses_anonymous_args = 0
 920              	.LVL44:
 921 0000 10B5     		push	{r4, lr}
 922              		.cfi_def_cfa_offset 8
 923              		.cfi_offset 4, -8
 924              		.cfi_offset 14, -4
 925 0002 1D4C     		ldr	r4, .L93
 207:usb.c         ****         ResumeS.eState = eResumeSetVal;
 926              		.loc 1 207 0
 927 0004 0728     		cmp	r0, #7
 208:usb.c         **** 
 928              		.loc 1 208 0
 929 0006 18BF     		it	ne
 930 0008 2070     		strbne	r0, [r4]
 210:usb.c         ****     case RESUME_EXTERNAL:
 931              		.loc 1 210 0
 932 000a 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 933 000c 052B     		cmp	r3, #5
 934 000e 06D8     		bhi	.L77
 935 0010 DFE803F0 		tbb	[pc, r3]
 936              	.L79:
 937 0014 03       		.byte	(.L78-.L79)/2
 938 0015 07       		.byte	(.L80-.L79)/2
 939 0016 0B       		.byte	(.L81-.L79)/2
 940 0017 10       		.byte	(.L82-.L79)/2
 941 0018 18       		.byte	(.L83-.L79)/2
 942 0019 23       		.byte	(.L84-.L79)/2
 943              		.p2align 1
 944              	.L78:
 212:usb.c         ****         ResumeS.eState = RESUME_OFF;
 945              		.loc 1 212 0
 946 001a FFF7FEFF 		bl	usbResumeInit
 947              	.LVL45:
 948              	.L77:
 247:usb.c         ****         break;
 949              		.loc 1 247 0
 950 001e 0623     		movs	r3, #6
 951 0020 06E0     		b	.L91
 952              	.L80:
 216:usb.c         ****         ResumeS.eState = RESUME_START;
 953              		.loc 1 216 0
 954 0022 FFF7FEFF 		bl	usbResumeInit
 955              	.LVL46:
 956              	.L92:
 226:usb.c         ****         break;
 957              		.loc 1 226 0
 958 0026 0423     		movs	r3, #4
 959 0028 02E0     		b	.L91
 960              	.L81:
 220:usb.c         ****         ResumeS.eState = RESUME_WAIT;
 961              		.loc 1 220 0
 962 002a 0223     		movs	r3, #2
 963 002c 6370     		strb	r3, [r4, #1]
 221:usb.c         ****         break;
 964              		.loc 1 221 0
 965 002e 0323     		movs	r3, #3
 966              	.L91:
 247:usb.c         ****         break;
 967              		.loc 1 247 0
 968 0030 2370     		strb	r3, [r4]
 250:usb.c         **** 
 969              		.loc 1 250 0
 970 0032 06E0     		b	.L75
 971              	.L82:
 224:usb.c         ****         if (ResumeS.bESOFcnt == 0)
 972              		.loc 1 224 0
 973 0034 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 974 0036 013B     		subs	r3, r3, #1
 975 0038 DBB2     		uxtb	r3, r3
 976 003a 6370     		strb	r3, [r4, #1]
 225:usb.c         ****             ResumeS.eState = RESUME_START;
 977              		.loc 1 225 0
 978 003c 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 979 003e 002B     		cmp	r3, #0
 980 0040 F1D0     		beq	.L92
 981              	.L75:
 250:usb.c         **** 
 982              		.loc 1 250 0
 983 0042 10BD     		pop	{r4, pc}
 984              	.L83:
 229:usb.c         ****         wCNTR |= CNTR_RESUME;
 985              		.loc 1 229 0
 986 0044 0D4A     		ldr	r2, .L93+4
 987 0046 1368     		ldr	r3, [r2]
 988 0048 9BB2     		uxth	r3, r3
 989              	.LVL47:
 231:usb.c         ****         ResumeS.eState = RESUME_ON;
 990              		.loc 1 231 0
 991 004a 43F01003 		orr	r3, r3, #16
 992              	.LVL48:
 993 004e 1360     		str	r3, [r2]
 232:usb.c         ****         ResumeS.bESOFcnt = 10;
 994              		.loc 1 232 0
 995 0050 0523     		movs	r3, #5
 996 0052 2370     		strb	r3, [r4]
 233:usb.c         ****         break;
 997              		.loc 1 233 0
 998 0054 0A23     		movs	r3, #10
 999 0056 6370     		strb	r3, [r4, #1]
 234:usb.c         ****     case RESUME_ON:
 1000              		.loc 1 234 0
 1001 0058 F3E7     		b	.L75
 1002              	.L84:
 236:usb.c         ****         if (ResumeS.bESOFcnt == 0) {
 1003              		.loc 1 236 0
 1004 005a 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1005 005c 013B     		subs	r3, r3, #1
 1006 005e DBB2     		uxtb	r3, r3
 1007 0060 6370     		strb	r3, [r4, #1]
 237:usb.c         ****             wCNTR = _GetCNTR();
 1008              		.loc 1 237 0
 1009 0062 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1010 0064 002B     		cmp	r3, #0
 1011 0066 ECD1     		bne	.L75
 240:usb.c         ****             ResumeS.eState = RESUME_OFF;
 1012              		.loc 1 240 0
 1013 0068 4FF6EF73 		movw	r3, #65519
 238:usb.c         ****             wCNTR &= (~CNTR_RESUME);
 1014              		.loc 1 238 0
 1015 006c 034A     		ldr	r2, .L93+4
 1016 006e 1168     		ldr	r1, [r2]
 1017              	.LVL49:
 240:usb.c         ****             ResumeS.eState = RESUME_OFF;
 1018              		.loc 1 240 0
 1019 0070 0B40     		ands	r3, r3, r1
 1020 0072 1360     		str	r3, [r2]
 1021 0074 D3E7     		b	.L77
 1022              	.L94:
 1023 0076 00BF     		.align	2
 1024              	.L93:
 1025 0078 00000000 		.word	ResumeS
 1026 007c 405C0040 		.word	1073765440
 1027              		.cfi_endproc
 1028              	.LFE9:
 1030              		.section	.text.usbPowerOn,"ax",%progbits
 1031              		.align	1
 1032              		.global	usbPowerOn
 1033              		.syntax unified
 1034              		.thumb
 1035              		.thumb_func
 1036              		.fpu softvfp
 1038              	usbPowerOn:
 1039              	.LFB10:
 253:usb.c         ****     // Enable USB clock
 1040              		.loc 1 253 0
 1041              		.cfi_startproc
 1042              		@ args = 0, pretend = 0, frame = 0
 1043              		@ frame_needed = 0, uses_anonymous_args = 0
 255:usb.c         **** 
 1044              		.loc 1 255 0
 1045 0000 0B4A     		ldr	r2, .L96
 253:usb.c         ****     // Enable USB clock
 1046              		.loc 1 253 0
 1047 0002 10B5     		push	{r4, lr}
 1048              		.cfi_def_cfa_offset 8
 1049              		.cfi_offset 4, -8
 1050              		.cfi_offset 14, -4
 255:usb.c         **** 
 1051              		.loc 1 255 0
 1052 0004 D369     		ldr	r3, [r2, #28]
 258:usb.c         ****     _SetISTR(0);
 1053              		.loc 1 258 0
 1054 0006 0024     		movs	r4, #0
 255:usb.c         **** 
 1055              		.loc 1 255 0
 1056 0008 43F40003 		orr	r3, r3, #8388608
 1057 000c D361     		str	r3, [r2, #28]
 257:usb.c         ****     _SetCNTR(0);
 1058              		.loc 1 257 0
 1059 000e 0122     		movs	r2, #1
 1060 0010 084B     		ldr	r3, .L96+4
 259:usb.c         **** 
 1061              		.loc 1 259 0
 1062 0012 0949     		ldr	r1, .L96+8
 257:usb.c         ****     _SetCNTR(0);
 1063              		.loc 1 257 0
 1064 0014 1A60     		str	r2, [r3]
 258:usb.c         ****     _SetISTR(0);
 1065              		.loc 1 258 0
 1066 0016 1C60     		str	r4, [r3]
 259:usb.c         **** 
 1067              		.loc 1 259 0
 1068 0018 0C60     		str	r4, [r1]
 261:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 1069              		.loc 1 261 0
 1070 001a 4FF4E051 		mov	r1, #7168
 1071 001e 0748     		ldr	r0, .L96+12
 1072 0020 0180     		strh	r1, [r0]	@ movhi
 262:usb.c         **** 
 1073              		.loc 1 262 0
 1074 0022 1960     		str	r1, [r3]
 269:usb.c         **** #endif
 1075              		.loc 1 269 0
 1076 0024 0648     		ldr	r0, .L96+16
 1077 0026 0C21     		movs	r1, #12
 1078 0028 FFF7FEFF 		bl	gpio_write_bit
 1079              	.LVL50:
 274:usb.c         **** 
 1080              		.loc 1 274 0
 1081 002c 2046     		mov	r0, r4
 1082 002e 10BD     		pop	{r4, pc}
 1083              	.L97:
 1084              		.align	2
 1085              	.L96:
 1086 0030 00100240 		.word	1073876992
 1087 0034 405C0040 		.word	1073765440
 1088 0038 445C0040 		.word	1073765444
 1089 003c 00000000 		.word	wInterrupt_Mask
 1090 0040 00080140 		.word	1073809408
 1091              		.cfi_endproc
 1092              	.LFE10:
 1094              		.section	.text.usbPowerOff,"ax",%progbits
 1095              		.align	1
 1096              		.global	usbPowerOff
 1097              		.syntax unified
 1098              		.thumb
 1099              		.thumb_func
 1100              		.fpu softvfp
 1102              	usbPowerOff:
 1103              	.LFB11:
 276:usb.c         ****     _SetCNTR(CNTR_FRES);
 1104              		.loc 1 276 0
 1105              		.cfi_startproc
 1106              		@ args = 0, pretend = 0, frame = 0
 1107              		@ frame_needed = 0, uses_anonymous_args = 0
 277:usb.c         ****     _SetISTR(0);
 1108              		.loc 1 277 0
 1109 0000 0122     		movs	r2, #1
 276:usb.c         ****     _SetCNTR(CNTR_FRES);
 1110              		.loc 1 276 0
 1111 0002 10B5     		push	{r4, lr}
 1112              		.cfi_def_cfa_offset 8
 1113              		.cfi_offset 4, -8
 1114              		.cfi_offset 14, -4
 278:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 1115              		.loc 1 278 0
 1116 0004 0024     		movs	r4, #0
 277:usb.c         ****     _SetISTR(0);
 1117              		.loc 1 277 0
 1118 0006 094B     		ldr	r3, .L99
 291:usb.c         **** #endif
 1119              		.loc 1 291 0
 1120 0008 0C21     		movs	r1, #12
 277:usb.c         ****     _SetISTR(0);
 1121              		.loc 1 277 0
 1122 000a 1A60     		str	r2, [r3]
 278:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 1123              		.loc 1 278 0
 1124 000c 084A     		ldr	r2, .L99+4
 291:usb.c         **** #endif
 1125              		.loc 1 291 0
 1126 000e 0948     		ldr	r0, .L99+8
 278:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 1127              		.loc 1 278 0
 1128 0010 1460     		str	r4, [r2]
 279:usb.c         **** 
 1129              		.loc 1 279 0
 1130 0012 0322     		movs	r2, #3
 1131 0014 1A60     		str	r2, [r3]
 291:usb.c         **** #endif
 1132              		.loc 1 291 0
 1133 0016 2246     		mov	r2, r4
 1134 0018 FFF7FEFF 		bl	gpio_write_bit
 1135              	.LVL51:
 296:usb.c         **** 
 1136              		.loc 1 296 0
 1137 001c 064A     		ldr	r2, .L99+12
 299:usb.c         **** 
 1138              		.loc 1 299 0
 1139 001e 2046     		mov	r0, r4
 296:usb.c         **** 
 1140              		.loc 1 296 0
 1141 0020 D369     		ldr	r3, [r2, #28]
 1142 0022 23F40003 		bic	r3, r3, #8388608
 1143 0026 D361     		str	r3, [r2, #28]
 299:usb.c         **** 
 1144              		.loc 1 299 0
 1145 0028 10BD     		pop	{r4, pc}
 1146              	.L100:
 1147 002a 00BF     		.align	2
 1148              	.L99:
 1149 002c 405C0040 		.word	1073765440
 1150 0030 445C0040 		.word	1073765444
 1151 0034 00080140 		.word	1073809408
 1152 0038 00100240 		.word	1073876992
 1153              		.cfi_endproc
 1154              	.LFE11:
 1156              		.section	.text.usbDsbBus,"ax",%progbits
 1157              		.align	1
 1158              		.global	usbDsbBus
 1159              		.syntax unified
 1160              		.thumb
 1161              		.thumb_func
 1162              		.fpu softvfp
 1164              	usbDsbBus:
 1165              	.LFB4:
 161:usb.c         ****     usbPowerOff();
 1166              		.loc 1 161 0
 1167              		.cfi_startproc
 1168              		@ args = 0, pretend = 0, frame = 0
 1169              		@ frame_needed = 0, uses_anonymous_args = 0
 1170              		@ link register save eliminated.
 162:usb.c         **** }
 1171              		.loc 1 162 0
 1172 0000 FFF7FEBF 		b	usbPowerOff
 1173              	.LVL52:
 1174              		.cfi_endproc
 1175              	.LFE4:
 1177              		.section	.text.usbEnbISR,"ax",%progbits
 1178              		.align	1
 1179              		.global	usbEnbISR
 1180              		.syntax unified
 1181              		.thumb
 1182              		.thumb_func
 1183              		.fpu softvfp
 1185              	usbEnbISR:
 1186              	.LFB32:
 493:usb.c         **** /***** end of USER STANDARD REQUESTS *****/
 494:usb.c         **** 
 495:usb.c         **** 
 496:usb.c         **** void usbEnbISR(void)
 497:usb.c         **** {
 1187              		.loc 1 497 0
 1188              		.cfi_startproc
 1189              		@ args = 0, pretend = 0, frame = 8
 1190              		@ frame_needed = 0, uses_anonymous_args = 0
 498:usb.c         ****     NVIC_InitTypeDef NVIC_InitStructure;
 499:usb.c         **** 
 500:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
 1191              		.loc 1 500 0
 1192 0000 1423     		movs	r3, #20
 497:usb.c         ****     NVIC_InitTypeDef NVIC_InitStructure;
 1193              		.loc 1 497 0
 1194 0002 07B5     		push	{r0, r1, r2, lr}
 1195              		.cfi_def_cfa_offset 16
 1196              		.cfi_offset 14, -4
 1197              		.loc 1 500 0
 1198 0004 ADF80430 		strh	r3, [sp, #4]	@ movhi
 501:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 1199              		.loc 1 501 0
 1200 0008 0023     		movs	r3, #0
 1201 000a 8DF80630 		strb	r3, [sp, #6]
 502:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 503:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
 1202              		.loc 1 503 0
 1203 000e 0123     		movs	r3, #1
 504:usb.c         ****     nvicInit(&NVIC_InitStructure);
 1204              		.loc 1 504 0
 1205 0010 01A8     		add	r0, sp, #4
 503:usb.c         ****     nvicInit(&NVIC_InitStructure);
 1206              		.loc 1 503 0
 1207 0012 8DF80730 		strb	r3, [sp, #7]
 1208              		.loc 1 504 0
 1209 0016 FFF7FEFF 		bl	nvicInit
 1210              	.LVL53:
 505:usb.c         **** }
 1211              		.loc 1 505 0
 1212 001a 03B0     		add	sp, sp, #12
 1213              		.cfi_def_cfa_offset 4
 1214              		@ sp needed
 1215 001c 5DF804FB 		ldr	pc, [sp], #4
 1216              		.cfi_endproc
 1217              	.LFE32:
 1219              		.section	.text.usbInit,"ax",%progbits
 1220              		.align	1
 1221              		.global	usbInit
 1222              		.syntax unified
 1223              		.thumb
 1224              		.thumb_func
 1225              		.fpu softvfp
 1227              	usbInit:
 1228              	.LFB12:
 302:usb.c         ****     dfuInit();
 1229              		.loc 1 302 0
 1230              		.cfi_startproc
 1231              		@ args = 0, pretend = 0, frame = 0
 1232              		@ frame_needed = 0, uses_anonymous_args = 0
 1233 0000 10B5     		push	{r4, lr}
 1234              		.cfi_def_cfa_offset 8
 1235              		.cfi_offset 4, -8
 1236              		.cfi_offset 14, -4
 305:usb.c         ****     usbPowerOn();
 1237              		.loc 1 305 0
 1238 0002 0024     		movs	r4, #0
 303:usb.c         **** 
 1239              		.loc 1 303 0
 1240 0004 FFF7FEFF 		bl	dfuInit
 1241              	.LVL54:
 305:usb.c         ****     usbPowerOn();
 1242              		.loc 1 305 0
 1243 0008 084B     		ldr	r3, .L104
 1244 000a 1B68     		ldr	r3, [r3]
 1245 000c 9C72     		strb	r4, [r3, #10]
 306:usb.c         **** 
 1246              		.loc 1 306 0
 1247 000e FFF7FEFF 		bl	usbPowerOn
 1248              	.LVL55:
 308:usb.c         ****     wInterrupt_Mask = ISR_MSK;
 1249              		.loc 1 308 0
 1250 0012 074B     		ldr	r3, .L104+4
 309:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 1251              		.loc 1 309 0
 1252 0014 074A     		ldr	r2, .L104+8
 308:usb.c         ****     wInterrupt_Mask = ISR_MSK;
 1253              		.loc 1 308 0
 1254 0016 1C60     		str	r4, [r3]
 309:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 1255              		.loc 1 309 0
 1256 0018 4FF43F43 		mov	r3, #48896
 1257 001c 1380     		strh	r3, [r2]	@ movhi
 310:usb.c         **** 
 1258              		.loc 1 310 0
 1259 001e 064A     		ldr	r2, .L104+12
 1260 0020 1360     		str	r3, [r2]
 313:usb.c         ****     bDeviceState = UNCONNECTED;
 1261              		.loc 1 313 0
 1262 0022 FFF7FEFF 		bl	usbEnbISR
 1263              	.LVL56:
 314:usb.c         **** }
 1264              		.loc 1 314 0
 1265 0026 054B     		ldr	r3, .L104+16
 1266 0028 1C60     		str	r4, [r3]
 315:usb.c         **** 
 1267              		.loc 1 315 0
 1268 002a 10BD     		pop	{r4, pc}
 1269              	.L105:
 1270              		.align	2
 1271              	.L104:
 1272 002c 00000000 		.word	pInformation
 1273 0030 445C0040 		.word	1073765444
 1274 0034 00000000 		.word	wInterrupt_Mask
 1275 0038 405C0040 		.word	1073765440
 1276 003c 00000000 		.word	.LANCHOR0
 1277              		.cfi_endproc
 1278              	.LFE12:
 1280              		.section	.text.usbDsbISR,"ax",%progbits
 1281              		.align	1
 1282              		.global	usbDsbISR
 1283              		.syntax unified
 1284              		.thumb
 1285              		.thumb_func
 1286              		.fpu softvfp
 1288              	usbDsbISR:
 1289              	.LFB33:
 506:usb.c         **** 
 507:usb.c         **** void usbDsbISR(void)
 508:usb.c         **** {
 1290              		.loc 1 508 0
 1291              		.cfi_startproc
 1292              		@ args = 0, pretend = 0, frame = 8
 1293              		@ frame_needed = 0, uses_anonymous_args = 0
 509:usb.c         ****     NVIC_InitTypeDef NVIC_InitStructure;
 510:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
 1294              		.loc 1 510 0
 1295 0000 1423     		movs	r3, #20
 508:usb.c         ****     NVIC_InitTypeDef NVIC_InitStructure;
 1296              		.loc 1 508 0
 1297 0002 07B5     		push	{r0, r1, r2, lr}
 1298              		.cfi_def_cfa_offset 16
 1299              		.cfi_offset 14, -4
 1300              		.loc 1 510 0
 1301 0004 ADF80430 		strh	r3, [sp, #4]	@ movhi
 511:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 1302              		.loc 1 511 0
 1303 0008 0023     		movs	r3, #0
 512:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 513:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
 514:usb.c         ****     nvicInit(&NVIC_InitStructure);
 1304              		.loc 1 514 0
 1305 000a 01A8     		add	r0, sp, #4
 511:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 1306              		.loc 1 511 0
 1307 000c 8DF80630 		strb	r3, [sp, #6]
 513:usb.c         ****     nvicInit(&NVIC_InitStructure);
 1308              		.loc 1 513 0
 1309 0010 8DF80730 		strb	r3, [sp, #7]
 1310              		.loc 1 514 0
 1311 0014 FFF7FEFF 		bl	nvicInit
 1312              	.LVL57:
 515:usb.c         **** }
 1313              		.loc 1 515 0
 1314 0018 03B0     		add	sp, sp, #12
 1315              		.cfi_def_cfa_offset 4
 1316              		@ sp needed
 1317 001a 5DF804FB 		ldr	pc, [sp], #4
 1318              		.cfi_endproc
 1319              	.LFE33:
 1321              		.section	.text.USB_LP_CAN1_RX0_IRQHandler,"ax",%progbits
 1322              		.align	1
 1323              		.global	USB_LP_CAN1_RX0_IRQHandler
 1324              		.syntax unified
 1325              		.thumb
 1326              		.thumb_func
 1327              		.fpu softvfp
 1329              	USB_LP_CAN1_RX0_IRQHandler:
 1330              	.LFB34:
 516:usb.c         **** 
 517:usb.c         **** void USB_LP_CAN1_RX0_IRQHandler(void)
 518:usb.c         **** {
 1331              		.loc 1 518 0
 1332              		.cfi_startproc
 1333              		@ args = 0, pretend = 0, frame = 0
 1334              		@ frame_needed = 0, uses_anonymous_args = 0
 1335 0000 70B5     		push	{r4, r5, r6, lr}
 1336              		.cfi_def_cfa_offset 16
 1337              		.cfi_offset 4, -16
 1338              		.cfi_offset 5, -12
 1339              		.cfi_offset 6, -8
 1340              		.cfi_offset 14, -4
 519:usb.c         ****     wIstr = _GetISTR();
 1341              		.loc 1 519 0
 1342 0002 274D     		ldr	r5, .L130
 1343 0004 274C     		ldr	r4, .L130+4
 1344 0006 2B68     		ldr	r3, [r5]
 520:usb.c         **** 
 521:usb.c         ****     /* go nuts with the preproc switches since this is an ISTR and must be FAST */
 522:usb.c         ****     /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
 523:usb.c         **** #if (ISR_MSK & ISTR_CTR)
 524:usb.c         ****     if (wIstr & ISTR_CTR & wInterrupt_Mask) {
 1345              		.loc 1 524 0
 1346 0008 274E     		ldr	r6, .L130+8
 519:usb.c         ****     wIstr = _GetISTR();
 1347              		.loc 1 519 0
 1348 000a 9BB2     		uxth	r3, r3
 1349 000c 2380     		strh	r3, [r4]	@ movhi
 1350              		.loc 1 524 0
 1351 000e 2388     		ldrh	r3, [r4]
 1352 0010 3288     		ldrh	r2, [r6]
 1353 0012 1340     		ands	r3, r3, r2
 1354 0014 1804     		lsls	r0, r3, #16
 1355 0016 01D5     		bpl	.L108
 525:usb.c         ****         /* servicing of the endpoint correct transfer interrupt */
 526:usb.c         ****         /* clear of the CTR flag into the sub */
 527:usb.c         ****         CTR_LP(); /* low priority ISR defined in the usb core lib */
 1356              		.loc 1 527 0
 1357 0018 FFF7FEFF 		bl	CTR_LP
 1358              	.LVL58:
 1359              	.L108:
 528:usb.c         ****     }
 529:usb.c         **** #endif
 530:usb.c         **** 
 531:usb.c         **** #if (ISR_MSK & ISTR_RESET)
 532:usb.c         ****     if (wIstr & ISTR_RESET & wInterrupt_Mask) {
 1360              		.loc 1 532 0
 1361 001c 2388     		ldrh	r3, [r4]
 1362 001e 3288     		ldrh	r2, [r6]
 1363 0020 1340     		ands	r3, r3, r2
 1364 0022 5905     		lsls	r1, r3, #21
 1365 0024 05D5     		bpl	.L109
 533:usb.c         ****         _SetISTR((u16)CLR_RESET);
 1366              		.loc 1 533 0
 1367 0026 4FF6FF33 		movw	r3, #64511
 1368 002a 2B60     		str	r3, [r5]
 534:usb.c         ****         Device_Property.Reset();
 1369              		.loc 1 534 0
 1370 002c 1F4B     		ldr	r3, .L130+12
 1371 002e 5B68     		ldr	r3, [r3, #4]
 1372 0030 9847     		blx	r3
 1373              	.LVL59:
 1374              	.L109:
 535:usb.c         ****     }
 536:usb.c         **** #endif
 537:usb.c         **** 
 538:usb.c         **** 
 539:usb.c         **** #if (ISR_MSK & ISTR_DOVR)
 540:usb.c         ****     if (wIstr & ISTR_DOVR & wInterrupt_Mask) {
 541:usb.c         ****         _SetISTR((u16)CLR_DOVR);
 542:usb.c         ****     }
 543:usb.c         **** #endif
 544:usb.c         **** 
 545:usb.c         **** 
 546:usb.c         **** #if (ISR_MSK & ISTR_ERR)
 547:usb.c         ****     if (wIstr & ISTR_ERR & wInterrupt_Mask) {
 1375              		.loc 1 547 0
 1376 0032 2288     		ldrh	r2, [r4]
 1377 0034 3388     		ldrh	r3, [r6]
 1378 0036 1A40     		ands	r2, r2, r3
 1379 0038 9204     		lsls	r2, r2, #18
 548:usb.c         ****         _SetISTR((u16)CLR_ERR);
 1380              		.loc 1 548 0
 1381 003a 44BF     		itt	mi
 1382 003c 4DF6FF72 		movwmi	r2, #57343
 1383 0040 2A60     		strmi	r2, [r5]
 549:usb.c         ****     }
 550:usb.c         **** #endif
 551:usb.c         **** 
 552:usb.c         **** 
 553:usb.c         **** #if (ISR_MSK & ISTR_WKUP)
 554:usb.c         ****     if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
 1384              		.loc 1 554 0
 1385 0042 2288     		ldrh	r2, [r4]
 1386 0044 1340     		ands	r3, r3, r2
 1387 0046 DB04     		lsls	r3, r3, #19
 1388 0048 05D5     		bpl	.L111
 555:usb.c         ****         _SetISTR((u16)CLR_WKUP);
 1389              		.loc 1 555 0
 1390 004a 4EF6FF73 		movw	r3, #61439
 556:usb.c         ****         usbResume(RESUME_EXTERNAL);
 1391              		.loc 1 556 0
 1392 004e 0020     		movs	r0, #0
 555:usb.c         ****         _SetISTR((u16)CLR_WKUP);
 1393              		.loc 1 555 0
 1394 0050 2B60     		str	r3, [r5]
 1395              		.loc 1 556 0
 1396 0052 FFF7FEFF 		bl	usbResume
 1397              	.LVL60:
 1398              	.L111:
 557:usb.c         ****     }
 558:usb.c         **** #endif
 559:usb.c         **** 
 560:usb.c         ****     /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
 561:usb.c         **** #if (ISR_MSK & ISTR_SUSP)
 562:usb.c         ****     if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
 1399              		.loc 1 562 0
 1400 0056 2388     		ldrh	r3, [r4]
 1401 0058 3288     		ldrh	r2, [r6]
 1402 005a 1340     		ands	r3, r3, r2
 1403 005c 1805     		lsls	r0, r3, #20
 1404 005e 04D5     		bpl	.L112
 563:usb.c         **** 
 564:usb.c         ****         // check if SUSPEND is possible
 565:usb.c         ****         if (F_SUSPEND_ENABLED) {
 566:usb.c         ****             usbSuspend();
 1405              		.loc 1 566 0
 1406 0060 FFF7FEFF 		bl	usbSuspend
 1407              	.LVL61:
 567:usb.c         ****         } else {
 568:usb.c         ****             // if not possible then resume after xx ms
 569:usb.c         ****             usbResume(RESUME_LATER);
 570:usb.c         ****         }
 571:usb.c         ****         // clear of the ISTR bit must be done after setting of CNTR_FSUSP
 572:usb.c         ****         _SetISTR((u16)CLR_SUSP);
 1408              		.loc 1 572 0
 1409 0064 4FF2FF73 		movw	r3, #63487
 1410 0068 2B60     		str	r3, [r5]
 1411              	.L112:
 573:usb.c         ****     }
 574:usb.c         **** #endif
 575:usb.c         **** 
 576:usb.c         **** 
 577:usb.c         **** #if (ISR_MSK & ISTR_SOF)
 578:usb.c         ****     if (wIstr & ISTR_SOF & wInterrupt_Mask) {
 1412              		.loc 1 578 0
 1413 006a 2388     		ldrh	r3, [r4]
 1414 006c 3288     		ldrh	r2, [r6]
 1415 006e 1340     		ands	r3, r3, r2
 1416 0070 9905     		lsls	r1, r3, #22
 1417 0072 07D5     		bpl	.L113
 579:usb.c         ****         _SetISTR((u16)CLR_SOF);
 1418              		.loc 1 579 0
 1419 0074 4FF6FF53 		movw	r3, #65023
 580:usb.c         ****         bIntPackSOF++;
 1420              		.loc 1 580 0
 1421 0078 0D49     		ldr	r1, .L130+16
 579:usb.c         ****         _SetISTR((u16)CLR_SOF);
 1422              		.loc 1 579 0
 1423 007a 2B60     		str	r3, [r5]
 1424              		.loc 1 580 0
 1425 007c 0B78     		ldrb	r3, [r1]	@ zero_extendqisi2
 1426 007e 0133     		adds	r3, r3, #1
 1427 0080 DBB2     		uxtb	r3, r3
 1428 0082 0B70     		strb	r3, [r1]
 1429              	.L113:
 581:usb.c         ****     }
 582:usb.c         **** #endif
 583:usb.c         **** 
 584:usb.c         **** 
 585:usb.c         **** #if (ISR_MSK & ISTR_ESOF)
 586:usb.c         ****     if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
 1430              		.loc 1 586 0
 1431 0084 2388     		ldrh	r3, [r4]
 1432 0086 1A40     		ands	r2, r2, r3
 1433 0088 D305     		lsls	r3, r2, #23
 1434 008a 07D5     		bpl	.L107
 587:usb.c         ****         _SetISTR((u16)CLR_ESOF);
 1435              		.loc 1 587 0
 1436 008c 4FF6FF63 		movw	r3, #65279
 588:usb.c         ****         // resume handling timing is made with ESOFs
 589:usb.c         ****         // request without change of the machine state
 590:usb.c         ****         usbResume(RESUME_ESOF); 
 1437              		.loc 1 590 0
 1438 0090 0720     		movs	r0, #7
 587:usb.c         ****         _SetISTR((u16)CLR_ESOF);
 1439              		.loc 1 587 0
 1440 0092 2B60     		str	r3, [r5]
 591:usb.c         ****     }
 592:usb.c         **** #endif
 593:usb.c         **** 
 594:usb.c         **** }
 1441              		.loc 1 594 0
 1442 0094 BDE87040 		pop	{r4, r5, r6, lr}
 1443              		.cfi_remember_state
 1444              		.cfi_restore 14
 1445              		.cfi_restore 6
 1446              		.cfi_restore 5
 1447              		.cfi_restore 4
 1448              		.cfi_def_cfa_offset 0
 590:usb.c         ****     }
 1449              		.loc 1 590 0
 1450 0098 FFF7FEBF 		b	usbResume
 1451              	.LVL62:
 1452              	.L107:
 1453              		.cfi_restore_state
 1454              		.loc 1 594 0
 1455 009c 70BD     		pop	{r4, r5, r6, pc}
 1456              	.L131:
 1457 009e 00BF     		.align	2
 1458              	.L130:
 1459 00a0 445C0040 		.word	1073765444
 1460 00a4 00000000 		.word	wIstr
 1461 00a8 00000000 		.word	wInterrupt_Mask
 1462 00ac 00000000 		.word	.LANCHOR1
 1463 00b0 00000000 		.word	.LANCHOR2
 1464              		.cfi_endproc
 1465              	.LFE34:
 1467              		.section	.text.usbGetState,"ax",%progbits
 1468              		.align	1
 1469              		.global	usbGetState
 1470              		.syntax unified
 1471              		.thumb
 1472              		.thumb_func
 1473              		.fpu softvfp
 1475              	usbGetState:
 1476              	.LFB35:
 595:usb.c         **** 
 596:usb.c         **** 
 597:usb.c         **** DEVICE_STATE usbGetState()
 598:usb.c         **** {
 1477              		.loc 1 598 0
 1478              		.cfi_startproc
 1479              		@ args = 0, pretend = 0, frame = 0
 1480              		@ frame_needed = 0, uses_anonymous_args = 0
 1481              		@ link register save eliminated.
 599:usb.c         ****     return bDeviceState;
 1482              		.loc 1 599 0
 1483 0000 014B     		ldr	r3, .L133
 1484 0002 1868     		ldr	r0, [r3]
 600:usb.c         **** }
 1485              		.loc 1 600 0
 1486 0004 C0B2     		uxtb	r0, r0
 1487 0006 7047     		bx	lr
 1488              	.L134:
 1489              		.align	2
 1490              	.L133:
 1491 0008 00000000 		.word	.LANCHOR0
 1492              		.cfi_endproc
 1493              	.LFE35:
 1495              		.comm	ResumeS,2,1
 1496              		.global	pEpInt_OUT
 1497              		.global	pEpInt_IN
 1498              		.global	User_Standard_Requests
 1499              		.global	Device_Property
 1500              		.global	Device_Table
 1501              		.global	bIntPackSOF
 1502              		.comm	wIstr,2,2
 1503              		.global	bDeviceState
 1504              		.comm	wTransferSize,4,4
 1505              		.section	.bss.bDeviceState,"aw",%nobits
 1506              		.align	2
 1507              		.set	.LANCHOR0,. + 0
 1510              	bDeviceState:
 1511 0000 00000000 		.space	4
 1512              		.section	.bss.bIntPackSOF,"aw",%nobits
 1513              		.set	.LANCHOR2,. + 0
 1516              	bIntPackSOF:
 1517 0000 00       		.space	1
 1518              		.section	.data.Device_Property,"aw",%progbits
 1519              		.align	2
 1520              		.set	.LANCHOR1,. + 0
 1523              	Device_Property:
 1524 0000 00000000 		.word	usbInit
 1525 0004 00000000 		.word	usbReset
 1526 0008 00000000 		.word	usbStatusIn
 1527 000c 00000000 		.word	usbStatusOut
 1528 0010 00000000 		.word	usbDataSetup
 1529 0014 00000000 		.word	usbNoDataSetup
 1530 0018 00000000 		.word	usbGetInterfaceSetting
 1531 001c 00000000 		.word	usbGetDeviceDescriptor
 1532 0020 00000000 		.word	usbGetConfigDescriptor
 1533 0024 00000000 		.word	usbGetStringDescriptor
 1534 0028 00000000 		.word	usbGetFunctionalDescriptor
 1535 002c 00000000 		.word	0
 1536 0030 40       		.byte	64
 1537 0031 000000   		.space	3
 1538              		.section	.data.Device_Table,"aw",%progbits
 1541              	Device_Table:
 1542 0000 01       		.byte	1
 1543 0001 01       		.byte	1
 1544              		.section	.data.User_Standard_Requests,"aw",%progbits
 1545              		.align	2
 1548              	User_Standard_Requests:
 1549 0000 00000000 		.word	usbGetConfiguration
 1550 0004 00000000 		.word	usbSetConfiguration
 1551 0008 00000000 		.word	usbGetInterface
 1552 000c 00000000 		.word	usbSetInterface
 1553 0010 00000000 		.word	usbGetStatus
 1554 0014 00000000 		.word	usbClearFeature
 1555 0018 00000000 		.word	usbSetEndpointFeature
 1556 001c 00000000 		.word	usbSetDeviceFeature
 1557 0020 00000000 		.word	usbSetDeviceAddress
 1558              		.section	.data.pEpInt_IN,"aw",%progbits
 1559              		.align	2
 1562              	pEpInt_IN:
 1563 0000 00000000 		.word	nothingProc
 1564 0004 00000000 		.word	nothingProc
 1565 0008 00000000 		.word	nothingProc
 1566 000c 00000000 		.word	nothingProc
 1567 0010 00000000 		.word	nothingProc
 1568 0014 00000000 		.word	nothingProc
 1569 0018 00000000 		.word	nothingProc
 1570              		.section	.data.pEpInt_OUT,"aw",%progbits
 1571              		.align	2
 1574              	pEpInt_OUT:
 1575 0000 00000000 		.word	nothingProc
 1576 0004 00000000 		.word	nothingProc
 1577 0008 00000000 		.word	nothingProc
 1578 000c 00000000 		.word	nothingProc
 1579 0010 00000000 		.word	nothingProc
 1580 0014 00000000 		.word	nothingProc
 1581 0018 00000000 		.word	nothingProc
 1582              		.text
 1583              	.Letext0:
 1584              		.file 2 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/lock.h
 1585              		.file 3 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/_types
 1586              		.file 4 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/lib/gcc/arm-none-eabi/7.3.1/incl
 1587              		.file 5 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/reent.
 1588              		.file 6 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/unistd
 1589              		.file 7 "/usr/local/Cellar/arm-none-eabi-gcc/7-2018-q2-update/gcc/arm-none-eabi/include/sys/errno.
 1590              		.file 8 "./stm32_lib/stm32f10x_type.h"
 1591              		.file 9 "hardware.h"
 1592              		.file 10 "./usb_lib/usb_regs.h"
 1593              		.file 11 "./usb_lib/usb_core.h"
 1594              		.file 12 "./usb_lib/usb_def.h"
 1595              		.file 13 "./usb_lib/usb_init.h"
 1596              		.file 14 "usb_descriptor.h"
 1597              		.file 15 "usb.h"
 1598              		.file 16 "dfu.h"
 1599              		.file 17 "./usb_lib/usb_int.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 usb.c
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:16     .text.usbStatusIn:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:23     .text.usbStatusIn:0000000000000000 usbStatusIn
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:37     .text.usbGetInterfaceSetting:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:44     .text.usbGetInterfaceSetting:0000000000000000 usbGetInterfaceSetting
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:64     .text.usbSetConfiguration:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:71     .text.usbSetConfiguration:0000000000000000 usbSetConfiguration
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:93     .text.usbSetConfiguration:0000000000000010 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:99     .text.usbSetDeviceAddress:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:106    .text.usbSetDeviceAddress:0000000000000000 usbSetDeviceAddress
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:122    .text.usbSetDeviceAddress:0000000000000008 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:127    .text.usbReset:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:134    .text.usbReset:0000000000000000 usbReset
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:239    .text.usbReset:000000000000008c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:250    .text.usbGetDeviceDescriptor:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:257    .text.usbGetDeviceDescriptor:0000000000000000 usbGetDeviceDescriptor
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:272    .text.usbGetDeviceDescriptor:0000000000000008 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:277    .text.usbGetConfigDescriptor:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:284    .text.usbGetConfigDescriptor:0000000000000000 usbGetConfigDescriptor
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:299    .text.usbGetConfigDescriptor:0000000000000008 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:304    .text.usbGetStringDescriptor:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:311    .text.usbGetStringDescriptor:0000000000000000 usbGetStringDescriptor
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:340    .text.usbGetStringDescriptor:0000000000000018 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:346    .text.usbGetFunctionalDescriptor:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:353    .text.usbGetFunctionalDescriptor:0000000000000000 usbGetFunctionalDescriptor
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:368    .text.usbGetFunctionalDescriptor:0000000000000008 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:373    .text.usbDataSetup:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:380    .text.usbDataSetup:0000000000000000 usbDataSetup
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:430    .text.usbDataSetup:000000000000002c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:435    .text.usbDataSetup:0000000000000040 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:481    .text.usbDataSetup:0000000000000060 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:492    .text.usbNoDataSetup:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:499    .text.usbNoDataSetup:0000000000000000 usbNoDataSetup
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:543    .text.usbNoDataSetup:0000000000000020 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:550    .text.usbSetDeviceFeature:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:557    .text.usbSetDeviceFeature:0000000000000000 usbSetDeviceFeature
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:568    .text.nothingProc:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:575    .text.nothingProc:0000000000000000 nothingProc
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:586    .text.usbStatusOut:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:593    .text.usbStatusOut:0000000000000000 usbStatusOut
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:604    .text.usbGetConfiguration:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:611    .text.usbGetConfiguration:0000000000000000 usbGetConfiguration
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:622    .text.usbGetInterface:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:629    .text.usbGetInterface:0000000000000000 usbGetInterface
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:640    .text.usbSetInterface:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:647    .text.usbSetInterface:0000000000000000 usbSetInterface
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:658    .text.usbGetStatus:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:665    .text.usbGetStatus:0000000000000000 usbGetStatus
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:676    .text.usbClearFeature:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:683    .text.usbClearFeature:0000000000000000 usbClearFeature
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:694    .text.usbSetEndpointFeature:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:701    .text.usbSetEndpointFeature:0000000000000000 usbSetEndpointFeature
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:712    .text.setupUSB:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:719    .text.setupUSB:0000000000000000 setupUSB
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:803    .text.setupUSB:0000000000000058 $d
                            *COM*:0000000000000004 wTransferSize
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:812    .text.usbAppInit:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:819    .text.usbAppInit:0000000000000000 usbAppInit
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:833    .text.usbSuspend:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:840    .text.usbSuspend:0000000000000000 usbSuspend
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:865    .text.usbSuspend:0000000000000014 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:871    .text.usbResumeInit:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:878    .text.usbResumeInit:0000000000000000 usbResumeInit
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:902    .text.usbResumeInit:0000000000000014 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:907    .text.usbResume:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:914    .text.usbResume:0000000000000000 usbResume
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:937    .text.usbResume:0000000000000014 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:943    .text.usbResume:000000000000001a $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1025   .text.usbResume:0000000000000078 $d
                            *COM*:0000000000000002 ResumeS
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1031   .text.usbPowerOn:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1038   .text.usbPowerOn:0000000000000000 usbPowerOn
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1086   .text.usbPowerOn:0000000000000030 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1095   .text.usbPowerOff:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1102   .text.usbPowerOff:0000000000000000 usbPowerOff
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1149   .text.usbPowerOff:000000000000002c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1157   .text.usbDsbBus:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1164   .text.usbDsbBus:0000000000000000 usbDsbBus
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1178   .text.usbEnbISR:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1185   .text.usbEnbISR:0000000000000000 usbEnbISR
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1220   .text.usbInit:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1227   .text.usbInit:0000000000000000 usbInit
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1272   .text.usbInit:000000000000002c $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1281   .text.usbDsbISR:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1288   .text.usbDsbISR:0000000000000000 usbDsbISR
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1322   .text.USB_LP_CAN1_RX0_IRQHandler:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1329   .text.USB_LP_CAN1_RX0_IRQHandler:0000000000000000 USB_LP_CAN1_RX0_IRQHandler
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1459   .text.USB_LP_CAN1_RX0_IRQHandler:00000000000000a0 $d
                            *COM*:0000000000000002 wIstr
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1468   .text.usbGetState:0000000000000000 $t
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1475   .text.usbGetState:0000000000000000 usbGetState
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1491   .text.usbGetState:0000000000000008 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1574   .data.pEpInt_OUT:0000000000000000 pEpInt_OUT
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1562   .data.pEpInt_IN:0000000000000000 pEpInt_IN
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1548   .data.User_Standard_Requests:0000000000000000 User_Standard_Requests
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1523   .data.Device_Property:0000000000000000 Device_Property
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1541   .data.Device_Table:0000000000000000 Device_Table
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1516   .bss.bIntPackSOF:0000000000000000 bIntPackSOF
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1510   .bss.bDeviceState:0000000000000000 bDeviceState
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1506   .bss.bDeviceState:0000000000000000 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1517   .bss.bIntPackSOF:0000000000000000 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1519   .data.Device_Property:0000000000000000 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1545   .data.User_Standard_Requests:0000000000000000 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1559   .data.pEpInt_IN:0000000000000000 $d
/var/folders/gy/ljsb_4sn10j121t6zk2d77mw0000gn/T//ccWk3OyZ.s:1571   .data.pEpInt_OUT:0000000000000000 $d

UNDEFINED SYMBOLS
pInformation
dfuUpdateByReset
Clear_Status_Out
SetEPRxCount
SetEPRxValid
SetDeviceAddress
usbConfigDescriptorDFU
pProperty
Standard_GetDescriptorData
usbDeviceDescriptorDFU
usbStringDescriptor
usbFunctionalDescriptor
dfuUpdateByRequest
dfuCopyState
dfuCopyDNLOAD
dfuCopyUPLOAD
dfuCopyStatus
gpio_write_bit
crMask
getFlashPageSize
USB_Init
u8_usbConfigDescriptorDFU
u8_usbFunctionalDescriptor
wInterrupt_Mask
nvicInit
dfuInit
CTR_LP
