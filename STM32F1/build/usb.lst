   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 2
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"usb.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.nothingProc,"ax",%progbits
  19              		.align	2
  20              		.global	nothingProc
  21              		.thumb
  22              		.thumb_func
  24              	nothingProc:
  25              	.LFB2:
  26              		.file 1 "usb.c"
   1:usb.c         **** /* *****************************************************************************
   2:usb.c         ****  * The MIT License
   3:usb.c         ****  *
   4:usb.c         ****  * Copyright (c) 2010 LeafLabs LLC.
   5:usb.c         ****  *
   6:usb.c         ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:usb.c         ****  * of this software and associated documentation files (the "Software"), to deal
   8:usb.c         ****  * in the Software without restriction, including without limitation the rights
   9:usb.c         ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:usb.c         ****  * copies of the Software, and to permit persons to whom the Software is
  11:usb.c         ****  * furnished to do so, subject to the following conditions:
  12:usb.c         ****  *
  13:usb.c         ****  * The above copyright notice and this permission notice shall be included in
  14:usb.c         ****  * all copies or substantial portions of the Software.
  15:usb.c         ****  *
  16:usb.c         ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:usb.c         ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:usb.c         ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:usb.c         ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:usb.c         ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:usb.c         ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:usb.c         ****  * THE SOFTWARE.
  23:usb.c         ****  * ****************************************************************************/
  24:usb.c         **** 
  25:usb.c         **** /**
  26:usb.c         ****  *  @file usb.c
  27:usb.c         ****  *
  28:usb.c         ****  *  @brief usb-specific hardware setup, NVIC, clocks, and usb activities
  29:usb.c         ****  *  in the pre-attached state. includes some of the lower level callbacks
  30:usb.c         ****  *  needed by the usb library, like suspend,resume,init,etc
  31:usb.c         ****  */
  32:usb.c         **** 
  33:usb.c         **** #include "usb.h"
  34:usb.c         **** #include "dfu.h"
  35:usb.c         **** 
  36:usb.c         **** 
  37:usb.c         **** extern u8 u8_usbConfigDescriptorDFU[];
  38:usb.c         **** extern u8 u8_usbFunctionalDescriptor[];
  39:usb.c         **** 
  40:usb.c         **** vu32 bDeviceState = UNCONNECTED;
  41:usb.c         **** 
  42:usb.c         **** /* tracks sequential behavior of the ISTR */
  43:usb.c         **** vu16 wIstr;
  44:usb.c         **** vu8 bIntPackSOF = 0;
  45:usb.c         **** 
  46:usb.c         **** DEVICE Device_Table = {
  47:usb.c         ****     NUM_ENDPTS,
  48:usb.c         ****     1
  49:usb.c         **** };
  50:usb.c         **** 
  51:usb.c         **** DEVICE_PROP Device_Property = {
  52:usb.c         ****     usbInit,
  53:usb.c         ****     usbReset,
  54:usb.c         ****     usbStatusIn,
  55:usb.c         ****     usbStatusOut,
  56:usb.c         ****     usbDataSetup,
  57:usb.c         ****     usbNoDataSetup,
  58:usb.c         ****     usbGetInterfaceSetting,
  59:usb.c         ****     usbGetDeviceDescriptor,
  60:usb.c         ****     usbGetConfigDescriptor,
  61:usb.c         ****     usbGetStringDescriptor,
  62:usb.c         ****     usbGetFunctionalDescriptor,
  63:usb.c         ****     0,
  64:usb.c         ****     bMaxPacketSize
  65:usb.c         **** };
  66:usb.c         **** 
  67:usb.c         **** USER_STANDARD_REQUESTS User_Standard_Requests = {
  68:usb.c         ****     usbGetConfiguration,
  69:usb.c         ****     usbSetConfiguration,
  70:usb.c         ****     usbGetInterface,
  71:usb.c         ****     usbSetInterface,
  72:usb.c         ****     usbGetStatus,
  73:usb.c         ****     usbClearFeature,
  74:usb.c         ****     usbSetEndpointFeature,
  75:usb.c         ****     usbSetDeviceFeature,
  76:usb.c         ****     usbSetDeviceAddress
  77:usb.c         **** };
  78:usb.c         **** 
  79:usb.c         **** void (*pEpInt_IN[7])(void) = {
  80:usb.c         ****     nothingProc,
  81:usb.c         ****     nothingProc,
  82:usb.c         ****     nothingProc,
  83:usb.c         ****     nothingProc,
  84:usb.c         ****     nothingProc,
  85:usb.c         ****     nothingProc,
  86:usb.c         ****     nothingProc,
  87:usb.c         **** };
  88:usb.c         **** 
  89:usb.c         **** void (*pEpInt_OUT[7])(void) = {
  90:usb.c         ****     nothingProc,
  91:usb.c         ****     nothingProc,
  92:usb.c         ****     nothingProc,
  93:usb.c         ****     nothingProc,
  94:usb.c         ****     nothingProc,
  95:usb.c         ****     nothingProc,
  96:usb.c         ****     nothingProc,
  97:usb.c         **** };
  98:usb.c         **** 
  99:usb.c         **** struct {
 100:usb.c         ****     volatile RESUME_STATE eState;
 101:usb.c         ****     volatile u8 bESOFcnt;
 102:usb.c         **** } ResumeS;
 103:usb.c         **** 
 104:usb.c         **** 
 105:usb.c         **** static RCC_TypeDef *RCC_Blot = (RCC_TypeDef *)RCC;
 106:usb.c         **** 
 107:usb.c         **** 
 108:usb.c         **** void setupUSB (void)
 109:usb.c         **** {
 110:usb.c         **** #ifndef USB_DISC_HARDWIRED
 111:usb.c         **** #ifdef HAS_MAPLE_HARDWARE	
 112:usb.c         ****     // set up USB DISC pin as output open drain
 113:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 114:usb.c         ****     SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 115:usb.c         ****             (GET_REG(
 116:usb.c         ****                 GPIO_CR(USB_DISC_BANK,USB_DISC_PIN)) & crMask(USB_DISC_PIN))
 117:usb.c         ****                 | CR_OUTPUT_OD << CR_SHITF(USB_DISC_PIN)
 118:usb.c         ****             );
 119:usb.c         **** #else
 120:usb.c         ****     #ifndef USB_DISC_HARDWIRED
 121:usb.c         ****     
 122:usb.c         ****     // Generic boards don't have disconnect hardware, so we drive PA12 (or defined pin) high.
 123:usb.c         ****     // this is connected to the usb D+ line. driving high will signal usb full speed to host
 124:usb.c         ****     #ifndef USB_DISC_BANK
 125:usb.c         ****     #define USB_DISC_BANK   GPIOA
 126:usb.c         ****     #endif
 127:usb.c         **** 
 128:usb.c         ****     #ifndef USB_DISC_PIN  
 129:usb.c         ****     #define USB_DISC_PIN    12
 130:usb.c         ****     #endif
 131:usb.c         **** 
 132:usb.c         ****     // set up pin in host disconnected state
 133:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 134:usb.c         ****     SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 135:usb.c         ****         (GET_REG(
 136:usb.c         ****             GPIO_CR(USB_DISC_BANK, USB_DISC_PIN)) & crMask(USB_DISC_PIN))
 137:usb.c         ****             | CR_OUTPUT_PP << CR_SHITF(USB_DISC_PIN)
 138:usb.c         ****         );
 139:usb.c         **** 
 140:usb.c         ****     // wait a while to make sure host disconnects us
 141:usb.c         ****     volatile u32 delay;
 142:usb.c         ****     for(delay = 256; delay; delay--);
 143:usb.c         **** 
 144:usb.c         ****     #endif
 145:usb.c         **** #endif
 146:usb.c         **** #endif
 147:usb.c         **** 
 148:usb.c         ****   // initialize the usb application  
 149:usb.c         ****   wTransferSize = getFlashPageSize();
 150:usb.c         ****   u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
 151:usb.c         ****   u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
 152:usb.c         ****   
 153:usb.c         ****   u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
 154:usb.c         ****   u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
 155:usb.c         ****   
 156:usb.c         ****   usbAppInit();
 157:usb.c         **** }
 158:usb.c         **** 
 159:usb.c         **** 
 160:usb.c         **** void usbDsbBus(void)
 161:usb.c         **** {
 162:usb.c         ****     usbPowerOff();
 163:usb.c         **** }
 164:usb.c         **** 
 165:usb.c         **** 
 166:usb.c         **** /* dummy proc */
 167:usb.c         **** void nothingProc(void)
 168:usb.c         **** {
  27              		.loc 1 168 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              		@ link register save eliminated.
  32 0000 7047     		bx	lr
  33              		.cfi_endproc
  34              	.LFE2:
  36 0002 00BF     		.section	.text.usbStatusIn,"ax",%progbits
  37              		.align	2
  38              		.global	usbStatusIn
  39              		.thumb
  40              		.thumb_func
  42              	usbStatusIn:
  43              	.LFB11:
 169:usb.c         ****     return;
 170:usb.c         **** }
 171:usb.c         **** 
 172:usb.c         **** /* application function definitions */
 173:usb.c         **** void usbAppInit(void)
 174:usb.c         **** {
 175:usb.c         ****     // hook in to usb_core, depends on all those damn non encapsulated externs!
 176:usb.c         ****     USB_Init();
 177:usb.c         **** }
 178:usb.c         **** 
 179:usb.c         **** void usbSuspend(void)
 180:usb.c         **** {
 181:usb.c         ****     u16 wCNTR;
 182:usb.c         ****     wCNTR = _GetCNTR();
 183:usb.c         ****     wCNTR |= CNTR_FSUSP | CNTR_LPMODE;
 184:usb.c         ****     _SetCNTR(wCNTR);
 185:usb.c         **** 
 186:usb.c         ****     // run any power reduction handlers
 187:usb.c         ****     bDeviceState = SUSPENDED;
 188:usb.c         **** }
 189:usb.c         **** 
 190:usb.c         **** void usbResumeInit(void)
 191:usb.c         **** {
 192:usb.c         ****     u16 wCNTR;
 193:usb.c         **** 
 194:usb.c         ****     // restart any clocks that had been stopped
 195:usb.c         ****     wCNTR = _GetCNTR();
 196:usb.c         ****     wCNTR &= (~CNTR_LPMODE);
 197:usb.c         ****     _SetCNTR(wCNTR);
 198:usb.c         **** 
 199:usb.c         ****     // undo power reduction handlers here
 200:usb.c         ****     _SetCNTR(ISR_MSK);
 201:usb.c         **** }
 202:usb.c         **** 
 203:usb.c         **** void usbResume(RESUME_STATE eResumeSetVal)
 204:usb.c         **** {
 205:usb.c         ****     u16 wCNTR;
 206:usb.c         **** 
 207:usb.c         ****     if (eResumeSetVal != RESUME_ESOF)
 208:usb.c         ****         ResumeS.eState = eResumeSetVal;
 209:usb.c         **** 
 210:usb.c         ****     switch (ResumeS.eState) {
 211:usb.c         ****     case RESUME_EXTERNAL:
 212:usb.c         ****         usbResumeInit();
 213:usb.c         ****         ResumeS.eState = RESUME_OFF;
 214:usb.c         ****         break;
 215:usb.c         ****     case RESUME_INTERNAL:
 216:usb.c         ****         usbResumeInit();
 217:usb.c         ****         ResumeS.eState = RESUME_START;
 218:usb.c         ****         break;
 219:usb.c         ****     case RESUME_LATER:
 220:usb.c         ****         ResumeS.bESOFcnt = 2;
 221:usb.c         ****         ResumeS.eState = RESUME_WAIT;
 222:usb.c         ****         break;
 223:usb.c         ****     case RESUME_WAIT:
 224:usb.c         ****         ResumeS.bESOFcnt--;
 225:usb.c         ****         if (ResumeS.bESOFcnt == 0)
 226:usb.c         ****             ResumeS.eState = RESUME_START;
 227:usb.c         ****         break;
 228:usb.c         ****     case RESUME_START:
 229:usb.c         ****         wCNTR = _GetCNTR();
 230:usb.c         ****         wCNTR |= CNTR_RESUME;
 231:usb.c         ****         _SetCNTR(wCNTR);
 232:usb.c         ****         ResumeS.eState = RESUME_ON;
 233:usb.c         ****         ResumeS.bESOFcnt = 10;
 234:usb.c         ****         break;
 235:usb.c         ****     case RESUME_ON:
 236:usb.c         ****         ResumeS.bESOFcnt--;
 237:usb.c         ****         if (ResumeS.bESOFcnt == 0) {
 238:usb.c         ****             wCNTR = _GetCNTR();
 239:usb.c         ****             wCNTR &= (~CNTR_RESUME);
 240:usb.c         ****             _SetCNTR(wCNTR);
 241:usb.c         ****             ResumeS.eState = RESUME_OFF;
 242:usb.c         ****         }
 243:usb.c         ****         break;
 244:usb.c         ****     case RESUME_OFF:
 245:usb.c         ****     case RESUME_ESOF:
 246:usb.c         ****     default:
 247:usb.c         ****         ResumeS.eState = RESUME_OFF;
 248:usb.c         ****         break;
 249:usb.c         ****     }
 250:usb.c         **** }
 251:usb.c         **** 
 252:usb.c         **** RESULT usbPowerOn(void)
 253:usb.c         **** {
 254:usb.c         ****     // Enable USB clock
 255:usb.c         ****     RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
 256:usb.c         **** 
 257:usb.c         ****     _SetCNTR(CNTR_FRES);
 258:usb.c         ****     _SetCNTR(0);
 259:usb.c         ****     _SetISTR(0);
 260:usb.c         **** 
 261:usb.c         ****     wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
 262:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 263:usb.c         **** 
 264:usb.c         ****     // present to host
 265:usb.c         **** #ifndef USB_DISC_HARDWIRED
 266:usb.c         **** #ifdef HAS_MAPLE_HARDWARE
 267:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 268:usb.c         **** #else
 269:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 270:usb.c         **** #endif
 271:usb.c         **** #endif
 272:usb.c         **** 
 273:usb.c         ****     return USB_SUCCESS;
 274:usb.c         **** }
 275:usb.c         **** 
 276:usb.c         **** RESULT usbPowerOff(void) {
 277:usb.c         ****     _SetCNTR(CNTR_FRES);
 278:usb.c         ****     _SetISTR(0);
 279:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 280:usb.c         **** 
 281:usb.c         ****     /* note that all weve done here is powerdown the
 282:usb.c         ****        usb peripheral, set USB_DISC_PIN to signal
 283:usb.c         ****        disconnect, and stopped USB clocks.
 284:usb.c         ****        we have not reset the application state machines */
 285:usb.c         **** 
 286:usb.c         ****     // act unplugged to host
 287:usb.c         **** #ifndef USB_DISC_HARDWIRED
 288:usb.c         **** #ifdef HAS_MAPLE_HARDWARE
 289:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 290:usb.c         **** #else
 291:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 292:usb.c         **** #endif
 293:usb.c         **** #endif
 294:usb.c         **** 
 295:usb.c         ****     // Disable USB clock
 296:usb.c         ****     RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
 297:usb.c         **** 
 298:usb.c         ****     return USB_SUCCESS;
 299:usb.c         **** }
 300:usb.c         **** 
 301:usb.c         **** void usbInit(void)
 302:usb.c         **** {
 303:usb.c         ****     dfuInit();
 304:usb.c         **** 
 305:usb.c         ****     pInformation->Current_Configuration = 0;
 306:usb.c         ****     usbPowerOn();
 307:usb.c         **** 
 308:usb.c         ****     _SetISTR(0);
 309:usb.c         ****     wInterrupt_Mask = ISR_MSK;
 310:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 311:usb.c         **** 
 312:usb.c         ****     // configure the cortex M3 private peripheral NVIC
 313:usb.c         ****     usbEnbISR();
 314:usb.c         ****     bDeviceState = UNCONNECTED;
 315:usb.c         **** }
 316:usb.c         **** 
 317:usb.c         **** void usbReset(void)
 318:usb.c         **** {    
 319:usb.c         ****     dfuUpdateByReset();
 320:usb.c         **** 
 321:usb.c         ****     pInformation->Current_Configuration = 0;
 322:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 323:usb.c         **** 
 324:usb.c         ****     _SetBTABLE(BTABLE_ADDRESS);
 325:usb.c         **** 
 326:usb.c         ****     // set up the ctrl endpoint
 327:usb.c         ****     _SetEPType(ENDP0, EP_CONTROL);
 328:usb.c         ****     _SetEPTxStatus(ENDP0, EP_TX_STALL);
 329:usb.c         **** 
 330:usb.c         ****     _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
 331:usb.c         ****     _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 332:usb.c         **** 
 333:usb.c         ****     Clear_Status_Out(ENDP0);
 334:usb.c         **** 
 335:usb.c         ****     SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 336:usb.c         ****     //  SetEPTxCount(ENDP0, pProperty->MaxPacketSize);
 337:usb.c         ****     SetEPRxValid(ENDP0);
 338:usb.c         **** 
 339:usb.c         ****     bDeviceState = ATTACHED;
 340:usb.c         ****     SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
 341:usb.c         **** }
 342:usb.c         **** 
 343:usb.c         **** void usbStatusIn(void)
 344:usb.c         **** {
  44              		.loc 1 344 0
  45              		.cfi_startproc
  46              		@ args = 0, pretend = 0, frame = 0
  47              		@ frame_needed = 0, uses_anonymous_args = 0
  48              		@ link register save eliminated.
  49 0000 7047     		bx	lr
  50              		.cfi_endproc
  51              	.LFE11:
  53 0002 00BF     		.section	.text.usbStatusOut,"ax",%progbits
  54              		.align	2
  55              		.global	usbStatusOut
  56              		.thumb
  57              		.thumb_func
  59              	usbStatusOut:
  60              	.LFB12:
 345:usb.c         ****     return;
 346:usb.c         **** }
 347:usb.c         **** 
 348:usb.c         **** void usbStatusOut(void)
 349:usb.c         **** {
  61              		.loc 1 349 0
  62              		.cfi_startproc
  63              		@ args = 0, pretend = 0, frame = 0
  64              		@ frame_needed = 0, uses_anonymous_args = 0
  65              		@ link register save eliminated.
  66 0000 7047     		bx	lr
  67              		.cfi_endproc
  68              	.LFE12:
  70 0002 00BF     		.section	.text.usbGetInterfaceSetting,"ax",%progbits
  71              		.align	2
  72              		.global	usbGetInterfaceSetting
  73              		.thumb
  74              		.thumb_func
  76              	usbGetInterfaceSetting:
  77              	.LFB15:
 350:usb.c         ****     return;
 351:usb.c         **** }
 352:usb.c         **** 
 353:usb.c         **** RESULT usbDataSetup(u8 request) {
 354:usb.c         ****     u8 *(*CopyRoutine)(u16);
 355:usb.c         ****     CopyRoutine = NULL;
 356:usb.c         **** 
 357:usb.c         ****     // handle dfu class requests
 358:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 359:usb.c         ****         if (dfuUpdateByRequest()) {
 360:usb.c         ****             // successfull state transition, handle the request
 361:usb.c         ****             switch (request) {
 362:usb.c         ****             case(DFU_GETSTATUS):
 363:usb.c         ****                 CopyRoutine = dfuCopyStatus;
 364:usb.c         ****                 break;
 365:usb.c         ****             case(DFU_GETSTATE):
 366:usb.c         ****                 CopyRoutine = dfuCopyState;
 367:usb.c         ****                 break;
 368:usb.c         ****             case(DFU_DNLOAD):
 369:usb.c         ****                 CopyRoutine = dfuCopyDNLOAD;
 370:usb.c         ****                 break;
 371:usb.c         ****             case(DFU_UPLOAD):
 372:usb.c         ****                 CopyRoutine = dfuCopyUPLOAD;
 373:usb.c         ****                 break;
 374:usb.c         ****             default:
 375:usb.c         ****                 // leave copy routine null
 376:usb.c         ****                 break;
 377:usb.c         ****             }
 378:usb.c         ****         }
 379:usb.c         ****     }
 380:usb.c         **** 
 381:usb.c         ****     if (CopyRoutine != NULL) {
 382:usb.c         ****         pInformation->Ctrl_Info.CopyData = CopyRoutine;
 383:usb.c         ****         pInformation->Ctrl_Info.Usb_wOffset = 0;
 384:usb.c         ****         (*CopyRoutine)(0);
 385:usb.c         **** 
 386:usb.c         ****         return USB_SUCCESS;
 387:usb.c         ****     }
 388:usb.c         **** 
 389:usb.c         ****     return USB_UNSUPPORT;
 390:usb.c         **** }
 391:usb.c         **** 
 392:usb.c         **** RESULT usbNoDataSetup(u8 request)
 393:usb.c         **** {
 394:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 395:usb.c         ****         // todo, keep track of the destination interface, often stored in wIndex
 396:usb.c         ****         if (dfuUpdateByRequest()) {
 397:usb.c         ****             return USB_SUCCESS;
 398:usb.c         ****         }
 399:usb.c         ****     }
 400:usb.c         ****     return USB_UNSUPPORT;
 401:usb.c         **** }
 402:usb.c         **** 
 403:usb.c         **** RESULT usbGetInterfaceSetting(u8 interface, u8 altSetting)
 404:usb.c         **** {
  78              		.loc 1 404 0
  79              		.cfi_startproc
  80              		@ args = 0, pretend = 0, frame = 0
  81              		@ frame_needed = 0, uses_anonymous_args = 0
  82              		@ link register save eliminated.
  83              	.LVL0:
 405:usb.c         ****     // alt setting 0 -> program RAM, alt setting 1 or higher -> FLASH
 406:usb.c         ****     if (interface > NUM_ALT_SETTINGS) {
 407:usb.c         ****         return USB_UNSUPPORT;
  84              		.loc 1 407 0
  85 0000 0328     		cmp	r0, #3
 408:usb.c         ****     }
 409:usb.c         **** 
 410:usb.c         ****     return USB_SUCCESS;
 411:usb.c         **** }
  86              		.loc 1 411 0
  87 0002 8CBF     		ite	hi
  88 0004 0220     		movhi	r0, #2
  89 0006 0020     		movls	r0, #0
  90              	.LVL1:
  91 0008 7047     		bx	lr
  92              		.cfi_endproc
  93              	.LFE15:
  95 000a 00BF     		.section	.text.usbGetConfiguration,"ax",%progbits
  96              		.align	2
  97              		.global	usbGetConfiguration
  98              		.thumb
  99              		.thumb_func
 101              	usbGetConfiguration:
 102              	.LFB20:
 412:usb.c         **** 
 413:usb.c         **** u8 *usbGetDeviceDescriptor(u16 len)
 414:usb.c         **** {
 415:usb.c         ****     return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
 416:usb.c         **** }
 417:usb.c         **** 
 418:usb.c         **** u8 *usbGetConfigDescriptor(u16 len)
 419:usb.c         **** {
 420:usb.c         ****     return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
 421:usb.c         **** }
 422:usb.c         **** 
 423:usb.c         **** u8 *usbGetStringDescriptor(u16 len)
 424:usb.c         **** {
 425:usb.c         ****     u8 strIndex = pInformation->USBwValue0;
 426:usb.c         ****     if (strIndex > STR_DESC_LEN) {
 427:usb.c         ****         return NULL;
 428:usb.c         ****     } else {
 429:usb.c         ****         return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
 430:usb.c         ****     }
 431:usb.c         **** }
 432:usb.c         **** 
 433:usb.c         **** u8 *usbGetFunctionalDescriptor(u16 len)
 434:usb.c         **** {
 435:usb.c         ****     return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
 436:usb.c         **** }
 437:usb.c         **** 
 438:usb.c         **** 
 439:usb.c         **** 
 440:usb.c         **** /***** start of USER STANDARD REQUESTS ******
 441:usb.c         ****  *
 442:usb.c         ****  * These are the USER STANDARD REQUESTS, they are handled
 443:usb.c         ****  * in the core but we are given these callbacks at the
 444:usb.c         ****  * application level
 445:usb.c         ****  *******************************************/
 446:usb.c         **** 
 447:usb.c         **** void usbGetConfiguration(void)
 448:usb.c         **** {
 103              		.loc 1 448 0
 104              		.cfi_startproc
 105              		@ args = 0, pretend = 0, frame = 0
 106              		@ frame_needed = 0, uses_anonymous_args = 0
 107              		@ link register save eliminated.
 108 0000 7047     		bx	lr
 109              		.cfi_endproc
 110              	.LFE20:
 112 0002 00BF     		.section	.text.usbSetConfiguration,"ax",%progbits
 113              		.align	2
 114              		.global	usbSetConfiguration
 115              		.thumb
 116              		.thumb_func
 118              	usbSetConfiguration:
 119              	.LFB21:
 449:usb.c         ****     /* nothing process */
 450:usb.c         **** }
 451:usb.c         **** 
 452:usb.c         **** void usbSetConfiguration(void)
 453:usb.c         **** {
 120              		.loc 1 453 0
 121              		.cfi_startproc
 122              		@ args = 0, pretend = 0, frame = 0
 123              		@ frame_needed = 0, uses_anonymous_args = 0
 124              		@ link register save eliminated.
 454:usb.c         ****     if (pInformation->Current_Configuration != 0) {
 125              		.loc 1 454 0
 126 0000 034B     		ldr	r3, .L14
 127 0002 1B68     		ldr	r3, [r3]
 128 0004 9B7A     		ldrb	r3, [r3, #10]	@ zero_extendqisi2
 129 0006 13B1     		cbz	r3, .L8
 455:usb.c         ****         bDeviceState = CONFIGURED;
 130              		.loc 1 455 0
 131 0008 024B     		ldr	r3, .L14+4
 132 000a 0522     		movs	r2, #5
 133 000c 1A60     		str	r2, [r3]
 134              	.L8:
 135 000e 7047     		bx	lr
 136              	.L15:
 137              		.align	2
 138              	.L14:
 139 0010 00000000 		.word	pInformation
 140 0014 00000000 		.word	.LANCHOR0
 141              		.cfi_endproc
 142              	.LFE21:
 144              		.section	.text.usbGetInterface,"ax",%progbits
 145              		.align	2
 146              		.global	usbGetInterface
 147              		.thumb
 148              		.thumb_func
 150              	usbGetInterface:
 151              	.LFB22:
 456:usb.c         ****     }
 457:usb.c         **** }
 458:usb.c         **** 
 459:usb.c         **** void usbGetInterface(void)
 460:usb.c         **** {
 152              		.loc 1 460 0
 153              		.cfi_startproc
 154              		@ args = 0, pretend = 0, frame = 0
 155              		@ frame_needed = 0, uses_anonymous_args = 0
 156              		@ link register save eliminated.
 157 0000 7047     		bx	lr
 158              		.cfi_endproc
 159              	.LFE22:
 161 0002 00BF     		.section	.text.usbSetInterface,"ax",%progbits
 162              		.align	2
 163              		.global	usbSetInterface
 164              		.thumb
 165              		.thumb_func
 167              	usbSetInterface:
 168              	.LFB23:
 461:usb.c         ****     /* nothing process */
 462:usb.c         **** }
 463:usb.c         **** 
 464:usb.c         **** void usbSetInterface(void)
 465:usb.c         **** {
 169              		.loc 1 465 0
 170              		.cfi_startproc
 171              		@ args = 0, pretend = 0, frame = 0
 172              		@ frame_needed = 0, uses_anonymous_args = 0
 173              		@ link register save eliminated.
 174 0000 7047     		bx	lr
 175              		.cfi_endproc
 176              	.LFE23:
 178 0002 00BF     		.section	.text.usbGetStatus,"ax",%progbits
 179              		.align	2
 180              		.global	usbGetStatus
 181              		.thumb
 182              		.thumb_func
 184              	usbGetStatus:
 185              	.LFB24:
 466:usb.c         ****     /* nothing process */
 467:usb.c         **** }
 468:usb.c         **** 
 469:usb.c         **** void usbGetStatus(void)
 470:usb.c         **** {
 186              		.loc 1 470 0
 187              		.cfi_startproc
 188              		@ args = 0, pretend = 0, frame = 0
 189              		@ frame_needed = 0, uses_anonymous_args = 0
 190              		@ link register save eliminated.
 191 0000 7047     		bx	lr
 192              		.cfi_endproc
 193              	.LFE24:
 195 0002 00BF     		.section	.text.usbClearFeature,"ax",%progbits
 196              		.align	2
 197              		.global	usbClearFeature
 198              		.thumb
 199              		.thumb_func
 201              	usbClearFeature:
 202              	.LFB25:
 471:usb.c         ****     /* nothing process */
 472:usb.c         **** }
 473:usb.c         **** 
 474:usb.c         **** void usbClearFeature(void)
 475:usb.c         **** {
 203              		.loc 1 475 0
 204              		.cfi_startproc
 205              		@ args = 0, pretend = 0, frame = 0
 206              		@ frame_needed = 0, uses_anonymous_args = 0
 207              		@ link register save eliminated.
 208 0000 7047     		bx	lr
 209              		.cfi_endproc
 210              	.LFE25:
 212 0002 00BF     		.section	.text.usbSetEndpointFeature,"ax",%progbits
 213              		.align	2
 214              		.global	usbSetEndpointFeature
 215              		.thumb
 216              		.thumb_func
 218              	usbSetEndpointFeature:
 219              	.LFB26:
 476:usb.c         ****     /* nothing process */
 477:usb.c         **** }
 478:usb.c         **** 
 479:usb.c         **** void usbSetEndpointFeature(void)
 480:usb.c         **** {
 220              		.loc 1 480 0
 221              		.cfi_startproc
 222              		@ args = 0, pretend = 0, frame = 0
 223              		@ frame_needed = 0, uses_anonymous_args = 0
 224              		@ link register save eliminated.
 225 0000 7047     		bx	lr
 226              		.cfi_endproc
 227              	.LFE26:
 229 0002 00BF     		.section	.text.usbSetDeviceFeature,"ax",%progbits
 230              		.align	2
 231              		.global	usbSetDeviceFeature
 232              		.thumb
 233              		.thumb_func
 235              	usbSetDeviceFeature:
 236              	.LFB27:
 481:usb.c         ****     /* nothing process */
 482:usb.c         **** }
 483:usb.c         **** 
 484:usb.c         **** void usbSetDeviceFeature(void)
 485:usb.c         **** {
 237              		.loc 1 485 0
 238              		.cfi_startproc
 239              		@ args = 0, pretend = 0, frame = 0
 240              		@ frame_needed = 0, uses_anonymous_args = 0
 241              		@ link register save eliminated.
 242 0000 7047     		bx	lr
 243              		.cfi_endproc
 244              	.LFE27:
 246 0002 00BF     		.section	.text.usbSetDeviceAddress,"ax",%progbits
 247              		.align	2
 248              		.global	usbSetDeviceAddress
 249              		.thumb
 250              		.thumb_func
 252              	usbSetDeviceAddress:
 253              	.LFB28:
 486:usb.c         ****     /* nothing process */
 487:usb.c         **** }
 488:usb.c         **** 
 489:usb.c         **** void usbSetDeviceAddress(void)
 490:usb.c         **** {
 254              		.loc 1 490 0
 255              		.cfi_startproc
 256              		@ args = 0, pretend = 0, frame = 0
 257              		@ frame_needed = 0, uses_anonymous_args = 0
 258              		@ link register save eliminated.
 491:usb.c         ****     bDeviceState = ADDRESSED;
 259              		.loc 1 491 0
 260 0000 014B     		ldr	r3, .L23
 261 0002 0422     		movs	r2, #4
 262 0004 1A60     		str	r2, [r3]
 263 0006 7047     		bx	lr
 264              	.L24:
 265              		.align	2
 266              	.L23:
 267 0008 00000000 		.word	.LANCHOR0
 268              		.cfi_endproc
 269              	.LFE28:
 271              		.section	.text.usbReset,"ax",%progbits
 272              		.align	2
 273              		.global	usbReset
 274              		.thumb
 275              		.thumb_func
 277              	usbReset:
 278              	.LFB10:
 318:usb.c         **** {    
 279              		.loc 1 318 0
 280              		.cfi_startproc
 281              		@ args = 0, pretend = 0, frame = 0
 282              		@ frame_needed = 0, uses_anonymous_args = 0
 283 0000 38B5     		push	{r3, r4, r5, lr}
 284              		.cfi_def_cfa_offset 16
 285              		.cfi_offset 3, -16
 286              		.cfi_offset 4, -12
 287              		.cfi_offset 5, -8
 288              		.cfi_offset 14, -4
 319:usb.c         ****     dfuUpdateByReset();
 289              		.loc 1 319 0
 290 0002 FFF7FEFF 		bl	dfuUpdateByReset
 291              	.LVL2:
 321:usb.c         ****     pInformation->Current_Configuration = 0;
 292              		.loc 1 321 0
 293 0006 214A     		ldr	r2, .L26
 322:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 294              		.loc 1 322 0
 295 0008 214B     		ldr	r3, .L26+4
 321:usb.c         ****     pInformation->Current_Configuration = 0;
 296              		.loc 1 321 0
 297 000a 1268     		ldr	r2, [r2]
 322:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 298              		.loc 1 322 0
 299 000c 1B68     		ldr	r3, [r3]
 321:usb.c         ****     pInformation->Current_Configuration = 0;
 300              		.loc 1 321 0
 301 000e 0024     		movs	r4, #0
 302 0010 9472     		strb	r4, [r2, #10]
 322:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 303              		.loc 1 322 0
 304 0012 D879     		ldrb	r0, [r3, #7]	@ zero_extendqisi2
 324:usb.c         ****     _SetBTABLE(BTABLE_ADDRESS);
 305              		.loc 1 324 0
 306 0014 1F49     		ldr	r1, .L26+8
 327:usb.c         ****     _SetEPType(ENDP0, EP_CONTROL);
 307              		.loc 1 327 0
 308 0016 204B     		ldr	r3, .L26+12
 322:usb.c         ****     pInformation->Current_Feature = usbConfigDescriptorDFU.Descriptor[7];
 309              		.loc 1 322 0
 310 0018 5072     		strb	r0, [r2, #9]
 324:usb.c         ****     _SetBTABLE(BTABLE_ADDRESS);
 311              		.loc 1 324 0
 312 001a 0C60     		str	r4, [r1]
 327:usb.c         ****     _SetEPType(ENDP0, EP_CONTROL);
 313              		.loc 1 327 0
 314 001c 1868     		ldr	r0, [r3]
 330:usb.c         ****     _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
 315              		.loc 1 330 0
 316 001e 1F4A     		ldr	r2, .L26+16
 327:usb.c         ****     _SetEPType(ENDP0, EP_CONTROL);
 317              		.loc 1 327 0
 318 0020 20F4EC40 		bic	r0, r0, #30208
 319 0024 20F07000 		bic	r0, r0, #112
 320 0028 40F40070 		orr	r0, r0, #512
 321 002c 80B2     		uxth	r0, r0
 322 002e 1860     		str	r0, [r3]
 323              	.LBB12:
 328:usb.c         ****     _SetEPTxStatus(ENDP0, EP_TX_STALL);
 324              		.loc 1 328 0
 325 0030 1868     		ldr	r0, [r3]
 326              	.LBE12:
 330:usb.c         ****     _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
 327              		.loc 1 330 0
 328 0032 4025     		movs	r5, #64
 329              	.LBB13:
 328:usb.c         ****     _SetEPTxStatus(ENDP0, EP_TX_STALL);
 330              		.loc 1 328 0
 331 0034 20F4E040 		bic	r0, r0, #28672
 332 0038 20F04000 		bic	r0, r0, #64
 333 003c 80B2     		uxth	r0, r0
 334              	.LVL3:
 335 003e 80F01000 		eor	r0, r0, #16
 336              	.LVL4:
 337 0042 1860     		str	r0, [r3]
 338              	.LBE13:
 330:usb.c         ****     _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
 339              		.loc 1 330 0
 340 0044 0868     		ldr	r0, [r1]
 341              	.LVL5:
 331:usb.c         ****     _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 342              		.loc 1 331 0
 343 0046 0B68     		ldr	r3, [r1]
 344              	.LVL6:
 345 0048 81B2     		uxth	r1, r0
 346 004a 9BB2     		uxth	r3, r3
 347 004c 03F10053 		add	r3, r3, #536870912
 330:usb.c         ****     _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
 348              		.loc 1 330 0
 349 0050 0A44     		add	r2, r2, r1
 331:usb.c         ****     _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 350              		.loc 1 331 0
 351 0052 03F54053 		add	r3, r3, #12288
 330:usb.c         ****     _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
 352              		.loc 1 330 0
 353 0056 5200     		lsls	r2, r2, #1
 331:usb.c         ****     _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 354              		.loc 1 331 0
 355 0058 5B00     		lsls	r3, r3, #1
 356 005a 8021     		movs	r1, #128
 330:usb.c         ****     _SetEPRxAddr(ENDP0, ENDP0_RXADDR);
 357              		.loc 1 330 0
 358 005c 1560     		str	r5, [r2]
 333:usb.c         ****     Clear_Status_Out(ENDP0);
 359              		.loc 1 333 0
 360 005e 2046     		mov	r0, r4
 331:usb.c         ****     _SetEPTxAddr(ENDP0, ENDP0_TXADDR);
 361              		.loc 1 331 0
 362 0060 1960     		str	r1, [r3]
 333:usb.c         ****     Clear_Status_Out(ENDP0);
 363              		.loc 1 333 0
 364 0062 FFF7FEFF 		bl	Clear_Status_Out
 365              	.LVL7:
 335:usb.c         ****     SetEPRxCount(ENDP0, pProperty->MaxPacketSize);
 366              		.loc 1 335 0
 367 0066 0E4B     		ldr	r3, .L26+20
 368 0068 2046     		mov	r0, r4
 369 006a 1B68     		ldr	r3, [r3]
 370 006c 93F83010 		ldrb	r1, [r3, #48]	@ zero_extendqisi2
 371 0070 FFF7FEFF 		bl	SetEPRxCount
 372              	.LVL8:
 337:usb.c         ****     SetEPRxValid(ENDP0);
 373              		.loc 1 337 0
 374 0074 2046     		mov	r0, r4
 375 0076 FFF7FEFF 		bl	SetEPRxValid
 376              	.LVL9:
 339:usb.c         ****     bDeviceState = ATTACHED;
 377              		.loc 1 339 0
 378 007a 0A4B     		ldr	r3, .L26+24
 379 007c 0122     		movs	r2, #1
 340:usb.c         ****     SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
 380              		.loc 1 340 0
 381 007e 2046     		mov	r0, r4
 339:usb.c         ****     bDeviceState = ATTACHED;
 382              		.loc 1 339 0
 383 0080 1A60     		str	r2, [r3]
 341:usb.c         **** }
 384              		.loc 1 341 0
 385 0082 BDE83840 		pop	{r3, r4, r5, lr}
 340:usb.c         ****     SetDeviceAddress(0); /* different than usbSetDeviceAddr! comes from usb_core */
 386              		.loc 1 340 0
 387 0086 FFF7FEBF 		b	SetDeviceAddress
 388              	.LVL10:
 389              	.L27:
 390 008a 00BF     		.align	2
 391              	.L26:
 392 008c 00000000 		.word	pInformation
 393 0090 00000000 		.word	usbConfigDescriptorDFU
 394 0094 505C0040 		.word	1073765456
 395 0098 005C0040 		.word	1073765376
 396 009c 04300020 		.word	536883204
 397 00a0 00000000 		.word	pProperty
 398 00a4 00000000 		.word	.LANCHOR0
 399              		.cfi_endproc
 400              	.LFE10:
 402              		.section	.text.usbDataSetup,"ax",%progbits
 403              		.align	2
 404              		.global	usbDataSetup
 405              		.thumb
 406              		.thumb_func
 408              	usbDataSetup:
 409              	.LFB13:
 353:usb.c         **** RESULT usbDataSetup(u8 request) {
 410              		.loc 1 353 0
 411              		.cfi_startproc
 412              		@ args = 0, pretend = 0, frame = 0
 413              		@ frame_needed = 0, uses_anonymous_args = 0
 414              	.LVL11:
 415 0000 38B5     		push	{r3, r4, r5, lr}
 416              		.cfi_def_cfa_offset 16
 417              		.cfi_offset 3, -16
 418              		.cfi_offset 4, -12
 419              		.cfi_offset 5, -8
 420              		.cfi_offset 14, -4
 358:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 421              		.loc 1 358 0
 422 0002 174C     		ldr	r4, .L43
 353:usb.c         **** RESULT usbDataSetup(u8 request) {
 423              		.loc 1 353 0
 424 0004 0546     		mov	r5, r0
 358:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 425              		.loc 1 358 0
 426 0006 2368     		ldr	r3, [r4]
 427 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 428 000a 03F07F03 		and	r3, r3, #127
 429 000e 212B     		cmp	r3, #33
 430 0010 01D0     		beq	.L42
 431              	.LVL12:
 432              	.L30:
 389:usb.c         ****     return USB_UNSUPPORT;
 433              		.loc 1 389 0
 434 0012 0220     		movs	r0, #2
 390:usb.c         **** }
 435              		.loc 1 390 0
 436 0014 38BD     		pop	{r3, r4, r5, pc}
 437              	.LVL13:
 438              	.L42:
 359:usb.c         ****         if (dfuUpdateByRequest()) {
 439              		.loc 1 359 0
 440 0016 FFF7FEFF 		bl	dfuUpdateByRequest
 441              	.LVL14:
 442 001a 0028     		cmp	r0, #0
 443 001c F9D0     		beq	.L30
 361:usb.c         ****             switch (request) {
 444              		.loc 1 361 0
 445 001e 013D     		subs	r5, r5, #1
 446 0020 042D     		cmp	r5, #4
 447 0022 F6D8     		bhi	.L30
 448 0024 01A3     		adr	r3, .L32
 449 0026 53F825F0 		ldr	pc, [r3, r5, lsl #2]
 450 002a 00BF     		.p2align 2
 451              	.L32:
 452 002c 5B000000 		.word	.L31+1
 453 0030 57000000 		.word	.L33+1
 454 0034 53000000 		.word	.L34+1
 455 0038 13000000 		.word	.L30+1
 456 003c 41000000 		.word	.L37+1
 457              		.p2align 1
 458              	.L37:
 366:usb.c         ****                 CopyRoutine = dfuCopyState;
 459              		.loc 1 366 0
 460 0040 084B     		ldr	r3, .L43+4
 461              	.LVL15:
 462              	.L35:
 382:usb.c         ****         pInformation->Ctrl_Info.CopyData = CopyRoutine;
 463              		.loc 1 382 0
 464 0042 2268     		ldr	r2, [r4]
 383:usb.c         ****         pInformation->Ctrl_Info.Usb_wOffset = 0;
 465              		.loc 1 383 0
 466 0044 0024     		movs	r4, #0
 384:usb.c         ****         (*CopyRoutine)(0);
 467              		.loc 1 384 0
 468 0046 2046     		mov	r0, r4
 382:usb.c         ****         pInformation->Ctrl_Info.CopyData = CopyRoutine;
 469              		.loc 1 382 0
 470 0048 9361     		str	r3, [r2, #24]
 383:usb.c         ****         pInformation->Ctrl_Info.Usb_wOffset = 0;
 471              		.loc 1 383 0
 472 004a 5482     		strh	r4, [r2, #18]	@ movhi
 384:usb.c         ****         (*CopyRoutine)(0);
 473              		.loc 1 384 0
 474 004c 9847     		blx	r3
 475              	.LVL16:
 386:usb.c         ****         return USB_SUCCESS;
 476              		.loc 1 386 0
 477 004e 2046     		mov	r0, r4
 478 0050 38BD     		pop	{r3, r4, r5, pc}
 479              	.LVL17:
 480              	.L34:
 363:usb.c         ****                 CopyRoutine = dfuCopyStatus;
 481              		.loc 1 363 0
 482 0052 054B     		ldr	r3, .L43+8
 483 0054 F5E7     		b	.L35
 484              	.L33:
 485              	.LVL18:
 372:usb.c         ****                 CopyRoutine = dfuCopyUPLOAD;
 486              		.loc 1 372 0
 487 0056 054B     		ldr	r3, .L43+12
 373:usb.c         ****                 break;
 488              		.loc 1 373 0
 489 0058 F3E7     		b	.L35
 490              	.LVL19:
 491              	.L31:
 369:usb.c         ****                 CopyRoutine = dfuCopyDNLOAD;
 492              		.loc 1 369 0
 493 005a 054B     		ldr	r3, .L43+16
 370:usb.c         ****                 break;
 494              		.loc 1 370 0
 495 005c F1E7     		b	.L35
 496              	.L44:
 497 005e 00BF     		.align	2
 498              	.L43:
 499 0060 00000000 		.word	pInformation
 500 0064 00000000 		.word	dfuCopyState
 501 0068 00000000 		.word	dfuCopyStatus
 502 006c 00000000 		.word	dfuCopyUPLOAD
 503 0070 00000000 		.word	dfuCopyDNLOAD
 504              		.cfi_endproc
 505              	.LFE13:
 507              		.section	.text.usbGetDeviceDescriptor,"ax",%progbits
 508              		.align	2
 509              		.global	usbGetDeviceDescriptor
 510              		.thumb
 511              		.thumb_func
 513              	usbGetDeviceDescriptor:
 514              	.LFB16:
 414:usb.c         **** {
 515              		.loc 1 414 0
 516              		.cfi_startproc
 517              		@ args = 0, pretend = 0, frame = 0
 518              		@ frame_needed = 0, uses_anonymous_args = 0
 519              		@ link register save eliminated.
 520              	.LVL20:
 415:usb.c         ****     return Standard_GetDescriptorData(len, &usbDeviceDescriptorDFU);
 521              		.loc 1 415 0
 522 0000 0149     		ldr	r1, .L46
 523 0002 FFF7FEBF 		b	Standard_GetDescriptorData
 524              	.LVL21:
 525              	.L47:
 526 0006 00BF     		.align	2
 527              	.L46:
 528 0008 00000000 		.word	usbDeviceDescriptorDFU
 529              		.cfi_endproc
 530              	.LFE16:
 532              		.section	.text.usbGetConfigDescriptor,"ax",%progbits
 533              		.align	2
 534              		.global	usbGetConfigDescriptor
 535              		.thumb
 536              		.thumb_func
 538              	usbGetConfigDescriptor:
 539              	.LFB17:
 419:usb.c         **** {
 540              		.loc 1 419 0
 541              		.cfi_startproc
 542              		@ args = 0, pretend = 0, frame = 0
 543              		@ frame_needed = 0, uses_anonymous_args = 0
 544              		@ link register save eliminated.
 545              	.LVL22:
 420:usb.c         ****     return Standard_GetDescriptorData(len, &usbConfigDescriptorDFU);
 546              		.loc 1 420 0
 547 0000 0149     		ldr	r1, .L49
 548 0002 FFF7FEBF 		b	Standard_GetDescriptorData
 549              	.LVL23:
 550              	.L50:
 551 0006 00BF     		.align	2
 552              	.L49:
 553 0008 00000000 		.word	usbConfigDescriptorDFU
 554              		.cfi_endproc
 555              	.LFE17:
 557              		.section	.text.usbGetStringDescriptor,"ax",%progbits
 558              		.align	2
 559              		.global	usbGetStringDescriptor
 560              		.thumb
 561              		.thumb_func
 563              	usbGetStringDescriptor:
 564              	.LFB18:
 424:usb.c         **** {
 565              		.loc 1 424 0
 566              		.cfi_startproc
 567              		@ args = 0, pretend = 0, frame = 0
 568              		@ frame_needed = 0, uses_anonymous_args = 0
 569              		@ link register save eliminated.
 570              	.LVL24:
 425:usb.c         ****     u8 strIndex = pInformation->USBwValue0;
 571              		.loc 1 425 0
 572 0000 054B     		ldr	r3, .L53
 573 0002 1B68     		ldr	r3, [r3]
 574 0004 9B78     		ldrb	r3, [r3, #2]	@ zero_extendqisi2
 575              	.LVL25:
 426:usb.c         ****     if (strIndex > STR_DESC_LEN) {
 576              		.loc 1 426 0
 577 0006 072B     		cmp	r3, #7
 578 0008 04D8     		bhi	.L52
 429:usb.c         ****         return Standard_GetDescriptorData(len, &usbStringDescriptor[strIndex]);
 579              		.loc 1 429 0
 580 000a 0449     		ldr	r1, .L53+4
 581 000c 01EBC301 		add	r1, r1, r3, lsl #3
 582 0010 FFF7FEBF 		b	Standard_GetDescriptorData
 583              	.LVL26:
 584              	.L52:
 431:usb.c         **** }
 585              		.loc 1 431 0
 586 0014 0020     		movs	r0, #0
 587              	.LVL27:
 588 0016 7047     		bx	lr
 589              	.L54:
 590              		.align	2
 591              	.L53:
 592 0018 00000000 		.word	pInformation
 593 001c 00000000 		.word	usbStringDescriptor
 594              		.cfi_endproc
 595              	.LFE18:
 597              		.section	.text.usbGetFunctionalDescriptor,"ax",%progbits
 598              		.align	2
 599              		.global	usbGetFunctionalDescriptor
 600              		.thumb
 601              		.thumb_func
 603              	usbGetFunctionalDescriptor:
 604              	.LFB19:
 434:usb.c         **** {
 605              		.loc 1 434 0
 606              		.cfi_startproc
 607              		@ args = 0, pretend = 0, frame = 0
 608              		@ frame_needed = 0, uses_anonymous_args = 0
 609              		@ link register save eliminated.
 610              	.LVL28:
 435:usb.c         ****     return Standard_GetDescriptorData(len, &usbFunctionalDescriptor);
 611              		.loc 1 435 0
 612 0000 0149     		ldr	r1, .L56
 613 0002 FFF7FEBF 		b	Standard_GetDescriptorData
 614              	.LVL29:
 615              	.L57:
 616 0006 00BF     		.align	2
 617              	.L56:
 618 0008 00000000 		.word	usbFunctionalDescriptor
 619              		.cfi_endproc
 620              	.LFE19:
 622              		.section	.text.usbNoDataSetup,"ax",%progbits
 623              		.align	2
 624              		.global	usbNoDataSetup
 625              		.thumb
 626              		.thumb_func
 628              	usbNoDataSetup:
 629              	.LFB14:
 393:usb.c         **** {
 630              		.loc 1 393 0
 631              		.cfi_startproc
 632              		@ args = 0, pretend = 0, frame = 0
 633              		@ frame_needed = 0, uses_anonymous_args = 0
 634              	.LVL30:
 635 0000 08B5     		push	{r3, lr}
 636              		.cfi_def_cfa_offset 8
 637              		.cfi_offset 3, -8
 638              		.cfi_offset 14, -4
 394:usb.c         ****     if ((pInformation->USBbmRequestType & (REQUEST_TYPE | RECIPIENT)) == (CLASS_REQUEST | INTERFACE
 639              		.loc 1 394 0
 640 0002 084B     		ldr	r3, .L64
 641 0004 1B68     		ldr	r3, [r3]
 642 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 643 0008 03F07F03 		and	r3, r3, #127
 644 000c 212B     		cmp	r3, #33
 645 000e 01D0     		beq	.L63
 400:usb.c         ****     return USB_UNSUPPORT;
 646              		.loc 1 400 0
 647 0010 0220     		movs	r0, #2
 648              	.LVL31:
 401:usb.c         **** }
 649              		.loc 1 401 0
 650 0012 08BD     		pop	{r3, pc}
 651              	.LVL32:
 652              	.L63:
 653              	.LBB16:
 654              	.LBB17:
 396:usb.c         ****         if (dfuUpdateByRequest()) {
 655              		.loc 1 396 0
 656 0014 FFF7FEFF 		bl	dfuUpdateByRequest
 657              	.LVL33:
 658 0018 0028     		cmp	r0, #0
 397:usb.c         ****             return USB_SUCCESS;
 659              		.loc 1 397 0
 660 001a 0CBF     		ite	eq
 661 001c 0220     		moveq	r0, #2
 662 001e 0020     		movne	r0, #0
 663 0020 08BD     		pop	{r3, pc}
 664              	.L65:
 665 0022 00BF     		.align	2
 666              	.L64:
 667 0024 00000000 		.word	pInformation
 668              	.LBE17:
 669              	.LBE16:
 670              		.cfi_endproc
 671              	.LFE14:
 673              		.section	.text.usbInit,"ax",%progbits
 674              		.align	2
 675              		.global	usbInit
 676              		.thumb
 677              		.thumb_func
 679              	usbInit:
 680              	.LFB9:
 302:usb.c         **** {
 681              		.loc 1 302 0
 682              		.cfi_startproc
 683              		@ args = 0, pretend = 0, frame = 8
 684              		@ frame_needed = 0, uses_anonymous_args = 0
 685 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 686              		.cfi_def_cfa_offset 24
 687              		.cfi_offset 4, -24
 688              		.cfi_offset 5, -20
 689              		.cfi_offset 6, -16
 690              		.cfi_offset 7, -12
 691              		.cfi_offset 8, -8
 692              		.cfi_offset 14, -4
 693 0004 82B0     		sub	sp, sp, #8
 694              		.cfi_def_cfa_offset 32
 303:usb.c         ****     dfuInit();
 695              		.loc 1 303 0
 696 0006 FFF7FEFF 		bl	dfuInit
 697              	.LVL34:
 305:usb.c         ****     pInformation->Current_Configuration = 0;
 698              		.loc 1 305 0
 699 000a 194B     		ldr	r3, .L67
 700 000c 0024     		movs	r4, #0
 701 000e 1B68     		ldr	r3, [r3]
 702              	.LBB22:
 703              	.LBB23:
 255:usb.c         ****     RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
 704              		.loc 1 255 0
 705 0010 184A     		ldr	r2, .L67+4
 706              	.LBE23:
 707              	.LBE22:
 305:usb.c         ****     pInformation->Current_Configuration = 0;
 708              		.loc 1 305 0
 709 0012 9C72     		strb	r4, [r3, #10]
 710              	.LBB25:
 711              	.LBB24:
 255:usb.c         ****     RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
 712              		.loc 1 255 0
 713 0014 D169     		ldr	r1, [r2, #28]
 257:usb.c         ****     _SetCNTR(CNTR_FRES);
 714              		.loc 1 257 0
 715 0016 184D     		ldr	r5, .L67+8
 259:usb.c         ****     _SetISTR(0);
 716              		.loc 1 259 0
 717 0018 DFF86C80 		ldr	r8, .L67+24
 261:usb.c         ****     wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
 718              		.loc 1 261 0
 719 001c 174F     		ldr	r7, .L67+12
 257:usb.c         ****     _SetCNTR(CNTR_FRES);
 720              		.loc 1 257 0
 721 001e 0126     		movs	r6, #1
 261:usb.c         ****     wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
 722              		.loc 1 261 0
 723 0020 4FF4E053 		mov	r3, #7168
 255:usb.c         ****     RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
 724              		.loc 1 255 0
 725 0024 41F40001 		orr	r1, r1, #8388608
 726 0028 D161     		str	r1, [r2, #28]
 269:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 727              		.loc 1 269 0
 728 002a 1548     		ldr	r0, .L67+16
 257:usb.c         ****     _SetCNTR(CNTR_FRES);
 729              		.loc 1 257 0
 730 002c 2E60     		str	r6, [r5]
 269:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 731              		.loc 1 269 0
 732 002e 3246     		mov	r2, r6
 258:usb.c         ****     _SetCNTR(0);
 733              		.loc 1 258 0
 734 0030 2C60     		str	r4, [r5]
 269:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 735              		.loc 1 269 0
 736 0032 0C21     		movs	r1, #12
 259:usb.c         ****     _SetISTR(0);
 737              		.loc 1 259 0
 738 0034 C8F80040 		str	r4, [r8]
 261:usb.c         ****     wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
 739              		.loc 1 261 0
 740 0038 3B80     		strh	r3, [r7]	@ movhi
 262:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 741              		.loc 1 262 0
 742 003a 2B60     		str	r3, [r5]
 269:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 743              		.loc 1 269 0
 744 003c FFF7FEFF 		bl	gpio_write_bit
 745              	.LVL35:
 746              	.LBE24:
 747              	.LBE25:
 309:usb.c         ****     wInterrupt_Mask = ISR_MSK;
 748              		.loc 1 309 0
 749 0040 4FF43F43 		mov	r3, #48896
 308:usb.c         ****     _SetISTR(0);
 750              		.loc 1 308 0
 751 0044 C8F80040 		str	r4, [r8]
 752              	.LBB26:
 753              	.LBB27:
 492:usb.c         **** }
 493:usb.c         **** /***** end of USER STANDARD REQUESTS *****/
 494:usb.c         **** 
 495:usb.c         **** 
 496:usb.c         **** void usbEnbISR(void)
 497:usb.c         **** {
 498:usb.c         ****     NVIC_InitTypeDef NVIC_InitStructure;
 499:usb.c         **** 
 500:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
 754              		.loc 1 500 0
 755 0048 1422     		movs	r2, #20
 756              	.LBE27:
 757              	.LBE26:
 309:usb.c         ****     wInterrupt_Mask = ISR_MSK;
 758              		.loc 1 309 0
 759 004a 3B80     		strh	r3, [r7]	@ movhi
 760              	.LBB30:
 761              	.LBB28:
 501:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 502:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 503:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
 504:usb.c         ****     nvicInit(&NVIC_InitStructure);
 762              		.loc 1 504 0
 763 004c 01A8     		add	r0, sp, #4
 764              	.LBE28:
 765              	.LBE30:
 310:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 766              		.loc 1 310 0
 767 004e 2B60     		str	r3, [r5]
 768              	.LBB31:
 769              	.LBB29:
 501:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 770              		.loc 1 501 0
 771 0050 8DF80540 		strb	r4, [sp, #5]
 502:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 772              		.loc 1 502 0
 773 0054 8DF80640 		strb	r4, [sp, #6]
 503:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelCmd = TRUE;
 774              		.loc 1 503 0
 775 0058 8DF80760 		strb	r6, [sp, #7]
 500:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
 776              		.loc 1 500 0
 777 005c 8DF80420 		strb	r2, [sp, #4]
 778              		.loc 1 504 0
 779 0060 FFF7FEFF 		bl	nvicInit
 780              	.LVL36:
 781              	.LBE29:
 782              	.LBE31:
 314:usb.c         ****     bDeviceState = UNCONNECTED;
 783              		.loc 1 314 0
 784 0064 074B     		ldr	r3, .L67+20
 785 0066 1C60     		str	r4, [r3]
 315:usb.c         **** }
 786              		.loc 1 315 0
 787 0068 02B0     		add	sp, sp, #8
 788              		@ sp needed
 789 006a BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 790              	.L68:
 791 006e 00BF     		.align	2
 792              	.L67:
 793 0070 00000000 		.word	pInformation
 794 0074 00100240 		.word	1073876992
 795 0078 405C0040 		.word	1073765440
 796 007c 00000000 		.word	wInterrupt_Mask
 797 0080 00080140 		.word	1073809408
 798 0084 00000000 		.word	.LANCHOR0
 799 0088 445C0040 		.word	1073765444
 800              		.cfi_endproc
 801              	.LFE9:
 803              		.section	.text.setupUSB,"ax",%progbits
 804              		.align	2
 805              		.global	setupUSB
 806              		.thumb
 807              		.thumb_func
 809              	setupUSB:
 810              	.LFB0:
 109:usb.c         **** {
 811              		.loc 1 109 0
 812              		.cfi_startproc
 813              		@ args = 0, pretend = 0, frame = 8
 814              		@ frame_needed = 0, uses_anonymous_args = 0
 815 0000 30B5     		push	{r4, r5, lr}
 816              		.cfi_def_cfa_offset 12
 817              		.cfi_offset 4, -12
 818              		.cfi_offset 5, -8
 819              		.cfi_offset 14, -4
 133:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 820              		.loc 1 133 0
 821 0002 1648     		ldr	r0, .L77
 109:usb.c         **** {
 822              		.loc 1 109 0
 823 0004 83B0     		sub	sp, sp, #12
 824              		.cfi_def_cfa_offset 24
 133:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 825              		.loc 1 133 0
 826 0006 0C21     		movs	r1, #12
 827 0008 0022     		movs	r2, #0
 134:usb.c         ****     SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 828              		.loc 1 134 0
 829 000a 154C     		ldr	r4, .L77+4
 133:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 830              		.loc 1 133 0
 831 000c FFF7FEFF 		bl	gpio_write_bit
 832              	.LVL37:
 134:usb.c         ****     SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 833              		.loc 1 134 0
 834 0010 0C20     		movs	r0, #12
 835 0012 2568     		ldr	r5, [r4]
 836 0014 FFF7FEFF 		bl	crMask
 837              	.LVL38:
 838 0018 2840     		ands	r0, r0, r5
 142:usb.c         ****     for(delay = 256; delay; delay--);
 839              		.loc 1 142 0
 840 001a 4FF48073 		mov	r3, #256
 134:usb.c         ****     SET_REG(GPIO_CR(USB_DISC_BANK, USB_DISC_PIN),
 841              		.loc 1 134 0
 842 001e 40F48035 		orr	r5, r0, #65536
 843 0022 2560     		str	r5, [r4]
 142:usb.c         ****     for(delay = 256; delay; delay--);
 844              		.loc 1 142 0
 845 0024 0193     		str	r3, [sp, #4]
 846 0026 019B     		ldr	r3, [sp, #4]
 847 0028 2BB1     		cbz	r3, .L71
 848              	.L72:
 142:usb.c         ****     for(delay = 256; delay; delay--);
 849              		.loc 1 142 0 is_stmt 0 discriminator 2
 850 002a 019B     		ldr	r3, [sp, #4]
 851 002c 013B     		subs	r3, r3, #1
 852 002e 0193     		str	r3, [sp, #4]
 853 0030 019B     		ldr	r3, [sp, #4]
 854 0032 002B     		cmp	r3, #0
 855 0034 F9D1     		bne	.L72
 856              	.L71:
 149:usb.c         ****   wTransferSize = getFlashPageSize();
 857              		.loc 1 149 0 is_stmt 1
 858 0036 FFF7FEFF 		bl	getFlashPageSize
 859              	.LVL39:
 150:usb.c         ****   u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
 860              		.loc 1 150 0
 861 003a 0A4C     		ldr	r4, .L77+8
 153:usb.c         ****   u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
 862              		.loc 1 153 0
 863 003c 0A4B     		ldr	r3, .L77+12
 149:usb.c         ****   wTransferSize = getFlashPageSize();
 864              		.loc 1 149 0
 865 003e 0B4D     		ldr	r5, .L77+16
 150:usb.c         ****   u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
 866              		.loc 1 150 0
 867 0040 C1B2     		uxtb	r1, r0
 151:usb.c         ****   u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
 868              		.loc 1 151 0
 869 0042 C0F30722 		ubfx	r2, r0, #8, #8
 149:usb.c         ****   wTransferSize = getFlashPageSize();
 870              		.loc 1 149 0
 871 0046 2860     		str	r0, [r5]
 150:usb.c         ****   u8_usbConfigDescriptorDFU[41] = (wTransferSize & 0x00FF);
 872              		.loc 1 150 0
 873 0048 84F82910 		strb	r1, [r4, #41]
 151:usb.c         ****   u8_usbConfigDescriptorDFU[42] = (wTransferSize & 0xFF00) >> 8;
 874              		.loc 1 151 0
 875 004c 84F82A20 		strb	r2, [r4, #42]
 153:usb.c         ****   u8_usbFunctionalDescriptor[5] = (wTransferSize & 0x00FF);
 876              		.loc 1 153 0
 877 0050 5971     		strb	r1, [r3, #5]
 154:usb.c         ****   u8_usbFunctionalDescriptor[6] = (wTransferSize & 0xFF00) >> 8;  
 878              		.loc 1 154 0
 879 0052 9A71     		strb	r2, [r3, #6]
 880              	.LBB32:
 881              	.LBB33:
 176:usb.c         ****     USB_Init();
 882              		.loc 1 176 0
 883 0054 FFF7FEFF 		bl	USB_Init
 884              	.LVL40:
 885              	.LBE33:
 886              	.LBE32:
 157:usb.c         **** }
 887              		.loc 1 157 0
 888 0058 03B0     		add	sp, sp, #12
 889              		@ sp needed
 890 005a 30BD     		pop	{r4, r5, pc}
 891              	.L78:
 892              		.align	2
 893              	.L77:
 894 005c 00080140 		.word	1073809408
 895 0060 04080140 		.word	1073809412
 896 0064 00000000 		.word	u8_usbConfigDescriptorDFU
 897 0068 00000000 		.word	u8_usbFunctionalDescriptor
 898 006c 00000000 		.word	wTransferSize
 899              		.cfi_endproc
 900              	.LFE0:
 902              		.section	.text.usbDsbBus,"ax",%progbits
 903              		.align	2
 904              		.global	usbDsbBus
 905              		.thumb
 906              		.thumb_func
 908              	usbDsbBus:
 909              	.LFB1:
 161:usb.c         **** {
 910              		.loc 1 161 0
 911              		.cfi_startproc
 912              		@ args = 0, pretend = 0, frame = 0
 913              		@ frame_needed = 0, uses_anonymous_args = 0
 914              	.LBB36:
 915              	.LBB37:
 277:usb.c         ****     _SetCNTR(CNTR_FRES);
 916              		.loc 1 277 0
 917 0000 0A4B     		ldr	r3, .L80
 278:usb.c         ****     _SetISTR(0);
 918              		.loc 1 278 0
 919 0002 0B48     		ldr	r0, .L80+4
 920 0004 0021     		movs	r1, #0
 277:usb.c         ****     _SetCNTR(CNTR_FRES);
 921              		.loc 1 277 0
 922 0006 0122     		movs	r2, #1
 923              	.LBE37:
 924              	.LBE36:
 161:usb.c         **** {
 925              		.loc 1 161 0
 926 0008 10B5     		push	{r4, lr}
 927              		.cfi_def_cfa_offset 8
 928              		.cfi_offset 4, -8
 929              		.cfi_offset 14, -4
 930              	.LBB39:
 931              	.LBB38:
 277:usb.c         ****     _SetCNTR(CNTR_FRES);
 932              		.loc 1 277 0
 933 000a 1A60     		str	r2, [r3]
 279:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 934              		.loc 1 279 0
 935 000c 0324     		movs	r4, #3
 278:usb.c         ****     _SetISTR(0);
 936              		.loc 1 278 0
 937 000e 0160     		str	r1, [r0]
 291:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 938              		.loc 1 291 0
 939 0010 00F52B40 		add	r0, r0, #43776
 940 0014 0A46     		mov	r2, r1
 279:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 941              		.loc 1 279 0
 942 0016 1C60     		str	r4, [r3]
 291:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 943              		.loc 1 291 0
 944 0018 BC30     		adds	r0, r0, #188
 945 001a 0C21     		movs	r1, #12
 946 001c FFF7FEFF 		bl	gpio_write_bit
 947              	.LVL41:
 296:usb.c         ****     RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
 948              		.loc 1 296 0
 949 0020 044B     		ldr	r3, .L80+8
 950 0022 DA69     		ldr	r2, [r3, #28]
 951 0024 22F40002 		bic	r2, r2, #8388608
 952 0028 DA61     		str	r2, [r3, #28]
 953 002a 10BD     		pop	{r4, pc}
 954              	.L81:
 955              		.align	2
 956              	.L80:
 957 002c 405C0040 		.word	1073765440
 958 0030 445C0040 		.word	1073765444
 959 0034 00100240 		.word	1073876992
 960              	.LBE38:
 961              	.LBE39:
 962              		.cfi_endproc
 963              	.LFE1:
 965              		.section	.text.usbAppInit,"ax",%progbits
 966              		.align	2
 967              		.global	usbAppInit
 968              		.thumb
 969              		.thumb_func
 971              	usbAppInit:
 972              	.LFB3:
 174:usb.c         **** {
 973              		.loc 1 174 0
 974              		.cfi_startproc
 975              		@ args = 0, pretend = 0, frame = 0
 976              		@ frame_needed = 0, uses_anonymous_args = 0
 977              		@ link register save eliminated.
 176:usb.c         ****     USB_Init();
 978              		.loc 1 176 0
 979 0000 FFF7FEBF 		b	USB_Init
 980              	.LVL42:
 981              		.cfi_endproc
 982              	.LFE3:
 984              		.section	.text.usbSuspend,"ax",%progbits
 985              		.align	2
 986              		.global	usbSuspend
 987              		.thumb
 988              		.thumb_func
 990              	usbSuspend:
 991              	.LFB4:
 180:usb.c         **** {
 992              		.loc 1 180 0
 993              		.cfi_startproc
 994              		@ args = 0, pretend = 0, frame = 0
 995              		@ frame_needed = 0, uses_anonymous_args = 0
 996              		@ link register save eliminated.
 182:usb.c         ****     wCNTR = _GetCNTR();
 997              		.loc 1 182 0
 998 0000 044B     		ldr	r3, .L84
 187:usb.c         ****     bDeviceState = SUSPENDED;
 999              		.loc 1 187 0
 1000 0002 054A     		ldr	r2, .L84+4
 182:usb.c         ****     wCNTR = _GetCNTR();
 1001              		.loc 1 182 0
 1002 0004 1868     		ldr	r0, [r3]
 187:usb.c         ****     bDeviceState = SUSPENDED;
 1003              		.loc 1 187 0
 1004 0006 0321     		movs	r1, #3
 182:usb.c         ****     wCNTR = _GetCNTR();
 1005              		.loc 1 182 0
 1006 0008 80B2     		uxth	r0, r0
 1007              	.LVL43:
 184:usb.c         ****     _SetCNTR(wCNTR);
 1008              		.loc 1 184 0
 1009 000a 40F00C00 		orr	r0, r0, #12
 1010              	.LVL44:
 1011 000e 1860     		str	r0, [r3]
 187:usb.c         ****     bDeviceState = SUSPENDED;
 1012              		.loc 1 187 0
 1013 0010 1160     		str	r1, [r2]
 1014 0012 7047     		bx	lr
 1015              	.L85:
 1016              		.align	2
 1017              	.L84:
 1018 0014 405C0040 		.word	1073765440
 1019 0018 00000000 		.word	.LANCHOR0
 1020              		.cfi_endproc
 1021              	.LFE4:
 1023              		.section	.text.usbResumeInit,"ax",%progbits
 1024              		.align	2
 1025              		.global	usbResumeInit
 1026              		.thumb
 1027              		.thumb_func
 1029              	usbResumeInit:
 1030              	.LFB5:
 191:usb.c         **** {
 1031              		.loc 1 191 0
 1032              		.cfi_startproc
 1033              		@ args = 0, pretend = 0, frame = 0
 1034              		@ frame_needed = 0, uses_anonymous_args = 0
 1035              		@ link register save eliminated.
 195:usb.c         ****     wCNTR = _GetCNTR();
 1036              		.loc 1 195 0
 1037 0000 044B     		ldr	r3, .L87
 197:usb.c         ****     _SetCNTR(wCNTR);
 1038              		.loc 1 197 0
 1039 0002 4FF6FB72 		movw	r2, #65531
 195:usb.c         ****     wCNTR = _GetCNTR();
 1040              		.loc 1 195 0
 1041 0006 1868     		ldr	r0, [r3]
 1042              	.LVL45:
 200:usb.c         ****     _SetCNTR(ISR_MSK);
 1043              		.loc 1 200 0
 1044 0008 4FF43F41 		mov	r1, #48896
 197:usb.c         ****     _SetCNTR(wCNTR);
 1045              		.loc 1 197 0
 1046 000c 0240     		ands	r2, r2, r0
 1047 000e 1A60     		str	r2, [r3]
 200:usb.c         ****     _SetCNTR(ISR_MSK);
 1048              		.loc 1 200 0
 1049 0010 1960     		str	r1, [r3]
 1050 0012 7047     		bx	lr
 1051              	.L88:
 1052              		.align	2
 1053              	.L87:
 1054 0014 405C0040 		.word	1073765440
 1055              		.cfi_endproc
 1056              	.LFE5:
 1058              		.section	.text.usbResume,"ax",%progbits
 1059              		.align	2
 1060              		.global	usbResume
 1061              		.thumb
 1062              		.thumb_func
 1064              	usbResume:
 1065              	.LFB6:
 204:usb.c         **** {
 1066              		.loc 1 204 0
 1067              		.cfi_startproc
 1068              		@ args = 0, pretend = 0, frame = 0
 1069              		@ frame_needed = 0, uses_anonymous_args = 0
 1070              		@ link register save eliminated.
 1071              	.LVL46:
 208:usb.c         ****         ResumeS.eState = eResumeSetVal;
 1072              		.loc 1 208 0
 1073 0000 2F4B     		ldr	r3, .L105
 207:usb.c         ****     if (eResumeSetVal != RESUME_ESOF)
 1074              		.loc 1 207 0
 1075 0002 0728     		cmp	r0, #7
 204:usb.c         **** {
 1076              		.loc 1 204 0
 1077 0004 10B4     		push	{r4}
 1078              		.cfi_def_cfa_offset 4
 1079              		.cfi_offset 4, -4
 208:usb.c         ****         ResumeS.eState = eResumeSetVal;
 1080              		.loc 1 208 0
 1081 0006 18BF     		it	ne
 1082 0008 1870     		strbne	r0, [r3]
 210:usb.c         ****     switch (ResumeS.eState) {
 1083              		.loc 1 210 0
 1084 000a 1A78     		ldrb	r2, [r3]	@ zero_extendqisi2
 1085 000c 052A     		cmp	r2, #5
 1086 000e 51D8     		bhi	.L91
 1087 0010 DFE802F0 		tbb	[pc, r2]
 1088              	.L93:
 1089 0014 15       		.byte	(.L92-.L93)/2
 1090 0015 23       		.byte	(.L94-.L93)/2
 1091 0016 31       		.byte	(.L95-.L93)/2
 1092 0017 38       		.byte	(.L96-.L93)/2
 1093 0018 43       		.byte	(.L97-.L93)/2
 1094 0019 03       		.byte	(.L98-.L93)/2
 1095              		.p2align 1
 1096              	.L98:
 236:usb.c         ****         ResumeS.bESOFcnt--;
 1097              		.loc 1 236 0
 1098 001a 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 1099 001c 2849     		ldr	r1, .L105
 1100 001e 013A     		subs	r2, r2, #1
 1101 0020 D2B2     		uxtb	r2, r2
 1102 0022 5A70     		strb	r2, [r3, #1]
 237:usb.c         ****         if (ResumeS.bESOFcnt == 0) {
 1103              		.loc 1 237 0
 1104 0024 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1105 0026 3BB9     		cbnz	r3, .L89
 238:usb.c         ****             wCNTR = _GetCNTR();
 1106              		.loc 1 238 0
 1107 0028 264A     		ldr	r2, .L105+4
 240:usb.c         ****             _SetCNTR(wCNTR);
 1108              		.loc 1 240 0
 1109 002a 4FF6EF73 		movw	r3, #65519
 238:usb.c         ****             wCNTR = _GetCNTR();
 1110              		.loc 1 238 0
 1111 002e 1468     		ldr	r4, [r2]
 1112              	.LVL47:
 241:usb.c         ****             ResumeS.eState = RESUME_OFF;
 1113              		.loc 1 241 0
 1114 0030 0620     		movs	r0, #6
 1115              	.LVL48:
 240:usb.c         ****             _SetCNTR(wCNTR);
 1116              		.loc 1 240 0
 1117 0032 2340     		ands	r3, r3, r4
 1118 0034 1360     		str	r3, [r2]
 241:usb.c         ****             ResumeS.eState = RESUME_OFF;
 1119              		.loc 1 241 0
 1120 0036 0870     		strb	r0, [r1]
 1121              	.LVL49:
 1122              	.L89:
 250:usb.c         **** }
 1123              		.loc 1 250 0
 1124 0038 5DF8044B 		ldr	r4, [sp], #4
 1125 003c 7047     		bx	lr
 1126              	.LVL50:
 1127              	.L92:
 1128              	.LBB40:
 1129              	.LBB41:
 195:usb.c         ****     wCNTR = _GetCNTR();
 1130              		.loc 1 195 0
 1131 003e 214A     		ldr	r2, .L105+4
 197:usb.c         ****     _SetCNTR(wCNTR);
 1132              		.loc 1 197 0
 1133 0040 4FF6FB71 		movw	r1, #65531
 195:usb.c         ****     wCNTR = _GetCNTR();
 1134              		.loc 1 195 0
 1135 0044 1068     		ldr	r0, [r2]
 1136              	.LVL51:
 200:usb.c         ****     _SetCNTR(ISR_MSK);
 1137              		.loc 1 200 0
 1138 0046 4FF43F44 		mov	r4, #48896
 197:usb.c         ****     _SetCNTR(wCNTR);
 1139              		.loc 1 197 0
 1140 004a 0140     		ands	r1, r1, r0
 1141              	.LBE41:
 1142              	.LBE40:
 213:usb.c         ****         ResumeS.eState = RESUME_OFF;
 1143              		.loc 1 213 0
 1144 004c 0620     		movs	r0, #6
 1145              	.LVL52:
 1146              	.LBB43:
 1147              	.LBB42:
 197:usb.c         ****     _SetCNTR(wCNTR);
 1148              		.loc 1 197 0
 1149 004e 1160     		str	r1, [r2]
 200:usb.c         ****     _SetCNTR(ISR_MSK);
 1150              		.loc 1 200 0
 1151 0050 1460     		str	r4, [r2]
 1152              	.LBE42:
 1153              	.LBE43:
 213:usb.c         ****         ResumeS.eState = RESUME_OFF;
 1154              		.loc 1 213 0
 1155 0052 1870     		strb	r0, [r3]
 250:usb.c         **** }
 1156              		.loc 1 250 0
 1157 0054 5DF8044B 		ldr	r4, [sp], #4
 1158 0058 7047     		bx	lr
 1159              	.LVL53:
 1160              	.L94:
 1161              	.LBB44:
 1162              	.LBB45:
 195:usb.c         ****     wCNTR = _GetCNTR();
 1163              		.loc 1 195 0
 1164 005a 1A4A     		ldr	r2, .L105+4
 197:usb.c         ****     _SetCNTR(wCNTR);
 1165              		.loc 1 197 0
 1166 005c 4FF6FB71 		movw	r1, #65531
 195:usb.c         ****     wCNTR = _GetCNTR();
 1167              		.loc 1 195 0
 1168 0060 1068     		ldr	r0, [r2]
 1169              	.LVL54:
 200:usb.c         ****     _SetCNTR(ISR_MSK);
 1170              		.loc 1 200 0
 1171 0062 4FF43F44 		mov	r4, #48896
 197:usb.c         ****     _SetCNTR(wCNTR);
 1172              		.loc 1 197 0
 1173 0066 0140     		ands	r1, r1, r0
 1174              	.LBE45:
 1175              	.LBE44:
 217:usb.c         ****         ResumeS.eState = RESUME_START;
 1176              		.loc 1 217 0
 1177 0068 0420     		movs	r0, #4
 1178              	.LVL55:
 1179              	.LBB47:
 1180              	.LBB46:
 197:usb.c         ****     _SetCNTR(wCNTR);
 1181              		.loc 1 197 0
 1182 006a 1160     		str	r1, [r2]
 200:usb.c         ****     _SetCNTR(ISR_MSK);
 1183              		.loc 1 200 0
 1184 006c 1460     		str	r4, [r2]
 1185              	.LBE46:
 1186              	.LBE47:
 217:usb.c         ****         ResumeS.eState = RESUME_START;
 1187              		.loc 1 217 0
 1188 006e 1870     		strb	r0, [r3]
 250:usb.c         **** }
 1189              		.loc 1 250 0
 1190 0070 5DF8044B 		ldr	r4, [sp], #4
 1191 0074 7047     		bx	lr
 1192              	.LVL56:
 1193              	.L95:
 220:usb.c         ****         ResumeS.bESOFcnt = 2;
 1194              		.loc 1 220 0
 1195 0076 0221     		movs	r1, #2
 1196 0078 5970     		strb	r1, [r3, #1]
 221:usb.c         ****         ResumeS.eState = RESUME_WAIT;
 1197              		.loc 1 221 0
 1198 007a 0322     		movs	r2, #3
 1199 007c 1A70     		strb	r2, [r3]
 250:usb.c         **** }
 1200              		.loc 1 250 0
 1201 007e 5DF8044B 		ldr	r4, [sp], #4
 1202 0082 7047     		bx	lr
 1203              	.L96:
 224:usb.c         ****         ResumeS.bESOFcnt--;
 1204              		.loc 1 224 0
 1205 0084 5A78     		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 1206 0086 0E49     		ldr	r1, .L105
 1207 0088 013A     		subs	r2, r2, #1
 1208 008a D2B2     		uxtb	r2, r2
 1209 008c 5A70     		strb	r2, [r3, #1]
 225:usb.c         ****         if (ResumeS.bESOFcnt == 0)
 1210              		.loc 1 225 0
 1211 008e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1212 0090 002B     		cmp	r3, #0
 1213 0092 D1D1     		bne	.L89
 226:usb.c         ****             ResumeS.eState = RESUME_START;
 1214              		.loc 1 226 0
 1215 0094 0423     		movs	r3, #4
 1216 0096 0B70     		strb	r3, [r1]
 1217 0098 CEE7     		b	.L89
 1218              	.L97:
 229:usb.c         ****         wCNTR = _GetCNTR();
 1219              		.loc 1 229 0
 1220 009a 0A4A     		ldr	r2, .L105+4
 232:usb.c         ****         ResumeS.eState = RESUME_ON;
 1221              		.loc 1 232 0
 1222 009c 0520     		movs	r0, #5
 1223              	.LVL57:
 229:usb.c         ****         wCNTR = _GetCNTR();
 1224              		.loc 1 229 0
 1225 009e 1468     		ldr	r4, [r2]
 233:usb.c         ****         ResumeS.bESOFcnt = 10;
 1226              		.loc 1 233 0
 1227 00a0 0A21     		movs	r1, #10
 229:usb.c         ****         wCNTR = _GetCNTR();
 1228              		.loc 1 229 0
 1229 00a2 A4B2     		uxth	r4, r4
 1230              	.LVL58:
 231:usb.c         ****         _SetCNTR(wCNTR);
 1231              		.loc 1 231 0
 1232 00a4 44F01004 		orr	r4, r4, #16
 1233              	.LVL59:
 1234 00a8 1460     		str	r4, [r2]
 232:usb.c         ****         ResumeS.eState = RESUME_ON;
 1235              		.loc 1 232 0
 1236 00aa 1870     		strb	r0, [r3]
 233:usb.c         ****         ResumeS.bESOFcnt = 10;
 1237              		.loc 1 233 0
 1238 00ac 5970     		strb	r1, [r3, #1]
 250:usb.c         **** }
 1239              		.loc 1 250 0
 1240 00ae 5DF8044B 		ldr	r4, [sp], #4
 1241 00b2 7047     		bx	lr
 1242              	.LVL60:
 1243              	.L91:
 247:usb.c         ****         ResumeS.eState = RESUME_OFF;
 1244              		.loc 1 247 0
 1245 00b4 0622     		movs	r2, #6
 1246 00b6 1A70     		strb	r2, [r3]
 250:usb.c         **** }
 1247              		.loc 1 250 0
 1248 00b8 5DF8044B 		ldr	r4, [sp], #4
 1249 00bc 7047     		bx	lr
 1250              	.L106:
 1251 00be 00BF     		.align	2
 1252              	.L105:
 1253 00c0 00000000 		.word	ResumeS
 1254 00c4 405C0040 		.word	1073765440
 1255              		.cfi_endproc
 1256              	.LFE6:
 1258              		.section	.text.usbPowerOn,"ax",%progbits
 1259              		.align	2
 1260              		.global	usbPowerOn
 1261              		.thumb
 1262              		.thumb_func
 1264              	usbPowerOn:
 1265              	.LFB7:
 253:usb.c         **** {
 1266              		.loc 1 253 0
 1267              		.cfi_startproc
 1268              		@ args = 0, pretend = 0, frame = 0
 1269              		@ frame_needed = 0, uses_anonymous_args = 0
 255:usb.c         ****     RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
 1270              		.loc 1 255 0
 1271 0000 0C4A     		ldr	r2, .L108
 253:usb.c         **** {
 1272              		.loc 1 253 0
 1273 0002 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1274              		.cfi_def_cfa_offset 24
 1275              		.cfi_offset 3, -24
 1276              		.cfi_offset 4, -20
 1277              		.cfi_offset 5, -16
 1278              		.cfi_offset 6, -12
 1279              		.cfi_offset 7, -8
 1280              		.cfi_offset 14, -4
 255:usb.c         ****     RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
 1281              		.loc 1 255 0
 1282 0004 D069     		ldr	r0, [r2, #28]
 257:usb.c         ****     _SetCNTR(CNTR_FRES);
 1283              		.loc 1 257 0
 1284 0006 0C4B     		ldr	r3, .L108+4
 259:usb.c         ****     _SetISTR(0);
 1285              		.loc 1 259 0
 1286 0008 0C4F     		ldr	r7, .L108+8
 261:usb.c         ****     wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
 1287              		.loc 1 261 0
 1288 000a 0D4E     		ldr	r6, .L108+12
 258:usb.c         ****     _SetCNTR(0);
 1289              		.loc 1 258 0
 1290 000c 0024     		movs	r4, #0
 257:usb.c         ****     _SetCNTR(CNTR_FRES);
 1291              		.loc 1 257 0
 1292 000e 0121     		movs	r1, #1
 261:usb.c         ****     wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
 1293              		.loc 1 261 0
 1294 0010 4FF4E055 		mov	r5, #7168
 255:usb.c         ****     RCC_Blot->APB1ENR |= RCC_APB1ENR_USB_CLK;
 1295              		.loc 1 255 0
 1296 0014 40F40000 		orr	r0, r0, #8388608
 1297 0018 D061     		str	r0, [r2, #28]
 257:usb.c         ****     _SetCNTR(CNTR_FRES);
 1298              		.loc 1 257 0
 1299 001a 1960     		str	r1, [r3]
 269:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 1300              		.loc 1 269 0
 1301 001c 0A46     		mov	r2, r1
 258:usb.c         ****     _SetCNTR(0);
 1302              		.loc 1 258 0
 1303 001e 1C60     		str	r4, [r3]
 269:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 1304              		.loc 1 269 0
 1305 0020 0848     		ldr	r0, .L108+16
 259:usb.c         ****     _SetISTR(0);
 1306              		.loc 1 259 0
 1307 0022 3C60     		str	r4, [r7]
 269:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 1308              		.loc 1 269 0
 1309 0024 0C21     		movs	r1, #12
 261:usb.c         ****     wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM; /* the bare minimum */
 1310              		.loc 1 261 0
 1311 0026 3580     		strh	r5, [r6]	@ movhi
 262:usb.c         ****     _SetCNTR(wInterrupt_Mask);
 1312              		.loc 1 262 0
 1313 0028 1D60     		str	r5, [r3]
 269:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 1);
 1314              		.loc 1 269 0
 1315 002a FFF7FEFF 		bl	gpio_write_bit
 1316              	.LVL61:
 274:usb.c         **** }
 1317              		.loc 1 274 0
 1318 002e 2046     		mov	r0, r4
 1319 0030 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1320              	.L109:
 1321 0032 00BF     		.align	2
 1322              	.L108:
 1323 0034 00100240 		.word	1073876992
 1324 0038 405C0040 		.word	1073765440
 1325 003c 445C0040 		.word	1073765444
 1326 0040 00000000 		.word	wInterrupt_Mask
 1327 0044 00080140 		.word	1073809408
 1328              		.cfi_endproc
 1329              	.LFE7:
 1331              		.section	.text.usbPowerOff,"ax",%progbits
 1332              		.align	2
 1333              		.global	usbPowerOff
 1334              		.thumb
 1335              		.thumb_func
 1337              	usbPowerOff:
 1338              	.LFB8:
 276:usb.c         **** RESULT usbPowerOff(void) {
 1339              		.loc 1 276 0
 1340              		.cfi_startproc
 1341              		@ args = 0, pretend = 0, frame = 0
 1342              		@ frame_needed = 0, uses_anonymous_args = 0
 277:usb.c         ****     _SetCNTR(CNTR_FRES);
 1343              		.loc 1 277 0
 1344 0000 0B4B     		ldr	r3, .L111
 278:usb.c         ****     _SetISTR(0);
 1345              		.loc 1 278 0
 1346 0002 0C48     		ldr	r0, .L111+4
 276:usb.c         **** RESULT usbPowerOff(void) {
 1347              		.loc 1 276 0
 1348 0004 10B5     		push	{r4, lr}
 1349              		.cfi_def_cfa_offset 8
 1350              		.cfi_offset 4, -8
 1351              		.cfi_offset 14, -4
 277:usb.c         ****     _SetCNTR(CNTR_FRES);
 1352              		.loc 1 277 0
 1353 0006 0122     		movs	r2, #1
 278:usb.c         ****     _SetISTR(0);
 1354              		.loc 1 278 0
 1355 0008 0024     		movs	r4, #0
 277:usb.c         ****     _SetCNTR(CNTR_FRES);
 1356              		.loc 1 277 0
 1357 000a 1A60     		str	r2, [r3]
 279:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 1358              		.loc 1 279 0
 1359 000c 0321     		movs	r1, #3
 278:usb.c         ****     _SetISTR(0);
 1360              		.loc 1 278 0
 1361 000e 0460     		str	r4, [r0]
 291:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 1362              		.loc 1 291 0
 1363 0010 00F52B40 		add	r0, r0, #43776
 1364 0014 2246     		mov	r2, r4
 279:usb.c         ****     _SetCNTR(CNTR_FRES + CNTR_PDWN);
 1365              		.loc 1 279 0
 1366 0016 1960     		str	r1, [r3]
 291:usb.c         ****     gpio_write_bit(USB_DISC_BANK, USB_DISC_PIN, 0);
 1367              		.loc 1 291 0
 1368 0018 BC30     		adds	r0, r0, #188
 1369 001a 0C21     		movs	r1, #12
 1370 001c FFF7FEFF 		bl	gpio_write_bit
 1371              	.LVL62:
 296:usb.c         ****     RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
 1372              		.loc 1 296 0
 1373 0020 054B     		ldr	r3, .L111+8
 299:usb.c         **** }
 1374              		.loc 1 299 0
 1375 0022 2046     		mov	r0, r4
 296:usb.c         ****     RCC_Blot->APB1ENR &= ~RCC_APB1ENR_USB_CLK;
 1376              		.loc 1 296 0
 1377 0024 DA69     		ldr	r2, [r3, #28]
 1378 0026 22F40002 		bic	r2, r2, #8388608
 1379 002a DA61     		str	r2, [r3, #28]
 299:usb.c         **** }
 1380              		.loc 1 299 0
 1381 002c 10BD     		pop	{r4, pc}
 1382              	.L112:
 1383 002e 00BF     		.align	2
 1384              	.L111:
 1385 0030 405C0040 		.word	1073765440
 1386 0034 445C0040 		.word	1073765444
 1387 0038 00100240 		.word	1073876992
 1388              		.cfi_endproc
 1389              	.LFE8:
 1391              		.section	.text.usbEnbISR,"ax",%progbits
 1392              		.align	2
 1393              		.global	usbEnbISR
 1394              		.thumb
 1395              		.thumb_func
 1397              	usbEnbISR:
 1398              	.LFB29:
 497:usb.c         **** {
 1399              		.loc 1 497 0
 1400              		.cfi_startproc
 1401              		@ args = 0, pretend = 0, frame = 8
 1402              		@ frame_needed = 0, uses_anonymous_args = 0
 1403 0000 00B5     		push	{lr}
 1404              		.cfi_def_cfa_offset 4
 1405              		.cfi_offset 14, -4
 500:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
 1406              		.loc 1 500 0
 1407 0002 054B     		ldr	r3, .L114
 497:usb.c         **** {
 1408              		.loc 1 497 0
 1409 0004 83B0     		sub	sp, sp, #12
 1410              		.cfi_def_cfa_offset 16
 500:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
 1411              		.loc 1 500 0
 1412 0006 02A8     		add	r0, sp, #8
 1413 0008 40F8043D 		str	r3, [r0, #-4]!
 1414              		.loc 1 504 0
 1415 000c FFF7FEFF 		bl	nvicInit
 1416              	.LVL63:
 505:usb.c         **** }
 1417              		.loc 1 505 0
 1418 0010 03B0     		add	sp, sp, #12
 1419              		@ sp needed
 1420 0012 5DF804FB 		ldr	pc, [sp], #4
 1421              	.L115:
 1422 0016 00BF     		.align	2
 1423              	.L114:
 1424 0018 14000001 		.word	16777236
 1425              		.cfi_endproc
 1426              	.LFE29:
 1428              		.section	.text.usbDsbISR,"ax",%progbits
 1429              		.align	2
 1430              		.global	usbDsbISR
 1431              		.thumb
 1432              		.thumb_func
 1434              	usbDsbISR:
 1435              	.LFB30:
 506:usb.c         **** 
 507:usb.c         **** void usbDsbISR(void)
 508:usb.c         **** {
 1436              		.loc 1 508 0
 1437              		.cfi_startproc
 1438              		@ args = 0, pretend = 0, frame = 8
 1439              		@ frame_needed = 0, uses_anonymous_args = 0
 1440 0000 00B5     		push	{lr}
 1441              		.cfi_def_cfa_offset 4
 1442              		.cfi_offset 14, -4
 1443 0002 83B0     		sub	sp, sp, #12
 1444              		.cfi_def_cfa_offset 16
 509:usb.c         ****     NVIC_InitTypeDef NVIC_InitStructure;
 510:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannel = USB_LP_IRQ;
 1445              		.loc 1 510 0
 1446 0004 1423     		movs	r3, #20
 1447 0006 02A8     		add	r0, sp, #8
 1448 0008 40F8043D 		str	r3, [r0, #-4]!
 511:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
 512:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelSubPriority = 0;
 513:usb.c         ****     NVIC_InitStructure.NVIC_IRQChannelCmd = FALSE;
 514:usb.c         ****     nvicInit(&NVIC_InitStructure);
 1449              		.loc 1 514 0
 1450 000c FFF7FEFF 		bl	nvicInit
 1451              	.LVL64:
 515:usb.c         **** }
 1452              		.loc 1 515 0
 1453 0010 03B0     		add	sp, sp, #12
 1454              		@ sp needed
 1455 0012 5DF804FB 		ldr	pc, [sp], #4
 1456              		.cfi_endproc
 1457              	.LFE30:
 1459 0016 00BF     		.section	.text.USB_LP_CAN1_RX0_IRQHandler,"ax",%progbits
 1460              		.align	2
 1461              		.global	USB_LP_CAN1_RX0_IRQHandler
 1462              		.thumb
 1463              		.thumb_func
 1465              	USB_LP_CAN1_RX0_IRQHandler:
 1466              	.LFB31:
 516:usb.c         **** 
 517:usb.c         **** void USB_LP_CAN1_RX0_IRQHandler(void)
 518:usb.c         **** {
 1467              		.loc 1 518 0
 1468              		.cfi_startproc
 1469              		@ args = 0, pretend = 0, frame = 0
 1470              		@ frame_needed = 0, uses_anonymous_args = 0
 1471 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1472              		.cfi_def_cfa_offset 24
 1473              		.cfi_offset 3, -24
 1474              		.cfi_offset 4, -20
 1475              		.cfi_offset 5, -16
 1476              		.cfi_offset 6, -12
 1477              		.cfi_offset 7, -8
 1478              		.cfi_offset 14, -4
 519:usb.c         ****     wIstr = _GetISTR();
 1479              		.loc 1 519 0
 1480 0002 314B     		ldr	r3, .L145
 1481 0004 314C     		ldr	r4, .L145+4
 1482 0006 1B68     		ldr	r3, [r3]
 520:usb.c         **** 
 521:usb.c         ****     /* go nuts with the preproc switches since this is an ISTR and must be FAST */
 522:usb.c         ****     /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
 523:usb.c         **** #if (ISR_MSK & ISTR_CTR)
 524:usb.c         ****     if (wIstr & ISTR_CTR & wInterrupt_Mask) {
 1483              		.loc 1 524 0
 1484 0008 314D     		ldr	r5, .L145+8
 519:usb.c         ****     wIstr = _GetISTR();
 1485              		.loc 1 519 0
 1486 000a 9BB2     		uxth	r3, r3
 1487 000c 2380     		strh	r3, [r4]	@ movhi
 1488              		.loc 1 524 0
 1489 000e 2288     		ldrh	r2, [r4]
 1490 0010 2B88     		ldrh	r3, [r5]
 1491 0012 1A40     		ands	r2, r2, r3
 1492 0014 1204     		lsls	r2, r2, #16
 1493 0016 53D4     		bmi	.L141
 1494              	.L118:
 525:usb.c         ****         /* servicing of the endpoint correct transfer interrupt */
 526:usb.c         ****         /* clear of the CTR flag into the sub */
 527:usb.c         ****         CTR_LP(); /* low priority ISR defined in the usb core lib */
 528:usb.c         ****     }
 529:usb.c         **** #endif
 530:usb.c         **** 
 531:usb.c         **** #if (ISR_MSK & ISTR_RESET)
 532:usb.c         ****     if (wIstr & ISTR_RESET & wInterrupt_Mask) {
 1495              		.loc 1 532 0
 1496 0018 2288     		ldrh	r2, [r4]
 1497 001a 02F48062 		and	r2, r2, #1024
 1498 001e 1342     		tst	r3, r2
 1499 0020 45D1     		bne	.L142
 1500              	.L119:
 533:usb.c         ****         _SetISTR((u16)CLR_RESET);
 534:usb.c         ****         Device_Property.Reset();
 535:usb.c         ****     }
 536:usb.c         **** #endif
 537:usb.c         **** 
 538:usb.c         **** 
 539:usb.c         **** #if (ISR_MSK & ISTR_DOVR)
 540:usb.c         ****     if (wIstr & ISTR_DOVR & wInterrupt_Mask) {
 541:usb.c         ****         _SetISTR((u16)CLR_DOVR);
 542:usb.c         ****     }
 543:usb.c         **** #endif
 544:usb.c         **** 
 545:usb.c         **** 
 546:usb.c         **** #if (ISR_MSK & ISTR_ERR)
 547:usb.c         ****     if (wIstr & ISTR_ERR & wInterrupt_Mask) {
 1501              		.loc 1 547 0
 1502 0022 2288     		ldrh	r2, [r4]
 1503 0024 02F40052 		and	r2, r2, #8192
 1504 0028 1342     		tst	r3, r2
 1505 002a 03D0     		beq	.L120
 548:usb.c         ****         _SetISTR((u16)CLR_ERR);
 1506              		.loc 1 548 0
 1507 002c 264A     		ldr	r2, .L145
 1508 002e 4DF6FF71 		movw	r1, #57343
 1509 0032 1160     		str	r1, [r2]
 1510              	.L120:
 549:usb.c         ****     }
 550:usb.c         **** #endif
 551:usb.c         **** 
 552:usb.c         **** 
 553:usb.c         **** #if (ISR_MSK & ISTR_WKUP)
 554:usb.c         ****     if (wIstr & ISTR_WKUP & wInterrupt_Mask) {
 1511              		.loc 1 554 0
 1512 0034 2288     		ldrh	r2, [r4]
 1513 0036 02F48052 		and	r2, r2, #4096
 1514 003a 1342     		tst	r3, r2
 1515 003c 2ED1     		bne	.L143
 1516              	.L121:
 555:usb.c         ****         _SetISTR((u16)CLR_WKUP);
 556:usb.c         ****         usbResume(RESUME_EXTERNAL);
 557:usb.c         ****     }
 558:usb.c         **** #endif
 559:usb.c         **** 
 560:usb.c         ****     /*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*-*/
 561:usb.c         **** #if (ISR_MSK & ISTR_SUSP)
 562:usb.c         ****     if (wIstr & ISTR_SUSP & wInterrupt_Mask) {
 1517              		.loc 1 562 0
 1518 003e 2288     		ldrh	r2, [r4]
 1519 0040 02F40062 		and	r2, r2, #2048
 1520 0044 1342     		tst	r3, r2
 1521 0046 0CD0     		beq	.L122
 1522              	.LBB48:
 1523              	.LBB49:
 182:usb.c         ****     wCNTR = _GetCNTR();
 1524              		.loc 1 182 0
 1525 0048 224A     		ldr	r2, .L145+12
 187:usb.c         ****     bDeviceState = SUSPENDED;
 1526              		.loc 1 187 0
 1527 004a 234D     		ldr	r5, .L145+16
 182:usb.c         ****     wCNTR = _GetCNTR();
 1528              		.loc 1 182 0
 1529 004c 1768     		ldr	r7, [r2]
 1530              	.LBE49:
 1531              	.LBE48:
 563:usb.c         **** 
 564:usb.c         ****         // check if SUSPEND is possible
 565:usb.c         ****         if (F_SUSPEND_ENABLED) {
 566:usb.c         ****             usbSuspend();
 567:usb.c         ****         } else {
 568:usb.c         ****             // if not possible then resume after xx ms
 569:usb.c         ****             usbResume(RESUME_LATER);
 570:usb.c         ****         }
 571:usb.c         ****         // clear of the ISTR bit must be done after setting of CNTR_FSUSP
 572:usb.c         ****         _SetISTR((u16)CLR_SUSP);
 1532              		.loc 1 572 0
 1533 004e 1E49     		ldr	r1, .L145
 1534              	.LBB52:
 1535              	.LBB50:
 182:usb.c         ****     wCNTR = _GetCNTR();
 1536              		.loc 1 182 0
 1537 0050 BFB2     		uxth	r7, r7
 1538              	.LVL65:
 184:usb.c         ****     _SetCNTR(wCNTR);
 1539              		.loc 1 184 0
 1540 0052 47F00C07 		orr	r7, r7, #12
 1541              	.LVL66:
 187:usb.c         ****     bDeviceState = SUSPENDED;
 1542              		.loc 1 187 0
 1543 0056 0326     		movs	r6, #3
 1544              	.LBE50:
 1545              	.LBE52:
 1546              		.loc 1 572 0
 1547 0058 4FF2FF70 		movw	r0, #63487
 1548              	.LBB53:
 1549              	.LBB51:
 184:usb.c         ****     _SetCNTR(wCNTR);
 1550              		.loc 1 184 0
 1551 005c 1760     		str	r7, [r2]
 187:usb.c         ****     bDeviceState = SUSPENDED;
 1552              		.loc 1 187 0
 1553 005e 2E60     		str	r6, [r5]
 1554              	.LBE51:
 1555              	.LBE53:
 1556              		.loc 1 572 0
 1557 0060 0860     		str	r0, [r1]
 1558              	.L122:
 573:usb.c         ****     }
 574:usb.c         **** #endif
 575:usb.c         **** 
 576:usb.c         **** 
 577:usb.c         **** #if (ISR_MSK & ISTR_SOF)
 578:usb.c         ****     if (wIstr & ISTR_SOF & wInterrupt_Mask) {
 1559              		.loc 1 578 0
 1560 0062 2288     		ldrh	r2, [r4]
 1561 0064 02F40072 		and	r2, r2, #512
 1562 0068 1342     		tst	r3, r2
 1563 006a 08D0     		beq	.L123
 579:usb.c         ****         _SetISTR((u16)CLR_SOF);
 1564              		.loc 1 579 0
 1565 006c 1649     		ldr	r1, .L145
 580:usb.c         ****         bIntPackSOF++;
 1566              		.loc 1 580 0
 1567 006e 1B4A     		ldr	r2, .L145+20
 579:usb.c         ****         _SetISTR((u16)CLR_SOF);
 1568              		.loc 1 579 0
 1569 0070 4FF6FF50 		movw	r0, #65023
 1570 0074 0860     		str	r0, [r1]
 1571              		.loc 1 580 0
 1572 0076 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 1573 0078 0131     		adds	r1, r1, #1
 1574 007a C9B2     		uxtb	r1, r1
 1575 007c 1170     		strb	r1, [r2]
 1576              	.L123:
 581:usb.c         ****     }
 582:usb.c         **** #endif
 583:usb.c         **** 
 584:usb.c         **** 
 585:usb.c         **** #if (ISR_MSK & ISTR_ESOF)
 586:usb.c         ****     if (wIstr & ISTR_ESOF & wInterrupt_Mask) {
 1577              		.loc 1 586 0
 1578 007e 2288     		ldrh	r2, [r4]
 1579 0080 02F48072 		and	r2, r2, #256
 1580 0084 1342     		tst	r3, r2
 1581 0086 00D1     		bne	.L144
 1582 0088 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 1583              	.L144:
 587:usb.c         ****         _SetISTR((u16)CLR_ESOF);
 1584              		.loc 1 587 0
 1585 008a 0F4B     		ldr	r3, .L145
 1586 008c 4FF6FF62 		movw	r2, #65279
 1587 0090 1A60     		str	r2, [r3]
 588:usb.c         ****         // resume handling timing is made with ESOFs
 589:usb.c         ****         // request without change of the machine state
 590:usb.c         ****         usbResume(RESUME_ESOF); 
 1588              		.loc 1 590 0
 1589 0092 0720     		movs	r0, #7
 591:usb.c         ****     }
 592:usb.c         **** #endif
 593:usb.c         **** 
 594:usb.c         **** }
 1590              		.loc 1 594 0
 1591 0094 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 590:usb.c         ****         usbResume(RESUME_ESOF); 
 1592              		.loc 1 590 0
 1593 0098 FFF7FEBF 		b	usbResume
 1594              	.LVL67:
 1595              	.L143:
 555:usb.c         ****         _SetISTR((u16)CLR_WKUP);
 1596              		.loc 1 555 0
 1597 009c 0A4B     		ldr	r3, .L145
 1598 009e 4EF6FF72 		movw	r2, #61439
 1599 00a2 1A60     		str	r2, [r3]
 556:usb.c         ****         usbResume(RESUME_EXTERNAL);
 1600              		.loc 1 556 0
 1601 00a4 0020     		movs	r0, #0
 1602 00a6 FFF7FEFF 		bl	usbResume
 1603              	.LVL68:
 1604 00aa 2B88     		ldrh	r3, [r5]
 1605 00ac C7E7     		b	.L121
 1606              	.L142:
 533:usb.c         ****         _SetISTR((u16)CLR_RESET);
 1607              		.loc 1 533 0
 1608 00ae 064A     		ldr	r2, .L145
 534:usb.c         ****         Device_Property.Reset();
 1609              		.loc 1 534 0
 1610 00b0 0B4B     		ldr	r3, .L145+24
 533:usb.c         ****         _SetISTR((u16)CLR_RESET);
 1611              		.loc 1 533 0
 1612 00b2 4FF6FF31 		movw	r1, #64511
 534:usb.c         ****         Device_Property.Reset();
 1613              		.loc 1 534 0
 1614 00b6 5B68     		ldr	r3, [r3, #4]
 533:usb.c         ****         _SetISTR((u16)CLR_RESET);
 1615              		.loc 1 533 0
 1616 00b8 1160     		str	r1, [r2]
 534:usb.c         ****         Device_Property.Reset();
 1617              		.loc 1 534 0
 1618 00ba 9847     		blx	r3
 1619              	.LVL69:
 1620 00bc 2B88     		ldrh	r3, [r5]
 1621 00be B0E7     		b	.L119
 1622              	.L141:
 527:usb.c         ****         CTR_LP(); /* low priority ISR defined in the usb core lib */
 1623              		.loc 1 527 0
 1624 00c0 FFF7FEFF 		bl	CTR_LP
 1625              	.LVL70:
 1626 00c4 2B88     		ldrh	r3, [r5]
 1627 00c6 A7E7     		b	.L118
 1628              	.L146:
 1629              		.align	2
 1630              	.L145:
 1631 00c8 445C0040 		.word	1073765444
 1632 00cc 00000000 		.word	wIstr
 1633 00d0 00000000 		.word	wInterrupt_Mask
 1634 00d4 405C0040 		.word	1073765440
 1635 00d8 00000000 		.word	.LANCHOR0
 1636 00dc 00000000 		.word	.LANCHOR2
 1637 00e0 00000000 		.word	.LANCHOR1
 1638              		.cfi_endproc
 1639              	.LFE31:
 1641              		.section	.text.usbGetState,"ax",%progbits
 1642              		.align	2
 1643              		.global	usbGetState
 1644              		.thumb
 1645              		.thumb_func
 1647              	usbGetState:
 1648              	.LFB32:
 595:usb.c         **** 
 596:usb.c         **** 
 597:usb.c         **** DEVICE_STATE usbGetState()
 598:usb.c         **** {
 1649              		.loc 1 598 0
 1650              		.cfi_startproc
 1651              		@ args = 0, pretend = 0, frame = 0
 1652              		@ frame_needed = 0, uses_anonymous_args = 0
 1653              		@ link register save eliminated.
 599:usb.c         ****     return bDeviceState;
 1654              		.loc 1 599 0
 1655 0000 014B     		ldr	r3, .L148
 1656 0002 1868     		ldr	r0, [r3]
 600:usb.c         **** }
 1657              		.loc 1 600 0
 1658 0004 C0B2     		uxtb	r0, r0
 1659 0006 7047     		bx	lr
 1660              	.L149:
 1661              		.align	2
 1662              	.L148:
 1663 0008 00000000 		.word	.LANCHOR0
 1664              		.cfi_endproc
 1665              	.LFE32:
 1667              		.comm	ResumeS,2,4
 1668              		.global	pEpInt_OUT
 1669              		.global	pEpInt_IN
 1670              		.global	User_Standard_Requests
 1671              		.global	Device_Property
 1672              		.global	Device_Table
 1673              		.global	bIntPackSOF
 1674              		.comm	wIstr,2,2
 1675              		.global	bDeviceState
 1676              		.comm	wTransferSize,4,4
 1677              		.section	.data.Device_Property,"aw",%progbits
 1678              		.align	2
 1679              		.set	.LANCHOR1,. + 0
 1682              	Device_Property:
 1683 0000 00000000 		.word	usbInit
 1684 0004 00000000 		.word	usbReset
 1685 0008 00000000 		.word	usbStatusIn
 1686 000c 00000000 		.word	usbStatusOut
 1687 0010 00000000 		.word	usbDataSetup
 1688 0014 00000000 		.word	usbNoDataSetup
 1689 0018 00000000 		.word	usbGetInterfaceSetting
 1690 001c 00000000 		.word	usbGetDeviceDescriptor
 1691 0020 00000000 		.word	usbGetConfigDescriptor
 1692 0024 00000000 		.word	usbGetStringDescriptor
 1693 0028 00000000 		.word	usbGetFunctionalDescriptor
 1694 002c 00000000 		.word	0
 1695 0030 40       		.byte	64
 1696 0031 000000   		.space	3
 1697              		.section	.data.pEpInt_IN,"aw",%progbits
 1698              		.align	2
 1701              	pEpInt_IN:
 1702 0000 00000000 		.word	nothingProc
 1703 0004 00000000 		.word	nothingProc
 1704 0008 00000000 		.word	nothingProc
 1705 000c 00000000 		.word	nothingProc
 1706 0010 00000000 		.word	nothingProc
 1707 0014 00000000 		.word	nothingProc
 1708 0018 00000000 		.word	nothingProc
 1709              		.section	.bss.bIntPackSOF,"aw",%nobits
 1710              		.set	.LANCHOR2,. + 0
 1713              	bIntPackSOF:
 1714 0000 00       		.space	1
 1715              		.section	.data.pEpInt_OUT,"aw",%progbits
 1716              		.align	2
 1719              	pEpInt_OUT:
 1720 0000 00000000 		.word	nothingProc
 1721 0004 00000000 		.word	nothingProc
 1722 0008 00000000 		.word	nothingProc
 1723 000c 00000000 		.word	nothingProc
 1724 0010 00000000 		.word	nothingProc
 1725 0014 00000000 		.word	nothingProc
 1726 0018 00000000 		.word	nothingProc
 1727              		.section	.bss.bDeviceState,"aw",%nobits
 1728              		.align	2
 1729              		.set	.LANCHOR0,. + 0
 1732              	bDeviceState:
 1733 0000 00000000 		.space	4
 1734              		.section	.data.User_Standard_Requests,"aw",%progbits
 1735              		.align	2
 1738              	User_Standard_Requests:
 1739 0000 00000000 		.word	usbGetConfiguration
 1740 0004 00000000 		.word	usbSetConfiguration
 1741 0008 00000000 		.word	usbGetInterface
 1742 000c 00000000 		.word	usbSetInterface
 1743 0010 00000000 		.word	usbGetStatus
 1744 0014 00000000 		.word	usbClearFeature
 1745 0018 00000000 		.word	usbSetEndpointFeature
 1746 001c 00000000 		.word	usbSetDeviceFeature
 1747 0020 00000000 		.word	usbSetDeviceAddress
 1748              		.section	.data.Device_Table,"aw",%progbits
 1749              		.align	2
 1752              	Device_Table:
 1753 0000 01       		.byte	1
 1754 0001 01       		.byte	1
 1755 0002 0000     		.text
 1756              	.Letext0:
 1757              		.file 2 "./stm32_lib/stm32f10x_type.h"
 1758              		.file 3 "hardware.h"
 1759              		.file 4 "./usb_lib/usb_core.h"
 1760              		.file 5 "./usb_lib/usb_def.h"
 1761              		.file 6 "usb.h"
 1762              		.file 7 "./usb_lib/usb_init.h"
 1763              		.file 8 "usb_descriptor.h"
 1764              		.file 9 "dfu.h"
 1765              		.file 10 "./usb_lib/usb_regs.h"
 1766              		.file 11 "./usb_lib/usb_int.h"
DEFINED SYMBOLS
                            *ABS*:00000000 usb.c
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:19     .text.nothingProc:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:24     .text.nothingProc:00000000 nothingProc
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:37     .text.usbStatusIn:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:42     .text.usbStatusIn:00000000 usbStatusIn
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:54     .text.usbStatusOut:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:59     .text.usbStatusOut:00000000 usbStatusOut
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:71     .text.usbGetInterfaceSetting:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:76     .text.usbGetInterfaceSetting:00000000 usbGetInterfaceSetting
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:96     .text.usbGetConfiguration:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:101    .text.usbGetConfiguration:00000000 usbGetConfiguration
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:113    .text.usbSetConfiguration:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:118    .text.usbSetConfiguration:00000000 usbSetConfiguration
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:139    .text.usbSetConfiguration:00000010 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:145    .text.usbGetInterface:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:150    .text.usbGetInterface:00000000 usbGetInterface
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:162    .text.usbSetInterface:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:167    .text.usbSetInterface:00000000 usbSetInterface
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:179    .text.usbGetStatus:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:184    .text.usbGetStatus:00000000 usbGetStatus
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:196    .text.usbClearFeature:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:201    .text.usbClearFeature:00000000 usbClearFeature
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:213    .text.usbSetEndpointFeature:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:218    .text.usbSetEndpointFeature:00000000 usbSetEndpointFeature
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:230    .text.usbSetDeviceFeature:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:235    .text.usbSetDeviceFeature:00000000 usbSetDeviceFeature
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:247    .text.usbSetDeviceAddress:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:252    .text.usbSetDeviceAddress:00000000 usbSetDeviceAddress
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:267    .text.usbSetDeviceAddress:00000008 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:272    .text.usbReset:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:277    .text.usbReset:00000000 usbReset
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:392    .text.usbReset:0000008c $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:403    .text.usbDataSetup:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:408    .text.usbDataSetup:00000000 usbDataSetup
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:452    .text.usbDataSetup:0000002c $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:457    .text.usbDataSetup:00000040 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:499    .text.usbDataSetup:00000060 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:508    .text.usbGetDeviceDescriptor:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:513    .text.usbGetDeviceDescriptor:00000000 usbGetDeviceDescriptor
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:528    .text.usbGetDeviceDescriptor:00000008 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:533    .text.usbGetConfigDescriptor:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:538    .text.usbGetConfigDescriptor:00000000 usbGetConfigDescriptor
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:553    .text.usbGetConfigDescriptor:00000008 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:558    .text.usbGetStringDescriptor:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:563    .text.usbGetStringDescriptor:00000000 usbGetStringDescriptor
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:592    .text.usbGetStringDescriptor:00000018 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:598    .text.usbGetFunctionalDescriptor:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:603    .text.usbGetFunctionalDescriptor:00000000 usbGetFunctionalDescriptor
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:618    .text.usbGetFunctionalDescriptor:00000008 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:623    .text.usbNoDataSetup:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:628    .text.usbNoDataSetup:00000000 usbNoDataSetup
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:667    .text.usbNoDataSetup:00000024 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:674    .text.usbInit:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:679    .text.usbInit:00000000 usbInit
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:793    .text.usbInit:00000070 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:804    .text.setupUSB:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:809    .text.setupUSB:00000000 setupUSB
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:894    .text.setupUSB:0000005c $d
                            *COM*:00000004 wTransferSize
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:903    .text.usbDsbBus:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:908    .text.usbDsbBus:00000000 usbDsbBus
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:957    .text.usbDsbBus:0000002c $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:966    .text.usbAppInit:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:971    .text.usbAppInit:00000000 usbAppInit
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:985    .text.usbSuspend:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:990    .text.usbSuspend:00000000 usbSuspend
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1018   .text.usbSuspend:00000014 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1024   .text.usbResumeInit:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1029   .text.usbResumeInit:00000000 usbResumeInit
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1054   .text.usbResumeInit:00000014 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1059   .text.usbResume:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1064   .text.usbResume:00000000 usbResume
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1089   .text.usbResume:00000014 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1095   .text.usbResume:0000001a $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1253   .text.usbResume:000000c0 $d
                            *COM*:00000002 ResumeS
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1259   .text.usbPowerOn:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1264   .text.usbPowerOn:00000000 usbPowerOn
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1323   .text.usbPowerOn:00000034 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1332   .text.usbPowerOff:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1337   .text.usbPowerOff:00000000 usbPowerOff
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1385   .text.usbPowerOff:00000030 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1392   .text.usbEnbISR:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1397   .text.usbEnbISR:00000000 usbEnbISR
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1424   .text.usbEnbISR:00000018 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1429   .text.usbDsbISR:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1434   .text.usbDsbISR:00000000 usbDsbISR
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1460   .text.USB_LP_CAN1_RX0_IRQHandler:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1465   .text.USB_LP_CAN1_RX0_IRQHandler:00000000 USB_LP_CAN1_RX0_IRQHandler
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1631   .text.USB_LP_CAN1_RX0_IRQHandler:000000c8 $d
                            *COM*:00000002 wIstr
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1642   .text.usbGetState:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1647   .text.usbGetState:00000000 usbGetState
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1663   .text.usbGetState:00000008 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1719   .data.pEpInt_OUT:00000000 pEpInt_OUT
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1701   .data.pEpInt_IN:00000000 pEpInt_IN
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1738   .data.User_Standard_Requests:00000000 User_Standard_Requests
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1682   .data.Device_Property:00000000 Device_Property
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1752   .data.Device_Table:00000000 Device_Table
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1713   .bss.bIntPackSOF:00000000 bIntPackSOF
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1732   .bss.bDeviceState:00000000 bDeviceState
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1678   .data.Device_Property:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1698   .data.pEpInt_IN:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1714   .bss.bIntPackSOF:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1716   .data.pEpInt_OUT:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1728   .bss.bDeviceState:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1735   .data.User_Standard_Requests:00000000 $d
C:\Users\haifisch\AppData\Local\Temp\ccqSafa7.s:1749   .data.Device_Table:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
pInformation
dfuUpdateByReset
Clear_Status_Out
SetEPRxCount
SetEPRxValid
SetDeviceAddress
usbConfigDescriptorDFU
pProperty
dfuUpdateByRequest
dfuCopyState
dfuCopyStatus
dfuCopyUPLOAD
dfuCopyDNLOAD
Standard_GetDescriptorData
usbDeviceDescriptorDFU
usbStringDescriptor
usbFunctionalDescriptor
dfuInit
gpio_write_bit
nvicInit
wInterrupt_Mask
crMask
getFlashPageSize
USB_Init
u8_usbConfigDescriptorDFU
u8_usbFunctionalDescriptor
CTR_LP
