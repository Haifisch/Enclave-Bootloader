   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 4
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"main.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.transmit_publickey_data,"ax",%progbits
  16              		.align	1
  17              		.global	transmit_publickey_data
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	transmit_publickey_data:
  24              	.LFB3:
  25              		.file 1 "main.c"
   1:main.c        **** /* *****************************************************************************
   2:main.c        ****  * The MIT License
   3:main.c        ****  *
   4:main.c        ****  * Copyright (c) 2010 LeafLabs LLC.
   5:main.c        ****  *
   6:main.c        ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:main.c        ****  * of this software and associated documentation files (the "Software"), to deal
   8:main.c        ****  * in the Software without restriction, including without limitation the rights
   9:main.c        ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:main.c        ****  * copies of the Software, and to permit persons to whom the Software is
  11:main.c        ****  * furnished to do so, subject to the following conditions:
  12:main.c        ****  *
  13:main.c        ****  * The above copyright notice and this permission notice shall be included in
  14:main.c        ****  * all copies or substantial portions of the Software.
  15:main.c        ****  *
  16:main.c        ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:main.c        ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:main.c        ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:main.c        ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:main.c        ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:main.c        ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:main.c        ****  * THE SOFTWARE.
  23:main.c        ****  * ****************************************************************************/
  24:main.c        **** 
  25:main.c        **** /**
  26:main.c        ****  *  @file main.c
  27:main.c        ****  *
  28:main.c        ****  *  @brief main loop and calling any hardware init stuff. timing hacks for EEPROM
  29:main.c        ****  *  writes not to block usb interrupts. logic to handle 2 second timeout then
  30:main.c        ****  *  jump to user code.
  31:main.c        ****  *
  32:main.c        ****  */
  33:main.c        **** #include <stdio.h>
  34:main.c        **** #include <stdint.h>
  35:main.c        **** #include <string.h>
  36:main.c        **** #include <limits.h>
  37:main.c        **** #include <unistd.h>
  38:main.c        **** #include <errno.h>
  39:main.c        **** #include <stdarg.h>
  40:main.c        **** 
  41:main.c        **** #include "common.h"
  42:main.c        **** #include "dfu.h"
  43:main.c        **** #include "image.h"
  44:main.c        **** #include "sha256.h"
  45:main.c        **** 
  46:main.c        **** extern char   __BUILD_DATE;
  47:main.c        **** extern char   __BUILD_NUMBER;
  48:main.c        **** 
  49:main.c        **** /*
  50:main.c        ****   Print the device's public key + signature (ed25519 between the device and the root ca)
  51:main.c        ****   the device is probably in DFU when this is needed -- the restore tool should use this to request 
  52:main.c        **** */
  53:main.c        **** void transmit_publickey_data() 
  54:main.c        **** {
  26              		.loc 1 54 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 784
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30 0000 10B5     		push	{r4, lr}
  31              		.cfi_def_cfa_offset 8
  32              		.cfi_offset 4, -8
  33              		.cfi_offset 14, -4
  55:main.c        ****     struct u_id id;
  56:main.c        ****     unsigned char uniqueID[0x17]; // device unique id
  57:main.c        ****     uint8 enclaveID[32]; // sha2'd unique id
  58:main.c        ****     char signature[EDSIGN_SIGNATURE_SIZE]; // signature of our enclave id
  59:main.c        ****     char publickey[EDSIGN_PUBLIC_KEY_SIZE];
  60:main.c        ****     char base64_pub[256];
  61:main.c        ****     char base64_signature[256];
  62:main.c        **** 
  63:main.c        ****     // read our unique id
  64:main.c        ****     uid_read(&id);
  65:main.c        ****     sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
  66:main.c        ****     // start sha256 context
  67:main.c        ****     sha256_context ctx;
  68:main.c        ****     sha256_starts(&ctx);
  69:main.c        ****     // hash in our unique id
  70:main.c        ****     sha256_update(&ctx, uniqueID, 0x17);
  71:main.c        ****     // store the hash as our enclave id
  72:main.c        ****     sha256_finish(&ctx, enclaveID);
  73:main.c        ****     // zero out public key memory
  74:main.c        ****     memset(publickey, 0, EDSIGN_PUBLIC_KEY_SIZE);
  34              		.loc 1 74 0
  35 0002 2024     		movs	r4, #32
  54:main.c        ****     struct u_id id;
  36              		.loc 1 54 0
  37 0004 ADF5467D 		sub	sp, sp, #792
  38              		.cfi_def_cfa_offset 800
  64:main.c        ****     sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
  39              		.loc 1 64 0
  40 0008 03A8     		add	r0, sp, #12
  41 000a FFF7FEFF 		bl	uid_read
  42              	.LVL0:
  65:main.c        ****     // start sha256 context
  43              		.loc 1 65 0
  44 000e 0599     		ldr	r1, [sp, #20]
  45 0010 BDF80E30 		ldrh	r3, [sp, #14]
  46 0014 0191     		str	r1, [sp, #4]
  47 0016 0499     		ldr	r1, [sp, #16]
  48 0018 BDF80C20 		ldrh	r2, [sp, #12]
  49 001c 0091     		str	r1, [sp]
  50 001e 06A8     		add	r0, sp, #24
  51 0020 2549     		ldr	r1, .L2
  52 0022 FFF7FEFF 		bl	sprintf
  53              	.LVL1:
  68:main.c        ****     // hash in our unique id
  54              		.loc 1 68 0
  55 0026 2CA8     		add	r0, sp, #176
  56 0028 FFF7FEFF 		bl	sha256_starts
  57              	.LVL2:
  70:main.c        ****     // store the hash as our enclave id
  58              		.loc 1 70 0
  59 002c 1722     		movs	r2, #23
  60 002e 06A9     		add	r1, sp, #24
  61 0030 2CA8     		add	r0, sp, #176
  62 0032 FFF7FEFF 		bl	sha256_update
  63              	.LVL3:
  72:main.c        ****     // zero out public key memory
  64              		.loc 1 72 0
  65 0036 0CA9     		add	r1, sp, #48
  66 0038 2CA8     		add	r0, sp, #176
  67 003a FFF7FEFF 		bl	sha256_finish
  68              	.LVL4:
  69              		.loc 1 74 0
  70 003e 2246     		mov	r2, r4
  71 0040 0021     		movs	r1, #0
  72 0042 14A8     		add	r0, sp, #80
  73 0044 FFF7FEFF 		bl	memset
  74              	.LVL5:
  75:main.c        ****     // get ed25519 public key from our enclave id
  76:main.c        ****     edsign_sec_to_pub((unsigned char*)publickey, enclaveID); // secret --> enclave id ===> 25519 pu
  75              		.loc 1 76 0
  76 0048 0CA9     		add	r1, sp, #48
  77 004a 14A8     		add	r0, sp, #80
  78 004c FFF7FEFF 		bl	edsign_sec_to_pub
  79              	.LVL6:
  77:main.c        ****     #if DEBUG
  78:main.c        ****         print_hex("Enclave ID", enclaveID, sizeof(enclaveID));
  80              		.loc 1 78 0
  81 0050 2246     		mov	r2, r4
  82 0052 0CA9     		add	r1, sp, #48
  83 0054 1948     		ldr	r0, .L2+4
  84 0056 FFF7FEFF 		bl	print_hex
  85              	.LVL7:
  79:main.c        ****     #endif
  80:main.c        ****     // encode the ed25519 public key for transport
  81:main.c        ****     encode_b64(publickey, base64_pub, 0x20);
  86              		.loc 1 81 0
  87 005a 2246     		mov	r2, r4
  88 005c 46A9     		add	r1, sp, #280
  89 005e 14A8     		add	r0, sp, #80
  90 0060 FFF7FEFF 		bl	encode_b64
  91              	.LVL8:
  82:main.c        ****     // zero out signature memory 
  83:main.c        ****     memset(signature, 0, EDSIGN_SIGNATURE_SIZE);
  92              		.loc 1 83 0
  93 0064 4022     		movs	r2, #64
  94 0066 0021     		movs	r1, #0
  95 0068 1CA8     		add	r0, sp, #112
  96 006a FFF7FEFF 		bl	memset
  97              	.LVL9:
  84:main.c        ****     // sign the public key for our rootCA 
  85:main.c        ****     edsign_sign((uint8_t*)signature, rootCA, enclaveID, (uint8_t*)publickey, EDSIGN_PUBLIC_KEY_SIZE
  98              		.loc 1 85 0
  99 006e 14AB     		add	r3, sp, #80
 100 0070 0094     		str	r4, [sp]
 101 0072 0CAA     		add	r2, sp, #48
 102 0074 1CA8     		add	r0, sp, #112
 103 0076 1249     		ldr	r1, .L2+8
 104 0078 FFF7FEFF 		bl	edsign_sign
 105              	.LVL10:
  86:main.c        ****     // encode signature for transport
  87:main.c        ****     encode_b64(signature, base64_signature, 0x64);
  88:main.c        **** 
  89:main.c        ****     // spit the base64 publickey
  90:main.c        ****     debug_print("\n\n[BEGIN_PUB_DATA]\n");
  91:main.c        ****     debug_print("%s", base64_pub);
 106              		.loc 1 91 0
 107 007c 114C     		ldr	r4, .L2+12
  87:main.c        **** 
 108              		.loc 1 87 0
 109 007e 6422     		movs	r2, #100
 110 0080 86A9     		add	r1, sp, #536
 111 0082 1CA8     		add	r0, sp, #112
 112 0084 FFF7FEFF 		bl	encode_b64
 113              	.LVL11:
  90:main.c        ****     debug_print("%s", base64_pub);
 114              		.loc 1 90 0
 115 0088 0F48     		ldr	r0, .L2+16
 116 008a FFF7FEFF 		bl	uart_printf
 117              	.LVL12:
 118              		.loc 1 91 0
 119 008e 46A9     		add	r1, sp, #280
 120 0090 2046     		mov	r0, r4
 121 0092 FFF7FEFF 		bl	uart_printf
 122              	.LVL13:
  92:main.c        ****     debug_print("[END_PUB_DATA]\n");
 123              		.loc 1 92 0
 124 0096 0D48     		ldr	r0, .L2+20
 125 0098 FFF7FEFF 		bl	uart_printf
 126              	.LVL14:
  93:main.c        ****     // sput the base64 signature
  94:main.c        ****     debug_print("\n[BEGIN_SIGNATURE_DATA]\n");
 127              		.loc 1 94 0
 128 009c 0C48     		ldr	r0, .L2+24
 129 009e FFF7FEFF 		bl	uart_printf
 130              	.LVL15:
  95:main.c        ****     debug_print("%s", base64_signature);
 131              		.loc 1 95 0
 132 00a2 86A9     		add	r1, sp, #536
 133 00a4 2046     		mov	r0, r4
 134 00a6 FFF7FEFF 		bl	uart_printf
 135              	.LVL16:
  96:main.c        ****     debug_print("[END_SIGNATURE_DATA]\n");
 136              		.loc 1 96 0
 137 00aa 0A48     		ldr	r0, .L2+28
 138 00ac FFF7FEFF 		bl	uart_printf
 139              	.LVL17:
  97:main.c        **** }
 140              		.loc 1 97 0
 141 00b0 0DF5467D 		add	sp, sp, #792
 142              		.cfi_def_cfa_offset 8
 143              		@ sp needed
 144 00b4 10BD     		pop	{r4, pc}
 145              	.L3:
 146 00b6 00BF     		.align	2
 147              	.L2:
 148 00b8 00000000 		.word	.LC0
 149 00bc 09000000 		.word	.LC1
 150 00c0 00000000 		.word	rootCA
 151 00c4 28000000 		.word	.LC3
 152 00c8 14000000 		.word	.LC2
 153 00cc 2B000000 		.word	.LC4
 154 00d0 3B000000 		.word	.LC5
 155 00d4 54000000 		.word	.LC6
 156              		.cfi_endproc
 157              	.LFE3:
 159              		.section	.text.print_bootheader,"ax",%progbits
 160              		.align	1
 161              		.global	print_bootheader
 162              		.syntax unified
 163              		.thumb
 164              		.thumb_func
 165              		.fpu softvfp
 167              	print_bootheader:
 168              	.LFB4:
  98:main.c        **** 
  99:main.c        **** /*
 100:main.c        ****     Printable boot header
 101:main.c        **** */
 102:main.c        **** void print_bootheader() 
 103:main.c        **** {
 169              		.loc 1 103 0
 170              		.cfi_startproc
 171              		@ args = 0, pretend = 0, frame = 24
 172              		@ frame_needed = 0, uses_anonymous_args = 0
 173 0000 10B5     		push	{r4, lr}
 174              		.cfi_def_cfa_offset 8
 175              		.cfi_offset 4, -8
 176              		.cfi_offset 14, -4
 177              	.LBB2:
 104:main.c        ****     uart_printf("[--------------------------------------------]\n");
 105:main.c        ****     char* letter[6]; 
 106:main.c        ****     letter[0] = "   ______            _                 \n";
 107:main.c        ****     letter[1] = "  |  ____|          | |                \n";
 108:main.c        ****     letter[2] = "  | |__   _ __   ___| | __ ___   _____ \n";
 109:main.c        ****     letter[3] = "  |  __| | '_ \\ / __| |/ _` \\ \\ / / _ \\\n";
 110:main.c        ****     letter[4] = "  | |____| | | | (__| | (_| |\\ V /  __/\n";
 111:main.c        ****     letter[5] = "  |______|_| |_|\\___|_|\\__,_| \\_/ \\___|\n\n";
 112:main.c        ****     for (int i = 0; i < 6; ++i) { uart_printf(letter[i]); } // print out
 178              		.loc 1 112 0
 179 0002 0024     		movs	r4, #0
 180              	.LBE2:
 103:main.c        ****     uart_printf("[--------------------------------------------]\n");
 181              		.loc 1 103 0
 182 0004 86B0     		sub	sp, sp, #24
 183              		.cfi_def_cfa_offset 32
 104:main.c        ****     uart_printf("[--------------------------------------------]\n");
 184              		.loc 1 104 0
 185 0006 2048     		ldr	r0, .L11
 186 0008 FFF7FEFF 		bl	uart_printf
 187              	.LVL18:
 106:main.c        ****     letter[1] = "  |  ____|          | |                \n";
 188              		.loc 1 106 0
 189 000c 1F4B     		ldr	r3, .L11+4
 190 000e 0093     		str	r3, [sp]
 107:main.c        ****     letter[2] = "  | |__   _ __   ___| | __ ___   _____ \n";
 191              		.loc 1 107 0
 192 0010 1F4B     		ldr	r3, .L11+8
 193 0012 0193     		str	r3, [sp, #4]
 108:main.c        ****     letter[3] = "  |  __| | '_ \\ / __| |/ _` \\ \\ / / _ \\\n";
 194              		.loc 1 108 0
 195 0014 1F4B     		ldr	r3, .L11+12
 196 0016 0293     		str	r3, [sp, #8]
 109:main.c        ****     letter[4] = "  | |____| | | | (__| | (_| |\\ V /  __/\n";
 197              		.loc 1 109 0
 198 0018 1F4B     		ldr	r3, .L11+16
 199 001a 0393     		str	r3, [sp, #12]
 110:main.c        ****     letter[5] = "  |______|_| |_|\\___|_|\\__,_| \\_/ \\___|\n\n";
 200              		.loc 1 110 0
 201 001c 1F4B     		ldr	r3, .L11+20
 202 001e 0493     		str	r3, [sp, #16]
 111:main.c        ****     for (int i = 0; i < 6; ++i) { uart_printf(letter[i]); } // print out
 203              		.loc 1 111 0
 204 0020 1F4B     		ldr	r3, .L11+24
 205 0022 0593     		str	r3, [sp, #20]
 206              	.LVL19:
 207              	.L5:
 208              	.LBB3:
 209              		.loc 1 112 0 discriminator 3
 210 0024 5DF82400 		ldr	r0, [sp, r4, lsl #2]
 211 0028 0134     		adds	r4, r4, #1
 212              	.LVL20:
 213 002a FFF7FEFF 		bl	uart_printf
 214              	.LVL21:
 215 002e 062C     		cmp	r4, #6
 216 0030 F8D1     		bne	.L5
 217              	.LBE3:
 113:main.c        ****     debug_print("  %s %s\n", __DATE__, __TIME__);
 218              		.loc 1 113 0 discriminator 1
 219 0032 1C4A     		ldr	r2, .L11+28
 220 0034 1C49     		ldr	r1, .L11+32
 221 0036 1D48     		ldr	r0, .L11+36
 222 0038 FFF7FEFF 		bl	uart_printf
 223              	.LVL22:
 114:main.c        ****     debug_print("  DEVID %08X\n", *((uint32_t *)0x1E0032000)); // 0xE0042000 + 0xFFFF0000
 224              		.loc 1 114 0 discriminator 1
 225 003c 1C4B     		ldr	r3, .L11+40
 226 003e 1D48     		ldr	r0, .L11+44
 227 0040 1968     		ldr	r1, [r3]
 228 0042 FFF7FEFF 		bl	uart_printf
 229              	.LVL23:
 115:main.c        ****     debug_print("  VER: 0x%X REV: 0x%X\n", __BUILD_NUMBER, 0x15);
 230              		.loc 1 115 0 discriminator 1
 231 0046 1C4B     		ldr	r3, .L11+48
 232 0048 1522     		movs	r2, #21
 233 004a 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 234 004c 1B48     		ldr	r0, .L11+52
 235 004e FFF7FEFF 		bl	uart_printf
 236              	.LVL24:
 116:main.c        ****     debug_print("  Security Fusing ::: %s\n", isSecure() ? "Secure":"Insecure");
 237              		.loc 1 116 0 discriminator 1
 238 0052 FFF7FEFF 		bl	isSecure
 239              	.LVL25:
 240 0056 1A4B     		ldr	r3, .L11+56
 241 0058 1A49     		ldr	r1, .L11+60
 242 005a 0028     		cmp	r0, #0
 243 005c 08BF     		it	eq
 244 005e 1946     		moveq	r1, r3
 245 0060 1948     		ldr	r0, .L11+64
 246 0062 FFF7FEFF 		bl	uart_printf
 247              	.LVL26:
 117:main.c        ****     debug_print("  Production Fusing ::: %s\n", isProduction() ? "Production":"Development");
 248              		.loc 1 117 0 discriminator 1
 249 0066 FFF7FEFF 		bl	isProduction
 250              	.LVL27:
 251 006a 184B     		ldr	r3, .L11+68
 252 006c 1849     		ldr	r1, .L11+72
 253 006e 0028     		cmp	r0, #0
 254 0070 08BF     		it	eq
 255 0072 1946     		moveq	r1, r3
 256 0074 1748     		ldr	r0, .L11+76
 257 0076 FFF7FEFF 		bl	uart_printf
 258              	.LVL28:
 118:main.c        ****     uart_printf("[--------------------------------------------]\n");
 259              		.loc 1 118 0 discriminator 1
 260 007a 0348     		ldr	r0, .L11
 119:main.c        **** }
 261              		.loc 1 119 0 discriminator 1
 262 007c 06B0     		add	sp, sp, #24
 263              		.cfi_def_cfa_offset 8
 264              		@ sp needed
 265 007e BDE81040 		pop	{r4, lr}
 266              		.cfi_restore 14
 267              		.cfi_restore 4
 268              		.cfi_def_cfa_offset 0
 269              	.LVL29:
 118:main.c        ****     uart_printf("[--------------------------------------------]\n");
 270              		.loc 1 118 0 discriminator 1
 271 0082 FFF7FEBF 		b	uart_printf
 272              	.LVL30:
 273              	.L12:
 274 0086 00BF     		.align	2
 275              	.L11:
 276 0088 27000000 		.word	.LC11
 277 008c 57000000 		.word	.LC12
 278 0090 80000000 		.word	.LC13
 279 0094 A9000000 		.word	.LC14
 280 0098 D2000000 		.word	.LC15
 281 009c FB000000 		.word	.LC16
 282 00a0 24010000 		.word	.LC17
 283 00a4 4E010000 		.word	.LC18
 284 00a8 57010000 		.word	.LC19
 285 00ac 63010000 		.word	.LC20
 286 00b0 002003E0 		.word	-536666112
 287 00b4 6C010000 		.word	.LC21
 288 00b8 00000000 		.word	__BUILD_NUMBER
 289 00bc 7A010000 		.word	.LC22
 290 00c0 07000000 		.word	.LC8
 291 00c4 00000000 		.word	.LC7
 292 00c8 91010000 		.word	.LC23
 293 00cc 1B000000 		.word	.LC10
 294 00d0 10000000 		.word	.LC9
 295 00d4 AB010000 		.word	.LC24
 296              		.cfi_endproc
 297              	.LFE4:
 299              		.section	.text.startup.main,"ax",%progbits
 300              		.align	1
 301              		.global	main
 302              		.syntax unified
 303              		.thumb
 304              		.thumb_func
 305              		.fpu softvfp
 307              	main:
 308              	.LFB5:
 120:main.c        **** 
 121:main.c        **** 
 122:main.c        **** /*
 123:main.c        ****     Bootloader main
 124:main.c        **** */
 125:main.c        **** int main() 
 126:main.c        **** {
 309              		.loc 1 126 0
 310              		.cfi_startproc
 311              		@ args = 0, pretend = 0, frame = 8
 312              		@ frame_needed = 0, uses_anonymous_args = 0
 313              	.LVL31:
 314 0000 7FB5     		push	{r0, r1, r2, r3, r4, r5, r6, lr}
 315              		.cfi_def_cfa_offset 32
 316              		.cfi_offset 4, -16
 317              		.cfi_offset 5, -12
 318              		.cfi_offset 6, -8
 319              		.cfi_offset 14, -4
 127:main.c        ****     // default state is true, logically if all else fails we should fallback into DFU and not jump 
 128:main.c        ****     bool refuse_user_jump = TRUE; 
 129:main.c        **** 
 130:main.c        ****     // low level hardware init  
 131:main.c        ****     systemReset(); // peripherals but not PC
 132:main.c        ****     setupCLK();
 133:main.c        ****     setupLEDAndButton();
 134:main.c        ****     setupFLASH();
 135:main.c        ****     uartInit();
 136:main.c        ****     setupUSB();
 137:main.c        **** 
 138:main.c        ****     // Init!
 139:main.c        ****     uart_printf("\033[2J\n");
 140:main.c        ****     uart_printf("Bootloader init!\n\n");
 141:main.c        ****     print_bootheader();
 142:main.c        ****     strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE); // show that we're alive via LED 
 320              		.loc 1 142 0
 321 0002 0024     		movs	r4, #0
 131:main.c        ****     setupCLK();
 322              		.loc 1 131 0
 323 0004 FFF7FEFF 		bl	systemReset
 324              	.LVL32:
 132:main.c        ****     setupLEDAndButton();
 325              		.loc 1 132 0
 326 0008 FFF7FEFF 		bl	setupCLK
 327              	.LVL33:
 133:main.c        ****     setupFLASH();
 328              		.loc 1 133 0
 329 000c FFF7FEFF 		bl	setupLEDAndButton
 330              	.LVL34:
 134:main.c        ****     uartInit();
 331              		.loc 1 134 0
 332 0010 FFF7FEFF 		bl	setupFLASH
 333              	.LVL35:
 135:main.c        ****     setupUSB();
 334              		.loc 1 135 0
 335 0014 FFF7FEFF 		bl	uartInit
 336              	.LVL36:
 136:main.c        **** 
 337              		.loc 1 136 0
 338 0018 FFF7FEFF 		bl	setupUSB
 339              	.LVL37:
 139:main.c        ****     uart_printf("Bootloader init!\n\n");
 340              		.loc 1 139 0
 341 001c 2848     		ldr	r0, .L27
 342 001e FFF7FEFF 		bl	uart_printf
 343              	.LVL38:
 140:main.c        ****     print_bootheader();
 344              		.loc 1 140 0
 345 0022 2848     		ldr	r0, .L27+4
 346 0024 FFF7FEFF 		bl	uart_printf
 347              	.LVL39:
 141:main.c        ****     strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE); // show that we're alive via LED 
 348              		.loc 1 141 0
 349 0028 FFF7FEFF 		bl	print_bootheader
 350              	.LVL40:
 351              		.loc 1 142 0
 352 002c 4FF4A023 		mov	r3, #327680
 353 0030 0522     		movs	r2, #5
 354 0032 0D21     		movs	r1, #13
 355 0034 2448     		ldr	r0, .L27+8
 356 0036 0094     		str	r4, [sp]
 357 0038 FFF7FEFF 		bl	strobePin
 358              	.LVL41:
 143:main.c        **** 
 144:main.c        ****     // Read DFU pin state 
 145:main.c        ****     if (readPin(GPIOB, 15) == 0x0) // force dfu
 359              		.loc 1 145 0
 360 003c 0F21     		movs	r1, #15
 361 003e 2348     		ldr	r0, .L27+12
 362 0040 FFF7FEFF 		bl	readPin
 363              	.LVL42:
 146:main.c        ****     {
 147:main.c        ****         refuse_user_jump = TRUE;
 148:main.c        ****     } 
 149:main.c        **** 
 150:main.c        ****     // verify boot chain
 151:main.c        ****     debug_print("checking chain...\n");
 364              		.loc 1 151 0
 365 0044 2248     		ldr	r0, .L27+16
 366 0046 FFF7FEFF 		bl	uart_printf
 367              	.LVL43:
 152:main.c        ****     // setup image structure 
 153:main.c        ****     ImageObjectHandle imageHandle;
 154:main.c        ****     // validate flash     
 155:main.c        ****     switch (imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0)) // if anything fails 
 368              		.loc 1 155 0
 369 004a 2246     		mov	r2, r4
 370 004c 2149     		ldr	r1, .L27+20
 371 004e 03A8     		add	r0, sp, #12
 372 0050 FFF7FEFF 		bl	imageCheckFromAddress
 373              	.LVL44:
 374 0054 0238     		subs	r0, r0, #2
 375 0056 0328     		cmp	r0, #3
 376 0058 15D8     		bhi	.L14
 377 005a DFE800F0 		tbb	[pc, r0]
 378              	.L16:
 379 005e 10       		.byte	(.L15-.L16)/2
 380 005f 02       		.byte	(.L17-.L16)/2
 381 0060 09       		.byte	(.L18-.L16)/2
 382 0061 12       		.byte	(.L19-.L16)/2
 383              		.p2align 1
 384              	.L17:
 156:main.c        ****     {
 157:main.c        ****         case kImageImageIsTrusted:
 158:main.c        ****             debug_print("Boot OK\n");
 385              		.loc 1 158 0 discriminator 1
 386 0062 1D48     		ldr	r0, .L27+24
 387 0064 FFF7FEFF 		bl	uart_printf
 388              	.LVL45:
 159:main.c        ****             refuse_user_jump = FALSE;
 389              		.loc 1 159 0 discriminator 1
 390 0068 0024     		movs	r4, #0
 391              	.LVL46:
 392              	.L20:
 160:main.c        ****             break;
 161:main.c        **** 
 162:main.c        ****         case kImageImageMissingMagic:
 163:main.c        ****             transmit_publickey_data();
 164:main.c        ****             debug_print("\nFirmware missing... waiting in DFU\n");
 165:main.c        ****             refuse_user_jump = TRUE;
 166:main.c        ****             break;
 167:main.c        **** 
 168:main.c        ****         case kImageImageRejectSignature:
 169:main.c        ****             debug_print("\nSignature validation failed... waiting in DFU\n");
 170:main.c        ****             refuse_user_jump = TRUE;
 171:main.c        ****             break;
 172:main.c        **** 
 173:main.c        ****         case kImageImageHashCalcFailed:
 174:main.c        ****             debug_print("\nHash calculation failed... waiting in DFU\n");
 175:main.c        ****             refuse_user_jump = TRUE;
 176:main.c        ****             break;
 177:main.c        ****             
 178:main.c        ****         default:
 179:main.c        ****             debug_print("\n!!! FATAL !!!\n");
 180:main.c        ****             refuse_user_jump = TRUE;
 181:main.c        ****             break;
 182:main.c        ****     }
 183:main.c        **** 
 184:main.c        ****     while (refuse_user_jump) // DFU spinlock
 185:main.c        ****     {
 186:main.c        ****         // we're spinning in DFU waiting for an upload...
 187:main.c        ****         strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
 393              		.loc 1 187 0 discriminator 1
 394 006a 174D     		ldr	r5, .L27+8
 395 006c 0026     		movs	r6, #0
 396 006e 1CE0     		b	.L21
 397              	.LVL47:
 398              	.L18:
 163:main.c        ****             debug_print("\nFirmware missing... waiting in DFU\n");
 399              		.loc 1 163 0
 400 0070 FFF7FEFF 		bl	transmit_publickey_data
 401              	.LVL48:
 164:main.c        ****             refuse_user_jump = TRUE;
 402              		.loc 1 164 0
 403 0074 1948     		ldr	r0, .L27+28
 404              	.L26:
 169:main.c        ****             refuse_user_jump = TRUE;
 405              		.loc 1 169 0 discriminator 1
 406 0076 FFF7FEFF 		bl	uart_printf
 407              	.LVL49:
 170:main.c        ****             break;
 408              		.loc 1 170 0 discriminator 1
 409 007a 0124     		movs	r4, #1
 171:main.c        **** 
 410              		.loc 1 171 0 discriminator 1
 411 007c F5E7     		b	.L20
 412              	.L15:
 169:main.c        ****             refuse_user_jump = TRUE;
 413              		.loc 1 169 0 discriminator 1
 414 007e 1848     		ldr	r0, .L27+32
 415 0080 F9E7     		b	.L26
 416              	.L19:
 174:main.c        ****             refuse_user_jump = TRUE;
 417              		.loc 1 174 0 discriminator 1
 418 0082 1848     		ldr	r0, .L27+36
 419 0084 F7E7     		b	.L26
 420              	.L14:
 179:main.c        ****             refuse_user_jump = TRUE;
 421              		.loc 1 179 0 discriminator 1
 422 0086 1848     		ldr	r0, .L27+40
 423 0088 F5E7     		b	.L26
 424              	.LVL50:
 425              	.L23:
 426              		.loc 1 187 0
 427 008a 4FF48013 		mov	r3, #1048576
 428 008e 0122     		movs	r2, #1
 429 0090 0D21     		movs	r1, #13
 430 0092 2846     		mov	r0, r5
 431 0094 0096     		str	r6, [sp]
 432 0096 FFF7FEFF 		bl	strobePin
 433              	.LVL51:
 188:main.c        ****         if (dfuUploadStarted()) 
 434              		.loc 1 188 0
 435 009a FFF7FEFF 		bl	dfuUploadStarted
 436              	.LVL52:
 437 009e 20B1     		cbz	r0, .L21
 189:main.c        ****         {
 190:main.c        ****             debug_print("DFU finished upload\n");
 438              		.loc 1 190 0 discriminator 1
 439 00a0 1248     		ldr	r0, .L27+44
 440 00a2 FFF7FEFF 		bl	uart_printf
 441              	.LVL53:
 191:main.c        ****             dfuFinishUpload(); // systemHardReset from DFU once done
 442              		.loc 1 191 0 discriminator 1
 443 00a6 FFF7FEFF 		bl	dfuFinishUpload
 444              	.LVL54:
 445              	.L21:
 184:main.c        ****     {
 446              		.loc 1 184 0 discriminator 1
 447 00aa 002C     		cmp	r4, #0
 448 00ac EDD1     		bne	.L23
 192:main.c        ****         }
 193:main.c        ****     }
 194:main.c        **** 
 195:main.c        ****     // we have the OS verified so lets jump to it. 
 196:main.c        ****     if (refuse_user_jump == FALSE)
 197:main.c        ****     {
 198:main.c        ****         debug_print("Jumping to OS.\n");
 449              		.loc 1 198 0 discriminator 1
 450 00ae 1048     		ldr	r0, .L27+48
 451 00b0 FFF7FEFF 		bl	uart_printf
 452              	.LVL55:
 199:main.c        ****         jumpToUser((USER_CODE_FLASH0X8008000+0x84));    
 453              		.loc 1 199 0 discriminator 1
 454 00b4 0F48     		ldr	r0, .L27+52
 455 00b6 FFF7FEFF 		bl	jumpToUser
 456              	.LVL56:
 200:main.c        ****     }
 201:main.c        ****     
 202:main.c        ****     return 0; // Added to please the compiler
 203:main.c        **** }...
 457              		.loc 1 203 0 discriminator 1
 458 00ba 2046     		mov	r0, r4
 459 00bc 04B0     		add	sp, sp, #16
 460              		.cfi_def_cfa_offset 16
 461              		@ sp needed
 462 00be 70BD     		pop	{r4, r5, r6, pc}
 463              	.LVL57:
 464              	.L28:
 465              		.align	2
 466              	.L27:
 467 00c0 00000000 		.word	.LC25
 468 00c4 06000000 		.word	.LC26
 469 00c8 00100140 		.word	1073811456
 470 00cc 000C0140 		.word	1073810432
 471 00d0 19000000 		.word	.LC27
 472 00d4 00900008 		.word	134254592
 473 00d8 2C000000 		.word	.LC28
 474 00dc 35000000 		.word	.LC29
 475 00e0 5A000000 		.word	.LC30
 476 00e4 8A000000 		.word	.LC31
 477 00e8 B6000000 		.word	.LC32
 478 00ec C6000000 		.word	.LC33
 479 00f0 DB000000 		.word	.LC34
 480 00f4 84900008 		.word	134254724
 481              		.cfi_endproc
 482              	.LFE5:
 484              		.comm	rootCA,32,1
 485              		.comm	wTransferSize,4,4
 486              		.section	.rodata.main.str1.1,"aMS",%progbits,1
 487              	.LC25:
 488 0000 1B5B324A 		.ascii	"\033[2J\012\000"
 488      0A00
 489              	.LC26:
 490 0006 426F6F74 		.ascii	"Bootloader init!\012\012\000"
 490      6C6F6164 
 490      65722069 
 490      6E697421 
 490      0A0A00
 491              	.LC27:
 492 0019 63686563 		.ascii	"checking chain...\012\000"
 492      6B696E67 
 492      20636861 
 492      696E2E2E 
 492      2E0A00
 493              	.LC28:
 494 002c 426F6F74 		.ascii	"Boot OK\012\000"
 494      204F4B0A 
 494      00
 495              	.LC29:
 496 0035 0A466972 		.ascii	"\012Firmware missing... waiting in DFU\012\000"
 496      6D776172 
 496      65206D69 
 496      7373696E 
 496      672E2E2E 
 497              	.LC30:
 498 005a 0A536967 		.ascii	"\012Signature validation failed... waiting in DFU\012"
 498      6E617475 
 498      72652076 
 498      616C6964 
 498      6174696F 
 499 0089 00       		.ascii	"\000"
 500              	.LC31:
 501 008a 0A486173 		.ascii	"\012Hash calculation failed... waiting in DFU\012\000"
 501      68206361 
 501      6C63756C 
 501      6174696F 
 501      6E206661 
 502              	.LC32:
 503 00b6 0A212121 		.ascii	"\012!!! FATAL !!!\012\000"
 503      20464154 
 503      414C2021 
 503      21210A00 
 504              	.LC33:
 505 00c6 44465520 		.ascii	"DFU finished upload\012\000"
 505      66696E69 
 505      73686564 
 505      2075706C 
 505      6F61640A 
 506              	.LC34:
 507 00db 4A756D70 		.ascii	"Jumping to OS.\012\000"
 507      696E6720 
 507      746F204F 
 507      532E0A00 
 508              		.section	.rodata.print_bootheader.str1.1,"aMS",%progbits,1
 509              	.LC7:
 510 0000 53656375 		.ascii	"Secure\000"
 510      726500
 511              	.LC8:
 512 0007 496E7365 		.ascii	"Insecure\000"
 512      63757265 
 512      00
 513              	.LC9:
 514 0010 50726F64 		.ascii	"Production\000"
 514      75637469 
 514      6F6E00
 515              	.LC10:
 516 001b 44657665 		.ascii	"Development\000"
 516      6C6F706D 
 516      656E7400 
 517              	.LC11:
 518 0027 5B2D2D2D 		.ascii	"[--------------------------------------------]\012\000"
 518      2D2D2D2D 
 518      2D2D2D2D 
 518      2D2D2D2D 
 518      2D2D2D2D 
 519              	.LC12:
 520 0057 2020205F 		.ascii	"   ______            _                 \012\000"
 520      5F5F5F5F 
 520      5F202020 
 520      20202020 
 520      20202020 
 521              	.LC13:
 522 0080 20207C20 		.ascii	"  |  ____|          | |                \012\000"
 522      205F5F5F 
 522      5F7C2020 
 522      20202020 
 522      20202020 
 523              	.LC14:
 524 00a9 20207C20 		.ascii	"  | |__   _ __   ___| | __ ___   _____ \012\000"
 524      7C5F5F20 
 524      20205F20 
 524      5F5F2020 
 524      205F5F5F 
 525              	.LC15:
 526 00d2 20207C20 		.ascii	"  |  __| | '_ \\ / __| |/ _` \\ \\ / / _ \\\012\000"
 526      205F5F7C 
 526      207C2027 
 526      5F205C20 
 526      2F205F5F 
 527              	.LC16:
 528 00fb 20207C20 		.ascii	"  | |____| | | | (__| | (_| |\\ V /  __/\012\000"
 528      7C5F5F5F 
 528      5F7C207C 
 528      207C207C 
 528      20285F5F 
 529              	.LC17:
 530 0124 20207C5F 		.ascii	"  |______|_| |_|\\___|_|\\__,_| \\_/ \\___|\012\012"
 530      5F5F5F5F 
 530      5F7C5F7C 
 530      207C5F7C 
 530      5C5F5F5F 
 531 014d 00       		.ascii	"\000"
 532              	.LC18:
 533 014e 32333A30 		.ascii	"23:01:24\000"
 533      313A3234 
 533      00
 534              	.LC19:
 535 0157 4E6F7620 		.ascii	"Nov 16 2018\000"
 535      31362032 
 535      30313800 
 536              	.LC20:
 537 0163 20202573 		.ascii	"  %s %s\012\000"
 537      2025730A 
 537      00
 538              	.LC21:
 539 016c 20204445 		.ascii	"  DEVID %08X\012\000"
 539      56494420 
 539      25303858 
 539      0A00
 540              	.LC22:
 541 017a 20205645 		.ascii	"  VER: 0x%X REV: 0x%X\012\000"
 541      523A2030 
 541      78255820 
 541      5245563A 
 541      20307825 
 542              	.LC23:
 543 0191 20205365 		.ascii	"  Security Fusing ::: %s\012\000"
 543      63757269 
 543      74792046 
 543      7573696E 
 543      67203A3A 
 544              	.LC24:
 545 01ab 20205072 		.ascii	"  Production Fusing ::: %s\012\000"
 545      6F647563 
 545      74696F6E 
 545      20467573 
 545      696E6720 
 546              		.section	.rodata.transmit_publickey_data.str1.1,"aMS",%progbits,1
 547              	.LC0:
 548 0000 25582558 		.ascii	"%X%X%X%X\000"
 548      25582558 
 548      00
 549              	.LC1:
 550 0009 456E636C 		.ascii	"Enclave ID\000"
 550      61766520 
 550      494400
 551              	.LC2:
 552 0014 0A0A5B42 		.ascii	"\012\012[BEGIN_PUB_DATA]\012\000"
 552      4547494E 
 552      5F505542 
 552      5F444154 
 552      415D0A00 
 553              	.LC3:
 554 0028 257300   		.ascii	"%s\000"
 555              	.LC4:
 556 002b 5B454E44 		.ascii	"[END_PUB_DATA]\012\000"
 556      5F505542 
 556      5F444154 
 556      415D0A00 
 557              	.LC5:
 558 003b 0A5B4245 		.ascii	"\012[BEGIN_SIGNATURE_DATA]\012\000"
 558      47494E5F 
 558      5349474E 
 558      41545552 
 558      455F4441 
 559              	.LC6:
 560 0054 5B454E44 		.ascii	"[END_SIGNATURE_DATA]\012\000"
 560      5F534947 
 560      4E415455 
 560      52455F44 
 560      4154415D 
 561              		.text
 562              	.Letext0:
 563              		.file 2 "/usr/arm-none-eabi/include/machine/_default_types.h"
 564              		.file 3 "/usr/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h"
 565              		.file 4 "/usr/arm-none-eabi/include/sys/lock.h"
 566              		.file 5 "/usr/arm-none-eabi/include/sys/_types.h"
 567              		.file 6 "/usr/arm-none-eabi/include/sys/reent.h"
 568              		.file 7 "/usr/arm-none-eabi/include/sys/_stdint.h"
 569              		.file 8 "/usr/arm-none-eabi/include/sys/unistd.h"
 570              		.file 9 "/usr/arm-none-eabi/include/sys/errno.h"
 571              		.file 10 "./stm32_lib/stm32f10x_type.h"
 572              		.file 11 "hardware.h"
 573              		.file 12 "./usb_lib/usb_regs.h"
 574              		.file 13 "./usb_lib/usb_core.h"
 575              		.file 14 "./usb_lib/usb_init.h"
 576              		.file 15 "usb_descriptor.h"
 577              		.file 16 "usb.h"
 578              		.file 17 "dfu.h"
 579              		.file 18 "image.h"
 580              		.file 19 "./25519/sha256.h"
 581              		.file 20 "/usr/arm-none-eabi/include/stdio.h"
 582              		.file 21 "./25519/edsign.h"
 583              		.file 22 "<built-in>"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc3lbZUK.s:16     .text.transmit_publickey_data:0000000000000000 $t
     /tmp/cc3lbZUK.s:23     .text.transmit_publickey_data:0000000000000000 transmit_publickey_data
     /tmp/cc3lbZUK.s:148    .text.transmit_publickey_data:00000000000000b8 $d
                            *COM*:0000000000000020 rootCA
     /tmp/cc3lbZUK.s:160    .text.print_bootheader:0000000000000000 $t
     /tmp/cc3lbZUK.s:167    .text.print_bootheader:0000000000000000 print_bootheader
     /tmp/cc3lbZUK.s:276    .text.print_bootheader:0000000000000088 $d
     /tmp/cc3lbZUK.s:300    .text.startup.main:0000000000000000 $t
     /tmp/cc3lbZUK.s:307    .text.startup.main:0000000000000000 main
     /tmp/cc3lbZUK.s:379    .text.startup.main:000000000000005e $d
     /tmp/cc3lbZUK.s:383    .text.startup.main:0000000000000062 $t
     /tmp/cc3lbZUK.s:467    .text.startup.main:00000000000000c0 $d
                            *COM*:0000000000000004 wTransferSize

UNDEFINED SYMBOLS
uid_read
sprintf
sha256_starts
sha256_update
sha256_finish
memset
edsign_sec_to_pub
print_hex
encode_b64
edsign_sign
uart_printf
isSecure
isProduction
__BUILD_NUMBER
systemReset
setupCLK
setupLEDAndButton
setupFLASH
uartInit
setupUSB
strobePin
readPin
imageCheckFromAddress
dfuUploadStarted
dfuFinishUpload
jumpToUser
