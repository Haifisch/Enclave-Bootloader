   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 4
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"main.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.section	.text.decode_b64,"ax",%progbits
  19              		.align	1
  20              		.global	decode_b64
  21              		.thumb
  22              		.thumb_func
  24              	decode_b64:
  25              	.LFB0:
  26              		.file 1 "main.c"
   1:main.c        **** /* *****************************************************************************
   2:main.c        ****  * The MIT License
   3:main.c        ****  *
   4:main.c        ****  * Copyright (c) 2010 LeafLabs LLC.
   5:main.c        ****  *
   6:main.c        ****  * Permission is hereby granted, free of charge, to any person obtaining a copy
   7:main.c        ****  * of this software and associated documentation files (the "Software"), to deal
   8:main.c        ****  * in the Software without restriction, including without limitation the rights
   9:main.c        ****  * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
  10:main.c        ****  * copies of the Software, and to permit persons to whom the Software is
  11:main.c        ****  * furnished to do so, subject to the following conditions:
  12:main.c        ****  *
  13:main.c        ****  * The above copyright notice and this permission notice shall be included in
  14:main.c        ****  * all copies or substantial portions of the Software.
  15:main.c        ****  *
  16:main.c        ****  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
  17:main.c        ****  * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
  18:main.c        ****  * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
  19:main.c        ****  * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
  20:main.c        ****  * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
  21:main.c        ****  * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
  22:main.c        ****  * THE SOFTWARE.
  23:main.c        ****  * ****************************************************************************/
  24:main.c        **** 
  25:main.c        **** /**
  26:main.c        ****  *  @file main.c
  27:main.c        ****  *
  28:main.c        ****  *  @brief main loop and calling any hardware init stuff. timing hacks for EEPROM
  29:main.c        ****  *  writes not to block usb interrupts. logic to handle 2 second timeout then
  30:main.c        ****  *  jump to user code.
  31:main.c        ****  *
  32:main.c        ****  */
  33:main.c        **** #include <stdio.h>
  34:main.c        **** #include <stdint.h>
  35:main.c        **** #include <string.h>
  36:main.c        **** #include <limits.h>
  37:main.c        **** #include <unistd.h>
  38:main.c        **** #include <errno.h>
  39:main.c        **** #include <stdarg.h>
  40:main.c        **** 
  41:main.c        **** #include "common.h"
  42:main.c        **** #include "dfu.h"
  43:main.c        **** #include "image.h"
  44:main.c        **** #include "sha256.h"
  45:main.c        **** #include "cencode.h"
  46:main.c        **** #include "cdecode.h"
  47:main.c        **** /*
  48:main.c        **** 	Base64 functions
  49:main.c        **** */
  50:main.c        **** size_t decode_b64(const char* input, char* output)
  51:main.c        **** {
  27              		.loc 1 51 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 8
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 37B5     		push	{r0, r1, r2, r4, r5, lr}
  33              		.cfi_def_cfa_offset 24
  34              		.cfi_offset 0, -24
  35              		.cfi_offset 1, -20
  36              		.cfi_offset 2, -16
  37              		.cfi_offset 4, -12
  38              		.cfi_offset 5, -8
  39              		.cfi_offset 14, -4
  40              		.loc 1 51 0
  41 0002 0546     		mov	r5, r0
  52:main.c        ****     base64_decodestate s;
  53:main.c        ****     size_t cnt;
  54:main.c        **** 
  55:main.c        ****     base64_init_decodestate(&s);
  42              		.loc 1 55 0
  43 0004 01A8     		add	r0, sp, #4
  44              	.LVL1:
  51:main.c        **** {
  45              		.loc 1 51 0
  46 0006 0C46     		mov	r4, r1
  47              		.loc 1 55 0
  48 0008 FFF7FEFF 		bl	base64_init_decodestate
  49              	.LVL2:
  56:main.c        ****     cnt = base64_decode_block(input, strlen(input), output, &s);
  50              		.loc 1 56 0
  51 000c 2846     		mov	r0, r5
  52 000e FFF7FEFF 		bl	strlen
  53              	.LVL3:
  54 0012 2246     		mov	r2, r4
  55 0014 0146     		mov	r1, r0
  56 0016 01AB     		add	r3, sp, #4
  57 0018 2846     		mov	r0, r5
  58 001a FFF7FEFF 		bl	base64_decode_block
  59              	.LVL4:
  57:main.c        ****     output[cnt] = 0;
  60              		.loc 1 57 0
  61 001e 0022     		movs	r2, #0
  62 0020 2254     		strb	r2, [r4, r0]
  58:main.c        **** 
  59:main.c        ****     return cnt;
  60:main.c        **** }
  63              		.loc 1 60 0
  64 0022 03B0     		add	sp, sp, #12
  65              		@ sp needed
  66 0024 30BD     		pop	{r4, r5, pc}
  67              		.cfi_endproc
  68              	.LFE0:
  70              		.section	.text.encode_b64,"ax",%progbits
  71              		.align	1
  72              		.global	encode_b64
  73              		.thumb
  74              		.thumb_func
  76              	encode_b64:
  77              	.LFB1:
  61:main.c        **** 
  62:main.c        **** size_t encode_b64(const char* input, char* output, int blocksize)
  63:main.c        **** {
  78              		.loc 1 63 0
  79              		.cfi_startproc
  80              		@ args = 0, pretend = 0, frame = 8
  81              		@ frame_needed = 0, uses_anonymous_args = 0
  82              	.LVL5:
  83 0000 73B5     		push	{r0, r1, r4, r5, r6, lr}
  84              		.cfi_def_cfa_offset 24
  85              		.cfi_offset 0, -24
  86              		.cfi_offset 1, -20
  87              		.cfi_offset 4, -16
  88              		.cfi_offset 5, -12
  89              		.cfi_offset 6, -8
  90              		.cfi_offset 14, -4
  91              		.loc 1 63 0
  92 0002 0C46     		mov	r4, r1
  93 0004 1646     		mov	r6, r2
  94 0006 0546     		mov	r5, r0
  64:main.c        ****     base64_encodestate s;
  65:main.c        ****     size_t cnt;
  66:main.c        **** 
  67:main.c        ****     base64_init_encodestate(&s);
  95              		.loc 1 67 0
  96 0008 6846     		mov	r0, sp
  97              	.LVL6:
  98 000a FFF7FEFF 		bl	base64_init_encodestate
  99              	.LVL7:
  68:main.c        ****     cnt = base64_encode_block(input, blocksize, output, &s);
 100              		.loc 1 68 0
 101 000e 6B46     		mov	r3, sp
 102 0010 3146     		mov	r1, r6
 103 0012 2246     		mov	r2, r4
 104 0014 2846     		mov	r0, r5
 105 0016 FFF7FEFF 		bl	base64_encode_block
 106              	.LVL8:
  69:main.c        ****     cnt += base64_encode_blockend(output + cnt, &s);
 107              		.loc 1 69 0
 108 001a 6946     		mov	r1, sp
  68:main.c        ****     cnt = base64_encode_block(input, blocksize, output, &s);
 109              		.loc 1 68 0
 110 001c 0546     		mov	r5, r0
 111              	.LVL9:
 112              		.loc 1 69 0
 113 001e 2018     		adds	r0, r4, r0
 114              	.LVL10:
 115 0020 FFF7FEFF 		bl	base64_encode_blockend
 116              	.LVL11:
  70:main.c        ****     output[cnt] = 0;
 117              		.loc 1 70 0
 118 0024 0023     		movs	r3, #0
  69:main.c        ****     cnt += base64_encode_blockend(output + cnt, &s);
 119              		.loc 1 69 0
 120 0026 2844     		add	r0, r0, r5
 121              	.LVL12:
 122              		.loc 1 70 0
 123 0028 2354     		strb	r3, [r4, r0]
  71:main.c        **** 
  72:main.c        ****     return cnt;
  73:main.c        **** }
 124              		.loc 1 73 0
 125 002a 02B0     		add	sp, sp, #8
 126              		@ sp needed
 127 002c 70BD     		pop	{r4, r5, r6, pc}
 128              		.cfi_endproc
 129              	.LFE1:
 131              		.section	.text.transmit_publickey_data,"ax",%progbits
 132              		.align	1
 133              		.global	transmit_publickey_data
 134              		.thumb
 135              		.thumb_func
 137              	transmit_publickey_data:
 138              	.LFB2:
  74:main.c        **** 
  75:main.c        **** /*
  76:main.c        ****   Print the device's public key + signature (ed25519 between the device and the root ca)
  77:main.c        ****   the device is probably in DFU when this is needed -- the restore tool should use this to request 
  78:main.c        **** */
  79:main.c        **** void transmit_publickey_data() {
 139              		.loc 1 79 0
 140              		.cfi_startproc
 141              		@ args = 0, pretend = 0, frame = 784
 142              		@ frame_needed = 0, uses_anonymous_args = 0
 143 0000 10B5     		push	{r4, lr}
 144              		.cfi_def_cfa_offset 8
 145              		.cfi_offset 4, -8
 146              		.cfi_offset 14, -4
 147 0002 ADF5467D 		sub	sp, sp, #792
 148              		.cfi_def_cfa_offset 800
  80:main.c        ****   struct u_id id;
  81:main.c        ****   unsigned char uniqueID[0x17];
  82:main.c        ****   unsigned char sha256sum[0x20];  
  83:main.c        ****   char signature[EDSIGN_SIGNATURE_SIZE];
  84:main.c        ****   char publickey[EDSIGN_PUBLIC_KEY_SIZE];
  85:main.c        ****   char base64_pub[256];
  86:main.c        ****   char base64_signature[256];
  87:main.c        **** 
  88:main.c        ****   // read our unique id
  89:main.c        ****   uid_read(&id);
 149              		.loc 1 89 0
 150 0006 03A8     		add	r0, sp, #12
 151 0008 FFF7FEFF 		bl	uid_read
 152              	.LVL13:
  90:main.c        ****   sprintf(uniqueID,"%X%X%X%X", id.off0, id.off2, id.off4, id.off8);
 153              		.loc 1 90 0
 154 000c 0499     		ldr	r1, [sp, #16]
 155 000e BDF80E30 		ldrh	r3, [sp, #14]
 156 0012 0091     		str	r1, [sp]
 157 0014 0599     		ldr	r1, [sp, #20]
 158 0016 BDF80C20 		ldrh	r2, [sp, #12]
 159 001a 0191     		str	r1, [sp, #4]
 160 001c 06A8     		add	r0, sp, #24
 161 001e 2049     		ldr	r1, .L4
 162 0020 FFF7FEFF 		bl	sprintf
 163              	.LVL14:
  91:main.c        ****   // start sha256 context
  92:main.c        ****   sha256_context ctx;
  93:main.c        ****   sha256_starts(&ctx);
 164              		.loc 1 93 0
 165 0024 2CA8     		add	r0, sp, #176
 166 0026 FFF7FEFF 		bl	sha256_starts
 167              	.LVL15:
  94:main.c        ****   // hash in our unique id
  95:main.c        ****   sha256_update(&ctx, uniqueID, 0x17);
 168              		.loc 1 95 0
 169 002a 2CA8     		add	r0, sp, #176
 170 002c 06A9     		add	r1, sp, #24
 171 002e 1722     		movs	r2, #23
 172 0030 FFF7FEFF 		bl	sha256_update
 173              	.LVL16:
  96:main.c        ****   sha256_finish(&ctx, sha256sum);
  97:main.c        ****   // get our public key
  98:main.c        ****   memset(publickey, 0, EDSIGN_PUBLIC_KEY_SIZE);
 174              		.loc 1 98 0
 175 0034 2024     		movs	r4, #32
  96:main.c        ****   sha256_finish(&ctx, sha256sum);
 176              		.loc 1 96 0
 177 0036 2CA8     		add	r0, sp, #176
 178 0038 0CA9     		add	r1, sp, #48
 179 003a FFF7FEFF 		bl	sha256_finish
 180              	.LVL17:
 181              		.loc 1 98 0
 182 003e 2246     		mov	r2, r4
 183 0040 14A8     		add	r0, sp, #80
 184 0042 0021     		movs	r1, #0
 185 0044 FFF7FEFF 		bl	memset
 186              	.LVL18:
  99:main.c        ****   edsign_sec_to_pub((unsigned char*)publickey, sha256sum);
 187              		.loc 1 99 0
 188 0048 14A8     		add	r0, sp, #80
 189 004a 0CA9     		add	r1, sp, #48
 190 004c FFF7FEFF 		bl	edsign_sec_to_pub
 191              	.LVL19:
 100:main.c        ****   encode_b64(publickey, base64_pub, 0x20);
 192              		.loc 1 100 0
 193 0050 46A9     		add	r1, sp, #280
 194 0052 2246     		mov	r2, r4
 195 0054 14A8     		add	r0, sp, #80
 196 0056 FFF7FEFF 		bl	encode_b64
 197              	.LVL20:
 101:main.c        **** 
 102:main.c        ****   memset(signature, 0, EDSIGN_SIGNATURE_SIZE);
 198              		.loc 1 102 0
 199 005a 1CA8     		add	r0, sp, #112
 200 005c 0021     		movs	r1, #0
 201 005e 4022     		movs	r2, #64
 202 0060 FFF7FEFF 		bl	memset
 203              	.LVL21:
 103:main.c        ****   // sign the pub
 104:main.c        ****   edsign_sign((uint8_t*)signature, rootCA, sha256sum, (uint8_t*)publickey, EDSIGN_PUBLIC_KEY_SIZE);
 204              		.loc 1 104 0
 205 0064 14AB     		add	r3, sp, #80
 206 0066 1CA8     		add	r0, sp, #112
 207 0068 0CAA     		add	r2, sp, #48
 208 006a 0094     		str	r4, [sp]
 209 006c 0D49     		ldr	r1, .L4+4
 210 006e FFF7FEFF 		bl	edsign_sign
 211              	.LVL22:
 105:main.c        ****   
 106:main.c        ****   encode_b64(signature, base64_signature, 0x64);
 212              		.loc 1 106 0
 213 0072 6422     		movs	r2, #100
 214 0074 86A9     		add	r1, sp, #536
 215 0076 1CA8     		add	r0, sp, #112
 216 0078 FFF7FEFF 		bl	encode_b64
 217              	.LVL23:
 107:main.c        **** 
 108:main.c        ****   debug_print("[BEGIN_PUB_DATA][BEGIN_PUB]%s[END_PUB][END_PUB_DATA]", base64_pub);
 218              		.loc 1 108 0
 219 007c 46A9     		add	r1, sp, #280
 220 007e 0A48     		ldr	r0, .L4+8
 221 0080 FFF7FEFF 		bl	uart_printf
 222              	.LVL24:
 109:main.c        ****   debug_print("[BEGIN_SIGNATURE_DATA][BEGIN_SIGNATURE]");
 223              		.loc 1 109 0
 224 0084 0948     		ldr	r0, .L4+12
 225 0086 FFF7FEFF 		bl	uart_printf
 226              	.LVL25:
 110:main.c        ****   debug_print("%s", base64_signature);
 227              		.loc 1 110 0
 228 008a 86A9     		add	r1, sp, #536
 229 008c 0848     		ldr	r0, .L4+16
 230 008e FFF7FEFF 		bl	uart_printf
 231              	.LVL26:
 111:main.c        ****   debug_print("[END_SIGNATURE][END_SIGNATURE_DATA]");
 232              		.loc 1 111 0
 233 0092 0848     		ldr	r0, .L4+20
 234 0094 FFF7FEFF 		bl	uart_printf
 235              	.LVL27:
 112:main.c        **** }
 236              		.loc 1 112 0
 237 0098 0DF5467D 		add	sp, sp, #792
 238              		@ sp needed
 239 009c 10BD     		pop	{r4, pc}
 240              	.L5:
 241 009e 00BF     		.align	2
 242              	.L4:
 243 00a0 00000000 		.word	.LC0
 244 00a4 00000000 		.word	rootCA
 245 00a8 09000000 		.word	.LC1
 246 00ac 3E000000 		.word	.LC2
 247 00b0 66000000 		.word	.LC3
 248 00b4 69000000 		.word	.LC4
 249              		.cfi_endproc
 250              	.LFE2:
 252              		.section	.text.startup.main,"ax",%progbits
 253              		.align	1
 254              		.global	main
 255              		.thumb
 256              		.thumb_func
 258              	main:
 259              	.LFB3:
 113:main.c        **** 
 114:main.c        **** /*
 115:main.c        **** 	Bootloader main
 116:main.c        **** */
 117:main.c        **** int main() 
 118:main.c        **** {
 260              		.loc 1 118 0
 261              		.cfi_startproc
 262              		@ args = 0, pretend = 0, frame = 8
 263              		@ frame_needed = 0, uses_anonymous_args = 0
 264              	.LVL28:
 265 0000 30B5     		push	{r4, r5, lr}
 266              		.cfi_def_cfa_offset 12
 267              		.cfi_offset 4, -12
 268              		.cfi_offset 5, -8
 269              		.cfi_offset 14, -4
 270 0002 85B0     		sub	sp, sp, #20
 271              		.cfi_def_cfa_offset 32
 119:main.c        **** 	bool no_user_jump = FALSE;
 120:main.c        **** 
 121:main.c        **** 	// low level hardware init	
 122:main.c        ****     systemReset(); // peripherals but not PC
 272              		.loc 1 122 0
 273 0004 FFF7FEFF 		bl	systemReset
 274              	.LVL29:
 123:main.c        ****     setupCLK();
 275              		.loc 1 123 0
 276 0008 FFF7FEFF 		bl	setupCLK
 277              	.LVL30:
 124:main.c        ****     setupLEDAndButton();
 278              		.loc 1 124 0
 279 000c FFF7FEFF 		bl	setupLEDAndButton
 280              	.LVL31:
 125:main.c        ****     setupFLASH();
 281              		.loc 1 125 0
 282 0010 FFF7FEFF 		bl	setupFLASH
 283              	.LVL32:
 126:main.c        ****     uartInit();
 284              		.loc 1 126 0
 285 0014 FFF7FEFF 		bl	uartInit
 286              	.LVL33:
 127:main.c        **** 	setupUSB();
 287              		.loc 1 127 0
 288 0018 FFF7FEFF 		bl	setupUSB
 289              	.LVL34:
 128:main.c        **** 
 129:main.c        **** 	uart_printf("\nBootloader init...\n");
 290              		.loc 1 129 0
 291 001c 2A48     		ldr	r0, .L21
 292 001e FFF7FEFF 		bl	uart_printf
 293              	.LVL35:
 130:main.c        ****     if (readPin(GPIOB, 15) == 0x0) // force dfu
 294              		.loc 1 130 0
 295 0022 0F21     		movs	r1, #15
 296 0024 2948     		ldr	r0, .L21+4
 297 0026 FFF7FEFF 		bl	readPin
 298              	.LVL36:
 299 002a 0446     		mov	r4, r0
 300              	.LVL37:
 131:main.c        **** 	{
 132:main.c        **** 		no_user_jump = TRUE;
 133:main.c        **** 	} 
 134:main.c        **** 
 135:main.c        **** 	// verify chain
 136:main.c        **** 	debug_print("checking chain...\n");
 301              		.loc 1 136 0
 302 002c 2848     		ldr	r0, .L21+8
 303              	.LVL38:
 304 002e FFF7FEFF 		bl	uart_printf
 305              	.LVL39:
 137:main.c        **** 	ImageObjectHandle imageHandle;
 138:main.c        ****     int ret = imageCheckFromAddress(&imageHandle, USER_CODE_FLASH0X8008000, 0);
 306              		.loc 1 138 0
 307 0032 2849     		ldr	r1, .L21+12
 308 0034 0022     		movs	r2, #0
 309 0036 03A8     		add	r0, sp, #12
 310 0038 FFF7FEFF 		bl	imageCheckFromAddress
 311              	.LVL40:
 312 003c 0546     		mov	r5, r0
 313              	.LVL41:
 139:main.c        ****     debug_print("image check ret: %X\n", ret);
 314              		.loc 1 139 0
 315 003e 2946     		mov	r1, r5
 316 0040 2548     		ldr	r0, .L21+16
 317              	.LVL42:
 140:main.c        **** 	switch (ret) // if anything fails to verify we need to kick ourselves into the DFU loop
 318              		.loc 1 140 0
 319 0042 023D     		subs	r5, r5, #2
 139:main.c        ****     debug_print("image check ret: %X\n", ret);
 320              		.loc 1 139 0
 321 0044 FFF7FEFF 		bl	uart_printf
 322              	.LVL43:
 323              		.loc 1 140 0
 324 0048 032D     		cmp	r5, #3
 325 004a 03D8     		bhi	.L7
 326 004c DFE805F0 		tbb	[pc, r5]
 327              	.L9:
 328 0050 10       		.byte	(.L8-.L9)/2
 329 0051 07       		.byte	(.L10-.L9)/2
 330 0052 0C       		.byte	(.L11-.L9)/2
 331 0053 12       		.byte	(.L12-.L9)/2
 332              		.p2align 1
 333              	.L7:
 132:main.c        **** 		no_user_jump = TRUE;
 334              		.loc 1 132 0
 335 0054 D4F10104 		rsbs	r4, r4, #1
 336              	.LVL44:
 337 0058 38BF     		it	cc
 338 005a 0024     		movcc	r4, #0
 339 005c 0EE0     		b	.L13
 340              	.LVL45:
 341              	.L10:
 141:main.c        **** 	{
 142:main.c        **** 		case kImageImageIsTrusted:
 143:main.c        **** 			debug_print("Boot OK\n");
 342              		.loc 1 143 0 discriminator 1
 343 005e 1F48     		ldr	r0, .L21+20
 344 0060 FFF7FEFF 		bl	uart_printf
 345              	.LVL46:
 144:main.c        **** 			no_user_jump = FALSE;
 346              		.loc 1 144 0 discriminator 1
 347 0064 0024     		movs	r4, #0
 145:main.c        **** 			break;
 348              		.loc 1 145 0 discriminator 1
 349 0066 09E0     		b	.L13
 350              	.LVL47:
 351              	.L11:
 146:main.c        **** 
 147:main.c        **** 		case kImageImageMissingMagic:
 148:main.c        **** 			transmit_publickey_data();
 352              		.loc 1 148 0
 353 0068 FFF7FEFF 		bl	transmit_publickey_data
 354              	.LVL48:
 149:main.c        **** 			debug_print("\nFirmware missing... waiting in DFU\n");
 355              		.loc 1 149 0
 356 006c 1C48     		ldr	r0, .L21+24
 357 006e 02E0     		b	.L19
 358              	.L8:
 150:main.c        **** 			no_user_jump = TRUE;
 151:main.c        **** 			break;
 152:main.c        **** 
 153:main.c        **** 		case kImageImageRejectSignature:
 154:main.c        **** 			debug_print("\nSignature unverified... waiting in DFU\n");
 359              		.loc 1 154 0 discriminator 1
 360 0070 1C48     		ldr	r0, .L21+28
 361 0072 00E0     		b	.L19
 362              	.L12:
 155:main.c        **** 			no_user_jump = TRUE;
 156:main.c        **** 			break;
 157:main.c        **** 
 158:main.c        **** 		case kImageImageHashCalcFailed:
 159:main.c        **** 			debug_print("\nHash calculation failed... waiting in DFU\n");
 363              		.loc 1 159 0 discriminator 1
 364 0074 1C48     		ldr	r0, .L21+32
 365              	.L19:
 366 0076 FFF7FEFF 		bl	uart_printf
 367              	.LVL49:
 160:main.c        **** 			no_user_jump = TRUE;
 368              		.loc 1 160 0 discriminator 1
 369 007a 0124     		movs	r4, #1
 370              	.LVL50:
 371              	.L13:
 161:main.c        **** 			break;
 162:main.c        **** 			
 163:main.c        **** 		default:
 164:main.c        **** 			break;
 165:main.c        **** 	}
 166:main.c        **** 
 167:main.c        **** 	strobePin(LED_BANK, LED_PIN, 5, BLINK_FAST,LED_ON_STATE);
 372              		.loc 1 167 0
 373 007c 0023     		movs	r3, #0
 374 007e 0093     		str	r3, [sp]
 375 0080 1A48     		ldr	r0, .L21+36
 376 0082 0D21     		movs	r1, #13
 377 0084 0522     		movs	r2, #5
 378 0086 4FF4A023 		mov	r3, #327680
 379 008a FFF7FEFF 		bl	strobePin
 380              	.LVL51:
 168:main.c        **** 	while (no_user_jump)
 381              		.loc 1 168 0
 382 008e 94B1     		cbz	r4, .L14
 383              	.L16:
 169:main.c        **** 	{
 170:main.c        **** 		// we're spinning in DFU waiting for an upload...
 171:main.c        **** 		strobePin(LED_BANK, LED_PIN, 1, BLINK_SLOW,LED_ON_STATE);
 384              		.loc 1 171 0
 385 0090 0023     		movs	r3, #0
 386 0092 0093     		str	r3, [sp]
 387 0094 1548     		ldr	r0, .L21+36
 388 0096 0D21     		movs	r1, #13
 389 0098 0122     		movs	r2, #1
 390 009a 4FF48013 		mov	r3, #1048576
 391 009e FFF7FEFF 		bl	strobePin
 392              	.LVL52:
 172:main.c        **** 		if (dfuUploadStarted()) 
 393              		.loc 1 172 0
 394 00a2 FFF7FEFF 		bl	dfuUploadStarted
 395              	.LVL53:
 396 00a6 0028     		cmp	r0, #0
 397 00a8 F2D0     		beq	.L16
 173:main.c        **** 		{
 174:main.c        **** 			debug_print("DFU finished upload\n");
 398              		.loc 1 174 0 discriminator 1
 399 00aa 1148     		ldr	r0, .L21+40
 400 00ac FFF7FEFF 		bl	uart_printf
 401              	.LVL54:
 175:main.c        **** 			dfuFinishUpload(); // systemHardReset from DFU once done
 402              		.loc 1 175 0 discriminator 1
 403 00b0 FFF7FEFF 		bl	dfuFinishUpload
 404              	.LVL55:
 405 00b4 ECE7     		b	.L16
 406              	.L14:
 176:main.c        **** 		}
 177:main.c        **** 	}
 178:main.c        **** 
 179:main.c        **** 	// we have the OS verified so lets jump to it. 
 180:main.c        **** 	if (no_user_jump == FALSE)
 181:main.c        **** 	{
 182:main.c        **** 		debug_print("Jumping to OS.\n");
 407              		.loc 1 182 0 discriminator 1
 408 00b6 0F48     		ldr	r0, .L21+44
 409 00b8 FFF7FEFF 		bl	uart_printf
 410              	.LVL56:
 183:main.c        **** 		jumpToUser((USER_CODE_FLASH0X8008000+0x84));	
 411              		.loc 1 183 0 discriminator 1
 412 00bc 0E48     		ldr	r0, .L21+48
 413 00be FFF7FEFF 		bl	jumpToUser
 414              	.LVL57:
 184:main.c        **** 	}
 185:main.c        **** 	
 186:main.c        **** 	return 0;// Added to please the compiler
 187:main.c        **** }...
 415              		.loc 1 187 0 discriminator 1
 416 00c2 2046     		mov	r0, r4
 417 00c4 05B0     		add	sp, sp, #20
 418              		@ sp needed
 419 00c6 30BD     		pop	{r4, r5, pc}
 420              	.LVL58:
 421              	.L22:
 422              		.align	2
 423              	.L21:
 424 00c8 8D000000 		.word	.LC5
 425 00cc 000C0140 		.word	1073810432
 426 00d0 A2000000 		.word	.LC6
 427 00d4 00900008 		.word	134254592
 428 00d8 B5000000 		.word	.LC7
 429 00dc CA000000 		.word	.LC8
 430 00e0 D3000000 		.word	.LC9
 431 00e4 F8000000 		.word	.LC10
 432 00e8 21010000 		.word	.LC11
 433 00ec 00100140 		.word	1073811456
 434 00f0 4D010000 		.word	.LC12
 435 00f4 62010000 		.word	.LC13
 436 00f8 84900008 		.word	134254724
 437              		.cfi_endproc
 438              	.LFE3:
 440              		.comm	rootCA,32,1
 441              		.comm	wTransferSize,4,4
 442              		.section	.rodata.str1.1,"aMS",%progbits,1
 443              	.LC0:
 444 0000 25582558 		.ascii	"%X%X%X%X\000"
 444      25582558 
 444      00
 445              	.LC1:
 446 0009 5B424547 		.ascii	"[BEGIN_PUB_DATA][BEGIN_PUB]%s[END_PUB][END_PUB_DATA"
 446      494E5F50 
 446      55425F44 
 446      4154415D 
 446      5B424547 
 447 003c 5D00     		.ascii	"]\000"
 448              	.LC2:
 449 003e 5B424547 		.ascii	"[BEGIN_SIGNATURE_DATA][BEGIN_SIGNATURE]\000"
 449      494E5F53 
 449      49474E41 
 449      54555245 
 449      5F444154 
 450              	.LC3:
 451 0066 257300   		.ascii	"%s\000"
 452              	.LC4:
 453 0069 5B454E44 		.ascii	"[END_SIGNATURE][END_SIGNATURE_DATA]\000"
 453      5F534947 
 453      4E415455 
 453      52455D5B 
 453      454E445F 
 454              	.LC5:
 455 008d 0A426F6F 		.ascii	"\012Bootloader init...\012\000"
 455      746C6F61 
 455      64657220 
 455      696E6974 
 455      2E2E2E0A 
 456              	.LC6:
 457 00a2 63686563 		.ascii	"checking chain...\012\000"
 457      6B696E67 
 457      20636861 
 457      696E2E2E 
 457      2E0A00
 458              	.LC7:
 459 00b5 696D6167 		.ascii	"image check ret: %X\012\000"
 459      65206368 
 459      65636B20 
 459      7265743A 
 459      2025580A 
 460              	.LC8:
 461 00ca 426F6F74 		.ascii	"Boot OK\012\000"
 461      204F4B0A 
 461      00
 462              	.LC9:
 463 00d3 0A466972 		.ascii	"\012Firmware missing... waiting in DFU\012\000"
 463      6D776172 
 463      65206D69 
 463      7373696E 
 463      672E2E2E 
 464              	.LC10:
 465 00f8 0A536967 		.ascii	"\012Signature unverified... waiting in DFU\012\000"
 465      6E617475 
 465      72652075 
 465      6E766572 
 465      69666965 
 466              	.LC11:
 467 0121 0A486173 		.ascii	"\012Hash calculation failed... waiting in DFU\012\000"
 467      68206361 
 467      6C63756C 
 467      6174696F 
 467      6E206661 
 468              	.LC12:
 469 014d 44465520 		.ascii	"DFU finished upload\012\000"
 469      66696E69 
 469      73686564 
 469      2075706C 
 469      6F61640A 
 470              	.LC13:
 471 0162 4A756D70 		.ascii	"Jumping to OS.\012\000"
 471      696E6720 
 471      746F204F 
 471      532E0A00 
 472              		.text
 473              	.Letext0:
 474              		.file 2 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\lib\\gcc\\arm-none-eabi\\4.8
 475              		.file 3 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\mach
 476              		.file 4 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\stdi
 477              		.file 5 "./stm32_lib/stm32f10x_type.h"
 478              		.file 6 "hardware.h"
 479              		.file 7 "image.h"
 480              		.file 8 "./25519/sha256.h"
 481              		.file 9 "./base64/cencode.h"
 482              		.file 10 "./base64/cdecode.h"
 483              		.file 11 "usb.h"
 484              		.file 12 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\str
 485              		.file 13 "c:\\program files (x86)\\gnu tools arm embedded\\4.8 2014q3\\arm-none-eabi\\include\\std
 486              		.file 14 "./25519/edsign.h"
 487              		.file 15 "dfu.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\haifisch\AppData\Local\Temp\ccIr0ajb.s:19     .text.decode_b64:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccIr0ajb.s:24     .text.decode_b64:00000000 decode_b64
C:\Users\haifisch\AppData\Local\Temp\ccIr0ajb.s:71     .text.encode_b64:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccIr0ajb.s:76     .text.encode_b64:00000000 encode_b64
C:\Users\haifisch\AppData\Local\Temp\ccIr0ajb.s:132    .text.transmit_publickey_data:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccIr0ajb.s:137    .text.transmit_publickey_data:00000000 transmit_publickey_data
C:\Users\haifisch\AppData\Local\Temp\ccIr0ajb.s:243    .text.transmit_publickey_data:000000a0 $d
                            *COM*:00000020 rootCA
C:\Users\haifisch\AppData\Local\Temp\ccIr0ajb.s:253    .text.startup.main:00000000 $t
C:\Users\haifisch\AppData\Local\Temp\ccIr0ajb.s:258    .text.startup.main:00000000 main
C:\Users\haifisch\AppData\Local\Temp\ccIr0ajb.s:328    .text.startup.main:00000050 $d
C:\Users\haifisch\AppData\Local\Temp\ccIr0ajb.s:332    .text.startup.main:00000054 $t
C:\Users\haifisch\AppData\Local\Temp\ccIr0ajb.s:424    .text.startup.main:000000c8 $d
                            *COM*:00000004 wTransferSize
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
base64_init_decodestate
strlen
base64_decode_block
base64_init_encodestate
base64_encode_block
base64_encode_blockend
uid_read
sprintf
sha256_starts
sha256_update
sha256_finish
memset
edsign_sec_to_pub
edsign_sign
uart_printf
systemReset
setupCLK
setupLEDAndButton
setupFLASH
uartInit
setupUSB
readPin
imageCheckFromAddress
strobePin
dfuUploadStarted
dfuFinishUpload
jumpToUser
